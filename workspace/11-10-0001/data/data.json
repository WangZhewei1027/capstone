[
  {
    "id": "75de9740-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:44:48.692Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Set",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Set — Interactive Module (Sets & Operations)</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg:#f6f8fb;\n      --card:#ffffff;\n      --accentA:#4f83ff;\n      --accentB:#ff7a59;\n      --accentResult:#56c596;\n      --text:#0b2140;\n      --muted:#5b6b7a;\n      --token-size:48px;\n      --circle-radius:160px;\n    }\n    *{box-sizing:border-box}\n    html,body{height:100%}\n    body{\n      margin:0;\n      font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;\n      background:var(--bg);\n      color:var(--text);\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      padding:var(--safe-margin);\n    }\n\n    /* Layout */\n    .module{\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      min-height:520px;\n    }\n    /* Responsive: stack on narrow screens */\n    @media (max-width:980px){\n      .module{flex-direction:column}\n    }\n\n    /* Left column (controls + overview) */\n    .col{\n      background:var(--card);\n      border-radius:12px;\n      padding:16px;\n      box-shadow:0 6px 18px rgba(10,25,50,0.06);\n    }\n    .left{\n      flex:0 0 320px;\n      min-width:260px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      padding:20px;\n    }\n    .main{\n      flex:1;\n      display:flex;\n      justify-content:center;\n      align-items:flex-start;\n    }\n    .right{\n      flex:0 0 320px;\n      min-width:260px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      padding:20px;\n    }\n\n    h1{font-size:18px;margin:0 0 8px 0}\n    .muted{color:var(--muted);font-size:13px}\n    .card-title{display:flex;align-items:center;justify-content:space-between;gap:8px}\n\n    /* Input palette */\n    .add-row{display:flex;gap:8px;align-items:center}\n    input[type=\"text\"]{\n      flex:1;\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid #d9e2ef;\n      font-size:14px;\n      outline:none;\n    }\n    .btn{\n      background:linear-gradient(180deg,#ffffff,#eef4ff);\n      border:1px solid #d0ddff;\n      padding:8px 12px;\n      border-radius:8px;\n      font-weight:600;\n      cursor:pointer;\n      color:var(--text);\n      min-width:72px;\n    }\n    .btn:active{transform:translateY(1px)}\n    .small{padding:6px 8px;font-size:13px}\n\n    .instructions{\n      font-size:13px;\n      color:var(--muted);\n      line-height:1.4;\n      padding:10px;\n      background:#fbfdff;\n      border-radius:8px;\n      border:1px solid #eef6ff;\n    }\n\n    /* Venn diagram container */\n    .venn-wrap{\n      position:relative;\n      width:100%;\n      max-width:720px;\n      height:420px;\n      min-height:320px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      padding:18px;\n    }\n    .venn{\n      position:relative;\n      width:100%;\n      height:100%;\n      max-width:680px;\n      max-height:380px;\n      min-width:320px;\n      min-height:260px;\n      margin:auto;\n    }\n    svg.venn-svg{width:100%;height:100%;overflow:visible}\n\n    /* Labels for sets */\n    .set-label{\n      position:absolute;\n      font-weight:700;\n      font-size:14px;\n      color:rgba(255,255,255,0.95);\n      padding:6px 10px;\n      border-radius:20px;\n      display:flex;\n      align-items:center;\n      gap:8px;\n    }\n    .label-A{background:linear-gradient(180deg,var(--accentA),#2d63d6)}\n    .label-B{background:linear-gradient(180deg,var(--accentB),#e65a40)}\n\n    /* Tokens (elements) */\n    .token{\n      position:absolute;\n      width:var(--token-size);\n      height:var(--token-size);\n      border-radius:10px;\n      background:#fff;\n      border:2px solid rgba(8,22,48,0.06);\n      box-shadow:0 6px 16px rgba(8,22,48,0.08);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:700;\n      cursor:grab;\n      user-select:none;\n      transition:transform 300ms cubic-bezier(.2,.9,.2,1), box-shadow 200ms;\n      z-index:3;\n    }\n    .token:active{cursor:grabbing; transform:scale(0.98)}\n    .token.small{width:40px;height:40px;font-size:13px}\n    .token.badgeA{border-color:rgba(79,131,255,0.9)}\n    .token.badgeB{border-color:rgba(255,122,89,0.95)}\n    .token.badgeAB{border-image:linear-gradient(90deg,var(--accentA),var(--accentB)) 1 0 0 0; border-style:solid}\n    .token.outside{opacity:0.88}\n\n    /* Counters */\n    .counters{display:flex;gap:12px;flex-wrap:wrap;font-size:13px;color:var(--muted)}\n    .counter{\n      background:#fbfdff;border:1px solid #eef6ff;padding:8px 10px;border-radius:10px;\n      display:flex;gap:8px;align-items:center;\n    }\n    .counter .dot{width:10px;height:10px;border-radius:50%}\n\n    /* Controls and result area on right */\n    .ops{display:flex;flex-wrap:wrap;gap:10px}\n    .ops .btn{background:#fff;border:1px solid #dfeaf7}\n    .result{\n      margin-top:6px;\n      padding:12px;\n      background:linear-gradient(180deg,#ffffff,#fbfffb);\n      border:1px solid #e8f7ee;\n      border-radius:8px;\n      min-height:72px;\n    }\n    .result .items{display:flex;flex-wrap:wrap;gap:10px;align-items:center}\n    .result .items .token{position:static;transform:none;box-shadow:none;cursor:default}\n\n    /* Anim move layer */\n    .move-layer{\n      position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:60;\n    }\n\n    /* Footer small text sections */\n    .meta{font-size:13px;color:var(--muted);line-height:1.45}\n    .section{background:#fff;padding:12px;border-radius:8px;border:1px solid #eef4ff}\n    .kbd{display:inline-block;padding:4px 6px;border-radius:6px;background:#f3f6fb;border:1px solid #e7eefc;font-weight:600;font-size:13px}\n\n    /* Accessibility focus */\n    .token:focus{outline:3px solid rgba(80,120,245,0.18);box-shadow:0 6px 16px rgba(37,71,251,0.08)}\n    .btn:focus{outline:3px solid rgba(37,71,251,0.12)}\n  </style>\n</head>\n<body>\n  <div class=\"module\" role=\"application\" aria-labelledby=\"title\">\n    <!-- LEFT: Title, objectives, controls -->\n    <aside class=\"col left\" aria-label=\"Module controls and overview\">\n      <div>\n        <div class=\"card-title\">\n          <div>\n            <h1 id=\"title\">Set — Interactive: visualizing set membership & operations</h1>\n            <div class=\"muted\">Explore sets A and B by placing elements, then apply set operations.</div>\n          </div>\n          <div class=\"muted\" style=\"text-align:right;font-size:12px\">Safe margins: 24px</div>\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <strong>Learning objective</strong>\n        <div class=\"muted\" style=\"margin-top:8px\">\n          After interacting you'll be able to:\n          - Visually interpret membership of elements in A, B, and A∩B.\n          - Predict outcomes of union, intersection and differences.\n          - See how operations manipulate element membership.\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <strong>Add elements</strong>\n        <div style=\"margin-top:8px\">\n          <form id=\"addForm\" class=\"add-row\" onsubmit=\"return false;\" aria-label=\"Add element form\">\n            <input id=\"elemInput\" type=\"text\" aria-label=\"Element label\" placeholder=\"Label (e.g. 1 or x)\" maxlength=\"6\"/>\n            <button id=\"addBtn\" class=\"btn\" type=\"button\">Add</button>\n          </form>\n          <div style=\"margin-top:10px\" class=\"muted\">Click token to cycle membership: Outside → A → B → A∩B → Outside. You can also drag tokens into circles. Keyboard: tab to token and press Space to cycle.</div>\n        </div>\n      </div>\n\n      <div class=\"section\" aria-hidden=\"false\">\n        <strong>Interaction design</strong>\n        <div class=\"muted\" style=\"margin-top:8px\">\n          - Drag tokens into circle regions (A or B) to change membership. Release to snap into region. Animation shows membership change.<br>\n          - Click or press Space on a token to cycle its region (accessible alternative to drag).<br>\n          - Use operation buttons (Union, Intersection, A−B, B−A, Symmetric) to animate the result set into the Result area.<br>\n          - Add new labels by typing and pressing Add or Enter.\n        </div>\n      </div>\n    </aside>\n\n    <!-- MAIN: Venn diagram -->\n    <main class=\"col main\" aria-label=\"Interactive venn diagram area\">\n      <div class=\"venn-wrap\" id=\"vennWrap\">\n        <div class=\"venn\" id=\"venn\" tabindex=\"0\" aria-label=\"Venn diagram with two sets A and B\">\n          <svg class=\"venn-svg\" id=\"svg\" viewBox=\"0 0 800 480\" preserveAspectRatio=\"xMidYMid meet\" aria-hidden=\"true\">\n            <!-- Circle A -->\n            <defs>\n              <filter id=\"soft\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\n                <feGaussianBlur stdDeviation=\"10\" />\n              </filter>\n            </defs>\n            <g id=\"circles\" transform=\"translate(40,40)\">\n              <circle id=\"circleA\" cx=\"260\" cy=\"200\" r=\"160\" fill=\"rgba(79,131,255,0.14)\" stroke=\"rgba(79,131,255,0.3)\" stroke-width=\"2\"/>\n              <circle id=\"circleB\" cx=\"420\" cy=\"200\" r=\"160\" fill=\"rgba(255,122,89,0.12)\" stroke=\"rgba(255,122,89,0.28)\" stroke-width=\"2\"/>\n              <!-- subtle intersection highlight -->\n              <path id=\"intersectionPath\" d=\"\" fill=\"rgba(140,160,220,0.12)\" stroke=\"none\"/>\n            </g>\n          </svg>\n\n          <!-- set labels -->\n          <div class=\"set-label label-A\" id=\"labelA\" style=\"left:110px; top:18px;\">A</div>\n          <div class=\"set-label label-B\" id=\"labelB\" style=\"left:470px; top:18px;\">B</div>\n\n          <!-- counters -->\n          <div style=\"position:absolute; left:8px; bottom:12px;\">\n            <div class=\"counters\" role=\"status\" aria-live=\"polite\">\n              <div class=\"counter\"><div class=\"dot\" style=\"background:var(--accentA)\"></div> A: <span id=\"countA\" style=\"margin-left:6px;font-weight:700\">0</span></div>\n              <div class=\"counter\"><div class=\"dot\" style=\"background:var(--accentB)\"></div> B: <span id=\"countB\" style=\"margin-left:6px;font-weight:700\">0</span></div>\n              <div class=\"counter\"><div class=\"dot\" style=\"background:var(--accentResult)\"></div> A∩B: <span id=\"countAB\" style=\"margin-left:6px;font-weight:700\">0</span></div>\n              <div class=\"counter\"><div class=\"dot\" style=\"background:#bfc7d9\"></div> Outside: <span id=\"countOut\" style=\"margin-left:6px;font-weight:700\">0</span></div>\n            </div>\n          </div>\n\n          <!-- tokens will be appended here -->\n          <div id=\"tokensLayer\" style=\"position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:auto\"></div>\n\n          <!-- move layer for animations -->\n          <div class=\"move-layer\" id=\"moveLayer\" aria-hidden=\"true\"></div>\n        </div>\n      </div>\n    </main>\n\n    <!-- RIGHT: operations and result -->\n    <aside class=\"col right\" aria-label=\"Operations and result\">\n      <div class=\"section\">\n        <strong>Set operations</strong>\n        <div class=\"muted\" style=\"margin-top:8px\">Apply an operation to see which elements belong to the resulting set.</div>\n        <div class=\"ops\" style=\"margin-top:12px\">\n          <button class=\"btn small\" data-op=\"union\" id=\"opUnion\">Union (A ∪ B)</button>\n          <button class=\"btn small\" data-op=\"inter\" id=\"opInter\">Intersection (A ∩ B)</button>\n          <button class=\"btn small\" data-op=\"adiff\" id=\"opADiff\">A − B</button>\n          <button class=\"btn small\" data-op=\"bdiff\" id=\"opBDiff\">B − A</button>\n          <button class=\"btn small\" data-op=\"sym\" id=\"opSym\">Symmetric</button>\n          <button class=\"btn small\" id=\"opClear\">Clear Result</button>\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <strong>Result</strong>\n        <div class=\"result\" id=\"resultArea\" aria-live=\"polite\" aria-atomic=\"true\">\n          <div class=\"muted\" style=\"margin-bottom:8px\">Animated result elements:</div>\n          <div class=\"items\" id=\"resultItems\"></div>\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <strong>Quick actions</strong>\n        <div style=\"margin-top:8px;display:flex;gap:8px;flex-wrap:wrap\">\n          <button class=\"btn small\" id=\"randomFill\">Random sample</button>\n          <button class=\"btn small\" id=\"resetAll\">Reset</button>\n        </div>\n        <div class=\"muted\" style=\"margin-top:8px\">Tip: Use Random sample to populate tokens for experimentation.</div>\n      </div>\n\n      <div class=\"meta\" style=\"margin-top:8px\">\n        <strong>Layout description</strong>\n        <div class=\"muted\" style=\"margin-top:6px\">\n          The module uses a three-column responsive layout: left controls & instructions, center Venn diagram workspace, right operations & results. Safe area margin 24px and minimum spacing 16px are enforced. Interactive tokens are reachable by keyboard and screen readers are supported via ARIA attributes.\n        </div>\n      </div>\n    </aside>\n  </div>\n\n  <script>\n    // Self-contained interactive Venn diagram set module\n    (function(){\n      // Constants & DOM refs\n      const venn = document.getElementById('venn');\n      const svg = document.getElementById('svg');\n      const circleA = document.getElementById('circleA');\n      const circleB = document.getElementById('circleB');\n      const tokensLayer = document.getElementById('tokensLayer');\n      const moveLayer = document.getElementById('moveLayer');\n      const resultItems = document.getElementById('resultItems');\n      const countA = document.getElementById('countA');\n      const countB = document.getElementById('countB');\n      const countAB = document.getElementById('countAB');\n      const countOut = document.getElementById('countOut');\n\n      const addForm = document.getElementById('addForm');\n      const elemInput = document.getElementById('elemInput');\n      const addBtn = document.getElementById('addBtn');\n      const opButtons = document.querySelectorAll('[data-op]');\n      const opClear = document.getElementById('opClear');\n      const randomFill = document.getElementById('randomFill');\n      const resetAll = document.getElementById('resetAll');\n\n      // state\n      let tokens = []; // {id, label, el, membership:{inA:bool,inB:bool}}\n      let idCounter = 1;\n\n      // For responsive circle geometry, compute current circle centers & radii in pixels relative to venn\n      function getCircleGeom() {\n        const svgRect = svg.getBoundingClientRect();\n        // circle elements have cx/cy/r from viewBox coords; viewBox offset (0,0) then translate(40,40) used in group\n        // we will read cx,cy,r and transform them using the svg bounding box scale\n        const vb = svg.viewBox.baseVal; // 0 0 800 480\n        const scaleX = svgRect.width / vb.width;\n        const scaleY = svgRect.height / vb.height;\n        // group transform translates by (40,40) -- that was in the markup\n        const groupOffsetX = 40 * scaleX;\n        const groupOffsetY = 40 * scaleY;\n\n        const cxA = parseFloat(circleA.getAttribute('cx')) * scaleX + groupOffsetX + svgRect.left;\n        const cyA = parseFloat(circleA.getAttribute('cy')) * scaleY + groupOffsetY + svgRect.top;\n        const rA  = parseFloat(circleA.getAttribute('r')) * ((scaleX+scaleY)/2);\n\n        const cxB = parseFloat(circleB.getAttribute('cx')) * scaleX + groupOffsetX + svgRect.left;\n        const cyB = parseFloat(circleB.getAttribute('cy')) * scaleY + groupOffsetY + svgRect.top;\n        const rB  = parseFloat(circleB.getAttribute('r')) * ((scaleX+scaleY)/2);\n\n        // Also compute local positions for placing tokens inside the venn container (relative coordinates)\n        const vennRect = venn.getBoundingClientRect();\n        const localA = {\n          cx: cxA - vennRect.left,\n          cy: cyA - vennRect.top,\n          r: rA\n        };\n        const localB = {\n          cx: cxB - vennRect.left,\n          cy: cyB - vennRect.top,\n          r: rB\n        };\n        return {A: localA, B: localB, svgRect, vennRect};\n      }\n\n      // Helper for membership test: whether a point (relative to venn container) is inside circle\n      function pointInCircle(px, py, circle){\n        const dx = px - circle.cx;\n        const dy = py - circle.cy;\n        return (dx*dx + dy*dy) <= (circle.r*circle.r);\n      }\n\n      // Create token element and initial placement (outside)\n      function createToken(label, initialPos){\n        const t = document.createElement('div');\n        const id = 't' + (idCounter++);\n        t.className = 'token outside';\n        t.setAttribute('role','button');\n        t.setAttribute('tabindex','0');\n        t.setAttribute('aria-pressed','false');\n        t.setAttribute('data-id', id);\n        t.textContent = label;\n        // initial position relative to venn\n        const rect = venn.getBoundingClientRect();\n        const x = (initialPos && initialPos.x) || (20 + Math.random()*(rect.width-80));\n        const y = (initialPos && initialPos.y) || (rect.height*0.7 - 24 + Math.random()*40);\n        t.style.left = x + 'px';\n        t.style.top = y + 'px';\n\n        // token state\n        const state = {id, label, el: t, membership:{inA:false,inB:false}};\n\n        // interactions: drag, click/keyboard to cycle\n        makeDraggable(t, state);\n        t.addEventListener('click', (e)=>{ e.preventDefault(); cycleMembership(state); });\n        t.addEventListener('keydown', (e)=>{ if(e.key === ' ' || e.key === 'Enter'){ e.preventDefault(); cycleMembership(state); }});\n\n        tokensLayer.appendChild(t);\n        tokens.push(state);\n        updateVisual(state);\n        updateCounts();\n        return state;\n      }\n\n      // Update token visual classes based on membership\n      function updateVisual(state){\n        const el = state.el;\n        el.classList.remove('badgeA','badgeB','badgeAB','outside');\n        const inA = state.membership.inA;\n        const inB = state.membership.inB;\n        if(inA && inB){ el.classList.add('badgeAB'); el.style.borderColor = ''; }\n        else if(inA){ el.classList.add('badgeA'); }\n        else if(inB){ el.classList.add('badgeB'); }\n        else { el.classList.add('outside'); }\n        el.setAttribute('aria-label', `Element ${state.label}. In A: ${inA ? 'yes' : 'no'}. In B: ${inB ? 'yes' : 'no'}.`);\n      }\n\n      // Cycle membership states: outside -> A -> B -> A∩B -> outside\n      function cycleMembership(state){\n        const s = state.membership;\n        if(!s.inA && !s.inB){ s.inA=true; s.inB=false; }\n        else if(s.inA && !s.inB){ s.inA=false; s.inB=true; }\n        else if(!s.inA && s.inB){ s.inA=true; s.inB=true; }\n        else { s.inA=false; s.inB=false; }\n        // Snap token to appropriate region visually\n        snapTokenToRegion(state);\n        updateVisual(state);\n        updateCounts();\n      }\n\n      // Snap token position to the chosen region (center-ish) with small random offset\n      function snapTokenToRegion(state){\n        const geom = getCircleGeom();\n        const el = state.el;\n        const rect = venn.getBoundingClientRect();\n        let targetX = parseFloat(el.style.left);\n        let targetY = parseFloat(el.style.top);\n        const margin = 16;\n\n        if(state.membership.inA && state.membership.inB){\n          // intersection: midpoint between centers\n          const cx = (geom.A.cx + geom.B.cx)/2;\n          const cy = (geom.A.cy + geom.B.cy)/2;\n          targetX = cx - rect.left + (Math.random()-0.5)*24;\n          targetY = cy - rect.top + (Math.random()-0.5)*24;\n        } else if(state.membership.inA){\n          targetX = geom.A.cx - rect.left + (Math.random()-0.5)*(geom.A.r*0.4);\n          targetY = geom.A.cy - rect.top + (Math.random()-0.5)*(geom.A.r*0.4);\n        } else if(state.membership.inB){\n          targetX = geom.B.cx - rect.left + (Math.random()-0.5)*(geom.B.r*0.4);\n          targetY = geom.B.cy - rect.top + (Math.random()-0.5)*(geom.B.r*0.4);\n        } else {\n          // outside region (bottom-left area)\n          targetX = 12 + (Math.random()*120);\n          targetY = rect.height*0.72 + (Math.random()*24);\n        }\n        // animate move\n        animateMove(el, targetX, targetY);\n      }\n\n      // Simple CSS transform-free animate by transitioning left/top (these are not GPU-accelerated but fine here)\n      function animateMove(el, left, top, duration=240){\n        el.style.transition = `left ${duration}ms cubic-bezier(.2,.9,.2,1), top ${duration}ms cubic-bezier(.2,.9,.2,1)`;\n        requestAnimationFrame(()=>{\n          el.style.left = left + 'px';\n          el.style.top = top + 'px';\n        });\n        setTimeout(()=>{ el.style.transition = ''; }, duration+50);\n      }\n\n      // Update counts display\n      function updateCounts(){\n        let a=0,b=0,ab=0,out=0;\n        tokens.forEach(t=>{\n          const inA = t.membership.inA;\n          const inB = t.membership.inB;\n          if(inA && inB) { ab++; a++; b++; }\n          else if(inA) { a++; }\n          else if(inB) { b++; }\n          else out++;\n        });\n        countA.textContent = a;\n        countB.textContent = b;\n        countAB.textContent = ab;\n        countOut.textContent = out;\n      }\n\n      // Draggable implementation (pointer events)\n      function makeDraggable(el, state){\n        let dragging = false;\n        let startX=0, startY=0, origLeft=0, origTop=0;\n        el.addEventListener('pointerdown', (e)=>{\n          if(e.button !== 0) return;\n          el.setPointerCapture(e.pointerId);\n          dragging = true;\n          startX = e.clientX; startY = e.clientY;\n          origLeft = parseFloat(el.style.left);\n          origTop = parseFloat(el.style.top);\n          el.style.transition = ''; // cancel snap transition\n          el.style.zIndex = 100;\n          el.style.boxShadow = '0 10px 26px rgba(8,22,48,0.12)';\n        });\n        window.addEventListener('pointermove', (e)=>{\n          if(!dragging) return;\n          const dx = e.clientX - startX;\n          const dy = e.clientY - startY;\n          el.style.left = (origLeft + dx) + 'px';\n          el.style.top = (origTop + dy) + 'px';\n        });\n        window.addEventListener('pointerup', (e)=>{\n          if(!dragging) return;\n          dragging=false;\n          el.releasePointerCapture(e.pointerId);\n          el.style.zIndex = '';\n          el.style.boxShadow = '';\n          // determine membership by testing center point\n          const rect = el.getBoundingClientRect();\n          const centerX = rect.left + rect.width/2;\n          const centerY = rect.top + rect.height/2;\n          const geom = getCircleGeom();\n          const inA = pointInCircle(centerX - geom.vennRect.left, centerY - geom.vennRect.top, geom.A);\n          const inB = pointInCircle(centerX - geom.vennRect.left, centerY - geom.vennRect.top, geom.B);\n          state.membership.inA = !!inA;\n          state.membership.inB = !!inB;\n          updateVisual(state);\n          // snap into region slightly to improve look\n          snapTokenToRegion(state);\n          updateCounts();\n        });\n      }\n\n      // Result animation: move copies of elements into result area\n      function showResult(setElements){\n        // clear previous\n        resultItems.innerHTML = '';\n        // for each token in result, create a small duplicate and animate from token to result container\n        const resultRect = resultItems.getBoundingClientRect();\n        setElements.forEach((t, i)=>{\n          const srcRect = t.el.getBoundingClientRect();\n          const clone = t.el.cloneNode(true);\n          clone.style.position='absolute';\n          clone.style.margin='0';\n          clone.style.left = srcRect.left + 'px';\n          clone.style.top  = srcRect.top + 'px';\n          clone.style.width = srcRect.width + 'px';\n          clone.style.height = srcRect.height + 'px';\n          clone.style.transform = 'none';\n          clone.style.transition = 'transform 520ms cubic-bezier(.2,.9,.2,1), left 520ms, top 520ms, opacity 360ms';\n          moveLayer.appendChild(clone);\n\n          // destination position inside result area\n          const destX = resultRect.left + 12 + ((i % 6) * (parseFloat(getComputedStyle(clone).width) + 10));\n          const destY = resultRect.top + 28 + (Math.floor(i/6) * (parseFloat(getComputedStyle(clone).height) + 10));\n\n          // animate using left/top\n          requestAnimationFrame(()=>{\n            clone.style.left = destX + 'px';\n            clone.style.top = destY + 'px';\n            clone.style.opacity = '0.98';\n            clone.style.transform = 'scale(0.92)';\n          });\n\n          // when animation ends, append a static small token into resultItems and remove clone\n          setTimeout(()=>{\n            const small = document.createElement('div');\n            small.className = 'token small';\n            small.textContent = t.label;\n            small.setAttribute('aria-hidden','true');\n            resultItems.appendChild(small);\n            clone.remove();\n          }, 560 + (i*30));\n        });\n      }\n\n      // Compute element sets for operations\n      function computeOperation(op){\n        const selection = [];\n        tokens.forEach(t=>{\n          const a = t.membership.inA;\n          const b = t.membership.inB;\n          let take=false;\n          switch(op){\n            case 'union': take = a || b; break;\n            case 'inter': take = a && b; break;\n            case 'adiff': take = a && !b; break;\n            case 'bdiff': take = b && !a; break;\n            case 'sym': take = (a || b) && !(a && b); break;\n            default: break;\n          }\n          if(take) selection.push(t);\n        });\n        return selection;\n      }\n\n      // Wire up add form\n      addBtn.addEventListener('click', ()=>{\n        const val = elemInput.value.trim();\n        if(!val) return;\n        createToken(val);\n        elemInput.value='';\n        elemInput.focus();\n      });\n      elemInput.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter'){ e.preventDefault(); addBtn.click(); }\n      });\n\n      // Operation buttons\n      opButtons.forEach(btn=>{\n        btn.addEventListener('click', ()=>{\n          const op = btn.dataset.op;\n          const result = computeOperation(op);\n          showResult(result);\n        });\n      });\n      opClear.addEventListener('click', ()=>{ resultItems.innerHTML=''; });\n\n      // Random sample populate\n      randomFill.addEventListener('click', ()=>{\n        // create 7 tokens, random membership\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n        for(let i=0;i<7;i++){\n          const label = chars.charAt(Math.floor(Math.random()*chars.length));\n          const t = createToken(label);\n          t.membership.inA = Math.random()<0.5;\n          t.membership.inB = Math.random()<0.5;\n          updateVisual(t);\n          snapTokenToRegion(t);\n        }\n        updateCounts();\n      });\n\n      // Reset\n      resetAll.addEventListener('click', ()=>{\n        tokens.forEach(t=>{ if(t.el) t.el.remove(); });\n        tokens = [];\n        resultItems.innerHTML = '';\n        updateCounts();\n      });\n\n      // Initialize intersection path (for a subtle highlight)\n      function updateIntersectionPath(){\n        // We'll compute intersection area path using simple circle intersection approximation by SVG arc commands\n        // For visual only, we compute midpoint and draw an ellipse-like shape between intersecting area\n        const vb = svg.viewBox.baseVal;\n        const scaleX = svg.getBoundingClientRect().width / vb.width;\n        const scaleY = svg.getBoundingClientRect().height / vb.height;\n        const groupOffsetX = 40 * scaleX;\n        const groupOffsetY = 40 * scaleY;\n        const cxA = parseFloat(circleA.getAttribute('cx')) * scaleX + groupOffsetX;\n        const cyA = parseFloat(circleA.getAttribute('cy')) * scaleY + groupOffsetY;\n        const rA  = parseFloat(circleA.getAttribute('r')) * ((scaleX+scaleY)/2);\n        const cxB = parseFloat(circleB.getAttribute('cx')) * scaleX + groupOffsetX;\n        const cyB = parseFloat(circleB.getAttribute('cy')) * scaleY + groupOffsetY;\n        const rB  = parseFloat(circleB.getAttribute('r')) * ((scaleX+scaleY)/2);\n\n        // if not intersecting, hide\n        const d = Math.hypot(cxB-cxA, cyB-cyA);\n        const path = document.getElementById('intersectionPath');\n        if(d > rA + rB){ path.setAttribute('d',''); return; }\n        // draw simple ellipse at midpoint sized proportionally\n        const mx = (cxA+cxB)/2;\n        const my = (cyA+cyB)/2;\n        const rx = Math.min(120, Math.max(40, (rA + rB - d)/2 + 20));\n        const ry = Math.min(60, Math.max(24, rx * 0.6));\n        const dstr = `M ${mx-rx} ${my} a ${rx} ${ry} 0 1 0 ${2*rx} 0 a ${rx} ${ry} 0 1 0 ${-2*rx} 0`;\n        path.setAttribute('d', dstr);\n      }\n\n      // Handle resize to recompute geometry & reposition tokens that have membership\n      function onResize(){\n        updateIntersectionPath();\n        tokens.forEach(t=>{\n          // reposition tokens if they are within A/B to snap properly\n          if(t.membership.inA || t.membership.inB) snapTokenToRegion(t);\n        });\n      }\n      window.addEventListener('resize', ()=>{ setTimeout(onResize,60); });\n      window.addEventListener('orientationchange', ()=>{ setTimeout(onResize,120); });\n\n      // Initial sample tokens\n      ['1','2','3','x','y'].forEach(l=>createToken(l));\n      onResize();\n\n      // Expose small debug (optional)\n      window._setModule = { tokens, createToken, computeOperation };\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Set.\n\n**Project Overview:**\nTopic: Set\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Set"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "79a710f0-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:44:55.039Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Queue",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Queue Explorer</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --slot-size: 64px;\n      --slot-gap: 12px;\n      --accent: #2563eb;\n      --accent-2: #06b6d4;\n      --bg: #0f172a;\n      --card: #0b1220;\n      --muted: #94a3b8;\n      --white: #e6eef8;\n      --success: #10b981;\n      --danger: #ef4444;\n    }\n    /* page safe area & base */\n    html,body{height:100%}\n    body{\n      margin:0;\n      padding:var(--safe-margin);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background: linear-gradient(180deg,#071029 0%, #07131c 100%);\n      color:var(--white);\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      box-sizing:border-box;\n    }\n    *{box-sizing:inherit}\n    a{color:inherit}\n\n    /* container layout */\n    .container{\n      max-width:1100px;\n      margin:0 auto;\n    }\n    header{\n      display:flex;\n      align-items:flex-start;\n      gap:var(--gap);\n      margin-bottom:24px;\n    }\n    .title{\n      flex:1 1 auto;\n    }\n    h1{\n      margin:0 0 8px 0;\n      font-size:20px;\n      letter-spacing: -0.2px;\n    }\n    .sub{\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* main module layout */\n    .module{\n      display:grid;\n      grid-template-columns: 1fr 360px;\n      gap:var(--gap);\n      align-items:start;\n    }\n\n    /* responsive fallback */\n    @media (max-width:920px){\n      .module{grid-template-columns: 1fr; }\n    }\n\n    /* left: interactive playground */\n    .playground{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:20px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      min-height:360px;\n    }\n\n    /* info text and controls */\n    .meta{\n      display:flex;\n      gap:var(--gap);\n      flex-wrap:wrap;\n      align-items:center;\n    }\n    .meta .desc{\n      flex:1 1 auto;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* queue visual area */\n    .queue-area{\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      padding:12px;\n      border-radius:10px;\n      background: linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      min-height:180px;\n      position:relative;\n      overflow:visible;\n    }\n    .slots{\n      display:flex;\n      gap:var(--slot-gap);\n      align-items:center;\n      justify-content:center;\n      flex-wrap:wrap;\n      padding:16px;\n    }\n    .slot{\n      width:var(--slot-size);\n      height:var(--slot-size);\n      border-radius:8px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.15));\n      border:1px solid rgba(255,255,255,0.04);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      position:relative;\n      transition: box-shadow .2s, transform .18s;\n      flex: 0 0 var(--slot-size);\n    }\n    .slot.empty{opacity:0.5}\n    .slot-label{\n      position:absolute;\n      bottom:-20px;\n      left:50%;\n      transform:translateX(-50%);\n      font-size:12px;\n      color:var(--muted);\n      pointer-events:none;\n    }\n    .chip{\n      background:linear-gradient(180deg,var(--accent), #1557c9);\n      color:white;\n      padding:8px 10px;\n      border-radius:999px;\n      box-shadow: 0 6px 14px rgba(2,6,23,0.6);\n      font-weight:600;\n      font-size:13px;\n      transform:translateZ(0);\n      transition: transform .3s cubic-bezier(.2,.9,.3,1),opacity .22s;\n      display:inline-block;\n      white-space:nowrap;\n    }\n\n    /* head & tail badges */\n    .pointer{\n      position:absolute;\n      top:-22px;\n      font-size:12px;\n      padding:4px 6px;\n      border-radius:6px;\n      background:rgba(6,182,212,0.12);\n      color:var(--accent-2);\n      border:1px solid rgba(6,182,212,0.14);\n    }\n    .pointer.tail{ background:rgba(37,99,235,0.12); color:var(--accent); border-color:rgba(37,99,235,0.14);}\n\n    /* controls */\n    .controls{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n      margin-top:6px;\n    }\n    .input{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex:1 1 380px;\n      min-width:220px;\n    }\n    input[type=\"text\"]{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      padding:10px 12px;\n      border-radius:8px;\n      color:var(--white);\n      min-width:120px;\n      outline:none;\n      transition:box-shadow .12s, border-color .12s;\n    }\n    input[type=\"text\"]:focus{\n      border-color:rgba(37,99,235,0.9);\n      box-shadow: 0 6px 18px rgba(37,99,235,0.06);\n    }\n    button{\n      background:linear-gradient(180deg,var(--accent), #1557c9);\n      color:white;\n      border:0;\n      border-radius:8px;\n      padding:10px 12px;\n      cursor:pointer;\n      font-weight:600;\n      min-height:44px;\n      transition: transform .12s, box-shadow .12s, opacity .12s;\n    }\n    button.secondary{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--white);\n      font-weight:600;\n    }\n    button.ghost{\n      background:transparent;\n      color:var(--muted);\n      border:0;\n      padding:8px;\n      min-height:auto;\n    }\n    button:active{transform:translateY(1px)}\n    button[disabled], button[aria-disabled=\"true\"]{opacity:0.45; cursor:not-allowed}\n\n    /* status & logs */\n    .status{\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      margin-top:6px;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .badges{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n    }\n    .badge{\n      background:rgba(255,255,255,0.02);\n      padding:6px 8px;\n      border-radius:8px;\n      font-weight:600;\n      font-size:13px;\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.03);\n    }\n\n    .log{\n      margin-top:6px;\n      background:rgba(255,255,255,0.02);\n      border-radius:8px;\n      padding:10px;\n      max-height:120px;\n      overflow:auto;\n      font-size:13px;\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.02);\n    }\n\n    /* right column: explanation & interactive docs */\n    .doc{\n      background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:16px;\n      min-height:360px;\n      color:var(--muted);\n      font-size:14px;\n      line-height:1.45;\n    }\n    .doc h3{\n      margin:0 0 8px 0;\n      color:var(--white);\n      font-size:15px;\n    }\n    .controls-row{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      margin-top:12px;\n      flex-wrap:wrap;\n    }\n\n    /* animations for slot highlight */\n    .slot.pulse{\n      box-shadow:0 8px 26px rgba(37,99,235,0.15);\n      transform:translateY(-6px);\n    }\n    /* ephemeral moving chip (positioned absolute during animation) */\n    .floating{\n      position:fixed;\n      z-index:1000;\n      pointer-events:none;\n      transition: transform .45s cubic-bezier(.2,.9,.3,1), opacity .25s;\n    }\n    /* small helpers for accessibility focus */\n    .sr-only{\n      border:0 !important;\n      clip:rect(1px,1px,1px,1px) !important;\n      -webkit-clip-path: inset(50%) !important;\n      clip-path: inset(50%) !important;\n      height:1px !important;\n      margin:-1px !important;\n      overflow:hidden !important;\n      padding:0 !important;\n      position:absolute !important;\n      width:1px !important;\n      white-space:nowrap !important;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"main\">\n    <header>\n      <div class=\"title\">\n        <h1>Queue — First-In First-Out (FIFO) Interactive Explorer</h1>\n        <p class=\"sub\">Visualize enqueue, dequeue, peek, and observe wrap-around behavior in a bounded queue.</p>\n      </div>\n    </header>\n\n    <div class=\"module\" aria-labelledby=\"module-heading\">\n      <!-- Left: Interactive Playground -->\n      <section class=\"playground\" aria-label=\"Queue interactive playground\">\n        <!-- Concept sections (visible in the UI as required by the design plan) -->\n        <div class=\"meta\" id=\"module-heading\">\n          <div class=\"desc\">\n            <strong>Concept Title:</strong> Queue (FIFO) — linear collection where elements are removed in the order they were added.<br/>\n            <strong>Learning Objective:</strong> After interacting you'll understand enqueue/dequeue operations, how head and tail move, how the queue becomes full/empty, and how indices wrap in a circular buffer.\n          </div>\n          <div style=\"min-width:160px; text-align:right;\">\n            <div style=\"font-size:13px;color:var(--muted)\">Capacity:</div>\n            <div class=\"badges\" aria-hidden=\"true\">\n              <div class=\"badge\" id=\"cap-badge\">8 slots</div>\n            </div>\n          </div>\n        </div>\n\n        <!-- Queue visualization -->\n        <div class=\"queue-area\" id=\"queueArea\" aria-live=\"polite\" aria-atomic=\"true\">\n          <div class=\"slots\" id=\"slots\" role=\"list\" aria-label=\"Queue slots representation\"></div>\n        </div>\n\n        <!-- Controls -->\n        <div class=\"controls\" role=\"toolbar\" aria-label=\"Queue controls\">\n          <div class=\"input\" role=\"group\" aria-label=\"Enqueue input\">\n            <label class=\"sr-only\" for=\"valueInput\">Value to enqueue</label>\n            <input id=\"valueInput\" type=\"text\" placeholder=\"Enter a value (press Enter to enqueue)\" aria-describedby=\"inputHint\" />\n            <div id=\"inputHint\" class=\"sr-only\">Type a short label and press Enter or click Enqueue.</div>\n            <button id=\"enqueueBtn\" title=\"Enqueue (add to tail)\">Enqueue</button>\n            <button id=\"dequeueBtn\" class=\"secondary\" title=\"Dequeue (remove from head)\">Dequeue</button>\n            <button id=\"peekBtn\" class=\"secondary\" title=\"Show head value\">Peek</button>\n          </div>\n\n          <div style=\"display:flex;gap:12px;align-items:center;\">\n            <button id=\"clearBtn\" class=\"ghost\" title=\"Clear all\">Clear</button>\n            <button id=\"fillBtn\" class=\"ghost\" title=\"Fill with sample values\">Fill</button>\n          </div>\n        </div>\n\n        <!-- Status / Logs -->\n        <div class=\"status\" aria-live=\"polite\">\n          <div style=\"display:flex;gap:12px;align-items:center;flex-wrap:wrap;\">\n            <div class=\"badge\">Head: <span id=\"headIndex\">0</span></div>\n            <div class=\"badge\">Tail: <span id=\"tailIndex\">0</span></div>\n            <div class=\"badge\">Size: <span id=\"size\">0</span></div>\n          </div>\n          <div class=\"log\" id=\"log\" aria-live=\"polite\" aria-atomic=\"false\" role=\"log\"></div>\n        </div>\n      </section>\n\n      <!-- Right: Explanation & Interaction Design / Layout Description -->\n      <aside class=\"doc\" aria-label=\"Design explanation\">\n        <h3>Interaction Design</h3>\n        <p>\n          - Enqueue: type a short value and press Enter or click <strong>Enqueue</strong>. The value animates from the input area into the tail slot. If the queue is full, the button disables and you'll see a helpful message. <br/>\n          - Dequeue: click <strong>Dequeue</strong>. The head element lifts and fades out with an animation and the head pointer advances. If empty, the action is disabled. <br/>\n          - Peek: highlight the head element without removing it. <br/>\n          - Fill/Clear: quickly populate or reset the queue for testing.\n        </p>\n\n        <h3>Layout Description</h3>\n        <p>\n          The page uses a two-column layout: the left column is the interactive playground (visualization + controls + live status), while the right column contains concise documentation explaining interactions and layout rationale. Spacing:\n        </p>\n        <ul>\n          <li>Safe area: 24 px padding on all sides of the viewport.</li>\n          <li>Minimum spacing: 16 px gap between interactive elements and layout regions.</li>\n          <li>Controls are grouped and responsive: on narrow screens the right column stacks below the playground.</li>\n        </ul>\n\n        <h3>Accessibility & Keyboard</h3>\n        <p>\n          - Input supports Enter to enqueue. Buttons are keyboard focusable with visible focus outlines. Live status updates (head/tail/size) are accessible to screen readers via aria-live. Buttons are disabled when actions are invalid.\n        </p>\n      </aside>\n    </div>\n  </div>\n\n  <script>\n    /*******************************************\n     * Interactive Queue Module — Vanilla JS\n     *******************************************/\n\n    // Configuration\n    const CAPACITY = 8; // visual slot capacity (bounded queue)\n    const slotsContainer = document.getElementById('slots');\n    const enqueueBtn = document.getElementById('enqueueBtn');\n    const dequeueBtn = document.getElementById('dequeueBtn');\n    const peekBtn = document.getElementById('peekBtn');\n    const clearBtn = document.getElementById('clearBtn');\n    const fillBtn = document.getElementById('fillBtn');\n    const valueInput = document.getElementById('valueInput');\n    const headIndexEl = document.getElementById('headIndex');\n    const tailIndexEl = document.getElementById('tailIndex');\n    const sizeEl = document.getElementById('size');\n    const logEl = document.getElementById('log');\n    const capBadge = document.getElementById('cap-badge');\n    const queueArea = document.getElementById('queueArea');\n\n    capBadge.textContent = CAPACITY + \" slots\";\n\n    // Queue state (circular buffer)\n    const queue = new Array(CAPACITY).fill(null);\n    let head = 0;\n    let tail = 0;\n    let count = 0;\n\n    // Build visual slots\n    for (let i = 0; i < CAPACITY; i++) {\n      const slot = document.createElement('div');\n      slot.className = 'slot empty';\n      slot.setAttribute('role','listitem');\n      slot.setAttribute('data-index', i);\n      slot.innerHTML = '<div class=\"slot-label\">#' + i + '</div>';\n      slotsContainer.appendChild(slot);\n    }\n\n    // Utility to update UI state\n    function refreshStatus(){\n      headIndexEl.textContent = head;\n      tailIndexEl.textContent = tail;\n      sizeEl.textContent = count;\n      // enable/disable controls\n      enqueueBtn.disabled = count >= CAPACITY;\n      dequeueBtn.disabled = count === 0;\n      peekBtn.disabled = count === 0;\n    }\n\n    // Logging helper\n    function log(message, type=\"info\"){\n      const el = document.createElement('div');\n      el.textContent = message;\n      if (type === 'error') el.style.color = 'var(--danger)';\n      else if (type === 'success') el.style.color = 'var(--success)';\n      el.style.padding = '2px 0';\n      logEl.prepend(el);\n      // keep log to a reasonable length\n      while (logEl.children.length > 40) logEl.removeChild(logEl.lastChild);\n    }\n\n    // Create a floating chip element at input position for animation\n    function createFloatingChip(value){\n      const chip = document.createElement('div');\n      chip.className = 'chip floating';\n      chip.textContent = value;\n      document.body.appendChild(chip);\n      return chip;\n    }\n\n    // Get center coordinates of an element (for animation)\n    function centerOf(el){\n      const r = el.getBoundingClientRect();\n      return {x: r.left + (r.width/2), y: r.top + (r.height/2)};\n    }\n\n    // Visualize placing a value in a slot (animated)\n    function animateEnqueue(value, targetIndex){\n      const targetSlot = slotsContainer.querySelector('.slot[data-index=\"'+targetIndex+'\"]');\n      // Create floating from input position\n      const inputRect = valueInput.getBoundingClientRect();\n      const chip = createFloatingChip(value);\n      // place floating chip at input center\n      const start = {x: inputRect.left + inputRect.width/2, y: inputRect.top + inputRect.height/2};\n      chip.style.left = (start.x - chip.offsetWidth/2) + 'px';\n      chip.style.top = (start.y - chip.offsetHeight/2) + 'px';\n      chip.style.opacity = '0.98';\n      // Force layout to apply initial position\n      chip.getBoundingClientRect();\n\n      // compute target center\n      const target = centerOf(targetSlot);\n      // animate by setting transform to move it there\n      const dx = target.x - start.x;\n      const dy = target.y - start.y;\n      chip.style.transform = `translate(${dx}px, ${dy}px) scale(1)`;\n      chip.style.transition = 'transform .45s cubic-bezier(.2,.9,.3,1), opacity .22s';\n\n      // highlight target slot while animating\n      targetSlot.classList.add('pulse');\n      setTimeout(()=>{\n        // after animation completes, put chip into slot DOM and remove floating\n        const placed = document.createElement('div');\n        placed.className = 'chip';\n        placed.textContent = value;\n        // clear slot and append chip\n        targetSlot.querySelectorAll('.chip').forEach(n=>n.remove());\n        targetSlot.appendChild(placed);\n        targetSlot.classList.remove('empty','pulse');\n        // remove floating chip\n        chip.style.opacity = '0';\n        setTimeout(()=>chip.remove(), 180);\n      }, 480);\n    }\n\n    // Visualize dequeuing head (animated)\n    function animateDequeue(fromIndex, callback){\n      const slot = slotsContainer.querySelector('.slot[data-index=\"'+fromIndex+'\"]');\n      const chip = slot.querySelector('.chip');\n      if (!chip){\n        // no chip present — fallback\n        slot.classList.add('pulse');\n        setTimeout(()=>slot.classList.remove('pulse'), 220);\n        callback && callback();\n        return;\n      }\n      // clone to floating, keep original in slot while animating\n      const floating = chip.cloneNode(true);\n      floating.classList.add('floating');\n      const chipPos = centerOf(chip);\n      floating.style.left = (chipPos.x - floating.offsetWidth/2) + 'px';\n      floating.style.top = (chipPos.y - floating.offsetHeight/2) + 'px';\n      document.body.appendChild(floating);\n      // hide chip in slot immediately (gives impression of moving)\n      chip.style.opacity = '0';\n      // animate floating upwards & fade\n      requestAnimationFrame(()=> {\n        floating.style.transform = 'translateY(-60px) scale(.96)';\n        floating.style.opacity = '0';\n      });\n      setTimeout(()=>{\n        // cleanup\n        floating.remove();\n        // remove chip from slot DOM\n        slot.querySelectorAll('.chip').forEach(n=>n.remove());\n        slot.classList.add('empty');\n        callback && callback();\n      }, 420);\n    }\n\n    // Core queue operations (update state + visuals)\n    function enqueue(value){\n      if (!value || count >= CAPACITY) {\n        log('Cannot enqueue — invalid value or queue is full.', 'error');\n        return;\n      }\n      // store in array\n      queue[tail] = value;\n      // animate visual\n      animateEnqueue(value, tail);\n      tail = (tail + 1) % CAPACITY;\n      count++;\n      log('Enqueued \"' + value + '\".');\n      refreshStatus();\n    }\n\n    function dequeue(){\n      if (count === 0) {\n        log('Cannot dequeue — queue is empty.', 'error');\n        return;\n      }\n      const value = queue[head];\n      queue[head] = null;\n      // animate removal then update head\n      animateDequeue(head, () => {\n        head = (head + 1) % CAPACITY;\n        count--;\n        log('Dequeued \"' + value + '\".', 'success');\n        refreshStatus();\n      });\n    }\n\n    function peek(){\n      if (count === 0){\n        log('Queue is empty — nothing to peek.', 'error');\n        return;\n      }\n      const value = queue[head];\n      // flash head slot\n      const slot = slotsContainer.querySelector('.slot[data-index=\"'+head+'\"]');\n      if (slot){\n        slot.classList.add('pulse');\n        setTimeout(()=>slot.classList.remove('pulse'), 420);\n      }\n      log('Peek -> \"' + value + '\".');\n    }\n\n    function clearQueue(){\n      // clear model\n      for (let i=0;i<CAPACITY;i++) queue[i] = null;\n      head = tail = count = 0;\n      // clear visuals\n      slotsContainer.querySelectorAll('.slot').forEach(s=>{\n        s.classList.add('empty');\n        s.querySelectorAll('.chip').forEach(n=>n.remove());\n      });\n      log('Queue cleared.');\n      refreshStatus();\n    }\n\n    function fillSample(){\n      clearQueue();\n      const samples = ['A','B','C','D','E','F','G','H'];\n      // small delay between enqueues to visualize\n      let i = 0;\n      (function step(){\n        if (i >= samples.length) return;\n        enqueue(samples[i]);\n        i++;\n        setTimeout(step, 220);\n      })();\n    }\n\n    // Initialize UI state\n    refreshStatus();\n    log('Interactive Queue ready. Try enqueueing values.');\n\n    // Hook up event listeners\n    enqueueBtn.addEventListener('click', ()=> {\n      const val = valueInput.value.trim();\n      if (!val) {\n        // if empty, create a random sample\n        const generated = Math.random().toString(36).slice(2,6).toUpperCase();\n        valueInput.value = generated;\n      }\n      enqueue(valueInput.value.trim());\n      valueInput.value = '';\n      valueInput.focus();\n    });\n\n    dequeueBtn.addEventListener('click', ()=> dequeue());\n    peekBtn.addEventListener('click', ()=> peek());\n    clearBtn.addEventListener('click', ()=> clearQueue());\n    fillBtn.addEventListener('click', ()=> fillSample());\n\n    // Support Enter key to enqueue, and D to dequeue (accessible)\n    valueInput.addEventListener('keydown', (e)=>{\n      if (e.key === 'Enter'){\n        e.preventDefault();\n        enqueueBtn.click();\n      }\n    });\n    document.addEventListener('keydown', (e)=>{\n      // avoid interfering when typing\n      if (document.activeElement === valueInput) return;\n      if (e.key === 'd' || e.key === 'D') {\n        dequeueBtn.focus();\n        dequeueBtn.click();\n      }\n      if (e.key === 'p' || e.key === 'P') {\n        peekBtn.click();\n      }\n    });\n\n    // Make sure visual slots reflect the model initially (all empty)\n    // Attach resize observer to keep animations accurate if layout changes\n    window.addEventListener('resize', ()=> { /* no-op placeholder for future adaptations */ });\n\n    // For accessibility: announce updates in logs with polite priority\n    // Already using aria-live region on the log/status elements.\n\n    // Expose for debugging in console (optional)\n    window._queueModule = {\n      enqueue, dequeue, peek, clearQueue, fillSample, get state(){\n        return {queue: queue.slice(), head, tail, count};\n      }\n    };\n  </script>\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Queue.\n\n**Project Overview:**\nTopic: Queue\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Queue"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "7a3b88c0-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:44:56.012Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Red-Black Tree",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Red-Black Tree — Insertion & Fix-up</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --muted: #94a3b8;\n      --accent: #60a5fa;\n      --white: #e6eef8;\n      --red: #ef4444;\n      --black: #111827;\n      --node-size: 36px;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071028 0%, #071b2a 100%);\n      color:var(--white);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    /* Safe area */\n    .app {\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height: calc(100vh - calc(var(--safe-margin) * 2));\n      display:flex;\n      gap: var(--gap);\n    }\n\n    /* Left column: info & controls */\n    .panel {\n      min-width: 320px;\n      max-width: 420px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: 12px;\n      padding: 20px;\n      box-sizing: border-box;\n      display:flex;\n      flex-direction:column;\n      gap: 16px;\n      border: 1px solid rgba(255,255,255,0.04);\n    }\n    .title{\n      font-size:20px;\n      font-weight:600;\n      margin:0 0 4px 0;\n      color:var(--white);\n    }\n    .subtitle{\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .section{\n      background: rgba(255,255,255,0.01);\n      border-radius:8px;\n      padding:12px;\n      display:flex;\n      flex-direction:column;\n      gap:10px;\n      box-sizing:border-box;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n\n    label{ font-size:13px; color:var(--muted); }\n    .controls{\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n    input[type=\"number\"]{\n      width:120px;\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.04);\n      background:transparent;\n      color:var(--white);\n      font-size:15px;\n      outline:none;\n    }\n    .btn{\n      padding:8px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.04);\n      background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      color:var(--white);\n      cursor:pointer;\n      font-weight:600;\n      font-size:14px;\n    }\n    .btn:active{ transform:translateY(1px); }\n    .btn.primary{\n      background: linear-gradient(90deg, rgba(96,165,250,0.18), rgba(96,165,250,0.12));\n      border-color: rgba(96,165,250,0.2);\n      color:var(--white);\n    }\n    .btn.ghost{\n      background:transparent;\n      border:1px dashed rgba(255,255,255,0.03);\n      color:var(--muted);\n    }\n\n    .legend{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .legend .badge{\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n    }\n    .node-dot{\n      width:14px;\n      height:14px;\n      border-radius:50%;\n      display:inline-block;\n      border:1px solid rgba(255,255,255,0.06);\n    }\n\n    /* Right: visualization panel */\n    .viz {\n      flex:1 1 0%;\n      min-width:240px;\n      border-radius:12px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));\n      padding:12px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .canvas-wrap{\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);\n      border-radius:8px;\n      padding:12px;\n      box-sizing:border-box;\n      display:flex;\n      gap:12px;\n      min-height:420px;\n      align-items:stretch;\n      justify-content:stretch;\n      position:relative;\n    }\n    /* SVG occupies full area */\n    svg {\n      width:100%;\n      height:100%;\n      overflow:visible;\n    }\n\n    /* Node style */\n    .node {\n      transition: transform 450ms cubic-bezier(.22,.9,.22,1), opacity 250ms ease;\n      transform-origin:center center;\n      cursor:default;\n    }\n    .node circle{\n      r:18;\n      fill:var(--black);\n      stroke: rgba(255,255,255,0.06);\n      stroke-width:2;\n      transition: fill 300ms ease, stroke 200ms ease;\n    }\n    .node .label{\n      font-size:13px;\n      fill:var(--white);\n      text-anchor:middle;\n      dominant-baseline:central;\n      pointer-events:none;\n    }\n    .node.red circle{ fill: var(--red); color:var(--red); }\n    .node.black circle{ fill: var(--black); color:var(--black); }\n\n    .edge{\n      stroke: rgba(255,255,255,0.08);\n      stroke-width:2;\n      fill:none;\n      transition: stroke 300ms ease, opacity 300ms ease;\n    }\n\n    .highlight{\n      filter: drop-shadow(0 6px 18px rgba(96,165,250,0.08));\n      transform: scale(1.08);\n    }\n\n    .log{\n      background: rgba(255,255,255,0.01);\n      border-radius:8px;\n      padding:10px;\n      font-size:13px;\n      color:var(--muted);\n      max-height:160px;\n      overflow:auto;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n\n    .status{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content:space-between;\n    }\n\n    /* Accessibility focus */\n    .btn:focus, input:focus { outline: 3px solid rgba(96,165,250,0.12); outline-offset:2px; }\n\n    /* Responsive */\n    @media (max-width: 900px){\n      .app{ flex-direction:column; }\n      .panel{ max-width:100%; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Red-Black Tree interactive module\">\n    <aside class=\"panel\" aria-labelledby=\"title\">\n      <div>\n        <h1 id=\"title\" class=\"title\">Red-Black Tree — Insertion & Fix-up</h1>\n        <p class=\"subtitle\">Concrete step-through of inserting values and restoring red-black properties</p>\n      </div>\n\n      <div class=\"section\" aria-live=\"polite\">\n        <strong style=\"font-size:14px;\">Learning objective</strong>\n        <p style=\"margin:0;color:var(--muted);font-size:13px;\">\n          After interacting with this module you will understand how a red-black tree inserts a node,\n          why newly inserted nodes are red, and how rotations and recoloring restore the tree's invariants.\n        </p>\n      </div>\n\n      <div class=\"section\" aria-label=\"Interaction design\">\n        <strong style=\"font-size:14px;\">Interaction design</strong>\n        <p style=\"margin:0;color:var(--muted);font-size:13px;\">\n          You can type a number and click Add (or press Enter) to insert. Use Step to advance a recorded\n          fix-up operation, or Auto to animate the full sequence. Watch nodes recolor and move during rotations;\n          explanations appear below the canvas.\n        </p>\n        <div style=\"display:flex;flex-direction:column;gap:12px;\">\n          <label for=\"keyInput\">Insert value (integer)</label>\n          <div class=\"controls\">\n            <input id=\"keyInput\" type=\"number\" aria-label=\"Value to insert\" placeholder=\"e.g. 10\" />\n            <button id=\"addBtn\" class=\"btn primary\" aria-label=\"Add value\">Add</button>\n            <button id=\"stepBtn\" class=\"btn ghost\" aria-label=\"Step\">Step</button>\n            <button id=\"autoBtn\" class=\"btn ghost\" aria-label=\"Auto play\">Auto</button>\n            <button id=\"resetBtn\" class=\"btn\" aria-label=\"Reset tree\">Reset</button>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"section\" aria-label=\"Legend & rules\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n          <strong style=\"font-size:14px;\">Legend & core rule</strong>\n          <div class=\"legend\" aria-hidden=\"true\">\n            <span class=\"badge\"><span class=\"node-dot\" style=\"background:var(--red)\"></span> Red</span>\n            <span class=\"badge\"><span class=\"node-dot\" style=\"background:var(--black)\"></span> Black</span>\n          </div>\n        </div>\n        <p style=\"margin:0;color:var(--muted);font-size:13px;\">\n          Key invariants:\n        </p>\n        <ul style=\"margin:8px 0 0 18px;color:var(--muted);font-size:13px;\">\n          <li>Every node is red or black.</li>\n          <li>Root is always black.</li>\n          <li>No red node has a red child.</li>\n          <li>Every path has the same number of black nodes.</li>\n        </ul>\n      </div>\n\n      <div class=\"section\" aria-label=\"Layout description\">\n        <strong style=\"font-size:14px;\">Layout description</strong>\n        <p style=\"margin:0;color:var(--muted);font-size:13px;\">\n          The UI has a left column for controls and explanations and a right column for the SVG tree.\n          Minimum spacing between interactive elements is 16px, safe margins are 24px.\n          The SVG scales to available space; node labels remain readable and controls are keyboard accessible.\n        </p>\n      </div>\n\n    </aside>\n\n    <main class=\"viz\" aria-live=\"polite\">\n      <div class=\"canvas-wrap\" role=\"region\" aria-label=\"Tree visualization\">\n        <svg id=\"svgCanvas\" viewBox=\"0 0 1000 600\" preserveAspectRatio=\"xMidYMid meet\" tabindex=\"0\">\n          <!-- edges and nodes added dynamically -->\n        </svg>\n      </div>\n\n      <div class=\"status\">\n        <div style=\"display:flex;gap:12px;align-items:center;\">\n          <div style=\"font-size:13px;color:var(--muted);\">Logs</div>\n        </div>\n        <div style=\"font-size:13px;color:var(--muted);\">Use Step / Auto to advance fix-up steps</div>\n      </div>\n\n      <div class=\"log\" id=\"log\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n    </main>\n  </div>\n\n  <script>\n    /********************************************************************\n     * Red-Black Tree Interactive Module\n     * - Vanilla JS implementation\n     * - Step-by-step action queue with animation feedback\n     ********************************************************************/\n\n    // Utility & DOM\n    const svg = document.getElementById('svgCanvas');\n    const keyInput = document.getElementById('keyInput');\n    const addBtn = document.getElementById('addBtn');\n    const stepBtn = document.getElementById('stepBtn');\n    const autoBtn = document.getElementById('autoBtn');\n    const resetBtn = document.getElementById('resetBtn');\n    const logEl = document.getElementById('log');\n\n    // Configuration\n    const nodeRadius = 18;\n    const levelHeight = 90;\n    const minNodeSep = 36; // used to compute horizontal spacing\n    const transitionMs = 450;\n\n    // Tree model\n    let nodeIdCounter = 1;\n    function makeNode(key){\n      return {\n        id: nodeIdCounter++,\n        key: key,\n        color: 'red', // default new node red\n        left: null,\n        right: null,\n        parent: null,\n        x: 0, y: 0, // layout positions\n      };\n    }\n\n    let root = null;\n\n    // Action queue for UI steps\n    let actions = [];\n    let autoPlay = false;\n    let autoTimer = null;\n\n    // Map from node id to SVG group element\n    const nodeElements = new Map();\n    const edgeElements = new Map();\n\n    // Logging utility\n    function log(msg){\n      const line = document.createElement('div');\n      line.textContent = msg;\n      logEl.prepend(line);\n    }\n\n    // Reset UI & data\n    function resetAll(){\n      root = null;\n      actions = [];\n      nodeElements.forEach(el => el.remove());\n      edgeElements.forEach(el => el.remove());\n      nodeElements.clear();\n      edgeElements.clear();\n      nodeIdCounter = 1;\n      logEl.innerHTML = '';\n      log('Tree reset. Insert a value to begin.');\n      stopAuto();\n    }\n\n    // BST insert (returns inserted node)\n    function bstInsert(node){\n      if(!root){\n        root = node;\n        return node;\n      }\n      let cur = root;\n      while(true){\n        if(node.key < cur.key){\n          if(!cur.left){\n            cur.left = node;\n            node.parent = cur;\n            return node;\n          }\n          cur = cur.left;\n        } else if(node.key > cur.key){\n          if(!cur.right){\n            cur.right = node;\n            node.parent = cur;\n            return node;\n          }\n          cur = cur.right;\n        } else {\n          // duplicate - ignore insertion\n          return null;\n        }\n      }\n    }\n\n    // Rotate left at node x\n    function rotateLeft(x){\n      const y = x.right;\n      if(!y) return;\n      x.right = y.left;\n      if(y.left) y.left.parent = x;\n      y.parent = x.parent;\n      if(!x.parent) root = y;\n      else if(x === x.parent.left) x.parent.left = y;\n      else x.parent.right = y;\n      y.left = x;\n      x.parent = y;\n    }\n\n    // Rotate right at node x\n    function rotateRight(x){\n      const y = x.left;\n      if(!y) return;\n      x.left = y.right;\n      if(y.right) y.right.parent = x;\n      y.parent = x.parent;\n      if(!x.parent) root = y;\n      else if(x === x.parent.right) x.parent.right = y;\n      else x.parent.left = y;\n      y.right = x;\n      x.parent = y;\n    }\n\n    // Helper to push action objects\n    // action types: create, highlight, unhighlight, recolor, rotateLeft, rotateRight, setRootBlack, message\n    function pushAction(action){\n      actions.push(action);\n    }\n\n    // Main insertion with fix-up: operations are applied to tree immediately,\n    // and corresponding UI actions are recorded to visualize the steps.\n    function insertAndRecord(key){\n      const node = makeNode(key);\n      const inserted = bstInsert(node);\n      if(!inserted){\n        pushAction({type:'message', text:`Value ${key} already present — ignored.`});\n        return;\n      }\n      // Record create action\n      pushAction({type:'create', nodeId: node.id, text:`Inserted ${key} as red leaf.`});\n\n      // Fix-up\n      let z = node;\n      while(z.parent && z.parent.color === 'red'){\n        const p = z.parent;\n        const g = p.parent;\n        if(!g) break;\n        if(p === g.left){\n          const y = g.right; // uncle\n          if(y && y.color === 'red'){\n            // case 1: recolor parent and uncle black, grandparent red; continue at grandparent\n            p.color = 'black';\n            y.color = 'black';\n            g.color = 'red';\n            pushAction({type:'highlight', nodeId: p.id});\n            pushAction({type:'highlight', nodeId: y.id});\n            pushAction({type:'recolor', nodeId: p.id, color:'black', text:`Parent ${p.key} -> black`});\n            pushAction({type:'recolor', nodeId: y.id, color:'black', text:`Uncle ${y.key} -> black`});\n            pushAction({type:'recolor', nodeId: g.id, color:'red', text:`Grandparent ${g.key} -> red`});\n            pushAction({type:'unhighlight', nodeId: p.id});\n            pushAction({type:'unhighlight', nodeId: y.id});\n            z = g;\n            continue;\n          } else {\n            if(z === p.right){\n              // case 2: left-rotate parent\n              pushAction({type:'highlight', nodeId: p.id});\n              rotateLeft(p);\n              pushAction({type:'rotateLeft', nodeId: p.id, text:`Rotate left at ${p.key}`});\n              pushAction({type:'unhighlight', nodeId: p.id});\n              // after rotation, z becomes p\n              z = p;\n            }\n            // case 3: right-rotate grandparent\n            const p2 = z.parent;\n            const g2 = p2.parent;\n            p2.color = 'black';\n            g2.color = 'red';\n            pushAction({type:'highlight', nodeId: p2.id});\n            pushAction({type:'highlight', nodeId: g2.id});\n            pushAction({type:'recolor', nodeId: p2.id, color:'black', text:`Parent ${p2.key} -> black`});\n            pushAction({type:'recolor', nodeId: g2.id, color:'red', text:`Grandparent ${g2.key} -> red`});\n            rotateRight(g2);\n            pushAction({type:'rotateRight', nodeId: g2.id, text:`Rotate right at ${g2.key}`});\n            pushAction({type:'unhighlight', nodeId: p2.id});\n            pushAction({type:'unhighlight', nodeId: g2.id});\n            break;\n          }\n        } else {\n          // mirror cases: p is right child\n          const y = g.left;\n          if(y && y.color === 'red'){\n            p.color = 'black';\n            y.color = 'black';\n            g.color = 'red';\n            pushAction({type:'highlight', nodeId: p.id});\n            pushAction({type:'highlight', nodeId: y.id});\n            pushAction({type:'recolor', nodeId: p.id, color:'black', text:`Parent ${p.key} -> black`});\n            pushAction({type:'recolor', nodeId: y.id, color:'black', text:`Uncle ${y.key} -> black`});\n            pushAction({type:'recolor', nodeId: g.id, color:'red', text:`Grandparent ${g.key} -> red`});\n            pushAction({type:'unhighlight', nodeId: p.id});\n            pushAction({type:'unhighlight', nodeId: y.id});\n            z = g;\n            continue;\n          } else {\n            if(z === p.left){\n              // case 2 mirror\n              pushAction({type:'highlight', nodeId: p.id});\n              rotateRight(p);\n              pushAction({type:'rotateRight', nodeId: p.id, text:`Rotate right at ${p.key}`});\n              pushAction({type:'unhighlight', nodeId: p.id});\n              z = p;\n            }\n            // case 3 mirror\n            const p2 = z.parent;\n            const g2 = p2.parent;\n            p2.color = 'black';\n            g2.color = 'red';\n            pushAction({type:'highlight', nodeId: p2.id});\n            pushAction({type:'highlight', nodeId: g2.id});\n            pushAction({type:'recolor', nodeId: p2.id, color:'black', text:`Parent ${p2.key} -> black`});\n            pushAction({type:'recolor', nodeId: g2.id, color:'red', text:`Grandparent ${g2.key} -> red`});\n            rotateLeft(g2);\n            pushAction({type:'rotateLeft', nodeId: g2.id, text:`Rotate left at ${g2.key}`});\n            pushAction({type:'unhighlight', nodeId: p2.id});\n            pushAction({type:'unhighlight', nodeId: g2.id});\n            break;\n          }\n        }\n      }\n      // ensure root black\n      if(root.color !== 'black'){\n        root.color = 'black';\n        pushAction({type:'recolor', nodeId: root.id, color:'black', text:`Root ${root.key} -> black`});\n      }\n      pushAction({type:'message', text:`Insertion of ${key} complete.`});\n    }\n\n    // Layout computation: assign x,y to nodes\n    function computeLayout(){\n      const positions = [];\n      let index = 0;\n      function inorder(n, depth){\n        if(!n) return;\n        inorder(n.left, depth+1);\n        positions.push({node:n, idx: index++});\n        inorder(n.right, depth+1);\n      }\n      index = 0;\n      // We need depths to compute y, and in-order index to compute x spacing\n      const depthMap = new Map();\n      function recordDepths(n, d){\n        if(!n) return;\n        depthMap.set(n.id, d);\n        recordDepths(n.left, d+1);\n        recordDepths(n.right, d+1);\n      }\n      recordDepths(root, 0);\n      // Now in-order to set x order\n      const inorderList = [];\n      function inorder2(n){\n        if(!n) return;\n        inorder2(n.left);\n        inorderList.push(n);\n        inorder2(n.right);\n      }\n      inorder2(root);\n      const nCount = Math.max(1, inorderList.length);\n      const width = 1000; // corresponds to SVG viewBox width\n      const margin = 40;\n      const availableW = width - margin*2;\n      const hSpacing = Math.max(minNodeSep + nodeRadius*2, availableW / (nCount + 1));\n      const mappingX = new Map();\n      inorderList.forEach((nd, i) => {\n        mappingX.set(nd.id, margin + (i+1) * hSpacing);\n      });\n      // assign coords\n      function assign(n){\n        if(!n) return;\n        n.x = mappingX.get(n.id) || 50;\n        n.y = (depthMap.get(n.id) || 0) * levelHeight + 60;\n        assign(n.left);\n        assign(n.right);\n      }\n      assign(root);\n    }\n\n    // Rendering: create node SVG group if not exists\n    function createNodeElement(node){\n      if(nodeElements.has(node.id)) return;\n      const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      g.classList.add('node');\n      g.setAttribute('data-id', node.id);\n      g.setAttribute('tabindex','0');\n      g.setAttribute('role','img');\n      g.setAttribute('aria-label', `node ${node.key} ${node.color}`);\n      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n      circle.setAttribute('r', nodeRadius);\n      const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n      text.classList.add('label');\n      text.textContent = node.key;\n      g.appendChild(circle);\n      g.appendChild(text);\n      // initial placement off-screen for effect\n      g.style.transform = `translate(${node.x}px, ${-40}px)`;\n      if(node.color === 'red') g.classList.add('red');\n      else g.classList.add('black');\n      svg.appendChild(g);\n      nodeElements.set(node.id, g);\n\n      // simple click to highlight explanation\n      g.addEventListener('click', () => {\n        const id = node.id;\n        pushAction({type:'highlight', nodeId:id});\n        pushAction({type:'unhighlight', nodeId:id});\n        processNextAction();\n      });\n    }\n\n    // Create edge element for parent-child\n    function createEdgeElement(parent, child){\n      const key = `${parent.id}-${child.id}`;\n      if(edgeElements.has(key)) return;\n      const line = document.createElementNS('http://www.w3.org/2000/svg','path');\n      line.classList.add('edge');\n      line.setAttribute('data-from', parent.id);\n      line.setAttribute('data-to', child.id);\n      svg.insertBefore(line, svg.firstChild); // edges under nodes\n      edgeElements.set(key, line);\n    }\n\n    // Helper to update all node visuals & edges positions\n    function updateAllVisuals(animate=true){\n      computeLayout();\n      // Create elements for nodes that do not have them yet\n      (function traverse(n){\n        if(!n) return;\n        createNodeElement(n);\n        traverse(n.left);\n        traverse(n.right);\n      })(root);\n\n      // create edges\n      edgeElements.forEach((el) => {\n        // we'll remove later if dangling\n        el.setAttribute('data-kept','false');\n      });\n      (function traverse2(n){\n        if(!n) return;\n        if(n.left){\n          createEdgeElement(n, n.left);\n        }\n        if(n.right){\n          createEdgeElement(n, n.right);\n        }\n        traverse2(n.left);\n        traverse2(n.right);\n      })(root);\n\n      // remove edges that are no longer valid\n      edgeElements.forEach((el, key) => {\n        const from = parseInt(el.getAttribute('data-from'));\n        const to = parseInt(el.getAttribute('data-to'));\n        // verify connection still exists\n        const fromNode = findNodeById(root, from);\n        const toNode = findNodeById(root, to);\n        let valid = false;\n        if(fromNode && fromNode.left && fromNode.left.id === to) valid = true;\n        if(fromNode && fromNode.right && fromNode.right.id === to) valid = true;\n        if(!valid){\n          el.remove();\n          edgeElements.delete(key);\n        }\n      });\n\n      // Position nodes (with CSS transform transitions)\n      nodeElements.forEach((g, id) => {\n        const node = findNodeById(root, id);\n        if(!node){\n          // node removed (shouldn't happen in this demo)\n          g.remove();\n          nodeElements.delete(id);\n          return;\n        }\n        const prev = g.__pos || {x: node.x, y: node.y};\n        const tx = node.x;\n        const ty = node.y;\n        g.__pos = {x: tx, y: ty};\n        // update color class & aria label\n        if(node.color === 'red') { g.classList.remove('black'); g.classList.add('red'); }\n        else { g.classList.remove('red'); g.classList.add('black'); }\n        g.setAttribute('aria-label', `node ${node.key} ${node.color}`);\n\n        if(animate){\n          // apply transform with transition in CSS\n          g.style.transition = `transform ${transitionMs}ms cubic-bezier(.22,.9,.22,1), opacity 200ms ease`;\n          g.style.transform = `translate(${tx}px, ${ty}px)`;\n        } else {\n          g.style.transition = 'none';\n          g.style.transform = `translate(${tx}px, ${ty}px)`;\n        }\n      });\n\n      // Update edges paths to connect node centers.\n      // We'll compute endpoints from node positions.\n      edgeElements.forEach((path) => {\n        const from = parseInt(path.getAttribute('data-from'));\n        const to = parseInt(path.getAttribute('data-to'));\n        const fNode = findNodeById(root, from);\n        const tNode = findNodeById(root, to);\n        if(!fNode || !tNode) return;\n        const x1 = fNode.x;\n        const y1 = fNode.y;\n        const x2 = tNode.x;\n        const y2 = tNode.y;\n        // Simple curved path\n        const dx = (x2 - x1) * 0.5;\n        const d = `M ${x1} ${y1+nodeRadius-2} C ${x1+dx} ${y1+20}, ${x2-dx} ${y2-20}, ${x2} ${y2-nodeRadius+2}`;\n        path.setAttribute('d', d);\n      });\n    }\n\n    // Find node by id\n    function findNodeById(n, id){\n      if(!n) return null;\n      if(n.id === id) return n;\n      return findNodeById(n.left, id) || findNodeById(n.right, id);\n    }\n\n    // Process next action in queue\n    function processNextAction(){\n      if(actions.length === 0){\n        log('No actions queued.');\n        stopAuto();\n        return;\n      }\n      const act = actions.shift();\n      switch(act.type){\n        case 'create': {\n          const node = findNodeById(root, act.nodeId);\n          if(node){\n            updateAllVisuals(false);\n            // Ensure node element created and animate it from top\n            const g = nodeElements.get(node.id);\n            if(g){\n              // start slightly above and fade/slide into place\n              g.style.transition = 'none';\n              g.style.transform = `translate(${node.x}px, ${-40}px)`;\n              g.style.opacity = '0';\n              // Force reflow\n              void g.offsetWidth;\n              // then animate\n              setTimeout(()=>{\n                g.style.transition = `transform ${transitionMs}ms cubic-bezier(.22,.9,.22,1), opacity 250ms ease`;\n                g.style.transform = `translate(${node.x}px, ${node.y}px)`;\n                g.style.opacity = '1';\n              }, 20);\n            }\n          }\n          log(act.text || `Inserted ${act.nodeId}`);\n          break;\n        }\n        case 'highlight': {\n          const g = nodeElements.get(act.nodeId);\n          if(g){\n            g.classList.add('highlight');\n          }\n          break;\n        }\n        case 'unhighlight': {\n          const g = nodeElements.get(act.nodeId);\n          if(g){\n            g.classList.remove('highlight');\n          }\n          break;\n        }\n        case 'recolor': {\n          const node = findNodeById(root, act.nodeId);\n          if(node){\n            node.color = act.color;\n            updateAllVisuals(true);\n            log(act.text || `Node ${node.key} -> ${act.color}`);\n          }\n          break;\n        }\n        case 'rotateLeft': {\n          // At this point, tree structure already updated during generation; just animate movement\n          updateAllVisuals(true);\n          log(act.text || `Rotate left`);\n          break;\n        }\n        case 'rotateRight': {\n          updateAllVisuals(true);\n          log(act.text || `Rotate right`);\n          break;\n        }\n        case 'message': {\n          log(act.text || '');\n          break;\n        }\n        default:\n          console.warn('Unknown action', act);\n      }\n    }\n\n    // Auto-play actions sequentially\n    function startAuto(){\n      if(autoPlay) return;\n      autoPlay = true;\n      autoBtn.classList.add('primary');\n      autoBtn.textContent = 'Auto (on)';\n      autoTimer = setInterval(()=>{\n        if(actions.length === 0){\n          stopAuto();\n          return;\n        }\n        processNextAction();\n      }, Math.max(350, transitionMs + 120));\n    }\n    function stopAuto(){\n      autoPlay = false;\n      if(autoTimer) clearInterval(autoTimer);\n      autoTimer = null;\n      autoBtn.classList.remove('primary');\n      autoBtn.textContent = 'Auto';\n    }\n\n    // Event handlers\n    addBtn.addEventListener('click', () => {\n      const val = parseInt(keyInput.value, 10);\n      if(Number.isNaN(val)){\n        log('Please enter an integer to insert.');\n        return;\n      }\n      insertAndRecord(val);\n      // prepare initial visuals for nodes created (but animation begins with actions when processed)\n      updateAllVisuals(false);\n      // Immediately process first action (the create) so user sees the insertion\n      processNextAction();\n      keyInput.value = '';\n      keyInput.focus();\n    });\n\n    stepBtn.addEventListener('click', () => {\n      if(actions.length === 0){\n        log('No more steps.');\n        return;\n      }\n      processNextAction();\n    });\n\n    autoBtn.addEventListener('click', () => {\n      if(autoPlay) stopAuto();\n      else startAuto();\n    });\n\n    resetBtn.addEventListener('click', () => {\n      resetAll();\n    });\n\n    // Keyboard: Enter triggers add\n    keyInput.addEventListener('keydown', (e) => {\n      if(e.key === 'Enter') { addBtn.click(); e.preventDefault(); }\n    });\n\n    // Initialize\n    resetAll();\n\n    // Pre-seed with a few values for demonstration (optional)\n    (function preloadDemo(){\n      const demo = [10, 5, 15, 1, 7, 12, 18];\n      demo.forEach(v => insertAndRecord(v));\n      // Apply all actions quickly to set initial tree\n      while(actions.length) processNextAction();\n      log('Demo tree loaded. Try inserting new values to see fix-up steps.');\n    })();\n\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Red-Black Tree.\n\n**Project Overview:**\nTopic: Red-Black Tree\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Red-Black Tree"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "7bd86fe0-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:44:58.718Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Array",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Array Explorer</title>\n  <style>\n    /* Safe area margins */\n    :root {\n      --safe-margin: 24px;\n      --min-gap: 16px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #38bdf8;\n      --muted: #94a3b8;\n      --card: #071023;\n      --success: #16a34a;\n      --danger: #ef4444;\n      --glass: rgba(255,255,255,0.03);\n      font-family: Inter, ui-sans-serif, system-ui, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n\n    html, body {\n      height: 100%;\n      margin: 0;\n      background: linear-gradient(180deg,#031028 0%, #07102a 100%);\n      color: #e6eef8;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n\n    .app {\n      min-height: 100vh;\n      box-sizing: border-box;\n      padding: var(--safe-margin);\n      display: flex;\n      flex-direction: column;\n      gap: var(--min-gap);\n    }\n\n    /* Header & plan text */\n    .plan {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.04);\n      border-radius: 10px;\n      padding: 18px;\n      display: grid;\n      gap: 12px;\n    }\n    .title {\n      font-size: 20px;\n      font-weight: 600;\n      display: flex;\n      gap: 12px;\n      align-items: baseline;\n    }\n    .subtitle {\n      color: var(--muted);\n      font-size: 13px;\n      margin-top: -4px;\n    }\n    .plan p {\n      margin: 0;\n      color: #cfe8ff;\n      font-size: 14px;\n      line-height: 1.4;\n    }\n    .plan .small {\n      color: var(--muted);\n      font-size: 13px;\n      line-height: 1.4;\n    }\n\n    /* Main interactive panel */\n    .panel {\n      margin-top: 8px;\n      display: grid;\n      grid-template-columns: 1fr 360px;\n      gap: var(--min-gap);\n      align-items: start;\n    }\n\n    /* Ensure responsiveness */\n    @media (max-width: 920px) {\n      .panel {\n        grid-template-columns: 1fr;\n      }\n    }\n\n    /* Visual array area */\n    .visual {\n      background: var(--card);\n      border-radius: 12px;\n      padding: 20px;\n      min-height: 220px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n      display: flex;\n      flex-direction: column;\n      gap: 16px;\n    }\n\n    .visual .info {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      gap: 16px;\n    }\n\n    .visual h2 {\n      margin: 0;\n      font-size: 16px;\n    }\n\n    .status {\n      font-size: 13px;\n      color: var(--muted);\n      display: flex;\n      gap: 12px;\n      align-items: center;\n    }\n\n    .status .badge {\n      background: rgba(255,255,255,0.03);\n      border: 1px solid rgba(255,255,255,0.02);\n      padding: 6px 10px;\n      border-radius: 8px;\n      font-size: 13px;\n      color: #dbefff;\n    }\n\n    /* Array strip */\n    .array-wrap {\n      background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      padding: 18px;\n      border-radius: 10px;\n      overflow-x: auto;\n      min-height: 120px;\n    }\n\n    .array {\n      display: inline-flex;\n      gap: 12px;\n      align-items: flex-end;\n      transition: height 200ms ease;\n      padding-bottom: 6px;\n    }\n\n    .cell {\n      --w: 84px;\n      width: var(--w);\n      min-width: var(--w);\n      height: 84px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: 8px;\n      border: 1px solid rgba(255,255,255,0.03);\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      align-items: center;\n      gap: 6px;\n      box-sizing: border-box;\n      padding: 8px;\n      position: relative;\n      transition: transform 300ms cubic-bezier(.2,.9,.2,1), opacity 240ms ease, box-shadow 220ms ease;\n    }\n\n    .cell .value {\n      font-size: 18px;\n      font-weight: 600;\n      color: #eaf6ff;\n      max-width: 100%;\n      word-break: break-word;\n      text-align: center;\n    }\n\n    .cell .index {\n      font-size: 12px;\n      color: var(--muted);\n      background: rgba(255,255,255,0.01);\n      padding: 4px 8px;\n      border-radius: 6px;\n    }\n\n    .cell.highlight {\n      box-shadow: 0 10px 26px rgba(56,189,248,0.12);\n      border-color: rgba(56,189,248,0.45);\n      transform: translateY(-8px) scale(1.02);\n    }\n\n    .cell.removing {\n      opacity: 0;\n      transform: translateY(18px) scale(.95);\n    }\n\n    .cell.adding {\n      opacity: 0;\n      transform: translateY(-18px) scale(0.98);\n    }\n\n    /* Controls panel */\n    .controls {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: 12px;\n      padding: 16px;\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n    }\n\n    .controls h3 {\n      margin: 0;\n      font-size: 15px;\n      color: #dff6ff;\n    }\n\n    .form-row {\n      display: flex;\n      gap: 12px;\n      flex-wrap: wrap;\n      align-items: center;\n    }\n\n    input[type=\"text\"], input[type=\"number\"] {\n      padding: 10px 12px;\n      border-radius: 8px;\n      border: 1px solid rgba(255,255,255,0.04);\n      background: rgba(255,255,255,0.02);\n      color: #e6eef8;\n      outline: none;\n      min-width: 120px;\n      box-sizing: border-box;\n    }\n    input[type=\"text\"]:focus, input[type=\"number\"]:focus {\n      box-shadow: 0 6px 16px rgba(56,189,248,0.08);\n      border-color: rgba(56,189,248,0.45);\n    }\n\n    .btn {\n      padding: 10px 12px;\n      border-radius: 8px;\n      border: none;\n      cursor: pointer;\n      background: rgba(255,255,255,0.03);\n      color: #dff6ff;\n      font-weight: 600;\n      min-width: 90px;\n      transition: transform 120ms ease, background 140ms ease;\n    }\n\n    .btn:active { transform: translateY(1px); }\n\n    .btn.primary {\n      background: linear-gradient(90deg, rgba(56,189,248,0.12), rgba(56,189,248,0.06));\n      border: 1px solid rgba(56,189,248,0.18);\n      color: #cff8ff;\n    }\n\n    .btn.warn { background: rgba(255,165,0,0.08); color: #ffdca6; border: 1px solid rgba(255,165,0,0.06); }\n\n    .btn.danger { background: rgba(239,68,68,0.06); color: #ffcfcf; border: 1px solid rgba(239,68,68,0.06); }\n\n    .muted {\n      color: var(--muted);\n      font-size: 13px;\n    }\n\n    /* Code / trace box */\n    .trace {\n      background: rgba(255,255,255,0.02);\n      border-radius: 8px;\n      padding: 12px;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", \"Courier New\", monospace;\n      font-size: 13px;\n      color: #d9f6ff;\n      max-height: 200px;\n      overflow: auto;\n      border: 1px solid rgba(255,255,255,0.03);\n    }\n\n    /* Small helpers */\n    .row {\n      display: flex;\n      gap: 12px;\n      align-items: center;\n    }\n\n    .spacer { flex: 1 1 auto; }\n\n    .sr-only {\n      position: absolute;\n      width: 1px;\n      height: 1px;\n      padding: 0;\n      margin: -1px;\n      overflow: hidden;\n      clip: rect(0,0,0,0);\n      white-space: nowrap;\n      border: 0;\n    }\n\n    /* Footer controls */\n    .ops {\n      display: grid;\n      grid-template-columns: 1fr 1fr;\n      gap: 12px;\n    }\n    @media (max-width: 420px) {\n      .ops { grid-template-columns: 1fr; }\n    }\n\n    /* Accessibility focus */\n    button:focus, input:focus {\n      outline: 3px solid rgba(56,189,248,0.14);\n      outline-offset: 2px;\n    }\n\n    /* Tiny responsive tweak for array cell size on narrow screens */\n    @media (max-width: 420px) {\n      .cell { --w: 72px; height: 72px; min-width: 72px; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"main\">\n    <!-- Plan / design explanation -->\n    <section class=\"plan\" aria-labelledby=\"plan-heading\">\n      <div id=\"plan-heading\" class=\"title\">Concept Title: Array (Ordered indexed collection)</div>\n      <div class=\"subtitle\">A compact interactive module to explore how arrays store and manipulate ordered elements.</div>\n\n      <p><strong>Learning Objective:</strong> After interacting with this module, you will be able to visualize an array as an ordered list of indexed slots, perform common operations (push, pop, insert, remove, access, set), and observe how elements shift positions — reinforcing how arrays maintain order and index-based access.</p>\n\n      <p class=\"small\"><strong>Interaction Design:</strong> Use the controls to add, insert, remove, access, or set elements. Each operation updates the visual array and the code-like trace. Animations (smooth shifting of items, highlights for accessed elements, and fade for adding/removing) make the internal changes visible: when inserting, we animate existing cells sliding right; when removing, cells slide left. Clicking a cell highlights it and announces the index and value via accessible text. The trace shows the equivalent JavaScript operation and resulting array content.</p>\n\n      <p class=\"small\"><strong>Layout Description:</strong> The module uses a two-column layout: the left side presents the visual array (top) and activity status (length, last operation), while the right side contains controls and a code trace. There is a 24px safe margin on all sides and a minimum 16px spacing between interactive elements. On narrow screens the layout stacks vertically. Controls are accessible via keyboard and labeled, and there is an ARIA live region announcing changes for screen readers.</p>\n    </section>\n\n    <!-- Interactive module -->\n    <section class=\"panel\" aria-labelledby=\"interactive-heading\">\n      <div class=\"visual\" aria-live=\"polite\">\n        <div class=\"info\">\n          <h2 id=\"interactive-heading\">Array Visualizer</h2>\n          <div class=\"status\" aria-hidden=\"false\">\n            <div class=\"badge\" id=\"lengthBadge\" aria-live=\"polite\">length: 0</div>\n            <div class=\"badge\" id=\"lastOp\" aria-live=\"polite\">idle</div>\n          </div>\n        </div>\n\n        <div class=\"array-wrap\" aria-label=\"Array visualization. Each cell shows value and index. Click a cell to highlight and access it.\">\n          <div id=\"array\" class=\"array\" role=\"list\"></div>\n        </div>\n\n        <div class=\"row\">\n          <div class=\"muted\">Tip: Try inserting at index 0 to see elements shift to the right. Click a cell to access it.</div>\n          <div class=\"spacer\"></div>\n          <div id=\"liveMsg\" class=\"muted\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n        </div>\n      </div>\n\n      <aside class=\"controls\" aria-label=\"Array controls\">\n        <h3>Controls</h3>\n\n        <div class=\"form-row\" role=\"group\" aria-label=\"Add value\">\n          <input id=\"valueInput\" type=\"text\" placeholder=\"value (string or number)\" aria-label=\"Value to insert\" />\n          <button id=\"pushBtn\" class=\"btn primary\" title=\"Push to end\">Push</button>\n          <button id=\"unshiftBtn\" class=\"btn\" title=\"Add to start\">Unshift</button>\n        </div>\n\n        <div class=\"form-row\" role=\"group\" aria-label=\"Remove\">\n          <button id=\"popBtn\" class=\"btn warn\" title=\"Remove last\">Pop</button>\n          <button id=\"shiftBtn\" class=\"btn warn\" title=\"Remove first\">Shift</button>\n          <button id=\"clearBtn\" class=\"btn danger\" title=\"Clear array\">Clear</button>\n        </div>\n\n        <div class=\"form-row\" role=\"group\" aria-label=\"Insert or remove at index\">\n          <input id=\"indexInput\" type=\"number\" min=\"0\" placeholder=\"index\" aria-label=\"Index\" />\n          <button id=\"insertBtn\" class=\"btn primary\" title=\"Insert at index\">Insert @ index</button>\n          <button id=\"removeIndexBtn\" class=\"btn warn\" title=\"Remove at index\">Remove @ index</button>\n        </div>\n\n        <div class=\"form-row\" role=\"group\" aria-label=\"Access and set\">\n          <input id=\"accessIndex\" type=\"number\" min=\"0\" placeholder=\"index to access\" aria-label=\"Index to access\" />\n          <button id=\"accessBtn\" class=\"btn\" title=\"Access index\">Access</button>\n          <input id=\"setValue\" type=\"text\" placeholder=\"new value\" aria-label=\"New value for set\" />\n          <button id=\"setBtn\" class=\"btn primary\" title=\"Set value\">Set</button>\n        </div>\n\n        <div class=\"form-row\" role=\"group\" aria-label=\"Swap or random\">\n          <input id=\"swapA\" type=\"number\" min=\"0\" placeholder=\"i\" aria-label=\"swap index a\" />\n          <input id=\"swapB\" type=\"number\" min=\"0\" placeholder=\"j\" aria-label=\"swap index b\" />\n          <button id=\"swapBtn\" class=\"btn\" title=\"Swap two indices\">Swap</button>\n          <button id=\"randomFillBtn\" class=\"btn\" title=\"Fill with random demo values\">Randomize</button>\n        </div>\n\n        <div class=\"muted\">Keyboard: focus inputs and press Enter to submit when appropriate. All operations update the code trace below.</div>\n\n        <div style=\"margin-top:8px\">\n          <div class=\"trace\" id=\"trace\" aria-live=\"polite\" aria-atomic=\"true\">// Operation trace will appear here</div>\n        </div>\n      </aside>\n    </section>\n  </div>\n\n  <script>\n    // Interactive Array Visualizer (vanilla JS)\n    (function () {\n      // Model\n      let arr = [];\n\n      // Elements\n      const arrayEl = document.getElementById('array');\n      const lengthBadge = document.getElementById('lengthBadge');\n      const lastOp = document.getElementById('lastOp');\n      const liveMsg = document.getElementById('liveMsg');\n      const traceEl = document.getElementById('trace');\n\n      const valueInput = document.getElementById('valueInput');\n      const indexInput = document.getElementById('indexInput');\n      const accessIndex = document.getElementById('accessIndex');\n      const setValue = document.getElementById('setValue');\n\n      // Buttons\n      const pushBtn = document.getElementById('pushBtn');\n      const popBtn = document.getElementById('popBtn');\n      const unshiftBtn = document.getElementById('unshiftBtn');\n      const shiftBtn = document.getElementById('shiftBtn');\n      const insertBtn = document.getElementById('insertBtn');\n      const removeIndexBtn = document.getElementById('removeIndexBtn');\n      const accessBtn = document.getElementById('accessBtn');\n      const setBtn = document.getElementById('setBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const swapBtn = document.getElementById('swapBtn');\n      const swapA = document.getElementById('swapA');\n      const swapB = document.getElementById('swapB');\n      const randomFillBtn = document.getElementById('randomFillBtn');\n\n      // Utility: Accessible announcements\n      function announce(text) {\n        liveMsg.textContent = text;\n      }\n\n      // Trace: append an operation with the resulting array\n      function pushTrace(op, details) {\n        const line = document.createElement('div');\n        const now = new Date();\n        const time = now.toLocaleTimeString();\n        line.textContent = `[${time}] ${op} -> ${JSON.stringify(arr)}` + (details ? `  // ${details}` : '');\n        traceEl.prepend(line);\n      }\n\n      // FLIP animation for smooth shifting\n      function renderArray(animate = true) {\n        // record first positions\n        const beforeRects = new Map();\n        Array.from(arrayEl.children).forEach((child) => {\n          beforeRects.set(child.dataset.key, child.getBoundingClientRect());\n        });\n\n        // Clear and rebuild\n        // We'll reuse keys to detect matching nodes\n        const newNodes = arr.map((v, i) => {\n          const key = `${i}:${String(v)}`;\n          const node = document.createElement('div');\n          node.className = 'cell';\n          node.setAttribute('role', 'listitem');\n          node.dataset.index = i;\n          node.dataset.key = key;\n          node.tabIndex = 0;\n          node.setAttribute('aria-label', `Index ${i}, value ${v}`);\n          // inner\n          const val = document.createElement('div');\n          val.className = 'value';\n          val.textContent = v;\n          const idx = document.createElement('div');\n          idx.className = 'index';\n          idx.textContent = i;\n          node.appendChild(val);\n          node.appendChild(idx);\n\n          // Click to access/highlight\n          node.addEventListener('click', () => {\n            accessAt(i);\n          });\n          node.addEventListener('keydown', (e) => {\n            if (e.key === 'Enter' || e.key === ' ') {\n              e.preventDefault();\n              accessAt(i);\n            }\n            // Allow inline edit with 'e'\n            if (e.key === 'e' || e.key === 'E') {\n              e.preventDefault();\n              const newVal = prompt(`Set value at index ${i}`, String(arr[i]));\n              if (newVal !== null) {\n                setAt(i, parseInputValue(newVal));\n              }\n            }\n          });\n\n          return node;\n        });\n\n        // Patch DOM: simple replace to simplify FLIP mapping by using dataset.key\n        // Save existing nodes by key\n        const existingByKey = new Map();\n        Array.from(arrayEl.children).forEach((child) => {\n          existingByKey.set(child.dataset.key, child);\n        });\n\n        // Build new fragment, reusing nodes if key matches\n        const fragment = document.createDocumentFragment();\n        newNodes.forEach((node) => {\n          const key = node.dataset.key;\n          if (existingByKey.has(key)) {\n            // reuse existing node to preserve DOM element and animate\n            fragment.appendChild(existingByKey.get(key));\n            existingByKey.delete(key);\n          } else {\n            node.classList.add('adding');\n            fragment.appendChild(node);\n          }\n        });\n\n        // Any nodes left in existingByKey were removed; mark them removing\n        existingByKey.forEach((n) => {\n          n.classList.add('removing');\n        });\n\n        // Replace content\n        arrayEl.innerHTML = '';\n        arrayEl.appendChild(fragment);\n\n        // AFTER DOM updated: compute after rects and animate differences\n        requestAnimationFrame(() => {\n          Array.from(arrayEl.children).forEach((child) => {\n            const key = child.dataset.key;\n            const before = beforeRects.get(key);\n            const after = child.getBoundingClientRect();\n            if (before) {\n              const dx = before.left - after.left;\n              const dy = before.top - after.top;\n              if (dx || dy) {\n                child.style.transition = 'none';\n                child.style.transform = `translate(${dx}px, ${dy}px)`;\n                requestAnimationFrame(() => {\n                  child.style.transition = 'transform 320ms cubic-bezier(.2,.9,.2,1), opacity 220ms ease';\n                  child.style.transform = '';\n                });\n              }\n            } else {\n              // New nodes: animate from adding state to normal\n              if (child.classList.contains('adding')) {\n                // force reflow to ensure animation\n                requestAnimationFrame(() => {\n                  child.classList.remove('adding');\n                  child.style.transition = 'transform 320ms cubic-bezier(.2,.9,.2,1), opacity 220ms ease';\n                  child.style.transform = 'translateY(0)';\n                });\n              }\n            }\n\n            // Removing nodes: animate then remove\n            if (child.classList.contains('removing')) {\n              child.style.transition = 'opacity 260ms ease, transform 280ms ease';\n              child.style.opacity = '0';\n              child.style.transform = 'translateY(18px)';\n              setTimeout(() => {\n                if (child.parentElement) child.remove();\n              }, 300);\n            }\n\n            // cleanup inline styles after animation\n            child.addEventListener('transitionend', function cleanup() {\n              child.style.transition = '';\n              child.style.transform = '';\n              child.removeEventListener('transitionend', cleanup);\n            });\n          });\n        });\n\n        // Update badges\n        lengthBadge.textContent = `length: ${arr.length}`;\n      }\n\n      // Parse input: detect number vs string\n      function parseInputValue(raw) {\n        if (raw === '') return '';\n        // Try number\n        if (!isNaN(raw) && raw.trim() !== '') {\n          // preserve leading zero strings? We'll treat numeric if parseFloat works and no trailing letters\n          if (/^-?\\d+(\\.\\d+)?$/.test(raw.trim())) return Number(raw);\n        }\n        // boolean?\n        if (raw.trim().toLowerCase() === 'true') return true;\n        if (raw.trim().toLowerCase() === 'false') return false;\n        return raw;\n      }\n\n      // Operations\n      function pushVal(value) {\n        const v = parseInputValue(String(value));\n        arr.push(v);\n        lastOp.textContent = 'push';\n        announce(`Pushed value ${v} at index ${arr.length - 1}`);\n        pushTrace(`arr.push(${JSON.stringify(v)})`);\n        renderArray();\n      }\n\n      function popVal() {\n        if (arr.length === 0) {\n          announce('Array is empty. Nothing to pop.');\n          lastOp.textContent = 'pop (empty)';\n          pushTrace('arr.pop()  // empty');\n          return;\n        }\n        const removed = arr.pop();\n        lastOp.textContent = 'pop';\n        announce(`Popped value ${removed} from end`);\n        pushTrace(`arr.pop()  // removed ${JSON.stringify(removed)}`);\n        renderArray();\n      }\n\n      function unshiftVal(value) {\n        const v = parseInputValue(String(value));\n        arr.unshift(v);\n        lastOp.textContent = 'unshift';\n        announce(`Added ${v} at start (index 0)`);\n        pushTrace(`arr.unshift(${JSON.stringify(v)})`);\n        renderArray();\n      }\n\n      function shiftVal() {\n        if (arr.length === 0) {\n          announce('Array is empty. Nothing to shift.');\n          lastOp.textContent = 'shift (empty)';\n          pushTrace('arr.shift()  // empty');\n          return;\n        }\n        const removed = arr.shift();\n        lastOp.textContent = 'shift';\n        announce(`Removed ${removed} from start`);\n        pushTrace(`arr.shift()  // removed ${JSON.stringify(removed)}`);\n        renderArray();\n      }\n\n      function insertAt(index, value) {\n        if (index < 0) index = 0;\n        if (index > arr.length) index = arr.length;\n        const v = parseInputValue(String(value));\n        arr.splice(index, 0, v);\n        lastOp.textContent = `insert @ ${index}`;\n        announce(`Inserted ${v} at index ${index}`);\n        pushTrace(`arr.splice(${index}, 0, ${JSON.stringify(v)})`);\n        renderArray();\n      }\n\n      function removeAt(index) {\n        if (index < 0 || index >= arr.length) {\n          announce('Index out of bounds.');\n          pushTrace(`remove at ${index} // out of bounds`);\n          lastOp.textContent = 'remove (oob)';\n          return;\n        }\n        const removed = arr.splice(index, 1)[0];\n        lastOp.textContent = `remove @ ${index}`;\n        announce(`Removed ${removed} from index ${index}`);\n        pushTrace(`arr.splice(${index}, 1)  // removed ${JSON.stringify(removed)}`);\n        renderArray();\n      }\n\n      function accessAt(index) {\n        if (index < 0 || index >= arr.length) {\n          announce('Index out of bounds.');\n          pushTrace(`access ${index} // out of bounds`);\n          lastOp.textContent = 'access (oob)';\n          return;\n        }\n        const val = arr[index];\n        lastOp.textContent = `access @ ${index}`;\n        announce(`Accessed index ${index}, value ${val}`);\n        pushTrace(`let v = arr[${index}]  // ${JSON.stringify(val)}`);\n        // Highlight cell\n        const cell = Array.from(arrayEl.children).find(c => Number(c.dataset.index) === index);\n        if (cell) {\n          cell.classList.add('highlight');\n          setTimeout(() => cell.classList.remove('highlight'), 800);\n        }\n      }\n\n      function setAt(index, value) {\n        if (index < 0 || index >= arr.length) {\n          announce('Index out of bounds.');\n          pushTrace(`set ${index} = ${JSON.stringify(value)} // out of bounds`);\n          lastOp.textContent = 'set (oob)';\n          return;\n        }\n        const old = arr[index];\n        arr[index] = parseInputValue(String(value));\n        lastOp.textContent = `set @ ${index}`;\n        announce(`Index ${index} changed from ${old} to ${arr[index]}`);\n        pushTrace(`arr[${index}] = ${JSON.stringify(arr[index])}  // was ${JSON.stringify(old)}`);\n        renderArray();\n      }\n\n      function clearAll() {\n        arr = [];\n        lastOp.textContent = 'clear';\n        announce('Cleared array');\n        pushTrace('arr = []');\n        renderArray();\n      }\n\n      function swapIndices(i, j) {\n        if (i < 0 || j < 0 || i >= arr.length || j >= arr.length) {\n          announce('Index out of bounds for swap.');\n          pushTrace(`swap ${i}, ${j} // out of bounds`);\n          lastOp.textContent = 'swap (oob)';\n          return;\n        }\n        [arr[i], arr[j]] = [arr[j], arr[i]];\n        lastOp.textContent = `swap ${i}<->${j}`;\n        announce(`Swapped indices ${i} and ${j}`);\n        pushTrace(`temp = arr[${i}]; arr[${i}] = arr[${j}]; arr[${j}] = temp`);\n        renderArray();\n      }\n\n      function randomFill() {\n        arr = [];\n        const sample = ['apple', '42', 7, 'banana', 'true', 'x', 99, 'hello', '🍪', 'node'];\n        const len = Math.floor(Math.random() * 6) + 3;\n        for (let i = 0; i < len; i++) {\n          const pick = sample[Math.floor(Math.random() * sample.length)];\n          arr.push(parseInputValue(String(pick)));\n        }\n        lastOp.textContent = 'randomize';\n        announce('Filled array with demo values');\n        pushTrace('random fill');\n        renderArray();\n      }\n\n      // Event wiring\n      pushBtn.addEventListener('click', () => {\n        const val = valueInput.value;\n        if (val === '') {\n          announce('Please enter a value to push.');\n          return;\n        }\n        pushVal(val);\n        valueInput.value = '';\n        valueInput.focus();\n      });\n\n      unshiftBtn.addEventListener('click', () => {\n        const val = valueInput.value;\n        if (val === '') {\n          announce('Please enter a value to add at start.');\n          return;\n        }\n        unshiftVal(val);\n        valueInput.value = '';\n        valueInput.focus();\n      });\n\n      popBtn.addEventListener('click', () => {\n        popVal();\n      });\n\n      shiftBtn.addEventListener('click', () => {\n        shiftVal();\n      });\n\n      insertBtn.addEventListener('click', () => {\n        const i = parseInt(indexInput.value, 10);\n        if (isNaN(i)) {\n          announce('Please enter a valid index to insert at.');\n          return;\n        }\n        const val = valueInput.value;\n        if (val === '') {\n          announce('Please enter a value to insert.');\n          return;\n        }\n        insertAt(i, val);\n        indexInput.value = '';\n        valueInput.value = '';\n      });\n\n      removeIndexBtn.addEventListener('click', () => {\n        const i = parseInt(indexInput.value, 10);\n        if (isNaN(i)) {\n          announce('Please enter a valid index to remove.');\n          return;\n        }\n        removeAt(i);\n        indexInput.value = '';\n      });\n\n      accessBtn.addEventListener('click', () => {\n        const i = parseInt(accessIndex.value, 10);\n        if (isNaN(i)) {\n          announce('Please enter a valid index to access.');\n          return;\n        }\n        accessAt(i);\n        accessIndex.value = '';\n      });\n\n      setBtn.addEventListener('click', () => {\n        const i = parseInt(accessIndex.value || indexInput.value, 10);\n        if (isNaN(i)) {\n          announce('Please enter a valid index to set.');\n          return;\n        }\n        const v = setValue.value;\n        if (v === '') {\n          announce('Please enter a value to set.');\n          return;\n        }\n        setAt(i, v);\n        setValue.value = '';\n        accessIndex.value = '';\n        indexInput.value = '';\n      });\n\n      clearBtn.addEventListener('click', () => {\n        if (!confirm('Clear the entire array?')) return;\n        clearAll();\n      });\n\n      swapBtn.addEventListener('click', () => {\n        const a = parseInt(swapA.value, 10);\n        const b = parseInt(swapB.value, 10);\n        if (isNaN(a) || isNaN(b)) {\n          announce('Please enter two valid indices to swap.');\n          return;\n        }\n        swapIndices(a, b);\n        swapA.value = '';\n        swapB.value = '';\n      });\n\n      randomFillBtn.addEventListener('click', randomFill);\n\n      // Keyboard: pressing Enter in certain inputs triggers related action\n      valueInput.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') pushBtn.click();\n      });\n      indexInput.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') insertBtn.click();\n      });\n      accessIndex.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') accessBtn.click();\n      });\n      setValue.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') setBtn.click();\n      });\n\n      // Initial demo content\n      arr = ['a', 'b', 'c'];\n      pushTrace('initial: [\"a\",\"b\",\"c\"]');\n      renderArray();\n      announce('Initialized demo array with 3 elements.');\n\n      // Expose some debug to window (safe)\n      window.__arrayVisualizer = {\n        getArray: () => arr,\n        push: (x) => pushVal(x),\n        insert: (i, x) => insertAt(i, x),\n        removeAt: (i) => removeAt(i),\n      };\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Array.\n\n**Project Overview:**\nTopic: Array\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Array"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "7bef2c30-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:44:58.867Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Stack",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Module: Stack (LIFO)</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --accent: #38bdf8;\n      --muted: #94a3b8;\n      --success: #34d399;\n      --danger: #fb7185;\n      --glass: rgba(255,255,255,0.03);\n      --max-width: 1100px;\n    }\n\n    /* Safe area margins on all sides */\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg, #071023 0%, #071428 60%);\n      color: #e6eef8;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      box-sizing:border-box;\n      padding: var(--safe-margin);\n    }\n    *,*::before,*::after{box-sizing:inherit}\n\n    .wrapper{\n      max-width: var(--max-width);\n      margin: 0 auto;\n    }\n\n    header{\n      display:flex;\n      align-items:flex-start;\n      justify-content:space-between;\n      gap:var(--gap);\n      margin-bottom:calc(var(--gap) + 8px);\n    }\n\n    .title-block{\n      flex:1 1 auto;\n    }\n    h1{\n      font-size:1.5rem;\n      margin:0 0 6px 0;\n      color: #fff;\n      line-height:1.1;\n    }\n    p.lead{\n      margin:0;\n      color:var(--muted);\n      font-size:0.95rem;\n    }\n\n    /* Layout: two-column responsive */\n    .module{\n      display:grid;\n      grid-template-columns: 1fr 360px;\n      gap:var(--gap);\n      align-items:start;\n    }\n    @media (max-width:900px){\n      .module{\n        grid-template-columns: 1fr;\n      }\n    }\n\n    /* Left: interactive area */\n    .interactive{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:18px;\n      box-shadow: 0 6px 30px rgba(2,6,23,0.6);\n      min-height:420px;\n    }\n\n    /* Right: controls and docs */\n    .sidebar{\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));\n      border-radius:12px;\n      padding:18px;\n      box-shadow: 0 6px 30px rgba(2,6,23,0.5);\n    }\n\n    /* Info panel (concept plan) */\n    .info{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:10px;\n      padding:12px;\n      margin-bottom:var(--gap);\n      color:var(--muted);\n      font-size:0.95rem;\n      line-height:1.3;\n    }\n    .info h3{margin:0 0 6px 0;color:#fff;font-size:1rem}\n\n    /* Visual stack area */\n    .vis-area{\n      display:flex;\n      gap:var(--gap);\n      flex-wrap:wrap;\n      align-items:flex-start;\n      justify-content:flex-start;\n    }\n\n    .stack-column{\n      width:320px;\n      min-height:320px;\n      border-radius:10px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      padding:18px;\n      display:flex;\n      flex-direction:column;\n      align-items:center;\n      justify-content:flex-start;\n      position:relative;\n    }\n    @media (max-width:900px){\n      .stack-column{width:100%}\n    }\n\n    .stack-frame{\n      width:160px;\n      min-height:240px;\n      border:2px dashed rgba(255,255,255,0.06);\n      border-radius:8px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      padding:12px;\n      display:flex;\n      flex-direction:column-reverse; /* stack grows downward in DOM but visually bottom-first */\n      align-items:center;\n      gap:10px;\n      position:relative;\n      overflow:visible;\n    }\n\n    .stack-slot{\n      width:100%;\n      height:40px;\n      border-radius:6px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));\n      border:1px solid rgba(255,255,255,0.03);\n      color:var(--muted);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:600;\n      font-size:0.95rem;\n      position:relative;\n      box-shadow: inset 0 -4px 8px rgba(2,6,23,0.3);\n    }\n\n    /* Actual element when pushed */\n    .elem{\n      width:100%;\n      height:40px;\n      border-radius:6px;\n      background:linear-gradient(180deg, #052434 0%, rgba(3,91,108,0.25) 100%);\n      border:1px solid rgba(56,189,248,0.15);\n      color:var(--accent);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:700;\n      font-size:0.95rem;\n      transform-origin:center;\n      box-shadow: 0 4px 20px rgba(3,91,108,0.08);\n    }\n\n    .elem.top{\n      background: linear-gradient(180deg,#0ea5e9,#036172);\n      color:white;\n      box-shadow:0 8px 30px rgba(3,91,108,0.25);\n    }\n\n    /* Top pointer */\n    .top-pointer{\n      position:absolute;\n      top:8px;\n      right:16px;\n      display:flex;\n      align-items:center;\n      gap:8px;\n      color:var(--muted);\n      font-size:0.85rem;\n    }\n    .arrow{\n      width:10px;height:10px;\n      transform:rotate(90deg);\n      border-right:2px solid var(--muted);\n      border-top:2px solid var(--muted);\n      display:inline-block;\n    }\n\n    /* Array view (mirror) */\n    .array-view{\n      flex:1;\n      min-width:260px;\n      border-radius:10px;\n      padding:12px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      align-items:stretch;\n    }\n    .array-title{color:var(--muted);font-size:0.88rem}\n    .array-row{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n    }\n    .array-cell{\n      min-width:48px;\n      height:44px;\n      border-radius:8px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border:1px solid rgba(255,255,255,0.03);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:700;\n      color:var(--muted);\n      font-size:0.9rem;\n      position:relative;\n    }\n    .array-cell.active{\n      background: linear-gradient(180deg,#062d3a,#08333d);\n      color:var(--accent);\n      border-color: rgba(56,189,248,0.18);\n      box-shadow:0 6px 24px rgba(3,91,108,0.08);\n    }\n    .cell-index{\n      position:absolute;\n      bottom:4px;\n      right:6px;\n      font-size:0.68rem;\n      color: #98a8b8;\n      font-weight:500;\n    }\n\n    /* Controls */\n    .controls{\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      margin-bottom:var(--gap);\n    }\n    .controls-row{\n      display:flex;\n      gap:var(--gap);\n      flex-wrap:wrap;\n      align-items:center;\n    }\n    input[type=\"text\"], input[type=\"number\"]{\n      height:40px;\n      padding:8px 12px;\n      background:var(--glass);\n      border:1px solid rgba(255,255,255,0.04);\n      color: #e6eef8;\n      border-radius:8px;\n      outline:none;\n      min-width:120px;\n    }\n    input[type=\"number\"]{width:120px}\n    input:focus{box-shadow:0 0 0 3px rgba(56,189,248,0.08); border-color: rgba(56,189,248,0.2)}\n\n    button{\n      height:40px;\n      border-radius:8px;\n      border:0;\n      background: linear-gradient(180deg,#0ea5e9,#036172);\n      color:white;\n      padding:0 14px;\n      font-weight:700;\n      cursor:pointer;\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n      transition: transform 120ms ease, box-shadow 120ms ease, opacity 120ms;\n    }\n    button.secondary{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--muted);\n      font-weight:600;\n    }\n    button.ghost{\n      background:transparent;\n      border:1px dashed rgba(255,255,255,0.04);\n      color:var(--muted);\n      font-weight:600;\n    }\n    button:active{transform:translateY(1px)}\n    button:focus{outline:none; box-shadow:0 0 0 3px rgba(56,189,248,0.08)}\n\n    /* Operation log */\n    .log{\n      margin-top:8px;\n      padding:10px;\n      border-radius:8px;\n      background: rgba(255,255,255,0.01);\n      color:var(--muted);\n      font-size:0.9rem;\n      max-height:140px;\n      overflow:auto;\n    }\n    .log .entry{\n      padding:6px 0;\n      border-bottom:1px dashed rgba(255,255,255,0.02);\n    }\n    .log .entry:last-child{border-bottom:0}\n\n    /* Animations for push/pop */\n    @keyframes slideDownIn {\n      0%{ transform: translateY(-60px) scale(0.98); opacity:0 }\n      60%{ transform: translateY(8px) scale(1.02); opacity:1 }\n      100%{ transform: translateY(0) scale(1) }\n    }\n    @keyframes popUpOut {\n      0%{ transform: translateY(0) scale(1); opacity:1 }\n      100%{ transform: translateY(-70px) scale(0.92); opacity:0 }\n    }\n    @keyframes shake {\n      0%{ transform: translateX(0) }\n      25%{ transform: translateX(-6px) }\n      50%{ transform: translateX(6px) }\n      75%{ transform: translateX(-4px) }\n      100%{ transform: translateX(0) }\n    }\n\n    .animate-in{ animation: slideDownIn 420ms cubic-bezier(.2,.9,.2,1) both; }\n    .animate-out{ animation: popUpOut 380ms cubic-bezier(.2,.9,.2,1) both; }\n    .shake{ animation: shake 420ms ease both; }\n\n    /* Small helpers */\n    .muted{ color:var(--muted); font-size:0.9rem }\n    .kbd{ background:rgba(255,255,255,0.03); padding:4px 8px; border-radius:6px; font-weight:700; color:#dbeafe; font-size:0.86rem; border:1px solid rgba(255,255,255,0.02) }\n    footer{ margin-top:var(--gap); color:var(--muted); font-size:0.86rem; }\n  </style>\n</head>\n<body>\n  <div class=\"wrapper\" role=\"main\">\n    <header>\n      <div class=\"title-block\">\n        <h1>Stack — LIFO (Last In, First Out)</h1>\n        <p class=\"lead\">Interactive module: push, pop, peek, and observe how a stack operates visually and as an array.</p>\n      </div>\n      <div style=\"min-width:220px; text-align:right;\">\n        <div class=\"muted\">Safe margins: 24px • Min spacing: 16px</div>\n        <div style=\"margin-top:8px\"><span class=\"kbd\">Enter</span> to Push • <span class=\"kbd\">P</span> Pop • <span class=\"kbd\">Space</span> Peek</div>\n      </div>\n    </header>\n\n    <div class=\"module\" aria-label=\"Stack interactive module\">\n      <!-- Left: Visual + controls -->\n      <section class=\"interactive\" aria-labelledby=\"concept\">\n        <div class=\"info\" id=\"concept\">\n          <h3>Concept Title</h3>\n          <div><strong>Stack (LIFO)</strong> — a collection that follows Last In, First Out ordering. Only the top element is accessible for removal or inspection.</div>\n          <hr style=\"opacity:0.06;margin:12px 0\">\n          <h3>Learning Objective</h3>\n          <div>After interacting you'll be able to: <ul style=\"margin:6px 0 0 18px;color:var(--muted)\"><li>Understand push/pop effects and LIFO ordering</li><li>See how a stack maps to array indices</li><li>Recognize underflow/overflow situations in bounded stacks</li></ul></div>\n        </div>\n\n        <div class=\"vis-area\" aria-hidden=\"false\">\n          <div class=\"stack-column\" aria-label=\"Stack visual\">\n            <div class=\"top-pointer\" id=\"topPointer\" aria-hidden=\"true\">\n              <span class=\"arrow\" aria-hidden=\"true\"></span>\n              <span id=\"topLabel\">top: -1</span>\n            </div>\n\n            <div style=\"width:100%; display:flex; align-items:center; justify-content:center; gap:8px; margin-bottom:6px;\">\n              <div style=\"font-weight:700; color:var(--muted);\">Stack Frame</div>\n            </div>\n\n            <div class=\"stack-frame\" id=\"stackFrame\" role=\"list\" aria-label=\"Stack slots\">\n              <!-- Stack elements will be injected here (bottom-first) -->\n              <div id=\"emptyHint\" class=\"muted\" style=\"padding:8px;text-align:center;\">Stack is empty — push values to begin</div>\n            </div>\n\n            <div style=\"margin-top:12px; color:var(--muted); font-size:0.9rem;\">\n              Top element highlighted in blue. New elements animate into place.\n            </div>\n          </div>\n\n          <div class=\"array-view\" aria-label=\"Array mirror\">\n            <div class=\"array-title\">Array representation (index 0 at bottom)</div>\n            <div class=\"array-row\" id=\"arrayRow\" role=\"list\" aria-label=\"Array cells\">\n              <!-- array cells injected here -->\n            </div>\n\n            <div style=\"margin-top:8px; color:var(--muted); font-size:0.88rem;\">\n              The stack maps to contiguous array indices. top points to the highest used index.\n            </div>\n          </div>\n        </div>\n\n        <div style=\"margin-top:18px;\">\n          <div class=\"controls\" aria-label=\"Stack controls\">\n            <div class=\"controls-row\" role=\"group\" aria-label=\"Push controls\">\n              <label for=\"valueInput\" class=\"muted\" style=\"display:block; margin-right:8px;\">Value</label>\n              <input id=\"valueInput\" type=\"text\" inputmode=\"text\" aria-label=\"Value to push\" placeholder=\"e.g. 42\" />\n              <button id=\"pushBtn\" aria-label=\"Push value\">Push</button>\n\n              <label for=\"capacityInput\" class=\"muted\" style=\"margin-left:12px;\">Capacity</label>\n              <input id=\"capacityInput\" type=\"number\" min=\"1\" value=\"6\" aria-label=\"Set stack capacity\" />\n              <button id=\"setCapBtn\" class=\"secondary\" aria-label=\"Set capacity\">Set</button>\n            </div>\n\n            <div class=\"controls-row\" role=\"group\" aria-label=\"Pop and Peek controls\">\n              <button id=\"popBtn\" class=\"secondary\" aria-label=\"Pop top\">Pop</button>\n              <button id=\"peekBtn\" class=\"ghost\" aria-label=\"Peek top\">Peek</button>\n              <button id=\"clearBtn\" class=\"secondary\" aria-label=\"Clear stack\">Clear</button>\n              <button id=\"fillBtn\" class=\"secondary\" aria-label=\"Fill with sample values\">Sample Fill</button>\n              <div style=\"flex:1\"></div>\n              <div class=\"muted\" aria-live=\"polite\" id=\"statusAnnounce\" style=\"text-align:right\">top = -1</div>\n            </div>\n\n            <div class=\"controls-row\" role=\"group\" aria-label=\"Machine controls\">\n              <button id=\"replayBtn\" class=\"ghost\" aria-label=\"Auto-play example\">Auto-play Example</button>\n              <div style=\"flex:1\"></div>\n              <div class=\"muted\">Shortcuts: <span class=\"kbd\">Enter</span> Push • <span class=\"kbd\">P</span> Pop • <span class=\"kbd\">Space</span> Peek</div>\n            </div>\n\n            <div>\n              <div class=\"log\" id=\"log\" aria-live=\"polite\" aria-label=\"Operation log\"></div>\n            </div>\n          </div>\n        </div>\n      </section>\n\n      <!-- Right: Sidebar docs, interaction design, layout description -->\n      <aside class=\"sidebar\" aria-labelledby=\"sidebarTitle\">\n        <h2 id=\"sidebarTitle\" style=\"margin:0 0 8px 0; font-size:1.05rem; color:#fff\">Interaction Design & Layout</h2>\n\n        <div class=\"info\" style=\"margin-bottom:var(--gap);\">\n          <h3>Interaction Design</h3>\n          <div style=\"color:var(--muted)\">\n            - Users type a value and click \"Push\" (or press Enter). The element animates into the stack (slide-down), becomes the top, and the array mirror updates.<br><br>\n            - Clicking \"Pop\" removes the top element with an upward pop animation and shows the popped value in the log. If empty, the stack frame gently shakes to indicate underflow.<br><br>\n            - \"Peek\" briefly highlights the top and announces its value without removing it.<br><br>\n            - \"Capacity\" sets a bounded size. Pushing beyond capacity triggers an overflow warning and prevents the push.<br><br>\n            - \"Auto-play Example\" runs a short scripted sequence (push, push, pop, peek) to reinforce LIFO behavior.\n          </div>\n        </div>\n\n        <div class=\"info\" style=\"margin-bottom:var(--gap);\">\n          <h3>Layout Description</h3>\n          <div style=\"color:var(--muted)\">\n            - Two-column responsive layout: left column contains the interactive visualization; right column contains controls and explanatory text.<br><br>\n            - Safe area margins: 24px (applied to body). Minimum spacing between interactive elements: 16px (CSS gap and margins).<br><br>\n            - Accessibility: controls have labels, keyboard shortcuts, aria-live announcements for the top and operation log, and focus styles. The module is responsive: columns stack on narrow screens.\n          </div>\n        </div>\n\n        <div class=\"info\">\n          <h3>What you'll see</h3>\n          <div style=\"color:var(--muted)\">\n            - Visual stack frame with element animation to show push/pop order.<br>\n            - Array mirror that shows indices (0 at bottom) and highlights the active cells.<br>\n            - A live operation log documenting actions (push X, pop -> Y).\n          </div>\n        </div>\n      </aside>\n    </div>\n\n    <footer>\n      Tip: Try pushing multiple values then popping them to confirm that the last pushed is the first popped.\n    </footer>\n  </div>\n\n  <script>\n    /*\n      Interactive Stack Module (vanilla JS)\n      - Implements push, pop, peek, clear, capacity\n      - Visual animations for push/pop\n      - Array mirror updates with indices (0 at bottom)\n      - Accessibility: aria-live updates and keyboard shortcuts\n    */\n\n    (function(){\n      // DOM refs\n      const stackFrame = document.getElementById('stackFrame');\n      const arrayRow = document.getElementById('arrayRow');\n      const logEl = document.getElementById('log');\n      const topLabel = document.getElementById('topLabel');\n      const statusAnnounce = document.getElementById('statusAnnounce');\n      const emptyHint = document.getElementById('emptyHint');\n\n      const valueInput = document.getElementById('valueInput');\n      const pushBtn = document.getElementById('pushBtn');\n      const popBtn = document.getElementById('popBtn');\n      const peekBtn = document.getElementById('peekBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const fillBtn = document.getElementById('fillBtn');\n      const replayBtn = document.getElementById('replayBtn');\n      const capacityInput = document.getElementById('capacityInput');\n      const setCapBtn = document.getElementById('setCapBtn');\n\n      let capacity = parseInt(capacityInput.value, 10) || 6;\n      let stack = []; // bottom at index 0, top = stack.length - 1\n\n      // Utility: log message\n      function log(msg){\n        const entry = document.createElement('div');\n        entry.className = 'entry';\n        entry.textContent = `${timestamp()} — ${msg}`;\n        logEl.prepend(entry);\n      }\n      function timestamp(){\n        const d = new Date();\n        return d.toLocaleTimeString();\n      }\n\n      // Update top label and status\n      function updateTop(){\n        const topIndex = stack.length - 1;\n        topLabel.textContent = `top: ${topIndex}`;\n        statusAnnounce.textContent = `top = ${topIndex}`;\n      }\n\n      // Render stack visual (rebuild)\n      function render(){\n        // Clear frame\n        while (stackFrame.firstChild) stackFrame.removeChild(stackFrame.firstChild);\n\n        if(stack.length === 0){\n          stackFrame.appendChild(emptyHint);\n          emptyHint.style.display = 'block';\n        } else {\n          emptyHint.style.display = 'none';\n          // Render from bottom (index 0) to top (last)\n          for(let i=0;i<stack.length;i++){\n            const val = stack[i];\n            const el = document.createElement('div');\n            el.className = 'elem' + (i === stack.length-1 ? ' top' : '');\n            el.setAttribute('role','listitem');\n            el.setAttribute('aria-label', `Stack element ${i} value ${val}`);\n            el.textContent = val;\n            // Place elements bottom-first: stack-frame is column-reverse, so append in increasing index\n            stackFrame.appendChild(el);\n          }\n        }\n\n        renderArray();\n        updateTop();\n      }\n\n      // Render array mirror\n      function renderArray(){\n        arrayRow.innerHTML = '';\n        // We'll show capacity cells: capacity may be larger than current stack length\n        for(let i=0;i<capacity;i++){\n          const cell = document.createElement('div');\n          cell.className = 'array-cell' + (i < stack.length ? ' active' : '');\n          const idx = document.createElement('div');\n          idx.className = 'cell-index';\n          idx.textContent = i;\n          cell.appendChild(idx);\n\n          if(i < stack.length){\n            cell.textContent = stack[i];\n            cell.appendChild(idx);\n          } else {\n            // placeholder\n            const placeholder = document.createElement('div');\n            placeholder.style.color = 'rgba(255,255,255,0.06)';\n            placeholder.style.fontWeight = '600';\n            placeholder.style.fontSize = '0.78rem';\n            placeholder.textContent = '-';\n            cell.appendChild(placeholder);\n            cell.appendChild(idx);\n          }\n          arrayRow.appendChild(cell);\n        }\n      }\n\n      // Animate push: create element then animate-in\n      function push(value){\n        if(stack.length >= capacity){\n          // overflow: flash stack frame\n          stackFrame.classList.add('shake');\n          setTimeout(()=>stackFrame.classList.remove('shake'),420);\n          log(`Overflow prevented when trying to push \"${value}\"`);\n          return;\n        }\n        // Update model first\n        stack.push(value);\n\n        // Visual: create a new elem at the end and animate in\n        const el = document.createElement('div');\n        el.className = 'elem top animate-in';\n        el.textContent = value;\n        el.setAttribute('role','listitem');\n        el.setAttribute('aria-label', `Stack element ${stack.length-1} value ${value}`);\n\n        // If emptyHint present, hide it\n        if(emptyHint && emptyHint.parentNode === stackFrame){\n          // We'll rebuild to ensure order and not duplicate nodes\n          render();\n          const last = stackFrame.lastElementChild;\n          if(last) last.classList.add('animate-in');\n        } else {\n          // Append to frame\n          stackFrame.appendChild(el);\n          // remove top class from previous top if exists\n          const others = stackFrame.querySelectorAll('.elem');\n          if(others.length > 1){\n            others[others.length - 2].classList.remove('top');\n          }\n        }\n\n        // Update array and UI\n        renderArray();\n        updateTop();\n\n        log(`push(\"${value}\")`);\n        announce(`Pushed ${value}`);\n      }\n\n      // Animate pop\n      function pop(){\n        if(stack.length === 0){\n          // underflow: shake and announce\n          stackFrame.classList.add('shake');\n          setTimeout(()=>stackFrame.classList.remove('shake'),420);\n          log('pop() attempted on empty stack (underflow)');\n          announce('Stack underflow: cannot pop, stack is empty');\n          return;\n        }\n        const popped = stack.pop();\n\n        // Visual: animate-out the top visual element\n        const elems = stackFrame.querySelectorAll('.elem');\n        const topEl = elems[elems.length - 1];\n        if(topEl){\n          topEl.classList.add('animate-out');\n          // on animation end, remove and update remaining top\n          topEl.addEventListener('animationend', ()=>{\n            if(topEl && topEl.parentNode === stackFrame) stackFrame.removeChild(topEl);\n            // mark new top\n            const remain = stackFrame.querySelectorAll('.elem');\n            if(remain.length > 0){\n              remain[remain.length -1].classList.add('top');\n            } else {\n              // show empty hint\n              if(emptyHint) stackFrame.appendChild(emptyHint);\n            }\n            renderArray();\n            updateTop();\n          }, {once:true});\n        } else {\n          // if no visual element found fallback to render\n          render();\n        }\n\n        log(`pop() -> \"${popped}\"`);\n        announce(`Popped ${popped}`);\n        return popped;\n      }\n\n      function peek(){\n        if(stack.length === 0){\n          log('peek() -> null (empty)');\n          announce('Stack is empty');\n          // brief shake to indicate empty\n          stackFrame.classList.add('shake');\n          setTimeout(()=>stackFrame.classList.remove('shake'),380);\n          return null;\n        }\n        const top = stack[stack.length - 1];\n\n        // Visual highlight: briefly pulse top element\n        const elems = stackFrame.querySelectorAll('.elem');\n        const topEl = elems[elems.length -1];\n        if(topEl){\n          topEl.style.transition = 'box-shadow 200ms, transform 200ms';\n          topEl.style.transform = 'translateY(-4px) scale(1.02)';\n          setTimeout(()=>{ topEl.style.transform=''; }, 280);\n        }\n\n        log(`peek() -> \"${top}\"`);\n        announce(`Top is ${top}`);\n        return top;\n      }\n\n      function clearStack(){\n        if(stack.length === 0){\n          log('clear() — stack already empty');\n          announce('Stack already empty');\n          return;\n        }\n        stack = [];\n        // Clear visuals\n        render();\n        log('clear() — stack cleared');\n        announce('Stack cleared');\n      }\n\n      // Helper to announce via aria-live\n      function announce(msg){\n        statusAnnounce.textContent = msg;\n        // also set a timeout to show top after short delay\n        setTimeout(updateTop, 600);\n      }\n\n      // Event bindings\n      pushBtn.addEventListener('click', ()=>{\n        const val = valueInput.value.trim();\n        if(val === '') { valueInput.focus(); return; }\n        push(val);\n        valueInput.value = '';\n        valueInput.focus();\n      });\n\n      popBtn.addEventListener('click', ()=>{\n        pop();\n      });\n\n      peekBtn.addEventListener('click', ()=>{\n        peek();\n      });\n\n      clearBtn.addEventListener('click', ()=>{\n        clearStack();\n      });\n\n      fillBtn.addEventListener('click', ()=>{\n        // sample fill with unique values until capacity or 4 items\n        const samples = ['A','B','C','D','E','F','G','H'];\n        clearStack();\n        const take = Math.min(4, capacity);\n        for(let i=0;i<take;i++){\n          push(samples[i]);\n        }\n        log('sample fill completed');\n      });\n\n      setCapBtn.addEventListener('click', ()=>{\n        const v = parseInt(capacityInput.value,10);\n        if(Number.isNaN(v) || v < 1) {\n          capacityInput.value = capacity;\n          return;\n        }\n        capacity = v;\n        // if stack longer than capacity, truncate and log overflow effect\n        if(stack.length > capacity){\n          const removed = stack.splice(capacity);\n          log(`capacity reduced to ${capacity}, trimmed ${removed.length} elements`);\n        } else {\n          log(`capacity set to ${capacity}`);\n        }\n        render();\n      });\n\n      capacityInput.addEventListener('keyup', (e)=>{\n        if(e.key === 'Enter'){ setCapBtn.click(); }\n      });\n\n      // Replay scripted example\n      replayBtn.addEventListener('click', async ()=>{\n        // Disable controls during replay\n        disableControls(true);\n        clearStack();\n        await delay(300);\n        push('1'); await delay(500);\n        push('2'); await delay(500);\n        push('3'); await delay(500);\n        await delay(300);\n        pop(); await delay(500);\n        peek(); await delay(600);\n        disableControls(false);\n      });\n\n      function disableControls(v){\n        const all = [pushBtn,popBtn,peekBtn,clearBtn,fillBtn,replayBtn,setCapBtn];\n        all.forEach(btn=>btn.disabled = v);\n      }\n\n      // Keyboard shortcuts\n      document.addEventListener('keydown',(e)=>{\n        if(e.key === 'Enter' && document.activeElement === valueInput){\n          e.preventDefault();\n          pushBtn.click();\n        } else if(e.key === 'p' || e.key === 'P'){\n          // Only when not focused on input\n          if(document.activeElement !== valueInput){\n            popBtn.click();\n          }\n        } else if(e.code === 'Space'){\n          // If not focused on an input, prevent scrolling and peek\n          if(document.activeElement !== valueInput && document.activeElement.tagName !== 'BUTTON'){\n            e.preventDefault();\n            peekBtn.click();\n          }\n        }\n      });\n\n      // Small helper delay\n      function delay(ms){ return new Promise(resolve=>setTimeout(resolve,ms)); }\n\n      // Initialize visuals\n      render();\n      log('Module ready. Capacity: ' + capacity);\n\n      // Accessibility: focus management\n      valueInput.setAttribute('aria-describedby','statusAnnounce');\n\n      // Expose some functions for debugging (in console)\n      window._stackModule = { push, pop, peek, clear: clearStack, getStack: ()=>stack, setCapacity: (c)=>{ capacity=c; render(); } };\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Stack.\n\n**Project Overview:**\nTopic: Stack\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Stack"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "7df5aa90-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:45:02.265Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Heap (Min/Max)",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Heap (Min/Max) — Interactive Module</title>\n  <style>\n    :root{\n      --safe:24px;\n      --gap:16px;\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#06b6d4;\n      --muted:#94a3b8;\n      --card:#071024;\n      --success:#10b981;\n      --danger:#ef4444;\n      --node-size:56px;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      background:linear-gradient(180deg,#071428 0%, #031528 100%);\n      color:#e6eef8;\n      font-family:system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    /* Safe area margin 24px */\n    .app {\n      padding: var(--safe);\n      box-sizing: border-box;\n      min-height:100%;\n      display:flex;\n      gap:var(--gap);\n    }\n\n    /* Left column: description */\n    .sidebar {\n      min-width:320px;\n      max-width:380px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:20px;\n      box-sizing:border-box;\n      border:1px solid rgba(255,255,255,0.03);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .title {\n      font-size:20px;\n      font-weight:700;\n      color:var(--accent);\n      display:flex;\n      align-items:center;\n      gap:10px;\n    }\n    .subtitle{\n      color:var(--muted);\n      font-size:13px;\n    }\n    .section {\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);\n      border-radius:8px;\n      padding:12px;\n      box-sizing:border-box;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .section h3{\n      margin:0 0 8px 0;\n      font-size:13px;\n      color:#cfeaf2;\n    }\n    .section p{\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n      line-height:1.4;\n    }\n\n    /* Right column: interactive module */\n    .main {\n      flex:1;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      min-width:0;\n    }\n\n    .controls {\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n      background: linear-gradient(180deg, rgba(255,255,255,0.012), transparent);\n      border:1px solid rgba(255,255,255,0.02);\n      padding:14px;\n      border-radius:12px;\n    }\n    .controls .group {\n      display:flex;\n      gap:10px;\n      align-items:center;\n    }\n    input[type=\"text\"]{\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.04);\n      background:rgba(255,255,255,0.02);\n      color:inherit;\n      min-width:120px;\n      outline:none;\n    }\n    button, .toggle {\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.04);\n      background:rgba(255,255,255,0.02);\n      color:inherit;\n      cursor:pointer;\n      font-weight:600;\n    }\n    button:active { transform:translateY(1px); }\n    .primary {\n      background:linear-gradient(90deg,var(--accent),#7dd3fc22);\n      border:1px solid rgba(6,182,212,0.2);\n      color:#021823;\n    }\n    .danger {\n      background:linear-gradient(90deg,var(--danger),#ff8787cc);\n      border:1px solid rgba(239,68,68,0.18);\n      color:white;\n    }\n    .muted {\n      background:transparent;\n      color:var(--muted);\n    }\n\n    .toggles { display:flex; gap:8px; align-items:center; }\n\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:12px;\n      padding:12px;\n      border:1px solid rgba(255,255,255,0.02);\n      display:flex;\n      gap:var(--gap);\n    }\n\n    /* Visual area */\n    .visual {\n      flex:1;\n      min-height:420px;\n      position:relative;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n\n    /* Tree area */\n    .tree-area {\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);\n      border-radius:10px;\n      padding:12px;\n      position:relative;\n      flex:1;\n      min-height:320px;\n      overflow:hidden;\n    }\n\n    .tree-canvas {\n      position:relative;\n      width:100%;\n      height:100%;\n      box-sizing:border-box;\n    }\n\n    .node {\n      position:absolute;\n      width:var(--node-size);\n      height:var(--node-size);\n      border-radius:50%;\n      background:linear-gradient(180deg,#072a3a, #06323f);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:700;\n      color:#e6faff;\n      box-shadow:0 6px 18px rgba(2,6,23,0.6), inset 0 -6px 10px rgba(255,255,255,0.02);\n      border:2px solid rgba(255,255,255,0.03);\n      transition: transform 350ms ease, top 350ms ease, left 350ms ease;\n      transform:translate(-50%, -50%);\n      z-index:2;\n    }\n    .node .idx {\n      position:absolute;\n      bottom:-18px;\n      right:-10px;\n      background:rgba(255,255,255,0.03);\n      color:var(--muted);\n      font-size:11px;\n      padding:2px 6px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.02);\n      font-weight:600;\n    }\n    .node.highlight {\n      box-shadow:0 10px 28px rgba(6,182,212,0.14), 0 0 0 6px rgba(6,182,212,0.06);\n      transform:translate(-50%,-50%) scale(1.06);\n    }\n    .node.swap {\n      background: linear-gradient(180deg,#3b82f6,#1e40af);\n    }\n    .node.min { border-color: rgba(16,185,129,0.12); }\n    .node.max { border-color: rgba(245,158,11,0.12); }\n\n    /* Array representation */\n    .array {\n      display:flex;\n      gap:8px;\n      align-items:center;\n      padding:8px;\n      border-radius:8px;\n      background:rgba(255,255,255,0.01);\n      border:1px solid rgba(255,255,255,0.02);\n      flex-wrap:wrap;\n      min-height:64px;\n    }\n    .arr-item {\n      min-width:56px;\n      height:48px;\n      background:linear-gradient(180deg,#031827,#042235);\n      border-radius:8px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      color:#cfeaf2;\n      font-weight:700;\n      border:1px solid rgba(255,255,255,0.02);\n      position:relative;\n      padding:0 8px;\n    }\n    .arr-item.idx {\n      font-size:12px;\n      color:var(--muted);\n    }\n    .arr-item.highlight {\n      outline:3px solid rgba(6,182,212,0.08);\n      transform:scale(1.04);\n    }\n\n    /* Log */\n    .log {\n      background:rgba(0,0,0,0.06);\n      border-radius:8px;\n      padding:10px;\n      min-height:72px;\n      max-height:120px;\n      overflow:auto;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .log .entry { margin-bottom:6px; }\n    .log .entry strong { color:var(--accent); font-weight:700; }\n\n    /* small screens */\n    @media (max-width:920px){\n      .app { flex-direction:column; }\n      .sidebar { max-width:100%; min-width:0; order:2; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Heap interactive module\">\n    <!-- Sidebar: Concept Title, Learning Objective, Interaction Design, Layout Description -->\n    <aside class=\"sidebar\" aria-labelledby=\"module-title\">\n      <div>\n        <div id=\"module-title\" class=\"title\">Heap (Min / Max)</div>\n        <div class=\"subtitle\">Visual, step-by-step build, insert, and extract with animations</div>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"learning-objective\">\n        <h3 id=\"learning-objective\">Learning Objective</h3>\n        <p>\n          Understand how a binary heap enforces the min-heap or max-heap property.\n          Interactively observe insert (sift-up), extract-root (sift-down), and build-heap operations.\n          After interacting, you should be able to trace comparisons and swaps and explain why the structure maintains its invariant.\n        </p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"interaction-design\">\n        <h3 id=\"interaction-design\">Interaction Design</h3>\n        <p>\n          Controls let you Insert values, Extract the root, Build from an array, or generate Random data.\n          Toggle between Min and Max mode. Use \"Step Mode\" to advance each comparison/swap manually, or run animations at adjustable speed.\n          Visual cues: nodes being compared highlight, swaps animate, and array representation syncs.\n        </p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"layout-description\">\n        <h3 id=\"layout-description\">Layout Description</h3>\n        <p>\n          Left panel (this column) contains explanations and guidance. The right panel is the interactive module: controls on top, tree visualization in the middle, array view and action log below.\n          Spacing: 24px safe margins, 16px minimum gap between interactive elements. Responsive: columns stack on narrow screens. All interactive controls are keyboard-focusable and labeled.\n        </p>\n      </div>\n    </aside>\n\n    <!-- Main interactive area -->\n    <main class=\"main\" aria-live=\"polite\">\n      <!-- Controls -->\n      <div class=\"controls\" role=\"region\" aria-label=\"Controls\">\n        <div class=\"group\">\n          <input id=\"value-input\" type=\"text\" inputmode=\"numeric\" placeholder=\"Enter value e.g. 42\" aria-label=\"Value to insert\" />\n          <button id=\"insert-btn\" class=\"primary\" title=\"Insert value (Enter)\" aria-label=\"Insert value\">Insert</button>\n          <button id=\"extract-btn\" class=\"danger\" aria-label=\"Extract root\">Extract Root</button>\n        </div>\n\n        <div class=\"group\">\n          <input id=\"array-input\" type=\"text\" placeholder=\"Array e.g. 4,1,7,3\" aria-label=\"Array to build\" />\n          <button id=\"build-btn\" class=\"muted\" aria-label=\"Build heap from array\">Build Heap</button>\n          <button id=\"random-btn\" class=\"muted\" aria-label=\"Randomize heap\">Random</button>\n        </div>\n\n        <div class=\"toggles\" style=\"margin-left:auto;\">\n          <label class=\"muted\" style=\"font-size:13px;align-self:center;\">Mode</label>\n          <select id=\"mode-select\" aria-label=\"Heap mode: Min or Max\" title=\"Min or Max\">\n            <option value=\"min\">Min-Heap</option>\n            <option value=\"max\">Max-Heap</option>\n          </select>\n\n          <label style=\"font-size:13px;align-self:center;margin-left:8px;\">Speed</label>\n          <input id=\"speed-range\" type=\"range\" min=\"50\" max=\"1000\" value=\"350\" aria-label=\"Animation speed\" title=\"Animation delay (ms)\" />\n\n          <label class=\"muted\" style=\"margin-left:8px;\">Step Mode</label>\n          <button id=\"step-toggle\" class=\"toggle\" aria-pressed=\"false\" aria-label=\"Toggle step mode\">Off</button>\n          <button id=\"next-step\" class=\"muted\" aria-label=\"Advance step\" disabled>Next Step</button>\n        </div>\n      </div>\n\n      <!-- Panel with visual tree and array -->\n      <div class=\"panel\" role=\"region\" aria-label=\"Heap visualization\">\n        <div class=\"visual\" style=\"flex:1;\">\n          <div class=\"tree-area\" id=\"tree-area\" aria-label=\"Heap tree visualization\">\n            <svg id=\"links\" style=\"position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:1;\"></svg>\n            <div class=\"tree-canvas\" id=\"tree-canvas\" aria-hidden=\"false\"></div>\n          </div>\n\n          <div>\n            <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;\">\n              <div style=\"color:var(--muted);font-size:13px;\">Array Representation (indices)</div>\n              <div style=\"display:flex;gap:8px;align-items:center;\">\n                <button id=\"peek-btn\" class=\"muted\" aria-label=\"Peek root\">Peek Root</button>\n                <button id=\"clear-btn\" class=\"muted\" aria-label=\"Clear heap\">Clear</button>\n              </div>\n            </div>\n            <div class=\"array\" id=\"array-view\" aria-live=\"polite\"></div>\n          </div>\n        </div>\n\n        <div style=\"width:320px;display:flex;flex-direction:column;gap:12px;\">\n          <div style=\"font-size:13px;color:var(--muted);\">Action Log</div>\n          <div class=\"log\" id=\"log\" aria-live=\"polite\"></div>\n          <div style=\"font-size:12px;color:var(--muted);\">Tips: Use Step Mode to trace each compare/swap. Toggle Min/Max to observe different invariants.</div>\n        </div>\n      </div>\n    </main>\n  </div>\n\n  <script>\n    // Heap Interactive Module\n    // Vanilla JS, self-contained. Implements a visual binary heap with animated sift-up/sift-down,\n    // build-heap, insertion, extraction, and step-by-step mode.\n\n    (function(){\n      // Utilities\n      const $ = sel => document.querySelector(sel);\n      const qs = (el, sel) => el.querySelector(sel);\n      const treeCanvas = $('#tree-canvas');\n      const linksSVG = $('#links');\n      const arrayView = $('#array-view');\n      const logEl = $('#log');\n\n      // Controls\n      const inputVal = $('#value-input');\n      const insertBtn = $('#insert-btn');\n      const extractBtn = $('#extract-btn');\n      const buildBtn = $('#build-btn');\n      const arrayInput = $('#array-input');\n      const randomBtn = $('#random-btn');\n      const modeSelect = $('#mode-select');\n      const speedRange = $('#speed-range');\n      const stepToggle = $('#step-toggle');\n      const nextStepBtn = $('#next-step');\n      const peekBtn = $('#peek-btn');\n      const clearBtn = $('#clear-btn');\n\n      // Config\n      let mode = 'min'; // 'min' or 'max'\n      let delay = Number(speedRange.value); // ms\n      let stepMode = false;\n      let awaitingStep = null;\n\n      // Data model: array of {value:number, el:HTMLElement}\n      let heap = [];\n\n      // Animation control\n      let animTicker = null;\n      let animActive = false;\n\n      // Accessibility: announce to log\n      function log(text, strong) {\n        const entry = document.createElement('div');\n        entry.className = 'entry';\n        entry.innerHTML = strong ? `<strong>${strong}</strong> ${text}` : text;\n        logEl.prepend(entry);\n      }\n\n      // Comparator\n      function cmp(a, b){\n        if (mode === 'min') return a < b;\n        return a > b;\n      }\n\n      // Create node element for a value\n      function createNode(value){\n        const node = document.createElement('div');\n        node.className = 'node';\n        node.setAttribute('role','img');\n        node.setAttribute('aria-label','Heap node value '+String(value));\n        node.innerHTML = `<span class=\"val\">${value}</span><span class=\"idx\">0</span>`;\n        treeCanvas.appendChild(node);\n        // transitions are CSS based: left/top are set in positioning\n        return node;\n      }\n\n      // Layout calculation: position nodes by index\n      function computePosition(index, totalWidth, totalHeight){\n        // level of node:\n        const level = Math.floor(Math.log2(index+1));\n        const levelStart = (1<<level)-1;\n        const posInLevel = index - levelStart;\n        const nodesInLevel = 1<<level;\n        const paddingX = 40;\n        const availableWidth = Math.max(100, totalWidth - paddingX*2);\n        const x = paddingX + (posInLevel + 1) * (availableWidth / (nodesInLevel + 1));\n        const levelGap = Math.max(72, (totalHeight - 60) / Math.max(3, Math.ceil(Math.log2(heap.length+1))));\n        const y = 30 + level * levelGap;\n        return {x, y};\n      }\n\n      // Render positions of all nodes; animate via CSS transitions on left/top\n      function renderPositions(animate=true){\n        const rect = treeCanvas.getBoundingClientRect();\n        const w = rect.width;\n        const h = rect.height;\n        heap.forEach((item, idx) => {\n          const pos = computePosition(idx, w, h);\n          const el = item.el;\n          el.style.left = pos.x + 'px';\n          el.style.top = pos.y + 'px';\n          const idxLabel = el.querySelector('.idx');\n          if (idxLabel) idxLabel.textContent = idx;\n          el.querySelector('.val').textContent = item.value;\n          // Mark min/max via class\n          el.classList.toggle('min', mode === 'min');\n          el.classList.toggle('max', mode === 'max');\n        });\n        updateLinks();\n        // set running ticker while transitions are active\n        if (animate){\n          startAnimTicker();\n        }\n        renderArray();\n      }\n\n      // Draw connecting lines using SVG between parent and child centers\n      function updateLinks(){\n        const svg = linksSVG;\n        while(svg.firstChild) svg.removeChild(svg.firstChild);\n        const rect = treeCanvas.getBoundingClientRect();\n        const offset = {left: treeCanvas.offsetLeft, top: treeCanvas.offsetTop};\n        // We need coordinates relative to svg\n        heap.forEach((item, idx) => {\n          const left = item.el.offsetLeft + (item.el.offsetWidth/2);\n          const top = item.el.offsetTop + (item.el.offsetHeight/2);\n          const leftRel = left;\n          const topRel = top;\n          const leftChildIdx = 2*idx + 1;\n          const rightChildIdx = 2*idx + 2;\n          [leftChildIdx, rightChildIdx].forEach(ci => {\n            if (ci < heap.length){\n              const child = heap[ci];\n              const childLeft = child.el.offsetLeft + (child.el.offsetWidth/2);\n              const childTop = child.el.offsetTop + (child.el.offsetHeight/2);\n              const line = document.createElementNS(\"http://www.w3.org/2000/svg\",\"line\");\n              line.setAttribute('x1', leftRel);\n              line.setAttribute('y1', topRel+18);\n              line.setAttribute('x2', childLeft);\n              line.setAttribute('y2', childTop-18);\n              line.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n              line.setAttribute('stroke-width', '2');\n              line.setAttribute('stroke-linecap','round');\n              svg.appendChild(line);\n            }\n          });\n        });\n      }\n\n      // Render array view\n      function renderArray(highlights){\n        // highlight is {i,j} or indices array\n        arrayView.innerHTML = '';\n        heap.forEach((item, idx) => {\n          const div = document.createElement('div');\n          div.className = 'arr-item';\n          if (highlights && highlights.includes(idx)) div.classList.add('highlight');\n          div.textContent = String(item.value);\n          const idxBadge = document.createElement('div');\n          idxBadge.className = 'idx';\n          idxBadge.textContent = idx;\n          div.appendChild(idxBadge);\n          arrayView.appendChild(div);\n        });\n      }\n\n      // Animation ticker updates links continuously while nodes move\n      function startAnimTicker(){\n        if (animActive) return;\n        animActive = true;\n        let last = performance.now();\n        const tick = (t) => {\n          updateLinks();\n          const any = heap.some(it => {\n            // We'll approximate whether a transition is in progress by seeing transform style\n            // but simpler: keep a small timeout after start\n            return true;\n          });\n          // Keep ticker running for short while: stop after delay + 80ms\n          const now = performance.now();\n          if (now - last < delay + 120){\n            animTicker = requestAnimationFrame(tick);\n          } else {\n            animActive = false;\n            cancelAnimationFrame(animTicker);\n          }\n        };\n        animTicker = requestAnimationFrame(tick);\n      }\n\n      // Helpers for async stepping and delays\n      function wait(ms){\n        return new Promise(res => setTimeout(res, ms));\n      }\n\n      function stepPause(){\n        if (!stepMode) return wait(delay);\n        // Step mode: return promise that resolves when user clicks Next Step\n        return new Promise(res => {\n          awaitingStep = res;\n          nextStepBtn.disabled = false;\n          nextStepBtn.focus();\n        });\n      }\n\n      // Public control interactions\n      insertBtn.addEventListener('click', () => {\n        const v = inputVal.value.trim();\n        if (!v) return;\n        const num = Number(v);\n        if (!isFinite(num)){\n          log('Please enter a valid number');\n          return;\n        }\n        inputVal.value = '';\n        insertValue(num);\n      });\n      inputVal.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') insertBtn.click();\n      });\n\n      extractBtn.addEventListener('click', () => {\n        extractRoot();\n      });\n\n      buildBtn.addEventListener('click', async () => {\n        const raw = arrayInput.value.trim();\n        if (!raw) return;\n        const items = raw.split(',').map(s=>s.trim()).filter(Boolean).map(Number).filter(n=>isFinite(n));\n        if (!items.length) return;\n        await buildHeap(items);\n      });\n\n      randomBtn.addEventListener('click', async () => {\n        const size = Math.floor(Math.random()*7)+3;\n        const items = Array.from({length:size}, ()=>Math.floor(Math.random()*100));\n        arrayInput.value = items.join(',');\n        await buildHeap(items);\n      });\n\n      modeSelect.addEventListener('change', async () => {\n        mode = modeSelect.value;\n        log('Mode changed to '+mode.toUpperCase());\n        // Rebuild in new mode preserving values: heapify\n        await heapifyAnimated();\n      });\n\n      speedRange.addEventListener('input', () => {\n        delay = Number(speedRange.value);\n      });\n\n      stepToggle.addEventListener('click', () => {\n        stepMode = !stepMode;\n        stepToggle.textContent = stepMode ? 'On' : 'Off';\n        stepToggle.setAttribute('aria-pressed', String(stepMode));\n        nextStepBtn.disabled = !stepMode;\n        log('Step Mode ' + (stepMode ? 'enabled' : 'disabled'));\n      });\n\n      nextStepBtn.addEventListener('click', () => {\n        if (awaitingStep){\n          awaitingStep();\n          awaitingStep = null;\n          nextStepBtn.disabled = true;\n        }\n      });\n\n      peekBtn.addEventListener('click', () => {\n        if (!heap.length) { log('Heap is empty'); return; }\n        log('Root: ' + heap[0].value, 'Peek:');\n      });\n\n      clearBtn.addEventListener('click', () => {\n        clearHeap();\n      });\n\n      // Core heap operations with animated steps\n      async function insertValue(value){\n        const nodeEl = createNode(value);\n        const nodeObj = {value, el: nodeEl};\n        heap.push(nodeObj);\n        renderPositions();\n        log('Inserted ' + value, 'Insert:');\n        await wait(20);\n        // sift-up with animations\n        await siftUp(heap.length - 1);\n      }\n\n      async function extractRoot(){\n        if (!heap.length){\n          log('Heap is empty');\n          return;\n        }\n        const rootVal = heap[0].value;\n        log('Extracting root ' + rootVal, 'Extract:');\n        // replace root with last\n        if (heap.length === 1){\n          // remove node element\n          const lone = heap.pop();\n          lone.el.remove();\n          renderPositions();\n          return;\n        }\n        // swap 0 and last, then pop last (animate)\n        await highlightIndices([0, heap.length-1], 'highlight');\n        // swap items in array\n        swapItems(0, heap.length-1);\n        await stepPause();\n        renderPositions();\n        await wait(delay);\n        // remove last node element\n        const removed = heap.pop();\n        removed.el.remove();\n        renderPositions();\n        // sift-down new root\n        await siftDown(0);\n      }\n\n      // Swap helper (data model swap)\n      function swapItems(i,j){\n        const tmp = heap[i];\n        heap[i] = heap[j];\n        heap[j] = tmp;\n      }\n\n      // Highlight indices helper\n      async function highlightIndices(indices, cls='highlight'){\n        indices.forEach(i => {\n          if (heap[i]) heap[i].el.classList.add(cls);\n        });\n        renderArray(indices);\n        await wait(Math.min(200, delay));\n        indices.forEach(i => {\n          if (heap[i]) heap[i].el.classList.remove(cls);\n        });\n        renderArray();\n      }\n\n      // Sift-up from index i\n      async function siftUp(i){\n        let idx = i;\n        while (idx > 0){\n          const parent = Math.floor((idx-1)/2);\n          // highlight compare\n          heap[idx].el.classList.add('highlight');\n          heap[parent].el.classList.add('highlight');\n          renderArray([idx, parent]);\n          log(`Compare ${heap[idx].value} and parent ${heap[parent].value}`);\n          await stepPause();\n          // compare values\n          if (cmp(heap[idx].value, heap[parent].value)){\n            // swap\n            heap[idx].el.classList.add('swap');\n            heap[parent].el.classList.add('swap');\n            log(`Swap ${heap[idx].value} ↔ ${heap[parent].value}`, 'Swap:');\n            swapItems(idx, parent);\n            renderPositions();\n            await wait(delay);\n            heap[idx].el.classList.remove('swap');\n            heap[parent].el.classList.remove('swap');\n            // continue up\n            heap[idx].el.classList.remove('highlight');\n            heap[parent].el.classList.remove('highlight');\n            idx = parent;\n          } else {\n            // no swap, done\n            heap[idx].el.classList.remove('highlight');\n            heap[parent].el.classList.remove('highlight');\n            renderArray();\n            break;\n          }\n        }\n      }\n\n      // Sift-down from index i\n      async function siftDown(i){\n        let idx = i;\n        const n = () => heap.length;\n        while (true){\n          const left = 2*idx + 1;\n          const right = 2*idx + 2;\n          let chosen = idx;\n          if (left < n()){\n            // compare with left\n            heap[idx].el.classList.add('highlight');\n            heap[left].el.classList.add('highlight');\n            renderArray([idx,left]);\n            log(`Compare ${heap[idx].value} and left ${heap[left].value}`);\n            await stepPause();\n            if (cmp(heap[left].value, heap[chosen].value)) chosen = left;\n            heap[idx].el.classList.remove('highlight');\n            heap[left].el.classList.remove('highlight');\n          }\n          if (right < n()){\n            heap[chosen].el.classList.add('highlight');\n            heap[right].el.classList.add('highlight');\n            renderArray([chosen,right]);\n            log(`Compare ${heap[chosen].value} and right ${heap[right].value}`);\n            await stepPause();\n            if (cmp(heap[right].value, heap[chosen].value)) chosen = right;\n            heap[chosen].el.classList.remove('highlight');\n            heap[right].el.classList.remove('highlight');\n          }\n          if (chosen !== idx){\n            heap[idx].el.classList.add('swap');\n            heap[chosen].el.classList.add('swap');\n            log(`Swap ${heap[idx].value} ↔ ${heap[chosen].value}`, 'Swap:');\n            swapItems(idx, chosen);\n            renderPositions();\n            await wait(delay);\n            heap[idx].el.classList.remove('swap');\n            heap[chosen].el.classList.remove('swap');\n            idx = chosen;\n          } else break;\n        }\n      }\n\n      // Heapify (build-heap) animated: perform sift-down from last non-leaf down to 0\n      async function buildHeap(values){\n        // clear current\n        clearHeap(false);\n        // create nodes\n        values.forEach(v => {\n          const el = createNode(v);\n          heap.push({value:v, el});\n        });\n        renderPositions();\n        log('Building heap from array', 'Build:');\n        // perform sift-down from floor(n/2)-1 down to 0\n        const start = Math.floor(heap.length/2) - 1;\n        for (let i = start; i >= 0; i--){\n          log(`Sift-down at index ${i}`, 'Heapify:');\n          await siftDown(i);\n        }\n        renderPositions();\n        log('Build complete');\n      }\n\n      async function heapifyAnimated(){\n        // rebuild current values in new mode\n        const values = heap.map(h => h.value);\n        await buildHeap(values);\n      }\n\n      function clearHeap(logIt=true){\n        heap.forEach(it => it.el.remove());\n        heap = [];\n        renderArray();\n        if (logIt) log('Cleared heap');\n      }\n\n      // Initial render\n      renderPositions();\n\n      // Responsive: reposition nodes on resize\n      window.addEventListener('resize', () => renderPositions(false));\n\n      // Initialize with a sample\n      (async function initSample(){\n        const sample = [42,31,28,10,18,15,7];\n        arrayInput.value = sample.join(',');\n        await buildHeap(sample);\n      })();\n\n      // Expose some internals for debugging (not required)\n      window.HeapViz = {\n        insertValue, extractRoot, buildHeap, clearHeap, heapRef: heap\n      };\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Heap (Min/Max).\n\n**Project Overview:**\nTopic: Heap (Min/Max)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Heap (Min/Max)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "611b7f30-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:45:03.269Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Hash Table",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Hash Table (Separate Chaining)</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --accent: #2563eb;\n      --muted: #6b7280;\n      --bg: #f8fafc;\n      --card: #ffffff;\n      --success: #16a34a;\n      --danger: #dc2626;\n      --yellow: #f59e0b;\n      --shadow: 0 6px 18px rgba(16,24,40,0.06);\n      --area-radius: 12px;\n    }\n    /* Safe area margins */\n    html,body{\n      height:100%;\n      margin:0;\n      background:linear-gradient(180deg,#f8fafc,#eef2ff);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      color: #0f172a;\n      -webkit-font-smoothing:antialiased;\n    }\n    body{\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n    }\n\n    /* Layout container */\n    .container{\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      justify-content:space-between;\n      max-width:1200px;\n      margin:0 auto;\n    }\n\n    /* Sidebar (controls + descriptions) */\n    .sidebar{\n      width:360px;\n      min-width:280px;\n      background:var(--card);\n      border-radius:var(--area-radius);\n      padding:20px;\n      box-shadow:var(--shadow);\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    .title{\n      font-size:20px;\n      font-weight:600;\n      display:flex;\n      align-items:center;\n      gap:10px;\n    }\n    .subtitle{\n      color:var(--muted);\n      font-size:13px;\n      margin-top:2px;\n    }\n\n    /* Controls */\n    .controls{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    label{font-size:13px;color:#0f172a;}\n    input[type=\"text\"], input[type=\"number\"], select{\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid #e6edf3;\n      font-size:14px;\n      outline:none;\n    }\n    input[type=\"number\"]{width:120px;}\n    .row{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .btn{\n      background:var(--accent);\n      color:white;\n      border:none;\n      padding:10px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      font-size:14px;\n      transition:transform .12s ease, box-shadow .12s ease;\n    }\n    .btn:active{transform:translateY(1px);}\n    .btn.secondary{\n      background:#e6eefb;\n      color:var(--accent);\n      font-weight:600;\n    }\n    .btn.warn{\n      background:var(--yellow);\n      color:#082032;\n    }\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* Visualization area */\n    .visual{\n      flex:1;\n      min-width:420px;\n      background:linear-gradient(180deg,#ffffff,#fbfdff);\n      border-radius:var(--area-radius);\n      padding:20px;\n      box-shadow:var(--shadow);\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      align-items:stretch;\n    }\n    .vis-header{\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:var(--gap);\n    }\n    .metrics{\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n    .metric{\n      background:#f8fafc;\n      border-radius:10px;\n      padding:8px 12px;\n      font-size:13px;\n      color:#0f172a;\n    }\n\n    /* Table of buckets */\n    .table-area{\n      display:flex;\n      gap:16px;\n      align-items:flex-start;\n      overflow:auto;\n      padding-bottom:6px;\n    }\n    .bucket{\n      min-width:120px;\n      background:linear-gradient(180deg,#ffffff,#f8fafc);\n      border-radius:10px;\n      border:1px solid #e6eefb;\n      padding:10px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:10px;\n      align-items:center;\n      position:relative;\n    }\n    .bucket-index{\n      width:36px;\n      height:36px;\n      border-radius:8px;\n      background:#eef2ff;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:700;\n      color:var(--accent);\n      font-size:13px;\n    }\n    .chain{\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      min-height:40px;\n      align-items:center;\n      width:100%;\n    }\n    .node{\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n      padding:8px 10px;\n      border-radius:999px;\n      background:linear-gradient(90deg,#eef2ff,#f1f5f9);\n      border:1px solid #dbeafe;\n      font-weight:600;\n      color:#04263b;\n      box-shadow:0 6px 14px rgba(16,24,40,0.04);\n      transform-origin:center;\n      transition:transform .25s ease, box-shadow .2s ease, opacity .2s ease;\n    }\n    .node.small{padding:6px 8px;font-size:13px;}\n    .node .del{\n      background:transparent;\n      border:none;\n      color:var(--danger);\n      margin-left:6px;\n      cursor:pointer;\n      font-weight:700;\n      font-size:13px;\n    }\n\n    /* Highlights and animations */\n    .bucket.highlight{\n      box-shadow:0 6px 20px rgba(37,99,235,0.12);\n      border-color:rgba(37,99,235,0.3);\n    }\n    .node.highlight{\n      transform:scale(1.06);\n      box-shadow:0 10px 24px rgba(37,99,235,0.12);\n    }\n    .node.found{\n      background:linear-gradient(90deg,#dcfce7,#bbf7d0);\n      border:1px solid rgba(16,185,129,0.2);\n      color:#064e3b;\n    }\n    .node.removing{\n      opacity:0.2;\n      transform:scale(.9) rotate(-6deg);\n    }\n\n    /* moving clone used for animation (absolute) */\n    .moving-clone{\n      position:fixed;\n      z-index:40;\n      pointer-events:none;\n      transition:transform .6s cubic-bezier(.2,.9,.2,1), opacity .2s ease;\n      will-change:transform, opacity;\n    }\n\n    /* Explanation panel */\n    .explain{\n      background:#ffffff;\n      padding:12px;\n      border-radius:10px;\n      border:1px solid #eef2ff;\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* Responsive: stack on narrow screens */\n    @media (max-width:1000px){\n      .container{flex-direction:column;}\n      .sidebar{width:100%;}\n      .visual{min-width:unset;}\n    }\n\n    /* Ensure minimum spacing between interactive elements */\n    .controls > * { margin-bottom: 16px; }\n    .row > * { margin-bottom: 0; }\n\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"main\">\n    <aside class=\"sidebar\" aria-label=\"Controls and description\">\n      <div>\n        <div class=\"title\" id=\"concept-title\">Hash Table — Separate Chaining</div>\n        <div class=\"subtitle\">Visual, step-by-step operations: insert, search, delete and collisions</div>\n      </div>\n\n      <div class=\"controls\" aria-live=\"polite\">\n        <div>\n          <label for=\"key-input\">Key (string or number)</label>\n          <input id=\"key-input\" type=\"text\" placeholder=\"e.g., apple or 42\" aria-label=\"Key input\" />\n        </div>\n\n        <div class=\"row\" aria-hidden=\"false\">\n          <div>\n            <label for=\"table-size\">Table Size (buckets)</label><br/>\n            <input id=\"table-size\" type=\"number\" min=\"2\" max=\"32\" value=\"8\" aria-label=\"Table size\" />\n          </div>\n          <div>\n            <label for=\"hash-select\">Hash Function</label><br/>\n            <select id=\"hash-select\" aria-label=\"Hash function\">\n              <option value=\"ascii\">ASCII sum mod size (default)</option>\n              <option value=\"firstchar\">First char code mod size</option>\n              <option value=\"numeric\">Numeric mod size (for numbers)</option>\n            </select>\n          </div>\n        </div>\n\n        <div class=\"row\">\n          <button class=\"btn\" id=\"insert-btn\" aria-label=\"Insert key\">Insert</button>\n          <button class=\"btn secondary\" id=\"search-btn\" aria-label=\"Search key\">Search</button>\n          <button class=\"btn warn\" id=\"delete-btn\" aria-label=\"Delete key\">Delete</button>\n        </div>\n\n        <div class=\"row\">\n          <button class=\"btn secondary\" id=\"reset-btn\" aria-label=\"Reset table\">Reset Table</button>\n          <button class=\"btn secondary\" id=\"random-btn\" aria-label=\"Fill random keys\">Fill Random</button>\n        </div>\n\n        <div class=\"explain\" id=\"learning-objective\" aria-label=\"Learning Objective\">\n          <strong>Learning objective</strong>\n          <div style=\"margin-top:8px;\">\n            After interacting, you will understand how hashing maps keys to bucket indices, how collisions are handled using separate chaining (linked lists per bucket), and how insertion, search, and deletion traverse and update chains visually.\n          </div>\n        </div>\n\n        <div class=\"explain\" style=\"font-size:13px;\" aria-hidden=\"false\">\n          <strong>Interaction tips</strong>\n          <ul style=\"margin:8px 0 0 18px; color:var(--muted);\">\n            <li>Type a key and click Insert to add it.</li>\n            <li>Click Search to animate scanning the chain.</li>\n            <li>Click Delete to remove the first matching key in the chain.</li>\n            <li>Change table size to see distribution differences (reset clears table).</li>\n          </ul>\n        </div>\n\n        <div aria-live=\"polite\" id=\"status\" class=\"muted\" style=\"margin-top:4px;\">Ready.</div>\n      </div>\n    </aside>\n\n    <section class=\"visual\" aria-label=\"Hash Table Visualization\">\n      <div class=\"vis-header\">\n        <div style=\"display:flex;flex-direction:column;\">\n          <div style=\"font-weight:700;\">Buckets (index → chain)</div>\n          <div class=\"muted\" style=\"margin-top:6px; font-size:13px;\">Separate chaining: nodes appended at head (new items at top)</div>\n        </div>\n\n        <div class=\"metrics\" aria-hidden=\"false\">\n          <div class=\"metric\" id=\"metric-load\">Load: 0</div>\n          <div class=\"metric\" id=\"metric-size\">Size: 8</div>\n          <div class=\"metric\" id=\"metric-collisions\">Collisions: 0</div>\n        </div>\n      </div>\n\n      <div class=\"table-area\" id=\"table-area\" tabindex=\"0\" aria-label=\"Hash table buckets\">\n        <!-- buckets injected here -->\n      </div>\n\n      <div class=\"explain\" id=\"interaction-design\" aria-label=\"Interaction Design\">\n        <strong>Interaction design</strong>\n        <ol style=\"margin:8px 0 0 18px; color:var(--muted);\">\n          <li>Insert: computes hash → highlights target bucket → animates key moving into chain. If chain non-empty, collision counter increments.</li>\n          <li>Search: computes hash → highlights bucket → steps through each node with brief highlight (simulating traversal). Match highlights green.</li>\n          <li>Delete: finds first match in chain, animates removal and adjusts chain. Shows message if not found.</li>\n        </ol>\n      </div>\n    </section>\n  </div>\n\n  <script>\n    // Interactive Hash Table (Separate Chaining) - Vanilla JS implementation\n    (function(){\n      // Configuration & state\n      const state = {\n        size: 8,\n        buckets: [], // array of arrays (chains), newest inserted at top (unshift)\n        load: 0\n      };\n\n      // Elements\n      const keyInput = document.getElementById('key-input');\n      const tableSizeInput = document.getElementById('table-size');\n      const hashSelect = document.getElementById('hash-select');\n      const insertBtn = document.getElementById('insert-btn');\n      const searchBtn = document.getElementById('search-btn');\n      const deleteBtn = document.getElementById('delete-btn');\n      const resetBtn = document.getElementById('reset-btn');\n      const randomBtn = document.getElementById('random-btn');\n\n      const tableArea = document.getElementById('table-area');\n      const status = document.getElementById('status');\n      const metricLoad = document.getElementById('metric-load');\n      const metricSize = document.getElementById('metric-size');\n      const metricCollisions = document.getElementById('metric-collisions');\n\n      // Accessibility: ensure keyboard controls\n      keyInput.addEventListener('keyup', (e) => {\n        if (e.key === 'Enter') insertBtn.focus();\n      });\n\n      // Initialize\n      function initTable(size){\n        state.size = size;\n        state.buckets = Array.from({length:size}, ()=>[]);\n        state.load = 0;\n        render();\n        updateMetrics();\n      }\n      initTable(state.size);\n\n      // Hash functions\n      function hashKey(key){\n        const size = state.size;\n        const mode = hashSelect.value;\n        if (mode === 'numeric' && !isNaN(Number(key))){\n          return (Number(key) % size + size) % size;\n        }\n        if (mode === 'firstchar'){\n          const ch = String(key)[0] || '';\n          return (ch.charCodeAt(0) || 0) % size;\n        }\n        // default: ascii sum\n        const s = String(key);\n        let sum = 0;\n        for (let i=0;i<s.length;i++){ sum += s.charCodeAt(i); }\n        return sum % size;\n      }\n\n      // Rendering buckets\n      function render(){\n        tableArea.innerHTML = '';\n        for (let i=0;i<state.size;i++){\n          const bucket = document.createElement('div');\n          bucket.className = 'bucket';\n          bucket.dataset.index = i;\n          bucket.setAttribute('role','group');\n          bucket.setAttribute('aria-label','Bucket '+i);\n\n          const idx = document.createElement('div');\n          idx.className = 'bucket-index';\n          idx.textContent = i;\n\n          const chain = document.createElement('div');\n          chain.className = 'chain';\n          chain.dataset.index = i;\n\n          // populate nodes (newest on top)\n          state.buckets[i].forEach((val, j) => {\n            const node = document.createElement('div');\n            node.className = 'node small';\n            node.setAttribute('tabindex','0');\n            node.setAttribute('role','button');\n            node.setAttribute('aria-label', 'Key ' + val);\n            node.textContent = val;\n\n            const del = document.createElement('button');\n            del.className = 'del';\n            del.title = 'Delete this key';\n            del.textContent = '×';\n            del.addEventListener('click', (e)=>{\n              e.stopPropagation();\n              performDelete(val, i, /*direct*/ true);\n            });\n            node.appendChild(del);\n            chain.appendChild(node);\n          });\n\n          bucket.appendChild(idx);\n          bucket.appendChild(chain);\n          tableArea.appendChild(bucket);\n        }\n      }\n\n      // Metrics\n      function updateMetrics(){\n        metricLoad.textContent = 'Load: '+ state.load;\n        metricSize.textContent = 'Size: '+ state.size;\n        const collisions = state.buckets.reduce((acc, chain) => acc + Math.max(0, chain.length - 1), 0);\n        metricCollisions.textContent = 'Collisions: '+ collisions;\n      }\n\n      // Utility: create a moving clone to animate from input to target\n      function animateMove(text, targetElem, callback){\n        // create clone element\n        const rectStart = keyInput.getBoundingClientRect();\n        const clone = document.createElement('div');\n        clone.className = 'node moving-clone';\n        clone.style.padding = '10px 12px';\n        clone.style.borderRadius = '12px';\n        clone.style.background = 'linear-gradient(90deg,#eef2ff,#f1f5f9)';\n        clone.style.fontWeight = '700';\n        clone.style.left = rectStart.left + 'px';\n        clone.style.top = rectStart.top + 'px';\n        clone.style.opacity = '1';\n        clone.textContent = text;\n        document.body.appendChild(clone);\n\n        // compute target position\n        const rectEnd = targetElem.getBoundingClientRect();\n        const dx = rectEnd.left + rectEnd.width/2 - (rectStart.left + rectStart.width/2);\n        const dy = rectEnd.top + rectEnd.height/2 - (rectStart.top + rectStart.height/2);\n\n        // apply translate\n        requestAnimationFrame(() => {\n          clone.style.transform = `translate(${dx}px, ${dy}px) scale(0.92)`;\n          clone.style.transition = 'transform .6s cubic-bezier(.2,.9,.2,1), opacity .2s linear';\n        });\n\n        // cleanup after animation\n        setTimeout(()=>{\n          clone.style.opacity = '0';\n          setTimeout(()=>{ try{ document.body.removeChild(clone); }catch(e){}; if (callback) callback(); }, 180);\n        }, 650);\n      }\n\n      // Helpers to highlight bucket and nodes\n      function highlightBucket(idx, duration=800){\n        const bucket = tableArea.querySelector(`.bucket[data-index=\"${idx}\"]`);\n        if (!bucket) return;\n        bucket.classList.add('highlight');\n        setTimeout(()=> bucket.classList.remove('highlight'), duration);\n      }\n      function highlightNode(elem, cls='highlight', duration=500){\n        elem.classList.add(cls);\n        setTimeout(()=> elem.classList.remove(cls), duration);\n      }\n\n      // Insert operation\n      function performInsert(key){\n        if (key === '') {\n          setStatus('Please enter a key to insert.', true);\n          return;\n        }\n        const index = hashKey(key);\n        setStatus(`Hashing key -> bucket ${index}. Inserting...`);\n        highlightBucket(index, 700);\n\n        // animate movement then update data\n        const bucketChainElem = tableArea.querySelector(`.bucket[data-index=\"${index}\"] .chain`);\n        animateMove(key, bucketChainElem, ()=>{\n          // Prepend item to chain (unshift => newest at top)\n          state.buckets[index].unshift(String(key));\n          state.load++;\n          render();\n          updateMetrics();\n          setStatus(`Inserted \"${key}\" into bucket ${index}.`);\n        });\n      }\n\n      // Search operation: animate traversal through chain\n      function performSearch(key){\n        if (key === '') {\n          setStatus('Please enter a key to search.', true);\n          return;\n        }\n        const index = hashKey(key);\n        setStatus(`Searching bucket ${index}...`);\n        highlightBucket(index, 900);\n        const chainElems = tableArea.querySelectorAll(`.bucket[data-index=\"${index}\"] .chain .node`);\n        if (chainElems.length === 0){\n          setTimeout(()=> setStatus(`Bucket ${index} empty. \"${key}\" not found.`, true), 450);\n          return;\n        }\n        // step through nodes with delay\n        let found = false;\n        let i = 0;\n        function step(){\n          if (i >= chainElems.length){\n            if (!found) setStatus(`\"${key}\" not found in bucket ${index}.`, true);\n            return;\n          }\n          const node = chainElems[i];\n          highlightNode(node, 'highlight', 600);\n          const val = node.firstChild && node.firstChild.nodeValue ? node.firstChild.nodeValue.trim() : node.textContent.trim();\n          if (val === String(key)){\n            // found\n            setTimeout(()=> {\n              node.classList.add('found');\n              setStatus(`Found \"${key}\" at bucket ${index}, position ${i}.`);\n            }, 300);\n            found = true;\n            // remove highlight after a bit\n            setTimeout(()=> node.classList.remove('found'), 900);\n            return;\n          }\n          i++;\n          setTimeout(step, 650);\n        }\n        setTimeout(step, 200);\n      }\n\n      // Delete operation\n      function performDelete(key, expectedBucket=null, direct=false){\n        if (!direct && key === '') {\n          setStatus('Please enter a key to delete.', true);\n          return;\n        }\n        const index = expectedBucket !== null ? expectedBucket : hashKey(key);\n        setStatus(`Attempting delete in bucket ${index}...`);\n        highlightBucket(index, 700);\n\n        const chain = state.buckets[index];\n        // find index of first matching element\n        const matchIdx = chain.findIndex(v => v === String(key));\n        if (matchIdx === -1){\n          // if direct deletion via delete button provided the value (direct true) then key param was already provided\n          if (direct){\n            // find using provided key param\n            const k = key;\n            const foundAt = chain.findIndex(v => v === String(k));\n            if (foundAt === -1){ setStatus(`\"${k}\" not found in bucket ${index}.`, true); return; }\n          } else {\n            setTimeout(()=> setStatus(`\"${key}\" not found in bucket ${index}.`, true), 300);\n            return;\n          }\n        }\n\n        // animate removal of element DOM node\n        const chainElems = tableArea.querySelectorAll(`.bucket[data-index=\"${index}\"] .chain .node`);\n        // if direct and called from delete button, key param is specific; recompute position\n        let removePos = matchIdx;\n        if (direct){\n          removePos = chain.findIndex(v => v === String(key));\n        }\n        const targetNode = chainElems[removePos];\n        if (targetNode){\n          targetNode.classList.add('removing');\n          setTimeout(()=>{\n            // remove from state\n            const removed = chain.splice(removePos, 1);\n            if (removed.length) state.load--;\n            render();\n            updateMetrics();\n            setStatus(`Deleted \"${removed[0]}\" from bucket ${index}.`);\n          }, 420);\n        } else {\n          // fallback: just update state\n          const removed = chain.splice(removePos, 1);\n          if (removed.length) state.load--;\n          render();\n          updateMetrics();\n          setStatus(`Deleted \"${removed[0]}\" from bucket ${index}.`);\n        }\n      }\n\n      // Set status message\n      function setStatus(msg, warn=false){\n        status.textContent = msg;\n        status.style.color = warn ? 'var(--danger)' : '#0f172a';\n      }\n\n      // Reset and random fill\n      function resetTable(){\n        const newSize = Math.max(2, Math.min(32, Number(tableSizeInput.value) || 8));\n        tableSizeInput.value = newSize;\n        initTable(newSize);\n        setStatus('Table reset.');\n      }\n\n      function fillRandom(){\n        resetTable();\n        const samples = ['apple','banana','pear','cherry','dog','cat','42','84','xyz','alpha','beta','gamma','delta'];\n        const count = Math.min(12, Math.floor(state.size * 1.2));\n        for (let i=0;i<count;i++){\n          const s = samples[Math.floor(Math.random()*samples.length)] + (Math.random() < 0.5 ? '' : Math.floor(Math.random()*100));\n          const idx = hashKey(s);\n          state.buckets[idx].unshift(s);\n          state.load++;\n        }\n        render();\n        updateMetrics();\n        setStatus(`Filled with ${count} random keys.`);\n      }\n\n      // Event listeners\n      insertBtn.addEventListener('click', ()=>{\n        const key = keyInput.value.trim();\n        performInsert(key);\n      });\n\n      searchBtn.addEventListener('click', ()=>{\n        const key = keyInput.value.trim();\n        performSearch(key);\n      });\n\n      deleteBtn.addEventListener('click', ()=>{\n        const key = keyInput.value.trim();\n        performDelete(key);\n      });\n\n      resetBtn.addEventListener('click', resetTable);\n      randomBtn.addEventListener('click', fillRandom);\n\n      tableSizeInput.addEventListener('change', ()=>{\n        const v = Number(tableSizeInput.value);\n        if (isNaN(v) || v < 2 || v > 32){\n          setStatus('Table size must be between 2 and 32.', true);\n          tableSizeInput.value = state.size;\n          return;\n        }\n        // Changing size resets table to avoid complex rehash operations (teaching simplification)\n        initTable(v);\n        setStatus('Table size changed — table reset.');\n      });\n\n      // Keyboard accessibility for table nodes (Enter to delete)\n      tableArea.addEventListener('keydown', (e)=>{\n        const target = e.target;\n        if (e.key === 'Enter' && target.classList.contains('node')){\n          const text = (target.firstChild && target.firstChild.nodeValue) ? target.firstChild.nodeValue.trim() : target.textContent.trim();\n          performDelete(text, Number(target.closest('.bucket').dataset.index), true);\n        }\n      });\n\n      // Initial sample\n      fillRandom();\n\n      // Expose for debugging (optional)\n      window.__ht_state = state;\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Hash Table.\n\n**Project Overview:**\nTopic: Hash Table\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Hash Table"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Hash Table (Separate Chaining)",
      "description": "Models the interactive states and transitions of a visual hash table demo supporting insert, search, delete, reset, random fill, and table-size changes with animated highlights and transitions.",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "CLICK_INSERT": "inserting",
            "CLICK_SEARCH": "searching",
            "CLICK_DELETE": "deleting",
            "NODE_DELETE_CLICK": "deleting",
            "KEYBOARD_NODE_DELETE": "deleting",
            "CLICK_RESET": "resetting",
            "CLICK_RANDOM": "filling_random",
            "CHANGE_TABLE_SIZE": "resetting",
            "INPUT_ENTER": "noop"
          }
        },
        {
          "name": "inserting",
          "onEnter": "computeHash_highlightBucket_animateMove",
          "onExit": "render_updateMetrics_setStatus",
          "on": {
            "ANIMATION_MOVE_END": "idle",
            "INVALID_INPUT": "idle",
            "ANIMATION_ERROR": "idle"
          }
        },
        {
          "name": "searching",
          "onEnter": "computeHash_highlightBucket_stepThroughNodes",
          "onExit": "clearHighlights",
          "on": {
            "SEARCH_FOUND": "found",
            "SEARCH_NOT_FOUND": "not_found",
            "SEARCH_EMPTY_BUCKET": "not_found",
            "INVALID_INPUT": "idle"
          }
        },
        {
          "name": "found",
          "onEnter": "highlightNode_found_setStatus",
          "onExit": "clearFoundHighlight",
          "on": {
            "FOUND_COMPLETE": "idle",
            "FOUND_TIMEOUT": "idle"
          }
        },
        {
          "name": "not_found",
          "onEnter": "setStatusNotFound",
          "onExit": "noop",
          "on": {
            "NOT_FOUND_ACK": "idle"
          }
        },
        {
          "name": "deleting",
          "onEnter": "computeHash_highlightBucket_markRemoving",
          "onExit": "render_updateMetrics_setStatus",
          "on": {
            "DELETE_ANIMATION_END": "idle",
            "DELETE_NOT_FOUND": "idle",
            "INVALID_INPUT": "idle"
          }
        },
        {
          "name": "resetting",
          "onEnter": "validateSize_initTable_render_updateMetrics_setStatus",
          "onExit": "noop",
          "on": {
            "RESET_COMPLETE": "idle",
            "SIZE_INVALID": "idle"
          }
        },
        {
          "name": "filling_random",
          "onEnter": "resetTable_populateChains_render_updateMetrics_setStatus",
          "onExit": "noop",
          "on": {
            "FILL_COMPLETE": "idle"
          }
        }
      ],
      "events": [
        "CLICK_INSERT",
        "CLICK_SEARCH",
        "CLICK_DELETE",
        "NODE_DELETE_CLICK",
        "KEYBOARD_NODE_DELETE",
        "CLICK_RESET",
        "CLICK_RANDOM",
        "CHANGE_TABLE_SIZE",
        "INPUT_ENTER",
        "ANIMATION_MOVE_END",
        "ANIMATION_ERROR",
        "SEARCH_FOUND",
        "SEARCH_NOT_FOUND",
        "SEARCH_EMPTY_BUCKET",
        "FOUND_COMPLETE",
        "FOUND_TIMEOUT",
        "NOT_FOUND_ACK",
        "DELETE_ANIMATION_END",
        "DELETE_NOT_FOUND",
        "RESET_COMPLETE",
        "FILL_COMPLETE",
        "SIZE_INVALID",
        "INVALID_INPUT"
      ],
      "notes": "This FSM models user-triggered operations and the transient animated/timeout-driven steps used by the demo. onEnter actions describe sequences invoked when entering a state (e.g., compute hash, highlight bucket, animate move, step through nodes, mark node removing). Many transitions are driven by timeouts or animation callbacks (represented as ANIMATION_MOVE_END, DELETE_ANIMATION_END, SEARCH_FOUND/SEARCH_NOT_FOUND). INVALID_INPUT and SIZE_INVALID represent early-return checks (empty key or invalid table size). Rendering and metrics updates occur on exits of mutating states (inserting, deleting, resetting, filling_random)."
    }
  },
  {
    "id": "82996910-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:45:10.049Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Linked List",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Linked List Interactive Module</title>\n  <style>\n    /* Safe area margins: 24px on all sides */\n    :root {\n      --safe-margin: 24px;\n      --gap: 16px; /* minimum spacing between interactive elements */\n      --node-w: 90px;\n      --node-h: 56px;\n      --accent: #0366d6;\n      --muted: #6b7280;\n      --bg: #f8fafc;\n      --card: #ffffff;\n      --danger: #d73a49;\n      --success: #16a34a;\n      --shadow: 0 6px 18px rgba(16,24,40,0.08);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n\n    html, body {\n      height: 100%;\n      margin: 0;\n      background: linear-gradient(180deg, #f7f9fc 0%, var(--bg) 100%);\n      color: #0f172a;\n    }\n\n    .app {\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height: 100vh;\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n    }\n\n    header {\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n      max-width: 1100px;\n      margin: 0 auto;\n    }\n\n    h1 {\n      font-size: 1.25rem;\n      margin: 0;\n      color: #051126;\n    }\n\n    p.lead {\n      margin: 0;\n      color: var(--muted);\n      font-size: 0.95rem;\n    }\n\n    main.module {\n      margin: 0 auto;\n      width: 100%;\n      max-width: 1100px;\n      display: grid;\n      grid-template-columns: 360px 1fr;\n      gap: calc(var(--gap) * 1.5);\n      align-items: start;\n    }\n\n    /* Responsive: stack on small screens */\n    @media (max-width: 880px) {\n      main.module {\n        grid-template-columns: 1fr;\n      }\n    }\n\n    /* Left column: description and controls */\n    .panel {\n      background: var(--card);\n      border-radius: 12px;\n      box-shadow: var(--shadow);\n      padding: 18px;\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n      min-height: 220px;\n    }\n\n    .section-title {\n      font-weight: 600;\n      font-size: 0.95rem;\n      color: #0b1220;\n    }\n\n    .small {\n      font-size: 0.9rem;\n      color: var(--muted);\n      line-height: 1.4;\n    }\n\n    .controls {\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n    }\n\n    .row {\n      display: flex;\n      gap: var(--gap);\n      align-items: center;\n    }\n\n    .row.wrap {\n      flex-wrap: wrap;\n    }\n\n    label {\n      font-size: 0.85rem;\n      color: var(--muted);\n    }\n\n    input[type=\"number\"],\n    input[type=\"text\"] {\n      padding: 10px 12px;\n      border-radius: 8px;\n      border: 1px solid #e6edf3;\n      background: #fff;\n      outline: none;\n      font-size: 0.95rem;\n      color: #021124;\n      min-width: 0;\n    }\n\n    input[type=\"number\"]:focus,\n    input[type=\"text\"]:focus {\n      border-color: rgba(3,102,214,0.35);\n      box-shadow: 0 4px 10px rgba(3,102,214,0.08);\n    }\n\n    .btn {\n      appearance: none;\n      border: none;\n      background: var(--accent);\n      color: #fff;\n      padding: 10px 12px;\n      border-radius: 8px;\n      font-weight: 600;\n      cursor: pointer;\n      box-shadow: 0 6px 12px rgba(3,102,214,0.12);\n      transition: transform 120ms ease, box-shadow 120ms ease;\n    }\n\n    .btn:hover { transform: translateY(-2px); }\n    .btn:active { transform: translateY(0); }\n\n    .btn.secondary {\n      background: #eef2ff;\n      color: var(--accent);\n      box-shadow: none;\n      font-weight: 600;\n      border: 1px solid rgba(3,102,214,0.08);\n    }\n\n    .btn.danger {\n      background: var(--danger);\n      box-shadow: none;\n    }\n\n    .control-grid {\n      display: grid;\n      grid-template-columns: repeat(2,1fr);\n      gap: var(--gap);\n    }\n\n    @media (max-width: 520px) {\n      .control-grid { grid-template-columns: 1fr; }\n    }\n\n    .hint {\n      font-size: 0.85rem;\n      color: var(--muted);\n    }\n\n    /* Right column: visualization */\n    .vis {\n      background: linear-gradient(180deg, rgba(255,255,255,0.9), #fff);\n      border-radius: 12px;\n      padding: 18px;\n      box-shadow: var(--shadow);\n      min-height: 420px;\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n      overflow: hidden;\n    }\n\n    .vis-top {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      gap: var(--gap);\n    }\n\n    .status {\n      font-size: 0.92rem;\n      color: var(--muted);\n    }\n\n    .canvas-wrap {\n      position: relative;\n      flex: 1;\n      min-height: 260px;\n      border-radius: 8px;\n      background: linear-gradient(180deg, #fbfdff, #ffffff);\n      border: 1px solid #eef3f8;\n      padding: 16px;\n      overflow: auto;\n    }\n\n    /* Node styles */\n    .nodes {\n      display: flex;\n      gap: 32px; /* visual spacing between nodes horizontally */\n      align-items: center;\n      min-height: var(--node-h);\n      transition: height 220ms ease;\n      padding-bottom: 6px;\n    }\n\n    .node {\n      width: var(--node-w);\n      height: var(--node-h);\n      border-radius: 10px;\n      background: linear-gradient(180deg, #ffffff, #fcfdff);\n      border: 1px solid #e6eef8;\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      justify-content: center;\n      position: relative;\n      box-shadow: 0 6px 18px rgba(10,20,40,0.04);\n      transition: transform 240ms cubic-bezier(.2,.9,.2,1), opacity 240ms ease;\n      flex-shrink: 0;\n    }\n\n    .node-value {\n      font-weight: 700;\n      color: #06202b;\n      font-size: 1rem;\n      user-select: none;\n    }\n\n    .node-index {\n      position: absolute;\n      top: -12px;\n      right: -10px;\n      background: #f1f5f9;\n      color: var(--muted);\n      font-size: 0.72rem;\n      padding: 4px 6px;\n      border-radius: 8px;\n    }\n\n    /* Head label */\n    .head-label {\n      position: absolute;\n      left: 8px;\n      top: -18px;\n      background: transparent;\n      font-size: 0.82rem;\n      color: var(--accent);\n      font-weight: 700;\n    }\n\n    /* Current pointer (animated) */\n    .current-pointer {\n      position: absolute;\n      width: 22px;\n      height: 22px;\n      border-radius: 50%;\n      background: var(--accent);\n      color: #fff;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      font-size: 0.72rem;\n      transform: translate(-50%, -50%);\n      box-shadow: 0 6px 14px rgba(3,102,214,0.2);\n      transition: transform 360ms cubic-bezier(.2,.9,.2,1);\n      z-index: 40;\n    }\n\n    /* Highlighted node during traversal */\n    .node.highlight {\n      transform: translateY(-6px) scale(1.02);\n      box-shadow: 0 10px 26px rgba(3,102,214,0.12);\n      border-color: rgba(3,102,214,0.12);\n    }\n\n    /* Deleted node animation */\n    .node.removing {\n      transform: scale(0.6) translateY(12px);\n      opacity: 0;\n    }\n\n    .msg {\n      font-size: 0.9rem;\n      color: var(--muted);\n    }\n\n    /* Footer small controls */\n    .footer-controls {\n      display: flex;\n      gap: var(--gap);\n      align-items: center;\n      flex-wrap: wrap;\n    }\n\n    /* SVG overlay that draws arrows between nodes */\n    .svg-layer {\n      position: absolute;\n      inset: 0;\n      pointer-events: none;\n      z-index: 10;\n    }\n\n    /* Accessibility focus outline */\n    .btn:focus, input:focus {\n      outline: 3px solid rgba(3,102,214,0.12);\n      outline-offset: 3px;\n      border-radius: 8px;\n    }\n\n    /* Tiny helper */\n    .kbd {\n      background: #f1f5f9;\n      color: #0b1220;\n      padding: 4px 8px;\n      border-radius: 8px;\n      font-weight: 700;\n      font-size: 0.82rem;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Linked List Interactive Module\">\n    <header>\n      <h1>Linked List — Interactive Exploration</h1>\n      <p class=\"lead\">Step through fundamental singly linked list operations: insertion, deletion, and traversal. Visual animations show pointers and node transitions to deepen intuition.</p>\n    </header>\n\n    <main class=\"module\" aria-live=\"polite\">\n      <!-- Left panel: meta + controls -->\n      <aside class=\"panel\" aria-label=\"Controls and explanations\">\n        <div>\n          <div class=\"section-title\">Concept Title</div>\n          <div class=\"small\">Singly Linked List: nodes with value and next pointer. Manage head, insert/delete nodes, and traverse step-by-step.</div>\n        </div>\n\n        <div>\n          <div class=\"section-title\">Learning Objective</div>\n          <div class=\"small\">\n            After interacting, you should understand:\n            <ul style=\"margin:8px 0 0 18px; color:var(--muted); font-size:0.92rem;\">\n              <li>How head and next pointers form a chain of nodes</li>\n              <li>How insertions and deletions update pointers</li>\n              <li>How traversal moves a current pointer from head along next links</li>\n            </ul>\n          </div>\n        </div>\n\n        <div>\n          <div class=\"section-title\">Interaction Design</div>\n          <div class=\"small\">\n            Use the controls to add nodes (head or tail), insert after an index, delete, or traverse. Visual feedback:\n            <ul style=\"margin:8px 0 0 18px; color:var(--muted); font-size:0.92rem;\">\n              <li>Pointer (blue circle) animates along arrows during traversal.</li>\n              <li>Nodes rise and highlight when visited; arrows redraw on changes.</li>\n              <li>Insertions slide in, deletions fade out—so pointer/pointer updates are visible.</li>\n            </ul>\n          </div>\n        </div>\n\n        <div>\n          <div class=\"section-title\">Layout Description</div>\n          <div class=\"small\">\n            Left column: descriptive text and interactive controls (inputs, buttons). Right column: visualization area with nodes and arrows. Safe area margins of 24px applied; spacing between controls at least 16px. The visualization is responsive and scrollable horizontally for long lists. Controls are keyboard accessible.\n          </div>\n        </div>\n\n        <hr />\n\n        <!-- Controls -->\n        <div class=\"controls\" aria-hidden=\"false\">\n          <div class=\"section-title\">Create and Modify</div>\n\n          <div class=\"row wrap\">\n            <label for=\"value-input\">Node value</label>\n            <input id=\"value-input\" type=\"text\" placeholder=\"e.g. 42 or 'A'\" aria-label=\"Node value\" />\n          </div>\n\n          <div class=\"control-grid\">\n            <button class=\"btn\" id=\"add-head\">Add Head</button>\n            <button class=\"btn secondary\" id=\"add-tail\">Add Tail</button>\n            <button class=\"btn\" id=\"random\">Random List</button>\n            <button class=\"btn secondary\" id=\"clear\">Clear</button>\n          </div>\n\n          <div class=\"row\">\n            <div style=\"flex:1;\">\n              <label for=\"index-input\">Index (0-based)</label>\n              <input id=\"index-input\" type=\"number\" min=\"0\" placeholder=\"e.g. 0\" aria-label=\"Index\" />\n            </div>\n            <div style=\"display:flex; flex-direction:column; gap:8px;\">\n              <button class=\"btn\" id=\"insert-after\">Insert After</button>\n              <button class=\"btn secondary\" id=\"delete-at\">Delete At</button>\n            </div>\n          </div>\n\n          <div class=\"row\">\n            <button class=\"btn secondary\" id=\"delete-head\">Delete Head</button>\n            <button class=\"btn secondary\" id=\"delete-tail\">Delete Tail</button>\n          </div>\n\n        </div>\n\n        <hr />\n\n        <div>\n          <div class=\"section-title\">Traversal</div>\n          <div class=\"small\">\n            Click \"Step\" to move the current pointer along the list. \"Auto\" plays traversal. Use \"Search\" to animate traversal until a value is found.\n          </div>\n\n          <div class=\"row\">\n            <button class=\"btn\" id=\"step\">Step</button>\n            <button class=\"btn secondary\" id=\"auto\">Auto</button>\n            <button class=\"btn secondary\" id=\"reset-pointer\">Reset Pointer</button>\n          </div>\n\n          <div style=\"display:flex; gap: var(--gap); align-items:center; margin-top:8px;\">\n            <input id=\"search-input\" type=\"text\" placeholder=\"Find value\" aria-label=\"Search value\" />\n            <button class=\"btn\" id=\"search\">Search</button>\n          </div>\n        </div>\n\n        <div class=\"hint\" style=\"margin-top:6px;\">Tip: Add a few nodes, then use Step/Auto to watch pointers and pointer updates during insert/delete operations.</div>\n      </aside>\n\n      <!-- Right panel: visualization -->\n      <section class=\"vis\" aria-label=\"Linked list visualization\">\n        <div class=\"vis-top\">\n          <div class=\"status\" id=\"list-status\">List: empty</div>\n          <div class=\"footer-controls\">\n            <div class=\"msg\" id=\"node-count\">0 nodes</div>\n            <div class=\"kbd\" id=\"head-label-small\">head</div>\n          </div>\n        </div>\n\n        <div class=\"canvas-wrap\" id=\"canvas\" tabindex=\"0\" aria-label=\"Linked list canvas\">\n          <!-- SVG layer for arrows -->\n          <svg class=\"svg-layer\" id=\"svg\" aria-hidden=\"true\"></svg>\n\n          <!-- Nodes container (flex) -->\n          <div class=\"nodes\" id=\"nodes\" role=\"list\" aria-label=\"Nodes container\"></div>\n\n          <!-- Animated current pointer -->\n          <div id=\"current-pointer\" class=\"current-pointer\" aria-hidden=\"true\" style=\"display:none;\">cur</div>\n        </div>\n\n        <div style=\"display:flex; justify-content:space-between; align-items:center; gap:var(--gap);\">\n          <div class=\"msg\" id=\"action-msg\">Ready.</div>\n          <div style=\"color:var(--muted); font-size:0.88rem;\">Accessible controls • keyboard-focusable</div>\n        </div>\n\n      </section>\n    </main>\n  </div>\n\n  <script>\n    /******************************************************\n     * Linked List Visual Interactive Module (vanilla JS)\n     * - Implements a conceptual singly linked list using\n     *   an array of nodes to model order; renders nodes and\n     *   SVG arrows and animates pointer for traversal.\n     *\n     * Accessibility:\n     * - Buttons and inputs are focusable.\n     * - Canvas has tabindex for keyboard focus.\n     ******************************************************/\n\n    (function () {\n      // DOM references\n      const nodesEl = document.getElementById('nodes');\n      const svgEl = document.getElementById('svg');\n      const pointerEl = document.getElementById('current-pointer');\n      const statusEl = document.getElementById('list-status');\n      const countEl = document.getElementById('node-count');\n      const actionMsg = document.getElementById('action-msg');\n\n      const valueInput = document.getElementById('value-input');\n      const indexInput = document.getElementById('index-input');\n      const searchInput = document.getElementById('search-input');\n\n      const btnAddHead = document.getElementById('add-head');\n      const btnAddTail = document.getElementById('add-tail');\n      const btnRandom = document.getElementById('random');\n      const btnClear = document.getElementById('clear');\n      const btnInsertAfter = document.getElementById('insert-after');\n      const btnDeleteAt = document.getElementById('delete-at');\n      const btnDeleteHead = document.getElementById('delete-head');\n      const btnDeleteTail = document.getElementById('delete-tail');\n\n      const btnStep = document.getElementById('step');\n      const btnAuto = document.getElementById('auto');\n      const btnResetPointer = document.getElementById('reset-pointer');\n      const btnSearch = document.getElementById('search');\n\n      // Model: an array of node objects {id, value}\n      let nodes = [];\n      let nextId = 1;\n\n      // Traversal state\n      let currentIndex = null; // null means pointer is not shown / reset\n      let autoTimer = null;\n      let isAuto = false;\n\n      // Helper: update status text\n      function updateStatus(msg) {\n        statusEl.textContent = msg;\n        actionMsg.textContent = msg;\n      }\n\n      // Helper: render nodes in DOM\n      function render() {\n        // Clear existing\n        nodesEl.innerHTML = '';\n        // Create node elements\n        nodes.forEach((nd, i) => {\n          const el = document.createElement('div');\n          el.className = 'node';\n          el.setAttribute('role', 'listitem');\n          el.setAttribute('data-index', i);\n          el.setAttribute('data-id', nd.id);\n          // index label\n          const idx = document.createElement('div');\n          idx.className = 'node-index';\n          idx.textContent = i;\n          // value\n          const val = document.createElement('div');\n          val.className = 'node-value';\n          val.textContent = nd.value;\n          el.appendChild(idx);\n          el.appendChild(val);\n\n          nodesEl.appendChild(el);\n        });\n\n        // Update count and status\n        countEl.textContent = nodes.length + (nodes.length === 1 ? ' node' : ' nodes');\n        statusEl.textContent = nodes.length ? 'List: head → ...' : 'List: empty';\n\n        // After DOM updated, redraw arrows and position pointer if present\n        requestAnimationFrame(() => {\n          drawArrows();\n          positionPointerToIndex(currentIndex, /*instant*/ true);\n        });\n      }\n\n      // Draw SVG arrows between adjacent nodes\n      function drawArrows() {\n        // Clear svg\n        while (svgEl.firstChild) svgEl.removeChild(svgEl.firstChild);\n\n        const containerRect = nodesEl.getBoundingClientRect();\n        const svgRect = svgEl.getBoundingClientRect();\n        const offsetX = containerRect.left - svgRect.left;\n        const offsetY = containerRect.top - svgRect.top;\n\n        // Setup marker for arrowhead\n        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');\n        marker.setAttribute('id', 'arrowhead');\n        marker.setAttribute('markerWidth', '10');\n        marker.setAttribute('markerHeight', '10');\n        marker.setAttribute('refX', '6');\n        marker.setAttribute('refY', '5');\n        marker.setAttribute('orient', 'auto');\n        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n        path.setAttribute('d', 'M0,0 L10,5 L0,10 z');\n        path.setAttribute('fill', '#9fb7e8');\n        marker.appendChild(path);\n        defs.appendChild(marker);\n        svgEl.appendChild(defs);\n\n        // For each pair nodes[i] -> nodes[i+1], draw a cubic bezier arrow\n        const nodeEls = Array.from(nodesEl.children);\n        for (let i = 0; i < nodeEls.length - 1; i++) {\n          const a = nodeEls[i].getBoundingClientRect();\n          const b = nodeEls[i + 1].getBoundingClientRect();\n\n          // start at right middle of a\n          const x1 = a.right - svgRect.left + 4;\n          const y1 = a.top + a.height / 2 - svgRect.top;\n          // end at left middle of b\n          const x2 = b.left - svgRect.left - 6;\n          const y2 = b.top + b.height / 2 - svgRect.top;\n\n          // control points for gentle arc\n          const dx = Math.max(30, (x2 - x1) / 2);\n          const cx1 = x1 + dx;\n          const cy1 = y1;\n          const cx2 = x2 - dx;\n          const cy2 = y2;\n\n          const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n          const d = `M ${x1} ${y1} C ${cx1} ${cy1} ${cx2} ${cy2} ${x2} ${y2}`;\n          pathEl.setAttribute('d', d);\n          pathEl.setAttribute('stroke', '#cfe3ff');\n          pathEl.setAttribute('stroke-width', '4');\n          pathEl.setAttribute('fill', 'none');\n          pathEl.setAttribute('marker-end', 'url(#arrowhead)');\n          pathEl.setAttribute('opacity', '0.98');\n          svgEl.appendChild(pathEl);\n        }\n      }\n\n      // Utility to create a new node object\n      function createNode(value) {\n        return { id: nextId++, value: String(value) };\n      }\n\n      // Add operations\n      function addHead(value) {\n        const node = createNode(value);\n        nodes.unshift(node);\n        // show animation: slide in from left\n        render();\n        const first = nodesEl.children[0];\n        first.style.transform = 'translateX(-40px) scale(0.98)';\n        first.style.opacity = '0';\n        requestAnimationFrame(() => {\n          first.style.transition = 'transform 360ms cubic-bezier(.2,.9,.2,1), opacity 260ms ease';\n          first.style.transform = 'translateX(0) scale(1)';\n          first.style.opacity = '1';\n          setTimeout(() => { first.style.transition = ''; }, 400);\n        });\n        updateStatus('Added node at head.');\n      }\n\n      function addTail(value) {\n        const node = createNode(value);\n        nodes.push(node);\n        render();\n        const last = nodesEl.children[nodesEl.children.length - 1];\n        last.style.transform = 'translateX(40px) scale(0.98)';\n        last.style.opacity = '0';\n        requestAnimationFrame(() => {\n          last.style.transition = 'transform 360ms cubic-bezier(.2,.9,.2,1), opacity 260ms ease';\n          last.style.transform = 'translateX(0) scale(1)';\n          last.style.opacity = '1';\n          setTimeout(() => { last.style.transition = ''; }, 400);\n        });\n        updateStatus('Added node at tail.');\n      }\n\n      function insertAfter(index, value) {\n        if (index < 0 || index >= nodes.length) {\n          updateStatus('Index out of range.');\n          return;\n        }\n        const node = createNode(value);\n        nodes.splice(index + 1, 0, node);\n        render();\n        // animate the inserted node slightly up\n        const el = nodesEl.children[index + 1];\n        el.style.transform = 'translateY(-12px)';\n        el.style.opacity = '0';\n        requestAnimationFrame(() => {\n          el.style.transition = 'transform 360ms cubic-bezier(.2,.9,.2,1), opacity 280ms ease';\n          el.style.transform = 'translateY(0)';\n          el.style.opacity = '1';\n          setTimeout(() => { el.style.transition = ''; }, 420);\n        });\n        updateStatus(`Inserted after index ${index}.`);\n      }\n\n      function deleteAt(index) {\n        if (index < 0 || index >= nodes.length) {\n          updateStatus('Index out of range.');\n          return;\n        }\n        // animate removal\n        const el = nodesEl.children[index];\n        el.classList.add('removing');\n        setTimeout(() => {\n          nodes.splice(index, 1);\n          render();\n        }, 260);\n        updateStatus(`Deleted node at index ${index}.`);\n        // adjust current pointer if necessary\n        if (currentIndex !== null) {\n          if (nodes.length === 0) currentIndex = null;\n          else if (index < currentIndex) currentIndex -= 1;\n          else if (index === currentIndex) currentIndex = null;\n        }\n        positionPointerToIndex(currentIndex, true);\n      }\n\n      function deleteHead() {\n        if (!nodes.length) { updateStatus('List is empty.'); return; }\n        deleteAt(0);\n      }\n\n      function deleteTail() {\n        if (!nodes.length) { updateStatus('List is empty.'); return; }\n        deleteAt(nodes.length - 1);\n      }\n\n      function clearList() {\n        nodes = [];\n        currentIndex = null;\n        render();\n        pointerEl.style.display = 'none';\n        updateStatus('Cleared list.');\n      }\n\n      // Traversal: move pointer to next node, highlight\n      function stepTraversal() {\n        if (!nodes.length) { updateStatus('List is empty.'); return; }\n        if (currentIndex === null) {\n          currentIndex = 0;\n        } else if (currentIndex < nodes.length - 1) {\n          currentIndex += 1;\n        } else {\n          updateStatus('Reached end of list.');\n          return;\n        }\n        animateVisit(currentIndex);\n      }\n\n      // animate visiting a node: pointer moves, highlight node\n      function animateVisit(index) {\n        // Show pointer if hidden\n        pointerEl.style.display = 'flex';\n        positionPointerToIndex(index, /*instant*/ false);\n        // highlight node\n        const el = nodesEl.children[index];\n        if (!el) return;\n        el.classList.add('highlight');\n        setTimeout(() => {\n          el.classList.remove('highlight');\n        }, 700);\n        updateStatus(`Visited index ${index} (value: ${nodes[index].value}).`);\n      }\n\n      // Position pointer element to center-top of node at index\n      function positionPointerToIndex(index, instant) {\n        if (index === null || index === undefined || index < 0 || index >= nodes.length) {\n          pointerEl.style.display = 'none';\n          return;\n        }\n        const target = nodesEl.children[index];\n        if (!target) {\n          pointerEl.style.display = 'none';\n          return;\n        }\n        pointerEl.style.display = 'flex';\n\n        const canvasRect = document.getElementById('canvas').getBoundingClientRect();\n        const t = target.getBoundingClientRect();\n\n        const left = (t.left + t.right) / 2 - canvasRect.left;\n        const top = t.top - canvasRect.top - 10; // slightly above node\n\n        if (instant) {\n          pointerEl.style.transition = 'none';\n        } else {\n          pointerEl.style.transition = 'transform 420ms cubic-bezier(.2,.9,.2,1)';\n        }\n        pointerEl.style.transform = `translate(${left}px, ${top}px) translate(-50%, -50%)`;\n        // restore transition after short time\n        if (instant) {\n          setTimeout(() => { pointerEl.style.transition = ''; }, 50);\n        }\n      }\n\n      // Auto traversal\n      function startAutoTraversal() {\n        if (isAuto) {\n          stopAutoTraversal();\n          return;\n        }\n        if (!nodes.length) { updateStatus('List is empty.'); return; }\n        isAuto = true;\n        btnAuto.textContent = 'Stop';\n        updateStatus('Auto traversal started.');\n        if (currentIndex === null) currentIndex = 0;\n        animateVisit(currentIndex);\n        autoTimer = setInterval(() => {\n          if (currentIndex === null) currentIndex = 0;\n          else if (currentIndex < nodes.length - 1) currentIndex += 1;\n          else {\n            stopAutoTraversal();\n            updateStatus('Auto traversal finished.');\n            return;\n          }\n          animateVisit(currentIndex);\n        }, 900);\n      }\n\n      function stopAutoTraversal() {\n        isAuto = false;\n        btnAuto.textContent = 'Auto';\n        clearInterval(autoTimer);\n        autoTimer = null;\n      }\n\n      // Search animation: traverse until value found (string match)\n      function searchValue(value) {\n        if (!nodes.length) { updateStatus('List is empty.'); return; }\n        // start from head\n        currentIndex = null;\n        pointerEl.style.display = 'flex';\n        let idx = 0;\n        updateStatus(`Searching for \"${value}\"...`);\n        const step = () => {\n          if (idx >= nodes.length) {\n            updateStatus(`Value \"${value}\" not found.`);\n            return;\n          }\n          currentIndex = idx;\n          animateVisit(idx);\n          if (String(nodes[idx].value) === String(value)) {\n            updateStatus(`Found value at index ${idx}.`);\n            return;\n          }\n          idx++;\n          setTimeout(step, 700);\n        };\n        step();\n      }\n\n      // Utility: generate small random list\n      function randomList() {\n        const len = Math.max(1, Math.floor(Math.random() * 6) + 1);\n        nodes = [];\n        for (let i = 0; i < len; i++) {\n          nodes.push(createNode(Math.floor(Math.random() * 99)));\n        }\n        currentIndex = null;\n        render();\n        updateStatus('Random list created.');\n      }\n\n      // Wire up buttons\n      btnAddHead.addEventListener('click', () => {\n        const val = valueInput.value.trim() || '•';\n        addHead(val);\n        valueInput.value = '';\n      });\n\n      btnAddTail.addEventListener('click', () => {\n        const val = valueInput.value.trim() || '•';\n        addTail(val);\n        valueInput.value = '';\n      });\n\n      btnRandom.addEventListener('click', () => {\n        randomList();\n      });\n\n      btnClear.addEventListener('click', () => {\n        clearList();\n      });\n\n      btnInsertAfter.addEventListener('click', () => {\n        const idx = parseInt(indexInput.value, 10);\n        const val = valueInput.value.trim() || '•';\n        if (isNaN(idx)) {\n          updateStatus('Please provide a valid index.');\n          return;\n        }\n        insertAfter(idx, val);\n      });\n\n      btnDeleteAt.addEventListener('click', () => {\n        const idx = parseInt(indexInput.value, 10);\n        if (isNaN(idx)) {\n          updateStatus('Please provide a valid index.');\n          return;\n        }\n        deleteAt(idx);\n      });\n\n      btnDeleteHead.addEventListener('click', () => { deleteHead(); });\n      btnDeleteTail.addEventListener('click', () => { deleteTail(); });\n\n      btnStep.addEventListener('click', () => {\n        stopAutoTraversal();\n        stepTraversal();\n      });\n\n      btnAuto.addEventListener('click', () => {\n        if (isAuto) stopAutoTraversal();\n        else startAutoTraversal();\n      });\n\n      btnResetPointer.addEventListener('click', () => {\n        stopAutoTraversal();\n        currentIndex = null;\n        pointerEl.style.display = 'none';\n        updateStatus('Pointer reset.');\n      });\n\n      btnSearch.addEventListener('click', () => {\n        const v = searchInput.value.trim();\n        if (!v) { updateStatus('Enter value to search.'); return; }\n        stopAutoTraversal();\n        searchValue(v);\n      });\n\n      // Keyboard support: Enter on inputs triggers addTail\n      valueInput.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n          addTail(valueInput.value.trim() || '•');\n          valueInput.value = '';\n        }\n      });\n\n      indexInput.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n          const idx = parseInt(indexInput.value, 10);\n          if (!isNaN(idx)) {\n            insertAfter(idx, valueInput.value.trim() || '•');\n            indexInput.value = '';\n          }\n        }\n      });\n\n      // Resize observer to redraw arrows on layout changes\n      let resizeObserver = new ResizeObserver(drawArrows);\n      resizeObserver.observe(document.getElementById('canvas'));\n\n      // Clicking a node selects it (move pointer there)\n      nodesEl.addEventListener('click', (e) => {\n        const nodeEl = e.target.closest('.node');\n        if (!nodeEl) return;\n        const idx = parseInt(nodeEl.getAttribute('data-index'), 10);\n        currentIndex = idx;\n        positionPointerToIndex(idx, false);\n        nodeEl.classList.add('highlight');\n        setTimeout(() => nodeEl.classList.remove('highlight'), 700);\n        updateStatus(`Pointer moved to index ${idx}.`);\n      });\n\n      // Initial render\n      render();\n\n      // Expose some helpful demo content for first load\n      (function seedDemo() {\n        nodes = [createNode(7), createNode(13), createNode(21)];\n        currentIndex = null;\n        render();\n        updateStatus('Demo list initialized. Try Step or Add Node.');\n      })();\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Linked List.\n\n**Project Overview:**\nTopic: Linked List\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Linked List"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "82f19b30-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:45:10.627Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Adjacency Matrix",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Adjacency Matrix — Interactive Module</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1720;\n      --panel: #0b1220;\n      --accent: #40c4ff;\n      --muted: #9aa6b2;\n      --success: #6ee7b7;\n      --danger: #ff7b7b;\n      --glass: rgba(255,255,255,0.03);\n      --cell-on: rgba(64,196,255,0.18);\n      --cell-on-strong: rgba(64,196,255,0.35);\n      --focus: 0 0 0 3px rgba(64,196,255,0.12);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#051021 0%, #071426 100%);\n      color:#dbeafe;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n\n    /* Safe area margins */\n    .app{\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height: 100vh;\n      display:flex;\n      flex-direction:column;\n      gap: var(--gap);\n    }\n\n    header{\n      display:flex;\n      gap: var(--gap);\n      align-items:flex-start;\n      flex-wrap:wrap;\n    }\n\n    .title{\n      flex:1 1 480px;\n      min-width: 220px;\n    }\n\n    h1{\n      margin:0 0 8px 0;\n      font-size:20px;\n      letter-spacing: -0.01em;\n      color: #e6f8ff;\n    }\n\n    p.lead{\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    .info{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.03);\n      padding:12px;\n      border-radius:10px;\n      min-width: 260px;\n      max-width: 420px;\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    .info h3{\n      margin:0 0 8px 0;\n      font-size:13px;\n      color:#e6f8ff;\n    }\n\n    /* Main area layout */\n    .main{\n      display:flex;\n      gap: var(--gap);\n      align-items:stretch;\n      justify-content:stretch;\n      flex:1;\n    }\n\n    /* Left: graph area */\n    .panel{\n      flex:1 1 560px;\n      background: var(--panel);\n      border-radius:12px;\n      padding:var(--gap);\n      display:flex;\n      flex-direction:column;\n      min-width:280px;\n      min-height:360px;\n      box-shadow: 0 6px 18px rgba(1,10,18,0.5);\n    }\n\n    .top-controls{\n      display:flex;\n      gap: var(--gap);\n      align-items:center;\n      margin-bottom: 8px;\n      flex-wrap:wrap;\n    }\n\n    .controls-left{\n      display:flex;\n      gap: var(--gap);\n      align-items:center;\n    }\n\n    button, .toggle{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      color: #e6f8ff;\n      border: 1px solid rgba(255,255,255,0.04);\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      font-size:13px;\n    }\n\n    button:focus, .toggle:focus{\n      outline: none;\n      box-shadow: var(--focus);\n    }\n\n    .toggle.active{\n      background: linear-gradient(180deg, rgba(64,196,255,0.12), rgba(64,196,255,0.06));\n      border-color: rgba(64,196,255,0.18);\n      color: #e9fbff;\n    }\n\n    .desc{\n      color:var(--muted);\n      font-size:13px;\n      margin-bottom:8px;\n    }\n\n    /* Graph canvas area */\n    .canvas-wrap{\n      flex:1;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius:10px;\n      display:flex;\n      align-items:stretch;\n      justify-content:stretch;\n      position:relative;\n      overflow:hidden;\n      min-height:260px;\n      border: 1px dashed rgba(255,255,255,0.03);\n    }\n\n    svg{\n      width:100%;\n      height:100%;\n      display:block;\n      cursor:default;\n    }\n\n    /* Nodes & edges */\n    .node{\n      transition: transform 0.18s ease, r 0.18s ease;\n    }\n\n    .node circle{\n      fill: linear-gradient(180deg,#183a5a,#0d1e2a);\n      fill: #072138;\n      stroke: rgba(255,255,255,0.06);\n      stroke-width:1.5px;\n    }\n\n    .node text{\n      fill:#dbeafe;\n      font-size:12px;\n      pointer-events:none;\n      user-select:none;\n    }\n\n    .node:hover circle{\n      transform: scale(1.06);\n      stroke: rgba(64,196,255,0.4);\n      stroke-width:2px;\n    }\n\n    .edge{\n      stroke: rgba(255,255,255,0.12);\n      stroke-width:2px;\n      fill:none;\n      transition: stroke 0.18s ease, stroke-width 0.18s ease, opacity 0.18s ease;\n    }\n\n    .edge.on{\n      stroke: var(--accent);\n      stroke-width:3px;\n      opacity:1;\n      filter: drop-shadow(0 6px 14px rgba(64,196,255,0.06));\n      animation: dash 600ms ease-out;\n    }\n\n    @keyframes dash{\n      from{ stroke-dasharray: 12; stroke-dashoffset: 12; }\n      to{ stroke-dasharray: 12; stroke-dashoffset: 0; }\n    }\n\n    .edge.hover{\n      stroke: var(--success);\n      stroke-width:4px;\n    }\n\n    /* Matrix area */\n    .matrix-panel{\n      width: 360px;\n      max-width: 45%;\n      min-width:260px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.03);\n      border-radius:12px;\n      padding:var(--gap);\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n\n    .matrix-title{\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:var(--gap);\n    }\n\n    .matrix-grid{\n      overflow:auto;\n      border-radius:8px;\n      border: 1px solid rgba(255,255,255,0.02);\n      background: rgba(4,10,15,0.4);\n      padding:8px;\n    }\n\n    table{\n      border-collapse:collapse;\n      width:100%;\n      table-layout:fixed;\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    th, td{\n      padding:6px;\n      text-align:center;\n      border: 1px solid rgba(255,255,255,0.02);\n    }\n\n    th{\n      background: rgba(255,255,255,0.02);\n      color:#dbeafe;\n      font-weight:600;\n    }\n\n    td button{\n      width:100%;\n      padding:6px;\n      border-radius:6px;\n      background:transparent;\n      border:none;\n      color:var(--muted);\n      cursor:pointer;\n      transition: background 160ms ease, color 160ms ease, transform 120ms ease;\n      font-size:13px;\n    }\n\n    td button:focus{\n      outline:none;\n      box-shadow: var(--focus);\n    }\n\n    td.on button{\n      background: var(--cell-on);\n      color: #e6f8ff;\n    }\n\n    td.on-strong button{\n      background: var(--cell-on-strong);\n      color:#e6f8ff;\n    }\n\n    td.hover button{\n      background: rgba(110,231,183,0.08);\n      color:#e6f8ff;\n      transform: translateY(-2px);\n    }\n\n    /* small screens: stack */\n    @media (max-width: 900px){\n      .main{\n        flex-direction:column;\n      }\n      .matrix-panel{\n        width:100%;\n      }\n    }\n\n    /* footer notes */\n    .notes{\n      color:var(--muted);\n      font-size:13px;\n      background: rgba(255,255,255,0.02);\n      border-radius:8px;\n      padding:10px;\n    }\n\n    /* Accessibility helper for keyboard users when nodes are focusable */\n    .node circle:focus{\n      outline:none;\n      stroke: var(--accent);\n      stroke-width:2px;\n      filter: none;\n    }\n\n    /* Flash animation for matrix cell change */\n    @keyframes flashCell {\n      0% { background: rgba(64,196,255,0.0); }\n      30% { background: rgba(64,196,255,0.26); }\n      100% { background: transparent; }\n    }\n\n    .flash{\n      animation: flashCell 700ms ease;\n    }\n\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Adjacency Matrix interactive module\">\n    <header>\n      <div class=\"title\">\n        <h1>Adjacency Matrix — Visual & Interactive</h1>\n        <p class=\"lead\">Toggle edges between nodes and observe how the adjacency matrix changes. Hover to reveal relationships and learn the mapping between graph and matrix.</p>\n      </div>\n\n      <aside class=\"info\" aria-live=\"polite\">\n        <h3>Learning Objective</h3>\n        <div>\n          After interacting with this module you will:\n          <ul style=\"margin:8px 0 0 18px; padding:0; color:var(--muted); font-size:13px;\">\n            <li>Understand how edges in a graph map to entries in an adjacency matrix.</li>\n            <li>See differences between directed and undirected adjacency matrices.</li>\n            <li>Practice toggling edges via the visual graph and the matrix table.</li>\n          </ul>\n        </div>\n        <hr style=\"border:none; height:1px; margin:8px 0; background: rgba(255,255,255,0.02)\"/>\n        <strong style=\"font-size:13px; color:#e6f8ff\">Interaction Design</strong>\n        <p style=\"margin:8px 0 0 0; color:var(--muted); font-size:13px;\">\n          Click two nodes (source then target) or click a matrix cell to add/remove an edge. Drag nodes to reposition them. Hover a node or a matrix cell to highlight corresponding row/column and edge. Toggle \"Directed\" mode to observe asymmetric matrices.\n        </p>\n      </aside>\n    </header>\n\n    <div class=\"main\" role=\"region\" aria-labelledby=\"module-main\">\n      <section class=\"panel\" aria-label=\"Graph area\">\n        <div class=\"top-controls\" role=\"toolbar\" aria-label=\"Graph controls\">\n          <div class=\"controls-left\">\n            <button id=\"add-node\" title=\"Add node (max 8)\">＋ Add Node</button>\n            <button id=\"remove-node\" title=\"Remove last node\">－ Remove Node</button>\n            <button id=\"reset\" title=\"Reset graph\">⟲ Reset</button>\n          </div>\n\n          <div style=\"margin-left:auto; display:flex; gap:12px;\">\n            <button id=\"directed-toggle\" class=\"toggle\" aria-pressed=\"false\" title=\"Toggle directed/undirected\">Directed: off</button>\n            <button id=\"weight-toggle\" class=\"toggle\" aria-pressed=\"false\" title=\"Toggle weighted edges\">Weighted: off</button>\n          </div>\n        </div>\n\n        <div class=\"desc\" id=\"interaction-hint\">Click node A then node B to toggle edge A → B (or A—B if undirected). Hover a cell or node to highlight.</div>\n\n        <div class=\"canvas-wrap\" id=\"canvas-wrap\" aria-hidden=\"false\">\n          <svg id=\"svg\" viewBox=\"0 0 800 520\" preserveAspectRatio=\"xMidYMid meet\" role=\"img\" aria-label=\"Graph visualization\">\n            <defs>\n              <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"10\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n                <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#40c4ff\"></path>\n              </marker>\n            </defs>\n\n            <g id=\"edges\" aria-hidden=\"true\"></g>\n            <g id=\"nodes\" aria-hidden=\"true\"></g>\n          </svg>\n        </div>\n      </section>\n\n      <aside class=\"matrix-panel\" aria-label=\"Adjacency matrix panel\">\n        <div class=\"matrix-title\">\n          <div>\n            <strong style=\"font-size:15px; color:#e6f8ff\">Adjacency Matrix</strong>\n            <div style=\"font-size:12px; color:var(--muted)\">Click cells to toggle edges. Rows = source, Columns = target.</div>\n          </div>\n          <div style=\"text-align:right; color:var(--muted); font-size:12px;\">\n            Nodes: <span id=\"node-count\">4</span>\n          </div>\n        </div>\n\n        <div class=\"matrix-grid\" id=\"matrix-grid\" tabindex=\"0\" aria-label=\"Adjacency matrix grid\">\n          <!-- matrix table is injected here -->\n        </div>\n\n        <div style=\"display:flex; gap:12px; align-items:center; justify-content:space-between;\">\n          <div style=\"color:var(--muted); font-size:13px;\">Mode: <span id=\"mode-label\">Undirected</span></div>\n          <div style=\"color:var(--muted); font-size:13px;\">Tip: Hover or tab into a cell to highlight the corresponding edge.</div>\n        </div>\n      </aside>\n    </div>\n\n    <div class=\"notes\" aria-hidden=\"false\">\n      <strong>Layout Description</strong>\n      <p style=\"margin:6px 0 0 0; color:var(--muted); font-size:13px;\">\n        Safe margins of 24px surround the module. The interface uses two primary panes arranged with a responsive flex layout:\n        left — interactive graph canvas with controls above; right — adjacency matrix table with scrollable grid. Minimum spacing of 16px is enforced between controls and panels. On narrow screens the matrix stacks below the graph. Interactive elements are focusable and labeled for accessibility.\n      </p>\n    </div>\n  </div>\n\n  <script>\n    // Adjacency Matrix Interactive Module\n    // Vanilla JS, self-contained. No external assets.\n    (function(){\n      const MAX_NODES = 8;\n      const svg = document.getElementById('svg');\n      const edgesGroup = document.getElementById('edges');\n      const nodesGroup = document.getElementById('nodes');\n      const matrixGrid = document.getElementById('matrix-grid');\n      const addBtn = document.getElementById('add-node');\n      const removeBtn = document.getElementById('remove-node');\n      const resetBtn = document.getElementById('reset');\n      const directedToggle = document.getElementById('directed-toggle');\n      const weightToggle = document.getElementById('weight-toggle');\n      const nodeCountEl = document.getElementById('node-count');\n      const modeLabel = document.getElementById('mode-label');\n      const interactionHint = document.getElementById('interaction-hint');\n\n      let directed = false;\n      let weighted = false;\n\n      let nodes = []; // {id, x, y}\n      let adj = [];   // 2D array [i][j] = 0 or weight>0\n      let selectedNode = null; // for click-to-connect\n      let dragging = null;\n      let dragOffset = {x:0,y:0};\n\n      // init with 4 nodes positioned in circle\n      function reset(){\n        nodes = [];\n        adj = [];\n        selectedNode = null;\n        const initial = 4;\n        for (let i=0;i<initial;i++){\n          nodes.push({id:i, x: 400 + 160*Math.cos(2*Math.PI*i/initial), y: 260 + 120*Math.sin(2*Math.PI*i/initial)});\n        }\n        adj = makeMatrix(nodes.length);\n        renderAll();\n      }\n\n      function makeMatrix(n){\n        const m = new Array(n);\n        for (let i=0;i<n;i++){\n          m[i] = new Array(n).fill(0);\n        }\n        return m;\n      }\n\n      function renderAll(){\n        renderNodes();\n        renderEdges();\n        renderMatrix();\n        updateCount();\n      }\n\n      function updateCount(){ nodeCountEl.textContent = nodes.length; modeLabel.textContent = directed ? 'Directed' : 'Undirected'; directedToggle.textContent = 'Directed: ' + (directed ? 'on' : 'off'); directedToggle.setAttribute('aria-pressed', String(directed)); weightToggle.textContent = 'Weighted: ' + (weighted ? 'on' : 'off'); weightToggle.setAttribute('aria-pressed', String(weighted)); }\n\n      // --- Render Nodes ---\n      function renderNodes(){\n        nodesGroup.innerHTML = '';\n        nodes.forEach(n=>{\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('class','node');\n          g.setAttribute('data-id', n.id);\n          g.setAttribute('tabindex','0');\n          g.setAttribute('role','button');\n          g.setAttribute('aria-label','Node '+labelFor(n.id));\n          g.style.cursor = 'pointer';\n\n          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          circle.setAttribute('cx', n.x);\n          circle.setAttribute('cy', n.y);\n          circle.setAttribute('r', 20);\n          circle.setAttribute('fill','#072138');\n\n          const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n          text.setAttribute('x', n.x);\n          text.setAttribute('y', n.y+4);\n          text.setAttribute('text-anchor','middle');\n          text.setAttribute('font-family','inherit');\n          text.setAttribute('font-size','12');\n          text.textContent = labelFor(n.id);\n\n          g.appendChild(circle);\n          g.appendChild(text);\n          nodesGroup.appendChild(g);\n\n          // Events: click to select target/source; drag\n          g.addEventListener('pointerdown', nodePointerDown);\n          g.addEventListener('click', nodeClickHandler);\n          g.addEventListener('keydown', nodeKeyHandler);\n          g.addEventListener('pointerenter', ()=>onNodeHover(n.id, true));\n          g.addEventListener('pointerleave', ()=>onNodeHover(n.id, false));\n        });\n      }\n\n      function labelFor(i){\n        // Labels A, B, C...\n        return String.fromCharCode(65 + i);\n      }\n\n      // --- Render Edges ---\n      function renderEdges(){\n        edgesGroup.innerHTML = '';\n        for (let i=0;i<nodes.length;i++){\n          for (let j=0;j<nodes.length;j++){\n            if (adj[i][j]){\n              const a = nodes[i];\n              const b = nodes[j];\n              const line = document.createElementNS('http://www.w3.org/2000/svg','path');\n              // curved path for better visuals if self-loop or overlap\n              const d = computePath(a.x, a.y, b.x, b.y, i===j);\n              line.setAttribute('d', d);\n              line.setAttribute('class', 'edge on');\n              // arrow marker for directed graphs\n              if (directed){\n                line.setAttribute('marker-end','url(#arrow)');\n              } else {\n                line.removeAttribute('marker-end');\n              }\n              line.setAttribute('data-from', i);\n              line.setAttribute('data-to', j);\n              edgesGroup.appendChild(line);\n\n              // optional weight label\n              if (weighted && adj[i][j] !== 1){\n                const mid = midPointOnPath(a.x,a.y,b.x,b.y);\n                const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n                t.setAttribute('x', mid.x);\n                t.setAttribute('y', mid.y - 6);\n                t.setAttribute('text-anchor','middle');\n                t.setAttribute('font-size','12');\n                t.setAttribute('fill','#e6f8ff');\n                t.textContent = adj[i][j];\n                edgesGroup.appendChild(t);\n              }\n\n              // click to remove edge\n              line.addEventListener('click', (ev)=>{\n                ev.stopPropagation();\n                toggleEdge(i,j,false);\n              });\n\n              // hover highlights matrix cell\n              line.addEventListener('pointerenter', ()=>highlightMatrixCell(i,j,true));\n              line.addEventListener('pointerleave', ()=>highlightMatrixCell(i,j,false));\n            }\n          }\n        }\n      }\n\n      function computePath(x1,y1,x2,y2,self){\n        if (self){\n          // loop\n          const r = 30;\n          return `M ${x1} ${y1} C ${x1-r} ${y1-r} ${x1+r} ${y1-r} ${x1} ${y1}`;\n        }\n        // simple quadratic curve offset by perpendicular\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        const mx = (x1 + x2)/2;\n        const my = (y1 + y2)/2;\n        const dist = Math.sqrt(dx*dx + dy*dy) || 1;\n        // offset proportional to distance\n        const offset = Math.min(80, Math.max(16, dist * 0.12));\n        // perp vector\n        const px = -dy / dist;\n        const py = dx / dist;\n        const cx = mx + px * offset;\n        const cy = my + py * offset;\n        return `M ${x1} ${y1} Q ${cx} ${cy} ${x2} ${y2}`;\n      }\n\n      function midPointOnPath(x1,y1,x2,y2){\n        return { x: (x1 + x2)/2, y: (y1 + y2)/2 };\n      }\n\n      // --- Matrix Rendering ---\n      function renderMatrix(){\n        matrixGrid.innerHTML = '';\n        const n = nodes.length;\n        if (n === 0){\n          matrixGrid.innerHTML = '<div style=\"color:var(--muted)\">No nodes yet. Add nodes to see the adjacency matrix.</div>';\n          return;\n        }\n        const table = document.createElement('table');\n        // header row\n        const thead = document.createElement('thead');\n        const headerRow = document.createElement('tr');\n        headerRow.appendChild(document.createElement('th')); // empty corner\n        for (let j=0;j<n;j++){\n          const th = document.createElement('th');\n          th.textContent = labelFor(j);\n          headerRow.appendChild(th);\n        }\n        thead.appendChild(headerRow);\n        table.appendChild(thead);\n\n        const tbody = document.createElement('tbody');\n        for (let i=0;i<n;i++){\n          const tr = document.createElement('tr');\n          const th = document.createElement('th');\n          th.textContent = labelFor(i);\n          tr.appendChild(th);\n\n          for (let j=0;j<n;j++){\n            const td = document.createElement('td');\n            const btn = document.createElement('button');\n            btn.setAttribute('aria-label', `Cell ${labelFor(i)} to ${labelFor(j)}: ${adj[i][j] ? '1' : '0'}`);\n            btn.textContent = adj[i][j] ? (weighted ? String(adj[i][j]) : '1') : '0';\n            btn.addEventListener('click', ()=> {\n              toggleEdge(i,j,true);\n            });\n            btn.addEventListener('pointerenter', ()=> onMatrixHover(i,j,true));\n            btn.addEventListener('pointerleave', ()=> onMatrixHover(i,j,false));\n            btn.addEventListener('focus', ()=> onMatrixHover(i,j,true));\n            btn.addEventListener('blur', ()=> onMatrixHover(i,j,false));\n            td.appendChild(btn);\n            if (adj[i][j]) td.classList.add('on');\n            tr.appendChild(td);\n          }\n          tbody.appendChild(tr);\n        }\n\n        table.appendChild(tbody);\n        matrixGrid.appendChild(table);\n      }\n\n      // --- Edge toggle ---\n      function toggleEdge(i,j,fromUI){\n        if (i < 0 || j < 0 || i >= nodes.length || j >= nodes.length) return;\n\n        if (adj[i][j]){\n          // remove\n          adj[i][j] = 0;\n          if (!directed){\n            adj[j][i] = 0;\n          }\n        } else {\n          // add\n          let val = 1;\n          if (weighted){\n            const entered = prompt('Enter weight for edge ' + labelFor(i) + '→' + labelFor(j), '1');\n            if (entered === null) return;\n            const parsed = Number(entered);\n            if (isNaN(parsed)) val = 1;\n            else val = parsed;\n          }\n          adj[i][j] = val;\n          if (!directed){\n            adj[j][i] = val;\n          }\n        }\n        renderEdges();\n        // flash matrix cells that changed, with class .flash\n        flashMatrixCells(i,j);\n        renderMatrix();\n\n        // if change was initiated by clicking a node (fromUI param false when clicking edge), reset selection\n        if (!fromUI){\n          selectedNode = null;\n          updateInteractionHint();\n        }\n      }\n\n      function flashMatrixCells(i,j){\n        // find table cell(s) corresponding and add flash\n        const table = matrixGrid.querySelector('table');\n        if (!table) return;\n        // rows start at 1 because of header\n        const tbody = table.tBodies[0];\n        if (!tbody) return;\n        const rowI = tbody.rows[i];\n        if (rowI){\n          const cell = rowI.cells[j+1]; // +1 offset for row header\n          if (cell){\n            cell.classList.add('flash');\n            setTimeout(()=>cell.classList.remove('flash'), 700);\n          }\n        }\n        if (!directed){\n          // also symmetric cell\n          const rowJ = tbody.rows[j];\n          if (rowJ){\n            const cell2 = rowJ.cells[i+1];\n            if (cell2){\n              cell2.classList.add('flash');\n              setTimeout(()=>cell2.classList.remove('flash'), 700);\n            }\n          }\n        }\n      }\n\n      // --- Node interactions ---\n      function nodePointerDown(ev){\n        ev.preventDefault();\n        const g = ev.currentTarget;\n        const id = Number(g.getAttribute('data-id'));\n        dragging = id;\n        const node = nodes.find(n=>n.id===id);\n        const pt = getPointFromEvent(ev);\n        dragOffset.x = node.x - pt.x;\n        dragOffset.y = node.y - pt.y;\n        g.setPointerCapture(ev.pointerId);\n        g.addEventListener('pointermove', nodePointerMove);\n        g.addEventListener('pointerup', nodePointerUp, { once: true });\n      }\n\n      function nodePointerMove(ev){\n        ev.preventDefault();\n        const g = ev.currentTarget;\n        const id = Number(g.getAttribute('data-id'));\n        if (dragging !== id) return;\n        const pt = getPointFromEvent(ev);\n        const node = nodes.find(n=>n.id===id);\n        node.x = pt.x + dragOffset.x;\n        node.y = pt.y + dragOffset.y;\n        // constrain inside viewBox margins\n        node.x = Math.max(26, Math.min(774, node.x));\n        node.y = Math.max(26, Math.min(494, node.y));\n        // update visuals live\n        // update node circle and text positions\n        const circle = g.querySelector('circle');\n        const text = g.querySelector('text');\n        circle.setAttribute('cx', node.x);\n        circle.setAttribute('cy', node.y);\n        text.setAttribute('x', node.x);\n        text.setAttribute('y', node.y + 4);\n        // update edges\n        renderEdges();\n      }\n\n      function nodePointerUp(ev){\n        const g = ev.currentTarget;\n        const id = Number(g.getAttribute('data-id'));\n        dragging = null;\n        try{\n          g.releasePointerCapture(ev.pointerId);\n        }catch(e){}\n        g.removeEventListener('pointermove', nodePointerMove);\n      }\n\n      function nodeClickHandler(ev){\n        ev.stopPropagation();\n        const id = Number(ev.currentTarget.getAttribute('data-id'));\n        if (selectedNode === null){\n          selectedNode = id;\n          updateInteractionHint();\n          // highlight selected node visually\n          highlightNode(id, true);\n        } else {\n          // if same node clicked twice, toggle self-loop\n          if (selectedNode === id){\n            toggleEdge(id,id,true);\n            highlightNode(id,false);\n            selectedNode = null;\n            updateInteractionHint();\n          } else {\n            // toggle edge from selectedNode -> id\n            const from = selectedNode;\n            const to = id;\n            toggleEdge(from,to,true);\n            highlightNode(selectedNode,false);\n            selectedNode = null;\n            updateInteractionHint();\n          }\n        }\n      }\n\n      function nodeKeyHandler(ev){\n        // Allow keyboard users to toggle self-loop on Enter or Space\n        if (ev.key === 'Enter' || ev.key === ' '){\n          ev.preventDefault();\n          const id = Number(ev.currentTarget.getAttribute('data-id'));\n          toggleEdge(id,id,true);\n        }\n      }\n\n      function updateInteractionHint(){\n        if (selectedNode === null){\n          interactionHint.textContent = 'Click node A then node B to toggle edge A → B (or A—B if undirected). Hover a cell or node to highlight.';\n        } else {\n          interactionHint.textContent = 'Selected node ' + labelFor(selectedNode) + '. Click another node to connect, click same node to toggle self-loop.';\n        }\n      }\n\n      function highlightNode(id, on){\n        const g = nodesGroup.querySelector(`g[data-id=\"${id}\"]`);\n        if (!g) return;\n        const circle = g.querySelector('circle');\n        if (on){\n          circle.style.stroke = 'rgba(64,196,255,0.5)';\n          circle.style.strokeWidth = '2px';\n        } else {\n          circle.style.stroke = '';\n          circle.style.strokeWidth = '';\n        }\n      }\n\n      // --- Matrix hover/graph highlight ---\n      function onMatrixHover(i,j,on){\n        // Highlight corresponding edge (if exists) or simulated edge path\n        highlightMatrixCell(i,j,on);\n      }\n\n      function highlightMatrixCell(i,j,on){\n        // Highlight edge visuals\n        // find matching edge path (if exists) and add 'hover' class, else draw a temporary path?\n        const existing = Array.from(edgesGroup.querySelectorAll('.edge')).find(p=>{\n          return Number(p.getAttribute('data-from'))===i && Number(p.getAttribute('data-to'))===j;\n        });\n        if (on){\n          if (existing){\n            existing.classList.add('hover');\n          } else {\n            // draw a temporary dashed path for preview\n            const a = nodes[i];\n            const b = nodes[j];\n            if (!a || !b) return;\n            const temp = document.createElementNS('http://www.w3.org/2000/svg','path');\n            temp.setAttribute('d', computePath(a.x,a.y,b.x,b.y, i===j));\n            temp.setAttribute('class','edge');\n            temp.setAttribute('stroke-dasharray','8 6');\n            temp.setAttribute('stroke','rgba(110,231,183,0.25)');\n            temp.setAttribute('data-temp','true');\n            edgesGroup.appendChild(temp);\n            // remove later on mouseleave\n          }\n        } else {\n          // remove temp and hover class\n          if (existing) existing.classList.remove('hover');\n          const temps = edgesGroup.querySelectorAll('[data-temp]');\n          temps.forEach(t=>t.remove());\n        }\n\n        // matrix cell highlight\n        const table = matrixGrid.querySelector('table');\n        if (!table) return;\n        const tbody = table.tBodies[0];\n        if (!tbody) return;\n        // clear previous hover classes\n        Array.from(tbody.querySelectorAll('td')).forEach(td=>td.classList.remove('hover'));\n        if (on){\n          const cell = tbody.rows[i].cells[j+1];\n          if (cell) cell.classList.add('hover');\n        }\n      }\n\n      function onNodeHover(id, on){\n        // highlight corresponding row/column in matrix\n        const table = matrixGrid.querySelector('table');\n        if (!table) return;\n        const tbody = table.tBodies[0];\n        if (!tbody) return;\n        // clear previous hover classes\n        Array.from(tbody.querySelectorAll('td')).forEach(td=>td.classList.remove('hover'));\n        if (on){\n          for (let j=0;j<nodes.length;j++){\n            const row = tbody.rows[id];\n            if (row){\n              const cell = row.cells[j+1];\n              if (cell) cell.classList.add('hover');\n            }\n            const colRow = tbody.rows[j];\n            if (colRow){\n              const colCell = colRow.cells[id+1];\n              if (colCell) colCell.classList.add('hover');\n            }\n          }\n        }\n      }\n\n      // --- Utility: get point in SVG coordinates ---\n      function getPointFromEvent(ev){\n        const pt = svg.createSVGPoint();\n        pt.x = ev.clientX;\n        pt.y = ev.clientY;\n        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());\n        return { x: svgP.x, y: svgP.y };\n      }\n\n      // --- Buttons ---\n      addBtn.addEventListener('click', ()=>{\n        if (nodes.length >= MAX_NODES) { alert('Max nodes: ' + MAX_NODES); return; }\n        const id = nodes.length;\n        // place new node near center with slight offset\n        nodes.push({id:id, x: 400 + (Math.random()*260-130), y: 260 + (Math.random()*160-80)});\n        // expand matrix\n        adj.forEach(row => row.push(0));\n        adj.push(new Array(nodes.length).fill(0));\n        renderAll();\n      });\n\n      removeBtn.addEventListener('click', ()=>{\n        if (nodes.length === 0) return;\n        nodes.pop();\n        adj.pop();\n        adj.forEach(row => row.pop());\n        selectedNode = null;\n        renderAll();\n      });\n\n      resetBtn.addEventListener('click', ()=>{\n        if (!confirm('Reset graph to default?')) return;\n        reset();\n      });\n\n      directedToggle.addEventListener('click', ()=>{\n        directed = !directed;\n        if (!directed){\n          // when switching to undirected, make symmetric\n          for (let i=0;i<nodes.length;i++){\n            for (let j=0;j<nodes.length;j++){\n              if (adj[i][j] || adj[j][i]){\n                const val = adj[i][j] || adj[j][i];\n                adj[i][j] = val;\n                adj[j][i] = val;\n              }\n            }\n          }\n        }\n        renderAll();\n        updateCount();\n      });\n\n      weightToggle.addEventListener('click', ()=>{\n        weighted = !weighted;\n        renderAll();\n        updateCount();\n      });\n\n      // clicking background clears selection\n      svg.addEventListener('click', (ev)=>{\n        selectedNode = null;\n        updateInteractionHint();\n        // clear any temporary hover lines\n        highlightMatrixCell(-1,-1,false);\n        // clear node highlight\n        Array.from(nodesGroup.querySelectorAll('g')).forEach(g=>{\n          const circle = g.querySelector('circle');\n          if (circle) { circle.style.stroke = ''; circle.style.strokeWidth=''; }\n        });\n      });\n\n      // init\n      reset();\n\n      // Accessibility: keyboard nav for matrix: allow arrow keys to move focus within matrix buttons\n      matrixGrid.addEventListener('keydown', (ev)=>{\n        const active = document.activeElement;\n        if (!active || active.tagName !== 'BUTTON') return;\n        const table = matrixGrid.querySelector('table');\n        if (!table) return;\n        // find position\n        const td = active.closest('td');\n        if (!td) return;\n        const row = td.parentElement;\n        const body = table.tBodies[0];\n        const rIndex = Array.prototype.indexOf.call(body.rows, row);\n        const cIndex = Array.prototype.indexOf.call(row.cells, td) - 1; // offset for row header\n        let nr = rIndex, nc = cIndex;\n        if (ev.key === 'ArrowRight') nc = Math.min(nodes.length-1, nc+1);\n        else if (ev.key === 'ArrowLeft') nc = Math.max(0, nc-1);\n        else if (ev.key === 'ArrowDown') nr = Math.min(nodes.length-1, nr+1);\n        else if (ev.key === 'ArrowUp') nr = Math.max(0, nr-1);\n        else return;\n        ev.preventDefault();\n        const target = body.rows[nr].cells[nc+1].querySelector('button');\n        if (target) target.focus();\n      });\n\n      // make module responsive on resize by adjusting viewBox if needed (kept static for simplicity)\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Adjacency Matrix.\n\n**Project Overview:**\nTopic: Adjacency Matrix\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Adjacency Matrix"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "897934e0-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:45:21.582Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Graph (Directed/Undirected)",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Graph: Directed vs Undirected — Interactive Module</title>\n  <style>\n    :root{\n      --safe-padding: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --muted: #94a3b8;\n      --accent: #60a5fa;\n      --accent-2: #7c3aed;\n      --success: #10b981;\n      --danger: #ef4444;\n    }\n\n    /* Safe area margins */\n    html,body{\n      height:100%;\n      margin:0;\n      padding:var(--safe-padding);\n      background: linear-gradient(180deg, #071029 0%, #081323 100%);\n      color:#e6eef8;\n      font-family: Inter, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      box-sizing:border-box;\n    }\n    *{box-sizing:inherit}\n\n    /* Layout */\n    .container{\n      display:flex;\n      gap:var(--gap);\n      height:calc(100% - (var(--safe-padding) * 2));\n    }\n\n    /* Left column: textual explanation & controls */\n    .left{\n      width:320px;\n      min-width:260px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);\n      border-radius:12px;\n      padding:20px;\n      display:flex;\n      flex-direction:column;\n      gap:16px;\n      overflow:auto;\n    }\n\n    h1{\n      font-size:18px;\n      margin:0 0 4px 0;\n      color:#f8fafc;\n    }\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n      margin:0 0 8px 0;\n    }\n    .box{\n      background:rgba(255,255,255,0.01);\n      border-radius:8px;\n      padding:12px;\n      border:1px solid rgba(255,255,255,0.02);\n      font-size:13px;\n      color:#dbeafe;\n    }\n\n    .controls{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .row{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n\n    button, .toggle {\n      cursor:pointer;\n      border:0;\n      border-radius:8px;\n      padding:8px 12px;\n      font-size:13px;\n      color:#0b1220;\n      background:var(--accent);\n      transition:transform .12s ease, box-shadow .12s ease;\n    }\n    button:hover{ transform:translateY(-2px); box-shadow:0 6px 18px rgba(0,0,0,0.4); }\n    .secondary{\n      background:transparent;\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.03);\n    }\n\n    .toggle{\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n    }\n\n    .mode-pill{\n      padding:6px 10px;\n      border-radius:999px;\n      font-weight:600;\n      font-size:13px;\n      color:#0b1220;\n    }\n    .mode-directed{ background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:white; }\n    .mode-undirected{ background:linear-gradient(90deg,#94a3b8,#64748b); color:white; }\n\n    .hint{\n      color:var(--muted);\n      font-size:13px;\n      line-height:1.4;\n    }\n\n    /* Main canvas */\n    .main{\n      flex:1 1 0%;\n      min-width:280px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    .canvas-wrap{\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));\n      border-radius:12px;\n      border:1px solid rgba(255,255,255,0.03);\n      flex:1 1 auto;\n      position:relative;\n      overflow:hidden;\n      display:flex;\n      flex-direction:column;\n    }\n\n    .toolbar{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      padding:12px;\n      border-bottom:1px solid rgba(255,255,255,0.02);\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n    }\n    .toolbar .note{\n      color:var(--muted);\n      font-size:13px;\n      margin-left:auto;\n    }\n\n    /* SVG area */\n    svg#graph{\n      flex:1 1 auto;\n      width:100%;\n      height:100%;\n      display:block;\n      cursor:crosshair;\n    }\n\n    /* Right info panel */\n    .right{\n      width:360px;\n      max-width:40%;\n      min-width:240px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));\n      border-radius:12px;\n      padding:12px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      border:1px solid rgba(255,255,255,0.03);\n      overflow:auto;\n    }\n    .panel-title{ font-size:14px; margin:0; color:#cfe8ff; }\n    pre, code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace; font-size:13px; color:#e2f1ff; background:transparent; margin:0; }\n\n    /* Node and edge visuals (SVG classes) */\n    .node{\n      fill:linear-gradient(180deg,#60a5fa,#7c3aed);\n      stroke:#0b1220;\n      stroke-width:2px;\n      transition:transform .14s ease;\n    }\n    circle.node {\n      fill: #0ea5e9;\n      stroke: rgba(11,18,32,0.9);\n      stroke-width:2px;\n      filter: drop-shadow(0 6px 16px rgba(14,165,233,0.12));\n    }\n    text.nlabel{\n      font-size:12px;\n      font-weight:600;\n      fill:#071025;\n      text-anchor:middle;\n      dominant-baseline:middle;\n      pointer-events:none;\n    }\n\n    path.edge-line{\n      stroke:#94a3b8;\n      stroke-width:2.5;\n      fill:none;\n      opacity:0.9;\n      transition:stroke .12s ease, stroke-width .12s ease;\n    }\n    path.edge-line.selected{\n      stroke:var(--accent);\n      stroke-width:3.6;\n      filter: drop-shadow(0 6px 14px rgba(96,165,250,0.14));\n    }\n    /* arrowhead marker styling is inlined in SVG defs */\n\n    /* small floating controls when edge selected */\n    .edge-controls{\n      position:absolute;\n      background:rgba(3,7,18,0.9);\n      border:1px solid rgba(255,255,255,0.03);\n      padding:8px;\n      border-radius:8px;\n      display:flex;\n      gap:8px;\n      align-items:center;\n      z-index:6;\n      transform:translate(-50%,-120%);\n    }\n    .edge-controls button{ padding:6px 8px; font-size:13px; }\n\n    /* Responsive adjustments */\n    @media (max-width:980px){\n      .container{ flex-direction:column; }\n      .left, .right{ width:100%; max-width:none; }\n      .main{ order:2; min-height:420px; }\n    }\n    /* Animations */\n    @keyframes pop {\n      0%{ transform:scale(.6); opacity:0; }\n      60%{ transform:scale(1.05); opacity:1; }\n      100%{ transform:scale(1); }\n    }\n\n    .node-pop{\n      animation: pop .26s cubic-bezier(.2,.9,.3,1);\n    }\n\n    .glow {\n      filter: drop-shadow(0 8px 18px rgba(124,58,237,0.18));\n    }\n\n    /* small helpers */\n    .muted-note{ color:var(--muted); font-size:13px; }\n    .kbd{ background:rgba(255,255,255,0.03); border-radius:6px; padding:4px 6px; font-weight:600; font-size:13px; color:#e6eef8; }\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"application\" aria-label=\"Interactive module: Directed vs Undirected Graphs\">\n    <aside class=\"left\" aria-label=\"Explanation and controls\">\n      <div>\n        <h1>Concept: Directed vs Undirected Graph</h1>\n        <p class=\"muted\">Explore how edge direction changes adjacency, degrees, and representation.</p>\n      </div>\n\n      <div class=\"box\" aria-hidden=\"false\">\n        <strong>Learning objective</strong>\n        <p class=\"hint\" style=\"margin-top:8px\">\n          After interacting you will be able to:\n          <ul style=\"margin:8px 0 0 18px; padding:0;\">\n            <li>Construct graphs by placing nodes and connecting them.</li>\n            <li>Switch between Directed and Undirected modes to observe differences.</li>\n            <li>See how adjacency lists, matrices, and node degrees change with direction.</li>\n          </ul>\n        </p>\n      </div>\n\n      <div class=\"controls\" aria-hidden=\"false\">\n        <div class=\"box\">\n          <div style=\"display:flex;gap:8px;align-items:center;\">\n            <div>\n              <strong>Interaction design</strong>\n              <div class=\"muted-note\" style=\"margin-top:6px\">\n                Click canvas to create nodes. Click a node to select source, then click target to create an edge. Drag nodes to reposition. Click an edge to select and reverse (in Directed mode).\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"box\">\n          <div style=\"display:flex;gap:12px;align-items:center;flex-wrap:wrap\">\n            <div>\n              <div style=\"font-size:13px;color:var(--muted);\">Graph mode</div>\n              <div style=\"margin-top:8px;display:flex;gap:8px;\">\n                <button id=\"btn-directed\" class=\"mode-pill mode-directed\" aria-pressed=\"true\">Directed</button>\n                <button id=\"btn-undirected\" class=\"mode-pill mode-undirected secondary\" aria-pressed=\"false\">Undirected</button>\n              </div>\n            </div>\n            <div style=\"margin-left:auto;\">\n              <button id=\"btn-clear\" class=\"secondary\">Clear</button>\n            </div>\n          </div>\n\n          <div style=\"margin-top:12px\" class=\"muted-note\">\n            Shortcuts: <span class=\"kbd\">Esc</span> to cancel selection, <span class=\"kbd\">Delete</span> to remove selected node/edge.\n          </div>\n        </div>\n\n        <div class=\"box\">\n          <strong>How the interaction reinforces learning</strong>\n          <p class=\"muted-note\" style=\"margin-top:8px\">\n            Visual arrows, adjacency views, and degree counters update immediately when you toggle mode or create edges — making the abstract notion of direction concrete and observable.\n          </p>\n        </div>\n\n      </div>\n    </aside>\n\n    <main class=\"main\" aria-label=\"Interactive canvas and controls\">\n      <div class=\"canvas-wrap\" aria-live=\"polite\">\n        <div class=\"toolbar\" role=\"toolbar\" aria-label=\"Canvas toolbar\">\n          <div>\n            <button id=\"mode-info\" class=\"secondary\">Mode: <span id=\"mode-pill\" style=\"font-weight:700;margin-left:8px;color:#cfe8ff\">Directed</span></button>\n          </div>\n          <div class=\"note\">Click canvas to add nodes • Click node → node to add edge • Drag nodes to move</div>\n        </div>\n\n        <!-- SVG graph area -->\n        <svg id=\"graph\" tabindex=\"0\" aria-label=\"Graph drawing area\">\n          <defs>\n            <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"14\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n              <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#94a3b8\"></path>\n            </marker>\n            <marker id=\"arrow-selected\" markerWidth=\"12\" markerHeight=\"12\" refX=\"16\" refY=\"6\" orient=\"auto\" markerUnits=\"strokeWidth\">\n              <path d=\"M0,0 L12,6 L0,12 z\" fill=\"#60a5fa\"></path>\n            </marker>\n          </defs>\n\n          <!-- edges group -->\n          <g id=\"edges\"></g>\n          <!-- nodes group -->\n          <g id=\"nodes\"></g>\n        </svg>\n\n        <!-- floating edge controls -->\n        <div id=\"edge-controls\" class=\"edge-controls\" style=\"display:none;\">\n          <div id=\"edge-info\" style=\"color:#cfe8ff;font-size:13px\">Edge controls</div>\n          <button id=\"btn-reverse\">Reverse</button>\n          <button id=\"btn-delete-edge\" class=\"secondary\">Delete</button>\n        </div>\n\n      </div>\n    </main>\n\n    <aside class=\"right\" aria-label=\"Adjacency and matrix details\">\n      <div>\n        <h3 class=\"panel-title\">Adjacency & Degrees</h3>\n        <div class=\"muted\" style=\"margin-top:6px\">Updates live when graph changes or when you toggle mode.</div>\n      </div>\n\n      <div class=\"box\" style=\"overflow:auto;\">\n        <div style=\"display:flex;gap:12px;align-items:center;margin-bottom:8px;\">\n          <strong style=\"font-size:13px\">Adjacency list</strong>\n          <div style=\"margin-left:auto\" class=\"muted-note\">Current mode: <span id=\"small-mode\" style=\"font-weight:700;color:#cfe8ff\">Directed</span></div>\n        </div>\n        <pre id=\"adj-list\" style=\"white-space:pre-wrap;min-height:90px;\">(empty)</pre>\n      </div>\n\n      <div class=\"box\" style=\"overflow:auto;\">\n        <strong style=\"font-size:13px\">Adjacency matrix</strong>\n        <div style=\"margin-top:8px; font-size:13px; color:var(--muted);\">Rows = sources, Columns = targets</div>\n        <pre id=\"adj-matrix\" style=\"margin-top:8px; white-space:pre; min-height:120px;\">(empty)</pre>\n      </div>\n\n      <div class=\"box\">\n        <strong style=\"font-size:13px\">Node degrees</strong>\n        <div id=\"deg-list\" style=\"margin-top:8px; font-size:13px; color:var(--muted)\">(empty)</div>\n      </div>\n\n    </aside>\n  </div>\n\n  <script>\n    /*****************************************************************************\n     * Graph module (vanilla JS)\n     *\n     * - Single concept: Directed vs Undirected graphs\n     * - Interactions:\n     *   * Click empty SVG to create node\n     *   * Click a node to select as source; click another to create edge\n     *   * Drag nodes to reposition\n     *   * Click edge to select; reverse/delete via floating controls (Reverse only in Directed mode)\n     *   * Toggle global graph mode (Directed/Undirected) via buttons\n     * - Visual feedback:\n     *   * Nodes pop in\n     *   * Edges get arrows in Directed mode (smooth fade)\n     *   * Selected edge glows; selected node glows; edges and lists update immediately\n     *\n     *****************************************************************************/\n\n    (function(){\n      // DOM elements\n      const svg = document.getElementById('graph');\n      const nodesG = document.getElementById('nodes');\n      const edgesG = document.getElementById('edges');\n      const btnDirected = document.getElementById('btn-directed');\n      const btnUndirected = document.getElementById('btn-undirected');\n      const modePill = document.getElementById('mode-pill');\n      const smallMode = document.getElementById('small-mode');\n      const btnClear = document.getElementById('btn-clear');\n      const adjListPre = document.getElementById('adj-list');\n      const adjMatrixPre = document.getElementById('adj-matrix');\n      const degListDiv = document.getElementById('deg-list');\n      const edgeControls = document.getElementById('edge-controls');\n      const btnReverse = document.getElementById('btn-reverse');\n      const btnDeleteEdge = document.getElementById('btn-delete-edge');\n\n      // Data model\n      let nodes = []; // {id, x, y}\n      let edges = []; // {id, sourceId, targetId}\n      let nextNodeId = 1;\n      let nextEdgeId = 1;\n\n      let state = {\n        mode: 'directed', // or 'undirected'\n        selectedNode: null, // nodeId used as source when creating edge\n        dragging: null, // {id, offsetX, offsetY}\n        selectedEdge: null, // edgeId\n      };\n\n      // Basic helpers\n      function svgPoint(evt){\n        const rect = svg.getBoundingClientRect();\n        return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };\n      }\n\n      function findNodeById(id){ return nodes.find(n => n.id === id); }\n      function findEdgeById(id){ return edges.find(e => e.id === id); }\n\n      // Render functions\n      function render(){\n        renderEdges();\n        renderNodes();\n        updateAdjViews();\n      }\n\n      function renderNodes(){\n        // Clear\n        nodesG.innerHTML = '';\n        for (const n of nodes){\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('transform', `translate(${n.x},${n.y})`);\n          g.dataset.id = n.id;\n          g.classList.add('node-group');\n\n          // circle\n          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          circle.setAttribute('r', 20);\n          circle.setAttribute('class','node');\n          circle.setAttribute('cx',0);\n          circle.setAttribute('cy',0);\n          circle.style.cursor = 'grab';\n          g.appendChild(circle);\n\n          // label\n          const label = document.createElementNS('http://www.w3.org/2000/svg','text');\n          label.setAttribute('class','nlabel');\n          label.setAttribute('x',0);\n          label.setAttribute('y',0);\n          label.textContent = n.id;\n          g.appendChild(label);\n\n          // Event handlers\n          g.addEventListener('mousedown', nodeMouseDown);\n          g.addEventListener('mouseup', nodeMouseUp);\n          g.addEventListener('dblclick', nodeDoubleClick);\n          g.addEventListener('click', nodeClick);\n\n          // Visual highlight if selected as source\n          if (state.selectedNode === n.id){\n            circle.classList.add('glow');\n            circle.style.filter = 'drop-shadow(0 6px 22px rgba(60,130,250,0.14))';\n          }\n\n          // Apply pop animation for recently created node\n          if (n._new){ circle.classList.add('node-pop'); delete n._new; }\n\n          nodesG.appendChild(g);\n        }\n      }\n\n      function renderEdges(){\n        edgesG.innerHTML = '';\n        for (const e of edges){\n          // if self-loop, render arc; otherwise render path between centers\n          const s = findNodeById(e.sourceId);\n          const t = findNodeById(e.targetId);\n          if (!s || !t) continue;\n\n          const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n          path.classList.add('edge-line');\n          path.dataset.id = e.id;\n\n          // For undirected mode we show symmetric lines without arrow markers\n          const isDirectedMode = (state.mode === 'directed');\n\n          // Compute path\n          if (s.id === t.id){\n            // self-loop as a circular arc\n            const r = 28;\n            const sx = s.x;\n            const sy = s.y;\n            const d = `M ${sx+20} ${sy} C ${sx+60} ${sy-40}, ${sx+60} ${sy+40}, ${sx+20} ${sy}`;\n            path.setAttribute('d', d);\n          } else {\n            // line with a slight curve offset for readability if opposite edge exists\n            const dx = t.x - s.x;\n            const dy = t.y - s.y;\n            const mx = (s.x + t.x) / 2;\n            const my = (s.y + t.y) / 2;\n            // check for opposite edge to curve\n            const opposite = edges.find(o => o.sourceId === e.targetId && o.targetId === e.sourceId && o.id !== e.id);\n            const curve = opposite ? 30 : 0;\n            const nx = mx + (dy / Math.hypot(dx,dy)) * curve;\n            const ny = my - (dx / Math.hypot(dx,dy)) * curve;\n            const d = `M ${s.x} ${s.y} Q ${nx} ${ny} ${t.x} ${t.y}`;\n            path.setAttribute('d', d);\n          }\n\n          // marker for arrow\n          if (isDirectedMode){\n            // directed mode: show arrow at end\n            path.setAttribute('marker-end', state.selectedEdge === e.id ? 'url(#arrow-selected)' : 'url(#arrow)');\n          } else {\n            path.removeAttribute('marker-end');\n          }\n\n          // selected styling\n          if (state.selectedEdge === e.id) path.classList.add('selected');\n\n          // events\n          path.addEventListener('click', edgeClick);\n          path.addEventListener('mouseenter', () => path.style.strokeWidth = '3.4');\n          path.addEventListener('mouseleave', () => { if (!path.classList.contains('selected')) path.style.strokeWidth = ''; });\n\n          edgesG.appendChild(path);\n        }\n      }\n\n      // Adjacency and matrix views\n      function updateAdjViews(){\n        if (nodes.length === 0){\n          adjListPre.textContent = '(empty)';\n          adjMatrixPre.textContent = '(empty)';\n          degListDiv.textContent = '(empty)';\n          return;\n        }\n        const ordered = nodes.map(n => n.id);\n        // adjacency list\n        const isDirected = (state.mode === 'directed');\n        const adj = {};\n        for (const id of ordered) adj[id] = [];\n        for (const e of edges){\n          if (isDirected){\n            adj[e.sourceId].push(e.targetId);\n          } else {\n            // undirected: add both ways but avoid duplicates\n            adj[e.sourceId].push(e.targetId);\n            if (e.sourceId !== e.targetId) adj[e.targetId].push(e.sourceId);\n          }\n        }\n        // build text\n        let listText = '';\n        for (const id of ordered){\n          const neighbors = adj[id].length ? adj[id].join(', ') : '-';\n          listText += id + ': ' + neighbors + '\\n';\n        }\n        adjListPre.textContent = listText.trim();\n\n        // adjacency matrix\n        const matrix = [];\n        for (let i=0;i<ordered.length;i++){\n          matrix[i] = Array(ordered.length).fill(0);\n        }\n        for (const e of edges){\n          const si = ordered.indexOf(e.sourceId);\n          const ti = ordered.indexOf(e.targetId);\n          if (si >= 0 && ti >= 0){\n            matrix[si][ti] = 1;\n            if (!isDirected){\n              matrix[ti][si] = 1;\n            }\n          }\n        }\n        let matrixText = '   ' + ordered.map(x=>(' '+x).slice(-3)).join('') + '\\n';\n        for (let i=0;i<ordered.length;i++){\n          matrixText += (' '+ordered[i]).slice(-3) + ' ' + matrix[i].map(v=>('  '+v).slice(-3)).join('') + '\\n';\n        }\n        adjMatrixPre.textContent = matrixText.trim();\n\n        // degrees\n        let degText = '';\n        if (isDirected){\n          // compute in/out\n          const inDeg = {};\n          const outDeg = {};\n          for (const id of ordered){ inDeg[id] = 0; outDeg[id] = 0; }\n          for (const e of edges){\n            outDeg[e.sourceId]++;\n            inDeg[e.targetId]++;\n          }\n          for (const id of ordered){\n            degText += `${id}: in=${inDeg[id]} | out=${outDeg[id]}\\n`;\n          }\n        } else {\n          const deg = {};\n          for (const id of ordered) deg[id] = 0;\n          for (const e of edges){\n            deg[e.sourceId]++;\n            if (e.sourceId !== e.targetId) deg[e.targetId]++;\n          }\n          for (const id of ordered){\n            degText += `${id}: degree=${deg[id]}\\n`;\n          }\n        }\n        degListDiv.textContent = degText.trim();\n      }\n\n      // Interaction handlers\n      svg.addEventListener('click', (evt) => {\n        // Create node if clicking on empty space (not on nodes or edges)\n        // we check event target; only create if background area clicked\n        if (evt.target === svg){\n          const p = svgPoint(evt);\n          createNode(p.x, p.y);\n        }\n      });\n\n      function createNode(x,y){\n        const id = nextNodeId++;\n        nodes.push({ id, x, y, _new:true });\n        // reset selections\n        state.selectedNode = null;\n        state.selectedEdge = null;\n        updateSelectionUI();\n        render();\n      }\n\n      // Node events: mousedown for drag, click for selection, double click to delete\n      let dragInfo = null;\n      function nodeMouseDown(evt){\n        evt.stopPropagation();\n        const g = evt.currentTarget;\n        const id = Number(g.dataset.id);\n        const point = svgPoint(evt);\n        const n = findNodeById(id);\n        dragInfo = { id, offsetX: point.x - n.x, offsetY: point.y - n.y };\n        state.dragging = true;\n        svg.style.cursor = 'grabbing';\n        window.addEventListener('mousemove', onMouseMove);\n        window.addEventListener('mouseup', onMouseUp);\n      }\n\n      function onMouseMove(evt){\n        if (!dragInfo) return;\n        const point = svgPoint(evt);\n        const n = findNodeById(dragInfo.id);\n        n.x = point.x - dragInfo.offsetX;\n        n.y = point.y - dragInfo.offsetY;\n        // keep within bounds (small padding)\n        const pad = 28;\n        n.x = Math.max(pad, Math.min(svg.clientWidth - pad, n.x));\n        n.y = Math.max(pad, Math.min(svg.clientHeight - pad, n.y));\n        render();\n      }\n\n      function onMouseUp(evt){\n        dragInfo = null;\n        state.dragging = false;\n        svg.style.cursor = 'crosshair';\n        window.removeEventListener('mousemove', onMouseMove);\n        window.removeEventListener('mouseup', onMouseUp);\n      }\n\n      function nodeMouseUp(evt){\n        evt.stopPropagation();\n      }\n\n      function nodeClick(evt){\n        evt.stopPropagation();\n        const id = Number(evt.currentTarget.dataset.id);\n        // If there is a selected node waiting, create edge from selectedNode -> id\n        if (state.selectedNode === null){\n          // select this node as source\n          state.selectedNode = id;\n          state.selectedEdge = null;\n          updateSelectionUI();\n          render();\n        } else if (state.selectedNode === id){\n          // clicked same node: interpret as cancel selection\n          state.selectedNode = null;\n          updateSelectionUI();\n          render();\n        } else {\n          // create edge from selectedNode to this id\n          const source = state.selectedNode;\n          const target = id;\n          createEdge(source, target);\n          state.selectedNode = null;\n          updateSelectionUI();\n          render();\n        }\n      }\n\n      function nodeDoubleClick(evt){\n        evt.stopPropagation();\n        const id = Number(evt.currentTarget.dataset.id);\n        // delete node and connected edges\n        nodes = nodes.filter(n => n.id !== id);\n        edges = edges.filter(e => e.sourceId !== id && e.targetId !== id);\n        if (state.selectedNode === id) state.selectedNode = null;\n        if (state.selectedEdge && !findEdgeById(state.selectedEdge)) state.selectedEdge = null;\n        render();\n      }\n\n      function createEdge(sourceId, targetId){\n        // avoid duplicate identical edges (for directed allow multiple? keep simple: no duplicates)\n        const exists = edges.find(e => e.sourceId === sourceId && e.targetId === targetId);\n        if (exists) return;\n        const id = nextEdgeId++;\n        edges.push({ id, sourceId, targetId });\n      }\n\n      // Edge click\n      function edgeClick(evt){\n        evt.stopPropagation();\n        const id = Number(evt.currentTarget.dataset.id);\n        state.selectedEdge = id;\n        state.selectedNode = null;\n        updateSelectionUI();\n        render();\n        // show edge controls near mouse\n        const rect = svg.getBoundingClientRect();\n        const clientX = evt.clientX;\n        const clientY = evt.clientY;\n        edgeControls.style.display = 'flex';\n        edgeControls.style.left = (clientX - rect.left) + 'px';\n        edgeControls.style.top = (clientY - rect.top) + 'px';\n        // show or hide reverse based on mode\n        btnReverse.disabled = (state.mode !== 'directed');\n        btnReverse.style.opacity = (state.mode === 'directed') ? '1' : '0.5';\n      }\n\n      // Outside click to clear selection\n      document.addEventListener('click', (evt) => {\n        if (!evt.target.closest('#graph') && !evt.target.closest('.edge-controls')){\n          state.selectedNode = null;\n          state.selectedEdge = null;\n          updateSelectionUI();\n          render();\n          edgeControls.style.display = 'none';\n        }\n      });\n\n      // Edge controls\n      btnReverse.addEventListener('click', () => {\n        if (!state.selectedEdge) return;\n        if (state.mode !== 'directed') return;\n        const e = findEdgeById(state.selectedEdge);\n        if (e){\n          // reverse\n          const tmp = e.sourceId;\n          e.sourceId = e.targetId;\n          e.targetId = tmp;\n          render();\n        }\n      });\n\n      btnDeleteEdge.addEventListener('click', () => {\n        if (!state.selectedEdge) return;\n        edges = edges.filter(e => e.id !== state.selectedEdge);\n        state.selectedEdge = null;\n        edgeControls.style.display = 'none';\n        render();\n      });\n\n      // Mode buttons\n      function setMode(m){\n        state.mode = m;\n        modePill.textContent = m[0].toUpperCase() + m.slice(1);\n        smallMode.textContent = modePill.textContent;\n        btnDirected.setAttribute('aria-pressed', m === 'directed');\n        btnUndirected.setAttribute('aria-pressed', m === 'undirected');\n        if (m === 'directed'){\n          btnDirected.classList.remove('secondary');\n          btnDirected.classList.add('mode-directed');\n          btnUndirected.classList.remove('mode-undirected');\n          btnUndirected.classList.add('secondary');\n        } else {\n          btnUndirected.classList.remove('secondary');\n          btnUndirected.classList.add('mode-undirected');\n          btnDirected.classList.remove('mode-directed');\n          btnDirected.classList.add('secondary');\n        }\n        // toggling mode updates rendering (arrows appear/disappear) and adjacency views\n        render();\n      }\n\n      btnDirected.addEventListener('click', () => setMode('directed'));\n      btnUndirected.addEventListener('click', () => setMode('undirected'));\n      btnClear.addEventListener('click', () => {\n        nodes = []; edges = []; nextNodeId = 1; nextEdgeId = 1;\n        state.selectedNode = null; state.selectedEdge = null;\n        render();\n      });\n\n      // Keyboard shortcuts\n      window.addEventListener('keydown', (evt) => {\n        if (evt.key === 'Escape'){\n          state.selectedNode = null;\n          state.selectedEdge = null;\n          edgeControls.style.display = 'none';\n          render();\n        }\n        if (evt.key === 'Delete' || evt.key === 'Backspace'){\n          if (state.selectedEdge){\n            edges = edges.filter(e => e.id !== state.selectedEdge);\n            state.selectedEdge = null;\n            edgeControls.style.display = 'none';\n            render();\n            evt.preventDefault();\n          } else if (state.selectedNode){\n            const id = state.selectedNode;\n            nodes = nodes.filter(n => n.id !== id);\n            edges = edges.filter(e => e.sourceId !== id && e.targetId !== id);\n            state.selectedNode = null;\n            render();\n            evt.preventDefault();\n          }\n        }\n      });\n\n      // Cancel drag on mouse up anywhere\n      svg.addEventListener('mouseup', () => {\n        dragInfo = null;\n        state.dragging = false;\n      });\n\n      // Initialize with some sample nodes to quickly show differences\n      (function seed(){\n        // optional: create a small example\n        createNode(140, 120);\n        createNode(340, 120);\n        createNode(240, 240);\n        // create sample edges\n        createEdge(1,2);\n        createEdge(2,3);\n        createEdge(3,1);\n        render();\n      })();\n\n      // Selection UI update\n      function updateSelectionUI(){\n        // hide edge controls if no edge selected\n        if (!state.selectedEdge) edgeControls.style.display = 'none';\n      }\n\n      // Initial render\n      render();\n\n      // Accessibility: focus the SVG for keyboard hints\n      svg.addEventListener('focus', () => {\n        svg.style.outline = '2px solid rgba(96,165,250,0.18)';\n      });\n      svg.addEventListener('blur', () => {\n        svg.style.outline = '';\n      });\n\n      // Make sure adj view updates when window resizes (for aesthetic)\n      window.addEventListener('resize', render);\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Graph (Directed/Undirected).\n\n**Project Overview:**\nTopic: Graph (Directed/Undirected)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Graph (Directed/Undirected)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "7788c4d0-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:45:28.296Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Binary Search Tree (BST)",
    "answer": {
      "role": "assistant",
      "content": "Concept Title:\nInteractive Binary Search Tree (BST) — Visual Insert & Search\n\nLearning Objective:\nAfter using this module, users will be able to:\n- Understand how values are placed in a BST during insertion (left for smaller, right for larger).\n- See the decision path the algorithm takes when inserting or searching a value.\n- Visually trace and interpret the runtime behavior of BST operations.\n\nInteraction Design:\n- Primary controls:\n  - Numeric input (0–999) + \"Insert\" button: Adds a value to the BST.\n  - Numeric input + \"Search\" button: Highlights the path used to search and indicates success/failure.\n  - \"Insert Random\" button: Inserts a small batch of random values with animation to build a tree.\n  - \"Clear\" button: Resets the visualization.\n- How user interactions behave and why they reinforce learning:\n  - Insert:\n    - A node \"ball\" is created at the top center and animates down to its final position while the tree is traversed.\n    - Each visited node is briefly highlighted (pulse + color change), showing the path comparisons: users see \"less than\" vs \"greater than\" decisions.\n    - After arrival, connecting edges appear and the tree reflows to maintain a tidy layout (positions computed by in-order spacing).\n    - Duplicate insert attempts are rejected with an explanation message.\n  - Search:\n    - On search, the algorithm traverses from the root to the candidate node. Each visited node pulses and the path line is emphasized.\n    - If found, the target node does a green pulse animation; if not found, the last visited node flashes red and a message explains why the value isn't present.\n  - Insert Random:\n    - Adds several values sequentially with a short delay so users can watch a tree being built step-by-step.\n  - Clear:\n    - Smoothly removes all nodes and edges and resets the state.\n- Visual/animation feedback:\n  - Node movement uses CSS transitions (transform) to animate nodes into place.\n  - \"Visiting\" nodes get a pulsing glow (CSS animation).\n  - Search success/failure uses color pulses to clearly indicate outcome.\n  - Edges animate into place when nodes settle.\n- Accessibility and keyboard support:\n  - Inputs and buttons have aria-labels.\n  - Enter key triggers Insert (when input focused).\n  - Color choices and focus outlines for keyboard navigation.\n  - Buttons sized and spaced to meet touch targets and minimum spacing rules.\n\nLayout Description:\n- Overall safe area: 24 px padding on all sides of the viewport (as required).\n- Top section: Title and learning objective (concise).\n- Main body: A responsive two-column layout on wide screens and a stacked layout on narrow screens.\n  - Left column (controls + messages) with the form controls stacked with at least 16 px gap.\n  - Right column (visualization) shows the tree using an SVG canvas that scales to available space.\n- Visualization area:\n  - The SVG sits inside a card with padding and a neutral background to keep focus.\n  - Node spacing: horizontally determined by in-order positions to avoid overlap, vertical spacing by depth (depth spacing ~90 px).\n- Minimum spacing: At least 16 px between interactive elements (buttons, input, legend, messages).\n- Responsiveness:\n  - On small screens, controls collapse above the visualization; tree canvas resizes and nodes keep readable size.\n  - All critical UI elements remain reachable via keyboard and screen readers.\n- Visual hierarchy and balance:\n  - Controls and explanations on the left (concise), the larger visualization on the right for emphasis.\n  - Messages appear beneath controls and update dynamically to explain each action.\n\nImplementation (self-contained HTML/CSS/JavaScript):\n- Vanilla HTML/CSS/JS only — no external libraries or assets.\n- Clean, consistent formatting and indentation.\n- The file below contains the interactive module described above. Save it as an .html file and open in a browser.\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive BST — Insert & Search Visualization</title>\n  <style>\n    :root{\n      --safe-padding: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --card: #071021;\n      --accent: #4fd1c5;\n      --accent-2: #63b3ed;\n      --muted: #94a3b8;\n      --success: #16a34a;\n      --danger: #ef4444;\n      --node-fill: #0ea5a1;\n      --node-stroke: #08333a;\n      --text: #e6eef6;\n      --transition: 600ms;\n    }\n\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071021 0%, #031027 100%);\n      color:var(--text);\n      font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;\n    }\n\n    /* Safe area */\n    .app {\n      box-sizing:border-box;\n      padding:var(--safe-padding);\n      min-height:100vh;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    header {\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n    h1 {\n      margin:0;\n      font-size:1.25rem;\n      letter-spacing:0.2px;\n    }\n    p.lead {\n      margin:0;\n      color:var(--muted);\n      font-size:0.95rem;\n    }\n\n    main {\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      width:100%;\n      flex:1 1 auto;\n    }\n\n    /* Controls panel */\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      padding:16px;\n      border-radius:10px;\n      width:320px;\n      min-width:240px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    .controls {\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n\n    input[type=\"number\"]{\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.06);\n      background:rgba(255,255,255,0.02);\n      color:var(--text);\n      width:120px;\n      font-size:1rem;\n      outline:none;\n    }\n    input[type=\"number\"]::placeholder{ color: #8aa0b6; }\n\n    button {\n      background: linear-gradient(180deg, var(--accent) 0%, var(--accent-2) 100%);\n      color: #022;\n      border: none;\n      padding:10px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      box-shadow: 0 6px 14px rgba(6,20,33,0.6);\n      transition: transform 120ms ease, box-shadow 120ms ease;\n    }\n    button.secondary {\n      background: transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--text);\n      box-shadow:none;\n    }\n    button:active { transform:translateY(1px); }\n\n    .small {\n      padding:8px 10px;\n      font-size:0.95rem;\n    }\n\n    .status {\n      font-size:0.95rem;\n      color:var(--muted);\n      background:rgba(0,0,0,0.04);\n      padding:10px;\n      border-radius:8px;\n      min-height:48px;\n    }\n\n    /* Visualization area */\n    .vis-card {\n      flex:1 1 auto;\n      min-height:420px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border:1px solid rgba(255,255,255,0.03);\n      border-radius:10px;\n      padding:12px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n    }\n\n    .vis-top {\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:12px;\n    }\n    .legend {\n      display:flex;\n      gap:8px;\n      align-items:center;\n      color:var(--muted);\n      font-size:0.9rem;\n    }\n    .legend .chip {\n      display:inline-flex;\n      gap:8px;\n      align-items:center;\n      background:rgba(255,255,255,0.02);\n      padding:6px 8px;\n      border-radius:999px;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n\n    /* SVG area */\n    .stage {\n      background:linear-gradient(180deg, rgba(10,14,20,0.6), rgba(8,10,16,0.6));\n      border-radius:8px;\n      flex:1 1 auto;\n      position:relative;\n      overflow:hidden;\n      min-height:320px;\n    }\n\n    svg {\n      width:100%;\n      height:100%;\n      display:block;\n    }\n\n    /* Node styles */\n    .node {\n      cursor:pointer;\n      transition: transform var(--transition) ease, opacity var(--transition) ease;\n      transform-origin: center center;\n    }\n    .node circle {\n      fill:var(--node-fill);\n      stroke:var(--node-stroke);\n      stroke-width:2px;\n    }\n    .node text {\n      fill: #022;\n      font-weight:700;\n      font-size:13px;\n      text-anchor:middle;\n      dominant-baseline:middle;\n    }\n\n    .edge {\n      stroke:rgba(255,255,255,0.12);\n      stroke-width:2px;\n      transition: opacity var(--transition) ease;\n      stroke-linecap:round;\n    }\n\n    /* Visiting highlight */\n    @keyframes pulse {\n      0%{ filter: drop-shadow(0 0 0 rgba(79,209,197,0.0)); transform:scale(1); }\n      50%{ filter: drop-shadow(0 8px 14px rgba(79,209,197,0.18)); transform:scale(1.06); }\n      100%{ filter: drop-shadow(0 0 0 rgba(79,209,197,0.0)); transform:scale(1); }\n    }\n    .visiting circle {\n      stroke: #d8fdf8;\n      stroke-width:3px;\n      animation: pulse 700ms ease-in-out infinite;\n    }\n    .found circle {\n      stroke: var(--success);\n      stroke-width:4px;\n      animation: pulse 800ms ease-in-out 3;\n    }\n    .notfound circle {\n      stroke: var(--danger);\n      stroke-width:4px;\n      animation: pulse 800ms ease-in-out 2;\n    }\n\n    /* small screens: stack panels */\n    @media (max-width:880px){\n      main { flex-direction:column; }\n      .panel { width:100%; min-width:unset; }\n    }\n\n    /* Accessibility focus outlines */\n    button:focus, input:focus {\n      outline: 3px solid rgba(99,179,255,0.16);\n      outline-offset:2px;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Binary Search Tree interactive visualization\">\n    <header>\n      <h1>Interactive Binary Search Tree — Insert & Search</h1>\n      <p class=\"lead\">Type a number and Insert to see how a Binary Search Tree places values. Search highlights comparison path.</p>\n    </header>\n\n    <main>\n      <aside class=\"panel\" aria-label=\"controls\">\n        <div>\n          <label for=\"valueInput\" style=\"display:block;margin-bottom:6px;font-weight:600;\">Value (0–999)</label>\n          <div style=\"display:flex;gap:8px;align-items:center;\">\n            <input id=\"valueInput\" type=\"number\" min=\"0\" max=\"999\" placeholder=\"e.g., 42\" aria-label=\"Value to insert or search\" />\n            <button id=\"insertBtn\" class=\"small\" aria-label=\"Insert value\">Insert</button>\n            <button id=\"searchBtn\" class=\"small secondary\" aria-label=\"Search value\">Search</button>\n          </div>\n        </div>\n\n        <div style=\"display:flex;gap:12px;\">\n          <button id=\"randomBtn\" class=\"small\" aria-label=\"Insert random values\">Insert Random</button>\n          <button id=\"clearBtn\" class=\"small secondary\" aria-label=\"Clear tree\">Clear</button>\n        </div>\n\n        <div class=\"status\" id=\"message\" role=\"status\" aria-live=\"polite\">Tip: Use Insert to add nodes. Search to trace comparisons.</div>\n\n        <div style=\"display:flex;flex-direction:column;gap:8px;\">\n          <strong style=\"font-size:0.95rem;\">Legend</strong>\n          <div style=\"display:flex;gap:8px;flex-wrap:wrap;\">\n            <div class=\"chip\" style=\"background:rgba(79,209,197,0.12);padding:6px 8px;border-radius:8px;\">\n              <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" style=\"margin-right:6px\"><circle cx=\"12\" cy=\"12\" r=\"7\" fill=\"#0ea5a1\" stroke=\"#08333a\" stroke-width=\"1.6\"/></svg><span style=\"color:var(--muted)\">Node</span>\n            </div>\n            <div class=\"chip\" style=\"background:rgba(79,209,197,0.06);padding:6px 8px;border-radius:8px;\">\n              <span style=\"width:14px;height:14px;border-radius:3px;background:var(--accent);display:inline-block;margin-right:6px;\"></span><span style=\"color:var(--muted)\">Visited</span>\n            </div>\n            <div class=\"chip\" style=\"background:rgba(22,163,74,0.06);padding:6px 8px;border-radius:8px;\">\n              <span style=\"width:14px;height:14px;border-radius:3px;background:var(--success);display:inline-block;margin-right:6px;\"></span><span style=\"color:var(--muted)\">Found</span>\n            </div>\n          </div>\n        </div>\n      </aside>\n\n      <section class=\"vis-card\" aria-label=\"visualization\">\n        <div class=\"vis-top\">\n          <div style=\"color:var(--muted);font-size:0.95rem;\">Tree Visualization</div>\n          <div class=\"legend\" aria-hidden=\"true\">\n            <div class=\"chip\">Nodes animate into position</div>\n            <div class=\"chip\">Traversal highlights decisions</div>\n          </div>\n        </div>\n\n        <div class=\"stage\" id=\"stage\" role=\"region\" aria-label=\"Binary search tree stage\">\n          <svg id=\"svgRoot\" viewBox=\"0 0 1200 640\" preserveAspectRatio=\"xMidYMid meet\" aria-hidden=\"false\"></svg>\n        </div>\n      </section>\n    </main>\n  </div>\n\n  <script>\n    // Simple BST visualization for Insert & Search (vanilla JS)\n    (function(){\n      const svg = document.getElementById('svgRoot');\n      const insertBtn = document.getElementById('insertBtn');\n      const searchBtn = document.getElementById('searchBtn');\n      const randomBtn = document.getElementById('randomBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const input = document.getElementById('valueInput');\n      const message = document.getElementById('message');\n      const stage = document.getElementById('stage');\n\n      // Layout settings\n      const WIDTH = 1200;\n      const HEIGHT = 640;\n      const V_SPACING = 92;   // vertical distance between levels\n      const NODE_RADIUS = 22;\n      const H_GAP = 56;       // minimum horizontal gap\n\n      svg.setAttribute('viewBox', `0 0 ${WIDTH} ${HEIGHT}`);\n\n      // Data model\n      let root = null;\n      let nodes = []; // flat array of node objects for easy DOM mapping\n      let idCounter = 1;\n      const TRANSITION_MS = 600;\n\n      // Create groups for edges and nodes\n      const edgesGroup = createSVG('g', {class:'edges'});\n      const nodesGroup = createSVG('g', {class:'nodes'});\n      svg.appendChild(edgesGroup);\n      svg.appendChild(nodesGroup);\n\n      // Utility helpers\n      function createSVG(tag, attrs = {}) {\n        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);\n        for (const k in attrs) el.setAttribute(k, attrs[k]);\n        return el;\n      }\n\n      function log(msg, type='info') {\n        message.textContent = msg;\n        if (type === 'error') message.style.color = 'var(--danger)';\n        else if (type === 'success') message.style.color = 'var(--success)';\n        else message.style.color = 'var(--muted)';\n      }\n\n      function clampVal(v) {\n        if (Number.isFinite(v)) return Math.max(0, Math.min(999, Math.trunc(v)));\n        return null;\n      }\n\n      // BST node creation\n      function makeNode(value) {\n        return {\n          id: idCounter++,\n          value: value,\n          left: null,\n          right: null,\n          parent: null,\n          x: WIDTH/2,\n          y: 40,\n          gx: WIDTH/2,\n          gy: 40\n        };\n      }\n\n      // Insert value into model (no DOM animation here)\n      function insertValueModel(val) {\n        const node = makeNode(val);\n        if (!root) { root = node; nodes.push(node); return {node, path: [node]}; }\n        let cur = root;\n        const path = [cur];\n        while (true) {\n          if (val === cur.value) {\n            return {duplicate: true, node: cur, path};\n          } else if (val < cur.value) {\n            if (cur.left) {\n              cur = cur.left;\n              path.push(cur);\n            } else {\n              cur.left = node;\n              node.parent = cur;\n              nodes.push(node);\n              path.push(node);\n              break;\n            }\n          } else {\n            if (cur.right) {\n              cur = cur.right;\n              path.push(cur);\n            } else {\n              cur.right = node;\n              node.parent = cur;\n              nodes.push(node);\n              path.push(node);\n              break;\n            }\n          }\n        }\n        return {node, path};\n      }\n\n      // Clear everything\n      function clearAll() {\n        root = null;\n        nodes = [];\n        idCounter = 1;\n        while (nodesGroup.firstChild) nodesGroup.removeChild(nodesGroup.firstChild);\n        while (edgesGroup.firstChild) edgesGroup.removeChild(edgesGroup.firstChild);\n        log('Tree cleared. Insert a value to begin.');\n      }\n\n      // Compute positions using inorder traversal to assign x\n      function layoutTree() {\n        let xpos = 60; // left padding\n        function inorder(n, depth=0) {\n          if (!n) return;\n          inorder(n.left, depth+1);\n          n.gx = xpos;\n          n.gy = 60 + depth * V_SPACING;\n          xpos += Math.max(H_GAP, NODE_RADIUS*2 + 10);\n          inorder(n.right, depth+1);\n        }\n        inorder(root);\n        // ensure nodes are within bounds: scale if exceed width\n        const maxX = Math.max(...nodes.map(n => n.gx), WIDTH);\n        const scale = Math.min(1, (WIDTH - 80) / Math.max(maxX, WIDTH));\n        if (scale < 1) {\n          nodes.forEach(n => { n.gx = 60 + (n.gx - 60) * scale; });\n        }\n      }\n\n      // Draw or update DOM nodes and edges\n      function syncDOM() {\n        // Ensure layout updated\n        layoutTree();\n\n        // Map nodes by id to DOM elements\n        const existing = {};\n        for (const g of Array.from(nodesGroup.children)) {\n          const id = Number(g.getAttribute('data-id'));\n          existing[id] = g;\n        }\n\n        // Create/Update node elements\n        nodes.forEach(n => {\n          let g = existing[n.id];\n          if (!g) {\n            g = createSVG('g', {class:'node', 'data-id': n.id});\n            const circle = createSVG('circle', {r: NODE_RADIUS});\n            const text = createSVG('text', {});\n            text.textContent = n.value;\n            g.appendChild(circle);\n            g.appendChild(text);\n\n            // initial at top center (for animated insertion)\n            g.setAttribute('transform', `translate(${WIDTH/2},40)`);\n            g.style.opacity = '0';\n            nodesGroup.appendChild(g);\n          } else {\n            // update text in case values change (shouldn't)\n            const txt = g.querySelector('text');\n            if (txt) txt.textContent = n.value;\n          }\n        });\n\n        // Remove DOM nodes that no longer exist\n        Array.from(nodesGroup.children).forEach(g => {\n          const id = Number(g.getAttribute('data-id'));\n          if (!nodes.find(n => n.id === id)) {\n            g.remove();\n          }\n        });\n\n        // Update edges\n        while (edgesGroup.firstChild) edgesGroup.removeChild(edgesGroup.firstChild);\n        nodes.forEach(n => {\n          if (n.left) {\n            const l = createSVG('line', {class:'edge'});\n            edgesGroup.appendChild(l);\n            // set will be updated below\n          }\n          if (n.right) {\n            const r = createSVG('line', {class:'edge'});\n            edgesGroup.appendChild(r);\n          }\n        });\n\n        // After creation, set transforms/positions with transitions\n        // Delay slightly to allow initial insertion position to be visible\n        requestAnimationFrame(() => {\n          nodes.forEach(n => {\n            const g = nodesGroup.querySelector(`g[data-id=\"${n.id}\"]`);\n            if (g) {\n              g.style.opacity = '1';\n              g.style.transition = `transform ${TRANSITION_MS}ms cubic-bezier(.2,.9,.2,1), opacity ${TRANSITION_MS}ms`;\n              g.setAttribute('transform', `translate(${n.gx},${n.gy})`);\n              // store logical coords for edges\n              n.x = n.gx;\n              n.y = n.gy;\n            }\n          });\n\n          // update edges lines\n          const edgeLines = Array.from(edgesGroup.querySelectorAll('line'));\n          let idx = 0;\n          nodes.forEach(n => {\n            if (n.left) {\n              const ln = edgeLines[idx++];\n              ln.setAttribute('x1', n.x);\n              ln.setAttribute('y1', n.y);\n              ln.setAttribute('x2', n.left.x);\n              ln.setAttribute('y2', n.left.y);\n              ln.style.opacity = '1';\n            }\n            if (n.right) {\n              const ln = edgeLines[idx++];\n              ln.setAttribute('x1', n.x);\n              ln.setAttribute('y1', n.y);\n              ln.setAttribute('x2', n.right.x);\n              ln.setAttribute('y2', n.right.y);\n              ln.style.opacity = '1';\n            }\n          });\n        });\n      }\n\n      // Traversal animation helpers\n      function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }\n\n      async function animateInsert(val) {\n        const v = clampVal(Number(val));\n        if (v === null || Number.isNaN(v)) { log('Enter a number between 0 and 999.', 'error'); return; }\n        log('Inserting ' + v + '...');\n\n        // Prepare a temp DOM node at top center to animate along the path\n        const {node, duplicate, path} = insertValueModel(v);\n\n        if (duplicate) {\n          // animate a quick visit highlight path to show where duplicate was found\n          await animateTraversalPath(path, /*highlightFinal*/ true, /*messageOnComplete*/ `Value ${v} already exists — BST does not allow duplicates.`);\n          // remove the duplicate node we added to nodes array in model function\n          // (insertValueModel returns existing node when duplicate; our nodes array didn't gain new element)\n          return;\n        }\n\n        // Create DOM elements for all nodes (new one included) — initial pos set in syncDOM\n        syncDOM();\n\n        // Animate traversal: highlight nodes in path sequentially (excluding final placement)\n        // For insertion visualize: highlight parent nodes until the spot\n        const animPath = path.slice(0, path.length - 1); // nodes visited before placing new one\n        await animateTraversalPath(animPath, /*highlightFinal*/ false);\n\n        // Move the new node from top center to its position (transform already set in syncDOM)\n        // The element already exists at top center; setting transform in syncDOM animates it to final spot\n        // Wait for transition completion\n        await sleep(TRANSITION_MS + 40);\n\n        log(`Inserted ${v}.`);\n      }\n\n      async function animateSearch(val) {\n        const v = clampVal(Number(val));\n        if (v === null || Number.isNaN(v)) { log('Enter a number between 0 and 999.', 'error'); return; }\n        if (!root) { log('The tree is empty. Insert a value first.', 'error'); return; }\n        log(`Searching for ${v}...`);\n\n        const path = [];\n        let cur = root;\n        while (cur) {\n          path.push(cur);\n          if (v === cur.value) break;\n          cur = (v < cur.value) ? cur.left : cur.right;\n        }\n        const found = path.length && path[path.length-1].value === v;\n\n        await animateTraversalPath(path, /*highlightFinal*/ true, found ? `Found ${v}.` : `Value ${v} not found.`);\n      }\n\n      // Animate a sequence of nodes being visited (pulsing), optionally highlight final node found/duplicate\n      async function animateTraversalPath(path, highlightFinal=true, finalMessage=null) {\n        // clear any previous classes\n        nodesGroup.querySelectorAll('g.node').forEach(g => {\n          g.classList.remove('visiting','found','notfound');\n        });\n\n        for (let i=0;i<path.length;i++) {\n          const n = path[i];\n          const g = nodesGroup.querySelector(`g[data-id=\"${n.id}\"]`);\n          if (!g) continue;\n          g.classList.add('visiting');\n          // message describing decision\n          if (i < path.length - 1) {\n            const next = path[i+1];\n            const dir = (next.value < n.value) ? 'left' : 'right';\n            log(`Visiting ${n.value} — ${dir} child (comparing ${next.value}).`);\n          } else {\n            log(`Visiting ${n.value} — reached end of path.`);\n          }\n          await sleep(560);\n          g.classList.remove('visiting');\n        }\n\n        if (path.length === 0) return;\n\n        const last = path[path.length-1];\n        const lastG = nodesGroup.querySelector(`g[data-id=\"${last.id}\"]`);\n        if (highlightFinal && lastG) {\n          // Determine if it's a success (found) or failure\n          // Found when the last node value equals target; otherwise last visited is where we'd insert -> failure\n          // We'll observe class externally: caller may supply finalMessage to indicate found or not\n          const isFound = (finalMessage && finalMessage.startsWith('Found')) || false;\n          if (isFound) {\n            lastG.classList.add('found');\n            log(finalMessage || `Found ${last.value}.`, 'success');\n          } else {\n            lastG.classList.add('notfound');\n            log(finalMessage || `Not found.`, 'error');\n          }\n          await sleep(900);\n          lastG.classList.remove('found','notfound');\n        } else if (finalMessage) {\n          log(finalMessage);\n        }\n      }\n\n      // UI bindings\n      insertBtn.addEventListener('click', async () => {\n        insertBtn.disabled = true;\n        searchBtn.disabled = true;\n        randomBtn.disabled = true;\n        clearBtn.disabled = true;\n        await animateInsert(input.value);\n        syncDOM();\n        insertBtn.disabled = false;\n        searchBtn.disabled = false;\n        randomBtn.disabled = false;\n        clearBtn.disabled = false;\n      });\n\n      searchBtn.addEventListener('click', async () => {\n        insertBtn.disabled = true;\n        searchBtn.disabled = true;\n        randomBtn.disabled = true;\n        clearBtn.disabled = true;\n        await animateSearch(input.value);\n        insertBtn.disabled = false;\n        searchBtn.disabled = false;\n        randomBtn.disabled = false;\n        clearBtn.disabled = false;\n      });\n\n      clearBtn.addEventListener('click', () => {\n        clearAll();\n      });\n\n      randomBtn.addEventListener('click', async () => {\n        // Insert a few random numbers sequentially to build tree\n        const count = 6;\n        const values = [];\n        while (values.length < count) {\n          const n = Math.floor(Math.random() * 200);\n          if (!values.includes(n)) values.push(n);\n        }\n        insertBtn.disabled = true;\n        searchBtn.disabled = true;\n        randomBtn.disabled = true;\n        clearBtn.disabled = true;\n        for (const v of values) {\n          input.value = v;\n          await animateInsert(v);\n        }\n        syncDOM();\n        insertBtn.disabled = false;\n        searchBtn.disabled = false;\n        randomBtn.disabled = false;\n        clearBtn.disabled = false;\n        log('Inserted random values.');\n      });\n\n      // Keyboard: Enter in input triggers Insert\n      input.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n          e.preventDefault();\n          insertBtn.click();\n        }\n      });\n\n      // Initialize with a small hint\n      log('Tip: Enter a number and press Insert. Try Insert Random to see a tree build.');\n      // Ensure stage resizes nicely on window changes\n      window.addEventListener('resize', () => {\n        // nothing needed; SVG scales with viewBox, but we still re-sync for crispness\n        syncDOM();\n      });\n\n      // Expose some helpers for debugging (optional)\n      window.bstviz = { syncDOM, clearAll };\n\n    })();\n  </script>\n</body>\n</html>\n```\n\nUsage notes:\n- Type a number (0–999) and press Insert to watch the BST insertion process. The algorithm visually compares nodes and moves the new node to its final position.\n- Use Search to trace the path taken when looking for a value; the path pulses and the result is clearly indicated.\n- Insert Random demonstrates sequential insertions to help users see how a tree grows.\n- Clear resets the visualization.\n\nThis single module focuses on one clear concept — how BST insertion and search decisions place and locate values — with interactive animation and descriptive feedback to reinforce understanding."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Binary Search Tree (BST).\n\n**Project Overview:**\nTopic: Binary Search Tree (BST)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Binary Search Tree (BST)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Finite state machine modelling the interactive Binary Search Tree insert & search visualization (user interactions, animations, traversal highlighting, random inserts, and clearing).",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "CLICK_INSERT": "inserting",
            "INPUT_ENTER": "inserting",
            "CLICK_SEARCH": "searching",
            "CLICK_RANDOM": "random_inserting",
            "CLICK_CLEAR": "clearing"
          }
        },
        {
          "name": "inserting",
          "onEnter": "disableControls_and_startInsert",
          "onExit": "noop",
          "on": {
            "VALIDATION_FAIL": "idle",
            "INSERT_MODEL_DUPLICATE": "animating_traversal",
            "INSERT_MODEL_OK": "animating_traversal"
          }
        },
        {
          "name": "searching",
          "onEnter": "disableControls_and_startSearch",
          "onExit": "noop",
          "on": {
            "VALIDATION_FAIL": "idle",
            "EMPTY_TREE": "idle",
            "SEARCH_TRAVERSAL_STARTED": "animating_traversal"
          }
        },
        {
          "name": "animating_traversal",
          "onEnter": "startTraversalAnimation",
          "onExit": "clearTraversalClasses",
          "on": {
            "TRAVERSAL_COMPLETE_INSERT_PLACE": "placing_node",
            "TRAVERSAL_COMPLETE_INSERT_DUPLICATE": "showing_result",
            "TRAVERSAL_COMPLETE_SEARCH_FOUND": "showing_result",
            "TRAVERSAL_COMPLETE_SEARCH_NOTFOUND": "showing_result"
          }
        },
        {
          "name": "placing_node",
          "onEnter": "animatePlacement_and_syncDOM",
          "onExit": "noop",
          "on": {
            "ANIMATION_END": "showing_result"
          }
        },
        {
          "name": "showing_result",
          "onEnter": "logResult_and_enableControls",
          "onExit": "noop",
          "on": {
            "COMPLETE": "idle"
          }
        },
        {
          "name": "random_inserting",
          "onEnter": "disableControls_and_startRandomSequence",
          "onExit": "enableControls",
          "on": {
            "RANDOM_INSERT_STEP": "inserting",
            "RANDOM_INSERT_COMPLETE": "idle"
          }
        },
        {
          "name": "clearing",
          "onEnter": "clearAll_and_log",
          "onExit": "noop",
          "on": {
            "CLEARED": "idle"
          }
        }
      ],
      "events": [
        "CLICK_INSERT",
        "INPUT_ENTER",
        "CLICK_SEARCH",
        "CLICK_RANDOM",
        "CLICK_CLEAR",
        "VALIDATION_FAIL",
        "INSERT_MODEL_OK",
        "INSERT_MODEL_DUPLICATE",
        "SEARCH_TRAVERSAL_STARTED",
        "EMPTY_TREE",
        "TRAVERSAL_COMPLETE_INSERT_PLACE",
        "TRAVERSAL_COMPLETE_INSERT_DUPLICATE",
        "TRAVERSAL_COMPLETE_SEARCH_FOUND",
        "TRAVERSAL_COMPLETE_SEARCH_NOTFOUND",
        "ANIMATION_END",
        "COMPLETE",
        "RANDOM_INSERT_STEP",
        "RANDOM_INSERT_COMPLETE",
        "CLEARED"
      ],
      "notes": "Controls are disabled at the start of insert/search/random operations and re-enabled when animations complete. Traversal animation uses CSS classes (visiting, found, notfound). insertValueModel performs model changes and returns duplicate or success; syncDOM/layoutTree update the SVG DOM and animate node placement. Clear is immediate. Events such as INSERT_MODEL_OK / DUPLICATE and traversal completion are emitted by the internal procedures and drive transitions between traversal, placement and result states."
    }
  },
  {
    "id": "6b3f2b60-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:45:31.214Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Binary Tree",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Binary Tree — Interactive Module</title>\n  <style>\n    :root{\n      --safe-padding: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #60a5fa;\n      --muted: #94a3b8;\n      --card: #071026;\n      --success: #34d399;\n      --danger: #fb7185;\n      --node-bg: linear-gradient(180deg,#1f2937,#111827);\n      --glass: rgba(255,255,255,0.03);\n      --font-sans: system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      font-family: var(--font-sans);\n      background: linear-gradient(180deg,#071021 0%, #081129 60%, #041018 100%);\n      color:#e6eef8;\n    }\n    /* Safe area container */\n    .container{\n      padding: var(--safe-padding);\n      box-sizing:border-box;\n      min-height:100vh;\n      display:flex;\n      gap:var(--gap);\n      align-items:stretch;\n    }\n\n    /* Left control column */\n    .panel{\n      width:360px;\n      max-width:40%;\n      min-width:300px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:20px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);\n    }\n\n    h1{\n      margin:0;\n      font-size:18px;\n      letter-spacing:0.2px;\n    }\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n      margin-top:6px;\n    }\n\n    .card{\n      background:var(--card);\n      border-radius:10px;\n      padding:12px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:10px;\n    }\n    label{ font-size:13px; color:var(--muted); }\n    input[type=\"text\"], input[type=\"number\"], select {\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:inherit;\n      padding:8px 10px;\n      border-radius:8px;\n      outline:none;\n    }\n    input:focus, select:focus { box-shadow: 0 0 0 4px rgba(96,165,250,0.08); border-color:var(--accent); }\n\n    .row { display:flex; gap:12px; align-items:center; }\n    button {\n      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.06);\n      color:inherit;\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      transition: transform .08s ease, box-shadow .12s ease;\n      font-weight:600;\n    }\n    button:active{ transform: translateY(1px); }\n    button.primary{\n      background: linear-gradient(180deg, #60a5fa22, #3b82f622);\n      border-color: rgba(96,165,250,0.24);\n      box-shadow: 0 6px 18px rgba(59,130,246,0.08), inset 0 -1px 0 rgba(255,255,255,0.02);\n    }\n    button.ghost{\n      background:transparent;\n      border:1px dashed rgba(255,255,255,0.04);\n      color:var(--muted);\n    }\n    .small{ padding:6px 8px; font-size:13px; border-radius:7px; }\n\n    /* Right visual area */\n    .stage{\n      flex:1;\n      min-height:600px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.014), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:18px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    .stage-top{\n      display:flex;\n      justify-content:space-between;\n      gap:var(--gap);\n      align-items:center;\n    }\n    .legend {\n      color:var(--muted);\n      font-size:13px;\n      display:flex;\n      gap:10px;\n      align-items:center;\n    }\n    .legend .dot{\n      width:12px;height:12px;border-radius:999px;background:var(--accent); box-shadow:0 4px 10px rgba(96,165,250,0.16);\n    }\n\n    /* Canvas area */\n    .canvas-wrap{\n      flex:1;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:10px;\n      border:1px solid rgba(255,255,255,0.03);\n      position:relative;\n      overflow:auto;\n      padding:14px;\n    }\n    svg {\n      width:100%;\n      height:100%;\n      min-height:420px;\n      overflow:visible;\n      display:block;\n    }\n\n    /* Node styles */\n    .node {\n      cursor:default;\n      transition: transform .18s cubic-bezier(.2,.9,.3,1), filter .18s;\n      filter: drop-shadow(0 6px 14px rgba(2,6,23,0.6));\n    }\n    .node circle{\n      fill: url(#nodeGrad);\n      stroke: rgba(255,255,255,0.06);\n      stroke-width:1.2;\n      transition: fill .18s, stroke .12s, r .12s;\n    }\n    .node text{\n      font-size:13px;\n      pointer-events:none;\n      fill: #e6eef8;\n      font-weight:700;\n    }\n    .node .hint {\n      fill: var(--muted);\n      font-weight:600;\n      font-size:11px;\n    }\n\n    .node:hover { transform: translateY(-6px); }\n    .node.selected circle{\n      stroke: var(--accent);\n      stroke-width:2.4;\n      box-shadow: 0 8px 28px rgba(96,165,250,0.12);\n    }\n\n    .node.empty-child .plus {\n      font-size:18px;\n      fill:var(--muted);\n      cursor:pointer;\n    }\n\n    .edge{\n      stroke: rgba(255,255,255,0.06);\n      stroke-width:2;\n      fill:none;\n      transition: stroke .12s;\n    }\n    .edge.highlight{\n      stroke: #60a5fa;\n      stroke-width:3.2;\n      stroke-opacity:1;\n    }\n\n    /* Traversal animation */\n    .pulse {\n      animation: pulse 900ms ease forwards;\n    }\n    @keyframes pulse {\n      0% { transform: scale(1); filter: drop-shadow(0 6px 14px rgba(2,6,23,0.6)); }\n      35% { transform: scale(1.26); }\n      100% { transform: scale(1); filter: drop-shadow(0 10px 30px rgba(96,165,250,0.12)); }\n    }\n\n    /* Control list showing traversal sequence */\n    .sequence {\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n      align-items:center;\n    }\n    .pill {\n      padding:6px 10px;\n      border-radius:999px;\n      background: rgba(255,255,255,0.03);\n      border:1px solid rgba(255,255,255,0.03);\n      font-weight:700;\n      color:var(--muted);\n      min-width:36px;\n      text-align:center;\n    }\n    .pill.current { background: linear-gradient(90deg,#60a5fa33,#3b82f633); color:#e6f3ff; border-color: rgba(96,165,250,0.14); }\n\n    /* footer small notes */\n    .note { font-size:13px; color:var(--muted); }\n\n    /* responsive */\n    @media (max-width:900px){\n      .container{ flex-direction:column; padding:18px; }\n      .panel{ width:100%; max-width:none; min-width:0; }\n      .stage{ width:100%; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"application\" aria-label=\"Binary Tree interactive module\">\n    <!-- LEFT PANEL: Descriptions & Controls -->\n    <aside class=\"panel\" aria-labelledby=\"title\">\n      <div>\n        <h1 id=\"title\">Binary Tree — Structure & Traversals</h1>\n        <div class=\"muted\">Build a binary tree and watch traversals step through nodes visually.</div>\n      </div>\n\n      <!-- Learning objective -->\n      <div class=\"card\" aria-live=\"polite\">\n        <strong>Learning Objective</strong>\n        <div class=\"muted\">\n          After using this module you will be able to:\n          - construct a binary tree by adding left/right children,\n          - visualize the tree structure,\n          - observe preorder, inorder, postorder and level-order traversals step-by-step.\n        </div>\n      </div>\n\n      <!-- Interaction Design (textual description required) -->\n      <div class=\"card\" id=\"interaction-design\" tabindex=\"0\">\n        <strong>Interaction Design</strong>\n        <div class=\"muted\">\n          - Click a node to select it. Click the small + near an empty child to add a left/right child.<br>\n          - Double-click a node value to edit it. Select a node and use \"Delete Subtree\" to remove it.<br>\n          - Use traversal buttons to animate visits. The current node pulses and edges highlight in sequence. A list shows visited order.\n        </div>\n      </div>\n\n      <!-- Layout Description (textual) -->\n      <div class=\"card\" id=\"layout-desc\" tabindex=\"0\">\n        <strong>Layout Description</strong>\n        <div class=\"muted\">\n          Left column: controls, inputs and explanations. Right area: the canvas displaying the tree (SVG) with nodes and edges. Spacing: 24px safe margin; 16px minimum gap between interactive controls. Responsive layout stacks vertically on narrow screens. Controls are keyboard accessible.\n        </div>\n      </div>\n\n      <!-- Controls -->\n      <div class=\"card\" aria-label=\"Controls\">\n        <label for=\"node-value\">Node value</label>\n        <div class=\"row\">\n          <input id=\"node-value\" type=\"text\" placeholder=\"e.g. 7\" aria-label=\"Node value\" />\n          <button id=\"create-root\" class=\"primary small\" title=\"Create root node\">Create Root</button>\n        </div>\n\n        <div style=\"height:8px;\"></div>\n\n        <label>Selected node</label>\n        <div class=\"row\" style=\"align-items:center;\">\n          <div id=\"selected-info\" class=\"muted\" style=\"flex:1\">None</div>\n          <button id=\"delete-subtree\" class=\"ghost small\" title=\"Delete selected node and its subtree\">Delete Subtree</button>\n        </div>\n\n        <div style=\"height:6px;\"></div>\n\n        <label>Traversals</label>\n        <div style=\"display:flex;gap:8px;flex-wrap:wrap;\">\n          <button class=\"small\" id=\"btn-pre\">Preorder</button>\n          <button class=\"small\" id=\"btn-in\">Inorder</button>\n          <button class=\"small\" id=\"btn-post\">Postorder</button>\n          <button class=\"small\" id=\"btn-level\">Level-Order</button>\n        </div>\n\n        <div style=\"height:8px;\"></div>\n\n        <div class=\"row\">\n          <button id=\"btn-random\" class=\"small\">Random Tree</button>\n          <button id=\"btn-reset\" class=\"small\">Reset</button>\n        </div>\n\n        <div style=\"height:6px;\"></div>\n\n        <div class=\"note\">Tip: add nodes by clicking the small + markers near an empty left/right child location in the canvas. Double-click a node to rename it.</div>\n      </div>\n\n      <!-- Traversal sequence display -->\n      <div class=\"card\" aria-live=\"polite\">\n        <label>Traversal sequence (live)</label>\n        <div id=\"sequence\" class=\"sequence\" aria-live=\"polite\" style=\"min-height:44px; align-items:center;\"></div>\n      </div>\n\n      <div class=\"muted\" style=\"font-size:12px;\">\n        Accessibility: All buttons and inputs are keyboard focusable. SVG nodes have accessible titles.\n      </div>\n    </aside>\n\n    <!-- RIGHT: Canvas / Stage -->\n    <main class=\"stage\" aria-labelledby=\"title\">\n      <div class=\"stage-top\">\n        <div class=\"legend\"><span class=\"dot\" aria-hidden=\"true\"></span> Visual tree</div>\n        <div class=\"muted\">Click nodes to select. Use controls on the left to manipulate and traverse.</div>\n      </div>\n\n      <div class=\"canvas-wrap\" id=\"canvas-wrap\" tabindex=\"0\" aria-label=\"Tree canvas\">\n        <!-- SVG will be injected here -->\n        <svg id=\"svgRoot\" viewBox=\"0 0 1200 600\" preserveAspectRatio=\"xMidYMid meet\" role=\"img\" aria-label=\"Binary tree visualization\">\n          <defs>\n            <linearGradient id=\"nodeGrad\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"1\">\n              <stop offset=\"0\" stop-color=\"#0ea5e9\" stop-opacity=\"0.08\"></stop>\n              <stop offset=\"1\" stop-color=\"#0b1220\" stop-opacity=\"0.6\"></stop>\n            </linearGradient>\n            <filter id=\"glow\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\n              <feGaussianBlur stdDeviation=\"6\" result=\"coloredBlur\"/>\n              <feMerge>\n                <feMergeNode in=\"coloredBlur\"/>\n                <feMergeNode in=\"SourceGraphic\"/>\n              </feMerge>\n            </filter>\n          </defs>\n          <g id=\"edges\"></g>\n          <g id=\"nodes\"></g>\n        </svg>\n      </div>\n    </main>\n  </div>\n\n  <script>\n    // Self-contained Binary Tree interactive module\n    (function(){\n      // Basic data model\n      let nodeIdCounter = 1;\n      function makeNode(value){\n        return {\n          id: 'n' + (nodeIdCounter++),\n          value: String(value),\n          left: null,\n          right: null,\n          parent: null\n        };\n      }\n\n      let root = null;\n      let selected = null;\n      const svg = document.getElementById('svgRoot');\n      const nodesLayer = document.getElementById('nodes');\n      const edgesLayer = document.getElementById('edges');\n      const seqWrap = document.getElementById('sequence');\n      const selectedInfo = document.getElementById('selected-info');\n\n      // Layout config\n      const canvasW = 1200, canvasH = 600;\n      const nodeR = 26;\n      const vGap = 110;\n\n      // UI elements\n      const inputVal = document.getElementById('node-value');\n      const btnCreateRoot = document.getElementById('create-root');\n      const btnReset = document.getElementById('btn-reset');\n      const btnRandom = document.getElementById('btn-random');\n      const btnPre = document.getElementById('btn-pre');\n      const btnIn = document.getElementById('btn-in');\n      const btnPost = document.getElementById('btn-post');\n      const btnLevel = document.getElementById('btn-level');\n      const btnDelete = document.getElementById('delete-subtree');\n\n      // Simple helpers\n      function setSelected(node){\n        selected = node;\n        render();\n        selectedInfo.textContent = selected ? (selected.value + ' (' + selected.id + ')') : 'None';\n      }\n\n      function clearSequence(){\n        seqWrap.innerHTML = '';\n      }\n      function pushSequenceLabel(val, highlight=false){\n        const pill = document.createElement('div');\n        pill.className = 'pill' + (highlight ? ' current' : '');\n        pill.textContent = val;\n        seqWrap.appendChild(pill);\n      }\n\n      // Tree manipulations\n      function insertChild(parent, side, value){\n        if(!parent) return;\n        if(side==='left'){\n          if(parent.left) return alert('Left child exists.');\n          const n = makeNode(value);\n          parent.left = n; n.parent = parent;\n        } else {\n          if(parent.right) return alert('Right child exists.');\n          const n = makeNode(value);\n          parent.right = n; n.parent = parent;\n        }\n        render();\n      }\n\n      function deleteSubtree(node){\n        if(!node) return;\n        if(node.parent){\n          if(node.parent.left === node) node.parent.left = null;\n          else if(node.parent.right === node) node.parent.right = null;\n        } else {\n          root = null;\n        }\n        setSelected(null);\n        render();\n      }\n\n      function findNodeById(id, cur=root){\n        if(!cur) return null;\n        if(cur.id === id) return cur;\n        return findNodeById(id, cur.left) || findNodeById(id, cur.right);\n      }\n\n      // Traversal generators\n      function preorder(n, arr=[]){\n        if(!n) return arr;\n        arr.push(n);\n        preorder(n.left, arr);\n        preorder(n.right, arr);\n        return arr;\n      }\n      function inorder(n, arr=[]){\n        if(!n) return arr;\n        inorder(n.left, arr);\n        arr.push(n);\n        inorder(n.right, arr);\n        return arr;\n      }\n      function postorder(n, arr=[]){\n        if(!n) return arr;\n        postorder(n.left, arr);\n        postorder(n.right, arr);\n        arr.push(n);\n        return arr;\n      }\n      function levelOrder(n){\n        const arr=[];\n        if(!n) return arr;\n        const q=[n];\n        while(q.length){\n          const cur=q.shift(); arr.push(cur);\n          if(cur.left) q.push(cur.left);\n          if(cur.right) q.push(cur.right);\n        }\n        return arr;\n      }\n\n      // Layout algorithm: compute x by inorder index scaled to canvas width\n      function computePositions(){\n        let index = 0;\n        const positions = new Map();\n        function dfs(node, depth){\n          if(!node) return;\n          dfs(node.left, depth+1);\n          const x = ++index;\n          positions.set(node.id, {xIndex:x, depth});\n          dfs(node.right, depth+1);\n        }\n        index = 0;\n        dfs(root, 0);\n        const total = Math.max(1, index);\n        // map xIndex to coordinate with padding\n        for(const [id,pos] of positions){\n          const cx = (pos.xIndex / (total + 1)) * (canvasW - 120) + 60;\n          const cy = 60 + pos.depth * vGap;\n          pos.cx = cx;\n          pos.cy = cy;\n        }\n        return positions;\n      }\n\n      // Draw utilities\n      function clearSVG(){\n        nodesLayer.innerHTML = '';\n        edgesLayer.innerHTML = '';\n      }\n\n      function createEdge(x1,y1,x2,y2, idFrom, idTo){\n        const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        const mx = x1 + dx * 0.5;\n        const my = y1 + dy * 0.25;\n        const d = `M ${x1} ${y1} Q ${mx} ${my} ${x2} ${y2}`;\n        path.setAttribute('d', d);\n        path.setAttribute('class','edge');\n        path.setAttribute('data-from', idFrom);\n        path.setAttribute('data-to', idTo);\n        edgesLayer.appendChild(path);\n      }\n\n      function createNodeElement(node, pos, positions){\n        const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n        g.classList.add('node');\n        g.setAttribute('transform', `translate(${pos.cx}, ${pos.cy})`);\n        g.setAttribute('data-id', node.id);\n        g.setAttribute('role','button');\n        g.setAttribute('tabindex','0');\n        g.setAttribute('aria-label', 'Node ' + node.value);\n\n        if(selected && selected.id === node.id) g.classList.add('selected');\n\n        // main circle\n        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n        circle.setAttribute('r', nodeR);\n        g.appendChild(circle);\n\n        // text\n        const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n        text.setAttribute('x',0);\n        text.setAttribute('y',6);\n        text.setAttribute('text-anchor','middle');\n        text.textContent = node.value;\n        g.appendChild(text);\n\n        // left empty child placeholder\n        const leftX = -nodeR*2.4;\n        const rightX = nodeR*2.4;\n        const childY = nodeR + 10;\n\n        if(!node.left){\n          const plus = document.createElementNS('http://www.w3.org/2000/svg','text');\n          plus.setAttribute('x', leftX);\n          plus.setAttribute('y', childY);\n          plus.setAttribute('text-anchor','middle');\n          plus.setAttribute('class','hint plus');\n          plus.textContent = '+';\n          plus.style.cursor = 'pointer';\n          plus.addEventListener('click', (e)=>{\n            e.stopPropagation();\n            promptAddChild(node, 'left');\n          });\n          g.appendChild(plus);\n        } else {\n          // marker for left child exists (small filled dot)\n          const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          dot.setAttribute('cx', leftX);\n          dot.setAttribute('cy', childY+2);\n          dot.setAttribute('r', 4);\n          dot.setAttribute('fill', '#60a5fa33');\n          g.appendChild(dot);\n        }\n\n        if(!node.right){\n          const plusr = document.createElementNS('http://www.w3.org/2000/svg','text');\n          plusr.setAttribute('x', rightX);\n          plusr.setAttribute('y', childY);\n          plusr.setAttribute('text-anchor','middle');\n          plusr.setAttribute('class','hint plus');\n          plusr.textContent = '+';\n          plusr.style.cursor = 'pointer';\n          plusr.addEventListener('click', (e)=>{\n            e.stopPropagation();\n            promptAddChild(node, 'right');\n          });\n          g.appendChild(plusr);\n        } else {\n          const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          dot.setAttribute('cx', rightX);\n          dot.setAttribute('cy', childY+2);\n          dot.setAttribute('r', 4);\n          dot.setAttribute('fill', '#60a5fa33');\n          g.appendChild(dot);\n        }\n\n        // events\n        g.addEventListener('click', (e)=>{\n          e.stopPropagation();\n          setSelected(node);\n        });\n        g.addEventListener('dblclick', (e)=>{\n          e.stopPropagation();\n          editNodeValue(node);\n        });\n        g.addEventListener('keydown', (e)=>{\n          if(e.key === 'Enter' || e.key === ' ') setSelected(node);\n          if(e.key === 'Delete') { deleteSubtree(node); }\n        });\n\n        nodesLayer.appendChild(g);\n      }\n\n      // Add child prompt\n      function promptAddChild(parent, side){\n        const val = prompt('Enter value for ' + side + ' child of ' + parent.value + ':', '');\n        if(val === null) return;\n        if(val.trim() === '') return alert('Value cannot be empty.');\n        insertChild(parent, side, val);\n      }\n\n      function editNodeValue(node){\n        const val = prompt('Edit value for node (id:' + node.id + ')', node.value);\n        if(val === null) return;\n        if(val.trim() === '') return alert('Value cannot be empty.');\n        node.value = String(val);\n        render();\n      }\n\n      // Render entire tree\n      function render(){\n        clearSequence();\n        clearSVG();\n        if(!root) return;\n        const positions = computePositions();\n\n        // draw edges first\n        function dfsEdges(node){\n          if(!node) return;\n          const pos = positions.get(node.id);\n          if(node.left){\n            const p2 = positions.get(node.left.id);\n            createEdge(pos.cx, pos.cy + nodeR - 2, p2.cx, p2.cy - nodeR + 2, node.id, node.left.id);\n          }\n          if(node.right){\n            const p2 = positions.get(node.right.id);\n            createEdge(pos.cx, pos.cy + nodeR - 2, p2.cx, p2.cy - nodeR + 2, node.id, node.right.id);\n          }\n          dfsEdges(node.left);\n          dfsEdges(node.right);\n        }\n        dfsEdges(root);\n\n        // draw nodes\n        function dfsNodes(node){\n          if(!node) return;\n          const pos = positions.get(node.id);\n          createNodeElement(node, pos, positions);\n          dfsNodes(node.left);\n          dfsNodes(node.right);\n        }\n        dfsNodes(root);\n      }\n\n      // Traversal animation\n      let animTimer = null;\n      function animateTraversal(order){\n        if(animTimer) {\n          clearInterval(animTimer);\n          animTimer = null;\n          // remove any pulsing classes left\n          document.querySelectorAll('.node').forEach(n=>n.classList.remove('pulse'));\n          document.querySelectorAll('.edge').forEach(e=>e.classList.remove('highlight'));\n          clearSequence();\n        }\n        if(!order || order.length===0) return;\n        // display sequence labels\n        clearSequence();\n        order.forEach(n => pushSequenceLabel(n.value));\n        let idx = 0;\n        const nodesMap = new Map();\n        document.querySelectorAll('.node').forEach(el=>{\n          nodesMap.set(el.getAttribute('data-id'), el);\n        });\n        const edges = Array.from(document.querySelectorAll('.edge'));\n\n        animTimer = setInterval(()=>{\n          // clear previous highlights\n          document.querySelectorAll('.node').forEach(n=>{ n.classList.remove('pulse'); });\n          edges.forEach(e => e.classList.remove('highlight'));\n\n          if(idx >= order.length){\n            clearInterval(animTimer);\n            animTimer = null;\n            return;\n          }\n          const cur = order[idx];\n          const el = nodesMap.get(cur.id);\n          if(el){\n            // highlight the node element\n            el.classList.add('pulse');\n            // highlight edge from parent if exists\n            if(cur.parent){\n              const pair = edges.find(e => e.getAttribute('data-from') === cur.parent.id && e.getAttribute('data-to') === cur.id);\n              if(pair) pair.classList.add('highlight');\n            }\n            // mark sequence pill\n            const pills = seqWrap.querySelectorAll('.pill');\n            pills.forEach(p => p.classList.remove('current'));\n            if(pills[idx]) pills[idx].classList.add('current');\n            // set selected preview\n            selectedInfo.textContent = 'Visiting: ' + cur.value;\n          }\n          idx++;\n        }, 700);\n      }\n\n      // Hook up UI events\n      btnCreateRoot.addEventListener('click', ()=>{\n        const v = inputVal.value.trim();\n        if(v === ''){\n          alert('Enter a value for root node in \"Node value\".');\n          inputVal.focus();\n          return;\n        }\n        root = makeNode(v);\n        setSelected(root);\n        render();\n      });\n      btnReset.addEventListener('click', ()=>{\n        if(!confirm('Reset the tree?')) return;\n        root = null;\n        setSelected(null);\n        clearSequence();\n        render();\n      });\n      btnRandom.addEventListener('click', ()=>{\n        // generate random small tree\n        root = makeNode(Math.floor(Math.random()*99)+1);\n        function maybeAdd(node, depth){\n          if(depth>3) return;\n          if(Math.random() > 0.45){\n            node.left = makeNode(Math.floor(Math.random()*99)+1);\n            node.left.parent = node;\n            maybeAdd(node.left, depth+1);\n          }\n          if(Math.random() > 0.45){\n            node.right = makeNode(Math.floor(Math.random()*99)+1);\n            node.right.parent = node;\n            maybeAdd(node.right, depth+1);\n          }\n        }\n        maybeAdd(root, 0);\n        setSelected(root);\n        render();\n      });\n\n      btnDelete.addEventListener('click', ()=>{\n        if(!selected) { alert('No node selected.'); return; }\n        if(!confirm('Delete node ' + selected.value + ' and its subtree?')) return;\n        deleteSubtree(selected);\n      });\n\n      btnPre.addEventListener('click', ()=>{\n        if(!root) return alert('Tree is empty.');\n        const order = preorder(root, []);\n        animateTraversal(order);\n      });\n      btnIn.addEventListener('click', ()=>{\n        if(!root) return alert('Tree is empty.');\n        const order = inorder(root, []);\n        animateTraversal(order);\n      });\n      btnPost.addEventListener('click', ()=>{\n        if(!root) return alert('Tree is empty.');\n        const order = postorder(root, []);\n        animateTraversal(order);\n      });\n      btnLevel.addEventListener('click', ()=>{\n        if(!root) return alert('Tree is empty.');\n        const order = levelOrder(root);\n        animateTraversal(order);\n      });\n\n      // clicking outside clears selection\n      document.getElementById('canvas-wrap').addEventListener('click', (e)=>{\n        // if clicked background area, deselect\n        if(e.target === svg || e.target === document.getElementById('canvas-wrap')){\n          setSelected(null);\n        }\n      });\n\n      // keyboard: Enter on input to create root or add as child if selected\n      inputVal.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter'){\n          const v = inputVal.value.trim();\n          if(v === '') return;\n          if(selected){\n            // prompt to choose left or right\n            const side = prompt('Add as left or right child? (L/R)', 'L');\n            if(!side) return;\n            if(side.toLowerCase().startsWith('l')) insertChild(selected, 'left', v);\n            else insertChild(selected, 'right', v);\n          } else {\n            root = makeNode(v);\n            setSelected(root);\n            render();\n          }\n        }\n      });\n\n      // initial sample\n      (function sample(){\n        // small default tree\n        root = makeNode(8);\n        root.left = makeNode(3); root.left.parent = root;\n        root.right = makeNode(10); root.right.parent = root;\n        root.left.left = makeNode(1); root.left.left.parent = root.left;\n        root.left.right = makeNode(6); root.left.right.parent = root.left;\n        root.right.right = makeNode(14); root.right.right.parent = root.right;\n        setSelected(root);\n        render();\n      })();\n\n      // Ensure svg viewBox fits content on resize for responsiveness:\n      function resizeSVG(){\n        // nothing complicated: keep viewBox constant; the wrapper scrolls if necessary\n      }\n      window.addEventListener('resize', resizeSVG);\n\n      // Accessibility: focus canvas with keyboard will focus root\n      document.getElementById('canvas-wrap').addEventListener('keydown', (e)=>{\n        if(e.key === 'Tab') return;\n        // basic navigation: Arrow keys to move selection to parent/left/right\n        if(!selected) return;\n        if(e.key === 'ArrowLeft' && selected.left){\n          setSelected(selected.left);\n        } else if(e.key === 'ArrowRight' && selected.right){\n          setSelected(selected.right);\n        } else if(e.key === 'ArrowUp' && selected.parent){\n          setSelected(selected.parent);\n        } else if(e.key === 'Delete'){\n          deleteSubtree(selected);\n        }\n      });\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Binary Tree.\n\n**Project Overview:**\nTopic: Binary Tree\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Binary Tree"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Binary Tree Interactive Module",
      "description": "Models the interactive states and transitions for a browser-based binary tree builder and traversal visualizer (create, select, edit, add/delete nodes, traversals with animations).",
      "states": [
        {
          "name": "empty",
          "onEnter": "render",
          "onExit": "noop",
          "on": {
            "CREATE_ROOT": "idle_selected",
            "RANDOMIZE": "idle_selected",
            "CLICK_CANVAS_BG": "empty",
            "START_PREORDER": "empty",
            "START_INORDER": "empty",
            "START_POSTORDER": "empty",
            "START_LEVELORDER": "empty",
            "RESET": "empty"
          }
        },
        {
          "name": "idle_no_selection",
          "onEnter": "render",
          "onExit": "noop",
          "on": {
            "SELECT_NODE": "idle_selected",
            "CREATE_ROOT": "idle_selected",
            "RANDOMIZE": "idle_selected",
            "RESET": "confirming_reset",
            "START_PREORDER": "animating_traversal",
            "START_INORDER": "animating_traversal",
            "START_POSTORDER": "animating_traversal",
            "START_LEVELORDER": "animating_traversal",
            "INPUT_ENTER_ADD": "idle_no_selection",
            "CLICK_CANVAS_BG": "idle_no_selection"
          }
        },
        {
          "name": "idle_selected",
          "onEnter": "setSelected",
          "onExit": "noop",
          "on": {
            "DESELECT_NODE": "idle_no_selection",
            "CLICK_CANVAS_BG": "idle_no_selection",
            "CLICK_CREATE_ROOT": "idle_selected",
            "CLICK_RANDOM": "idle_selected",
            "DELETE_SUBTREE": "confirming_delete",
            "CONFIRM_DELETE": "idle_no_selection",
            "CANCEL_DELETE": "idle_selected",
            "EDIT_NODE": "prompt_edit_node",
            "DOUBLE_CLICK_NODE": "prompt_edit_node",
            "INSERT_CHILD": "idle_selected",
            "PROMPT_ADD_CHILD": "prompt_add_child",
            "START_PREORDER": "animating_traversal",
            "START_INORDER": "animating_traversal",
            "START_POSTORDER": "animating_traversal",
            "START_LEVELORDER": "animating_traversal",
            "RESET": "confirming_reset",
            "NAV_LEFT": "idle_selected",
            "NAV_RIGHT": "idle_selected",
            "NAV_UP": "idle_selected",
            "KEY_DELETE": "confirming_delete",
            "INPUT_ENTER_ADD": "idle_selected"
          }
        },
        {
          "name": "prompt_add_child",
          "onEnter": "showAddChildPrompt",
          "onExit": "hideAddChildPrompt",
          "on": {
            "PROMPT_SUBMIT": "idle_selected",
            "PROMPT_CANCEL": "idle_selected",
            "INSERT_CHILD": "idle_selected",
            "CANCEL_PROMPT": "idle_selected"
          }
        },
        {
          "name": "prompt_edit_node",
          "onEnter": "showEditPrompt",
          "onExit": "hideEditPrompt",
          "on": {
            "EDIT_SUBMIT": "idle_selected",
            "EDIT_CANCEL": "idle_selected",
            "CANCEL_PROMPT": "idle_selected"
          }
        },
        {
          "name": "confirming_delete",
          "onEnter": "showConfirmDelete",
          "onExit": "hideConfirmDelete",
          "on": {
            "CONFIRM_DELETE": "idle_no_selection",
            "CANCEL_DELETE": "idle_selected"
          }
        },
        {
          "name": "confirming_reset",
          "onEnter": "showConfirmReset",
          "onExit": "hideConfirmReset",
          "on": {
            "CONFIRM_RESET": "empty",
            "CANCEL_RESET": "idle_no_selection"
          }
        },
        {
          "name": "animating_traversal",
          "onEnter": "startAnimation",
          "onExit": "stopAnimation",
          "on": {
            "ANIMATION_STEP": "animating_traversal",
            "ANIMATION_END_WITH_SELECTION": "idle_selected",
            "ANIMATION_END_NO_SELECTION": "idle_no_selection",
            "STOP_ANIMATION": "idle_no_selection",
            "CLICK_CREATE_ROOT": "idle_selected",
            "CLICK_RANDOM": "idle_selected",
            "RESET": "confirming_reset",
            "DELETE_SUBTREE": "confirming_delete",
            "SELECT_NODE": "idle_selected",
            "DESELECT_NODE": "idle_no_selection"
          }
        }
      ],
      "events": [
        "CREATE_ROOT",
        "CLICK_CREATE_ROOT",
        "RANDOMIZE",
        "CLICK_RANDOM",
        "RESET",
        "CONFIRM_RESET",
        "CANCEL_RESET",
        "SELECT_NODE",
        "DESELECT_NODE",
        "CLICK_CANVAS_BG",
        "CLICK_NODE",
        "DOUBLE_CLICK_NODE",
        "EDIT_NODE",
        "EDIT_SUBMIT",
        "EDIT_CANCEL",
        "PROMPT_ADD_CHILD",
        "PROMPT_SUBMIT",
        "PROMPT_CANCEL",
        "INSERT_CHILD",
        "INPUT_ENTER_ADD",
        "DELETE_SUBTREE",
        "CONFIRM_DELETE",
        "CANCEL_DELETE",
        "START_PREORDER",
        "START_INORDER",
        "START_POSTORDER",
        "START_LEVELORDER",
        "ANIMATION_STEP",
        "ANIMATION_END_WITH_SELECTION",
        "ANIMATION_END_NO_SELECTION",
        "STOP_ANIMATION",
        "KEY_DELETE",
        "NAV_LEFT",
        "NAV_RIGHT",
        "NAV_UP",
        "RENDER"
      ],
      "notes": "Prompts and confirms use synchronous browser prompt()/confirm() dialogs. Selection is stored externally (setSelected) and preserved across traversals. Traversal animation uses an interval to step through nodes, applying 'pulse' to nodes and 'highlight' to edges; starting a traversal clears any existing animation. 'Create Root' and 'Random' replace root; 'Reset' clears the tree. UI actions trigger render() to update SVG; modal/dialog states are modeled as explicit prompt/confirm states."
    }
  },
  {
    "id": "6dec9820-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:45:32.659Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Hash Map",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Hash Map Explorer</title>\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --muted:#98a0b3;\n      --accent:#46c3ff;\n      --accent-2:#7af59a;\n      --danger:#ff6b6b;\n      --glass: rgba(255,255,255,0.03);\n      --card:#0b1220;\n      --gap:16px;\n    }\n\n    /* Safe area margins: 24px on all sides */\n    html,body{height:100%}\n    body{\n      margin:0;\n      padding:24px;\n      background:linear-gradient(180deg,#071021 0%, #051424 100%);\n      color:#e6eef8;\n      font-family:Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      box-sizing:border-box;\n      min-height:100vh;\n      display:flex;\n      align-items:flex-start;\n    }\n    *{box-sizing:inherit}\n    a{color:var(--accent)}\n\n    .module {\n      width:100%;\n      max-width:1200px;\n      margin:0 auto;\n      display:grid;\n      grid-template-columns: 360px 1fr;\n      gap:var(--gap);\n      align-items:start;\n    }\n\n    /* Responsive: stack on narrow screens */\n    @media (max-width:980px){\n      .module{grid-template-columns: 1fr; padding-bottom:40px}\n    }\n\n    /* Left panel: plan and explanations */\n    .info {\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:20px;\n      min-width:0;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n\n    .title {\n      font-size:20px;\n      font-weight:700;\n      color:#eaffff;\n      display:flex;\n      align-items:center;\n      gap:10px;\n    }\n    .subtitle{ color:var(--muted); font-size:13px; margin-top:-4px }\n\n    .section{\n      background:var(--glass);\n      padding:12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.02);\n      font-size:13px;\n      color:var(--muted);\n    }\n    .section h4{\n      margin:0 0 8px 0;\n      color:#dff6ff;\n      font-size:13px;\n    }\n    .klist{display:flex;flex-direction:column;gap:8px}\n    .small{\n      font-size:12px;color:var(--muted)\n    }\n\n    /* Right: interactive workspace */\n    .work {\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:18px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n      min-height:380px;\n      display:flex;\n      flex-direction:column;\n      gap:16px;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n\n    .controls{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n\n    .input {\n      display:flex;\n      gap:8px;\n      align-items:center;\n      background:rgba(255,255,255,0.02);\n      padding:8px;\n      border-radius:10px;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    label{font-size:13px;color:var(--muted);margin-right:8px}\n\n    input[type=\"text\"], select, input[type=\"number\"]{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.04);\n      color:inherit;\n      padding:8px 10px;\n      border-radius:8px;\n      outline:none;\n      min-width:160px;\n      font-size:14px;\n    }\n    input[type=\"number\"]{width:100px}\n    input[type=\"text\"]::placeholder{color:#94a2b8}\n\n    button{\n      background:linear-gradient(180deg,var(--accent) 0%, #24a7d6 100%);\n      color:#022034;\n      border:none;\n      padding:8px 12px;\n      border-radius:10px;\n      font-weight:600;\n      cursor:pointer;\n      box-shadow: 0 6px 12px rgba(40,160,190,0.12);\n      transition:transform .12s ease;\n    }\n    button.secondary{\n      background:transparent;\n      color:var(--accent);\n      border:1px solid rgba(70,195,255,0.12);\n      box-shadow:none;\n    }\n    button:active{transform:translateY(1px)}\n    .danger{background:linear-gradient(180deg,var(--danger),#e04b4b); color:white}\n\n    /* Visualization area */\n    .visual {\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      flex-wrap:wrap;\n    }\n\n    .canvas {\n      flex:1 1 680px;\n      min-width:280px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent);\n      border-radius:12px;\n      padding:16px;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .sidebar {\n      width:260px;\n      min-width:200px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    @media (max-width:980px){\n      .sidebar{width:100%}\n    }\n\n    .table-wrap{\n      padding:8px;\n      border-radius:10px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border:1px dashed rgba(255,255,255,0.02);\n    }\n\n    /* table of buckets */\n    .bucket-grid{\n      display:grid;\n      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));\n      gap:12px;\n      align-items:start;\n    }\n    .bucket{\n      min-height:120px;\n      background:rgba(255,255,255,0.02);\n      border-radius:10px;\n      padding:10px;\n      position:relative;\n      border:1px solid rgba(255,255,255,0.02);\n      transition:box-shadow .18s ease, transform .18s ease;\n      overflow:visible;\n    }\n    .bucket.highlight{ box-shadow:0 8px 30px rgba(70,195,255,0.08); transform:translateY(-4px) }\n    .bucket-header{\n      display:flex;\n      justify-content:space-between;\n      gap:8px;\n      align-items:center;\n      margin-bottom:10px;\n    }\n    .bucket-index{\n      font-size:12px;\n      color:var(--muted);\n      background:rgba(255,255,255,0.02);\n      padding:4px 8px;\n      border-radius:8px;\n    }\n    .bucket-body{\n      min-height:60px;\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n\n    /* nodes for chaining */\n    .node {\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n      padding:8px 10px;\n      border-radius:999px;\n      background:linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));\n      border:1px solid rgba(255,255,255,0.02);\n      color:var(--muted);\n      font-weight:600;\n      font-size:13px;\n      transition:transform .22s ease, box-shadow .12s ease, background .12s ease;\n    }\n    .node.found{\n      background:linear-gradient(90deg, #e6fffa, #d7fff7);\n      color:#002420;\n      box-shadow:0 8px 20px rgba(122,245,154,0.08);\n    }\n    .node.adding{\n      box-shadow:0 16px 30px rgba(70,195,255,0.08);\n      transform:scale(1.03);\n    }\n    .node.removing{\n      opacity:0.12;\n      transform:scale(.88) rotate(-6deg);\n    }\n\n    /* floating animated mover (absolute) */\n    .mover {\n      position:fixed;\n      pointer-events:none;\n      z-index:1200;\n      transition:transform .6s cubic-bezier(.22,.9,.32,1), opacity .4s ease;\n      will-change:transform, opacity;\n    }\n\n    .meta {\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    .stat {\n      background:rgba(255,255,255,0.02);\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.02);\n      min-width:110px;\n      text-align:center;\n    }\n\n    .log {\n      background:transparent;\n      color:var(--muted);\n      font-size:13px;\n      padding:8px;\n      border-radius:8px;\n      border:1px dashed rgba(255,255,255,0.02);\n      min-height:80px;\n      max-height:160px;\n      overflow:auto;\n    }\n\n    /* tiny visual of hash computation */\n    .hashline{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .chip{\n      background:rgba(255,255,255,0.02);\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.02);\n      color:var(--muted);\n      font-weight:700;\n    }\n\n    /* subtle helper text */\n    .hint{font-size:12px;color:var(--muted);margin-top:4px}\n\n    /* accessibility focus */\n    button:focus, input:focus, select:focus { outline:2px solid rgba(70,195,255,0.14); outline-offset:2px; }\n\n  </style>\n</head>\n<body>\n  <main class=\"module\" aria-labelledby=\"concept-title\">\n    <!-- Info Panel -->\n    <aside class=\"info\" aria-label=\"Lesson Plan\">\n      <div>\n        <div class=\"title\" id=\"concept-title\">Hash Map — Visual Explorer</div>\n        <div class=\"subtitle\">Interactive demonstration of hashing, buckets, and collision handling (separate chaining).</div>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"objective-heading\">\n        <h4 id=\"objective-heading\">Learning Objective</h4>\n        <div class=\"klist\">\n          <div>After interacting you will be able to:</div>\n          <ul style=\"margin:8px 0 0 18px; color:var(--muted)\">\n            <li>Compute a simple hash (sum of char codes mod table size).</li>\n            <li>Insert, search, and delete keys while observing bucket mapping.</li>\n            <li>See how collisions are handled via separate chaining (linked lists).</li>\n            <li>Understand how table size affects distribution and load factor.</li>\n          </ul>\n        </div>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"interaction-heading\">\n        <h4 id=\"interaction-heading\">Interaction Design</h4>\n        <div class=\"small\">\n          - Type a key (text) then choose Insert, Search, or Delete.<br>\n          - Use \"Visualize Hash\" to see character-by-character computation.<br>\n          - Change bucket count to observe distribution (resets table).<br>\n          - Click a bucket to highlight its chain and focus animation.<br>\n          - Animated mover will travel from input to target bucket showing placement; searching highlights nodes sequentially.\n        </div>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"layout-heading\">\n        <h4 id=\"layout-heading\">Layout Description</h4>\n        <div class=\"small\">\n          - Left column: this descriptive plan and controls overview.<br>\n          - Right column: workspace containing controls (top), visualization canvas (center), and sidebar (right) with stats & log.<br>\n          - Safe margins: 24px padding on page; 16px minimum gaps between interactive elements; responsive stack on small screens.<br>\n          - Accessibility: labeled inputs, keyboard focus states, color contrast and text alternatives for animation.\n        </div>\n      </div>\n\n      <div class=\"section\" style=\"display:flex;flex-direction:column;gap:8px\">\n        <h4>Tips</h4>\n        <div class=\"small\">Try keys with similar characters (e.g. \"ab\", \"ba\") and observe where collisions occur. Increase or decrease buckets to see distribution change.</div>\n      </div>\n    </aside>\n\n    <!-- Interactive Workspace -->\n    <section class=\"work\" aria-label=\"Hash Map Workspace\">\n      <div class=\"controls\" role=\"region\" aria-label=\"Controls\">\n        <div class=\"input\" style=\"flex:1 1 420px; min-width:260px;\">\n          <label for=\"key-input\">Key</label>\n          <input id=\"key-input\" type=\"text\" placeholder=\"Enter key (e.g., 'apple')\" aria-label=\"Key input\" />\n          <button id=\"visualize-hash\" title=\"Show hash computation\">Visualize Hash</button>\n        </div>\n\n        <div style=\"display:flex;gap:8px;\">\n          <button id=\"insert-btn\">Insert</button>\n          <button class=\"secondary\" id=\"search-btn\">Search</button>\n          <button class=\"danger\" id=\"delete-btn\">Delete</button>\n        </div>\n\n        <div style=\"display:flex;gap:8px;align-items:center;\">\n          <label for=\"buckets-count\">Buckets</label>\n          <input aria-label=\"Buckets count\" id=\"buckets-count\" type=\"number\" min=\"3\" max=\"32\" value=\"8\" />\n          <button class=\"secondary\" id=\"reset-btn\" title=\"Reset table\">Reset</button>\n        </div>\n      </div>\n\n      <div class=\"visual\" aria-live=\"polite\">\n        <div class=\"canvas\" role=\"application\" aria-label=\"Hash table visualization\">\n          <div class=\"table-wrap\" id=\"table-wrap\">\n            <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px\">\n              <div style=\"display:flex;flex-direction:column\">\n                <div style=\"font-weight:700;color:#dff6ff;font-size:15px\">Hash Table (Separate Chaining)</div>\n                <div class=\"hint\">Buckets are indexed 0 .. N-1. Click any bucket to highlight it.</div>\n              </div>\n              <div class=\"meta\" aria-hidden=\"true\">\n                <div class=\"stat\" id=\"stat-buckets\">Buckets: 8</div>\n                <div class=\"stat\" id=\"stat-nodes\">Keys: 0</div>\n                <div class=\"stat\" id=\"stat-load\">Load: 0.00</div>\n              </div>\n            </div>\n\n            <div id=\"bucket-grid\" class=\"bucket-grid\" aria-label=\"Buckets container\">\n              <!-- buckets will be injected here -->\n            </div>\n          </div>\n          <div style=\"margin-top:12px;display:flex;gap:12px;flex-wrap:wrap\">\n            <div style=\"flex:1 1 320px\">\n              <div style=\"font-size:13px;color:var(--muted);margin-bottom:6px\">Hash Function (sum of char codes mod buckets)</div>\n              <div class=\"hashline\" id=\"hash-line\" aria-live=\"polite\">\n                <div class=\"chip\" id=\"hash-sum\">sum: 0</div>\n                <div class=\"chip\" id=\"hash-mod\">mod: 0</div>\n                <div class=\"chip\" id=\"hash-index\">index: 0</div>\n              </div>\n            </div>\n\n            <div style=\"flex:1 1 240px\">\n              <div style=\"font-size:13px;color:var(--muted);margin-bottom:6px\">Last action</div>\n              <div id=\"action-result\" class=\"hint\">No actions yet</div>\n            </div>\n          </div>\n\n        </div>\n\n        <aside class=\"sidebar\" aria-label=\"Sidebar\">\n          <div class=\"log\" id=\"log\" aria-live=\"polite\" role=\"log\">Event log...</div>\n          <div style=\"display:flex;gap:8px;\">\n            <button class=\"secondary\" id=\"fill-sample\">Fill sample keys</button>\n            <button id=\"clear-btn\" class=\"secondary\">Clear table</button>\n          </div>\n        </aside>\n      </div>\n    </section>\n  </main>\n\n  <script>\n    // Hash Map Visual Explorer - vanilla JS\n    (function(){\n      // DOM references\n      const bucketsCountInput = document.getElementById('buckets-count');\n      const bucketGrid = document.getElementById('bucket-grid');\n      const statBuckets = document.getElementById('stat-buckets');\n      const statNodes = document.getElementById('stat-nodes');\n      const statLoad = document.getElementById('stat-load');\n      const keyInput = document.getElementById('key-input');\n      const insertBtn = document.getElementById('insert-btn');\n      const searchBtn = document.getElementById('search-btn');\n      const deleteBtn = document.getElementById('delete-btn');\n      const resetBtn = document.getElementById('reset-btn');\n      const clearBtn = document.getElementById('clear-btn');\n      const fillSampleBtn = document.getElementById('fill-sample');\n      const visualizeHashBtn = document.getElementById('visualize-hash');\n      const hashSumChip = document.getElementById('hash-sum');\n      const hashModChip = document.getElementById('hash-mod');\n      const hashIndexChip = document.getElementById('hash-index');\n      const actionResult = document.getElementById('action-result');\n      const logBox = document.getElementById('log');\n      const tableWrap = document.getElementById('table-wrap');\n\n      let buckets = [];\n      let bucketCount = parseInt(bucketsCountInput.value,10) || 8;\n      let totalKeys = 0;\n\n      // Create initial table\n      function makeBuckets(n){\n        buckets = Array.from({length:n}, ()=>[]);\n        bucketCount = n;\n        renderBuckets();\n        updateStats();\n      }\n\n      // Render bucket grid\n      function renderBuckets(){\n        bucketGrid.innerHTML = '';\n        bucketGrid.style.gridTemplateColumns = computeGridColumns(bucketCount);\n        for(let i=0;i<bucketCount;i++){\n          const b = document.createElement('div');\n          b.className = 'bucket';\n          b.tabIndex = 0;\n          b.setAttribute('role','group');\n          b.setAttribute('aria-label','Bucket '+i);\n          b.dataset.index = String(i);\n          b.innerHTML = `\n            <div class=\"bucket-header\">\n              <div class=\"bucket-index\">#${i}</div>\n              <div class=\"hint\" style=\"font-size:12px;color:var(--muted)\">len: <span data-len>${buckets[i].length}</span></div>\n            </div>\n            <div class=\"bucket-body\" aria-live=\"polite\"></div>\n          `;\n          bucketGrid.appendChild(b);\n\n          // click to highlight\n          b.addEventListener('click', ()=>highlightBucket(i));\n          b.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); highlightBucket(i) }});\n          populateBucketBody(i);\n        }\n      }\n\n      function computeGridColumns(n){\n        // show reasonable columns for layout\n        if(window.innerWidth < 980) return 'repeat(2, 1fr)';\n        if(n <= 4) return 'repeat('+n+', minmax(120px,1fr))';\n        if(n <= 8) return 'repeat(4, minmax(120px,1fr))';\n        return 'repeat(6, minmax(120px,1fr))';\n      }\n\n      function populateBucketBody(index){\n        const b = bucketGrid.querySelector('[data-index=\"'+index+'\"]');\n        if(!b) return;\n        const body = b.querySelector('.bucket-body');\n        body.innerHTML = '';\n        buckets[index].forEach(nodeKey => {\n          const nodeEl = makeNodeElement(nodeKey);\n          body.appendChild(nodeEl);\n        });\n        b.querySelector('[data-len]').textContent = String(buckets[index].length);\n      }\n\n      function makeNodeElement(key){\n        const el = document.createElement('div');\n        el.className = 'node';\n        el.textContent = key;\n        el.tabIndex = 0;\n        el.setAttribute('aria-label','Key '+key);\n        return el;\n      }\n\n      // Hash function: sum of char codes mod buckets\n      function computeHash(key){\n        let sum = 0;\n        for(let ch of key){\n          sum += ch.codePointAt(0);\n        }\n        const idx = bucketCount > 0 ? (sum % bucketCount) : 0;\n        return {sum, idx};\n      }\n\n      // Animation: move floating node from an element to bucket body\n      function animateMove(text, fromRect, toRect, onDone){\n        // create mover element\n        const mover = document.createElement('div');\n        mover.className = 'mover node adding';\n        mover.style.left = (fromRect.left) + 'px';\n        mover.style.top = (fromRect.top) + 'px';\n        mover.style.opacity = '0';\n        mover.style.transform = 'translate(0,0) scale(1)';\n        mover.textContent = text;\n        document.body.appendChild(mover);\n        // compute translation\n        const startX = fromRect.left;\n        const startY = fromRect.top;\n        const endX = toRect.left + (toRect.width/2) - (mover.offsetWidth/2);\n        const endY = toRect.top + (toRect.height/2) - (mover.offsetHeight/2);\n        // set initial position with transform for smooth anim\n        mover.style.transform = `translate(${startX - startX}px, ${startY - startY}px)`;\n        requestAnimationFrame(()=>{\n          mover.style.opacity = '1';\n          mover.style.left = startX + 'px';\n          mover.style.top = startY + 'px';\n          mover.style.transform = `translate(${endX - startX}px, ${endY - startY}px)`;\n        });\n        // cleanup after transition\n        mover.addEventListener('transitionend', ()=>{\n          mover.style.opacity = '0';\n          setTimeout(()=>{ mover.remove(); if(onDone) onDone(); }, 120);\n        }, {once:true});\n        // safety fallback\n        setTimeout(()=>{ if(document.body.contains(mover)){ mover.remove(); if(onDone) onDone(); }}, 1200);\n      }\n\n      function log(msg){\n        const time = new Date().toLocaleTimeString();\n        const line = `[${time}] ${msg}\\n`;\n        logBox.textContent = line + logBox.textContent;\n      }\n\n      function updateStats(){\n        statBuckets.textContent = 'Buckets: ' + bucketCount;\n        statNodes.textContent = 'Keys: ' + totalKeys;\n        const load = bucketCount>0 ? (totalKeys / bucketCount) : 0;\n        statLoad.textContent = 'Load: ' + load.toFixed(2);\n      }\n\n      // Public operations\n      function insertKey(key){\n        if(!key || typeof key !== 'string') return;\n        const k = key.trim();\n        if(k.length === 0) return;\n        const {sum, idx} = computeHash(k);\n        // anim: mover from input to bucket\n        const inputRect = keyInput.getBoundingClientRect();\n        const bucketEl = bucketGrid.querySelector('[data-index=\"'+idx+'\"]');\n        const bucketBody = bucketEl.querySelector('.bucket-body');\n        const targetRect = bucketBody.getBoundingClientRect();\n\n        actionResult.textContent = `Inserting \"${k}\" -> bucket ${idx}`;\n        log(`Insert: \"${k}\" hashed to ${idx} (sum ${sum})`);\n\n        animateMove(k, inputRect, targetRect, ()=>{\n          // if duplicate, avoid adding duplicate keys\n          if(buckets[idx].includes(k)){\n            actionResult.textContent = `Duplicate key \"${k}\" already present in bucket ${idx}.`;\n            log(`Insert aborted: duplicate \"${k}\" at ${idx}`);\n            return;\n          }\n          buckets[idx].push(k);\n          totalKeys++;\n          populateBucketBody(idx);\n          updateStats();\n          actionResult.textContent = `Inserted \"${k}\" into bucket ${idx}.`;\n        });\n\n        // show hash chips\n        showHashChips({sum,idx});\n      }\n\n      function searchKey(key){\n        const k = (key||'').trim();\n        if(k.length === 0) return;\n        const {sum, idx} = computeHash(k);\n        actionResult.textContent = `Searching \"${k}\" in bucket ${idx}...`;\n        log(`Search: \"${k}\" -> bucket ${idx}`);\n        showHashChips({sum, idx});\n\n        const bucketEl = bucketGrid.querySelector('[data-index=\"'+idx+'\"]');\n        const body = bucketEl.querySelector('.bucket-body');\n        const nodes = Array.from(body.children);\n        // sequential highlight with delay\n        let foundIndex = -1;\n        const highlightNext = (i)=>{\n          if(i >= nodes.length){\n            actionResult.textContent = `Not found: \"${k}\"`;\n            log(`Result: \"${k}\" not found in bucket ${idx}`);\n            clearHighlights(bucketEl);\n            return;\n          }\n          clearHighlights(bucketEl);\n          nodes[i].classList.add('adding');\n          nodes[i].style.background = 'linear-gradient(90deg, rgba(70,195,255,0.08), rgba(255,255,255,0.02))';\n          // compare\n          setTimeout(()=>{\n            const nodeKey = buckets[idx][i];\n            if(nodeKey === k){\n              nodes[i].classList.remove('adding');\n              nodes[i].classList.add('found');\n              actionResult.textContent = `Found \"${k}\" in bucket ${idx} (position ${i}).`;\n              log(`Result: Found \"${k}\" in bucket ${idx} at position ${i}`);\n              foundIndex = i;\n              // keep highlight for a bit then clear\n              setTimeout(()=> clearHighlights(bucketEl), 1200);\n            } else {\n              nodes[i].classList.remove('adding');\n              setTimeout(()=> highlightNext(i+1), 180);\n            }\n          }, 450);\n        };\n        highlightNext(0);\n      }\n\n      function deleteKey(key){\n        const k = (key||'').trim();\n        if(k.length === 0) return;\n        const {sum, idx} = computeHash(k);\n        actionResult.textContent = `Deleting \"${k}\" from bucket ${idx}...`;\n        log(`Delete: \"${k}\" -> bucket ${idx}`);\n        showHashChips({sum, idx});\n\n        const bucketEl = bucketGrid.querySelector('[data-index=\"'+idx+'\"]');\n        const body = bucketEl.querySelector('.bucket-body');\n        const nodes = Array.from(body.children);\n        for(let i=0;i<nodes.length;i++){\n          const nodeKey = buckets[idx][i];\n          if(nodeKey === k){\n            // animate removal\n            nodes[i].classList.add('removing');\n            nodes[i].style.transform = 'translateX(20px) scale(.92) rotate(6deg)';\n            setTimeout(()=>{\n              buckets[idx].splice(i,1);\n              totalKeys--;\n              populateBucketBody(idx);\n              updateStats();\n              actionResult.textContent = `Deleted \"${k}\" from bucket ${idx}.`;\n              log(`Deleted \"${k}\" from bucket ${idx}`);\n            }, 420);\n            return;\n          }\n        }\n        actionResult.textContent = `Key \"${k}\" not found in bucket ${idx}.`;\n        log(`Delete failed: \"${k}\" not in bucket ${idx}`);\n      }\n\n      function clearHighlights(bucketEl){\n        const nodes = bucketEl.querySelectorAll('.node');\n        nodes.forEach(n=>{\n          n.classList.remove('adding','found');\n          n.style.background = '';\n        });\n        bucketEl.classList.remove('highlight');\n      }\n\n      function highlightBucket(index){\n        // remove other highlights\n        bucketGrid.querySelectorAll('.bucket').forEach(b=>b.classList.remove('highlight'));\n        const b = bucketGrid.querySelector('[data-index=\"'+index+'\"]');\n        b.classList.add('highlight');\n        actionResult.textContent = `Bucket ${index} highlighted (len ${buckets[index].length}).`;\n        log(`Bucket ${index} highlighted`);\n        // animate a small pulse on nodes\n        const nodes = b.querySelectorAll('.node');\n        nodes.forEach((n,i)=>{\n          n.classList.add('adding');\n          setTimeout(()=>n.classList.remove('adding'), 500 + i*80);\n        });\n        // scroll into view if needed\n        b.scrollIntoView({behavior:'smooth', block:'center'});\n      }\n\n      function showHashChips({sum, idx}){\n        hashSumChip.textContent = 'sum: ' + sum;\n        hashModChip.textContent = 'mod: ' + bucketCount;\n        hashIndexChip.textContent = 'index: ' + idx;\n      }\n\n      // Event handlers\n      insertBtn.addEventListener('click', ()=>{\n        const key = keyInput.value;\n        if(!key.trim()){ actionResult.textContent = 'Please enter a key to insert.'; return; }\n        insertKey(key);\n      });\n      searchBtn.addEventListener('click', ()=>{\n        const key = keyInput.value;\n        if(!key.trim()){ actionResult.textContent = 'Please enter a key to search.'; return; }\n        searchKey(key);\n      });\n      deleteBtn.addEventListener('click', ()=>{\n        const key = keyInput.value;\n        if(!key.trim()){ actionResult.textContent = 'Please enter a key to delete.'; return; }\n        deleteKey(key);\n      });\n      resetBtn.addEventListener('click', ()=>{\n        const n = parseInt(bucketsCountInput.value,10);\n        if(!n || n < 3){ actionResult.textContent = 'Buckets must be at least 3.'; return; }\n        if(n > 32){ actionResult.textContent = 'Buckets max 32.'; bucketsCountInput.value = 32; return; }\n        makeBuckets(n);\n        totalKeys = 0;\n        log(`Reset table with ${n} buckets`);\n        actionResult.textContent = `Table reset to ${n} buckets.`;\n      });\n      clearBtn.addEventListener('click', ()=>{\n        makeBuckets(bucketCount);\n        totalKeys = 0;\n        log('Cleared table');\n        actionResult.textContent = 'Table cleared.';\n      });\n\n      fillSampleBtn.addEventListener('click', ()=>{\n        const sample = ['apple','banana','grape','pear','peach','plum','apricot','berry','melon','mango','kiwi','orange'];\n        // insert sequentially with slight delay to show animation\n        let i=0;\n        (function next(){\n          if(i>=sample.length) return;\n          const k = sample[i++];\n          keyInput.value = k;\n          insertKey(k);\n          setTimeout(next, 280);\n        })();\n      });\n\n      visualizeHashBtn.addEventListener('click', ()=>{\n        const key = keyInput.value || '';\n        if(!key.trim()){ actionResult.textContent = 'Enter a key to visualize hashing.'; return; }\n        const k = key.trim();\n        // show step-by-step calculation\n        let sum = 0;\n        hashSumChip.textContent = 'sum: 0';\n        hashModChip.textContent = 'mod: ' + bucketCount;\n        hashIndexChip.textContent = 'index: -';\n        actionResult.textContent = `Visualizing hash for \"${k}\"...`;\n        log(`Visualize hash for \"${k}\"`);\n        // create small sequence near input\n        const inputRect = keyInput.getBoundingClientRect();\n        // show each char's code and accumulate\n        let idx=0;\n        const steps = Array.from(k);\n        function step(){\n          if(idx >= steps.length){\n            const final = computeHash(k);\n            hashIndexChip.textContent = 'index: ' + final.idx;\n            actionResult.textContent = `Hash computed: sum ${final.sum}, index ${final.idx}`;\n            log(`Hash computed: sum ${final.sum}, index ${final.idx}`);\n            // briefly highlight bucket\n            const bEl = bucketGrid.querySelector('[data-index=\"'+final.idx+'\"]');\n            if(bEl){\n              bEl.classList.add('highlight');\n              setTimeout(()=>bEl.classList.remove('highlight'), 900);\n            }\n            return;\n          }\n          const ch = steps[idx];\n          const code = ch.codePointAt(0);\n          sum += code;\n          hashSumChip.textContent = 'sum: ' + sum;\n          // show ephemeral mover with char->code\n          const moverLabel = `${ch}→${code}`;\n          // position mover near input and animate small upward then fade\n          const mover = document.createElement('div');\n          mover.className = 'mover chip';\n          mover.textContent = moverLabel;\n          mover.style.left = (inputRect.left + 10 + (idx*8)) + 'px';\n          mover.style.top = (inputRect.top - 40) + 'px';\n          mover.style.opacity = '0';\n          document.body.appendChild(mover);\n          requestAnimationFrame(()=>{ mover.style.opacity='1'; mover.style.transform = 'translateY(-20px)'; });\n          setTimeout(()=>{ mover.style.opacity='0'; mover.remove(); }, 700);\n          idx++;\n          setTimeout(step, 420);\n        }\n        step();\n      });\n\n      // keyboard shortcut: Enter to insert, Shift+Enter to search\n      keyInput.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter' && !e.shiftKey){\n          insertBtn.click();\n        } else if(e.key === 'Enter' && e.shiftKey){\n          searchBtn.click();\n        }\n      });\n\n      // init\n      makeBuckets(bucketCount);\n\n      // Accessibility: announcer for log\n      log('Interactive Hash Map Explorer ready. Use the controls to insert, search, and delete keys.');\n\n      // expose for debugging (not necessary)\n      window.__hashviz = {buckets, insertKey, searchKey, deleteKey, computeHash};\n\n      // ensure grid updates on resize\n      window.addEventListener('resize', ()=>{ bucketGrid.style.gridTemplateColumns = computeGridColumns(bucketCount); });\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Hash Map.\n\n**Project Overview:**\nTopic: Hash Map\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Hash Map"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Hash Map Explorer",
      "description": "Finite state machine modeling user interactions, animations and data operations (insert, search, delete, hash visualization, bucket highlighting, table reset/clear, sample fill) in the Hash Map visualizer.",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "CLICK_INSERT": "inserting",
            "CLICK_SEARCH": "searching",
            "CLICK_DELETE": "deleting",
            "CLICK_VISUALIZE_HASH": "visualizing_hash",
            "CLICK_RESET": "resetting_table",
            "CLICK_CLEAR": "clearing_table",
            "CLICK_FILL_SAMPLE": "filling_sample",
            "CLICK_BUCKET": "highlighting_bucket",
            "KEY_ENTER": "inserting",
            "KEY_SHIFT_ENTER": "searching",
            "BUCKETS_CHANGED": "resetting_table",
            "RESIZE": "idle"
          }
        },
        {
          "name": "inserting",
          "onEnter": "startInsertAnimation",
          "onExit": "finalizeInsert",
          "on": {
            "INSERT_ANIMATION_END": "idle",
            "DUPLICATE_DETECTED": "idle",
            "INVALID_INPUT": "idle",
            "CANCEL": "idle"
          }
        },
        {
          "name": "searching",
          "onEnter": "startSequentialSearch",
          "onExit": "clearHighlights",
          "on": {
            "SEARCH_STEP": "searching",
            "SEARCH_FOUND": "idle",
            "SEARCH_NOT_FOUND": "idle",
            "SEARCH_COMPLETE": "idle",
            "CANCEL": "idle"
          }
        },
        {
          "name": "deleting",
          "onEnter": "startDeleteAnimation",
          "onExit": "updateStats",
          "on": {
            "DELETE_DONE": "idle",
            "DELETE_NOT_FOUND": "idle",
            "INVALID_INPUT": "idle"
          }
        },
        {
          "name": "visualizing_hash",
          "onEnter": "startHashVisualization",
          "onExit": "showHashResult",
          "on": {
            "HASH_VIS_STEP": "visualizing_hash",
            "HASH_VIS_DONE": "idle",
            "INVALID_INPUT": "idle",
            "CANCEL": "idle"
          }
        },
        {
          "name": "highlighting_bucket",
          "onEnter": "highlightBucketUI",
          "onExit": "clearHighlight",
          "on": {
            "HIGHLIGHT_DONE": "idle",
            "CLICK_BUCKET": "highlighting_bucket",
            "CANCEL": "idle"
          }
        },
        {
          "name": "resetting_table",
          "onEnter": "makeBuckets",
          "onExit": "updateStats",
          "on": {
            "RESET_DONE": "idle",
            "INVALID_BUCKETS": "idle"
          }
        },
        {
          "name": "clearing_table",
          "onEnter": "clearTable",
          "onExit": "updateStats",
          "on": {
            "CLEAR_DONE": "idle"
          }
        },
        {
          "name": "filling_sample",
          "onEnter": "startSampleInsertion",
          "onExit": "updateStats",
          "on": {
            "SAMPLE_STEP": "filling_sample",
            "SAMPLE_COMPLETE": "idle",
            "CANCEL": "idle"
          }
        },
        {
          "name": "error",
          "onEnter": "showError",
          "onExit": "noop",
          "on": {
            "DISMISS_ERROR": "idle"
          }
        }
      ],
      "events": [
        "CLICK_INSERT",
        "CLICK_SEARCH",
        "CLICK_DELETE",
        "CLICK_VISUALIZE_HASH",
        "CLICK_RESET",
        "CLICK_CLEAR",
        "CLICK_FILL_SAMPLE",
        "CLICK_BUCKET",
        "KEY_ENTER",
        "KEY_SHIFT_ENTER",
        "BUCKETS_CHANGED",
        "RESIZE",
        "INSERT_ANIMATION_END",
        "DUPLICATE_DETECTED",
        "INVALID_INPUT",
        "CANCEL",
        "SEARCH_STEP",
        "SEARCH_FOUND",
        "SEARCH_NOT_FOUND",
        "SEARCH_COMPLETE",
        "DELETE_DONE",
        "DELETE_NOT_FOUND",
        "HASH_VIS_STEP",
        "HASH_VIS_DONE",
        "HIGHLIGHT_DONE",
        "RESET_DONE",
        "CLEAR_DONE",
        "SAMPLE_STEP",
        "SAMPLE_COMPLETE",
        "DISMISS_ERROR"
      ],
      "notes": "This FSM is high-level and models asynchronous/animated operations (insert move animation, per-step search highlighting, delete removal animation, stepwise hash visualization and sample bulk inserts). Timers and DOM transitionend callbacks drive transitions such as INSERT_ANIMATION_END, SEARCH_FOUND/NOT_FOUND, DELETE_DONE, HASH_VIS_DONE and SAMPLE_COMPLETE. Invalid input or constraints (empty key, buckets out of range, duplicate key) produce transient error/result messages and return to idle."
    }
  },
  {
    "id": "904d40e0-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:45:33.038Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Weighted Graph",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Weighted Graph — Interactive Module</title>\n  <style>\n    /* Safe area margin 24px on all sides */\n    :root {\n      --safe-margin: 24px;\n      --gap: 16px;\n      --panel-width: 340px;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --accent: #58a6ff;\n      --accent-2: #7ee787;\n      --muted: #94a3b8;\n      --danger: #ff6b6b;\n    }\n    html,body {\n      height: 100%;\n      margin: 0;\n      background: linear-gradient(180deg,var(--bg) 0%, #09101a 100%);\n      color: #e6eef8;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .app {\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height: calc(100vh - calc(var(--safe-margin) * 2));\n      display: flex;\n      gap: var(--gap);\n      align-items: stretch;\n    }\n\n    /* Left panel: info + controls */\n    .panel {\n      width: var(--panel-width);\n      max-width: 40%;\n      min-width: 240px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: 12px;\n      padding: 18px;\n      box-sizing: border-box;\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n    }\n    .title {\n      font-size: 18px;\n      font-weight: 600;\n      color: #f8fafc;\n      display: flex;\n      gap: 8px;\n      align-items: baseline;\n    }\n    .subtitle {\n      font-size: 13px;\n      color: var(--muted);\n      margin-top: 2px;\n    }\n    .section {\n      background: rgba(255,255,255,0.02);\n      border-radius: 8px;\n      padding: 12px;\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n    }\n    .section h3 {\n      margin: 0;\n      font-size: 13px;\n      color: #cfe8ff;\n      font-weight: 600;\n    }\n    .section p {\n      margin: 0;\n      color: var(--muted);\n      font-size: 13px;\n      line-height: 1.3;\n    }\n\n    /* Controls */\n    .controls {\n      display: grid;\n      grid-template-columns: 1fr 1fr;\n      gap: 10px;\n      align-items: center;\n    }\n    button, select, input[type=\"number\"] {\n      appearance: none;\n      border: none;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      color: #e8f3ff;\n      padding: 10px 12px;\n      border-radius: 8px;\n      font-size: 13px;\n      cursor: pointer;\n      outline: none;\n      box-shadow: 0 2px 6px rgba(0,0,0,0.4);\n    }\n    button:hover { transform: translateY(-1px); }\n    .btn-primary {\n      background: linear-gradient(180deg, #1e6fe9, #155bc9);\n      color: white;\n      grid-column: span 2;\n    }\n    .btn-ghost {\n      background: rgba(255,255,255,0.02);\n      border: 1px solid rgba(255,255,255,0.03);\n    }\n    .muted-note {\n      font-size: 12px;\n      color: var(--muted);\n    }\n\n    /* Right: canvas area */\n    .canvas-wrap {\n      flex: 1;\n      min-height: 420px;\n      background: radial-gradient(1200px 600px at 20% 10%, rgba(88,166,255,0.04), transparent 6%), linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius: 12px;\n      padding: 12px;\n      position: relative;\n      overflow: hidden;\n      display: flex;\n      flex-direction: column;\n      gap: 10px;\n    }\n    .canvas-top {\n      display: flex;\n      justify-content: space-between;\n      gap: 12px;\n      align-items: center;\n    }\n    .hint {\n      color: var(--muted);\n      font-size: 13px;\n      margin-left: 8px;\n    }\n    svg {\n      width: 100%;\n      height: 100%;\n      border-radius: 8px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      cursor: crosshair;\n      touch-action: none;\n    }\n\n    /* Node and Edge styling derived from classes */\n    .node {\n      cursor: pointer;\n    }\n    .node .node-circle {\n      fill: #071a2b;\n      stroke: #2b6fd6;\n      stroke-width: 2;\n      transition: transform 120ms ease, stroke 120ms ease;\n      filter: drop-shadow(0 6px 12px rgba(2,6,23,0.6));\n    }\n    .node.selected .node-circle {\n      stroke: #ffd166;\n      stroke-width: 3.2;\n      transform: scale(1.04);\n    }\n    .node.visiting .node-circle { stroke: #ffb020; }\n    .node.settled .node-circle { stroke: #34d399; }\n    .node.final .node-circle { stroke: #9b5cff; stroke-width: 3.6; }\n    .node-label {\n      fill: #e6f0ff;\n      font-size: 12px;\n      pointer-events: none;\n    }\n    .node-dist {\n      fill: #94a3b8;\n      font-size: 11px;\n      pointer-events: none;\n    }\n    .edge-line {\n      stroke: rgba(255,255,255,0.06);\n      stroke-width: 3;\n      stroke-linecap: round;\n      transition: stroke 200ms ease;\n    }\n    .edge-line.consider { stroke: #ffb020; stroke-width: 4.4; }\n    .edge-line.updated { stroke: #34d399; stroke-width: 4.4; }\n    .edge-line.final { stroke: #9b5cff; stroke-width: 4.6; }\n    .edge-weight {\n      fill: #dbeafe;\n      font-size: 12px;\n      pointer-events: none;\n      background: transparent;\n      text-anchor: middle;\n    }\n\n    /* Modal for weight input */\n    .modal {\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%,-50%);\n      background: linear-gradient(180deg, rgba(12,20,30,0.98), rgba(8,12,18,0.98));\n      padding: 14px;\n      border-radius: 10px;\n      box-shadow: 0 12px 36px rgba(2,6,23,0.75);\n      z-index: 40;\n      min-width: 260px;\n    }\n    .modal h4 {\n      margin: 0 0 8px 0;\n      font-size: 14px;\n      color: #e8f4ff;\n    }\n    .modal .row {\n      display: flex;\n      gap: 8px;\n      align-items: center;\n    }\n    .modal input[type=\"number\"] {\n      width: 100%;\n      padding: 8px;\n      font-size: 13px;\n      border-radius: 8px;\n      border: none;\n      background: rgba(255,255,255,0.02);\n      color: #e6f0ff;\n    }\n    .modal .actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 10px; }\n    .small {\n      font-size: 12px;\n      color: var(--muted);\n    }\n\n    /* Responsive: stack panels on narrow screens */\n    @media (max-width: 900px) {\n      .app { flex-direction: column; padding: 18px; }\n      .panel { width: 100%; max-width: none; order: 2; }\n      .canvas-wrap { order: 1; min-height: 360px; }\n    }\n\n    /* tiny helper link style */\n    a.doclink {\n      color: var(--accent);\n      text-decoration: none;\n      font-weight: 600;\n      font-size: 13px;\n    }\n\n    /* keyboard hint */\n    .kbd {\n      display: inline-block;\n      padding: 4px 8px;\n      border-radius: 6px;\n      background: rgba(255,255,255,0.02);\n      border: 1px solid rgba(255,255,255,0.03);\n      font-size: 12px;\n      color: var(--muted);\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Weighted Graph interactive module\">\n    <!-- Left panel: Plan / Controls -->\n    <aside class=\"panel\" aria-labelledby=\"module-title\">\n      <div>\n        <div class=\"title\" id=\"module-title\">Weighted Graph — Shortest Path Explorer</div>\n        <div class=\"subtitle\">Interactive module: create nodes and weighted edges, then visualize how weights affect shortest path (Dijkstra)</div>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"learning-objective\">\n        <h3 id=\"learning-objective\">Learning Objective</h3>\n        <p>After using this module you should understand how edge weights influence shortest-path selection: how exploring nodes, relaxing edges, and updating tentative distances leads to the final shortest path from a chosen source to a target.</p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"interaction-design\">\n        <h3 id=\"interaction-design\">Interaction Design</h3>\n        <p>How you interact:</p>\n        <ul style=\"margin:0 0 0 18px; color:var(--muted); font-size:13px;\">\n          <li>Click anywhere on canvas to add a node (auto-labeled).</li>\n          <li>Drag nodes to reposition them — edges update in real-time.</li>\n          <li>Click a node once to select, then click another node to create an undirected edge; set or edit its weight in the popup.</li>\n          <li>Click an edge to edit its weight; select a node and press Delete to remove it and its edges.</li>\n          <li>Choose source and target from controls, then press \"Run Dijkstra\" to animate the algorithm step-by-step.</li>\n        </ul>\n        <p class=\"small\">Visual feedback: nodes and edges change color during exploration; tentative distances appear next to nodes; final shortest path is highlighted.</p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"layout-description\">\n        <h3 id=\"layout-description\">Layout Description & Accessibility</h3>\n        <p>The module uses a two-column layout: left for text and controls, right for the interactive SVG canvas. Safe area margins are 24px; spacing between controls is at least 16px. Elements are keyboard-focusable and labels provided for assistive tech. The canvas is responsive and stacks above controls on narrow screens.</p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"controls-title\" style=\"margin-top:4px;\">\n        <h3 id=\"controls-title\">Controls</h3>\n        <div class=\"controls\" role=\"region\" aria-label=\"controls\">\n          <button id=\"btn-clear\" class=\"btn-ghost\" title=\"Clear graph\">Clear Graph</button>\n          <button id=\"btn-random\" class=\"btn-ghost\" title=\"Generate random graph\">Random Graph</button>\n\n          <select id=\"select-source\" aria-label=\"Source node\">\n            <option value=\"\">Source</option>\n          </select>\n          <select id=\"select-target\" aria-label=\"Target node\">\n            <option value=\"\">Target</option>\n          </select>\n\n          <button id=\"btn-run\" class=\"btn-primary\" style=\"grid-column: span 2;\">Run Dijkstra</button>\n\n          <button id=\"btn-step\" class=\"btn-ghost\">Step</button>\n          <button id=\"btn-stop\" class=\"btn-ghost\">Stop</button>\n        </div>\n\n        <p class=\"muted-note\">Tips: Click a node to select it for edge creation. Press Delete to remove selected node. \"Step\" runs the next algorithm step when animation is paused.</p>\n      </div>\n\n      <div style=\"margin-top:auto;\" class=\"small\">Made with vanilla HTML/CSS/JS — no external libraries. Colors show state: orange = considering, green = updated/settled, purple = final path.</div>\n    </aside>\n\n    <!-- Right: Interactive Canvas -->\n    <main class=\"canvas-wrap\" id=\"canvas-wrap\">\n      <div class=\"canvas-top\" role=\"toolbar\" aria-label=\"Canvas controls\">\n        <div style=\"display:flex;flex-direction:column;\">\n          <div class=\"hint\">Canvas: Click to add node · Drag to move</div>\n          <div class=\"hint\" style=\"margin-top:6px;font-size:12px;color:var(--muted)\">Select a node then click another to make an edge. Click edge to edit weight.</div>\n        </div>\n        <div style=\"display:flex;gap:12px;align-items:center;\">\n          <div class=\"kbd\">Selected: <span id=\"selected-info\" style=\"color:#e6f0ff;margin-left:8px\">None</span></div>\n        </div>\n      </div>\n\n      <div style=\"flex:1; min-height:220px; position:relative;\">\n        <svg id=\"svg-canvas\" tabindex=\"0\" role=\"img\" aria-label=\"Graph canvas\"></svg>\n        <!-- Modal (hidden until needed) -->\n        <div id=\"modal\" class=\"modal\" style=\"display:none;\" role=\"dialog\" aria-modal=\"true\" aria-labelledby=\"modal-title\">\n          <h4 id=\"modal-title\">Set edge weight</h4>\n          <div class=\"row\">\n            <input id=\"modal-weight\" type=\"number\" step=\"0.1\" min=\"0\" value=\"1\" aria-label=\"Edge weight\" />\n          </div>\n          <div class=\"actions\">\n            <button id=\"modal-cancel\" class=\"btn-ghost\">Cancel</button>\n            <button id=\"modal-save\" class=\"btn-primary\">Save</button>\n          </div>\n        </div>\n      </div>\n    </main>\n  </div>\n\n  <script>\n    /******************************************************************\n     * Weighted Graph Interactive Module\n     * - No external libraries\n     * - Implements node creation, drag, edge creation, weight editing\n     * - Runs Dijkstra with step-by-step animation\n     ******************************************************************/\n\n    (function() {\n      // Basic state\n      let nodes = [];     // {id,label,x,y,dist,prev}\n      let edges = [];     // {id,u,v,w}\n      let nodeId = 0;\n      let edgeId = 0;\n\n      // Selected state\n      let selectedNode = null; // id\n      let hoverElement = null;\n      let dragging = null; // {id,offsetX,offsetY}\n\n      // Animation / algorithm state\n      let animSteps = []; // sequence of actions for animation\n      let animIndex = 0;\n      let animTimer = null;\n      let animPaused = true;\n\n      // DOM refs\n      const svg = document.getElementById('svg-canvas');\n      const wrap = document.getElementById('canvas-wrap');\n      const selectedInfo = document.getElementById('selected-info');\n      const btnClear = document.getElementById('btn-clear');\n      const btnRandom = document.getElementById('btn-random');\n      const btnRun = document.getElementById('btn-run');\n      const btnStep = document.getElementById('btn-step');\n      const btnStop = document.getElementById('btn-stop');\n      const selectSource = document.getElementById('select-source');\n      const selectTarget = document.getElementById('select-target');\n      const modal = document.getElementById('modal');\n      const modalWeight = document.getElementById('modal-weight');\n      const modalSave = document.getElementById('modal-save');\n      const modalCancel = document.getElementById('modal-cancel');\n\n      // SVG groups\n      const gEdges = document.createElementNS('http://www.w3.org/2000/svg','g');\n      const gEdgeLabels = document.createElementNS('http://www.w3.org/2000/svg','g');\n      const gNodes = document.createElementNS('http://www.w3.org/2000/svg','g');\n      svg.appendChild(gEdges);\n      svg.appendChild(gEdgeLabels);\n      svg.appendChild(gNodes);\n\n      // Utility functions\n      function createNode(x,y) {\n        const id = 'n' + (++nodeId);\n        const label = String(nodeId);\n        const node = { id, label, x, y, dist: Infinity, prev: null };\n        nodes.push(node);\n        drawNode(node);\n        updateSelectors();\n        return node;\n      }\n\n      function createEdge(uId, vId, weight) {\n        // prevent self-loop or duplicates\n        if (uId === vId) return null;\n        const existing = edges.find(e => (e.u===uId && e.v===vId) || (e.u===vId && e.v===uId));\n        if (existing) return null;\n        const id = 'e' + (++edgeId);\n        const edge = { id, u: uId, v: vId, w: Number(weight) };\n        edges.push(edge);\n        drawEdge(edge);\n        return edge;\n      }\n\n      function removeNode(nodeIdToRemove) {\n        nodes = nodes.filter(n => n.id !== nodeIdToRemove);\n        edges = edges.filter(e => e.u !== nodeIdToRemove && e.v !== nodeIdToRemove);\n        selectedNode = null;\n        redraw();\n        updateSelectors();\n      }\n\n      function setEdgeWeight(edgeIdToEdit, weight) {\n        const e = edges.find(ed => ed.id === edgeIdToEdit);\n        if (e) { e.w = Number(weight); redraw(); }\n      }\n\n      function updateSelectors() {\n        // rebuild source/target selects\n        [selectSource, selectTarget].forEach(sel => {\n          const val = sel.value;\n          while (sel.firstChild) sel.removeChild(sel.firstChild);\n          const op0 = document.createElement('option');\n          op0.value = '';\n          op0.textContent = sel===selectSource ? 'Source' : 'Target';\n          sel.appendChild(op0);\n          nodes.forEach(n=>{\n            const op = document.createElement('option');\n            op.value = n.id;\n            op.textContent = n.label;\n            sel.appendChild(op);\n          });\n          sel.value = nodes.some(nn=>nn.id===val) ? val : '';\n        });\n      }\n\n      // Drawing\n      function drawNode(node) {\n        const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg','g');\n        nodeGroup.classList.add('node');\n        nodeGroup.setAttribute('data-id', node.id);\n        nodeGroup.setAttribute('transform', `translate(${node.x},${node.y})`);\n        nodeGroup.innerHTML = `\n          <circle class=\"node-circle\" r=\"18\"></circle>\n          <text class=\"node-label\" y=\"-4\" text-anchor=\"middle\">${node.label}</text>\n          <text class=\"node-dist\" y=\"18\" text-anchor=\"middle\">${displayDist(node.dist)}</text>\n        `;\n        // event listeners\n        nodeGroup.addEventListener('pointerdown', onNodePointerDown);\n        nodeGroup.addEventListener('pointerup', onNodePointerUp);\n        nodeGroup.addEventListener('click', onNodeClick);\n        nodeGroup.addEventListener('contextmenu', (e)=>{ e.preventDefault(); removeNode(node.id); });\n        gNodes.appendChild(nodeGroup);\n      }\n\n      function drawEdge(edge) {\n        const u = nodes.find(n => n.id === edge.u);\n        const v = nodes.find(n => n.id === edge.v);\n        if (!u || !v) return;\n\n        // line\n        const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n        line.classList.add('edge-line');\n        line.setAttribute('data-id', edge.id);\n        line.setAttribute('x1', u.x);\n        line.setAttribute('y1', u.y);\n        line.setAttribute('x2', v.x);\n        line.setAttribute('y2', v.y);\n        line.addEventListener('click', onEdgeClick);\n        gEdges.appendChild(line);\n\n        // label\n        const mid = midpoint(u,v);\n        const label = document.createElementNS('http://www.w3.org/2000/svg','text');\n        label.classList.add('edge-weight');\n        label.setAttribute('data-id', edge.id);\n        label.setAttribute('x', mid.x);\n        label.setAttribute('y', mid.y - 6);\n        label.textContent = edge.w;\n        gEdgeLabels.appendChild(label);\n      }\n\n      function redraw() {\n        // clear groups\n        while (gNodes.firstChild) gNodes.removeChild(gNodes.firstChild);\n        while (gEdges.firstChild) gEdges.removeChild(gEdges.firstChild);\n        while (gEdgeLabels.firstChild) gEdgeLabels.removeChild(gEdgeLabels.firstChild);\n        // redraw edges then nodes\n        edges.forEach(drawEdge);\n        nodes.forEach(drawNode);\n        updateSelectedDisplay();\n      }\n\n      function updatePositions() {\n        // update edge positions and node transforms\n        gNodes.querySelectorAll('.node').forEach(g => {\n          const id = g.getAttribute('data-id');\n          const n = nodes.find(x=>x.id===id);\n          if (n) g.setAttribute('transform', `translate(${n.x},${n.y})`);\n          const distElem = g.querySelector('.node-dist');\n          if (distElem) distElem.textContent = displayDist(n.dist);\n        });\n        gEdges.querySelectorAll('.edge-line').forEach(line => {\n          const id = line.getAttribute('data-id');\n          const e = edges.find(x=>x.id===id);\n          if (!e) return;\n          const u = nodes.find(n=>n.id===e.u);\n          const v = nodes.find(n=>n.id===e.v);\n          if (u && v) {\n            line.setAttribute('x1', u.x);\n            line.setAttribute('y1', u.y);\n            line.setAttribute('x2', v.x);\n            line.setAttribute('y2', v.y);\n          }\n        });\n        gEdgeLabels.querySelectorAll('.edge-weight').forEach(label => {\n          const id = label.getAttribute('data-id');\n          const e = edges.find(x=>x.id===id);\n          if (!e) return;\n          const u = nodes.find(n=>n.id===e.u);\n          const v = nodes.find(n=>n.id===e.v);\n          if (u && v) {\n            const mid = midpoint(u,v);\n            label.setAttribute('x', mid.x);\n            label.setAttribute('y', mid.y - 6);\n            label.textContent = e.w;\n          }\n        });\n      }\n\n      function midpoint(a,b) {\n        return { x: (a.x+b.x)/2, y: (a.y+b.y)/2 };\n      }\n\n      function displayDist(d) {\n        if (d === Infinity) return '∞';\n        return (Math.round(d*100)/100).toString();\n      }\n\n      // Event handlers for canvas interactions\n      svg.addEventListener('click', function(evt) {\n        // If click on svg background (not on node or edge)\n        if (evt.target === svg) {\n          const pt = getSvgPoint(evt.clientX, evt.clientY);\n          const rect = svg.getBoundingClientRect();\n          createNode(pt.x, pt.y);\n          updatePositions();\n        }\n      });\n\n      function getSvgPoint(clientX, clientY) {\n        const rect = svg.getBoundingClientRect();\n        // Simple mapping: use client coords relative to svg top-left\n        return { x: clientX - rect.left, y: clientY - rect.top };\n      }\n\n      // Node pointer events for dragging\n      function onNodePointerDown(evt) {\n        evt.stopPropagation();\n        const target = evt.currentTarget;\n        const id = target.getAttribute('data-id');\n        const n = nodes.find(x=>x.id===id);\n        if (!n) return;\n        dragging = { id, startX: evt.clientX, startY: evt.clientY, origX: n.x, origY: n.y };\n        target.setPointerCapture(evt.pointerId);\n      }\n\n      function onNodePointerUp(evt) {\n        if (!dragging) return;\n        const target = evt.currentTarget;\n        try { target.releasePointerCapture(evt.pointerId); } catch(e){}\n        dragging = null;\n      }\n\n      window.addEventListener('pointermove', function(evt) {\n        if (!dragging) return;\n        const n = nodes.find(x=>x.id===dragging.id);\n        if (!n) return;\n        const dx = evt.clientX - dragging.startX;\n        const dy = evt.clientY - dragging.startY;\n        n.x = dragging.origX + dx;\n        n.y = dragging.origY + dy;\n        updatePositions();\n      });\n\n      // Node click: select or create edge\n      function onNodeClick(evt) {\n        evt.stopPropagation();\n        const target = evt.currentTarget;\n        const id = target.getAttribute('data-id');\n        if (!selectedNode) {\n          selectedNode = id;\n          updateSelectedDisplay();\n        } else if (selectedNode === id) {\n          // Deselect\n          selectedNode = null;\n          updateSelectedDisplay();\n        } else {\n          // Create edge between selectedNode and id\n          openWeightModal(1, function(weight){\n            const e = createEdge(selectedNode, id, weight);\n            if (e) {\n              redraw();\n            } else {\n              // maybe show message; omitted for brevity\n            }\n            selectedNode = null;\n            updateSelectedDisplay();\n          });\n        }\n      }\n\n      // Edge click: edit weight\n      function onEdgeClick(evt) {\n        evt.stopPropagation();\n        const line = evt.currentTarget;\n        const id = line.getAttribute('data-id');\n        const e = edges.find(x=>x.id===id);\n        if (!e) return;\n        openWeightModal(e.w, function(w){\n          setEdgeWeight(id, w);\n        });\n      }\n\n      function updateSelectedDisplay() {\n        selectedInfo.textContent = selectedNode ? (nodes.find(n=>n.id===selectedNode)?.label || '—') : 'None';\n        // update node visuals\n        gNodes.querySelectorAll('.node').forEach(g => {\n          const id = g.getAttribute('data-id');\n          g.classList.toggle('selected', id === selectedNode);\n        });\n      }\n\n      // Modal for weight input\n      let modalCallback = null;\n      function openWeightModal(defaultValue, callback) {\n        modal.style.display = 'block';\n        modalWeight.value = defaultValue;\n        modalCallback = callback;\n        modalWeight.focus();\n      }\n      function closeModal() {\n        modal.style.display = 'none';\n        modalCallback = null;\n      }\n      modalCancel.addEventListener('click', function(){ closeModal(); });\n      modalSave.addEventListener('click', function(){\n        const val = parseFloat(modalWeight.value);\n        if (!isFinite(val) || val < 0) {\n          modalWeight.focus();\n          return;\n        }\n        if (modalCallback) modalCallback(val);\n        closeModal();\n      });\n\n      // Keyboard: Delete to remove selected node\n      window.addEventListener('keydown', function(evt) {\n        if (evt.key === 'Delete' || evt.key === 'Backspace') {\n          if (selectedNode) {\n            removeNode(selectedNode);\n            selectedNode = null;\n            updateSelectedDisplay();\n          }\n        }\n      });\n\n      // Clear / Random\n      btnClear.addEventListener('click', function(){\n        nodes = []; edges = []; nodeId = 0; edgeId = 0; selectedNode = null;\n        redraw();\n        updateSelectors();\n      });\n\n      btnRandom.addEventListener('click', function(){\n        nodes = []; edges = []; nodeId = 0; edgeId = 0;\n        // generate 6-9 nodes\n        const count = 6 + Math.floor(Math.random()*4);\n        const rect = svg.getBoundingClientRect();\n        for (let i=0;i<count;i++){\n          const x = 80 + Math.random()*(rect.width-160);\n          const y = 40 + Math.random()*(rect.height-120);\n          createNode(x,y);\n        }\n        // create some random edges\n        const allIds = nodes.map(n=>n.id);\n        for (let i=0;i<allIds.length;i++){\n          const u = allIds[i];\n          // add 1-3 edges per node\n          const deg = 1 + Math.floor(Math.random()*3);\n          for (let j=0;j<deg;j++){\n            const v = allIds[Math.floor(Math.random()*allIds.length)];\n            if (u === v) continue;\n            const w = Math.round((1 + Math.random()*9)*10)/10;\n            createEdge(u,v,w);\n          }\n        }\n        redraw();\n        updateSelectors();\n      });\n\n      // Dijkstra algorithm — produce steps for animation\n      function buildDijkstraSteps(sourceId, targetId) {\n        // Reset distances\n        nodes.forEach(n => { n.dist = Infinity; n.prev = null; });\n        const nodeMap = new Map(nodes.map(n=>[n.id, n]));\n        const adj = new Map();\n        nodes.forEach(n => adj.set(n.id,[]));\n        edges.forEach(e => {\n          adj.get(e.u).push({ to: e.v, w: e.w, id: e.id });\n          adj.get(e.v).push({ to: e.u, w: e.w, id: e.id });\n        });\n        const steps = [];\n        // min-heap simulated with array; we'll use simple array for clarity\n        nodes.forEach(n => { n.dist = Infinity; n.prev = null; });\n        const source = sourceId;\n        nodeMap.get(source).dist = 0;\n        // initial push\n        const pq = [{id: source, dist: 0}];\n\n        const visited = new Set();\n\n        while (pq.length) {\n          // pop smallest\n          pq.sort((a,b)=>a.dist-b.dist);\n          const cur = pq.shift();\n          const u = cur.id;\n          if (visited.has(u)) continue;\n          visited.add(u);\n          // record visiting node\n          steps.push({ type: 'visitNode', nodeId: u });\n          if (u === targetId) {\n            // we can break early after visiting target (Dijkstra guarantee)\n            break;\n          }\n          const neighbors = adj.get(u) || [];\n          for (const nb of neighbors) {\n            // consider edge u->v\n            steps.push({ type: 'considerEdge', edgeId: nb.id, from: u, to: nb.to, w: nb.w });\n            const alt = nodeMap.get(u).dist + nb.w;\n            if (alt < nodeMap.get(nb.to).dist) {\n              nodeMap.get(nb.to).dist = alt;\n              nodeMap.get(nb.to).prev = u;\n              // record update\n              steps.push({ type: 'updateNode', nodeId: nb.to, newDist: alt, via: u, edgeId: nb.id });\n              pq.push({ id: nb.to, dist: alt });\n            }\n          }\n          // settled\n          steps.push({ type: 'settleNode', nodeId: u });\n        }\n\n        // build final path events by following prev pointers from target to source\n        const finalPath = [];\n        let curId = targetId;\n        if (nodeMap.get(curId).prev !== null || curId === sourceId) {\n          while (curId) {\n            finalPath.push(curId);\n            if (curId === sourceId) break;\n            curId = nodeMap.get(curId).prev;\n            if (!curId) break;\n          }\n          // set final path edges\n          for (let i=0;i<finalPath.length-1;i++) {\n            const a = finalPath[i], b = finalPath[i+1];\n            // find edge id between a and b\n            const e = edges.find(ed => (ed.u===a && ed.v===b) || (ed.u===b && ed.v===a));\n            if (e) steps.push({ type: 'finalEdge', edgeId: e.id });\n          }\n          // highlight nodes of final path\n          finalPath.forEach(nid => steps.push({ type: 'finalNode', nodeId: nid }));\n        }\n\n        return steps;\n      }\n\n      // Animation runner\n      function resetNodeEdgeVisuals() {\n        // clear classes\n        gNodes.querySelectorAll('.node').forEach(g => {\n          g.classList.remove('visiting','settled','final');\n        });\n        gEdges.querySelectorAll('.edge-line').forEach(l => {\n          l.classList.remove('consider','updated','final');\n        });\n      }\n\n      function runAnimation(steps) {\n        if (!steps || !steps.length) return;\n        animSteps = steps;\n        animIndex = 0;\n        animPaused = false;\n        resetNodeEdgeVisuals();\n        // also reset distances display to current node state saved in nodes (we will update them as updates occur)\n        nodes.forEach(n => n.dist = Infinity);\n        updatePositions();\n\n        // start timer\n        if (animTimer) clearInterval(animTimer);\n        animTimer = setInterval(()=> {\n          if (animIndex >= animSteps.length) {\n            clearInterval(animTimer);\n            animTimer = null;\n            animPaused = true;\n            return;\n          }\n          stepAnimation();\n        }, 700);\n      }\n\n      function stepAnimation() {\n        if (animIndex >= animSteps.length) return;\n        const s = animSteps[animIndex++];\n        switch (s.type) {\n          case 'visitNode':\n            { // highlight node as visiting\n              const g = gNodes.querySelector(`.node[data-id=\"${s.nodeId}\"]`);\n              if (g) {\n                g.classList.add('visiting');\n              }\n            }\n            break;\n          case 'considerEdge':\n            {\n              const line = gEdges.querySelector(`.edge-line[data-id=\"${s.edgeId}\"]`);\n              if (line) {\n                line.classList.add('consider');\n                // remove after short time\n                setTimeout(()=>{ line.classList.remove('consider'); }, 500);\n              }\n            }\n            break;\n          case 'updateNode':\n            {\n              // update tentative distance\n              const node = nodes.find(n=>n.id===s.nodeId);\n              if (node) {\n                node.dist = s.newDist;\n                node.prev = s.via;\n                updatePositions();\n                const line = gEdges.querySelector(`.edge-line[data-id=\"${s.edgeId}\"]`);\n                if (line) {\n                  line.classList.add('updated');\n                  setTimeout(()=>{ line.classList.remove('updated'); }, 800);\n                }\n              }\n            }\n            break;\n          case 'settleNode':\n            {\n              const g = gNodes.querySelector(`.node[data-id=\"${s.nodeId}\"]`);\n              if (g) {\n                g.classList.remove('visiting');\n                g.classList.add('settled');\n              }\n            }\n            break;\n          case 'finalEdge':\n            {\n              const line = gEdges.querySelector(`.edge-line[data-id=\"${s.edgeId}\"]`);\n              if (line) line.classList.add('final');\n            }\n            break;\n          case 'finalNode':\n            {\n              const g = gNodes.querySelector(`.node[data-id=\"${s.nodeId}\"]`);\n              if (g) g.classList.add('final');\n            }\n            break;\n        }\n      }\n\n      // Run / Step / Stop controls\n      btnRun.addEventListener('click', function(){\n        const src = selectSource.value;\n        const tgt = selectTarget.value;\n        if (!src || !tgt) {\n          alert('Please choose both source and target nodes.');\n          return;\n        }\n        animSteps = buildDijkstraSteps(src,tgt);\n        runAnimation(animSteps);\n      });\n\n      btnStep.addEventListener('click', function(){\n        if (!animSteps || !animSteps.length) {\n          const src = selectSource.value;\n          const tgt = selectTarget.value;\n          if (!src || !tgt) {\n            alert('Please choose both source and target nodes, then press Step.');\n            return;\n          }\n          animSteps = buildDijkstraSteps(src,tgt);\n          animIndex = 0;\n          resetNodeEdgeVisuals();\n          // reset distances\n          nodes.forEach(n => n.dist = Infinity);\n          updatePositions();\n        }\n        if (animIndex >= animSteps.length) return;\n        stepAnimation();\n      });\n\n      btnStop.addEventListener('click', function(){\n        if (animTimer) clearInterval(animTimer);\n        animTimer = null;\n        animPaused = true;\n      });\n\n      // Dbl click on edge to open weight edit (some clients)\n      svg.addEventListener('dblclick', function(evt){ evt.preventDefault(); });\n\n      // Initialization: add a starter graph\n      function initDefault() {\n        // create a small sample graph\n        nodes = []; edges = []; nodeId = 0; edgeId = 0;\n        const W = svg.clientWidth || 800;\n        const H = svg.clientHeight || 480;\n        const nA = createNode(W*0.22, H*0.28);\n        const nB = createNode(W*0.46, H*0.18);\n        const nC = createNode(W*0.7, H*0.3);\n        const nD = createNode(W*0.28, H*0.58);\n        const nE = createNode(W*0.56, H*0.6);\n\n        createEdge(nA.id, nB.id, 4);\n        createEdge(nB.id, nC.id, 2.5);\n        createEdge(nA.id, nD.id, 6);\n        createEdge(nD.id, nE.id, 3);\n        createEdge(nE.id, nC.id, 2);\n        createEdge(nB.id, nE.id, 5);\n\n        redraw();\n        updateSelectors();\n      }\n\n      initDefault();\n\n      // Keep svg responsive on resize\n      window.addEventListener('resize', function(){ updatePositions(); });\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Weighted Graph.\n\n**Project Overview:**\nTopic: Weighted Graph\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Weighted Graph"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "87068730-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:46:16.456Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Deque",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Deque Interactive Module</title>\n  <style>\n    :root{\n      --safe: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --accent: #60a5fa;\n      --muted: #94a3b8;\n      --ok: #10b981;\n      --danger: #ef4444;\n      --glass: rgba(255,255,255,0.03);\n      --radius: 10px;\n      --shadow: 0 6px 18px rgba(2,6,23,0.6);\n    }\n\n    /* Safe area margins */\n    html,body{\n      height:100%;\n      margin:0;\n      padding:var(--safe);\n      background: linear-gradient(180deg,#071123 0%, #071427 100%);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      color: #e6eef8;\n      box-sizing:border-box;\n    }\n    *{box-sizing:inherit}\n    a{color:inherit}\n\n    /* Layout */\n    .container{\n      max-width:1200px;\n      margin:0 auto;\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n    }\n\n    /* Left explanation column */\n    .panel {\n      flex: 1 1 360px;\n      min-width:280px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:var(--radius);\n      padding:20px;\n      box-shadow:var(--shadow);\n      border:1px solid rgba(255,255,255,0.03);\n    }\n\n    h1{margin:0 0 10px 0; font-size:20px}\n    p{margin:0 0 12px 0; color:var(--muted); line-height:1.45}\n    .section-title{font-weight:600; margin-top:12px; margin-bottom:8px; color:#dbeafe}\n\n    /* Right interactive canvas */\n    .canvas {\n      flex: 2 1 640px;\n      min-width:320px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:var(--radius);\n      padding:20px;\n      box-shadow:var(--shadow);\n      border:1px solid rgba(255,255,255,0.03);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    /* Controls layout */\n    .controls {\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .input-group{\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n    input[type=\"text\"]{\n      background:var(--glass);\n      border:1px solid rgba(255,255,255,0.04);\n      padding:10px 12px;\n      border-radius:8px;\n      color:inherit;\n      min-width:160px;\n      outline:none;\n    }\n    input[type=\"text\"]::placeholder{color:rgba(230,238,248,0.5)}\n    button{\n      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      padding:10px 14px;\n      border-radius:8px;\n      color:inherit;\n      cursor:pointer;\n      transition:transform .12s ease, box-shadow .12s ease;\n      min-width:110px;\n    }\n    button:active{transform:translateY(1px)}\n    button:focus{outline:2px solid rgba(96,165,250,0.2); box-shadow:0 6px 18px rgba(96,165,250,0.06)}\n    .primary{\n      background:linear-gradient(180deg, #2563eb, #1e40af);\n      border:1px solid rgba(255,255,255,0.08);\n      box-shadow:0 6px 16px rgba(37,99,235,0.12);\n    }\n    .danger{\n      background:linear-gradient(180deg,#ef4444,#b91c1c);\n    }\n\n    /* Toggles and sliders */\n    .row {\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .small{\n      font-size:13px;\n      color:var(--muted);\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n    input[type=\"range\"]{\n      width:180px;\n    }\n\n    /* Deque visual */\n    .deque-viewport{\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));\n      border-radius:12px;\n      padding:20px;\n      display:flex;\n      flex-direction:column;\n      gap:14px;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .deque-track{\n      min-height:120px;\n      display:flex;\n      align-items:center;\n      gap:12px;\n      padding:12px;\n      overflow:auto;\n    }\n    .slot{\n      width:96px;\n      height:72px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));\n      border:1px dashed rgba(255,255,255,0.03);\n      border-radius:10px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      position:relative;\n      flex: 0 0 96px;\n      transition:transform .25s cubic-bezier(.2,.9,.3,1), box-shadow .2s ease, opacity .2s ease;\n    }\n    .slot.filled{\n      border-style:solid;\n      border-color:rgba(96,165,250,0.18);\n      background: linear-gradient(180deg, rgba(96,165,250,0.06), rgba(96,165,250,0.02));\n    }\n    .node {\n      background: linear-gradient(180deg,#0ea5e9,#0369a1);\n      color:white;\n      padding:10px 14px;\n      border-radius:8px;\n      font-weight:600;\n      box-shadow:0 8px 18px rgba(3,105,161,0.18);\n      transform:translateY(0);\n      transition:transform .28s cubic-bezier(.2,.9,.3,1), opacity .18s ease;\n      max-width:88px;\n      text-overflow:ellipsis;\n      overflow:hidden;\n      white-space:nowrap;\n    }\n    .slot.empty .node{opacity:0.0}\n    .slot.head::after, .slot.tail::after{\n      content:'';\n      position:absolute;\n      left:50%;\n      transform:translateX(-50%);\n      bottom:-16px;\n      width:0;height:0;\n      border-left:8px solid transparent;\n      border-right:8px solid transparent;\n    }\n    .slot.head::after{\n      border-top:8px solid #34d399;\n    }\n    .slot.tail::after{\n      border-top:8px solid #fca5a5;\n      bottom:-18px;\n    }\n    .index {\n      font-size:12px;\n      color:var(--muted);\n      text-align:center;\n      margin-top:6px;\n    }\n\n    /* Animations for push/pop */\n    .animate-in-left{ animation:pushInLeft .36s cubic-bezier(.2,.9,.3,1) both; }\n    .animate-in-right{ animation:pushInRight .36s cubic-bezier(.2,.9,.3,1) both; }\n    .animate-out-left{ animation:popOutLeft .36s ease both; }\n    .animate-out-right{ animation:popOutRight .36s ease both; }\n    @keyframes pushInLeft {\n      from { transform: translateX(-40px) scale(.98); opacity:0 }\n      to   { transform: translateX(0) scale(1); opacity:1 }\n    }\n    @keyframes pushInRight {\n      from { transform: translateX(40px) scale(.98); opacity:0 }\n      to   { transform: translateX(0) scale(1); opacity:1 }\n    }\n    @keyframes popOutLeft {\n      from { transform: translateX(0) scale(1); opacity:1 }\n      to   { transform: translateX(-40px) scale(.98); opacity:0 }\n    }\n    @keyframes popOutRight {\n      from { transform: translateX(0) scale(1); opacity:1 }\n      to   { transform: translateX(40px) scale(.98); opacity:0 }\n    }\n\n    /* Feedback messages */\n    .message {\n      padding:10px 12px;\n      border-radius:8px;\n      font-size:13px;\n      color:#081126;\n      display:inline-block;\n    }\n    .msg-ok{ background: linear-gradient(180deg,#bbf7d0,#86efac); }\n    .msg-error{ background: linear-gradient(180deg,#fecaca,#fca5a5); color:#210101; }\n\n    /* Operation log */\n    .log{\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));\n      padding:12px;\n      border-radius:8px;\n      font-size:13px;\n      color:var(--muted);\n      max-height:140px;\n      overflow:auto;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .log-entry{ margin-bottom:8px; }\n    .controls .spacer{flex:1}\n\n    /* Drag chip */\n    .chip {\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n      padding:8px 10px;\n      border-radius:999px;\n      background:linear-gradient(180deg,#1f2937,#111827);\n      border:1px solid rgba(255,255,255,0.03);\n      cursor:grab;\n      color:var(--muted);\n    }\n    .chip:active{cursor:grabbing}\n    .chip .value{ color:#e6eef8; font-weight:700 }\n\n    /* Responsive */\n    @media (max-width:900px){\n      .container{flex-direction:column}\n      .panel{order:2}\n      .canvas{order:1}\n      .slot{width:84px; height:64px; flex:0 0 84px}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"application\" aria-label=\"Deque interactive module\">\n    <!-- Left panel: Concept Title, Learning Objective, Interaction Design, Layout Description -->\n    <aside class=\"panel\" aria-labelledby=\"concept-title\">\n      <h1 id=\"concept-title\">Deque — Double-Ended Queue (Interactive)</h1>\n      <p><strong>Learning Objective:</strong> After using this module you will understand deque operations (push/pop from both ends), how a bounded (circular) deque differs from an unbounded deque, and see visual animations that reinforce the head/tail behavior and edge cases (full/empty).</p>\n\n      <div class=\"section-title\">Interaction Design</div>\n      <p>\n        Interact using buttons, a draggable \"chip\", or keyboard:\n      </p>\n      <ul style=\"color:var(--muted); margin:8px 0 12px 18px;\">\n        <li>Type a value and use Push Front / Push Back to insert. Watch it slide in from the chosen side.</li>\n        <li>Use Pop Front / Pop Back to remove. The removed node animates out and is displayed in the feedback area.</li>\n        <li>Enable \"Bounded (circular)\" to visualize a fixed-capacity ring buffer with head/tail pointers and slot indices.</li>\n        <li>Drag the blue chip onto the left/right of the deque to insert from that side (drag-and-drop).</li>\n      </ul>\n\n      <div class=\"section-title\">Layout Description</div>\n      <p>\n        The page keeps a safe area margin of 24px and a minimum spacing of 16px between interactive controls. A left information panel explains the concept; the right interactive canvas contains controls on top, the deque visual in the middle, and an operation log below.\n      </p>\n      <p style=\"color:var(--muted)\">Accessibility: controls are real buttons and inputs with ARIA annotations, the log uses aria-live to present operation results, and focus styles are provided.</p>\n    </aside>\n\n    <!-- Right interactive canvas -->\n    <main class=\"canvas\" aria-labelledby=\"interactive-title\">\n      <h2 id=\"interactive-title\" style=\"margin:0;font-size:18px\">Interactive Deque Playground</h2>\n\n      <!-- Controls -->\n      <div class=\"controls\" role=\"region\" aria-label=\"Controls\">\n        <div class=\"input-group\" style=\"min-width:220px;\">\n          <input id=\"valueInput\" type=\"text\" placeholder=\"Enter value (text or number)\" aria-label=\"Value to insert\" />\n          <button id=\"makeChip\" title=\"Create a draggable chip from the input\">Create Chip</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"pushFront\" class=\"primary\" aria-label=\"Push to front\">Push Front</button>\n          <button id=\"pushBack\" class=\"primary\" aria-label=\"Push to back\">Push Back</button>\n          <button id=\"popFront\" aria-label=\"Pop from front\">Pop Front</button>\n          <button id=\"popBack\" aria-label=\"Pop from back\">Pop Back</button>\n          <button id=\"peekFront\" aria-label=\"Peek front\">Peek Front</button>\n          <button id=\"peekBack\" aria-label=\"Peek back\">Peek Back</button>\n        </div>\n\n        <div class=\"spacer\"></div>\n\n        <div class=\"small\">\n          <label for=\"capacityRange\">Capacity</label>\n          <input id=\"capacityRange\" type=\"range\" min=\"3\" max=\"12\" value=\"7\" aria-label=\"Set deque capacity\"/>\n          <span id=\"capValue\" style=\"min-width:26px; text-align:center;\">7</span>\n        </div>\n\n        <div class=\"small\" style=\"margin-left:8px;\">\n          <label><input id=\"boundedToggle\" type=\"checkbox\" aria-label=\"Toggle bounded (circular) mode\"/> Bounded (circular)</label>\n        </div>\n\n        <div style=\"min-width:12px\"></div>\n\n        <button id=\"clearBtn\" class=\"danger\" aria-label=\"Clear deque\">Clear</button>\n      </div>\n\n      <!-- Deque Visual -->\n      <section class=\"deque-viewport\" aria-live=\"polite\" aria-atomic=\"false\">\n        <div class=\"small\" id=\"statusLine\" aria-hidden=\"false\">\n          <span>Mode: <strong id=\"modeLabel\">Unbounded</strong></span>\n          <span style=\"margin-left: 16px;\">Length: <strong id=\"lenLabel\">0</strong></span>\n        </div>\n\n        <div id=\"dequeTrack\" class=\"deque-track\" role=\"list\" aria-label=\"Deque visual representation\">\n          <!-- slots / nodes inserted here -->\n        </div>\n\n        <div class=\"index\" id=\"indicesHint\" style=\"color:var(--muted); display:none;\">\n          (Circular view: indices show internal ring-buffer positions; marked slots are head/tail.)\n        </div>\n      </section>\n\n      <!-- Feedback & Log -->\n      <div style=\"display:flex; gap:var(--gap); align-items:flex-start; flex-wrap:wrap;\">\n        <div style=\"flex:1 1 360px;\">\n          <div id=\"feedback\" aria-live=\"polite\"></div>\n        </div>\n\n        <div style=\"flex:1 1 360px;\">\n          <div class=\"log\" id=\"log\" role=\"log\" aria-live=\"polite\" aria-atomic=\"false\">\n            <div style=\"color:var(--muted); margin-bottom:8px;\">Operation log:</div>\n          </div>\n        </div>\n      </div>\n    </main>\n  </div>\n\n  <script>\n    // Deque interactive module (vanilla JS)\n    (function(){\n      // Elements\n      const valueInput = document.getElementById('valueInput');\n      const makeChipBtn = document.getElementById('makeChip');\n      const pushFrontBtn = document.getElementById('pushFront');\n      const pushBackBtn = document.getElementById('pushBack');\n      const popFrontBtn = document.getElementById('popFront');\n      const popBackBtn = document.getElementById('popBack');\n      const peekFrontBtn = document.getElementById('peekFront');\n      const peekBackBtn = document.getElementById('peekBack');\n      const clearBtn = document.getElementById('clearBtn');\n      const dequeTrack = document.getElementById('dequeTrack');\n      const boundedToggle = document.getElementById('boundedToggle');\n      const capacityRange = document.getElementById('capacityRange');\n      const capValue = document.getElementById('capValue');\n      const modeLabel = document.getElementById('modeLabel');\n      const lenLabel = document.getElementById('lenLabel');\n      const feedback = document.getElementById('feedback');\n      const log = document.getElementById('log');\n      const indicesHint = document.getElementById('indicesHint');\n\n      // Internal state\n      let bounded = false;\n      let capacity = parseInt(capacityRange.value,10) || 7;\n      capValue.textContent = capacity;\n      // We maintain two representations:\n      // - unboundedArray: simple JS array used when bounded === false\n      // - ringBuffer: object with buffer array, head index, count used when bounded === true\n      let unboundedArray = [];\n      let ringBuffer = createRing(capacity);\n\n      // Utilities\n      function createRing(cap) {\n        return {\n          buf: new Array(cap).fill(null),\n          cap: cap,\n          head: 0,\n          count: 0\n        };\n      }\n      function logOp(text){\n        const el = document.createElement('div');\n        el.className = 'log-entry';\n        el.textContent = `${new Date().toLocaleTimeString()}: ${text}`;\n        log.appendChild(el);\n        log.scrollTop = log.scrollHeight;\n      }\n      function showFeedback(text, ok=true){\n        feedback.innerHTML = '';\n        const div = document.createElement('div');\n        div.className = 'message ' + (ok ? 'msg-ok' : 'msg-error');\n        div.textContent = text;\n        feedback.appendChild(div);\n        setTimeout(()=> {\n          if (feedback.contains(div)) feedback.removeChild(div);\n        }, 2800);\n      }\n      function updateStatus(){\n        const len = bounded ? ringBuffer.count : unboundedArray.length;\n        lenLabel.textContent = len;\n        modeLabel.textContent = bounded ? `Bounded (cap ${capacity})` : 'Unbounded';\n        indicesHint.style.display = bounded ? 'block' : 'none';\n      }\n\n      // Rendering functions\n      function clearVisual(){\n        dequeTrack.innerHTML = '';\n      }\n\n      function renderUnbounded(){\n        clearVisual();\n        // Show up to 24 to avoid overflow; allow horizontal scroll for more\n        unboundedArray.forEach((v, i) => {\n          const s = makeSlot();\n          const node = makeNode(v);\n          s.appendChild(node);\n          if (i===0) s.classList.add('head');\n          if (i===unboundedArray.length-1) s.classList.add('tail');\n          s.setAttribute('role','listitem');\n          dequeTrack.appendChild(s);\n        });\n      }\n\n      function renderBounded(){\n        clearVisual();\n        const {buf, cap, head, count} = ringBuffer;\n        // Show fixed slots (internal indices)\n        for(let i=0;i<cap;i++){\n          const s = makeSlot();\n          s.classList.add('empty');\n          const indexEl = document.createElement('div');\n          indexEl.className = 'index';\n          indexEl.textContent = `idx ${i}`;\n          s.appendChild(indexEl);\n\n          if (count > 0){\n            if (isOccupied(i)){\n              s.classList.remove('empty');\n              s.classList.add('filled');\n              // get logical value\n              const val = buf[i];\n              const node = makeNode(val);\n              // Put node above the index\n              s.insertBefore(node, indexEl);\n            }\n            if (i === ringBuffer.head) s.classList.add('head');\n            if (i === tailIndex()) s.classList.add('tail');\n          }\n          s.setAttribute('role','listitem');\n          dequeTrack.appendChild(s);\n        }\n        function isOccupied(idx){\n          // distance from head modulo cap < count\n          const dist = (idx - head + cap) % cap;\n          return dist < count;\n        }\n        function tailIndex(){\n          // tail is (head + count -1) % cap\n          return (head + count - 1 + cap) % cap;\n        }\n      }\n\n      function makeSlot(){\n        const s = document.createElement('div');\n        s.className = 'slot empty';\n        s.style.minWidth = '96px';\n        // allow it to be a drop target (for dragging)\n        s.addEventListener('dragover', ev=>ev.preventDefault());\n        s.addEventListener('drop', onDropSlot);\n        return s;\n      }\n      function makeNode(value){\n        const n = document.createElement('div');\n        n.className = 'node';\n        n.textContent = String(value);\n        n.setAttribute('draggable','false');\n        return n;\n      }\n\n      // Operations: unbounded\n      function pushFrontUnbounded(val, animate=true){\n        unboundedArray.unshift(val);\n        logOp(`pushFront(${val})`);\n        showFeedback(`Pushed \"${val}\" to front.`);\n        refreshVisual('front', animate);\n      }\n      function pushBackUnbounded(val, animate=true){\n        unboundedArray.push(val);\n        logOp(`pushBack(${val})`);\n        showFeedback(`Pushed \"${val}\" to back.`);\n        refreshVisual('back', animate);\n      }\n      function popFrontUnbounded(){\n        if (unboundedArray.length===0){\n          showFeedback('Deque is empty — nothing to pop.', false);\n          logOp(`popFront() -> empty`);\n          return null;\n        }\n        const v = unboundedArray.shift();\n        logOp(`popFront() -> ${v}`);\n        showFeedback(`Popped \"${v}\" from front.`);\n        refreshVisual('frontPop', true, v);\n        return v;\n      }\n      function popBackUnbounded(){\n        if (unboundedArray.length===0){\n          showFeedback('Deque is empty — nothing to pop.', false);\n          logOp(`popBack() -> empty`);\n          return null;\n        }\n        const v = unboundedArray.pop();\n        logOp(`popBack() -> ${v}`);\n        showFeedback(`Popped \"${v}\" from back.`);\n        refreshVisual('backPop', true, v);\n        return v;\n      }\n\n      // Operations: bounded (ring buffer)\n      function pushFrontBounded(val){\n        if (ringBuffer.count === ringBuffer.cap){\n          showFeedback('Deque is full — cannot push.', false);\n          logOp(`pushFront(${val}) -> full`);\n          // visual shake\n          flashTrack('danger');\n          return false;\n        }\n        // new head = (head - 1 + cap) % cap\n        ringBuffer.head = (ringBuffer.head - 1 + ringBuffer.cap) % ringBuffer.cap;\n        ringBuffer.buf[ringBuffer.head] = val;\n        ringBuffer.count++;\n        logOp(`pushFront(${val})`);\n        showFeedback(`Pushed \"${val}\" to front.`);\n        refreshVisual('front', true);\n        return true;\n      }\n      function pushBackBounded(val){\n        if (ringBuffer.count === ringBuffer.cap){\n          showFeedback('Deque is full — cannot push.', false);\n          logOp(`pushBack(${val}) -> full`);\n          flashTrack('danger');\n          return false;\n        }\n        const tail = (ringBuffer.head + ringBuffer.count) % ringBuffer.cap;\n        ringBuffer.buf[tail] = val;\n        ringBuffer.count++;\n        logOp(`pushBack(${val})`);\n        showFeedback(`Pushed \"${val}\" to back.`);\n        refreshVisual('back', true);\n        return true;\n      }\n      function popFrontBounded(){\n        if (ringBuffer.count === 0){\n          showFeedback('Deque is empty — nothing to pop.', false);\n          logOp(`popFront() -> empty`);\n          return null;\n        }\n        const v = ringBuffer.buf[ringBuffer.head];\n        ringBuffer.buf[ringBuffer.head] = null;\n        ringBuffer.head = (ringBuffer.head + 1) % ringBuffer.cap;\n        ringBuffer.count--;\n        logOp(`popFront() -> ${v}`);\n        showFeedback(`Popped \"${v}\" from front.`);\n        refreshVisual('frontPop', true, v);\n        return v;\n      }\n      function popBackBounded(){\n        if (ringBuffer.count === 0){\n          showFeedback('Deque is empty — nothing to pop.', false);\n          logOp(`popBack() -> empty`);\n          return null;\n        }\n        const tailIdx = (ringBuffer.head + ringBuffer.count - 1 + ringBuffer.cap) % ringBuffer.cap;\n        const v = ringBuffer.buf[tailIdx];\n        ringBuffer.buf[tailIdx] = null;\n        ringBuffer.count--;\n        logOp(`popBack() -> ${v}`);\n        showFeedback(`Popped \"${v}\" from back.`);\n        refreshVisual('backPop', true, v);\n        return v;\n      }\n\n      // Visual helpers: animate in/out\n      function refreshVisual(action='none', animate=true, poppedValue){\n        updateStatus();\n        if (bounded) renderBounded();\n        else renderUnbounded();\n\n        // Highlight newest/removed node with animation\n        if (!animate) return;\n\n        if (!bounded){\n          // find element nodes\n          const items = Array.from(dequeTrack.querySelectorAll('.slot'));\n          if (action === 'front' && items[0]){\n            const node = items[0].querySelector('.node');\n            if (node) node.classList.add('animate-in-left');\n          } else if (action === 'back' && items.length){\n            const node = items[items.length-1].querySelector('.node');\n            if (node) node.classList.add('animate-in-right');\n          } else if (action === 'frontPop'){\n            // create a floating element showing popped node animates out\n            if (poppedValue !== undefined && poppedValue !== null){\n              animatePop(poppedValue, 'left');\n            }\n          } else if (action === 'backPop'){\n            if (poppedValue !== undefined && poppedValue !== null){\n              animatePop(poppedValue, 'right');\n            }\n          }\n        } else {\n          // bounded visual: animate slot of head or tail index\n          const slots = Array.from(dequeTrack.querySelectorAll('.slot'));\n          if (action==='front'){\n            const idx = ringBuffer.head;\n            const slotEl = slots[idx];\n            if (slotEl){\n              const node = slotEl.querySelector('.node');\n              if (node) node.classList.add('animate-in-left');\n            }\n          } else if (action==='back'){\n            const tailIdx = (ringBuffer.head + ringBuffer.count -1 + ringBuffer.cap) % ringBuffer.cap;\n            const slotEl = slots[tailIdx];\n            if (slotEl){\n              const node = slotEl.querySelector('.node');\n              if (node) node.classList.add('animate-in-right');\n            }\n          } else if (action==='frontPop'){\n            if (poppedValue !== undefined && poppedValue !== null) animatePop(poppedValue, 'left');\n          } else if (action==='backPop'){\n            if (poppedValue !== undefined && poppedValue !== null) animatePop(poppedValue, 'right');\n          }\n        }\n      }\n\n      function animatePop(value, dir){\n        // create floating node overlay near start of track\n        const float = document.createElement('div');\n        float.className = 'node';\n        float.textContent = String(value);\n        float.style.position = 'absolute';\n        float.style.zIndex = 999;\n        float.style.opacity = '1';\n        // position roughly center-top of dequeTrack\n        const rect = dequeTrack.getBoundingClientRect();\n        float.style.left = (rect.left + (dir==='left' ? 20 : rect.width - 120)) + 'px';\n        float.style.top = (rect.top + 12) + 'px';\n        float.style.transition = 'transform .6s ease, opacity .6s ease';\n        document.body.appendChild(float);\n        requestAnimationFrame(()=>{\n          float.style.transform = `translateX(${dir==='left' ? -80 : 80}px) translateY(-20px)`;\n          float.style.opacity = '0';\n        });\n        setTimeout(()=> float.remove(), 650);\n      }\n\n      function flashTrack(kind){\n        dequeTrack.style.transition = 'box-shadow .18s ease, transform .12s ease';\n        dequeTrack.style.transform = 'translateY(-3px)';\n        dequeTrack.style.boxShadow = kind === 'danger' ? '0 6px 18px rgba(239,68,68,0.14)' : '0 6px 18px rgba(16,185,129,0.12)';\n        setTimeout(()=>{\n          dequeTrack.style.transform = '';\n          dequeTrack.style.boxShadow = '';\n        }, 260);\n      }\n\n      // Event handlers for UI controls\n      pushFrontBtn.addEventListener('click', ()=>{\n        const val = valueInput.value.trim();\n        if (val === ''){\n          showFeedback('Enter a value first.', false);\n          return;\n        }\n        if (bounded) pushFrontBounded(val);\n        else pushFrontUnbounded(val);\n        valueInput.value = '';\n      });\n      pushBackBtn.addEventListener('click', ()=>{\n        const val = valueInput.value.trim();\n        if (val === ''){\n          showFeedback('Enter a value first.', false);\n          return;\n        }\n        if (bounded) pushBackBounded(val);\n        else pushBackUnbounded(val);\n        valueInput.value = '';\n      });\n      popFrontBtn.addEventListener('click', ()=> {\n        if (bounded) popFrontBounded();\n        else popFrontUnbounded();\n      });\n      popBackBtn.addEventListener('click', ()=> {\n        if (bounded) popBackBounded();\n        else popBackUnbounded();\n      });\n      peekFrontBtn.addEventListener('click', ()=>{\n        let v = null;\n        if (bounded) {\n          if (ringBuffer.count === 0) { showFeedback('Deque empty.'); logOp('peekFront -> empty'); return; }\n          v = ringBuffer.buf[ringBuffer.head];\n        } else {\n          if (unboundedArray.length === 0){ showFeedback('Deque empty.'); logOp('peekFront -> empty'); return; }\n          v = unboundedArray[0];\n        }\n        showFeedback(`Front: \"${v}\"`);\n        logOp(`peekFront -> ${v}`);\n      });\n      peekBackBtn.addEventListener('click', ()=>{\n        let v = null;\n        if (bounded){\n          if (ringBuffer.count === 0){ showFeedback('Deque empty.'); logOp('peekBack -> empty'); return; }\n          const tailIdx = (ringBuffer.head + ringBuffer.count - 1 + ringBuffer.cap) % ringBuffer.cap;\n          v = ringBuffer.buf[tailIdx];\n        } else {\n          if (unboundedArray.length === 0){ showFeedback('Deque empty.'); logOp('peekBack -> empty'); return; }\n          v = unboundedArray[unboundedArray.length - 1];\n        }\n        showFeedback(`Back: \"${v}\"`);\n        logOp(`peekBack -> ${v}`);\n      });\n\n      clearBtn.addEventListener('click', ()=>{\n        unboundedArray = [];\n        ringBuffer = createRing(capacity);\n        showFeedback('Deque cleared.');\n        logOp('clear()');\n        refreshVisual('none', false);\n      });\n\n      boundedToggle.addEventListener('change', (e)=>{\n        bounded = e.target.checked;\n        // if switching to bounded and current unbounded length > capacity, trim from back\n        if (bounded){\n          if (unboundedArray.length > capacity){\n            // trim oldest elements from back to fit\n            const removed = unboundedArray.splice(capacity);\n            logOp(`Switch to bounded: trimmed ${removed.length} items`);\n            showFeedback(`Switched to bounded; trimmed ${removed.length} items from back to fit capacity.`, true);\n          }\n          // populate ringBuffer from unboundedArray\n          ringBuffer = createRing(capacity);\n          unboundedArray.forEach(v => {\n            // pushBackBounded won't animate here; use direct insertion\n            const tail = (ringBuffer.head + ringBuffer.count) % ringBuffer.cap;\n            ringBuffer.buf[tail] = v;\n            ringBuffer.count++;\n          });\n          unboundedArray = [];\n        } else {\n          // convert ringBuffer contents into unboundedArray in logical order\n          const arr = [];\n          for (let i=0;i<ringBuffer.count;i++){\n            const idx = (ringBuffer.head + i) % ringBuffer.cap;\n            arr.push(ringBuffer.buf[idx]);\n          }\n          unboundedArray = arr;\n          ringBuffer = createRing(capacity);\n        }\n        refreshVisual('none', false);\n      });\n\n      capacityRange.addEventListener('input', (e)=>{\n        capacity = parseInt(e.target.value,10);\n        capValue.textContent = capacity;\n      });\n      capacityRange.addEventListener('change', (e)=>{\n        const newCap = parseInt(e.target.value,10);\n        // If bounded, change ring buffer capacity (attempt to preserve contents)\n        if (bounded){\n          // extract current logical items\n          const items = [];\n          for(let i=0;i<ringBuffer.count;i++){\n            const idx = (ringBuffer.head + i) % ringBuffer.cap;\n            items.push(ringBuffer.buf[idx]);\n          }\n          // if new cap < items.length, trim from back\n          if (newCap < items.length){\n            const removed = items.splice(newCap);\n            logOp(`Resized capacity to ${newCap}; removed ${removed.length} items`);\n            showFeedback(`Capacity reduced: removed ${removed.length} items from back.`, true);\n          }\n          // create new ring and put items\n          ringBuffer = createRing(newCap);\n          items.forEach(v=>{\n            const tail = (ringBuffer.head + ringBuffer.count) % ringBuffer.cap;\n            ringBuffer.buf[tail] = v;\n            ringBuffer.count++;\n          });\n        } else {\n          // unbounded: no immediate change needed, but update capacity var\n          // if current length > newCap, we keep the unbounded array as-is but warn when switching to bounded\n          if (unboundedArray.length > newCap){\n            showFeedback(`Note: current length (${unboundedArray.length}) exceeds new capacity (${newCap}). Switching to bounded will trim.`, true);\n            logOp(`setCapacity(${newCap}) (unbounded; current length > capacity)`);\n          } else {\n            logOp(`setCapacity(${newCap})`);\n          }\n        }\n        capacity = newCap;\n        capValue.textContent = capacity;\n        updateStatus();\n        refreshVisual('none', false);\n      });\n\n      // Drag & Drop: create a draggable chip from input\n      makeChipBtn.addEventListener('click', ()=>{\n        const text = valueInput.value.trim();\n        if (!text){\n          showFeedback('Enter a value first to make a chip.', false);\n          return;\n        }\n        createChip(text);\n        valueInput.value = '';\n        showFeedback('Draggable chip created. Drag it onto the deque to insert from that side.');\n      });\n\n      function createChip(text){\n        // create a floating chip appended to control area\n        const chip = document.createElement('div');\n        chip.className = 'chip';\n        chip.setAttribute('draggable','true');\n        chip.setAttribute('role','button');\n        chip.setAttribute('aria-label','Draggable chip: ' + text);\n        const valSpan = document.createElement('span');\n        valSpan.className = 'value';\n        valSpan.textContent = text;\n        chip.appendChild(valSpan);\n        chip.addEventListener('dragstart', ev=>{\n          ev.dataTransfer.setData('text/plain', text);\n          // set drag image (fallback: use the chip itself)\n          if (ev.dataTransfer.setDragImage){\n            // create small canvas-like element to use as drag image\n            const crt = chip.cloneNode(true);\n            crt.style.position='absolute';\n            crt.style.top='-9999px';\n            document.body.appendChild(crt);\n            ev.dataTransfer.setDragImage(crt, 10, 10);\n            setTimeout(()=> document.body.removeChild(crt), 0);\n          }\n        });\n        chip.addEventListener('click', ()=>{\n          // quick shortcut: push back by click\n          if (bounded) pushBackBounded(text);\n          else pushBackUnbounded(text);\n          chip.remove();\n        });\n        // add a small \"remove\" on right-click\n        chip.addEventListener('contextmenu', ev=>{\n          ev.preventDefault();\n          chip.remove();\n        });\n        // append to controls area\n        makeChipBtn.parentElement.appendChild(chip);\n      }\n\n      // Deque drop behavior: if dropped on leftmost slot area, push front; if on rightmost, push back; else push to nearest\n      function onDropSlot(ev){\n        ev.preventDefault();\n        const val = ev.dataTransfer.getData('text/plain') || ev.target.textContent || '';\n        if (!val) return;\n        // Determine side by comparing drop position to slot center\n        const slotRect = ev.currentTarget.getBoundingClientRect();\n        const dropX = ev.clientX;\n        const isLeft = dropX < (slotRect.left + slotRect.width/2);\n        if (isLeft){\n          if (bounded) pushFrontBounded(val);\n          else pushFrontUnbounded(val);\n        } else {\n          if (bounded) pushBackBounded(val);\n          else pushBackUnbounded(val);\n        }\n        // If the dragged element exists in DOM and is a chip, remove it\n        // Many browsers don't include reference to the dragged element. Try to delete any chip with matching text near.\n        const chips = Array.from(document.querySelectorAll('.chip .value')).filter(n=>n.textContent===val);\n        if (chips.length) chips[0].closest('.chip').remove();\n      }\n\n      // accessibility: keyboard shortcuts\n      // Enter in input -> pushBack\n      valueInput.addEventListener('keydown', (e)=>{\n        if (e.key === 'Enter'){\n          if (bounded) pushBackBounded(valueInput.value.trim());\n          else pushBackUnbounded(valueInput.value.trim());\n          valueInput.value = '';\n        }\n      });\n\n      // initial render\n      updateStatus();\n      refreshVisual('none', false);\n\n      // Expose nothing to window (module encapsulated)\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Deque.\n\n**Project Overview:**\nTopic: Deque\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Deque"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Deque Interactive Module",
      "description": "Models the interactive states and transitions of a double-ended queue playground (push/pop front/back, bounded/unbounded modes, drag-and-drop chip creation, capacity changes, visual animations and feedback).",
      "states": [
        {
          "name": "unbounded",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "CLICK_PUSH_FRONT": "inserting_front_unbounded",
            "CLICK_PUSH_BACK": "inserting_back_unbounded",
            "CLICK_POP_FRONT": "popping_front_unbounded",
            "CLICK_POP_BACK": "popping_back_unbounded",
            "CLICK_PEEK_FRONT": "peeking_front_unbounded",
            "CLICK_PEEK_BACK": "peeking_back_unbounded",
            "CREATE_CHIP_CLICK": "creating_chip_unbounded",
            "DRAG_START": "dragging_unbounded",
            "INPUT_ENTER": "inserting_back_unbounded",
            "CAPACITY_INPUT": "resizing_unbounded",
            "CAPACITY_CHANGE": "resizing_unbounded",
            "CLEAR": "clearing_unbounded",
            "TOGGLE_BOUNDED_ON": "switching_to_bounded"
          }
        },
        {
          "name": "bounded",
          "onEnter": "setBoundedTrue",
          "onExit": "noop",
          "on": {
            "CLICK_PUSH_FRONT": "inserting_front_bounded",
            "CLICK_PUSH_BACK": "inserting_back_bounded",
            "CLICK_POP_FRONT": "popping_front_bounded",
            "CLICK_POP_BACK": "popping_back_bounded",
            "CLICK_PEEK_FRONT": "peeking_front_bounded",
            "CLICK_PEEK_BACK": "peeking_back_bounded",
            "CREATE_CHIP_CLICK": "creating_chip_bounded",
            "DRAG_START": "dragging_bounded",
            "INPUT_ENTER": "inserting_back_bounded",
            "CAPACITY_INPUT": "resizing_bounded",
            "CAPACITY_CHANGE": "resizing_bounded",
            "CLEAR": "clearing_bounded",
            "TOGGLE_BOUNDED_OFF": "switching_to_unbounded"
          }
        },
        {
          "name": "inserting_front_unbounded",
          "onEnter": "pushFrontUnbounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "unbounded"
          }
        },
        {
          "name": "inserting_back_unbounded",
          "onEnter": "pushBackUnbounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "unbounded"
          }
        },
        {
          "name": "popping_front_unbounded",
          "onEnter": "popFrontUnbounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "unbounded",
            "OP_EMPTY": "error_empty_unbounded"
          }
        },
        {
          "name": "popping_back_unbounded",
          "onEnter": "popBackUnbounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "unbounded",
            "OP_EMPTY": "error_empty_unbounded"
          }
        },
        {
          "name": "peeking_front_unbounded",
          "onEnter": "peekFrontUnbounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "unbounded",
            "OP_EMPTY": "error_empty_unbounded"
          }
        },
        {
          "name": "peeking_back_unbounded",
          "onEnter": "peekBackUnbounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "unbounded",
            "OP_EMPTY": "error_empty_unbounded"
          }
        },
        {
          "name": "inserting_front_bounded",
          "onEnter": "pushFrontBounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "bounded",
            "OP_ERROR": "error_full_bounded"
          }
        },
        {
          "name": "inserting_back_bounded",
          "onEnter": "pushBackBounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "bounded",
            "OP_ERROR": "error_full_bounded"
          }
        },
        {
          "name": "popping_front_bounded",
          "onEnter": "popFrontBounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "bounded",
            "OP_EMPTY": "error_empty_bounded"
          }
        },
        {
          "name": "popping_back_bounded",
          "onEnter": "popBackBounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "bounded",
            "OP_EMPTY": "error_empty_bounded"
          }
        },
        {
          "name": "peeking_front_bounded",
          "onEnter": "peekFrontBounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "bounded",
            "OP_EMPTY": "error_empty_bounded"
          }
        },
        {
          "name": "peeking_back_bounded",
          "onEnter": "peekBackBounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "bounded",
            "OP_EMPTY": "error_empty_bounded"
          }
        },
        {
          "name": "creating_chip_unbounded",
          "onEnter": "createChipFromInput",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "unbounded"
          }
        },
        {
          "name": "creating_chip_bounded",
          "onEnter": "createChipFromInput",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "bounded"
          }
        },
        {
          "name": "dragging_unbounded",
          "onEnter": "startDrag",
          "onExit": "endDragCleanup",
          "on": {
            "DROP_ON_SLOT_LEFT": "inserting_front_unbounded",
            "DROP_ON_SLOT_RIGHT": "inserting_back_unbounded",
            "DROP_ON_SLOT_NEAR": "inserting_back_unbounded",
            "DRAG_CANCEL": "unbounded"
          }
        },
        {
          "name": "dragging_bounded",
          "onEnter": "startDrag",
          "onExit": "endDragCleanup",
          "on": {
            "DROP_ON_SLOT_LEFT": "inserting_front_bounded",
            "DROP_ON_SLOT_RIGHT": "inserting_back_bounded",
            "DROP_ON_SLOT_NEAR": "inserting_back_bounded",
            "DRAG_CANCEL": "bounded"
          }
        },
        {
          "name": "clearing_unbounded",
          "onEnter": "clearDeque",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "unbounded"
          }
        },
        {
          "name": "clearing_bounded",
          "onEnter": "clearDeque",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "bounded"
          }
        },
        {
          "name": "resizing_unbounded",
          "onEnter": "applyCapacityChangeUnbounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "unbounded"
          }
        },
        {
          "name": "resizing_bounded",
          "onEnter": "applyCapacityChangeBounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "bounded",
            "OP_TRIMMED": "bounded"
          }
        },
        {
          "name": "switching_to_bounded",
          "onEnter": "convertUnboundedToBounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "bounded",
            "OP_TRIMMED": "bounded"
          }
        },
        {
          "name": "switching_to_unbounded",
          "onEnter": "convertBoundedToUnbounded",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "unbounded"
          }
        },
        {
          "name": "error_full_bounded",
          "onEnter": "showFullFeedback",
          "onExit": "noop",
          "on": {
            "ERROR_TIMEOUT": "bounded",
            "CLICK_CLEAR": "clearing_bounded"
          }
        },
        {
          "name": "error_empty_unbounded",
          "onEnter": "showEmptyFeedback",
          "onExit": "noop",
          "on": {
            "ERROR_TIMEOUT": "unbounded"
          }
        },
        {
          "name": "error_empty_bounded",
          "onEnter": "showEmptyFeedback",
          "onExit": "noop",
          "on": {
            "ERROR_TIMEOUT": "bounded"
          }
        }
      ],
      "events": [
        "CLICK_PUSH_FRONT",
        "CLICK_PUSH_BACK",
        "CLICK_POP_FRONT",
        "CLICK_POP_BACK",
        "CLICK_PEEK_FRONT",
        "CLICK_PEEK_BACK",
        "CREATE_CHIP_CLICK",
        "DRAG_START",
        "DROP_ON_SLOT_LEFT",
        "DROP_ON_SLOT_RIGHT",
        "DROP_ON_SLOT_NEAR",
        "DRAG_CANCEL",
        "CHIP_CLICK_PUSHBACK",
        "CHIP_REMOVE",
        "INPUT_ENTER",
        "CAPACITY_INPUT",
        "CAPACITY_CHANGE",
        "CLEAR",
        "TOGGLE_BOUNDED_ON",
        "TOGGLE_BOUNDED_OFF",
        "OP_COMPLETE",
        "OP_ERROR",
        "OP_EMPTY",
        "OP_TRIMMED",
        "ERROR_TIMEOUT"
      ],
      "notes": "This FSM models two modes (bounded vs unbounded) and duplicates action states per mode to reflect differing operations (ring buffer checks, trimming on capacity change). onEnter actions correspond to the functions in the implementation (e.g., pushFrontUnbounded, pushFrontBounded, popFrontBounded, createChipFromInput, convertUnboundedToBounded, applyCapacityChangeBounded). Error states represent visual/feedback responses (full/empty). Transitions use OP_* events to represent synchronous operation results (success, empty, full/ error, trimmed). Drag-and-drop is represented by dragging_* states and DROP_* events. Clearing and resizing are modeled as operations with completion events."
    }
  },
  {
    "id": "c794b650-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:47:05.781Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Bubble Sort",
    "answer": {
      "role": "assistant",
      "content": "Concept Title:\nBubble Sort — Visual step-by-step comparison and swap\n\nLearning Objective:\nAfter interacting with this module, users will be able to:\n- Understand the pairwise comparison and swap mechanics that make Bubble Sort work.\n- See how elements \"bubble\" to their correct position over repeated passes.\n- Correlate the algorithm's pseudocode with the visual state transitions (comparison, swap, pass completion).\n- Control and observe the algorithm at their own pace (step-by-step, rewind, or autoplay).\n\nInteraction Design:\n- Primary interactions:\n  - Slider: choose array size (2–20). Changing size resets the array.\n  - \"Randomize\" button: fills the array with random integers and positions the bars.\n  - Text input: type a comma-separated list of integers to use a custom array (Enter to apply).\n  - \"Step\" button (or Right-Arrow key): perform one comparison (and swap if needed). Each step highlights the two compared bars; if a swap is required, they animate to their new positions.\n  - \"Back\" button (or Left-Arrow key): step back one algorithm state (maintains a history stack).\n  - \"Play/Pause\" toggle (or Space key): automatically step through the algorithm at a user-controlled speed.\n  - Speed slider: adjust autoplay speed (milliseconds per step).\n  - \"Reset\" button: restore to initial array and algorithm start.\n- Visual feedback and animation:\n  - Bars represent array elements (height proportional to value) and show numeric value.\n  - When comparing, the two bars pulse / change color (yellow).\n  - When swapping, bars smoothly animate their horizontal positions (translateX) to swapped places and briefly highlight (orange).\n  - Already-sorted (finalized) right-side bars are marked in green as passes complete.\n  - Pseudocode shown to the side with the currently-executing line highlighted; line updates with each step to reinforce mapping from code to visual actions.\n  - A small status area shows current pass (i), comparison index (j), total comparisons, and swaps count.\n- Reinforcement:\n  - Users can slow down to inspect each comparison, step back if confused, or run continuously to see emergent behavior.\n  - The pseudocode highlight and stats make it explicit why Bubble Sort requires multiple passes and where time is spent.\n\nLayout Description:\n- Safe area: The page uses 24px padding on all sides (body padding: 24px).\n- Overall layout: A responsive two-column layout (stacked into one column on narrow screens).\n  - Left (primary visual): Array visualization at the top and large, clear. Bars are centered inside a fixed-height container with responsive width. Controls for direct element interaction (if focused) exist but the main interactions are the right-side controls.\n  - Right (controls & explanation): Algorithm controls (sliders, buttons), pseudocode block with current-line highlight, and small statistics/status below.\n- Spacing and composition:\n  - Minimum spacing of 16px between interactive elements (buttons, sliders, inputs). CSS gap and margins enforce this spacing.\n  - Visual focus: The array container takes the most horizontal space and vertical space to keep attention on the animation. Controls are grouped logically with clear headings and consistent spacing.\n- Accessibility and responsiveness:\n  - All controls are keyboard-accessible and have ARIA labels. There are keyboard shortcuts: Space (play/pause), Right Arrow (step), Left Arrow (back).\n  - Color choices use distinct hues and also employ patterns (borders/opacity) for those with color vision issues. Focus outlines are visible.\n  - The layout collapses to a vertical stack on small viewports; controls remain touch-friendly with adequate sizes.\n\n\nImplementation (self-contained HTML/CSS/JS)\n- Paste the following single-file HTML into a browser. It implements everything above using only vanilla HTML, CSS and JavaScript.\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Bubble Sort Interactive Module</title>\n  <style>\n    :root{\n      --safe-padding: 24px;\n      --gap: 16px;\n      --control-height: 40px;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --text: #e6eef8;\n      --muted: #9fb0c8;\n      --accent: #60a5fa;\n      --compare: #f6d365;\n      --swap: #fb923c;\n      --done: #34d399;\n      --danger: #ef4444;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071025 0%, #071827 100%);\n      color:var(--text);\n      font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n    body{\n      padding:var(--safe-padding);\n      box-sizing:border-box;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      display:flex;\n      align-items:flex-start;\n      justify-content:center;\n      gap:var(--gap);\n    }\n\n    /* Container */\n    .module {\n      width:100%;\n      max-width:1100px;\n      display:grid;\n      grid-template-columns: 1fr 380px;\n      gap:var(--gap);\n    }\n\n    /* Responsive stack */\n    @media (max-width:920px){\n      .module{\n        grid-template-columns:1fr;\n      }\n    }\n\n    .card{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.04);\n      border-radius:12px;\n      padding:18px;\n      box-shadow: 0 6px 24px rgba(2,6,23,0.6);\n    }\n\n    header h1{\n      margin:0 0 8px 0;\n      font-size:20px;\n      letter-spacing:0.2px;\n    }\n    header p {\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* Visual area */\n    .visual {\n      min-height:340px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    .array-area {\n      background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.006));\n      border-radius:10px;\n      padding:14px;\n      position:relative;\n      height:240px;\n      overflow:hidden;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n    }\n\n    /* bars container: relative positioning for children */\n    .bars {\n      position:relative;\n      height:100%;\n      width:100%;\n      max-width:100%;\n      margin:0 6px;\n      min-height:120px;\n    }\n\n    .bar {\n      position:absolute;\n      bottom:12px;\n      width:48px;\n      max-width:16%;\n      background:linear-gradient(180deg,#1e293b,#0f1724);\n      color:var(--text);\n      border-radius:8px;\n      display:flex;\n      align-items:flex-end;\n      justify-content:center;\n      box-shadow: 0 4px 10px rgba(2,6,23,0.6);\n      transition: transform 360ms cubic-bezier(.2,.9,.2,1), background-color 220ms, box-shadow 220ms;\n      padding:6px;\n      box-sizing:border-box;\n      border:1px solid rgba(255,255,255,0.03);\n      text-align:center;\n      font-weight:600;\n      outline: none;\n    }\n    .bar .val {\n      transform: translateY(6px);\n      font-size:13px;\n      color:var(--text);\n      text-shadow: 0 1px 0 rgba(0,0,0,0.6);\n    }\n    .bar.compare {\n      background: linear-gradient(180deg, rgba(255,215,120,0.12), rgba(255,200,80,0.06));\n      box-shadow: 0 6px 18px rgba(250,200,60,0.06), 0 0 0 3px rgba(246,211,101,0.06);\n    }\n    .bar.swap {\n      background: linear-gradient(180deg, rgba(251,146,60,0.12), rgba(251,146,60,0.06));\n      box-shadow: 0 6px 18px rgba(251,146,60,0.06), 0 0 0 3px rgba(251,146,60,0.04);\n    }\n    .bar.done {\n      background: linear-gradient(180deg, rgba(52,211,153,0.08), rgba(52,211,153,0.04));\n      box-shadow: 0 6px 18px rgba(52,211,153,0.06);\n      color:#042c1e;\n      font-weight:700;\n    }\n\n    /* Controls and pseudocode panel */\n    .controls {\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    .controls .group {\n      display:flex;\n      flex-direction:column;\n      gap:10px;\n    }\n    .row {\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    label {\n      font-size:13px;\n      color:var(--muted);\n    }\n    input[type=\"range\"]{\n      width:100%;\n    }\n    input[type=\"text\"]{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.05);\n      color:var(--text);\n      padding:10px;\n      border-radius:8px;\n      min-width:0;\n    }\n    .btn {\n      height:var(--control-height);\n      padding:0 12px;\n      background:rgba(255,255,255,0.03);\n      color:var(--text);\n      border:1px solid rgba(255,255,255,0.04);\n      border-radius:8px;\n      cursor:pointer;\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n      font-weight:600;\n      transition: background 180ms, transform 120ms;\n      min-width:78px;\n    }\n    .btn:active{ transform:translateY(1px); }\n    .btn.primary {\n      background: linear-gradient(90deg,var(--accent), #3b82f6);\n      border: none;\n      color:white;\n      box-shadow: 0 6px 18px rgba(59,130,246,0.12);\n    }\n    .btn.ghost {\n      background:transparent;\n      border:1px dashed rgba(255,255,255,0.04);\n    }\n    .small {\n      font-size:13px;\n      padding:8px 10px;\n      height:34px;\n    }\n\n    /* Pseudocode */\n    pre.pseudo {\n      background: linear-gradient(180deg, rgba(0,0,0,0.25), rgba(0,0,0,0.12));\n      border-radius:8px;\n      padding:12px;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;\n      font-size:13px;\n      color:var(--muted);\n      overflow:auto;\n      max-height:200px;\n    }\n    pre.pseudo code {\n      white-space:pre;\n      display:block;\n    }\n    .line {\n      padding:2px 6px;\n      border-radius:6px;\n      display:block;\n    }\n    .line.current {\n      background: rgba(96,165,250,0.12);\n      color:var(--text);\n      box-shadow: inset 0 0 0 1px rgba(96,165,250,0.06);\n    }\n\n    /* stats */\n    .stats {\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .stat {\n      background: rgba(255,255,255,0.02);\n      padding:8px 10px;\n      border-radius:8px;\n      min-width:88px;\n      text-align:center;\n    }\n\n    /* Footer hint */\n    .hint {\n      font-size:12px;\n      color:var(--muted);\n    }\n\n    /* Focus */\n    .bar:focus {\n      outline: 2px solid rgba(96,165,250,0.26);\n      outline-offset:4px;\n    }\n    .btn:focus, input:focus, textarea:focus {\n      outline: 2px solid rgba(96,165,250,0.14);\n      outline-offset:2px;\n    }\n  </style>\n</head>\n<body>\n  <main class=\"module\" aria-labelledby=\"title\">\n    <section class=\"card visual\" aria-label=\"Bubble sort visualization\">\n      <header>\n        <h1 id=\"title\">Bubble Sort — Compare & Swap Visualization</h1>\n        <p>Step through pairwise comparisons. Swapping animates; passes mark sorted items on the right.</p>\n      </header>\n\n      <div class=\"array-area\" role=\"region\" aria-label=\"Array visualization\">\n        <div class=\"bars\" id=\"bars\" aria-live=\"polite\"></div>\n      </div>\n\n      <div style=\"display:flex;justify-content:space-between;align-items:center;gap:16px\">\n        <div class=\"hint\">Keyboard: Space = Play/Pause • → = Step • ← = Back</div>\n        <div class=\"stats\" aria-hidden=\"false\" id=\"stats\">\n          <div class=\"stat\" id=\"stat-pass\">Pass: 0</div>\n          <div class=\"stat\" id=\"stat-idx\">Compare j: 0</div>\n          <div class=\"stat\" id=\"stat-comp\">Comparisons: 0</div>\n          <div class=\"stat\" id=\"stat-swaps\">Swaps: 0</div>\n        </div>\n      </div>\n    </section>\n\n    <aside class=\"card controls\" aria-label=\"Controls and pseudocode\">\n      <div class=\"group\">\n        <div class=\"row\" style=\"align-items:center;\">\n          <label for=\"size\">Array size</label>\n          <input id=\"size\" type=\"range\" min=\"2\" max=\"20\" value=\"8\" aria-label=\"Array size slider\">\n          <div style=\"min-width:48px;text-align:right;color:var(--muted)\" id=\"sizeVal\">8</div>\n        </div>\n\n        <div class=\"row\">\n          <button class=\"btn\" id=\"randomBtn\" aria-label=\"Randomize array\">Randomize</button>\n          <button class=\"btn ghost\" id=\"shuffleBtn\" aria-label=\"Shuffle array\">Shuffle</button>\n          <button class=\"btn\" id=\"resetBtn\" aria-label=\"Reset array\">Reset</button>\n        </div>\n\n        <div class=\"row\" style=\"flex-direction:column;gap:8px\">\n          <label for=\"arrInput\">Custom array (comma-separated)</label>\n          <input id=\"arrInput\" type=\"text\" placeholder=\"e.g. 5,1,4,2\" aria-label=\"Array input\">\n        </div>\n\n        <div class=\"row\" style=\"justify-content:flex-start;\">\n          <button class=\"btn primary\" id=\"playBtn\" aria-pressed=\"false\">Play</button>\n          <button class=\"btn\" id=\"stepBtn\">Step</button>\n          <button class=\"btn\" id=\"backBtn\">Back</button>\n          <button class=\"btn ghost\" id=\"fastFinishBtn\" title=\"Finish algorithm quickly\">Finish</button>\n        </div>\n\n        <div class=\"row\" style=\"align-items:center;\">\n          <label for=\"speed\">Speed</label>\n          <input id=\"speed\" type=\"range\" min=\"60\" max=\"1200\" step=\"10\" value=\"420\" aria-label=\"Animation speed\">\n          <div style=\"min-width:56px;text-align:right;color:var(--muted)\" id=\"speedVal\">420ms</div>\n        </div>\n      </div>\n\n      <div class=\"group\">\n        <label>Pseudocode (highlights current step)</label>\n        <pre class=\"pseudo\" id=\"pseudocode\" tabindex=\"0\" aria-label=\"Bubble sort pseudocode\">\n<code>\n<span class=\"line\" data-line=\"1\">for i from 0 to n-1:</span>\n<span class=\"line\" data-line=\"2\">  for j from 0 to n-2-i:</span>\n<span class=\"line\" data-line=\"3\">    if arr[j] &gt; arr[j+1]:</span>\n<span class=\"line\" data-line=\"4\">      swap arr[j] and arr[j+1]</span>\n</code>\n        </pre>\n      </div>\n\n      <div class=\"group\" style=\"margin-top:auto\">\n        <div style=\"display:flex;gap:12px;align-items:center;justify-content:space-between;\">\n          <div style=\"color:var(--muted);font-size:13px\">Status</div>\n          <div style=\"display:flex;gap:8px;\">\n            <div style=\"color:var(--muted);font-size:13px\" id=\"statusText\">Idle</div>\n          </div>\n        </div>\n      </div>\n    </aside>\n  </main>\n\n  <script>\n    // Safe constants & helpers\n    const MIN_BAR_WIDTH = 36; // px\n    const GAP = 12; // px gap between bars visually\n    const barsEl = document.getElementById('bars');\n    const sizeRange = document.getElementById('size');\n    const sizeVal = document.getElementById('sizeVal');\n    const randomBtn = document.getElementById('randomBtn');\n    const shuffleBtn = document.getElementById('shuffleBtn');\n    const resetBtn = document.getElementById('resetBtn');\n    const arrInput = document.getElementById('arrInput');\n    const playBtn = document.getElementById('playBtn');\n    const stepBtn = document.getElementById('stepBtn');\n    const backBtn = document.getElementById('backBtn');\n    const speedRange = document.getElementById('speed');\n    const speedVal = document.getElementById('speedVal');\n    const fastFinishBtn = document.getElementById('fastFinishBtn');\n\n    const statPass = document.getElementById('stat-pass');\n    const statIdx = document.getElementById('stat-idx');\n    const statComp = document.getElementById('stat-comp');\n    const statSwaps = document.getElementById('stat-swaps');\n    const statusText = document.getElementById('statusText');\n\n    const pseudocode = document.getElementById('pseudocode');\n    const codeLines = Array.from(pseudocode.querySelectorAll('.line'));\n\n    let array = [];\n    let initialArray = [];\n    let positions = []; // computed left positions for each index\n    let nodeOrder = []; // mapping of logical index -> DOM element\n    let history = []; // snapshots for back: {array, i, j, swaps, comps, currentLine}\n    let i = 0, j = 0; // bubble variables\n    let comparisons = 0, swaps = 0;\n    let playing = false;\n    let timer = null;\n\n    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }\n\n    function makeRandomArray(n){\n      const arr = [];\n      for(let k=0;k<n;k++){\n        arr.push(Math.floor(Math.random()*90)+10);\n      }\n      return arr;\n    }\n\n    function init(){\n      sizeVal.textContent = sizeRange.value;\n      speedVal.textContent = speedRange.value + 'ms';\n      array = makeRandomArray(parseInt(sizeRange.value,10));\n      initialArray = array.slice();\n      resetAlgorithmState();\n      renderBars();\n      updateStats();\n      highlightPseudocode(1);\n    }\n\n    function resetAlgorithmState(){\n      i = 0; j = 0;\n      comparisons = 0; swaps = 0;\n      history = [];\n      stop();\n    }\n\n    function renderBars(){\n      barsEl.innerHTML = '';\n      nodeOrder = [];\n      const n = array.length;\n      // compute element width based on container size\n      const rect = barsEl.getBoundingClientRect();\n      const containerWidth = Math.max(200, rect.width || 600);\n      const totalGap = Math.max(0, (n-1) * GAP);\n      let barWidth = Math.max(MIN_BAR_WIDTH, Math.floor((containerWidth - totalGap) / n));\n      // limit width to avoid overflow\n      barWidth = Math.min(barWidth, Math.floor((containerWidth - totalGap) / Math.max(1,n)));\n      // compute x positions\n      positions = [];\n      let left = 0;\n      for(let idx=0; idx<n; idx++){\n        positions.push(left);\n        left += barWidth + GAP;\n      }\n\n      // create DOM bars\n      for(let idx=0; idx<n; idx++){\n        const val = array[idx];\n        const el = document.createElement('button');\n        el.className = 'bar';\n        el.setAttribute('data-index', idx);\n        el.setAttribute('aria-label', 'Value ' + val + ' at position ' + idx);\n        el.setAttribute('title', String(val));\n        el.style.width = barWidth + 'px';\n        const maxVal = Math.max(...array);\n        const minVal = Math.min(...array);\n        // compute height proportion\n        const hMin = 36; const hMax = barsEl.clientHeight - 36;\n        const height = hMin + ( (val - minVal) / Math.max(1, (maxVal - minVal)) ) * (hMax - hMin);\n        el.style.height = Math.max(44, height) + 'px';\n        // content\n        const span = document.createElement('div');\n        span.className = 'val';\n        span.textContent = val;\n        el.appendChild(span);\n\n        // position initially\n        el.style.transform = `translateX(${positions[idx]}px)`;\n        el.style.transition = 'transform 360ms cubic-bezier(.2,.9,.2,1)';\n        barsEl.appendChild(el);\n        nodeOrder.push(el);\n      }\n\n      // mark any done elements if appropriate\n      markDoneElements();\n    }\n\n    function markDoneElements(){\n      const n = array.length;\n      for(let idx=0; idx<n; idx++){\n        const el = nodeOrder[idx];\n        el.classList.remove('done');\n        // if element is in a position >= n - i, it's finalized (bubble sorted to right)\n        // But since we reorder DOM on swap, we mark elements that are in final right positions after passes complete:\n      }\n      // after a pass completes (i passes), last i elements are considered done (if i>0)\n      const finalized = i;\n      for(let k=0;k<finalized;k++){\n        const idx = array.length - 1 - k;\n        if(nodeOrder[idx]) nodeOrder[idx].classList.add('done');\n      }\n    }\n\n    function updatePositions(animated = true){\n      // recompute positions (in case of resize or array length change)\n      const n = array.length;\n      const rect = barsEl.getBoundingClientRect();\n      const containerWidth = Math.max(200, rect.width || 600);\n      const totalGap = Math.max(0, (n-1) * GAP);\n      let barWidth = Math.max(MIN_BAR_WIDTH, Math.floor((containerWidth - totalGap) / n));\n      barWidth = Math.min(barWidth, Math.floor((containerWidth - totalGap) / Math.max(1,n)));\n      positions = [];\n      let left = 0;\n      for(let idx=0; idx<n; idx++){\n        positions.push(left);\n        left += barWidth + GAP;\n      }\n      nodeOrder.forEach((el, idx) => {\n        el.style.width = barWidth + 'px';\n        if(!animated) el.style.transition = 'none';\n        else el.style.transition = 'transform 360ms cubic-bezier(.2,.9,.2,1)';\n        el.style.transform = `translateX(${positions[idx]}px)`;\n      });\n      // re-enable transition\n      if(!animated){\n        requestAnimationFrame(()=> {\n          nodeOrder.forEach(el => el.style.transition = 'transform 360ms cubic-bezier(.2,.9,.2,1)');\n        });\n      }\n    }\n\n    // Pseudocode highlighting utility\n    function highlightPseudocode(n){\n      codeLines.forEach(ln => {\n        ln.classList.toggle('current', parseInt(ln.dataset.line,10) === n);\n      });\n    }\n\n    // Save snapshot for back navigation\n    function pushHistory(currentLine){\n      history.push({\n        array: array.slice(),\n        i, j, comparisons, swaps,\n        currentLine\n      });\n      // limit history size\n      if(history.length > 1000) history.shift();\n    }\n\n    function restoreHistory(){\n      if(history.length === 0) return;\n      const snap = history.pop();\n      array = snap.array.slice();\n      i = snap.i; j = snap.j;\n      comparisons = snap.comparisons;\n      swaps = snap.swaps;\n      renderBars();\n      updateStats();\n      highlightPseudocode(snap.currentLine || 1);\n    }\n\n    function stepOnce(){\n      const n = array.length;\n      if(n <= 1 || i >= n-1){\n        // done\n        stop();\n        statusText.textContent = 'Sorted';\n        highlightPseudocode(1);\n        i = n - 1;\n        markDoneElements();\n        return;\n      }\n      // Save pre-step snapshot for Back (before making the change)\n      pushHistory(2); // line 2 we're entering inner loop\n      // compare arr[j] and arr[j+1]\n      const leftIdx = j;\n      const rightIdx = j+1;\n      comparisons++;\n      updateStats();\n      // highlight comparison\n      const leftEl = nodeOrder[leftIdx];\n      const rightEl = nodeOrder[rightIdx];\n      if(leftEl) leftEl.classList.add('compare');\n      if(rightEl) rightEl.classList.add('compare');\n      highlightPseudocode(3);\n      statusText.textContent = `Comparing index ${j} and ${j+1}`;\n      // wait for a bit if playing for visual\n      setTimeout(() => {\n        // check order\n        if(array[leftIdx] > array[rightIdx]){\n          // swap in array\n          [array[leftIdx], array[rightIdx]] = [array[rightIdx], array[leftIdx]];\n          swaps++;\n          updateStats();\n          // also swap DOM nodes in nodeOrder array and animate positions\n          leftEl.classList.remove('compare');\n          rightEl.classList.remove('compare');\n          leftEl.classList.add('swap');\n          rightEl.classList.add('swap');\n          highlightPseudocode(4);\n          statusText.textContent = `Swapping ${rightIdx} ↔ ${leftIdx}`;\n          // perform swap in nodeOrder\n          nodeOrder.splice(leftIdx, 2, rightEl, leftEl);\n          // animate to new positions\n          updatePositions(true);\n          // after animation, remove swap class\n          setTimeout(() => {\n            leftEl.classList.remove('swap');\n            rightEl.classList.remove('swap');\n            // proceed to next index\n            incrementIndexes();\n          }, Math.max(220, parseInt(speedRange.value,10)));\n        } else {\n          // no swap\n          leftEl.classList.remove('compare');\n          rightEl.classList.remove('compare');\n          // small pause to let user see comparison\n          setTimeout(() => {\n            // proceed to next index\n            incrementIndexes();\n          }, Math.max(120, parseInt(speedRange.value,10)/2));\n        }\n      }, Math.max(80, parseInt(speedRange.value,10)/3));\n    }\n\n    function incrementIndexes(){\n      // advance j; if inner loop done, advance i\n      j++;\n      const n = array.length;\n      if(j >= n - 1 - i){\n        // finished a pass\n        i++;\n        j = 0;\n        markDoneElements();\n        statusText.textContent = `Pass ${i} complete`;\n      }\n      updateStats();\n      // if sorted complete\n      if(i >= n - 1){\n        stop();\n        statusText.textContent = 'Sorted';\n        highlightPseudocode(1);\n        markDoneElements();\n      } else {\n        highlightPseudocode(2);\n      }\n    }\n\n    function updateStats(){\n      statPass.textContent = 'Pass: ' + i;\n      statIdx.textContent = 'Compare j: ' + j;\n      statComp.textContent = 'Comparisons: ' + comparisons;\n      statSwaps.textContent = 'Swaps: ' + swaps;\n    }\n\n    // Control handlers\n    sizeRange.addEventListener('input', (e)=>{\n      sizeVal.textContent = e.target.value;\n    });\n    sizeRange.addEventListener('change', (e)=>{\n      array = makeRandomArray(parseInt(e.target.value,10));\n      initialArray = array.slice();\n      resetAlgorithmState();\n      renderBars();\n      updateStats();\n    });\n\n    randomBtn.addEventListener('click', ()=>{\n      array = makeRandomArray(parseInt(sizeRange.value,10));\n      initialArray = array.slice();\n      resetAlgorithmState();\n      renderBars();\n      updateStats();\n    });\n\n    shuffleBtn.addEventListener('click', ()=>{\n      // shuffle current array\n      for(let k=array.length-1;k>0;k--){\n        const r = Math.floor(Math.random()*(k+1));\n        [array[k], array[r]] = [array[r], array[k]];\n      }\n      initialArray = array.slice();\n      resetAlgorithmState();\n      renderBars();\n      updateStats();\n    });\n\n    resetBtn.addEventListener('click', ()=>{\n      array = initialArray.slice();\n      resetAlgorithmState();\n      renderBars();\n      updateStats();\n      statusText.textContent = 'Reset';\n    });\n\n    arrInput.addEventListener('keydown', (e)=>{\n      if(e.key === 'Enter'){\n        applyCustomArray();\n      }\n    });\n\n    function applyCustomArray(){\n      const raw = arrInput.value.trim();\n      if(!raw) return;\n      const parts = raw.split(',').map(s => s.trim()).filter(Boolean);\n      const nums = [];\n      for(const p of parts){\n        const v = Number(p);\n        if(Number.isNaN(v)){\n          alert('Please enter only numbers separated by commas.');\n          return;\n        }\n        nums.push(v);\n      }\n      if(nums.length < 2){\n        alert('Please provide at least 2 numbers.');\n        return;\n      }\n      array = nums.slice(0, 40); // guard\n      initialArray = array.slice();\n      sizeRange.value = Math.min(20, array.length);\n      sizeVal.textContent = sizeRange.value;\n      resetAlgorithmState();\n      renderBars();\n      updateStats();\n      statusText.textContent = 'Custom array applied';\n    }\n\n    playBtn.addEventListener('click', togglePlay);\n    function togglePlay(){\n      if(playing) stop();\n      else play();\n    }\n\n    function play(){\n      if(array.length <= 1) return;\n      playing = true;\n      playBtn.classList.add('primary');\n      playBtn.textContent = 'Pause';\n      playBtn.setAttribute('aria-pressed','true');\n      // set interval by speed\n      const delay = Math.max(40, parseInt(speedRange.value,10));\n      timer = setInterval(()=>{\n        // if done, stop\n        if(i >= array.length - 1){\n          stop();\n          return;\n        }\n        stepOnce();\n      }, delay);\n    }\n\n    function stop(){\n      playing = false;\n      if(timer) {\n        clearInterval(timer);\n        timer = null;\n      }\n      playBtn.classList.remove('primary');\n      playBtn.textContent = 'Play';\n      playBtn.setAttribute('aria-pressed','false');\n    }\n\n    stepBtn.addEventListener('click', ()=>{\n      if(playing) stop();\n      stepOnce();\n    });\n\n    backBtn.addEventListener('click', ()=>{\n      if(playing) stop();\n      restoreHistory();\n    });\n\n    speedRange.addEventListener('input', (e)=>{\n      speedVal.textContent = e.target.value + 'ms';\n      if(playing){\n        stop();\n        play();\n      }\n    });\n\n    fastFinishBtn.addEventListener('click', ()=>{\n      if(playing) stop();\n      // quickly finish algorithm with no animation (fast)\n      while(i < array.length - 1){\n        for(j=0;j<array.length-1-i;j++){\n          if(array[j] > array[j+1]){\n            [array[j], array[j+1]] = [array[j+1], array[j]];\n            swaps++; comparisons++;\n          } else {\n            comparisons++;\n          }\n        }\n        i++;\n      }\n      // re-render final\n      renderBars();\n      updateStats();\n      statusText.textContent = 'Finished (fast)';\n      highlightPseudocode(1);\n    });\n\n    // keyboard shortcuts\n    window.addEventListener('keydown', (e)=>{\n      if(e.key === ' '){\n        e.preventDefault();\n        togglePlay();\n      } else if(e.key === 'ArrowRight'){\n        e.preventDefault();\n        if(playing) stop();\n        stepOnce();\n      } else if(e.key === 'ArrowLeft'){\n        e.preventDefault();\n        if(playing) stop();\n        restoreHistory();\n      }\n    });\n\n    // on resize recompute positions\n    window.addEventListener('resize', ()=>{\n      updatePositions(false);\n    });\n\n    // initialize\n    init();\n    // ensure positions recomputed after fonts/layout\n    setTimeout(()=> updatePositions(false), 120);\n\n  </script>\n</body>\n</html>\n```\n\nNotes and accessibility considerations:\n- All UI controls are keyboard-accessible; clear visual focus outlines are shown.\n- Colors use additional box/shadow patterns for emphasis (not only color).\n- The \"Back\" feature uses a history stack to allow a single-step rewind; this keeps the state model simple and predictable.\n- The pseudocode is intentionally short and mapped to visual steps; the currently-executing line is highlighted to cement the connection between code and animation.\n\nYou can paste the single HTML file above into a browser to run the interactive Bubble Sort module."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Bubble Sort.\n\n**Project Overview:**\nTopic: Bubble Sort\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Bubble Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "ca5b2950-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:47:10.437Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Selection Sort",
    "answer": {
      "role": "assistant",
      "content": "Here's a single-file, self-contained interactive HTML module that teaches Selection Sort. Save this as an .html file and open in a modern browser.\n\nThe page includes:\n- Concept Title\n- Learning Objective\n- Interaction Design (both described and implemented)\n- Layout Description\n- A fully interactive Selection Sort visualizer with step, play/pause, speed, shuffle/reset, and an optional \"Manual Swap\" practice mode\n- Animated swaps and visual feedback for the current index, current candidate minimum, comparisons, and sorted region\n- Accessible controls and responsive layout (safe area margin 24px, minimum spacing 16px)\n\nCode:\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Selection Sort — Interactive Module</title>\n  <style>\n    :root{\n      --safe-padding: 24px;\n      --gap: 16px;\n      --bg: #f7f9fc;\n      --card: #ffffff;\n      --muted: #6b7280;\n      --accent: #0369a1;\n      --success: #059669;\n      --danger: #dc2626;\n      --shadow: 0 6px 18px rgba(13, 16, 23, 0.08);\n      --bar-width: 44px;\n      --bar-gap: 12px;\n      --max-bars: 12;\n    }\n\n    html,body{\n      height:100%;\n      margin:0;\n      font-family: Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;\n      background: linear-gradient(180deg, #eef2ff 0%, #f7f9fc 100%);\n      color:#0f172a;\n    }\n\n    /* Safe area margin 24px */\n    body{\n      padding: var(--safe-padding);\n      box-sizing: border-box;\n    }\n\n    .container{\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      justify-content:space-between;\n      max-width:1200px;\n      margin:0 auto;\n    }\n\n    /* Responsive stacking for narrow screens */\n    @media (max-width: 900px){\n      .container{\n        flex-direction:column;\n      }\n    }\n\n    /* Left column: info and controls */\n    .panel{\n      background:var(--card);\n      border-radius:12px;\n      padding:20px;\n      box-shadow:var(--shadow);\n      flex:0 0 360px;\n      min-width:260px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    @media (max-width:900px){\n      .panel{ flex:unset; width:100%; }\n    }\n\n    .title{\n      font-size:20px;\n      font-weight:600;\n      color:var(--accent);\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n    .subtitle{\n      font-size:14px;\n      color:var(--muted);\n    }\n\n    .section{\n      background: #fbfdff;\n      border-radius:8px;\n      padding:12px;\n      border:1px solid rgba(2,6,23,0.03);\n    }\n\n    .section h4{\n      margin:0 0 8px 0;\n      font-size:13px;\n      color:#0b1220;\n    }\n\n    .controls{\n      display:flex;\n      flex-wrap:wrap;\n      gap:var(--gap);\n      align-items:center;\n    }\n\n    /* Right column: visual canvas */\n    .canvas{\n      background:transparent;\n      flex:1 1 600px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      min-width:300px;\n    }\n\n    .visual-card{\n      background:var(--card);\n      border-radius:12px;\n      padding:20px;\n      box-shadow:var(--shadow);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      align-items:stretch;\n    }\n\n    .toolbar{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    button{\n      background:#0369a18f;\n      color:white;\n      border:none;\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      min-height:40px;\n    }\n    button.secondary{\n      background:#e6eef6;\n      color:#0f172a;\n      font-weight:600;\n    }\n    button.ghost{\n      background:transparent;\n      color:var(--accent);\n      border:1px solid rgba(3,105,161,0.12);\n    }\n    button:disabled{\n      opacity:0.5;\n      cursor:not-allowed;\n    }\n\n    .small{\n      padding:6px 10px;\n      font-size:13px;\n      border-radius:8px;\n    }\n\n    .speed{\n      display:flex;\n      align-items:center;\n      gap:8px;\n    }\n    input[type=range]{\n      width:160px;\n    }\n\n    .array-area{\n      background:linear-gradient(180deg, #ffffff, #fbfdff);\n      border-radius:8px;\n      padding:18px;\n      min-height:220px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n    }\n\n    .bars{\n      display:flex;\n      align-items:flex-end;\n      gap:var(--bar-gap);\n      padding:8px;\n      min-height:160px;\n      max-width:100%;\n      overflow:hidden;\n    }\n\n    .bar{\n      width:var(--bar-width);\n      background:linear-gradient(180deg,#60a5fa,#0369a1);\n      color:white;\n      border-radius:6px 6px 4px 4px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:700;\n      user-select:none;\n      position:relative;\n      transition: transform 300ms ease, box-shadow 150ms ease;\n      box-shadow: 0 3px 8px rgba(3,105,161,0.12);\n      cursor:pointer;\n    }\n\n    .bar .label{\n      position:absolute;\n      top:-28px;\n      font-size:12px;\n      color:#0b1220;\n      background:rgba(255,255,255,0.92);\n      padding:4px 6px;\n      border-radius:6px;\n      box-shadow:0 3px 10px rgba(2,6,23,0.06);\n    }\n\n    .bar.index{\n      font-size:11px;\n      position:absolute;\n      bottom:-20px;\n      color:var(--muted);\n      background:transparent;\n      box-shadow:none;\n      font-weight:600;\n    }\n\n    .bar.current{\n      outline:3px solid #fde68a;\n      transform:translateY(-6px);\n    }\n    .bar.min{\n      outline:3px solid #7dd3fc;\n      box-shadow:0 8px 20px rgba(34,197,94,0.06);\n      transform:translateY(-8px);\n    }\n    .bar.comparing{\n      outline:3px dashed rgba(2,6,23,0.06);\n      transform: translateY(-4px);\n      box-shadow:0 6px 18px rgba(3,105,161,0.06);\n    }\n    .bar.sorted{\n      outline:3px solid rgba(5,150,105,0.12);\n      background:linear-gradient(180deg,#bbf7d0,#10b981);\n    }\n\n    .legend{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .legend .item{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .swatch{\n      width:18px;height:18px;border-radius:4px;\n      display:inline-block;\n      box-shadow:0 2px 6px rgba(2,6,23,0.06);\n    }\n\n    .footer-note{\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* Small helper for shake on wrong click */\n    @keyframes shake {\n      0% { transform: translateX(0px); }\n      20% { transform: translateX(-6px); }\n      40% { transform: translateX(6px); }\n      60% { transform: translateX(-4px); }\n      80% { transform: translateX(4px); }\n      100% { transform: translateX(0px); }\n    }\n    .shake{\n      animation: shake 360ms ease;\n    }\n\n    /* Ensure minimum spacing 16px between controls */\n    .controls > * { margin: 0; }\n\n    /* Help text */\n    .muted-small { color:var(--muted); font-size:13px; }\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"main\">\n    <!-- Left column: descriptive and instructions -->\n    <aside class=\"panel\" aria-labelledby=\"module-title\">\n      <div>\n        <div class=\"title\" id=\"module-title\">Selection Sort — Visual & Interactive</div>\n        <div class=\"subtitle\">A hands-on walkthrough of selection sort's process and swaps.</div>\n      </div>\n\n      <div class=\"section\" aria-label=\"Learning Objective\">\n        <h4>Learning Objective</h4>\n        <p class=\"muted-small\">After interacting with this module you will be able to:\n          identify the repeated selection of the minimum element each pass, track comparisons, and understand how and when swaps occur in Selection Sort.</p>\n      </div>\n\n      <div class=\"section\" aria-label=\"Interaction Design\">\n        <h4>Interaction Design</h4>\n        <p class=\"muted-small\">\n          Use the controls to step through the algorithm or play it. Visual cues:\n        </p>\n        <ul class=\"muted-small\" style=\"margin:8px 0 0 18px; padding:0;\">\n          <li><strong>Current index (i)</strong>: highlighted (yellow). This is where the next minimum will be placed.</li>\n          <li><strong>Current min</strong>: highlighted (cyan). Updated when a smaller value is found.</li>\n          <li><strong>Comparing</strong>: element being compared animates slightly upward.</li>\n          <li><strong>Sorted</strong>: elements already placed in final positions turn green.</li>\n          <li><strong>Swap animation</strong>: bars slide to swap positions so you can see the exchange.</li>\n        </ul>\n        <p class=\"muted-small\" style=\"margin-top:8px;\">\n          Toggle \"Manual Swap\" to practice: when the pass completes, click the bar you think should swap into position i. If wrong, you'll see a shake and can try again.\n        </p>\n      </div>\n\n      <div class=\"section\" aria-label=\"Layout Description\">\n        <h4>Layout Description</h4>\n        <p class=\"muted-small\" style=\"margin:0\">\n          The page uses a two-column layout: left for explanatory text and controls, right for the visual canvas and interactive controls.\n          The design respects a safe padding of 24px and keeps 16px minimum spacing between interactive elements. Controls are keyboard-accessible (Space = step).\n        </p>\n      </div>\n\n      <div class=\"section\" aria-label=\"Tips\">\n        <h4>Tips for Practice</h4>\n        <ul class=\"muted-small\" style=\"margin:8px 0 0 18px; padding:0;\">\n          <li>Start with small arrays to follow each comparison.</li>\n          <li>Use \"Step\" to see how minIndex changes during a pass.</li>\n          <li>Switch to \"Manual Swap\" to test your understanding of which element is the minimum.</li>\n        </ul>\n      </div>\n\n      <div style=\"margin-top:auto;\">\n        <div class=\"footer-note\">Author: Interactive Learning · Built with vanilla HTML/CSS/JS</div>\n      </div>\n    </aside>\n\n    <!-- Right column: interactive visual -->\n    <section class=\"canvas\" aria-label=\"Selection sort visual canvas\">\n      <div class=\"visual-card\" aria-live=\"polite\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;\">\n          <div style=\"display:flex;flex-direction:column;\">\n            <div style=\"font-weight:700\">Array</div>\n            <div class=\"muted-small\">Click a bar to select in manual swap mode</div>\n          </div>\n\n          <div class=\"toolbar\" role=\"region\" aria-label=\"Controls\">\n            <button id=\"shuffleBtn\" class=\"small\" title=\"Shuffle array\">Shuffle</button>\n            <button id=\"resetBtn\" class=\"small secondary\" title=\"Reset to original\">Reset</button>\n\n            <button id=\"stepBtn\" class=\"small\" title=\"Step (Space)\">Step</button>\n            <button id=\"playBtn\" class=\"small\" title=\"Play / Pause\">Play</button>\n\n            <label class=\"small speed\" title=\"Adjust speed\">\n              <span style=\"font-size:13px;color:var(--muted)\">Speed</span>\n              <input id=\"speedRange\" type=\"range\" min=\"0.25\" max=\"2\" step=\"0.25\" value=\"1\" />\n            </label>\n\n            <button id=\"manualToggle\" class=\"small ghost\" title=\"Toggle manual swap mode\">Manual Swap: Off</button>\n          </div>\n        </div>\n\n        <div class=\"array-area\" role=\"img\" aria-label=\"Array visualization\">\n          <div id=\"bars\" class=\"bars\" aria-hidden=\"false\"></div>\n        </div>\n\n        <div style=\"display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:12px;\">\n          <div class=\"legend\" aria-hidden=\"false\" style=\"gap:12px;\">\n            <div class=\"item\"><span class=\"swatch\" style=\"background:#fde68a;border:1px solid rgba(0,0,0,0.04)\"></span> Current index (i)</div>\n            <div class=\"item\"><span class=\"swatch\" style=\"background:#7dd3fc;border:1px solid rgba(0,0,0,0.04)\"></span> Current min</div>\n            <div class=\"item\"><span class=\"swatch\" style=\"background:#60a5fa;border:1px solid rgba(0,0,0,0.04)\"></span> Comparing</div>\n            <div class=\"item\"><span class=\"swatch\" style=\"background:#bbf7d0;border:1px solid rgba(0,0,0,0.04)\"></span> Sorted</div>\n          </div>\n\n          <div style=\"display:flex;gap:12px;align-items:center;flex-wrap:wrap\">\n            <div class=\"muted-small\">Size:\n              <input id=\"sizeInput\" type=\"number\" min=\"3\" max=\"12\" value=\"8\" style=\"width:64px;margin-left:8px;padding:6px;border-radius:8px;border:1px solid #e6eef6;font-weight:600;\" />\n            </div>\n            <div class=\"muted-small\">Seeded values may repeat; try different sizes.</div>\n          </div>\n        </div>\n      </div>\n\n      <!-- Info Card: current algorithm state -->\n      <div class=\"visual-card\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;gap:12px;\">\n          <div>\n            <div style=\"font-weight:700\">Algorithm State</div>\n            <div class=\"muted-small\" id=\"stateText\" style=\"margin-top:6px\">Idle — array ready</div>\n          </div>\n          <div style=\"text-align:right\">\n            <div class=\"muted-small\">Comparisons: <span id=\"comparisons\">0</span></div>\n            <div class=\"muted-small\" style=\"margin-top:6px\">Swaps: <span id=\"swaps\">0</span></div>\n          </div>\n        </div>\n      </div>\n    </section>\n  </div>\n\n  <script>\n    (function(){\n      // Constants and DOM\n      const barsContainer = document.getElementById('bars');\n      const shuffleBtn = document.getElementById('shuffleBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const stepBtn = document.getElementById('stepBtn');\n      const playBtn = document.getElementById('playBtn');\n      const speedRange = document.getElementById('speedRange');\n      const manualToggle = document.getElementById('manualToggle');\n      const sizeInput = document.getElementById('sizeInput');\n      const stateText = document.getElementById('stateText');\n      const comparisonsEl = document.getElementById('comparisons');\n      const swapsEl = document.getElementById('swaps');\n\n      let array = [];\n      let original = [];\n      let n = Math.max(3, Math.min(12, parseInt(sizeInput.value,10) || 8));\n      let i = 0, j = 1, minIndex = 0;\n      let running = false;\n      let timer = null;\n      let speed = 1; // multiplier; lower -> faster, but we'll invert\n      let comparisons = 0, swaps = 0;\n      let manualSwap = false;\n      let phase = 'idle'; // 'finding', 'swapping', 'done'\n      let animating = false;\n\n      // Utility functions\n      function randInt(min, max){ return Math.floor(Math.random()*(max-min+1)) + min; }\n\n      function genRandomArray(sz){\n        const a = [];\n        for(let k=0;k<sz;k++) a.push(randInt(10,99));\n        return a;\n      }\n\n      function render(){\n        barsContainer.innerHTML = '';\n        const maxVal = Math.max(...array);\n        array.forEach((val, idx) => {\n          const bar = document.createElement('div');\n          bar.className = 'bar';\n          bar.style.height = Math.max(32, (val / maxVal) * 160) + 'px';\n          bar.style.width = 'var(--bar-width)';\n          bar.dataset.index = idx;\n          bar.dataset.value = val;\n          bar.tabIndex = 0;\n          bar.setAttribute('role','button');\n          bar.setAttribute('aria-label', 'Value ' + val + ' at index ' + idx);\n\n          const label = document.createElement('div');\n          label.className = 'label';\n          label.textContent = val;\n          bar.appendChild(label);\n\n          const idxLabel = document.createElement('div');\n          idxLabel.className = 'index';\n          idxLabel.textContent = idx;\n          bar.appendChild(idxLabel);\n\n          bar.addEventListener('click', () => onBarClick(idx, bar));\n          bar.addEventListener('keydown', (e) => {\n            if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onBarClick(idx, bar); }\n          });\n\n          barsContainer.appendChild(bar);\n        });\n        updateVisualHighlights();\n      }\n\n      function updateVisualHighlights(){\n        const bars = Array.from(barsContainer.children);\n        bars.forEach((bar, idx) => {\n          bar.classList.remove('current','min','comparing','sorted','shake');\n          if (phase === 'done' || i >= array.length) {\n            bar.classList.add('sorted');\n          } else {\n            if (idx < i) bar.classList.add('sorted');\n            if (idx === i) bar.classList.add('current');\n            if (idx === minIndex && phase !== 'done') bar.classList.add('min');\n            if (idx === j && phase === 'finding') bar.classList.add('comparing');\n          }\n          // Update label and index text (in case values changed)\n          const label = bar.querySelector('.label');\n          label.textContent = array[idx];\n          const idxLabel = bar.querySelector('.index');\n          idxLabel.textContent = idx;\n          bar.dataset.index = idx;\n          bar.dataset.value = array[idx];\n          // update style height\n          const maxVal = Math.max(...array);\n          bar.style.height = Math.max(32, (array[idx] / maxVal) * 160) + 'px';\n        });\n        comparisonsEl.textContent = comparisons;\n        swapsEl.textContent = swaps;\n        if (phase === 'done') {\n          stateText.textContent = 'Done — array sorted';\n        } else {\n          stateText.textContent = `i=${i}  min=${minIndex}  j=${(phase==='finding'?j:'-')}  phase=${phase}`;\n        }\n      }\n\n      // Selection sort step logic (non-animated)\n      async function step(){\n        if (animating) return;\n        if (phase === 'done') return;\n        if (i >= array.length - 1) {\n          phase = 'done';\n          updateVisualHighlights();\n          return;\n        }\n        phase = 'finding';\n        updateVisualHighlights();\n\n        // If j is within bounds, perform one compare step\n        if (j < array.length) {\n          // compare array[j] with array[minIndex]\n          comparisons++;\n          // visual: highlight j as comparing\n          updateVisualHighlights();\n\n          if (array[j] < array[minIndex]) {\n            minIndex = j;\n          }\n          j++;\n          updateVisualHighlights();\n          return;\n        }\n\n        // j reached end, perform swap if needed\n        if (minIndex !== i) {\n          phase = 'swapping';\n          updateVisualHighlights();\n          await animateSwapIndices(i, minIndex);\n          swaps++;\n          // After swap, proceed\n        }\n        // move to next i\n        i++;\n        minIndex = i;\n        j = i + 1;\n        if (i >= array.length - 1) {\n          phase = 'done';\n        } else {\n          phase = 'finding';\n        }\n        updateVisualHighlights();\n      }\n\n      // animate swap bars at indices a and b\n      function animateSwapIndices(a, b){\n        return new Promise((resolve) => {\n          animating = true;\n          const bars = Array.from(barsContainer.children);\n          const barA = bars[a];\n          const barB = bars[b];\n          // compute positions\n          const rectA = barA.getBoundingClientRect();\n          const rectB = barB.getBoundingClientRect();\n          const deltaX = rectB.left - rectA.left;\n          // apply transform to visually move them\n          barA.style.transition = 'transform 400ms ease';\n          barB.style.transition = 'transform 400ms ease';\n          barA.style.transform = `translateX(${deltaX}px)`;\n          barB.style.transform = `translateX(${-deltaX}px)`;\n          // increase z-index while animating\n          barA.style.zIndex = '10';\n          barB.style.zIndex = '10';\n\n          // after transition, swap actual array and re-render positions without animation\n          const cleanup = () => {\n            barA.style.transition = '';\n            barB.style.transition = '';\n            barA.style.transform = '';\n            barB.style.transform = '';\n            barA.style.zIndex = '';\n            barB.style.zIndex = '';\n            // swap in data array\n            const tmp = array[a];\n            array[a] = array[b];\n            array[b] = tmp;\n            // update DOM: re-render to ensure correct order and indices\n            render();\n            animating = false;\n            resolve();\n          };\n\n          // Use event listener for transition end on one of them (safeguard with timeout)\n          let done = false;\n          const onEnd = (ev) => {\n            if(done) return;\n            done = true;\n            cleanup();\n          };\n          barB.addEventListener('transitionend', onEnd, {once:true});\n          // safety timeout\n          setTimeout(() => {\n            if(!done) onEnd();\n          }, 700);\n        });\n      }\n\n      // Manual swap handling: if manualSwap mode on, when pass finishes user must click correct bar\n      function onBarClick(idx, barEl){\n        if (!manualSwap) return;\n        if (phase !== 'finding') return;\n        // If j hasn't finished scanning, clicking shouldn't swap. Only allow when j >= n (pass finished)\n        if (j <= array.length - 1) {\n          // optionally inform user to finish scanning\n          barEl.classList.add('shake');\n          setTimeout(() => barEl.classList.remove('shake'), 350);\n          return;\n        }\n        // Now user must select the minIndex to swap with i\n        if (idx === minIndex) {\n          // perform actual swap (animated)\n          (async () => {\n            animating = true;\n            await animateSwapIndices(i, minIndex);\n            swaps++;\n            // advance\n            i++;\n            minIndex = i;\n            j = i+1;\n            if (i >= array.length - 1) phase = 'done';\n            else phase = 'finding';\n            animating = false;\n            updateVisualHighlights();\n          })();\n        } else {\n          // wrong choice — shake and hint\n          barEl.classList.add('shake');\n          setTimeout(() => barEl.classList.remove('shake'), 360);\n        }\n      }\n\n      function resetState(newArray){\n        array = newArray.slice();\n        original = newArray.slice();\n        n = array.length;\n        i = 0; j = 1; minIndex = 0;\n        comparisons = 0; swaps = 0;\n        phase = 'finding';\n        running = false;\n        clearInterval(timer);\n        timer = null;\n        updatePlayBtn();\n        render();\n      }\n\n      function shuffleArray(){\n        const sz = Math.max(3, Math.min(12, parseInt(sizeInput.value,10) || 8));\n        const newArr = genRandomArray(sz);\n        resetState(newArr);\n      }\n\n      function resetToOriginal(){\n        resetState(original);\n      }\n\n      function updatePlayBtn(){\n        playBtn.textContent = running ? 'Pause' : 'Play';\n      }\n\n      // Play loop uses step() at interval (adjusted by speed)\n      function startPlaying(){\n        if (running) return;\n        running = true;\n        updatePlayBtn();\n        const baseDelay = 600; // ms per step at speed 1\n        function tick(){\n          // If algorithm ends, stop\n          if (phase === 'done') {\n            stopPlaying();\n            return;\n          }\n          step();\n        }\n        timer = setInterval(tick, Math.max(120, baseDelay / speed));\n      }\n\n      function stopPlaying(){\n        running = false;\n        updatePlayBtn();\n        if (timer) {\n          clearInterval(timer);\n          timer = null;\n        }\n      }\n\n      // Keyboard shortcuts\n      window.addEventListener('keydown', (e) => {\n        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;\n        if (e.code === 'Space') { e.preventDefault(); step(); }\n      });\n\n      // Event hooks\n      shuffleBtn.addEventListener('click', () => {\n        shuffleArray();\n      });\n      resetBtn.addEventListener('click', () => {\n        resetToOriginal();\n      });\n      stepBtn.addEventListener('click', () => {\n        step();\n      });\n      playBtn.addEventListener('click', () => {\n        if (running) stopPlaying(); else startPlaying();\n      });\n      speedRange.addEventListener('input', (e) => {\n        // Mapping: slider value 0.25..2 -> bigger means faster\n        speed = parseFloat(e.target.value);\n        // If running, restart interval to adjust speed\n        if (running) {\n          stopPlaying();\n          startPlaying();\n        }\n      });\n      manualToggle.addEventListener('click', () => {\n        manualSwap = !manualSwap;\n        manualToggle.textContent = 'Manual Swap: ' + (manualSwap ? 'On' : 'Off');\n        if (manualSwap) {\n          manualToggle.classList.add('ghost');\n          manualToggle.style.background = '#eaf8ff';\n        } else {\n          manualToggle.style.background = 'transparent';\n        }\n      });\n      sizeInput.addEventListener('change', () => {\n        let v = parseInt(sizeInput.value,10) || 8;\n        if (v < 3) v = 3;\n        if (v > 12) v = 12;\n        sizeInput.value = v;\n        shuffleArray();\n      });\n\n      // Initialize with a random array\n      resetState(genRandomArray(n));\n\n      // Expose some helpers for debugging in console (optional)\n      window._selectionSortViz = {\n        getArray: () => array.slice(),\n        step: step,\n        play: startPlaying,\n        pause: stopPlaying\n      };\n    })();\n  </script>\n</body>\n</html>\n```\n\nNotes:\n- The module focuses exclusively on Selection Sort and uses only vanilla HTML/CSS/JavaScript.\n- Swap animations move bars horizontally so you can clearly see which elements exchange places.\n- \"Manual Swap\" mode lets you practice picking the correct minimum at the end of each pass — a useful active-learning exercise.\n- Layout respects the safe margin (24px) and minimum spacing (16px) between interactive items and is responsive for smaller screens."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Selection Sort.\n\n**Project Overview:**\nTopic: Selection Sort\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Selection Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "cbdf5850-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:47:12.981Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Heap Sort",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Heap Sort Module</title>\n  <style>\n    /* Safe area margin: 24px on all sides */\n    html, body {\n      height: 100%;\n      margin: 0;\n    }\n    body {\n      box-sizing: border-box;\n      padding: 24px;\n      font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      color: #111;\n      background: #f7f8fa;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n\n    /* Layout container */\n    .module {\n      max-width: 1200px;\n      margin: 0 auto;\n      display: grid;\n      grid-template-columns: 1fr 420px;\n      gap: 24px; /* at least 16px, using 24 for breathing room */\n      align-items: start;\n    }\n\n    /* Responsive stack on narrow screens */\n    @media (max-width: 960px) {\n      .module {\n        grid-template-columns: 1fr;\n      }\n    }\n\n    /* Left column: visualization and controls */\n    .panel {\n      background: #fff;\n      border-radius: 12px;\n      padding: 20px;\n      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.06);\n      display: flex;\n      flex-direction: column;\n      gap: 16px;\n    }\n\n    header.title {\n      display:flex;\n      gap: 16px;\n      align-items: center;\n      justify-content: space-between;\n    }\n    header.title h1 {\n      font-size: 20px;\n      margin: 0;\n    }\n    .meta {\n      font-size: 13px;\n      color: #444;\n    }\n\n    .controls {\n      display:flex;\n      flex-wrap:wrap;\n      gap: 16px; /* minimum spacing between interactive elements */\n      align-items:center;\n    }\n\n    .controls > * {\n      min-width: 0;\n    }\n\n    input[type=\"text\"] {\n      padding: 8px 10px;\n      border-radius: 8px;\n      border: 1px solid #d0d7de;\n      min-width: 220px;\n      font-size: 14px;\n    }\n    button, select {\n      background: #0b5fff;\n      color: white;\n      border: none;\n      padding: 8px 12px;\n      border-radius: 8px;\n      font-size: 14px;\n      cursor: pointer;\n    }\n    button.secondary {\n      background: #e6eefc;\n      color: #0b5fff;\n      border: 1px solid #cfe0ff;\n    }\n    button.ghost {\n      background: transparent;\n      color: #0b5fff;\n      border: 1px solid transparent;\n    }\n    button:disabled {\n      opacity: 0.5;\n      cursor: not-allowed;\n    }\n\n    .range {\n      display:flex;\n      gap: 8px;\n      align-items:center;\n    }\n    .range input[type=\"range\"] {\n      width: 160px;\n    }\n\n    /* Visual area */\n    .visual {\n      display:flex;\n      gap: 16px;\n      align-items: start;\n      justify-content: space-between;\n      flex-wrap:wrap;\n    }\n\n    .heap-area {\n      flex: 1 1 60%;\n      min-width: 280px;\n      position: relative;\n      border-radius: 10px;\n      padding: 12px;\n      background: linear-gradient(180deg,#ffffff,#fbfdff);\n      border: 1px solid #eef3ff;\n    }\n\n    .array-area {\n      flex: 1 1 35%;\n      min-width: 200px;\n      display:flex;\n      flex-direction:column;\n      gap: 12px;\n      align-items: center;\n      justify-content: flex-start;\n    }\n\n    /* Array bars */\n    .bars {\n      width: 100%;\n      height: 160px;\n      display:flex;\n      align-items:end;\n      gap: 8px;\n      padding: 8px;\n      box-sizing:border-box;\n    }\n    .bar {\n      flex: 1 1 0;\n      background: linear-gradient(180deg,#8fb6ff,#3b82f6);\n      border-radius: 6px 6px 4px 4px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      color: white;\n      font-weight: 600;\n      transition: transform 400ms cubic-bezier(.2,.9,.2,1), background 300ms;\n      position: relative;\n      min-width: 20px;\n      cursor: grab;\n      user-select: none;\n    }\n    .bar.dragging {\n      opacity: 0.85;\n      transform: scale(1.05);\n      cursor: grabbing;\n      box-shadow: 0 10px 30px rgba(11,92,255,0.12);\n    }\n    .bar.index {\n      position: absolute;\n      top: -18px;\n      font-size: 12px;\n      color: #1f2937;\n      background: transparent;\n      left: 50%;\n      transform: translateX(-50%);\n    }\n    .bar.bad {\n      background: linear-gradient(180deg,#ffa8a8,#ff6b6b);\n    }\n    .bar.highlight {\n      box-shadow: 0 6px 18px rgba(59,130,246,0.18);\n      transform: translateY(-6px);\n    }\n\n    /* Heap tree visualization using SVG overlaid nodes */\n    .tree-svg {\n      width: 100%;\n      height: 320px;\n      position: relative;\n      overflow: visible;\n    }\n\n    .node {\n      position: absolute;\n      width: 44px;\n      height: 44px;\n      border-radius: 50%;\n      background: #ffffff;\n      border: 2px solid #cfe0ff;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight: 700;\n      color: #0b5fff;\n      box-shadow: 0 4px 10px rgba(11,92,255,0.06);\n      transition: transform 350ms, background 300ms, border-color 300ms;\n      z-index: 2;\n    }\n    .node.small {\n      width: 36px;\n      height: 36px;\n      font-size: 13px;\n    }\n    .node.highlight {\n      background: linear-gradient(180deg,#e6f0ff,#d2e6ff);\n      border-color: #0b5fff;\n      transform: scale(1.08);\n    }\n    .node.sorted {\n      background: linear-gradient(180deg,#e6fffa,#a7f3d0);\n      color: #065f46;\n      border-color: #bbf7d0;\n    }\n\n    /* Info panel on right */\n    .info {\n      background: #fff;\n      border-radius: 12px;\n      padding: 16px;\n      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.04);\n      font-size: 14px;\n      color: #1f2937;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .info h2 {\n      margin: 0;\n      font-size: 16px;\n    }\n    .muted {\n      color: #6b7280;\n      font-size: 13px;\n    }\n    .log {\n      font-family: ui-monospace,SFMono-Regular,Monaco,Menlo,monospace;\n      font-size: 13px;\n      background: #fbfdff;\n      border: 1px dashed #eef3ff;\n      padding: 8px;\n      border-radius: 8px;\n      max-height: 220px;\n      overflow:auto;\n    }\n\n    /* Footer small controls */\n    .play-controls {\n      display:flex;\n      gap: 12px;\n      align-items:center;\n    }\n\n    /* Accessibility focus */\n    button:focus, input:focus {\n      outline: 3px solid rgba(11,92,255,0.14);\n      outline-offset: 2px;\n    }\n\n    /* Tiny helper */\n    .small {\n      font-size: 13px;\n      padding: 6px 10px;\n    }\n  </style>\n</head>\n<body>\n  <main class=\"module\" role=\"main\" aria-labelledby=\"title\">\n    <!-- Left column: visual + controls -->\n    <section class=\"panel\" aria-labelledby=\"title\">\n      <header class=\"title\">\n        <div>\n          <h1 id=\"title\">Heap Sort — Build a Max-Heap and Sort</h1>\n          <div class=\"meta\">Interactive step-by-step visualization of Heap Sort (max-heap).</div>\n        </div>\n        <div class=\"meta\" id=\"statusLabel\" aria-live=\"polite\">Idle</div>\n      </header>\n\n      <!-- Learning objective and interaction design -->\n      <div>\n        <strong>Learning objective</strong>\n        <p class=\"muted\" id=\"objective\">\n          Understand how Heap Sort builds a max-heap and repeatedly extracts the maximum to produce a sorted array.\n          You will step through heapify operations, observe swaps in both array and heap tree, and test with custom arrays.\n        </p>\n      </div>\n\n      <!-- Controls -->\n      <div class=\"controls\" aria-label=\"Controls\">\n        <label class=\"small\" for=\"sizeRange\">Size</label>\n        <div class=\"range\" style=\"min-width:120px;\">\n          <input id=\"sizeRange\" type=\"range\" min=\"4\" max=\"16\" value=\"8\" aria-label=\"Array size\" />\n          <div id=\"sizeVal\" class=\"small muted\">8</div>\n        </div>\n\n        <input id=\"customInput\" type=\"text\" aria-label=\"Custom array input\" placeholder=\"e.g. 6,3,9,1,5\" />\n        <button id=\"loadBtn\" class=\"small secondary\" aria-label=\"Load custom array\">Load</button>\n\n        <button id=\"randomBtn\" class=\"small\" aria-label=\"Generate random array\">Randomize</button>\n        <button id=\"buildBtn\" class=\"small\" aria-label=\"Build max-heap\">Build Heap</button>\n        <button id=\"sortBtn\" class=\"small\" aria-label=\"Start heap sort\">Start Sort</button>\n        <button id=\"resetBtn\" class=\"small ghost\" aria-label=\"Reset\">Reset</button>\n      </div>\n\n      <!-- Visuals -->\n      <div class=\"visual\" aria-hidden=\"false\">\n        <div class=\"heap-area\" aria-label=\"Heap tree visualization\">\n          <svg id=\"links\" class=\"tree-svg\" role=\"img\" aria-hidden=\"true\"></svg>\n          <!-- nodes will be absolutely positioned on top of SVG -->\n          <div id=\"nodesLayer\" aria-hidden=\"true\"></div>\n        </div>\n\n        <div class=\"array-area\" aria-label=\"Array representation and interaction\">\n          <div style=\"width:100%;display:flex;align-items:center;justify-content:space-between;\">\n            <div><strong>Array</strong></div>\n            <div class=\"muted small\">Drag bars to reorder</div>\n          </div>\n          <div id=\"bars\" class=\"bars\" role=\"list\" aria-label=\"Array bars\"></div>\n\n          <div style=\"width:100%;display:flex;gap:8px;align-items:center;justify-content:space-between;\">\n            <div class=\"muted\">Step: <span id=\"stepCounter\">0 / 0</span></div>\n            <div style=\"display:flex;gap:8px;\">\n              <button id=\"prevBtn\" class=\"small secondary\" aria-label=\"Previous step\">Prev</button>\n              <button id=\"nextBtn\" class=\"small\" aria-label=\"Next step\">Next</button>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <!-- Play controls -->\n      <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n        <div class=\"play-controls\">\n          <button id=\"playPauseBtn\" class=\"small\" aria-label=\"Play\">Play</button>\n          <div class=\"muted small\">Speed</div>\n          <input id=\"speed\" type=\"range\" min=\"100\" max=\"1500\" value=\"800\" aria-label=\"Animation speed (ms)\" />\n        </div>\n\n        <div class=\"muted small\">Algorithm: Heap Sort (Max-Heap)</div>\n      </div>\n    </section>\n\n    <!-- Right column: info / explanation / log -->\n    <aside class=\"info\" aria-labelledby=\"explainTitle\">\n      <h2 id=\"explainTitle\">Interaction Design & Layout</h2>\n      <div>\n        <strong>Interaction design</strong>\n        <p class=\"muted\">\n          - Create arrays by randomizing or entering comma-separated values. <br>\n          - Drag bars horizontally to experiment with initial ordering (keyboard accessible focus and buttons). <br>\n          - Press \"Build Heap\" to run the heapify process (from last parent down). Each heapify emits steps: comparisons and swaps. <br>\n          - Press \"Start Sort\" to perform the full Heap Sort: swap root with end, mark sorted region, heapify root within reduced heap. <br>\n          - Use Play/Pause and Next/Prev to move through recorded steps. Animations highlight nodes/bars being compared or swapped and update the tree layout via SVG lines.\n        </p>\n      </div>\n\n      <div>\n        <strong>Layout description</strong>\n        <p class=\"muted\">\n          - Safe area: 24px padding around viewport. Controls and visuals keep at least 16px spacing. <br>\n          - Left column holds visuals and controls for focus; right column contains explanations and logs. <br>\n          - On small screens the two columns stack vertically for clarity. Node and bar sizes scale for responsiveness.\n        </p>\n      </div>\n\n      <div>\n        <strong>Step log</strong>\n        <div id=\"log\" class=\"log\" aria-live=\"polite\"></div>\n      </div>\n\n      <div>\n        <strong>How this teaches Heap Sort</strong>\n        <p class=\"muted\">\n          Visual feedback (bar heights and a tree) ties abstract heap operations to array indices. Highlighting compares and animated swaps make the relationship between heap structure and array ordering explicit.\n        </p>\n      </div>\n    </aside>\n  </main>\n\n  <script>\n    // Self-contained Heap Sort interactive module (vanilla JS)\n    (function(){\n      // DOM elements\n      const sizeRange = document.getElementById('sizeRange');\n      const sizeVal = document.getElementById('sizeVal');\n      const randomBtn = document.getElementById('randomBtn');\n      const loadBtn = document.getElementById('loadBtn');\n      const customInput = document.getElementById('customInput');\n      const barsEl = document.getElementById('bars');\n      const nodesLayer = document.getElementById('nodesLayer');\n      const linksSvg = document.getElementById('links');\n      const buildBtn = document.getElementById('buildBtn');\n      const sortBtn = document.getElementById('sortBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const playPauseBtn = document.getElementById('playPauseBtn');\n      const speedRange = document.getElementById('speed');\n      const prevBtn = document.getElementById('prevBtn');\n      const nextBtn = document.getElementById('nextBtn');\n      const logEl = document.getElementById('log');\n      const stepCounter = document.getElementById('stepCounter');\n      const statusLabel = document.getElementById('statusLabel');\n\n      let array = [];\n      let steps = []; // recorded steps for visualization\n      let currentStep = -1;\n      let playing = false;\n      let playTimer = null;\n\n      // Utility: random array\n      function randomArray(n, max=100) {\n        const a = [];\n        for (let i=0;i<n;i++) a.push(Math.floor(Math.random()*max)+1);\n        return a;\n      }\n\n      // Initialize\n      function initInitialArray(n) {\n        array = randomArray(n, 90);\n        recordReset();\n        renderAll();\n      }\n\n      sizeRange.addEventListener('input', ()=> {\n        sizeVal.textContent = sizeRange.value;\n      });\n\n      randomBtn.addEventListener('click', ()=> {\n        const n = Number(sizeRange.value);\n        array = randomArray(n, 90);\n        recordReset();\n        renderAll();\n        log('Randomized array.');\n      });\n\n      loadBtn.addEventListener('click', ()=> {\n        const text = customInput.value.trim();\n        if (!text) return;\n        const parts = text.split(',').map(s=>s.trim()).filter(s=>s.length);\n        const nums = parts.map(p => Number(p));\n        if (nums.some(n => Number.isNaN(n))) {\n          alert('Please enter comma-separated numbers only.');\n          return;\n        }\n        if (nums.length < 2 || nums.length > 40) {\n          // keep reasonable bounds\n          if (!confirm('Array length should be between 2 and 40. Continue?')) return;\n        }\n        array = nums;\n        sizeRange.value = Math.min(Math.max(nums.length, 4), 16);\n        sizeVal.textContent = sizeRange.value;\n        recordReset();\n        renderAll();\n        log('Loaded custom array.');\n      });\n\n      resetBtn.addEventListener('click', ()=> {\n        if (confirm('Reset and clear steps?')) {\n          recordReset();\n          renderAll();\n          log('Reset.');\n        }\n      });\n\n      // Drag to reorder bars (pointer events)\n      let dragState = null;\n      function makeBarsDraggable() {\n        // Clear previous listeners by reassigning innerHTML; but we will attach per element listeners on render\n      }\n\n      // Render bars and attach drag handlers\n      function renderBars() {\n        barsEl.innerHTML = '';\n        const maxVal = Math.max(...array, 1);\n        array.forEach((val, idx) => {\n          const bar = document.createElement('div');\n          bar.className = 'bar';\n          bar.setAttribute('role','listitem');\n          bar.setAttribute('tabindex','0');\n          bar.setAttribute('aria-label',`Index ${idx}, value ${val}`);\n          bar.style.height = `${Math.max(24, (val/maxVal)*120)}px`;\n          bar.dataset.index = idx;\n          bar.innerHTML = `<div class=\"index\">${idx}</div><div>${val}</div>`;\n          // Dragging\n          bar.addEventListener('pointerdown', (e)=>{\n            e.preventDefault();\n            bar.setPointerCapture(e.pointerId);\n            bar.classList.add('dragging');\n            dragState = {el:bar, startX:e.clientX, index: idx};\n          });\n          bar.addEventListener('pointermove', (e)=>{\n            if (!dragState || dragState.el !== bar) return;\n            const dx = e.clientX - dragState.startX;\n            bar.style.transform = `translateX(${dx}px) scale(1.04)`;\n          });\n          bar.addEventListener('pointerup', (e)=>{\n            if (!dragState || dragState.el !== bar) return;\n            bar.releasePointerCapture(e.pointerId);\n            bar.classList.remove('dragging');\n            bar.style.transform = '';\n            // determine drop position by x coordinate relative to barsEl\n            const rect = barsEl.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            // compute target index by dividing bars width evenly\n            const children = Array.from(barsEl.children);\n            const childWidth = rect.width / Math.max(children.length,1);\n            let target = Math.floor(x / childWidth);\n            target = Math.max(0, Math.min(children.length-1, target));\n            const from = Number(bar.dataset.index);\n            if (from !== target) {\n              // perform reorder\n              const val = array.splice(from,1)[0];\n              array.splice(target,0,val);\n              recordReset(); // clear steps since data changed\n              renderAll();\n              log(`Dragged value ${val} from ${from} to ${target}.`);\n            } else {\n              renderBars(); // reset transforms\n            }\n            dragState = null;\n          });\n          bar.addEventListener('keydown', (e)=>{\n            // keyboard reordering: left/right arrows move element\n            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {\n              const from = idx;\n              let to = (e.key === 'ArrowLeft') ? Math.max(0, from-1) : Math.min(array.length-1, from+1);\n              if (to !== from) {\n                const val = array.splice(from,1)[0];\n                array.splice(to,0,val);\n                recordReset();\n                renderAll();\n                log(`Moved value ${val} from ${from} to ${to} (keyboard).`);\n                // focus moved element\n                const newBar = barsEl.children[to];\n                if (newBar) newBar.focus();\n              }\n            }\n          });\n\n          barsEl.appendChild(bar);\n        });\n      }\n\n      // Render heap tree nodes and connecting lines (SVG)\n      function renderTree() {\n        nodesLayer.innerHTML = '';\n        linksSvg.innerHTML = '';\n        if (array.length === 0) return;\n        const n = array.length;\n        // Determine positions for a binary tree layout:\n        // For level h (0-based), nodes distributed evenly horizontally.\n        const levels = Math.floor(Math.log2(n)) + 1;\n        const width = linksSvg.clientWidth || linksSvg.getBoundingClientRect().width || 360;\n        const height = linksSvg.clientHeight || 320;\n        const positions = [];\n        for (let i=0;i<n;i++){\n          const level = Math.floor(Math.log2(i+1));\n          const indexInLevel = i - (2**level - 1);\n          const nodesInLevel = 2**level;\n          const x = ((indexInLevel + 0.5) / nodesInLevel) * (width - 20) + 10;\n          const y = (level + 0.5) / levels * (height - 10) + 5;\n          positions.push({x,y});\n        }\n        // Draw lines first\n        for (let i=0;i<n;i++){\n          const left = 2*i+1;\n          const right = 2*i+2;\n          if (left < n) {\n            const p1 = positions[i];\n            const p2 = positions[left];\n            const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n            line.setAttribute('x1', p1.x);\n            line.setAttribute('y1', p1.y);\n            line.setAttribute('x2', p2.x);\n            line.setAttribute('y2', p2.y);\n            line.setAttribute('stroke','#cfe0ff');\n            line.setAttribute('stroke-width','2');\n            linksSvg.appendChild(line);\n          }\n          if (right < n) {\n            const p1 = positions[i];\n            const p2 = positions[right];\n            const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n            line.setAttribute('x1', p1.x);\n            line.setAttribute('y1', p1.y);\n            line.setAttribute('x2', p2.x);\n            line.setAttribute('y2', p2.y);\n            line.setAttribute('stroke','#cfe0ff');\n            line.setAttribute('stroke-width','2');\n            linksSvg.appendChild(line);\n          }\n        }\n        // Create nodes\n        const maxVal = Math.max(...array,1);\n        for (let i=0;i<n;i++){\n          const node = document.createElement('div');\n          node.className = 'node';\n          node.dataset.index = i;\n          node.setAttribute('role','img');\n          node.setAttribute('aria-label',`Heap node index ${i} value ${array[i]}`);\n          node.textContent = array[i];\n          // position absolute\n          const pos = positions[i];\n          node.style.left = `${pos.x - 22}px`;\n          node.style.top = `${pos.y - 22}px`;\n          nodesLayer.appendChild(node);\n        }\n      }\n\n      // Render everything\n      function renderAll() {\n        renderBars();\n        renderTree();\n        updateStepCounter();\n      }\n\n      // Logging\n      function log(s) {\n        const time = new Date().toLocaleTimeString();\n        const entry = document.createElement('div');\n        entry.textContent = `[${time}] ${s}`;\n        logEl.prepend(entry);\n      }\n\n      // Steps recorder management\n      function recordReset() {\n        steps = [];\n        currentStep = -1;\n        playing = false;\n        playPauseBtn.textContent = 'Play';\n        statusLabel.textContent = 'Idle';\n        logEl.innerHTML = '';\n        updateStepCounter();\n      }\n\n      function updateStepCounter() {\n        stepCounter.textContent = `${Math.max(0,currentStep+1)} / ${steps.length}`;\n      }\n\n      // Heap sort engine that creates step-by-step actions\n      function buildStepsForHeapSort(input) {\n        // Work on a copy to record snapshots\n        const a = input.slice();\n        const n = a.length;\n        const rec = [];\n\n        function pushStep(kind, info) {\n          // push a step object: kind: 'compare'|'swap'|'heapify'|'markSorted' etc.\n          rec.push({kind, info, snapshot: a.slice()});\n        }\n\n        function swap(i,j) {\n          const tmp = a[i]; a[i] = a[j]; a[j] = tmp;\n          pushStep('swap', {i,j});\n        }\n\n        function heapify(len, i) {\n          pushStep('heapifyStart', {i, len});\n          let largest = i;\n          const l = 2*i + 1;\n          const r = 2*i + 2;\n          if (l < len) {\n            pushStep('compare', {a:i, b:l});\n            if (a[l] > a[largest]) largest = l;\n          }\n          if (r < len) {\n            pushStep('compare', {a:largest, b:r});\n            if (a[r] > a[largest]) largest = r;\n          }\n          if (largest !== i) {\n            swap(i, largest);\n            heapify(len, largest);\n          } else {\n            pushStep('heapifyEnd', {i, len});\n          }\n        }\n\n        // Build max heap\n        for (let i = Math.floor(n/2)-1; i >= 0; i--) {\n          heapify(n, i);\n        }\n        pushStep('builtHeap', {});\n\n        // Extract elements from heap one by one\n        for (let end = n-1; end >= 1; end--) {\n          // swap root and end\n          pushStep('aboutToSwapRoot', {root:0, end});\n          swap(0, end);\n          pushStep('markSorted', {index:end});\n          // heapify reduced heap\n          heapify(end, 0);\n        }\n        pushStep('markSorted', {index:0});\n        pushStep('sorted', {});\n        return rec;\n      }\n\n      // Execute a single recorded step (apply visual changes)\n      function applyStep(stepIndex) {\n        if (stepIndex < 0 || stepIndex >= steps.length) return;\n        const st = steps[stepIndex];\n        currentStep = stepIndex;\n        // Update status label and visuals according to step.kind\n        statusLabel.textContent = st.kind;\n        // animate by reading st.snapshot\n        const snap = st.snapshot;\n        array = snap.slice(); // update current array to snapshot for rendering\n        renderAll();\n        // highlight involved nodes/bars\n        clearHighlights();\n        const info = st.info || {};\n        if (st.kind === 'compare') {\n          highlightIndices([info.a, info.b], 'highlight');\n          log(`Compare index ${info.a} (val ${array[info.a]}) and ${info.b} (val ${array[info.b]})`);\n        } else if (st.kind === 'swap') {\n          highlightIndices([info.i, info.j], 'highlight');\n          animateSwap(info.i, info.j);\n          log(`Swap index ${info.i} ⇄ ${info.j}`);\n        } else if (st.kind === 'heapifyStart') {\n          highlightIndices([info.i], 'highlight');\n          log(`Heapify start at index ${info.i}, heap length ${info.len}`);\n        } else if (st.kind === 'heapifyEnd') {\n          highlightIndices([info.i], 'highlight');\n          log(`Heapify end at ${info.i}`);\n        } else if (st.kind === 'aboutToSwapRoot') {\n          highlightIndices([info.root, info.end], 'highlight');\n          log(`About to swap root and end index ${info.end}`);\n        } else if (st.kind === 'markSorted') {\n          markSortedIndex(info.index);\n          log(`Element at index ${info.index} marked sorted.`);\n        } else if (st.kind === 'builtHeap') {\n          log('Max-heap built.');\n        } else if (st.kind === 'sorted') {\n          log('Array sorted.');\n        }\n        updateStepCounter();\n      }\n\n      // Helper: highlight node and bar by indices\n      function clearHighlights() {\n        document.querySelectorAll('.node, .bar').forEach(n=>n.classList.remove('highlight','sorted','bad'));\n      }\n\n      function highlightIndices(indices, cls) {\n        indices.forEach(i=>{\n          const node = nodesLayer.querySelector(`.node[data-index=\"${i}\"]`);\n          const bar = barsEl.querySelector(`.bar[data-index=\"${i}\"]`);\n          if (node) node.classList.add(cls);\n          if (bar) bar.classList.add(cls);\n        });\n      }\n\n      function markSortedIndex(i) {\n        const node = nodesLayer.querySelector(`.node[data-index=\"${i}\"]`);\n        const bar = barsEl.querySelector(`.bar[data-index=\"${i}\"]`);\n        if (node) node.classList.add('sorted');\n        if (bar) bar.classList.add('sorted');\n      }\n\n      // Animate swap visually using CSS transform between two bars\n      function animateSwap(i,j) {\n        // Swap positions in DOM after animation\n        const barI = barsEl.querySelector(`.bar[data-index=\"${i}\"]`);\n        const barJ = barsEl.querySelector(`.bar[data-index=\"${j}\"]`);\n        if (!barI || !barJ) return;\n        const rectI = barI.getBoundingClientRect();\n        const rectJ = barJ.getBoundingClientRect();\n        const dx = rectJ.left - rectI.left;\n\n        // Temporarily transform bars visually, then swap DOM and update attributes\n        barI.style.transition = 'transform 320ms';\n        barJ.style.transition = 'transform 320ms';\n        barI.style.transform = `translateX(${dx}px)`;\n        barJ.style.transform = `translateX(${-dx}px)`;\n\n        setTimeout(()=>{\n          // reset transforms\n          barI.style.transition = '';\n          barJ.style.transition = '';\n          barI.style.transform = '';\n          barJ.style.transform = '';\n          // swap indices/data attributes in DOM to match array order\n          const children = Array.from(barsEl.children);\n          // swap positions in DOM: remove and reinsert\n          if (i < j) {\n            barsEl.insertBefore(barJ, barI);\n            const after = barsEl.children;\n            barsEl.insertBefore(barI, after[i+1]);\n          } else {\n            barsEl.insertBefore(barI, barJ);\n            const after = barsEl.children;\n            barsEl.insertBefore(barJ, after[j+1]);\n          }\n          // Update bar dataset indices to match new array ordering\n          barsEl.querySelectorAll('.bar').forEach((b, idx)=>{\n            b.dataset.index = idx;\n            const val = array[idx];\n            b.querySelector('div:last-child').textContent = val;\n            b.querySelector('.index').textContent = idx;\n            b.setAttribute('aria-label', `Index ${idx}, value ${val}`);\n          });\n          // update tree after swap\n          renderTree();\n        }, 340);\n      }\n\n      // Controls: Build Heap button\n      buildBtn.addEventListener('click', ()=> {\n        if (array.length === 0) return;\n        steps = buildStepsForHeapSort(array).filter(s=>s.kind !== 'markSorted' && s.kind !== 'sorted'); // optionally show build steps only if desired\n        // We want to show the heapify operations and swaps up through builtHeap\n        // Trim after 'builtHeap'\n        const builtIndex = steps.findIndex(s=>s.kind === 'builtHeap');\n        if (builtIndex !== -1) {\n          steps = steps.slice(0, builtIndex+1);\n        }\n        currentStep = -1;\n        updateStepCounter();\n        log('Recorded heapify steps for building max-heap.');\n        // set steps to full build sequence so user can step\n        // But also keep original full steps in a separate var? Simpler: regenerate full on sort click.\n      });\n\n      // Start full Heap Sort and record steps\n      sortBtn.addEventListener('click', ()=> {\n        if (array.length === 0) return;\n        steps = buildStepsForHeapSort(array);\n        currentStep = -1;\n        updateStepCounter();\n        log('Recorded full heap sort steps.');\n      });\n\n      // Next, Prev\n      nextBtn.addEventListener('click', ()=> {\n        if (currentStep < steps.length - 1) {\n          applyStep(currentStep + 1);\n        }\n      });\n      prevBtn.addEventListener('click', ()=> {\n        if (currentStep > 0) {\n          applyStep(currentStep - 1);\n        } else if (currentStep === 0) {\n          // go to initial state\n          currentStep = -1;\n          recordReset();\n          renderAll();\n        }\n      });\n\n      // Play/pause\n      playPauseBtn.addEventListener('click', ()=> {\n        if (!playing) {\n          if (currentStep >= steps.length - 1) {\n            // restart\n            currentStep = -1;\n          }\n          playing = true;\n          playPauseBtn.textContent = 'Pause';\n          statusLabel.textContent = 'Playing';\n          scheduleNext();\n        } else {\n          playing = false;\n          playPauseBtn.textContent = 'Play';\n          statusLabel.textContent = 'Paused';\n          if (playTimer) clearTimeout(playTimer);\n        }\n      });\n\n      function scheduleNext() {\n        if (!playing) return;\n        const delay = Number(speedRange.value) || 700;\n        playTimer = setTimeout(()=>{\n          if (currentStep < steps.length - 1) {\n            applyStep(currentStep + 1);\n            scheduleNext();\n          } else {\n            playing = false;\n            playPauseBtn.textContent = 'Play';\n            statusLabel.textContent = 'Finished';\n          }\n        }, delay);\n      }\n\n      // window resize -> re-render tree positions\n      window.addEventListener('resize', throttle(()=> {\n        renderTree();\n      }, 120));\n\n      // throttle helper\n      function throttle(fn, wait) {\n        let t = null;\n        return function(...args) {\n          if (t) return;\n          t = setTimeout(()=> {\n            t = null;\n            fn.apply(this,args);\n          }, wait);\n        };\n      }\n\n      // Initial load\n      initInitialArray(Number(sizeRange.value));\n\n      // Keyboard accessibility: allow pressing Enter on bars to mark/inspect\n      barsEl.addEventListener('keydown', (e)=>{\n        // handled on per-bar keydown\n      });\n\n      // Start with a random array\n      log('Module ready. Change size and randomize or enter a custom array to begin.');\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Heap Sort.\n\n**Project Overview:**\nTopic: Heap Sort\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Heap Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "d05a0b00-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:47:20.496Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Adjacency List",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Adjacency List — Interactive Module</title>\n  <style>\n    :root{\n      --safe-padding: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #22c1c3;\n      --accent-2: #7dd3fc;\n      --muted: #93a2b8;\n      --success: #16a34a;\n      --danger: #ef4444;\n      --glass: rgba(255,255,255,0.03);\n      --transition: 220ms cubic-bezier(.2,.9,.3,1);\n    }\n\n    /* Safe area margins */\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071022 0%, #082034 40%);\n      color:#e6eef6;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n    body{\n      padding: var(--safe-padding);\n      box-sizing: border-box;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      display:flex;\n      flex-direction:column;\n      gap: var(--gap);\n      min-height:100vh;\n    }\n\n    /* Header */\n    header{\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n    .title{\n      display:flex;\n      align-items:center;\n      gap:12px;\n    }\n    .badge{\n      background:linear-gradient(90deg,var(--accent),var(--accent-2));\n      color:#042027;\n      padding:6px 10px;\n      border-radius:8px;\n      font-weight:600;\n      font-size:14px;\n      box-shadow:0 4px 18px rgba(34,193,195,0.12);\n    }\n    h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing:-0.01em;\n    }\n    p.lead{\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n      max-width:980px;\n    }\n\n    /* Main layout */\n    main{\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      width:100%;\n      flex:1;\n    }\n\n    /* Left: interactive workspace */\n    .workspace{\n      flex:1 1 680px;\n      min-width:260px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:16px;\n      box-shadow: 0 6px 30px rgba(2,6,23,0.5);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .controls{\n      display:flex;\n      gap:var(--gap);\n      flex-wrap:wrap;\n      align-items:center;\n    }\n    button, .toggle{\n      background:var(--glass);\n      border:1px solid rgba(255,255,255,0.04);\n      color:var(--accent-2);\n      padding:8px 12px;\n      border-radius:10px;\n      font-weight:600;\n      cursor:pointer;\n      min-height:40px;\n      transition:all var(--transition);\n    }\n    button:focus{ outline:2px solid rgba(125,211,252,0.15); outline-offset:2px; }\n    .btn-primary{\n      background:linear-gradient(90deg,var(--accent),var(--accent-2));\n      color:#042027;\n      border:0;\n      box-shadow:0 8px 30px rgba(34,193,195,0.12);\n    }\n    .mode{\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n\n    .status{\n      color:var(--muted);\n      font-size:13px;\n      margin-left:auto;\n    }\n\n    /* Canvas area */\n    .canvas-wrap{\n      background:transparent;\n      border-radius:10px;\n      flex:1;\n      min-height:420px;\n      position:relative;\n      overflow:hidden;\n    }\n    svg{\n      width:100%;\n      height:100%;\n      display:block;\n      touch-action:none;\n      user-select:none;\n      cursor:grab;\n    }\n    svg:active{ cursor:grabbing; }\n\n    .instructions{\n      color:var(--muted);\n      font-size:13px;\n      padding:8px 10px;\n    }\n\n    /* Right panel: adjacency list & explanation */\n    .panel{\n      width:360px;\n      min-width:240px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:16px;\n      box-shadow: 0 6px 30px rgba(2,6,23,0.5);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n\n    .panel h3{ margin:0; font-size:15px; color:#fff; }\n    .panel p{ margin:0; color:var(--muted); font-size:13px; }\n\n    .adj-list{\n      display:flex;\n      flex-direction:column;\n      gap:10px;\n      max-height:320px;\n      overflow:auto;\n      padding-right:6px;\n    }\n\n    .node-entry{\n      background: rgba(255,255,255,0.02);\n      border:1px solid rgba(255,255,255,0.03);\n      padding:10px;\n      border-radius:10px;\n      display:flex;\n      gap:10px;\n      align-items:center;\n      transition: transform var(--transition), box-shadow var(--transition);\n    }\n    .node-entry.selected{\n      box-shadow: 0 6px 20px rgba(20,132,142,0.12);\n      transform:translateY(-4px);\n      border-color: rgba(125,211,252,0.18);\n    }\n    .node-key{\n      width:40px;\n      height:40px;\n      border-radius:10px;\n      background:linear-gradient(180deg,#032b30,#06343a);\n      color:var(--accent-2);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:700;\n      font-size:14px;\n      flex-shrink:0;\n    }\n    .neighbors{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n    }\n    .pill{\n      background:rgba(255,255,255,0.03);\n      padding:6px 8px;\n      border-radius:999px;\n      color:var(--muted);\n      font-size:13px;\n      border:1px solid rgba(255,255,255,0.02);\n      display:inline-flex;\n      gap:8px;\n      align-items:center;\n      cursor:pointer;\n      transition: all 180ms ease;\n    }\n    .pill:hover{ transform: translateY(-3px); color:#eaf6fb; }\n\n    /* code block */\n    pre.code{\n      background: rgba(1,6,11,0.6);\n      border-radius:8px;\n      padding:10px;\n      margin:0;\n      color:#cfeffd;\n      font-size:13px;\n      overflow:auto;\n      max-height:130px;\n      border:1px solid rgba(125,211,252,0.06);\n    }\n\n    /* small helpers */\n    .row{ display:flex; gap:var(--gap); align-items:center; }\n    .muted{ color:var(--muted); font-size:13px; }\n    .tiny{ font-size:12px; color:var(--muted); }\n    .kbd{\n      background:rgba(255,255,255,0.03);\n      padding:6px 8px;\n      border-radius:6px;\n      border:1px solid rgba(255,255,255,0.02);\n      font-weight:700;\n      color:var(--muted);\n      font-size:12px;\n    }\n\n    /* animations */\n    .fade-in{\n      animation: fadeIn 260ms ease both;\n    }\n    @keyframes fadeIn{\n      from{ opacity:0; transform: translateY(6px); }\n      to{ opacity:1; transform: translateY(0); }\n    }\n\n    /* Responsive: stack */\n    @media (max-width:980px){\n      main{ flex-direction:column; }\n      .panel{ width:100%; }\n    }\n\n    /* Accessibility focus */\n    button:focus-visible, .pill:focus{ outline:2px solid rgba(125,211,252,0.18); outline-offset:2px; }\n\n    /* Graph styling helpers via classes added by JS */\n    .node-circle{\n      fill: linear-gradient(180deg,#052f35,#06343a);\n      stroke: rgba(255,255,255,0.06);\n      stroke-width:1.5px;\n      transition: transform var(--transition), filter var(--transition);\n      filter: drop-shadow(0 8px 20px rgba(0,0,0,0.4));\n    }\n    .node-text{ pointer-events:none; font-weight:700; fill:#e6eef6; font-size:12px; }\n    .edge-line{\n      stroke: rgba(255,255,255,0.07);\n      stroke-width:2;\n      fill:none;\n      transition: stroke var(--transition);\n    }\n    .edge-highlight{\n      stroke: linear-gradient(90deg,var(--accent),var(--accent-2));\n      stroke: rgba(34,193,195,0.9);\n      stroke-width:3.6;\n    }\n    .node-selected{\n      transform: scale(1.06);\n      filter: drop-shadow(0 14px 30px rgba(34,193,195,0.08));\n    }\n\n  </style>\n</head>\n<body>\n  <header>\n    <div class=\"title\">\n      <div class=\"badge\">Data Structure</div>\n      <h1>Adjacency List — Visual, Editable, Interactive</h1>\n    </div>\n    <p class=\"lead\">Explore how adjacency lists represent graphs. Add nodes, create edges (directed or undirected), drag nodes around, and watch the adjacency list update instantly with smooth animations and live code-like representation.</p>\n  </header>\n\n  <main>\n    <!-- LEFT: Workspace -->\n    <section class=\"workspace\" aria-label=\"Graph workspace\">\n      <div class=\"controls\" role=\"toolbar\" aria-label=\"Graph controls\">\n        <div class=\"mode\" style=\"gap:8px;\">\n          <button id=\"btnAddNode\" class=\"btn-primary\" title=\"Add a node (then click canvas to place) or press N\">Add Node (N)</button>\n          <button id=\"btnAddEdge\" title=\"Toggle Add Edge mode\">Add Edge</button>\n          <button id=\"btnDelete\" title=\"Delete selected node or edge\">Delete</button>\n          <button id=\"btnClear\" title=\"Clear graph\">Clear</button>\n        </div>\n\n        <label class=\"toggle\" title=\"Toggle directed/undirected graph\" style=\"display:inline-flex; align-items:center; gap:8px;\">\n          <input id=\"directedToggle\" type=\"checkbox\" aria-label=\"Directed edges\" style=\"display:none;\">\n          <span id=\"directedVisual\" style=\"padding:6px 8px; border-radius:8px; background:rgba(255,255,255,0.02); color:var(--accent-2); font-weight:700;\">Undirected</span>\n        </label>\n\n        <div class=\"status\" id=\"status\">Mode: Browse • Nodes: 0 • Edges: 0</div>\n      </div>\n\n      <div class=\"canvas-wrap\" aria-hidden=\"false\" role=\"region\" aria-label=\"Graph canvas\">\n        <svg id=\"svgCanvas\" viewBox=\"0 0 1200 700\" preserveAspectRatio=\"xMidYMid meet\" tabindex=\"0\" aria-label=\"Interactive graph area\">\n          <defs>\n            <marker id=\"arrowhead\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\" markerWidth=\"8\" markerHeight=\"8\" orient=\"auto-start-reverse\">\n              <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#16a3a5\"></path>\n            </marker>\n          </defs>\n\n          <!-- edges group -->\n          <g id=\"edges\"></g>\n\n          <!-- nodes group -->\n          <g id=\"nodes\"></g>\n        </svg>\n\n        <div class=\"instructions tiny\" id=\"instructions\" style=\"position:absolute; bottom:12px; left:12px;\">\n          Click nodes to select. Drag to move. In \"Add Edge\", click two nodes to create an edge.\n        </div>\n      </div>\n    </section>\n\n    <!-- RIGHT: Adjacency List Panel -->\n    <aside class=\"panel\" aria-label=\"Adjacency list and explanation\">\n      <div>\n        <h3>Learning Objective</h3>\n        <p>After using this module you will be able to: understand how adjacency lists store graph connectivity, see how operations (adding/removing edges/nodes) update the structure, and read an adjacency-list representation as a JavaScript-like object.</p>\n      </div>\n\n      <div>\n        <h3>Interaction Design</h3>\n        <p class=\"tiny muted\">\n          - Add Node: click \"Add Node\" then click on the canvas to place a node (or press N to auto-place).<br>\n          - Add Edge: toggle \"Add Edge\", then click two nodes: the first is source, the second is destination. If \"Directed\" is on, an arrow is drawn; otherwise an undirected connection is created.<br>\n          - Select: click any node to highlight it and reveal its neighbors in the adjacency list. Click a neighbor pill to highlight that node in the canvas.<br>\n          - Drag: click and drag nodes to reposition; edges and the adjacency view update in real time.<br>\n          - Delete: delete selected node (removes its incident edges) or click an edge to remove it. All UI updates animate for clarity.\n        </p>\n      </div>\n\n      <div>\n        <h3>Layout Description</h3>\n        <p class=\"tiny muted\">\n          Safe area: 24px padding around the viewport. Minimum spacing between interactive elements: 16px. The page uses a two-column layout: the left column is the interactive canvas with controls above; the right column is a compact panel showing the adjacency list, a live code representation, and textual instructions. On narrow screens the layout stacks vertically. Controls use clear affordances and high-contrast color; buttons and pills are keyboard-focusable for accessibility.\n        </p>\n      </div>\n\n      <div>\n        <h3>Adjacency List (visual)</h3>\n        <div class=\"adj-list\" id=\"adjList\" aria-live=\"polite\" aria-atomic=\"true\">\n          <!-- entries inserted here -->\n        </div>\n      </div>\n\n      <div>\n        <h3>Adjacency List (code)</h3>\n        <pre class=\"code\" id=\"codeBlock\">// Empty graph</pre>\n      </div>\n\n      <div style=\"display:flex; justify-content:space-between; gap:10px; align-items:center;\">\n        <div class=\"tiny muted\">Click a node to inspect its adjacency list.</div>\n        <div>\n          <span class=\"kbd\">Drag</span>\n        </div>\n      </div>\n    </aside>\n  </main>\n\n  <script>\n    // Adjacency List Interactive Module\n    // Self-contained, vanilla JS/CSS/HTML\n    (function(){\n      // Basic state\n      const state = {\n        nodes: [], // {id, x, y, label}\n        edges: [], // {id, a, b, directed}\n        adj: {},   // adjacency list: {id: [neighborIds...]}\n        nextNodeId: 1,\n        nextEdgeId: 1,\n        mode: 'browse', // 'browse' | 'addNode' | 'addEdge' | 'delete'\n        addEdgeFirst: null,\n        directed: false,\n        selectedNode: null,\n        selectedEdge: null,\n      };\n\n      // Element refs\n      const svg = document.getElementById('svgCanvas');\n      const nodesGroup = document.getElementById('nodes');\n      const edgesGroup = document.getElementById('edges');\n      const btnAddNode = document.getElementById('btnAddNode');\n      const btnAddEdge = document.getElementById('btnAddEdge');\n      const btnDelete = document.getElementById('btnDelete');\n      const btnClear = document.getElementById('btnClear');\n      const status = document.getElementById('status');\n      const directedToggle = document.getElementById('directedToggle');\n      const directedVisual = document.getElementById('directedVisual');\n      const adjListEl = document.getElementById('adjList');\n      const codeBlock = document.getElementById('codeBlock');\n      const instructions = document.getElementById('instructions');\n\n      // Helper utilities\n      const ns = \"http://www.w3.org/2000/svg\";\n      function createNodeElement(node){\n        const g = document.createElementNS(ns,'g');\n        g.setAttribute('data-id', node.id);\n        g.setAttribute('class','node');\n        g.setAttribute('transform', `translate(${node.x} ${node.y})`);\n        g.style.cursor = 'grab';\n        // circle\n        const circle = document.createElementNS(ns,'circle');\n        circle.setAttribute('r', 26);\n        circle.setAttribute('class','node-circle');\n        circle.setAttribute('fill', '#052f35');\n        circle.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n        circle.setAttribute('stroke-width', '1.5');\n\n        // label\n        const text = document.createElementNS(ns,'text');\n        text.setAttribute('class','node-text');\n        text.setAttribute('text-anchor','middle');\n        text.setAttribute('dy','5');\n        text.textContent = node.label;\n\n        // append\n        g.appendChild(circle);\n        g.appendChild(text);\n\n        // event listeners\n        g.tabIndex = 0;\n        g.addEventListener('pointerdown', nodePointerDown);\n        g.addEventListener('click', nodeClick);\n        g.addEventListener('keydown', (e) => {\n          if(e.key === 'Enter') nodeClick(e);\n        });\n\n        return g;\n      }\n\n      function createEdgeElement(edge){\n        const g = document.createElementNS(ns,'g');\n        g.setAttribute('data-id', edge.id);\n        g.setAttribute('class','edge-group');\n\n        const line = document.createElementNS(ns,'path');\n        line.setAttribute('class','edge-line');\n        line.setAttribute('fill','none');\n        line.setAttribute('stroke-linecap','round');\n        line.setAttribute('stroke-linejoin','round');\n        if(edge.directed){\n          line.setAttribute('marker-end','url(#arrowhead)');\n        } else {\n          line.removeAttribute('marker-end');\n        }\n        g.appendChild(line);\n\n        // clickable hit area for deletion (wider transparent stroke)\n        const hit = document.createElementNS(ns,'path');\n        hit.setAttribute('class','edge-hit');\n        hit.setAttribute('fill','none');\n        hit.setAttribute('stroke','transparent');\n        hit.setAttribute('stroke-width','18');\n        hit.style.cursor = 'pointer';\n        hit.addEventListener('click',(e)=> {\n          e.stopPropagation();\n          selectEdge(edge.id);\n        });\n        g.appendChild(hit);\n\n        return g;\n      }\n\n      // Render functions\n      function render(){\n        renderEdges();\n        renderNodes();\n        renderAdjList();\n        renderCode();\n        updateStatus();\n      }\n\n      function renderNodes(){\n        // Clear and re-add\n        nodesGroup.innerHTML = '';\n        for(const n of state.nodes){\n          const el = createNodeElement(n);\n          nodesGroup.appendChild(el);\n          if(state.selectedNode === n.id){\n            el.querySelector('circle').classList.add('node-selected');\n          }\n        }\n        // Update transforms\n        requestAnimationFrame(()=> {\n          for(const g of nodesGroup.querySelectorAll('g.node')){\n            const id = +g.getAttribute('data-id');\n            const node = state.nodes.find(x=>x.id===id);\n            if(node) g.setAttribute('transform', `translate(${node.x} ${node.y})`);\n          }\n        });\n      }\n\n      function renderEdges(){\n        edgesGroup.innerHTML = '';\n        for(const e of state.edges){\n          const g = createEdgeElement(e);\n          edgesGroup.appendChild(g);\n          updateEdgeElement(e);\n        }\n      }\n\n      function updateEdgeElement(edge){\n        const g = edgesGroup.querySelector(`[data-id=\"${edge.id}\"]`);\n        if(!g) return;\n        const path = g.querySelector('path.edge-line');\n        const hit = g.querySelector('path.edge-hit');\n\n        const a = state.nodes.find(n=>n.id===edge.a);\n        const b = state.nodes.find(n=>n.id===edge.b);\n        if(!a || !b) return;\n        // compute a nice path (curved if needed)\n        const dx = b.x - a.x;\n        const dy = b.y - a.y;\n        const dist = Math.hypot(dx,dy);\n        const offset = Math.min(40, dist*0.2);\n        const nx = dx / dist || 0;\n        const ny = dy / dist || 0;\n        const cx = (a.x + b.x)/2 - ny * offset;\n        const cy = (a.y + b.y)/2 + nx * offset;\n        const d = `M ${a.x} ${a.y} Q ${cx} ${cy} ${b.x} ${b.y}`;\n        // animate stroke drawing\n        path.setAttribute('d', d);\n        hit.setAttribute('d', d);\n        // stroke dash animation\n        path.style.transition = 'stroke-dashoffset 420ms ease, stroke 220ms ease';\n        path.style.stroke = (state.selectedEdge===edge.id) ? 'rgba(125,211,252,0.95)' : 'rgba(255,255,255,0.07)';\n        if(edge.directed){\n          path.setAttribute('marker-end','url(#arrowhead)');\n        } else {\n          path.removeAttribute('marker-end');\n        }\n        // create an animated draw effect\n        const length = path.getTotalLength ? path.getTotalLength() : dist * 1.2;\n        path.style.strokeDasharray = length;\n        path.style.strokeDashoffset = length;\n        requestAnimationFrame(()=> {\n          path.style.strokeDashoffset = 0;\n        });\n      }\n\n      function renderAdjList(){\n        adjListEl.innerHTML = '';\n        // For visual clarity, sort nodes by id\n        const nodesSorted = state.nodes.slice().sort((a,b)=>a.id - b.id);\n        for(const n of nodesSorted){\n          const entry = document.createElement('div');\n          entry.className = 'node-entry fade-in';\n          if(state.selectedNode === n.id) entry.classList.add('selected');\n          entry.setAttribute('data-id', n.id);\n\n          const key = document.createElement('div');\n          key.className = 'node-key';\n          key.textContent = n.label;\n\n          const neighbors = document.createElement('div');\n          neighbors.className = 'neighbors';\n\n          const list = state.adj[n.id] ? state.adj[n.id].slice() : [];\n          if(list.length === 0){\n            const none = document.createElement('div');\n            none.className = 'pill';\n            none.textContent = '—';\n            neighbors.appendChild(none);\n          } else {\n            for(const nb of list){\n              const pill = document.createElement('button');\n              pill.className = 'pill';\n              pill.textContent = (state.nodes.find(s=>s.id===nb) || {label:'?'}).label;\n              pill.setAttribute('aria-label', 'Highlight node ' + pill.textContent);\n              pill.addEventListener('click', ()=> {\n                // highlight node on canvas\n                selectNode(nb);\n                pulseNode(nb);\n              });\n              neighbors.appendChild(pill);\n            }\n          }\n\n          entry.appendChild(key);\n          entry.appendChild(neighbors);\n          adjListEl.appendChild(entry);\n        }\n      }\n\n      function renderCode(){\n        // Build a JS-like object string\n        const lines = [];\n        lines.push('const adjacencyList = {');\n        for(const n of state.nodes.sort((a,b)=>a.id-b.id)){\n          const arr = (state.adj[n.id] || []).map(id => {\n            const lab = (state.nodes.find(s=>s.id===id) || {}).label || id;\n            return `${id} /* ${lab} */`;\n          });\n          lines.push(`  ${n.id}: [ ${arr.join(', ')} ],`);\n        }\n        lines.push('};');\n        if(state.nodes.length===0) codeBlock.textContent = '// Empty graph';\n        else codeBlock.textContent = lines.join('\\n');\n      }\n\n      function updateStatus(){\n        status.textContent = `Mode: ${state.mode === 'browse' ? 'Browse' : state.mode === 'addEdge' ? 'Add Edge' : state.mode === 'addNode' ? 'Add Node' : 'Delete'} • Nodes: ${state.nodes.length} • Edges: ${state.edges.length}`;\n        directedVisual.textContent = state.directed ? 'Directed' : 'Undirected';\n      }\n\n      // Selection logic\n      function selectNode(id){\n        state.selectedNode = id;\n        state.selectedEdge = null;\n        // highlight node visually\n        highlightNode(id);\n        render();\n      }\n\n      function selectEdge(edgeId){\n        state.selectedEdge = edgeId;\n        state.selectedNode = null;\n        render();\n      }\n\n      function highlightNode(id){\n        // temporarily enlarge circle\n        for(const g of nodesGroup.querySelectorAll('g.node')){\n          const nid = +g.getAttribute('data-id');\n          const circle = g.querySelector('circle');\n          if(nid === id){\n            circle.classList.add('node-selected');\n            g.querySelector('text').style.fill = '#e6eef6';\n          } else {\n            circle.classList.remove('node-selected');\n          }\n        }\n      }\n\n      function pulseNode(id){\n        // quick animation to draw attention\n        const g = nodesGroup.querySelector(`g.node[data-id=\"${id}\"]`);\n        if(!g) return;\n        const c = g.querySelector('circle');\n        c.animate([\n          { transform: 'scale(1)', filter: 'drop-shadow(0 8px 20px rgba(0,0,0,0.4))' },\n          { transform: 'scale(1.12)', filter: 'drop-shadow(0 20px 40px rgba(34,193,195,0.09))' },\n          { transform: 'scale(1)' }\n        ], { duration: 420, easing: 'cubic-bezier(.2,.9,.3,1)' });\n      }\n\n      // Graph modification functions\n      function addNodeAt(x,y){\n        const id = state.nextNodeId++;\n        const label = String(id);\n        const node = { id, x, y, label };\n        state.nodes.push(node);\n        state.adj[id] = [];\n        render();\n        // auto-select the new node\n        selectNode(id);\n      }\n\n      function addEdge(a, b, directed){\n        // prevent duplicates\n        const exists = state.edges.find(e => (e.a === a && e.b === b && e.directed === !!directed) || (!e.directed && !directed && ((e.a===a && e.b===b)||(e.a===b && e.b===a))));\n        if(exists) return;\n        const id = state.nextEdgeId++;\n        const edge = { id, a, b, directed: !!directed };\n        state.edges.push(edge);\n        // update adj lists\n        if(!state.adj[a]) state.adj[a] = [];\n        if(!state.adj[b]) state.adj[b] = [];\n        state.adj[a].push(b);\n        if(!directed){\n          state.adj[b].push(a);\n        }\n        render();\n        // highlight the new edge\n        state.selectedEdge = id;\n        setTimeout(()=> state.selectedEdge = null, 900);\n      }\n\n      function removeNode(id){\n        // remove node, its edges and references\n        state.nodes = state.nodes.filter(n=>n.id!==id);\n        state.edges = state.edges.filter(e=>e.a!==id && e.b!==id);\n        delete state.adj[id];\n        for(const k in state.adj){\n          state.adj[k] = state.adj[k].filter(v=>v!==id);\n        }\n        if(state.selectedNode === id) state.selectedNode = null;\n        render();\n      }\n\n      function removeEdge(id){\n        const edge = state.edges.find(e=>e.id===id);\n        if(!edge) return;\n        // remove from edges\n        state.edges = state.edges.filter(e=>e.id!==id);\n        // update adjacency lists\n        state.adj[edge.a] = (state.adj[edge.a]||[]).filter(v=>v!==edge.b);\n        if(!edge.directed){\n          state.adj[edge.b] = (state.adj[edge.b]||[]).filter(v=>v!==edge.a);\n        }\n        if(state.selectedEdge === id) state.selectedEdge = null;\n        render();\n      }\n\n      function clearGraph(){\n        state.nodes = [];\n        state.edges = [];\n        state.adj = {};\n        state.nextNodeId = 1;\n        state.nextEdgeId = 1;\n        state.selectedNode = null;\n        state.selectedEdge = null;\n        render();\n      }\n\n      // Event handlers for nodes (dragging etc)\n      let dragging = null;\n      let pointerOffset = {x:0,y:0};\n      function nodePointerDown(e){\n        e.stopPropagation();\n        const g = e.currentTarget;\n        const id = +g.getAttribute('data-id');\n        if(state.mode === 'addEdge'){\n          // treat as part of add-edge flow\n          if(state.addEdgeFirst == null){\n            state.addEdgeFirst = id;\n            // brief visual\n            selectNode(id);\n            instructions.textContent = 'Select second node to complete the edge (or click same to cancel).';\n          } else {\n            if(state.addEdgeFirst === id){\n              // cancel\n              state.addEdgeFirst = null;\n              instructions.textContent = 'Add Edge canceled.';\n            } else {\n              addEdge(state.addEdgeFirst, id, state.directed);\n              state.addEdgeFirst = null;\n              instructions.textContent = 'Edge added.';\n            }\n          }\n          return;\n        }\n\n        // if delete mode, select node for deletion\n        if(state.mode === 'delete'){\n          selectNode(id);\n          removeNode(id);\n          instructions.textContent = 'Node deleted.';\n          return;\n        }\n\n        // otherwise begin dragging\n        dragging = id;\n        const pt = getPoint(e);\n        const node = state.nodes.find(n=>n.id===id);\n        pointerOffset.x = pt.x - node.x;\n        pointerOffset.y = pt.y - node.y;\n        this.setPointerCapture(e.pointerId);\n        this.style.cursor = 'grabbing';\n      }\n\n      function nodeClick(e){\n        e.stopPropagation();\n        const id = +e.currentTarget.getAttribute('data-id');\n        // Select node\n        selectNode(id);\n        instructions.textContent = 'Node selected.';\n      }\n\n      function svgPointerDown(e){\n        // place node if in addNode mode\n        if(state.mode === 'addNode'){\n          const pt = getPoint(e);\n          addNodeAt(pt.x, pt.y);\n          state.mode = 'browse';\n          instructions.textContent = 'Node placed.';\n          render();\n        } else {\n          // clear selections\n          state.selectedNode = null;\n          state.selectedEdge = null;\n          state.addEdgeFirst = null;\n          render();\n        }\n      }\n\n      // pointer move/up on svg for dragging\n      svg.addEventListener('pointermove', (e)=>{\n        if(!dragging) return;\n        const pt = getPoint(e);\n        const node = state.nodes.find(n=>n.id===dragging);\n        if(!node) return;\n        node.x = Math.max(40, Math.min(pt.x - pointerOffset.x, 1160));\n        node.y = Math.max(40, Math.min(pt.y - pointerOffset.y, 660));\n        // update edges connected to this node\n        for(const ed of state.edges.filter(ed => ed.a === node.id || ed.b === node.id)){\n          updateEdgeElement(ed);\n        }\n        // update node position transform\n        const g = nodesGroup.querySelector(`g.node[data-id=\"${node.id}\"]`);\n        if(g) g.setAttribute('transform', `translate(${node.x} ${node.y})`);\n      });\n\n      svg.addEventListener('pointerup', (e)=>{\n        if(dragging){\n          const g = nodesGroup.querySelector(`g.node[data-id=\"${dragging}\"]`);\n          if(g) g.style.cursor = 'grab';\n          dragging = null;\n          render();\n        }\n      });\n\n      svg.addEventListener('click', svgPointerDown);\n      svg.addEventListener('contextmenu', (e)=> e.preventDefault());\n\n      // UI control handlers\n      btnAddNode.addEventListener('click', ()=> {\n        state.mode = state.mode === 'addNode' ? 'browse' : 'addNode';\n        instructions.textContent = state.mode === 'addNode' ? 'Click anywhere on the canvas to place the new node.' : 'Cancelled node placement.';\n        render();\n      });\n      btnAddEdge.addEventListener('click', ()=> {\n        state.mode = state.mode === 'addEdge' ? 'browse' : 'addEdge';\n        state.addEdgeFirst = null;\n        instructions.textContent = state.mode === 'addEdge' ? 'Add Edge: select source node.' : 'Add Edge cancelled.';\n        render();\n      });\n      btnDelete.addEventListener('click', ()=> {\n        state.mode = state.mode === 'delete' ? 'browse' : 'delete';\n        instructions.textContent = state.mode === 'delete' ? 'Delete mode: click a node or edge to remove it.' : 'Delete cancelled.';\n        render();\n      });\n      btnClear.addEventListener('click', ()=>{\n        if(confirm('Clear all nodes and edges?')) clearGraph();\n      });\n\n      directedToggle.addEventListener('change', (e)=>{\n        state.directed = e.target.checked;\n        render();\n      });\n\n      // keyboard shortcuts\n      window.addEventListener('keydown', (e)=>{\n        if(e.key === 'n' || e.key === 'N'){\n          state.mode = 'addNode';\n          instructions.textContent = 'Press N: Click on canvas to place node.';\n          render();\n        } else if(e.key === 'Escape'){\n          state.mode = 'browse';\n          state.addEdgeFirst = null;\n          instructions.textContent = 'Mode reset.';\n          render();\n        } else if(e.key === 'Delete' || e.key === 'Backspace'){\n          if(state.selectedNode) removeNode(state.selectedNode);\n          else if(state.selectedEdge) removeEdge(state.selectedEdge);\n        }\n      });\n\n      // Utility: get mouse position relative to SVG coordinate system\n      function getPoint(evt){\n        const pt = svg.createSVGPoint();\n        pt.x = evt.clientX;\n        pt.y = evt.clientY;\n        const ctm = svg.getScreenCTM();\n        if(ctm) return pt.matrixTransform(ctm.inverse());\n        return {x: evt.offsetX, y: evt.offsetY};\n      }\n\n      // Initial guidance: populate with a small example\n      (function seedExample(){\n        // center-ish positions mapped to viewBox 1200x700\n        addNodeAt(250, 200); // 1\n        addNodeAt(430, 140); // 2\n        addNodeAt(550, 280); // 3\n        addNodeAt(350, 360); // 4\n        addNodeAt(720, 200); // 5\n        addEdge(1,2,false);\n        addEdge(1,4,false);\n        addEdge(2,3,false);\n        addEdge(3,5,true);\n        state.selectedNode = 1;\n        render();\n      })();\n\n      // Accessibility: clicking outside clears selection\n      document.body.addEventListener('click', (e)=>{\n        const inside = e.target.closest('.panel') || e.target.closest('.workspace');\n        if(!inside){\n          state.selectedNode = null;\n          state.selectedEdge = null;\n          render();\n        }\n      });\n\n      // Expose some functions for console debugging (optional)\n      window.__adj = {\n        state,\n        addNodeAt,\n        addEdge,\n        removeNode,\n        removeEdge,\n        clearGraph,\n      };\n\n      // Initial render call (ensures UI elements reflect state)\n      render();\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Adjacency List.\n\n**Project Overview:**\nTopic: Adjacency List\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Adjacency List"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "d0b7bb60-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:47:21.110Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Insertion Sort",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Insertion Sort — Interactive Explorer</title>\n  <style>\n    :root{\n      --safe-margin:24px;\n      --gap:16px;\n      --bg:#0f1720;\n      --panel:#0b1220;\n      --card:#0f1b2a;\n      --muted:#9aa7b7;\n      --accent:#3ea3ff;\n      --accent-2:#7df0a4;\n      --text:#e6eef6;\n      --danger:#ff6b6b;\n      --control-bg:#111827;\n      --speed-default:400; /* ms */\n    }\n    /* Safe area and base */\n    html,body{\n      height:100%;\n      margin:0;\n      padding:0;\n      background:linear-gradient(180deg,#071023 0%, #0b1622 100%);\n      color:var(--text);\n      font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    main{\n      padding:var(--safe-margin);\n      box-sizing:border-box;\n      min-height:100vh;\n      display:flex;\n      justify-content:center;\n      align-items:flex-start;\n    }\n    .container{\n      width:100%;\n      max-width:1200px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    header{\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n    .title{\n      font-size:20px;\n      font-weight:700;\n      letter-spacing:-0.2px;\n    }\n    .subtitle{\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* Layout: two-column responsive */\n    .module{\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      flex-wrap:wrap;\n    }\n\n    /* Left column: info + controls */\n    .left{\n      flex:1 1 340px;\n      min-width:280px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:16px;\n      box-sizing:border-box;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .panel-section{\n      margin-bottom:12px;\n    }\n    .label{\n      font-size:12px;\n      color:var(--muted);\n      margin-bottom:8px;\n    }\n    .desc{\n      font-size:13px;\n      color:var(--text);\n      line-height:1.4;\n    }\n    .controls{\n      display:flex;\n      flex-wrap:wrap;\n      gap:var(--gap);\n      margin-top:8px;\n      align-items:center;\n    }\n    .controls button, .controls input[type=\"text\"], .controls select{\n      background:var(--control-bg);\n      color:var(--text);\n      border:1px solid rgba(255,255,255,0.03);\n      padding:10px 12px;\n      border-radius:8px;\n      min-height:40px;\n      font-size:14px;\n      cursor:pointer;\n    }\n    .controls button:active{ transform:translateY(1px);}\n    .controls button[aria-pressed=\"true\"]{\n      outline:2px solid rgba(62,163,255,0.18);\n      box-shadow:0 4px 18px rgba(62,163,255,0.06);\n    }\n    .controls input[type=\"text\"]{\n      flex:1 1 180px;\n      min-width:120px;\n    }\n    .small{\n      background:var(--panel);\n      padding:8px;\n      border-radius:8px;\n      display:flex;\n      gap:8px;\n      align-items:center;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .speed{\n      display:flex;\n      align-items:center;\n      gap:8px;\n    }\n    .speed input[type=\"range\"]{\n      width:160px;\n    }\n\n    /* Right column: visual + pseudocode */\n    .right{\n      flex:2 1 560px;\n      min-width:300px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .visual-card{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:16px;\n      box-sizing:border-box;\n      border:1px solid rgba(255,255,255,0.03);\n      min-height:220px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n\n    .array-area{\n      position:relative;\n      height:120px;\n      background:linear-gradient(90deg, rgba(255,255,255,0.006), transparent);\n      border-radius:8px;\n      padding:12px;\n      box-sizing:border-box;\n      overflow:hidden;\n    }\n    .bars{\n      position:relative;\n      height:100%;\n      width:100%;\n      box-sizing:border-box;\n    }\n    .bar{\n      position:absolute;\n      top:50%;\n      transform:translateY(-50%);\n      height:64px;\n      min-width:44px;\n      padding:6px;\n      box-sizing:border-box;\n      border-radius:8px;\n      display:inline-flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:700;\n      color:var(--text);\n      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      transition: transform 400ms cubic-bezier(.2,.9,.3,1), background-color 180ms, box-shadow 180ms;\n      will-change:transform, background-color;\n      user-select:none;\n    }\n    .bar .value{\n      font-size:14px;\n      color:var(--text);\n    }\n    .index-label{\n      position:absolute;\n      top:6px;\n      left:6px;\n      font-size:11px;\n      color:var(--muted);\n    }\n    .bar.key{\n      background:linear-gradient(180deg, rgba(62,163,255,0.14), rgba(62,163,255,0.06));\n      box-shadow:0 6px 18px rgba(62,163,255,0.06);\n      transform:translateY(-65%) scale(1.03);\n      z-index:20;\n    }\n    .bar.compare{\n      background:linear-gradient(180deg, rgba(255,183,77,0.12), rgba(255,183,77,0.04));\n      box-shadow:0 8px 20px rgba(255,183,77,0.06);\n    }\n    .bar.shifted{\n      background:linear-gradient(180deg, rgba(125,240,164,0.08), rgba(125,240,164,0.02));\n      box-shadow:0 6px 18px rgba(125,240,164,0.06);\n    }\n\n    .pseudocode{\n      background:var(--panel);\n      border-radius:8px;\n      padding:12px;\n      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;\n      font-size:13px;\n      color:var(--muted);\n      overflow:auto;\n      max-height:200px;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .code-line{\n      padding:6px 8px;\n      border-radius:6px;\n    }\n    .code-line.active{\n      background:linear-gradient(90deg, rgba(62,163,255,0.08), rgba(62,163,255,0.04));\n      color:var(--text);\n      box-shadow:inset 0 0 0 1px rgba(62,163,255,0.06);\n    }\n\n    /* Footer info */\n    .legend{\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .legend .item{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      background:rgba(255,255,255,0.02);\n      padding:8px;\n      border-radius:8px;\n    }\n    .dot{\n      width:14px;\n      height:14px;\n      border-radius:4px;\n      background:var(--muted);\n    }\n    .dot.key{ background:linear-gradient(180deg, rgba(62,163,255,0.9), rgba(30,130,240,0.9));}\n    .dot.compare{ background:linear-gradient(180deg, rgba(255,183,77,0.9), rgba(240,150,40,0.9));}\n    .dot.shift{ background:linear-gradient(180deg, rgba(125,240,164,0.9), rgba(70,200,120,0.9));}\n\n    /* small screens */\n    @media (max-width:880px){\n      .module{ flex-direction:column; }\n      .right{ order:2; }\n    }\n  </style>\n</head>\n<body>\n  <main>\n    <div class=\"container\" role=\"main\">\n      <header>\n        <div class=\"title\">Insertion Sort — Interactive Explorer</div>\n        <div class=\"subtitle\">Step through insertion sort with animated shifts, inspect pseudocode, and try your own arrays.</div>\n      </header>\n\n      <section class=\"module\" aria-labelledby=\"module-title\">\n        <!-- Left: Info + Controls -->\n        <aside class=\"left\" aria-label=\"Controls and explanation\">\n          <div class=\"panel-section\" aria-hidden=\"false\">\n            <div class=\"label\">Concept Title</div>\n            <div class=\"desc\"><strong>Insertion Sort (in-place, stable)</strong> — build a sorted segment on the left by inserting the current element at its correct position.</div>\n          </div>\n\n          <div class=\"panel-section\">\n            <div class=\"label\">Learning Objective</div>\n            <div class=\"desc\">\n              After interacting you will be able to:\n              <ul style=\"margin:8px 0 0 18px;\">\n                <li>Visualize how insertion sort shifts elements to make room for the key.</li>\n                <li>Follow the algorithm step-by-step and map actions to pseudocode.</li>\n                <li>Experiment with different input arrays and animation speeds.</li>\n              </ul>\n            </div>\n          </div>\n\n          <div class=\"panel-section\">\n            <div class=\"label\">Interaction Design</div>\n            <div class=\"desc\">\n              Controls and interactions:\n              <ul style=\"margin:8px 0 0 18px;\">\n                <li>Enter a comma-separated list of numbers or press Randomize to create an array.</li>\n                <li>Step Forward / Back through the prepared action list — every action animates (select key, compare, shift, place).</li>\n                <li>Play will animate actions sequentially using the speed slider; Pause stops playback.</li>\n                <li>Pseudocode lines are highlighted to link visual actions to code flow.</li>\n              </ul>\n            </div>\n          </div>\n\n          <div class=\"panel-section\">\n            <div class=\"label\">Layout Description</div>\n            <div class=\"desc\">\n              The page uses a responsive two-column layout:\n              <ul style=\"margin:8px 0 0 18px;\">\n                <li>Left column: text, input form and controls (min-width 280px).</li>\n                <li>Right column: visual array + pseudocode (flexible, larger area).</li>\n                <li>Safe margins are 24px around the viewport and minimum spacing between interactive elements is 16px.</li>\n              </ul>\n            </div>\n          </div>\n\n          <div class=\"panel-section\">\n            <div class=\"label\">Array Input</div>\n            <div style=\"display:flex;gap:12px;align-items:center;\">\n              <input id=\"arrayInput\" type=\"text\" aria-label=\"Array input\" placeholder=\"e.g. 5,3,8,1,4\" />\n              <button id=\"setArrayBtn\" title=\"Set array\">Set</button>\n              <button id=\"randomBtn\" title=\"Randomize\">Randomize</button>\n            </div>\n            <div style=\"margin-top:10px;font-size:13px;color:var(--muted)\">Elements will be clamped to integers between -999 and 999. Max length: 12.</div>\n          </div>\n\n          <div class=\"panel-section\">\n            <div class=\"label\">Controls</div>\n            <div class=\"controls\" role=\"toolbar\" aria-label=\"Playback controls\">\n              <button id=\"stepBack\" title=\"Step Back\" aria-label=\"Step Back\">⟲ Back</button>\n              <button id=\"stepForward\" title=\"Step Forward\" aria-label=\"Step Forward\">Forward ⟳</button>\n              <button id=\"playPause\" title=\"Play\" aria-pressed=\"false\" aria-label=\"Play or pause\">Play ▶</button>\n              <button id=\"resetBtn\" title=\"Reset\">Reset</button>\n            </div>\n            <div style=\"margin-top:10px;display:flex;gap:12px;align-items:center;flex-wrap:wrap;\">\n              <div class=\"small\" title=\"Current action index\">\n                <div style=\"font-weight:700\" id=\"actionCounter\">Action 0 / 0</div>\n              </div>\n              <div class=\"small\" title=\"Array length\">\n                Length: <strong id=\"arrayLen\" style=\"margin-left:6px\">0</strong>\n              </div>\n            </div>\n          </div>\n\n          <div class=\"panel-section\">\n            <div class=\"label\">Playback Speed</div>\n            <div class=\"speed\">\n              <input id=\"speedRange\" type=\"range\" min=\"80\" max=\"1200\" value=\"400\" aria-label=\"Animation speed\" />\n              <div class=\"small\">Speed: <strong id=\"speedLabel\" style=\"margin-left:8px\">400ms</strong></div>\n            </div>\n          </div>\n\n          <div class=\"panel-section\">\n            <div class=\"label\">Legend</div>\n            <div class=\"legend\" aria-hidden=\"false\">\n              <div class=\"item\"><div class=\"dot key\" aria-hidden=\"true\"></div><div>Key (being inserted)</div></div>\n              <div class=\"item\"><div class=\"dot compare\" aria-hidden=\"true\"></div><div>Comparing</div></div>\n              <div class=\"item\"><div class=\"dot shift\" aria-hidden=\"true\"></div><div>Shifted to the right</div></div>\n            </div>\n          </div>\n        </aside>\n\n        <!-- Right: Visual + Pseudocode -->\n        <section class=\"right\" aria-label=\"Visualization\">\n          <div class=\"visual-card\" role=\"region\" aria-label=\"Array visualization\">\n            <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n              <div style=\"font-weight:700\">Array Visualization</div>\n              <div style=\"color:var(--muted);font-size:13px\">Insertion Sort — animated shifts</div>\n            </div>\n\n            <div class=\"array-area\" id=\"arrayArea\" aria-live=\"polite\">\n              <div class=\"index-label\" id=\"indicesHint\">Indices: 0 .. n-1</div>\n              <div class=\"bars\" id=\"barsContainer\" aria-hidden=\"false\"></div>\n            </div>\n\n            <div style=\"display:flex;justify-content:space-between;align-items:center;font-size:13px;color:var(--muted);\">\n              <div id=\"statusText\">Status: Idle</div>\n              <div id=\"timeEstimate\" aria-hidden=\"true\"></div>\n            </div>\n          </div>\n\n          <div class=\"pseudocode\" role=\"region\" aria-label=\"Pseudocode\">\n            <!-- Simple insertion sort pseudocode with line ids -->\n            <div id=\"line0\" class=\"code-line\">1  for i = 1 to n-1</div>\n            <div id=\"line1\" class=\"code-line\">2    key = A[i]</div>\n            <div id=\"line2\" class=\"code-line\">3    j = i - 1</div>\n            <div id=\"line3\" class=\"code-line\">4    while j &gt;= 0 and A[j] &gt; key</div>\n            <div id=\"line4\" class=\"code-line\">5      A[j+1] = A[j]   // shift right</div>\n            <div id=\"line5\" class=\"code-line\">6      j = j - 1</div>\n            <div id=\"line6\" class=\"code-line\">7    A[j+1] = key     // place key</div>\n          </div>\n        </section>\n      </section>\n    </div>\n  </main>\n\n  <script>\n    // Insertion Sort Interactive — Vanilla JS\n    (function(){\n      // DOM elements\n      const arrayInput = document.getElementById('arrayInput');\n      const setArrayBtn = document.getElementById('setArrayBtn');\n      const randomBtn = document.getElementById('randomBtn');\n      const stepBackBtn = document.getElementById('stepBack');\n      const stepForwardBtn = document.getElementById('stepForward');\n      const playPauseBtn = document.getElementById('playPause');\n      const resetBtn = document.getElementById('resetBtn');\n      const speedRange = document.getElementById('speedRange');\n      const speedLabel = document.getElementById('speedLabel');\n      const barsContainer = document.getElementById('barsContainer');\n      const actionCounter = document.getElementById('actionCounter');\n      const arrayLen = document.getElementById('arrayLen');\n      const statusText = document.getElementById('statusText');\n      const indicesHint = document.getElementById('indicesHint');\n      const pseudocodeLines = Array.from({length:7}, (_,i)=>document.getElementById('line'+i));\n\n      // State\n      let initialArray = [5,3,8,1,4];\n      let actions = []; // precomputed actions list\n      let currentActionIndex = 0; // how many actions have been applied\n      let playing = false;\n      let playTimer = null;\n\n      // Visual parameters\n      let transitionMs = parseInt(speedRange.value || 400, 10);\n\n      // Constraints\n      const MAX_LEN = 12;\n      const MIN_VAL = -999;\n      const MAX_VAL = 999;\n\n      // Build initial UI\n      arrayInput.value = initialArray.join(',');\n      speedLabel.textContent = transitionMs + 'ms';\n      setupFromInput();\n\n      // Event listeners\n      setArrayBtn.addEventListener('click', setupFromInput);\n      randomBtn.addEventListener('click', () => {\n        const n = 6 + Math.floor(Math.random()* (MAX_LEN - 6 + 1));\n        const arr = Array.from({length:n}, ()=> Math.floor(Math.random()*41)-10);\n        arrayInput.value = arr.join(',');\n        setupFromInput();\n      });\n      stepForwardBtn.addEventListener('click', ()=> stepForward());\n      stepBackBtn.addEventListener('click', ()=> stepBack());\n      playPauseBtn.addEventListener('click', togglePlay);\n      resetBtn.addEventListener('click', ()=> {\n        stopPlay();\n        currentActionIndex = 0;\n        renderActions(currentActionIndex);\n      });\n      speedRange.addEventListener('input', ()=> {\n        transitionMs = parseInt(speedRange.value,10);\n        speedLabel.textContent = transitionMs + 'ms';\n        updateAnimationSpeed();\n      });\n\n      // keyboard shortcuts: Space toggles play/pause\n      window.addEventListener('keydown', (e)=>{\n        if(e.code === 'Space'){\n          e.preventDefault();\n          togglePlay();\n        } else if(e.key === 'ArrowRight'){\n          stepForward();\n        } else if(e.key === 'ArrowLeft'){\n          stepBack();\n        }\n      });\n\n      // Resize handling: recalc positions on resize\n      window.addEventListener('resize', recalcPositions);\n\n      // Helpers: clamp and parse\n      function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }\n      function parseArrayInput(text){\n        if(!text.trim()) return [];\n        const tokens = text.split(',');\n        const nums = [];\n        for(const t of tokens){\n          const v = parseInt(t.trim(),10);\n          if(Number.isFinite(v)) nums.push(clamp(v,MIN_VAL,MAX_VAL));\n        }\n        return nums.slice(0,MAX_LEN);\n      }\n\n      // Create actions by simulating insertion sort\n      // Action types: select(i), compare(j,i?), shift(from,to), place(index,value), done\n      function buildActions(arr){\n        const a = arr.slice();\n        const acts = [];\n        const n = a.length;\n        for(let i=1;i<n;i++){\n          acts.push({type:'select', i:i});\n          const key = a[i];\n          let j = i-1;\n          acts.push({type:'setKeyValue', value:key}); // for clarity to UI\n          while(j >= 0 && a[j] > key){\n            acts.push({type:'compare', j:j, keyIndex:i});\n            // shift a[j] to a[j+1]\n            acts.push({type:'shift', from:j, to:j+1});\n            a[j+1] = a[j];\n            j = j-1;\n            acts.push({type:'decrementJ', j:j});\n          }\n          if(j >= 0){\n            // final comparison that fails (optional)\n            acts.push({type:'compare', j:j, keyIndex:i, result:false});\n          }\n          acts.push({type:'place', index:j+1, value:key});\n          a[j+1] = key;\n        }\n        acts.push({type:'done'});\n        return acts;\n      }\n\n      // Render functions: set bars to positions according to an array state\n      // For animation, we'll set transform: translateX(px) according to index position.\n      let visualArray = []; // current values mapped to bars (array of values)\n      let barElements = []; // DOM nodes for bars\n      function renderInitialBars(arr){\n        // remove existing\n        barsContainer.innerHTML = '';\n        barElements = [];\n        visualArray = arr.slice();\n        arrayLen.textContent = arr.length;\n        indicesHint.textContent = (arr.length>0) ? `Indices: 0 .. ${arr.length-1}` : 'Indices: (empty)';\n        // create bars\n        for(let i=0;i<arr.length;i++){\n          const b = document.createElement('div');\n          b.className='bar';\n          b.setAttribute('data-index', i);\n          b.setAttribute('role','img');\n          b.setAttribute('aria-label', `Value ${arr[i]} at index ${i}`);\n          const v = document.createElement('div');\n          v.className='value';\n          v.textContent = String(arr[i]);\n          b.appendChild(v);\n          barsContainer.appendChild(b);\n          barElements.push(b);\n        }\n        // position them\n        recalcPositions(true);\n      }\n\n      function recalcPositions(noTransition){\n        // Calculate available width and assign positions\n        const container = barsContainer;\n        const w = container.clientWidth - 12; // padding compensation\n        const n = barElements.length;\n        const gap = 12; // pixel gap between bars\n        let barW = 96;\n        if(n>0){\n          barW = Math.max(44, Math.min(160, Math.floor((w - (n-1)*gap)/n)));\n        }\n        // set CSS vars for transition speed\n        updateAnimationSpeed();\n        for(let i=0;i<barElements.length;i++){\n          const el = barElements[i];\n          // calculate center positions so bars look evenly spaced\n          const left = i * (barW + gap) + 6; // 6 px left padding\n          if(noTransition){\n            el.style.transition = 'none';\n            requestAnimationFrame(()=> {\n              el.style.transform = `translate(${left}px, -50%)`;\n              // force reflow then restore transition\n              void el.offsetWidth;\n              el.style.transition = `transform ${transitionMs}ms cubic-bezier(.2,.9,.3,1), background-color 180ms, box-shadow 180ms`;\n            });\n          } else {\n            el.style.transform = `translate(${left}px, -50%)`;\n          }\n        }\n      }\n\n      function updateAnimationSpeed(){\n        // update CSS transition durations\n        for(const el of barElements){\n          el.style.transition = `transform ${transitionMs}ms cubic-bezier(.2,.9,.3,1), background-color 180ms, box-shadow 180ms`;\n        }\n        // update global\n        speedLabel.textContent = transitionMs + 'ms';\n      }\n\n      // Apply actions up to index (0..actions.length). We rebuild the array from initial and apply actions sequentially to produce a deterministic state.\n      function renderActions(upTo){\n        // Reset bar classes\n        for(const el of barElements){\n          el.classList.remove('key','compare','shifted');\n        }\n        // Reconstruct array state by applying actions from scratch\n        let arr = initialArray.slice();\n        let keyValue = undefined;\n        let highlighted = {keyIndex:-1, compareIndex:-1};\n        // Apply actions sequentially (but we won't animate internal steps here; positions will animate using CSS)\n        for(let k=0;k<upTo && k<actions.length;k++){\n          const a = actions[k];\n          switch(a.type){\n            case 'select':\n              highlighted.keyIndex = a.i;\n              // keyValue will be set by setKeyValue action\n              break;\n            case 'setKeyValue':\n              keyValue = a.value;\n              break;\n            case 'compare':\n              highlighted.compareIndex = a.j;\n              break;\n            case 'shift':\n              // move arr[from] to arr[to]\n              arr[a.to] = arr[a.from];\n              // mark shifted bar visually after we update DOM\n              break;\n            case 'decrementJ':\n              // no direct change to array\n              break;\n            case 'place':\n              arr[a.index] = a.value;\n              // placing key\n              break;\n            case 'done':\n              // nothing\n              break;\n          }\n        }\n\n        // Update visualArray values and text\n        // If array size changed, re-create bars (shouldn't change length in insertion sort)\n        if(arr.length !== visualArray.length){\n          renderInitialBars(arr);\n          visualArray = arr.slice();\n        } else {\n          visualArray = arr.slice();\n          // update text inside bars and aria labels\n          for(let i=0;i<visualArray.length;i++){\n            const el = barElements[i];\n            el.querySelector('.value').textContent = String(visualArray[i]);\n            el.setAttribute('data-index', i);\n            el.setAttribute('aria-label', `Value ${visualArray[i]} at index ${i}`);\n            // clear classes\n            el.classList.remove('key','compare','shifted');\n          }\n        }\n\n        // Apply highlights based on the last action applied\n        const lastAction = actions[Math.max(0, upTo-1)];\n        if(lastAction){\n          switch(lastAction.type){\n            case 'select':\n            case 'setKeyValue':\n              if(highlighted.keyIndex >=0 && barElements[highlighted.keyIndex])\n                barElements[highlighted.keyIndex].classList.add('key');\n              setActiveLine(1); // key = A[i] line\n              break;\n            case 'compare':\n              if(barElements[lastAction.j]) barElements[lastAction.j].classList.add('compare');\n              if(barElements[lastAction.keyIndex]) barElements[lastAction.keyIndex].classList.add('key');\n              setActiveLine(3);\n              break;\n            case 'shift':\n              // The shift action already updated array values at this point; highlight the \"to\" index as shifted\n              if(barElements[lastAction.to]) barElements[lastAction.to].classList.add('shifted');\n              setActiveLine(4);\n              break;\n            case 'place':\n              if(barElements[lastAction.index]) barElements[lastAction.index].classList.add('key');\n              setActiveLine(6);\n              break;\n            case 'done':\n              setActiveLine(-1);\n              break;\n            default:\n              setActiveLine(-1);\n          }\n        } else {\n          setActiveLine(-1);\n        }\n\n        // Update positions (CSS transitions will animate)\n        recalcPositions(false);\n\n        // Update UI counters and status\n        actionCounter.textContent = `Action ${upTo} / ${actions.length}`;\n        arrayLen.textContent = visualArray.length;\n        statusText.textContent = (upTo >= actions.length) ? 'Status: Finished' : 'Status: Ready';\n      }\n\n      function setActiveLine(n){\n        // map actions to pseudocode lines\n        const mapping = {\n          'select': 1,\n          'setKeyValue': 1,\n          'compare': 3,\n          'shift': 4,\n          'decrementJ': 5,\n          'place': 6,\n          'done': -1\n        };\n        // If n is -1 then clear\n        pseudocodeLines.forEach(line => line.classList.remove('active'));\n        if(typeof n === 'number' && n>=0 && n < pseudocodeLines.length){\n          pseudocodeLines[n].classList.add('active');\n        }\n      }\n\n      // Build actions and recreate visual elements\n      function setupFromInput(){\n        stopPlay();\n        const arr = parseArrayInput(arrayInput.value);\n        if(arr.length === 0){\n          // default\n          initialArray = [];\n        } else {\n          initialArray = arr;\n        }\n        // create visual bars and actions\n        renderInitialBars(initialArray);\n        actions = buildActions(initialArray);\n        currentActionIndex = 0;\n        renderActions(0);\n      }\n\n      // Step forward: increment currentActionIndex and animate\n      function stepForward(){\n        if(currentActionIndex >= actions.length){\n          // already finished\n          return;\n        }\n        currentActionIndex++;\n        renderActions(currentActionIndex);\n      }\n\n      function stepBack(){\n        if(currentActionIndex <= 0) return;\n        stopPlay();\n        currentActionIndex--;\n        renderActions(currentActionIndex);\n      }\n\n      // Play/pause logic\n      function togglePlay(){\n        if(playing) stopPlay();\n        else startPlay();\n      }\n      function startPlay(){\n        if(playing) return;\n        playing = true;\n        playPauseBtn.setAttribute('aria-pressed','true');\n        playPauseBtn.textContent = 'Pause ⏸';\n        statusText.textContent = 'Status: Playing';\n        scheduleNext();\n      }\n      function stopPlay(){\n        playing = false;\n        if(playTimer) { clearTimeout(playTimer); playTimer = null; }\n        playPauseBtn.setAttribute('aria-pressed','false');\n        playPauseBtn.textContent = 'Play ▶';\n        statusText.textContent = 'Status: Paused';\n      }\n      function scheduleNext(){\n        if(!playing) return;\n        if(currentActionIndex >= actions.length){\n          stopPlay();\n          currentActionIndex = actions.length;\n          renderActions(currentActionIndex);\n          return;\n        }\n        // Step and schedule based on transitionMs\n        stepForward();\n        // Wait transitionMs + small buffer to allow user to see animation\n        playTimer = setTimeout(()=> scheduleNext(), transitionMs + 80);\n      }\n\n      // Initialize UI with starting array\n      // already called above\n\n      // Accessibility: focus outlines and hover hints\n      // (No additional code required — using native controls and ARIA attributes)\n\n      // Expose some helpers on window for debugging (optional)\n      window.__insertionSort = {\n        getState: ()=> ({ initialArray, actions, currentActionIndex }),\n      };\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Insertion Sort.\n\n**Project Overview:**\nTopic: Insertion Sort\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Insertion Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "d12486f0-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:47:21.823Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Counting Sort",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Counting Sort — Interactive Module</title>\n  <style>\n    :root{\n      --safe: 24px;\n      --gap: 16px;\n      --bg:#0f1720;\n      --panel:#0b1220;\n      --card:#0f1728;\n      --muted:#9aa6b2;\n      --accent:#22c1c3;\n      --accent-2:#6be3b8;\n      --danger:#ff6b6b;\n      --glass: rgba(255,255,255,0.03);\n      --max-bar-height:180px;\n      --bar-width:44px;\n    }\n    /* Safe area margins */\n    html,body{\n      height:100%;\n      margin:0;\n      background:linear-gradient(180deg,#041018 0%, #071827 60%);\n      color:#e6f2f1;\n      font-family:Inter, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n    .app{\n      min-height:100vh;\n      padding:var(--safe);\n      box-sizing:border-box;\n      display:flex;\n      align-items:flex-start;\n      justify-content:center;\n    }\n    .container{\n      width:100%;\n      max-width:1200px;\n      display:grid;\n      grid-template-columns: 360px 1fr;\n      gap:var(--gap);\n      align-items:start;\n    }\n\n    /* Left column: controls & explanation */\n    .panel{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      padding:18px;\n      border-radius:12px;\n      box-sizing:border-box;\n    }\n    header.title{\n      margin-bottom:12px;\n    }\n    header.title h1{\n      margin:0 0 6px 0;\n      font-size:18px;\n      letter-spacing:0.2px;\n    }\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n      line-height:1.35;\n      margin:0;\n    }\n    .controls{\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      margin-top:18px;\n    }\n    .control-row{\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n    label { font-size:13px; color:var(--muted); min-width:120px; }\n    input[type=\"range\"]{ flex:1; }\n    input[type=\"text\"]{\n      width:100%;\n      background:transparent;\n      color:inherit;\n      border:1px solid rgba(255,255,255,0.06);\n      padding:8px 10px;\n      border-radius:8px;\n      outline:none;\n    }\n    .btn-row{\n      display:flex;\n      gap:var(--gap);\n      flex-wrap:wrap;\n    }\n    button{\n      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      color:inherit;\n      padding:10px 12px;\n      border-radius:10px;\n      cursor:pointer;\n      font-size:13px;\n      min-height:40px;\n      outline:none;\n    }\n    button.primary{\n      background:linear-gradient(180deg,var(--accent), var(--accent-2));\n      color:#042022;\n      border: none;\n      font-weight:600;\n    }\n    button.danger{ background: linear-gradient(180deg,var(--danger), #ff8787); color:#2b0202; border:none; }\n    .small{ font-size:13px; padding:8px 10px; min-height:36px; }\n\n    /* Right column: visualization */\n    .viz{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      padding:18px;\n      border-radius:12px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      min-height:520px;\n    }\n    .viz-top{\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:var(--gap);\n    }\n    .status{\n      color:var(--muted);\n      font-size:13px;\n    }\n    .stage-pill{\n      background:var(--glass);\n      padding:6px 10px;\n      border-radius:999px;\n      font-size:13px;\n    }\n\n    /* Arrays layout */\n    .arrays{\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      align-items:stretch;\n    }\n    .array-row{\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      padding:12px;\n      border-radius:10px;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .array-title{\n      font-size:13px;\n      color:var(--muted);\n      margin-bottom:10px;\n    }\n    .bars{\n      display:flex;\n      gap:12px;\n      align-items:end;\n      min-height:120px;\n      padding:6px;\n      overflow:auto;\n    }\n    .bar{\n      width:var(--bar-width);\n      min-width:var(--bar-width);\n      display:flex;\n      align-items:end;\n      justify-content:center;\n      flex-direction:column;\n      cursor:grab;\n      user-select:none;\n      position:relative;\n      transition:transform 400ms ease, opacity 300ms ease;\n    }\n    .bar:active{ cursor:grabbing; }\n    .bar-inner{\n      width:100%;\n      background:linear-gradient(180deg,#20b8d3,#1a99a0);\n      border-radius:8px 8px 6px 6px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      color:#042022;\n      font-weight:700;\n      box-shadow:0 6px 18px rgba(0,0,0,0.35);\n      transition:height 400ms ease;\n    }\n    .bar-label{\n      margin-top:8px;\n      text-align:center;\n      font-size:12px;\n      color:var(--muted);\n    }\n    .count-bar-inner{\n      background:linear-gradient(180deg,#f6d365,#fda085);\n      color:#2b0202;\n    }\n    .output-bar-inner{\n      background:linear-gradient(180deg,#c6f6d5,#7ae3b3);\n      color:#042022;\n    }\n    .ghost{\n      opacity:0.15;\n      transform:scale(0.95);\n    }\n    .highlight{\n      box-shadow:0 0 0 4px rgba(34,193,195,0.12);\n      transform:translateY(-6px);\n    }\n\n    /* small labels underneath arrays */\n    .array-foot{\n      display:flex;\n      gap:12px;\n      font-size:12px;\n      color:var(--muted);\n      margin-top:8px;\n      flex-wrap:wrap;\n    }\n\n    /* animate moving clones */\n    .floating{\n      position:absolute;\n      pointer-events:none;\n      z-index:9999;\n      transition:transform 500ms cubic-bezier(.2,.9,.2,1), opacity 300ms ease;\n    }\n\n    /* explanation area */\n    .explain{\n      font-size:13px;\n      color:var(--muted);\n      line-height:1.45;\n      background:rgba(255,255,255,0.015);\n      padding:12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n\n    footer.attribution{\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      margin-top:8px;\n      color:var(--muted);\n      font-size:12px;\n    }\n\n    /* responsive */\n    @media (max-width:980px){\n      .container{ grid-template-columns: 1fr; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Counting Sort interactive module\">\n    <div class=\"container\" role=\"region\" aria-label=\"Module container\">\n      <!-- LEFT PANEL -->\n      <aside class=\"panel\" aria-labelledby=\"title\">\n        <header class=\"title\">\n          <h1 id=\"title\">Counting Sort — Stable, Integer Sorting</h1>\n          <p class=\"muted\">A focused interactive exploration: see how Counting Sort builds counts, computes cumulative counts, and places elements into a stable output.</p>\n        </header>\n\n        <div class=\"controls\" aria-hidden=\"false\">\n          <div class=\"control-row\" title=\"Number of elements in the input array\">\n            <label for=\"sizeRange\">Array size (n)</label>\n            <input id=\"sizeRange\" type=\"range\" min=\"1\" max=\"16\" value=\"8\" aria-label=\"Array size\">\n            <div id=\"sizeVal\" class=\"muted\" style=\"min-width:36px;text-align:right\">8</div>\n          </div>\n\n          <div class=\"control-row\" title=\"Maximum value (k)\">\n            <label for=\"maxRange\">Max value (k)</label>\n            <input id=\"maxRange\" type=\"range\" min=\"1\" max=\"20\" value=\"9\" aria-label=\"Maximum value\">\n            <div id=\"maxVal\" class=\"muted\" style=\"min-width:36px;text-align:right\">9</div>\n          </div>\n\n          <div class=\"control-row\" style=\"align-items:flex-start;\">\n            <label for=\"manualInput\">Manual array</label>\n            <input id=\"manualInput\" type=\"text\" aria-label=\"Enter array as comma separated integers\" placeholder=\"e.g. 3,1,4,1,5\" />\n          </div>\n\n          <div class=\"btn-row\" role=\"group\" aria-label=\"Primary controls\">\n            <button id=\"randomBtn\" class=\"small\" title=\"Create a random array\">Randomize</button>\n            <button id=\"initBtn\" class=\"primary small\" title=\"Initialize counts and arrays\">Initialize</button>\n            <button id=\"stepBtn\" class=\"small\" title=\"Advance one step\">Step</button>\n            <button id=\"playBtn\" class=\"small\" title=\"Automatically play steps\">Auto</button>\n            <button id=\"resetBtn\" class=\"danger small\" title=\"Reset to empty state\">Reset</button>\n          </div>\n\n          <div class=\"control-row\" style=\"margin-top:6px;\">\n            <label>Speed</label>\n            <input id=\"speedRange\" type=\"range\" min=\"200\" max=\"1500\" value=\"700\" aria-label=\"Playback speed (ms per step)\">\n            <div id=\"speedVal\" class=\"muted\" style=\"min-width:48px;text-align:right\">700ms</div>\n          </div>\n\n          <div style=\"margin-top:8px;\" class=\"explain\" aria-live=\"polite\">\n            <strong>Concept Title:</strong>\n            <div>Counting Sort (stable integer sort using counts)</div>\n            <hr style=\"opacity:0.06;border:none;height:8px\"/>\n            <strong>Learning Objective:</strong>\n            <div>After interacting with this module you should be able to:\n              - Understand how Counting Sort builds a frequency (count) array,\n              - See how cumulative counts map values to output indices,\n              - Observe stable placement of equal keys (processing input from right to left),\n              - Experiment with different n and k to see performance/space trade-offs.\n            </div>\n            <hr style=\"opacity:0.06;border:none;height:8px\"/>\n            <strong>Interaction Design:</strong>\n            <div style=\"margin-top:6px;\">Use the sliders or manual input to create arrays. Drag input bars left/right to reorder before initializing. Press Initialize to set up count and output arrays. Use Step to advance through building counts, computing cumulative counts, and placing elements (each step animates a bar moving into the output and highlights count updates). Auto plays steps continuously. Reset clears state.</div>\n            <hr style=\"opacity:0.06;border:none;height:8px\"/>\n            <strong>Layout Description:</strong>\n            <div style=\"margin-top:6px;\">Controls on the left (safe margins 24px) and the visualization on the right. The visualization shows three horizontal rows: Input (top), Count array (middle), Output (bottom). Spacing between interactive elements >=16px. Colors and contrast selected for clarity; keyboard-accessible buttons and aria labels included. Responsive: on small screens the controls stack above visualization.</div>\n          </div>\n\n          <footer class=\"attribution\" style=\"margin-top:12px;\">\n            <div>Stable Counting Sort demo</div>\n            <div class=\"muted\">Only non-negative integers</div>\n          </footer>\n        </div>\n      </aside>\n\n      <!-- RIGHT PANEL: Visualization -->\n      <main class=\"viz\" role=\"main\" aria-label=\"Visualization area\">\n        <div class=\"viz-top\">\n          <div class=\"status\">State: <span id=\"stateText\">Ready</span></div>\n          <div class=\"stage-pill\" id=\"stepInfo\" aria-live=\"polite\">Idle</div>\n        </div>\n\n        <div class=\"arrays\" id=\"arraysContainer\">\n          <!-- Input Array -->\n          <section class=\"array-row\" aria-label=\"Input array\">\n            <div class=\"array-title\">Input Array (drag to reorder before Initialize)</div>\n            <div id=\"inputBars\" class=\"bars\" tabindex=\"0\" aria-describedby=\"inputDesc\"></div>\n            <div class=\"array-foot\" id=\"inputFoot\"></div>\n          </section>\n\n          <!-- Count Array -->\n          <section class=\"array-row\" aria-label=\"Count array\">\n            <div class=\"array-title\">Count Array (frequency of each value)</div>\n            <div id=\"countBars\" class=\"bars\" aria-live=\"polite\"></div>\n            <div class=\"array-foot\" id=\"countFoot\"></div>\n          </section>\n\n          <!-- Output Array -->\n          <section class=\"array-row\" aria-label=\"Output array\">\n            <div class=\"array-title\">Output Array (stable result)</div>\n            <div id=\"outputBars\" class=\"bars\" aria-live=\"polite\"></div>\n            <div class=\"array-foot\" id=\"outputFoot\"></div>\n          </section>\n        </div>\n      </main>\n    </div>\n  </div>\n\n  <script>\n    // Counting Sort Interactive Module\n    (function(){\n      // Utility\n      const qs = s => document.querySelector(s);\n      const qsa = s => Array.from(document.querySelectorAll(s));\n      const clamp = (v,min,max)=>Math.max(min, Math.min(max, v));\n      // Elements\n      const sizeRange = qs('#sizeRange');\n      const sizeVal = qs('#sizeVal');\n      const maxRange = qs('#maxRange');\n      const maxVal = qs('#maxVal');\n      const manualInput = qs('#manualInput');\n      const randomBtn = qs('#randomBtn');\n      const initBtn = qs('#initBtn');\n      const stepBtn = qs('#stepBtn');\n      const playBtn = qs('#playBtn');\n      const resetBtn = qs('#resetBtn');\n      const speedRange = qs('#speedRange');\n      const speedVal = qs('#speedVal');\n\n      const inputBars = qs('#inputBars');\n      const countBars = qs('#countBars');\n      const outputBars = qs('#outputBars');\n      const stateText = qs('#stateText');\n      const stepInfo = qs('#stepInfo');\n\n      // State\n      let inputArray = [];\n      let k = parseInt(maxRange.value,10);\n      let n = parseInt(sizeRange.value,10);\n      let countArray = [];\n      let outputArray = [];\n      let phase = 'idle'; // 'idle' | 'counting' | 'cumulative' | 'placing' | 'done'\n      let stepIndex = 0; // index inside current phase\n      let autoTimer = null;\n      let speed = parseInt(speedRange.value,10);\n      let lastAction = null;\n      let allowDrag = true;\n\n      // Initialize with random\n      function randomArray(n, k){\n        const arr = [];\n        for(let i=0;i<n;i++){\n          arr.push(Math.floor(Math.random()*(k+1)));\n        }\n        return arr;\n      }\n\n      function parseManualInput(text){\n        if(!text.trim()) return null;\n        const parts = text.split(',').map(s=>s.trim()).filter(s=>s.length);\n        const vals = [];\n        for(const p of parts){\n          const v = Number(p);\n          if(!Number.isFinite(v) || v<0 || Math.floor(v)!==v) return null;\n          vals.push(v);\n        }\n        return vals;\n      }\n\n      function renderAll(){\n        renderInput();\n        renderCount();\n        renderOutput();\n        updateStatus();\n      }\n\n      function updateStatus(){\n        stateText.textContent = phase.charAt(0).toUpperCase()+phase.slice(1);\n        if(phase === 'idle') stepInfo.textContent = 'Ready — initialize to begin';\n        else if(phase === 'counting') stepInfo.textContent = `Counting frequencies — processing input index ${stepIndex}/${n-1}`;\n        else if(phase === 'cumulative') stepInfo.textContent = 'Computing cumulative counts';\n        else if(phase === 'placing') stepInfo.textContent = `Placing items — processing input index ${stepIndex}/${n-1}`;\n        else if(phase === 'done') stepInfo.textContent = 'Done — output is sorted';\n      }\n\n      // Render input bars with drag-and-drop support\n      function renderInput(){\n        inputBars.innerHTML = '';\n        inputArray.forEach((v,idx)=>{\n          const bar = document.createElement('div');\n          bar.className = 'bar';\n          bar.setAttribute('draggable','true');\n          bar.setAttribute('role','button');\n          bar.setAttribute('tabindex','0');\n          bar.setAttribute('aria-label',`Value ${v} at index ${idx}`);\n          bar.dataset.index = idx;\n\n          const inner = document.createElement('div');\n          inner.className = 'bar-inner';\n          inner.style.height = (Math.max(24, v/(k||1) * parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-bar-height') || 180))) + 'px';\n          inner.textContent = v;\n\n          const label = document.createElement('div');\n          label.className = 'bar-label';\n          label.textContent = idx;\n\n          bar.appendChild(inner);\n          bar.appendChild(label);\n          inputBars.appendChild(bar);\n\n          // Drag handlers\n          bar.addEventListener('dragstart', (e)=> {\n            if(!allowDrag) { e.preventDefault(); return; }\n            e.dataTransfer.setData('text/plain', idx);\n            bar.classList.add('ghost');\n          });\n          bar.addEventListener('dragend', ()=> {\n            bar.classList.remove('ghost');\n          });\n          bar.addEventListener('keydown', (e)=>{\n            if(e.key === 'Enter' || e.key === ' '){\n              // select and swap mode could be implemented; for simplicity ignore\n            }\n          });\n          // Allow dropping onto other bars to swap\n          bar.addEventListener('dragover', (e)=> {\n            e.preventDefault();\n            bar.classList.add('highlight');\n          });\n          bar.addEventListener('dragleave', ()=> {\n            bar.classList.remove('highlight');\n          });\n          bar.addEventListener('drop', (e)=> {\n            e.preventDefault();\n            bar.classList.remove('highlight');\n            const fromIdx = Number(e.dataTransfer.getData('text/plain'));\n            const toIdx = Number(bar.dataset.index);\n            if(Number.isFinite(fromIdx) && fromIdx!==toIdx){\n              swapInputIndices(fromIdx,toIdx);\n              renderAll();\n            }\n          });\n        });\n        qs('#inputFoot').textContent = `n = ${inputArray.length}`;\n      }\n\n      function swapInputIndices(i,j){\n        const t = inputArray[i];\n        inputArray[i] = inputArray[j];\n        inputArray[j] = t;\n      }\n\n      function renderCount(){\n        countBars.innerHTML = '';\n        const len = countArray.length;\n        for(let i=0;i<len;i++){\n          const v = countArray[i] ?? 0;\n          const bar = document.createElement('div');\n          bar.className = 'bar';\n          bar.dataset.index = i;\n          const inner = document.createElement('div');\n          inner.className = 'bar-inner count-bar-inner';\n          // height relative to max count for visual clarity\n          const maxC = Math.max(1, ...countArray);\n          inner.style.height = (Math.max(18, v/maxC * parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-bar-height') || 180))) + 'px';\n          inner.textContent = v;\n          const label = document.createElement('div');\n          label.className = 'bar-label';\n          label.textContent = i;\n          bar.appendChild(inner);\n          bar.appendChild(label);\n          countBars.appendChild(bar);\n        }\n        qs('#countFoot').textContent = `k+1 = ${countArray.length}`;\n      }\n\n      function renderOutput(){\n        outputBars.innerHTML = '';\n        for(let i=0;i<outputArray.length;i++){\n          const v = outputArray[i];\n          const bar = document.createElement('div');\n          bar.className = 'bar';\n          const inner = document.createElement('div');\n          inner.className = 'bar-inner output-bar-inner';\n          if(v===null || v===undefined){\n            inner.style.height = '18px';\n            inner.style.background = 'linear-gradient(180deg,#111827,#0b1220)';\n            inner.textContent = '';\n            inner.style.opacity = 0.35;\n          } else {\n            inner.textContent = v;\n            inner.style.height = (Math.max(18, v/(k||1) * parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-bar-height') || 180))) + 'px';\n          }\n          const label = document.createElement('div');\n          label.className = 'bar-label';\n          label.textContent = i;\n          bar.appendChild(inner);\n          bar.appendChild(label);\n          outputBars.appendChild(bar);\n        }\n        qs('#outputFoot').textContent = `indices 0..${Math.max(0,outputArray.length-1)}`;\n      }\n\n      // Initialization workflow\n      function initialize(){\n        // parse manual input if present\n        const manual = parseManualInput(manualInput.value || '');\n        if(manual){\n          inputArray = manual.slice();\n          n = inputArray.length;\n          clampRanges();\n          sizeRange.value = n;\n          sizeVal.textContent = n;\n        } else {\n          // ensure n and k current\n          n = parseInt(sizeRange.value,10);\n          inputArray = randomArray(n,k);\n        }\n\n        // ensure values within k\n        const tooBig = inputArray.some(v => v > k);\n        if(tooBig){\n          // increase k automatically\n          k = Math.max(...inputArray);\n          maxRange.value = k;\n          maxVal.textContent = k;\n        }\n\n        // prepare arrays\n        countArray = new Array(k+1).fill(0);\n        outputArray = new Array(n).fill(null);\n\n        phase = 'counting';\n        stepIndex = 0;\n        allowDrag = false;\n        renderAll();\n        updateStatus();\n      }\n\n      // Step controller: one atomic step per press\n      function step(){\n        if(phase === 'idle'){\n          // not initialized\n          return;\n        }\n        if(phase === 'counting'){\n          if(stepIndex < n){\n            // process input[stepIndex]\n            const val = inputArray[stepIndex];\n            countArray[val] = (countArray[val] || 0) + 1;\n            animateCountIncrement(val, stepIndex);\n            stepIndex++;\n            renderCount();\n            updateStatus();\n          } else {\n            // move to cumulative\n            phase = 'cumulative';\n            stepIndex = 0;\n            computeCumulativeStep(); // may animate quickly\n            phase = 'placing';\n            // placing processes input from right to left\n            stepIndex = n-1;\n            renderAll();\n            updateStatus();\n          }\n        } else if(phase === 'placing'){\n          if(stepIndex >= 0){\n            const val = inputArray[stepIndex];\n            // determine placement index from countArray\n            const idx = (countArray[val] || 0) - 1;\n            // place into output[idx]\n            outputArray[idx] = val;\n            animatePlace(val, stepIndex, idx);\n            // decrement count\n            countArray[val] = idx;\n            renderCount();\n            renderOutput();\n            stepIndex--;\n            updateStatus();\n          } else {\n            phase = 'done';\n            allowDrag = true;\n            renderAll();\n            updateStatus();\n            stopAuto();\n          }\n        } else if(phase === 'done'){\n          // no-op\n        }\n      }\n\n      function animateCountIncrement(value, inputIdx){\n        // Highlight the corresponding count bar briefly\n        const cb = countBars.children[value];\n        if(!cb) return;\n        cb.classList.add('highlight');\n        setTimeout(()=> cb.classList.remove('highlight'), 520);\n      }\n\n      function computeCumulativeStep(){\n        // transform countArray into cumulative counts\n        for(let i=1;i<countArray.length;i++){\n          countArray[i] = (countArray[i] || 0) + (countArray[i-1] || 0);\n        }\n        // animate a gentle highlight across count bars\n        countBars.querySelectorAll('.bar').forEach((b,idx)=>{\n          setTimeout(()=> b.classList.add('highlight'), idx*60);\n          setTimeout(()=> b.classList.remove('highlight'), 500 + idx*60);\n        });\n        renderCount();\n      }\n\n      function animatePlace(value, fromIndex, toIndex){\n        // create a floating clone from input bar to output bar\n        const inputBar = inputBars.children[fromIndex];\n        const outBar = outputBars.children[toIndex];\n        if(!inputBar || !outBar) return;\n        const clone = inputBar.cloneNode(true);\n        clone.classList.add('floating');\n        document.body.appendChild(clone);\n        // measure positions\n        const inRect = inputBar.getBoundingClientRect();\n        const outRect = outBar.getBoundingClientRect();\n        // initial style\n        clone.style.left = inRect.left + 'px';\n        clone.style.top = inRect.top + 'px';\n        clone.style.width = inRect.width + 'px';\n        clone.style.height = inRect.height + 'px';\n        clone.style.opacity = 1;\n        // force reflow then transform\n        requestAnimationFrame(()=>{\n          const dx = outRect.left - inRect.left;\n          const dy = outRect.top - inRect.top;\n          clone.style.transform = `translate(${dx}px, ${dy}px) scale(0.95)`;\n          clone.style.opacity = 0.92;\n        });\n        setTimeout(()=> {\n          clone.style.opacity = 0;\n          setTimeout(()=> clone.remove(), 420);\n        }, 520);\n      }\n\n      // Auto play\n      function toggleAuto(){\n        if(autoTimer) stopAuto();\n        else startAuto();\n      }\n      function startAuto(){\n        if(phase === 'idle') return;\n        autoTimer = setInterval(()=> {\n          step();\n          if(phase === 'done') stopAuto();\n        }, speed);\n        playBtn.textContent = 'Pause';\n        playBtn.classList.add('primary');\n        playBtn.setAttribute('aria-pressed','true');\n      }\n      function stopAuto(){\n        if(autoTimer){ clearInterval(autoTimer); autoTimer = null; }\n        playBtn.textContent = 'Auto';\n        playBtn.classList.remove('primary');\n        playBtn.setAttribute('aria-pressed','false');\n      }\n\n      function resetAll(){\n        inputArray = [];\n        n = parseInt(sizeRange.value,10);\n        k = parseInt(maxRange.value,10);\n        countArray = new Array(k+1).fill(0);\n        outputArray = new Array(n).fill(null);\n        phase = 'idle';\n        stepIndex = 0;\n        allowDrag = true;\n        stopAuto();\n        renderAll();\n      }\n\n      function clampRanges(){\n        // keep ranges consistent with new n,k\n        n = clamp(n, 1, 16);\n        k = clamp(k, 1, 20);\n      }\n\n      // Event listeners\n      sizeRange.addEventListener('input', (e)=>{\n        n = Number(e.target.value);\n        sizeVal.textContent = n;\n        if(phase==='idle'){\n          inputArray = randomArray(n,k);\n          renderAll();\n        }\n      });\n      maxRange.addEventListener('input', (e)=>{\n        k = Number(e.target.value);\n        maxVal.textContent = k;\n        if(phase==='idle'){\n          // adjust input values if necessary\n          inputArray = inputArray.map(v => Math.min(v,k));\n          renderAll();\n        }\n      });\n      randomBtn.addEventListener('click', ()=>{\n        n = parseInt(sizeRange.value,10);\n        k = parseInt(maxRange.value,10);\n        inputArray = randomArray(n,k);\n        manualInput.value = '';\n        renderAll();\n      });\n      initBtn.addEventListener('click', ()=>{\n        k = parseInt(maxRange.value,10);\n        n = parseInt(sizeRange.value,10);\n        initialize();\n      });\n      stepBtn.addEventListener('click', ()=>{\n        step();\n      });\n      playBtn.addEventListener('click', ()=>{\n        if(!autoTimer) startAuto();\n        else stopAuto();\n      });\n      resetBtn.addEventListener('click', ()=>{\n        resetAll();\n      });\n      speedRange.addEventListener('input', (e)=>{\n        speed = parseInt(e.target.value,10);\n        speedVal.textContent = speed + 'ms';\n        if(autoTimer){ stopAuto(); startAuto(); }\n      });\n\n      // Initial render\n      (function start(){\n        k = parseInt(maxRange.value,10);\n        n = parseInt(sizeRange.value,10);\n        inputArray = randomArray(n,k);\n        countArray = new Array(k+1).fill(0);\n        outputArray = new Array(n).fill(null);\n        renderAll();\n      })();\n\n      // Keyboard accessibility: allow step with space on Step button\n      stepBtn.addEventListener('keydown', (e)=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); step(); } });\n\n      // Allow manual input pressing Enter to initialize\n      manualInput.addEventListener('keydown', (e)=> {\n        if(e.key === 'Enter'){\n          const parsed = parseManualInput(manualInput.value || '');\n          if(parsed){\n            inputArray = parsed.slice();\n            sizeRange.value = inputArray.length;\n            sizeVal.textContent = inputArray.length;\n            // expand k if needed\n            const maxv = Math.max(...inputArray);\n            if(maxv > k){\n              k = maxv;\n              maxRange.value = k;\n              maxVal.textContent = k;\n            }\n            renderAll();\n          } else {\n            alert('Please enter comma-separated non-negative integers (e.g. 3,1,4,1)');\n          }\n        }\n      });\n\n      // Provide simple tooltip feedback\n      [randomBtn, initBtn, stepBtn, playBtn, resetBtn].forEach(b=>{\n        b.addEventListener('focus', ()=> b.style.boxShadow = '0 6px 20px rgba(34,193,195,0.08)');\n        b.addEventListener('blur', ()=> b.style.boxShadow = 'none');\n      });\n\n      // ensure safe spacing between interactive elements (CSS obeys)\n      // End module\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Counting Sort.\n\n**Project Overview:**\nTopic: Counting Sort\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Counting Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "d7de2d20-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:47:33.106Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Radix Sort",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Radix Sort — Interactive Module</title>\n  <style>\n    :root{\n      --safe:24px;\n      --gap:16px;\n      --bg:#0f1724;\n      --card:#0b1220;\n      --muted:#98a0b3;\n      --accent:#6ee7b7;\n      --accent-2:#60a5fa;\n      --tile:#111827;\n      --tile-border:#233044;\n      --success:#16a34a;\n      --danger:#ef4444;\n      --glass: rgba(255,255,255,0.03);\n      --radius:10px;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n\n    /* Safe area margins */\n    html,body{height:100%}\n    body{\n      margin:0;\n      padding:var(--safe);\n      background:linear-gradient(180deg,#021028 0%, #071428 60%);\n      color:#e6eef8;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      box-sizing:border-box;\n      min-height:100%;\n    }\n    *,*:before,*:after{box-sizing:inherit}\n\n    /* Layout container */\n    .module {\n      display:grid;\n      grid-template-columns: 380px 1fr;\n      gap:var(--gap);\n      align-items:start;\n      max-width:1400px;\n      margin:0 auto;\n    }\n    @media (max-width:900px){\n      .module{grid-template-columns:1fr; padding-bottom:40px}\n    }\n\n    /* Left column (info + controls) */\n    .panel {\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      padding:20px;\n      border-radius:var(--radius);\n      min-height:220px;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    h1{\n      margin:0 0 8px 0;\n      font-size:20px;\n      letter-spacing:0.2px;\n    }\n    p.lead{\n      margin:0 0 12px 0;\n      color:var(--muted);\n      font-size:13px;\n      line-height:1.4;\n    }\n\n    .section-title{margin-top:10px;margin-bottom:8px;font-weight:600;font-size:13px;color:#cfe7ff;}\n\n    .controls{\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    label.small{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}\n\n    /* inputs */\n    .row{\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n    input[type=\"text\"], input[type=\"number\"], select{\n      background:var(--glass);\n      border:1px solid rgba(255,255,255,0.03);\n      color:inherit;\n      padding:8px 10px;\n      border-radius:8px;\n      outline:none;\n      font-size:13px;\n      width:100%;\n    }\n    input[type=\"range\"]{\n      width:100%;\n    }\n    .small-btn{\n      background:#0b1220;\n      border:1px solid rgba(255,255,255,0.03);\n      color:var(--accent-2);\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n    }\n    .small-btn:focus{outline:2px solid rgba(96,165,250,0.25)}\n    .danger{color:var(--danger); border-color:rgba(239,68,68,0.15)}\n    .muted{color:var(--muted); font-size:13px}\n\n    /* main visual area */\n    .visual {\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:var(--radius);\n      padding:20px;\n      border:1px solid rgba(255,255,255,0.03);\n      min-height:480px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    .status{\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n    .badge{\n      background:rgba(255,255,255,0.03);\n      padding:8px 12px;\n      border-radius:999px;\n      font-weight:600;\n      font-size:13px;\n      color:var(--muted);\n      display:inline-flex;\n      gap:8px;\n      align-items:center;\n    }\n    .badge .num{color:var(--accent-2); font-weight:700}\n\n    /* canvas area for tiles and buckets */\n    .canvas {\n      position:relative;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.0));\n      border-radius:10px;\n      padding:20px;\n      height:370px;\n      overflow:hidden;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n\n    .array-row{\n      position:relative;\n      height:72px;\n      border-radius:8px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border:1px dashed rgba(255,255,255,0.03);\n      display:flex;\n      align-items:center;\n      padding:12px;\n      gap:12px;\n    }\n\n    /* tile */\n    .tile{\n      min-width:56px;\n      height:48px;\n      background:linear-gradient(180deg,#0b1224,#071428);\n      border-radius:10px;\n      border:1px solid var(--tile-border);\n      display:inline-flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:700;\n      color:#eaf5ff;\n      font-size:15px;\n      box-shadow:0 6px 18px rgba(2,6,23,0.6);\n      position:absolute;\n      left:0;\n      top:0;\n      transition:transform 400ms cubic-bezier(.2,.9,.2,1), box-shadow 200ms;\n      padding:6px;\n      text-align:center;\n      line-height:1;\n    }\n    .tile:focus{outline:3px solid rgba(96,165,250,0.18)}\n    .digit{\n      display:block;\n      color:var(--muted);\n      font-size:11px;\n      font-weight:600;\n      margin-top:6px;\n    }\n\n    /* bucket area */\n    .buckets {\n      flex:1;\n      display:flex;\n      gap:8px;\n      align-items:flex-start;\n      padding-top:6px;\n    }\n    .bucket {\n      flex:1;\n      min-width:48px;\n      background:rgba(255,255,255,0.02);\n      border:1px solid rgba(255,255,255,0.02);\n      border-radius:8px;\n      padding:8px;\n      height:200px;\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      align-items:center;\n      position:relative;\n    }\n    .bucket-label{\n      position:absolute;\n      top:8px;\n      left:8px;\n      background:rgba(0,0,0,0.25);\n      padding:4px 6px;\n      border-radius:6px;\n      font-weight:700;\n      color:var(--muted);\n      font-size:12px;\n    }\n    .bucket-queue{\n      margin-top:32px;\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      align-items:center;\n    }\n\n    .hint{\n      color:var(--muted);\n      font-size:13px;\n      line-height:1.4;\n    }\n\n    .controls-row{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n\n    /* small helpers */\n    .muted-block{color:var(--muted); font-size:13px}\n    .error{color:var(--danger); font-weight:700;margin-top:6px}\n    footer{margin-top:12px;color:var(--muted);font-size:12px}\n\n    /* Responsive adjustments */\n    @media (max-width:500px){\n      .tile{min-width:48px;height:42px;font-size:13px}\n      .array-row{height:62px;padding:8px}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"module\" role=\"main\" aria-label=\"Radix Sort interactive module\">\n    <!-- Left panel: explanation and controls -->\n    <aside class=\"panel\" aria-labelledby=\"title\">\n      <h1 id=\"title\">Radix Sort (LSD) — Interactive</h1>\n      <p class=\"lead\">Explore least-significant-digit (LSD) Radix Sort for non-negative integers. Visualize distribution by digit (buckets) and how stable collecting produces a fully sorted list.</p>\n\n      <div class=\"section-title\">Learning Objective</div>\n      <p class=\"muted\">After interacting with this module you will be able to:</p>\n      <ul class=\"muted\" style=\"margin:8px 0 0 18px; padding:0; line-height:1.4\">\n        <li>See how numbers are grouped by digits (least significant to most).</li>\n        <li>Understand why stability of each pass is essential.</li>\n        <li>Observe how multiple passes produce a sorted list without direct comparisons.</li>\n      </ul>\n\n      <div class=\"section-title\" style=\"margin-top:18px\">Interaction Design</div>\n      <p class=\"muted\" style=\"margin-top:0\">\n        Controls let you enter a custom list or randomize it, choose base (radix), step through each distribution/collection phase, or autoplay. Each number is a movable tile:\n      </p>\n      <ul class=\"muted\" style=\"margin:8px 0 0 18px\">\n        <li>Apply: parse numbers (non-negative integers). Errors display immediately.</li>\n        <li>Step: advance one animation step — either place next item into its bucket or collect next item back into the array.</li>\n        <li>Play/Pause: animate full passes sequentially; speed slider adjusts timing.</li>\n        <li>Randomize / Reset: generate a small array or restore original input.</li>\n      </ul>\n\n      <div class=\"section-title\" style=\"margin-top:18px\">Layout Description</div>\n      <p class=\"muted\" style=\"margin-top:0\">\n        Two-column layout: left column contains descriptions and controls; right column is the visualization canvas. Safe margin of 24px on all sides and 16px minimum spacing between controls. The canvas shows:\n      </p>\n      <ul class=\"muted\" style=\"margin:8px 0 0 18px\">\n        <li>Top row: current array as movable tiles.</li>\n        <li>Lower: equally spaced buckets labeled 0…(base-1).</li>\n        <li>Status bar: current pass and phase, accessible badges and hints.</li>\n      </ul>\n\n      <div style=\"height:18px\"></div>\n\n      <!-- Controls -->\n      <div class=\"controls\" aria-label=\"Controls\">\n        <div>\n          <label class=\"small\" for=\"inputArray\">Array (comma or space separated)</label>\n          <div style=\"display:flex;gap:8px\">\n            <input id=\"inputArray\" type=\"text\" placeholder=\"e.g. 170, 45, 75, 90, 802, 24, 2, 66\" aria-label=\"Array input\" />\n            <button id=\"applyBtn\" class=\"small-btn\" aria-label=\"Apply array\">Apply</button>\n          </div>\n          <div class=\"muted\" style=\"margin-top:8px\">Only non-negative integers. Max 12 elements recommended for clarity.</div>\n        </div>\n\n        <div style=\"display:flex;gap:12px;align-items:center\">\n          <div style=\"flex:1\">\n            <label class=\"small\" for=\"base\">Base (radix)</label>\n            <input id=\"base\" type=\"number\" min=\"2\" max=\"16\" value=\"10\" aria-label=\"Radix base\" />\n          </div>\n          <div style=\"width:120px\">\n            <label class=\"small\" for=\"speed\">Speed</label>\n            <input id=\"speed\" type=\"range\" min=\"200\" max=\"1800\" step=\"100\" value=\"800\" aria-label=\"Animation speed\" />\n            <div class=\"muted\" style=\"font-size:12px;margin-top:6px\">Lower is faster</div>\n          </div>\n        </div>\n\n        <div class=\"controls-row\">\n          <button id=\"stepBtn\" class=\"small-btn\" aria-label=\"Step one action\">Step</button>\n          <button id=\"playBtn\" class=\"small-btn\" aria-label=\"Play or pause\">Play</button>\n          <button id=\"resetBtn\" class=\"small-btn\" aria-label=\"Reset to original\">Reset</button>\n          <button id=\"randBtn\" class=\"small-btn\" aria-label=\"Randomize array\">Randomize</button>\n        </div>\n\n        <div>\n          <div class=\"muted-block\" id=\"statusText\" aria-live=\"polite\" style=\"margin-bottom:6px\">Status: Idle</div>\n          <div id=\"error\" class=\"error\" role=\"alert\" style=\"display:none\"></div>\n        </div>\n      </div>\n\n      <footer>\n        Tip: Try base 2 (binary) to see many passes; base 16 reduces passes but increases bucket count — both illustrate the same stable-digit grouping idea.\n      </footer>\n    </aside>\n\n    <!-- Right panel: visualization -->\n    <main class=\"visual\" aria-labelledby=\"vis-title\">\n      <div class=\"status\" role=\"status\" aria-live=\"polite\">\n        <div class=\"badge\">Pass <span class=\"num\" id=\"passNum\">0</span></div>\n        <div class=\"badge\">Phase <span class=\"num\" id=\"phaseText\">Idle</span></div>\n        <div class=\"badge\">Base <span class=\"num\" id=\"baseDisplay\">10</span></div>\n        <div class=\"muted\" style=\"margin-left:auto\" id=\"stabilityHint\">Stable order preserved each pass</div>\n      </div>\n\n      <div class=\"canvas\" id=\"canvas\" tabindex=\"0\">\n        <div class=\"array-row\" id=\"arrayRow\" aria-label=\"Current array\">\n          <!-- tiles will be absolutely positioned inside canvas; arrayRow used to compute coordinates -->\n        </div>\n\n        <div class=\"buckets\" id=\"buckets\" aria-label=\"Buckets area\">\n          <!-- bucket columns generated dynamically -->\n        </div>\n\n        <div class=\"hint\" id=\"explain\">\n          Interactive steps: Distribute numbers into buckets according to the current digit (least significant first). Then collect buckets from lowest to highest, preserving the order inside each bucket (stability). Repeat for next more significant digit until no further digits remain.\n        </div>\n      </div>\n    </main>\n  </div>\n\n  <script>\n    /* Radix Sort Interactive Module (vanilla JS)\n       - Implements LSD Radix Sort for non-negative integers\n       - Animates tiles moving to buckets and back to the array\n       - Supports stepping and autoplay\n    */\n\n    (function(){\n      // DOM elements\n      const input = document.getElementById('inputArray');\n      const baseInput = document.getElementById('base');\n      const applyBtn = document.getElementById('applyBtn');\n      const stepBtn = document.getElementById('stepBtn');\n      const playBtn = document.getElementById('playBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const randBtn = document.getElementById('randBtn');\n      const speedSlider = document.getElementById('speed');\n      const errorEl = document.getElementById('error');\n      const statusText = document.getElementById('statusText');\n      const passNumEl = document.getElementById('passNum');\n      const phaseTextEl = document.getElementById('phaseText');\n      const baseDisplay = document.getElementById('baseDisplay');\n      const canvas = document.getElementById('canvas');\n      const arrayRow = document.getElementById('arrayRow');\n      const bucketsEl = document.getElementById('buckets');\n      const explain = document.getElementById('explain');\n\n      // State\n      let originalArray = [170,45,75,90,802,24,2,66];\n      let array = [];\n      let tiles = []; // tile objects {value, el}\n      let base = 10;\n      let maxDigits = 0;\n      let pass = 0; // current digit index (0 = least significant)\n      let phase = 'idle'; // 'idle'|'distributing'|'collecting'\n      let buckets = []; // arrays of tile indices\n      let playing = false;\n      let timer = null;\n      let speed = 800; // ms per animated move default\n\n      // Config\n      const tileWidth = 56;\n      const tileHeight = 48;\n      const maxElements = 12;\n      const animationDuration = 400;\n\n      // Helpers: show error or status\n      function showError(msg){\n        errorEl.textContent = msg;\n        errorEl.style.display = msg ? 'block' : 'none';\n      }\n      function setStatus(s){\n        statusText.textContent = 'Status: ' + s;\n      }\n      function setPhase(p){\n        phase = p;\n        phaseTextEl.textContent = p === 'idle' ? 'Idle' : (p === 'distributing' ? 'Distributing' : 'Collecting');\n      }\n      function setPass(n){\n        pass = n;\n        passNumEl.textContent = n;\n      }\n      function clamp(v,min,max){return Math.max(min,Math.min(max,v))}\n\n      // Parse input into array of non-negative integers\n      function parseInput(str){\n        const parts = str.split(/[\\s,]+/).filter(Boolean);\n        if(parts.length === 0) return null;\n        if(parts.length > maxElements) { showError('Limit: max ' + maxElements + ' elements.'); return null; }\n        const out = [];\n        for(const p of parts){\n          if(!/^\\d+$/.test(p)){ showError('All values must be non-negative integers.'); return null; }\n          out.push(Number(p));\n        }\n        showError('');\n        return out;\n      }\n\n      // Create bucket DOMs depending on base\n      function createBuckets(b){\n        bucketsEl.innerHTML = '';\n        buckets = [];\n        for(let i=0;i<b;i++){\n          const bucket = document.createElement('div');\n          bucket.className = 'bucket';\n          bucket.setAttribute('aria-label','Bucket ' + i);\n          const label = document.createElement('div');\n          label.className = 'bucket-label';\n          label.textContent = i;\n          bucket.appendChild(label);\n          const queue = document.createElement('div');\n          queue.className = 'bucket-queue';\n          bucket.appendChild(queue);\n          bucketsEl.appendChild(bucket);\n          buckets.push({el:bucket, queueEl:queue, items:[]});\n        }\n      }\n\n      // Render initial array tiles at positions inside canvas\n      function renderArray(){\n        arrayRow.innerHTML = '';\n        tiles = [];\n        // compute start positions inside canvas (arrayRow has padding and gap; we will position tiles absolutely relative to canvas)\n        const canvasRect = canvas.getBoundingClientRect();\n        const rowRect = arrayRow.getBoundingClientRect();\n        const startX = 12; // left padding in arrayRow\n        const gap = 12;\n        const elLeft = arrayRow.offsetLeft;\n        const elTop = arrayRow.offsetTop;\n\n        // For responsive placement, compute tile horizontal spacing to fit\n        const available = arrayRow.clientWidth - 24; // padding both sides\n        const used = Math.min(array.length, maxElements);\n        const spacing = Math.max(tileWidth + gap, Math.floor(available / used) - 4);\n\n        for(let i=0;i<array.length;i++){\n          const val = array[i];\n          const tile = document.createElement('div');\n          tile.className = 'tile';\n          tile.setAttribute('tabindex','0');\n          tile.setAttribute('role','img');\n          tile.setAttribute('aria-label', 'Value ' + val);\n          tile.dataset.index = i;\n          tile.style.width = tileWidth + 'px';\n          tile.style.height = tileHeight + 'px';\n          tile.style.lineHeight = tileHeight + 'px';\n          tile.innerHTML = '<div style=\"font-size:14px;\">' + val + '</div><span class=\"digit\" aria-hidden=\"true\"></span>';\n          // initial absolute placement relative to canvas\n          const x = startX + i * spacing;\n          const y = arrayRow.offsetTop + (arrayRow.clientHeight - tileHeight)/2;\n          // use transform so transitions are visible\n          tile.style.transform = `translate(${x}px, ${y}px)`;\n          canvas.appendChild(tile);\n          tiles.push({value: val, el: tile, x:x, y:y});\n        }\n      }\n\n      // Utility: compute digit at pass (0 = LSD) for given base\n      function digitAt(value, passIdx, b){\n        return Math.floor(value / Math.pow(b, passIdx)) % b;\n      }\n\n      // Prepare for sorting: compute max digits and reset pass\n      function prepare(){\n        base = clamp(Number(baseInput.value) || 10, 2, 16);\n        baseDisplay.textContent = base;\n        maxDigits = 0;\n        for(const v of array){\n          const digits = v === 0 ? 1 : Math.floor(Math.log(v)/Math.log(base)) + 1;\n          maxDigits = Math.max(maxDigits, digits);\n        }\n        setPass(0);\n        setPhase('idle');\n        createBuckets(base);\n        renderArray();\n        updateDigitsOnTiles();\n        setStatus('Ready — ' + array.length + ' items, ' + maxDigits + ' passes');\n      }\n\n      function updateDigitsOnTiles(){\n        tiles.forEach(t=>{\n          const d = digitAt(t.value, pass, base);\n          const span = t.el.querySelector('.digit');\n          span.textContent = 'd' + pass + ': ' + d;\n        });\n      }\n\n      // Animate moving a tile to a target transform position (x,y)\n      function moveTileTo(tileObj, targetX, targetY, delay=0){\n        return new Promise(resolve=>{\n          const el = tileObj.el;\n          setTimeout(()=>{\n            // apply transition then resolve after duration\n            el.style.transition = `transform ${animationDuration}ms cubic-bezier(.2,.9,.2,1)`;\n            el.style.transform = `translate(${targetX}px, ${targetY}px)`;\n            // update stored coordinates\n            tileObj.x = targetX;\n            tileObj.y = targetY;\n            const handler = (e)=>{\n              if(e.propertyName === 'transform'){\n                el.removeEventListener('transitionend', handler);\n                resolve();\n              }\n            };\n            el.addEventListener('transitionend', handler);\n          }, delay);\n        });\n      }\n\n      // Distribute phase: place each array tile into appropriate bucket one by one\n      async function distributeStep(startIndex=0){\n        setPhase('distributing');\n        // clear bucket arrays\n        buckets.forEach(b => b.items = []);\n        for(let i=startIndex;i<tiles.length;i++){\n          const t = tiles[i];\n          const d = digitAt(t.value, pass, base);\n          // compute target position in bucket\n          const bucket = buckets[d];\n          const queueLen = bucket.items.length;\n          // compute bucket center x relative to canvas\n          const bucketRect = bucket.el.getBoundingClientRect();\n          const canvasRect = canvas.getBoundingClientRect();\n          // compute local x,y inside canvas for where tile should go\n          const targetX = (bucketRect.left - canvasRect.left) + (bucketRect.width - tileWidth)/2;\n          const targetY = bucket.el.offsetTop + 36 + queueLen * (tileHeight + 8);\n          // append tile visually to canvas (it's already in canvas)\n          bucket.items.push(t);\n          bucket.queueEl.appendChild(t.el); // move DOM into bucket for visual stacking (keeps transform relative)\n          // compute relative transform to keep same coordinates; we recompute target transform below\n          // set transform relative to canvas\n          const relX = (bucketRect.left - canvasRect.left) + (bucketRect.width - tileWidth)/2;\n          const relY = bucket.el.offsetTop + 36 + queueLen * (tileHeight + 8);\n          const delay = 0;\n          // Attach digit label update\n          const span = t.el.querySelector('.digit');\n          if(span) span.textContent = 'd' + pass + ': ' + d;\n          // move tile to bucket spot\n          await moveTileTo(t, relX, relY, delay);\n          // small inset shadow to show it's been placed\n          t.el.style.boxShadow = '0 8px 20px rgba(2,6,23,0.6)';\n          // Pause between placements depending on speed\n          await sleep(Math.max(80, speed/8));\n          if(!playing) {\n            // if playing was turned off, we still finish step as part of this step invocation\n          }\n        }\n      }\n\n      // Collect phase: gather buckets from 0..base-1 preserving order\n      async function collectStep(){\n        setPhase('collecting');\n        const canvasRect = canvas.getBoundingClientRect();\n        // We'll build a new tiles array in collected order\n        const newTiles = [];\n        let index = 0;\n        // compute spacing for final array positions\n        const available = arrayRow.clientWidth - 24;\n        const used = Math.max(1, tiles.length);\n        const spacing = Math.max(tileWidth + 12, Math.floor(available / used) - 4);\n        for(let b=0;b<buckets.length;b++){\n          const bucket = buckets[b];\n          for(const t of bucket.items){\n            // compute target x,y back in array row\n            const targetX = 12 + index * spacing;\n            const targetY = arrayRow.offsetTop + (arrayRow.clientHeight - tileHeight)/2;\n            // move tile back to canvas root (so z-order)\n            canvas.appendChild(t.el);\n            await moveTileTo(t, targetX, targetY, 0);\n            // update digit label for clarity (unchanged)\n            const span = t.el.querySelector('.digit');\n            if(span) span.textContent = 'd' + pass + ': ' + b;\n            newTiles.push(t);\n            index++;\n            await sleep(Math.max(80, speed/8));\n          }\n        }\n        // reorder tiles array to new order\n        tiles = newTiles;\n        // update underlying array values to match collected order\n        array = tiles.map(t => t.value);\n        setStatus('After pass ' + pass + ': ' + array.join(', '));\n      }\n\n      // Step controller: perform either distributing or collecting for current pass and progress state\n      async function stepOnce(){\n        if(phase === 'idle'){\n          if(pass >= maxDigits){\n            setStatus('Sorting complete');\n            setPhase('idle');\n            return;\n          }\n          // start distributing\n          await distributeStep(0);\n          setStatus('Distributed pass ' + pass);\n          // after distributing, set phase to collecting automatically\n          setPhase('collecting');\n        } else if(phase === 'distributing'){\n          // we assume distributeStep completed in our implementation; move to collecting\n          setPhase('collecting');\n        }\n        if(phase === 'collecting'){\n          await collectStep();\n          // increment pass\n          setPass(pass + 1);\n          updateDigitsOnTiles();\n          // clear buckets\n          createBuckets(base);\n          // update tiles' DOM parent to canvas\n          tiles.forEach((t,idx)=>{\n            canvas.appendChild(t.el);\n          });\n          if(pass >= maxDigits){\n            setPhase('idle');\n            setStatus('Sorting complete');\n          } else {\n            setPhase('idle'); // ready to start next pass with a new step\n            setStatus('Ready for next pass');\n          }\n        }\n      }\n\n      // Sleep helper\n      function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }\n\n      // Play controller: runs steps automatically until finish or pause\n      async function playLoop(){\n        playing = true;\n        playBtn.textContent = 'Pause';\n        setStatus('Playing...');\n        while(playing){\n          // If sorting complete\n          if(pass >= maxDigits){\n            setStatus('Sorting complete');\n            setPhase('idle');\n            playing = false;\n            playBtn.textContent = 'Play';\n            break;\n          }\n          // Start distribute then collect for this pass\n          setPhase('distributing');\n          await distributeStep(0);\n          await sleep(120);\n          setPhase('collecting');\n          await collectStep();\n          setPass(pass + 1);\n          updateDigitsOnTiles();\n          createBuckets(base);\n          tiles.forEach(t => canvas.appendChild(t.el));\n          await sleep(120);\n          if(pass >= maxDigits){\n            setStatus('Sorting complete');\n            setPhase('idle');\n            playing = false;\n            playBtn.textContent = 'Play';\n            break;\n          }\n          // short pause before next pass\n          await sleep(200);\n        }\n      }\n\n      // UI bindings\n      applyBtn.addEventListener('click', ()=>{\n        const parsed = parseInput(input.value || '');\n        if(!parsed) return;\n        originalArray = parsed.slice();\n        array = parsed.slice();\n        prepare();\n      });\n\n      baseInput.addEventListener('change', ()=>{\n        const b = clamp(Number(baseInput.value) || 10, 2, 16);\n        baseInput.value = b;\n        baseDisplay.textContent = b;\n        if(array.length) prepare();\n      });\n\n      stepBtn.addEventListener('click', async ()=>{\n        if(playing) return; // disable step while playing\n        setStatus('Stepping...');\n        await stepOnce();\n      });\n\n      playBtn.addEventListener('click', ()=>{\n        if(playing){\n          playing = false;\n          playBtn.textContent = 'Play';\n          setStatus('Paused');\n        } else {\n          // ensure state prepared\n          if(array.length === 0){ showError('Apply an array first.'); return; }\n          showError('');\n          playLoop();\n        }\n      });\n\n      resetBtn.addEventListener('click', ()=>{\n        playing = false;\n        playBtn.textContent = 'Play';\n        array = originalArray.slice();\n        prepare();\n      });\n\n      randBtn.addEventListener('click', ()=>{\n        // generate random length 6-10\n        const n = Math.floor(Math.random() * 5) + 5;\n        const arr = [];\n        for(let i=0;i<n;i++){\n          arr.push(Math.floor(Math.random()*900) + Math.floor(Math.random()*10)); // varied distribution\n        }\n        originalArray = arr.slice();\n        array = arr.slice();\n        input.value = arr.join(', ');\n        prepare();\n      });\n\n      speedSlider.addEventListener('input', ()=>{\n        speed = Number(speedSlider.value);\n      });\n\n      // Keyboard shortcuts: Space = step, P = play/pause, R = reset\n      document.addEventListener('keydown', (e)=>{\n        if(e.code === 'Space'){ e.preventDefault(); stepBtn.click(); }\n        if(e.key === 'p' || e.key === 'P'){ playBtn.click(); }\n        if(e.key === 'r' || e.key === 'R'){ resetBtn.click(); }\n      });\n\n      // Initialization\n      function init(){\n        input.value = originalArray.join(', ');\n        array = originalArray.slice();\n        prepare();\n      }\n\n      // Make sure the canvas is focusable for accessibility\n      canvas.setAttribute('tabindex','0');\n\n      init();\n\n      // Expose some actions for easier testing in dev console (optional)\n      window.radixModule = {\n        getState: () => ({array, pass, phase, base, tiles}),\n      };\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Radix Sort.\n\n**Project Overview:**\nTopic: Radix Sort\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Radix Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "d884a650-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:47:34.197Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Merge Sort",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Merge Sort — Interactive Module</title>\n  <style>\n    :root{\n      --safe: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --muted: #94a3b8;\n      --accent: #60a5fa;\n      --accent-2: #7c3aed;\n      --good: #34d399;\n      --danger: #fb7185;\n      --surface: #0b1220;\n      --text: #e6eef8;\n      --panel: #0f1724;\n      --action: #f59e0b;\n    }\n\n    html,body{\n      height:100%;\n      margin:0;\n      background:linear-gradient(180deg,#071127 0%, #07111a 100%);\n      color:var(--text);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n\n    /* Safe area container */\n    .app {\n      padding: var(--safe);\n      box-sizing: border-box;\n      min-height:100vh;\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n    }\n\n    /* Two-column responsive */\n    .left {\n      width:360px;\n      min-width:280px;\n      max-width:40%;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:20px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:16px;\n    }\n\n    .right {\n      flex:1;\n      min-width:0;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:12px;\n      padding:20px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:16px;\n      align-items:stretch;\n    }\n\n    h1 {\n      font-size:18px;\n      margin:0 0 4px 0;\n      color:var(--text);\n    }\n    p.small {\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n      line-height:1.4;\n    }\n\n    .section {\n      background: rgba(255,255,255,0.02);\n      border-radius:8px;\n      padding:12px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n\n    label.block {\n      display:block;\n      font-size:13px;\n      color:var(--muted);\n      margin-bottom:6px;\n    }\n\n    .controls {\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n    }\n\n    button, input[type=\"number\"], select, .small-btn {\n      font-size:13px;\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.04);\n      background:transparent;\n      color:var(--text);\n      cursor:pointer;\n    }\n\n    button:active{ transform:translateY(1px); }\n    button.primary {\n      background:linear-gradient(90deg,var(--accent),var(--accent-2));\n      border: none;\n      color:white;\n      box-shadow:0 6px 18px rgba(124,58,237,0.12);\n    }\n\n    .row {\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n\n    input[type=\"text\"] {\n      width:100%;\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.04);\n      background:transparent;\n      color:var(--text);\n      font-size:13px;\n    }\n\n    .slider {\n      width:100%;\n    }\n\n    .visual {\n      height:360px;\n      min-height:260px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:8px;\n      padding:16px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      align-items:stretch;\n    }\n\n    .array-area {\n      flex:1;\n      position:relative;\n      background:linear-gradient(180deg, rgba(0,0,0,0.04), rgba(255,255,255,0.01));\n      border-radius:8px;\n      padding:12px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      overflow:visible;\n    }\n\n    .array-line {\n      position:relative;\n      width:100%;\n      height:120px;\n      max-height:180px;\n      min-height:80px;\n      display:block;\n    }\n\n    .bar {\n      position:absolute;\n      bottom:8px;\n      width:40px;\n      height:40px;\n      border-radius:6px;\n      background:linear-gradient(180deg,#1e293b,#0b1220);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      color:var(--text);\n      font-weight:600;\n      box-shadow:0 6px 14px rgba(2,6,23,0.6);\n      transition:transform 300ms ease, background 250ms ease, opacity 200ms ease;\n      user-select:none;\n    }\n\n    .bar .val {\n      font-size:13px;\n    }\n\n    .bar.compare {\n      background: linear-gradient(180deg,#f97316,#fb923c);\n      box-shadow:0 8px 18px rgba(249,115,22,0.16);\n      z-index:6;\n    }\n\n    .bar.merged {\n      background: linear-gradient(180deg,#10b981,#34d399);\n      box-shadow:0 8px 18px rgba(16,185,129,0.12);\n      z-index:5;\n    }\n\n    .bar.source {\n      opacity:0.85;\n      transform:translateY(-6px) scale(0.98);\n    }\n\n    .temp-layer {\n      position:absolute;\n      top:0;\n      left:0;\n      right:0;\n      bottom:0;\n      pointer-events:none;\n    }\n\n    .temp {\n      position:absolute;\n      width:40px;\n      height:40px;\n      border-radius:6px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      color:white;\n      font-weight:700;\n      background:linear-gradient(180deg,#7c3aed,#60a5fa);\n      box-shadow:0 10px 30px rgba(12,8,40,0.6);\n      transition:transform 350ms cubic-bezier(.2,.9,.2,1), opacity 250ms ease;\n      z-index:10;\n    }\n\n    .meta {\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content:space-between;\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    .stats {\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n\n    .stat {\n      background:rgba(255,255,255,0.02);\n      padding:8px 10px;\n      border-radius:8px;\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    .legend {\n      display:flex;\n      gap:8px;\n      align-items:center;\n      color:var(--muted);\n      font-size:13px;\n      margin-top:6px;\n    }\n\n    .swatch {\n      width:12px;\n      height:12px;\n      border-radius:3px;\n      margin-right:6px;\n    }\n\n    /* responsive */\n    @media (max-width:900px){\n      .app { flex-direction:column; }\n      .left { width:100%; max-width:none; }\n      .right { width:100%; }\n    }\n\n    /* small helpers */\n    .muted { color:var(--muted); font-size:13px; }\n    .center { display:flex; align-items:center; justify-content:center; gap:8px; }\n    .small-btn {\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.03);\n      padding:6px 8px;\n    }\n\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Merge Sort Interactive Module\">\n    <aside class=\"left\" aria-label=\"Module Controls and Explanation\">\n      <div>\n        <h1>Merge Sort — Divide & Conquer Visualization</h1>\n        <p class=\"small\">Interactive, step-by-step exploration of how Merge Sort splits arrays and merges them back in sorted order.</p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"objective-title\">\n        <div id=\"objective-title\" style=\"display:flex; justify-content:space-between; align-items:center;\">\n          <strong>Learning objective</strong>\n          <span class=\"muted\" style=\"font-size:12px\">One concept</span>\n        </div>\n        <p class=\"small\">After using this module you will be able to:\n          - understand how merge sort recursively splits an array into halves,\n          - follow the merge step where two sorted halves are compared and combined,\n          - observe the cost in comparisons and writes, and step through each elementary action.</p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"interaction-title\">\n        <strong id=\"interaction-title\">Interaction design</strong>\n        <p class=\"small\">\n          Controls:\n          - Generate a random array or enter a custom comma-separated array.\n          - Set array size, animation speed.\n          - Use Start / Pause / Step / Reset to control playback.\n        </p>\n        <p class=\"small\">\n          Visual & tactile feedback:\n          - Compare actions highlight two elements (orange).\n          - When an element is taken for merge a temporary tile animates to the merge position.\n          - Writes copy merged values back and turn elements green for the merged range.\n          - A live counter shows comparisons and writes to reinforce algorithm cost.\n        </p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"layout-title\">\n        <strong id=\"layout-title\">Layout description</strong>\n        <p class=\"small\">\n          - Safe area: 24px padding around the viewport; minimum spacing between interactive elements is 16px.\n          - Left column holds controls & descriptions; right column contains the visualization, playback controls and stats.\n          - Responsive: on narrow screens the left column stacks above the visual area.\n        </p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"controls-title\" style=\"margin-top:4px\">\n        <div id=\"controls-title\" style=\"display:flex; justify-content:space-between; align-items:center;\">\n          <strong>Controls</strong>\n          <span class=\"muted\" style=\"font-size:12px\">Interactive</span>\n        </div>\n\n        <div class=\"row\">\n          <label class=\"block\">Array size (3–20)</label>\n          <input id=\"size\" type=\"number\" min=\"3\" max=\"20\" value=\"8\" />\n          <button id=\"rand\" class=\"small-btn\">Randomize</button>\n        </div>\n\n        <div class=\"row\">\n          <label class=\"block\" style=\"flex:1\">Custom array (comma-separated)</label>\n        </div>\n        <div class=\"row\">\n          <input id=\"custom\" type=\"text\" placeholder=\"e.g. 5,2,9,1,6\" aria-label=\"Custom array input\"/>\n          <button id=\"load\" class=\"small-btn\">Load</button>\n        </div>\n\n        <div class=\"row\">\n          <label class=\"block\" style=\"width:100%\">Speed (animation)</label>\n          <input id=\"speed\" class=\"slider\" type=\"range\" min=\"0.25\" max=\"3\" value=\"1\" step=\"0.25\" />\n        </div>\n\n        <div class=\"row controls\" style=\"margin-top:8px;\">\n          <button id=\"start\" class=\"primary\">Start</button>\n          <button id=\"step\" class=\"small-btn\">Step</button>\n          <button id=\"pause\" class=\"small-btn\">Pause</button>\n          <button id=\"reset\" class=\"small-btn\">Reset</button>\n        </div>\n\n        <div style=\"margin-top:8px; font-size:13px; color:var(--muted);\">\n          Tips: Use Step to inspect individual comparisons. Pause anytime to examine the state.\n        </div>\n      </div>\n\n    </aside>\n\n    <main class=\"right\" aria-label=\"Visualization and Playback\">\n      <div class=\"visual\" role=\"region\" aria-label=\"Merge sort visualization\">\n        <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n          <div style=\"display:flex; flex-direction:column;\">\n            <strong>Array visualization</strong>\n            <div class=\"muted\" style=\"margin-top:4px; font-size:13px\">Colors:\n              <span style=\"display:inline-flex; align-items:center; gap:8px; margin-left:8px;\">\n                <span class=\"swatch\" style=\"background:#f97316\"></span><span class=\"muted\">compare</span>\n                <span style=\"width:16px\"></span>\n                <span class=\"swatch\" style=\"background:#10b981\"></span><span class=\"muted\">merged</span>\n              </span>\n            </div>\n          </div>\n\n          <div class=\"meta\" style=\"min-width:240px;\">\n            <div class=\"stats\">\n              <div class=\"stat\">Comparisons: <span id=\"comp\">0</span></div>\n              <div class=\"stat\">Writes: <span id=\"writes\">0</span></div>\n            </div>\n            <div style=\"font-size:13px; color:var(--muted);\">Step: <span id=\"stepIndex\">0</span>/<span id=\"totalSteps\">0</span></div>\n          </div>\n        </div>\n\n        <div class=\"array-area\" id=\"arrayArea\" aria-live=\"polite\">\n          <div class=\"array-line\" id=\"arrayLine\" aria-hidden=\"false\"></div>\n          <div class=\"temp-layer\" id=\"tempLayer\" aria-hidden=\"true\"></div>\n        </div>\n\n        <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n          <div class=\"muted\" style=\"font-size:13px\">\n            Playback: <span id=\"status\">idle</span>\n          </div>\n          <div style=\"display:flex; gap:8px; align-items:center;\">\n            <button id=\"fast\" class=\"small-btn\" title=\"Speed up\">+ Speed</button>\n            <button id=\"slow\" class=\"small-btn\" title=\"Slow down\">- Speed</button>\n            <button id=\"explain\" class=\"small-btn\" title=\"Short explanation\">Explain</button>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"section\" aria-live=\"polite\">\n        <strong>Explanation (brief)</strong>\n        <p class=\"small\">\n          Merge Sort works by recursively splitting the array until single elements remain, then merging\n          pairs of sorted subarrays by repeatedly comparing their front elements and selecting the smaller one.\n          This module emphasizes the split boundaries, each compare, and each write (copy back), showing the algorithm's mechanics and cost.\n        </p>\n      </div>\n\n    </main>\n  </div>\n\n  <script>\n    // Merge Sort Interactive Module — vanilla JS\n    (function(){\n      // DOM\n      const sizeInput = document.getElementById('size');\n      const randBtn = document.getElementById('rand');\n      const customInput = document.getElementById('custom');\n      const loadBtn = document.getElementById('load');\n      const speedInput = document.getElementById('speed');\n      const startBtn = document.getElementById('start');\n      const stepBtn = document.getElementById('step');\n      const pauseBtn = document.getElementById('pause');\n      const resetBtn = document.getElementById('reset');\n      const fastBtn = document.getElementById('fast');\n      const slowBtn = document.getElementById('slow');\n      const explainBtn = document.getElementById('explain');\n\n      const arrayLine = document.getElementById('arrayLine');\n      const tempLayer = document.getElementById('tempLayer');\n      const compCounter = document.getElementById('comp');\n      const writesCounter = document.getElementById('writes');\n      const statusLabel = document.getElementById('status');\n      const stepIndexLabel = document.getElementById('stepIndex');\n      const totalStepsLabel = document.getElementById('totalSteps');\n\n      // State\n      let initialArray = [];\n      let arr = [];\n      let steps = []; // recorded actions\n      let stepPos = 0;\n      let playing = false;\n      let speed = parseFloat(speedInput.value) || 1;\n      let timer = null;\n      let comparisons = 0;\n      let writes = 0;\n\n      // visual parameters\n      const minSize = 3;\n      const maxSize = 20;\n      const barWidth = 40;\n      const barGap = 8;\n\n      // Helpers\n      function randArray(n){\n        const a = [];\n        for(let i=0;i<n;i++) a.push(Math.floor(Math.random()*90)+10);\n        return a;\n      }\n\n      function clampSize(v){\n        v = Math.max(minSize, Math.min(maxSize, Number(v)||minSize));\n        sizeInput.value = v;\n        return v;\n      }\n\n      // UI init\n      function init(){\n        clampSize(sizeInput.value);\n        initialArray = randArray(Number(sizeInput.value));\n        loadArray(initialArray);\n      }\n\n      function loadArray(a){\n        initialArray = a.slice();\n        resetState();\n        renderArray(initialArray);\n      }\n\n      function resetState(){\n        if(timer) { clearTimeout(timer); timer = null; }\n        playing = false;\n        stepPos = 0;\n        comparisons = 0;\n        writes = 0;\n        compCounter.textContent = '0';\n        writesCounter.textContent = '0';\n        statusLabel.textContent = 'idle';\n        stepIndexLabel.textContent = '0';\n        totalStepsLabel.textContent = '0';\n        // clear temp layer\n        tempLayer.innerHTML = '';\n        // clear highlights\n        const bars = arrayLine.querySelectorAll('.bar');\n        bars.forEach(b=> {\n          b.classList.remove('compare');\n          b.classList.remove('merged');\n          b.style.transform = '';\n          b.style.opacity = '1';\n        });\n      }\n\n      // Render main array as bars positioned absolutely\n      function renderArray(a){\n        arr = a.slice();\n        arrayLine.innerHTML = '';\n        tempLayer.innerHTML = '';\n        const n = arr.length;\n        const containerWidth = arrayLine.clientWidth || arrayLine.getBoundingClientRect().width;\n        // compute width allocation\n        const totalGap = (n-1) * barGap;\n        let available = containerWidth - totalGap;\n        let w = barWidth;\n        // if doesn't fit, scale width\n        const needed = n * w;\n        if(needed > containerWidth){\n          w = Math.max(28, Math.floor((containerWidth - totalGap) / n));\n        }\n        const effectiveWidth = w;\n        // position bars\n        for(let i=0;i<n;i++){\n          const el = document.createElement('div');\n          el.className = 'bar';\n          el.style.width = effectiveWidth + 'px';\n          el.style.left = (i*(effectiveWidth + barGap)) + 'px';\n          el.dataset.index = i;\n          el.dataset.value = String(arr[i]);\n          el.innerHTML = '<div class=\"val\">'+arr[i]+'</div>';\n          arrayLine.appendChild(el);\n        }\n      }\n\n      // Record actions with a modified merge sort\n      function recordActions(inputArray){\n        const a = inputArray.slice();\n        const actions = [];\n        function mergeSort(l, r){\n          if(r - l <= 1) return;\n          const mid = Math.floor((l + r)/2);\n          actions.push({type:'split', l, r, mid});\n          mergeSort(l, mid);\n          mergeSort(mid, r);\n          // merge\n          let i = l, j = mid;\n          const temp = [];\n          while(i < mid || j < r){\n            if(i < mid && j < r){\n              actions.push({type:'compare', i, j});\n              if(a[i] <= a[j]){\n                actions.push({type:'take', from:i, value:a[i]});\n                temp.push(a[i]); i++;\n              } else {\n                actions.push({type:'take', from:j, value:a[j]});\n                temp.push(a[j]); j++;\n              }\n            } else if(i < mid){\n              actions.push({type:'take', from:i, value:a[i]});\n              temp.push(a[i]); i++;\n            } else {\n              actions.push({type:'take', from:j, value:a[j]});\n              temp.push(a[j]); j++;\n            }\n          }\n          for(let k=l;k<r;k++){\n            actions.push({type:'write', index:k, value: temp[k-l]});\n            a[k] = temp[k-l];\n          }\n          actions.push({type:'merged', l, r});\n        }\n        mergeSort(0, a.length);\n        return actions;\n      }\n\n      // Playback handlers\n      function startPlayback(){\n        if(playing) return;\n        if(steps.length === 0){\n          steps = recordActions(initialArray);\n          totalStepsLabel.textContent = steps.length;\n        }\n        playing = true;\n        statusLabel.textContent = 'playing';\n        scheduleNext();\n      }\n\n      function pausePlayback(){\n        playing = false;\n        statusLabel.textContent = 'paused';\n        if(timer){ clearTimeout(timer); timer = null; }\n      }\n\n      function resetPlayback(){\n        pausePlayback();\n        resetState();\n        renderArray(initialArray);\n        steps = [];\n      }\n\n      // step one action (used by Step button)\n      function doStep(){\n        if(steps.length === 0){\n          steps = recordActions(initialArray);\n          totalStepsLabel.textContent = steps.length;\n        }\n        if(stepPos >= steps.length){\n          statusLabel.textContent = 'finished';\n          playing = false;\n          return;\n        }\n        const action = steps[stepPos++];\n        stepIndexLabel.textContent = stepPos;\n        executeAction(action);\n      }\n\n      // schedule next automatic step using speed\n      function scheduleNext(){\n        if(!playing) return;\n        if(stepPos >= steps.length){\n          statusLabel.textContent = 'finished';\n          playing = false;\n          return;\n        }\n        const delayBase = 500; // base ms\n        const delay = Math.max(70, delayBase / speed);\n        timer = setTimeout(() => {\n          doStep();\n          scheduleNext();\n        }, delay);\n      }\n\n      // Execute recorded action and trigger visuals\n      function executeAction(action){\n        switch(action.type){\n          case 'split':\n            highlightRange(action.l, action.r, 'split');\n            break;\n          case 'compare':\n            comparisons++;\n            compCounter.textContent = String(comparisons);\n            highlightCompare(action.i, action.j);\n            break;\n          case 'take':\n            animateTake(action.from, action.value);\n            break;\n          case 'write':\n            writes++;\n            writesCounter.textContent = String(writes);\n            animateWrite(action.index, action.value);\n            break;\n          case 'merged':\n            markMerged(action.l, action.r);\n            break;\n          default:\n            // noop\n            break;\n        }\n      }\n\n      // Visual helpers\n      function highlightRange(l, r, why){\n        // subtle: dim other bars, and brighten this range temporarily\n        const bars = arrayLine.querySelectorAll('.bar');\n        bars.forEach(b=>{\n          const idx = Number(b.dataset.index);\n          if(idx >= l && idx < r){\n            b.style.opacity = '1';\n            b.style.transform = 'translateY(-4px)';\n          } else {\n            b.style.opacity = '0.45';\n            b.style.transform = 'translateY(0px) scale(0.98)';\n          }\n        });\n        // remove highlight after short time (but don't block)\n        setTimeout(()=> {\n          bars.forEach(b=>{\n            b.style.opacity = '1';\n            b.style.transform = '';\n          });\n        }, 700 / speed);\n      }\n\n      function highlightCompare(i,j){\n        const b1 = arrayLine.querySelector('.bar[data-index=\"'+i+'\"]');\n        const b2 = arrayLine.querySelector('.bar[data-index=\"'+j+'\"]');\n        if(!b1 || !b2) return;\n        b1.classList.add('compare');\n        b2.classList.add('compare');\n        // remove after brief moment\n        setTimeout(()=> {\n          b1.classList.remove('compare');\n          b2.classList.remove('compare');\n        }, 400 / speed);\n      }\n\n      function animateTake(fromIndex, value){\n        // create a temp tile at position of source bar and move it to next merge slot visually above the array center\n        const source = arrayLine.querySelector('.bar[data-index=\"'+fromIndex+'\"]');\n        if(!source) return;\n        const rect = arrayLine.getBoundingClientRect();\n        const srcRect = source.getBoundingClientRect();\n        const layerRect = tempLayer.getBoundingClientRect();\n        const tempEl = document.createElement('div');\n        tempEl.className = 'temp';\n        tempEl.textContent = value;\n        tempLayer.appendChild(tempEl);\n        // set initial position relative to layer (absolute)\n        const startLeft = srcRect.left - layerRect.left;\n        const startTop = srcRect.top - layerRect.top;\n        tempEl.style.left = startLeft + 'px';\n        tempEl.style.top = startTop + 'px';\n        tempEl.style.width = source.offsetWidth + 'px';\n        tempEl.style.height = source.offsetHeight + 'px';\n        tempEl.style.opacity = '1';\n        // compute merge target position: we'll place merges centered horizontally in the merged range area.\n        // For simplicity, target y is top: 8px; target x is center of array area (progressively left-to-right).\n        const targetTop = 8;\n        // compute next slot index based on current number of temps in tempLayer\n        const existingTemps = tempLayer.querySelectorAll('.temp');\n        const slot = existingTemps.length - 1; // since we've already appended, slot is count-1\n        // place distributed across width\n        const containerWidth = arrayLine.clientWidth || arrayLine.getBoundingClientRect().width;\n        const slotX = Math.max(8, (slot * (source.offsetWidth + barGap)) + 8);\n        // animate move\n        requestAnimationFrame(()=> {\n          tempEl.style.transition = 'transform 420ms cubic-bezier(.2,.9,.2,1), opacity 200ms ease';\n          const dx = slotX - startLeft;\n          const dy = targetTop - startTop;\n          tempEl.style.transform = `translate(${dx}px, ${dy}px)`;\n        });\n        // leave the temp in layer for later \"write\" step which will remove it when copying back\n        // after a timeout, we may dim the source to indicate it's been used\n        setTimeout(()=> {\n          if(source) source.classList.add('source');\n        }, 200 / speed);\n      }\n\n      function animateWrite(index, value){\n        // find main bar at index and set new value + flash merged color\n        const target = arrayLine.querySelector('.bar[data-index=\"'+index+'\"]');\n        if(!target) return;\n        // optionally, find a temp tile (FIFO) and animate it to target\n        const temp = tempLayer.querySelector('.temp');\n        if(temp){\n          const layerRect = tempLayer.getBoundingClientRect();\n          const tarRect = target.getBoundingClientRect();\n          const tLeft = parseFloat(temp.style.left || 0);\n          const tTop = parseFloat(temp.style.top || 0);\n          const dx = tarRect.left - layerRect.left - tLeft;\n          const dy = tarRect.top - layerRect.top - tTop;\n          temp.style.transform = `translate(${dx}px, ${dy}px)`;\n          // after it arrives, update main and remove temp\n          setTimeout(()=> {\n            target.dataset.value = String(value);\n            target.querySelector('.val').textContent = String(value);\n            target.classList.add('merged');\n            target.classList.remove('source');\n            // remove the temp\n            if(temp && temp.parentNode) temp.parentNode.removeChild(temp);\n          }, 380 / speed);\n        } else {\n          // fallback: instant update with flash\n          target.dataset.value = String(value);\n          target.querySelector('.val').textContent = String(value);\n          target.classList.add('merged');\n          target.classList.remove('source');\n        }\n\n        // clean merged class after a while\n        setTimeout(()=> {\n          if(target) target.classList.remove('merged');\n        }, 900 / speed);\n      }\n\n      function markMerged(l,r){\n        // mark these indices as sorted (green) briefly\n        for(let k=l;k<r;k++){\n          const b = arrayLine.querySelector('.bar[data-index=\"'+k+'\"]');\n          if(b){\n            b.classList.add('merged');\n            b.style.opacity = '1';\n            b.style.transform = '';\n          }\n        }\n        setTimeout(()=> {\n          for(let k=l;k<r;k++){\n            const b = arrayLine.querySelector('.bar[data-index=\"'+k+'\"]');\n            if(b) b.classList.remove('merged');\n          }\n        }, 900 / speed);\n      }\n\n      // UI events\n      randBtn.addEventListener('click', ()=>{\n        const n = clampSize(sizeInput.value);\n        const a = randArray(n);\n        loadArray(a);\n      });\n\n      loadBtn.addEventListener('click', ()=>{\n        const txt = customInput.value.trim();\n        if(!txt) return;\n        const parts = txt.split(',').map(s=>s.trim()).filter(Boolean);\n        if(parts.length < minSize || parts.length > maxSize){\n          alert('Please enter between '+minSize+' and '+maxSize+' numbers.');\n          return;\n        }\n        const nums = [];\n        for(const p of parts){\n          const v = Number(p);\n          if(Number.isFinite(v)){\n            nums.push(v);\n          } else {\n            alert('Invalid value: ' + p);\n            return;\n          }\n        }\n        sizeInput.value = nums.length;\n        loadArray(nums);\n      });\n\n      sizeInput.addEventListener('change', ()=>{\n        const n = clampSize(sizeInput.value);\n        const a = randArray(n);\n        loadArray(a);\n      });\n\n      speedInput.addEventListener('input', ()=>{\n        speed = parseFloat(speedInput.value) || 1;\n      });\n\n      startBtn.addEventListener('click', ()=>{\n        if(playing) return;\n        if(stepPos === 0 && steps.length === 0){\n          steps = recordActions(initialArray);\n          totalStepsLabel.textContent = steps.length;\n        }\n        startPlayback();\n      });\n\n      pauseBtn.addEventListener('click', ()=> pausePlayback());\n\n      stepBtn.addEventListener('click', ()=>{\n        pausePlayback();\n        doStep();\n      });\n\n      resetBtn.addEventListener('click', ()=>{\n        resetPlayback();\n      });\n\n      fastBtn.addEventListener('click', ()=>{\n        speed = Math.min(3, speed + 0.25);\n        speedInput.value = String(speed);\n      });\n      slowBtn.addEventListener('click', ()=>{\n        speed = Math.max(0.25, speed - 0.25);\n        speedInput.value = String(speed);\n      });\n\n      explainBtn.addEventListener('click', ()=>{\n        alert('Merge Sort: recursively split the array into halves until you have single-element arrays. Then repeatedly compare the first elements of two sorted halves and move the smaller into a result array. After merging, write the result back into the original range. This visualization shows each compare, take (moving into merge), and write (copy back).');\n      });\n\n      // keep labels in sync\n      setInterval(()=>{\n        stepIndexLabel.textContent = String(stepPos);\n      }, 200);\n\n      // initialize\n      init();\n\n      // handle window resize to re-render array positions\n      let resizeTimer = null;\n      window.addEventListener('resize', ()=>{\n        if(resizeTimer) clearTimeout(resizeTimer);\n        resizeTimer = setTimeout(()=> {\n          renderArray(initialArray);\n        }, 200);\n      });\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Merge Sort.\n\n**Project Overview:**\nTopic: Merge Sort\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Merge Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "d98e2710-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:47:35.937Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Linear Search",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Module — Linear Search</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1720;\n      --pane: #0b1220;\n      --muted: #98a0b3;\n      --accent: #60a5fa;\n      --success: #34d399;\n      --danger: #fb7185;\n      --glass: rgba(255,255,255,0.03);\n      --cell-size: 64px;\n      --cell-gap: 12px;\n    }\n\n    /* Safe area margins */\n    html,body{height:100%;}\n    body{\n      margin:0;\n      padding:var(--safe-margin);\n      font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background: linear-gradient(180deg,#071023,#071428 60%);\n      color: #e6eef8;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      box-sizing:border-box;\n    }\n\n    *{box-sizing:inherit;}\n\n    /* Layout container */\n    .container{\n      display:grid;\n      grid-template-columns: 360px 1fr;\n      gap: var(--gap);\n      align-items:start;\n      max-width:1300px;\n      margin: 0 auto;\n    }\n\n    /* Responsive: stack on small widths */\n    @media (max-width:920px){\n      .container{grid-template-columns: 1fr; padding-bottom:40px;}\n    }\n\n    /* Left control panel */\n    .panel{\n      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));\n      border-radius:12px;\n      padding:20px;\n      min-height:200px;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    h1{\n      margin:0;\n      font-size:20px;\n      color:var(--accent);\n      letter-spacing:0.2px;\n    }\n    .meta{color:var(--muted); font-size:13px; margin-top:2px;}\n\n    .controls{ display:flex; flex-direction:column; gap:var(--gap); }\n\n    label{font-size:13px; color:var(--muted); display:block; margin-bottom:8px;}\n    .row{display:flex; gap:var(--gap); align-items:center; flex-wrap:wrap;}\n\n    input[type=\"number\"], input[type=\"text\"], select{\n      background:var(--glass);\n      border:1px solid rgba(255,255,255,0.04);\n      color:inherit;\n      padding:10px 12px;\n      border-radius:8px;\n      min-width:0;\n      outline:none;\n    }\n    input[type=\"range\"]{width:100%;}\n    .btn{\n      background:linear-gradient(180deg,var(--accent), #2b80d8);\n      color:#042233;\n      border:none;\n      padding:10px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      box-shadow: 0 6px 16px rgba(35,88,159,0.18);\n    }\n    .btn.ghost{\n      background:transparent;\n      color:var(--accent);\n      border:1px solid rgba(96,165,250,0.14);\n      box-shadow:none;\n    }\n    .btn.warn{ background:linear-gradient(180deg,#fb7185,#ef445f); color:white; box-shadow:none; }\n    .btn.small{ padding:8px 10px; font-size:13px; }\n\n    .inline-controls{ display:flex; gap:var(--gap); align-items:center; flex-wrap:wrap; }\n\n    /* Visual pane */\n    .visual{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:20px;\n      min-height:420px;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    /* Top info row: target and status */\n    .info{\n      display:flex;\n      justify-content:space-between;\n      gap:var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n\n    .target-box{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      background:rgba(255,255,255,0.02);\n      padding:12px;\n      border-radius:10px;\n      min-width:180px;\n    }\n    .target-box .lbl{font-size:13px; color:var(--muted);}\n    .target-box .val{\n      font-weight:700;\n      font-size:20px;\n      color:var(--accent);\n    }\n\n    .status{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* Array visualization */\n    .array-wrap{\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      padding:16px;\n      border-radius:10px;\n      min-height:140px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      position:relative;\n      overflow:auto;\n    }\n\n    .array{\n      display:flex;\n      gap:var(--cell-gap);\n      padding:8px;\n      align-items:end;\n    }\n\n    .cell{\n      width:var(--cell-size);\n      height:var(--cell-size);\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);\n      border-radius:10px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:700;\n      font-size:18px;\n      color:#e7f2ff;\n      position:relative;\n      transition: transform 300ms cubic-bezier(.2,.9,.3,1), background 300ms, box-shadow 200ms;\n      user-select:none;\n    }\n\n    .cell.index{ font-size:12px; color:var(--muted); font-weight:600; }\n\n    .cell .idx{\n      position:absolute; bottom:-22px; font-size:12px; color:var(--muted);\n    }\n\n    .cell.checking{\n      background: linear-gradient(180deg,#fff6d9,#fff1c3);\n      color:#6b4a00;\n      transform:translateY(-8px) scale(1.04);\n      box-shadow: 0 8px 24px rgba(0,0,0,0.35);\n    }\n\n    .cell.match{\n      background: linear-gradient(180deg, rgba(52,211,153,0.9), rgba(16,185,129,0.9));\n      color:#042233;\n      transform:translateY(-10px) scale(1.06);\n      box-shadow: 0 10px 30px rgba(16,185,129,0.12);\n    }\n\n    .cell.miss{\n      background: linear-gradient(180deg, rgba(251,113,133,0.12), rgba(251,113,133,0.06));\n      color:var(--muted);\n      transform:translateY(-4px);\n      opacity:0.92;\n    }\n\n    /* Pointer arrow */\n    .pointer{\n      position:absolute;\n      top:8px;\n      width:0;height:0;\n      border-left:14px solid transparent;\n      border-right:14px solid transparent;\n      border-bottom:18px solid rgba(96,165,250,0.98);\n      transform-origin:center top;\n      transition: transform 350ms cubic-bezier(.2,.9,.3,1), left 350ms;\n      filter:drop-shadow(0 6px 14px rgba(96,165,250,0.12));\n      z-index:2;\n    }\n\n    /* Comparison counter bar */\n    .meter{\n      height:10px;\n      background:rgba(255,255,255,0.03);\n      border-radius:6px;\n      overflow:hidden;\n      width:100%;\n      min-width:120px;\n    }\n    .meter > i{\n      display:block;\n      height:100%;\n      width:0%;\n      background:linear-gradient(90deg,var(--accent), #34d399);\n      transition:width 350ms ease;\n    }\n\n    .controls-row{ display:flex; gap:var(--gap); flex-wrap:wrap; }\n\n    /* Footer result */\n    .result{\n      padding:12px;\n      border-radius:10px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      justify-content:space-between;\n    }\n    .result .text{font-size:14px; color:var(--muted); }\n    .result .out{font-weight:800; color:var(--accent); font-size:15px;}\n\n    /* Small helpers */\n    .muted{color:var(--muted); font-size:13px;}\n    .kbd{background:rgba(255,255,255,0.03); border-radius:6px; padding:6px 8px; font-weight:700; font-size:13px; color:var(--muted);}\n\n    /* Focus styles */\n    button:focus, input:focus { outline: 3px solid rgba(96,165,250,0.12); outline-offset:2px; }\n\n    /* Ensure 16px min spacing between interactive elements (already set via gap var) */\n    .panel .controls > * { margin-bottom:0; }\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"main\" aria-labelledby=\"title\">\n    <!-- Left Panel -->\n    <section class=\"panel\" aria-labelledby=\"title\">\n      <div>\n        <h1 id=\"title\">Linear Search — Interactive Exploration</h1>\n        <div class=\"meta\">A step-by-step, visual introduction to the linear search algorithm.</div>\n      </div>\n\n      <div class=\"controls\" aria-hidden=\"false\">\n        <div>\n          <label class=\"muted\">Learning Objective</label>\n          <div class=\"muted\" style=\"line-height:1.35\">\n            After using this module you will be able to explain how linear search scans elements one-by-one, count comparisons, and observe best/worst/average-case behaviors.\n          </div>\n        </div>\n\n        <div>\n          <label for=\"size\" class=\"muted\">Array size</label>\n          <div class=\"row\">\n            <input id=\"size\" type=\"range\" min=\"2\" max=\"20\" value=\"8\" aria-label=\"Array size slider\">\n            <div class=\"kbd\" id=\"sizeVal\">8</div>\n          </div>\n        </div>\n\n        <div>\n          <label class=\"muted\">Array controls</label>\n          <div class=\"inline-controls\">\n            <button class=\"btn\" id=\"randomize\">Randomize</button>\n            <button class=\"btn ghost\" id=\"editToggle\">Edit elements</button>\n            <button class=\"btn small\" id=\"sortBtn\" title=\"Sort for easier testing\">Sort</button>\n          </div>\n          <div class=\"muted\" style=\"font-size:12px; margin-top:8px;\">Edit mode: click a cell to change its value. Press Enter to confirm a typed number.</div>\n        </div>\n\n        <div>\n          <label for=\"targetInput\" class=\"muted\">Target value to search</label>\n          <div class=\"row\">\n            <input id=\"targetInput\" type=\"text\" inputmode=\"numeric\" aria-label=\"Target value\" placeholder=\"e.g., 42\">\n            <button class=\"btn\" id=\"startBtn\">Search</button>\n            <button class=\"btn ghost\" id=\"stepBtn\">Step</button>\n          </div>\n          <div class=\"muted\" style=\"font-size:12px; margin-top:8px;\">Use \"Step\" to move one comparison at a time. \"Search\" runs continuously.</div>\n        </div>\n\n        <div>\n          <label class=\"muted\">Playback & speed</label>\n          <div class=\"row\">\n            <button class=\"btn small\" id=\"prevBtn\">&larr; Prev</button>\n            <button class=\"btn small\" id=\"nextBtn\">Next &rarr;</button>\n            <button class=\"btn ghost\" id=\"autoToggle\">Auto: Off</button>\n          </div>\n          <div style=\"margin-top:8px;\">\n            <label class=\"muted\">Speed</label>\n            <input type=\"range\" id=\"speed\" min=\"100\" max=\"1200\" value=\"600\" aria-label=\"Animation speed\">\n          </div>\n        </div>\n\n        <div>\n          <label class=\"muted\">Reset & examples</label>\n          <div class=\"row\">\n            <button class=\"btn warn\" id=\"resetBtn\">Reset</button>\n            <button class=\"btn ghost\" id=\"exampleNotFound\">Example: Not Found</button>\n          </div>\n        </div>\n\n        <div style=\"margin-top:4px;\">\n          <label class=\"muted\">Interaction help</label>\n          <div class=\"muted\" style=\"font-size:13px\">\n            Shortcuts: Space = Step, Enter in target = Search. Edit mode: click cell to change value.\n          </div>\n        </div>\n      </div>\n    </section>\n\n    <!-- Right Visual Panel -->\n    <section class=\"visual\" aria-live=\"polite\">\n      <div class=\"info\">\n        <div class=\"target-box\" aria-hidden=\"false\" role=\"group\" aria-label=\"Target display\">\n          <div>\n            <div class=\"lbl\">Target</div>\n            <div class=\"val\" id=\"targetDisplay\">—</div>\n          </div>\n        </div>\n\n        <div style=\"display:flex; gap:var(--gap); align-items:center; flex-wrap:wrap;\">\n          <div class=\"status\" aria-hidden=\"false\">\n            <div class=\"muted\">Comparisons</div>\n            <div style=\"font-weight:800; color:var(--accent);\" id=\"compCount\">0</div>\n          </div>\n          <div style=\"min-width:160px;\">\n            <div class=\"muted\">Progress</div>\n            <div class=\"meter\" aria-hidden=\"true\" title=\"Progress\">\n              <i id=\"meterBar\" style=\"width:0%\"></i>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"array-wrap\" id=\"arrayWrap\">\n        <div class=\"pointer\" id=\"pointer\" aria-hidden=\"true\" style=\"left:20px; display:none;\"></div>\n        <div class=\"array\" id=\"array\" role=\"list\" aria-label=\"Array elements\">\n          <!-- Cells inserted by JS -->\n        </div>\n      </div>\n\n      <div class=\"controls-row\">\n        <div class=\"muted\">State: <span id=\"stateLabel\">Idle</span></div>\n        <div style=\"flex:1\"></div>\n        <div class=\"muted\">Index under check: <span id=\"currentIdx\">—</span></div>\n      </div>\n\n      <div class=\"result\" role=\"status\">\n        <div class=\"text\">Outcome</div>\n        <div class=\"out\" id=\"resultText\">No search yet</div>\n      </div>\n\n      <div style=\"margin-top:8px;\">\n        <h2 style=\"font-size:14px; margin:0 0 8px 0; color:var(--accent)\">Interaction Design</h2>\n        <div class=\"muted\" style=\"font-size:13px; line-height:1.45\">\n          - Use the array size slider to change how many elements are in the array. Click \"Randomize\" to fill with random numbers.<br>\n          - Enter a target value and press \"Search\" to run linear search automatically, or use \"Step\" to advance one comparison at a time.<br>\n          - Edit mode toggles allowing direct clicks on cells to change values.<br>\n          - Visual feedback: the pointer arrow moves above the current cell; the cell transitions to \"checking\" color while compared, then becomes \"match\" if equal or \"miss\" if not. The comparisons counter and progress bar update in real time. When found, the animation highlights success and displays index and total comparisons.\n        </div>\n\n        <h2 style=\"font-size:14px; margin:12px 0 8px 0; color:var(--accent)\">Layout Description</h2>\n        <div class=\"muted\" style=\"font-size:13px; line-height:1.45\">\n          - Safe margins of 24px are applied to the page. Controls are in a left panel and the interactive visualization on the right (stacked vertically on small screens).<br>\n          - Minimum spacing of 16px is enforced between interactive elements using the layout gaps. The array visualization occupies the main focus area with clear labels for comparisons, index, and outcome. Interactive elements are keyboard accessible and use clear focus styles.\n        </div>\n      </div>\n    </section>\n  </div>\n\n  <script>\n    // Linear Search Interactive Module - Vanilla JS\n    (function(){\n      const sizeEl = document.getElementById('size');\n      const sizeVal = document.getElementById('sizeVal');\n      const arrayEl = document.getElementById('array');\n      const pointer = document.getElementById('pointer');\n      const targetInput = document.getElementById('targetInput');\n      const startBtn = document.getElementById('startBtn');\n      const stepBtn = document.getElementById('stepBtn');\n      const randomizeBtn = document.getElementById('randomize');\n      const editToggle = document.getElementById('editToggle');\n      const compCountEl = document.getElementById('compCount');\n      const meterBar = document.getElementById('meterBar');\n      const stateLabel = document.getElementById('stateLabel');\n      const resultText = document.getElementById('resultText');\n      const targetDisplay = document.getElementById('targetDisplay');\n      const prevBtn = document.getElementById('prevBtn');\n      const nextBtn = document.getElementById('nextBtn');\n      const autoToggle = document.getElementById('autoToggle');\n      const speedEl = document.getElementById('speed');\n      const resetBtn = document.getElementById('resetBtn');\n      const exampleNotFound = document.getElementById('exampleNotFound');\n      const sortBtn = document.getElementById('sortBtn');\n\n      let arr = [];\n      let current = -1;\n      let comparisons = 0;\n      let running = false;\n      let auto = false;\n      let timer = null;\n      let speed = 600;\n      let editing = false;\n      let lastTarget = null;\n\n      // Utility\n      function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }\n\n      function makeArray(n){\n        arr = [];\n        for(let i=0;i<n;i++) arr.push(randInt(1,99));\n        renderArray();\n        resetState();\n      }\n\n      function renderArray(){\n        arrayEl.innerHTML = '';\n        arr.forEach((v,i)=>{\n          const cell = document.createElement('div');\n          cell.className = 'cell';\n          cell.setAttribute('role','listitem');\n          cell.dataset.index = i;\n          cell.innerHTML = `<div class=\"val\">${v}</div><div class=\"idx\">${i}</div>`;\n          cell.tabIndex = 0;\n          // Click to edit if in edit mode\n          cell.addEventListener('click', (e)=>{\n            if(!editing) return;\n            enterEditCell(cell, i);\n          });\n          cell.addEventListener('keydown', (e)=>{\n            if(!editing) return;\n            if(e.key === 'Enter') enterEditCell(cell, i);\n          });\n          arrayEl.appendChild(cell);\n        });\n        placePointerAt(-1);\n      }\n\n      function enterEditCell(cell,i){\n        const prev = arr[i];\n        const input = document.createElement('input');\n        input.type = 'number';\n        input.value = prev;\n        input.style.width = '100%';\n        input.style.height = '100%';\n        input.style.border = 'none';\n        input.style.textAlign = 'center';\n        input.style.fontWeight = '700';\n        input.style.fontSize = '18px';\n        input.style.background = 'transparent';\n        cell.innerHTML = '';\n        cell.appendChild(input);\n        input.focus();\n        input.select();\n        function finish(){\n          const v = Number(input.value) || 0;\n          arr[i] = v;\n          renderArray();\n        }\n        input.addEventListener('blur', finish);\n        input.addEventListener('keydown', (e)=>{\n          if(e.key === 'Enter'){ finish(); }\n        });\n      }\n\n      function placePointerAt(index){\n        const cells = Array.from(arrayEl.children);\n        if(index < 0 || index >= cells.length){\n          pointer.style.display = 'none';\n          document.getElementById('currentIdx').textContent = '—';\n          return;\n        }\n        const targetCell = cells[index];\n        const rect = targetCell.getBoundingClientRect();\n        const parentRect = arrayEl.getBoundingClientRect();\n        const left = targetCell.offsetLeft + targetCell.offsetWidth/2 - 14 + arrayEl.offsetLeft;\n        pointer.style.display = 'block';\n        // Position pointer relative to arrayWrap (absolute)\n        const wrap = document.getElementById('arrayWrap');\n        const wrapRect = wrap.getBoundingClientRect();\n        const leftPos = targetCell.offsetLeft + targetCell.offsetWidth/2 + arrayEl.offsetLeft - wrap.offsetLeft - 14;\n        pointer.style.left = Math.max(8, leftPos) + 'px';\n        document.getElementById('currentIdx').textContent = index;\n      }\n\n      function resetState(){\n        stopAuto();\n        running = false;\n        current = -1;\n        comparisons = 0;\n        compCountEl.textContent = comparisons;\n        stateLabel.textContent = 'Idle';\n        resultText.textContent = 'No search yet';\n        meterBar.style.width = '0%';\n        placePointerAt(-1);\n        clearCellStates();\n      }\n\n      function clearCellStates(){\n        Array.from(arrayEl.children).forEach(c=>{\n          c.classList.remove('checking','match','miss');\n        });\n      }\n\n      function updateMeter(){\n        const pct = arr.length ? Math.min(100, Math.round((comparisons/arr.length)*100)) : 0;\n        meterBar.style.width = pct + '%';\n      }\n\n      function stepOnce(){\n        if(current >= arr.length) return;\n        if(current === -1){\n          current = 0;\n        } else {\n          // clear previous checking state unless it was match\n          const prev = arrayEl.children[current];\n          if(prev) prev.classList.remove('checking');\n          current++;\n        }\n        if(current < arr.length){\n          compareAt(current);\n        } else {\n          // finished, not found\n          finishNotFound();\n        }\n      }\n\n      function compareAt(idx){\n        clearCellStates();\n        const cell = arrayEl.children[idx];\n        if(!cell) return;\n        placePointerAt(idx);\n        cell.classList.add('checking');\n        stateLabel.textContent = 'Comparing';\n        comparisons++;\n        compCountEl.textContent = comparisons;\n        updateMeter();\n        // slight delay to show checking before reading equality\n        setTimeout(()=> {\n          const val = arr[idx];\n          const target = toNumberSafe(lastTarget);\n          if(val === target){\n            cell.classList.remove('checking');\n            cell.classList.add('match');\n            stateLabel.textContent = 'Found';\n            resultText.textContent = `Found at index ${idx} (comparisons: ${comparisons})`;\n            stopAuto();\n            running = false;\n            current = idx;\n            placePointerAt(idx);\n          } else {\n            cell.classList.remove('checking');\n            cell.classList.add('miss');\n            // Continue if auto mode\n            if(auto){\n              if(current < arr.length - 1){\n                // schedule next\n                timer = setTimeout(()=> stepOnce(), speed);\n              } else {\n                finishNotFound();\n              }\n            } else {\n              // idle, allow manual next\n              stateLabel.textContent = 'Idle';\n            }\n          }\n        }, Math.max(120, speed/4));\n      }\n\n      function finishNotFound(){\n        stateLabel.textContent = 'Completed';\n        resultText.textContent = `Not found (comparisons: ${comparisons})`;\n        stopAuto();\n        running = false;\n      }\n\n      function startSearch(){\n        const t = targetInput.value.trim();\n        if(t === '') return;\n        lastTarget = t;\n        targetDisplay.textContent = t;\n        // prepare\n        clearCellStates();\n        comparisons = 0;\n        compCountEl.textContent = comparisons;\n        stateLabel.textContent = 'Running';\n        current = -1;\n        running = true;\n        // if auto is on start auto loop else step once\n        if(auto){\n          stepOnce();\n        } else {\n          stepOnce(); // still single step initial comparison\n        }\n      }\n\n      function toNumberSafe(v){\n        const n = Number(String(v).trim());\n        return Number.isNaN(n) ? String(v) : n;\n      }\n\n      // Buttons and handlers\n      sizeEl.addEventListener('input', ()=>{\n        sizeVal.textContent = sizeEl.value;\n        makeArray(Number(sizeEl.value));\n      });\n\n      randomizeBtn.addEventListener('click', ()=> {\n        makeArray(Number(sizeEl.value));\n      });\n\n      editToggle.addEventListener('click', ()=>{\n        editing = !editing;\n        editToggle.classList.toggle('ghost', !editing);\n        editToggle.textContent = editing ? 'Editing: On' : 'Edit elements';\n        editToggle.setAttribute('aria-pressed', editing);\n      });\n\n      startBtn.addEventListener('click', ()=>{\n        auto = true;\n        autoToggle.textContent = 'Auto: On';\n        speed = Number(speedEl.value);\n        startSearch();\n      });\n\n      stepBtn.addEventListener('click', ()=>{\n        // manual step\n        auto = false;\n        stopAuto();\n        if(lastTarget == null && targetInput.value.trim() !== ''){\n          lastTarget = targetInput.value.trim();\n          targetDisplay.textContent = lastTarget;\n        }\n        if(lastTarget == null) return;\n        stepOnce();\n      });\n\n      nextBtn.addEventListener('click', ()=>{\n        auto = false;\n        stopAuto();\n        if(lastTarget == null && targetInput.value.trim() !== ''){\n          lastTarget = targetInput.value.trim();\n          targetDisplay.textContent = lastTarget;\n        }\n        stepOnce();\n      });\n\n      prevBtn.addEventListener('click', ()=>{\n        auto = false;\n        stopAuto();\n        // move back one step for exploration\n        if(current <= 0){\n          current = -1;\n          clearCellStates();\n          comparisons = 0;\n          compCountEl.textContent = comparisons;\n          updateMeter();\n          placePointerAt(-1);\n          resultText.textContent = 'No search yet';\n          stateLabel.textContent = 'Idle';\n          return;\n        }\n        // revert a comparison: decrement comparisons, remove state from current cell\n        const cell = arrayEl.children[current];\n        if(cell) cell.classList.remove('checking','miss','match');\n        current--;\n        comparisons = Math.max(0, comparisons-1);\n        compCountEl.textContent = comparisons;\n        updateMeter();\n        placePointerAt(current);\n        stateLabel.textContent = 'Idle';\n        resultText.textContent = 'Stepped back';\n      });\n\n      autoToggle.addEventListener('click', ()=>{\n        auto = !auto;\n        autoToggle.textContent = auto ? 'Auto: On' : 'Auto: Off';\n        if(auto && running){\n          // ensure loop continues\n          stepOnce();\n        }\n      });\n\n      speedEl.addEventListener('input', ()=>{\n        speed = Number(speedEl.value);\n      });\n\n      resetBtn.addEventListener('click', ()=> {\n        makeArray(Number(sizeEl.value));\n        targetInput.value = '';\n        lastTarget = null;\n        targetDisplay.textContent = '—';\n      });\n\n      exampleNotFound.addEventListener('click', ()=>{\n        // create an array that doesn't contain 999\n        const n = Number(sizeEl.value);\n        arr = [];\n        for(let i=0;i<n;i++) arr.push(i+1);\n        renderArray();\n        targetInput.value = '999';\n        lastTarget = null;\n        targetDisplay.textContent = '—';\n      });\n\n      sortBtn.addEventListener('click', ()=>{\n        arr.sort((a,b)=>a-b);\n        renderArray();\n      });\n\n      function stopAuto(){\n        auto = false;\n        autoToggle.textContent = 'Auto: Off';\n        if(timer) clearTimeout(timer);\n        timer = null;\n      }\n\n      // Keyboard shortcuts\n      window.addEventListener('keydown', (e)=>{\n        if(e.key === ' '){\n          e.preventDefault();\n          stepBtn.click();\n        } else if(e.key === 'Enter' && document.activeElement === targetInput){\n          startBtn.click();\n        }\n      });\n\n      // Initialize\n      sizeVal.textContent = sizeEl.value;\n      makeArray(Number(sizeEl.value));\n\n      // Accessibility: update aria labels if needed in the future\n      // Resize handling: reposition pointer on layout changes\n      window.addEventListener('resize', ()=> {\n        placePointerAt(current);\n      });\n\n      // When user types target, update display\n      targetInput.addEventListener('input', ()=>{\n        targetDisplay.textContent = targetInput.value.trim() || '—';\n      });\n\n      // Make sure pointer appears above array on first compare\n      // Ensure transitions and animations remain smooth with CSS above\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Linear Search.\n\n**Project Overview:**\nTopic: Linear Search\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Linear Search"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "b2b03390-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:47:50.367Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Priority Queue",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Priority Queue Explorer</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --accent: #1e88e5;\n      --accent-2: #009688;\n      --bg: #f7f9fc;\n      --card: #ffffff;\n      --muted: #6b7280;\n      --danger: #e53935;\n      --success: #2e7d32;\n      --node-size: 56px;\n      --level-gap: 96px;\n    }\n\n    /* Safe area margins */\n    html,body{\n      height:100%;\n      margin:0;\n      background:var(--bg);\n      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,\"Noto Sans\",sans-serif;\n      color:#0f1724;\n    }\n    .app{\n      padding:var(--safe-margin);\n      box-sizing:border-box;\n      min-height:100vh;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    header{\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n    h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing:0.2px;\n    }\n    .sub{\n      color:var(--muted);\n      font-size:13px;\n      margin:0;\n    }\n\n    main{\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      width:100%;\n    }\n\n    /* left controls column */\n    .controls{\n      flex:0 0 320px;\n      min-width:260px;\n      background:var(--card);\n      border-radius:10px;\n      padding:16px;\n      box-shadow:0 6px 20px rgba(16,24,40,0.06);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    .controls h2{\n      margin:0;\n      font-size:14px;\n      color:#09203a;\n    }\n    .form-row{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    label{\n      font-size:13px;\n      color:var(--muted);\n    }\n    input[type=\"text\"], input[type=\"number\"], select{\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid #e6edf3;\n      background:transparent;\n      font-size:14px;\n      flex:1 1 auto;\n      min-width:0;\n    }\n    input[type=\"number\"]{\n      width:110px;\n      -moz-appearance:textfield;\n    }\n    input[type=\"number\"]::-webkit-outer-spin-button,\n    input[type=\"number\"]::-webkit-inner-spin-button{\n      -webkit-appearance:none;\n      margin:0;\n    }\n\n    .btn-row{\n      display:flex;\n      gap:var(--gap);\n      flex-wrap:wrap;\n    }\n    button{\n      padding:10px 14px;\n      border-radius:8px;\n      border:0;\n      background:var(--accent);\n      color:white;\n      cursor:pointer;\n      font-weight:600;\n      letter-spacing:0.2px;\n    }\n    button.secondary{\n      background:transparent;\n      color:var(--accent);\n      border:1px solid rgba(30,136,229,0.12);\n    }\n    button.warn{\n      background:var(--danger);\n    }\n    button:disabled{\n      opacity:0.45;\n      cursor:not-allowed;\n    }\n\n    .small{\n      padding:8px 10px;\n      font-size:13px;\n      border-radius:8px;\n    }\n\n    .toggles{\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n    .muted{\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* Visualization area */\n    .visual{\n      flex:1 1 auto;\n      min-height:420px;\n      background:var(--card);\n      border-radius:10px;\n      padding:16px;\n      box-shadow:0 6px 20px rgba(16,24,40,0.06);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      position:relative;\n      overflow:hidden;\n    }\n\n    .vis-top{\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:var(--gap);\n    }\n    .legend{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .badge{\n      padding:6px 10px;\n      border-radius:999px;\n      background:#f1f5f9;\n      font-weight:600;\n      color:#0f1724;\n      font-size:13px;\n    }\n\n    /* Canvas container for nodes */\n    .canvas{\n      position:relative;\n      background:linear-gradient(180deg, rgba(14,165,233,0.02), transparent 20%);\n      border-radius:8px;\n      flex:1 1 auto;\n      min-height:320px;\n      padding:16px;\n      display:block;\n    }\n\n    /* array display */\n    .array{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n      padding-top:12px;\n    }\n    .arr-box{\n      min-width:56px;\n      height:56px;\n      background:#fff;\n      border-radius:8px;\n      border:1px solid #e6edf3;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      flex-direction:column;\n      gap:4px;\n      padding:6px;\n      font-size:13px;\n      box-shadow:0 2px 8px rgba(16,24,40,0.04);\n    }\n    .arr-idx{\n      font-size:11px;\n      color:var(--muted);\n    }\n    .arr-val{\n      font-weight:700;\n      color:#0f1724;\n    }\n\n    /* node style */\n    .node{\n      position:absolute;\n      width:var(--node-size);\n      height:var(--node-size);\n      border-radius:50%;\n      background:linear-gradient(180deg,var(--accent),#0b63b8);\n      color:white;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      text-align:center;\n      box-shadow:0 8px 18px rgba(30,41,59,0.12);\n      cursor:pointer;\n      user-select:none;\n      transition:transform 300ms cubic-bezier(.2,.9,.2,1), box-shadow 200ms, background 200ms;\n      transform-origin:center;\n      will-change:transform;\n      outline:2px solid transparent;\n    }\n    .node .prio{\n      font-size:12px;\n      opacity:0.95;\n      font-weight:700;\n      line-height:1;\n    }\n    .node .lbl{\n      font-size:11px;\n      opacity:0.95;\n      line-height:1;\n    }\n    .node:focus, .node.selected{\n      box-shadow:0 12px 28px rgba(16,24,40,0.18);\n      transform:translateY(-6px) scale(1.04);\n      outline:3px solid rgba(30,136,229,0.18);\n    }\n    .node.min{\n      background:linear-gradient(180deg,#00bfa5,#00897b);\n    }\n\n    /* connecting lines use svg */\n    .links{\n      position:absolute;\n      inset:0;\n      pointer-events:none;\n    }\n\n    /* accessibility helper on small screens */\n    @media (max-width:880px){\n      main{\n        flex-direction:column;\n      }\n      .controls{\n        width:100%;\n      }\n    }\n\n    /* small helper */\n    footer{\n      font-size:12px;\n      color:var(--muted);\n      margin-top:8px;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Priority Queue interactive module\">\n    <!-- Concept Title & Learning Objective -->\n    <header>\n      <h1>Priority Queue — Visual Heap Explorer</h1>\n      <p class=\"sub\">Learning Objective: Understand how a priority queue (implemented as a binary heap) organizes elements by priority and how enqueue, dequeue (pop), and update-priority operations re-balance the heap (bubble-up / sift-down).</p>\n    </header>\n\n    <main>\n      <!-- Controls panel -->\n      <section class=\"controls\" aria-labelledby=\"controls-title\">\n        <h2 id=\"controls-title\">Controls & Actions</h2>\n\n        <div class=\"form-row\" style=\"align-items:stretch;\">\n          <div style=\"flex:1; min-width:120px;\">\n            <label for=\"labelInput\">Element label</label>\n            <input id=\"labelInput\" type=\"text\" placeholder=\"e.g., Task A\" aria-label=\"Element label\" />\n          </div>\n          <div style=\"width:120px;\">\n            <label for=\"prioInput\">Priority</label>\n            <input id=\"prioInput\" type=\"number\" value=\"10\" aria-label=\"Priority value\" />\n          </div>\n        </div>\n\n        <div class=\"form-row\">\n          <label for=\"modeSelect\">Queue type</label>\n          <select id=\"modeSelect\" aria-label=\"Select queue type\">\n            <option value=\"max\">Max-heap (highest priority first)</option>\n            <option value=\"min\">Min-heap (lowest priority first)</option>\n          </select>\n        </div>\n\n        <div class=\"btn-row\" role=\"toolbar\" aria-label=\"Primary actions\" style=\"margin-top:4px;\">\n          <button id=\"enqueueBtn\" class=\"small\">Enqueue</button>\n          <button id=\"dequeueBtn\" class=\"small\">Dequeue</button>\n          <button id=\"peekBtn\" class=\"small secondary\">Peek</button>\n          <button id=\"clearBtn\" class=\"small secondary\">Clear</button>\n        </div>\n\n        <div style=\"border-top:1px dashed #eef3f6; padding-top:12px;\">\n          <h2 style=\"font-size:13px; margin:0 0 6px 0;\">Node Interaction</h2>\n          <p class=\"muted\" style=\"margin:0 0 6px 0;\">Click a node in the visualization to select it, then change its priority or remove it.</p>\n\n          <div class=\"form-row\">\n            <div style=\"flex:1;\">\n              <label for=\"selectedPrio\">Selected priority</label>\n              <input id=\"selectedPrio\" type=\"number\" aria-label=\"Selected node priority\" />\n            </div>\n            <div style=\"width:120px;\">\n              <label>&nbsp;</label>\n              <button id=\"changePrioBtn\" class=\"small secondary\" style=\"width:100%;\">Change</button>\n            </div>\n          </div>\n\n          <div class=\"btn-row\" style=\"margin-top:8px;\">\n            <button id=\"removeBtn\" class=\"small warn\">Remove Node</button>\n            <button id=\"randomBtn\" class=\"small\">Add Random ×5</button>\n          </div>\n        </div>\n\n        <div style=\"border-top:1px dashed #eef3f6; padding-top:12px;\">\n          <h2 style=\"font-size:13px; margin:0 0 6px 0;\">Animation</h2>\n          <div class=\"form-row\" style=\"align-items:center;\">\n            <label class=\"muted\" style=\"margin-right:8px;\">Animate</label>\n            <input id=\"animateToggle\" type=\"checkbox\" checked aria-label=\"Toggle animations\" />\n            <label for=\"speedRange\" class=\"muted\" style=\"margin-left:12px;\">Speed</label>\n            <input id=\"speedRange\" type=\"range\" min=\"0.25\" max=\"2\" step=\"0.25\" value=\"1\" style=\"width:120px;\" aria-label=\"Animation speed\" />\n          </div>\n          <p class=\"muted\" style=\"margin:6px 0 0 0;\">Use \"Step\" with animation off to inspect each comparison manually (not implemented: optional extension).</p>\n        </div>\n      </section>\n\n      <!-- Visualization -->\n      <section class=\"visual\" aria-labelledby=\"visual-title\">\n        <div class=\"vis-top\">\n          <div>\n            <h2 id=\"visual-title\" style=\"margin:0;font-size:14px;\">Heap Visualization</h2>\n            <p class=\"muted\" style=\"margin:4px 0 0 0;\">Click nodes to select. The array view below shows internal heap layout (index 0 = root).</p>\n          </div>\n          <div class=\"legend\" aria-hidden=\"true\">\n            <div class=\"badge\">Selected: <span id=\"selInfo\" style=\"margin-left:8px;font-weight:700;\">—</span></div>\n            <div class=\"muted\">Nodes: <strong id=\"count\">0</strong></div>\n          </div>\n        </div>\n\n        <div class=\"canvas\" id=\"canvas\" tabindex=\"0\" aria-label=\"Heap canvas\">\n          <!-- SVG for links -->\n          <svg class=\"links\" id=\"links\" aria-hidden=\"true\"></svg>\n          <!-- Nodes container (positions absolute) -->\n          <div id=\"nodesContainer\" style=\"position:absolute; inset:0;\"></div>\n        </div>\n\n        <div>\n          <h3 style=\"margin:0 0 8px 0;font-size:13px;\">Array Representation</h3>\n          <div class=\"array\" id=\"arrayView\" aria-live=\"polite\"></div>\n        </div>\n      </section>\n    </main>\n\n    <footer>\n      Tip: Try both max-heap and min-heap modes. Add several items, then click the root and change its priority to watch bubble-up or sift-down happen.\n    </footer>\n  </div>\n\n  <script>\n    (function(){\n      /* --- Data model for the heap (binary heap using array) --- */\n      const heap = {\n        arr: [], // elements: {label, priority, id}\n        mode: 'max' // 'max' or 'min'\n      };\n\n      // DOM refs\n      const labelInput = document.getElementById('labelInput');\n      const prioInput = document.getElementById('prioInput');\n      const modeSelect = document.getElementById('modeSelect');\n      const enqueueBtn = document.getElementById('enqueueBtn');\n      const dequeueBtn = document.getElementById('dequeueBtn');\n      const peekBtn = document.getElementById('peekBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const randomBtn = document.getElementById('randomBtn');\n\n      const canvas = document.getElementById('canvas');\n      const nodesContainer = document.getElementById('nodesContainer');\n      const linksSvg = document.getElementById('links');\n      const arrayView = document.getElementById('arrayView');\n      const countEl = document.getElementById('count');\n\n      const animateToggle = document.getElementById('animateToggle');\n      const speedRange = document.getElementById('speedRange');\n\n      const selectedPrio = document.getElementById('selectedPrio');\n      const changePrioBtn = document.getElementById('changePrioBtn');\n      const removeBtn = document.getElementById('removeBtn');\n      const selInfo = document.getElementById('selInfo');\n\n      let selectedNodeId = null;\n      let idCounter = 1;\n      let animating = false;\n\n      /* Animation configuration */\n      function getAnimDuration(){\n        // base 350ms scaled by speed\n        const speed = parseFloat(speedRange.value) || 1;\n        return 350 / speed;\n      }\n\n      /* Utility: compare depending on mode */\n      function cmp(a,b){\n        if(heap.mode === 'max') return a - b;\n        return b - a;\n      }\n\n      /* Create element object */\n      function makeElem(label, prio){\n        return {label: label || 'Item '+(idCounter), priority: Number(prio)||0, id: idCounter++};\n      }\n\n      /* Heap operations with animation hooks */\n      async function enqueue(elem){\n        const i = heap.arr.push(elem) - 1;\n        await render(); // place at end\n        await bubbleUp(i);\n      }\n\n      async function dequeue(){\n        if(heap.arr.length === 0) return null;\n        if(heap.arr.length === 1){\n          const x = heap.arr.pop();\n          await render();\n          return x;\n        }\n        // swap root with last\n        swap(0, heap.arr.length-1);\n        await renderSwap(0, heap.arr.length-1);\n        const popped = heap.arr.pop();\n        await render(); // removes last\n        await siftDown(0);\n        return popped;\n      }\n\n      function peek(){\n        return heap.arr.length ? heap.arr[0] : null;\n      }\n\n      function swap(i,j){\n        const tmp = heap.arr[i];\n        heap.arr[i] = heap.arr[j];\n        heap.arr[j] = tmp;\n      }\n\n      /* Bubble-up operation (while compare with parent) */\n      async function bubbleUp(i){\n        while(i > 0){\n          const p = Math.floor((i-1)/2);\n          if(cmp(heap.arr[i].priority, heap.arr[p].priority) > 0){\n            swap(i,p);\n            await renderSwap(i,p);\n            i = p;\n          } else break;\n        }\n      }\n\n      /* Sift-down operation */\n      async function siftDown(i){\n        const n = heap.arr.length;\n        while(true){\n          let left = 2*i + 1;\n          let right = 2*i + 2;\n          let largest = i;\n          if(left < n && cmp(heap.arr[left].priority, heap.arr[largest].priority) > 0) largest = left;\n          if(right < n && cmp(heap.arr[right].priority, heap.arr[largest].priority) > 0) largest = right;\n          if(largest !== i){\n            swap(i, largest);\n            await renderSwap(i, largest);\n            i = largest;\n          } else break;\n        }\n      }\n\n      /* Remove arbitrary node by id */\n      async function removeById(id){\n        const idx = heap.arr.findIndex(x => x.id === id);\n        if(idx === -1) return null;\n        const last = heap.arr.length-1;\n        if(idx === last){\n          const removed = heap.arr.pop();\n          await render();\n          return removed;\n        }\n        swap(idx, last);\n        await renderSwap(idx,last);\n        const removed = heap.arr.pop();\n        await render();\n        // After swap, bubble or sift as needed\n        // Try bubble-up then sift-down\n        await bubbleUp(idx);\n        await siftDown(idx);\n        return removed;\n      }\n\n      /* Change priority of a node */\n      async function changePriorityById(id, newPrio){\n        const idx = heap.arr.findIndex(x => x.id === id);\n        if(idx === -1) return;\n        const old = heap.arr[idx].priority;\n        heap.arr[idx].priority = Number(newPrio);\n        await render();\n        if(cmp(heap.arr[idx].priority, old) > 0){\n          await bubbleUp(idx);\n        } else {\n          await siftDown(idx);\n        }\n      }\n\n      /* Rendering functions */\n      function clearNodes(){\n        nodesContainer.innerHTML = '';\n        linksSvg.innerHTML = '';\n      }\n\n      // compute layout positions for each index in heap\n      function computePositions(){\n        const rect = canvas.getBoundingClientRect();\n        const width = Math.max(320, rect.width - 32); // padding\n        const positions = [];\n        const n = heap.arr.length;\n        for(let i=0;i<n;i++){\n          const level = Math.floor(Math.log2(i+1));\n          const levelStart = Math.pow(2, level) - 1;\n          const idxInLevel = i - levelStart;\n          const nodesInLevel = Math.pow(2, level);\n          const gapX = width / (nodesInLevel + 1);\n          const x = Math.round(gapX * (idxInLevel + 1)) - 28; // center node (node size / 2)\n          const y = level * parseInt(getComputedStyle(document.documentElement).getPropertyValue('--level-gap') || 96) + 16;\n          positions.push({x, y});\n        }\n        return positions;\n      }\n\n      // create node DOM element\n      function createNodeDom(elem){\n        const el = document.createElement('div');\n        el.className = 'node';\n        el.setAttribute('role','button');\n        el.setAttribute('tabindex','0');\n        el.setAttribute('data-id', elem.id);\n        el.setAttribute('aria-label', `${elem.label} priority ${elem.priority}`);\n        el.innerHTML = '<div class=\"prio\"></div><div class=\"lbl\"></div>';\n        return el;\n      }\n\n      // update one node content\n      function populateNode(el, elem){\n        el.querySelector('.prio').textContent = elem.priority;\n        el.querySelector('.lbl').textContent = elem.label;\n      }\n\n      // render everything without animation (but nodes will transition because of CSS)\n      async function render(){\n        // If animating flagged and we want to suppress intermediate renders, we still update DOM\n        const positions = computePositions();\n        // update array view\n        buildArrayView();\n\n        // update nodes: create or remove accordingly\n        const existing = Array.from(nodesContainer.children);\n        // map by id\n        const existingMap = new Map(existing.map(e => [Number(e.getAttribute('data-id')), e]));\n        // create missing nodes\n        heap.arr.forEach((elem, idx) => {\n          if(!existingMap.has(elem.id)){\n            const node = createNodeDom(elem);\n            populateNode(node, elem);\n            node.style.left = positions[idx].x + 'px';\n            node.style.top = positions[idx].y + 'px';\n            // color based on mode\n            node.classList.toggle('min', heap.mode === 'min');\n            node.addEventListener('click', onNodeClick);\n            node.addEventListener('keydown', (ev) => {\n              if(ev.key === 'Enter' || ev.key === ' '){\n                ev.preventDefault();\n                onNodeClick(ev);\n              }\n            });\n            nodesContainer.appendChild(node);\n          } else {\n            const node = existingMap.get(elem.id);\n            populateNode(node, elem);\n            node.classList.toggle('min', heap.mode === 'min');\n          }\n        });\n        // remove extras\n        existing.forEach(e => {\n          const id = Number(e.getAttribute('data-id'));\n          if(!heap.arr.find(x => x.id === id)){\n            // remove element\n            e.remove();\n          }\n        });\n\n        // position nodes\n        const nodeEls = Array.from(nodesContainer.children);\n        nodeEls.forEach((el, idx) => {\n          // find index of this id in heap.arr to get pos\n          const id = Number(el.getAttribute('data-id'));\n          const newIdx = heap.arr.findIndex(x => x.id === id);\n          if(newIdx === -1) return;\n          const pos = positions[newIdx];\n          // set transform for smooth animation\n          el.style.transform = `translate(${pos.x}px, ${pos.y}px)`;\n          // also set top/left for later absolute anchors (we keep container relative)\n          el.style.left = '0px';\n          el.style.top = '0px';\n        });\n\n        // draw links between parent-child using svg lines\n        drawLinks(positions);\n        // update counts and selection details\n        countEl.textContent = heap.arr.length;\n        updateSelectionDetails();\n        await wait(5); // allow layout/transition to apply\n      }\n\n      // Render swap animation explicitly: highlight two ids, animate their movement\n      async function renderSwap(i,j){\n        if(!animateToggle.checked){\n          // non-animated: just render resulting positions\n          await render();\n          return;\n        }\n        animating = true;\n        const duration = getAnimDuration();\n        const positions = computePositions();\n\n        // find nodes for indices (ids)\n        const idI = heap.arr[i] ? heap.arr[i].id : null;\n        const idJ = heap.arr[j] ? heap.arr[j].id : null;\n\n        // store current positions of all nodes\n        const nodeEls = Array.from(nodesContainer.children);\n        const idToEl = new Map(nodeEls.map(e => [Number(e.getAttribute('data-id')), e]));\n\n        // Highlight swapping nodes\n        if(idI) idToEl.get(idI).classList.add('selected');\n        if(idJ) idToEl.get(idJ).classList.add('selected');\n\n        // Force reflow\n        void nodesContainer.offsetWidth;\n\n        // We'll animate by setting transform to target positions\n        // Prepare a map id -> target position\n        const targetPos = new Map();\n        heap.arr.forEach((elem, idx) => {\n          targetPos.set(elem.id, positions[idx]);\n        });\n\n        // Apply transitions\n        nodeEls.forEach(el => {\n          const id = Number(el.getAttribute('data-id'));\n          const pos = targetPos.get(id);\n          el.style.transition = `transform ${duration}ms cubic-bezier(.2,.9,.2,1)`;\n          if(pos){\n            el.style.transform = `translate(${pos.x}px, ${pos.y}px)`;\n          } else {\n            // fading out\n            el.style.opacity = 0;\n          }\n        });\n\n        // animate links by repeatedly redrawing during the animation\n        const start = performance.now();\n        await new Promise(resolve => {\n          function frame(now){\n            const t = Math.min(1, (now - start) / duration);\n            // recompute current positions from transform computed style\n            const positionsNow = [];\n            // but simply redraw links based on current transforms of nodes\n            drawLinks(); // draw based on node centers\n            if(t < 1){\n              requestAnimationFrame(frame);\n            } else {\n              resolve();\n            }\n          }\n          requestAnimationFrame(frame);\n        });\n\n        // cleanup: remove transitions\n        nodeEls.forEach(el => {\n          el.style.transition = '';\n          el.style.opacity = '';\n        });\n\n        if(idI) idToEl.get(idI).classList.remove('selected');\n        if(idJ) idToEl.get(idJ).classList.remove('selected');\n\n        animating = false;\n        // final render to ensure consistent positions\n        await render();\n      }\n\n      // Draw links lines between parent and child using node centers\n      function drawLinks(forcePositions){\n        // We can compute positions either from forcePositions (array) or from current transforms of nodes\n        const positions = forcePositions || computePositions();\n        // Build map id -> center coordinates\n        const coords = new Map();\n        heap.arr.forEach((elem, idx) => {\n          const pos = positions[idx];\n          const cx = pos.x + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--node-size'))/2 || pos.x + 28;\n          const cy = pos.y + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--node-size'))/2 || pos.y + 28;\n          coords.set(elem.id, {x: cx, y: cy});\n        });\n\n        // Clear SVG\n        linksSvg.innerHTML = '';\n        // Ensure svg has right size\n        const rect = canvas.getBoundingClientRect();\n        linksSvg.setAttribute('width', rect.width);\n        linksSvg.setAttribute('height', rect.height);\n        linksSvg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);\n\n        // For each parent, draw lines to children\n        heap.arr.forEach((elem, idx) => {\n          const left = 2*idx + 1;\n          const right = 2*idx + 2;\n          const a = coords.get(elem.id);\n          if(!a) return;\n          [left, right].forEach(childIdx => {\n            if(childIdx < heap.arr.length){\n              const child = heap.arr[childIdx];\n              const b = coords.get(child.id);\n              if(!b) return;\n              const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n              line.setAttribute('x1', a.x);\n              line.setAttribute('y1', a.y);\n              line.setAttribute('x2', b.x);\n              line.setAttribute('y2', b.y);\n              line.setAttribute('stroke', '#cfe9ff');\n              line.setAttribute('stroke-width', '2');\n              line.setAttribute('stroke-linecap','round');\n              line.setAttribute('opacity','0.95');\n              linksSvg.appendChild(line);\n            }\n          });\n        });\n      }\n\n      // Build array view below visualization\n      function buildArrayView(){\n        arrayView.innerHTML = '';\n        heap.arr.forEach((elem, idx) => {\n          const box = document.createElement('div');\n          box.className = 'arr-box';\n          box.setAttribute('data-id', elem.id);\n          box.setAttribute('tabindex','0');\n          box.innerHTML = `<div class=\"arr-val\">${elem.priority}</div><div class=\"arr-idx\">${elem.label} • [${idx}]</div>`;\n          box.addEventListener('click', () => {\n            const id = elem.id;\n            focusNodeById(id);\n            selectNodeById(id);\n          });\n          arrayView.appendChild(box);\n        });\n      }\n\n      // Helper: wait ms\n      function wait(ms){\n        return new Promise(resolve => setTimeout(resolve, ms));\n      }\n\n      /* Event handlers */\n      enqueueBtn.addEventListener('click', async () => {\n        if(animating) return;\n        const label = labelInput.value.trim() || `Item ${idCounter}`;\n        const prio = Number(prioInput.value) || 0;\n        const elem = makeElem(label, prio);\n        await enqueue(elem);\n      });\n\n      dequeueBtn.addEventListener('click', async () => {\n        if(animating) return;\n        const popped = await dequeue();\n        if(popped){\n          // show brief info\n          flashSelection(`Popped: ${popped.label} (prio ${popped.priority})`);\n        }\n      });\n\n      peekBtn.addEventListener('click', () => {\n        const p = peek();\n        if(p){\n          flashSelection(`Peek: ${p.label} (prio ${p.priority})`);\n        } else {\n          flashSelection('Queue empty');\n        }\n      });\n\n      clearBtn.addEventListener('click', async () => {\n        if(animating) return;\n        heap.arr = [];\n        selectedNodeId = null;\n        await render();\n      });\n\n      modeSelect.addEventListener('change', async (e) => {\n        heap.mode = e.target.value;\n        // Rebalance? Mode change requires rebuilding heap to match new comparator\n        // Simple approach: reconstruct heap by inserting elements into new array\n        const items = heap.arr.slice();\n        heap.arr = [];\n        for(const it of items) {\n          heap.arr.push(it);\n          // bubble-up to satisfy new ordering\n          await bubbleUp(heap.arr.length-1);\n        }\n        await render();\n      });\n\n      randomBtn.addEventListener('click', async () => {\n        if(animating) return;\n        for(let i=0;i<5;i++){\n          const label = `R${Math.floor(Math.random()*90)+10}`;\n          const prio = Math.floor(Math.random()*100);\n          const elem = makeElem(label, prio);\n          await enqueue(elem);\n        }\n      });\n\n      /* Node click: select */\n      function onNodeClick(ev){\n        const el = ev.currentTarget;\n        const id = Number(el.getAttribute('data-id'));\n        selectNodeById(id);\n      }\n\n      function selectNodeById(id){\n        selectedNodeId = id;\n        // update UI selections\n        const nodeEls = Array.from(nodesContainer.children);\n        nodeEls.forEach(n => {\n          const nid = Number(n.getAttribute('data-id'));\n          n.classList.toggle('selected', nid === id);\n        });\n        const elem = heap.arr.find(x => x.id === id);\n        if(elem){\n          selectedPrio.value = elem.priority;\n        } else {\n          selectedPrio.value = '';\n        }\n        updateSelectionDetails();\n      }\n\n      function updateSelectionDetails(){\n        const elem = heap.arr.find(x => x.id === selectedNodeId);\n        if(elem){\n          selInfo.textContent = `${elem.label} • ${elem.priority}`;\n        } else {\n          selInfo.textContent = '—';\n        }\n      }\n\n      changePrioBtn.addEventListener('click', async () => {\n        if(!selectedNodeId) return;\n        if(animating) return;\n        const newP = Number(selectedPrio.value);\n        if(Number.isNaN(newP)) return;\n        await changePriorityById(selectedNodeId, newP);\n      });\n\n      removeBtn.addEventListener('click', async () => {\n        if(!selectedNodeId) return;\n        if(animating) return;\n        await removeById(selectedNodeId);\n        selectedNodeId = null;\n        await render();\n      });\n\n      // Focus node by id (scroll into view if required)\n      function focusNodeById(id){\n        const node = nodesContainer.querySelector(`[data-id=\"${id}\"]`);\n        if(node){\n          node.focus();\n        }\n      }\n\n      // utility: flash selection message in selInfo briefly\n      async function flashSelection(msg){\n        const prev = selInfo.textContent;\n        selInfo.textContent = msg;\n        selInfo.parentElement.style.background = '#e8f4ff';\n        await wait(900);\n        selInfo.textContent = prev;\n        selInfo.parentElement.style.background = '';\n      }\n\n      // resize observer for canvas to re-render responsive positions\n      const ro = new ResizeObserver(() => {\n        render();\n      });\n      ro.observe(canvas);\n\n      // keyboard shortcuts\n      window.addEventListener('keydown', (e) => {\n        if(e.key === 'e' && document.activeElement.tagName !== 'INPUT') {\n          enqueueBtn.click();\n        }\n        if(e.key === 'd' && document.activeElement.tagName !== 'INPUT') {\n          dequeueBtn.click();\n        }\n      });\n\n      // initial demo content\n      (async function initDemo(){\n        heap.mode = modeSelect.value;\n        const demo = [\n          makeElem('A', 40),\n          makeElem('B', 15),\n          makeElem('C', 30),\n          makeElem('D', 50),\n          makeElem('E', 20)\n        ];\n        for(const el of demo) await enqueue(el);\n      })();\n\n      // expose for debugging (not necessary)\n      window._heap = heap;\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Priority Queue.\n\n**Project Overview:**\nTopic: Priority Queue\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Priority Queue"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Priority Queue Explorer",
      "description": "Models the interactive states and transitions of a visual binary-heap priority-queue web application (enqueue, dequeue, peek, change priority, remove, animations, selection, mode change).",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "ENQUEUE": "busy",
            "DEQUEUE": "busy",
            "PEEK": "busy",
            "CLEAR": "busy",
            "CHANGE_MODE": "busy",
            "ADD_RANDOM": "busy",
            "CHANGE_PRIORITY": "busy",
            "REMOVE_NODE": "busy",
            "SELECT_NODE": "node_selected",
            "DESELECT_NODE": "idle",
            "TOGGLE_ANIMATE": "idle",
            "SPEED_CHANGE": "idle",
            "KEY_ENQUEUE": "busy",
            "KEY_DEQUEUE": "busy",
            "ANIMATION_START": "animating",
            "ANIMATION_END": "idle",
            "RESIZE": "idle",
            "INIT_DONE": "idle",
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "busy",
          "onEnter": "startOperation",
          "onExit": "endOperation",
          "on": {
            "ANIMATION_START": "animating",
            "ANIMATION_END": "busy",
            "OP_COMPLETE": "idle",
            "SELECT_NODE": "node_selected",
            "DESELECT_NODE": "idle",
            "ENQUEUE": "busy",
            "DEQUEUE": "busy",
            "PEEK": "busy",
            "CLEAR": "busy",
            "CHANGE_MODE": "busy",
            "ADD_RANDOM": "busy",
            "CHANGE_PRIORITY": "busy",
            "REMOVE_NODE": "busy",
            "TOGGLE_ANIMATE": "busy",
            "SPEED_CHANGE": "busy",
            "KEY_ENQUEUE": "busy",
            "KEY_DEQUEUE": "busy",
            "RESIZE": "busy",
            "INIT_DONE": "busy"
          }
        },
        {
          "name": "animating",
          "onEnter": "setAnimatingTrue",
          "onExit": "setAnimatingFalse",
          "on": {
            "ANIMATION_END": "busy",
            "OP_COMPLETE": "idle",
            "ENQUEUE": "animating",
            "DEQUEUE": "animating",
            "PEEK": "animating",
            "CLEAR": "animating",
            "CHANGE_MODE": "animating",
            "ADD_RANDOM": "animating",
            "CHANGE_PRIORITY": "animating",
            "REMOVE_NODE": "animating",
            "SELECT_NODE": "animating",
            "DESELECT_NODE": "animating",
            "TOGGLE_ANIMATE": "animating",
            "SPEED_CHANGE": "animating",
            "KEY_ENQUEUE": "animating",
            "KEY_DEQUEUE": "animating",
            "RESIZE": "animating",
            "INIT_DONE": "animating"
          }
        },
        {
          "name": "node_selected",
          "onEnter": "highlightNode",
          "onExit": "clearHighlight",
          "on": {
            "CHANGE_PRIORITY": "busy",
            "REMOVE_NODE": "busy",
            "DESELECT_NODE": "idle",
            "ENQUEUE": "busy",
            "DEQUEUE": "busy",
            "PEEK": "busy",
            "CLEAR": "busy",
            "CHANGE_MODE": "busy",
            "ADD_RANDOM": "busy",
            "SELECT_NODE": "node_selected",
            "TOGGLE_ANIMATE": "node_selected",
            "SPEED_CHANGE": "node_selected",
            "ANIMATION_START": "animating",
            "ANIMATION_END": "node_selected",
            "KEY_ENQUEUE": "busy",
            "KEY_DEQUEUE": "busy",
            "RESIZE": "node_selected",
            "INIT_DONE": "node_selected",
            "OP_COMPLETE": "idle"
          }
        }
      ],
      "events": [
        "ENQUEUE",
        "DEQUEUE",
        "PEEK",
        "CLEAR",
        "CHANGE_MODE",
        "ADD_RANDOM",
        "CHANGE_PRIORITY",
        "REMOVE_NODE",
        "SELECT_NODE",
        "DESELECT_NODE",
        "TOGGLE_ANIMATE",
        "SPEED_CHANGE",
        "KEY_ENQUEUE",
        "KEY_DEQUEUE",
        "ANIMATION_START",
        "ANIMATION_END",
        "OP_COMPLETE",
        "RESIZE",
        "INIT_DONE"
      ],
      "notes": "Selection (node_selected) is conceptually orthogonal to busy/animating but represented as explicit states here. The app sets an 'animating' flag during renderSwap; while animating most user actions are ignored in the implementation (modeled as self-transitions to 'animating'). 'busy' models any asynchronous heap operation (enqueue, dequeue, change priority, remove, random adds, mode change, peek/flash) and transitions to 'animating' when swap animations occur. onEnter/onExit action names are descriptive hooks representing UI updates (startOperation/endOperation, setAnimatingTrue/setAnimatingFalse, highlightNode/clearHighlight)."
    }
  },
  {
    "id": "e716f740-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:47:58.644Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Quick Sort",
    "answer": {
      "role": "assistant",
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Quick Sort Explorer</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --accent: #2b7cff;\n      --accent-2: #ff7a59;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --muted: #94a3b8;\n      --success: #16a34a;\n      --danger: #ef4444;\n      --panel-radius: 12px;\n      --transition: 300ms cubic-bezier(.2,.9,.3,1);\n      --font-sans: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n\n    /* Safe area */\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071025 0%, #07131f 100%);\n      font-family: var(--font-sans);\n      color: #e6eef8;\n    }\n    .safe {\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height: 100vh;\n    }\n\n    .container{\n      display: grid;\n      grid-template-columns: 320px 1fr 300px;\n      gap: var(--gap);\n      align-items: start;\n    }\n\n    /* Top header across full width */\n    header{\n      grid-column: 1 / -1;\n      display:flex;\n      align-items:center;\n      gap: var(--gap);\n      margin-bottom: 8px;\n    }\n    h1{\n      font-size: 20px;\n      margin:0;\n      letter-spacing: -0.2px;\n    }\n    .subtitle{\n      color: var(--muted);\n      font-size: 13px;\n    }\n\n    /* Left controls card */\n    .card{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: var(--panel-radius);\n      padding: 16px;\n      box-shadow: 0 4px 18px rgba(2,6,23,0.6);\n    }\n\n    .controls{\n      display:flex;\n      flex-direction:column;\n      gap: 12px;\n    }\n\n    label{\n      font-size: 13px;\n      color: var(--muted);\n    }\n\n    input[type=\"text\"]{\n      padding: 8px 10px;\n      border-radius: 8px;\n      border: none;\n      background: rgba(255,255,255,0.03);\n      color: #e6eef8;\n      outline: 2px solid transparent;\n      transition: outline var(--transition);\n    }\n    input[type=\"text\"]:focus{ outline: 2px solid rgba(43,124,255,.18); }\n\n    .row {\n      display:flex;\n      gap: var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n\n    .btn {\n      background: linear-gradient(180deg,var(--accent), #196eec);\n      color:#fff;\n      border:none;\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      box-shadow: 0 6px 18px rgba(43,124,255,0.18);\n      transition: transform 140ms ease, opacity 120ms ease;\n      font-weight:600;\n    }\n    .btn.secondary{\n      background: rgba(255,255,255,0.03);\n      color:#cfe4ff;\n      border: 1px solid rgba(255,255,255,0.03);\n      box-shadow: none;\n      font-weight:600;\n    }\n    .btn:active{ transform: translateY(1px); }\n\n    .toggles{ display:flex; gap:8px; flex-wrap:wrap; }\n    .option{\n      background: rgba(255,255,255,0.02);\n      padding:6px 8px;\n      border-radius:8px;\n      font-size:13px;\n      cursor:pointer;\n      border:1px solid transparent;\n    }\n    .option.active{\n      border-color: rgba(255,255,255,0.06);\n      background: rgba(43,124,255,0.12);\n    }\n\n    .small{\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* Center visualization */\n    .viz-card{\n      overflow:hidden;\n      position:relative;\n      min-height: 420px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .viz-top{\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:12px;\n    }\n\n    .controls-inline{\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n\n    .speed{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      color:var(--muted);\n      font-size:13px;\n    }\n    input[type=\"range\"]{ width:140px; }\n\n    .visualization{\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      padding: 18px;\n      border-radius: 12px;\n      position:relative;\n      height:320px;\n      display:block;\n      border: 1px solid rgba(255,255,255,0.02);\n    }\n\n    .array-area{\n      position:relative;\n      height:100%;\n      width:100%;\n      margin:0;\n      user-select:none;\n      display:block;\n    }\n\n    .bar {\n      position:absolute;\n      bottom: 18px;\n      width: 48px;\n      border-radius: 8px;\n      background: linear-gradient(180deg,#3777ff,#2458cc);\n      display:flex;\n      align-items:flex-end;\n      justify-content:center;\n      color:#fff;\n      font-weight:700;\n      transition: left var(--transition), height var(--transition), transform var(--transition), background-color var(--transition), opacity var(--transition);\n      box-shadow: 0 6px 14px rgba(7,12,23,0.6);\n      padding-bottom:8px;\n    }\n    .bar.small{ width:40px; border-radius:6px; font-size:12px; padding-bottom:6px; }\n    .bar .val {\n      pointer-events:none;\n      font-size:13px;\n    }\n\n    .bar.pivot { background: linear-gradient(180deg,#ffb36b,#ff8a3b); box-shadow: 0 8px 20px rgba(255,122,89,0.12); }\n    .bar.compare { outline: 3px solid rgba(255,255,255,0.06); transform: translateY(-8px) scale(1.02); }\n    .bar.sorted { background: linear-gradient(180deg,#33d17a,#16a34a); box-shadow: 0 8px 20px rgba(22,163,74,0.08); }\n    .bar.swap { background: linear-gradient(180deg,#7cd3ff,#2b9bff); }\n\n    .legend{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .legend .item{\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n    .chip{ width:14px; height:14px; border-radius:4px; }\n\n    /* Right panel code & stack */\n    .code {\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;\n      font-size: 13px;\n      background: rgba(255,255,255,0.02);\n      padding: 12px;\n      border-radius: 12px;\n      line-height:1.5;\n      color:#cfe4ff;\n      min-height: 220px;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .line { padding:4px 8px; border-radius:8px; display:block; }\n    .line.active { background: rgba(43,124,255,0.08); color: #eaf4ff; border-left: 3px solid var(--accent); }\n\n    .stack{\n      margin-top:12px;\n      background: rgba(255,255,255,0.01);\n      padding:10px;\n      border-radius:8px;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .stack .range{\n      background: rgba(255,255,255,0.02);\n      padding:6px 8px;\n      border-radius:8px;\n      margin-bottom:8px;\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n    }\n\n    .explain{\n      margin-top:12px;\n      color:var(--muted);\n      font-size:13px;\n      min-height:48px;\n    }\n\n    /* Responsive */\n    @media (max-width: 1000px){\n      .container{ grid-template-columns: 1fr; }\n      header{ flex-direction:column; align-items:flex-start; gap:8px; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"safe\" role=\"main\">\n    <header>\n      <div>\n        <h1>Quick Sort — Interactive Explorer</h1>\n        <div class=\"subtitle\">Step through partitioning, choose pivot strategies, and watch recursive ranges resolve.</div>\n      </div>\n      <div style=\"margin-left:auto; text-align:right\">\n        <div class=\"subtitle\">Safe margins: 24px • Spacing ≥ 16px • Accessible controls</div>\n      </div>\n    </header>\n\n    <div class=\"container\" aria-live=\"polite\">\n      <!-- Left: Info & Controls -->\n      <div class=\"card\" aria-label=\"Controls\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n          <div>\n            <strong>Quick Sort Module</strong>\n            <div class=\"small\">One concept: Quick Sort (Lomuto partition visualized)</div>\n          </div>\n          <div style=\"font-size:12px;color:var(--muted)\">Interactive</div>\n        </div>\n\n        <hr style=\"border:none;height:1px;background:rgba(255,255,255,0.02);margin:12px 0\">\n\n        <div class=\"controls\">\n          <div>\n            <label for=\"arrayInput\">Array (comma-separated numbers)</label>\n            <input id=\"arrayInput\" type=\"text\" aria-label=\"Array input\" value=\"7,2,1,6,8,5,3,4\" />\n            <div style=\"margin-top:8px\" class=\"row\">\n              <button id=\"updateBtn\" class=\"btn\">Update Array</button>\n              <button id=\"shuffleBtn\" class=\"btn secondary\">Shuffle</button>\n              <button id=\"randomBtn\" class=\"btn secondary\">Random</button>\n            </div>\n          </div>\n\n          <div>\n            <label>Pivot selection</label>\n            <div class=\"toggles\" role=\"tablist\" aria-label=\"Pivot selection\">\n              <button class=\"option active\" data-pivot=\"last\">Last</button>\n              <button class=\"option\" data-pivot=\"first\">First</button>\n              <button class=\"option\" data-pivot=\"random\">Random</button>\n              <button class=\"option\" data-pivot=\"median\">Median-of-3</button>\n              <button class=\"option\" data-pivot=\"manual\">Manual</button>\n            </div>\n            <div class=\"small\" style=\"margin-top:8px\">Manual: click a bar to set pivot for current range.</div>\n          </div>\n\n          <div>\n            <label>Controls</label>\n            <div class=\"row\">\n              <button id=\"stepBtn\" class=\"btn\">Step</button>\n              <button id=\"playBtn\" class=\"btn secondary\">Play</button>\n              <button id=\"runBtn\" class=\"btn\">Run to End</button>\n              <button id=\"resetBtn\" class=\"btn secondary\">Reset</button>\n            </div>\n            <div style=\"margin-top:8px\" class=\"row\">\n              <div class=\"speed\">\n                <span class=\"small\">Speed</span>\n                <input id=\"speed\" type=\"range\" min=\"50\" max=\"1200\" value=\"450\" />\n              </div>\n              <div class=\"small\" style=\"margin-left:8px\">Delay (ms)</div>\n            </div>\n          </div>\n\n          <div>\n            <label>Learning objective</label>\n            <div class=\"small\">Understand how Quick Sort partitions around a pivot, how comparisons and swaps place the pivot in final position, and how recursive subproblems resolve.</div>\n          </div>\n\n          <div>\n            <label>Interaction design (summary)</label>\n            <div class=\"small\">Users update the array, select a pivot strategy, then step through or play the algorithm. Visual bars animate comparisons and swaps; pseudo-code and recursion stack update to reinforce mapping between code and action.</div>\n          </div>\n        </div>\n      </div>\n\n      <!-- Center: Visualization -->\n      <div class=\"viz-card card\" aria-label=\"Visualization area\">\n        <div class=\"viz-top\">\n          <div style=\"display:flex;flex-direction:column\">\n            <div style=\"font-weight:600\">Array visualization</div>\n            <div class=\"small\">Bars represent array values. Watch pivot (orange), compares (lifted), swaps (blue), and sorted positions (green).</div>\n          </div>\n\n          <div style=\"display:flex;flex-direction:column;align-items:flex-end;gap:6px\">\n            <div class=\"legend\" aria-hidden=\"true\">\n              <div class=\"item\"><div class=\"chip\" style=\"background:#ffb36b\"></div><div class=\"small\">Pivot</div></div>\n              <div class=\"item\"><div class=\"chip\" style=\"background:#7cd3ff\"></div><div class=\"small\">Swap</div></div>\n              <div class=\"item\"><div class=\"chip\" style=\"background:#33d17a\"></div><div class=\"small\">Placed/Sorted</div></div>\n            </div>\n            <div class=\"small\">Range stack and pseudo-code to the right map algorithm progress.</div>\n          </div>\n        </div>\n\n        <div class=\"visualization\" id=\"visualization\" role=\"application\" aria-label=\"Quick sort visualization\">\n          <div class=\"array-area\" id=\"arrayArea\"></div>\n        </div>\n\n        <div style=\"display:flex;justify-content:space-between;align-items:center;margin-top:6px;\">\n          <div class=\"explain\" id=\"explain\">Ready. Load or shuffle an array and press Step.</div>\n          <div style=\"font-size:12px;color:var(--muted)\">Elements: <span id=\"count\">8</span></div>\n        </div>\n      </div>\n\n      <!-- Right: Pseudocode & Stack -->\n      <div class=\"card\" aria-label=\"Pseudocode and stack\">\n        <div style=\"font-weight:600\">Pseudocode (Lomuto partition)</div>\n\n        <div class=\"code\" id=\"codeArea\" tabindex=\"0\" aria-label=\"Pseudocode\">\n          <div class=\"line\" data-line=\"1\">quicksort(arr, low, high)</div>\n          <div class=\"line\" data-line=\"2\">  if low &lt; high</div>\n          <div class=\"line\" data-line=\"3\">    p = partition(arr, low, high)</div>\n          <div class=\"line\" data-line=\"4\">    quicksort(arr, low, p - 1)</div>\n          <div class=\"line\" data-line=\"5\">    quicksort(arr, p + 1, high)</div>\n          <hr style=\"border:none;height:1px;background:rgba(255,255,255,0.02);margin:8px 0\">\n          <div class=\"line\" data-line=\"10\">partition(arr, low, high)</div>\n          <div class=\"line\" data-line=\"11\">  pivot = arr[high]</div>\n          <div class=\"line\" data-line=\"12\">  i = low</div>\n          <div class=\"line\" data-line=\"13\">  for j = low to high-1</div>\n          <div class=\"line\" data-line=\"14\">    if arr[j] &lt; pivot</div>\n          <div class=\"line\" data-line=\"15\">      swap arr[i], arr[j]</div>\n          <div class=\"line\" data-line=\"16\">      i = i + 1</div>\n          <div class=\"line\" data-line=\"17\">  swap arr[i], arr[high]</div>\n          <div class=\"line\" data-line=\"18\">  return i</div>\n        </div>\n\n        <div class=\"stack\" aria-live=\"polite\" aria-atomic=\"true\">\n          <div style=\"font-weight:600;margin-bottom:6px\">Range stack (next to sort)</div>\n          <div id=\"stackList\">\n            <!-- dynamic -->\n          </div>\n        </div>\n\n        <div style=\"margin-top:12px\" class=\"small\">\n          Layout description: Controls (left), visualization (center), code/stack (right). Safe margins 24px; interactive elements spaced ≥16px. Responsive: stacks vertically on narrow screens.\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Quick Sort Interactive Module (vanilla JS)\n    (function(){\n      // Utilities\n      function $(sel){ return document.querySelector(sel); }\n      function $all(sel){ return Array.from(document.querySelectorAll(sel)); }\n\n      // DOM refs\n      const arrayInput = $('#arrayInput');\n      const updateBtn = $('#updateBtn');\n      const shuffleBtn = $('#shuffleBtn');\n      const randomBtn = $('#randomBtn');\n      const stepBtn = $('#stepBtn');\n      const playBtn = $('#playBtn');\n      const runBtn = $('#runBtn');\n      const resetBtn = $('#resetBtn');\n      const speedInput = $('#speed');\n      const pivotOptions = $all('.option');\n      const arrayArea = $('#arrayArea');\n      const explain = $('#explain');\n      const countLabel = $('#count');\n      const stackList = $('#stackList');\n      const codeLines = $all('.line');\n\n      // State\n      let baseArray = [];\n      let items = []; // {value, id, index}\n      let positions = []; // left positions\n      let barWidth = 56;\n      let vizRect;\n      let generator = null;\n      let playing = false;\n      let playTimer = null;\n      let currentStep = null;\n      let pivotMode = 'last';\n      let manualPivotIdx = null;\n      let speed = parseInt(speedInput.value,10);\n      let sortedIndices = new Set();\n\n      // Initialize\n      function initFromInput(){\n        const txt = arrayInput.value.trim();\n        let arr;\n        if(!txt){\n          arr = [5,4,3,2,1];\n        } else {\n          arr = txt.split(',').map(s=>s.trim()).filter(Boolean).map(Number).filter(n=>!Number.isNaN(n));\n        }\n        baseArray = arr.slice(0, 24); // cap length\n        setupArray(baseArray);\n      }\n\n      function setupArray(arr){\n        stopPlay();\n        generator = null;\n        playing = false;\n        manualPivotIdx = null;\n        sortedIndices.clear();\n        items = arr.map((v,i)=>({value: v, id: Math.random().toString(36).slice(2,9), index: i}));\n        renderArray();\n        countLabel.textContent = items.length;\n        explain.textContent = 'Array loaded. Choose pivot mode and press Step to start.';\n        updateStack([]);\n        highlightCode(null);\n      }\n\n      function renderArray(){\n        arrayArea.innerHTML = '';\n        vizRect = arrayArea.getBoundingClientRect();\n        const n = items.length;\n        const areaW = arrayArea.clientWidth || (window.innerWidth - 200);\n        // compute bar width responsively\n        let maxBarW = 72;\n        let minBarW = 34;\n        barWidth = Math.max(minBarW, Math.min(maxBarW, Math.floor((areaW - 20) / n) - 8));\n        const gap = 12;\n        // heights based on values scaled\n        const values = items.map(it=>it.value);\n        const maxV = Math.max(1, ...values.map(Math.abs));\n        const minV = Math.min(...values);\n        const availableH = arrayArea.clientHeight - 36;\n        items.forEach((it, idx)=>{\n          it.index = idx;\n        });\n        items.forEach((it, idx)=>{\n          const el = document.createElement('div');\n          el.className = 'bar';\n          if(items.length > 12) el.classList.add('small');\n          el.setAttribute('data-id', it.id);\n          el.setAttribute('tabindex', 0);\n          el.setAttribute('role', 'button');\n          el.setAttribute('aria-label', 'Value ' + it.value);\n          const h = Math.max(18, Math.round((Math.abs(it.value)/maxV) * (availableH - 20))) + 24;\n          el.style.height = h + 'px';\n          const left = idx * (barWidth + 8) + 12;\n          el.style.left = left + 'px';\n          el.style.width = barWidth + 'px';\n          el.style.transition = 'left ' + (speed*0.6) + 'ms cubic-bezier(.2,.9,.3,1), height 240ms';\n          el.innerHTML = '<div class=\"val\">' + it.value + '</div>';\n          el.addEventListener('click', ()=> onBarClick(idx));\n          arrayArea.appendChild(el);\n        });\n        // store base positions\n      }\n\n      function onBarClick(idx){\n        if(pivotMode === 'manual' && currentStep && currentStep.type === 'choosePivot' && currentStep.range){\n          const [low, high] = currentStep.range;\n          if(idx >= low && idx <= high){\n            manualPivotIdx = idx;\n            explain.textContent = 'Manual pivot selected at index ' + idx + ' (value ' + items[idx].value + '). Press Step.';\n          } else {\n            explain.textContent = 'Click must be inside current partition range ['+low+','+high+'].';\n          }\n        }\n      }\n\n      // Pivot option buttons\n      pivotOptions.forEach(btn=>{\n        btn.addEventListener('click', ()=>{\n          pivotOptions.forEach(b=>b.classList.remove('active'));\n          btn.classList.add('active');\n          pivotMode = btn.dataset.pivot;\n          explain.textContent = 'Pivot mode: ' + pivotMode + '.';\n        });\n      });\n\n      // Generate steps via iterative simulation (Lomuto)\n      function* quickSortGenerator(arr){\n        // arr is array of values\n        // use stack of ranges to simulate recursion\n        const stack = [];\n        stack.push([0, arr.length - 1]);\n        updateStack(stack.slice().reverse());\n        while(stack.length){\n          const range = stack.pop();\n          const [low, high] = range;\n          // yield stack update\n          yield {type:'popRange', range: [low,high], stack: stack.slice().reverse()};\n          if(low < high){\n            // choose pivot index based on mode\n            yield {type:'choosePivot', range:[low,high]};\n            let pivotIdx = high; // default last\n            if(pivotMode === 'first') pivotIdx = low;\n            else if(pivotMode === 'random') pivotIdx = Math.floor(Math.random()*(high-low+1))+low;\n            else if(pivotMode === 'median'){\n              const a = arr[low], b = arr[Math.floor((low+high)/2)], c = arr[high];\n              const vals = [[a,low],[b,Math.floor((low+high)/2)],[c,high]];\n              vals.sort((x,y)=>x[0]-y[0]);\n              pivotIdx = vals[1][1];\n            } else if(pivotMode === 'manual'){\n              // wait for manualPivotIdx to be set externally\n              yield {type:'awaitManual', range:[low,high]};\n              // external code will set manualPivotIdx variable and then continue\n              // yield until manualPivotIdx is set\n              while(manualPivotIdx === null || manualPivotIdx < low || manualPivotIdx > high){\n                yield {type:'waitingManual', range:[low,high]};\n              }\n              pivotIdx = manualPivotIdx;\n              manualPivotIdx = null;\n            }\n            yield {type:'pivotChosen', pivotIdx, range:[low,high]};\n\n            // Move pivot to end (swap pivotIdx and high)\n            if(pivotIdx !== high){\n              yield {type:'swap', a: pivotIdx, b: high, values:[arr[pivotIdx], arr[high]], range:[low,high]};\n              const tmp = arr[pivotIdx]; arr[pivotIdx] = arr[high]; arr[high] = tmp;\n            }\n\n            // Lomuto partition\n            const pivot = arr[high];\n            let i = low;\n            yield {type:'setI', i, pivot, range:[low,high]};\n            for(let j = low; j <= high - 1; j++){\n              yield {type:'compare', j, pivot, range:[low,high]};\n              if(arr[j] < pivot){\n                yield {type:'swap', a: i, b: j, values:[arr[i],arr[j]], range:[low,high]};\n                const tmp = arr[i]; arr[i]=arr[j]; arr[j]=tmp;\n                i++;\n                yield {type:'updateI', i, range:[low,high]};\n              }\n            }\n            // place pivot at i\n            yield {type:'swap', a: i, b: high, values:[arr[i],arr[high]], range:[low,high]};\n            const tmp2 = arr[i]; arr[i] = arr[high]; arr[high] = tmp2;\n            yield {type:'partitionDone', p: i, range:[low,high]};\n\n            // push right and left ranges (so left is processed first we push right then left)\n            stack.push([i+1, high]);\n            yield {type:'pushRange', range:[i+1,high], stack: stack.slice().reverse()};\n            stack.push([low, i-1]);\n            yield {type:'pushRange', range:[low,i-1], stack: stack.slice().reverse()};\n            updateStack(stack.slice().reverse());\n          } else {\n            // single element or invalid\n            if(low === high){\n              yield {type:'markSorted', idx: low, range:[low,high]};\n            }\n          }\n          updateStack(stack.slice().reverse());\n        }\n        yield {type:'done'};\n      }\n\n      // Visual update helpers\n      function queryBarByIdx(idx){\n        return arrayArea.querySelectorAll('.bar')[idx];\n      }\n      function highlightCode(line){\n        codeLines.forEach(l=>l.classList.toggle('active', Number(l.dataset.line) === line));\n      }\n\n      function updateStack(stack){\n        stackList.innerHTML = '';\n        if(!stack || stack.length===0){\n          stackList.innerHTML = '<div class=\"small\" style=\"color:var(--muted)\">Stack empty (done or ready)</div>';\n          return;\n        }\n        stack.forEach(r=>{\n          const el = document.createElement('div');\n          el.className = 'range';\n          el.textContent = '['+r[0]+', '+r[1]+']';\n          stackList.appendChild(el);\n        });\n      }\n\n      // Perform a single step from generator\n      function stepOnce(){\n        if(!generator){\n          // create a copy of array values for algorithm simulation\n          const arr = items.map(it=>it.value);\n          generator = quickSortGenerator(arr);\n        }\n        const res = generator.next();\n        if(res.done){\n          explain.textContent = 'Complete.';\n          highlightCode(null);\n          updateStack([]);\n          generator = null;\n          stopPlay();\n          return;\n        }\n        const step = res.value;\n        currentStep = step;\n        handleStep(step);\n      }\n\n      // Animate swap between two indices\n      function animateSwap(a,b, fast=false){\n        const bars = arrayArea.querySelectorAll('.bar');\n        const barA = bars[a];\n        const barB = bars[b];\n        if(!barA || !barB) return;\n        // mark\n        barA.classList.add('swap');\n        barB.classList.add('swap');\n\n        // compute left positions\n        const leftA = parseFloat(barA.style.left);\n        const leftB = parseFloat(barB.style.left);\n        // swap lefts\n        barA.style.left = leftB + 'px';\n        barB.style.left = leftA + 'px';\n\n        // swap DOM order to keep index mapping stable for queries\n        const parent = arrayArea;\n        if(a < b){\n          parent.insertBefore(barB, barA);\n          // then insert barA where barB was\n          // (insertBefore handles)\n        } else {\n          parent.insertBefore(barA, barB);\n        }\n\n        return new Promise(resolve=>{\n          setTimeout(()=>{\n            barA.classList.remove('swap');\n            barB.classList.remove('swap');\n            // also swap items array entries\n            const tmp = items[a];\n            items[a] = items[b];\n            items[b] = tmp;\n            resolve();\n          }, fast ? 160 : Math.max(220, speed * 0.6));\n        });\n      }\n\n      function handleStep(step){\n        // clear transient styles\n        clearTransient();\n        switch(step.type){\n          case 'popRange':\n            explain.textContent = 'Popped range ['+step.range[0]+','+step.range[1]+'] from stack.';\n            updateStack(step.stack);\n            highlightCode(2);\n            break;\n          case 'choosePivot':\n            explain.textContent = 'Choosing pivot for range ['+step.range[0]+','+step.range[1]+'].';\n            highlightRange(step.range);\n            highlightCode(11);\n            break;\n          case 'awaitManual':\n            explain.textContent = 'Awaiting manual pivot selection inside range ['+step.range[0]+','+step.range[1]+'] — click a bar.';\n            highlightRange(step.range);\n            highlightCode(11);\n            break;\n          case 'waitingManual':\n            explain.textContent = 'Still waiting for manual pivot. Click an element inside the range.';\n            highlightRange(step.range);\n            highlightCode(11);\n            break;\n          case 'pivotChosen':\n            explain.textContent = 'Pivot chosen at index '+step.pivotIdx+' value '+items[step.pivotIdx].value;\n            highlightBar(step.pivotIdx, 'pivot');\n            highlightCode(11);\n            break;\n          case 'swap':\n            explain.textContent = 'Swapping indices ' + step.a + ' and ' + step.b + ' (' + step.values[0] + ' ↔ ' + step.values[1] + ').';\n            // animate: swap in items array visually\n            highlightCode(15);\n            animateSwap(step.a, step.b).then(()=>{\n              // After swap, we continue when Play is active or user presses Step\n            });\n            break;\n          case 'setI':\n            explain.textContent = 'Set i = ' + step.i + '. Pivot value = ' + step.pivot;\n            highlightCode(12);\n            break;\n          case 'compare':\n            explain.textContent = 'Compare index ' + step.j + ' value ' + items[step.j].value + ' with pivot ' + step.pivot + '.';\n            highlightBar(step.j, 'compare');\n            highlightCode(14);\n            break;\n          case 'updateI':\n            explain.textContent = 'Increment i → ' + step.i;\n            highlightCode(16);\n            break;\n          case 'partitionDone':\n            explain.textContent = 'Partition complete. Pivot placed at index ' + step.p + '.';\n            highlightBar(step.p, 'sorted');\n            highlightCode(17);\n            sortedIndices.add(step.p);\n            break;\n          case 'pushRange':\n            explain.textContent = 'Pushed range ['+step.range[0]+','+step.range[1]+'] onto stack.';\n            updateStack(step.stack);\n            highlightCode(4);\n            break;\n          case 'markSorted':\n            explain.textContent = 'Single element at index ' + step.idx + ' considered sorted.';\n            highlightBar(step.idx, 'sorted');\n            break;\n          case 'done':\n            explain.textContent = 'Sorting complete! All elements placed.';\n            highlightAllSorted();\n            highlightCode(null);\n            stopPlay();\n            break;\n          default:\n            explain.textContent = JSON.stringify(step);\n        }\n      }\n\n      function highlightRange(range){\n        const [low, high] = range;\n        const bars = arrayArea.querySelectorAll('.bar');\n        bars.forEach((b,idx)=>{\n          b.classList.toggle('compare', idx >= low && idx <= high);\n          if(idx >= low && idx <= high){\n            // lighten slightly\n            b.style.opacity = 1;\n          } else {\n            b.style.opacity = 0.6;\n          }\n        });\n      }\n\n      function highlightBar(idx, kind){\n        const bars = arrayArea.querySelectorAll('.bar');\n        bars.forEach(b=>b.classList.remove('pivot','compare','sorted'));\n        if(typeof idx === 'number'){\n          const b = bars[idx];\n          if(b) b.classList.add(kind);\n        }\n      }\n\n      function highlightAllSorted(){\n        const bars = arrayArea.querySelectorAll('.bar');\n        bars.forEach(b=>{\n          b.classList.remove('compare','pivot');\n          b.classList.add('sorted');\n          b.style.opacity = 1;\n        });\n      }\n\n      function clearTransient(){\n        const bars = arrayArea.querySelectorAll('.bar');\n        bars.forEach(b=>{\n          b.classList.remove('compare');\n        });\n      }\n\n      // Control actions\n      updateBtn.addEventListener('click', ()=>{\n        initFromInput();\n      });\n      randomBtn.addEventListener('click', ()=>{\n        const n = Math.floor(Math.random()*9)+6;\n        const arr = [];\n        for(let i=0;i<n;i++) arr.push(Math.floor(Math.random()*90)-10);\n        arrayInput.value = arr.join(',');\n        initFromInput();\n      });\n      shuffleBtn.addEventListener('click', ()=>{\n        if(items.length === 0) return;\n        // Fisher-Yates on items array, then rerender with same values\n        for(let i=items.length-1;i>0;i--){\n          const j = Math.floor(Math.random()*(i+1));\n          const tmp = items[i].value; items[i].value = items[j].value; items[j].value = tmp;\n        }\n        // update DOM labels and heights\n        const bars = arrayArea.querySelectorAll('.bar');\n        const values = items.map(it=>it.value);\n        const maxV = Math.max(1, ...values.map(Math.abs));\n        const availableH = arrayArea.clientHeight - 36;\n        bars.forEach((b,idx)=>{\n          const h = Math.max(18, Math.round((Math.abs(items[idx].value)/maxV) * (availableH - 20))) + 24;\n          b.style.height = h + 'px';\n          b.querySelector('.val').textContent = items[idx].value;\n        });\n        explain.textContent = 'Array shuffled.';\n      });\n\n      resetBtn.addEventListener('click', ()=>{\n        initFromInput();\n      });\n\n      stepBtn.addEventListener('click', ()=>{\n        if(playing){\n          stopPlay();\n        }\n        stepOnce();\n      });\n\n      function playLoop(){\n        if(!generator) stepOnce(); // initializes generator\n        stepOnce();\n        if(playing){\n          playTimer = setTimeout(playLoop, speed);\n        }\n      }\n\n      playBtn.addEventListener('click', ()=>{\n        if(!playing){\n          playing = true;\n          playBtn.classList.add('active');\n          playBtn.textContent = 'Pause';\n          playLoop();\n        } else {\n          stopPlay();\n        }\n      });\n\n      runBtn.addEventListener('click', ()=>{\n        if(!generator) stepOnce();\n        // run until done\n        const runUntilDone = () => {\n          const next = generator.next();\n          if(next.done){\n            explain.textContent = 'Complete.';\n            highlightAllSorted();\n            generator = null;\n            return;\n          }\n          handleStep(next.value);\n          setTimeout(runUntilDone, Math.max(30, speed*0.2));\n        };\n        runUntilDone();\n      });\n\n      speedInput.addEventListener('input', (e)=>{\n        speed = parseInt(e.target.value,10);\n      });\n\n      function stopPlay(){\n        playing = false;\n        playBtn.classList.remove('active');\n        playBtn.textContent = 'Play';\n        if(playTimer) clearTimeout(playTimer);\n        playTimer = null;\n      }\n\n      // keyboard accessibility\n      document.addEventListener('keydown', (e)=>{\n        if(e.code === 'Space'){\n          e.preventDefault();\n          stepBtn.click();\n        } else if(e.key === 'p'){\n          playBtn.click();\n        }\n      });\n\n      // Initialize on load\n      initFromInput();\n\n      // Resize handling: reposition bars based on new width\n      window.addEventListener('resize', ()=>{\n        if(items.length === 0) return;\n        // recompute left positions\n        const bars = arrayArea.querySelectorAll('.bar');\n        const areaW = arrayArea.clientWidth;\n        let maxBarW = 72;\n        let minBarW = 34;\n        barWidth = Math.max(minBarW, Math.min(maxBarW, Math.floor((areaW - 20) / items.length) - 8));\n        bars.forEach((b,idx)=>{\n          const left = idx * (barWidth + 8) + 12;\n          b.style.width = barWidth + 'px';\n          b.style.left = left + 'px';\n        });\n      });\n\n      // Ensure announcements are polite for screen readers\n      const live = document.createElement('div');\n      live.setAttribute('aria-live','polite');\n      live.style.position = 'absolute';\n      live.style.left = '-9999px';\n      document.body.appendChild(live);\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Quick Sort.\n\n**Project Overview:**\nTopic: Quick Sort\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Quick Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "ed88bf00-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:48:09.456Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Depth-First Search (DFS)",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Depth-First Search (DFS) Interactive Module</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #60a5fa;\n      --accent-2: #7c3aed;\n      --muted: #94a3b8;\n      --success: #10b981;\n      --danger: #ef4444;\n      --node-size: 44px;\n    }\n    html,body{\n      margin:0;\n      height:100%;\n      background: linear-gradient(180deg,#071022 0%, #07142a 100%);\n      color: #dbeafe;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n    .app {\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height: 100vh;\n      display:flex;\n      flex-direction:column;\n      gap: var(--gap);\n    }\n\n    /* Header (planning / description) */\n    .header {\n      background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: 12px;\n      padding: 18px;\n      display:flex;\n      flex-direction:column;\n      gap:10px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n    }\n    .title-row{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content:space-between;\n    }\n    h1 {\n      margin:0;\n      font-size:18px;\n      letter-spacing: -0.2px;\n      color: #e6eef8;\n    }\n    .meta {\n      display:flex;\n      gap:12px;\n      align-items:center;\n      color: var(--muted);\n      font-size:13px;\n    }\n    .pill {\n      background: rgba(255,255,255,0.04);\n      padding:6px 10px;\n      border-radius:999px;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .header p { margin:0; color: #cfe8ffcc; font-size:13px; line-height:1.4; }\n\n    /* Main content layout */\n    .main {\n      display:flex;\n      gap: var(--gap);\n      align-items:stretch;\n      flex: 1;\n      min-height: 420px;\n    }\n    .canvas-panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: 12px;\n      padding:12px;\n      flex:1 1 0;\n      min-width: 320px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .top-controls {\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .btn{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);\n      color: var(--accent);\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      min-height:40px;\n      display:inline-flex;\n      gap:8px;\n      align-items:center;\n    }\n    .btn.primary{ background: linear-gradient(90deg,var(--accent),var(--accent-2)); color:#022; border: none;}\n    .btn.ghost { color:var(--muted); border:1px dashed rgba(255,255,255,0.03); background:transparent; }\n    .btn.small { padding:6px 8px; font-size:13px; min-height:32px;}\n    .toggles { display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px;}\n\n    /* Canvas area */\n    .board {\n      background: linear-gradient(180deg, rgba(255,255,255,0.006), rgba(255,255,255,0.002));\n      border-radius:10px;\n      height:520px;\n      position:relative;\n      overflow:hidden;\n      touch-action:none;\n    }\n    svg {\n      width:100%;\n      height:100%;\n      display:block;\n    }\n    .node {\n      cursor:pointer;\n      transition: transform 120ms ease, filter 120ms ease;\n    }\n    .node .circle{\n      fill: #0b1220;\n      stroke: rgba(255,255,255,0.06);\n      stroke-width:2;\n      filter: drop-shadow(0 6px 12px rgba(2,6,23,0.6));\n      transition: fill 220ms ease, stroke 220ms ease;\n    }\n    .node text {\n      font-size:13px;\n      fill: #e6eef8;\n      pointer-events:none;\n    }\n    .node.unvisited .circle { fill: #0b1220; stroke: rgba(255,255,255,0.06); }\n    .node.discovered .circle { fill: #07367a; stroke: var(--accent); }\n    .node.finished .circle { fill: #08391b; stroke: var(--success); }\n\n    /* Node pulsing when active */\n    .node.pulse .pulse-ring {\n      opacity:1;\n      transform:scale(1);\n      transition:opacity 300ms, transform 600ms;\n    }\n    .pulse-ring{\n      fill:none;\n      stroke: rgba(96,165,250,0.22);\n      stroke-width:6;\n      r:30;\n      transform-origin:center;\n      transform:scale(0.4);\n      opacity:0;\n    }\n\n    /* Edge styles */\n    .edge {\n      stroke: rgba(255,255,255,0.06);\n      stroke-width:3;\n      transition: stroke 220ms ease, stroke-width 220ms ease, opacity 220ms;\n      fill:none;\n      marker-end: url(#arrow);\n    }\n    .edge.highlight { stroke: var(--accent); stroke-width:4.4; opacity:1; }\n    .edge.dim { opacity:0.25; }\n\n    /* Right panel */\n    .side-panel {\n      width:340px;\n      min-width:260px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:12px;\n      padding:12px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .panel-section { background: transparent; padding:8px; border-radius:8px; display:flex; flex-direction:column; gap:8px; }\n    label { font-size:13px; color:var(--muted); }\n    .controls-row { display:flex; gap:8px; flex-wrap:wrap; }\n    .info { font-size:13px; color: #cfe8ffcc; }\n\n    .stack {\n      background: rgba(255,255,255,0.02);\n      border-radius:8px;\n      padding:8px;\n      min-height:120px;\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      overflow:auto;\n    }\n    .stack .frame {\n      background: rgba(255,255,255,0.01);\n      border:1px solid rgba(255,255,255,0.02);\n      padding:8px;\n      border-radius:8px;\n      display:flex;\n      justify-content:space-between;\n      gap:8px;\n      align-items:center;\n      color:var(--muted);\n      font-weight:600;\n    }\n    .trace {\n      background: rgba(255,255,255,0.01);\n      border-radius:8px;\n      padding:8px;\n      color:var(--muted);\n      font-size:13px;\n      min-height:80px;\n      overflow:auto;\n    }\n\n    /* footer / hints */\n    .hints { color:var(--muted); font-size:13px; display:flex; gap:10px; flex-wrap:wrap; }\n\n    /* responsive */\n    @media (max-width: 920px) {\n      .main { flex-direction:column; }\n      .side-panel { width:100%; }\n    }\n\n    /* small helper components */\n    .kbd { background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:6px; color:var(--muted); font-weight:700; font-size:12px; }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"DFS interactive module\">\n\n    <!-- Header / Planning -->\n    <div class=\"header\" role=\"region\" aria-label=\"Module description\">\n      <div class=\"title-row\">\n        <h1>Depth-First Search (DFS) — Interactive Exploration</h1>\n        <div class=\"meta\">\n          <div class=\"pill\">Concept: Graph Traversal</div>\n          <div class=\"pill\">Mode: Visual & Stepwise</div>\n        </div>\n      </div>\n\n      <!-- Planning Sections -->\n      <p><strong>Learning Objective:</strong> Interactively understand how Depth-First Search (DFS) explores a graph: how nodes are discovered, how DFS backtracks, and how the traversal order depends on neighbor order. After using the module, you will be able to trace DFS steps manually and reason about the recursion stack or iterative stack behavior.</p>\n\n      <p><strong>Interaction Design:</strong> This single-page module lets you construct a graph by clicking to add nodes and dragging from one node to another to create edges. Pick a start node, then run DFS either recursively or iteratively. Controls include Play/Pause, Step Forward, Step Back, and Speed. Visual feedback includes node color changes for undiscovered/discovered/finished states, animated edge highlights during exploration, and a live stack/call-frame panel that updates with push/pop events. Reposition nodes by dragging to observe how visual layout doesn't affect traversal logic. All animations are CSS/SVG-based and reversible by stepping back.</p>\n\n      <p><strong>Layout Description:</strong> The page uses a two-column responsive layout: a left canvas panel (graph + controls) and a right side panel (algorithm controls, stack visualization, and event trace). Safe area margins are 24px; minimum spacing between interactive elements is 16px. Buttons and interactive items have clear focus and labels; the SVG canvas supports pointer and touch interactions and scales responsively for small screens.</p>\n    </div>\n\n    <!-- Main interactive area -->\n    <div class=\"main\" role=\"region\" aria-label=\"Interactive workspace\">\n\n      <!-- Canvas and controls -->\n      <div class=\"canvas-panel\" role=\"region\" aria-label=\"Graph construction panel\">\n        <div class=\"top-controls\" role=\"toolbar\" aria-label=\"Top controls\">\n          <button class=\"btn\" id=\"helpBtn\" title=\"Quick usage tips\">Hints</button>\n\n          <div style=\"display:flex; gap:8px; align-items:center;\">\n            <button class=\"btn\" id=\"addNodeBtn\" aria-pressed=\"true\">Add Node (click)</button>\n            <button class=\"btn ghost\" id=\"connectTips\" title=\"Drag from a node to another to create an edge\">Drag to Connect</button>\n          </div>\n\n          <div style=\"flex:1\"></div>\n\n          <div class=\"toggles\" aria-hidden=\"false\">\n            <label for=\"directedToggle\" style=\"display:flex; gap:8px; align-items:center;\">\n              <input type=\"checkbox\" id=\"directedToggle\" /> Directed\n            </label>\n            <label for=\"modeSelect\" style=\"display:flex; gap:8px; align-items:center;\">\n              Mode:\n              <select id=\"modeSelect\" style=\"background:transparent; color:var(--accent); border:none; font-weight:700;\">\n                <option value=\"recursive\">Recursive</option>\n                <option value=\"iterative\">Iterative (stack)</option>\n              </select>\n            </label>\n          </div>\n        </div>\n\n        <div class=\"board\" id=\"board\" tabindex=\"0\" aria-label=\"Graph board. Click to add nodes. Drag nodes to move. Drag from a node to another to connect.\">\n          <!-- SVG inside -->\n          <svg id=\"svgRoot\" xmlns=\"http://www.w3.org/2000/svg\" role=\"img\" aria-label=\"Graph visualization\">\n            <defs>\n              <marker id=\"arrow\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\" markerWidth=\"6\" markerHeight=\"6\" orient=\"auto-start-reverse\">\n                <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#bfe1ff\" opacity=\"0.85\"></path>\n              </marker>\n            </defs>\n            <g id=\"edgesLayer\"></g>\n            <g id=\"tempEdgeLayer\"></g>\n            <g id=\"nodesLayer\"></g>\n          </svg>\n        </div>\n\n        <div style=\"display:flex; gap:12px; align-items:center; justify-content:space-between;\">\n          <div style=\"display:flex; gap:8px; align-items:center;\">\n            <button class=\"btn primary\" id=\"playBtn\">Play</button>\n            <button class=\"btn\" id=\"stepFwd\">Step ›</button>\n            <button class=\"btn\" id=\"stepBack\">‹ Step</button>\n            <button class=\"btn ghost\" id=\"resetBtn\">Reset</button>\n          </div>\n\n          <div style=\"display:flex; gap:8px; align-items:center;\">\n            <label class=\"info\" for=\"speedRange\">Speed</label>\n            <input id=\"speedRange\" type=\"range\" min=\"200\" max=\"1600\" value=\"800\" step=\"50\" />\n          </div>\n        </div>\n\n      </div>\n\n      <!-- Side panel -->\n      <aside class=\"side-panel\" role=\"region\" aria-label=\"Controls and stack visualization\">\n        <div class=\"panel-section\" role=\"group\" aria-label=\"Algorithm controls\">\n          <label>Start Node</label>\n          <div style=\"display:flex; gap:8px; align-items:center;\">\n            <div id=\"startNodeInfo\" class=\"info\">No start node selected</div>\n            <button class=\"btn small\" id=\"pickStartBtn\">Pick Start</button>\n          </div>\n\n          <div class=\"controls-row\" style=\"margin-top:6px;\">\n            <button class=\"btn small\" id=\"discoverAllBtn\">Discover All (multi-component)</button>\n            <button class=\"btn small\" id=\"clearGraphBtn\">Clear Graph</button>\n          </div>\n\n          <div style=\"display:flex; gap:8px; align-items:center; margin-top:6px;\">\n            <label style=\"min-width:74px;\">Edge Type</label>\n            <div class=\"info\" id=\"edgeTypeInfo\">Undirected by default</div>\n          </div>\n        </div>\n\n        <div class=\"panel-section\" role=\"group\" aria-label=\"Stack / Call frames\">\n          <label>Stack / Call Frames</label>\n          <div class=\"stack\" id=\"stackPanel\" aria-live=\"polite\">\n            <div class=\"info\">Stack is empty. Start the traversal to see push/pop events.</div>\n          </div>\n\n          <label style=\"margin-top:8px\">Event Trace</label>\n          <div class=\"trace\" id=\"tracePanel\" aria-live=\"polite\">No events yet.</div>\n        </div>\n\n        <div class=\"panel-section\" role=\"group\" aria-label=\"Tips\">\n          <label>Quick Tips</label>\n          <div class=\"hints\">\n            <div class=\"kbd\">Click</div> to add a node\n            <div class=\"kbd\">Drag</div> from a node to another to create an edge\n            <div class=\"kbd\">Drag node</div> to reposition\n            <div class=\"kbd\">Pick Start</div> then Play/Step to run DFS\n          </div>\n        </div>\n      </aside>\n    </div>\n  </div>\n\n  <script>\n    /*\n      DFS Interactive Module\n      - Build a graph by clicking to add nodes and dragging from node to node to create edges.\n      - Select a start node and run DFS in recursive or iterative mode.\n      - The traversal is converted to an event log which is animated step-by-step.\n      - Supports Play/Pause, Step Forward, Step Back, Reset, and speed control.\n      - All visuals are SVG + CSS.\n    */\n\n    (function(){\n\n      // Basic constants & DOM\n      const board = document.getElementById('board');\n      const svg = document.getElementById('svgRoot');\n      const nodesLayer = document.getElementById('nodesLayer');\n      const edgesLayer = document.getElementById('edgesLayer');\n      const tempEdgeLayer = document.getElementById('tempEdgeLayer');\n\n      const addNodeBtn = document.getElementById('addNodeBtn');\n      const pickStartBtn = document.getElementById('pickStartBtn');\n      const startNodeInfo = document.getElementById('startNodeInfo');\n      const modeSelect = document.getElementById('modeSelect');\n      const directedToggle = document.getElementById('directedToggle');\n      const playBtn = document.getElementById('playBtn');\n      const stepFwd = document.getElementById('stepFwd');\n      const stepBack = document.getElementById('stepBack');\n      const resetBtn = document.getElementById('resetBtn');\n      const speedRange = document.getElementById('speedRange');\n      const stackPanel = document.getElementById('stackPanel');\n      const tracePanel = document.getElementById('tracePanel');\n      const discoverAllBtn = document.getElementById('discoverAllBtn');\n      const clearGraphBtn = document.getElementById('clearGraphBtn');\n      const edgeTypeInfo = document.getElementById('edgeTypeInfo');\n      const helpBtn = document.getElementById('helpBtn');\n\n      // State\n      let nodes = []; // {id, x, y}\n      let edges = []; // {id, from, to}\n      let nodeIdSeq = 1;\n      let edgeIdSeq = 1;\n      let mode = 'recursive';\n      let directed = false;\n      let startNodeId = null;\n      let addNodeMode = true;\n      let pickStartMode = false;\n\n      // Interaction state\n      let draggingNode = null;\n      let dragOffset = {x:0,y:0};\n      let isDraggingCanvas = false;\n\n      // Temp edge drawing\n      let isDrawingEdge = false;\n      let edgeStartNode = null;\n\n      // Traversal playback\n      let eventLog = []; // sequence of events\n      let currentEventIndex = 0; // events applied [0..currentEventIndex-1]\n      let playing = false;\n      let playTimer = null;\n\n      // Accessibility: announce small messages to tracePanel/stack live regions\n      function announce(text){\n        const p = document.createElement('div');\n        p.textContent = text;\n        tracePanel.appendChild(p);\n        tracePanel.scrollTop = tracePanel.scrollHeight;\n      }\n\n      // Utility: mouse to svg coordinates\n      function getSvgPoint(clientX, clientY){\n        const pt = svg.createSVGPoint();\n        pt.x = clientX; pt.y = clientY;\n        const ctm = svg.getScreenCTM().inverse();\n        return pt.matrixTransform(ctm);\n      }\n\n      // Node and edge rendering\n      function render(){\n        // edges first\n        edgesLayer.innerHTML = '';\n        for (const e of edges){\n          const from = nodes.find(n=>n.id===e.from);\n          const to = nodes.find(n=>n.id===e.to);\n          if (!from || !to) continue;\n          const line = document.createElementNS('http://www.w3.org/2000/svg','path');\n          line.setAttribute('d', makeEdgePath(from,to));\n          line.setAttribute('class','edge');\n          line.dataset.id = e.id;\n          edgesLayer.appendChild(line);\n        }\n\n        // nodes\n        nodesLayer.innerHTML = '';\n        for (const n of nodes){\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('transform', `translate(${n.x},${n.y})`);\n          g.setAttribute('class', 'node unvisited');\n          g.dataset.id = n.id;\n          g.setAttribute('role','button');\n          g.setAttribute('tabindex','0');\n          g.setAttribute('aria-label', 'Node ' + n.label);\n\n          const ring = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          ring.setAttribute('r','30');\n          ring.setAttribute('class','pulse-ring');\n          g.appendChild(ring);\n\n          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          c.setAttribute('r','22');\n          c.setAttribute('class','circle');\n          g.appendChild(c);\n\n          const txt = document.createElementNS('http://www.w3.org/2000/svg','text');\n          txt.setAttribute('x','0');\n          txt.setAttribute('y','5');\n          txt.setAttribute('text-anchor','middle');\n          txt.textContent = n.label;\n          g.appendChild(txt);\n\n          // event handlers\n          g.addEventListener('mousedown', onNodePointerDown);\n          g.addEventListener('touchstart', onNodePointerDown, {passive:false});\n          g.addEventListener('click', onNodeClick);\n          g.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter' || ev.key===' ') onNodeClick(ev); });\n\n          nodesLayer.appendChild(g);\n        }\n\n        updateEdgeTypeInfo();\n      }\n\n      function makeEdgePath(a,b){\n        // simple straight line; for readability offset a bit if overlapping\n        return `M ${a.x} ${a.y} L ${b.x} ${b.y}`;\n      }\n\n      // Add node at coordinates\n      function addNodeAt(x,y){\n        const label = String(nodeIdSeq);\n        const n = { id: nodeIdSeq, x, y, label };\n        nodeIdSeq++;\n        nodes.push(n);\n        render();\n      }\n\n      // Add edge\n      function addEdge(fromId, toId){\n        if (!directed) {\n          // avoid double (from,to) duplicates in undirected: store smaller->larger\n          const a = Math.min(fromId,toId), b = Math.max(fromId,toId);\n          if (edges.some(e => (e.from===a && e.to===b) || (e.from===b && e.to===a))) return;\n          edges.push({ id: edgeIdSeq++, from: a, to: b });\n        } else {\n          if (edges.some(e => e.from===fromId && e.to===toId)) return;\n          edges.push({ id: edgeIdSeq++, from: fromId, to: toId });\n        }\n        render();\n      }\n\n      // Update edge hint text\n      function updateEdgeTypeInfo(){\n        edgeTypeInfo.textContent = directed ? 'Directed' : 'Undirected';\n      }\n\n      // Node handlers\n      function onNodePointerDown(e){\n        e.preventDefault();\n        const target = e.currentTarget;\n        const id = parseInt(target.dataset.id,10);\n        const pt = (e.touches && e.touches[0]) ? e.touches[0] : e;\n        const svgP = getSvgPoint(pt.clientX, pt.clientY);\n        // start dragging node\n        draggingNode = nodes.find(n=>n.id===id);\n        dragOffset.x = svgP.x - draggingNode.x;\n        dragOffset.y = svgP.y - draggingNode.y;\n\n        // For drawing edge: start drawing if shift key is held (or long press)\n        if (e.shiftKey || e.button === 2) {\n          // start drawing edge\n          startDrawingEdge(draggingNode, svgP.x, svgP.y);\n          draggingNode = null;\n        } else {\n          // normal drag move\n          window.addEventListener('mousemove', onPointerMove);\n          window.addEventListener('mouseup', onPointerUp);\n          window.addEventListener('touchmove', onPointerMove, {passive:false});\n          window.addEventListener('touchend', onPointerUp);\n        }\n      }\n\n      function onPointerMove(e){\n        e.preventDefault();\n        const pt = (e.touches && e.touches[0]) ? e.touches[0] : e;\n        const svgP = getSvgPoint(pt.clientX, pt.clientY);\n        if (draggingNode){\n          draggingNode.x = svgP.x - dragOffset.x;\n          draggingNode.y = svgP.y - dragOffset.y;\n          render();\n        } else if (isDrawingEdge){\n          // update temp line\n          const from = edgeStartNode;\n          tempEdgeLayer.innerHTML = '';\n          const line = document.createElementNS('http://www.w3.org/2000/svg','path');\n          line.setAttribute('d', `M ${from.x} ${from.y} L ${svgP.x} ${svgP.y}`);\n          line.setAttribute('stroke','#7c3aed');\n          line.setAttribute('stroke-width','3');\n          line.setAttribute('fill','none');\n          tempEdgeLayer.appendChild(line);\n        }\n      }\n\n      function onPointerUp(e){\n        e.preventDefault();\n        if (draggingNode){\n          draggingNode = null;\n          window.removeEventListener('mousemove', onPointerMove);\n          window.removeEventListener('mouseup', onPointerUp);\n          window.removeEventListener('touchmove', onPointerMove);\n          window.removeEventListener('touchend', onPointerUp);\n        } else if (isDrawingEdge){\n          // check where it was released - if on a node, create edge\n          tempEdgeLayer.innerHTML = '';\n          const pt = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : e;\n          const svgP = getSvgPoint(pt.clientX, pt.clientY);\n          const target = nearestNodeWithin(svgP.x, svgP.y, 26);\n          if (target && target.id !== edgeStartNode.id){\n            addEdge(edgeStartNode.id, target.id);\n          }\n          edgeStartNode = null;\n          isDrawingEdge = false;\n        }\n      }\n\n      function onNodeClick(e){\n        if (pickStartMode){\n          const id = parseInt(e.currentTarget.dataset.id,10);\n          startNodeId = id;\n          startNodeInfo.textContent = 'Start: ' + id;\n          pickStartMode = false;\n          pickStartBtn.classList.remove('btn--active');\n          saveUiState();\n        } else if (addNodeMode){\n          // clicking node selects it (for future features), for now toggle selection highlight\n          // small pulse\n          const g = e.currentTarget;\n          g.classList.add('pulse');\n          setTimeout(()=>g.classList.remove('pulse'), 800);\n        }\n      }\n\n      // Board click: add node\n      board.addEventListener('click', function(e){\n        // ignore clicks on existing nodes (handled separately)\n        if (e.target.closest('.node')) return;\n        if (!addNodeMode) return;\n        const svgP = getSvgPoint(e.clientX, e.clientY);\n        addNodeAt(svgP.x, svgP.y);\n      });\n\n      // Start drawing edge from node\n      function startDrawingEdge(node, x, y){\n        isDrawingEdge = true;\n        edgeStartNode = node;\n        tempEdgeLayer.innerHTML = '';\n        const line = document.createElementNS('http://www.w3.org/2000/svg','path');\n        line.setAttribute('d', `M ${x} ${y} L ${x} ${y}`);\n        line.setAttribute('stroke','#7c3aed');\n        line.setAttribute('stroke-width','3');\n        line.setAttribute('fill','none');\n        tempEdgeLayer.appendChild(line);\n        window.addEventListener('mousemove', onPointerMove);\n        window.addEventListener('mouseup', onPointerUp);\n        window.addEventListener('touchmove', onPointerMove, {passive:false});\n        window.addEventListener('touchend', onPointerUp);\n      }\n\n      // find nearest node within radius\n      function nearestNodeWithin(x,y,radius){\n        let best = null, bestd = radius*radius;\n        for (const n of nodes){\n          const dx = n.x - x, dy = n.y - y;\n          const d = dx*dx + dy*dy;\n          if (d < bestd){\n            bestd = d; best = n;\n          }\n        }\n        return best;\n      }\n\n      // UI button events\n      addNodeBtn.addEventListener('click', ()=>{\n        addNodeMode = true;\n        pickStartMode = false;\n        addNodeBtn.setAttribute('aria-pressed','true');\n        pickStartBtn.setAttribute('aria-pressed','false');\n      });\n\n      pickStartBtn.addEventListener('click', ()=>{\n        pickStartMode = !pickStartMode;\n        if (pickStartMode){\n          addNodeMode = false;\n          pickStartBtn.setAttribute('aria-pressed','true');\n          addNodeBtn.setAttribute('aria-pressed','false');\n        } else {\n          pickStartBtn.setAttribute('aria-pressed','false');\n        }\n      });\n\n      directedToggle.addEventListener('change', (e)=>{\n        directed = e.target.checked;\n        render();\n      });\n\n      modeSelect.addEventListener('change', (e)=>{\n        mode = e.target.value;\n      });\n\n      clearGraphBtn.addEventListener('click', ()=>{\n        nodes = [];\n        edges = [];\n        nodeIdSeq = 1;\n        edgeIdSeq = 1;\n        startNodeId = null;\n        startNodeInfo.textContent = 'No start node selected';\n        resetTraversal();\n        render();\n      });\n\n      discoverAllBtn.addEventListener('click', ()=>{\n        // If no start node, run DFS from each unvisited to cover all components\n        if (nodes.length === 0) return;\n        startNodeId = nodes[0].id;\n        startNodeInfo.textContent = 'Start: All components';\n        runTraversalAll();\n      });\n\n      helpBtn.addEventListener('click', ()=>{\n        alert('Quick tips:\\n\\n- Click anywhere on the board to add a node.\\n- Drag from one node to another to create an edge.\\n- Click \"Pick Start\" then click a node to set start node.\\n- Toggle Recursive/Iterative mode and Play to animate DFS.\\n- Use Step to go forward/back through events. Shift+Drag on a node also draws an edge.');\n      });\n\n      // Playback controls\n      playBtn.addEventListener('click', ()=>{\n        if (playing) stopPlaying();\n        else startPlaying();\n      });\n\n      stepFwd.addEventListener('click', ()=>{\n        pausePlaying();\n        stepForward();\n      });\n\n      stepBack.addEventListener('click', ()=>{\n        pausePlaying();\n        stepBackwards();\n      });\n\n      resetBtn.addEventListener('click', ()=>{\n        pausePlaying();\n        resetTraversal();\n      });\n\n      speedRange.addEventListener('input', ()=>{\n        if (playing) {\n          stopPlaying();\n          startPlaying();\n        }\n      });\n\n      // ---------------------------\n      // Traversal: generate event log\n      // events: { type:'discover'|'explore'|'finish'|'push'|'pop', node: id, from?:id, to?:id }\n      // For both recursive and iterative we will generate events that are easy to play.\n      // ---------------------------\n      function buildAdjacency(){\n        const adj = new Map();\n        for (const n of nodes) adj.set(n.id, []);\n        for (const e of edges){\n          if (!directed){\n            // edges stored maybe as smaller->larger; but we should add adjacency both ways\n            adj.get(e.from).push(e.to);\n            adj.get(e.to).push(e.from);\n          } else {\n            adj.get(e.from).push(e.to);\n          }\n        }\n        // We'll keep neighbor order as insertion order (i.e., as edges were added).\n        return adj;\n      }\n\n      function generateEventsRecursive(startId){\n        eventLog = [];\n        const adj = buildAdjacency();\n        const visited = new Set();\n\n        function dfs(u){\n          eventLog.push({type:'discover', node:u});\n          visited.add(u);\n          const neighbors = adj.get(u) || [];\n          for (const v of neighbors){\n            eventLog.push({type:'explore', from:u, to:v});\n            if (!visited.has(v)){\n              dfs(v);\n            } else {\n              // short note: already visited\n            }\n          }\n          eventLog.push({type:'finish', node:u});\n        }\n\n        if (startId != null){\n          dfs(startId);\n        }\n        return eventLog;\n      }\n\n      function generateEventsIterative(startId){\n        eventLog = [];\n        const adj = buildAdjacency();\n        const visited = new Set();\n        if (startId == null) return eventLog;\n\n        // iterative stack contains {node, nextIndex}\n        const stack = [];\n        stack.push({node:startId, nextIndex:0});\n        eventLog.push({type:'push', node:startId});\n        eventLog.push({type:'discover', node:startId});\n        visited.add(startId);\n\n        while (stack.length){\n          const frame = stack[stack.length-1];\n          const u = frame.node;\n          const neighbors = adj.get(u) || [];\n          if (frame.nextIndex < neighbors.length){\n            const v = neighbors[frame.nextIndex];\n            frame.nextIndex++;\n            eventLog.push({type:'explore', from:u, to:v});\n            if (!visited.has(v)){\n              visited.add(v);\n              eventLog.push({type:'push', node:v});\n              eventLog.push({type:'discover', node:v});\n              stack.push({node:v, nextIndex:0});\n            } else {\n              // already visited, just note exploration\n            }\n          } else {\n            // finished u\n            eventLog.push({type:'pop', node:u});\n            eventLog.push({type:'finish', node:u});\n            stack.pop();\n          }\n        }\n        return eventLog;\n      }\n\n      // If wanting to traverse all components (Discover All)\n      function generateEventsAll(modeOption){\n        eventLog = [];\n        const adj = buildAdjacency();\n        const visited = new Set();\n        const allNodes = Array.from(adj.keys());\n        for (const start of allNodes){\n          if (!visited.has(start)){\n            if (modeOption === 'recursive'){\n              // local recursive that references visited outside\n              function dfs(u){\n                eventLog.push({type:'discover', node:u});\n                visited.add(u);\n                const neighbors = adj.get(u) || [];\n                for (const v of neighbors){\n                  eventLog.push({type:'explore', from:u, to:v});\n                  if (!visited.has(v)){\n                    dfs(v);\n                  }\n                }\n                eventLog.push({type:'finish', node:u});\n              }\n              dfs(start);\n            } else {\n              // iterative from start\n              const stack = [];\n              stack.push({node:start, nextIndex:0});\n              eventLog.push({type:'push', node:start});\n              eventLog.push({type:'discover', node:start});\n              visited.add(start);\n              while (stack.length){\n                const frame = stack[stack.length-1];\n                const u = frame.node;\n                const neighbors = adj.get(u) || [];\n                if (frame.nextIndex < neighbors.length){\n                  const v = neighbors[frame.nextIndex];\n                  frame.nextIndex++;\n                  eventLog.push({type:'explore', from:u, to:v});\n                  if (!visited.has(v)){\n                    visited.add(v);\n                    eventLog.push({type:'push', node:v});\n                    eventLog.push({type:'discover', node:v});\n                    stack.push({node:v, nextIndex:0});\n                  }\n                } else {\n                  eventLog.push({type:'pop', node:u});\n                  eventLog.push({type:'finish', node:u});\n                  stack.pop();\n                }\n              }\n            }\n          }\n        }\n        return eventLog;\n      }\n\n      // Playback: apply events up to a given index. We'll rebuild state from scratch and apply first N events for simplicity.\n      function applyEventsUpTo(index){\n        // index is number of events to apply\n        // reset visuals\n        for (const g of Array.from(nodesLayer.children || [])){\n          g.classList.remove('discovered','finished','pulse');\n          g.classList.add('unvisited');\n        }\n        for (const e of Array.from(edgesLayer.children || [])){\n          e.classList.remove('highlight','dim');\n        }\n        // clear stack and trace\n        stackPanel.innerHTML = '';\n        tracePanel.innerHTML = '';\n\n        const stackRep = []; // for display, for iterative mode reflect pushes/pops; for recursive we show call frames\n        const discovered = new Set();\n\n        for (let i=0;i<index && i<eventLog.length;i++){\n          const ev = eventLog[i];\n          handleEvent(ev, stackRep, discovered);\n        }\n      }\n\n      function handleEvent(ev, stackRep, discovered){\n        if (ev.type === 'discover'){\n          const g = findNodeGroup(ev.node);\n          if (g){\n            g.classList.remove('unvisited');\n            g.classList.add('discovered');\n            // pulse\n            g.classList.add('pulse');\n            setTimeout(()=>g.classList.remove('pulse'), 600);\n          }\n          discovered.add(ev.node);\n          appendTrace(`Discovered node ${ev.node}`);\n        } else if (ev.type === 'explore'){\n          highlightEdge(ev.from, ev.to);\n          appendTrace(`Exploring edge ${ev.from} → ${ev.to}`);\n        } else if (ev.type === 'finish'){\n          const g = findNodeGroup(ev.node);\n          if (g){\n            g.classList.remove('discovered');\n            g.classList.add('finished');\n          }\n          appendTrace(`Finished node ${ev.node}`);\n        } else if (ev.type === 'push'){\n          stackRep.push(ev.node);\n          renderStack(stackRep);\n          appendTrace(`Push ${ev.node} onto stack`);\n        } else if (ev.type === 'pop'){\n          const popped = stackRep.pop();\n          renderStack(stackRep);\n          appendTrace(`Pop ${popped} from stack`);\n        }\n      }\n\n      function findNodeGroup(id){\n        return nodesLayer.querySelector(`g[data-id=\"${id}\"]`);\n      }\n\n      function appendTrace(text){\n        const d = document.createElement('div');\n        d.textContent = text;\n        tracePanel.appendChild(d);\n        tracePanel.scrollTop = tracePanel.scrollHeight;\n      }\n\n      // Edge highlight animation\n      function highlightEdge(from,to){\n        // find nearest edge element that matches (undirected or directed)\n        const all = Array.from(edgesLayer.children);\n        let el = null;\n        for (const e of all){\n          const ed = edges.find(edg => String(edg.id) === e.dataset.id);\n          if (!ed) continue;\n          if (!directed){\n            // check endpoints\n            if ((ed.from === Math.min(from,to) && ed.to === Math.max(from,to)) || (ed.from === Math.max(from,to) && ed.to === Math.min(from,to))){\n              el = e; break;\n            }\n          } else {\n            if (ed.from === from && ed.to === to){ el = e; break; }\n          }\n        }\n        if (el){\n          el.classList.add('highlight');\n          // remove after timeout to create transient effect\n          setTimeout(()=> el.classList.remove('highlight'), Math.max(400, parseInt(speedRange.value)/2));\n        }\n      }\n\n      function renderStack(stackRep){\n        stackPanel.innerHTML = '';\n        if (stackRep.length === 0){\n          const d = document.createElement('div');\n          d.className = 'info';\n          d.textContent = 'Stack is empty';\n          stackPanel.appendChild(d);\n          return;\n        }\n        // show top at top\n        for (let i = stackRep.length-1; i >= 0; i--){\n          const f = document.createElement('div');\n          f.className = 'frame';\n          f.textContent = 'Node ' + stackRep[i];\n          stackPanel.appendChild(f);\n        }\n      }\n\n      // play / pause logic\n      function startPlaying(){\n        if (!prepareEventLog()) return;\n        playing = true;\n        playBtn.textContent = 'Pause';\n        scheduleNext();\n      }\n\n      function pausePlaying(){\n        playing = false;\n        playBtn.textContent = 'Play';\n        if (playTimer) clearTimeout(playTimer);\n        playTimer = null;\n      }\n\n      function stopPlaying(){\n        pausePlaying();\n      }\n\n      function scheduleNext(){\n        if (!playing) return;\n        if (currentEventIndex >= eventLog.length){\n          // finished\n          pausePlaying();\n          return;\n        }\n        const delay = parseInt(speedRange.value,10);\n        playTimer = setTimeout(()=>{\n          currentEventIndex++;\n          applyEventsUpTo(currentEventIndex);\n          scheduleNext();\n        }, delay);\n      }\n\n      function stepForward(){\n        if (!prepareEventLog()) return;\n        if (currentEventIndex < eventLog.length){\n          currentEventIndex++;\n          applyEventsUpTo(currentEventIndex);\n        }\n      }\n\n      function stepBackwards(){\n        if (!prepareEventLog()) return;\n        if (currentEventIndex > 0){\n          currentEventIndex--;\n          applyEventsUpTo(currentEventIndex);\n        }\n      }\n\n      function prepareEventLog(){\n        if (nodes.length===0) { alert('No nodes to traverse. Add nodes first.'); return false; }\n        if (startNodeId == null && !discoverAllModeRequested) {\n          alert('No start node selected. Click \"Pick Start\" and select a node (or use Discover All).');\n          return false;\n        }\n        // generate eventLog based on mode and start node\n        if (discoverAllModeRequested){\n          eventLog = generateEventsAll(mode);\n          discoverAllModeRequested = false;\n        } else {\n          if (mode === 'recursive') eventLog = generateEventsRecursive(startNodeId);\n          else eventLog = generateEventsIterative(startNodeId);\n        }\n        currentEventIndex = 0;\n        // clear trace and stack\n        stackPanel.innerHTML = '';\n        tracePanel.innerHTML = '';\n        return true;\n      }\n\n      // Reset traversal visuals and state\n      function resetTraversal(){\n        pausePlaying();\n        currentEventIndex = 0;\n        eventLog = [];\n        stackPanel.innerHTML = '';\n        tracePanel.innerHTML = '';\n        // reset node classes\n        for (const g of Array.from(nodesLayer.children || [])){\n          g.classList.remove('discovered','finished','pulse');\n          g.classList.add('unvisited');\n        }\n        for (const e of Array.from(edgesLayer.children || [])){\n          e.classList.remove('highlight','dim');\n        }\n      }\n\n      // Discover all mode\n      let discoverAllModeRequested = false;\n      function runTraversalAll(){\n        // set flag so prepareEventLog will generate all\n        discoverAllModeRequested = true;\n        startPlaying();\n      }\n\n      // small helpers to save UI state (not persistent)\n      function saveUiState(){\n        // stub for future extension\n      }\n\n      // initial render\n      render();\n\n      // allow keyboard shortcuts for convenience\n      window.addEventListener('keydown', (e)=>{\n        if (e.key === ' ') { e.preventDefault(); if (playing) stopPlaying(); else startPlaying(); }\n        if (e.key === 'ArrowRight') { e.preventDefault(); stepForward(); }\n        if (e.key === 'ArrowLeft') { e.preventDefault(); stepBackwards(); }\n        if (e.key === 'r') { resetTraversal(); }\n      });\n\n      // minimal touch: long touch on node draws edge\n      // (we already support shift+drag for edge drawing; touch devices can use long press)\n      let longPressTimer = null;\n      board.addEventListener('touchstart', (e)=>{\n        if (e.target.closest('.node')){\n          const nodeEl = e.target.closest('.node');\n          longPressTimer = setTimeout(()=>{\n            // simulate shift-drag\n            const id = parseInt(nodeEl.dataset.id,10);\n            const node = nodes.find(n=>n.id===id);\n            const client = e.touches[0];\n            const svgP = getSvgPoint(client.clientX, client.clientY);\n            startDrawingEdge(node, svgP.x, svgP.y);\n          }, 450);\n        }\n      });\n      board.addEventListener('touchend', ()=>{ if (longPressTimer) clearTimeout(longPressTimer); });\n\n      // expose some functions for debugging (optional)\n      window.__dfs_debug = {\n        nodes, edges, addNodeAt, addEdge, render\n      };\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Depth-First Search (DFS).\n\n**Project Overview:**\nTopic: Depth-First Search (DFS)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Depth-First Search (DFS)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "c9fed880-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:48:12.840Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Union-Find (Disjoint Set)",
    "answer": {
      "role": "assistant",
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Union-Find Interactive Module</title>\n  <style>\n    :root{\n      --safe-pad: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --accent: #10b981;\n      --accent-2: #2563eb;\n      --muted: #94a3b8;\n      --white: #e6eef8;\n      --danger: #ef4444;\n      --node-size: 48px;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071027 0%, #081420 100%);\n      color:var(--white);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    /* Safe area margins = 24px */\n    .app {\n      padding: var(--safe-pad);\n      box-sizing: border-box;\n      min-height:100vh;\n      display:flex;\n      gap:var(--gap);\n      align-items:stretch;\n    }\n\n    /* Left panel: description and controls */\n    .panel {\n      width:360px;\n      min-width:280px;\n      max-width:40%;\n      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:20px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      box-shadow: 0 6px 20px rgba(2,6,23,0.6);\n    }\n    h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing:0.2px;\n    }\n    p.small {\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n      line-height:1.4;\n    }\n    .section {\n      background: rgba(255,255,255,0.02);\n      padding:12px;\n      border-radius:8px;\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n    .label {\n      font-size:12px;\n      color:var(--muted);\n    }\n\n    /* Controls */\n    .controls {\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .row {\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n    input[type=\"number\"], select {\n      background: rgba(255,255,255,0.03);\n      border:1px solid rgba(255,255,255,0.04);\n      color:var(--white);\n      padding:8px 10px;\n      border-radius:8px;\n      outline:none;\n      width:100%;\n      box-sizing:border-box;\n    }\n    .btn {\n      background: linear-gradient(180deg,var(--accent), #08966b);\n      border:none;\n      color:white;\n      padding:10px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      box-shadow: 0 6px 14px rgba(16,185,129,0.12);\n    }\n    .btn.secondary {\n      background: linear-gradient(180deg,#2a3b5a,#1b2a44);\n      box-shadow:none;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .toggle {\n      display:flex;\n      align-items:center;\n      gap:8px;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .checkbox {\n      appearance:none;\n      width:36px;\n      height:20px;\n      background:rgba(255,255,255,0.06);\n      border-radius:12px;\n      position:relative;\n      outline:none;\n      cursor:pointer;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .checkbox:after{\n      content:'';\n      width:16px;\n      height:16px;\n      border-radius:50%;\n      background:white;\n      position:absolute;\n      left:2px;\n      top:1px;\n      transition:transform .18s ease;\n    }\n    .checkbox[aria-checked=\"true\"]{\n      background:linear-gradient(90deg,var(--accent-2),#7c3aed);\n    }\n    .checkbox[aria-checked=\"true\"]:after{\n      transform:translateX(16px);\n      background:white;\n    }\n\n    /* Right panel: visualizer */\n    .visual {\n      flex:1;\n      min-width:0;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius:12px;\n      padding:18px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      position:relative;\n      overflow:hidden;\n    }\n    .viz-top {\n      display:flex;\n      justify-content:space-between;\n      gap:12px;\n      align-items:center;\n    }\n    .canvas-wrap {\n      flex:1;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius:10px;\n      position:relative;\n      overflow:hidden;\n      min-height:360px;\n      border:1px dashed rgba(255,255,255,0.03);\n    }\n    svg {\n      width:100%;\n      height:100%;\n      display:block;\n    }\n\n    /* Node style */\n    .node {\n      cursor:pointer;\n      transition:transform .12s ease;\n    }\n    .node .circle {\n      fill: #071a2b;\n      stroke: rgba(255,255,255,0.06);\n      stroke-width:2;\n    }\n    .node.root .circle {\n      fill: linear-gradient(180deg,#06324a,#05273b);\n      stroke: rgba(16,185,129,0.2);\n      filter: drop-shadow(0 6px 18px rgba(16,185,129,0.06));\n    }\n    .node .label {\n      fill:var(--white);\n      font-weight:700;\n      font-size:14px;\n      text-anchor:middle;\n      dominant-baseline:middle;\n      pointer-events:none;\n    }\n    .node.selected .circle {\n      stroke: var(--accent-2);\n      stroke-width:3;\n      transform-origin:center;\n    }\n    .pulse {\n      animation: pulse 900ms ease-in-out 2;\n    }\n    @keyframes pulse {\n      0% { transform:scale(1); opacity:1;}\n      50% { transform:scale(1.12); opacity:0.9;}\n      100% { transform:scale(1); opacity:1;}\n    }\n    /* Arrow style */\n    .edge {\n      stroke: rgba(255,255,255,0.08);\n      stroke-width:2;\n      fill:none;\n      marker-end: url(#arrow);\n      transition:stroke 240ms ease;\n    }\n    .edge.new {\n      stroke: var(--accent);\n      stroke-width:2.6;\n      opacity:1;\n      stroke-dasharray: 1000;\n      stroke-dashoffset: 1000;\n      animation: draw 700ms forwards ease-out;\n    }\n    @keyframes draw {\n      to { stroke-dashoffset: 0; }\n    }\n\n    /* Tables for arrays */\n    .arrays {\n      display:flex;\n      gap:12px;\n      align-items:flex-start;\n      flex-wrap:wrap;\n    }\n    .array-box {\n      background: rgba(255,255,255,0.02);\n      padding:8px;\n      border-radius:8px;\n      min-width:120px;\n      box-sizing:border-box;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .array-box .row {\n      justify-content:space-between;\n      gap:8px;\n    }\n    .array-box b {\n      color:var(--white);\n    }\n\n    /* Footer hint */\n    .hint {\n      font-size:13px;\n      color:var(--muted);\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n\n    /* Responsive */\n    @media (max-width:900px){\n      .app { flex-direction:column; padding:18px; }\n      .panel { width:100%; max-width:none; }\n      .visual { width:100%; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Union-Find interactive module\">\n    <!-- LEFT PANEL -->\n    <div class=\"panel\" aria-hidden=\"false\">\n      <h1>Union-Find (Disjoint Set) — Interactive Module</h1>\n      <p class=\"small\">\n        Learn how the Union-Find (Disjoint Set) data structure maintains connected components using union and find operations. Interact to see parent pointers, ranks, and path compression in action.\n      </p>\n\n      <div class=\"section\" aria-labelledby=\"objective\">\n        <div class=\"label\" id=\"objective\">Learning Objective</div>\n        <p class=\"small\">\n          After using this module you should be able to:\n          - Visually trace find(x) to the set representative (root), see how union(a,b) attaches trees, and observe how path compression shortens paths. You will experiment with union-by-rank and animated path compression.\n        </p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"interaction\">\n        <div class=\"label\" id=\"interaction\">Interaction Design (how to use)</div>\n        <ol class=\"small\" style=\"margin:0; padding-left:18px; color:var(--muted);\">\n          <li>Click a node to select it. Select two nodes and press \"Union\" to merge their sets.</li>\n          <li>Click a single node and press \"Find\" to animate find(path) and optionally compress paths.</li>\n          <li>Toggle \"Union by Rank\" and \"Path Compression\" to see different behaviors.</li>\n          <li>Drag nodes to rearrange the layout for clarity.</li>\n          <li>Use \"Random Unions\" to apply random merges with animation and observe parent/rank changes.</li>\n        </ol>\n      </div>\n\n      <div class=\"section controls\" aria-labelledby=\"controls\">\n        <div class=\"label\" id=\"controls\">Controls</div>\n\n        <div class=\"row\" style=\"align-items:center;\">\n          <input id=\"nodeCount\" type=\"number\" min=\"2\" max=\"16\" value=\"8\" aria-label=\"number of nodes\" />\n          <button id=\"rebuildBtn\" class=\"btn\" title=\"Rebuild nodes\">Rebuild</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"unionBtn\" class=\"btn secondary\" title=\"Union selected nodes\">Union</button>\n          <button id=\"findBtn\" class=\"btn secondary\" title=\"Find root of selected node\">Find</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"randomBtn\" class=\"btn\" title=\"Perform random unions\">Random Unions</button>\n          <button id=\"resetBtn\" class=\"btn secondary\" title=\"Reset to singleton sets\">Reset</button>\n        </div>\n\n        <div class=\"row\" style=\"flex-direction:column; gap:8px;\">\n          <label class=\"toggle\"><span class=\"label\">Union by Rank</span>\n            <button id=\"rankToggle\" class=\"checkbox\" role=\"switch\" aria-checked=\"true\" aria-label=\"toggle union by rank\"></button>\n          </label>\n          <label class=\"toggle\"><span class=\"label\">Path Compression</span>\n            <button id=\"pcToggle\" class=\"checkbox\" role=\"switch\" aria-checked=\"true\" aria-label=\"toggle path compression\"></button>\n          </label>\n        </div>\n\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"arrays\">\n        <div class=\"label\" id=\"arrays\">State Views</div>\n        <div class=\"arrays\" id=\"arraysBox\">\n          <div class=\"array-box\">\n            <div style=\"margin-bottom:6px;\"><b>parent[]</b></div>\n            <div id=\"parentView\" style=\"display:flex;flex-direction:column;gap:6px;\"></div>\n          </div>\n          <div class=\"array-box\">\n            <div style=\"margin-bottom:6px;\"><b>rank[]</b></div>\n            <div id=\"rankView\" style=\"display:flex;flex-direction:column;gap:6px;\"></div>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"layout\">\n        <div class=\"label\" id=\"layout\">Layout Notes</div>\n        <p class=\"small\">\n          The right area shows a draggable node graph (SVG). Arrows point from each node to its parent. Selected nodes are highlighted. Animations show new edges being created and path compression rewiring pointers.\n        </p>\n      </div>\n\n      <div class=\"hint\">\n        <span style=\"color:var(--muted);\">Tip:</span>\n        <span style=\"color:var(--white);font-weight:600;\">Click nodes → Union / Find → Watch animations</span>\n      </div>\n\n    </div>\n\n    <!-- RIGHT PANEL: VISUALIZER -->\n    <div class=\"visual\" aria-live=\"polite\">\n      <div class=\"viz-top\">\n        <div style=\"display:flex;flex-direction:column;\">\n          <div style=\"font-size:13px;color:var(--muted);\">Visualizer</div>\n          <div style=\"font-size:12px;color:var(--muted);\">Drag nodes to reposition. Click to select.</div>\n        </div>\n        <div style=\"display:flex;gap:12px;\">\n          <div style=\"font-size:13px;color:var(--muted);\">Selected:\n            <span id=\"selLabel\" style=\"color:var(--white); font-weight:700; margin-left:8px;\">None</span>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"canvas-wrap\" id=\"canvasWrap\">\n        <!-- SVG will be injected here -->\n      </div>\n\n    </div>\n  </div>\n\n  <script>\n    /*****************************************************************************\n     * Union-Find Interactive Module\n     * - Self-contained vanilla JS, HTML, CSS\n     * - Visual, draggable nodes, animated edges, union-by-rank and path compression toggles\n     *\n     * Spacing rules:\n     * - Safe area: 24px via .app padding\n     * - Minimum spacing: 16px via CSS gap variables\n     *****************************************************************************/\n\n    // Utility\n    const clamp = (v,a,b) => Math.max(a,Math.min(b,v));\n    const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;\n\n    // DOM\n    const canvasWrap = document.getElementById('canvasWrap');\n    const nodeCountInput = document.getElementById('nodeCount');\n    const rebuildBtn = document.getElementById('rebuildBtn');\n    const unionBtn = document.getElementById('unionBtn');\n    const findBtn = document.getElementById('findBtn');\n    const randomBtn = document.getElementById('randomBtn');\n    const resetBtn = document.getElementById('resetBtn');\n    const parentView = document.getElementById('parentView');\n    const rankView = document.getElementById('rankView');\n    const rankToggle = document.getElementById('rankToggle');\n    const pcToggle = document.getElementById('pcToggle');\n    const selLabel = document.getElementById('selLabel');\n\n    // State\n    let N = parseInt(nodeCountInput.value,10) || 8;\n    let parent = [];\n    let rankArr = [];\n    let nodes = []; // {id,x,y,svgGroup}\n    let selected = new Set();\n    let svg, edgeLayer, nodeLayer;\n    let dragging = null;\n    let svgRect = null;\n    let unionByRank = true;\n    let pathCompression = true;\n    let animQueue = Promise.resolve();\n\n    // Initialize UI toggles\n    function setToggle(btn, enabled){\n      btn.setAttribute('aria-checked', enabled ? 'true' : 'false');\n    }\n    setToggle(rankToggle, unionByRank);\n    setToggle(pcToggle, pathCompression);\n    rankToggle.addEventListener('click', ()=> {\n      unionByRank = !unionByRank;\n      setToggle(rankToggle, unionByRank);\n    });\n    pcToggle.addEventListener('click', ()=> {\n      pathCompression = !pathCompression;\n      setToggle(pcToggle, pathCompression);\n    });\n\n    // Setup and rebuild\n    function build(Nnodes){\n      N = Math.max(2, Math.min(16, Nnodes));\n      nodeCountInput.value = N;\n      parent = new Array(N).fill(0).map((_,i)=>i);\n      rankArr = new Array(N).fill(0);\n      selected.clear();\n      selLabel.textContent = 'None';\n      // Build SVG\n      canvasWrap.innerHTML = '';\n      svg = document.createElementNS('http://www.w3.org/2000/svg','svg');\n      svg.setAttribute('viewBox','0 0 1000 600');\n      svg.setAttribute('preserveAspectRatio','xMidYMid meet');\n      canvasWrap.appendChild(svg);\n\n      // defs for arrow marker\n      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');\n      const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');\n      marker.setAttribute('id','arrow');\n      marker.setAttribute('markerWidth','8');\n      marker.setAttribute('markerHeight','8');\n      marker.setAttribute('refX','8');\n      marker.setAttribute('refY','3');\n      marker.setAttribute('orient','auto');\n      const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n      path.setAttribute('d','M0,0 L6,3 L0,6 L1,3 z');\n      path.setAttribute('fill','rgba(255,255,255,0.08)');\n      marker.appendChild(path);\n      defs.appendChild(marker);\n      svg.appendChild(defs);\n\n      // layers\n      edgeLayer = document.createElementNS('http://www.w3.org/2000/svg','g');\n      nodeLayer = document.createElementNS('http://www.w3.org/2000/svg','g');\n      svg.appendChild(edgeLayer);\n      svg.appendChild(nodeLayer);\n\n      // place nodes in circular layout\n      nodes = [];\n      const cx = 500, cy = 300, radius = Math.min(380, Math.max(200, N*40));\n      for(let i=0;i<N;i++){\n        const angle = (i/N) * Math.PI*2 - Math.PI/2;\n        const x = cx + Math.cos(angle)*radius*0.7 + randInt(-30,30);\n        const y = cy + Math.sin(angle)*radius*0.7 + randInt(-20,20);\n        nodes.push({id:i,x,y,grp:null});\n      }\n\n      // create visuals\n      nodes.forEach(n => {\n        const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n        g.classList.add('node');\n        g.setAttribute('tabindex','0');\n        g.setAttribute('role','button');\n        g.setAttribute('aria-label','node ' + n.id);\n        // circle\n        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n        circle.classList.add('circle');\n        circle.setAttribute('r', 24);\n        circle.setAttribute('cx', n.x);\n        circle.setAttribute('cy', n.y);\n        // label\n        const label = document.createElementNS('http://www.w3.org/2000/svg','text');\n        label.classList.add('label');\n        label.setAttribute('x', n.x);\n        label.setAttribute('y', n.y);\n        label.textContent = n.id;\n        g.appendChild(circle);\n        g.appendChild(label);\n        g.style.transformOrigin = `${n.x}px ${n.y}px`;\n        nodeLayer.appendChild(g);\n        n.grp = g;\n\n        // attach mouse handlers (drag & click)\n        g.addEventListener('mousedown', (e)=> onNodeDown(e, n));\n        g.addEventListener('touchstart', (e)=> onNodeDown(e, n), {passive:false});\n        g.addEventListener('click', (e)=> onNodeClick(e, n));\n        // keyboard accessibility\n        g.addEventListener('keydown', (e)=> {\n          if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onNodeClick(e,n); }\n        });\n      });\n\n      // initial draw\n      updateEdges();\n      updateArrays();\n      refreshSelectionUI();\n      // listen to mouse move/up on document for dragging\n      document.addEventListener('mousemove', onDocMove);\n      document.addEventListener('mouseup', onDocUp);\n      document.addEventListener('touchmove', onDocMove, {passive:false});\n      document.addEventListener('touchend', onDocUp);\n\n      // recalc svg rect for bounds on drag\n      setTimeout(()=> {\n        svgRect = canvasWrap.getBoundingClientRect();\n      }, 50);\n    }\n\n    // Update parent and rank boxes\n    function updateArrays(){\n      parentView.innerHTML = '';\n      rankView.innerHTML = '';\n      for(let i=0;i<N;i++){\n        const r1 = document.createElement('div');\n        r1.className = 'row';\n        const k = document.createElement('div'); k.textContent = i;\n        k.style.color = 'var(--muted)';\n        const v = document.createElement('div'); v.innerHTML = '<b>' + parent[i] + '</b>';\n        r1.appendChild(k); r1.appendChild(v);\n        parentView.appendChild(r1);\n\n        const r2 = document.createElement('div'); r2.className='row';\n        const k2 = document.createElement('div'); k2.textContent = i;\n        k2.style.color = 'var(--muted)';\n        const v2 = document.createElement('div'); v2.innerHTML = '<b>' + rankArr[i] + '</b>';\n        r2.appendChild(k2); r2.appendChild(v2);\n        rankView.appendChild(r2);\n      }\n    }\n\n    // Draw edges based on parent[]\n    function updateEdges(animNew = null){\n      // Clear existing edges\n      while(edgeLayer.firstChild) edgeLayer.removeChild(edgeLayer.firstChild);\n      // For each i where parent[i] != i, draw a curved path from i -> parent[i]\n      for(let i=0;i<N;i++){\n        const p = parent[i];\n        if(p === i) continue;\n        const from = nodes[i];\n        const to = nodes[p];\n        // compute control points for gentle curve\n        const dx = to.x - from.x;\n        const dy = to.y - from.y;\n        const mx = (from.x + to.x)/2;\n        const my = (from.y + to.y)/2;\n        const nx = -dy*0.12;\n        const ny = dx*0.12;\n        const c1x = mx + nx, c1y = my + ny;\n        const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n        path.setAttribute('d', `M ${from.x} ${from.y} Q ${c1x} ${c1y} ${to.x} ${to.y}`);\n        path.classList.add('edge');\n        if(animNew && animNew.from === i && animNew.to === p) {\n          path.classList.add('new');\n        }\n        edgeLayer.appendChild(path);\n      }\n\n      // Update node positions\n      nodes.forEach(n => {\n        const g = n.grp;\n        const circle = g.querySelector('circle');\n        const label = g.querySelector('text');\n        circle.setAttribute('cx', n.x);\n        circle.setAttribute('cy', n.y);\n        label.setAttribute('x', n.x);\n        label.setAttribute('y', n.y+0.5);\n      });\n\n      // Update which nodes are roots (for visual styling)\n      nodes.forEach(n => {\n        const g = n.grp;\n        if(parent[n.id] === n.id) {\n          g.classList.add('root');\n        } else {\n          g.classList.remove('root');\n        }\n      });\n    }\n\n    // Selection UI\n    function refreshSelectionUI(){\n      // update node visuals\n      nodes.forEach(n=>{\n        if(selected.has(n.id)){\n          n.grp.classList.add('selected');\n        } else {\n          n.grp.classList.remove('selected');\n        }\n      });\n      selLabel.textContent = (selected.size === 0) ? 'None' : Array.from(selected).join(', ');\n    }\n\n    // Node click: toggle selection\n    function onNodeClick(e, node){\n      e.stopPropagation();\n      // toggle selection\n      if(selected.has(node.id)){\n        selected.delete(node.id);\n      } else {\n        // if more than 2 selected, keep only latest two (limit for union op)\n        if(selected.size >= 2){\n          // convert to array, drop first\n          const arr = Array.from(selected);\n          selected.clear();\n          arr.slice(1).forEach(x=>selected.add(x));\n        }\n        selected.add(node.id);\n      }\n      refreshSelectionUI();\n    }\n\n    // Dragging\n    function onNodeDown(e, node){\n      e.preventDefault();\n      dragging = {node: node, startX: e.clientX || (e.touches && e.touches[0].clientX), startY: e.clientY || (e.touches && e.touches[0].clientY)};\n    }\n    function onDocMove(e){\n      if(!dragging) return;\n      e.preventDefault();\n      const clientX = e.clientX || (e.touches && e.touches[0].clientX);\n      const clientY = e.clientY || (e.touches && e.touches[0].clientY);\n      if(!svgRect) svgRect = canvasWrap.getBoundingClientRect();\n      const dx = clientX - dragging.startX;\n      const dy = clientY - dragging.startY;\n      dragging.startX = clientX;\n      dragging.startY = clientY;\n      // convert screen delta to SVG coordinates (approx using viewBox scale)\n      const vb = svg.viewBox.baseVal;\n      const sx = vb.width / svgRect.width;\n      const sy = vb.height / svgRect.height;\n      dragging.node.x = clamp(dragging.node.x + dx * sx, vb.x + 40, vb.x + vb.width - 40);\n      dragging.node.y = clamp(dragging.node.y + dy * sy, vb.y + 40, vb.y + vb.height - 40);\n      updateEdges();\n    }\n    function onDocUp(e){\n      dragging = null;\n    }\n\n    // Union-Find logic with animations.\n    function findPath(x){\n      // Return array of nodes visited from x up to root (inclusive)\n      const path = [];\n      let cur = x;\n      while(true){\n        path.push(cur);\n        if(parent[cur] === cur) break;\n        cur = parent[cur];\n      }\n      return path;\n    }\n\n    function findRoot(x, animate=true){\n      const path = findPath(x);\n      const root = path[path.length-1];\n      if(animate){\n        // highlight the path nodes and edges sequentially\n        return animateFindPath(path).then(()=>{\n          if(pathCompression){\n            return animatePathCompression(path, root);\n          } else {\n            return root;\n          }\n        });\n      } else {\n        if(pathCompression){\n          // compress without animation\n          for(let v of path) parent[v] = root;\n          updateArrays();\n          updateEdges();\n        }\n        return Promise.resolve(root);\n      }\n    }\n\n    function animateFindPath(path){\n      // pulse nodes sequentially to show traversal\n      return new Promise(resolve=>{\n        let i = 0;\n        function step(){\n          if(i>0){\n            const prev = nodes[path[i-1]];\n            prev.grp.classList.remove('pulse');\n          }\n          if(i >= path.length){\n            resolve();\n            return;\n          }\n          const n = nodes[path[i]];\n          n.grp.classList.add('pulse');\n          // also momentarily highlight text color\n          setTimeout(()=> {\n            n.grp.classList.remove('pulse');\n            i++;\n            step();\n          }, 500);\n        }\n        step();\n      });\n    }\n\n    function animatePathCompression(path, root){\n      // For each node in path (except root), animate its edge removal and reattachment directly to root\n      return new Promise(async resolve=>{\n        for(let i=0;i<path.length-1;i++){\n          const v = path[i];\n          // visually show removal by fading existing edge and drawing new one\n          await animateReparent(v, root);\n          parent[v] = root; // update model\n          updateArrays();\n        }\n        updateEdges();\n        resolve(root);\n      });\n    }\n\n    function animateReparent(nodeId, newParentId){\n      return new Promise(resolve=>{\n        // Draw a temporary new edge with .new class and animate the stroke dash\n        const from = nodes[nodeId];\n        const to = nodes[newParentId];\n        const dx = to.x - from.x;\n        const dy = to.y - from.y;\n        const mx = (from.x + to.x)/2;\n        const my = (from.y + to.y)/2;\n        const nx = -dy*0.12;\n        const ny = dx*0.12;\n        const c1x = mx + nx, c1y = my + ny;\n        const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n        path.setAttribute('d', `M ${from.x} ${from.y} Q ${c1x} ${c1y} ${to.x} ${to.y}`);\n        path.classList.add('edge','new');\n        edgeLayer.appendChild(path);\n\n        // Fade the previous edge for nodeId (if exists)\n        const oldEdges = Array.from(edgeLayer.querySelectorAll('path.edge')).filter(p=>{\n          const d = p.getAttribute('d');\n          return d && d.startsWith('M ' + from.x + ' ' + from.y);\n        });\n        oldEdges.forEach(p => {\n          p.style.transition = 'opacity 300ms ease';\n          p.style.opacity = 0.12;\n        });\n\n        // After animation completes, resolve\n        setTimeout(()=> {\n          // remove temporary 'new' class (keeps edge but set normal style), remove faded edges if they pointed to old parent\n          path.classList.remove('new');\n          // fully remove faded edges that were aiming from this node (the old one)\n          oldEdges.forEach(p => {\n            try{ p.remove(); } catch(e){}\n          });\n          resolve();\n        }, 700);\n      });\n    }\n\n    // Animate a union between two nodes (their roots)\n    function unionAnimate(a,b){\n      return new Promise(async resolve=>{\n        // find roots (non-compressing)\n        const ra = findPath(a).slice(-1)[0];\n        const rb = findPath(b).slice(-1)[0];\n        // pulse both roots\n        nodes[ra].grp.classList.add('pulse');\n        nodes[rb].grp.classList.add('pulse');\n        await new Promise(r=> setTimeout(r, 520));\n        nodes[ra].grp.classList.remove('pulse');\n        nodes[rb].grp.classList.remove('pulse');\n\n        if(ra === rb){\n          // nothing to do; just highlight briefly\n          nodes[ra].grp.classList.add('pulse');\n          setTimeout(()=>{ nodes[ra].grp.classList.remove('pulse'); resolve(); }, 400);\n          return;\n        }\n\n        // decide which root becomes parent based on union-by-rank\n        let parentRoot = ra, childRoot = rb;\n        if(unionByRank){\n          if(rankArr[ra] < rankArr[rb]) { parentRoot = rb; childRoot = ra; }\n          else if(rankArr[ra] > rankArr[rb]) { parentRoot = ra; childRoot = rb; }\n          else { parentRoot = ra; childRoot = rb; rankArr[parentRoot] += 1; }\n        } else {\n          // attach b's tree under a\n          parentRoot = ra; childRoot = rb;\n        }\n\n        // animate reparent of childRoot to parentRoot\n        await animateReparent(childRoot, parentRoot);\n        parent[childRoot] = parentRoot;\n        updateArrays();\n        updateEdges({from:childRoot, to:parentRoot});\n        // small settle delay\n        setTimeout(()=> resolve(), 240);\n      });\n    }\n\n    // UI actions\n    unionBtn.addEventListener('click', ()=> {\n      if(selected.size < 2) {\n        alert('Select two nodes to union.');\n        return;\n      }\n      const [a,b] = Array.from(selected);\n      // disable interactions by chaining animations\n      animQueue = animQueue.then(()=> unionAnimate(a,b));\n      animQueue.then(()=> {\n        // update UI after animation\n        updateArrays();\n        updateEdges();\n      });\n      selected.clear();\n      refreshSelectionUI();\n    });\n\n    findBtn.addEventListener('click', ()=> {\n      if(selected.size === 0){\n        alert('Select a node to run find() on.');\n        return;\n      }\n      const [x] = Array.from(selected);\n      // perform find with animation and optional path compression\n      animQueue = animQueue.then(()=> findRoot(x, true));\n      animQueue.then(()=> {\n        updateArrays();\n        updateEdges();\n      });\n      // keep selection of the node for clarity\n    });\n\n    // Random unions\n    randomBtn.addEventListener('click', ()=> {\n      const steps = Math.max(1, Math.floor(N/2));\n      // perform random unions sequentially\n      let promise = animQueue;\n      for(let i=0;i<steps;i++){\n        const a = randInt(0,N-1), b = randInt(0,N-1);\n        if(a===b) continue;\n        promise = promise.then(()=> unionAnimate(a,b)).then(()=> {\n          updateArrays();\n          updateEdges();\n        });\n      }\n      animQueue = promise;\n    });\n\n    // Reset and rebuild\n    resetBtn.addEventListener('click', ()=> {\n      build(N);\n    });\n    rebuildBtn.addEventListener('click', ()=> {\n      const v = parseInt(nodeCountInput.value,10) || 8;\n      build(v);\n    });\n\n    // Initial build\n    build(N);\n\n    // Accessibility: clicking canvas clears selection\n    canvasWrap.addEventListener('click', (e)=> {\n      if(e.target === canvasWrap || e.target.nodeName === 'svg') {\n        selected.clear();\n        refreshSelectionUI();\n      }\n    });\n\n    // Make sure arrays update whenever parent/rank change by any action\n    // (we call updateArrays explicitly where needed)\n\n    // Expose a console-friendly API (for debugging)\n    window.__UF = {\n      parents: ()=> parent.slice(),\n      ranks: ()=> rankArr.slice(),\n      nodes,\n      rebuild: ()=> build(N),\n    };\n  </script>\n\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Union-Find (Disjoint Set).\n\n**Project Overview:**\nTopic: Union-Find (Disjoint Set)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Union-Find (Disjoint Set)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Union-Find Interactive Module",
      "description": "Models the interactive states and transitions of a Union-Find visualizer (node selection, dragging, union/find animations, toggles, rebuild/reset and UI feedback).",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "NODE_CLICK": "oneSelected",
            "NODE_DOWN": "dragging",
            "UNION_CLICK": "idle",
            "FIND_CLICK": "idle",
            "RANDOM_CLICK": "animating",
            "RESET_CLICK": "building",
            "REBUILD_CLICK": "building",
            "TOGGLE_RANK": "idle",
            "TOGGLE_PC": "idle",
            "CANVAS_CLICK_CLEAR": "idle",
            "ANIMATION_START": "animating"
          }
        },
        {
          "name": "oneSelected",
          "onEnter": "selectNode",
          "onExit": "refreshSelectionUI",
          "on": {
            "NODE_CLICK": "twoSelected",
            "NODE_CLICK_SAME": "idle",
            "NODE_DOWN": "dragging",
            "UNION_CLICK": "oneSelected",
            "FIND_CLICK": "animating",
            "RANDOM_CLICK": "animating",
            "RESET_CLICK": "building",
            "REBUILD_CLICK": "building",
            "TOGGLE_RANK": "oneSelected",
            "TOGGLE_PC": "oneSelected",
            "CANVAS_CLICK_CLEAR": "idle",
            "ANIMATION_START": "animating"
          }
        },
        {
          "name": "twoSelected",
          "onEnter": "selectSecondNode",
          "onExit": "clearSelectionIfNeeded",
          "on": {
            "NODE_CLICK": "twoSelected",
            "NODE_CLICK_DESELECT": "oneSelected",
            "NODE_DOWN": "dragging",
            "UNION_CLICK": "animating",
            "FIND_CLICK": "animating",
            "RANDOM_CLICK": "animating",
            "RESET_CLICK": "building",
            "REBUILD_CLICK": "building",
            "TOGGLE_RANK": "twoSelected",
            "TOGGLE_PC": "twoSelected",
            "CANVAS_CLICK_CLEAR": "idle",
            "ANIMATION_START": "animating"
          }
        },
        {
          "name": "dragging",
          "onEnter": "startDrag",
          "onExit": "stopDrag",
          "on": {
            "NODE_MOVE": "dragging",
            "NODE_UP": "idle",
            "RESET_CLICK": "building",
            "REBUILD_CLICK": "building",
            "ANIMATION_START": "animating",
            "CANVAS_CLICK_CLEAR": "idle",
            "NODE_CLICK": "dragging"
          }
        },
        {
          "name": "animating",
          "onEnter": "enqueueAndRunAnimation",
          "onExit": "updateArraysAndEdges",
          "on": {
            "ANIMATION_END": "idle",
            "NODE_CLICK": "animating",
            "NODE_DOWN": "dragging",
            "UNION_CLICK": "animating",
            "FIND_CLICK": "animating",
            "RANDOM_CLICK": "animating",
            "RESET_CLICK": "building",
            "REBUILD_CLICK": "building",
            "TOGGLE_RANK": "animating",
            "TOGGLE_PC": "animating",
            "CANVAS_CLICK_CLEAR": "animating"
          }
        },
        {
          "name": "building",
          "onEnter": "build",
          "onExit": "noop",
          "on": {
            "BUILD_COMPLETE": "idle",
            "ANIMATION_START": "animating"
          }
        }
      ],
      "events": [
        "NODE_CLICK",
        "NODE_CLICK_SAME",
        "NODE_CLICK_DESELECT",
        "NODE_DOWN",
        "NODE_MOVE",
        "NODE_UP",
        "UNION_CLICK",
        "FIND_CLICK",
        "RANDOM_CLICK",
        "RESET_CLICK",
        "REBUILD_CLICK",
        "TOGGLE_RANK",
        "TOGGLE_PC",
        "CANVAS_CLICK_CLEAR",
        "ANIMATION_START",
        "ANIMATION_END",
        "BUILD_COMPLETE"
      ],
      "notes": "Selection is toggled by node clicks and limited to two selections for union. Dragging updates node positions and edge geometry. Animations (find traversal, path compression, union reparenting, random unions) are sequenced using an animation queue (animQueue). UI toggles change behavior (union-by-rank, path compression). Rebuild/reset triggers a full build that reinitializes parent/rank and visuals. Alerts (invalid union/find) are shown when user actions are not possible; these are modeled as events that keep the FSM in the current state while invoking a showAlert action."
    }
  },
  {
    "id": "fbbebf20-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:48:33.298Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Binary Search",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Binary Search — Interactive Module</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --accent: #3b82f6;\n      --muted: #94a3b8;\n      --ok: #16a34a;\n      --bad: #ef4444;\n      --glass: rgba(255,255,255,0.03);\n      --duration: 450ms;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\",\n                   Roboto, \"Helvetica Neue\", Arial;\n    }\n\n    /* Safe area */\n    html,body{height:100%;}\n    body{\n      margin:0;\n      padding:var(--safe-margin);\n      background:linear-gradient(180deg,#071022 0%, #071322 60%);\n      color:#e6eef8;\n      box-sizing:border-box;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      display:flex;\n      justify-content:center;\n      align-items:flex-start;\n    }\n\n    /* Container */\n    .module{\n      width:100%;\n      max-width:1100px;\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n    }\n\n    /* Left: Visual board */\n    .board{\n      flex:1 1 620px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      border-radius:12px;\n      padding:20px;\n      box-shadow:0 6px 30px rgba(2,6,23,0.6);\n      min-width:300px;\n    }\n    .header{\n      display:flex;\n      align-items:center;\n      justify-content:space-between;\n      gap:var(--gap);\n    }\n    h1{\n      font-size:20px;\n      margin:0;\n      letter-spacing:0.2px;\n    }\n    p.lead{\n      margin:8px 0 0 0;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* Control and info area to the right */\n    .side{\n      width:360px;\n      min-width:280px;\n      background:var(--card);\n      border-radius:12px;\n      padding:18px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      box-shadow:0 6px 20px rgba(2,6,23,0.5);\n    }\n\n    /* Array visualization */\n    .array-wrap{\n      margin-top:18px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      align-items:center;\n    }\n    .array-line{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      overflow:auto;\n      padding:12px;\n      width:100%;\n    }\n\n    .cell{\n      min-width:56px;\n      height:56px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      background:var(--glass);\n      border-radius:10px;\n      border:1px solid rgba(255,255,255,0.04);\n      color:var(--muted);\n      font-weight:600;\n      font-size:16px;\n      position:relative;\n      transition:transform var(--duration) ease, background-color var(--duration), opacity var(--duration), color var(--duration);\n      cursor:pointer;\n      flex:0 0 56px;\n      user-select:none;\n    }\n    .cell:focus{outline:2px solid rgba(59,130,246,0.25);}\n\n    .cell.selected{\n      background:linear-gradient(180deg, rgba(59,130,246,0.18), rgba(59,130,246,0.08));\n      color:var(--accent);\n      transform:scale(1.05);\n      box-shadow:0 6px 20px rgba(59,130,246,0.08);\n    }\n    .cell.mid{\n      background: linear-gradient(180deg, rgba(99,102,241,0.14), rgba(99,102,241,0.06));\n      color:#c7d8ff;\n      transform:scale(1.08);\n      box-shadow:0 10px 30px rgba(99,102,241,0.06);\n      animation:midPulse 1s infinite ease-in-out;\n    }\n    @keyframes midPulse{\n      0%{ box-shadow:0 6px 18px rgba(99,102,241,0.05); transform:scale(1.06);}\n      50%{ box-shadow:0 16px 36px rgba(99,102,241,0.09); transform:scale(1.08);}\n      100%{ box-shadow:0 6px 18px rgba(99,102,241,0.05); transform:scale(1.06);}\n    }\n\n    .cell.eliminated{\n      opacity:0.28;\n      transform:scale(0.98);\n      color:rgba(255,255,255,0.45);\n      background:transparent;\n      cursor:default;\n    }\n\n    /* Pointers above array */\n    .pointer-row{\n      height:36px;\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content:flex-start;\n      width:100%;\n      padding-left:2px;\n    }\n    .pointer{\n      position:relative;\n      min-width:56px;\n      height:36px;\n      display:flex;\n      align-items:flex-end;\n      justify-content:center;\n      transform-origin:center;\n      transition:transform var(--duration) ease, opacity var(--duration) ease;\n    }\n    .pointer .label{\n      background:rgba(255,255,255,0.03);\n      font-size:12px;\n      color:var(--muted);\n      padding:4px 8px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .arrow{\n      width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:10px solid var(--muted);\n      margin-top:4px;\n      opacity:0.9;\n    }\n    .pointer.faded{opacity:0.28;}\n    .pointer.found .label{background:rgba(22,163,74,0.12); color:var(--ok); border-color:rgba(22,163,74,0.1);}\n    .pointer.found .arrow{border-top-color:var(--ok);}\n\n    /* Controls */\n    .controls{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .row{display:flex;gap:12px;align-items:center;}\n    .btn{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      color:var(--muted);\n      padding:10px 12px;\n      border-radius:10px;\n      cursor:pointer;\n      font-weight:600;\n      min-height:40px;\n      flex:0 0 auto;\n      transition:transform 160ms ease, background-color 160ms;\n    }\n    .btn:active{transform:translateY(1px);}\n    .btn.primary{\n      background:linear-gradient(180deg,#1e3a8a22,#1e40af11);\n      color:var(--accent);\n      border-color:rgba(59,130,246,0.12);\n      box-shadow:0 6px 14px rgba(59,130,246,0.04);\n    }\n    .btn.ghost{\n      background:transparent;\n      border:1px dashed rgba(255,255,255,0.03);\n      color:var(--muted);\n    }\n    input[type=\"number\"], input[type=\"range\"]{\n      appearance:none;\n      -webkit-appearance:none;\n      background:transparent;\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.03);\n      padding:10px 12px;\n      border-radius:10px;\n      min-height:40px;\n      font-weight:600;\n    }\n    input[type=\"number\"]::-webkit-inner-spin-button{opacity:0.4;}\n\n    .small{font-size:13px;color:var(--muted);}\n\n    .status{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content:space-between;\n      padding:12px;\n      border-radius:10px;\n      background:rgba(255,255,255,0.02);\n      border:1px solid rgba(255,255,255,0.02);\n      font-size:13px;\n    }\n\n    /* Pseudocode */\n    .pseudocode{\n      background:rgba(255,255,255,0.02);\n      padding:12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.02);\n      color:var(--muted);\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;\n      font-size:13px;\n    }\n    .pseudocode .line{\n      padding:6px 8px;\n      border-radius:6px;\n      display:block;\n      transition:background-color 220ms ease, color 220ms;\n    }\n    .pseudocode .line.active{\n      background:linear-gradient(90deg, rgba(59,130,246,0.14), rgba(99,102,241,0.06));\n      color:#cfe1ff;\n      border-left:3px solid rgba(59,130,246,0.18);\n    }\n\n    /* Narration / explanation */\n    .narration{\n      background:transparent;\n      color:var(--muted);\n      font-size:13px;\n      min-height:48px;\n      padding:8px;\n    }\n\n    /* Footer small */\n    .meta{font-size:12px;color:var(--muted);}\n\n    /* Responsive stacking */\n    @media (max-width:980px){\n      .module{flex-direction:column;padding-bottom:40px;}\n      .side{width:100%;}\n    }\n    /* Ensure minimum spacing between interactive elements (16px) where applicable */\n    .controls > * { margin:0; }\n  </style>\n</head>\n<body>\n  <main class=\"module\" id=\"module\">\n    <!-- Left: Visual + description -->\n    <section class=\"board\" aria-labelledby=\"title\">\n      <div class=\"header\">\n        <div>\n          <h1 id=\"title\">Binary Search — Visual Explorer</h1>\n          <p class=\"lead\">Click a value to set the search target (or type a number on the right). Step through how binary search narrows the array.</p>\n        </div>\n        <div class=\"meta\">Interactive module — vanilla HTML/CSS/JS</div>\n      </div>\n\n      <!-- Concept & Learning Objective & Interaction Design & Layout Description -->\n      <div style=\"margin-top:16px;display:flex;flex-direction:column;gap:12px\">\n        <div style=\"background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);\">\n          <strong>Concept Title:</strong> Binary Search (on sorted arrays)\n          <div style=\"margin-top:6px;color:var(--muted);font-size:13px\">\n            <strong>Learning Objective:</strong> After interacting, you will be able to explain how binary search halves a sorted array each comparison, identify mid/low/high pointers, and count comparisons and steps needed to find (or not find) a target.\n          </div>\n        </div>\n\n        <div style=\"background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);color:var(--muted);font-size:13px\">\n          <strong>Interaction Design:</strong>\n          <ul style=\"margin:8px 0 0 18px\">\n            <li>Click any cell to select the target number, or type a number and press \"Set target\".</li>\n            <li>Use Next / Prev to step through the algorithm. \"Auto\" runs the steps with animation; speed is adjustable.</li>\n            <li>Visual feedback: the mid cell pulses; eliminated segments fade out; L/R pointers move and highlight. Pseudocode lines are highlighted in sync with the current step and a short narration explains the decision.</li>\n            <li>Accessible controls: keyboard arrows for step navigation, Space to play/pause.</li>\n          </ul>\n        </div>\n\n        <div style=\"background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);color:var(--muted);font-size:13px\">\n          <strong>Layout Description:</strong> The left panel shows the array visualization and brief module header. The right panel contains controls, target input, playback, pseudocode, and narration. Safe-area margins are 24px; minimum spacing between controls is 16px. The layout is responsive: panels sit side-by-side on wide screens and stack on narrow screens. Visual focus is enforced by clear color contrast and motion for the active elements.\n        </div>\n      </div>\n\n      <!-- Visualizer: pointers and array -->\n      <div class=\"array-wrap\" aria-hidden=\"false\" style=\"margin-top:18px\">\n        <div class=\"pointer-row\" id=\"pointerRow\" aria-hidden=\"true\"></div>\n        <div class=\"array-line\" id=\"arrayLine\" role=\"list\" aria-label=\"Sorted array elements\"></div>\n      </div>\n    </section>\n\n    <!-- Right: Controls, pseudocode, narration -->\n    <aside class=\"side\" aria-label=\"Controls and explanation\">\n      <div class=\"controls\">\n        <div style=\"display:flex;gap:12px;align-items:center;\">\n          <label class=\"small\" for=\"sizeRange\">Array size</label>\n          <input id=\"sizeRange\" type=\"range\" min=\"5\" max=\"21\" value=\"11\" aria-label=\"Array size slider\" />\n          <button class=\"btn ghost\" id=\"regenBtn\" aria-label=\"Regenerate array\">Regenerate</button>\n        </div>\n\n        <div style=\"display:flex;gap:12px;align-items:center;\">\n          <input id=\"targetInput\" type=\"number\" placeholder=\"Type target value\" aria-label=\"Target value input\" />\n          <button class=\"btn primary\" id=\"setTargetBtn\" aria-label=\"Set target by number\">Set target</button>\n          <button class=\"btn\" id=\"clearTargetBtn\" aria-label=\"Clear target\">Clear</button>\n        </div>\n\n        <div style=\"display:flex;gap:12px;align-items:center;justify-content:space-between;\">\n          <div style=\"display:flex;gap:8px;\">\n            <button class=\"btn\" id=\"prevBtn\" aria-label=\"Previous step\">◀ Prev</button>\n            <button class=\"btn primary\" id=\"nextBtn\" aria-label=\"Next step\">Next ▶</button>\n            <button class=\"btn\" id=\"playBtn\" aria-label=\"Auto play\">Auto ▶</button>\n            <button class=\"btn ghost\" id=\"resetBtn\" aria-label=\"Reset\">Reset</button>\n          </div>\n        </div>\n\n        <div style=\"display:flex;gap:12px;align-items:center;\">\n          <label class=\"small\" for=\"speedRange\">Speed</label>\n          <input id=\"speedRange\" type=\"range\" min=\"200\" max=\"1600\" value=\"800\" />\n          <div class=\"small\" id=\"comparisons\">Comparisons: 0</div>\n        </div>\n\n        <div class=\"status\" aria-live=\"polite\">\n          <div><strong>State:</strong> <span id=\"stateLabel\">idle</span></div>\n          <div><strong>Step:</strong> <span id=\"stepLabel\">0</span></div>\n        </div>\n\n        <div class=\"pseudocode\" aria-hidden=\"false\" id=\"pseudocode\">\n          <div class=\"line\" data-line=\"1\">function binarySearch(arr, target):</div>\n          <div class=\"line\" data-line=\"2\" style=\"margin-left:12px\">low = 0</div>\n          <div class=\"line\" data-line=\"3\" style=\"margin-left:12px\">high = arr.length - 1</div>\n          <div class=\"line\" data-line=\"4\" style=\"margin-left:12px\">while low <= high:</div>\n          <div class=\"line\" data-line=\"5\" style=\"margin-left:24px\">mid = floor((low + high) / 2)</div>\n          <div class=\"line\" data-line=\"6\" style=\"margin-left:24px\">if arr[mid] == target: return mid</div>\n          <div class=\"line\" data-line=\"7\" style=\"margin-left:24px\">else if arr[mid] < target: low = mid + 1</div>\n          <div class=\"line\" data-line=\"8\" style=\"margin-left:24px\">else: high = mid - 1</div>\n          <div class=\"line\" data-line=\"9\" style=\"margin-left:12px\">return -1  # not found</div>\n        </div>\n\n        <div class=\"narration\" id=\"narration\" aria-live=\"polite\">Select a target to begin.</div>\n\n      </div>\n    </aside>\n  </main>\n\n  <script>\n    // ===== Binary Search Visual Module (vanilla JS) =====\n    (function(){\n      // Elements\n      const arrayLine = document.getElementById('arrayLine');\n      const pointerRow = document.getElementById('pointerRow');\n      const sizeRange = document.getElementById('sizeRange');\n      const regenBtn = document.getElementById('regenBtn');\n      const targetInput = document.getElementById('targetInput');\n      const setTargetBtn = document.getElementById('setTargetBtn');\n      const clearTargetBtn = document.getElementById('clearTargetBtn');\n      const prevBtn = document.getElementById('prevBtn');\n      const nextBtn = document.getElementById('nextBtn');\n      const playBtn = document.getElementById('playBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const speedRange = document.getElementById('speedRange');\n\n      const comparisonsLabel = document.getElementById('comparisons');\n      const stateLabel = document.getElementById('stateLabel');\n      const stepLabel = document.getElementById('stepLabel');\n      const pseudocode = document.getElementById('pseudocode');\n      const narration = document.getElementById('narration');\n\n      // State\n      let arr = [];\n      let size = parseInt(sizeRange.value,10) || 11;\n      let target = null;\n      let low = 0, high = -1, mid = -1;\n      let history = []; // records snapshots for stepping\n      let stepIndex = -1;\n      let playing = false;\n      let playTimer = null;\n      let comparisons = 0;\n\n      // Generate a sorted array (increasing but not necessarily consecutive)\n      function generateArray(n){\n        const out = [];\n        let cur = Math.max(1, Math.floor(Math.random()*3));\n        for(let i=0;i<n;i++){\n          cur += Math.floor(Math.random()*5) + 1;\n          out.push(cur);\n        }\n        return out;\n      }\n\n      // Render array elements and attach click behavior\n      function renderArray(){\n        arrayLine.innerHTML = '';\n        pointerRow.innerHTML = '';\n        arr.forEach((val, idx) => {\n          const cell = document.createElement('div');\n          cell.className = 'cell';\n          cell.setAttribute('role','button');\n          cell.setAttribute('tabindex','0');\n          cell.setAttribute('aria-label', 'Value ' + val + ' at index ' + idx);\n          cell.textContent = val;\n          cell.dataset.index = idx;\n          cell.addEventListener('click', () => setTargetByIndex(idx));\n          cell.addEventListener('keydown', (e) => {\n            if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); setTargetByIndex(idx); }\n          });\n          arrayLine.appendChild(cell);\n\n          // pointer placeholders (same number)\n          const p = document.createElement('div');\n          p.className = 'pointer faded';\n          p.innerHTML = '<div class=\"label\"></div>';\n          p.style.width = cell.style.width;\n          pointerRow.appendChild(p);\n        });\n        syncVisualState();\n      }\n\n      // Sync UI elements to current search state\n      function syncVisualState(){\n        const cells = Array.from(arrayLine.children);\n        const pointers = Array.from(pointerRow.children);\n\n        cells.forEach((cell, i) => {\n          cell.classList.remove('mid','selected','eliminated');\n          cell.style.transitionDelay = '0ms';\n          // default: interactive\n          if (target !== null && arr[i] === target) {\n            // if target set but not found yet, mark selected as target\n            cell.classList.add('selected');\n          }\n        });\n\n        // mark eliminated (outside [low,high])\n        cells.forEach((cell, i) => {\n          if (low !== null && high !== null && (i < low || i > high)) {\n            cell.classList.add('eliminated');\n          }\n        });\n\n        // highlight mid if defined and within bounds\n        if (mid !== null && mid >= 0 && mid < arr.length) {\n          const mc = cells[mid];\n          if(mc) mc.classList.add('mid');\n        }\n\n        // pointers: map labels L and R above their positions (faded if out)\n        pointers.forEach((p, i) => {\n          p.innerHTML = '';\n          p.classList.remove('faded','found');\n          const labelDiv = document.createElement('div');\n          labelDiv.className='label';\n          p.appendChild(labelDiv);\n          const arrow = document.createElement('div');\n          arrow.className='arrow';\n          p.appendChild(arrow);\n          if (i === low && low <= high) {\n            labelDiv.textContent = 'L';\n            p.classList.remove('faded');\n          } else if (i === high && low <= high) {\n            labelDiv.textContent = 'R';\n            p.classList.remove('faded');\n          } else if (i === mid && mid >= 0 && mid < arr.length) {\n            labelDiv.textContent = 'mid';\n            p.classList.remove('faded');\n          } else {\n            p.classList.add('faded');\n          }\n\n          // Found pointer: if mid is found\n          if (mid>=0 && mid<arr.length && arr[mid] === target) {\n            if(i === mid) p.classList.add('found');\n          }\n        });\n\n        // update labels & counters\n        comparisonsLabel.textContent = 'Comparisons: ' + comparisons;\n        stepLabel.textContent = Math.max(0, stepIndex+1);\n      }\n\n      // Save a snapshot for history (for stepping backward)\n      function snapshot(note=''){\n        history = history.slice(0, stepIndex+1);\n        history.push({\n          arr: arr.slice(),\n          target,\n          low, high, mid,\n          comparisons,\n          note\n        });\n        stepIndex = history.length - 1;\n      }\n\n      // Initialize or reset search variables\n      function initSearch(resetComparisons=true){\n        low = 0;\n        high = arr.length - 1;\n        mid = Math.floor((low + high)/2);\n        if(resetComparisons) comparisons = 0;\n        history = [];\n        stepIndex = -1;\n        snapshot('start');\n        stateLabel.textContent = 'idle';\n        syncPseudocode(null);\n        narration.textContent = 'Ready. Select a target (click cell or use the input).';\n        syncVisualState();\n      }\n\n      // Set target by clicking an index\n      function setTargetByIndex(idx){\n        target = arr[idx];\n        targetInput.value = target;\n        narration.textContent = 'Target set to ' + target + '. Use Next to step or Auto to run.';\n        initSearch();\n      }\n\n      // Set target by input value\n      function setTargetByInput(){\n        const v = Number(targetInput.value);\n        if(Number.isNaN(v)) {\n          narration.textContent = 'Please enter a valid number.';\n          return;\n        }\n        target = v;\n        narration.textContent = 'Target set to ' + target + '.';\n        initSearch();\n      }\n\n      // Clear target\n      function clearTarget(){\n        target = null;\n        targetInput.value = '';\n        initSearch();\n        narration.textContent = 'Target cleared.';\n      }\n\n      // Perform one binary search step (returns outcome string)\n      function doStep(){\n        if(target === null){\n          narration.textContent = 'No target selected. Choose one to begin.';\n          return;\n        }\n        if(low > high){\n          snapshot('not found');\n          syncVisualState();\n          narration.textContent = 'Search ended: target not found (low > high).';\n          stateLabel.textContent = 'finished';\n          syncPseudocode(9);\n          return;\n        }\n\n        mid = Math.floor((low + high)/2);\n        comparisons++;\n        snapshot('compare mid');\n        syncVisualState();\n        syncPseudocode(5);\n        // small delay to allow mid pulsing then evaluate\n        return new Promise(resolve => {\n          setTimeout(() => {\n            if(arr[mid] === target){\n              snapshot('found');\n              syncPseudocode(6);\n              syncVisualState();\n              narration.textContent = 'Found target at index ' + mid + ' after ' + comparisons + ' comparisons.';\n              stateLabel.textContent = 'found';\n              resolve('found');\n            } else if (arr[mid] < target){\n              snapshot('mid < target -> shift low');\n              syncPseudocode(7);\n              narration.textContent = 'arr[mid] ('+arr[mid]+') < target ('+target+') → move L to mid+1.';\n              low = mid + 1;\n              mid = Math.floor((low + high)/2);\n              syncVisualState();\n              stateLabel.textContent = 'searching';\n              resolve('low');\n            } else {\n              snapshot('mid > target -> shift high');\n              syncPseudocode(8);\n              narration.textContent = 'arr[mid] ('+arr[mid]+') > target ('+target+') → move R to mid-1.';\n              high = mid - 1;\n              mid = Math.floor((low + high)/2);\n              syncVisualState();\n              stateLabel.textContent = 'searching';\n              resolve('high');\n            }\n          }, 420);\n        });\n      }\n\n      // Step backward to previous snapshot\n      function stepBack(){\n        if(stepIndex <= 0) {\n          narration.textContent = 'At start. Nothing before this step.';\n          return;\n        }\n        stepIndex--;\n        restoreSnapshot(history[stepIndex]);\n        narration.textContent = 'Step ' + (stepIndex+1) + ' (rewound).';\n      }\n\n      // Restore snapshot to UI\n      function restoreSnapshot(snap){\n        arr = snap.arr.slice();\n        target = snap.target;\n        low = snap.low;\n        high = snap.high;\n        mid = snap.mid;\n        comparisons = snap.comparisons;\n        syncVisualState();\n        syncPseudocodeForSnapshot(snap);\n        stateLabel.textContent = (low>high)?'finished':'idle';\n        stepLabel.textContent = Math.max(0, stepIndex+1);\n      }\n\n      // Play auto steps\n      function togglePlay(){\n        if(playing){\n          stopPlay();\n        } else {\n          startPlay();\n        }\n      }\n      function startPlay(){\n        if(!target){\n          narration.textContent = 'Set a target first.';\n          return;\n        }\n        playing = true;\n        playBtn.textContent = 'Pause ⏸';\n        stateLabel.textContent = 'playing';\n        playLoop();\n      }\n      function stopPlay(){\n        playing = false;\n        playBtn.textContent = 'Auto ▶';\n        stateLabel.textContent = 'idle';\n        if(playTimer) { clearTimeout(playTimer); playTimer = null; }\n      }\n\n      function playLoop(){\n        if(!playing) return;\n        // if finished, stop\n        if(low > high){\n          narration.textContent = 'Target not found. Auto stopped.';\n          stopPlay();\n          return;\n        }\n        // if last snapshot was found, stop\n        if(mid>=0 && arr[mid]===target){\n          narration.textContent = 'Target found. Auto stopped.';\n          stopPlay();\n          return;\n        }\n        doStep().then(() => {\n          // schedule next\n          if(playing){\n            playTimer = setTimeout(playLoop, Number(speedRange.value) || 800);\n          }\n        });\n      }\n\n      // Reset to beginning (but keep target)\n      function resetToStart(){\n        if(history.length === 0) {\n          initSearch();\n          return;\n        }\n        stepIndex = 0;\n        restoreSnapshot(history[0]);\n        narration.textContent = 'Reset to start.';\n      }\n\n      // Regenerate array\n      function regenerate(){\n        size = Math.max(5, Math.min(21, Number(sizeRange.value)));\n        arr = generateArray(size);\n        target = null;\n        targetInput.value = '';\n        initSearch(true);\n        renderArray();\n      }\n\n      // Update pseudocode highlight\n      function syncPseudocode(line){\n        const lines = pseudocode.querySelectorAll('.line');\n        lines.forEach(l => l.classList.remove('active'));\n        if(line){\n          const selected = pseudocode.querySelector('.line[data-line=\"'+line+'\"]');\n          if(selected) selected.classList.add('active');\n        }\n      }\n\n      // Sync based on snapshot's note (for stepping)\n      function syncPseudocodeForSnapshot(snap){\n        if(!snap) { syncPseudocode(null); return; }\n        // Simple mapping: use note to highlight approximate line\n        if(snap.note === 'start') syncPseudocode(2);\n        else if(snap.note === 'compare mid') syncPseudocode(5);\n        else if(snap.note === 'found') syncPseudocode(6);\n        else if(snap.note.indexOf('mid < target')>=0) syncPseudocode(7);\n        else if(snap.note.indexOf('mid > target')>=0) syncPseudocode(8);\n        else if(snap.note === 'not found') syncPseudocode(9);\n        else syncPseudocode(null);\n      }\n\n      // Event bindings\n      nextBtn.addEventListener('click', () => {\n        stopPlay();\n        doStep();\n      });\n      prevBtn.addEventListener('click', () => {\n        stopPlay();\n        stepBack();\n      });\n      playBtn.addEventListener('click', togglePlay);\n      resetBtn.addEventListener('click', () => {\n        stopPlay();\n        resetToStart();\n      });\n      regenBtn.addEventListener('click', () => {\n        stopPlay();\n        regenerate();\n      });\n      setTargetBtn.addEventListener('click', () => {\n        stopPlay();\n        setTargetByInput();\n      });\n      clearTargetBtn.addEventListener('click', () => {\n        stopPlay();\n        clearTarget();\n      });\n      sizeRange.addEventListener('input', () => {\n        // visual update of size but do not auto regenerate until button or change end\n      });\n      // regenerate on release for friendliness\n      sizeRange.addEventListener('change', () => {\n        stopPlay();\n        regenerate();\n      });\n\n      // Keyboard shortcuts\n      window.addEventListener('keydown', (e) => {\n        if(e.key === 'ArrowRight') { e.preventDefault(); stopPlay(); doStep(); }\n        if(e.key === 'ArrowLeft') { e.preventDefault(); stopPlay(); stepBack(); }\n        if(e.key === ' ') { e.preventDefault(); togglePlay(); }\n      });\n\n      // Initial bootstrap\n      arr = generateArray(size);\n      renderArray();\n      initSearch();\n\n      // Helper: restore initial when window resized to keep pointer alignment (not required but helps)\n      window.addEventListener('resize', () => { syncVisualState(); });\n\n      // Accessibility tip: focusing elements\n      document.querySelectorAll('.cell').forEach(c => c.setAttribute('tabindex','0'));\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Binary Search.\n\n**Project Overview:**\nTopic: Binary Search\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Binary Search"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "fd567620-bdce-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:48:35.970Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Breadth-First Search (BFS)",
    "answer": {
      "role": "assistant",
      "content": "Concept Title:\nBreadth-First Search (BFS) — Visual, step-by-step exploration of BFS on an interactive graph\n\nLearning Objective:\nAfter interacting with this module the user will be able to:\n- Explain how BFS explores a graph level-by-level.\n- See how the queue (frontier) evolves over time and how nodes become \"visited\".\n- Observe distances (levels) from a chosen start node.\n- Practice stepping through and playing the BFS algorithm to build intuition about ordering and traversal.\n\nInteraction Design:\n- Modes & Basic Interaction:\n  - Add nodes: Click on the drawing area to create a node at that position. Nodes are labeled automatically (A, B, C...).\n  - Add edges: Toggle \"Add Edge\" mode, then click a source node and then a target node to create an (undirected) edge between them. Each click pair creates one edge; clicking the same node twice cancels selection.\n  - Drag nodes: Click+drag any node to reposition it. Edges follow automatically.\n  - Remove: Select a node (click) and press Delete to remove it and its edges.\n  - Random graph: Use \"Random Graph\" to generate a small test graph quickly.\n- BFS Controls:\n  - Start-Node selector updates live when nodes are added/removed.\n  - \"Run BFS\" builds an animatable script of state changes for BFS from the selected start node.\n  - Playback controls: Play/Pause, Step Forward, Reset, and a Speed slider for animation rate.\n- Visual feedback & animation:\n  - Node states animate color changes:\n    - Unvisited: neutral (gray)\n    - In queue (frontier): yellow with a subtle pulsing animation while queued\n    - Current (dequeued and being expanded): blue with a light glow\n    - Visited (finalized): green\n  - Edges being traversed briefly highlight (orange) when BFS considers them.\n  - Queue visualization: a horizontal, animated list shows the queue contents in order. Enqueue/dequeue operations animate (fade/slide).\n  - Visited list: shows nodes as they are finalized, along with computed distances.\n  - Step-by-step animation: each BFS action (enqueue neighbor, dequeue node, visit node) corresponds to a discrete animation frame so users can step or play continuously.\n- Reinforcement:\n  - Seeing queue operations animated alongside node/edge highlighting reinforces how BFS expands nodes in FIFO order and how distances are assigned.\n  - Step control allows users to hypothesize then check by stepping forward.\n\nLayout Description:\n- Safe margins: The entire content sits in a container with 24px padding from the viewport edges.\n- Overall layout: A two-column responsive layout.\n  - Left column (controls and explanation): fixed-min width ~320px on wide screens, collapses to top area on narrow screens. Contains:\n    - Title and concise instructions / Learning Objective.\n    - Mode toggles and graph tools (Add Edge, Random Graph, Clear).\n    - BFS controls (start selector, Run, Play/Pause, Step, Reset, Speed).\n    - Live status panes (Queue, Visited list, Current action text).\n  - Right column (visualization area): flexible, occupies remaining space and holds the interactive SVG graph canvas centered within the safe area.\n- Spacing:\n  - Minimum spacing of 16px between interactive elements is enforced via consistent gap values in control groups.\n  - Buttons/controls are grouped with clear headings and enough whitespace for focus.\n- Accessibility & Responsiveness:\n  - Controls have aria-labels; buttons and the canvas are keyboard accessible (e.g., Step via Space/Enter when focused on the \"Step\" button).\n  - SVG nodes have title elements to show labels on hover.\n  - Layout stacks vertically on small screens to maintain clarity.\n- Visual balance: The left column contains concise instructional text and controls; the right column is reserved for the animated visualization so attention is focused on the graph.\n\nImplementation:\nBelow is a self-contained HTML file (vanilla HTML/CSS/JavaScript). Paste into a .html file and open in a browser. The code respects the safe margins and spacing, provides drag-and-drop, edge creation, BFS animations, and step controls.\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Breadth-First Search (BFS) Interactive</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --control-width: 340px;\n      --bg: #0f1724;\n      --panel: #071028;\n      --accent: #06b6d4;\n      --muted: #9aa5b1;\n      --node-size: 36px;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071028 0%, #08172a 60%);\n      color:#e6eef6;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .wrap{\n      padding: var(--safe-margin);\n      box-sizing:border-box;\n      min-height:100%;\n      display:flex;\n      gap: var(--gap);\n    }\n    /* Responsive columns: left controls, right canvas */\n    .left {\n      width: var(--control-width);\n      min-width: 280px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:16px;\n      box-shadow: 0 6px 18px rgba(0,0,0,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:16px;\n      align-self:stretch;\n    }\n    .title {\n      margin:0;\n      font-size:18px;\n      font-weight:600;\n      color: #e7f8ff;\n    }\n    .subtitle{\n      margin:0;\n      font-size:13px;\n      color: var(--muted);\n    }\n    .controls {\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .row {\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    button, select, input[type=\"range\"]{\n      background:rgba(255,255,255,0.03);\n      border:1px solid rgba(255,255,255,0.04);\n      color:var(--muted);\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      font-size:13px;\n    }\n    button:hover { border-color: rgba(255,255,255,0.08); color:#e8f6ff; }\n    .btn-primary{\n      background: linear-gradient(90deg,#06b6d4, #7c3aed);\n      color:white;\n      border: none;\n      box-shadow: 0 6px 18px rgba(7,18,28,0.6);\n    }\n    .toggle {\n      display:flex;\n      gap:8px;\n      align-items:center;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .small {\n      font-size:12px;\n      color:var(--muted);\n    }\n    .canvas-wrap{\n      flex:1;\n      min-width:0;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:12px;\n      padding:12px;\n      position:relative;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .svg-area{\n      flex:1;\n      position:relative;\n      border-radius:10px;\n      background:\n        radial-gradient(800px 400px at 10% 10%, rgba(6,182,212,0.03), transparent 2%),\n        linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.02));\n      overflow:hidden;\n    }\n    svg{ width:100%; height:100%; display:block; }\n    .hint{\n      font-size:12px;\n      color:var(--muted);\n    }\n    .pane{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .chip {\n      background: rgba(255,255,255,0.02);\n      border: 1px solid rgba(255,255,255,0.03);\n      padding:6px 8px;\n      border-radius:999px;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .queue {\n      display:flex;\n      gap:8px;\n      align-items:center;\n      min-height:42px;\n      padding:6px;\n      border-radius:8px;\n      background: rgba(255,255,255,0.015);\n      border:1px dashed rgba(255,255,255,0.02);\n      overflow-x:auto;\n    }\n    .queue .node-chip {\n      min-width:36px;\n      height:36px;\n      border-radius:9px;\n      display:inline-flex;\n      align-items:center;\n      justify-content:center;\n      color:#071428;\n      font-weight:700;\n      transition: transform 250ms ease, opacity 220ms ease;\n      background: #ffd966;\n      box-shadow: 0 8px 18px rgba(0,0,0,0.4);\n    }\n    .visited-list {\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n    }\n    .status {\n      font-size:12px;\n      color:var(--muted);\n    }\n\n    /* Node / edge visuals */\n    .node {\n      cursor:pointer;\n      transition: transform 200ms ease;\n    }\n    .node-circle {\n      fill: #94a3b8; /* neutral */\n      stroke: rgba(255,255,255,0.06);\n      stroke-width:1.5;\n      transition: fill 300ms ease, r 200ms ease, filter 220ms ease;\n    }\n    .label {\n      fill:#071428;\n      font-size:13px;\n      font-weight:700;\n      pointer-events:none;\n      user-select:none;\n    }\n    .edge {\n      stroke: rgba(255,255,255,0.06);\n      stroke-width:2;\n      transition: stroke 220ms ease, stroke-width 120ms ease, opacity 200ms ease;\n    }\n\n    /* States */\n    .state-unvisited .node-circle{ fill:#94a3b8; }\n    .state-queued .node-circle{ fill: #ffd966; }\n    .state-current .node-circle{ fill: #60a5fa; filter: drop-shadow(0 6px 14px rgba(96,165,250,0.12)); }\n    .state-visited .node-circle{ fill: #34d399; }\n\n    .edge-traverse { stroke: #fb923c; stroke-width:4px; }\n\n    /* Node pulsing while queued */\n    @keyframes pulse {\n      0% { transform: scale(1); }\n      50% { transform: scale(1.08); }\n      100% { transform: scale(1); }\n    }\n    .state-queued .node-circle { animation: pulse 1200ms ease-in-out infinite; transform-origin:center; }\n\n    /* small responsive tweaks */\n    @media (max-width: 880px){\n      .wrap { flex-direction:column; padding:18px; }\n      .left { width:100%; min-width:0; order:1; }\n      .canvas-wrap { order:2; min-height:420px; }\n    }\n    /* subtle scrollbar style for queue */\n    .queue::-webkit-scrollbar { height:8px; }\n    .queue::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.04); border-radius:6px; }\n    /* accessibility focus */\n    button:focus, select:focus { outline: 2px solid rgba(6,182,212,0.16); outline-offset:2px; }\n    .sr { position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden; }\n  </style>\n</head>\n<body>\n  <div class=\"wrap\" role=\"application\" aria-label=\"Breadth First Search interactive module\">\n    <aside class=\"left\" aria-labelledby=\"title\">\n      <div>\n        <h1 id=\"title\" class=\"title\">Breadth-First Search (BFS)</h1>\n        <p class=\"subtitle\">Explore BFS visually: build graphs, then step through how BFS expands nodes level-by-level.</p>\n      </div>\n\n      <div class=\"controls\" role=\"region\" aria-label=\"Controls\">\n        <div>\n          <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n            <div class=\"small\">Graph Editing</div>\n            <div class=\"small hint\">Click canvas to add nodes</div>\n          </div>\n          <div class=\"row\" style=\"margin-top:8px;\">\n            <button id=\"btn-rand\" title=\"Generate a small random graph\">Random Graph</button>\n            <button id=\"btn-clear\" title=\"Clear all nodes and edges\">Clear</button>\n            <label class=\"toggle\" title=\"Toggle edge creation mode\">\n              <input id=\"toggle-edge\" type=\"checkbox\" aria-label=\"Toggle add edge mode\" />\n              <span class=\"small\">Add Edge</span>\n            </label>\n          </div>\n        </div>\n\n        <div>\n          <div class=\"small\">BFS Controls</div>\n          <div class=\"row\" style=\"margin-top:8px;\">\n            <select id=\"start-select\" aria-label=\"Start node for BFS\">\n              <option value=\"\">Select start node</option>\n            </select>\n            <button id=\"btn-run\" class=\"btn-primary\">Run BFS</button>\n          </div>\n          <div class=\"row\" style=\"margin-top:8px;\">\n            <button id=\"btn-play\">Play</button>\n            <button id=\"btn-step\">Step</button>\n            <button id=\"btn-reset\">Reset</button>\n            <div style=\"display:flex;align-items:center;gap:8px;\">\n              <input id=\"speed\" type=\"range\" min=\"200\" max=\"1600\" step=\"100\" value=\"700\" aria-label=\"Animation speed\" />\n            </div>\n          </div>\n          <div style=\"margin-top:8px;\" class=\"status\" id=\"action-status\">Status: idle</div>\n        </div>\n\n        <div>\n          <div class=\"small\">Queue (Frontier)</div>\n          <div class=\"queue\" id=\"queue\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n        </div>\n\n        <div>\n          <div class=\"small\">Visited (with distances)</div>\n          <div class=\"visited-list\" id=\"visited\"></div>\n        </div>\n\n        <div class=\"hint\" style=\"margin-top:8px\">\n          Tips: Use \"Add Edge\" then click two nodes to connect them. Drag nodes to rearrange. Press Delete after selecting a node to remove it.\n        </div>\n      </div>\n    </aside>\n\n    <main class=\"canvas-wrap\">\n      <div class=\"svg-area\" id=\"canvas-area\" role=\"region\" aria-label=\"Graph drawing area\">\n        <svg id=\"svg\" viewBox=\"0 0 1200 800\" preserveAspectRatio=\"xMidYMid meet\" tabindex=\"0\" aria-label=\"Graph visualization\">\n          <!-- edges and nodes are drawn here -->\n        </svg>\n      </div>\n      <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n        <div class=\"small hint\">Click the canvas to add nodes. Toggle \"Add Edge\" to connect nodes.</div>\n        <div class=\"small hint\">Nodes animate color: queued → current → visited.</div>\n      </div>\n    </main>\n  </div>\n\n  <script>\n    (function(){\n      // Basic graph data\n      let nodes = []; // {id,label,x,y}\n      let edges = []; // {id, a, b}\n      let nodeCounter = 0;\n\n      // UI elements\n      const svg = document.getElementById('svg');\n      const queueEl = document.getElementById('queue');\n      const visitedEl = document.getElementById('visited');\n      const startSelect = document.getElementById('start-select');\n      const btnRand = document.getElementById('btn-rand');\n      const btnClear = document.getElementById('btn-clear');\n      const toggleEdge = document.getElementById('toggle-edge');\n      const btnRun = document.getElementById('btn-run');\n      const btnPlay = document.getElementById('btn-play');\n      const btnStep = document.getElementById('btn-step');\n      const btnReset = document.getElementById('btn-reset');\n      const speedInput = document.getElementById('speed');\n      const actionStatus = document.getElementById('action-status');\n\n      // Animation / BFS state\n      let animScript = []; // sequence of actions for animation\n      let animIndex = 0;\n      let animTimer = null;\n      let isPlaying = false;\n      let selectedNodeId = null; // for edge creation or selection\n      let focusedNodeId = null; // for deletion\n      let dragState = null;\n\n      // Utility\n      function genLabel(i){\n        // Label A, B, C... then AA, AB...\n        let s = '';\n        i += 1;\n        while(i > 0){\n          i--; s = String.fromCharCode(65 + (i % 26)) + s;\n          i = Math.floor(i / 26);\n        }\n        return s;\n      }\n      function getNodeById(id){ return nodes.find(n=>n.id===id); }\n      function getNodeIndex(id){ return nodes.findIndex(n=>n.id===id); }\n      function addNodeAt(x,y){\n        const id = 'n'+(++nodeCounter);\n        const label = genLabel(nodes.length);\n        nodes.push({id,label,x,y});\n        render();\n      }\n      function addEdge(a,b){\n        if(a===b) return;\n        // avoid duplicate undirected edges\n        const exists = edges.some(e => (e.a===a&&e.b===b) || (e.a===b&&e.b===a));\n        if(!exists){\n          edges.push({id:'e'+(edges.length+1), a, b});\n          render();\n        }\n      }\n      function removeNode(id){\n        nodes = nodes.filter(n=>n.id!==id);\n        edges = edges.filter(e=>e.a!==id && e.b!==id);\n        render();\n      }\n      function clearGraph(){\n        nodes = []; edges = []; nodeCounter = 0;\n        resetAnimation();\n        render();\n      }\n\n      // SVG rendering\n      function render(){\n        // update start-select\n        const prev = startSelect.value;\n        startSelect.innerHTML = '<option value=\"\">Select start node</option>';\n        nodes.forEach(n=>{\n          const opt = document.createElement('option');\n          opt.value = n.id; opt.textContent = n.label;\n          startSelect.appendChild(opt);\n        });\n        if(nodes.some(n=>n.id===prev)) startSelect.value = prev;\n\n        // clear svg\n        while(svg.firstChild) svg.removeChild(svg.firstChild);\n\n        // adapt viewBox to container size\n        const vbW = 1200, vbH = 800;\n        svg.setAttribute('viewBox', `0 0 ${vbW} ${vbH}`);\n\n        // draw edges first\n        edges.forEach(e=>{\n          const a = getNodeById(e.a), b = getNodeById(e.b);\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n          line.setAttribute('x1', a.x);\n          line.setAttribute('y1', a.y);\n          line.setAttribute('x2', b.x);\n          line.setAttribute('y2', b.y);\n          line.setAttribute('class','edge');\n          line.setAttribute('data-id', e.id);\n          g.appendChild(line);\n          svg.appendChild(g);\n        });\n\n        // draw nodes on top\n        nodes.forEach(n=>{\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('class', 'node state-unvisited');\n          g.setAttribute('transform', `translate(${n.x},${n.y})`);\n          g.setAttribute('data-id', n.id);\n          g.setAttribute('tabindex', 0);\n          g.setAttribute('role', 'button');\n          g.setAttribute('aria-label', `Node ${n.label}`);\n\n          // circle\n          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          c.setAttribute('r', 18);\n          c.setAttribute('class','node-circle');\n          g.appendChild(c);\n\n          // label background (small rounded rect via rect)\n          const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');\n          rect.setAttribute('x', -16);\n          rect.setAttribute('y', -10);\n          rect.setAttribute('width', 32);\n          rect.setAttribute('height', 20);\n          rect.setAttribute('rx', 6);\n          rect.setAttribute('fill', 'transparent');\n          rect.setAttribute('pointer-events', 'none');\n          // append rect after circle to keep it below text\n          // label text\n          const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n          t.setAttribute('class','label');\n          t.setAttribute('x',0);\n          t.setAttribute('y',5);\n          t.setAttribute('text-anchor','middle');\n          t.textContent = n.label;\n\n          g.appendChild(t);\n\n          // events\n          g.addEventListener('mousedown', onNodeMouseDown);\n          g.addEventListener('click', onNodeClick);\n          g.addEventListener('keydown', (ev)=>{\n            if(ev.key === 'Delete'){ removeNode(n.id); }\n          });\n\n          svg.appendChild(g);\n        });\n\n        updateVisualStates();\n      }\n\n      // Update node/edge classes based on runtime states (visited/queued/current)\n      let nodeState = {}; // id -> 'unvisited'|'queued'|'current'|'visited'\n      let edgeState = {}; // id -> 'normal'|'traverse'\n\n      function updateVisualStates(){\n        // nodes\n        nodes.forEach(n=>{\n          const g = svg.querySelector(`g.node[data-id=\"${n.id}\"]`);\n          if(!g) return;\n          const state = nodeState[n.id] || 'unvisited';\n          g.classList.remove('state-unvisited','state-queued','state-current','state-visited');\n          g.classList.add('state-'+state);\n        });\n        // edges\n        edges.forEach(e=>{\n          const line = svg.querySelector(`line[data-id=\"${e.id}\"]`);\n          if(!line) return;\n          if(edgeState[e.id] === 'traverse'){\n            line.classList.add('edge-traverse');\n          } else {\n            line.classList.remove('edge-traverse');\n          }\n        });\n      }\n\n      // Canvas events\n      const canvasArea = document.getElementById('canvas-area');\n      let svgPoint = function(x,y){\n        // convert client coordinates to svg coords using viewBox mapping\n        const rect = svg.getBoundingClientRect();\n        const vb = svg.viewBox.baseVal;\n        const scaleX = vb.width / rect.width;\n        const scaleY = vb.height / rect.height;\n        const vx = (x - rect.left) * scaleX + vb.x;\n        const vy = (y - rect.top) * scaleY + vb.y;\n        return {x: vx, y: vy};\n      };\n\n      svg.addEventListener('click', function(ev){\n        // add node unless clicked on an existing node or in edge mode (in edge mode only click node to create edges)\n        if(ev.target.closest('g.node')) return;\n        const p = svgPoint(ev.clientX, ev.clientY);\n        addNodeAt(p.x, p.y);\n      });\n\n      function onNodeClick(ev){\n        ev.stopPropagation();\n        const gid = this.getAttribute('data-id');\n        // selection for edge creation\n        if(toggleEdge.checked){\n          if(!selectedNodeId){\n            selectedNodeId = gid;\n            highlightNode(gid, true);\n            actionStatus.textContent = `Selected ${getNodeById(gid).label} as source. Click target to create edge.`;\n          } else if(selectedNodeId === gid){\n            // cancel\n            highlightNode(gid, false);\n            selectedNodeId = null;\n            actionStatus.textContent = 'Edge selection canceled.';\n          } else {\n            addEdge(selectedNodeId, gid);\n            highlightNode(selectedNodeId, false);\n            actionStatus.textContent = `Edge created between ${getNodeById(selectedNodeId).label} and ${getNodeById(gid).label}.`;\n            selectedNodeId = null;\n          }\n          return;\n        }\n\n        // Selection for deletion or focus\n        focusedNodeId = gid;\n        // toggle focus visual with a subtle transform\n        const g = svg.querySelector(`g.node[data-id=\"${gid}\"]`);\n        if(g) {\n          // briefly scale\n          g.style.transform = 'scale(1.04)';\n          setTimeout(()=> g.style.transform = '', 220);\n        }\n      }\n\n      function highlightNode(id, on){\n        const g = svg.querySelector(`g.node[data-id=\"${id}\"]`);\n        if(g){\n          if(on) g.style.transform = 'scale(1.06)';\n          else g.style.transform = '';\n        }\n      }\n\n      // Dragging\n      function onNodeMouseDown(ev){\n        ev.stopPropagation();\n        const g = this;\n        const id = g.getAttribute('data-id');\n        const startPoint = svgPoint(ev.clientX, ev.clientY);\n        const node = getNodeById(id);\n        dragState = {id, ox: node.x, oy: node.y, sx:startPoint.x, sy:startPoint.y, g};\n        window.addEventListener('mousemove', onDrag);\n        window.addEventListener('mouseup', endDrag);\n      }\n      function onDrag(ev){\n        if(!dragState) return;\n        const p = svgPoint(ev.clientX, ev.clientY);\n        const dx = p.x - dragState.sx;\n        const dy = p.y - dragState.sy;\n        const node = getNodeById(dragState.id);\n        node.x = dragState.ox + dx;\n        node.y = dragState.oy + dy;\n        // update transform\n        dragState.g.setAttribute('transform', `translate(${node.x},${node.y})`);\n        // update edges positions quickly by re-rendering edges only\n        edges.forEach(e=>{\n          const line = svg.querySelector(`line[data-id=\"${e.id}\"]`);\n          if(line){\n            const a = getNodeById(e.a), b = getNodeById(e.b);\n            line.setAttribute('x1', a.x);\n            line.setAttribute('y1', a.y);\n            line.setAttribute('x2', b.x);\n            line.setAttribute('y2', b.y);\n          }\n        });\n      }\n      function endDrag(){\n        window.removeEventListener('mousemove', onDrag);\n        window.removeEventListener('mouseup', endDrag);\n        dragState = null;\n      }\n\n      // Random graph generator\n      btnRand.addEventListener('click', ()=>{\n        clearGraph();\n        const w = 1200, h = 800;\n        const n = 7 + Math.floor(Math.random()*3);\n        for(let i=0;i<n;i++){\n          addNodeAt(150 + Math.random()*(w-300), 120 + Math.random()*(h-240));\n        }\n        // add some edges\n        for(let i=0;i<n;i++){\n          for(let j=i+1;j<n;j++){\n            if(Math.random() < 0.22) addEdge(nodes[i].id, nodes[j].id);\n          }\n        }\n        actionStatus.textContent = 'Random graph generated.';\n      });\n\n      // Clear\n      btnClear.addEventListener('click', ()=> { clearGraph(); actionStatus.textContent='Graph cleared.'; });\n\n      // Delete key for removing focused node\n      window.addEventListener('keydown', (ev)=>{\n        if(ev.key === 'Delete' && focusedNodeId){\n          removeNode(focusedNodeId);\n          focusedNodeId = null;\n        }\n      });\n\n      // BFS algorithm: build script of actions for visual animation\n      // Actions: {type:'enqueue',nodeId}, {type:'dequeue',nodeId}, {type:'visit',nodeId,dist}, {type:'edge',edgeId}\n      function buildBFSScript(startId){\n        const script = [];\n        nodeState = {}; edgeState = {};\n        nodes.forEach(n=>{ nodeState[n.id] = 'unvisited'; });\n        edges.forEach(e=>{ edgeState[e.id] = 'normal'; });\n\n        const q = [];\n        const dist = {};\n        q.push(startId);\n        nodeState[startId] = 'queued';\n        script.push({type:'enqueue', id:startId});\n        dist[startId] = 0;\n\n        while(q.length){\n          const cur = q.shift();\n          script.push({type:'dequeue', id:cur});\n          script.push({type:'current', id:cur});\n          // get neighbors (undirected)\n          const neighbors = edges.reduce((acc,e)=>{\n            if(e.a === cur) acc.push({id:e.b, edge:e.id});\n            else if(e.b === cur) acc.push({id:e.a, edge:e.id});\n            return acc;\n          }, []);\n          // sort neighbors by label to make deterministic\n          neighbors.sort((A,B)=> {\n            const la = getNodeById(A.id).label, lb = getNodeById(B.id).label;\n            return la.localeCompare(lb);\n          });\n          neighbors.forEach(nbr => {\n            // edge traversal highlight\n            script.push({type:'edge', id:nbr.edge});\n            if(nodeState[nbr.id] === 'unvisited'){\n              nodeState[nbr.id] = 'queued';\n              dist[nbr.id] = dist[cur] + 1;\n              q.push(nbr.id);\n              script.push({type:'enqueue', id:nbr.id});\n            } else {\n              // still show considered neighbor\n              script.push({type:'considered', id:nbr.id});\n            }\n          });\n          script.push({type:'visit', id:cur, dist:dist[cur]});\n        }\n        return script;\n      }\n\n      function resetAnimation(){\n        if(animTimer) { clearInterval(animTimer); animTimer = null; }\n        animScript = []; animIndex = 0; isPlaying = false;\n        nodeState = {}; edgeState = {};\n        nodes.forEach(n=> nodeState[n.id]='unvisited');\n        edges.forEach(e=> edgeState[e.id]='normal');\n        updateVisualStates();\n        queueEl.innerHTML = '';\n        visitedEl.innerHTML = '';\n        actionStatus.textContent = 'Status: idle';\n        btnPlay.textContent = 'Play';\n      }\n\n      function runBFS(){\n        const startId = startSelect.value;\n        if(!startId){ actionStatus.textContent = 'Choose a start node.'; return; }\n        resetAnimation();\n        animScript = buildBFSScript(startId);\n        animIndex = 0;\n        actionStatus.textContent = 'BFS script prepared. Step or Play to begin.';\n      }\n\n      // animate next action\n      function stepAnimation(){\n        if(!animScript || animIndex >= animScript.length){\n          actionStatus.textContent = 'Finished.';\n          isPlaying = false;\n          btnPlay.textContent = 'Play';\n          return;\n        }\n        const a = animScript[animIndex++];\n        handleAction(a);\n        updateVisualStates();\n      }\n\n      function handleAction(a){\n        switch(a.type){\n          case 'enqueue':\n            nodeState[a.id] = 'queued';\n            animateQueueEnqueue(a.id);\n            actionStatus.textContent = `Enqueue ${getNodeById(a.id).label}`;\n            break;\n          case 'dequeue':\n            // will be set to current after\n            // remove from queue visualization\n            animateQueueDequeue(a.id);\n            actionStatus.textContent = `Dequeue ${getNodeById(a.id).label}`;\n            break;\n          case 'current':\n            // mark current\n            Object.keys(nodeState).forEach(k=>{\n              if(nodeState[k] === 'current') nodeState[k] = 'visited'; // finalize previous current\n            });\n            nodeState[a.id] = 'current';\n            actionStatus.textContent = `Expanding ${getNodeById(a.id).label}`;\n            break;\n          case 'edge':\n            // highlight edge briefly\n            edgeState[a.id] = 'traverse';\n            actionStatus.textContent = `Considering edge ${a.id}`;\n            // clear after short timeout\n            setTimeout(()=>{ edgeState[a.id] = 'normal'; updateVisualStates(); }, Math.max(180, parseInt(speedInput.value)/2));\n            break;\n          case 'considered':\n            // flash considered node briefly\n            actionStatus.textContent = `Considered ${getNodeById(a.id).label}`;\n            break;\n          case 'visit':\n            nodeState[a.id] = 'visited';\n            // add to visited list with distance\n            const chip = document.createElement('div');\n            chip.className = 'chip';\n            chip.textContent = `${getNodeById(a.id).label} (d=${a.dist})`;\n            visitedEl.appendChild(chip);\n            actionStatus.textContent = `Visited ${getNodeById(a.id).label} (distance ${a.dist})`;\n            break;\n        }\n        // keep UI updated\n        updateVisualStates();\n      }\n\n      // Queue visual helpers\n      function animateQueueEnqueue(id){\n        const node = getNodeById(id);\n        const chip = document.createElement('div');\n        chip.className = 'node-chip';\n        chip.textContent = node.label;\n        chip.setAttribute('data-id', id);\n        chip.style.opacity = '0';\n        chip.style.transform = 'translateY(-6px)';\n        queueEl.appendChild(chip);\n        // animate in\n        requestAnimationFrame(()=> {\n          chip.style.transition = 'transform 260ms ease, opacity 220ms ease';\n          chip.style.opacity = '1';\n          chip.style.transform = 'translateY(0)';\n        });\n      }\n      function animateQueueDequeue(id){\n        const chip = queueEl.querySelector(`.node-chip[data-id=\"${id}\"]`);\n        if(chip){\n          chip.style.transition = 'transform 260ms ease, opacity 200ms ease';\n          chip.style.transform = 'translateY(-8px) scale(0.9)';\n          chip.style.opacity = '0';\n          setTimeout(()=> chip.remove(), 260);\n        }\n      }\n\n      // Play controls\n      btnRun.addEventListener('click', runBFS);\n\n      btnPlay.addEventListener('click', ()=>{\n        if(!animScript || animScript.length === 0){ actionStatus.textContent = 'No BFS prepared. Click Run BFS first.'; return; }\n        if(isPlaying){\n          // pause\n          isPlaying = false;\n          if(animTimer){ clearInterval(animTimer); animTimer = null; }\n          btnPlay.textContent = 'Play';\n          actionStatus.textContent = 'Paused.';\n        } else {\n          // play\n          isPlaying = true;\n          btnPlay.textContent = 'Pause';\n          const speed = parseInt(speedInput.value);\n          animTimer = setInterval(()=> {\n            if(animIndex >= animScript.length){\n              clearInterval(animTimer); animTimer = null;\n              isPlaying = false;\n              btnPlay.textContent = 'Play';\n              actionStatus.textContent = 'Finished.';\n              return;\n            }\n            stepAnimation();\n          }, speed);\n          actionStatus.textContent = 'Playing...';\n        }\n      });\n      btnStep.addEventListener('click', ()=>{\n        if(!animScript || animScript.length === 0){ actionStatus.textContent = 'No BFS prepared. Click Run BFS first.'; return; }\n        if(isPlaying){\n          // if playing, step should pause\n          isPlaying = false;\n          if(animTimer){ clearInterval(animTimer); animTimer = null; }\n          btnPlay.textContent = 'Play';\n        }\n        stepAnimation();\n      });\n      btnReset.addEventListener('click', ()=>{\n        resetAnimation();\n        actionStatus.textContent = 'Reset animation state.';\n      });\n\n      // initialize empty state\n      resetAnimation();\n      render();\n\n      // keyboard: space to step when Run button focused\n      btnStep.addEventListener('keydown', function(ev){\n        if(ev.key === ' ' || ev.key === 'Enter') { ev.preventDefault(); stepAnimation(); }\n      });\n\n      // small accessibility: announce nodes added\n      const live = document.createElement('div'); live.className='sr'; live.setAttribute('aria-live','polite'); document.body.appendChild(live);\n      const origAddNode = addNodeAt;\n      // override to announce (not strictly necessary; we will just set text when adding)\n      // but we use actionStatus for feedback already.\n\n    })();\n  </script>\n</body>\n</html>\n```\n\nNotes and pedagogical suggestions:\n- Encourage learners to create simple graphs (a line, a star, a cycle) and predict BFS order before running the animation.\n- Try different start nodes and observe how distances change.\n- Use the step control to slow down and inspect the queue each time nodes are enqueued and dequeued."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Breadth-First Search (BFS).\n\n**Project Overview:**\nTopic: Breadth-First Search (BFS)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Breadth-First Search (BFS)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "22fd7040-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:49:39.140Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Dijkstra’s Algorithm",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Dijkstra’s Algorithm — Interactive Module</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #0ea5a4;\n      --muted: #94a3b8;\n      --success: #10b981;\n      --danger: #ef4444;\n      --glass: rgba(255,255,255,0.03);\n      --node-radius: 22;\n      --node-font: 13px/1 \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071124 0%, #0b1220 100%);\n      color:#e6eef8;\n      font-family: \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .app{\n      box-sizing:border-box;\n      padding:var(--safe-margin);\n      min-height:100%;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    header{\n      display:flex;\n      align-items:baseline;\n      justify-content:space-between;\n      gap:var(--gap);\n    }\n    .title{\n      display:flex;\n      flex-direction:column;\n      gap:6px;\n    }\n    .title h1{\n      margin:0;\n      font-size:20px;\n    }\n    .subtitle{\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    main{\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n    }\n\n    /* left: interactive canvas */\n    .canvas-panel{\n      flex:1 1 0%;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n      border-radius:12px;\n      padding:16px;\n      min-height:520px;\n      box-shadow: 0 6px 30px rgba(2,6,23,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n\n    .top-controls{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .controls-group{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      background:var(--glass);\n      padding:8px;\n      border-radius:8px;\n    }\n\n    button, .control-btn{\n      background:transparent;\n      color:var(--accent);\n      border:1px solid rgba(14,165,164,0.12);\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      font-size:13px;\n    }\n    button:hover, .control-btn:hover{ filter:brightness(1.2); }\n    button:active{ transform:translateY(1px); }\n    .control-btn[aria-pressed=\"true\"]{\n      background:linear-gradient(90deg, rgba(14,165,164,0.12), rgba(16,185,129,0.04));\n      border-color:rgba(14,165,164,0.3);\n      color:var(--success);\n    }\n\n    .small{\n      padding:6px 8px;\n      font-size:13px;\n    }\n\n    .canvas-wrap{\n      position:relative;\n      flex:1;\n      border-radius:8px;\n      background:linear-gradient(180deg,#071428 0%, rgba(10,16,26,0.55) 100%);\n      min-height:420px;\n      overflow:hidden;\n      display:flex;\n      gap:12px;\n    }\n    /* svg fills available space */\n    svg#graph {\n      width:100%;\n      height:100%;\n      display:block;\n      touch-action:none;\n      cursor:default;\n    }\n\n    /* right: controls and explanation */\n    .side-panel{\n      width:320px;\n      max-width:40%;\n      min-width:260px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n      border-radius:12px;\n      padding:16px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n\n    label{ font-size:13px; color:var(--muted); }\n\n    .kv-row{\n      display:flex;\n      gap:10px;\n      align-items:center;\n      justify-content:space-between;\n      font-size:13px;\n    }\n\n    .pq{\n      background:rgba(255,255,255,0.02);\n      padding:8px;\n      border-radius:8px;\n      min-height:48px;\n      max-height:180px;\n      overflow:auto;\n      font-size:13px;\n    }\n    .pq-item{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content:space-between;\n      padding:6px 8px;\n      border-radius:8px;\n    }\n    .pq-item.seen{ opacity:0.6;}\n    .hint{ font-size:13px; color:var(--muted); }\n\n    footer.note{\n      color:var(--muted);\n      font-size:13px;\n      background:transparent;\n    }\n\n    /* node and edge styles in SVG classes */\n    .edge-line{ stroke:#2b6b86; stroke-width:2; transition:stroke 220ms, stroke-width 220ms; }\n    .edge-label{ fill:#bfe8e6; font-size:12px; pointer-events:none; }\n    .node-circle{ fill:#071a2a; stroke:#17868a; stroke-width:2; cursor:pointer; transition:transform 160ms; }\n    .node-label{ fill:#dff7f6; font:var(--node-font); text-anchor:middle; dominant-baseline:central; pointer-events:none; }\n    .node-dist{ fill:#9fe0dd; font-size:12px; text-anchor:middle; pointer-events:none; }\n    .node-start{ stroke:#60a5fa; stroke-width:3; }\n    .node-visited{ fill:#0b2b1e; stroke:#10b981; }\n    .node-frontier{ fill:#092f3a; stroke:#f59e0b; }\n    .edge-relax{ stroke:#f8b4a6; stroke-width:3.5; }\n\n    .pulse {\n      animation: pulseEdge 520ms ease-out;\n    }\n    @keyframes pulseEdge {\n      0%{ stroke-width:4; opacity:1; }\n      100%{ stroke-width:2; opacity:0.9; }\n    }\n\n    /* responsive */\n    @media (max-width: 900px){\n      main{ flex-direction:column; }\n      .side-panel{ width:100%; max-width:100%; }\n    }\n\n    /* focus styles */\n    button:focus, .control-btn:focus{ outline:2px solid rgba(14,165,164,0.16); outline-offset:2px; }\n\n    /* small helper */\n    .muted{ color:var(--muted); font-size:13px; }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-labelledby=\"main-title\">\n    <header>\n      <div class=\"title\">\n        <h1 id=\"main-title\">Dijkstra’s Algorithm — Step-by-step Visualizer</h1>\n        <p class=\"subtitle\">Interactive exploration: build a weighted graph, run Dijkstra, and observe relaxations and shortest paths.</p>\n      </div>\n      <div class=\"kv-row\">\n        <div class=\"muted\">Safe margins: 24px • Min spacing: 16px</div>\n      </div>\n    </header>\n\n    <main>\n      <!-- Left: Canvas and Controls -->\n      <section class=\"canvas-panel\" aria-label=\"Visualizer area\">\n        <div class=\"top-controls\" role=\"toolbar\" aria-label=\"Graph actions\">\n          <div class=\"controls-group\" role=\"group\" aria-label=\"Edit modes\">\n            <button id=\"mode-add-node\" class=\"control-btn\" aria-pressed=\"false\" title=\"Add node: click on canvas\">Add node</button>\n            <button id=\"mode-add-edge\" class=\"control-btn\" aria-pressed=\"false\" title=\"Add edge: click source then target\">Add edge</button>\n            <button id=\"mode-set-start\" class=\"control-btn\" aria-pressed=\"false\" title=\"Set start node\">Set start</button>\n            <button id=\"mode-delete\" class=\"control-btn\" aria-pressed=\"false\" title=\"Delete node/edge\">Delete</button>\n          </div>\n\n          <div class=\"controls-group\" role=\"group\" aria-label=\"Edge options\">\n            <label for=\"edge-weight\" class=\"muted\">Weight</label>\n            <input id=\"edge-weight\" type=\"number\" min=\"0\" value=\"1\" style=\"width:72px; padding:6px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); background:transparent; color:inherit;\">\n          </div>\n\n          <div class=\"controls-group\" role=\"group\" aria-label=\"Run controls\">\n            <button id=\"step-btn\" class=\"control-btn small\">Step</button>\n            <button id=\"autorun-btn\" class=\"control-btn small\" aria-pressed=\"false\">Auto-run</button>\n            <button id=\"reset-btn\" class=\"control-btn small\">Reset</button>\n          </div>\n\n          <div class=\"controls-group\" role=\"group\" aria-label=\"Speed control\">\n            <label class=\"muted\">Speed</label>\n            <input id=\"speed\" type=\"range\" min=\"200\" max=\"1500\" value=\"700\" step=\"50\" title=\"Animation speed\">\n          </div>\n        </div>\n\n        <div class=\"canvas-wrap\" aria-hidden=\"false\">\n          <svg id=\"graph\" role=\"img\" aria-label=\"Graph drawing area\" tabindex=\"0\"></svg>\n        </div>\n\n        <div style=\"display:flex;gap:12px;align-items:center;justify-content:space-between;\">\n          <div class=\"hint\">Tip: Toggle modes then click nodes. Drag nodes to reposition. After running, click a target node to show the shortest path from start.</div>\n          <div class=\"muted\">Nodes: <span id=\"count-nodes\">0</span> • Edges: <span id=\"count-edges\">0</span></div>\n        </div>\n      </section>\n\n      <!-- Right: Controls, PQ, Explanations -->\n      <aside class=\"side-panel\" aria-label=\"Controls and explanation\">\n        <div>\n          <label class=\"muted\">Priority Queue (frontier)</label>\n          <div id=\"pq\" class=\"pq\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n        </div>\n\n        <div>\n          <label class=\"muted\">Algorithm state</label>\n          <div style=\"display:flex;gap:8px;flex-direction:column;margin-top:8px;\">\n            <div class=\"kv-row\"><span>Start node</span><strong id=\"start-node\">—</strong></div>\n            <div class=\"kv-row\"><span>Current node</span><strong id=\"current-node\">—</strong></div>\n            <div class=\"kv-row\"><span>Visited count</span><strong id=\"visited-count\">0</strong></div>\n          </div>\n        </div>\n\n        <div>\n          <label class=\"muted\">Concept Title</label>\n          <div style=\"padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;margin-top:8px;\">\n            Dijkstra’s algorithm: find shortest paths from a start node to all others in a weighted graph with non-negative edge weights.\n          </div>\n        </div>\n\n        <div>\n          <label class=\"muted\">Learning Objective</label>\n          <div style=\"padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;margin-top:8px;\">\n            After interacting you will understand how tentative distances are updated by edge relaxations, how the priority queue (frontier) selects the next node, and how the shortest path tree is built.\n          </div>\n        </div>\n\n        <div>\n          <label class=\"muted\">Interaction Design</label>\n          <div style=\"padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;margin-top:8px;font-size:13px;color:var(--muted);\">\n            - Add nodes by toggling \"Add node\" and clicking the canvas (or drag to reposition).<br>\n            - Add an edge by toggling \"Add edge\", selecting two nodes; specify its weight in the weight field.<br>\n            - Set the start node with \"Set start\".<br>\n            - Use \"Step\" to advance one operation of Dijkstra: the smallest-distance node is popped, marked visited, and its incident edges are relaxed with an animation (edge pulse and distance update).<br>\n            - \"Auto-run\" animates steps automatically. After the algorithm runs, click any node to highlight the shortest path from the start.\n          </div>\n        </div>\n\n        <div>\n          <label class=\"muted\">Layout Description</label>\n          <div style=\"padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;margin-top:8px;font-size:13px;color:var(--muted);\">\n            The viewport uses a two-column layout: left is the interactive SVG canvas with the editing and run controls above, right is a vertical panel showing the priority queue, algorithm state, and explanatory text. The entire layout uses 24px safe area padding and a minimum spacing of 16px between interactive elements. It is responsive: on smaller screens the side panel stacks beneath the canvas.\n          </div>\n        </div>\n\n        <footer class=\"note\" style=\"margin-top:8px;\">\n          Accessibility: all controls are keyboard-focusable; the priority queue region updates live for screen readers.\n        </footer>\n      </aside>\n    </main>\n  </div>\n\n  <script>\n    /*****************************************************************************\n     * Dijkstra Interactive Visualizer\n     * - Vanilla JS, single-file\n     * - Modes: add node, add edge, set start, delete\n     * - Step-by-step Dijkstra with animated relaxations\n     *****************************************************************************/\n\n    // Basic graph data structures\n    const svg = document.getElementById('graph');\n    const pqEl = document.getElementById('pq');\n    const countNodesEl = document.getElementById('count-nodes');\n    const countEdgesEl = document.getElementById('count-edges');\n    const startNodeEl = document.getElementById('start-node');\n    const currentNodeEl = document.getElementById('current-node');\n    const visitedCountEl = document.getElementById('visited-count');\n\n    const NS = \"http://www.w3.org/2000/svg\";\n\n    let nodes = []; // {id, x, y, elementRefs..., dist, prev, visited, inPQ}\n    let edges = []; // {id, a, b, w, elements...}\n    let nodeIdCounter = 0;\n    let edgeIdCounter = 0;\n\n    // Modes\n    const modeButtons = {\n      addNode: document.getElementById('mode-add-node'),\n      addEdge: document.getElementById('mode-add-edge'),\n      setStart: document.getElementById('mode-set-start'),\n      delete: document.getElementById('mode-delete')\n    };\n    let mode = null;\n\n    function setMode(newMode){\n      mode = newMode;\n      for(const [k,btn] of Object.entries(modeButtons)){\n        btn.setAttribute('aria-pressed', k===newMode ? 'true' : 'false');\n      }\n      svg.style.cursor = (newMode === 'addNode') ? 'crosshair' : 'default';\n      // clearing any partial edge selection\n      pendingEdgeSource = null;\n      updateHints();\n    }\n\n    for(const [k,btn] of Object.entries(modeButtons)){\n      btn.addEventListener('click', () => {\n        setMode(mode === k ? null : k);\n      });\n    }\n\n    // Controls\n    const edgeWeightInput = document.getElementById('edge-weight');\n    const stepBtn = document.getElementById('step-btn');\n    const autorunBtn = document.getElementById('autorun-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    const speedInput = document.getElementById('speed');\n\n    stepBtn.addEventListener('click', stepOnce);\n    autorunBtn.addEventListener('click', toggleAutoRun);\n    resetBtn.addEventListener('click', resetAlgorithm);\n\n    let autoRunInterval = null;\n    function toggleAutoRun(){\n      const pressed = autorunBtn.getAttribute('aria-pressed') === 'true';\n      if(pressed){\n        autorunBtn.setAttribute('aria-pressed', 'false');\n        stopAutoRun();\n      } else {\n        autorunBtn.setAttribute('aria-pressed', 'true');\n        startAutoRun();\n      }\n    }\n    function startAutoRun(){\n      stopAutoRun();\n      autoRunInterval = setInterval(() => {\n        if(!stepOnce()) stopAutoRun();\n      }, parseInt(speedInput.value,10) || 700);\n    }\n    function stopAutoRun(){\n      autorunBtn.setAttribute('aria-pressed', 'false');\n      if(autoRunInterval) { clearInterval(autoRunInterval); autoRunInterval = null; }\n    }\n\n    // SVG setup to fit parent\n    function resizeSVG(){\n      const r = svg.getBoundingClientRect();\n      svg.setAttribute('viewBox', `0 0 ${r.width} ${r.height}`);\n    }\n    window.addEventListener('resize', resizeSVG);\n    setTimeout(resizeSVG, 100);\n\n    // Helper: create SVG elements\n    function svgEl(tag, attrs = {}){\n      const el = document.createElementNS(NS, tag);\n      for(const k in attrs) el.setAttribute(k, attrs[k]);\n      return el;\n    }\n\n    // Add node at position\n    function addNodeAt(x,y){\n      const id = nodeIdCounter++;\n      const g = svgEl('g', { 'data-id': id, tabindex: 0 });\n      const circle = svgEl('circle', {\n        cx: x, cy: y, r: 22, class: 'node-circle'\n      });\n      const label = svgEl('text', { x, y: y-8, class: 'node-label' });\n      label.textContent = String(id);\n      const distText = svgEl('text', { x, y: y+12, class: 'node-dist' });\n      distText.textContent = '∞';\n\n      g.appendChild(circle);\n      g.appendChild(label);\n      g.appendChild(distText);\n      svg.appendChild(g);\n\n      const node = {\n        id,\n        x, y,\n        g, circle, label, distText,\n        dist: Infinity,\n        prev: null,\n        visited: false,\n        inPQ: false\n      };\n      nodes.push(node);\n      attachNodeHandlers(node);\n      updateCounts();\n      return node;\n    }\n\n    function attachNodeHandlers(node){\n      // dragging\n      let dragging = false;\n      let start = null;\n\n      function pointerDown(e){\n        if(e.pointerType) e.target.setPointerCapture(e.pointerId);\n        const pt = getSvgPoint(e);\n        start = { x: pt.x - node.x, y: pt.y - node.y };\n        dragging = true;\n        e.preventDefault();\n      }\n      function pointerMove(e){\n        if(!dragging) return;\n        const pt = getSvgPoint(e);\n        node.x = pt.x - start.x;\n        node.y = pt.y - start.y;\n        updateNodePosition(node);\n        updateEdgePositionsConnected(node);\n      }\n      function pointerUp(e){\n        dragging = false;\n        if(e.pointerType) try{ e.target.releasePointerCapture(e.pointerId); }catch(_){}\n        // If modes: handle click actions (but ignore small drags)\n        // We'll differentiate click based on mode by checking e.detail && no drag\n      }\n\n      node.g.addEventListener('pointerdown', pointerDown);\n      window.addEventListener('pointermove', pointerMove);\n      window.addEventListener('pointerup', pointerUp);\n\n      // Click / keyboard activation\n      node.g.addEventListener('click', (e) => {\n        e.stopPropagation();\n        handleNodeClick(node);\n      });\n\n      node.g.addEventListener('keydown', (e) => {\n        if(e.key === 'Enter' || e.key === ' ') {\n          e.preventDefault();\n          handleNodeClick(node);\n        }\n      });\n    }\n\n    function handleNodeClick(node){\n      if(mode === 'addEdge'){\n        if(!pendingEdgeSource){\n          pendingEdgeSource = node;\n          highlightNode(node, 'frontier');\n        } else if(pendingEdgeSource.id === node.id){\n          // cancel\n          highlightNode(node, null);\n          pendingEdgeSource = null;\n        } else {\n          // create edge between pendingEdgeSource and this node\n          const w = Math.max(0, parseFloat(edgeWeightInput.value) || 1);\n          addEdge(pendingEdgeSource, node, w);\n          highlightNode(pendingEdgeSource, null);\n          pendingEdgeSource = null;\n        }\n      } else if(mode === 'setStart'){\n        setStartNode(node);\n      } else if(mode === 'delete'){\n        deleteNode(node);\n      } else {\n        // If algorithm finished or running: allow clicking a node to display shortest path\n        if(algorithmFinished){\n          showShortestPathTo(node);\n        }\n      }\n    }\n\n    // Edge creation\n    function addEdge(aNode, bNode, weight){\n      // undirected edge\n      const id = edgeIdCounter++;\n      // draw line\n      const line = svgEl('line', {\n        x1: aNode.x, y1: aNode.y, x2: bNode.x, y2: bNode.y, class: 'edge-line', 'data-id': id\n      });\n      // weight label at midpoint\n      const midx = (aNode.x + bNode.x)/2;\n      const midy = (aNode.y + bNode.y)/2;\n      const label = svgEl('text', { x: midx, y: midy-6, class: 'edge-label' });\n      label.textContent = String(weight);\n      svg.insertBefore(line, svg.firstChild); // place under nodes\n      svg.insertBefore(label, line.nextSibling);\n\n      const edge = {\n        id, a: aNode.id, b: bNode.id, w: weight, line, label\n      };\n      edges.push(edge);\n      updateCounts();\n      attachEdgeHandlers(edge);\n      return edge;\n    }\n\n    function attachEdgeHandlers(edge){\n      const onClick = (e) => {\n        e.stopPropagation();\n        if(mode === 'delete'){\n          deleteEdge(edge);\n        } else {\n          // maybe select or highlight\n          flashEdge(edge);\n        }\n      };\n      edge.line.addEventListener('click', onClick);\n      edge.line.addEventListener('pointerdown', (e)=> e.stopPropagation());\n      edge.label.addEventListener('click', onClick);\n    }\n\n    function deleteNode(node){\n      // Remove connected edges\n      const conn = edges.filter(ed => ed.a === node.id || ed.b === node.id);\n      for(const ed of conn) deleteEdge(ed);\n      // remove svg\n      node.g.remove();\n      nodes = nodes.filter(n => n.id !== node.id);\n      updateCounts();\n    }\n\n    function deleteEdge(edge){\n      edge.line.remove();\n      edge.label.remove();\n      edges = edges.filter(e => e.id !== edge.id);\n      updateCounts();\n    }\n\n    function updateCounts(){\n      countNodesEl.textContent = nodes.length;\n      countEdgesEl.textContent = edges.length;\n    }\n\n    function highlightNode(node, kind){\n      node.circle.classList.remove('node-start','node-visited','node-frontier');\n      if(kind === 'start') node.circle.classList.add('node-start');\n      if(kind === 'visited') node.circle.classList.add('node-visited');\n      if(kind === 'frontier') node.circle.classList.add('node-frontier');\n    }\n\n    function updateNodePosition(node){\n      node.circle.setAttribute('cx', node.x);\n      node.circle.setAttribute('cy', node.y);\n      node.label.setAttribute('x', node.x);\n      node.label.setAttribute('y', node.y - 8);\n      node.distText.setAttribute('x', node.x);\n      node.distText.setAttribute('y', node.y + 12);\n    }\n\n    function updateEdgePositionsConnected(node){\n      for(const ed of edges){\n        if(ed.a === node.id || ed.b === node.id){\n          const a = nodes.find(n => n.id === ed.a);\n          const b = nodes.find(n => n.id === ed.b);\n          if(!a || !b) continue;\n          ed.line.setAttribute('x1', a.x);\n          ed.line.setAttribute('y1', a.y);\n          ed.line.setAttribute('x2', b.x);\n          ed.line.setAttribute('y2', b.y);\n          const midx = (a.x + b.x)/2;\n          const midy = (a.y + b.y)/2;\n          ed.label.setAttribute('x', midx);\n          ed.label.setAttribute('y', midy - 6);\n        }\n      }\n    }\n\n    function flashEdge(edge){\n      edge.line.classList.add('pulse');\n      setTimeout(()=> edge.line.classList.remove('pulse'), 520);\n    }\n\n    // Canvas click to add node when in addNode mode\n    svg.addEventListener('click', (e) => {\n      const pt = getSvgPoint(e);\n      if(mode === 'addNode'){\n        addNodeAt(pt.x, pt.y);\n      } else {\n        // cancel pending edge selection when clicking empty space\n        if(pendingEdgeSource){\n          highlightNode(pendingEdgeSource, null);\n          pendingEdgeSource = null;\n        }\n      }\n    });\n\n    // Utility: get SVG coordinate\n    function getSvgPoint(evt){\n      const r = svg.getBoundingClientRect();\n      return { x: evt.clientX - r.left, y: evt.clientY - r.top };\n    }\n\n    // --- Dijkstra algorithm implementation and UI wiring ---\n\n    let startNode = null;\n    let pq = []; // simple array as min-queue by dist\n    let algorithmStarted = false;\n    let algorithmFinished = false;\n    let pendingEdgeSource = null;\n\n    function setStartNode(node){\n      // clear previous\n      if(startNode) highlightNode(startNode, null);\n      startNode = node;\n      highlightNode(node, 'start');\n      startNodeEl.textContent = String(node.id);\n      resetAlgorithm();\n    }\n\n    function resetAlgorithm(){\n      // Reset node distances, prev, visited, colors\n      for(const n of nodes){\n        n.dist = Infinity;\n        n.prev = null;\n        n.visited = false;\n        n.inPQ = false;\n        n.distText.textContent = '∞';\n        n.circle.classList.remove('node-visited','node-frontier');\n      }\n      pq = [];\n      algorithmStarted = false;\n      algorithmFinished = false;\n      currentNodeEl.textContent = '—';\n      visitedCountEl.textContent = '0';\n      renderPQ();\n      stopAutoRun();\n      // keep start node visually marked\n      if(startNode) highlightNode(startNode, 'start');\n    }\n\n    function stepOnce(){\n      // If no start defined -> nothing\n      if(!startNode){ alert('Please set a start node.'); return false; }\n\n      if(!algorithmStarted){\n        // Initialize\n        for(const n of nodes){\n          n.dist = Infinity;\n          n.prev = null;\n          n.visited = false;\n          n.inPQ = false;\n          n.distText.textContent = '∞';\n          n.circle.classList.remove('node-visited','node-frontier');\n        }\n        startNode.dist = 0;\n        startNode.distText.textContent = '0';\n        startNode.inPQ = true;\n        pq = [startNode];\n        algorithmStarted = true;\n        currentNodeEl.textContent = '—';\n        renderPQ();\n      }\n\n      // If PQ empty -> finished\n      if(pq.length === 0){\n        algorithmFinished = true;\n        currentNodeEl.textContent = '—';\n        return false;\n      }\n\n      // Pop min\n      pq.sort((a,b) => a.dist - b.dist);\n      const u = pq.shift();\n      u.inPQ = false;\n      if(u.visited){\n        // skip already visited (shouldn't normally happen)\n        return true;\n      }\n      // Mark visited\n      u.visited = true;\n      highlightNode(u, 'visited');\n      currentNodeEl.textContent = String(u.id);\n      visitedCountEl.textContent = nodes.filter(n => n.visited).length;\n      renderPQ();\n\n      // Relax all neighbors\n      const neighbors = getNeighbors(u);\n      let relaxPromises = [];\n      for(const {edge, other} of neighbors){\n        if(other.visited) continue;\n        relaxPromises.push(relaxEdgeAnimation(edge, u, other));\n      }\n\n      // After all relaxations done, return true to indicate step done\n      Promise.all(relaxPromises).then(() => {\n        // finished step; check if PQ empty to set finished flag\n        if(pq.length === 0){\n          algorithmFinished = true;\n        }\n      });\n\n      return true;\n    }\n\n    function getNeighbors(node){\n      // returns array of {edge, other}\n      const out = [];\n      for(const e of edges){\n        if(e.a === node.id){\n          const other = nodes.find(n => n.id === e.b);\n          if(other) out.push({edge:e, other});\n        } else if(e.b === node.id){\n          const other = nodes.find(n => n.id === e.a);\n          if(other) out.push({edge:e, other});\n        }\n      }\n      return out;\n    }\n\n    async function relaxEdgeAnimation(edge, u, v){\n      // animate edge highlight\n      pulseEdgeVisual(edge);\n      // show potential new dist\n      const newDist = u.dist + edge.w;\n      // small delay to let animation be visible\n      await sleep(180);\n      if(newDist < v.dist){\n        // update v\n        v.dist = newDist;\n        v.prev = u.id;\n        v.distText.textContent = String(Number(newDist.toFixed(2)));\n        // add to PQ if not in\n        if(!v.inPQ && !v.visited){\n          v.inPQ = true;\n          pq.push(v);\n        }\n        // animate node color change\n        highlightNode(v, 'frontier');\n      } else {\n        // brief visual indicating no change\n        // pulse the edge differently\n        await sleep(120);\n      }\n      renderPQ();\n      return;\n    }\n\n    function pulseEdgeVisual(edge){\n      edge.line.classList.add('edge-relax');\n      setTimeout(()=> edge.line.classList.remove('edge-relax'), 420);\n    }\n\n    function renderPQ(){\n      pqEl.innerHTML = '';\n      // show sorted view\n      const view = pq.slice().sort((a,b)=>a.dist-b.dist);\n      if(view.length === 0){\n        pqEl.textContent = '(empty)';\n        return;\n      }\n      for(const n of view){\n        const div = document.createElement('div');\n        div.className = 'pq-item' + (n.visited ? ' seen' : '');\n        div.innerHTML = `<div>Node ${n.id}</div><div>${n.dist===Infinity? '∞': String(Number(n.dist.toFixed(2)))}</div>`;\n        pqEl.appendChild(div);\n      }\n    }\n\n    // Show shortest path from start to target (assumes prev pointers set)\n    function showShortestPathTo(target){\n      // Clear previous path highlights\n      for(const e of edges) e.line.style.stroke = '';\n      if(!startNode) return;\n      if(target.dist === Infinity){\n        alert('Target unreachable from start.');\n        return;\n      }\n      // reconstruct path\n      const path = [];\n      let cur = target;\n      while(cur && cur.id !== startNode.id){\n        if(cur.prev === null) break;\n        path.push(cur.id);\n        cur = nodes.find(n=>n.id===cur.prev);\n      }\n      path.push(startNode.id);\n      path.reverse();\n      // highlight edges along path\n      for(let i=0;i<path.length-1;i++){\n        const a = path[i], b = path[i+1];\n        const edge = edges.find(e => (e.a===a && e.b===b) || (e.a===b && e.b===a));\n        if(edge){\n          edge.line.style.stroke = 'rgba(255,215,115,0.95)';\n          edge.line.style.strokeWidth = 4;\n        }\n      }\n    }\n\n    // Utility sleep\n    function sleep(ms){ return new Promise(resolve=>setTimeout(resolve, ms)); }\n\n    // Simple helper to show update hints\n    function updateHints(){\n      // if pending edge selection present, show visually\n      if(pendingEdgeSource){\n        // ensure it's highlighted\n        highlightNode(pendingEdgeSource, 'frontier');\n      }\n    }\n\n    // Keyboard: press Escape to clear modes\n    window.addEventListener('keydown', (e) => {\n      if(e.key === 'Escape'){\n        setMode(null);\n      }\n    });\n\n    // Initialize with a small sample graph for convenience\n    function seedSampleGraph(){\n      // Place 6 nodes\n      const w = svg.getBoundingClientRect().width || 800;\n      const h = svg.getBoundingClientRect().height || 480;\n      const positions = [\n        {x: w*0.2, y: h*0.25},\n        {x: w*0.5, y: h*0.16},\n        {x: w*0.78, y: h*0.28},\n        {x: w*0.22, y: h*0.66},\n        {x: w*0.48, y: h*0.6},\n        {x: w*0.78, y: h*0.64}\n      ];\n      for(const p of positions) addNodeAt(p.x, p.y);\n      // Add sample edges (undirected)\n      addEdge(nodes[0], nodes[1], 7);\n      addEdge(nodes[0], nodes[3], 9);\n      addEdge(nodes[0], nodes[4], 14);\n      addEdge(nodes[1], nodes[2], 10);\n      addEdge(nodes[1], nodes[3], 15);\n      addEdge(nodes[2], nodes[4], 2);\n      addEdge(nodes[3], nodes[4], 11);\n      addEdge(nodes[4], nodes[5], 9);\n      // set a default start\n      setStartNode(nodes[0]);\n      resizeSVG();\n    }\n\n    // Remove all and seed sample\n    function clearAll(){\n      // remove elements\n      for(const n of nodes) n.g.remove();\n      for(const e of edges){\n        e.line.remove();\n        e.label.remove();\n      }\n      nodes = [];\n      edges = [];\n      nodeIdCounter = 0;\n      edgeIdCounter = 0;\n      startNode = null;\n      pendingEdgeSource = null;\n      updateCounts();\n    }\n\n    // Initialize\n    seedSampleGraph();\n\n    // Helper: for clicking blank space, deselect\n    svg.addEventListener('pointerdown', (e) => {\n      // nothing for now\n    });\n\n    // helper: when user clicks on edge label or line weight editing not implemented for simplicity\n    // but allow deletion mode for edges via clicking\n\n    // expose some functions for console debugging (optional)\n    window._dijkstra = {\n      nodes, edges, addNodeAt, addEdge, resetAlgorithm, stepOnce, startAutoRun, stopAutoRun\n    };\n\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Dijkstra’s Algorithm.\n\n**Project Overview:**\nTopic: Dijkstra’s Algorithm\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Dijkstra’s Algorithm"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "23a485b0-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:49:40.235Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Recursion",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Recursion Interactive Module — Call Stack & Tree</title>\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#60a5fa;\n      --muted:#94a3b8;\n      --card:#0b1728;\n      --success:#34d399;\n      --danger:#fb7185;\n      --glass: rgba(255,255,255,0.03);\n      --radius:12px;\n      --gap:16px; /* minimum spacing */\n    }\n    *{box-sizing:border-box}\n    html,body{height:100%}\n    body{\n      margin:0;\n      padding:24px; /* safe area margin */\n      background: linear-gradient(180deg,#07102a 0%, #071021 50%, #04101b 100%);\n      color:#e6eef8;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      line-height:1.4;\n      -webkit-user-select:none;\n    }\n\n    /* Layout */\n    .container{\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      justify-content:space-between;\n      flex-wrap:wrap;\n    }\n\n    .panel{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      border-radius:var(--radius);\n      padding:20px;\n      min-width:280px;\n      box-shadow:0 6px 24px rgba(2,6,23,0.6);\n    }\n\n    /* Left column: Info and controls */\n    .left{\n      flex:0 1 320px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    h1{\n      font-size:18px;\n      margin:0 0 6px 0;\n      color:var(--accent);\n      letter-spacing:0.2px;\n    }\n    .subtitle{\n      margin:0 0 12px 0;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    .meta-block{\n      background:var(--glass);\n      border-radius:10px;\n      padding:12px;\n    }\n    .meta-block h3{\n      margin:0 0 8px 0;\n      font-size:13px;\n      color:#cfe8ff;\n    }\n    .meta-block p{\n      margin:0;\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* Controls */\n    .controls{\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    .row{\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n    label{font-size:13px;color:var(--muted);min-width:80px}\n    input[type=\"range\"]{\n      -webkit-appearance:none;\n      width:100%;\n      height:8px;\n      background:linear-gradient(90deg,var(--accent), rgba(96,165,250,0.5));\n      border-radius:999px;\n      outline:none;\n      margin:0;\n    }\n    input[type=\"number\"]{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--muted);\n      padding:8px 10px;\n      border-radius:8px;\n      width:84px;\n    }\n    .buttons{\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n    }\n    button{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.04);\n      padding:10px 12px;\n      border-radius:10px;\n      cursor:pointer;\n      min-width:64px;\n      transition:all 160ms ease;\n      font-size:13px;\n    }\n    button.primary{\n      background:linear-gradient(180deg, var(--accent), #2186f4);\n      color:#021026;\n      border:1px solid rgba(255,255,255,0.06);\n      box-shadow:0 6px 18px rgba(33,134,244,0.12);\n    }\n    button:active{transform:translateY(1px) scale(0.998)}\n    button[disabled]{opacity:0.5;cursor:not-allowed}\n\n    /* Visual area */\n    .visual{\n      flex:1 1 640px;\n      min-width:320px;\n      display:flex;\n      gap:var(--gap);\n      flex-direction:column;\n    }\n    .stage{\n      display:flex;\n      gap:var(--gap);\n      min-height:360px;\n    }\n\n    .stack-area, .tree-area{\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:12px;\n      padding:16px;\n      flex:1 1 0;\n      min-width:280px;\n      position:relative;\n      overflow:hidden;\n    }\n    .area-title{\n      display:flex;\n      align-items:center;\n      gap:10px;\n      margin-bottom:12px;\n    }\n    .area-title h4{margin:0;font-size:14px;color:var(--accent)}\n    .area-title p{margin:0;font-size:12px;color:var(--muted)}\n\n    /* Stack frames */\n    .stack{\n      display:flex;\n      flex-direction:column-reverse;\n      gap:12px;\n      align-items:center;\n      padding-bottom:8px;\n      height:calc(100% - 36px);\n      overflow:auto;\n    }\n    .frame{\n      width:220px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015));\n      border:1px solid rgba(255,255,255,0.04);\n      padding:10px;\n      border-radius:10px;\n      color:var(--muted);\n      text-align:left;\n      transform-origin:center;\n      transition:transform 240ms cubic-bezier(.2,.9,.2,1), opacity 200ms ease;\n      box-shadow:0 8px 20px rgba(2,6,23,0.6);\n    }\n    .frame.push{\n      transform: translateY(-8px) scale(1.02);\n      opacity:0.98;\n    }\n    .frame.returning{\n      border-left:4px solid var(--success);\n      transform:translateX(6px) scale(1);\n      opacity:0.95;\n    }\n    .frame .title{font-weight:600;color:#e6f6ff;font-size:13px}\n    .frame .body{font-size:13px;color:var(--muted);margin-top:6px}\n\n    /* Tree visualization as nested nodes */\n    .tree{\n      display:block;\n      height: calc(100% - 36px);\n      overflow:auto;\n      padding:8px 4px;\n    }\n    .node{\n      display:inline-flex;\n      align-items:center;\n      gap:10px;\n      margin:6px 0;\n      transition:opacity 240ms ease, transform 240ms ease;\n      opacity:0;\n      transform:scale(0.9) translateY(6px);\n    }\n    .node.visible{\n      opacity:1;\n      transform:scale(1) translateY(0);\n    }\n    .node .circle{\n      width:46px;height:46px;border-radius:50%;\n      display:flex;align-items:center;justify-content:center;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      font-weight:700;color:var(--accent);\n      box-shadow:0 8px 18px rgba(2,6,23,0.45);\n    }\n    .node .label{color:var(--muted);font-size:13px}\n\n    .node .sub{\n      margin-left:18px;\n      border-left:2px dashed rgba(255,255,255,0.03);\n      padding-left:12px;\n    }\n\n    /* Code pane */\n    .code{\n      background:#071226;\n      border-radius:10px;\n      padding:12px;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", \"Helvetica Neue\", monospace;\n      font-size:13px;\n      color:#cfe8ff;\n      border:1px solid rgba(255,255,255,0.03);\n      margin-top:var(--gap);\n      min-height:120px;\n    }\n    .line{display:block;padding:4px 6px;border-radius:6px}\n    .lineno{display:inline-block;width:34px;color:var(--muted);font-size:12px}\n    .code .highlight{\n      background:linear-gradient(90deg, rgba(96,165,250,0.08), rgba(33,134,244,0.06));\n      color:var(--accent);\n      box-shadow:inset 0 0 0 1px rgba(96,165,250,0.04);\n    }\n\n    /* Footer / result */\n    .result{\n      margin-top:12px;\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content:flex-start;\n    }\n    .pill{\n      padding:8px 12px;border-radius:999px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03); color:var(--muted);font-size:13px;\n    }\n\n    /* Responsive */\n    @media (max-width:900px){\n      .stage{flex-direction:column}\n      .container{padding:0}\n      body{padding:16px}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"main\">\n    <div class=\"left panel\" aria-labelledby=\"module-title\">\n      <h1 id=\"module-title\">Recursion: Visualizing the Call Stack & Return Flow</h1>\n      <p class=\"subtitle\">Step through a recursive factorial function and watch calls push onto the stack, expand a recursive tree, and then return values back up.</p>\n\n      <div class=\"meta-block\" aria-labelledby=\"concept-title\">\n        <h3 id=\"concept-title\">Concept Title</h3>\n        <p>Recursion — understanding function calls, local frames, and how results bubble up through the call stack.</p>\n      </div>\n\n      <div class=\"meta-block\" aria-labelledby=\"learning-objective\">\n        <h3 id=\"learning-objective\">Learning Objective</h3>\n        <p>After interacting you should be able to predict how many frames a recursive factorial(n) call creates, visualize the order calls occur, and understand how return values are combined back to the original caller.</p>\n      </div>\n\n      <div class=\"meta-block\" aria-labelledby=\"interaction-design\">\n        <h3 id=\"interaction-design\">Interaction Design</h3>\n        <p>\n          Use the slider or number input to pick n (1–10). Press \"Step\" to advance one event, \"Back\" to reverse, or \"Run\" to animate all events. Each step either \"pushes\" a frame (a function call) or \"returns\" a value — frames animate into the stack, tree nodes fade in, and code lines are highlighted to map actions to source code.\n        </p>\n      </div>\n\n      <div class=\"controls\" aria-label=\"Controls\">\n        <div class=\"row\">\n          <label for=\"n\">n (1–10)</label>\n          <input id=\"n\" type=\"number\" min=\"1\" max=\"10\" value=\"5\" aria-label=\"Recursion input number\"/>\n        </div>\n        <div class=\"row\">\n          <label for=\"range\">Quick slider</label>\n          <input id=\"range\" type=\"range\" min=\"1\" max=\"10\" value=\"5\" aria-label=\"Recursion slider\"/>\n        </div>\n\n        <div class=\"buttons\">\n          <button id=\"stepBtn\" title=\"Advance one step\">Step</button>\n          <button id=\"backBtn\" title=\"Go back one step\">Back</button>\n          <button id=\"runBtn\" class=\"primary\" title=\"Run animation\">Run</button>\n          <button id=\"resetBtn\" title=\"Reset\">Reset</button>\n        </div>\n\n        <div class=\"row\" role=\"status\" aria-live=\"polite\" style=\"margin-top:6px\">\n          <div class=\"pill\" id=\"status\">Idle</div>\n          <div class=\"pill\" id=\"currentEvent\" style=\"background:rgba(96,165,250,0.06);color:var(--accent)\">Event: 0 / 0</div>\n        </div>\n\n        <div class=\"code\" aria-hidden=\"false\" aria-label=\"Code example\">\n          <div class=\"line\"><span class=\"lineno\">1</span> <code>function factorial(n) {</code></div>\n          <div class=\"line\"><span class=\"lineno\">2</span> <code>&nbsp;&nbsp;if (n === 1) return 1;</code></div>\n          <div class=\"line highlight\" id=\"line3\"><span class=\"lineno\">3</span> <code>&nbsp;&nbsp;let t = factorial(n - 1);</code></div>\n          <div class=\"line\"><span class=\"lineno\">4</span> <code>&nbsp;&nbsp;return n * t;</code></div>\n          <div class=\"line\"><span class=\"lineno\">5</span> <code>}</code></div>\n        </div>\n\n      </div>\n    </div>\n\n    <div class=\"visual panel\" aria-labelledby=\"visual-title\">\n      <div class=\"area-title\" id=\"visual-title\" style=\"margin-bottom:0\">\n        <h4>Interactive Visualization</h4>\n        <p style=\"margin-left:auto;color:var(--muted);font-size:13px\">Push / Return animations & code highlighting</p>\n      </div>\n\n      <div class=\"stage\">\n        <div class=\"stack-area\" aria-label=\"Call stack area\">\n          <div class=\"area-title\">\n            <h4>Call Stack</h4>\n            <p>Newest frame appears on top (bottom of column, reversed visually)</p>\n          </div>\n          <div class=\"stack\" id=\"stack\" role=\"list\" aria-live=\"polite\"></div>\n        </div>\n\n        <div class=\"tree-area\" aria-label=\"Recursion tree\">\n          <div class=\"area-title\">\n            <h4>Recursive Tree</h4>\n            <p>Each node is a call. Nodes appear when a frame is pushed; on return, node shows the return value.</p>\n          </div>\n          <div class=\"tree\" id=\"tree\" role=\"tree\"></div>\n        </div>\n      </div>\n\n      <div class=\"result\" aria-live=\"polite\">\n        <div class=\"pill\" id=\"finalResult\">Result: —</div>\n        <div class=\"pill\" id=\"framesCount\">Frames: 0</div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    /*\n      Recursion Visualizer\n      - Simulates factorial recursion and records events (push/return)\n      - Animates push: add frame to stack and node to tree\n      - Animates return: mark frame as returning, show return value on node, pop from stack\n      - Controls: step, back, run, reset\n      - Code highlight maps to events\n    */\n\n    (function(){\n      // Elements\n      const nInput = document.getElementById('n');\n      const range = document.getElementById('range');\n      const stepBtn = document.getElementById('stepBtn');\n      const backBtn = document.getElementById('backBtn');\n      const runBtn = document.getElementById('runBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const status = document.getElementById('status');\n      const curEvent = document.getElementById('currentEvent');\n      const stackEl = document.getElementById('stack');\n      const treeEl = document.getElementById('tree');\n      const finalResult = document.getElementById('finalResult');\n      const framesCount = document.getElementById('framesCount');\n      const line3 = document.getElementById('line3');\n\n      // State\n      let events = []; // {type: 'push'|'return', n: number, id: string, result?: number}\n      let pointer = -1; // index of last-applied event\n      let nodesById = new Map();\n      let framesById = new Map();\n      let running = false;\n      let playInterval = null;\n      const animationDelay = 450;\n\n      // Utilities\n      function uid(prefix='id'){\n        return prefix + Math.random().toString(36).slice(2,9);\n      }\n\n      // Build events by running a recursive function that logs actions\n      function buildEvents(n){\n        events = [];\n        function fact(x){\n          const id = uid('f');\n          events.push({type:'push', n:x, id});\n          if(x === 1){\n            events.push({type:'return', n:x, id, result:1});\n            return 1;\n          } else {\n            const sub = fact(x-1);\n            const res = x * sub;\n            events.push({type:'return', n:x, id, result:res});\n            return res;\n          }\n        }\n        const final = fact(n);\n        // After building, we have pushes and returns interleaved.\n        return {events, final};\n      }\n\n      // Render helpers\n      function createFrame(event){\n        const el = document.createElement('div');\n        el.className = 'frame push';\n        el.dataset.id = event.id;\n        el.setAttribute('role','listitem');\n        el.innerHTML = `<div class=\"title\">factorial(${event.n})</div>\n                        <div class=\"body\">state: <span class=\"state\">waiting</span></div>`;\n        return el;\n      }\n      function createNode(event){\n        const el = document.createElement('div');\n        el.className = 'node';\n        el.dataset.id = event.id;\n        el.setAttribute('role','treeitem');\n        el.innerHTML = `<div class=\"circle\">${event.n}</div>\n                        <div class=\"label\">call: factorial(${event.n})</div>`;\n        return el;\n      }\n\n      // Find insertion parent in tree for a push event:\n      // The parent is the most recent pushed node that hasn't yet had its child created for this n.\n      // We'll use the current stack order to decide parent.\n      function findParentId(){\n        // The top of stack (last element's dataset) is the parent candidate.\n        // Get latest frame in DOM\n        const frames = Array.from(stackEl.querySelectorAll('.frame'));\n        if(frames.length === 0) return null;\n        const top = frames[frames.length - 1];\n        return top ? top.dataset.id : null;\n      }\n\n      // Apply next event (pointer -> pointer+1)\n      function stepForward(){\n        if(pointer >= events.length - 1) return;\n        pointer++;\n        const ev = events[pointer];\n        curEvent.textContent = `Event: ${pointer+1} / ${events.length}`;\n        if(ev.type === 'push'){\n          status.textContent = `Pushing factorial(${ev.n})`;\n          // Add frame\n          const frame = createFrame(ev);\n          framesById.set(ev.id, frame);\n          // push visually (stack is column-reverse so we append to container)\n          stackEl.appendChild(frame);\n          // slight animation\n          requestAnimationFrame(()=> frame.classList.add('push'));\n          // Add node to tree under parent\n          const node = createNode(ev);\n          nodesById.set(ev.id, node);\n          // find parent and append into its sub container or root\n          const parentId = findParentId();\n          if(parentId && parentId !== ev.id){\n            const parentNode = nodesById.get(parentId);\n            // find or create sub container\n            let sub = parentNode.querySelector('.sub');\n            if(!sub){\n              sub = document.createElement('div');\n              sub.className = 'sub';\n              parentNode.appendChild(sub);\n            }\n            sub.appendChild(node);\n          } else {\n            treeEl.appendChild(node);\n          }\n          // reveal animation\n          setTimeout(()=>node.classList.add('visible'), 20);\n          // code highlight: show line with recursive call briefly\n          highlightLine(3);\n          updateCounts();\n        } else if(ev.type === 'return'){\n          status.textContent = `Returning ${ev.result} from factorial(${ev.n})`;\n          // mark frame as returning then remove after delay\n          const frame = framesById.get(ev.id);\n          if(frame){\n            frame.classList.remove('push');\n            frame.classList.add('returning');\n            frame.querySelector('.state').textContent = `returned ${ev.result}`;\n          }\n          // update node label to include return\n          const node = nodesById.get(ev.id);\n          if(node){\n            node.querySelector('.label').textContent = `factorial(${ev.n}) → ${ev.result}`;\n            node.classList.add('visible');\n          }\n          // Simulate a short pause to show return, then pop frame for UX\n          setTimeout(()=>{\n            if(frame && frame.parentElement) frame.parentElement.removeChild(frame);\n            // leave node visible to show final value\n            updateCounts();\n          }, animationDelay - 50);\n          // highlight multiplication/return area by briefly toggling code highlight off then on\n          highlightLine(4);\n        }\n        // Update final result if last event is a return for original call\n        const last = events[events.length - 1];\n        if(pointer === events.length - 1 && last.type === 'return'){\n          finalResult.textContent = `Result: ${last.result}`;\n        } else {\n          finalResult.textContent = `Result: —`;\n        }\n      }\n\n      function stepBackward(){\n        if(pointer < 0) return;\n        const ev = events[pointer];\n        curEvent.textContent = `Event: ${pointer} / ${events.length}`;\n        if(ev.type === 'push'){\n          // reverse pushing: remove frame and node if they exist\n          const frame = framesById.get(ev.id);\n          if(frame && frame.parentElement) frame.parentElement.removeChild(frame);\n          const node = nodesById.get(ev.id);\n          if(node && node.parentElement) node.parentElement.removeChild(node);\n          framesById.delete(ev.id);\n          nodesById.delete(ev.id);\n          status.textContent = `Undo push factorial(${ev.n})`;\n        } else if(ev.type === 'return'){\n          // reverse return: recreate the frame and reset node to pre-return\n          const frame = createFrame(ev);\n          framesById.set(ev.id, frame);\n          stackEl.appendChild(frame);\n          const node = nodesById.get(ev.id);\n          if(node){\n            node.querySelector('.label').textContent = `call: factorial(${ev.n})`;\n          } else {\n            // create node\n            const nodeNew = createNode(ev);\n            nodesById.set(ev.id, nodeNew);\n            treeEl.appendChild(nodeNew);\n            nodeNew.classList.add('visible');\n          }\n          status.textContent = `Undo return factorial(${ev.n})`;\n        }\n        pointer--;\n        // Update final result\n        const last = events[events.length - 1];\n        if(pointer >= 0 && events[pointer].type === 'return' && events[pointer].id === last.id){\n          finalResult.textContent = `Result: ${events[pointer].result}`;\n        } else {\n          finalResult.textContent = `Result: —`;\n        }\n        updateCounts();\n      }\n\n      function highlightLine(num){\n        // Blink highlight on the code line element(s)\n        line3.classList.add('highlight');\n        setTimeout(()=>line3.classList.remove('highlight'), 300);\n      }\n\n      function updateCounts(){\n        framesCount.textContent = `Frames: ${stackEl.querySelectorAll('.frame').length}`;\n      }\n\n      // Control bindings\n      function prepare(n){\n        // reset visuals and build events\n        clearAll();\n        const built = buildEvents(n);\n        events = built.events;\n        pointer = -1;\n        curEvent.textContent = `Event: 0 / ${events.length}`;\n        status.textContent = `Prepared factorial(${n}) — ${events.length} events`;\n        finalResult.textContent = `Result: —`;\n        framesCount.textContent = `Frames: 0`;\n      }\n\n      function clearAll(){\n        // clear DOM elements and caches\n        stackEl.innerHTML = '';\n        treeEl.innerHTML = '';\n        framesById.clear();\n        nodesById.clear();\n        pointer = -1;\n        if(playInterval) {clearInterval(playInterval); playInterval = null}\n        running = false;\n        runBtn.textContent = 'Run';\n        status.textContent = 'Idle';\n      }\n\n      function runAll(){\n        if(events.length === 0) return;\n        if(running){\n          // pause\n          running = false;\n          runBtn.textContent = 'Run';\n          if(playInterval) {clearInterval(playInterval); playInterval = null}\n          status.textContent = 'Paused';\n          return;\n        }\n        running = true;\n        runBtn.textContent = 'Pause';\n        status.textContent = 'Running';\n        playInterval = setInterval(()=>{\n          if(pointer < events.length - 1){\n            stepForward();\n          } else {\n            clearInterval(playInterval);\n            playInterval = null;\n            running = false;\n            runBtn.textContent = 'Run';\n            status.textContent = 'Finished';\n          }\n        }, animationDelay);\n      }\n\n      // Wire events\n      range.addEventListener('input', (e)=>{\n        nInput.value = e.target.value;\n      });\n      nInput.addEventListener('change', (e)=>{\n        let v = Number(e.target.value);\n        if(isNaN(v)) v = 1;\n        v = Math.max(1, Math.min(10, Math.floor(v)));\n        nInput.value = v;\n        range.value = v;\n        prepare(v);\n      });\n\n      stepBtn.addEventListener('click', ()=>{\n        if(pointer < events.length - 1){\n          stepForward();\n        } else {\n          status.textContent = 'No more events';\n        }\n      });\n      backBtn.addEventListener('click', ()=>{\n        if(pointer >= 0) stepBackward();\n        else status.textContent = 'At beginning';\n      });\n      runBtn.addEventListener('click', ()=>{\n        runAll();\n      });\n      resetBtn.addEventListener('click', ()=>{\n        const v = Number(nInput.value) || 1;\n        clearAll();\n        prepare(v);\n      });\n\n      // Keyboard accessibility: space to step\n      document.addEventListener('keydown',(e)=>{\n        if(e.key === ' ' && document.activeElement.tagName !== 'INPUT'){\n          e.preventDefault();\n          stepBtn.click();\n        }\n      });\n\n      // Initialize\n      (function init(){\n        const v = Number(nInput.value) || 5;\n        range.value = v;\n        prepare(v);\n      })();\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Recursion.\n\n**Project Overview:**\nTopic: Recursion\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Recursion"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "267ef5e0-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:49:45.022Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Divide and Conquer",
    "answer": {
      "role": "assistant",
      "content": "Concept Title:\nDivide and Conquer — Visualizing recursive splitting and merging (merge-sort style)\n\nLearning Objective:\nAfter interacting with this module, users will be able to:\n- Understand the core idea of divide and conquer: recursively break a problem into smaller subproblems, solve each, and combine their solutions.\n- See how a problem (array) is split into subranges and how merging combines sorted subranges.\n- Trace the recursion order (calls and returns) and relate it to visible changes in the data structure.\n\nInteraction Design:\n- Input & Controls:\n  - A numeric array input (comma-separated) and a \"Randomize\" button to create test arrays.\n  - Play/Pause button to run an automatic animation of the divide-and-conquer process.\n  - Step Forward / Step Back buttons to navigate one recorded step at a time.\n  - Speed slider to adjust animation duration.\n  - Reset button to return to the original array.\n- Visual Feedback:\n  - The array is shown as horizontal bars. Bar height represents value; the bar label shows the number.\n  - When a recursive call \"splits\" a range, that range's bars are outlined and colored (split highlight).\n  - A recursion-call panel (call stack / tree-like list) displays active ranges (e.g., [0..7]) in the order calls are made; the currently executing call is highlighted.\n  - During \"merge\" steps, bars move (animated) into their merged positions and colors change to indicate the copy/merge operations.\n  - The UI animates bar positions and heights using CSS transitions for smooth motion. Buttons and slider provide immediate response and accessible focus outlines.\n- How this reinforces understanding:\n  - The split highlights show the \"divide\" phase — ranges get smaller until base cases.\n  - The recursion-call panel shows the order of calls and returns (helps map time to the call tree).\n  - Merge animations show how results of subproblems are combined into larger sorted ranges, demonstrating \"conquer\" + \"combine\".\n\nLayout Description:\n- Safe area: the whole layout uses 24px padding on all sides of the viewport to meet the safe area margin requirement.\n- Overall structure: a responsive two-column layout on wide screens and stacked layout on narrow screens:\n  - Top: Title and one-sentence objective.\n  - Main area (flex container with gap 24px):\n    - Left (visual stage, flexible): array visualization area with bars, and beneath it a compact status line that indicates current step and stage (Split/Merge).\n    - Right (controls column, fixed min-width): form controls (input field, randomize, Play/Pause, Step Back/Forward, Reset, speed slider) arranged vertically with at least 16px spacing between interactive elements. The recursion-call panel is below controls, scrollable if long.\n- Spacing and accessibility:\n  - Minimum spacing between interactive controls is 16px (implemented via gap and margins).\n  - Controls are keyboard-accessible; elements have accessible labels (label elements and aria attributes).\n  - Color choices use clear contrast for highlights; focus outlines are preserved.\n- Responsiveness:\n  - On narrow screens, the right column stacks below the visual stage; layout uses flexbox and media queries to adjust.\n  - Bar sizes and container scales with available width; values remain readable.\n\nImplementation:\nBelow is a self-contained HTML/CSS/JS module (no external libraries or assets). Copy into a .html file and open in a modern browser.\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Divide and Conquer — Interactive Module</title>\n  <style>\n    :root{\n      --safe-pad: 24px;\n      --gap: 24px;\n      --min-gap: 16px;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --muted: #9aa6bb;\n      --accent: #3ddc97;\n      --accent-2: #67b7ff;\n      --danger: #ff6b6b;\n      --bar-bg: linear-gradient(180deg,#1f2937,#111827);\n      --max-bars: 20;\n      --control-width: 320px;\n      --radius: 10px;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      font-family: Inter, Roboto, system-ui, -apple-system, \"Segoe UI\", \"Helvetica Neue\", Arial;\n      background: linear-gradient(180deg,#071025 0%, #04101a 100%);\n      color: #e6eef8;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    /* Safe area padding 24px on all sides */\n    .app {\n      padding: var(--safe-pad);\n      box-sizing: border-box;\n      min-height: 100vh;\n      display: flex;\n      flex-direction: column;\n      gap: 20px;\n    }\n\n    header {\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      max-width: 100%;\n    }\n    h1 {\n      margin:0;\n      font-size:20px;\n      font-weight:600;\n      letter-spacing: -0.2px;\n    }\n    .subtitle {\n      margin:0;\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    main {\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      width:100%;\n    }\n\n    /* Layout columns */\n    .stage {\n      flex:1 1 0;\n      min-width:0;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n      border-radius: var(--radius);\n      padding:16px;\n      box-sizing:border-box;\n      box-shadow: 0 6px 16px rgba(2,6,23,0.6),"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Divide and Conquer.\n\n**Project Overview:**\nTopic: Divide and Conquer\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Divide and Conquer"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "27dd4d60-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:49:47.318Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Bellman-Ford Algorithm",
    "answer": {
      "role": "assistant",
      "content": "Below is a single self-contained HTML file that implements an interactive learning module for the Bellman-Ford Algorithm. The page itself includes the required descriptive sections (Concept Title, Learning Objective, Interaction Design, Layout Description) and a hands-on interactive canvas where you can add nodes and edges, run the algorithm step-by-step or autoplay, and observe relaxations and negative cycle detection through animations and visual feedback.\n\nCopy the entire contents into an .html file and open it in a modern browser. The implementation uses only vanilla HTML, CSS and JavaScript.\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Bellman-Ford Interactive Module</title>\n  <style>\n    :root{\n      --safe-padding: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #4f9cff;\n      --accent-2: #7bffb2;\n      --muted: #99a0b0;\n      --danger: #ff6b6b;\n      --glass: rgba(255,255,255,0.03);\n    }\n\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071028 0%, #071523 60%);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      color:#e6eef8;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n\n    /* Safe area */\n    .app {\n      padding: var(--safe-padding);\n      box-sizing:border-box;\n      min-height:100vh;\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n    }\n\n    /* Layout: left column controls + explanation, right column canvas */\n    .left {\n      width:380px;\n      min-width:260px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:20px;\n      box-sizing:border-box;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:16px;\n    }\n\n    .right {\n      flex:1;\n      min-width:320px;\n      display:flex;\n      flex-direction:column;\n      gap:16px;\n    }\n\n    h1{\n      margin:0;\n      font-size:18px;\n      letter-spacing:0.2px;\n    }\n\n    .card-title{\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    .section {\n      background:var(--glass);\n      padding:12px;\n      border-radius:10px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n\n    .controls {\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n\n    .btn-row {\n      display:flex;\n      flex-wrap:wrap;\n      gap:12px;\n    }\n\n    button {\n      background:transparent;\n      color:var(--accent-2);\n      border:1px solid rgba(127,170,255,0.08);\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      font-size:13px;\n      min-height:40px;\n      transition:transform .12s ease, background .12s;\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n    }\n    button:hover{ transform:translateY(-2px); background:rgba(127,170,255,0.02); }\n    button.primary{\n      background:linear-gradient(90deg,var(--accent),#7fceff22);\n      color:#031029;\n      border:none;\n      box-shadow:0 6px 18px rgba(79,156,255,0.06);\n    }\n    button.danger{\n      background:linear-gradient(90deg,#ff8b8b22,#ff6b6b11);\n      color:#fff;\n      border:none;\n    }\n\n    .small {\n      font-size:13px;\n      padding:6px 8px;\n      min-height:36px;\n    }\n\n    label { font-size:13px; color:var(--muted); }\n\n    .controls .row {\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n\n    /* Canvas area */\n    .canvas-wrap{\n      background: linear-gradient(180deg,#071428 0%, #031828 100%);\n      border-radius:12px;\n      padding:12px;\n      min-height:420px;\n      position:relative;\n      overflow:hidden;\n      box-shadow:inset 0 1px 0 rgba(255,255,255,0.02);\n    }\n\n    svg {\n      width:100%;\n      height:420px;\n      display:block;\n      touch-action:none;\n    }\n\n    .panel-bottom {\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      flex-wrap:wrap;\n    }\n\n    .table {\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      padding:10px;\n      border-radius:10px;\n      min-width:220px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n    .table .row { display:flex; justify-content:space-between; gap:8px; font-size:14px; }\n    .table .title { font-weight:700; color:var(--accent-2); }\n\n    /* Node and edge styles */\n    .node {\n      cursor:pointer;\n      transition:transform .12s ease;\n    }\n    .node circle {\n      fill: linear-gradient(180deg,#1e3a8a, #0a254a);\n      fill:#0b2244;\n      stroke:rgba(127,170,255,0.12);\n      stroke-width:2px;\n    }\n    .node text {\n      font-size:13px;\n      text-anchor:middle;\n      dominant-baseline:middle;\n      pointer-events:none;\n      fill:#e6eef8;\n      font-weight:700;\n    }\n    .node .dist {\n      font-size:12px;\n      fill:var(--muted);\n      font-weight:600;\n    }\n\n    .node.pulse circle {\n      animation: nodePulse 520ms ease forwards;\n    }\n    @keyframes nodePulse {\n      0% { transform: scale(1); filter:drop-shadow(0 0 0 rgba(127,170,255,0.0)); }\n      50% { transform: scale(1.08); filter:drop-shadow(0 8px 18px rgba(79,156,255,0.12)); }\n      100% { transform: scale(1); filter:none; }\n    }\n\n    .edge {\n      stroke:#73a6ff55;\n      stroke-width:2.4px;\n      fill:none;\n      transition:stroke .18s, stroke-width .18s;\n    }\n    .edge.highlight { stroke:#ffd166; stroke-width:3.6px; }\n    .edge.relaxed { stroke:#7bffb2; stroke-width:3.6px; }\n    .edge.bad { stroke:var(--danger); stroke-width:3.6px; }\n\n    .weight-label {\n      fill:#e2f0ff;\n      font-size:12px;\n      pointer-events:none;\n      font-weight:700;\n    }\n\n    .info {\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    .status {\n      padding:10px;\n      border-radius:10px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    .speed {\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n\n    input[type=range] { width:140px; }\n\n    /* Responsiveness */\n    @media (max-width:920px){\n      .app{ flex-direction:column; padding:16px; }\n      .left{ width:100%; min-width:auto; order:2; }\n      .right{ order:1; }\n      svg{ height:320px; }\n    }\n\n    /* Accessibility focus */\n    button:focus, .node:focus { outline: 2px dashed rgba(127,170,255,0.18); outline-offset:3px; }\n\n    .muted-block { color:var(--muted); font-size:13px; }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"main\" aria-label=\"Bellman-Ford Interactive Module\">\n    <div class=\"left\" id=\"leftPanel\">\n      <div class=\"section\" aria-hidden=\"false\">\n        <div class=\"card-title\">\n          <h1>Bellman-Ford Algorithm — Interactive Explorer</h1>\n        </div>\n        <div class=\"muted\">Single concept: shortest paths with possible negative weights &amp; negative cycle detection.</div>\n      </div>\n\n      <div class=\"section\" aria-label=\"Learning Objective\">\n        <strong>Learning Objective</strong>\n        <div class=\"muted-block\">\n          After interacting with this module you will be able to:\n          <ul>\n            <li>Run Bellman-Ford step-by-step and observe edge relaxations.</li>\n            <li>Understand why up to |V|-1 iterations are needed.</li>\n            <li>See how negative cycles are detected and visualized.</li>\n          </ul>\n        </div>\n      </div>\n\n      <div class=\"section\" aria-label=\"Interaction Design\">\n        <strong>Interaction Design</strong>\n        <div class=\"muted-block\">\n          Controls and interactions:\n          <ul>\n            <li>Add nodes by clicking \"Add Node\" then clicking the canvas, or use \"Add Sample\".</li>\n            <li>Add directed edges: activate \"Add Edge\", click source then target, then provide weight.</li>\n            <li>Drag nodes to reposition. Click a node to set it as the source (or use \"Set Source\").</li>\n            <li>Run algorithm: Step (relax a single edge), Next Iteration (complete one full pass), Play/Pause (auto-run), Reset.</li>\n            <li>Animations: edges highlight while being relaxed, nodes pulse when their distance improves. Negative cycles flash red.</li>\n          </ul>\n        </div>\n      </div>\n\n      <div class=\"section\" aria-label=\"Layout Description\">\n        <strong>Layout Description</strong>\n        <div class=\"muted-block\">\n          - Left column: controls, explanations, and status. Safe area margin 24px, minimum spacing 16px.<br>\n          - Right column: interactive SVG canvas on top and a distance table/panel below showing current distances and predecessors.<br>\n          - Responsive: columns stack on small screens; controls remain accessible with keyboard focus outlines.\n        </div>\n      </div>\n\n      <div class=\"section controls\" aria-label=\"Controls\">\n        <div class=\"btn-row\" role=\"toolbar\" aria-label=\"Graph editing controls\">\n          <button id=\"addNodeBtn\" title=\"Add Node\">Add Node</button>\n          <button id=\"addEdgeBtn\" title=\"Add Edge\">Add Edge</button>\n          <button id=\"setSourceBtn\" title=\"Set Source\">Set Source</button>\n          <button id=\"sampleBtn\" class=\"primary\" title=\"Load sample graph\">Add Sample</button>\n        </div>\n\n        <div class=\"btn-row\" role=\"toolbar\" aria-label=\"Algorithm controls\">\n          <button id=\"stepBtn\" class=\"small\">Step</button>\n          <button id=\"iterBtn\" class=\"small\">Next Iteration</button>\n          <button id=\"playBtn\" class=\"small\">Play</button>\n          <button id=\"resetBtn\" class=\"small\">Reset</button>\n          <button id=\"clearBtn\" class=\"small danger\" title=\"Clear graph\">Clear</button>\n        </div>\n\n        <div class=\"row\">\n          <label for=\"speed\">Speed</label>\n          <div class=\"speed\">\n            <input id=\"speed\" type=\"range\" min=\"100\" max=\"1200\" step=\"50\" value=\"450\" aria-label=\"Animation speed\" />\n            <div class=\"muted\" id=\"speedVal\">450ms</div>\n          </div>\n        </div>\n\n        <div class=\"status\" id=\"status\" aria-live=\"polite\">Idle. Add nodes and edges, set a source, then run the algorithm.</div>\n      </div>\n\n      <div class=\"section\" aria-label=\"Hints\">\n        <strong>Hints</strong>\n        <div class=\"muted-block\">\n          - Use negative weights to see negative cycle detection.<br>\n          - If you see \"Inf\" for a node, it's not reachable yet from the chosen source.<br>\n          - Distances and predecessors update live while relaxing edges.\n        </div>\n      </div>\n    </div>\n\n    <div class=\"right\">\n      <div class=\"canvas-wrap\" id=\"canvasWrap\">\n        <svg id=\"svgCanvas\" tabindex=\"0\" aria-label=\"Graph canvas\">\n          <defs>\n            <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"12\" refY=\"5\"\n                    orient=\"auto\" markerUnits=\"strokeWidth\">\n              <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#cfe9ff\" />\n            </marker>\n            <marker id=\"arrow-highlight\" markerWidth=\"12\" markerHeight=\"12\" refX=\"13\" refY=\"6\"\n                    orient=\"auto\" markerUnits=\"strokeWidth\">\n              <path d=\"M0,0 L12,6 L0,12 z\" fill=\"#ffd166\" />\n            </marker>\n          </defs>\n        </svg>\n      </div>\n\n      <div class=\"panel-bottom\">\n        <div class=\"table\" aria-label=\"Distance table\">\n          <div class=\"row title\"><div>Node</div><div>Distance — Predecessor</div></div>\n          <div id=\"distList\"></div>\n        </div>\n\n        <div class=\"table\" style=\"flex:1;\" aria-label=\"Algorithm info\">\n          <div class=\"row title\"><div>Algorithm</div><div>Details</div></div>\n          <div class=\"info\" id=\"algoInfo\">Iteration: 0 / ? <br> Edge index: 0 / 0</div>\n          <div style=\"height:8px;\"></div>\n          <div class=\"muted\" id=\"log\">Action log appears here.</div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    /*****************************************************************************\n     * Bellman-Ford Interactive Module\n     * - Vanilla JS, self-contained\n     * - Graph drawn on SVG; nodes draggable; edges directed with arrow markers\n     * - Modes: add node, add edge, set source, default\n     * - Controls: step, next iteration (one full pass), play/pause, reset, clear\n     * - Visual feedback: edge highlight while relaxing, node pulse on improvement,\n     *   negative cycle detection highlights a cycle in red pulsing.\n     *****************************************************************************/\n\n    (function(){\n      // Basic data structures\n      let nodes = []; // {id, x,y,svgGroup, labelEl, distEl}\n      let edges = []; // {id, u,v,weight, pathEl, labelEl}\n      let nodeIdCounter = 0;\n      let edgeIdCounter = 0;\n      let mode = null; // 'addNode' | 'addEdge' | 'setSource' | null\n      let addEdgeState = { from: null };\n      let source = null; // node id\n      const INF = 1e15;\n\n      // Bellman-Ford execution state\n      let running = false;\n      let playing = false;\n      let iteration = 0;\n      let edgeIndex = 0;\n      let relaxOrder = []; // edges order used for relaxing (array of edge indices)\n      let speed = 450;\n      let playTimer = null;\n      let negativeCycleDetected = false;\n\n      // DOM references\n      const svg = document.getElementById('svgCanvas');\n      const canvasWrap = document.getElementById('canvasWrap');\n      const addNodeBtn = document.getElementById('addNodeBtn');\n      const addEdgeBtn = document.getElementById('addEdgeBtn');\n      const setSourceBtn = document.getElementById('setSourceBtn');\n      const sampleBtn = document.getElementById('sampleBtn');\n      const stepBtn = document.getElementById('stepBtn');\n      const iterBtn = document.getElementById('iterBtn');\n      const playBtn = document.getElementById('playBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const statusEl = document.getElementById('status');\n      const distList = document.getElementById('distList');\n      const algoInfo = document.getElementById('algoInfo');\n      const logEl = document.getElementById('log');\n      const speedRange = document.getElementById('speed');\n      const speedVal = document.getElementById('speedVal');\n\n      // Initialize\n      svg.addEventListener('click', canvasClick);\n      addNodeBtn.addEventListener('click', () => setMode('addNode'));\n      addEdgeBtn.addEventListener('click', () => setMode('addEdge'));\n      setSourceBtn.addEventListener('click', () => setMode('setSource'));\n      sampleBtn.addEventListener('click', addSampleGraph);\n      stepBtn.addEventListener('click', stepOnce);\n      iterBtn.addEventListener('click', nextIteration);\n      playBtn.addEventListener('click', togglePlay);\n      resetBtn.addEventListener('click', resetAlgorithmState);\n      clearBtn.addEventListener('click', clearGraph);\n      speedRange.addEventListener('input', (e)=> {\n        speed = parseInt(e.target.value,10);\n        speedVal.textContent = speed + 'ms';\n      });\n\n      // Utility:\n      function log(msg){\n        logEl.textContent = msg;\n      }\n      function setStatus(txt){\n        statusEl.textContent = txt;\n      }\n\n      // Mode handling\n      function setMode(m){\n        mode = (mode === m ? null : m);\n        addEdgeState.from = null;\n        updateModeUI();\n      }\n      function updateModeUI(){\n        const active = (btn, name) => {\n          if(mode === name) btn.classList.add('primary');\n          else btn.classList.remove('primary');\n        };\n        active(addNodeBtn, 'addNode'); active(addEdgeBtn, 'addEdge'); active(setSourceBtn, 'setSource');\n        setStatus(mode ? 'Mode: ' + mode : 'Idle.');\n      }\n\n      // Canvas click: adding node if in addNode mode\n      function canvasClick(evt){\n        if(mode !== 'addNode') return;\n        const rect = svg.getBoundingClientRect();\n        const x = (evt.clientX - rect.left);\n        const y = (evt.clientY - rect.top);\n        addNode(x,y);\n      }\n\n      // Node creation\n      function addNode(x=80, y=80, label=null){\n        const id = 'n' + (++nodeIdCounter);\n        const group = document.createElementNS('http://www.w3.org/2000/svg','g');\n        group.setAttribute('class','node');\n        group.setAttribute('tabindex','0');\n        group.setAttribute('data-id', id);\n\n        // circle\n        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n        circle.setAttribute('cx', x);\n        circle.setAttribute('cy', y);\n        circle.setAttribute('r', 22);\n        circle.setAttribute('fill','#0b2244');\n        circle.setAttribute('stroke','#6fa9ff22');\n        group.appendChild(circle);\n\n        // label\n        const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n        text.setAttribute('x', x);\n        text.setAttribute('y', y-2);\n        text.textContent = label || id;\n        group.appendChild(text);\n\n        // distance text\n        const distText = document.createElementNS('http://www.w3.org/2000/svg','text');\n        distText.setAttribute('x', x);\n        distText.setAttribute('y', y+20);\n        distText.setAttribute('class','dist');\n        distText.textContent = 'Inf';\n        group.appendChild(distText);\n\n        svg.appendChild(group);\n\n        const node = { id, x, y, svgGroup: group, labelEl: text, distEl: distText, r:22, pred:null, dist:INF };\n        nodes.push(node);\n\n        // Interaction\n        group.addEventListener('mousedown', (e)=> startDrag(e, node));\n        group.addEventListener('click', (e)=> nodeClicked(e, node));\n        group.addEventListener('keydown', (e)=> {\n          if(e.key === 'Enter') nodeClicked(e, node);\n        });\n\n        updateDistancesList();\n        redrawAllEdges();\n        return node;\n      }\n\n      // Node click depending on mode\n      function nodeClicked(e, node){\n        e.stopPropagation();\n        if(mode === 'addEdge'){\n          if(!addEdgeState.from){\n            addEdgeState.from = node;\n            setStatus('Selected source ' + node.id + '. Now click a target node.');\n            node.svgGroup.classList.add('selected');\n            node.svgGroup.style.outline = '2px solid rgba(127,170,255,0.10)';\n          } else {\n            const from = addEdgeState.from;\n            addEdgeState.from = null;\n            // remove selected style\n            from.svgGroup.classList.remove('selected');\n            from.svgGroup.style.outline = '';\n            // prompt for weight\n            let w = prompt(`Weight for edge ${from.id} → ${node.id}`, \"1\");\n            if(w === null) { setStatus('Edge creation cancelled.'); return; }\n            w = Number(w);\n            if(isNaN(w)) { alert('Please enter a numeric weight.'); return; }\n            addEdge(from.id, node.id, w);\n            setStatus(`Added edge ${from.id} → ${node.id} (w=${w})`);\n          }\n          return;\n        }\n        if(mode === 'setSource'){\n          source = node.id;\n          setStatus('Source set to ' + source + '.');\n          updateNodeStyles();\n          updateDistancesList();\n          return;\n        }\n        // Default click: set source as well\n        source = node.id;\n        setStatus('Source set to ' + source + '.');\n        updateNodeStyles();\n        updateDistancesList();\n      }\n\n      // Dragging\n      let dragState = null;\n      function startDrag(e, node){\n        e.preventDefault();\n        const rect = svg.getBoundingClientRect();\n        const startX = e.clientX;\n        const startY = e.clientY;\n        dragState = { node, startX, startY, origX: node.x, origY: node.y };\n        window.addEventListener('mousemove', onDragMove);\n        window.addEventListener('mouseup', onDragEnd);\n      }\n      function onDragMove(e){\n        if(!dragState) return;\n        const dx = e.clientX - dragState.startX;\n        const dy = e.clientY - dragState.startY;\n        const nx = dragState.origX + dx;\n        const ny = dragState.origY + dy;\n        dragState.node.x = nx;\n        dragState.node.y = ny;\n        updateNodePosition(dragState.node);\n        redrawAllEdges();\n      }\n      function onDragEnd(){\n        dragState = null;\n        window.removeEventListener('mousemove', onDragMove);\n        window.removeEventListener('mouseup', onDragEnd);\n      }\n\n      function updateNodePosition(node){\n        const group = node.svgGroup;\n        const circle = group.querySelector('circle');\n        const text = node.labelEl;\n        const distText = node.distEl;\n        circle.setAttribute('cx', node.x);\n        circle.setAttribute('cy', node.y);\n        text.setAttribute('x', node.x);\n        text.setAttribute('y', node.y-2);\n        distText.setAttribute('x', node.x);\n        distText.setAttribute('y', node.y+20);\n      }\n\n      // Edge creation and drawing\n      function addEdge(uId, vId, weight){\n        const u = nodes.find(n=>n.id===uId);\n        const v = nodes.find(n=>n.id===vId);\n        if(!u || !v){ console.warn('Invalid nodes for edge'); return; }\n\n        const id = 'e' + (++edgeIdCounter);\n        // path\n        const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n        path.setAttribute('class','edge');\n        path.setAttribute('id', id);\n        path.setAttribute('marker-end','url(#arrow)');\n\n        // weight label\n        const label = document.createElementNS('http://www.w3.org/2000/svg','text');\n        label.setAttribute('class','weight-label');\n        label.textContent = String(weight);\n\n        svg.insertBefore(path, svg.firstChild); // edges under nodes\n        svg.appendChild(label);\n\n        const edge = { id, u:uId, v:vId, weight: Number(weight), pathEl: path, labelEl: label };\n        edges.push(edge);\n        redrawEdge(edge);\n        updateDistancesList();\n        return edge;\n      }\n\n      function redrawEdge(edge){\n        const u = nodes.find(n=>n.id===edge.u);\n        const v = nodes.find(n=>n.id===edge.v);\n        if(!u || !v) return;\n        // create a simple curved path offset a bit\n        const dx = v.x - u.x;\n        const dy = v.y - u.y;\n        const dist = Math.hypot(dx,dy);\n        const offset = Math.min(40, dist/3);\n        // perpendicular vector\n        const px = -dy/dist;\n        const py = dx/dist;\n        const mx = (u.x + v.x)/2 + px*offset;\n        const my = (u.y + v.y)/2 + py*offset;\n        const d = `M ${u.x} ${u.y} Q ${mx} ${my} ${v.x} ${v.y}`;\n        edge.pathEl.setAttribute('d', d);\n\n        // label position: at midpoint of curve using quadratic formula (t=0.5)\n        const t = 0.5;\n        const x = (1-t)*(1-t)*u.x + 2*(1-t)*t*mx + t*t*v.x;\n        const y = (1-t)*(1-t)*u.y + 2*(1-t)*t*my + t*t*v.y;\n        edge.labelEl.setAttribute('x', x);\n        edge.labelEl.setAttribute('y', y-6);\n        edge.labelEl.textContent = String(edge.weight);\n      }\n\n      function redrawAllEdges(){\n        edges.forEach(redrawEdge);\n      }\n\n      // Distances list UI\n      function updateDistancesList(){\n        distList.innerHTML = '';\n        nodes.forEach(n=>{\n          const row = document.createElement('div');\n          row.setAttribute('class','row');\n          const left = document.createElement('div'); left.textContent = n.id;\n          const right = document.createElement('div');\n          const d = (n.dist >= INF/2) ? 'Inf' : String(n.dist);\n          const p = n.pred || '-';\n          right.textContent = d + '  —  ' + p;\n          row.appendChild(left); row.appendChild(right);\n          distList.appendChild(row);\n        });\n      }\n\n      // Node visual state updates\n      function updateNodeStyles(){\n        nodes.forEach(n=>{\n          if(n.id === source){\n            n.svgGroup.querySelector('circle').setAttribute('stroke','#7bffb2');\n            n.svgGroup.querySelector('circle').setAttribute('stroke-width','3');\n          } else {\n            n.svgGroup.querySelector('circle').setAttribute('stroke','#6fa9ff22');\n            n.svgGroup.querySelector('circle').setAttribute('stroke-width','2');\n          }\n        });\n      }\n\n      // Algorithm: prepare\n      function prepareAlgorithm(){\n        resetAlgorithmState(true);\n        if(!source){ setStatus('Please set a source node first.'); return false; }\n        // init distances\n        nodes.forEach(n => { n.dist = INF; n.pred = null; });\n        const s = nodes.find(n=>n.id===source);\n        if(!s){ setStatus('Source not found.'); return false; }\n        s.dist = 0;\n        // prepare order\n        relaxOrder = edges.map((e,i)=>i); // current order: insertion order\n        iteration = 0;\n        edgeIndex = 0;\n        running = true;\n        negativeCycleDetected = false;\n        updateDistancesList();\n        updateAlgoInfo();\n        setStatus('Prepared algorithm. Ready to step.');\n        return true;\n      }\n\n      // Step a single edge relaxation\n      async function stepOnce(){\n        if(!running && !prepareAlgorithm()) return;\n        if(negativeCycleDetected){ setStatus('Negative cycle already detected. Reset to rerun.'); return; }\n        if(iteration >= Math.max(0, nodes.length - 1)){\n          // after |V|-1 iterations, run negative cycle check (one more pass)\n          await relaxEdgeForNegativeCheck();\n          return;\n        }\n        // process the current edge in the current iteration\n        const eIdx = relaxOrder[edgeIndex];\n        await animateRelaxEdge(eIdx);\n        edgeIndex++;\n        if(edgeIndex >= relaxOrder.length){\n          iteration++;\n          edgeIndex = 0;\n          setStatus(`Completed iteration ${iteration}.`);\n          // If no improvements happened in iteration, you could early stop (optional)\n        } else {\n          setStatus(`Relaxed edge ${edgeIndex}/${relaxOrder.length} in iteration ${iteration}.`);\n        }\n        updateAlgoInfo();\n      }\n\n      // Next iteration: complete the rest of edges of current iteration\n      async function nextIteration(){\n        if(!running && !prepareAlgorithm()) return;\n        if(negativeCycleDetected){ setStatus('Negative cycle already detected. Reset to rerun.'); return; }\n        if(iteration >= Math.max(0, nodes.length - 1)){\n          await relaxEdgeForNegativeCheck();\n          return;\n        }\n        setStatus('Running complete iteration ' + (iteration+1) + '...');\n        while(edgeIndex < relaxOrder.length){\n          const eIdx = relaxOrder[edgeIndex];\n          await animateRelaxEdge(eIdx);\n          edgeIndex++;\n        }\n        iteration++;\n        edgeIndex = 0;\n        setStatus(`Completed iteration ${iteration}.`);\n        updateAlgoInfo();\n      }\n\n      // Play mode: animate continuously through iterations\n      function togglePlay(){\n        if(playing){\n          playing = false;\n          playBtn.textContent = 'Play';\n          if(playTimer) { clearTimeout(playTimer); playTimer = null; }\n          setStatus('Paused.');\n          return;\n        }\n        if(!running && !prepareAlgorithm()) return;\n        playing = true;\n        playBtn.textContent = 'Pause';\n        setStatus('Auto-playing...');\n        continuePlaying();\n      }\n      function continuePlaying(){\n        if(!playing) return;\n        if(negativeCycleDetected){ playing=false; playBtn.textContent='Play'; setStatus('Detected negative cycle — paused.'); return; }\n        if(iteration >= Math.max(0, nodes.length - 1)){\n          // after |V|-1 iterations, do negative check\n          relaxEdgeForNegativeCheck().then(()=>{ playing=false; playBtn.textContent='Play'; });\n          return;\n        }\n        const eIdx = relaxOrder[edgeIndex];\n        animateRelaxEdge(eIdx).then(()=>{\n          edgeIndex++;\n          if(edgeIndex >= relaxOrder.length){\n            iteration++;\n            edgeIndex = 0;\n          }\n          updateAlgoInfo();\n          playTimer = setTimeout(continuePlaying, speed);\n        });\n      }\n\n      // Perform relaxation animation for edge index\n      function animateRelaxEdge(eIdx){\n        return new Promise((resolve)=>{\n          const edge = edges[eIdx];\n          if(!edge){ resolve(); return; }\n          const pathEl = edge.pathEl;\n          // highlight edge\n          pathEl.classList.add('highlight');\n          // change marker (arrow)\n          pathEl.setAttribute('marker-end','url(#arrow-highlight)');\n          log(`Relaxing ${edge.u} → ${edge.v} (w=${edge.weight})`);\n          updateAlgoInfo();\n\n          setTimeout(()=> {\n            // compute relaxation\n            const uNode = nodes.find(n=>n.id===edge.u);\n            const vNode = nodes.find(n=>n.id===edge.v);\n            let improved = false;\n            if(uNode && vNode && uNode.dist < INF/2){\n              const candidate = uNode.dist + Number(edge.weight);\n              if(candidate < vNode.dist){\n                vNode.dist = candidate;\n                vNode.pred = uNode.id;\n                improved = true;\n                // node pulse\n                vNode.svgGroup.classList.add('pulse');\n                setTimeout(()=> vNode.svgGroup.classList.remove('pulse'), 520);\n                // mark edge as relaxed\n                pathEl.classList.remove('highlight');\n                pathEl.classList.add('relaxed');\n                pathEl.setAttribute('marker-end','url(#arrow)');\n                // update UI\n                updateDistancesList();\n                log(`Improved ${vNode.id}: distance → ${candidate} (via ${uNode.id})`);\n              } else {\n                // no change\n                pathEl.classList.add(''); // nothing\n                log(`No change for ${edge.v}`);\n              }\n            } else {\n              log(`Cannot relax ${edge.u} → ${edge.v} (u unreachable)`);\n            }\n\n            // small pause then remove highlight, keep relaxed class if improved\n            setTimeout(()=>{\n              pathEl.classList.remove('highlight');\n              // keep .relaxed if improved; otherwise reset\n              if(!improved){\n                pathEl.classList.remove('relaxed');\n              }\n              updateAlgoInfo();\n              resolve();\n            }, speed/2);\n          }, Math.min(300, speed/2));\n        });\n      }\n\n      // Negative cycle check: one pass, detect any relaxations. If relaxation found, mark cycle.\n      async function relaxEdgeForNegativeCheck(){\n        setStatus('Checking for negative cycles...');\n        let found = false;\n        let foundEdge = null;\n        for(let i=0;i<relaxOrder.length;i++){\n          const eIdx = relaxOrder[i];\n          const edge = edges[eIdx];\n          const uNode = nodes.find(n=>n.id===edge.u);\n          const vNode = nodes.find(n=>n.id===edge.v);\n          // animate highlight\n          edge.pathEl.classList.add('highlight');\n          edge.pathEl.setAttribute('marker-end','url(#arrow-highlight)');\n          await new Promise(r => setTimeout(r, speed/2));\n          if(uNode && vNode && uNode.dist < INF/2){\n            if(uNode.dist + Number(edge.weight) < vNode.dist){\n              found = true;\n              foundEdge = edge;\n              edge.pathEl.classList.remove('highlight');\n              edge.pathEl.classList.add('bad');\n              log('Negative cycle relaxation detected at edge ' + edge.id);\n              break;\n            }\n          }\n          edge.pathEl.classList.remove('highlight');\n          edge.pathEl.setAttribute('marker-end','url(#arrow)');\n          await new Promise(r => setTimeout(r, speed/4));\n        }\n        if(found){\n          negativeCycleDetected = true;\n          setStatus('Negative cycle detected! Highlighting cycle...');\n          await highlightNegativeCycle(foundEdge);\n        } else {\n          setStatus('No negative cycle detected. Algorithm finished.');\n          running = false;\n        }\n        updateAlgoInfo();\n      }\n\n      // Follow predecessors to find a cycle and highlight it\n      async function highlightNegativeCycle(edge){\n        // attempt to locate a cycle reachable from v by following predecessors\n        const start = edge.v;\n        // To find cycle, follow pred chain and mark visited\n        let cur = start;\n        const visited = {};\n        for(let i=0;i< nodes.length*2;i++){\n          if(!cur) break;\n          if(visited[cur]){\n            // cycle found from visited[cur] to cur\n            const cycleNodes = [];\n            let nodeInCycle = cur;\n            do {\n              cycleNodes.push(nodeInCycle);\n              nodeInCycle = nodes.find(n=>n.id===nodeInCycle).pred;\n            } while(nodeInCycle && nodeInCycle !== cur && cycleNodes.length < nodes.length+2);\n            // highlight edges that connect cycle nodes\n            const cycleEdges = [];\n            for(let j=0;j<cycleNodes.length;j++){\n              const a = cycleNodes[j];\n              const b = nodes.find(n=>n.id===a).pred;\n              if(!b) continue;\n              const e = edges.find(ed => ed.u === b && ed.v === a);\n              if(e) cycleEdges.push(e);\n            }\n            // animate cycle edges pulsing red\n            cycleEdges.forEach(e=> e.pathEl.classList.add('bad'));\n            // pulse effect\n            let times = 6;\n            while(times--){\n              cycleEdges.forEach(e=> e.pathEl.style.opacity = '0.4');\n              await new Promise(r=>setTimeout(r,200));\n              cycleEdges.forEach(e=> e.pathEl.style.opacity = '1');\n              await new Promise(r=>setTimeout(r,200));\n            }\n            setStatus('Negative cycle highlighted. Reset to try again.');\n            return;\n          }\n          visited[cur] = true;\n          const n = nodes.find(no=>no.id===cur);\n          cur = n ? n.pred : null;\n        }\n        // fallback: flash the offending edge\n        const offending = edge.pathEl;\n        for(let i=0;i<6;i++){\n          offending.style.opacity = (i%2? '0.3' : '1');\n          await new Promise(r=>setTimeout(r,180));\n        }\n        setStatus('Negative cycle suspected, but cycle path could not be reconstructed.');\n      }\n\n      // Reset algorithm execution state but keep graph\n      function resetAlgorithmState(keepNodes=false){\n        if(!keepNodes){\n          nodes.forEach(n=>{ n.dist = INF; n.pred = null; });\n        } else {\n          // set distances but keep nodes (prepareAlgorithm does init)\n        }\n        running = false;\n        playing = false;\n        playBtn.textContent = 'Play';\n        if(playTimer){ clearTimeout(playTimer); playTimer = null; }\n        iteration = 0;\n        edgeIndex = 0;\n        relaxOrder = [];\n        negativeCycleDetected = false;\n        // clear edge classes\n        edges.forEach(e=>{\n          e.pathEl.classList.remove('highlight','relaxed','bad');\n          e.pathEl.style.opacity = '1';\n          e.pathEl.setAttribute('marker-end','url(#arrow)');\n        });\n        updateDistancesList();\n        updateAlgoInfo();\n        setStatus('Reset algorithm state.');\n      }\n\n      function updateAlgoInfo(){\n        algoInfo.innerHTML = `Iteration: ${iteration} / ${Math.max(0, nodes.length-1)} <br> Edge index: ${edgeIndex} / ${edges.length}`;\n      }\n\n      // Clear graph completely\n      function clearGraph(){\n        nodes.forEach(n=> svg.removeChild(n.svgGroup));\n        edges.forEach(e=> { if(e.pathEl.parentNode) svg.removeChild(e.pathEl); if(e.labelEl.parentNode) svg.removeChild(e.labelEl); });\n        nodes = []; edges = [];\n        nodeIdCounter = 0; edgeIdCounter = 0;\n        source = null;\n        resetAlgorithmState();\n        updateDistancesList();\n        setStatus('Graph cleared.');\n      }\n\n      // Sample graph with negative cycle optionally\n      function addSampleGraph(){\n        clearGraph();\n        // Add sample nodes in positions\n        const A = addNode(120,80,'A');\n        const B = addNode(300,60,'B');\n        const C = addNode(480,120,'C');\n        const D = addNode(380,260,'D');\n        const E = addNode(160,220,'E');\n\n        // edges\n        addEdge(A.id, B.id, 6);\n        addEdge(A.id, D.id, 7);\n        addEdge(B.id, C.id, 5);\n        addEdge(C.id, B.id, -2);\n        addEdge(B.id, D.id, 8);\n        addEdge(B.id, E.id, -4);\n        addEdge(D.id, E.id, 9);\n        addEdge(E.id, C.id, 7);\n        addEdge(D.id, C.id, -3);\n\n        // set source\n        source = A.id;\n        updateNodeStyles();\n        setStatus('Sample graph loaded. Source = A');\n        updateDistancesList();\n      }\n\n      // Initialize small example\n      addSampleGraph();\n\n      // Keyboard shortcuts (optional)\n      window.addEventListener('keydown', (e)=>{\n        if(e.key === 'n') setMode('addNode');\n        if(e.key === 'e') setMode('addEdge');\n        if(e.key === 's') setMode('setSource');\n        if(e.key === ' ') { e.preventDefault(); togglePlay(); }\n      });\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Bellman-Ford Algorithm.\n\n**Project Overview:**\nTopic: Bellman-Ford Algorithm\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Bellman-Ford Algorithm"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "29b6c850-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:49:50.421Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Fibonacci Sequence",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Fibonacci Sequence Module</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --min-gap: 16px;\n      --bg: #f7fafc;\n      --card: #ffffff;\n      --accent: #0b84ff;\n      --muted: #6b7280;\n      --success: #10b981;\n      --danger: #ef4444;\n      font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#f8fbff 0%, var(--bg) 100%);\n      color:#0f172a;\n    }\n\n    /* Safe area margins */\n    .app {\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height: calc(100vh - calc(var(--safe-margin) * 2));\n      display:flex;\n      flex-direction:column;\n      gap: var(--min-gap);\n    }\n\n    header {\n      display:flex;\n      align-items:baseline;\n      gap: 12px;\n      flex-wrap:wrap;\n    }\n\n    h1 {\n      margin:0;\n      font-size:1.25rem;\n      letter-spacing: -0.01em;\n    }\n\n    .meta {\n      display:flex;\n      gap: 8px;\n      align-items:center;\n      color:var(--muted);\n      font-size:0.95rem;\n    }\n\n    /* Layout: controls left, canvas right on wide screens */\n    .module {\n      display:grid;\n      grid-template-columns: 360px 1fr;\n      gap: var(--min-gap);\n      align-items:start;\n    }\n\n    @media (max-width:900px){\n      .module {\n        grid-template-columns: 1fr;\n      }\n    }\n\n    .panel {\n      background: var(--card);\n      border-radius: 12px;\n      padding:16px;\n      box-shadow: 0 2px 8px rgba(12,18,31,0.06);\n    }\n\n    /* Controls panel */\n    .controls {\n      display:flex;\n      flex-direction:column;\n      gap: var(--min-gap);\n    }\n\n    label {\n      font-size:0.9rem;\n      color:#0f172a;\n      display:block;\n      margin-bottom:6px;\n    }\n\n    .row {\n      display:flex;\n      gap: var(--min-gap);\n      align-items:center;\n    }\n\n    .row.wrap{\n      flex-wrap:wrap;\n    }\n\n    input[type=\"range\"]{\n      width:100%;\n    }\n\n    .small {\n      font-size:0.85rem;\n      color:var(--muted);\n    }\n\n    .btn {\n      display:inline-flex;\n      align-items:center;\n      justify-content:center;\n      gap:8px;\n      padding:8px 12px;\n      border-radius:8px;\n      border: 1px solid rgba(2,6,23,0.06);\n      background:linear-gradient(180deg,#ffffff,#fbfdff);\n      cursor:pointer;\n      font-weight:600;\n      color: #0b1730;\n    }\n\n    .btn:active { transform: translateY(1px); }\n\n    .btn.primary {\n      background: linear-gradient(180deg,var(--accent),#0577e6);\n      color: white;\n      border: none;\n    }\n\n    .btn.ghost {\n      background: transparent;\n      border: 1px dashed rgba(2,6,23,0.06);\n    }\n\n    input[type=\"number\"]{\n      width:92px;\n      padding:8px;\n      border-radius:8px;\n      border:1px solid #e6eefb;\n      background:#fbfdff;\n    }\n\n    .info {\n      font-size:0.95rem;\n      color:var(--muted);\n    }\n\n    ul.sequence {\n      list-style:none;\n      padding:0;\n      margin:0;\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n    }\n\n    ul.sequence li{\n      min-width:48px;\n      padding:8px;\n      border-radius:8px;\n      background:linear-gradient(180deg,#fcfeff,#f6fbff);\n      border:1px solid rgba(12,18,31,0.04);\n      text-align:center;\n      font-weight:700;\n      cursor:pointer;\n      transition: transform .12s ease, box-shadow .12s ease;\n    }\n\n    ul.sequence li:focus,\n    ul.sequence li:hover{\n      transform: translateY(-4px);\n      box-shadow: 0 6px 16px rgba(11,132,255,0.08);\n      outline:none;\n    }\n\n    ul.sequence li.selected{\n      background: linear-gradient(180deg,#e6f3ff,#d4eefe);\n      border: 1px solid rgba(11,132,255,0.18);\n      color: var(--accent);\n    }\n\n    .canvas-wrap {\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n\n    canvas{\n      width:100%;\n      background: linear-gradient(180deg,#ffffff,#fbfdff);\n      border-radius:12px;\n      border:1px solid rgba(12,18,31,0.04);\n    }\n\n    .legend {\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content:space-between;\n    }\n\n    .ratio {\n      font-weight:700;\n      font-size:1.25rem;\n      color:#0b1730;\n    }\n\n    .muted-sm {\n      color:var(--muted);\n      font-size:0.9rem;\n    }\n\n    .footer-note {\n      font-size:0.85rem;\n      color:var(--muted);\n    }\n\n    /* Accessibility focus outlines */\n    button:focus, input:focus, li:focus{\n      outline: 3px solid rgba(11,132,255,0.16);\n      outline-offset:2px;\n    }\n\n    /* spacing constraints */\n    .controls > * { margin-bottom: 0; }\n\n    /* small helper */\n    .pill {\n      padding:6px 10px;\n      border-radius:999px;\n      background:#f1f7ff;\n      border:1px solid rgba(11,132,255,0.08);\n      color:var(--accent);\n      font-weight:700;\n      font-size:0.85rem;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"main\">\n    <header>\n      <div>\n        <h1>Fibonacci Sequence — Interactive Exploration</h1>\n        <div class=\"meta\">\n          <span class=\"pill\" aria-hidden=\"true\">Hands‑on</span>\n          <span class=\"small\">One concept • Visual & numeric intuition</span>\n        </div>\n      </div>\n    </header>\n\n    <!-- Explanatory meta sections required by the design plan -->\n    <div class=\"module\" aria-labelledby=\"module-heading\">\n      <div class=\"panel controls\" aria-hidden=\"false\">\n        <section aria-labelledby=\"concept-title\">\n          <h2 id=\"concept-title\" style=\"margin:0 0 6px 0; font-size:1rem;\">Concept Title</h2>\n          <div class=\"info\">Fibonacci Sequence (recursive integer sequence where each term is the sum of the two preceding terms).</div>\n        </section>\n\n        <section aria-labelledby=\"learning-objective\">\n          <h3 id=\"learning-objective\" style=\"margin:12px 0 6px 0; font-size:0.95rem;\">Learning Objective</h3>\n          <div class=\"info\">\n            After using this module you will:\n            <ul style=\"margin:8px 0 0 18px; color:var(--muted);\">\n              <li>Generate the Fibonacci numbers and see how they grow.</li>\n              <li>Visualize the Fibonacci squares and spiral and observe how ratios converge to the golden ratio (~1.618).</li>\n              <li>Interactively change how many terms to show and watch the visual build-up step by step.</li>\n            </ul>\n          </div>\n        </section>\n\n        <section aria-labelledby=\"interaction-design\" style=\"margin-top:12px;\">\n          <h3 id=\"interaction-design\" style=\"margin:0 0 6px 0; font-size:0.95rem;\">Interaction Design</h3>\n          <div class=\"info\">\n            Controls:\n            <ul style=\"margin:8px 0 0 18px; color:var(--muted);\">\n              <li>Use the slider or number box to set how many terms are shown (2–12).</li>\n              <li>Step through terms with Next / Prev, or Play to auto-build the sequence with animated squares and spiral arcs.</li>\n              <li>Click any term in the sequence list to highlight its square on the canvas and view its ratio to the previous term.</li>\n            </ul>\n            Visual feedback:\n            <ul style=\"margin:8px 0 0 18px; color:var(--muted);\">\n              <li>Squares animate as they are added; quarter‑circle arcs draw to form the spiral.</li>\n              <li>Bar chart displays values; ratio chart shows convergence toward the golden ratio.</li>\n              <li>Hover/focus states and keyboard operability ensure accessibility.</li>\n            </ul>\n          </div>\n        </section>\n\n        <section aria-labelledby=\"layout-desc\" style=\"margin-top:12px;\">\n          <h3 id=\"layout-desc\" style=\"margin:0 0 6px 0; font-size:0.95rem;\">Layout Description</h3>\n          <div class=\"info\">\n            Spatial organization:\n            <ul style=\"margin:8px 0 0 18px; color:var(--muted);\">\n              <li>Left column (controls): textual info, slider, seeds, play/step, and the numeric sequence list for quick selection.</li>\n              <li>Right column (visual): large responsive canvas showing Fibonacci squares and spiral, with two small ratio/value charts beneath.</li>\n              <li>Safe area margins of 24px applied; minimum spacing 16px between interactive elements using gaps and padding.</li>\n            </ul>\n            Responsiveness & accessibility:\n            <ul style=\"margin:8px 0 0 18px; color:var(--muted);\">\n              <li>On narrow screens the layout stacks vertically; controls remain at top for immediate access.</li>\n              <li>All controls keyboard accessible; color contrast chosen for clarity.</li>\n            </ul>\n          </div>\n        </section>\n\n        <!-- Controls -->\n        <div style=\"margin-top:14px;\">\n          <label for=\"termsRange\">Number of terms: <span id=\"termsLabel\" class=\"pill\">8</span></label>\n          <div class=\"row\">\n            <input id=\"termsRange\" type=\"range\" min=\"2\" max=\"12\" value=\"8\" aria-valuemin=\"2\" aria-valuemax=\"12\" />\n            <input id=\"termsNumber\" type=\"number\" min=\"2\" max=\"12\" value=\"8\" aria-label=\"Number of terms\" />\n          </div>\n        </div>\n\n        <div>\n          <label for=\"seed1\">Starting seeds (optional):</label>\n          <div class=\"row wrap\">\n            <div style=\"display:flex;flex-direction:column;\">\n              <input id=\"seed1\" type=\"number\" value=\"1\" aria-label=\"Seed A\" />\n              <span class=\"small\" style=\"margin-top:6px;\">F0 (default 1)</span>\n            </div>\n            <div style=\"display:flex;flex-direction:column;\">\n              <input id=\"seed2\" type=\"number\" value=\"1\" aria-label=\"Seed B\" />\n              <span class=\"small\" style=\"margin-top:6px;\">F1 (default 1)</span>\n            </div>\n            <button id=\"applySeeds\" class=\"btn\" aria-label=\"Apply seeds\">Apply</button>\n            <button id=\"resetSeeds\" class=\"btn ghost\" aria-label=\"Reset seeds\">Reset</button>\n          </div>\n          <div class=\"small\" style=\"margin-top:8px;\">Changing seeds shows generalized Fibonacci growth (keeps other interactions the same).</div>\n        </div>\n\n        <div style=\"margin-top:8px;\">\n          <div class=\"row\">\n            <button id=\"prevBtn\" class=\"btn\" aria-label=\"Previous term\">Prev</button>\n            <button id=\"playBtn\" class=\"btn primary\" aria-pressed=\"false\" aria-label=\"Play animation\">Play</button>\n            <button id=\"nextBtn\" class=\"btn\" aria-label=\"Next term\">Next</button>\n            <button id=\"toggleSpiral\" class=\"btn\" aria-pressed=\"true\" style=\"margin-left:auto;\" aria-label=\"Toggle spiral\">Spiral ON</button>\n          </div>\n        </div>\n\n        <div style=\"margin-top:8px;\">\n          <label>Sequence:</label>\n          <ul class=\"sequence\" id=\"sequenceList\" role=\"listbox\" aria-label=\"Fibonacci terms\"></ul>\n          <div class=\"small\" style=\"margin-top:8px;\">Click a term to highlight it on the canvas and view its ratio to the previous term.</div>\n        </div>\n\n        <div style=\"margin-top:12px;\">\n          <div class=\"footer-note\">Tip: Use keyboard to focus the numeric list (Tab) and press Enter to select a term. Play will animate the squares and arcs to build the spiral step by step.</div>\n        </div>\n      </div>\n\n      <!-- Visual column -->\n      <div class=\"canvas-wrap\">\n        <div class=\"panel\" style=\"padding:12px;\">\n          <div class=\"legend\" role=\"status\" aria-live=\"polite\">\n            <div>\n              <div class=\"muted-sm\">Selected index</div>\n              <div class=\"ratio\" id=\"selectedInfo\">n=7 • F7 = 21</div>\n            </div>\n            <div style=\"text-align:right;\">\n              <div class=\"muted-sm\">Latest ratio</div>\n              <div id=\"ratioValue\" class=\"ratio\">21 / 13 ≈ 1.615</div>\n            </div>\n          </div>\n        </div>\n\n        <canvas id=\"fibCanvas\" width=\"1200\" height=\"640\" aria-label=\"Fibonacci squares and spiral visualization\"></canvas>\n\n        <div class=\"panel\" style=\"display:grid;grid-template-columns:1fr 1fr;gap:12px;\">\n          <canvas id=\"barCanvas\" width=\"600\" height=\"180\" aria-label=\"Fibonacci bar chart\"></canvas>\n          <canvas id=\"ratioCanvas\" width=\"600\" height=\"180\" aria-label=\"Ratio convergence chart\"></canvas>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Fibonacci Interactive Module\n    (function () {\n      // DOM elements\n      const termsRange = document.getElementById('termsRange');\n      const termsNumber = document.getElementById('termsNumber');\n      const termsLabel = document.getElementById('termsLabel');\n      const sequenceList = document.getElementById('sequenceList');\n      const seed1Input = document.getElementById('seed1');\n      const seed2Input = document.getElementById('seed2');\n      const applySeedsBtn = document.getElementById('applySeeds');\n      const resetSeedsBtn = document.getElementById('resetSeeds');\n      const prevBtn = document.getElementById('prevBtn');\n      const nextBtn = document.getElementById('nextBtn');\n      const playBtn = document.getElementById('playBtn');\n      const toggleSpiralBtn = document.getElementById('toggleSpiral');\n      const selectedInfo = document.getElementById('selectedInfo');\n      const ratioValue = document.getElementById('ratioValue');\n\n      const fibCanvas = document.getElementById('fibCanvas');\n      const barCanvas = document.getElementById('barCanvas');\n      const ratioCanvas = document.getElementById('ratioCanvas');\n\n      const fibCtx = fibCanvas.getContext('2d');\n      const barCtx = barCanvas.getContext('2d');\n      const ratioCtx = ratioCanvas.getContext('2d');\n\n      // State\n      let maxTerms = parseInt(termsRange.value, 10);\n      let seedA = parseInt(seed1Input.value, 10) || 1;\n      let seedB = parseInt(seed2Input.value, 10) || 1;\n      let sequence = [];\n      let selectedIndex = maxTerms - 1; // 0-based index\n      let isPlaying = false;\n      let playProgress = 1; // how many terms currently shown during play\n      let showSpiral = true;\n      let animationFrame = null;\n\n      // Constants\n      const MAX_CANVAS_PADDING = 24;\n      const COLORS = {\n        squareFill: '#dbeeff',\n        squareStroke: '#0b84ff',\n        selectedFill: '#e8f5ff',\n        arcStroke: '#0b84ff',\n        barFill: '#0b84ff',\n        barFade: 'rgba(11,132,255,0.18)',\n        ratioLine: '#ef4444',\n      };\n\n      // Initialize\n      function init() {\n        bindEvents();\n        updateSequence();\n        renderAll();\n      }\n\n      // Event bindings\n      function bindEvents() {\n        termsRange.addEventListener('input', onTermsChange);\n        termsNumber.addEventListener('change', onTermsNumberChange);\n        termsNumber.addEventListener('input', onTermsNumberChange);\n        applySeedsBtn.addEventListener('click', onApplySeeds);\n        resetSeedsBtn.addEventListener('click', onResetSeeds);\n        prevBtn.addEventListener('click', onPrev);\n        nextBtn.addEventListener('click', onNext);\n        playBtn.addEventListener('click', onPlayToggle);\n        toggleSpiralBtn.addEventListener('click', onToggleSpiral);\n\n        sequenceList.addEventListener('click', onSequenceClick);\n        sequenceList.addEventListener('keydown', onSequenceKeydown);\n\n        // Resize handling: keep canvases crisp for css width\n        window.addEventListener('resize', resizeCanvases);\n        resizeCanvases();\n      }\n\n      function resizeCanvases() {\n        // Make the internal canvas size match CSS pixel size * devicePixelRatio\n        [fibCanvas, barCanvas, ratioCanvas].forEach((c) => {\n          const rect = c.getBoundingClientRect();\n          const dpr = window.devicePixelRatio || 1;\n          c.width = Math.max(300, Math.floor(rect.width * dpr));\n          c.height = Math.max(150, Math.floor(rect.height * dpr));\n        });\n        renderAll();\n      }\n\n      // Update sequence array\n      function updateSequence() {\n        const n = maxTerms;\n        sequence = [];\n        if (n >= 1) sequence.push(seedA);\n        if (n >= 2) sequence.push(seedB);\n        for (let i = 2; i < n; i++) {\n          sequence[i] = sequence[i - 1] + sequence[i - 2];\n        }\n        // Cap huge values for display (no external resources)\n        selectedIndex = Math.min(selectedIndex, sequence.length - 1);\n        playProgress = Math.min(playProgress, sequence.length);\n        updateSequenceList();\n        updateSelectedInfo();\n      }\n\n      // UI: sequence list\n      function updateSequenceList() {\n        sequenceList.innerHTML = '';\n        sequence.forEach((val, idx) => {\n          const li = document.createElement('li');\n          li.tabIndex = 0;\n          li.dataset.index = idx;\n          li.textContent = val;\n          li.title = `n=${idx} • F${idx} = ${val}`;\n          if (idx === selectedIndex) li.classList.add('selected');\n          sequenceList.appendChild(li);\n        });\n      }\n\n      // Handlers\n      function onTermsChange(e) {\n        maxTerms = parseInt(e.target.value, 10);\n        termsNumber.value = maxTerms;\n        termsLabel.textContent = maxTerms;\n        updateSequence();\n        renderAll();\n      }\n\n      function onTermsNumberChange(e) {\n        let val = parseInt(e.target.value, 10);\n        if (isNaN(val)) val = maxTerms;\n        val = Math.max(2, Math.min(12, val));\n        termsNumber.value = val;\n        termsRange.value = val;\n        maxTerms = val;\n        termsLabel.textContent = val;\n        updateSequence();\n        renderAll();\n      }\n\n      function onApplySeeds() {\n        const a = parseInt(seed1Input.value, 10);\n        const b = parseInt(seed2Input.value, 10);\n        if (!Number.isFinite(a) || !Number.isFinite(b)) return;\n        seedA = a;\n        seedB = b;\n        updateSequence();\n        renderAll();\n      }\n\n      function onResetSeeds() {\n        seedA = 1; seedB = 1;\n        seed1Input.value = 1; seed2Input.value = 1;\n        updateSequence();\n        renderAll();\n      }\n\n      function onPrev() {\n        if (isPlaying) stopPlaying();\n        if (playProgress > 1) {\n          playProgress = Math.max(1, playProgress - 1);\n        } else {\n          // shift selection left\n          selectedIndex = Math.max(0, selectedIndex - 1);\n        }\n        updateSelectedInfo();\n        renderAll();\n      }\n\n      function onNext() {\n        if (isPlaying) stopPlaying();\n        if (playProgress < sequence.length) {\n          playProgress = Math.min(sequence.length, playProgress + 1);\n        } else {\n          selectedIndex = Math.min(sequence.length - 1, selectedIndex + 1);\n        }\n        updateSelectedInfo();\n        renderAll();\n      }\n\n      function onPlayToggle() {\n        if (isPlaying) {\n          stopPlaying();\n        } else {\n          startPlaying();\n        }\n      }\n\n      function startPlaying() {\n        isPlaying = true;\n        playBtn.textContent = 'Pause';\n        playBtn.classList.add('primary');\n        playBtn.setAttribute('aria-pressed', 'true');\n        playProgress = 1;\n        animateBuild();\n      }\n\n      function stopPlaying() {\n        isPlaying = false;\n        playBtn.textContent = 'Play';\n        playBtn.classList.remove('primary');\n        playBtn.setAttribute('aria-pressed', 'false');\n        if (animationFrame) {\n          cancelAnimationFrame(animationFrame);\n          animationFrame = null;\n        }\n      }\n\n      function onToggleSpiral() {\n        showSpiral = !showSpiral;\n        toggleSpiralBtn.textContent = showSpiral ? 'Spiral ON' : 'Spiral OFF';\n        toggleSpiralBtn.setAttribute('aria-pressed', String(showSpiral));\n        renderAll();\n      }\n\n      function onSequenceClick(e) {\n        const li = e.target.closest('li');\n        if (!li) return;\n        const idx = parseInt(li.dataset.index, 10);\n        selectedIndex = idx;\n        if (isPlaying) stopPlaying();\n        updateSequenceList();\n        updateSelectedInfo();\n        renderAll();\n      }\n\n      function onSequenceKeydown(e) {\n        const li = document.activeElement;\n        if (!li || li.tagName !== 'LI') return;\n        const idx = parseInt(li.dataset.index, 10);\n        if (e.key === 'Enter' || e.key === ' ') {\n          selectedIndex = idx;\n          updateSequenceList();\n          updateSelectedInfo();\n          renderAll();\n          e.preventDefault();\n        } else if (e.key === 'ArrowRight') {\n          const next = li.nextElementSibling;\n          if (next) next.focus();\n        } else if (e.key === 'ArrowLeft') {\n          const prev = li.previousElementSibling;\n          if (prev) prev.focus();\n        }\n      }\n\n      // Selection info\n      function updateSelectedInfo() {\n        if (!sequence.length) {\n          selectedInfo.textContent = '—';\n          ratioValue.textContent = '—';\n          return;\n        }\n        const idx = selectedIndex;\n        const val = sequence[idx];\n        selectedInfo.textContent = `n=${idx} • F${idx} = ${val}`;\n        if (idx >= 1) {\n          const prev = sequence[idx - 1];\n          const ratio = (val / prev);\n          ratioValue.textContent = `${val} / ${prev} ≈ ${ratio.toFixed(6)}`;\n        } else {\n          ratioValue.textContent = 'No previous term';\n        }\n      }\n\n      // Build animation: animate adding squares one by one\n      function animateBuild() {\n        const target = sequence.length;\n        if (!isPlaying) return;\n        if (playProgress >= target) {\n          // stop at end\n          isPlaying = false;\n          playBtn.textContent = 'Play';\n          playBtn.classList.remove('primary');\n          playBtn.setAttribute('aria-pressed', 'false');\n          return;\n        }\n        playProgress++;\n        // animate drawing until next increment or stop\n        renderAll(true);\n        // schedule next step after a delay\n        setTimeout(() => {\n          if (isPlaying) {\n            animateBuild();\n          }\n        }, 700); // pause to appreciate each step\n      }\n\n      // Rendering: orchestrates canvas drawings\n      function renderAll(animated = false) {\n        updateSelectedInfo();\n        updateSequenceList();\n        drawFibCanvas(animated);\n        drawBarChart();\n        drawRatioChart();\n      }\n\n      // Drawing Fibonacci squares & spirals\n      function drawFibCanvas(animated = false) {\n        const ctx = fibCtx;\n        const dpr = window.devicePixelRatio || 1;\n        const width = fibCanvas.width;\n        const height = fibCanvas.height;\n        ctx.clearRect(0, 0, width, height);\n        ctx.save();\n        ctx.scale(dpr, dpr);\n\n        // CSS size (logical)\n        const cssW = width / dpr;\n        const cssH = height / dpr;\n        // compute scale factor so the largest square fits comfortably\n        const visibleCount = Math.max(1, Math.min(sequence.length, playProgress));\n        const values = sequence.slice(0, visibleCount);\n        const maxVal = Math.max(...values, 1);\n\n        // Determine layout scale. We'll map largest side to at most ~40% of min dimension.\n        const padding = MAX_CANVAS_PADDING;\n        const available = Math.min(cssW, cssH) - padding * 2;\n        const maxSidePx = Math.max(available * 0.5, 40);\n        const scale = maxSidePx / maxVal;\n\n        // Center starting point\n        let centerX = cssW / 2;\n        let centerY = cssH / 2;\n\n        // We'll place squares in a spiral: start with first square at center.\n        // We'll keep track of the bounding box (for adjusting positions).\n        let squares = []; // {x,y,size,dir}\n        // Directions sequence: 0:right,1:up,2:left,3:down (clockwise)\n        // Placement algorithm: each new square adjacent to previous, rotating direction.\n        // For visual clarity, we start first square centered, then place next to its right, etc.\n\n        // Compute scaled sizes\n        const sizes = values.map(v => Math.max(2, v * scale));\n\n        // Start with first square at origin (0,0). We'll later translate to center.\n        let x = 0, y = 0;\n        // Keep track of current bounding box\n        let minX = 0, minY = 0, maxX = sizes[0], maxY = sizes[0];\n\n        // Store first square\n        squares.push({ x: 0, y: 0, s: sizes[0], dir: 0 });\n\n        for (let i = 1; i < sizes.length; i++) {\n          const s = sizes[i];\n          const prev = squares[i - 1];\n          // direction rotates: right, up, left, down, right...\n          const dir = (i - 1) % 4;\n          let nx = prev.x, ny = prev.y;\n          if (dir === 0) {\n            // right: place to the right of prev\n            nx = prev.x + prev.s;\n            ny = prev.y + (prev.s - s);\n          } else if (dir === 1) {\n            // up\n            nx = prev.x + (prev.s - s);\n            ny = prev.y - s;\n          } else if (dir === 2) {\n            // left\n            nx = prev.x - s;\n            ny = prev.y + (prev.s - s);\n          } else if (dir === 3) {\n            // down\n            nx = prev.x + (prev.s - s);\n            ny = prev.y + prev.s;\n          }\n          squares.push({ x: nx, y: ny, s: s, dir: (dir + 1) % 4 });\n          minX = Math.min(minX, nx);\n          minY = Math.min(minY, ny);\n          maxX = Math.max(maxX, nx + s);\n          maxY = Math.max(maxY, ny + s);\n        }\n\n        // Translate to center in canvas\n        const totalW = maxX - minX;\n        const totalH = maxY - minY;\n        const offsetX = centerX - (minX + totalW / 2);\n        const offsetY = centerY - (minY + totalH / 2);\n\n        // Drawing squares\n        ctx.lineWidth = 1.4;\n        ctx.strokeStyle = COLORS.squareStroke;\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.font = 'bold 12px system-ui, sans-serif';\n\n        // Draw grid background subtle\n        ctx.fillStyle = '#f7fbff';\n        ctx.fillRect(0, 0, cssW, cssH);\n\n        // Optionally animate: show each square with a scale effect\n        const now = performance.now();\n\n        for (let i = 0; i < squares.length; i++) {\n          const sq = squares[i];\n          const drawX = sq.x + offsetX;\n          const drawY = sq.y + offsetY;\n          const size = sq.s;\n\n          // Determine visibility based on playProgress\n          if (i >= playProgress) break;\n\n          // Animation for the newest square if playing and animated flag is set\n          let animProgress = 1;\n          if (animated && isPlaying && i === playProgress - 1) {\n            // use a smooth scale in based on time\n            const t = Math.min(1, ((now % 1000) / 600));\n            animProgress = easeOutCubic(t);\n          }\n\n          const drawS = size * animProgress;\n          const drawCX = drawX + (size - drawS) / 2;\n          const drawCY = drawY + (size - drawS) / 2;\n\n          // Fill\n          ctx.fillStyle = (i === selectedIndex) ? COLORS.selectedFill : COLORS.squareFill;\n          roundRect(ctx, drawCX, drawCY, drawS, drawS, 6);\n          ctx.fill();\n\n          // Stroke\n          ctx.strokeStyle = COLORS.squareStroke;\n          ctx.strokeRect(drawCX + 0.5, drawCY + 0.5, drawS - 1, drawS - 1);\n\n          // Value label\n          ctx.fillStyle = '#0b1730';\n          ctx.font = `${Math.max(10, Math.min(16, drawS / 4))}px system-ui, sans-serif`;\n          ctx.fillText(sequence[i], drawCX + drawS / 2, drawCY + drawS / 2);\n        }\n\n        // Draw spiral arcs if enabled\n        if (showSpiral) {\n          ctx.lineWidth = 2;\n          ctx.strokeStyle = COLORS.arcStroke;\n          ctx.beginPath();\n          for (let i = 0; i < squares.length && i < playProgress; i++) {\n            const sq = squares[i];\n            const cx = sq.x + offsetX;\n            const cy = sq.y + offsetY;\n            const s = sq.s;\n\n            // Arc center and radius depend on dir pattern; we'll draw quarter circles inside each square.\n            // Determine arc center/angles for each placement step\n            const dir = (i - 1) % 4;\n            // For consistent spiral, compute arc center at the corner opposite rotation\n            let arcCx, arcCy, startAng, endAng, r;\n            if (i === 0) {\n              // first square - draw a tiny arc\n              arcCx = cx + s;\n              arcCy = cy + s;\n              startAng = Math.PI;\n              endAng = 1.5 * Math.PI;\n              r = s;\n            } else {\n              // Use square position and direction to compute appropriate arc\n              // We can approximate: place quarter circle inside this square connecting to previous square\n              const dirIdx = (i - 1) % 4;\n              if (dirIdx === 0) {\n                // right: arc centered at bottom-right of square\n                arcCx = cx + s;\n                arcCy = cy + s;\n                startAng = Math.PI;\n                endAng = 1.5 * Math.PI;\n              } else if (dirIdx === 1) {\n                // up: arc centered at bottom-left\n                arcCx = cx;\n                arcCy = cy + s;\n                startAng = 1.5 * Math.PI;\n                endAng = 0;\n              } else if (dirIdx === 2) {\n                // left: arc centered at top-left\n                arcCx = cx;\n                arcCy = cy;\n                startAng = 0;\n                endAng = 0.5 * Math.PI;\n              } else {\n                // down: arc centered at top-right\n                arcCx = cx + s;\n                arcCy = cy;\n                startAng = 0.5 * Math.PI;\n                endAng = Math.PI;\n              }\n              r = s;\n            }\n            // Draw arc with slight animation if newest\n            if (animated && isPlaying && i === playProgress - 1) {\n              const t = Math.min(1, ((now % 1000) / 600));\n              const eased = easeOutCubic(t);\n              // interpolate angle range\n              const mid = startAng + (endAng - startAng) * eased;\n              ctx.beginPath();\n              ctx.arc(arcCx, arcCy, r, startAng, mid);\n              ctx.stroke();\n            } else {\n              ctx.beginPath();\n              ctx.arc(arcCx, arcCy, r, startAng, endAng);\n              ctx.stroke();\n            }\n          }\n        }\n\n        ctx.restore();\n      }\n\n      // Simple rounded rectangle helper\n      function roundRect(ctx, x, y, w, h, r) {\n        const radius = Math.min(r, w / 2, h / 2);\n        ctx.beginPath();\n        ctx.moveTo(x + radius, y);\n        ctx.arcTo(x + w, y, x + w, y + h, radius);\n        ctx.arcTo(x + w, y + h, x, y + h, radius);\n        ctx.arcTo(x, y + h, x, y, radius);\n        ctx.arcTo(x, y, x + w, y, radius);\n        ctx.closePath();\n      }\n\n      // Bar chart for values\n      function drawBarChart() {\n        const ctx = barCtx;\n        const dpr = window.devicePixelRatio || 1;\n        const W = barCanvas.width;\n        const H = barCanvas.height;\n        ctx.clearRect(0, 0, W, H);\n        ctx.save();\n        ctx.scale(dpr, dpr);\n\n        const cssW = W / dpr;\n        const cssH = H / dpr;\n        ctx.fillStyle = '#ffffff';\n        ctx.fillRect(0, 0, cssW, cssH);\n\n        const visible = sequence.slice(0, playProgress);\n        if (!visible.length) {\n          ctx.restore();\n          return;\n        }\n        const maxVal = Math.max(...visible);\n        const padding = 12;\n        const barGap = 8;\n        const barWidth = (cssW - padding * 2 - barGap * (visible.length - 1)) / visible.length;\n\n        for (let i = 0; i < visible.length; i++) {\n          const v = visible[i];\n          const x = padding + i * (barWidth + barGap);\n          const h = (v / maxVal) * (cssH - padding * 2);\n          const y = cssH - padding - h;\n          ctx.fillStyle = (i === selectedIndex) ? COLORS.barFade : COLORS.barFill;\n          roundRect(ctx, x, y, barWidth, h, 6);\n          ctx.fill();\n\n          // label\n          ctx.fillStyle = '#0b1730';\n          ctx.font = 'bold 11px system-ui, sans-serif';\n          ctx.textAlign = 'center';\n          ctx.fillText(v, x + barWidth / 2, y - 10);\n        }\n\n        ctx.restore();\n      }\n\n      // Ratio chart: plot Fn/F(n-1) convergence\n      function drawRatioChart() {\n        const ctx = ratioCtx;\n        const dpr = window.devicePixelRatio || 1;\n        const W = ratioCanvas.width;\n        const H = ratioCanvas.height;\n        ctx.clearRect(0, 0, W, H);\n        ctx.save();\n        ctx.scale(dpr, dpr);\n\n        const cssW = W / dpr;\n        const cssH = H / dpr;\n        ctx.fillStyle = '#ffffff';\n        ctx.fillRect(0, 0, cssW, cssH);\n\n        const visible = sequence.slice(0, playProgress);\n        const ratios = [];\n        for (let i = 1; i < visible.length; i++) {\n          ratios.push(visible[i] / visible[i - 1]);\n        }\n        if (!ratios.length) {\n          ctx.restore();\n          return;\n        }\n\n        const padding = 18;\n        const xStep = (cssW - padding * 2) / (ratios.length - 1 || 1);\n        // target/golden ratio\n        const phi = (1 + Math.sqrt(5)) / 2;\n\n        // find y scale: min and max near phi for clarity\n        let minY = Math.min(...ratios, phi);\n        let maxY = Math.max(...ratios, phi);\n        // pad slightly\n        const pad = (maxY - minY) * 0.15 || 0.1;\n        minY -= pad; maxY += pad;\n\n        // background grid lines\n        ctx.strokeStyle = '#eef5ff';\n        ctx.lineWidth = 1;\n        for (let i = 0; i <= 4; i++) {\n          const y = padding + (cssH - padding * 2) * (i / 4);\n          ctx.beginPath();\n          ctx.moveTo(padding, y);\n          ctx.lineTo(cssW - padding, y);\n          ctx.stroke();\n        }\n\n        // draw phi reference\n        const phiY = mapY(phi, minY, maxY, cssH, padding);\n        ctx.beginPath();\n        ctx.strokeStyle = '#0b84ff';\n        ctx.setLineDash([4, 6]);\n        ctx.moveTo(padding, phiY);\n        ctx.lineTo(cssW - padding, phiY);\n        ctx.stroke();\n        ctx.setLineDash([]);\n\n        // draw ratio polyline\n        ctx.beginPath();\n        ctx.strokeStyle = COLORS.ratioLine;\n        ctx.lineWidth = 2;\n        ctx.moveTo(padding, mapY(ratios[0], minY, maxY, cssH, padding));\n        for (let i = 1; i < ratios.length; i++) {\n          const x = padding + i * xStep;\n          const y = mapY(ratios[i], minY, maxY, cssH, padding);\n          ctx.lineTo(x, y);\n        }\n        ctx.stroke();\n\n        // draw points\n        ctx.fillStyle = COLORS.ratioLine;\n        for (let i = 0; i < ratios.length; i++) {\n          const x = padding + i * xStep;\n          const y = mapY(ratios[i], minY, maxY, cssH, padding);\n          ctx.beginPath();\n          ctx.arc(x, y, 3.5, 0, Math.PI * 2);\n          ctx.fill();\n        }\n\n        // labels\n        ctx.fillStyle = '#0b1730';\n        ctx.font = '12px system-ui, sans-serif';\n        ctx.textAlign = 'right';\n        ctx.fillText(`φ ≈ ${phi.toFixed(6)}`, cssW - padding, phiY - 8);\n\n        ctx.restore();\n\n        // helpers\n        function mapY(val, min, max, height, padding) {\n          const t = (val - min) / (max - min || 1);\n          return padding + (1 - t) * (height - padding * 2);\n        }\n      }\n\n      // Utilities\n      function easeOutCubic(t) {\n        return 1 - Math.pow(1 - t, 3);\n      }\n\n      // Initialize sequence from current inputs\n      init();\n\n      // Expose nothing globally\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Fibonacci Sequence.\n\n**Project Overview:**\nTopic: Fibonacci Sequence\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Fibonacci Sequence"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "2aaa9e30-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:49:52.019Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Kruskal’s Algorithm",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Kruskal’s Algorithm — Interactive Module</title>\n  <style>\n    /* Safe area margins: 24px on all sides */\n    :root {\n      --safe-margin: 24px;\n      --gap: 16px; /* Minimum spacing between interactive elements */\n      --bg: #0f1720;\n      --panel: #0b1220;\n      --muted: #98a8b9;\n      --accent: #60a5fa;\n      --success: #22c55e;\n      --danger: #ef4444;\n      --glass: rgba(255,255,255,0.04);\n      --font-family: Inter, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n\n    html,body {\n      height: 100%;\n      margin: 0;\n      padding: var(--safe-margin);\n      background: linear-gradient(180deg, #05060a 0%, #071026 100%);\n      color: #e6eef8;\n      font-family: var(--font-family);\n      box-sizing: border-box;\n      -webkit-font-smoothing: antialiased;\n      -moz-osx-font-smoothing: grayscale;\n    }\n\n    * { box-sizing: inherit; }\n    a { color: var(--accent); }\n\n    header {\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n      max-width: 1200px;\n      margin: 0 auto 16px;\n    }\n\n    h1 {\n      margin: 0;\n      font-size: 20px;\n      letter-spacing: -0.2px;\n    }\n\n    .meta {\n      display: flex;\n      gap: 12px;\n      flex-wrap: wrap;\n      align-items: center;\n      color: var(--muted);\n      font-size: 13px;\n    }\n\n    .container {\n      display: grid;\n      grid-template-columns: 1fr 360px;\n      gap: var(--gap);\n      max-width: 1200px;\n      margin: 0 auto;\n    }\n\n    /* Responsive: stack on small screens */\n    @media (max-width: 900px) {\n      .container {\n        grid-template-columns: 1fr;\n      }\n    }\n\n    /* Left: interactive canvas */\n    .canvas-panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: 10px;\n      padding: 12px;\n      min-height: 520px;\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n      align-items: stretch;\n    }\n\n    .top-controls {\n      display: flex;\n      gap: var(--gap);\n      align-items: center;\n      flex-wrap: wrap;\n    }\n\n    .btn {\n      background: var(--glass);\n      border: 1px solid rgba(255,255,255,0.04);\n      color: var(--accent);\n      padding: 8px 10px;\n      border-radius: 8px;\n      cursor: pointer;\n      font-size: 13px;\n      min-height: 40px;\n      display: inline-flex;\n      gap: 8px;\n      align-items: center;\n    }\n\n    .btn.primary {\n      background: linear-gradient(90deg, rgba(96,165,250,0.12), rgba(96,165,250,0.06));\n      color: #d9f4ff;\n      border: 1px solid rgba(96,165,250,0.18);\n    }\n\n    .btn.danger {\n      color: #ffdfe1;\n      border: 1px solid rgba(239,68,68,0.16);\n      background: linear-gradient(90deg, rgba(239,68,68,0.06), rgba(239,68,68,0.02));\n    }\n\n    .btn:disabled {\n      opacity: 0.45;\n      cursor: not-allowed;\n    }\n\n    .tools {\n      display: flex;\n      gap: var(--gap);\n      align-items: center;\n    }\n\n    .info {\n      color: var(--muted);\n      font-size: 13px;\n      padding: 8px 12px;\n      background: rgba(255,255,255,0.02);\n      border-radius: 8px;\n    }\n\n    .stage {\n      flex: 1;\n      border-radius: 8px;\n      background: radial-gradient(600px 200px at 10% 10%, rgba(96,165,250,0.02), transparent),\n                  linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      position: relative;\n      overflow: hidden;\n      min-height: 420px;\n    }\n\n    /* SVG fills the stage */\n    svg {\n      width: 100%;\n      height: 100%;\n      display: block;\n      touch-action: none;\n    }\n\n    .right-panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: 10px;\n      padding: 12px;\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n      min-height: 520px;\n    }\n\n    h2 {\n      margin: 0;\n      font-size: 16px;\n    }\n\n    .section {\n      background: rgba(255,255,255,0.02);\n      border-radius: 8px;\n      padding: 12px;\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n    }\n\n    .small {\n      font-size: 13px;\n      color: var(--muted);\n    }\n\n    .edge-list {\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n      max-height: 200px;\n      overflow: auto;\n      padding-right: 8px;\n    }\n\n    .edge-item {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      background: rgba(255,255,255,0.01);\n      padding: 8px;\n      border-radius: 6px;\n      gap: 8px;\n      font-size: 13px;\n    }\n\n    .edge-item span.weight {\n      color: var(--muted);\n      font-weight: 600;\n      padding: 4px 8px;\n      background: rgba(255,255,255,0.02);\n      border-radius: 6px;\n    }\n\n    .status {\n      display: flex;\n      gap: 8px;\n      flex-wrap: wrap;\n    }\n\n    .chip {\n      padding: 6px 8px;\n      border-radius: 999px;\n      font-size: 12px;\n      background: rgba(255,255,255,0.02);\n      color: var(--muted);\n    }\n\n    .sets {\n      display: flex;\n      gap: 8px;\n      flex-direction: column;\n      max-height: 180px;\n      overflow: auto;\n    }\n\n    .set {\n      background: rgba(255,255,255,0.02);\n      border-radius: 8px;\n      padding: 8px;\n      display: flex;\n      gap: 8px;\n      align-items: center;\n      justify-content: space-between;\n      font-size: 13px;\n    }\n\n    .legend {\n      display: flex;\n      gap: 8px;\n      align-items: center;\n      flex-wrap: wrap;\n    }\n\n    .legend .box {\n      width: 14px;\n      height: 14px;\n      border-radius: 4px;\n    }\n\n    /* Node styles (SVG) */\n    .node {\n      cursor: grab;\n    }\n\n    .node:active {\n      cursor: grabbing;\n    }\n\n    .node circle {\n      fill: rgba(255,255,255,0.04);\n      stroke: rgba(255,255,255,0.06);\n      stroke-width: 1.5px;\n    }\n\n    .node text {\n      fill: #e6eef8;\n      font-size: 12px;\n      pointer-events: none;\n    }\n\n    /* Edge base */\n    .edge {\n      stroke: rgba(255,255,255,0.08);\n      stroke-width: 3px;\n      transition: stroke 200ms, stroke-width 200ms, opacity 200ms;\n      stroke-linecap: round;\n    }\n\n    /* Edge states */\n    .edge.highlight {\n      stroke: #fbbf24; /* amber */\n      stroke-width: 5px;\n      filter: drop-shadow(0 4px 8px rgba(249,115,22,0.12));\n    }\n\n    .edge.accepted {\n      stroke: var(--success);\n      stroke-width: 5px;\n      filter: drop-shadow(0 6px 12px rgba(34,197,94,0.12));\n    }\n\n    .edge.rejected {\n      stroke: var(--danger);\n      stroke-width: 4px;\n      opacity: 0.75;\n      filter: drop-shadow(0 4px 8px rgba(239,68,68,0.06));\n    }\n\n    .weight-label {\n      font-size: 12px;\n      fill: #e6eef8;\n      pointer-events: none;\n      background: transparent;\n    }\n\n    .muted-label {\n      fill: var(--muted);\n      font-size: 12px;\n    }\n\n    .node-merged circle {\n      stroke-width: 2.5px;\n      stroke: rgba(96,165,250,0.7);\n    }\n\n    footer {\n      max-width: 1200px;\n      margin: 12px auto 0;\n      color: var(--muted);\n      font-size: 13px;\n    }\n\n    /* small animations */\n    @keyframes pulse {\n      0% { transform: scale(1); opacity: 1; }\n      50% { transform: scale(1.03); opacity: 0.95; }\n      100% { transform: scale(1); opacity: 1; }\n    }\n\n    .pulse {\n      animation: pulse 700ms ease-in-out;\n    }\n\n    /* subtle shadow container for accessibility */\n    .sr-only { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px,1px,1px,1px); white-space: nowrap; }\n  </style>\n</head>\n<body>\n  <header aria-labelledby=\"title\">\n    <h1 id=\"title\">Kruskal’s Algorithm — Minimum Spanning Tree (Interactive)</h1>\n    <div class=\"meta\">\n      <div class=\"small\"><strong>Concept Title:</strong> Kruskal’s Algorithm — Build an MST by processing edges in increasing weight.</div>\n      <div class=\"small\"><strong>Learning Objective:</strong> Understand how Kruskal’s algorithm chooses edges, uses a union-find structure to avoid cycles, and constructs the minimum spanning tree step-by-step.</div>\n    </div>\n  </header>\n\n  <div class=\"container\" role=\"main\">\n    <div class=\"canvas-panel\" aria-label=\"Graph editor and visualization\">\n      <div class=\"top-controls\" role=\"toolbar\" aria-label=\"Graph controls\">\n        <div class=\"tools\" style=\"flex:1\">\n          <button id=\"add-node-btn\" class=\"btn\" aria-pressed=\"false\" title=\"Add node by clicking canvas\">Add Node</button>\n          <button id=\"add-edge-btn\" class=\"btn\" aria-pressed=\"false\" title=\"Connect two nodes to add an edge\">Add Edge</button>\n          <button id=\"move-btn\" class=\"btn primary\" aria-pressed=\"true\" title=\"Move nodes\">Move</button>\n        </div>\n\n        <div style=\"display:flex; gap:var(--gap); align-items:center;\">\n          <button id=\"load-sample\" class=\"btn\" title=\"Load a sample graph\">Load Example</button>\n          <button id=\"clear-btn\" class=\"btn danger\" title=\"Remove all nodes and edges\">Clear</button>\n        </div>\n      </div>\n\n      <div class=\"stage\" id=\"stage\" tabindex=\"0\" aria-label=\"Graph canvas. Click to add nodes when Add Node is active. Drag nodes to move them.\">\n        <!-- SVG drawing area -->\n        <svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" role=\"img\" aria-label=\"Graph drawing\">\n          <!-- edges and nodes injected by JavaScript -->\n        </svg>\n      </div>\n\n      <div class=\"top-controls\" style=\"justify-content: space-between;\">\n        <div class=\"tools\">\n          <button id=\"step-btn\" class=\"btn primary\" title=\"Process next edge (step-by-step)\">Step</button>\n          <button id=\"play-btn\" class=\"btn\" title=\"Play through remaining steps\">Play</button>\n          <button id=\"pause-btn\" class=\"btn\" title=\"Pause auto-play\" disabled>Pause</button>\n          <button id=\"run-btn\" class=\"btn\" title=\"Run to completion\">Run to Completion</button>\n          <button id=\"reset-step-btn\" class=\"btn\" title=\"Reset Kruskal steps (keeps graph)\">Reset Steps</button>\n        </div>\n\n        <div class=\"info small\" id=\"status-text\" aria-live=\"polite\">Mode: Move — Create or edit a graph, then run Kruskal.</div>\n      </div>\n    </div>\n\n    <aside class=\"right-panel\" aria-label=\"Kruskal controls and information\">\n      <div class=\"section\" aria-live=\"polite\">\n        <h2>Algorithm Controls</h2>\n        <div class=\"small\">Edge sorting: ascending by weight. Use Step to see each decision (accept/reject).</div>\n        <div class=\"status\" style=\"margin-top:8px;\">\n          <div class=\"chip\">Edges: <span id=\"edge-count\">0</span></div>\n          <div class=\"chip\">Nodes: <span id=\"node-count\">0</span></div>\n          <div class=\"chip\">Selected MST weight: <strong id=\"mst-weight\">0</strong></div>\n        </div>\n      </div>\n\n      <div class=\"section\" aria-label=\"Edges sorted by weight\">\n        <h2>Sorted Edge List</h2>\n        <div class=\"small\">Click an edge to highlight it on the canvas.</div>\n        <div class=\"edge-list\" id=\"edge-list\" tabindex=\"0\">\n          <!-- edges injected here -->\n        </div>\n      </div>\n\n      <div class=\"section\" aria-label=\"Union-Find sets\">\n        <h2>Union-Find (Components)</h2>\n        <div class=\"small\">Components show which nodes are connected so far in the MST.</div>\n        <div class=\"sets\" id=\"sets\">\n          <!-- sets injected here -->\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <h2>Legend</h2>\n        <div class=\"legend small\">\n          <div style=\"display:flex; gap:8px; align-items:center;\">\n            <div class=\"box\" style=\"background:var(--success)\"></div><div>MST edge (accepted)</div>\n          </div>\n          <div style=\"display:flex; gap:8px; align-items:center;\">\n            <div class=\"box\" style=\"background:var(--danger)\"></div><div>Rejected edge (creates cycle)</div>\n          </div>\n          <div style=\"display:flex; gap:8px; align-items:center;\">\n            <div class=\"box\" style=\"background:#fbbf24\"></div><div>Currently processing</div>\n          </div>\n        </div>\n      </div>\n    </aside>\n  </div>\n\n  <footer>\n    <div><strong>Interaction Design:</strong> Use Add Node to place nodes by clicking inside the canvas. Use Add Edge to click a source node then a target node — a prompt will ask for the edge weight. Use Move to drag nodes. After building a graph, use Step to process the next smallest edge according to Kruskal's algorithm. On Step, the chosen edge is highlighted (amber). If it connects two different components it is accepted (turns green and animates into the MST) and the union-find components merge; otherwise it is rejected (turns red). Play runs steps automatically; Pause stops it. Reset Steps clears only the algorithm state so you can re-run Kruskal without rebuilding the graph. Visual feedback includes animated edge highlights, color transitions for accepted/rejected edges, and a live display of components and total MST weight.</div>\n    <div style=\"margin-top:8px; color:var(--muted)\"><strong>Layout Description:</strong> The page uses a two-column responsive layout. The left column (canvas-panel) contains the interactive SVG stage with top and bottom control bars for graph editing and algorithm controls. The right column (right-panel) contains algorithm controls, a sorted edge list, and a union-find view. Spacing respects a 24px safe margin and 16px minimum gaps. Controls are keyboard-focusable and labeled for assistive technologies. The design maintains clear visual hierarchy with compact sections and consistent spacing to keep focus on the canvas while providing contextual information at the side.</div>\n  </footer>\n\n  <script>\n    /**\n     * Kruskal Interactive Module (vanilla JS)\n     *\n     * Features:\n     * - Add nodes by clicking canvas (Add Node mode)\n     * - Add edges by selecting two nodes (Add Edge mode) with weight prompt\n     * - Move nodes (Move mode)\n     * - Load sample graph\n     * - Step through Kruskal's algorithm (edge-by-edge), with animations for accept/reject\n     * - Play/Pause/Run to completion\n     * - Reset algorithm state\n     * - Visual union-find sets and edge list\n     *\n     * No external libraries. Accessible buttons and basic keyboard focus.\n     */\n\n    (function () {\n      // State\n      let mode = 'move'; // 'move' | 'add-node' | 'add-edge'\n      let nodes = []; // {id, x, y}\n      let edges = []; // {id, a, b, weight, state: 'idle'|'processing'|'accepted'|'rejected'}\n      let nextNodeId = 1;\n      let nextEdgeId = 1;\n\n      // Kruskal state\n      let sortedEdges = []; // references to edges sorted by weight\n      let kruskalIndex = 0;\n      let playing = false;\n      let playTimer = null;\n      let uf = null; // union-find structure\n\n      // DOM\n      const svg = document.getElementById('svg');\n      const stage = document.getElementById('stage');\n      const addNodeBtn = document.getElementById('add-node-btn');\n      const addEdgeBtn = document.getElementById('add-edge-btn');\n      const moveBtn = document.getElementById('move-btn');\n      const loadSampleBtn = document.getElementById('load-sample');\n      const clearBtn = document.getElementById('clear-btn');\n\n      const stepBtn = document.getElementById('step-btn');\n      const playBtn = document.getElementById('play-btn');\n      const pauseBtn = document.getElementById('pause-btn');\n      const runBtn = document.getElementById('run-btn');\n      const resetStepBtn = document.getElementById('reset-step-btn');\n\n      const edgeListDiv = document.getElementById('edge-list');\n      const setsDiv = document.getElementById('sets');\n      const nodeCountSpan = document.getElementById('node-count');\n      const edgeCountSpan = document.getElementById('edge-count');\n      const statusText = document.getElementById('status-text');\n      const mstWeightSpan = document.getElementById('mst-weight');\n\n      // SVG groups\n      const edgeGroup = createSvgElement('g');\n      const edgeWeightGroup = createSvgElement('g');\n      const nodeGroup = createSvgElement('g');\n      svg.appendChild(edgeGroup);\n      svg.appendChild(edgeWeightGroup);\n      svg.appendChild(nodeGroup);\n\n      // Interaction helpers\n      let pendingEdgeSource = null;\n      let selectedNodeId = null;\n      let dragOffset = {x:0,y:0};\n      let dragging = false;\n\n      // Initialize\n      setMode('move');\n      bindEvents();\n      render();\n\n      // -------------------------\n      // Utility functions\n      function createSvgElement(tag, attrs={}) {\n        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);\n        for (const k in attrs) el.setAttribute(k, attrs[k]);\n        return el;\n      }\n\n      function setMode(m) {\n        mode = m;\n        addNodeBtn.classList.toggle('primary', mode === 'add-node');\n        addEdgeBtn.classList.toggle('primary', mode === 'add-edge');\n        moveBtn.classList.toggle('primary', mode === 'move');\n        addNodeBtn.setAttribute('aria-pressed', mode === 'add-node');\n        addEdgeBtn.setAttribute('aria-pressed', mode === 'add-edge');\n        moveBtn.setAttribute('aria-pressed', mode === 'move');\n        if (mode !== 'add-edge') pendingEdgeSource = null;\n        setStatus(`Mode: ${capitalize(mode)} — ${mode === 'move' ? 'Drag nodes to reposition.' : mode === 'add-node' ? 'Click canvas to add a node.' : 'Click two nodes to add an edge.'}`);\n      }\n\n      function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }\n\n      function setStatus(text) {\n        statusText.textContent = text;\n      }\n\n      function getSvgPoint(clientX, clientY) {\n        const pt = svg.createSVGPoint();\n        pt.x = clientX;\n        pt.y = clientY;\n        const ctm = svg.getScreenCTM().inverse();\n        const svgPt = pt.matrixTransform(ctm);\n        return {x: svgPt.x, y: svgPt.y};\n      }\n\n      function findNodeAt(x, y, radius=18) {\n        return nodes.find(n => {\n          const dx = n.x - x;\n          const dy = n.y - y;\n          return dx*dx + dy*dy <= radius*radius;\n        });\n      }\n\n      function updateCounts() {\n        nodeCountSpan.textContent = nodes.length;\n        edgeCountSpan.textContent = edges.length;\n      }\n\n      // -------------------------\n      // Node & Edge creation\n      function addNode(x, y) {\n        const id = nextNodeId++;\n        nodes.push({id, x, y});\n        render();\n        return id;\n      }\n\n      function addEdge(a, b, weight) {\n        if (a === b) return null;\n        // prevent multi-edge duplicates (a,b) or (b,a) existing\n        const exists = edges.some(e => (e.a === a && e.b === b) || (e.a === b && e.b === a));\n        if (exists) return null;\n        const id = nextEdgeId++;\n        edges.push({id, a, b, weight: Number(weight), state: 'idle'});\n        render();\n        return id;\n      }\n\n      // -------------------------\n      // Rendering\n      function render() {\n        // Clear SVG groups\n        while (edgeGroup.firstChild) edgeGroup.removeChild(edgeGroup.firstChild);\n        while (edgeWeightGroup.firstChild) edgeWeightGroup.removeChild(edgeWeightGroup.firstChild);\n        while (nodeGroup.firstChild) nodeGroup.removeChild(nodeGroup.firstChild);\n\n        // Draw edges (z-order: edges below nodes)\n        for (const e of edges) {\n          const na = nodes.find(n => n.id === e.a);\n          const nb = nodes.find(n => n.id === e.b);\n          if (!na || !nb) continue;\n          const line = createSvgElement('line', {\n            x1: na.x, y1: na.y, x2: nb.x, y2: nb.y,\n            class: 'edge ' + (e.state !== 'idle' ? e.state : ''),\n            'data-edge-id': e.id\n          });\n          line.addEventListener('click', () => focusEdge(e.id));\n          edgeGroup.appendChild(line);\n\n          // weight label positioned at midpoint\n          const mx = (na.x + nb.x) / 2;\n          const my = (na.y + nb.y) / 2;\n          const label = createSvgElement('text', {\n            x: mx + 6,\n            y: my - 6,\n            class: 'weight-label',\n            'data-edge-id': e.id\n          });\n          label.textContent = e.weight;\n          edgeWeightGroup.appendChild(label);\n        }\n\n        // Draw nodes (on top)\n        for (const n of nodes) {\n          const g = createSvgElement('g', {class: 'node', 'data-node-id': n.id});\n          g.style.cursor = (mode === 'move') ? 'grab' : 'pointer';\n          g.setAttribute('transform', `translate(${n.x}, ${n.y})`);\n          const circle = createSvgElement('circle', {r: 16});\n          g.appendChild(circle);\n          const label = createSvgElement('text', {x: 0, y: 4, 'text-anchor': 'middle'});\n          label.textContent = n.id;\n          g.appendChild(label);\n          // mouse events\n          g.addEventListener('pointerdown', onNodePointerDown);\n          g.addEventListener('click', onNodeClick);\n          nodeGroup.appendChild(g);\n        }\n\n        updateEdgeList();\n        updateSets();\n        updateCounts();\n      }\n\n      // -------------------------\n      // Edge list UI\n      function updateEdgeList() {\n        // sorted copy for UI display (by weight asc)\n        const arr = edges.slice().sort((a,b) => a.weight - b.weight || a.id - b.id);\n        sortedEdges = arr;\n        edgeListDiv.innerHTML = '';\n        for (const e of arr) {\n          const div = document.createElement('div');\n          div.className = 'edge-item';\n          div.tabIndex = 0;\n          div.setAttribute('data-edge-id', e.id);\n          div.innerHTML = `<div>(${e.a} — ${e.b})</div><div style=\"display:flex; gap:8px; align-items:center;\"><span class=\"weight\">${e.weight}</span><span style=\"opacity:0.8; font-size:12px;\">${e.state === 'accepted' ? 'accepted' : e.state === 'rejected' ? 'rejected' : 'idle'}</span></div>`;\n          div.addEventListener('click', () => focusEdge(e.id));\n          div.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); focusEdge(e.id); }});\n          edgeListDiv.appendChild(div);\n        }\n      }\n\n      function focusEdge(edgeId) {\n        // highlight edge on canvas briefly\n        const lines = edgeGroup.querySelectorAll(`[data-edge-id=\"${edgeId}\"]`);\n        lines.forEach(l => {\n          l.classList.add('pulse');\n          setTimeout(() => l.classList.remove('pulse'), 700);\n        });\n        // also scroll edge list into view\n        const item = edgeListDiv.querySelector(`[data-edge-id=\"${edgeId}\"]`);\n        if (item) item.scrollIntoView({behavior:'smooth', block:'center'});\n      }\n\n      // -------------------------\n      // Union-Find (DSU) implementation\n      function makeUnionFind(nNodes) {\n        const parent = {};\n        const rank = {};\n        // init with existing node ids\n        for (const node of nodes) {\n          parent[node.id] = node.id;\n          rank[node.id] = 0;\n        }\n        return {\n          find(x) {\n            if (parent[x] !== x) parent[x] = this.find(parent[x]);\n            return parent[x];\n          },\n          union(x, y) {\n            const rx = this.find(x);\n            const ry = this.find(y);\n            if (rx === ry) return false;\n            if (rank[rx] < rank[ry]) parent[rx] = ry;\n            else if (rank[ry] < rank[rx]) parent[ry] = rx;\n            else { parent[ry] = rx; rank[rx]++; }\n            return true;\n          },\n          parent,\n          rank\n        };\n      }\n\n      // Build sets view from current accepted edges\n      function updateSets() {\n        const comp = {};\n        // initially, each node alone\n        for (const n of nodes) comp[n.id] = [n.id];\n        // union per accepted edges\n        const dsu = makeUnionFind();\n        for (const e of edges) {\n          if (e.state === 'accepted') {\n            dsu.union(e.a, e.b);\n          }\n        }\n        // group nodes by root\n        const groups = {};\n        for (const n of nodes) {\n          const r = dsu.find(n.id);\n          if (!groups[r]) groups[r] = [];\n          groups[r].push(n.id);\n        }\n\n        setsDiv.innerHTML = '';\n        for (const root in groups) {\n          const div = document.createElement('div');\n          div.className = 'set';\n          div.innerHTML = `<div>Set ${root}</div><div style=\"opacity:0.9\">${groups[root].join(', ')}</div>`;\n          setsDiv.appendChild(div);\n        }\n\n        // Update mst total weight\n        const total = edges.filter(e => e.state === 'accepted').reduce((s,e) => s + e.weight, 0);\n        mstWeightSpan.textContent = total;\n      }\n\n      // -------------------------\n      // Node events (pointer)\n      function onNodePointerDown(evt) {\n        evt.stopPropagation();\n        const nid = Number(this.getAttribute('data-node-id'));\n        if (mode === 'move') {\n          selectedNodeId = nid;\n          dragging = true;\n          const pt = getSvgPoint(evt.clientX, evt.clientY);\n          const node = nodes.find(n => n.id === nid);\n          dragOffset.x = node.x - pt.x;\n          dragOffset.y = node.y - pt.y;\n          this.setPointerCapture(evt.pointerId);\n        } else if (mode === 'add-edge') {\n          // clicked node to build edge\n          if (!pendingEdgeSource) {\n            pendingEdgeSource = nid;\n            setStatus(`Selected source node ${nid}. Now click target node.`);\n            // highlight selected node visually by adding class\n            highlightNode(nid, true);\n          } else {\n            const source = pendingEdgeSource;\n            const target = nid;\n            if (source === target) {\n              setStatus('Cannot connect a node to itself. Choose a different target.');\n              highlightNode(source, false);\n              pendingEdgeSource = null;\n              return;\n            }\n            // prompt for weight\n            const input = prompt(`Enter edge weight for (${source} — ${target}):`, \"1\");\n            const w = input === null ? null : Number(input);\n            if (w === null || isNaN(w)) {\n              setStatus('Edge creation canceled or invalid weight.');\n            } else {\n              const added = addEdge(source, target, w);\n              if (added == null) setStatus('Edge not created (duplicate or invalid).');\n              else setStatus(`Edge (${source} — ${target}) with weight ${w} created.`);\n            }\n            highlightNode(source, false);\n            pendingEdgeSource = null;\n          }\n        }\n      }\n\n      function onNodeClick(evt) {\n        evt.stopPropagation();\n        // prevent click when dragging\n        if (dragging) return;\n        const nid = Number(this.getAttribute('data-node-id'));\n        if (mode === 'move') {\n          // maybe in move mode clicking can be selecting node (future)\n        }\n      }\n\n      // highlight a node by id (temporary style)\n      function highlightNode(id, on) {\n        const g = nodeGroup.querySelector(`[data-node-id=\"${id}\"]`);\n        if (!g) return;\n        const circle = g.querySelector('circle');\n        if (on) {\n          circle.classList.add('node-merged');\n          circle.style.stroke = 'rgba(96,165,250,0.8)';\n          circle.style.strokeWidth = '2.5px';\n        } else {\n          circle.classList.remove('node-merged');\n          circle.style.stroke = '';\n          circle.style.strokeWidth = '';\n        }\n      }\n\n      // -------------------------\n      // Stage events (canvas)\n      svg.addEventListener('pointermove', (evt) => {\n        if (!dragging || !selectedNodeId) return;\n        const pt = getSvgPoint(evt.clientX, evt.clientY);\n        const node = nodes.find(n => n.id === selectedNodeId);\n        node.x = pt.x + dragOffset.x;\n        node.y = pt.y + dragOffset.y;\n        render();\n      });\n\n      svg.addEventListener('pointerup', (evt) => {\n        if (dragging && selectedNodeId) {\n          const nodeEl = nodeGroup.querySelector(`[data-node-id=\"${selectedNodeId}\"]`);\n          if (nodeEl) nodeEl.releasePointerCapture(evt.pointerId);\n        }\n        dragging = false;\n        selectedNodeId = null;\n      });\n\n      svg.addEventListener('click', (evt) => {\n        const pt = getSvgPoint(evt.clientX, evt.clientY);\n        if (mode === 'add-node') {\n          addNode(pt.x, pt.y);\n          setStatus('Node added.');\n        } else {\n          // if clicking empty canvas in add-edge mode, cancel selection\n          if (mode === 'add-edge' && pendingEdgeSource) {\n            highlightNode(pendingEdgeSource, false);\n            pendingEdgeSource = null;\n            setStatus('Edge creation canceled.');\n          }\n        }\n      });\n\n      // -------------------------\n      // Button bindings\n      function bindEvents() {\n        addNodeBtn.addEventListener('click', () => setMode('add-node'));\n        addEdgeBtn.addEventListener('click', () => setMode('add-edge'));\n        moveBtn.addEventListener('click', () => setMode('move'));\n\n        loadSampleBtn.addEventListener('click', loadSampleGraph);\n        clearBtn.addEventListener('click', () => {\n          if (!confirm('Clear the graph? This removes all nodes and edges.')) return;\n          nodes = []; edges = []; nextNodeId = 1; nextEdgeId = 1;\n          resetKruskalState();\n          render();\n        });\n\n        stepBtn.addEventListener('click', () => {\n          if (edges.length === 0 || nodes.length === 0) { setStatus('Graph is empty.'); return; }\n          ensureKruskalPrepared();\n          processNextEdge();\n        });\n\n        playBtn.addEventListener('click', () => {\n          if (playing) return;\n          if (edges.length === 0 || nodes.length === 0) { setStatus('Graph is empty.'); return; }\n          ensureKruskalPrepared();\n          playing = true;\n          playBtn.disabled = true;\n          pauseBtn.disabled = false;\n          playTimer = setInterval(() => {\n            if (kruskalIndex >= sortedEdges.length) {\n              stopPlaying();\n              return;\n            }\n            processNextEdge();\n          }, 900);\n          setStatus('Playing Kruskal steps...');\n        });\n\n        pauseBtn.addEventListener('click', () => {\n          stopPlaying();\n          setStatus('Paused.');\n        });\n\n        runBtn.addEventListener('click', () => {\n          if (edges.length === 0 || nodes.length === 0) { setStatus('Graph is empty.'); return; }\n          ensureKruskalPrepared();\n          // process remaining quickly\n          const interval = setInterval(() => {\n            if (kruskalIndex >= sortedEdges.length) {\n              clearInterval(interval);\n              setStatus('Kruskal completed.');\n              return;\n            }\n            processNextEdge();\n          }, 250);\n        });\n\n        resetStepBtn.addEventListener('click', () => {\n          resetKruskalState();\n          setStatus('Kruskal state reset (graph preserved).');\n          render();\n        });\n\n        // keyboard shortcuts for Step (Space), Play (P), Reset (R)\n        document.addEventListener('keydown', (ev) => {\n          if (ev.target.tagName === 'INPUT' || ev.target.tagName === 'TEXTAREA') return;\n          if (ev.code === 'Space') { ev.preventDefault(); stepBtn.click(); }\n          if (ev.key.toLowerCase() === 'p') { playBtn.click(); }\n          if (ev.key.toLowerCase() === 'r') { resetStepBtn.click(); }\n        });\n      }\n\n      function stopPlaying() {\n        playing = false;\n        playBtn.disabled = false;\n        pauseBtn.disabled = true;\n        if (playTimer) { clearInterval(playTimer); playTimer = null; }\n      }\n\n      // -------------------------\n      // Kruskal algorithm control\n      function ensureKruskalPrepared() {\n        // initialize union-find and sorted edge list if not already\n        if (!uf || !sortedEdges || kruskalIndex === 0) {\n          uf = makeUnionFind();\n          sortedEdges = edges.slice().sort((a,b) => a.weight - b.weight || a.id - b.id);\n          kruskalIndex = 0;\n          // reset any previous markings\n          for (const e of edges) e.state = 'idle';\n          render();\n        }\n      }\n\n      function processNextEdge() {\n        if (!sortedEdges || kruskalIndex >= sortedEdges.length) {\n          setStatus('No more edges to process. Kruskal finished.');\n          stopPlaying();\n          return;\n        }\n        // find the next edge that is still idle (some edges might have been added after initialization)\n        let e = sortedEdges[kruskalIndex];\n        // If the edge object was removed or changed, skip gracefully\n        while (e && !edges.includes(e) && kruskalIndex < sortedEdges.length - 1) {\n          kruskalIndex++;\n          e = sortedEdges[kruskalIndex];\n        }\n        if (!e) {\n          kruskalIndex++;\n          processNextEdge();\n          return;\n        }\n\n        // Mark as processing\n        e.state = 'processing';\n        render();\n        setStatus(`Processing edge (${e.a} — ${e.b}) weight ${e.weight}...`);\n        // highlight visually\n        highlightEdgeVisual(e.id, 'processing');\n\n        // small delay to show processing\n        setTimeout(() => {\n          const ra = uf.find(e.a);\n          const rb = uf.find(e.b);\n          if (ra !== rb) {\n            // accept edge\n            uf.union(ra, rb);\n            e.state = 'accepted';\n            setStatus(`Accepted edge (${e.a} — ${e.b}) weight ${e.weight}.`);\n            highlightEdgeVisual(e.id, 'accepted');\n          } else {\n            // reject edge (forms cycle)\n            e.state = 'rejected';\n            setStatus(`Rejected edge (${e.a} — ${e.b}) — would form a cycle.`);\n            highlightEdgeVisual(e.id, 'rejected');\n          }\n          kruskalIndex++;\n          render();\n          // stop playing if finished\n          if (kruskalIndex >= sortedEdges.length) {\n            setTimeout(() => {\n              setStatus('Kruskal completed.');\n              stopPlaying();\n            }, 200);\n          }\n        }, 600);\n      }\n\n      function resetKruskalState() {\n        uf = null;\n        sortedEdges = [];\n        kruskalIndex = 0;\n        for (const e of edges) e.state = 'idle';\n        stopPlaying();\n      }\n\n      // Visual edge highlighting helper\n      function highlightEdgeVisual(edgeId, state) {\n        // remove processing classes from all\n        const el = edgeGroup.querySelector(`[data-edge-id=\"${edgeId}\"]`);\n        if (!el) return;\n        const original = el.className.baseVal;\n        // apply temporary style\n        el.classList.remove('accepted','rejected','highlight','processing');\n        if (state === 'processing') {\n          el.classList.add('highlight');\n          // small pulsing\n          el.classList.add('pulse');\n          setTimeout(() => el.classList.remove('pulse'), 700);\n        } else if (state === 'accepted') {\n          el.classList.remove('highlight');\n          el.classList.add('accepted');\n          el.classList.add('pulse');\n          setTimeout(() => el.classList.remove('pulse'), 700);\n        } else if (state === 'rejected') {\n          el.classList.remove('highlight');\n          el.classList.add('rejected');\n          el.classList.add('pulse');\n          setTimeout(() => el.classList.remove('pulse'), 700);\n        }\n      }\n\n      // -------------------------\n      // Sample graph loader\n      function loadSampleGraph() {\n        // a somewhat connected sample graph\n        nodes = [];\n        edges = [];\n        nextNodeId = 1;\n        nextEdgeId = 1;\n        // coordinates scaled for svg area: use relative positions\n        const w = svg.clientWidth || 800;\n        const h = svg.clientHeight || 420;\n        const coords = [\n          {x: w*0.2, y: h*0.2},\n          {x: w*0.5, y: h*0.1},\n          {x: w*0.8, y: h*0.2},\n          {x: w*0.3, y: h*0.45},\n          {x: w*0.6, y: h*0.4},\n          {x: w*0.2, y: h*0.75},\n          {x: w*0.5, y: h*0.65},\n          {x: w*0.78, y: h*0.72}\n        ];\n        for (const c of coords) addNode(c.x, c.y);\n        // edges with weights\n        addEdge(1,2,3);\n        addEdge(2,3,4);\n        addEdge(1,4,2);\n        addEdge(4,5,4);\n        addEdge(2,5,6);\n        addEdge(3,5,2);\n        addEdge(4,6,7);\n        addEdge(6,7,3);\n        addEdge(5,7,1);\n        addEdge(7,8,5);\n        addEdge(3,8,9);\n\n        resetKruskalState();\n        setStatus('Sample graph loaded. Use Step to run Kruskal.');\n      }\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Kruskal’s Algorithm.\n\n**Project Overview:**\nTopic: Kruskal’s Algorithm\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Kruskal’s Algorithm"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "2deb4a40-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:49:57.476Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Floyd-Warshall Algorithm",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Floyd–Warshall Interactive Module</title>\n  <style>\n    /* Safe area margins: 24px on all sides */\n    :root {\n      --safe-margin: 24px;\n      --gap: 16px; /* minimum spacing */\n      --bg: #0f1720;\n      --panel: #0b1320;\n      --accent: #38bdf8;\n      --muted: #94a3b8;\n      --good: #16a34a;\n      --bad: #ef4444;\n      --glass: rgba(255,255,255,0.03);\n      --cell-size: 48px;\n      --node-radius: 20;\n    }\n\n    html,body {\n      height: 100%;\n      margin: 0;\n      background: linear-gradient(180deg,#071022 0%, #06121a 100%);\n      color: #e6eef8;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing: antialiased;\n      -moz-osx-font-smoothing: grayscale;\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n    }\n\n    /* Layout container */\n    .container {\n      display: grid;\n      grid-template-columns: 360px 1fr;\n      gap: var(--gap);\n      height: calc(100% - calc(var(--safe-margin) * 2));\n      align-items: start;\n    }\n\n    @media (max-width: 920px) {\n      .container {\n        grid-template-columns: 1fr;\n        height: auto;\n      }\n    }\n\n    /* Left panel: controls and explanation */\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.03);\n      border-radius: 12px;\n      padding: 18px;\n      min-width: 260px;\n    }\n\n    h1 {\n      font-size: 18px;\n      margin: 0 0 8px 0;\n      color: var(--accent);\n      display: flex;\n      gap: 8px;\n      align-items: center;\n    }\n\n    .subtitle {\n      margin: 0 0 12px 0;\n      color: var(--muted);\n      font-size: 13px;\n    }\n\n    .objective {\n      background: var(--glass);\n      padding: 12px;\n      border-radius: 8px;\n      font-size: 13px;\n      color: #dbeafe;\n      margin-bottom: 12px;\n      line-height: 1.4;\n    }\n\n    /* Controls area */\n    .controls {\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n    }\n\n    .row {\n      display: flex;\n      gap: var(--gap);\n      align-items: center;\n      flex-wrap: wrap;\n    }\n\n    button, input[type=\"range\"], select {\n      background: rgba(255,255,255,0.02);\n      color: #e6eef8;\n      border: 1px solid rgba(255,255,255,0.04);\n      padding: 8px 10px;\n      border-radius: 8px;\n      font-size: 14px;\n      cursor: pointer;\n    }\n\n    button:disabled {\n      opacity: 0.45;\n      cursor: not-allowed;\n    }\n\n    .control-row {\n      display: flex;\n      gap: 12px;\n      align-items: center;\n      justify-content: space-between;\n    }\n\n    label.small {\n      font-size: 12px;\n      color: var(--muted);\n    }\n\n    .status {\n      background: rgba(255,255,255,0.02);\n      padding: 10px;\n      border-radius: 8px;\n      font-size: 13px;\n      color: #dbeafe;\n    }\n\n    /* Right panel: visualization */\n    .visual {\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border: 1px solid rgba(255,255,255,0.03);\n      border-radius: 12px;\n      padding: 18px;\n      min-height: 420px;\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n    }\n\n    .vis-top {\n      display: flex;\n      gap: var(--gap);\n      align-items: flex-start;\n    }\n\n    .canvas {\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius: 10px;\n      flex: 1;\n      min-height: 300px;\n      position: relative;\n      overflow: hidden;\n      border: 1px solid rgba(255,255,255,0.02);\n    }\n\n    svg {\n      width: 100%;\n      height: 100%;\n      display: block;\n    }\n\n    .matrix-panel {\n      width: 360px;\n      background: rgba(255,255,255,0.02);\n      border-radius: 10px;\n      padding: 10px;\n      overflow: auto;\n    }\n\n    @media (max-width: 920px) {\n      .vis-top {\n        flex-direction: column;\n      }\n      .matrix-panel {\n        width: 100%;\n      }\n    }\n\n    table.matrix {\n      border-collapse: collapse;\n      width: 100%;\n      font-size: 13px;\n      table-layout: fixed;\n      text-align: center;\n    }\n\n    table.matrix th, table.matrix td {\n      border: 1px solid rgba(255,255,255,0.03);\n      padding: 6px;\n      min-width: var(--cell-size);\n      height: var(--cell-size);\n      vertical-align: middle;\n      color: #e6eef8;\n      position: relative;\n      transition: background-color 300ms ease, color 300ms ease;\n    }\n\n    table.matrix th {\n      background: rgba(255,255,255,0.02);\n      font-weight: 600;\n      color: var(--muted);\n      font-size: 12px;\n    }\n\n    .cell-input {\n      width: 100%;\n      height: 100%;\n      border: none;\n      background: transparent;\n      color: inherit;\n      text-align: center;\n      font-size: 13px;\n      outline: none;\n    }\n\n    .cell-highlight {\n      animation: pulse 800ms ease;\n      background: linear-gradient(90deg, rgba(56,189,248,0.14), rgba(22,163,74,0.06));\n      box-shadow: 0 6px 18px rgba(56,189,248,0.06);\n    }\n\n    @keyframes pulse {\n      0% { transform: scale(1); }\n      50% { transform: scale(1.02); }\n      100% { transform: scale(1); }\n    }\n\n    .cell-updated {\n      background: linear-gradient(90deg, rgba(16,185,129,0.12), rgba(56,189,248,0.06));\n      color: #d1fae5;\n      font-weight: 700;\n    }\n\n    .node {\n      cursor: grab;\n      user-select: none;\n    }\n\n    .node:active {\n      cursor: grabbing;\n    }\n\n    .node-circle {\n      fill: #063249;\n      stroke: linear-gradient(180deg,#38bdf8,#06b6d4);\n      stroke-width: 2px;\n    }\n\n    .node-label {\n      font-size: 13px;\n      fill: #e6eef8;\n      pointer-events: none;\n    }\n\n    .edge {\n      stroke: rgba(255,255,255,0.06);\n      stroke-width: 2.5;\n      fill: none;\n      marker-end: url(#arrowhead);\n      transition: stroke 250ms ease, stroke-width 200ms ease;\n    }\n\n    .edge.highlight {\n      stroke: #38bdf8;\n      stroke-width: 4;\n      filter: drop-shadow(0 6px 12px rgba(56,189,248,0.12));\n    }\n\n    .weight-label {\n      font-size: 12px;\n      fill: #cfeefe;\n      background: rgba(0,0,0,0.2);\n      pointer-events: none;\n    }\n\n    .mini-hint {\n      font-size: 12px;\n      color: var(--muted);\n    }\n\n    .legend {\n      display: flex;\n      gap: 8px;\n      align-items: center;\n      flex-wrap: wrap;\n      font-size: 13px;\n    }\n\n    .chip {\n      border-radius: 8px;\n      background: rgba(255,255,255,0.02);\n      padding: 6px 8px;\n      color: #cfeefe;\n      font-size: 13px;\n      display: inline-flex;\n      gap: 8px;\n      align-items: center;\n    }\n\n    .info {\n      font-size: 13px;\n      color: #dbeafe;\n    }\n\n    /* focus states */\n    button:focus, input:focus, select:focus {\n      outline: 2px solid rgba(56,189,248,0.18);\n      outline-offset: 2px;\n    }\n\n    /* small helpers */\n    .muted { color: var(--muted); font-size: 13px; }\n    .tight { margin-top: 6px; }\n    .flex { display: flex; gap: 12px; align-items: center; }\n\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"application\" aria-label=\"Floyd–Warshall Interactive Module\">\n    <!-- LEFT: Title, objective & controls -->\n    <aside class=\"panel\" aria-labelledby=\"title\">\n      <h1 id=\"title\">Floyd–Warshall Algorithm — All-pairs Shortest Paths</h1>\n      <p class=\"subtitle\">Interactive step-through with editable graph and matrices</p>\n\n      <div class=\"objective\" aria-live=\"polite\">\n        Learning objective: After interacting with this module you will be able to:\n        <ul>\n          <li>Observe how Floyd–Warshall updates the distance matrix using each vertex as an intermediate.</li>\n          <li>See exactly when and why a particular distance entry is updated (visual + matrix highlight).</li>\n          <li>Reconstruct a shortest path using the \"next\" predecessor table and inspect it on the graph.</li>\n        </ul>\n      </div>\n\n      <div class=\"controls\" role=\"region\" aria-label=\"Controls\">\n        <div class=\"row control-row\">\n          <div>\n            <label class=\"small\">Nodes</label>\n            <select id=\"nodeCount\" aria-label=\"Node count\">\n              <option value=\"4\">4 nodes</option>\n              <option value=\"5\" selected>5 nodes</option>\n              <option value=\"6\">6 nodes</option>\n            </select>\n          </div>\n          <div style=\"min-width:140px;\">\n            <label class=\"small\">Directed</label>\n            <select id=\"directedToggle\" aria-label=\"Directed or undirected\">\n              <option value=\"true\">Directed</option>\n              <option value=\"false\">Undirected</option>\n            </select>\n          </div>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"randomizeBtn\" title=\"Create a random weighted graph\">Randomize graph</button>\n          <button id=\"resetBtn\" title=\"Reset to initial graph state\">Reset</button>\n        </div>\n\n        <div class=\"row control-row\">\n          <div style=\"min-width: 180px;\">\n            <label class=\"small\">Playback</label>\n            <div style=\"display:flex;gap:8px;\">\n              <button id=\"backBtn\" aria-label=\"Step backward\">◀</button>\n              <button id=\"playBtn\" aria-pressed=\"false\" aria-label=\"Play pause\">Play</button>\n              <button id=\"stepBtn\" aria-label=\"Step forward\">▶</button>\n            </div>\n          </div>\n\n          <div style=\"text-align:right;\">\n            <label class=\"small\">Speed</label>\n            <input id=\"speed\" type=\"range\" min=\"200\" max=\"2000\" step=\"50\" value=\"900\" aria-label=\"Playback speed ms\">\n          </div>\n        </div>\n\n        <div class=\"row\">\n          <div>\n            <label class=\"small\">Show path reconstruction</label>\n            <select id=\"showNext\" aria-label=\"Show next table\">\n              <option value=\"true\" selected>Show next table</option>\n              <option value=\"false\">Hide next table</option>\n            </select>\n          </div>\n          <div>\n            <label class=\"small\">Animation</label>\n            <select id=\"animateToggle\" aria-label=\"Toggle animation\">\n              <option value=\"true\" selected>Animate highlights</option>\n              <option value=\"false\">Instant</option>\n            </select>\n          </div>\n        </div>\n\n        <div class=\"status\" id=\"status\" aria-live=\"polite\">\n          Status: Ready. Build or randomize a graph, then press Play or Step to start.\n        </div>\n\n        <div class=\"mini-hint tight\" role=\"note\">\n          Tip: Edit any non-diagonal matrix cell to change edge weight (type number or INF). Drag nodes on the graph to reposition.\n        </div>\n      </div>\n    </aside>\n\n    <!-- RIGHT: Visualization (graph SVG) and matrix -->\n    <main class=\"visual\" role=\"main\">\n      <div class=\"vis-top\" role=\"region\" aria-label=\"Visualization\">\n        <div class=\"canvas\" id=\"canvas\" tabindex=\"0\" aria-label=\"Graph canvas - draggable nodes\">\n          <!-- Inline SVG for graph drawing -->\n          <svg id=\"svg\" viewBox=\"0 0 800 520\" preserveAspectRatio=\"xMidYMid meet\" role=\"img\" aria-label=\"Graph view\"></svg>\n        </div>\n\n        <div class=\"matrix-panel\" aria-label=\"Matrices\">\n          <div style=\"display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;\">\n            <div class=\"legend\">\n              <div class=\"chip\">Distance matrix</div>\n              <div class=\"chip\" id=\"nextChip\">Next table</div>\n            </div>\n            <div class=\"muted\">Click a cell to edit & press Enter</div>\n          </div>\n\n          <div id=\"matrices\">\n            <!-- Distance table and next table -->\n            <div id=\"distTableWrap\"></div>\n            <div id=\"nextTableWrap\" style=\"margin-top:12px;\"></div>\n          </div>\n        </div>\n      </div>\n\n      <div style=\"display:flex;gap:12px;align-items:center;justify-content:space-between;\">\n        <div class=\"info\" id=\"operation\">Operation: idle</div>\n        <div class=\"muted\">Current snapshot: <span id=\"snapshotIndex\">0</span></div>\n      </div>\n    </main>\n  </div>\n\n  <script>\n    /*\n      Floyd–Warshall Interactive Module\n      - Single-concept: Floyd–Warshall algorithm (all-pairs shortest paths)\n      - Vanilla JS, self-contained, responsive, accessible\n\n      Design notes (also visible in UI):\n      * Users can edit distances via the distance matrix (type a number or INF).\n      * Nodes are draggable. Graph updates reflect matrix values and vice versa.\n      * Step-wise snapshots are recorded so users can step forwards/backwards.\n      * Visual feedback: when examining triple (i,k,j) we highlight nodes and cells.\n      * When an update happens, the matrix cell pulses and edges/path highlight.\n    */\n\n    (function () {\n      // Config & state\n      const svg = document.getElementById('svg');\n      const canvas = document.getElementById('canvas');\n      const nodeCountSelect = document.getElementById('nodeCount');\n      const directedToggle = document.getElementById('directedToggle');\n      const randomizeBtn = document.getElementById('randomizeBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const playBtn = document.getElementById('playBtn');\n      const stepBtn = document.getElementById('stepBtn');\n      const backBtn = document.getElementById('backBtn');\n      const speedInput = document.getElementById('speed');\n      const statusDiv = document.getElementById('status');\n      const operationDiv = document.getElementById('operation');\n      const snapshotIndexSpan = document.getElementById('snapshotIndex');\n      const distTableWrap = document.getElementById('distTableWrap');\n      const nextTableWrap = document.getElementById('nextTableWrap');\n      const showNext = document.getElementById('showNext');\n      const animateToggle = document.getElementById('animateToggle');\n\n      // Layout dims for SVG internal coordinate system\n      const W = 800, H = 520;\n      svg.setAttribute('viewBox', `0 0 ${W} ${H}`);\n\n      // Algorithm representation\n      let N = parseInt(nodeCountSelect.value, 10);\n      let directed = (directedToggle.value === 'true');\n      let positions = []; // [{x,y}]\n      let adj = []; // adjacency matrix weights (number or Infinity)\n      let dist = []; // current distances\n      let nxt = []; // next matrix for path reconstruction (null or index)\n      let snapshots = []; // array of snapshots for stepping\n      let stepPos = 0; // index into snapshots\n      let playing = false;\n      let playTimer = null;\n\n      // Graph visuals\n      let nodes = []; // svg group elements for nodes\n      let edges = {}; // map key \"i-j\" -> svg elements (path, weight text)\n\n      // Utility: Infinity representation for UI\n      const INF = Number.POSITIVE_INFINITY;\n      const INF_STR = 'INF';\n\n      // Helpers for deep clone matrices\n      function cloneMatrix(m) {\n        return m.map(row => row.slice());\n      }\n\n      // Create default positions for N nodes (circle layout)\n      function generatePositions(n) {\n        const cx = W / 2, cy = H / 2;\n        const r = Math.min(W, H) / 2 - 80;\n        const arr = [];\n        for (let i = 0; i < n; i++) {\n          const a = (i / n) * Math.PI * 2 - Math.PI / 2;\n          arr.push({ x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) });\n        }\n        return arr;\n      }\n\n      // Random graph generator with some sparsity\n      function randomizeGraph(n, directed) {\n        const maxWeight = 12;\n        const pEdge = 0.45;\n        const A = Array.from({ length: n }, () => Array(n).fill(INF));\n        for (let i = 0; i < n; i++) {\n          A[i][i] = 0;\n        }\n        for (let i = 0; i < n; i++) {\n          for (let j = 0; j < n; j++) {\n            if (i === j) continue;\n            if (Math.random() < pEdge) {\n              const w = Math.floor(Math.random() * (maxWeight - 1)) + 1;\n              A[i][j] = w;\n              if (!directed) A[j][i] = w;\n            }\n          }\n        }\n        return A;\n      }\n\n      // Build initial state\n      function buildInitial(n, directedFlag, randomize = true) {\n        N = n;\n        directed = directedFlag;\n        positions = generatePositions(N);\n        adj = randomize ? randomizeGraph(N, directed) : Array.from({ length: N }, () => Array(N).fill(INF));\n        for (let i = 0; i < N; i++) adj[i][i] = 0;\n        resetAlgorithmState();\n        renderAll();\n      }\n\n      // Reset dist/nxt and snapshots\n      function resetAlgorithmState() {\n        dist = cloneMatrix(adj);\n        nxt = Array.from({ length: N }, () => Array(N).fill(null));\n        for (let i = 0; i < N; i++) {\n          for (let j = 0; j < N; j++) {\n            if (dist[i][j] !== INF && i !== j) nxt[i][j] = j;\n          }\n        }\n        snapshots = [];\n        stepPos = 0;\n        recordInitialSnapshot();\n        updateStatus('Ready: initial snapshot created.');\n        updateSnapshotUI();\n      }\n\n      // Record snapshot structure:\n      // { k, i, j, beforeDist, afterDist, beforeNext, afterNext, updated (bool) }\n      function recordInitialSnapshot() {\n        const snap = {\n          k: -1, i: -1, j: -1,\n          beforeDist: cloneMatrix(dist),\n          afterDist: cloneMatrix(dist),\n          beforeNext: cloneMatrix(nxt),\n          afterNext: cloneMatrix(nxt),\n          updated: false,\n          description: 'Initial state'\n        };\n        snapshots = [snap];\n        stepPos = 0;\n      }\n\n      // Run full Floyd–Warshall but record snapshots for each (i,k,j)\n      function computeSnapshots() {\n        // Start from current adjacency (fresh)\n        dist = cloneMatrix(adj);\n        nxt = Array.from({ length: N }, () => Array(N).fill(null));\n        for (let i = 0; i < N; i++) {\n          for (let j = 0; j < N; j++) {\n            if (dist[i][j] !== INF && i !== j) nxt[i][j] = j;\n          }\n        }\n        snapshots = [];\n        // initial\n        snapshots.push({\n          k: -1, i: -1, j: -1,\n          beforeDist: cloneMatrix(dist),\n          afterDist: cloneMatrix(dist),\n          beforeNext: cloneMatrix(nxt),\n          afterNext: cloneMatrix(nxt),\n          updated: false,\n          description: 'Initial state'\n        });\n        for (let k = 0; k < N; k++) {\n          for (let i = 0; i < N; i++) {\n            for (let j = 0; j < N; j++) {\n              const beforeDist = cloneMatrix(dist);\n              const beforeNext = cloneMatrix(nxt);\n              let updated = false;\n              const di = dist[i][j];\n              const dik = dist[i][k];\n              const dkj = dist[k][j];\n              if (dik !== INF && dkj !== INF) {\n                const via = dik + dkj;\n                if (via < di) {\n                  dist[i][j] = via;\n                  nxt[i][j] = nxt[i][k];\n                  updated = true;\n                }\n              }\n              snapshots.push({\n                k, i, j,\n                beforeDist, afterDist: cloneMatrix(dist),\n                beforeNext, afterNext: cloneMatrix(nxt),\n                updated,\n                description: updated\n                  ? `dist[${i}][${j}] improved via ${k}: ${beforeDist[i][j]} → ${dist[i][j]}`\n                  : `Checked dist[${i}][${j}] via ${k}: no improvement`\n              });\n            }\n          }\n        }\n        // final snapshot state already included as last\n        stepPos = 0;\n        updateSnapshotUI();\n        updateStatus('Snapshots computed. Use Play/Step to traverse.');\n      }\n\n      // Render all visuals (nodes, edges, matrices)\n      function renderAll() {\n        clearSVG();\n        renderDefs();\n        renderEdgesFromAdj();\n        renderNodes();\n        renderMatrices();\n      }\n\n      // Clear & initialize svg\n      function clearSVG() {\n        while (svg.firstChild) svg.removeChild(svg.firstChild);\n      }\n\n      // SVG defs (arrowhead)\n      function renderDefs() {\n        const defs = el('defs');\n        const marker = el('marker', { id: 'arrowhead', viewBox: '0 0 10 10', refX: 10, refY: 5, markerWidth: 6, markerHeight: 6, orient: 'auto-start-reverse' });\n        const path = el('path', { d: 'M 0 0 L 10 5 L 0 10 z', fill: 'rgba(255,255,255,0.08)' });\n        marker.appendChild(path);\n        defs.appendChild(marker);\n        svg.appendChild(defs);\n      }\n\n      // Render nodes as draggable circles\n      function renderNodes() {\n        nodes = [];\n        for (let i = 0; i < N; i++) {\n          const g = el('g', { class: 'node', 'data-idx': i, transform: `translate(${positions[i].x},${positions[i].y})` });\n          const circle = el('circle', { r: 20, fill: '#063249', class: 'node-circle' });\n          const label = el('text', { x: 0, y: 6, 'text-anchor': 'middle', class: 'node-label' });\n          label.textContent = String(i);\n          g.appendChild(circle);\n          g.appendChild(label);\n          svg.appendChild(g);\n          nodes.push(g);\n\n          // drag behavior\n          attachDragHandlers(g, i);\n        }\n      }\n\n      // Render edges using adjacency matrix\n      function renderEdgesFromAdj() {\n        edges = {};\n        for (let i = 0; i < N; i++) {\n          for (let j = 0; j < N; j++) {\n            if (i === j) continue;\n            const w = adj[i][j];\n            if (w !== INF) {\n              createEdge(i, j, w);\n            }\n          }\n        }\n      }\n\n      // Create an edge from i to j with weight w\n      function createEdge(i, j, w) {\n        const key = `${i}-${j}`;\n        const g = el('g', { class: 'edge-group', 'data-key': key });\n        const path = el('path', { class: 'edge', 'data-key': key, fill: 'none' });\n        const txt = el('text', { class: 'weight-label' });\n        txt.textContent = String(w);\n        g.appendChild(path);\n        g.appendChild(txt);\n        svg.appendChild(g);\n        edges[key] = { group: g, path, txt, i, j };\n        updateEdgePath(key);\n      }\n\n      // Update all edge paths (called after node drag)\n      function updateAllEdgePaths() {\n        Object.keys(edges).forEach(updateEdgePath);\n      }\n\n      function updateEdgePath(key) {\n        const e = edges[key];\n        if (!e) return;\n        const sx = positions[e.i].x;\n        const sy = positions[e.i].y;\n        const tx = positions[e.j].x;\n        const ty = positions[e.j].y;\n        // simple curved path for readability\n        const dx = tx - sx;\n        const dy = ty - sy;\n        const mx = (sx + tx) / 2;\n        const my = (sy + ty) / 2;\n        // offset for curve\n        const nx = -dy * 0.2;\n        const ny = dx * 0.2;\n        const cx = mx + nx, cy = my + ny;\n        const d = `M ${sx} ${sy} Q ${cx} ${cy} ${tx} ${ty}`;\n        e.path.setAttribute('d', d);\n        // place weight label near midpoint\n        const mid = quadPoint(sx, sy, cx, cy, tx, ty, 0.5);\n        e.txt.setAttribute('x', mid.x);\n        e.txt.setAttribute('y', mid.y - 8);\n      }\n\n      // quadratic curve midpoint util\n      function quadPoint(x1, y1, cx, cy, x2, y2, t) {\n        // B(t) = (1-t)^2 P0 + 2(1-t)t C + t^2 P2\n        const mt = 1 - t;\n        return {\n          x: mt * mt * x1 + 2 * mt * t * cx + t * t * x2,\n          y: mt * mt * y1 + 2 * mt * t * cy + t * t * y2\n        };\n      }\n\n      // Attach pointer drag to node group\n      function attachDragHandlers(g, idx) {\n        let dragging = false;\n        let offset = { x: 0, y: 0 };\n\n        function onPointerDown(e) {\n          e.preventDefault();\n          dragging = true;\n          g.setPointerCapture(e.pointerId);\n          const pt = getEventPoint(e);\n          const transform = g.getAttribute('transform'); // translate(x,y)\n          const m = transform.match(/translate\\((.+),(.+)\\)/);\n          const curX = parseFloat(m[1]), curY = parseFloat(m[2]);\n          offset.x = pt.x - curX;\n          offset.y = pt.y - curY;\n        }\n\n        function onPointerMove(e) {\n          if (!dragging) return;\n          const pt = getEventPoint(e);\n          const nx = pt.x - offset.x;\n          const ny = pt.y - offset.y;\n          positions[idx].x = clamp(nx, 40, W - 40);\n          positions[idx].y = clamp(ny, 40, H - 40);\n          g.setAttribute('transform', `translate(${positions[idx].x},${positions[idx].y})`);\n          updateAllEdgePaths();\n        }\n\n        function onPointerUp(e) {\n          if (!dragging) return;\n          dragging = false;\n          try { g.releasePointerCapture(e.pointerId); } catch (err) {}\n        }\n\n        g.addEventListener('pointerdown', onPointerDown);\n        window.addEventListener('pointermove', onPointerMove);\n        window.addEventListener('pointerup', onPointerUp);\n      }\n\n      function getEventPoint(e) {\n        // Convert client coords to SVG viewBox coords\n        const rect = svg.getBoundingClientRect();\n        const svgX = (e.clientX - rect.left) * (W / rect.width);\n        const svgY = (e.clientY - rect.top) * (H / rect.height);\n        return { x: svgX, y: svgY };\n      }\n\n      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }\n\n      // Render distance and next matrices as HTML tables with editable inputs\n      function renderMatrices() {\n        distTableWrap.innerHTML = '';\n        nextTableWrap.innerHTML = '';\n        // Distance table\n        const dTable = document.createElement('table');\n        dTable.className = 'matrix';\n        const thead = document.createElement('thead');\n        const headRow = document.createElement('tr');\n        headRow.appendChild(makeTH(''));\n        for (let j = 0; j < N; j++) headRow.appendChild(makeTH(String(j)));\n        thead.appendChild(headRow);\n        dTable.appendChild(thead);\n        const tbody = document.createElement('tbody');\n        for (let i = 0; i < N; i++) {\n          const tr = document.createElement('tr');\n          tr.appendChild(makeTH(String(i)));\n          for (let j = 0; j < N; j++) {\n            const td = document.createElement('td');\n            const input = document.createElement('input');\n            input.className = 'cell-input';\n            input.setAttribute('data-i', i);\n            input.setAttribute('data-j', j);\n            input.type = 'text';\n            input.value = (adj[i][j] === INF) ? INF_STR : String(adj[i][j]);\n            input.title = 'Click to edit weight (type INF for no edge). Press Enter to set.';\n            input.addEventListener('keydown', onCellKeydown);\n            input.addEventListener('blur', onCellBlur);\n            td.appendChild(input);\n            tr.appendChild(td);\n          }\n          tbody.appendChild(tr);\n        }\n        dTable.appendChild(tbody);\n        const distTitle = document.createElement('div');\n        distTitle.className = 'muted tight';\n        distTitle.textContent = 'Distance (click cells to edit).';\n        distTableWrap.appendChild(distTitle);\n        distTableWrap.appendChild(dTable);\n\n        // Next/predecessor table\n        if (showNext.value === 'true') {\n          const nTable = document.createElement('table');\n          nTable.className = 'matrix';\n          const nhead = document.createElement('thead');\n          const nheadRow = document.createElement('tr');\n          nheadRow.appendChild(makeTH(''));\n          for (let j = 0; j < N; j++) nheadRow.appendChild(makeTH(String(j)));\n          nhead.appendChild(nheadRow);\n          nTable.appendChild(nhead);\n          const nbody = document.createElement('tbody');\n          for (let i = 0; i < N; i++) {\n            const tr = document.createElement('tr');\n            tr.appendChild(makeTH(String(i)));\n            for (let j = 0; j < N; j++) {\n              const td = document.createElement('td');\n              td.textContent = (nxt[i] && nxt[i][j] != null) ? String(nxt[i][j]) : '-';\n              tr.appendChild(td);\n            }\n            nbody.appendChild(tr);\n          }\n          nTable.appendChild(nbody);\n          const nextTitle = document.createElement('div');\n          nextTitle.className = 'muted tight';\n          nextTitle.textContent = 'Next table (for path reconstruction)';\n          nextTableWrap.appendChild(nextTitle);\n          nextTableWrap.appendChild(nTable);\n          document.getElementById('nextChip').style.display = 'inline-block';\n        } else {\n          document.getElementById('nextChip').style.display = 'none';\n        }\n      }\n\n      function makeTH(text) {\n        const th = document.createElement('th');\n        th.textContent = text;\n        return th;\n      }\n\n      // Edit matrix cell handlers\n      function onCellKeydown(e) {\n        if (e.key === 'Enter') {\n          e.target.blur();\n        }\n      }\n      function onCellBlur(e) {\n        const i = parseInt(e.target.getAttribute('data-i'), 10);\n        const j = parseInt(e.target.getAttribute('data-j'), 10);\n        const raw = e.target.value.trim().toUpperCase();\n        if (raw === INF_STR) {\n          adj[i][j] = INF;\n          if (!directed) adj[j][i] = INF;\n          if (i === j) adj[i][j] = 0;\n        } else {\n          const v = Number(raw);\n          if (!isFinite(v) || isNaN(v)) {\n            // revert\n            e.target.value = (adj[i][j] === INF) ? INF_STR : String(adj[i][j]);\n            return;\n          }\n          adj[i][j] = v;\n          if (!directed) adj[j][i] = v;\n        }\n        // update edge visuals\n        rebuildEdgesFromAdj();\n        // recompute snapshots\n        computeSnapshots();\n        renderMatrices();\n      }\n\n      // Remove all edges and recreate based on adj matrix\n      function rebuildEdgesFromAdj() {\n        // remove existing edge groups\n        Object.keys(edges).forEach(k => {\n          const g = edges[k].group;\n          if (g && g.parentNode) g.parentNode.removeChild(g);\n        });\n        edges = {};\n        renderEdgesFromAdj();\n      }\n\n      // Utility to create element with attrs\n      function el(tag, attrs = {}) {\n        const e = document.createElementNS('http://www.w3.org/2000/svg', tag);\n        for (const k in attrs) {\n          e.setAttribute(k, attrs[k]);\n        }\n        return e;\n      }\n\n      // Animation & stepping mechanics\n      function updateSnapshotUI() {\n        snapshotIndexSpan.textContent = `${stepPos} / ${Math.max(0, snapshots.length - 1)}`;\n      }\n\n      function updateStatus(text) {\n        statusDiv.textContent = 'Status: ' + text;\n      }\n\n      // Apply a snapshot (visual + matrix)\n      function applySnapshot(idx, animate = true) {\n        if (idx < 0 || idx >= snapshots.length) return;\n        stepPos = idx;\n        const snap = snapshots[idx];\n        operationDiv.textContent = 'Operation: ' + snap.description;\n        // update dist & next to snapshot.after\n        dist = cloneMatrix(snap.afterDist);\n        nxt = cloneMatrix(snap.afterNext);\n        // update matrix cells values visually (distance)\n        // Update adjacency? No. Adjacency is the base input; dist shows computed distances.\n        // We'll reflect changes in the distance table by temporarily highlighting cells that changed.\n        renderMatrices();\n        // highlight nodes and cells\n        highlightForSnapshot(snap, animate);\n        updateSnapshotUI();\n      }\n\n      // Highlight nodes i,k,j and corresponding table cells\n      function highlightForSnapshot(snap, animate) {\n        // Clear previous highlights\n        clearHighlights();\n\n        const { k, i, j, beforeDist, afterDist, updated } = snap;\n        // If it's initial snapshot just show initial\n        if (k === -1) {\n          // no highlight\n          return;\n        }\n\n        // Visual highlight: highlight nodes i, k, j\n        highlightNode(i, '#38bdf8');\n        highlightNode(k, '#facc15'); // intermediate in yellow\n        highlightNode(j, '#34d399');\n\n        // Highlight cells in matrix before and after\n        const cellElements = distTableWrap.querySelectorAll('.cell-input');\n        // compute index in flat order: row-major\n        for (const input of cellElements) {\n          const ii = parseInt(input.getAttribute('data-i'), 10);\n          const jj = parseInt(input.getAttribute('data-j'), 10);\n          // if this is the cell being considered\n          if (ii === i && jj === j) {\n            const td = input.parentElement;\n            td.classList.add('cell-highlight');\n            if (updated && animateToggle.value === 'true') {\n              // animate update: flash then set new text\n              setTimeout(() => {\n                td.classList.remove('cell-highlight');\n                td.classList.add('cell-updated');\n                input.value = (afterDist[ii][jj] === INF) ? INF_STR : String(afterDist[ii][jj]);\n                setTimeout(() => td.classList.remove('cell-updated'), 900);\n              }, (animate ? 250 : 0));\n            } else {\n              // if not updated just set value to before (no change)\n              input.value = (afterDist[ii][jj] === INF) ? INF_STR : String(afterDist[ii][jj]);\n            }\n          } else {\n            // for other cells ensure they display the adjacency (input edits reflect base adj)\n            const val = adj[ii][jj];\n            input.value = (val === INF) ? INF_STR : String(val);\n          }\n        }\n\n        // highlight edges used by i->k and k->j path (if exist)\n        // show a path reconstruction from i to k and k to j using 'beforeNext' or 'afterNext'?\n        // We'll use beforeNext for demonstration of combining.\n        const beforeNext = snap.beforeNext;\n        const pathIK = reconstructPathWithNext(beforeNext, i, k);\n        const pathKJ = reconstructPathWithNext(beforeNext, k, j);\n        // highlight edges along pathIK and pathKJ sequentially\n        if (pathIK.length > 1) highlightEdgePath(pathIK, '#38bdf8', animate);\n        if (pathKJ.length > 1) highlightEdgePath(pathKJ, '#34d399', animate, 200);\n\n        // If updated, highlight the final shortest path i->...->j using afterNext\n        if (updated) {\n          const afterNext = snap.afterNext;\n          const pathIJ = reconstructPathWithNext(afterNext, i, j);\n          if (pathIJ.length > 1) {\n            // highlight final path in green after a short delay\n            highlightEdgePath(pathIJ, '#10b981', animate, 500);\n          }\n        }\n      }\n\n      function clearHighlights() {\n        // remove highlight class from edges\n        Object.values(edges).forEach(e => {\n          e.path.classList.remove('highlight');\n          e.path.style.stroke = '';\n          e.path.style.strokeWidth = '';\n        });\n        // clear node highlight outline by removing temporary circles\n        const temps = svg.querySelectorAll('.node-outline');\n        temps.forEach(t => t.parentNode && t.parentNode.removeChild(t));\n        // remove cell highlight classes\n        const cells = distTableWrap.querySelectorAll('td');\n        cells.forEach(td => {\n          td.classList.remove('cell-highlight', 'cell-updated');\n        });\n      }\n\n      function highlightNode(idx, color) {\n        const g = nodes[idx];\n        if (!g) return;\n        const outline = el('circle', { cx: 0, cy: 0, r: 28, fill: 'none', stroke: color, 'stroke-width': 3, class: 'node-outline' });\n        g.insertBefore(outline, g.firstChild);\n      }\n\n      function highlightEdgePath(pathNodes, color, animate = true, delay = 0) {\n        // pathNodes is array of node indices [a, b, c, ...]\n        setTimeout(() => {\n          for (let t = 0; t < pathNodes.length - 1; t++) {\n            const a = pathNodes[t], b = pathNodes[t + 1];\n            const key = `${a}-${b}`;\n            if (edges[key]) {\n              edges[key].path.classList.add('highlight');\n              edges[key].path.style.stroke = color;\n            } else {\n              // if edge doesn't exist visually, skip (maybe due to INF)\n            }\n            if (!animate) {\n              // no animation further\n            } else {\n              // small timeout for sequential pulse\n              // NOTE: we leave them highlighted; they are cleared on next snapshot\n            }\n          }\n        }, delay);\n      }\n\n      // Reconstruct path using a given next matrix (returns [] if unreachable)\n      function reconstructPathWithNext(nextMat, u, v) {\n        if (!nextMat[u] || nextMat[u][v] == null) return [];\n        const path = [u];\n        let cur = u;\n        const visited = new Set();\n        while (cur !== v) {\n          if (visited.has(cur)) return []; // cycle protection\n          visited.add(cur);\n          cur = nextMat[cur][v];\n          if (cur == null) return [];\n          path.push(cur);\n          if (path.length > N + 4) return []; // safety\n        }\n        return path;\n      }\n\n      // Play control\n      function playSnapshots() {\n        if (playing) return;\n        playing = true;\n        playBtn.textContent = 'Pause';\n        playBtn.setAttribute('aria-pressed', 'true');\n        scheduleNext();\n      }\n\n      function scheduleNext() {\n        if (!playing) return;\n        const delay = parseInt(speedInput.value, 10);\n        playTimer = setTimeout(() => {\n          if (stepPos < snapshots.length - 1) {\n            applySnapshot(stepPos + 1, animateToggle.value === 'true');\n            scheduleNext();\n          } else {\n            stopPlaying();\n          }\n        }, delay);\n      }\n\n      function stopPlaying() {\n        playing = false;\n        if (playTimer) clearTimeout(playTimer);\n        playBtn.textContent = 'Play';\n        playBtn.setAttribute('aria-pressed', 'false');\n      }\n\n      // Step backward (use snapshots history)\n      function stepBackward() {\n        if (stepPos > 0) {\n          applySnapshot(stepPos - 1, false);\n        }\n      }\n\n      // Step forward\n      function stepForward() {\n        if (stepPos < snapshots.length - 1) {\n          applySnapshot(stepPos + 1, animateToggle.value === 'true');\n        }\n      }\n\n      // Recompute snapshots when graph edits occur or when user requests\n      function recomputeAndRender() {\n        computeSnapshots();\n        renderMatrices();\n        renderAll();\n      }\n\n      // UI event bindings\n      nodeCountSelect.addEventListener('change', () => {\n        const n = parseInt(nodeCountSelect.value, 10);\n        buildInitial(n, directed);\n      });\n\n      directedToggle.addEventListener('change', () => {\n        directed = directedToggle.value === 'true';\n        // If switching to undirected, mirror adjacency\n        if (!directed) {\n          for (let i = 0; i < N; i++) {\n            for (let j = 0; j < N; j++) {\n              if (adj[i][j] !== INF) adj[j][i] = adj[i][j];\n            }\n          }\n        }\n        recomputeAndRender();\n      });\n\n      randomizeBtn.addEventListener('click', () => {\n        adj = randomizeGraph(N, directed);\n        for (let i = 0; i < N; i++) adj[i][i] = 0;\n        rebuildEdgesFromAdj();\n        computeSnapshots();\n        renderMatrices();\n        renderAll();\n      });\n\n      resetBtn.addEventListener('click', () => {\n        // re-create positions and graphs based on current adj\n        positions = generatePositions(N);\n        resetAlgorithmState();\n        renderAll();\n      });\n\n      playBtn.addEventListener('click', () => {\n        if (!playing) {\n          computeSnapshots();\n          playSnapshots();\n        } else {\n          stopPlaying();\n        }\n      });\n\n      stepBtn.addEventListener('click', () => {\n        stopPlaying();\n        // ensure snapshots exist\n        if (snapshots.length === 0) computeSnapshots();\n        stepForward();\n      });\n\n      backBtn.addEventListener('click', () => {\n        stopPlaying();\n        stepBackward();\n      });\n\n      // Recompute snapshots on animate toggle or showNext changes\n      animateToggle.addEventListener('change', () => { /* no-op visual only */ });\n      showNext.addEventListener('change', () => renderMatrices());\n\n      // Keyboard support: space toggles play/pause when focus on canvas\n      canvas.addEventListener('keydown', (e) => {\n        if (e.key === ' ') {\n          e.preventDefault();\n          playBtn.click();\n        } else if (e.key === 'ArrowRight') {\n          stepBtn.click();\n        } else if (e.key === 'ArrowLeft') {\n          backBtn.click();\n        }\n      });\n\n      // Start initial graph\n      buildInitial(N, directed, true);\n\n      // Precompute snapshots so step controls are immediately usable\n      computeSnapshots();\n\n      // Extra: clicking on an edge weight in svg could prompt to edit weight - optional\n      svg.addEventListener('dblclick', (e) => {\n        // if user double-clicks near a weight label, allow editing that edge\n        const target = e.target;\n        if (target.tagName === 'text' && target.classList.contains('weight-label')) {\n          const g = target.parentNode;\n          const key = g.getAttribute('data-key'); // \"i-j\"\n          if (!key) return;\n          const parts = key.split('-').map(s => parseInt(s, 10));\n          const i = parts[0], j = parts[1];\n          const input = prompt(`Set weight for edge ${i} → ${j} (type INF for no edge)`, String(adj[i][j] === INF ? INF_STR : adj[i][j]));\n          if (input == null) return;\n          const val = input.trim().toUpperCase();\n          if (val === INF_STR) {\n            adj[i][j] = INF;\n            if (!directed) adj[j][i] = INF;\n          } else {\n            const nval = Number(val);\n            if (!isFinite(nval)) return;\n            adj[i][j] = nval;\n            if (!directed) adj[j][i] = nval;\n          }\n          rebuildEdgesFromAdj();\n          computeSnapshots();\n          renderMatrices();\n        }\n      });\n\n      // Safety: stop playing when page hidden/unloaded\n      document.addEventListener('visibilitychange', () => {\n        if (document.hidden) stopPlaying();\n      });\n      window.addEventListener('beforeunload', () => stopPlaying());\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Floyd-Warshall Algorithm.\n\n**Project Overview:**\nTopic: Floyd-Warshall Algorithm\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Floyd-Warshall Algorithm"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "2ec88ae0-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:49:58.926Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Topological Sort",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Topological Sort — Interactive Module</title>\n  <style>\n    :root{\n      --safe-margin:24px;\n      --gap:16px;\n      --bg:#0f1720;\n      --panel:#0b1220;\n      --accent:#4f46e5;\n      --muted:#93c5fd;\n      --text:#e6eef8;\n      --card:#071025;\n      --danger:#ef4444;\n    }\n    *{box-sizing:border-box}\n    html,body{height:100%;margin:0;background:linear-gradient(180deg,#07142a 0%, #041827 100%);font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;}\n    .app{\n      padding:var(--safe-margin);\n      min-height:100vh;\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      color:var(--text);\n      user-select:none;\n    }\n\n    /* Left: Interactive Area */\n    .canvas-wrap{\n      flex:1 1 65%;\n      min-width:320px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:16px;\n      display:flex;\n      flex-direction:column;\n      gap:16px;\n      box-shadow:0 6px 20px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);\n      min-height:560px;\n    }\n    .title-row{\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:16px;\n    }\n    h1{\n      font-size:18px;margin:0;\n      letter-spacing:0.2px;\n    }\n    .subtitle{font-size:12px;color:var(--muted)}\n    .viewport{\n      flex:1 1 auto;\n      min-height:420px;\n      background:transparent;\n      border-radius:8px;\n      position:relative;\n      overflow:hidden;\n      border:1px dashed rgba(255,255,255,0.04);\n      display:flex;\n    }\n    svg{\n      width:100%;height:100%;\n      touch-action:none;\n    }\n    .toolbar{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      padding-top:4px;\n    }\n    .btn{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      color:var(--text);\n      border:1px solid rgba(255,255,255,0.04);\n      padding:8px 12px;\n      border-radius:8px;\n      font-size:13px;\n      cursor:pointer;\n      display:inline-flex;\n      gap:8px;\n      align-items:center;\n    }\n    .btn.primary{\n      background:linear-gradient(180deg,var(--accent),#3b33d8);\n      border: none;\n      box-shadow: 0 8px 24px rgba(79,70,229,0.18);\n      font-weight:600;\n    }\n    .btn.ghost{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n    }\n    .btn.toggle.active{\n      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);\n      outline:2px solid rgba(99,102,241,0.12);\n    }\n\n    /* Right: Controls & Info */\n    .side{\n      width:360px;\n      min-width:280px;\n      max-width:420px;\n      display:flex;\n      flex-direction:column;\n      gap:16px;\n    }\n    .card{\n      background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.006));\n      border-radius:12px;\n      padding:14px;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .info h2{margin:0;font-size:15px}\n    .info p{margin:8px 0 0 0;font-size:13px;color:var(--muted);line-height:1.4}\n    .controls{display:flex;flex-direction:column;gap:12px}\n    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}\n    .small{font-size:13px;color:var(--muted)}\n\n    /* Output Order Area */\n    .output{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n      align-items:center;\n      min-height:46px;\n    }\n    .out-node{\n      width:36px;height:36px;border-radius:8px;\n      display:inline-flex;align-items:center;justify-content:center;\n      background:rgba(255,255,255,0.03);\n      color:var(--text);font-weight:600;\n      border:1px solid rgba(255,255,255,0.02);\n      transform:translateY(0);\n      transition:transform 360ms cubic-bezier(.2,.9,.2,1),opacity 260ms;\n    }\n\n    /* Node & Edge Styling (SVG) */\n    .node { cursor:grab; transition: transform 160ms ease, filter 200ms ease; }\n    .node:active{ cursor:grabbing; }\n    .circle { fill:#06233a; stroke:rgba(255,255,255,0.06); stroke-width:1.8; transition:fill 260ms, stroke 260ms, r 160ms; }\n    .label { fill:var(--text); font-size:12px; pointer-events:none; font-weight:600; text-anchor:middle; dominant-baseline:central; }\n    .degree { fill:var(--muted); font-size:11px; text-anchor:middle; dominant-baseline:central; }\n    .edge { stroke:rgba(255,255,255,0.06); stroke-width:2; marker-end:url(#arrowhead); transition:stroke 200ms,opacity 200ms; }\n    .edge.highlight { stroke: #60a5fa; opacity:1; stroke-width:2.4 }\n    .node.zero { filter: drop-shadow(0 6px 14px rgba(79,70,229,0.12)); }\n    .node.removed .circle { fill:rgba(255,255,255,0.03); opacity:0.5; }\n    .node.highlight .circle { fill: #20304b; stroke: #60a5fa; stroke-width:2.6; }\n    .node.selected .circle { stroke: #94a3b8; stroke-width:2.2; }\n\n    /* Cycle Banner */\n    .banner{\n      display:flex;gap:12px;align-items:center;padding:10px;border-radius:10px;\n      background:linear-gradient(90deg, rgba(239,68,68,0.12), rgba(239,68,68,0.06));\n      color:var(--danger);\n      font-weight:600;\n    }\n\n    /* Footer log */\n    .log{\n      max-height:160px;overflow:auto;padding:10px;border-radius:8px;background:transparent;border:1px dashed rgba(255,255,255,0.02);\n      font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:13px;color:var(--muted);\n    }\n\n    /* responsive */\n    @media (max-width:960px){\n      .app{flex-direction:column;}\n      .side{width:100%}\n      .canvas-wrap{min-height:420px}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Topological Sort interactive module\">\n    <!-- Left interactive canvas -->\n    <div class=\"canvas-wrap\" style=\"min-width:320px;\">\n      <div class=\"title-row\">\n        <div>\n          <h1>Topological Sort — Interactive Visualizer</h1>\n          <div class=\"subtitle\">Create a directed acyclic graph (DAG) and step through Kahn's algorithm.</div>\n        </div>\n        <div class=\"toolbar\" role=\"toolbar\" aria-label=\"Graph controls\">\n          <button class=\"btn\" id=\"helpBtn\" title=\"Show information\">Info</button>\n          <button class=\"btn toggle\" id=\"edgeModeBtn\" title=\"Edge Mode: click source then target to add directed edge\" aria-pressed=\"false\">Edge Mode</button>\n          <button class=\"btn\" id=\"presetBtn\" title=\"Load example graphs\">Example</button>\n          <button class=\"btn ghost\" id=\"clearBtn\" title=\"Clear graph\">Clear</button>\n        </div>\n      </div>\n\n      <div class=\"viewport\" id=\"viewport\" aria-label=\"Graph drawing area\">\n        <svg id=\"svg\" viewBox=\"0 0 1200 700\" preserveAspectRatio=\"xMidYMid meet\" tabindex=\"0\" aria-describedby=\"howto\">\n          <defs>\n            <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"8\" refX=\"10\" refY=\"4\" orient=\"auto\">\n              <path d=\"M0,0 L10,4 L0,8 z\" fill=\"#9fbaf0\"></path>\n            </marker>\n          </defs>\n          <g id=\"edges\"></g>\n          <g id=\"nodes\"></g>\n        </svg>\n      </div>\n\n      <div style=\"display:flex;justify-content:space-between;align-items:center;gap:16px;\">\n        <div style=\"display:flex;gap:12px;align-items:center;\">\n          <button class=\"btn primary\" id=\"runBtn\" title=\"Start Kahn's topological sort\">Run</button>\n          <button class=\"btn\" id=\"stepBtn\" title=\"Step forward one removal\">Step</button>\n          <button class=\"btn\" id=\"playBtn\" title=\"Auto play/pause\">Play</button>\n          <button class=\"btn ghost\" id=\"resetBtn\" title=\"Reset algorithm (graph preserved)\">Reset</button>\n        </div>\n        <div style=\"display:flex;gap:12px;align-items:center;\">\n          <div class=\"small\">Queue: <span id=\"queueCount\">0</span></div>\n          <div class=\"small\">Remaining: <span id=\"remainCount\">0</span></div>\n        </div>\n      </div>\n\n    </div>\n\n    <!-- Right: info and controls -->\n    <div class=\"side\">\n      <div class=\"card info\" id=\"infoCard\" role=\"region\" aria-label=\"Module details\">\n        <h2>Concept Title</h2>\n        <p style=\"margin-top:6px;\"><strong>Topological Sort (Kahn's algorithm)</strong></p>\n\n        <h2 style=\"margin-top:12px;\">Learning Objective</h2>\n        <p>After interacting you will be able to:\n          identify nodes with zero in-degree, observe how removing them updates neighbors' in-degrees,\n          and understand how an ordering is produced or why a cycle prevents a topo order.</p>\n\n        <h2 style=\"margin-top:12px;\">Interaction Design</h2>\n        <p>\n          - Add nodes: click empty space in the drawing area (nodes labeled A, B, C...).<br>\n          - Move nodes: drag nodes to reorganize layout.<br>\n          - Add edges: enable <em>Edge Mode</em>, then click a source and a target node (directed).<br>\n          - Run algorithm: press <em>Run</em> to initialize Kahn's algorithm; use <em>Step</em> to advance one removal.\n          <em>Play</em> animates steps. Visual feedback highlights zero in-degree nodes (queue),\n          removed nodes, and updated in-degree counters. If the queue empties while nodes remain, a cycle banner appears.\n        </p>\n\n        <h2 style=\"margin-top:12px;\">Layout Description</h2>\n        <p>\n          The page uses a two-column layout: the left side is the interactive canvas (graph drawing and controls),\n          and the right side contains descriptive information, algorithm controls, and the output order.\n          A safe area margin of 24px is applied and spacing between interactive elements is at least 16px to maintain clarity.\n          Controls have clear labels and keyboard focusability for accessibility.\n        </p>\n      </div>\n\n      <div class=\"card controls\" role=\"region\" aria-label=\"Controls\">\n        <div class=\"row\">\n          <label class=\"small\" for=\"speedRange\">Animation speed</label>\n          <input id=\"speedRange\" type=\"range\" min=\"200\" max=\"1800\" value=\"900\" style=\"flex:1\" aria-label=\"Animation speed\"/>\n        </div>\n        <div class=\"row\">\n          <button class=\"btn\" id=\"loadDagBtn\">Load DAG (example)</button>\n          <button class=\"btn\" id=\"loadMultipleBtn\">Load Multi-order</button>\n          <button class=\"btn ghost\" id=\"loadCycleBtn\">Load Cycle (shows detection)</button>\n        </div>\n        <div style=\"margin-top:8px;\">\n          <div class=\"small\" style=\"margin-bottom:6px\">Output order (nodes removed, left → right):</div>\n          <div class=\"output card\" id=\"outputList\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n        </div>\n      </div>\n\n      <div class=\"card\" role=\"region\" aria-label=\"Logs and messages\">\n        <div class=\"row\" style=\"justify-content:space-between;align-items:center;\">\n          <div style=\"display:flex;gap:8px;align-items:center;\">\n            <div style=\"width:10px;height:10px;border-radius:50%;background:var(--accent)\"></div>\n            <div class=\"small\">Algorithm log</div>\n          </div>\n          <div class=\"small\">Keyboard: Delete (remove selection)</div>\n        </div>\n        <div class=\"log\" id=\"logArea\" tabindex=\"0\" aria-live=\"polite\"></div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Topological Sort interactive module (vanilla JS)\n    (function(){\n      // Utilities\n      const svg = document.getElementById('svg');\n      const nodesGroup = document.getElementById('nodes');\n      const edgesGroup = document.getElementById('edges');\n      const viewport = document.getElementById('viewport');\n      const runBtn = document.getElementById('runBtn');\n      const stepBtn = document.getElementById('stepBtn');\n      const playBtn = document.getElementById('playBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const edgeModeBtn = document.getElementById('edgeModeBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const helpBtn = document.getElementById('helpBtn');\n      const presetBtn = document.getElementById('presetBtn');\n      const queueCount = document.getElementById('queueCount');\n      const remainCount = document.getElementById('remainCount');\n      const outputList = document.getElementById('outputList');\n      const logArea = document.getElementById('logArea');\n      const speedRange = document.getElementById('speedRange');\n      const loadDagBtn = document.getElementById('loadDagBtn');\n      const loadMultipleBtn = document.getElementById('loadMultipleBtn');\n      const loadCycleBtn = document.getElementById('loadCycleBtn');\n\n      let state = {\n        nodes: [], // {id,label,x,y}\n        edges: [], // {id,src,tgt}\n        nextId: 0,\n        selectedNode: null,\n        selectedEdge: null,\n        dragging: null,\n        edgeMode: false,\n        edgeSource: null,\n        algorithm: {\n          running: false,\n          inDegree: {},\n          queue: [],\n          output: [],\n          removed: new Set(),\n          timer: null,\n          speed: 900\n        }\n      };\n\n      // constants for layout\n      const NODE_R = 22;\n      const SVG_W = 1200, SVG_H = 700;\n\n      // helper: log\n      function log(msg){\n        const time = new Date().toLocaleTimeString();\n        const el = document.createElement('div');\n        el.textContent = `[${time}] ${msg}`;\n        logArea.prepend(el);\n      }\n\n      // add node\n      function addNodeAt(px,py,label){\n        const id = state.nextId++;\n        const node = { id, label: label || String.fromCharCode(65 + (id % 26)), x:px, y:py };\n        state.nodes.push(node);\n        render();\n        log(`Added node ${node.label}`);\n        return node;\n      }\n\n      // add edge\n      function addEdge(srcId,tgtId){\n        if(srcId === tgtId) {\n          log('Cannot add self-loop (topological sort requires a DAG).');\n        }\n        // prevent duplicates\n        const exists = state.edges.find(e=> e.src===srcId && e.tgt===tgtId);\n        if(exists) return;\n        const id = 'e' + state.edges.length;\n        state.edges.push({id, src: srcId, tgt: tgtId});\n        render();\n        log(`Added edge ${labelOf(srcId)} → ${labelOf(tgtId)}`);\n      }\n\n      function removeNodeById(id){\n        const node = state.nodes.find(n=>n.id===id);\n        if(!node) return;\n        state.edges = state.edges.filter(e=> e.src!==id && e.tgt!==id);\n        state.nodes = state.nodes.filter(n=>n.id!==id);\n        if(state.selectedNode === id) state.selectedNode = null;\n        render();\n        log(`Removed node ${node.label}`);\n      }\n\n      function removeEdgeById(eid){\n        const e = state.edges.find(x=>x.id===eid);\n        if(!e) return;\n        state.edges = state.edges.filter(x=>x.id!==eid);\n        render();\n        log(`Removed edge ${labelOf(e.src)} → ${labelOf(e.tgt)}`);\n      }\n\n      function labelOf(id){\n        const n = state.nodes.find(x=>x.id===id);\n        return n? n.label : '?';\n      }\n\n      // Graph rendering\n      function render(){\n        // clear\n        nodesGroup.innerHTML='';\n        edgesGroup.innerHTML='';\n        // draw edges first\n        state.edges.forEach(e=>{\n          const src = state.nodes.find(n=>n.id===e.src);\n          const tgt = state.nodes.find(n=>n.id===e.tgt);\n          if(!src || !tgt) return;\n          // simple straight line with arrow\n          const line = document.createElementNS('http://www.w3.org/2000/svg','path');\n          line.setAttribute('class','edge');\n          const dx = tgt.x - src.x, dy = tgt.y - src.y;\n          const dist = Math.hypot(dx,dy) || 1;\n          const ox = (dx/dist)*NODE_R, oy = (dy/dist)*NODE_R;\n          const sx = src.x + ox, sy = src.y + oy;\n          const tx = tgt.x - ox, ty = tgt.y - oy;\n          const d = `M ${sx} ${sy} L ${tx} ${ty}`;\n          line.setAttribute('d',d);\n          line.dataset.id = e.id;\n          line.addEventListener('click', (ev)=>{\n            ev.stopPropagation();\n            // select edge\n            clearSelection();\n            state.selectedEdge = e.id;\n            line.classList.add('highlight');\n            log(`Selected edge ${labelOf(e.src)} → ${labelOf(e.tgt)}`);\n          });\n          edgesGroup.appendChild(line);\n        });\n\n        // draw nodes\n        state.nodes.forEach(n=>{\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('class','node');\n          g.setAttribute('transform', `translate(${n.x} ${n.y})`);\n          g.dataset.id = n.id;\n\n          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          circle.setAttribute('r', NODE_R);\n          circle.setAttribute('class','circle');\n          circle.setAttribute('cx',0);\n          circle.setAttribute('cy',0);\n          g.appendChild(circle);\n\n          const label = document.createElementNS('http://www.w3.org/2000/svg','text');\n          label.setAttribute('class','label');\n          label.textContent = n.label;\n          label.setAttribute('x',0);\n          label.setAttribute('y',-2);\n          g.appendChild(label);\n\n          const degree = document.createElementNS('http://www.w3.org/2000/svg','text');\n          degree.setAttribute('class','degree');\n          degree.setAttribute('x',0);\n          degree.setAttribute('y',18);\n          degree.textContent = inDegreeOf(n.id);\n          g.appendChild(degree);\n\n          // classes\n          if(state.algorithm.removed && state.algorithm.removed.has(n.id)){\n            g.classList.add('removed');\n          }\n          if(state.selectedNode === n.id){\n            g.classList.add('selected');\n          }\n          if(state.edgeMode && state.edgeSource === n.id){\n            g.classList.add('highlight');\n          }\n          // zero-degree highlight when algorithm running\n          if(state.algorithm.running && state.algorithm.queue.indexOf(n.id) !== -1 && !state.algorithm.removed.has(n.id)){\n            g.classList.add('zero');\n          }\n\n          // mouse events\n          g.addEventListener('pointerdown', pointerDownNode);\n          g.addEventListener('click', (ev)=>{\n            ev.stopPropagation();\n            if(state.edgeMode){\n              handleEdgeModeClick(n.id);\n            } else {\n              // select node\n              state.selectedNode = n.id;\n              state.selectedEdge = null;\n              render();\n            }\n          });\n\n          nodesGroup.appendChild(g);\n        });\n\n        // update info counters\n        queueCount.textContent = state.algorithm.queue ? state.algorithm.queue.length : 0;\n        remainCount.textContent = state.nodes.length - (state.algorithm.removed ? state.algorithm.removed.size : 0);\n\n        // update output list rendering\n        outputList.innerHTML = '';\n        state.algorithm.output && state.algorithm.output.forEach(id=>{\n          const nd = document.createElement('div');\n          nd.className = 'out-node';\n          nd.textContent = labelOf(id);\n          outputList.appendChild(nd);\n        });\n      }\n\n      // compute in-degrees\n      function computeInDegrees(){\n        const indeg = {};\n        state.nodes.forEach(n=> indeg[n.id]=0);\n        state.edges.forEach(e=>{\n          if(indeg[e.tgt] !== undefined) indeg[e.tgt]++;\n        });\n        return indeg;\n      }\n\n      function inDegreeOf(id){\n        const indeg = computeInDegrees();\n        return indeg[id] !== undefined ? indeg[id] : 0;\n      }\n\n      // Kahn algorithm control\n      function startKahn(){\n        state.algorithm.inDegree = computeInDegrees();\n        state.algorithm.queue = state.nodes.map(n=>n.id).filter(id=> state.algorithm.inDegree[id]===0);\n        // stable order by label for deterministic behavior\n        state.algorithm.queue.sort((a,b)=> labelOf(a).localeCompare(labelOf(b)));\n        state.algorithm.output = [];\n        state.algorithm.removed = new Set();\n        state.algorithm.running = true;\n        log('Kahn: initialized. Queue: ' + state.algorithm.queue.map(id=>labelOf(id)).join(', '));\n        render();\n      }\n\n      function stepKahn(){\n        if(!state.algorithm.running) {\n          log('Run the algorithm first (click Run).');\n          return;\n        }\n        if(state.algorithm.timer){ // if auto-playing, stepping manually clears timer\n          clearInterval(state.algorithm.timer); state.algorithm.timer = null; playBtn.textContent='Play';\n        }\n        if(state.algorithm.queue.length === 0){\n          // if all nodes removed => finished; else cycle detected\n          if(state.algorithm.removed.size === state.nodes.length){\n            log('Topological order complete: ' + state.algorithm.output.map(id=>labelOf(id)).join(' → '));\n          } else {\n            // cycle\n            log('Cycle detected — queue empty but nodes remain. No topological ordering exists.');\n            showCycleBanner();\n          }\n          state.algorithm.running = false;\n          render();\n          return;\n        }\n        // remove first node from queue\n        const nid = state.algorithm.queue.shift();\n        state.algorithm.removed.add(nid);\n        state.algorithm.output.push(nid);\n        // animate highlight and then update neighbors\n        highlightNodeRemoval(nid).then(()=>{\n          // for each outgoing edge, decrement indegree and add to queue if becomes 0\n          const outEdges = state.edges.filter(e=> e.src === nid && !state.algorithm.removed.has(e.tgt));\n          outEdges.forEach(e=>{\n            const tgt = e.tgt;\n            state.algorithm.inDegree[tgt]--;\n            log(`Decrement in-degree of ${labelOf(tgt)} → ${state.algorithm.inDegree[tgt]}`);\n            if(state.algorithm.inDegree[tgt] === 0){\n              state.algorithm.queue.push(tgt);\n              // keep queue stable by label\n              state.algorithm.queue.sort((a,b)=> labelOf(a).localeCompare(labelOf(b)));\n              log(`Enqueued ${labelOf(tgt)} (in-degree 0)`);\n            }\n          });\n          render();\n        });\n      }\n\n      function highlightNodeRemoval(nid){\n        return new Promise(resolve=>{\n          // add highlight class to node element\n          const g = nodesGroup.querySelector(`g[data-id='${nid}']`);\n          if(g){\n            g.classList.add('highlight');\n            setTimeout(()=>{\n              g.classList.remove('highlight');\n              g.classList.add('removed');\n              // show node in output list (render will place it)\n              render();\n              setTimeout(()=> resolve(), Math.max(200, state.algorithm.speed/3));\n            }, Math.max(300, state.algorithm.speed/2));\n          } else {\n            resolve();\n          }\n        });\n      }\n\n      function showCycleBanner(){\n        const existing = document.querySelector('.banner');\n        if(existing) return;\n        const card = document.createElement('div');\n        card.className = 'banner';\n        card.textContent = 'Cycle detected — remaining nodes cannot be ordered.';\n        // insert banner at top of canvas-wrap\n        const canvasWrap = document.querySelector('.canvas-wrap');\n        canvasWrap.insertBefore(card, canvasWrap.children[0].nextSibling);\n        setTimeout(()=> card.remove(), 6000);\n      }\n\n      // controls\n      runBtn.addEventListener('click', ()=>{\n        startKahn();\n      });\n\n      stepBtn.addEventListener('click', stepKahn);\n\n      playBtn.addEventListener('click', ()=>{\n        if(state.algorithm.timer){\n          clearInterval(state.algorithm.timer);\n          state.algorithm.timer = null;\n          playBtn.textContent = 'Play';\n          log('Auto-play paused.');\n        } else {\n          if(!state.algorithm.running) startKahn();\n          state.algorithm.timer = setInterval(()=> {\n            if(!state.algorithm.running) {\n              clearInterval(state.algorithm.timer);\n              state.algorithm.timer = null;\n              playBtn.textContent = 'Play';\n              return;\n            }\n            stepKahn();\n          }, state.algorithm.speed);\n          playBtn.textContent = 'Pause';\n          log('Auto-play started.');\n        }\n      });\n\n      resetBtn.addEventListener('click', ()=>{\n        // keep graph, reset algorithm state\n        state.algorithm = { running:false, inDegree:{}, queue:[], output:[], removed:new Set(), timer:null, speed:state.algorithm.speed || 900 };\n        outputList.innerHTML='';\n        log('Algorithm reset.');\n        render();\n      });\n\n      // Edge mode toggle\n      edgeModeBtn.addEventListener('click', ()=>{\n        state.edgeMode = !state.edgeMode;\n        state.edgeSource = null;\n        edgeModeBtn.classList.toggle('active', state.edgeMode);\n        edgeModeBtn.setAttribute('aria-pressed', String(state.edgeMode));\n        if(state.edgeMode){\n          log('Edge mode: click a source node then target node to create directed edge.');\n        } else {\n          log('Edge mode disabled.');\n        }\n        render();\n      });\n\n      // Clear graph\n      clearBtn.addEventListener('click', ()=>{\n        state.nodes = [];\n        state.edges = [];\n        state.nextId = 0;\n        state.selectedNode = null;\n        state.selectedEdge = null;\n        state.edgeMode = false;\n        state.edgeSource = null;\n        state.algorithm = { running:false, inDegree:{}, queue:[], output:[], removed:new Set(), timer:null, speed:900 };\n        outputList.innerHTML='';\n        log('Graph cleared.');\n        render();\n      });\n\n      // presets\n      loadDagBtn.addEventListener('click', ()=>{\n        loadExampleDAG();\n      });\n      loadMultipleBtn.addEventListener('click', ()=>{\n        loadExampleMultiple();\n      });\n      loadCycleBtn.addEventListener('click', ()=>{\n        loadExampleCycle();\n      });\n\n      presetBtn.addEventListener('click', ()=>{\n        // simple modal-like prompt using built-in choices\n        const choice = prompt(\"Choose example: 1) Simple DAG  2) Multi-order  3) Cycle\\nEnter 1, 2, or 3\", \"1\");\n        if(choice==='1') loadExampleDAG();\n        else if(choice==='2') loadExampleMultiple();\n        else if(choice==='3') loadExampleCycle();\n      });\n\n      helpBtn.addEventListener('click', ()=>{\n        const help = `Interactions:\n- Click empty space to add nodes.\n- Drag nodes to move them.\n- Toggle \"Edge Mode\", click a source then a target to add a directed edge.\n- Run -> initializes Kahn's algorithm.\n- Step -> remove one node from the queue.\n- Play -> animate steps.\n- Reset -> stops algorithm and preserves graph.\n- Clear -> remove entire graph.`;\n        alert(help);\n      });\n\n      // example loaders\n      function loadExampleDAG(){\n        clearBtn.click();\n        // simple DAG\n        const A = addNodeAt(180,120,'A');\n        const B = addNodeAt(420,80,'B');\n        const C = addNodeAt(420,200,'C');\n        const D = addNodeAt(660,140,'D');\n        const E = addNodeAt(900,120,'E');\n        setTimeout(()=> {\n          addEdge(A.id,B.id);\n          addEdge(A.id,C.id);\n          addEdge(B.id,D.id);\n          addEdge(C.id,D.id);\n          addEdge(D.id,E.id);\n        },50);\n      }\n      function loadExampleMultiple(){\n        clearBtn.click();\n        const A = addNodeAt(160,120,'A');\n        const B = addNodeAt(320,60,'B');\n        const C = addNodeAt(320,180,'C');\n        const D = addNodeAt(480,120,'D');\n        const E = addNodeAt(640,120,'E');\n        setTimeout(()=>{\n          addEdge(A.id,B.id);\n          addEdge(A.id,C.id);\n          addEdge(B.id,D.id);\n          addEdge(C.id,D.id);\n          addEdge(D.id,E.id);\n        },50);\n      }\n      function loadExampleCycle(){\n        clearBtn.click();\n        const A = addNodeAt(200,150,'A');\n        const B = addNodeAt(400,120,'B');\n        const C = addNodeAt(600,150,'C');\n        const D = addNodeAt(400,260,'D');\n        setTimeout(()=>{\n          addEdge(A.id,B.id);\n          addEdge(B.id,C.id);\n          addEdge(C.id,D.id);\n          addEdge(D.id,B.id); // back edge creates cycle\n        },50);\n      }\n\n      // Pointer events for adding and dragging nodes\n      function getSvgPoint(evt){\n        const CTM = svg.getScreenCTM();\n        const point = svg.createSVGPoint();\n        point.x = evt.clientX;\n        point.y = evt.clientY;\n        const transformed = point.matrixTransform(CTM.inverse());\n        return {x: transformed.x, y: transformed.y};\n      }\n\n      // Add node on background click\n      svg.addEventListener('click', (ev)=>{\n        // only add if click landed on svg background (not on node)\n        const target = ev.target;\n        if(target.closest('g')) return;\n        const p = getSvgPoint(ev);\n        addNodeAt(p.x, p.y);\n      });\n\n      // dragging logic\n      function pointerDownNode(ev){\n        ev.stopPropagation();\n        const g = ev.currentTarget;\n        const id = parseInt(g.dataset.id,10);\n        const p = getSvgPoint(ev);\n        state.dragging = { id, offsetX: p.x - state.nodes.find(n=>n.id===id).x, offsetY: p.y - state.nodes.find(n=>n.id===id).y };\n        svg.setPointerCapture(ev.pointerId);\n        function moveHandler(e){\n          const pos = getSvgPoint(e);\n          const node = state.nodes.find(n=>n.id===state.dragging.id);\n          node.x = pos.x - state.dragging.offsetX;\n          node.y = pos.y - state.dragging.offsetY;\n          render();\n        }\n        function upHandler(e){\n          svg.removeEventListener('pointermove', moveHandler);\n          svg.removeEventListener('pointerup', upHandler);\n          svg.releasePointerCapture(ev.pointerId);\n          state.dragging = null;\n        }\n        svg.addEventListener('pointermove', moveHandler);\n        svg.addEventListener('pointerup', upHandler);\n      }\n\n      // edge mode handling\n      function handleEdgeModeClick(nodeId){\n        if(state.edgeSource == null){\n          state.edgeSource = nodeId;\n          log(`Edge source selected: ${labelOf(nodeId)}. Now click target.`);\n          render();\n        } else {\n          const src = state.edgeSource;\n          const tgt = nodeId;\n          if(src === tgt){\n            log('Cannot add edge to same node.');\n          } else {\n            addEdge(src,tgt);\n          }\n          state.edgeSource = null;\n          render();\n        }\n      }\n\n      // selection delete key\n      window.addEventListener('keydown', (ev)=>{\n        if(ev.key === 'Delete' || ev.key === 'Backspace'){\n          if(state.selectedNode != null){\n            removeNodeById(state.selectedNode);\n          } else if(state.selectedEdge != null){\n            removeEdgeById(state.selectedEdge);\n          }\n        }\n      });\n\n      // clear selections on background click\n      svg.addEventListener('click', (ev)=>{\n        // handled earlier for add node; but also clear selection when clicking on empty area\n        if(ev.target === svg || ev.target === svg.querySelector('g') || ev.target === svg.querySelector('path')){\n          // nothing\n        }\n      });\n      viewport.addEventListener('click', (ev)=>{\n        // clear selection if clicked outside nodes\n        if(ev.target === viewport || ev.target === svg){\n          clearSelection();\n        }\n      });\n\n      function clearSelection(){\n        state.selectedNode = null;\n        state.selectedEdge = null;\n        render();\n      }\n\n      // animation speed\n      speedRange.addEventListener('input', ()=>{\n        state.algorithm.speed = parseInt(speedRange.value,10);\n        log('Animation speed set to '+state.algorithm.speed+'ms.');\n        if(state.algorithm.timer){\n          clearInterval(state.algorithm.timer);\n          state.algorithm.timer = setInterval(()=> stepKahn(), state.algorithm.speed);\n        }\n      });\n\n      // helper: initial render and sample nodes to show\n      (function init(){\n        // start with a small example\n        addNodeAt(300,180,'A');\n        addNodeAt(520,140,'B');\n        addNodeAt(520,260,'C');\n        addNodeAt(740,200,'D');\n        setTimeout(()=> {\n          addEdge(0,1);\n          addEdge(0,2);\n          addEdge(1,3);\n          addEdge(2,3);\n        },120);\n        render();\n        log('Module ready. Click the canvas to add nodes. Toggle Edge Mode to draw edges.');\n      })();\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Topological Sort.\n\n**Project Overview:**\nTopic: Topological Sort\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Topological Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "308d4550-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:50:01.893Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Longest Common Subsequence",
    "answer": {
      "role": "assistant",
      "content": "Concept Title:\nLongest Common Subsequence — interactive DP matrix explorer\n\nLearning Objective:\nAfter interacting with this module, users will understand the dynamic programming recurrence for LCS, see how the DP matrix is filled cell-by-cell, observe how choices (diagonal vs. top/left) determine values, and watch the backtracking process that produces the LCS. Users will be able to step through the computation manually or play an animated walkthrough to reinforce intuition.\n\nInteraction Design:\n- Inputs: Two text fields for String A (top) and String B (left). A \"Compute LCS\" button builds the DP matrix. A \"Random Example\" button seeds strings for quick exploration.\n- Playback controls: Play/Pause toggle, Step Forward, Step Back, and a speed slider (0.2x–2x) to control animation tempo. A checkbox toggles \"Auto-backtrack\" (automatically animate backtracking when matrix fill completes).\n- Matrix interaction:\n  - The DP matrix is rendered as an accessible HTML table. Row 0 and column 0 initialize to 0.\n  - When \"Play\" is active, cells are filled left-to-right, top-to-bottom (row-major). Each cell animates its value appearing (fade+slide) and briefly highlights the contributing neighbor(s).\n  - Each cell stores its computed value and \"source\": \"diag\" (if characters matched), \"top\", \"left\", or both (tie). Colors: diagonal-match uses a green accent; top/left uses purple/blue accents; ties highlight both.\n  - Clicking any cell shows a detail panel (below) explaining how that cell's value was derived (showing dp[i-1][j], dp[i][j-1], dp[i-1][j-1] and the chosen predecessor).\n  - Hovering a cell visually emphasizes its predecessor(s) with animated pulses.\n- Backtracking:\n  - After fill completes, a \"Backtrack\" button appears (or auto-backtracks if enabled). Backtracking animates the selected path from bottom-right to top-left, highlighting each diagonal move where characters match. The LCS characters are appended to a display as they're discovered (with a reversing animation so result reads left-to-right).\n- Keyboard & Accessibility:\n  - All controls are focusable and labeled (aria-labels).\n  - Table cells are focusable so keyboard users can navigate and inspect cell details.\n- Visual feedback & animations:\n  - Cell fill: slide-and-fade in with a short color glow indicating source.\n  - Predecessor highlight: brief pulse on contributing cell(s).\n  - Backtrack: animated stroke (CSS transition) along path and character reveal with a subtle bounce.\n- Reinforcement:\n  - The right-side explanation panel shows the LCS recurrence formula, the current step index, and an English description of what's happening.\n  - Users can experiment with different strings and speeds to build intuition about how matches drive growth in dp values.\n\nLayout Description:\n- Safe area margins: the body uses 24px padding on all sides to respect the requirement.\n- Overall layout: a responsive two-column layout on wide viewports and a stacked single-column layout on narrow viewports.\n  - Top: Concept title and short one-line objective.\n  - Left/main column: interactive controls (inputs, playback controls), then the DP matrix visualization.\n  - Right/side column (or below on narrow screens): Explanation panel (recurrence, current step description), cell detail view, and final LCS result box.\n- Spacing:\n  - All interactive elements are separated by at least 16px via consistent CSS gap variables and margin rules.\n  - The matrix grid has 16px minimum gap from controls and explanation panel.\n- Responsiveness:\n  - The matrix scales: cells have a minimum size but will wrap/scale to fit smaller screens; horizontal scrolling is possible when strings are long.\n  - Controls wrap into multiple rows to avoid cramped layouts.\n- Accessibility & contrast:\n  - High-contrast color palette and clear focus outlines on interactive elements.\n  - Table captions and aria attributes communicate state to assistive tech.\n\nImplementation:\nBelow is a self-contained HTML file (vanilla HTML/CSS/JS) implementing the module described above. Paste it into an .html file and open in a browser.\n\n```\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Longest Common Subsequence (LCS) Explorer</title>\n  <style>\n    :root{\n      --safe-padding: 24px;\n      --gap: 16px;\n      --accent-diag: #2ca58d;\n      --accent-side: #3b82f6;\n      --accent-tie: #8b5cf6;\n      --bg: #0f172a;\n      --panel: #0b1220;\n      --muted: #94a3b8;\n      --cell-size: 44px;\n      --cell-font: 16px;\n    }\n    /* Safe area margins */\n    html,body{\n      height:100%;\n      margin:0;\n      padding:0;\n      background:linear-gradient(180deg,#071027 0%, #081728 100%);\n      font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      color:#e6eef8;\n    }\n    body{\n      padding:var(--safe-padding);\n      box-sizing:border-box;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .container{\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      justify-content:center;\n      width:100%;\n      max-width:1500px;\n      margin:0 auto;\n      box-sizing:border-box;\n    }\n    /* Responsive: stack on narrow */\n    @media (max-width:980px){\n      .container{flex-direction:column;}\n    }\n\n    /* Left column: main interactive area */\n    .main{\n      flex:1 1 680px;\n      min-width:280px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:10px;\n      padding:16px;\n      box-sizing:border-box;\n    }\n    .side{\n      width:360px;\n      min-width:260px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius:10px;\n      padding:16px;\n      box-sizing:border-box;\n    }\n    @media (max-width:980px){\n      .side{width:100%;}\n    }\n\n    header h1{\n      margin:0 0 8px 0;\n      font-size:20px;\n      letter-spacing:0.2px;\n    }\n    header p{margin:0;color:var(--muted);font-size:13px}\n\n    .controls{\n      display:flex;\n      gap:var(--gap);\n      flex-wrap:wrap;\n      margin-top:16px;\n      align-items:center;\n    }\n    .field{\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      min-width:180px;\n      flex:1 1 220px;\n    }\n    label{font-size:13px;color:var(--muted)}\n    input[type=\"text\"]{\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.06);\n      background:rgba(255,255,255,0.02);\n      color:inherit;\n      font-size:15px;\n      outline:none;\n    }\n    input[type=\"text\"]:focus{box-shadow:0 0 0 3px rgba(59,130,246,0.12);}\n\n    .controls-row{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      margin-top:12px;\n      flex-wrap:wrap;\n    }\n    button{\n      background:linear-gradient(180deg, #1f2937, #111827);\n      color:#e6eef8;\n      border:1px solid rgba(255,255,255,0.04);\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-size:14px;\n    }\n    button[aria-pressed=\"true\"]{\n      box-shadow:0 6px 18px rgba(0,0,0,0.45);\n      transform:translateY(-1px);\n    }\n    .compact {\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n\n    /* Matrix area */\n    .matrix-wrap{\n      margin-top:var(--gap);\n      overflow:auto;\n      background:linear-gradient(180deg, rgba(255,255,255,0.008), transparent);\n      padding:12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    table.dp{\n      border-collapse:collapse;\n      font-size:var(--cell-font);\n      color:inherit;\n    }\n    table.dp caption{\n      text-align:left;\n      padding:8px 0;\n      color:var(--muted);\n      font-size:13px;\n    }\n    table.dp td, table.dp th{\n      width:var(--cell-size);\n      height:var(--cell-size);\n      min-width:var(--cell-size);\n      min-height:var(--cell-size);\n      border:1px solid rgba(255,255,255,0.04);\n      text-align:center;\n      vertical-align:middle;\n      position:relative;\n      background:rgba(255,255,255,0.01);\n      transition:background-color 300ms ease, transform 200ms ease;\n      border-radius:6px;\n      padding:4px;\n    }\n    table.dp th{\n      background:rgba(255,255,255,0.02);\n      font-weight:600;\n      color:#cfe7ff;\n    }\n    .char-cell{font-weight:700;color:#dbeafe;}\n\n    .cell-value{\n      font-size:14px;\n      font-weight:700;\n      opacity:0;\n      transform:translateY(6px);\n      transition:opacity 300ms ease, transform 300ms ease;\n      display:inline-block;\n      min-width:14px;\n    }\n    td.filled .cell-value{\n      opacity:1;\n      transform:none;\n    }\n    /* Source highlights */\n    td.source-diag{box-shadow:0 0 0 3px rgba(44,165,141,0.06) inset;}\n    td.source-side{box-shadow:0 0 0 3px rgba(59,130,246,0.06) inset;}\n    td.source-tie{box-shadow:0 0 0 3px rgba(139,92,246,0.06) inset;}\n\n    /* Predecessor pulse */\n    .pulse{\n      position:absolute;\n      inset:0;\n      border-radius:6px;\n      pointer-events:none;\n      opacity:0;\n      transform:scale(0.9);\n      transition:opacity 300ms ease, transform 300ms ease;\n      box-shadow:0 0 0 4px rgba(255,255,255,0.02) inset;\n    }\n    .pulse.on{opacity:1;transform:scale(1.02);}\n\n    /* Focus outline for accessibility */\n    td:focus{\n      outline:3px solid rgba(99,102,241,0.18);\n      outline-offset:2px;\n    }\n\n    /* Side panel */\n    .panel{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .box{\n      background:rgba(255,255,255,0.02);\n      padding:12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .muted{color:var(--muted);font-size:13px}\n    .big{\n      font-size:20px;\n      font-weight:700;\n      color:#dff6ef;\n    }\n    .lcs-result{\n      font-size:18px;\n      font-weight:700;\n      color:#ffd580;\n      min-height:28px;\n    }\n\n    /* Small helper texts */\n    .hint{font-size:13px;color:var(--muted)}\n\n    /* Responsive cell size when wide */\n    @media (min-width:1200px){\n      :root{--cell-size:56px;--cell-font:17px;}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"main\">\n    <div class=\"main\" aria-labelledby=\"title\">\n      <header>\n        <h1 id=\"title\">Interactive: Longest Common Subsequence (LCS)</h1>\n        <p>Explore how the DP matrix is filled and how backtracking recovers the LCS.</p>\n      </header>\n\n      <div class=\"controls\" aria-hidden=\"false\">\n        <div class=\"field\">\n          <label for=\"inputA\">String A (top)</label>\n          <input id=\"inputA\" type=\"text\" maxlength=\"28\" value=\"ABCBDAB\" aria-label=\"String A\">\n        </div>\n        <div class=\"field\">\n          <label for=\"inputB\">String B (left)</label>\n          <input id=\"inputB\" type=\"text\" maxlength=\"28\" value=\"BDCABC\" aria-label=\"String B\">\n        </div>\n        <div style=\"min-width:180px\">\n          <label class=\"muted\">Examples / Actions</label>\n          <div style=\"display:flex;gap:8px;margin-top:8px;\">\n            <button id=\"computeBtn\" aria-pressed=\"false\">Compute LCS</button>\n            <button id=\"randomBtn\" title=\"Random example\">Random Example</button>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"controls-row\">\n        <div class=\"compact\">\n          <button id=\"playBtn\" aria-pressed=\"false\" title=\"Play / Pause\">Play</button>\n          <button id=\"stepBackBtn\" title=\"Step Back\">&larr; Step</button>\n          <button id=\"stepFwdBtn\" title=\"Step Forward\">Step &rarr;</button>\n        </div>\n\n        <div style=\"display:flex;align-items:center;gap:8px;\">\n          <label class=\"muted\" for=\"speed\">Speed</label>\n          <input id=\"speed\" type=\"range\" min=\"0.2\" max=\"2\" step=\"0.1\" value=\"1\" style=\"width:160px\" aria-label=\"Playback speed\">\n        </div>\n\n        <div style=\"display:flex;align-items:center;gap:8px;\">\n          <input id=\"autoBack\" type=\"checkbox\" />\n          <label for=\"autoBack\" class=\"muted\">Auto-backtrack</label>\n        </div>\n\n        <div style=\"flex:1\"></div>\n\n        <div style=\"display:flex;gap:8px;\">\n          <button id=\"backtrackBtn\" style=\"display:none\">Backtrack</button>\n        </div>\n      </div>\n\n      <div class=\"matrix-wrap\" id=\"matrixWrap\" aria-live=\"polite\">\n        <!-- Matrix will be inserted here -->\n        <table class=\"dp\" id=\"dpTable\" aria-label=\"DP matrix for LCS\">\n          <caption>Press Compute to build the DP matrix</caption>\n        </table>\n      </div>\n\n      <div style=\"margin-top:var(--gap);display:flex;gap:var(--gap);flex-wrap:wrap;\">\n        <div class=\"box\" style=\"flex:1;min-width:220px;\">\n          <div class=\"muted\">Recurrence</div>\n          <div style=\"margin-top:8px;color:#dbeafe;\">\n            If A[j-1] == B[i-1]: dp[i][j] = dp[i-1][j-1] + 1 (from diagonal).<br>\n            Else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) (from top or left).\n          </div>\n        </div>\n\n        <div class=\"box\" style=\"min-width:220px;flex:1;\">\n          <div class=\"muted\">Current step</div>\n          <div id=\"stepDesc\" style=\"margin-top:8px;color:#dbeafe;\">No calculation yet.</div>\n        </div>\n      </div>\n    </div>\n\n    <aside class=\"side\" aria-labelledby=\"sideTitle\">\n      <h2 id=\"sideTitle\" style=\"margin:0;font-size:16px;\">Inspector & Result</h2>\n\n      <div class=\"panel\" style=\"margin-top:8px;\">\n        <div class=\"box\">\n          <div class=\"muted\">Cell details</div>\n          <div id=\"cellDetail\" style=\"margin-top:8px;color:#dbeafe\">Click or focus a cell to inspect how its value was derived.</div>\n        </div>\n\n        <div class=\"box\">\n          <div class=\"muted\">LCS (revealed)</div>\n          <div class=\"lcs-result\" id=\"lcsResult\">—</div>\n          <div class=\"hint\" style=\"margin-top:8px;\">Backtracking highlights the chosen path; diagonal moves add a character to the LCS.</div>\n        </div>\n\n        <div class=\"box\">\n          <div class=\"muted\">Controls hint</div>\n          <div style=\"margin-top:8px;color:#cfe7ff;\">\n            Use Play to animate filling. Step buttons step cells. Click cells to see predecessors. Toggle Auto-backtrack to run backtracking automatically after filling.\n          </div>\n        </div>\n      </div>\n    </aside>\n  </div>\n\n  <script>\n    // LCS interactive module - vanilla JS\n    (function () {\n      // DOM elements\n      const inputA = document.getElementById('inputA');\n      const inputB = document.getElementById('inputB');\n      const computeBtn = document.getElementById('computeBtn');\n      const randomBtn = document.getElementById('randomBtn');\n      const dpTable = document.getElementById('dpTable');\n      const matrixWrap = document.getElementById('matrixWrap');\n      const playBtn = document.getElementById('playBtn');\n      const stepFwdBtn = document.getElementById('stepFwdBtn');\n      const stepBackBtn = document.getElementById('stepBackBtn');\n      const speedSlider = document.getElementById('speed');\n      const stepDesc = document.getElementById('stepDesc');\n      const cellDetail = document.getElementById('cellDetail');\n      const backtrackBtn = document.getElementById('backtrackBtn');\n      const lcsResult = document.getElementById('lcsResult');\n      const autoBack = document.getElementById('autoBack');\n\n      // State\n      let A = '';\n      let B = '';\n      let dp = [];        // numeric DP matrix\n      let source = [];    // source pointers per cell\n      let steps = [];     // list of step objects: {i,j,value,sourceKind}\n      let currentStep = -1;\n      let playing = false;\n      let playTimer = null;\n      let speed = 1.0;\n      let backtrackPath = []; // array of [i,j] for backtrack\n      let cellElements = {}; // keyed by \"i,j\" store td element\n\n      // Utility\n      function clamp(n,min,max){return Math.max(min,Math.min(max,n));}\n\n      function clearTable() {\n        dpTable.innerHTML = '<caption>Press Compute to build the DP matrix</caption>';\n        cellElements = {};\n        dp = [];\n        source = [];\n        steps = [];\n        currentStep = -1;\n        backtrackPath = [];\n        stepDesc.textContent = 'No calculation yet.';\n        cellDetail.textContent = 'Click or focus a cell to inspect how its value was derived.';\n        lcsResult.textContent = '—';\n        backtrackBtn.style.display = 'none';\n      }\n\n      // Build dp arrays and precompute step sequence\n      function prepareComputation(a,b) {\n        A = a;\n        B = b;\n        const n = A.length;\n        const m = B.length;\n        // initialize dp and source matrices (size m+1 x n+1)\n        dp = Array.from({length:m+1},()=>Array(n+1).fill(0));\n        source = Array.from({length:m+1},()=>Array(n+1).fill(null));\n        steps = [];\n        // generate steps for each cell (i:1..m, j:1..n)\n        for(let i=1;i<=m;i++){\n          for(let j=1;j<=n;j++){\n            const ai = A[j-1];\n            const bi = B[i-1];\n            if(ai === bi){\n              const val = dp[i-1][j-1] + 1;\n              dp[i][j] = val;\n              source[i][j] = {kind:'diag', from:[i-1,j-1]};\n            } else {\n              const top = dp[i-1][j];\n              const left = dp[i][j-1];\n              if(top > left){\n                dp[i][j] = top;\n                source[i][j] = {kind:'top', from:[i-1,j]};\n              } else if(left > top){\n                dp[i][j] = left;\n                source[i][j] = {kind:'left', from:[i,j-1]};\n              } else {\n                dp[i][j] = top; // equal\n                source[i][j] = {kind:'tie', from:[[i-1,j],[i,j-1]]};\n              }\n            }\n            // push step snapshot (we store the computed value and source kind)\n            steps.push({\n              i, j,\n              value: dp[i][j],\n              kind: source[i][j].kind,\n              ai: A[j-1],\n              bi: B[i-1],\n              top: dp[i-1][j],\n              left: dp[i][j-1],\n              diag: dp[i-1][j-1]\n            });\n          }\n        }\n        // After filling, compute backtrack path (choose one path for demo)\n        // We'll follow standard preference: diag when match, else prefer top if >= left, else left.\n        backtrackPath = computeBacktrackPath();\n      }\n\n      function computeBacktrackPath(){\n        const path = [];\n        let i = B.length;\n        let j = A.length;\n        while(i>0 && j>0){\n          const s = source[i][j];\n          if(!s) break;\n          if(s.kind === 'diag' && A[j-1] === B[i-1]) {\n            path.push([i,j]);\n            i--; j--;\n          } else if(s.kind === 'top' || (s.kind === 'tie' && dp[i-1][j] >= dp[i][j-1])) {\n            // move up\n            path.push([i,j]);\n            i = i-1;\n          } else {\n            // left\n            path.push([i,j]);\n            j = j-1;\n          }\n        }\n        // include any remaining zero row/col if desired (not necessary)\n        return path;\n      }\n\n      // Build the HTML table with headers and initial zeros\n      function buildTable() {\n        const n = A.length;\n        const m = B.length;\n        dpTable.innerHTML = '';\n        // caption\n        const cap = document.createElement('caption');\n        cap.textContent = `DP matrix: rows = B length (${m}), cols = A length (${n}).`;\n        dpTable.appendChild(cap);\n\n        // Create top header row: empty corner then characters of A\n        const thead = document.createElement('thead');\n        const topRow = document.createElement('tr');\n        // top-left empty cell\n        const corner = document.createElement('th');\n        corner.setAttribute('scope','col');\n        corner.textContent = '';\n        corner.style.width = 'auto';\n        topRow.appendChild(corner);\n        // header row of chars\n        const emptyHeader = document.createElement('th');\n        emptyHeader.textContent = '0';\n        emptyHeader.setAttribute('scope','col');\n        topRow.appendChild(emptyHeader);\n        for(let j=0;j<n;j++){\n          const th = document.createElement('th');\n          th.className = 'char-cell';\n          th.textContent = A[j];\n          th.setAttribute('scope','col');\n          topRow.appendChild(th);\n        }\n        thead.appendChild(topRow);\n        dpTable.appendChild(thead);\n\n        // tbody with rows: each row begins with header for B char, then numeric cells\n        const tbody = document.createElement('tbody');\n        for(let i=0;i<=m;i++){\n          const tr = document.createElement('tr');\n          // first header cell for each row\n          const rowLabel = document.createElement('th');\n          rowLabel.setAttribute('scope','row');\n          if(i===0){\n            rowLabel.textContent = '0';\n          } else {\n            rowLabel.className = 'char-cell';\n            rowLabel.textContent = B[i-1];\n          }\n          tr.appendChild(rowLabel);\n\n          for(let j=0;j<=n;j++){\n            const td = document.createElement('td');\n            td.tabIndex = 0;\n            td.setAttribute('data-i', i);\n            td.setAttribute('data-j', j);\n            // value span\n            const span = document.createElement('span');\n            span.className = 'cell-value';\n            span.setAttribute('aria-hidden','true');\n            span.textContent = (i===0 || j===0) ? '0' : '';\n            td.appendChild(span);\n            // pulse overlay\n            const pulse = document.createElement('div');\n            pulse.className = 'pulse';\n            td.appendChild(pulse);\n\n            // store element\n            cellElements[`${i},${j}`] = td;\n\n            // listeners for click/focus\n            td.addEventListener('click', ()=>inspectCell(i,j));\n            td.addEventListener('focus', ()=>inspectCell(i,j));\n            tr.appendChild(td);\n          }\n          tbody.appendChild(tr);\n        }\n        dpTable.appendChild(tbody);\n      }\n\n      function inspectCell(i,j){\n        const n = A.length;\n        const m = B.length;\n        if(i<0||j<0||i>m||j>n) return;\n        const val = (i===0 || j===0) ? 0 : dp[i][j];\n        let html = `dp[${i}][${j}] = ${val}.`;\n        if(i===0||j===0){\n          html += ' (base row/column = 0)';\n        } else {\n          const s = source[i][j];\n          if(s){\n            html += ` Derived from: dp[${i-1}][${j}] = ${dp[i-1][j]}, dp[${i}][${j-1}] = ${dp[i][j-1]}, dp[${i-1}][${j-1}] = ${dp[i-1][j-1]}.`;\n            if(A[j-1] === B[i-1]){\n              html += ` Characters matched: A[${j-1}]=\"${A[j-1]}\" = B[${i-1}] — diagonal (+1).`;\n            } else {\n              if(s.kind === 'top') html += ' Chosen: top (up).';\n              else if(s.kind === 'left') html += ' Chosen: left.';\n              else if(s.kind === 'tie') html += ' Tie: both top and left have equal value.';\n            }\n          } else {\n            html += ' Not computed yet.';\n          }\n        }\n        cellDetail.textContent = html;\n      }\n\n      // Animate a single step: fill cell at stepIndex\n      function animateStep(stepIndex, immediate=false) {\n        if(stepIndex < 0 || stepIndex >= steps.length) return;\n        const step = steps[stepIndex];\n        const {i,j,value,kind,ai,bi,top,left,diag} = step;\n        const key = `${i},${j}`;\n        const td = cellElements[key];\n        if(!td) return;\n        // Update description\n        stepDesc.textContent = `Filling dp[${i}][${j}] for A=\"${ai}\", B=\"${bi}\" => ${value} (${kind})`;\n        // Show value with animation\n        const span = td.querySelector('.cell-value');\n        span.textContent = String(value);\n        // mark as filled\n        td.classList.add('filled');\n        // add source class\n        td.classList.remove('source-diag','source-side','source-tie');\n        if(kind === 'diag') td.classList.add('source-diag');\n        else if(kind === 'tie') td.classList.add('source-tie');\n        else td.classList.add('source-side');\n\n        // pulse predecessors\n        const predKeys = [];\n        if(kind === 'diag'){ predKeys.push(`${i-1},${j-1}`); }\n        else if(kind === 'top'){ predKeys.push(`${i-1},${j}`); }\n        else if(kind === 'left'){ predKeys.push(`${i},${j-1}`); }\n        else if(kind === 'tie'){ predKeys.push(`${i-1},${j}`, `${i},${j-1}`); }\n\n        predKeys.forEach(k=>{\n          const pred = cellElements[k];\n          if(pred){\n            const pulse = pred.querySelector('.pulse');\n            pulse.classList.add('on');\n            // remove pulse after short delay\n            setTimeout(()=>pulse.classList.remove('on'), Math.max(250, 600 / speed));\n          }\n        });\n\n        // brief highlight effect\n        td.style.transform = 'translateY(-3px)';\n        setTimeout(()=>td.style.transform='translateY(0)', 250);\n\n        // update cell detail if currently focused\n        const active = document.activeElement;\n        if(active === td) inspectCell(i,j);\n      }\n\n      // Clear all filled states (used when recomputing)\n      function clearFilledSet() {\n        Object.keys(cellElements).forEach(k=>{\n          const td = cellElements[k];\n          td.classList.remove('filled','source-diag','source-side','source-tie');\n          const span = td.querySelector('.cell-value');\n          const [i,j] = k.split(',').map(Number);\n          span.textContent = (i===0||j===0)? '0' : '';\n        });\n      }\n\n      // Play controls\n      function play() {\n        if(playing) return;\n        playing = true;\n        playBtn.setAttribute('aria-pressed','true');\n        playBtn.textContent = 'Pause';\n        const delayBase = 500; // ms per step at speed=1\n        function tick(){\n          if(currentStep < steps.length - 1){\n            currentStep++;\n            animateStep(currentStep);\n            scheduleNext();\n          } else {\n            // finished filling\n            stopPlay();\n            // reveal backtrack if enabled\n            backtrackBtn.style.display = 'inline-block';\n            if(autoBack.checked) {\n              animateBacktrack();\n            }\n          }\n        }\n        function scheduleNext(){\n          const d = Math.max(80, delayBase / speed);\n          playTimer = setTimeout(tick, d);\n        }\n        scheduleNext();\n      }\n\n      function stopPlay(){\n        playing = false;\n        playBtn.setAttribute('aria-pressed','false');\n        playBtn.textContent = 'Play';\n        if(playTimer) { clearTimeout(playTimer); playTimer = null; }\n      }\n\n      // Step forward/back\n      function stepForward(){\n        if(currentStep < steps.length - 1){\n          currentStep++;\n          animateStep(currentStep);\n          if(currentStep === steps.length - 1){\n            backtrackBtn.style.display = 'inline-block';\n            if(autoBack.checked) animateBacktrack();\n          }\n        }\n      }\n      function stepBack(){\n        if(currentStep >= 0){\n          // clear current cell\n          const s = steps[currentStep];\n          const td = cellElements[`${s.i},${s.j}`];\n          if(td){\n            const span = td.querySelector('.cell-value');\n            span.textContent = '';\n            td.classList.remove('filled','source-diag','source-side','source-tie');\n          }\n          currentStep--;\n          stepDesc.textContent = currentStep >= 0 ? `Stepped back to ${currentStep+1}/${steps.length}` : 'No calculation yet.';\n          lcsResult.textContent = '—';\n          backtrackBtn.style.display = 'none';\n        }\n      }\n\n      // Backtrack animation: follow backtrackPath, highlight diag moves to reveal chars\n      async function animateBacktrack(){\n        if(backtrackPath.length === 0) {\n          stepDesc.textContent = 'No backtrack path available.';\n          return;\n        }\n        // Ensure matrix is fully filled\n        if(currentStep < steps.length - 1){\n          stepDesc.textContent = 'Complete the filling before backtracking.';\n          return;\n        }\n        backtrackBtn.disabled = true;\n        // Build LCS by walking path; collect matching diag cells where characters matched.\n        const collected = [];\n        // We'll animate from start of path (bottom-right) to top-left\n        const path = backtrackPath.slice(); // already bottom-right to top-left\n        // Highlight each visited cell\n        for(let k=0;k<path.length;k++){\n          const [i,j] = path[k];\n          const td = cellElements[`${i},${j}`];\n          if(!td) continue;\n          td.style.transition = 'background-color 220ms ease, transform 240ms ease';\n          td.style.backgroundColor = 'rgba(255,255,255,0.02)';\n          td.style.transform = 'scale(1.03)';\n          // if diagonal and chars match, reveal char to LCS\n          if(A[j-1] === B[i-1]){\n            // small delay to emphasize\n            await delay(200 / speed);\n            collected.push(A[j-1]);\n            // flash the cell with diag color\n            td.style.boxShadow = `0 0 0 3px rgba(44,165,141,0.22) inset`;\n            await delay(200 / speed);\n          } else {\n            await delay(120 / speed);\n          }\n          // restore\n          td.style.transform = '';\n          td.style.boxShadow = '';\n        }\n\n        // collected currently in reverse order (from bottom-right backwards), reverse to display\n        const result = collected.reverse().join('') || '—';\n        lcsResult.textContent = result;\n        stepDesc.textContent = `Backtracking complete. LCS = \"${result}\"`;\n        backtrackBtn.disabled = false;\n      }\n\n      function delay(ms){ return new Promise(resolve => setTimeout(resolve, ms)); }\n\n      // Event handlers\n      computeBtn.addEventListener('click', ()=>{\n        const a = inputA.value.trim();\n        const b = inputB.value.trim();\n        if(a.length === 0 || b.length === 0){\n          alert('Both strings must be non-empty to compute LCS.');\n          return;\n        }\n        if(a.length > 28 || b.length > 28){\n          alert('Strings should be at most 28 characters for this demo.');\n          return;\n        }\n        stopPlay();\n        clearTable();\n        A = a;\n        B = b;\n        prepareComputation(A,B);\n        buildTable();\n        clearFilledSet();\n        currentStep = -1;\n        stepDesc.textContent = `Ready: matrix ${B.length+1} x ${A.length+1}. Press Play to animate.`;\n        backtrackBtn.style.display = 'none';\n      });\n\n      randomBtn.addEventListener('click', ()=>{\n        // generate random short strings from uppercase letters\n        const letters = 'ABCDEFXYZLMNOP';\n        const lenA = 5 + Math.floor(Math.random()*6);\n        const lenB = 5 + Math.floor(Math.random()*6);\n        const rand = (len) => Array.from({length:len},()=>letters[Math.floor(Math.random()*letters.length)]).join('');\n        inputA.value = rand(lenA);\n        inputB.value = rand(lenB);\n      });\n\n      playBtn.addEventListener('click', ()=>{\n        if(!dpTable.querySelector('tbody')){\n          alert('Press Compute to build the DP matrix first.');\n          return;\n        }\n        if(playing) stopPlay();\n        else play();\n      });\n\n      stepFwdBtn.addEventListener('click', ()=>{\n        if(!dpTable.querySelector('tbody')){\n          alert('Press Compute to build the DP matrix first.');\n          return;\n        }\n        stopPlay();\n        stepForward();\n      });\n\n      stepBackBtn.addEventListener('click', ()=>{\n        if(!dpTable.querySelector('tbody')){\n          alert('Press Compute to build the DP matrix first.');\n          return;\n        }\n        stopPlay();\n        stepBack();\n      });\n\n      speedSlider.addEventListener('input', (e)=>{\n        speed = Number(e.target.value) || 1;\n      });\n\n      backtrackBtn.addEventListener('click', async ()=>{\n        stopPlay();\n        await animateBacktrack();\n      });\n\n      // Utility: when clicking outside, pause pulses etc.\n      document.addEventListener('visibilitychange', ()=>{\n        if(document.hidden) stopPlay();\n      });\n\n      // Initialize\n      clearTable();\n      // Preload with default compute to show something\n      // auto-trigger compute for initial default values\n      computeBtn.click();\n\n    })();\n  </script>\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Longest Common Subsequence.\n\n**Project Overview:**\nTopic: Longest Common Subsequence\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Longest Common Subsequence"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "180f9640-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:50:09.893Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Knapsack Problem",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Module — Knapsack Problem (0/1)</title>\n  <style>\n    :root{\n      --safe-padding: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --muted: #9aa4b2;\n      --accent: #4f46e5;\n      --good: #059669;\n      --bad: #ef4444;\n      --glass: rgba(255,255,255,0.04);\n      --radius: 12px;\n      --max-width: 1100px;\n    }\n\n    html,body{\n      height:100%;\n      margin:0;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background: linear-gradient(180deg,#061025 0%, #071029 100%);\n      color:#e6eef8;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n\n    .wrap{\n      padding: var(--safe-padding);\n      box-sizing:border-box;\n      max-width: var(--max-width);\n      margin: 0 auto;\n      min-height:100vh;\n      display:flex;\n      flex-direction:column;\n      gap: var(--gap);\n    }\n\n    header{\n      display:flex;\n      justify-content:space-between;\n      align-items: flex-start;\n      gap: var(--gap);\n      flex-wrap:wrap;\n    }\n    .title{\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n    h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing:-0.2px;\n    }\n    p.lead{\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n      max-width:60ch;\n    }\n\n    main{\n      display:flex;\n      gap: var(--gap);\n      align-items:flex-start;\n      width:100%;\n    }\n\n    /* Left column: controls & explanation */\n    .panel{\n      flex: 0 0 380px;\n      min-width: 260px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n      border-radius: var(--radius);\n      padding: var(--gap);\n      box-sizing:border-box;\n      gap: var(--gap);\n      display:flex;\n      flex-direction:column;\n    }\n\n    .panel h2{\n      margin:0 0 4px 0;\n      font-size:16px;\n    }\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n      margin:0;\n    }\n\n    .controls{\n      display:flex;\n      gap: var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n      margin-top:8px;\n    }\n\n    .control-block{\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      min-width:120px;\n    }\n    label{\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    input[type=\"range\"]{\n      width:100%;\n    }\n    .btn{\n      background:var(--accent);\n      color:white;\n      border:0;\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      transition:transform .12s ease, box-shadow .12s ease;\n      box-shadow: 0 6px 18px rgba(79,70,229,0.12);\n    }\n    .btn.secondary{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--muted);\n      box-shadow:none;\n    }\n    .btn:active{ transform: translateY(1px); }\n\n    /* Right column: visuals */\n    .visual{\n      flex:1 1 auto;\n      min-width:320px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: var(--radius);\n      padding: var(--gap);\n      display:flex;\n      flex-direction:column;\n      gap: var(--gap);\n      box-sizing:border-box;\n    }\n\n    .top-row{\n      display:flex;\n      justify-content:space-between;\n      gap: var(--gap);\n      align-items:center;\n    }\n\n    .items-area{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      padding:8px;\n      border-radius:10px;\n      background: var(--glass);\n    }\n\n    .items-list{\n      display:flex;\n      flex-wrap:wrap;\n      gap:12px;\n      align-items:flex-start;\n    }\n\n    .item{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:10px;\n      padding:10px 12px;\n      min-width:110px;\n      display:flex;\n      gap:8px;\n      align-items:center;\n      cursor:grab;\n      border:1px solid rgba(255,255,255,0.03);\n      transition:transform .14s ease, box-shadow .14s ease;\n      user-select:none;\n    }\n\n    .item:active{ cursor:grabbing; transform:scale(.995); }\n    .item .meta{\n      display:flex;\n      flex-direction:column;\n      gap:4px;\n    }\n    .badge{\n      font-size:12px;\n      padding:6px 8px;\n      border-radius:10px;\n      color:white;\n      font-weight:700;\n    }\n    .w-badge{ background: linear-gradient(180deg,#0ea5a7,#0891b2); }\n    .v-badge{ background: linear-gradient(180deg,#f97316,#fb923c); }\n\n    .knapsack{\n      margin-top:12px;\n      border-radius:12px;\n      min-height:140px;\n      position:relative;\n      padding:14px;\n      background: linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border:1px dashed rgba(255,255,255,0.03);\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      align-items:flex-start;\n      overflow:hidden;\n    }\n\n    .capacity-row{\n      width:100%;\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content:space-between;\n    }\n\n    .progress-bar{\n      height:12px;\n      background: rgba(255,255,255,0.03);\n      border-radius:999px;\n      flex:1;\n      overflow:hidden;\n      display:flex;\n      align-items:center;\n    }\n\n    .progress-fill{\n      height:100%;\n      background: linear-gradient(90deg,var(--accent),#06b6d4);\n      width:0%;\n      transition: width .4s ease, background .2s ease;\n    }\n\n    .status{\n      font-size:13px;\n      font-weight:700;\n      min-width:84px;\n      text-align:right;\n    }\n\n    .knap-items{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n      align-items:center;\n    }\n\n    .small{\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* DP table */\n    .dp-area{\n      margin-top:12px;\n      border-radius:10px;\n      padding:12px;\n      background: rgba(255,255,255,0.02);\n      overflow:auto;\n    }\n\n    table.dp{\n      border-collapse:collapse;\n      font-size:13px;\n      min-width:480px;\n    }\n    table.dp td, table.dp th{\n      border:1px solid rgba(255,255,255,0.03);\n      padding:6px 8px;\n      text-align:center;\n      min-width:36px;\n      white-space:nowrap;\n    }\n    table.dp td.active{\n      background: linear-gradient(90deg, rgba(79,70,229,0.12), rgba(6,182,212,0.06));\n      transition: background .18s ease;\n      font-weight:700;\n      color:white;\n    }\n    table.dp td.chosen{\n      box-shadow: inset 0 0 0 2px rgba(5,150,105,0.16);\n      background: linear-gradient(90deg, rgba(5,150,105,0.12), rgba(79,70,229,0.06));\n    }\n\n    /* small helpers */\n    .flex{\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n\n    .controls-row{\n      display:flex;\n      gap:12px;\n      margin-top:8px;\n      flex-wrap:wrap;\n    }\n\n    /* responsive */\n    @media (max-width: 980px){\n      main{ flex-direction:column; }\n      .panel{ width:100%; }\n      .visual{ width:100%; }\n    }\n\n    /* focus & accessibility */\n    button:focus, .btn:focus, input:focus, .item:focus{\n      outline: 3px solid rgba(79,70,229,0.24);\n      outline-offset:2px;\n    }\n\n    /* animation helper for flying items */\n    .flying-clone{\n      position:fixed;\n      z-index:9999;\n      transition: transform .45s cubic-bezier(.2,.9,.25,1), opacity .3s ease;\n      pointer-events:none;\n      will-change:transform, opacity;\n    }\n\n    .note{\n      color:var(--muted);\n      font-size:13px;\n      background:transparent;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"wrap\" role=\"main\">\n    <header>\n      <div class=\"title\" aria-hidden=\"false\">\n        <h1>Knapsack Problem — Interactive 0/1 Exploration</h1>\n        <p class=\"lead\">Drag items into the knapsack, adjust capacity, and visualize the dynamic programming table that finds the optimal selection. Animations show how choices are made.</p>\n      </div>\n      <div style=\"min-width:220px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;\">\n        <div class=\"small muted\">Safe area: 24px — Spacing: 16px</div>\n        <button class=\"btn\" id=\"helpBtn\" title=\"Show learning objective\">Learning objective</button>\n      </div>\n    </header>\n\n    <main>\n      <!-- Left panel contains overview, controls, and explanations -->\n      <aside class=\"panel\" aria-labelledby=\"conceptTitle\">\n        <h2 id=\"conceptTitle\">Concept Title</h2>\n        <p class=\"muted\">0/1 Knapsack: choose a subset of items (each either taken or not) to maximize total value without exceeding capacity.</p>\n\n        <h2>Learning Objective</h2>\n        <p class=\"muted\">After interacting with this module you will:\n          <ul style=\"margin:6px 0 0 18px; color:var(--muted); padding:0;\">\n            <li>Understand how item weight/value trade-offs affect selection</li>\n            <li>See how the dynamic programming table computes optimal value step-by-step</li>\n            <li>Compare manual selections to the algorithm's optimal set</li>\n          </ul>\n        </p>\n\n        <div style=\"height:8px;\"></div>\n\n        <div class=\"controls\" aria-hidden=\"false\">\n          <div class=\"control-block\" style=\"min-width:160px;\">\n            <label for=\"capacityRange\">Knapsack capacity</label>\n            <input id=\"capacityRange\" type=\"range\" min=\"5\" max=\"60\" value=\"25\" aria-describedby=\"capacityVal\" />\n            <div class=\"flex\" style=\"justify-content:space-between;\">\n              <div class=\"small\">Capacity limit</div>\n              <div id=\"capacityVal\" class=\"small\" style=\"font-weight:700\">25</div>\n            </div>\n          </div>\n\n          <div class=\"control-block\" style=\"min-width:140px;\">\n            <label for=\"maxItems\">Items</label>\n            <div style=\"display:flex; gap:8px; align-items:center;\">\n              <input id=\"maxItems\" type=\"number\" min=\"3\" max=\"10\" value=\"6\" step=\"1\" style=\"width:64px; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit;\" />\n              <button class=\"btn secondary\" id=\"regen\">New set</button>\n            </div>\n            <div class=\"small muted\" style=\"margin-top:6px;\">Randomize item list (weights 1–20, values 1–50)</div>\n          </div>\n        </div>\n\n        <div class=\"controls-row\">\n          <button class=\"btn\" id=\"computeBtn\">Compute Optimal</button>\n          <button class=\"btn secondary\" id=\"clearBtn\">Clear Knapsack</button>\n          <button class=\"btn secondary\" id=\"resetBtn\">Reset Items</button>\n        </div>\n\n        <div style=\"margin-top:var(--gap);\">\n          <h2 style=\"margin-bottom:6px;\">Interaction Design</h2>\n          <p class=\"muted\">How to interact:\n            <ul style=\"margin:6px 0 0 18px; color:var(--muted); padding:0;\">\n              <li>Drag an item from the left list into the knapsack area (or click to toggle).</li>\n              <li>Adjust capacity with the slider. The weight bar animates to show fill.</li>\n              <li>Press Compute Optimal to see the DP table fill step-by-step and auto-select the best subset.</li>\n              <li>If selection exceeds capacity, the status turns red and prevents Compute from accepting that manual selection as optimal.</li>\n            </ul>\n          </p>\n        </div>\n\n        <div style=\"margin-top:6px;\">\n          <h2 style=\"margin-bottom:6px;\">Layout Description</h2>\n          <p class=\"muted\">A two-column layout:\n            <ul style=\"margin:6px 0 0 18px; color:var(--muted); padding:0;\">\n              <li>Left panel: explanations and controls (capacity slider, number of items, action buttons).</li>\n              <li>Right panel: interactive visualization — item list, knapsack dropzone, progress bar, and DP table.</li>\n              <li>Spacing: 24px padding on all sides, minimum 16px gap between interactive elements. Responsive: stacks vertically on narrow viewports.</li>\n            </ul>\n          </p>\n        </div>\n      </aside>\n\n      <!-- Right visual area -->\n      <section class=\"visual\" aria-live=\"polite\">\n        <div class=\"top-row\">\n          <div style=\"flex:1;\">\n            <h2 style=\"margin:0 0 6px 0;\">Available Items</h2>\n            <div class=\"items-area\" aria-label=\"Available items\">\n              <div class=\"items-list\" id=\"itemsList\" tabindex=\"0\">\n                <!-- Items generated by JS -->\n              </div>\n            </div>\n            <div style=\"margin-top:8px; display:flex; gap:12px; align-items:center;\">\n              <div class=\"note\">Tip: drag items to the knapsack, or select and press \"Add to knapsack\" (keyboard accessible).</div>\n              <div style=\"margin-left:auto; display:flex; gap:8px;\">\n                <button class=\"btn secondary\" id=\"addBtn\">Add selected</button>\n                <button class=\"btn secondary\" id=\"removeBtn\">Remove selected</button>\n              </div>\n            </div>\n          </div>\n\n          <div style=\"width:320px;\">\n            <h2 style=\"margin:0 0 6px 0;\">Knapsack</h2>\n            <div class=\"knapsack\" id=\"knapsack\" aria-label=\"Knapsack dropzone\" tabindex=\"0\">\n              <div class=\"capacity-row\">\n                <div style=\"display:flex; flex-direction:column;\">\n                  <div class=\"small\">Capacity</div>\n                  <div style=\"font-weight:800; font-size:18px;\" id=\"capDisplay\">25</div>\n                </div>\n\n                <div class=\"progress-bar\" aria-hidden=\"true\">\n                  <div class=\"progress-fill\" id=\"progressFill\" style=\"width:0%\"></div>\n                </div>\n\n                <div class=\"status\" id=\"capStatus\">0 / 25</div>\n              </div>\n\n              <div class=\"knap-items\" id=\"knapItems\" aria-live=\"polite\" style=\"min-height:40px;\">\n                <!-- dropped items appear here -->\n              </div>\n\n              <div style=\"width:100%; display:flex; justify-content:space-between; align-items:center; margin-top:6px;\">\n                <div class=\"small muted\">Total value: <span id=\"totalValue\" style=\"font-weight:800\">0</span></div>\n                <div class=\"small muted\">Total weight: <span id=\"totalWeight\" style=\"font-weight:800\">0</span></div>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"dp-area\" aria-live=\"polite\" id=\"dpArea\" style=\"margin-top:12px;\">\n          <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n            <div>\n              <h2 style=\"margin:0 0 6px 0;\">Dynamic Programming Table (0/1)</h2>\n              <div class=\"small muted\">Watch the table fill. Highlighted cells show the best known value at each step.</div>\n            </div>\n            <div class=\"small muted\">Capacity columns: 0..W</div>\n          </div>\n\n          <div style=\"margin-top:12px; overflow:auto;\">\n            <table class=\"dp\" id=\"dpTable\" role=\"table\" aria-label=\"Dynamic programming table\"></table>\n          </div>\n        </div>\n      </section>\n    </main>\n  </div>\n\n  <script>\n    // Utility and state\n    (function(){\n      const itemsListEl = document.getElementById('itemsList');\n      const knapEl = document.getElementById('knapsack');\n      const knapItemsEl = document.getElementById('knapItems');\n      const capacityRange = document.getElementById('capacityRange');\n      const capacityVal = document.getElementById('capacityVal');\n      const capDisplay = document.getElementById('capDisplay');\n      const capStatus = document.getElementById('capStatus');\n      const progressFill = document.getElementById('progressFill');\n      const totalValueEl = document.getElementById('totalValue');\n      const totalWeightEl = document.getElementById('totalWeight');\n      const regenBtn = document.getElementById('regen');\n      const computeBtn = document.getElementById('computeBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const dpTableEl = document.getElementById('dpTable');\n      const maxItemsInput = document.getElementById('maxItems');\n      const addBtn = document.getElementById('addBtn');\n      const removeBtn = document.getElementById('removeBtn');\n      const helpBtn = document.getElementById('helpBtn');\n\n      let capacity = parseInt(capacityRange.value,10);\n      let items = []; // {id,w,v,el}\n      let selectedItemId = null;\n      let inKnap = new Set();\n\n      // Initialize\n      function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }\n\n      function createItems(n){\n        items = [];\n        for(let i=0;i<n;i++){\n          const w = rand(1,20);\n          const v = rand(1,50);\n          items.push({ id: 'i'+i, w, v });\n        }\n        renderItems();\n        clearKnapsack();\n      }\n\n      function renderItems(){\n        itemsListEl.innerHTML = '';\n        items.forEach(it=>{\n          const el = document.createElement('div');\n          el.className = 'item';\n          el.setAttribute('draggable','true');\n          el.setAttribute('tabindex','0');\n          el.id = 'item-' + it.id;\n          el.dataset.id = it.id;\n          el.innerHTML = `\n            <div style=\"display:flex; flex-direction:column;\">\n              <div style=\"font-weight:700\">${'Item ' + it.id.slice(1)}</div>\n              <div class=\"small muted\">weight ${it.w} · value ${it.v}</div>\n            </div>\n            <div style=\"margin-left:auto; display:flex; gap:6px;\">\n              <div class=\"badge w-badge\">${it.w}</div>\n              <div class=\"badge v-badge\">${it.v}</div>\n            </div>\n          `;\n          // event handlers\n          el.addEventListener('dragstart', onDragStart);\n          el.addEventListener('click', ()=>toggleSelect(it.id));\n          el.addEventListener('keydown', (e)=>{\n            if(e.key === 'Enter' || e.key === ' '){\n              e.preventDefault();\n              toggleSelect(it.id);\n            }\n            if(e.key === 'a'){ // quick add via keyboard\n              addToKnapsackById(it.id);\n            }\n          });\n          itemsListEl.appendChild(el);\n          it.el = el;\n        });\n      }\n\n      function toggleSelect(id){\n        // visually select a single item; used by Add/Remove buttons\n        if(selectedItemId === id) {\n          selectedItemId = null;\n          updateSelectionVisual();\n          return;\n        }\n        selectedItemId = id;\n        updateSelectionVisual();\n      }\n      function updateSelectionVisual(){\n        items.forEach(it=>{\n          if(it.id === selectedItemId){\n            it.el.style.boxShadow = '0 6px 18px rgba(79,70,229,0.12)';\n            it.el.style.border = '1px solid rgba(79,70,229,0.14)';\n          } else {\n            it.el.style.boxShadow = 'none';\n            it.el.style.border = '1px solid rgba(255,255,255,0.03)';\n          }\n        });\n      }\n\n      // Drag & Drop handlers\n      let draggingId = null;\n      function onDragStart(e){\n        const id = e.currentTarget.dataset.id;\n        draggingId = id;\n        e.dataTransfer.setData('text/plain', id);\n        // create a ghost dragging image\n        const crt = e.currentTarget.cloneNode(true);\n        crt.style.width = getComputedStyle(e.currentTarget).width;\n        crt.style.boxShadow = '0 20px 40px rgba(0,0,0,0.6)';\n        crt.classList.add('flying-clone');\n        document.body.appendChild(crt);\n        e.dataTransfer.setDragImage(crt, 40, 20);\n        setTimeout(()=>document.body.removeChild(crt), 0);\n      }\n\n      knapEl.addEventListener('dragover', (e)=>{ e.preventDefault(); knapEl.style.borderColor = 'rgba(79,70,229,0.18)';});\n      knapEl.addEventListener('dragleave', ()=>{ knapEl.style.borderColor = 'rgba(255,255,255,0.03)';});\n      knapEl.addEventListener('drop', (e)=>{\n        e.preventDefault();\n        knapEl.style.borderColor = 'rgba(255,255,255,0.03)';\n        const id = e.dataTransfer.getData('text/plain') || draggingId;\n        if(id) addToKnapsackById(id);\n        draggingId = null;\n      });\n\n      // Add / Remove by id\n      function addToKnapsackById(id){\n        if(inKnap.has(id)) return; // already in knapsack\n        inKnap.add(id);\n        animateAddItem(id);\n        updateTotals();\n      }\n\n      function removeFromKnapsackById(id){\n        if(!inKnap.has(id)) return;\n        inKnap.delete(id);\n        const el = knapItemsEl.querySelector('[data-id=\"'+id+'\"]');\n        if(el) el.remove();\n        updateTotals();\n      }\n\n      // Clicking in knapsack to remove\n      knapItemsEl.addEventListener('click', (e)=>{\n        const card = e.target.closest('.item');\n        if(card && card.dataset.id){\n          removeFromKnapsackById(card.dataset.id);\n        }\n      });\n\n      // Keyboard support: add/remove selected\n      addBtn.addEventListener('click', ()=>{\n        if(selectedItemId) addToKnapsackById(selectedItemId);\n      });\n      removeBtn.addEventListener('click', ()=>{\n        if(selectedItemId) removeFromKnapsackById(selectedItemId);\n      });\n\n      // Animates copying visual from items list to knapsack area\n      function animateAddItem(id){\n        const it = items.find(x=>x.id===id);\n        if(!it) return;\n        const source = it.el;\n        const clone = source.cloneNode(true);\n        clone.classList.add('flying-clone');\n        document.body.appendChild(clone);\n        const srcRect = source.getBoundingClientRect();\n        const destRect = knapItemsEl.getBoundingClientRect();\n        // place clone at source\n        clone.style.left = srcRect.left + 'px';\n        clone.style.top = srcRect.top + 'px';\n        clone.style.width = srcRect.width + 'px';\n        clone.style.opacity = '1';\n        // compute target position\n        const targetX = destRect.left + 8 + (knapItemsEl.children.length % 6) * 120;\n        const targetY = destRect.top + Math.floor(knapItemsEl.children.length / 6) * 48;\n        // use transform to animate\n        requestAnimationFrame(()=>{\n          clone.style.transform = `translate(${targetX - srcRect.left}px, ${targetY - srcRect.top}px) scale(.94)`;\n          clone.style.opacity = '0.98';\n        });\n        setTimeout(()=>{\n          // append a real item inside knapsack\n          const knEl = source.cloneNode(true);\n          knEl.classList.remove('flying-clone');\n          knEl.style.cursor = 'pointer';\n          knEl.style.transform = 'none';\n          knEl.style.boxShadow = 'none';\n          knEl.setAttribute('data-id', id);\n          // adjust look slightly\n          knEl.querySelector('.badge').style.opacity = '1';\n          knapItemsEl.appendChild(knEl);\n          updateTotals();\n          // fade & remove clone\n          clone.style.opacity = '0';\n          clone.style.transform += ' scale(.86)';\n          setTimeout(()=>{ if(clone.parentNode) clone.parentNode.removeChild(clone); }, 400);\n        }, 420);\n      }\n\n      // Totals & progress\n      function updateTotals(){\n        const chosen = Array.from(inKnap).map(id => items.find(x=>x.id===id));\n        const totalW = chosen.reduce((s, it)=> s + (it ? it.w : 0), 0);\n        const totalV = chosen.reduce((s, it)=> s + (it ? it.v : 0), 0);\n        totalWeightEl.textContent = totalW;\n        totalValueEl.textContent = totalV;\n        capStatus.textContent = `${totalW} / ${capacity}`;\n        const pct = Math.min(100, Math.round(totalW / capacity * 100));\n        progressFill.style.width = pct + '%';\n        if(totalW > capacity){\n          progressFill.style.background = 'linear-gradient(90deg,var(--bad), #fb7185)';\n          capStatus.style.color = 'var(--bad)';\n        } else {\n          progressFill.style.background = '';\n          capStatus.style.color = '';\n        }\n      }\n\n      // Clear knapsack\n      function clearKnapsack(){\n        inKnap.clear();\n        knapItemsEl.innerHTML = '';\n        updateTotals();\n      }\n\n      // Reset items to current list\n      function resetItems(){\n        renderItems();\n        clearKnapsack();\n      }\n\n      // DP Table visualization\n      async function computeOptimal(){\n        computeBtn.disabled = true;\n        const n = items.length;\n        const W = capacity;\n        // prepare DP matrix (n+1) x (W+1)\n        const dp = Array.from({length: n+1}, ()=> new Array(W+1).fill(0));\n        // build table visually\n        buildEmptyTable(n, W);\n        // animate filling\n        for(let i=1;i<=n;i++){\n          const it = items[i-1];\n          for(let w=0; w<=W; w++){\n            // highlight current cell\n            highlightCell(i, w, 'active');\n            await sleep(20);\n            if(it.w <= w){\n              const without = dp[i-1][w];\n              const withVal = dp[i-1][w - it.w] + it.v;\n              dp[i][w] = Math.max(without, withVal);\n            } else {\n              dp[i][w] = dp[i-1][w];\n            }\n            // update cell text\n            setCellValue(i, w, dp[i][w]);\n            await sleep(24);\n            highlightCell(i, w, ''); // remove active\n          }\n        }\n        // backtrack to find chosen items\n        const chosen = [];\n        let w = W;\n        for(let i = n; i>0; i--){\n          if(dp[i][w] !== dp[i-1][w]){\n            // item i-1 chosen\n            chosen.push(items[i-1].id);\n            highlightCell(i, w, 'chosen');\n            w -= items[i-1].w;\n          }\n        }\n        // animate selected items into knapsack\n        // clear existing knapsack first so animation is clear\n        clearKnapsack();\n        await sleep(350);\n        for(let i = chosen.length - 1; i >= 0; i--){\n          addToKnapsackById(chosen[i]);\n          await sleep(260);\n        }\n        computeBtn.disabled = false;\n      }\n\n      function buildEmptyTable(n,W){\n        dpTableEl.innerHTML = '';\n        // header row\n        const header = document.createElement('tr');\n        header.appendChild(document.createElement('th')); // corner\n        for(let w=0; w<=W; w++){\n          const th = document.createElement('th');\n          th.textContent = w;\n          header.appendChild(th);\n        }\n        dpTableEl.appendChild(header);\n        // rows for each item\n        for(let i=0;i<=n;i++){\n          const tr = document.createElement('tr');\n          const firstCell = document.createElement('th');\n          firstCell.textContent = (i===0) ? '0 (base)' : `Item ${items[i-1].id.slice(1)} (w${items[i-1].w},v${items[i-1].v})`;\n          tr.appendChild(firstCell);\n          for(let w=0; w<=W; w++){\n            const td = document.createElement('td');\n            td.dataset.row = i;\n            td.dataset.col = w;\n            td.textContent = '0';\n            tr.appendChild(td);\n          }\n          dpTableEl.appendChild(tr);\n        }\n      }\n\n      function setCellValue(i,w,val){\n        const td = dpTableEl.querySelector('td[data-row=\"'+i+'\"][data-col=\"'+w+'\"]');\n        if(td) td.textContent = val;\n      }\n      function highlightCell(i,w,cls){\n        const td = dpTableEl.querySelector('td[data-row=\"'+i+'\"][data-col=\"'+w+'\"]');\n        if(!td) return;\n        td.classList.remove('active','chosen');\n        if(cls) td.classList.add(cls);\n      }\n\n      function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }\n\n      // Event wiring\n      capacityRange.addEventListener('input', (e)=>{\n        capacity = parseInt(e.target.value,10);\n        capacityVal.textContent = capacity;\n        capDisplay.textContent = capacity;\n        updateTotals();\n      });\n\n      regenBtn.addEventListener('click', ()=>{\n        const n = Math.max(3, Math.min(10, parseInt(maxItemsInput.value,10) || 6));\n        maxItemsInput.value = n;\n        createItems(n);\n      });\n\n      computeBtn.addEventListener('click', async ()=>{\n        // cap sanity\n        if(items.length === 0) return;\n        // ensure capacity reasonable\n        if(capacity > 120) {\n          alert('Capacity too large for visualization. Reduce it.');\n          return;\n        }\n        await computeOptimal();\n      });\n\n      clearBtn.addEventListener('click', ()=>{\n        clearKnapsack();\n      });\n\n      resetBtn.addEventListener('click', ()=>{\n        resetItems();\n      });\n\n      helpBtn.addEventListener('click', ()=>{\n        alert(\"Learning Objective:\\n\\n• Understand how item weights and values influence selection.\\n• Watch the dynamic programming table compute optimal value step-by-step.\\n\\nTry dragging items or pressing 'Compute Optimal'.\");\n      });\n\n      // init defaults\n      createItems(parseInt(maxItemsInput.value,10) || 6);\n      updateTotals();\n\n      // Ensure keyboard users can drop: pressing Enter on knapsack adds selected\n      knapEl.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter' && selectedItemId){\n          addToKnapsackById(selectedItemId);\n        }\n      });\n\n      // Accessibility: allow selecting item with arrow keys inside itemsList\n      itemsListEl.addEventListener('keydown', (e)=>{\n        const focusable = Array.from(itemsListEl.querySelectorAll('.item'));\n        if(!focusable.length) return;\n        const idx = focusable.indexOf(document.activeElement);\n        if(e.key === 'ArrowRight' || e.key === 'ArrowDown'){\n          e.preventDefault();\n          const next = focusable[Math.min(focusable.length-1, (idx===-1?0:idx+1))];\n          next.focus();\n        } else if(e.key === 'ArrowLeft' || e.key === 'ArrowUp'){\n          e.preventDefault();\n          const prev = focusable[Math.max(0, (idx<=0?0:idx-1))];\n          prev.focus();\n        }\n      });\n\n      // Provide window resize safe recalculation for animation; nothing extra needed here.\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Knapsack Problem.\n\n**Project Overview:**\nTopic: Knapsack Problem\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Knapsack Problem"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Knapsack Interactive Application",
      "description": "Finite state machine modeling user interactions, animations, and data-processing phases of the 0/1 knapsack interactive visualization (item selection, drag/drop, capacity changes, DP compute animation and result application).",
      "states": [
        {
          "name": "idle",
          "onEnter": "renderItems",
          "onExit": "noop",
          "on": {
            "SELECT_ITEM": "selected",
            "START_DRAG": "dragging",
            "PRESS_COMPUTE": "computing_filling",
            "PRESS_REGEN": "regenerating",
            "PRESS_RESET": "resetting",
            "PRESS_CLEAR": "clearing",
            "PRESS_ADD": "adding",
            "PRESS_REMOVE": "removing",
            "CHANGE_CAPACITY": "changing_capacity",
            "OPEN_HELP": "help_open",
            "DRAG_START": "dragging"
          }
        },
        {
          "name": "selected",
          "onEnter": "updateSelectionVisual",
          "onExit": "clearSelectionVisual",
          "on": {
            "DESELECT_ITEM": "idle",
            "PRESS_ADD": "adding",
            "PRESS_REMOVE": "removing",
            "START_DRAG": "dragging",
            "PRESS_COMPUTE": "computing_filling",
            "CHANGE_CAPACITY": "changing_capacity",
            "OPEN_HELP": "help_open"
          }
        },
        {
          "name": "dragging",
          "onEnter": "setDraggingId",
          "onExit": "clearDraggingId",
          "on": {
            "DRAG_OVER_KNAPSACK": "drag_over_knapsack",
            "DRAG_LEAVE_KNAPSACK": "idle",
            "DROP_ON_KNAPSACK": "adding_from_drag",
            "DRAG_CANCEL": "idle"
          }
        },
        {
          "name": "drag_over_knapsack",
          "onEnter": "highlightKnapsack",
          "onExit": "unhighlightKnapsack",
          "on": {
            "DROP_ON_KNAPSACK": "adding_from_drag",
            "DRAG_LEAVE_KNAPSACK": "dragging",
            "DRAG_CANCEL": "dragging"
          }
        },
        {
          "name": "adding",
          "onEnter": "addToKnapsack",
          "onExit": "noop",
          "on": {
            "ACTION_COMPLETE": "totals_check",
            "CANCEL": "idle"
          }
        },
        {
          "name": "adding_from_drag",
          "onEnter": "addToKnapsackFromDrag",
          "onExit": "noop",
          "on": {
            "ACTION_COMPLETE": "totals_check",
            "CANCEL": "idle"
          }
        },
        {
          "name": "removing",
          "onEnter": "removeFromKnapsack",
          "onExit": "noop",
          "on": {
            "ACTION_COMPLETE": "totals_check",
            "CANCEL": "idle"
          }
        },
        {
          "name": "clearing",
          "onEnter": "clearKnapsack",
          "onExit": "noop",
          "on": {
            "ACTION_COMPLETE": "totals_check"
          }
        },
        {
          "name": "resetting",
          "onEnter": "resetItems",
          "onExit": "noop",
          "on": {
            "ACTION_COMPLETE": "totals_check"
          }
        },
        {
          "name": "regenerating",
          "onEnter": "createItems",
          "onExit": "noop",
          "on": {
            "ACTION_COMPLETE": "totals_check"
          }
        },
        {
          "name": "changing_capacity",
          "onEnter": "changeCapacity",
          "onExit": "noop",
          "on": {
            "ACTION_COMPLETE": "totals_check"
          }
        },
        {
          "name": "totals_check",
          "onEnter": "updateTotals",
          "onExit": "noop",
          "on": {
            "TOTALS_OK": "idle",
            "TOTALS_OVER": "over_capacity"
          }
        },
        {
          "name": "over_capacity",
          "onEnter": "highlightOverCapacity",
          "onExit": "unhighlightOverCapacity",
          "on": {
            "PRESS_CLEAR": "clearing",
            "PRESS_REMOVE": "removing",
            "CHANGE_CAPACITY": "changing_capacity",
            "PRESS_COMPUTE": "computing_filling",
            "TOTALS_OK": "idle",
            "DESELECT_ITEM": "idle",
            "OPEN_HELP": "help_open"
          }
        },
        {
          "name": "computing_filling",
          "onEnter": "disableCompute; buildEmptyTable; startDpFillAnimation",
          "onExit": "noop",
          "on": {
            "FILL_COMPLETE": "computing_backtracking",
            "CANCEL_COMPUTE": "computed_done",
            "ERROR": "computed_done"
          }
        },
        {
          "name": "computing_backtracking",
          "onEnter": "highlightBacktrack",
          "onExit": "noop",
          "on": {
            "BACKTRACK_COMPLETE": "computing_animating_adds",
            "CANCEL_COMPUTE": "computed_done"
          }
        },
        {
          "name": "computing_animating_adds",
          "onEnter": "clearKnapsack; animateAddingChosen; enableCompute",
          "onExit": "noop",
          "on": {
            "ANIM_ADDS_COMPLETE": "computed_done",
            "CANCEL_COMPUTE": "computed_done"
          }
        },
        {
          "name": "computed_done",
          "onEnter": "updateTotals",
          "onExit": "noop",
          "on": {
            "PRESS_COMPUTE": "computing_filling",
            "PRESS_CLEAR": "clearing",
            "PRESS_RESET": "resetting",
            "PRESS_REGEN": "regenerating",
            "SELECT_ITEM": "selected",
            "OPEN_HELP": "help_open"
          }
        },
        {
          "name": "help_open",
          "onEnter": "showHelp",
          "onExit": "noop",
          "on": {
            "CLOSE_HELP": "idle"
          }
        }
      ],
      "events": [
        "SELECT_ITEM",
        "DESELECT_ITEM",
        "START_DRAG",
        "DRAG_OVER_KNAPSACK",
        "DRAG_LEAVE_KNAPSACK",
        "DROP_ON_KNAPSACK",
        "DRAG_CANCEL",
        "PRESS_ADD",
        "PRESS_REMOVE",
        "PRESS_CLEAR",
        "PRESS_RESET",
        "PRESS_REGEN",
        "CHANGE_CAPACITY",
        "PRESS_COMPUTE",
        "FILL_COMPLETE",
        "BACKTRACK_COMPLETE",
        "ANIM_ADDS_COMPLETE",
        "ACTION_COMPLETE",
        "TOTALS_OK",
        "TOTALS_OVER",
        "CANCEL_COMPUTE",
        "ERROR",
        "OPEN_HELP",
        "CLOSE_HELP",
        "DRAG_START",
        "DRAG_END"
      ],
      "notes": "States capture selection, drag/drop, capacity evaluation (over_capacity), DP compute phases (filling, backtrack, animating adds), and auxiliary actions (regen/reset/clear). Action states (adding, removing, clearing, resetting, regenerating, changing_capacity, adding_from_drag) perform the side-effect in onEnter and emit ACTION_COMPLETE, which triggers totals_check; totals_check routes to idle or over_capacity via TOTALS_OK/TOTALS_OVER depending on updateTotals outcome. Computing states disable the compute control during animation and re-enable after animating chosen items."
    }
  },
  {
    "id": "37e80d80-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:50:14.232Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Huffman Coding",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Huffman Coding Module</title>\n  <style>\n    /* Safe area margins: 24px on all sides */\n    html,body {\n      height: 100%;\n      margin: 0;\n    }\n    body {\n      font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      padding: 24px;\n      box-sizing: border-box;\n      background: linear-gradient(180deg,#f7fbff,#ffffff);\n      color: #0b2545;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n\n    /* Layout: responsive two-column, stacks on narrow screens */\n    .container {\n      display: grid;\n      grid-template-columns: 380px 1fr;\n      gap: 24px; /* ensure at least 16px between elements; using 24 for comfortable spacing */\n      min-height: calc(100vh - 48px);\n      align-items: start;\n    }\n\n    @media (max-width: 880px) {\n      .container {\n        grid-template-columns: 1fr;\n      }\n    }\n\n    /* Left panel: controls and description */\n    .panel {\n      background: #ffffff;\n      border-radius: 10px;\n      box-shadow: 0 6px 18px rgba(8,30,63,0.08);\n      padding: 20px;\n      display: flex;\n      flex-direction: column;\n      gap: 16px;\n    }\n\n    h1 {\n      margin: 0;\n      font-size: 20px;\n      color: #04213a;\n      display: flex;\n      align-items: center;\n      gap: 10px;\n    }\n\n    .meta {\n      font-size: 13px;\n      color: #25425a;\n      line-height: 1.35;\n    }\n\n    /* Symbol editor */\n    .symbols {\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n      margin-top: 6px;\n    }\n\n    .symbol-row {\n      display: grid;\n      grid-template-columns: 60px 1fr 80px;\n      gap: 12px;\n      align-items: center;\n    }\n\n    .symbol-row input[type=\"text\"],\n    .symbol-row input[type=\"number\"] {\n      padding: 8px 10px;\n      border-radius: 8px;\n      border: 1px solid #d6e2ee;\n      font-size: 14px;\n      background: #fbfdff;\n    }\n\n    .symbol-row button {\n      padding: 8px 10px;\n      border-radius: 8px;\n      border: none;\n      background: #0b66ff;\n      color: white;\n      font-weight: 600;\n      cursor: pointer;\n      transition: transform .12s ease;\n    }\n    .symbol-row button:active { transform: scale(.98); }\n\n    .controls {\n      display: flex;\n      gap: 12px;\n      flex-wrap: wrap;\n    }\n\n    button.control {\n      padding: 8px 12px;\n      border-radius: 8px;\n      border: 1px solid rgba(11,102,255,0.12);\n      background: #fff;\n      color: #063b7a;\n      font-weight: 600;\n      cursor: pointer;\n    }\n\n    button.control.primary {\n      background: linear-gradient(180deg,#0b66ff,#0954d1);\n      color: white;\n      border: none;\n      box-shadow: 0 6px 18px rgba(11,102,255,0.12);\n    }\n\n    button.control.secondary {\n      background: #f6f9ff;\n      color: #063b7a;\n    }\n\n    /* Priority queue display */\n    .queue-box {\n      background: linear-gradient(180deg,#fbfdff,#f4f9ff);\n      padding: 12px;\n      border-radius: 10px;\n      border: 1px solid #e6eefb;\n      min-height: 64px;\n      display: flex;\n      gap: 12px;\n      align-items: center;\n      overflow-x: auto;\n    }\n\n    .queue-item {\n      background: #ffffff;\n      border-radius: 10px;\n      padding: 10px 12px;\n      min-width: 72px;\n      text-align: center;\n      box-shadow: 0 4px 14px rgba(9,33,63,0.06);\n      border: 1px solid #e6eefb;\n      transition: transform .25s cubic-bezier(.2,.9,.2,1), box-shadow .2s;\n      display: inline-block;\n      font-weight: 700;\n      color: #053057;\n    }\n\n    .queue-item.small {\n      opacity: 0.88;\n      font-weight: 600;\n      font-size: 13px;\n    }\n\n    .queue-item.highlight {\n      transform: translateY(-8px) scale(1.04);\n      box-shadow: 0 10px 26px rgba(11,102,255,0.14);\n      border-color: #a8cffb;\n    }\n\n    /* Right panel: visualization */\n    .visual {\n      background: #fff;\n      border-radius: 10px;\n      padding: 18px;\n      min-height: 420px;\n      box-shadow: 0 6px 18px rgba(8,30,63,0.06);\n      display: flex;\n      flex-direction: column;\n      gap: 16px;\n    }\n\n    .vis-top {\n      display: flex;\n      gap: 16px;\n      align-items: center;\n      justify-content: space-between;\n    }\n\n    /* SVG container will be responsive */\n    .tree-area {\n      background: linear-gradient(180deg,#ffffff,#fbfdff);\n      border-radius: 10px;\n      padding: 12px;\n      border: 1px solid #eef6ff;\n      flex: 1 1 auto;\n      min-height: 260px;\n      position: relative;\n      overflow: auto;\n    }\n\n    svg.tree {\n      width: 100%;\n      height: 100%;\n      display: block;\n    }\n\n    /* Node styles (SVG) */\n    .node-circle {\n      fill: #ffffff;\n      stroke: #0b66ff;\n      stroke-opacity: 0.12;\n      stroke-width: 2;\n      filter: drop-shadow(0 6px 14px rgba(11,102,255,0.06));\n      transition: transform .36s cubic-bezier(.2,.9,.2,1), opacity .28s;\n    }\n    .node-circle.highlight {\n      fill: #eaf4ff;\n      stroke-opacity: 0.6;\n      transform: scale(1.06);\n    }\n    .node-text {\n      font-weight: 700;\n      fill: #052a4a;\n      font-size: 12px;\n      pointer-events: none;\n    }\n    .edge {\n      stroke: #8fbcf7;\n      stroke-width: 2;\n      stroke-linecap: round;\n      opacity: 0.9;\n      transition: stroke-opacity .2s, stroke .2s;\n    }\n    .edge.weak {\n      stroke: #cfe6ff;\n      opacity: 0.6;\n    }\n\n    /* Code table */\n    .codes {\n      display: grid;\n      grid-template-columns: repeat(auto-fit,minmax(120px,1fr));\n      gap: 10px;\n      margin-top: 8px;\n    }\n\n    .code-card {\n      background: #fbfdff;\n      border-radius: 8px;\n      padding: 8px 10px;\n      border: 1px solid #e8f2ff;\n      font-weight: 700;\n      color: #053057;\n    }\n\n    /* Encoding area */\n    .encoder {\n      display: flex;\n      gap: 12px;\n      align-items: center;\n      flex-wrap: wrap;\n    }\n    .encoder input[type=\"text\"] {\n      flex: 1 1 240px;\n      padding: 8px 10px;\n      border-radius: 8px;\n      border: 1px solid #d6e2ee;\n      background: #fbfdff;\n    }\n\n    .bit-output {\n      background: #ffffff;\n      padding: 8px;\n      border-radius: 8px;\n      border: 1px solid #e6eefb;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;\n      color: #052a4a;\n      min-height: 48px;\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      flex-wrap: wrap;\n    }\n\n    .bit-pill {\n      background: #f1f8ff;\n      color: #04407a;\n      padding: 4px 8px;\n      border-radius: 6px;\n      font-weight: 700;\n      border: 1px solid #d9eeff;\n      transition: transform .14s;\n    }\n\n    .bit-pill.playing {\n      transform: translateY(-6px) scale(1.04);\n      background: linear-gradient(180deg,#dff0ff,#bfe5ff);\n      border-color: #9ad4ff;\n    }\n\n    /* Explanation / step text */\n    .explain {\n      background: linear-gradient(180deg,#fff,#fbfdff);\n      padding: 12px;\n      border-radius: 8px;\n      border: 1px solid #e6eefb;\n      min-height: 56px;\n      color: #12314a;\n      font-size: 14px;\n    }\n\n    footer.note {\n      margin-top: 6px;\n      font-size: 12px;\n      color: #3b596e;\n    }\n\n    /* Accessibility focus */\n    button:focus, input:focus {\n      outline: 3px solid rgba(11,102,255,0.12);\n      outline-offset: 2px;\n    }\n\n    /* Small helpers */\n    .muted { color: #5a778e; font-size: 13px; }\n    .row { display:flex; gap:12px; align-items:center; }\n    .spacer { flex:1 1 auto; }\n\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"application\" aria-label=\"Huffman Coding interactive module\">\n    <!-- LEFT PANEL: controls and description -->\n    <section class=\"panel\" aria-labelledby=\"title\">\n      <div>\n        <h1 id=\"title\">Huffman Coding — Build an optimal prefix code</h1>\n        <p class=\"meta\">Interactively create symbols and frequencies, step through the Huffman algorithm, and see how the optimal binary codes are formed and used to encode text.</p>\n      </div>\n\n      <div>\n        <strong>Learning Objective</strong>\n        <p class=\"muted\" id=\"objective\">\n          After interacting with this module you will understand how Huffman Coding builds a minimum-redundancy binary prefix code from symbol frequencies, how the Huffman tree is constructed step-by-step, and how codes are derived and applied to encode a message.\n        </p>\n      </div>\n\n      <div>\n        <strong>Symbol Frequencies</strong>\n        <p class=\"muted\">Add symbols (single character labels) and set their frequencies. Minimum two symbols required.</p>\n\n        <div class=\"symbols\" id=\"symbolsList\" aria-live=\"polite\">\n          <!-- symbol rows inserted here -->\n        </div>\n\n        <div style=\"margin-top:8px;\" class=\"controls\">\n          <button class=\"control primary\" id=\"addSymbolBtn\" title=\"Add a new symbol\">Add Symbol</button>\n          <button class=\"control\" id=\"randomBtn\" title=\"Fill with random example\">Random Example</button>\n          <button class=\"control\" id=\"resetBtn\" title=\"Reset to default\">Reset</button>\n        </div>\n      </div>\n\n      <div>\n        <strong>Priority Queue</strong>\n        <div class=\"queue-box\" id=\"queueBox\" aria-live=\"polite\" aria-label=\"Priority queue of nodes\">\n          <!-- queue items -->\n        </div>\n      </div>\n\n      <div>\n        <strong>Controls</strong>\n        <div style=\"display:flex; gap:12px; margin-top:8px; flex-wrap:wrap;\">\n          <button class=\"control primary\" id=\"stepBtn\">Build Step</button>\n          <button class=\"control\" id=\"playBtn\">Auto-Play</button>\n          <button class=\"control secondary\" id=\"buildAllBtn\">Build All</button>\n          <button class=\"control\" id=\"undoBtn\" title=\"Undo one step\">Undo</button>\n        </div>\n      </div>\n\n      <div>\n        <strong>About this module</strong>\n        <div class=\"muted\" style=\"font-size:13px;\">\n          <p style=\"margin:6px 0;\"><strong>Interaction Design:</strong> Edit or add symbols. Use \"Build Step\" to merge the two smallest-frequency nodes; each merge animates the creation of a parent node in the tree and updates the priority queue. Use Auto-Play to animate all steps. When complete, codes are shown and you can encode/decode a message using them. The visualization animates node highlights and code bit playback to reinforce how tree structure determines bit prefixes.</p>\n          <p style=\"margin:6px 0;\"><strong>Layout Description:</strong> Left column contains controls and the priority queue; right column shows the Huffman tree visualization, the resulting codes, and an encoder/decoder. Safe area margin is 24px; elements have at least 16px gaps and scale responsively for smaller screens. All interactive controls are keyboard-accessible and labeled for screen readers.</p>\n        </div>\n      </div>\n\n    </section>\n\n    <!-- RIGHT PANEL: visualization and encoder -->\n    <main class=\"visual\" aria-live=\"polite\">\n      <div class=\"vis-top\">\n        <div>\n          <strong>Huffman Tree</strong>\n          <div class=\"muted\" style=\"font-size:13px;\">Watch merges animate and observe code assignment.</div>\n        </div>\n        <div style=\"display:flex; gap:12px; align-items:center;\">\n          <div class=\"muted\">Total bits: <span id=\"totalBits\">—</span></div>\n          <div class=\"muted\">Fixed-length bits: <span id=\"fixedBits\">—</span></div>\n        </div>\n      </div>\n\n      <div class=\"tree-area\" id=\"treeArea\" tabindex=\"0\" aria-label=\"Huffman tree visualization\">\n        <!-- SVG tree -->\n        <svg class=\"tree\" id=\"svgTree\" viewBox=\"0 0 1000 360\" preserveAspectRatio=\"xMidYMin meet\" role=\"img\" aria-hidden=\"false\"></svg>\n      </div>\n\n      <div>\n        <strong>Codes</strong>\n        <div class=\"codes\" id=\"codesGrid\" aria-live=\"polite\">\n          <!-- code cards -->\n        </div>\n      </div>\n\n      <div>\n        <strong>Encode / Decode</strong>\n        <div class=\"encoder\">\n          <input type=\"text\" id=\"messageInput\" placeholder=\"Type message to encode (characters must match symbols)\" aria-label=\"Message to encode\" />\n          <button class=\"control primary\" id=\"encodeBtn\">Encode</button>\n          <button class=\"control\" id=\"decodeBtn\">Decode</button>\n        </div>\n        <div style=\"margin-top:8px;\">\n          <div class=\"bit-output\" id=\"bitOutput\" aria-live=\"polite\">Encoded bits will appear here</div>\n        </div>\n      </div>\n\n      <div>\n        <strong>Step Explanation</strong>\n        <div class=\"explain\" id=\"explain\" aria-live=\"assertive\">Ready. Add symbols or press \"Random Example\" to try a preset built example.</div>\n      </div>\n\n      <footer class=\"note\">Tip: For clarity use small alphabets first (3–7 symbols). The algorithm always chooses the two smallest current nodes to merge; ties are broken by insertion order.</footer>\n    </main>\n  </div>\n\n  <script>\n    // Huffman Interactive Module - Vanilla JS\n    (function () {\n      // Utility short-hands\n      const $ = (sel, ctx = document) => ctx.querySelector(sel);\n      const $$ = (sel, ctx = document) => Array.from(ctx.querySelectorAll(sel));\n      const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;\n\n      // DOM elements\n      const symbolsList = $('#symbolsList');\n      const addSymbolBtn = $('#addSymbolBtn');\n      const randomBtn = $('#randomBtn');\n      const resetBtn = $('#resetBtn');\n      const queueBox = $('#queueBox');\n      const stepBtn = $('#stepBtn');\n      const playBtn = $('#playBtn');\n      const buildAllBtn = $('#buildAllBtn');\n      const undoBtn = $('#undoBtn');\n      const svgTree = $('#svgTree');\n      const codesGrid = $('#codesGrid');\n      const explain = $('#explain');\n      const totalBitsEl = $('#totalBits');\n      const fixedBitsEl = $('#fixedBits');\n      const messageInput = $('#messageInput');\n      const encodeBtn = $('#encodeBtn');\n      const decodeBtn = $('#decodeBtn');\n      const bitOutput = $('#bitOutput');\n\n      // Module state\n      let nodes = [];       // active nodes in PQ (objects)\n      let history = [];     // history of merges (for undo)\n      let allNodes = {};    // id->node for tree drawing\n      let nextId = 1;\n      let autoPlayTimer = null;\n      let playing = false;\n      let codes = null;\n\n      // Accessibility: announce changes\n      function announce(text) {\n        explain.textContent = text;\n      }\n\n      // Node structure: { id, symbols: [chars], freq, left, right, createdAt }\n      function createLeaf(symbol, freq) {\n        const id = String(nextId++);\n        const node = { id, symbols: [symbol], freq: Number(freq), left: null, right: null, createdAt: Date.now() + Math.random() };\n        allNodes[id] = node;\n        return node;\n      }\n\n      function createInternal(left, right) {\n        const id = String(nextId++);\n        const node = { id, symbols: left.symbols.concat(right.symbols), freq: left.freq + right.freq, left: left.id, right: right.id, createdAt: Date.now() + Math.random() };\n        allNodes[id] = node;\n        return node;\n      }\n\n      // Priority: sort by freq asc, tie-break by createdAt\n      function sortQueue(q) {\n        q.sort((a,b) => {\n          if (a.freq !== b.freq) return a.freq - b.freq;\n          return a.createdAt - b.createdAt;\n        });\n      }\n\n      // Render symbol editor rows\n      function renderSymbolRows() {\n        symbolsList.innerHTML = '';\n        if (nodes.length === 0) {\n          // default two symbols\n          addSymbolRow('A', 5);\n          addSymbolRow('B', 9);\n          return;\n        }\n        // show leaves (only symbols, not internal parents)\n        const leaves = Object.values(allNodes).filter(n => !n.left && !n.right && nodes.some(q => q.id === n.id));\n        leaves.forEach(n => {\n          const row = document.createElement('div');\n          row.className = 'symbol-row';\n          const symInput = document.createElement('input');\n          symInput.type = 'text';\n          symInput.maxLength = 2;\n          symInput.value = n.symbols[0];\n          symInput.setAttribute('aria-label', 'Symbol label');\n          const freqInput = document.createElement('input');\n          freqInput.type = 'number';\n          freqInput.min = 1;\n          freqInput.value = n.freq;\n          freqInput.setAttribute('aria-label', 'Symbol frequency');\n          const removeBtn = document.createElement('button');\n          removeBtn.textContent = 'Remove';\n          removeBtn.title = 'Remove symbol';\n          removeBtn.addEventListener('click', () => {\n            removeSymbol(n.id);\n          });\n          // Update handlers\n          symInput.addEventListener('input', (e) => {\n            const v = e.target.value || '';\n            n.symbols[0] = v.slice(0,1) || '?';\n            updateQueueDisplay();\n            updateCodesIfReady();\n          });\n          freqInput.addEventListener('change', (e) => {\n            const v = Math.max(1, Math.floor(Number(e.target.value) || 1));\n            n.freq = v;\n            updateQueueFromLeaves();\n            updateCodesIfReady();\n          });\n          row.appendChild(symInput);\n          row.appendChild(freqInput);\n          row.appendChild(removeBtn);\n          symbolsList.appendChild(row);\n        });\n      }\n\n      function addSymbolRow(symbol='?', freq=1) {\n        // create new leaf node and add to PQ\n        const leaf = createLeaf(symbol, freq);\n        nodes.push(leaf);\n        sortQueue(nodes);\n        renderSymbolRows();\n        updateQueueDisplay();\n        announce(`Added symbol \"${symbol}\" with frequency ${freq}.`);\n      }\n\n      function removeSymbol(id) {\n        // remove leaf only if leaf present in nodes\n        const idx = nodes.findIndex(n => n.id === id);\n        if (idx >= 0) {\n          const sym = nodes[idx].symbols[0];\n          nodes.splice(idx,1);\n          delete allNodes[id];\n          renderSymbolRows();\n          updateQueueDisplay();\n          announce(`Removed symbol \"${sym}\".`);\n        }\n      }\n\n      function updateQueueFromLeaves() {\n        // Keep only leaf nodes in nodes (for when freq changed via editor)\n        // nodes currently contains leaves and possibly internals; but editor only edits leaves.\n        // We will re-create nodes array to contain current leaves from allNodes that are leaves.\n        const leafNodes = Object.values(allNodes).filter(n => !n.left && !n.right);\n        // Keep only those that also exist in nodes list previously OR all leaf nodes.\n        nodes = leafNodes.slice(); // shallow copy\n        sortQueue(nodes);\n        renderSymbolRows();\n        updateQueueDisplay();\n      }\n\n      function clearAll() {\n        nodes = [];\n        history = [];\n        allNodes = {};\n        nextId = 1;\n        codes = null;\n        svgTree.innerHTML = '';\n        codesGrid.innerHTML = '';\n        totalBitsEl.textContent = '—';\n        fixedBitsEl.textContent = '—';\n        bitOutput.textContent = 'Encoded bits will appear here';\n        renderSymbolRows();\n        updateQueueDisplay();\n        announce('Reset complete.');\n      }\n\n      // Update the visual priority queue\n      function updateQueueDisplay(highlightIds=[]) {\n        queueBox.innerHTML = '';\n        sortQueue(nodes);\n        nodes.forEach(n => {\n          const div = document.createElement('div');\n          div.className = 'queue-item small';\n          if (highlightIds.includes(n.id)) div.classList.add('highlight');\n          const sym = n.symbols.length === 1 ? n.symbols[0] : n.symbols.join(',');\n          div.innerHTML = `<div style=\"font-size:12px;opacity:.9\">${sym}</div><div style=\"font-size:14px\">${n.freq}</div>`;\n          queueBox.appendChild(div);\n        });\n      }\n\n      // Render the Huffman tree using SVG\n      function renderTree(rootId) {\n        svgTree.innerHTML = '';\n        if (!rootId) return;\n        // compute layout: assign x positions to leaves via inorder, depth for y\n        const root = allNodes[rootId];\n        const positions = {};\n        let leafCount = 0;\n        function dfsCount(nId, depth) {\n          const n = allNodes[nId];\n          if (!n) return;\n          if (!n.left && !n.right) {\n            positions[nId] = { xIndex: leafCount++, depth };\n            return;\n          }\n          dfsCount(n.left, depth+1);\n          dfsCount(n.right, depth+1);\n          // internal node x is average of children\n          const leftPos = positions[n.left], rightPos = positions[n.right];\n          positions[nId] = { xIndex: (leftPos.xIndex + rightPos.xIndex)/2, depth };\n        }\n        dfsCount(rootId, 0);\n        const width = Math.max(600, svgTree.clientWidth || 800);\n        const height = Math.max(300, svgTree.clientHeight || 360);\n        const marginX = 40, marginY = 40;\n        const availW = width - marginX*2;\n        const maxDepth = Math.max(...Object.values(positions).map(p=>p.depth));\n        const vgap = (height - marginY*2) / Math.max(1, maxDepth + 1);\n        const hstep = leafCount > 1 ? availW / (leafCount - 1) : 0;\n        // draw edges first\n        const edges = [];\n        for (const id in positions) {\n          const p = positions[id];\n          const n = allNodes[id];\n          if (n.left && n.right) {\n            const x = marginX + p.xIndex * hstep;\n            const y = marginY + p.depth * vgap;\n            const leftPos = positions[n.left];\n            const rightPos = positions[n.right];\n            const lx = marginX + leftPos.xIndex * hstep;\n            const ly = marginY + leftPos.depth * vgap;\n            const rx = marginX + rightPos.xIndex * hstep;\n            const ry = marginY + rightPos.depth * vgap;\n            edges.push({ from: {x,y}, to: {x:lx,y:ly}, parentId:id, childId:n.left, label: '0' });\n            edges.push({ from: {x,y}, to: {x:rx,y:ry}, parentId:id, childId:n.right, label: '1' });\n          }\n        }\n        // build svg\n        svgTree.setAttribute('viewBox', `0 0 ${width} ${height}`);\n        // edges\n        edges.forEach(e => {\n          const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n          const d = `M ${e.from.x} ${e.from.y} C ${e.from.x} ${ (e.from.y + e.to.y)/2 } ${e.to.x} ${ (e.from.y + e.to.y)/2 } ${e.to.x} ${e.to.y}`;\n          path.setAttribute('d', d);\n          path.setAttribute('class','edge');\n          path.setAttribute('data-parent', e.parentId);\n          path.setAttribute('data-child', e.childId);\n          svgTree.appendChild(path);\n\n          // label near child\n          const midX = (e.from.x + e.to.x)/2;\n          const midY = (e.from.y + e.to.y)/2 - 6;\n          const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n          t.setAttribute('x', midX);\n          t.setAttribute('y', midY);\n          t.setAttribute('text-anchor','middle');\n          t.setAttribute('fill','#1b567f');\n          t.setAttribute('font-size','11');\n          t.setAttribute('font-weight','700');\n          t.textContent = e.label;\n          svgTree.appendChild(t);\n        });\n        // nodes\n        for (const id in positions) {\n          const p = positions[id];\n          const n = allNodes[id];\n          const cx = marginX + p.xIndex * hstep;\n          const cy = marginY + p.depth * vgap;\n          // group\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('transform', `translate(${cx},${cy})`);\n          g.setAttribute('data-id', id);\n\n          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          circle.setAttribute('r','20');\n          circle.setAttribute('class','node-circle');\n          circle.setAttribute('data-id', id);\n          g.appendChild(circle);\n\n          const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n          text.setAttribute('y','6');\n          text.setAttribute('text-anchor','middle');\n          text.setAttribute('class','node-text');\n          text.textContent = `${n.freq}`;\n          g.appendChild(text);\n\n          svgTree.appendChild(g);\n        }\n      }\n\n      // Compute codes from final root\n      function computeCodes(rootId) {\n        const map = {};\n        function dfs(id, prefix='') {\n          const n = allNodes[id];\n          if (!n.left && !n.right) {\n            map[n.symbols[0]] = prefix || '0'; // single symbol edge-case -> assign '0'\n            return;\n          }\n          dfs(n.left, prefix + '0');\n          dfs(n.right, prefix + '1');\n        }\n        dfs(rootId, '');\n        return map;\n      }\n\n      function updateCodesIfReady() {\n        // if only one node -> trivial codes\n        if (nodes.length === 1 && allNodes[nodes[0].id]) {\n          const rootId = nodes[0].id;\n          codes = computeCodes(rootId);\n          showCodes(codes);\n          updateBitCounts();\n        } else {\n          codes = null;\n          codesGrid.innerHTML = '';\n          totalBitsEl.textContent = '—';\n          fixedBitsEl.textContent = '—';\n        }\n      }\n\n      function showCodes(map) {\n        codesGrid.innerHTML = '';\n        Object.keys(map).sort().forEach(sym => {\n          const div = document.createElement('div');\n          div.className = 'code-card';\n          div.textContent = `${sym}: ${map[sym]}`;\n          codesGrid.appendChild(div);\n        });\n      }\n\n      function updateBitCounts() {\n        if (!codes) {\n          totalBitsEl.textContent = '—';\n          fixedBitsEl.textContent = '—';\n          return;\n        }\n        // compute total bits for encoding all symbols once (weighted by freq)\n        let total = 0;\n        let fixed = 0;\n        const leafNodes = Object.values(allNodes).filter(n => !n.left && !n.right);\n        const uniqueSymbols = leafNodes.length;\n        leafNodes.forEach(n => {\n          const sym = n.symbols[0];\n          const len = codes[sym].length;\n          total += n.freq * len;\n        });\n        fixed = Math.ceil(Math.log2(Math.max(2, uniqueSymbols))) * leafNodes.reduce((s,n)=>s+n.freq,0);\n        totalBitsEl.textContent = String(total);\n        fixedBitsEl.textContent = String(fixed);\n      }\n\n      // Step algorithm: pick two smallest nodes, create parent, update nodes and history, animate\n      function buildStep() {\n        if (nodes.length < 2) {\n          announce('Not enough symbols to merge. Add more symbols.');\n          return;\n        }\n        sortQueue(nodes);\n        const a = nodes.shift();\n        const b = nodes.shift();\n        // choice: left = a, right = b (a has <= freq)\n        const parent = createInternal(a,b);\n        // remove a and b from nodes array if not present (they were removed)\n        nodes.push(parent);\n        sortQueue(nodes);\n        history.push({ left:a, right:b, parent:parent });\n        // Animate: highlight a and b in queue, then create parent in queue and update tree\n        updateQueueDisplay([a.id,b.id]);\n        announce(`Merging \"${a.symbols.join(',')}\" (${a.freq}) and \"${b.symbols.join(',')}\" (${b.freq}) to create parent (${parent.freq}).`);\n        // Slight delay to show highlight, then update tree with a small visual pop\n        setTimeout(() => {\n          renderTree(parent.id);\n          updateQueueDisplay();\n          playMergeAnimation(a.id, b.id, parent.id);\n          updateCodesIfReady();\n        }, 450);\n      }\n\n      // Undo last merge\n      function undoStep() {\n        if (history.length === 0) {\n          announce('Nothing to undo.');\n          return;\n        }\n        const last = history.pop();\n        // remove parent node from allNodes and nodes list, add back children\n        delete allNodes[last.parent.id];\n        // remove parent from nodes array\n        const pIdx = nodes.findIndex(n => n.id === last.parent.id);\n        if (pIdx >= 0) nodes.splice(pIdx,1);\n        // re-add children (ensure they're present)\n        nodes.push(last.left);\n        nodes.push(last.right);\n        sortQueue(nodes);\n        renderSymbolRows();\n        updateQueueDisplay();\n        // Re-render tree if there is a root left\n        let rootId = null;\n        if (nodes.length === 1) rootId = nodes[0].id;\n        else {\n          // find node that is ancestor of others? We'll render nothing until finished\n          rootId = null;\n        }\n        svgTree.innerHTML = '';\n        if (rootId) renderTree(rootId);\n        updateCodesIfReady();\n        announce('Undid last merge.');\n      }\n\n      // Play/pause auto-play merges\n      function togglePlay() {\n        if (playing) {\n          playing = false;\n          clearInterval(autoPlayTimer);\n          playBtn.textContent = 'Auto-Play';\n          announce('Auto-play paused.');\n          return;\n        }\n        if (nodes.length < 2) {\n          announce('Not enough symbols to auto-play.');\n          return;\n        }\n        playing = true;\n        playBtn.textContent = 'Pause';\n        announce('Auto-play started.');\n        autoPlayTimer = setInterval(() => {\n          if (nodes.length < 2) {\n            clearInterval(autoPlayTimer);\n            playing = false;\n            playBtn.textContent = 'Auto-Play';\n            finalizeTreeAfterBuild();\n            return;\n          }\n          buildStep();\n          // if after step nodes length == 1, stop playing and finalize\n          if (nodes.length === 1) {\n            clearInterval(autoPlayTimer);\n            playing = false;\n            playBtn.textContent = 'Auto-Play';\n            finalizeTreeAfterBuild();\n          }\n        }, 900);\n      }\n\n      function finalizeTreeAfterBuild() {\n        if (nodes.length === 1) {\n          const rootId = nodes[0].id;\n          renderTree(rootId);\n          codes = computeCodes(rootId);\n          showCodes(codes);\n          updateBitCounts();\n          announce('Build complete. Codes generated.');\n        }\n      }\n\n      function buildAll() {\n        if (nodes.length < 2) {\n          announce('Not enough symbols to build.');\n          return;\n        }\n        // Perform steps with small delays to animate sequentially\n        const iterate = () => {\n          if (nodes.length < 2) {\n            finalizeTreeAfterBuild();\n            return;\n          }\n          buildStep();\n          setTimeout(iterate, 600);\n        };\n        iterate();\n      }\n\n      // Play a small animation when merging: highlight nodes in SVG (if present)\n      function playMergeAnimation(leftId, rightId, parentId) {\n        // Highlight the nodes by adding class\n        const leftCircle = svgTree.querySelector(`.node-circle[data-id=\"${leftId}\"]`);\n        const rightCircle = svgTree.querySelector(`.node-circle[data-id=\"${rightId}\"]`);\n        const parentCircle = svgTree.querySelector(`.node-circle[data-id=\"${parentId}\"]`);\n        if (leftCircle) leftCircle.classList.add('highlight');\n        if (rightCircle) rightCircle.classList.add('highlight');\n        if (parentCircle) {\n          parentCircle.style.opacity = '0';\n          setTimeout(() => {\n            parentCircle.style.transition = 'opacity .28s ease, transform .28s ease';\n            parentCircle.style.opacity = '1';\n            parentCircle.classList.add('highlight');\n          }, 200);\n        }\n        // Remove highlights after a moment\n        setTimeout(() => {\n          if (leftCircle) leftCircle.classList.remove('highlight');\n          if (rightCircle) rightCircle.classList.remove('highlight');\n          if (parentCircle) parentCircle.classList.remove('highlight');\n        }, 900);\n      }\n\n      // Encoding and decoding\n      function encodeMessage(text) {\n        if (!codes) {\n          announce('Codes not ready. Complete the tree first.');\n          return;\n        }\n        const bits = [];\n        for (const ch of text) {\n          if (!(ch in codes)) {\n            announce(`Character \"${ch}\" not found in current symbol set.`);\n            return;\n          }\n          bits.push(codes[ch]);\n        }\n        const bitString = bits.join('');\n        bitOutput.innerHTML = '';\n        // create bit pills with small playback animation\n        const pills = bitString.split('').map(b => {\n          const span = document.createElement('div');\n          span.className = 'bit-pill';\n          span.textContent = b;\n          bitOutput.appendChild(span);\n          return span;\n        });\n        // animate playback: highlight each pill sequentially\n        let i = 0;\n        const interval = setInterval(() => {\n          if (i > 0) pills[i-1].classList.remove('playing');\n          if (i >= pills.length) {\n            clearInterval(interval);\n            announce(`Encoded message to ${bitString.length} bits.`);\n            return;\n          }\n          pills[i].classList.add('playing');\n          i++;\n        }, 60);\n      }\n\n      function decodeBits(bitString) {\n        if (!codes) {\n          announce('Codes not ready. Complete the tree first.');\n          return;\n        }\n        // build reverse mapping\n        const rev = {};\n        Object.entries(codes).forEach(([k,v]) => rev[v] = k);\n        // decode using tree traversal\n        let out = '';\n        let cur = '';\n        for (const bit of bitString) {\n          cur += bit;\n          if (cur in rev) {\n            out += rev[cur];\n            cur = '';\n          } else {\n            // continue\n          }\n        }\n        if (cur.length) {\n          announce('Bit string does not terminate at a valid code (incomplete).');\n        } else {\n          bitOutput.innerHTML = '';\n          const span = document.createElement('div');\n          span.textContent = out;\n          span.style.fontWeight = '700';\n          span.style.color = '#063b7a';\n          bitOutput.appendChild(span);\n          announce('Decoded bitstring to message.');\n        }\n      }\n\n      // UI wiring\n      addSymbolBtn.addEventListener('click', () => {\n        // Choose a default symbol label not used\n        const used = new Set(Object.values(allNodes).filter(n=>!n.left&&!n.right).map(n=>n.symbols[0]));\n        let ch = 'A';\n        for (let i=65;i<91;i++) {\n          if (!used.has(String.fromCharCode(i))) { ch = String.fromCharCode(i); break;}\n        }\n        addSymbolRow(ch, randInt(1,16));\n      });\n\n      randomBtn.addEventListener('click', () => {\n        // create random example: common illustrative set\n        clearAll();\n        const examples = [\n          [['A',45],['B',13],['C',12],['D',16],['E',9],['F',5]],\n          [['a',5],['b',9],['c',12],['d',13],['e',16],['f',45]],\n          [['X',3],['Y',7],['Z',2],['W',8]],\n        ];\n        const ex = examples[randInt(0, examples.length-1)];\n        ex.forEach(([s,f]) => {\n          addSymbolRow(s,f);\n        });\n        announce('Random example loaded.');\n      });\n\n      resetBtn.addEventListener('click', () => clearAll());\n\n      stepBtn.addEventListener('click', () => buildStep());\n      buildAllBtn.addEventListener('click', () => buildAll());\n      playBtn.addEventListener('click', () => togglePlay());\n      undoBtn.addEventListener('click', () => undoStep());\n\n      encodeBtn.addEventListener('click', () => {\n        const txt = messageInput.value || '';\n        if (!txt) {\n          announce('Enter a message to encode.');\n          return;\n        }\n        encodeMessage(txt);\n      });\n\n      decodeBtn.addEventListener('click', () => {\n        const txt = messageInput.value || '';\n        if (!txt) {\n          announce('Enter a bit string to decode.');\n          return;\n        }\n        decodeBits(txt);\n      });\n\n      // initial default seed\n      (function init() {\n        clearAll();\n        // create a simple default example\n        addSymbolRow('A', 5);\n        addSymbolRow('B', 9);\n        addSymbolRow('C', 12);\n        addSymbolRow('D', 13);\n        addSymbolRow('E', 16);\n        addSymbolRow('F', 45);\n        renderSymbolRows();\n        updateQueueDisplay();\n        announce('Module ready. Use Build Step to start constructing the tree.');\n      })();\n\n      // Keyboard accessibility: Enter on message input encodes\n      messageInput.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n          // by default encode if codes ready, else try decode if looks like bits\n          const txt = messageInput.value || '';\n          if (/^[01\\s]+$/.test(txt.trim())) {\n            decodeBits(txt.replace(/\\s+/g,''));\n          } else {\n            encodeMessage(txt);\n          }\n        }\n      });\n\n      // Keep visuals responsive on resize\n      window.addEventListener('resize', () => {\n        if (nodes.length === 1) renderTree(nodes[0].id);\n      });\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Huffman Coding.\n\n**Project Overview:**\nTopic: Huffman Coding\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Huffman Coding"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "3efa8210-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:50:26.097Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Prim’s Algorithm",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Prim’s Algorithm Module</title>\n  <style>\n    /* Safe area margins: 24px on all sides */\n    :root {\n      --safe-margin: 24px;\n      --gap: 16px;\n      --sidebar-width: 360px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --muted: #9aa4b2;\n      --accent: #38bdf8;\n      --good: #34d399;\n      --danger: #fb7185;\n      --glass: rgba(255,255,255,0.03);\n    }\n\n    html,body {\n      height: 100%;\n      margin: 0;\n      background: linear-gradient(180deg,#061223 0%, #081827 100%);\n      color: #e6eef6;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing: antialiased;\n      -moz-osx-font-smoothing: grayscale;\n    }\n\n    /* Container with safe margins */\n    .app {\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height: 100vh;\n      display: flex;\n      gap: var(--gap);\n    }\n\n    /* Sidebar and main canvas: responsive */\n    .sidebar {\n      min-width: 280px;\n      width: clamp(280px, 28vw, var(--sidebar-width));\n      max-width: 420px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.03);\n      border-radius: 12px;\n      padding: 16px;\n      box-sizing: border-box;\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n    }\n\n    .main {\n      flex: 1;\n      min-width: 0;\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n    }\n\n    h1 {\n      margin: 0;\n      font-size: 18px;\n      letter-spacing: -0.2px;\n      color: #e8f5ff;\n    }\n\n    .muted {\n      color: var(--muted);\n      font-size: 13px;\n    }\n\n    .section {\n      background: var(--panel);\n      border: 1px solid rgba(255,255,255,0.03);\n      padding: 12px;\n      border-radius: 10px;\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n    }\n\n    .controls {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 12px;\n    }\n\n    button, .btn {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.04);\n      color: #e6eef6;\n      padding: 8px 10px;\n      border-radius: 8px;\n      cursor: pointer;\n      font-size: 13px;\n      min-height: 40px;\n      display: inline-flex;\n      align-items: center;\n      gap: 8px;\n    }\n\n    button.primary {\n      background: linear-gradient(180deg, rgba(56,189,248,0.12), rgba(56,189,248,0.06));\n      border: 1px solid rgba(56,189,248,0.18);\n      color: #dff8ff;\n    }\n\n    button.ghost {\n      background: transparent;\n      border: 1px dashed rgba(255,255,255,0.04);\n    }\n\n    button.toggle.active {\n      background: linear-gradient(180deg, rgba(52,211,153,0.10), rgba(52,211,153,0.04));\n      border: 1px solid rgba(52,211,153,0.12);\n      color: #eafff4;\n    }\n\n    .row {\n      display: flex;\n      gap: 8px;\n      align-items: center;\n    }\n\n    label {\n      font-size: 13px;\n      color: var(--muted);\n      min-width: 120px;\n    }\n\n    .small {\n      font-size: 12px;\n      color: var(--muted);\n    }\n\n    /* Canvas card */\n    .canvas-card {\n      background: var(--glass);\n      border-radius: 12px;\n      padding: 12px;\n      border: 1px solid rgba(255,255,255,0.02);\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n      min-height: 520px;\n      align-items: stretch;\n    }\n\n    /* SVG area */\n    .graph-area {\n      flex: 1;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius: 10px;\n      overflow: hidden;\n      position: relative;\n      border: 1px solid rgba(255,255,255,0.02);\n    }\n\n    svg {\n      width: 100%;\n      height: 100%;\n      display: block;\n      touch-action: none;\n      user-select: none;\n    }\n\n    /* Node styles */\n    .node {\n      cursor: pointer;\n      transition: filter 0.18s, transform 0.18s;\n    }\n    .node circle {\n      fill: #0b2340;\n      stroke: rgba(255,255,255,0.06);\n      stroke-width: 1.5px;\n      transition: fill 200ms, r 120ms, stroke 200ms;\n    }\n\n    .node.selected circle {\n      fill: rgba(56,189,248,0.12);\n      stroke: rgba(56,189,248,0.6);\n      stroke-width: 2.2px;\n    }\n\n    .node.mst circle {\n      fill: rgba(52,211,153,0.12);\n      stroke: rgba(52,211,153,0.65);\n      stroke-width: 2.4px;\n    }\n\n    .node.highlight circle {\n      stroke: rgba(250,204,21,0.9);\n      stroke-width: 2.6px;\n      filter: drop-shadow(0 4px 10px rgba(250,204,21,0.08));\n    }\n\n    .node text {\n      font-size: 12px;\n      fill: #e6eef6;\n      pointer-events: none;\n    }\n\n    .edge {\n      stroke: rgba(255,255,255,0.06);\n      stroke-width: 2.4px;\n      transition: stroke 240ms, stroke-width 160ms, opacity 160ms;\n    }\n\n    .edge.weighted text {\n      fill: #cfeafc;\n      font-size: 12px;\n      pointer-events: none;\n      user-select: none;\n    }\n\n    .edge.candidate {\n      stroke: rgba(56,189,248,0.7);\n      stroke-width: 3.2px;\n      opacity: 1;\n    }\n\n    .edge.considering {\n      stroke: rgba(250,204,21,0.95);\n      stroke-width: 4px;\n      filter: drop-shadow(0 6px 14px rgba(250,204,21,0.06));\n      animation: pulse 1s infinite ease-in-out;\n    }\n\n    .edge.mst {\n      stroke: rgba(52,211,153,0.9);\n      stroke-width: 4.2px;\n      opacity: 1;\n    }\n\n    .edge.faded {\n      opacity: 0.12;\n    }\n\n    @keyframes pulse {\n      0% { stroke-dashoffset: 0; }\n      50% { stroke-dashoffset: 12; }\n      100% { stroke-dashoffset: 0; }\n    }\n\n    /* Candidate list */\n    .candidate-list {\n      display: flex;\n      flex-direction: column;\n      gap: 6px;\n      max-height: 120px;\n      overflow: auto;\n      padding-right: 6px;\n    }\n\n    .candidate-item {\n      display: flex;\n      justify-content: space-between;\n      gap: 8px;\n      background: rgba(255,255,255,0.01);\n      border-radius: 8px;\n      padding: 6px 8px;\n      font-size: 13px;\n      color: #dff8ff;\n      border: 1px solid rgba(255,255,255,0.02);\n    }\n\n    .candidate-item .edge-label {\n      color: var(--muted);\n      font-size: 12px;\n    }\n\n    .footer {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      gap: 8px;\n    }\n\n    /* Floating weight input popup */\n    .weight-popup {\n      position: absolute;\n      z-index: 30;\n      background: rgba(8,12,20,0.96);\n      border: 1px solid rgba(255,255,255,0.03);\n      padding: 8px;\n      border-radius: 8px;\n      display: flex;\n      gap: 8px;\n      align-items: center;\n      box-shadow: 0 8px 30px rgba(2,6,23,0.7);\n    }\n\n    .weight-popup input[type=\"number\"] {\n      width: 80px;\n      padding: 6px;\n      border-radius: 6px;\n      border: 1px solid rgba(255,255,255,0.04);\n      background: rgba(255,255,255,0.02);\n      color: #e6eef6;\n    }\n\n    .small-muted {\n      font-size: 12px;\n      color: var(--muted);\n    }\n\n    /* Pseudocode area */\n    .pseudocode {\n      background: rgba(255,255,255,0.01);\n      border-radius: 8px;\n      padding: 8px;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;\n      font-size: 13px;\n      color: #cfeafc;\n      border: 1px solid rgba(255,255,255,0.02);\n      display: flex;\n      flex-direction: column;\n      gap: 6px;\n    }\n\n    .code-line {\n      padding: 6px;\n      border-radius: 6px;\n      transition: background 180ms, color 180ms;\n    }\n\n    .code-line.active {\n      background: linear-gradient(90deg, rgba(56,189,248,0.08), rgba(56,189,248,0.04));\n      color: #e8faff;\n    }\n\n    /* Responsive tweaks */\n    @media (max-width: 920px) {\n      .app {\n        flex-direction: column;\n      }\n      .sidebar { width: 100%; max-width: none; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"main\">\n    <!-- Sidebar: descriptive plan and controls -->\n    <aside class=\"sidebar\" aria-label=\"Prim's Algorithm controls and explanation\">\n      <div>\n        <h1>Prim’s Algorithm — Minimum Spanning Tree (MST)</h1>\n        <div class=\"muted small\" style=\"margin-top:6px;\">\n          Interactive step-by-step visualization and playground.\n        </div>\n      </div>\n\n      <div class=\"section\" aria-hidden=\"false\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n          <div>\n            <div class=\"small-muted\">Concept Title</div>\n            <strong>Prim’s Algorithm (MST) — greedy edge selection</strong>\n          </div>\n          <div style=\"text-align:right;\">\n            <div class=\"small-muted\">Nodes</div>\n            <div id=\"node-count\">0</div>\n          </div>\n        </div>\n\n        <div>\n          <div class=\"small-muted\">Learning Objective</div>\n          <div class=\"muted small\" style=\"margin-top:6px;\">\n            After interacting you will be able to: (1) follow Prim’s greedy process choosing the cheapest edge connecting the growing tree to the graph, (2) see candidate edges and the priority decision, and (3) build and test your own graphs.\n          </div>\n        </div>\n\n        <details style=\"margin-top:8px;\">\n          <summary style=\"cursor:pointer;color:var(--muted);font-size:13px;\">Interaction Design (click to expand)</summary>\n          <div class=\"small-muted\" style=\"margin-top:8px;\">\n            - Add nodes: toggle \"Add Node\" then click canvas.<br>\n            - Create edges: toggle \"Connect\" then click source node and target node; enter weight in popup.<br>\n            - Drag nodes to reposition edges; edit mid-visualization.<br>\n            - Select a start node by clicking a node (before running) or use \"Preset Example\".<br>\n            - Controls: Step, Play/Pause (auto-step), Reset, Random Graph, Preset.<br>\n            - Visual feedback: candidate edges (blue), currently-considered edge (gold pulse), chosen MST edges (green), faded irrelevant edges; nodes highlight as they join the MST; pseudocode lines highlight to map the code to each visual step.\n          </div>\n        </details>\n      </div>\n\n      <div class=\"section\" aria-label=\"Controls\">\n        <div class=\"controls\" role=\"group\" aria-label=\"Graph tools\">\n          <button id=\"preset-btn\" class=\"btn ghost\" title=\"Load example graph\">Preset Example</button>\n          <button id=\"random-btn\" class=\"btn\" title=\"Create a random graph\">Random Graph</button>\n          <button id=\"reset-btn\" class=\"btn\" title=\"Reset graph and algorithm\">Reset</button>\n        </div>\n\n        <div style=\"display:flex;gap:8px;align-items:center;margin-top:8px;\">\n          <button id=\"add-node-toggle\" class=\"btn toggle\" aria-pressed=\"false\">Add Node</button>\n          <button id=\"connect-toggle\" class=\"btn toggle\" aria-pressed=\"false\">Connect</button>\n          <button id=\"delete-toggle\" class=\"btn toggle\" aria-pressed=\"false\">Delete</button>\n        </div>\n\n        <div style=\"display:flex;gap:8px;margin-top:8px;\">\n          <button id=\"step-btn\" class=\"btn primary\" title=\"Perform one Prim step\">Step</button>\n          <button id=\"play-btn\" class=\"btn\" title=\"Auto play\">Play</button>\n          <button id=\"pause-btn\" class=\"btn\" title=\"Pause autoplay\" style=\"display:none;\">Pause</button>\n        </div>\n\n        <div style=\"margin-top:8px;display:flex;gap:8px;align-items:center;\">\n          <label style=\"min-width:84px;\">Speed</label>\n          <input id=\"speed\" type=\"range\" min=\"300\" max=\"2000\" value=\"900\" step=\"100\" aria-label=\"Playback speed\" />\n        </div>\n\n        <div class=\"small-muted\" style=\"margin-top:8px;\">\n          Start node: click any node to set start (before stepping). The algorithm will choose the smallest crossing edge each step.\n        </div>\n      </div>\n\n      <div class=\"section\" aria-label=\"Algorithm state\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n          <div>\n            <div class=\"small-muted\">Current MST Weight</div>\n            <strong id=\"mst-weight\">0</strong>\n          </div>\n          <div>\n            <div class=\"small-muted\">Steps</div>\n            <div id=\"step-count\">0</div>\n          </div>\n        </div>\n\n        <div style=\"margin-top:8px;\">\n          <div class=\"small-muted\">Candidate edges (min first)</div>\n          <div class=\"candidate-list\" id=\"candidate-list\" aria-live=\"polite\"></div>\n        </div>\n      </div>\n\n      <div class=\"section\" aria-label=\"Pseudocode\">\n        <div class=\"small-muted\">Prim's pseudocode (highlights current step)</div>\n        <div class=\"pseudocode\" id=\"pseudocode\">\n          <div class=\"code-line\" data-line=\"init\">1. Choose start node s; S = {s}, MST = ∅</div>\n          <div class=\"code-line\" data-line=\"add-edges\">2. Add all edges (s, v) to candidate set C</div>\n          <div class=\"code-line\" data-line=\"loop\">3. while (|S| &lt; n):</div>\n          <div class=\"code-line\" data-line=\"pick\">4. &nbsp;&nbsp; e = smallest-weight edge in C that connects S to V\\S</div>\n          <div class=\"code-line\" data-line=\"add-edge\">5. &nbsp;&nbsp; Add e to MST; let w be the new vertex added</div>\n          <div class=\"code-line\" data-line=\"update\">6. &nbsp;&nbsp; Add edges (w, x) to C for x ∉ S</div>\n          <div class=\"code-line\" data-line=\"done\">7. return MST</div>\n        </div>\n      </div>\n\n    </aside>\n\n    <!-- Main visual area -->\n    <main class=\"main\" aria-label=\"Graph visualization\">\n      <div class=\"canvas-card\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n          <div>\n            <div class=\"small-muted\">Graph Canvas</div>\n            <div class=\"muted small\">Drag nodes, create edges and run Prim's algorithm. Nodes are labeled automatically.</div>\n          </div>\n          <div style=\"display:flex;gap:8px;align-items:center;\">\n            <div class=\"small-muted\">Nodes</div>\n            <div id=\"node-count-top\">0</div>\n          </div>\n        </div>\n\n        <div class=\"graph-area\" id=\"graph-area\" tabindex=\"0\" role=\"application\" aria-label=\"Graph drawing area\">\n          <!-- SVG inserted by JS -->\n        </div>\n\n        <div class=\"footer\">\n          <div class=\"small-muted\">Tips: Toggle Connect to create edges. Click a node to set the start. Use Step/Play to follow Prim.</div>\n          <div style=\"display:flex;gap:8px;align-items:center;\">\n            <div class=\"small-muted\">Mode:</div>\n            <div id=\"mode-indicator\" class=\"small-muted\">None</div>\n          </div>\n        </div>\n      </div>\n    </main>\n  </div>\n\n  <!-- Floating weight popup template -->\n  <div id=\"weight-popup\" class=\"weight-popup\" style=\"display:none;\">\n    <label class=\"small-muted\" for=\"weight-input\">Weight</label>\n    <input id=\"weight-input\" type=\"number\" min=\"1\" value=\"5\" />\n    <button id=\"weight-add\" class=\"btn primary\">Add</button>\n    <button id=\"weight-cancel\" class=\"btn ghost\">Cancel</button>\n  </div>\n\n  <script>\n    /* Prim's Algorithm interactive module - vanilla JS\n       - Enforces safe margins and spacing via CSS\n       - No external libraries\n       - Accessible controls\n    */\n\n    /***** Utility helpers *****/\n    const $ = (sel, root = document) => root.querySelector(sel);\n    const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));\n    const rand = (a,b) => Math.floor(Math.random()*(b-a+1))+a;\n\n    /***** DOM References *****/\n    const graphArea = $('#graph-area');\n    const candidateList = $('#candidate-list');\n    const mstWeightEl = $('#mst-weight');\n    const stepCountEl = $('#step-count');\n    const nodeCountEl = $('#node-count');\n    const nodeCountTop = $('#node-count-top');\n    const modeIndicator = $('#mode-indicator');\n    const pseudocode = $('#pseudocode');\n    const weightPopup = $('#weight-popup');\n    const weightInput = $('#weight-input');\n    const weightAddBtn = $('#weight-add');\n    const weightCancelBtn = $('#weight-cancel');\n\n    const addNodeToggle = $('#add-node-toggle');\n    const connectToggle = $('#connect-toggle');\n    const deleteToggle = $('#delete-toggle');\n    const presetBtn = $('#preset-btn');\n    const randomBtn = $('#random-btn');\n    const resetBtn = $('#reset-btn');\n    const stepBtn = $('#step-btn');\n    const playBtn = $('#play-btn');\n    const pauseBtn = $('#pause-btn');\n    const speedRange = $('#speed');\n\n    /***** SVG Setup *****/\n    const svgNS = \"http://www.w3.org/2000/svg\";\n    const svg = document.createElementNS(svgNS, 'svg');\n    svg.setAttribute('viewBox','0 0 1000 600');\n    svg.setAttribute('preserveAspectRatio','xMidYMid meet');\n    graphArea.appendChild(svg);\n\n    // Groups for drawing order\n    const edgeGroup = document.createElementNS(svgNS,'g');\n    const edgeWeightGroup = document.createElementNS(svgNS,'g');\n    const nodeGroup = document.createElementNS(svgNS,'g');\n    svg.appendChild(edgeGroup);\n    svg.appendChild(edgeWeightGroup);\n    svg.appendChild(nodeGroup);\n\n    /***** Graph Data *****/\n    let nodes = []; // {id,label,x,y,svg}\n    let edges = []; // {id,u,v,weight,svgLine,svgText,state}\n\n    let nextNodeId = 1;\n    let nextEdgeId = 1;\n\n    function resetData() {\n      nodes = [];\n      edges = [];\n      nextNodeId = 1;\n      nextEdgeId = 1;\n      selectedStartNode = null;\n      primStateReset();\n      renderAll();\n    }\n\n    /***** Interaction state *****/\n    let mode = null; // 'add-node', 'connect', 'delete', null\n    let isDragging = false;\n    let dragNode = null;\n    let dragOffset = {x:0,y:0};\n    let connectSource = null;\n    let weightPopupContext = null;\n\n    function setMode(m) {\n      mode = m;\n      addNodeToggle.classList.toggle('active', mode === 'add-node');\n      addNodeToggle.setAttribute('aria-pressed', mode === 'add-node');\n      connectToggle.classList.toggle('active', mode === 'connect');\n      connectToggle.setAttribute('aria-pressed', mode === 'connect');\n      deleteToggle.classList.toggle('active', mode === 'delete');\n      deleteToggle.setAttribute('aria-pressed', mode === 'delete');\n      modeIndicator.textContent = mode ? mode.replace('-',' ') : 'None';\n    }\n\n    addNodeToggle.addEventListener('click', () => {\n      setMode(mode === 'add-node' ? null : 'add-node');\n    });\n    connectToggle.addEventListener('click', () => {\n      setMode(mode === 'connect' ? null : 'connect');\n      connectSource = null; // reset any partial connection\n    });\n    deleteToggle.addEventListener('click', () => {\n      setMode(mode === 'delete' ? null : 'delete');\n    });\n\n    /***** Rendering *****/\n    function renderAll() {\n      // clear svg groups\n      while (edgeGroup.firstChild) edgeGroup.removeChild(edgeGroup.firstChild);\n      while (edgeWeightGroup.firstChild) edgeWeightGroup.removeChild(edgeWeightGroup.firstChild);\n      while (nodeGroup.firstChild) nodeGroup.removeChild(nodeGroup.firstChild);\n\n      // edges\n      edges.forEach(e => {\n        const line = document.createElementNS(svgNS,'line');\n        line.classList.add('edge');\n        line.setAttribute('x1', e.u.x);\n        line.setAttribute('y1', e.u.y);\n        line.setAttribute('x2', e.v.x);\n        line.setAttribute('y2', e.v.y);\n        line.setAttribute('stroke-linecap','round');\n        if (e.state) line.classList.add(e.state);\n        edgeGroup.appendChild(line);\n        e.svgLine = line;\n\n        const txt = document.createElementNS(svgNS,'text');\n        txt.classList.add('edge-weight');\n        txt.setAttribute('x', (e.u.x + e.v.x)/2 );\n        txt.setAttribute('y', (e.u.y + e.v.y)/2 - 8 );\n        txt.textContent = e.weight;\n        txt.setAttribute('text-anchor','middle');\n        txt.setAttribute('fill','#cfeafc');\n        edgeWeightGroup.appendChild(txt);\n        e.svgText = txt;\n\n        // ensure pointer events on edges are disabled so clicks go to nodes or canvas\n        line.style.pointerEvents = 'none';\n        txt.style.pointerEvents = 'none';\n      });\n\n      // nodes\n      nodes.forEach(n => {\n        const g = document.createElementNS(svgNS,'g');\n        g.classList.add('node');\n        g.setAttribute('transform', `translate(${n.x},${n.y})`);\n        g.setAttribute('data-id', n.id);\n\n        const circle = document.createElementNS(svgNS,'circle');\n        circle.setAttribute('r', 18);\n        g.appendChild(circle);\n\n        const label = document.createElementNS(svgNS,'text');\n        label.setAttribute('y', 5);\n        label.setAttribute('text-anchor','middle');\n        label.textContent = n.label;\n        g.appendChild(label);\n\n        nodeGroup.appendChild(g);\n        n.svg = g;\n\n        // Reflect prim state classes\n        g.classList.toggle('selected', n === selectedStartNode || primSelectedNodes.has(n.id));\n        g.classList.toggle('mst', primMSTNodeSet.has(n.id));\n      });\n\n      updateCounts();\n      updateCandidateList();\n      updatePseudocodeHighlight();\n    }\n\n    function updateEdgePositions(e) {\n      e.svgLine.setAttribute('x1', e.u.x);\n      e.svgLine.setAttribute('y1', e.u.y);\n      e.svgLine.setAttribute('x2', e.v.x);\n      e.svgLine.setAttribute('y2', e.v.y);\n      e.svgText.setAttribute('x', (e.u.x + e.v.x)/2 );\n      e.svgText.setAttribute('y', (e.u.y + e.v.y)/2 - 8 );\n    }\n\n    function updateCounts() {\n      nodeCountEl.textContent = nodes.length;\n      nodeCountTop.textContent = nodes.length;\n      stepCountEl.textContent = primStepCount;\n    }\n\n    /***** Canvas interactions: add node, drag node, connect edges, delete *****/\n    // Convert screen click to SVG coordinates (viewBox 1000x600)\n    function clientToSvgCoords(clientX, clientY) {\n      const rect = svg.getBoundingClientRect();\n      const xPct = (clientX - rect.left) / rect.width;\n      const yPct = (clientY - rect.top) / rect.height;\n      const vb = svg.viewBox.baseVal;\n      const x = vb.x + xPct * vb.width;\n      const y = vb.y + yPct * vb.height;\n      return {x,y};\n    }\n\n    graphArea.addEventListener('pointerdown', (ev) => {\n      graphArea.focus();\n      // check if clicked on a node (use elementFromPoint)\n      const pt = document.elementFromPoint(ev.clientX, ev.clientY);\n      const nodeEl = pt && pt.closest && pt.closest('.node');\n\n      if (mode === 'add-node' && !nodeEl) {\n        // add node\n        const p = clientToSvgCoords(ev.clientX, ev.clientY);\n        addNode(p.x, p.y);\n        renderAll();\n        return;\n      }\n\n      if (nodeEl) {\n        const id = Number(nodeEl.getAttribute('data-id'));\n        const node = nodes.find(n => n.id === id);\n\n        if (mode === 'delete') {\n          // delete node and related edges\n          removeNode(node);\n          renderAll();\n          return;\n        }\n\n        if (mode === 'connect') {\n          // handle connect sequence\n          if (!connectSource) {\n            connectSource = node;\n            // visual feedback: highlight\n            node.svg.classList.add('highlight');\n          } else if (connectSource && connectSource !== node) {\n            // open weight popup near pointer\n            openWeightPopup(ev.clientX, ev.clientY, {u: connectSource, v: node});\n            // clear highlight\n            connectSource.svg.classList.remove('highlight');\n            connectSource = null;\n          } else {\n            // clicked same node - cancel\n            connectSource.svg.classList.remove('highlight');\n            connectSource = null;\n          }\n          return;\n        }\n\n        // If not in a special mode, allow dragging or selecting as start node\n        // Setup dragging\n        isDragging = true;\n        dragNode = node;\n        const p = clientToSvgCoords(ev.clientX, ev.clientY);\n        dragOffset.x = node.x - p.x;\n        dragOffset.y = node.y - p.y;\n\n        // If Prim hasn't started, clicking selects start node\n        if (!primRunning && !primHasRun) {\n          setStartNode(node);\n        }\n\n        ev.preventDefault();\n        return;\n      } else {\n        // clicked empty canvas: clear connectSource if any\n        if (connectSource) {\n          connectSource.svg.classList.remove('highlight');\n          connectSource = null;\n        }\n      }\n    });\n\n    window.addEventListener('pointermove', (ev) => {\n      if (isDragging && dragNode) {\n        const p = clientToSvgCoords(ev.clientX, ev.clientY);\n        dragNode.x = Math.max(20, Math.min(980, p.x + dragOffset.x));\n        dragNode.y = Math.max(20, Math.min(580, p.y + dragOffset.y));\n        // update node transform and edges\n        dragNode.svg.setAttribute('transform', `translate(${dragNode.x},${dragNode.y})`);\n        edges.forEach(e => {\n          if (e.u === dragNode || e.v === dragNode) updateEdgePositions(e);\n        });\n      }\n    });\n\n    window.addEventListener('pointerup', (ev) => {\n      isDragging = false;\n      dragNode = null;\n    });\n\n    // Keyboard shortcuts for accessibility\n    graphArea.addEventListener('keydown', (ev) => {\n      if (ev.key === 'a') setMode('add-node');\n      if (ev.key === 'c') setMode('connect');\n      if (ev.key === 'Escape') setMode(null);\n    });\n\n    /***** Node / Edge CRUD *****/\n    function addNode(x,y,label) {\n      const id = nextNodeId++;\n      const node = { id, label: label || String.fromCharCode(64 + id), x, y, svg: null };\n      nodes.push(node);\n      renderAll();\n      return node;\n    }\n\n    function removeNode(node) {\n      // remove connected edges\n      edges = edges.filter(e => {\n        if (e.u === node || e.v === node) {\n          // remove svg too if present\n          return false;\n        }\n        return true;\n      });\n      nodes = nodes.filter(n => n !== node);\n      // update ids mapping unaffected\n      // update prim structures (reset algorithm)\n      primStateReset();\n    }\n\n    function addEdge(u,v,weight) {\n      // prevent duplicate edges\n      if (edges.some(e => (e.u===u && e.v===v) || (e.u===v && e.v===u))) return null;\n      const id = nextEdgeId++;\n      const e = { id, u, v, weight: Number(weight), svgLine: null, svgText: null, state: null };\n      edges.push(e);\n      renderAll();\n      return e;\n    }\n\n    /***** Weight popup handling *****/\n    function openWeightPopup(clientX, clientY, context) {\n      weightPopupContext = context;\n      weightPopup.style.display = 'flex';\n      // position within graphArea bounds\n      const rect = graphArea.getBoundingClientRect();\n      let left = clientX - rect.left + 10;\n      let top = clientY - rect.top + 10;\n      // clamp\n      left = Math.max(6, Math.min(rect.width - 160, left));\n      top = Math.max(6, Math.min(rect.height - 60, top));\n      weightPopup.style.left = (rect.left + left) + 'px';\n      weightPopup.style.top = (rect.top + top) + 'px';\n      weightInput.value = rand(1, 20);\n      weightInput.focus();\n    }\n\n    weightAddBtn.addEventListener('click', () => {\n      const w = Number(weightInput.value) || 1;\n      if (weightPopupContext) {\n        addEdge(weightPopupContext.u, weightPopupContext.v, w);\n        weightPopupContext = null;\n      }\n      weightPopup.style.display = 'none';\n    });\n\n    weightCancelBtn.addEventListener('click', () => {\n      if (connectSource) connectSource.svg.classList.remove('highlight');\n      connectSource = null;\n      weightPopupContext = null;\n      weightPopup.style.display = 'none';\n    });\n\n    /***** Preset and random graph generators *****/\n    function loadPreset() {\n      resetData();\n      // Some nodes arranged\n      addNode(220,110,'A');\n      addNode(420,70,'B');\n      addNode(620,120,'C');\n      addNode(320,250,'D');\n      addNode(520,280,'E');\n      addNode(180,340,'F');\n\n      // find node by label\n      const find = (label) => nodes.find(n=>n.label===label);\n      addEdge(find('A'), find('B'), 7);\n      addEdge(find('A'), find('D'), 5);\n      addEdge(find('B'), find('C'), 8);\n      addEdge(find('B'), find('D'), 9);\n      addEdge(find('B'), find('E'), 7);\n      addEdge(find('C'), find('E'), 5);\n      addEdge(find('D'), find('E'), 15);\n      addEdge(find('D'), find('F'), 6);\n      addEdge(find('F'), find('E'), 8);\n      renderAll();\n    }\n\n    function generateRandomGraph() {\n      resetData();\n      const n = rand(6,10);\n      for (let i=0;i<n;i++) {\n        addNode(rand(80,920), rand(60,520));\n      }\n      // ensure connected-ish: connect each node to a few others\n      for (let i=0;i<n;i++) {\n        const u = nodes[i];\n        const connections = rand(2,3);\n        for (let k=0;k<connections;k++) {\n          const v = nodes[rand(0,n-1)];\n          if (v === u) continue;\n          addEdge(u,v, rand(1,20));\n        }\n      }\n      renderAll();\n    }\n\n    presetBtn.addEventListener('click', loadPreset);\n    randomBtn.addEventListener('click', generateRandomGraph);\n    resetBtn.addEventListener('click', resetData);\n\n    /***** Prim's Algorithm State & Logic *****/\n    // We'll implement Prim step-by-step; maintain sets\n    let selectedStartNode = null;\n    let primSelectedNodes = new Set(); // nodes in S\n    let primMSTEdges = new Set(); // edges included\n    let primMSTNodeSet = new Set(); // nodes that are in MST (same as selectedNodes)\n    let primCandidates = []; // list of candidate edges: {edge, weight}\n    let primRunning = false;\n    let primHasRun = false;\n    let primStepCount = 0;\n    let primTimer = null;\n\n    function primStateReset() {\n      primSelectedNodes.clear();\n      primMSTEdges.clear();\n      primMSTNodeSet.clear();\n      primCandidates = [];\n      primRunning = false;\n      primHasRun = false;\n      primStepCount = 0;\n      clearTimeout(primTimer);\n      pauseBtn.style.display = 'none';\n      playBtn.style.display = 'inline-flex';\n      mstWeightEl.textContent = '0';\n      stepCountEl.textContent = '0';\n      // reset edge/node states visuals\n      edges.forEach(e => { e.state = null; });\n      nodes.forEach(n => { /* nothing */ });\n      renderAll();\n    }\n\n    function setStartNode(node) {\n      selectedStartNode = node;\n      primStateReset();\n      // highlight\n      renderAll();\n      node.svg.classList.add('selected');\n      // add initial state in pseudocode\n      highlightLine('init');\n    }\n\n    function gatherCandidates() {\n      // candidate edges: edges with exactly one endpoint in primSelectedNodes\n      primCandidates = edges.filter(e => {\n        const inU = primSelectedNodes.has(e.u.id);\n        const inV = primSelectedNodes.has(e.v.id);\n        return (inU && !inV) || (!inU && inV);\n      }).map(e => ({e, w: e.weight}));\n      // sort by weight then by id\n      primCandidates.sort((a,b) => a.w - b.w || a.e.id - b.e.id);\n      // update edge states\n      edges.forEach(e => {\n        e.state = null;\n      });\n      primCandidates.forEach(obj => {\n        if (!primMSTEdges.has(obj.e.id)) obj.e.state = 'candidate';\n      });\n      renderAll();\n    }\n\n    function primInitIfNeeded() {\n      if (!selectedStartNode) {\n        // choose first node by default if available\n        if (nodes.length === 0) return false;\n        setStartNode(nodes[0]);\n      }\n      if (!primRunning && !primHasRun) {\n        // add start to S\n        primSelectedNodes.add(selectedStartNode.id);\n        primMSTNodeSet.add(selectedStartNode.id);\n        primStepCount = 0;\n        gatherCandidates();\n        highlightLine('add-edges');\n        renderAll();\n        return true;\n      }\n      return primRunning || primHasRun;\n    }\n\n    function primStep() {\n      if (!nodes.length) return;\n      const initOK = primInitIfNeeded();\n      if (!initOK && !primRunning && !primHasRun) return;\n\n      primRunning = true;\n      // while S size < n, pick smallest candidate that connects S to V\\S\n      if (primSelectedNodes.size >= nodes.length) {\n        primCompleted();\n        return;\n      }\n      // refresh candidates\n      gatherCandidates();\n\n      if (primCandidates.length === 0) {\n        // No crossing edges — graph disconnected. finish.\n        primCompleted();\n        return;\n      }\n\n      // Consider smallest\n      const candidate = primCandidates[0];\n      const e = candidate.e;\n\n      // Visual: mark as being considered\n      e.state = 'considering';\n      renderAll();\n      highlightLine('pick');\n\n      // After a short delay show addition\n      setTimeout(() => {\n        // if both endpoints already in S (might be stale), skip\n        const inU = primSelectedNodes.has(e.u.id);\n        const inV = primSelectedNodes.has(e.v.id);\n        if (inU && inV) {\n          // remove and step again\n          primCandidates.shift();\n          renderAll();\n          primStep();\n          return;\n        }\n\n        // Add edge to MST\n        primMSTEdges.add(e.id);\n        e.state = 'mst';\n        // decide which node was new\n        const newNode = inU ? e.v : e.u;\n        primSelectedNodes.add(newNode.id);\n        primMSTNodeSet.add(newNode.id);\n        primStepCount += 1;\n        // Update MST weight\n        const total = Array.from(primMSTEdges).reduce((acc, eid) => {\n          const edge = edges.find(x => x.id === eid);\n          return acc + (edge ? edge.weight : 0);\n        }, 0);\n        mstWeightEl.textContent = String(total);\n        stepCountEl.textContent = primStepCount;\n\n        highlightLine('add-edge');\n\n        // Update candidates: add adjacent edges of newNode\n        // will be recalculated in next gatherCandidates call\n        setTimeout(() => {\n          gatherCandidates();\n          highlightLine('update');\n\n          // keep running state\n          if (primSelectedNodes.size >= nodes.length) {\n            primCompleted();\n            return;\n          }\n          // Not auto stepping further here (Step vs Play handled by timer)\n        }, 420);\n      }, 700);\n    }\n\n    function primCompleted() {\n      primRunning = false;\n      primHasRun = true;\n      clearTimeout(primTimer);\n      playBtn.style.display = 'inline-flex';\n      pauseBtn.style.display = 'none';\n      highlightLine('done');\n      // fade irrelevant edges\n      edges.forEach(e => {\n        if (!primMSTEdges.has(e.id)) {\n          e.state = 'faded';\n        }\n      });\n      renderAll();\n    }\n\n    // Pseudocode highlighting helper\n    function highlightLine(name) {\n      $$('.code-line', pseudocode).forEach(el => el.classList.remove('active'));\n      const el = $(`.code-line[data-line=\"${name}\"]`, pseudocode);\n      if (el) el.classList.add('active');\n    }\n\n    // Update candidate list UI\n    function updateCandidateList() {\n      candidateList.innerHTML = '';\n      primCandidates.forEach(obj => {\n        const e = obj.e;\n        const div = document.createElement('div');\n        div.className = 'candidate-item';\n        div.innerHTML = `<div><span class=\"edge-label\">(${e.u.label} - ${e.v.label})</span></div><div>${e.weight}</div>`;\n        candidateList.appendChild(div);\n      });\n      if (primCandidates.length === 0) {\n        const none = document.createElement('div');\n        none.className = 'candidate-item';\n        none.style.opacity = 0.6;\n        none.textContent = '— no candidates —';\n        candidateList.appendChild(none);\n      }\n    }\n\n    /***** Controls: Step / Play / Pause *****/\n    stepBtn.addEventListener('click', () => {\n      primStep();\n    });\n\n    playBtn.addEventListener('click', () => {\n      if (!primInitIfNeeded()) primInitIfNeeded();\n      playBtn.style.display = 'none';\n      pauseBtn.style.display = 'inline-flex';\n      startAutoPlay();\n    });\n\n    pauseBtn.addEventListener('click', () => {\n      stopAutoPlay();\n    });\n\n    function startAutoPlay() {\n      primRunning = true;\n      function loop() {\n        // If completed, stop\n        if (primSelectedNodes.size >= nodes.length || primCandidates.length === 0 && primHasRun) {\n          primCompleted();\n          return;\n        }\n        primStep();\n        primTimer = setTimeout(loop, Number(speedRange.value) || 900);\n      }\n      loop();\n    }\n\n    function stopAutoPlay() {\n      clearTimeout(primTimer);\n      primRunning = false;\n      pauseBtn.style.display = 'none';\n      playBtn.style.display = 'inline-flex';\n    }\n\n    /***** Initialization: load a preset example on start *****/\n    resetData();\n    loadPreset();\n\n    /***** Accessibility: expose brief instructions in console for keyboard users *****/\n    console.log('Prim interactive: Shortcuts - \"a\": Add Node mode, \"c\": Connect mode, \"Esc\": clear mode. Use Tab to focus controls.');\n\n    /***** Small polish: update node visuals when prim structures change *****/\n    // Observe prim sets and update node classes after each render call by hooking renderAll (already does)\n    // Also update edge classes in DOM when edge.state changes\n    const observer = new MutationObserver(() => {});\n    // Not necessary further.\n\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Prim’s Algorithm.\n\n**Project Overview:**\nTopic: Prim’s Algorithm\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Prim’s Algorithm"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "477dc4b0-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:50:40.380Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Sliding Window",
    "answer": {
      "role": "assistant",
      "content": "Concept Title:\nSliding Window — fixed-size window for finding the maximum sum of any contiguous subarray of length k\n\nLearning Objective:\nAfter interacting with this module users will be able to:\n- Visually understand how a fixed-size sliding window moves across an array.\n- See the difference between recomputing a window sum and updating it incrementally (subtract outgoing, add incoming).\n- Appreciate why sliding-window achieves O(n) time for this problem.\n- Manipulate inputs and controls to build intuition for correctness and performance.\n\nInteraction Design:\n- Inputs & Controls:\n  - Array input: a text field for comma-/space-separated integer values (validated). Keyboard accessible and labeled.\n  - Window size (k): a slider and numeric stepper bound to [1, array length]. Changing k updates the visualization immediately.\n  - Buttons: Randomize, Reset, Play/Pause, Step Back, Step Forward. Keyboard shortcuts: Space = Play/Pause, Left/Right arrows = Step Back/Forward.\n  - Animation speed slider.\n- Visual interactions & feedback:\n  - Bar-chart representation of the array. Each element is a vertical bar with its numeric label beneath.\n  - The active window is shown as a semi-transparent rounded rectangle overlaying k consecutive bars. The overlay animates smoothly left/right when stepping or autoplaying.\n  - When the window moves forward:\n    - The outgoing bar briefly flashes red with an animated \"-x\" label that fades upward.\n    - The incoming bar briefly flashes green with an animated \"+y\" label that fades upward.\n    - The displayed running sum updates with a small \"delta\" animation showing the subtraction and addition (for example: \"sum = 10 → 10 - 3 + 6 = 13\").\n  - \"Best sum so far\" is displayed and the bars that form the best window are highlighted (gold outline).\n  - Play mode animates the window automatically at selected speed, pausing at the end.\n  - Step Forward/Back allows precise exploration; the Back action re-computes using reverse delta (add outgoing/subtract incoming) so animation demonstrates invertible update.\n  - A short textual invariant is shown and updated (e.g., \"Invariant: currentSum = sum(window elements)\"). An aria-live region announces updated sums for screen readers.\n- How interactions reinforce understanding:\n  - The subtraction/addition animations make the incremental update explicit, reinforcing why recomputing all k elements each step is unnecessary.\n  - The best-window highlight and running sum updates let users verify correctness for many inputs quickly.\n  - By editing the array and k, users can produce corner cases (negative values, zeros, large magnitude) and see the algorithm still holds.\n\nLayout Description:\n- Safe area: the entire layout uses a 24 px padding from the viewport edges.\n- Responsive design:\n  - Desktop (>= 900px): Two-column layout. Left column (controls & explanation) width 360–420px; right column expands (visualization).\n  - Narrow/mobile: Single column stacked vertically: controls on top, visualization below.\n- Spacing rules:\n  - Minimum 16 px gap between interactive elements (controls, buttons, sliders).\n  - Visual area centers the bar chart horizontally and has ample vertical spacing so animations are clear.\n- Visual hierarchy:\n  - Top: Title and concise learning objective text.\n  - Left (controls): Inputs stacked with clear labels, grouped sections (Array, Window Size, Animation Controls), and buttons in a single-row toolbar.\n  - Right (visualization): Large bar-chart with the sliding window overlay, current sum and best sum shown above the chart. Beneath the chart: the pseudocode/invariant block and a brief complexity summary.\n- Accessibility & contrast:\n  - Buttons and sliders use sufficient color contrast.\n  - All controls are labeled and reachable via keyboard.\n  - The chart uses both color and outline highlighting for the best window.\n- Minimum spacing & safe margins are enforced via CSS variables and utility classes.\n\nInteractive Module Implementation (self-contained HTML/CSS/JS):\n- The following single-file implementation fulfills the design: it is vanilla HTML/CSS/JS, accessible, responsive, and includes animations and keyboard support.\n\nYou can paste the code below into a file named sliding-window.html and open it in a browser.\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Sliding Window — Max Sum of Fixed-Size Window (Interactive)</title>\n  <style>\n    :root{\n      --safe: 24px;\n      --gap: 16px;\n      --panel-width: 380px;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --accent: #38bdf8;\n      --good: #10b981;\n      --bad: #ef4444;\n      --gold: #f59e0b;\n      --muted: #94a3b8;\n      --glass: rgba(255,255,255,0.03);\n      --radius: 10px;\n      --transition: 350ms cubic-bezier(.2,.9,.2,1);\n    }\n    /* Page safe area */\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071023 0%, #071226 60%);\n      color:#e6eef8;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .wrap{\n      padding: var(--safe);\n      box-sizing:border-box;\n      min-height:100vh;\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      justify-content:center;\n    }\n\n    /* Layout: responsive two-column */\n    .left, .right{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: var(--radius);\n      padding:20px;\n      box-sizing:border-box;\n      box-shadow: 0 6px 24px rgba(2,6,23,0.6);\n    }\n    .left{\n      width: min(var(--panel-width), 92vw);\n      flex: 0 0 auto;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    .right{\n      flex:1 1 auto;\n      min-width: 280px;\n      display:flex;\n      flex-direction:column;\n      gap:20px;\n    }\n\n    header h1{\n      font-size:18px;\n      margin:0 0 4px 0;\n      color:var(--accent);\n    }\n    header p{\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* Controls styling */\n    .control-group{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    label{\n      font-size:13px;\n      color:#cfe8ff;\n      display:block;\n    }\n    input[type=\"text\"], input[type=\"number\"]{\n      width:100%;\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.06);\n      background:var(--glass);\n      color:inherit;\n      outline:none;\n      box-sizing:border-box;\n      font-size:14px;\n    }\n    .row{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n    }\n    .toolbar{\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n    }\n    button{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.06);\n      color:inherit;\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-size:14px;\n      transition: transform 160ms ease, box-shadow 160ms ease;\n      display:inline-flex;\n      gap:8px;\n      align-items:center;\n    }\n    button:active{ transform: translateY(1px); }\n    .primary{\n      background: linear-gradient(180deg,var(--accent), #2bb0df);\n      color:#042027;\n      font-weight:600;\n      border: none;\n    }\n    .small{\n      padding:6px 8px;\n      font-size:13px;\n    }\n\n    /* Visualization */\n    .viscard{\n      padding:18px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      align-items:stretch;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .stats{\n      display:flex;\n      gap:20px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .stat{\n      background: rgba(255,255,255,0.02);\n      padding:8px 10px;\n      border-radius:8px;\n      min-width:140px;\n      font-size:14px;\n      color:var(--muted);\n    }\n    .stat .value{\n      display:block;\n      font-size:16px;\n      font-weight:700;\n      color:#e6f8ff;\n      margin-top:6px;\n    }\n\n    /* Chart area */\n    .chart-wrap{\n      position:relative;\n      height:260px;\n      display:flex;\n      align-items:flex-end;\n      justify-content:center;\n      background: linear-gradient(180deg, rgba(255,255,255,0.00), rgba(255,255,255,0.00));\n      border-radius:8px;\n      padding:14px;\n      overflow:hidden;\n    }\n    .bars{\n      display:flex;\n      align-items:end;\n      gap:10px;\n      transition: transform var(--transition);\n      position:relative;\n      padding-bottom:28px;\n    }\n    .bar{\n      width:44px;\n      display:flex;\n      flex-direction:column;\n      align-items:center;\n      gap:8px;\n      user-select:none;\n    }\n    .bar-rect{\n      width:100%;\n      border-radius:8px 8px 4px 4px;\n      background: linear-gradient(180deg,#2b6a8f,#174b64);\n      display:flex;\n      align-items:flex-end;\n      justify-content:center;\n      transition: transform var(--transition), box-shadow 220ms ease, background 220ms ease;\n      position:relative;\n    }\n    .bar-label{\n      font-size:12px;\n      color:var(--muted);\n      margin-top:6px;\n      text-align:center;\n      word-break:break-word;\n    }\n    .bar-value{\n      font-size:12px;\n      color:#e6f8ff;\n      padding:4px 6px;\n      border-radius:6px;\n      background: rgba(255,255,255,0.03);\n      margin-bottom:6px;\n    }\n\n    /* Window overlay */\n    .window-overlay{\n      position:absolute;\n      top:12px;\n      bottom:28px;\n      background: rgba(60,120,180,0.14);\n      border: 2px dashed rgba(60,160,220,0.25);\n      border-radius:12px;\n      pointer-events:none;\n      transition: transform var(--transition), width var(--transition);\n      box-shadow: 0 6px 18px rgba(11,31,55,0.45);\n      display:flex;\n      align-items:flex-start;\n      justify-content:center;\n      overflow:visible;\n    }\n    .window-overlay .label{\n      margin-top:8px;\n      font-size:12px;\n      color:#e6f8ff;\n      background: rgba(255,255,255,0.03);\n      padding:6px 10px;\n      border-radius:6px;\n      backdrop-filter: blur(4px);\n    }\n\n    /* Highlights */\n    .bar.best .bar-rect{\n      outline: 3px solid rgba(245,158,11,0.18);\n      box-shadow: 0 8px 30px rgba(245,158,11,0.06), inset 0 -6px 18px rgba(245,158,11,0.02);\n      background: linear-gradient(180deg,#f59e0b,#dea42b);\n    }\n    .bar.outgoing .bar-rect{\n      box-shadow: 0 8px 18px rgba(239,68,68,0.12);\n      background: linear-gradient(180deg,#ff6b6b,#da3b3b);\n    }\n    .bar.incoming .bar-rect{\n      box-shadow: 0 8px 18px rgba(16,185,129,0.12);\n      background: linear-gradient(180deg,#34d399,#10b981);\n    }\n\n    /* delta animations (floating labels) */\n    .float-delta{\n      position:absolute;\n      top:-26px;\n      left:50%;\n      transform:translateX(-50%);\n      font-size:13px;\n      padding:6px 8px;\n      border-radius:6px;\n      color:#042027;\n      font-weight:700;\n      opacity:0;\n      transition: transform 420ms cubic-bezier(.2,.9,.2,1), opacity 320ms ease;\n      pointer-events:none;\n    }\n    .bar.outgoing .float-delta{\n      background: rgba(239,68,68,0.95);\n      color:white;\n      opacity:1;\n      transform: translate(-50%,-18px);\n    }\n    .bar.incoming .float-delta{\n      background: rgba(16,185,129,0.95);\n      color:white;\n      opacity:1;\n      transform: translate(-50%,-18px);\n    }\n\n    /* pseudocode block */\n    pre{\n      background: rgba(255,255,255,0.02);\n      padding:12px;\n      border-radius:8px;\n      color: #dff7ff;\n      font-size:13px;\n      margin:0;\n      overflow:auto;\n    }\n\n    /* small helpers */\n    .muted{ color:var(--muted); font-size:13px; }\n    .kbd{\n      background: rgba(255,255,255,0.03);\n      padding:6px 8px;\n      border-radius:6px;\n      font-weight:600;\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* Responsive adjustments */\n    @media (max-width:900px){\n      .wrap{ flex-direction:column; gap:var(--gap); padding: var(--safe); }\n      .left{ width:100%; order:1; }\n      .right{ order:2; }\n      .bars{ gap:8px; }\n      .bar{ width:38px; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"wrap\" role=\"application\" aria-label=\"Sliding window interactive module\">\n    <div class=\"left\" aria-hidden=\"false\">\n      <header>\n        <h1>Sliding Window — Fixed Window Max Sum</h1>\n        <p>Interactively explore how a sliding window finds the maximum sum of any contiguous window of size k in O(n) time.</p>\n      </header>\n\n      <div class=\"control-group\" style=\"margin-top:6px;\">\n        <div>\n          <label for=\"arrayInput\">Array (comma or space separated integers)</label>\n          <input id=\"arrayInput\" type=\"text\" aria-label=\"Array input\" value=\"2 1 5 1 3 2\" />\n        </div>\n\n        <div style=\"display:flex; gap:12px; align-items:center;\">\n          <div style=\"flex:1;\">\n            <label for=\"kRange\">Window size k</label>\n            <input id=\"kRange\" type=\"range\" min=\"1\" max=\"6\" value=\"3\" aria-label=\"Window size slider\" />\n          </div>\n          <div style=\"width:84px;\">\n            <label for=\"kNumber\" class=\"muted\">k</label>\n            <input id=\"kNumber\" type=\"number\" min=\"1\" max=\"6\" value=\"3\" aria-label=\"Window size numeric\" />\n          </div>\n        </div>\n\n        <div class=\"row toolbar\" role=\"toolbar\" aria-label=\"Playback controls\">\n          <button id=\"btnRandom\" class=\"small\" title=\"Randomize array\">Randomize</button>\n          <button id=\"btnReset\" class=\"small\" title=\"Reset\">Reset</button>\n          <button id=\"btnBack\" class=\"small\" title=\"Step back (Left arrow)\">◀ Step</button>\n          <button id=\"btnPlay\" class=\"small primary\" title=\"Play / Pause (Space)\">Play</button>\n          <button id=\"btnForward\" class=\"small\" title=\"Step forward (Right arrow)\">Step ▶</button>\n        </div>\n\n        <div style=\"display:flex; gap:12px; align-items:center;\">\n          <div style=\"flex:1;\">\n            <label for=\"speedRange\">Animation speed</label>\n            <input id=\"speedRange\" type=\"range\" min=\"200\" max=\"1400\" step=\"50\" value=\"700\" />\n          </div>\n          <div style=\"width:64px;\">\n            <label class=\"muted\">Speed</label>\n            <div id=\"speedLabel\" style=\"font-weight:600;\">700 ms</div>\n          </div>\n        </div>\n\n        <div>\n          <label class=\"muted\">Hints & Shortcuts</label>\n          <div style=\"display:flex; gap:8px; margin-top:8px;\">\n            <span class=\"kbd\">Space</span><span class=\"muted\">Play/Pause</span>\n            <span class=\"kbd\">←</span><span class=\"muted\">Step back</span>\n            <span class=\"kbd\">→</span><span class=\"muted\">Step forward</span>\n          </div>\n        </div>\n      </div>\n\n      <div aria-live=\"polite\" id=\"ariaAnnounce\" style=\"position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden;\"></div>\n    </div>\n\n    <div class=\"right\">\n      <div class=\"viscard\">\n        <div class=\"stats\">\n          <div class=\"stat\" aria-live=\"polite\">\n            <div class=\"muted\">Current window sum</div>\n            <div id=\"currentSum\" class=\"value\">—</div>\n            <div style=\"font-size:12px; color:var(--muted); margin-top:6px;\" id=\"currentDelta\"> </div>\n          </div>\n\n          <div class=\"stat\">\n            <div class=\"muted\">Best window sum</div>\n            <div id=\"bestSum\" class=\"value\">—</div>\n            <div style=\"font-size:12px; color:var(--muted); margin-top:6px;\" id=\"bestRange\"> </div>\n          </div>\n\n          <div class=\"stat\">\n            <div class=\"muted\">Complexity</div>\n            <div class=\"value\">O(n)</div>\n            <div style=\"font-size:12px; color:var(--muted); margin-top:6px;\">Sliding window update: sum += in - out</div>\n          </div>\n        </div>\n\n        <div class=\"chart-wrap\" id=\"chartWrap\" aria-hidden=\"false\">\n          <div class=\"bars\" id=\"bars\"></div>\n          <div class=\"window-overlay\" id=\"windowOverlay\" style=\"width:0; transform:translateX(0px);\">\n            <div class=\"label\" id=\"overlayLabel\">Window</div>\n          </div>\n        </div>\n\n        <div>\n          <label class=\"muted\">Algorithm (pseudocode)</label>\n          <pre id=\"pseudocode\">\nbest = -∞\ncurrent = sum(first k elements)\nbest = current\nfor i = k to n-1:\n    current = current - nums[i-k] + nums[i]\n    if current > best:\n        best = current\n          </pre>\n        </div>\n      </div>\n\n      <div style=\"display:flex; gap:12px; align-items:center;\">\n        <div class=\"muted\" style=\"flex:1\">Try different arrays and window sizes. Watch outgoing (red) and incoming (green) elements and the incremental update.</div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Self-contained sliding window interactive implementation\n    (function () {\n      // Elements\n      const arrayInput = document.getElementById('arrayInput');\n      const kRange = document.getElementById('kRange');\n      const kNumber = document.getElementById('kNumber');\n      const barsEl = document.getElementById('bars');\n      const windowOverlay = document.getElementById('windowOverlay');\n      const currentSumEl = document.getElementById('currentSum');\n      const bestSumEl = document.getElementById('bestSum');\n      const bestRangeEl = document.getElementById('bestRange');\n      const currentDeltaEl = document.getElementById('currentDelta');\n      const btnRandom = document.getElementById('btnRandom');\n      const btnReset = document.getElementById('btnReset');\n      const btnPlay = document.getElementById('btnPlay');\n      const btnBack = document.getElementById('btnBack');\n      const btnForward = document.getElementById('btnForward');\n      const speedRange = document.getElementById('speedRange');\n      const speedLabel = document.getElementById('speedLabel');\n      const ariaAnnounce = document.getElementById('ariaAnnounce');\n\n      // State\n      let nums = [2,1,5,1,3,2];\n      let baseNums = nums.slice();\n      let k = 3;\n      let index = 0; // start index of window\n      let currentSum = 0;\n      let bestSum = -Infinity;\n      let bestStart = 0;\n      let playing = false;\n      let timer = null;\n\n      // Visual parameters\n      const BAR_WIDTH = 44; // CSS width of .bar\n      const GAP = 10; // matches CSS .bars gap\n      const MAX_BAR_HEIGHT = 180; // px area for height mapping\n\n      // Helpers\n      function parseInputArray(value) {\n        const parts = value.trim().split(/[\\s,]+/).filter(Boolean);\n        const parsed = parts.map(s => {\n          const n = Number(s);\n          return Number.isFinite(n) ? Math.trunc(n) : NaN;\n        }).filter(x => !Number.isNaN(x));\n        return parsed;\n      }\n\n      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }\n\n      function normalizeHeights(values) {\n        // Normalize to [28, MAX_BAR_HEIGHT] based on absolute values\n        const absMax = Math.max(1, ...values.map(v => Math.abs(v)));\n        return values.map(v => {\n          // Add small offset for almost-zero visuals\n          const relative = Math.abs(v) / absMax;\n          const min = 28;\n          return min + Math.round(relative * (MAX_BAR_HEIGHT - min)) * Math.sign(v);\n        });\n      }\n\n      // Render bars based on nums\n      function renderBars() {\n        barsEl.innerHTML = '';\n        const values = nums.slice();\n        const heights = normalizeHeights(values);\n        values.forEach((val, i) => {\n          const bar = document.createElement('div');\n          bar.className = 'bar';\n          bar.dataset.index = i;\n          bar.innerHTML = `\n            <div class=\"bar-rect\" style=\"height:${Math.abs(heights[i])}px;\" aria-hidden=\"false\">\n              <div class=\"float-delta\"></div>\n            </div>\n            <div class=\"bar-value\">${val}</div>\n            <div class=\"bar-label\">idx ${i}</div>\n          `;\n          barsEl.appendChild(bar);\n        });\n\n        // Update range slider max/min\n        kRange.max = Math.max(1, nums.length);\n        kNumber.max = Math.max(1, nums.length);\n        if (k > nums.length) {\n          k = nums.length;\n          kRange.value = k;\n          kNumber.value = k;\n        }\n\n        // Position overlay and width\n        updateOverlayVisual();\n      }\n\n      function updateOverlayVisual(immediate) {\n        const barsCount = nums.length;\n        if (!barsCount) {\n          windowOverlay.style.width = '0';\n          return;\n        }\n        const barEl = barsEl.querySelector('.bar');\n        const barRect = barEl ? barEl.getBoundingClientRect() : { width: BAR_WIDTH };\n        const width = (barRect.width * k) + (GAP * (k - 1));\n        // compute translate X relative to bars container\n        const offset = index * (barRect.width + GAP);\n        // apply transition duration according to speed (faster speed = shorter CSS transition)\n        const ms = Number(speedRange.value) || 700;\n        windowOverlay.style.transitionDuration = Math.max(120, ms * 0.6) + 'ms';\n        windowOverlay.style.width = width + 'px';\n        windowOverlay.style.transform = `translateX(${offset}px)`;\n        // overlay label shows start..end\n        const overlayLabel = windowOverlay.querySelector('.label');\n        overlayLabel.textContent = `window: [${index} .. ${index + k - 1}]`;\n      }\n\n      // Compute initial sums\n      function computeInitialSums() {\n        if (k <= 0 || nums.length < k) {\n          currentSum = 0;\n          bestSum = -Infinity;\n          bestStart = 0;\n          index = 0;\n          updateUI();\n          return;\n        }\n        currentSum = nums.slice(0, k).reduce((a,b) => a+b, 0);\n        bestSum = currentSum;\n        bestStart = 0;\n        index = 0;\n        updateUI();\n      }\n\n      function updateUI(deltaInfo) {\n        // Clear all highlights\n        const allBars = barsEl.querySelectorAll('.bar');\n        allBars.forEach(b => b.classList.remove('incoming','outgoing','best'));\n\n        // Mark best bars\n        for (let i=bestStart; i<bestStart + k; i++){\n          const b = barsEl.querySelector(`.bar[data-index=\"${i}\"]`);\n          if (b) b.classList.add('best');\n        }\n\n        // Mark current incoming/outgoing if provided\n        if (deltaInfo) {\n          const outEl = barsEl.querySelector(`.bar[data-index=\"${deltaInfo.outIndex}\"]`);\n          const inEl = barsEl.querySelector(`.bar[data-index=\"${deltaInfo.inIndex}\"]`);\n          if (outEl) {\n            outEl.classList.add('outgoing');\n            const fd = outEl.querySelector('.float-delta');\n            if (fd) fd.textContent = `-${deltaInfo.outVal}`;\n            // remove highlight after animation\n            setTimeout(() => { outEl.classList.remove('outgoing'); }, 700);\n          }\n          if (inEl) {\n            inEl.classList.add('incoming');\n            const fd = inEl.querySelector('.float-delta');\n            if (fd) fd.textContent = `+${deltaInfo.inVal}`;\n            setTimeout(() => { inEl.classList.remove('incoming'); }, 700);\n          }\n        }\n\n        currentSumEl.textContent = String(currentSum);\n        bestSumEl.textContent = Number.isFinite(bestSum) ? String(bestSum) : '—';\n        bestRangeEl.textContent = Number.isFinite(bestSum) ? `best window: [${bestStart} .. ${bestStart + k - 1}]` : '';\n        if (deltaInfo) {\n          currentDeltaEl.textContent = `${currentSum} = (prev ${deltaInfo.prevSum}) - ${deltaInfo.outVal} + ${deltaInfo.inVal}`;\n        } else {\n          currentDeltaEl.textContent = '';\n        }\n        updateOverlayVisual();\n        // announce for screen readers\n        ariaAnnounce.textContent = `Window at ${index}. current sum ${currentSum}. best ${bestSum} at ${bestStart}`;\n      }\n\n      // Step forward: perform sliding update at index -> index+1\n      function stepForward(animate=true) {\n        if (nums.length === 0 || k <= 0 || index >= nums.length - k) {\n          // reached end\n          playing = false;\n          updatePlayButton();\n          return;\n        }\n        const outIndex = index;\n        const inIndex = index + k;\n        const outVal = nums[outIndex];\n        const inVal = nums[inIndex];\n        const prev = currentSum;\n        currentSum = currentSum - outVal + inVal;\n        index++;\n        // check best\n        if (currentSum > bestSum) {\n          bestSum = currentSum;\n          bestStart = index;\n        }\n        updateUI({ outIndex, inIndex, outVal, inVal, prevSum: prev });\n      }\n\n      // Step back: reverse update (index -> index-1)\n      function stepBack(animate=true) {\n        if (nums.length === 0 || k <= 0 || index <= 0) return;\n        // reverse the forward operation\n        const inIndex = index - 1;\n        const outIndex = index + k - 1;\n        const inVal = nums[inIndex];\n        const outVal = nums[outIndex];\n        const prev = currentSum;\n        currentSum = currentSum - outVal + inVal; // reverse: subtract outgoing (rightmost), add incoming (new left)\n        index--;\n        // if best was at a later start, we keep best as is (we don't retroactively undo best)\n        updateUI({ outIndex, inIndex, outVal, inVal, prevSum: prev });\n      }\n\n      function resetToBase() {\n        nums = baseNums.slice();\n        k = Math.min(k, nums.length || 1);\n        kRange.value = k;\n        kNumber.value = k;\n        index = 0;\n        renderBars();\n        computeInitialSums();\n      }\n\n      function randomizeArray() {\n        const len = Math.max(3, Math.min(18, Math.round(3 + Math.random() * 12)));\n        nums = new Array(len).fill(0).map(() => Math.round((Math.random()*20)-10)); // -10..10\n        baseNums = nums.slice();\n        k = Math.min(k, nums.length);\n        k = Math.max(1, Math.min(k, nums.length));\n        kRange.max = nums.length;\n        kNumber.max = nums.length;\n        kRange.value = k;\n        kNumber.value = k;\n        renderBars();\n        computeInitialSums();\n      }\n\n      // Playback management\n      function play() {\n        if (playing) return;\n        playing = true;\n        updatePlayButton();\n        const ms = Number(speedRange.value) || 700;\n        timer = setInterval(() => {\n          if (index >= nums.length - k) {\n            stop();\n            return;\n          }\n          stepForward();\n        }, ms);\n      }\n      function stop() {\n        playing = false;\n        updatePlayButton();\n        if (timer) { clearInterval(timer); timer = null; }\n      }\n      function togglePlay() {\n        if (playing) stop(); else play();\n      }\n      function updatePlayButton() {\n        btnPlay.textContent = playing ? 'Pause' : 'Play';\n      }\n\n      // UI events\n      arrayInput.addEventListener('change', () => {\n        const parsed = parseInputArray(arrayInput.value);\n        if (parsed.length === 0) {\n          alert('Please enter at least one integer.');\n          return;\n        }\n        nums = parsed;\n        baseNums = nums.slice();\n        k = Math.min(k, nums.length);\n        kRange.max = nums.length;\n        kNumber.max = nums.length;\n        kRange.value = k;\n        kNumber.value = k;\n        index = 0;\n        renderBars();\n        computeInitialSums();\n      });\n\n      arrayInput.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n          arrayInput.dispatchEvent(new Event('change'));\n        }\n      });\n\n      kRange.addEventListener('input', () => {\n        k = Number(kRange.value);\n        kNumber.value = k;\n        index = 0;\n        renderBars();\n        computeInitialSums();\n      });\n\n      kNumber.addEventListener('change', () => {\n        let v = Number(kNumber.value);\n        if (!Number.isFinite(v) || v < 1) v = 1;\n        v = Math.round(v);\n        v = Math.min(v, nums.length || v);\n        k = v;\n        kRange.value = k;\n        kNumber.value = k;\n        index = 0;\n        renderBars();\n        computeInitialSums();\n      });\n\n      btnRandom.addEventListener('click', () => {\n        randomizeArray();\n      });\n      btnReset.addEventListener('click', () => {\n        // restore baseNums if changed; reset to initial seed\n        nums = baseNums.slice();\n        index = 0;\n        k = Math.min(k, nums.length || 1);\n        kRange.value = k;\n        kNumber.value = k;\n        renderBars();\n        computeInitialSums();\n      });\n\n      btnBack.addEventListener('click', () => {\n        stop();\n        stepBack();\n      });\n\n      btnForward.addEventListener('click', () => {\n        stop();\n        stepForward();\n      });\n\n      btnPlay.addEventListener('click', () => {\n        togglePlay();\n      });\n\n      speedRange.addEventListener('input', () => {\n        speedLabel.textContent = `${speedRange.value} ms`;\n        // adjust overlay transition duration immediately\n        updateOverlayVisual();\n        // if playing, restart timer with new speed\n        if (playing) {\n          stop();\n          play();\n        }\n      });\n\n      // Keyboard shortcuts\n      window.addEventListener('keydown', (e) => {\n        if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) {\n          // allow typing in inputs\n          return;\n        }\n        if (e.code === 'Space') { e.preventDefault(); togglePlay(); }\n        else if (e.code === 'ArrowRight') { e.preventDefault(); stop(); stepForward(); }\n        else if (e.code === 'ArrowLeft') { e.preventDefault(); stop(); stepBack(); }\n      });\n\n      // Resize observer to adapt overlay width when bar widths change (responsive)\n      new ResizeObserver(() => {\n        updateOverlayVisual();\n      }).observe(barsEl);\n\n      // Initial render\n      function init() {\n        // parse initial array input\n        const p = parseInputArray(arrayInput.value);\n        if (p.length) {\n          nums = p;\n          baseNums = p.slice();\n        }\n        k = Math.min(Number(kRange.value) || 1, nums.length);\n        kRange.max = Math.max(1, nums.length);\n        kNumber.max = Math.max(1, nums.length);\n        kRange.value = k;\n        kNumber.value = k;\n        renderBars();\n        computeInitialSums();\n        updatePlayButton();\n      }\n\n      init();\n\n      // expose some debug (not necessary)\n      window._slidingWindow = {\n        get nums(){ return nums; },\n        get k(){ return k; },\n        get index(){ return index; },\n        stepForward, stepBack, play, stop\n      };\n    })();\n  </script>\n</body>\n</html>\n```\n\nNotes on pedagogy and design decisions:\n- The module focuses on one clear concept (fixed-size sliding window for maximum sum) to avoid cognitive overload.\n- Incremental delta animations (outgoing/incoming) make the core operation explicit and memorable.\n- Keyboard shortcuts and ARIA live region improve accessibility and make the demo usable without a mouse.\n- The layout enforces the safe-area 24px and 16px minimum spacing between interactive elements; responsive rules ensure usability on narrow screens.\n\nYou can modify the array and window size to explore corner cases (negative numbers, zeros, short arrays) and watch how the algorithm updates the running and best sums in constant time per step."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Sliding Window.\n\n**Project Overview:**\nTopic: Sliding Window\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Sliding Window"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "587ea4a0-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:51:08.906Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Two Pointers",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Two Pointers — Interactive Module</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --accent: #06b6d4;\n      --muted: #98a2b3;\n      --success: #16a34a;\n      --danger: #ef4444;\n      --glass: rgba(255,255,255,0.03);\n      --radius: 10px;\n      --font-sans: ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n\n    html,body{\n      height: 100%;\n      margin: 0;\n      background: linear-gradient(180deg,#071025 0%, #081526 100%);\n      font-family: var(--font-sans);\n      color: #e6eef8;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n\n    /* Safe area margins */\n    .app {\n      box-sizing: border-box;\n      padding: var(--safe-margin);\n      min-height: 100%;\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n    }\n\n    header {\n      display: flex;\n      align-items: center;\n      justify-content: space-between;\n      gap: var(--gap);\n      flex-wrap: wrap;\n    }\n\n    .title {\n      display: flex;\n      flex-direction: column;\n      gap: 6px;\n    }\n    h1 {\n      margin: 0;\n      font-size: 20px;\n      letter-spacing: -0.2px;\n    }\n    .subtitle {\n      color: var(--muted);\n      font-size: 13px;\n      margin: 0;\n    }\n\n    /* Main layout */\n    .main {\n      display: grid;\n      grid-template-columns: 360px 1fr;\n      gap: var(--gap);\n      align-items: start;\n    }\n\n    @media (max-width: 900px){\n      .main {\n        grid-template-columns: 1fr;\n      }\n    }\n\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n      border-radius: var(--radius);\n      padding: 16px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n      min-width: 0;\n    }\n\n    /* Controls column */\n    .controls {\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n    }\n\n    label { font-size: 13px; color: var(--muted); }\n    input[type=\"text\"], input[type=\"number\"]{\n      width: 100%;\n      padding: 10px 12px;\n      margin-top: 8px;\n      border-radius: 8px;\n      border: 1px solid rgba(255,255,255,0.04);\n      background: rgba(255,255,255,0.02);\n      color: inherit;\n      font-size: 14px;\n      outline: none;\n    }\n    input[type=\"text\"]::placeholder { color: rgba(255,255,255,0.25); }\n\n    .row {\n      display: flex;\n      gap: 12px;\n      align-items: center;\n      flex-wrap: wrap;\n    }\n\n    .buttons {\n      display: flex;\n      gap: 12px;\n      flex-wrap: wrap;\n    }\n\n    button {\n      padding: 10px 12px;\n      border-radius: 8px;\n      border: none;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      color: #e6eef8;\n      cursor: pointer;\n      font-weight: 600;\n      font-size: 13px;\n      min-height: 40px;\n      box-shadow: 0 4px 10px rgba(0,0,0,0.35);\n    }\n    button.primary {\n      background: linear-gradient(180deg, rgba(6,182,212,0.18), rgba(6,182,212,0.08));\n      color: #063740;\n      border: 1px solid rgba(6,182,212,0.14);\n      min-width: 120px;\n    }\n    button.ghost {\n      background: transparent;\n      border: 1px solid rgba(255,255,255,0.04);\n      color: var(--muted);\n    }\n    button:disabled {\n      opacity: 0.45;\n      cursor: not-allowed;\n    }\n\n    .small {\n      font-size: 13px;\n      padding: 8px 10px;\n      min-height: 36px;\n    }\n\n    .checkbox {\n      display: inline-flex;\n      gap: 8px;\n      align-items: center;\n      cursor: pointer;\n      user-select: none;\n    }\n\n    .examples { display:flex; gap:8px; flex-wrap:wrap; }\n    .chip {\n      padding: 8px 10px;\n      border-radius: 999px;\n      background: rgba(255,255,255,0.03);\n      border: 1px solid rgba(255,255,255,0.02);\n      cursor: pointer;\n      font-size: 13px;\n    }\n\n    /* Visualization column */\n    .viz {\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n    }\n\n    .canvas {\n      position: relative;\n      min-height: 220px;\n      padding: 20px;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      background: linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.01));\n      border-radius: var(--radius);\n      overflow: hidden;\n    }\n\n    .array-row {\n      width: 100%;\n      display: flex;\n      gap: 12px;\n      justify-content: center;\n      align-items: flex-end;\n      padding-bottom: 48px; /* space for pointer arrows */\n      position: relative;\n    }\n\n    .cell {\n      min-width: 56px;\n      width: 56px;\n      height: 56px;\n      border-radius: 10px;\n      background: var(--glass);\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      font-weight: 700;\n      color: #dbeafe;\n      font-size: 16px;\n      position: relative;\n      transition: transform 300ms ease, background 200ms ease, box-shadow 200ms;\n      user-select: none;\n    }\n\n    .cell.highlight {\n      background: linear-gradient(180deg, rgba(6,182,212,0.12), rgba(6,182,212,0.06));\n      box-shadow: 0 10px 30px rgba(6,182,212,0.06);\n      transform: translateY(-6px) scale(1.03);\n    }\n\n    .cell.match {\n      background: linear-gradient(180deg, rgba(22,163,74,0.12), rgba(22,163,74,0.06));\n      box-shadow: 0 10px 30px rgba(22,163,74,0.06);\n      transform: translateY(-8px) scale(1.05);\n    }\n\n    /* Pointer handles */\n    .pointer {\n      position: absolute;\n      top: 8px;\n      transform: translateX(-50%);\n      display:flex;\n      flex-direction: column;\n      align-items: center;\n      gap: 6px;\n      cursor: grab;\n      user-select: none;\n      touch-action: none;\n    }\n    .pointer:active { cursor: grabbing; }\n\n    .arrow {\n      width: 0;\n      height: 0;\n      border-left: 10px solid transparent;\n      border-right: 10px solid transparent;\n      border-bottom: 14px solid var(--accent);\n      filter: drop-shadow(0 6px 10px rgba(6,182,212,0.06));\n      transition: transform 160ms ease;\n    }\n\n    .label {\n      background: rgba(255,255,255,0.02);\n      color: var(--muted);\n      border-radius: 6px;\n      padding: 6px 8px;\n      font-size: 12px;\n      border: 1px solid rgba(255,255,255,0.02);\n    }\n\n    .pointer.right .arrow {\n      transform: rotate(180deg);\n      border-bottom-color: var(--accent);\n    }\n\n    /* Info & log */\n    .info {\n      display: flex;\n      gap: var(--gap);\n      align-items: center;\n      flex-wrap: wrap;\n    }\n    .status {\n      padding: 10px 12px;\n      border-radius: 8px;\n      background: rgba(255,255,255,0.02);\n      color: var(--muted);\n      font-size: 13px;\n      min-width: 120px;\n    }\n    .log {\n      flex: 1;\n      padding: 10px;\n      border-radius: 8px;\n      background: rgba(255,255,255,0.02);\n      font-size: 13px;\n      color: var(--muted);\n      max-height: 88px;\n      overflow:auto;\n    }\n    .log p { margin: 0 0 6px 0; font-size: 13px; }\n    .legend { display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px; }\n\n    /* Footer: algorithm explanation + layout description */\n    .meta {\n      display: grid;\n      grid-template-columns: 1fr 1fr;\n      gap: var(--gap);\n    }\n    @media (max-width:900px){ .meta { grid-template-columns: 1fr; } }\n\n    .card-title { font-weight:700; margin-bottom:8px; }\n    .card p { color:var(--muted); margin:0; line-height:1.45; font-size:13px; }\n\n    /* accessibility focus */\n    button:focus, .chip:focus {\n      outline: 2px solid rgba(6,182,212,0.18);\n      outline-offset: 2px;\n      border-radius: 8px;\n    }\n\n    /* spacing helpers */\n    .spacer { height: var(--gap); }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Two Pointers interactive module\">\n    <header>\n      <div class=\"title\">\n        <h1>Two Pointers — Pair Sum on Sorted Array</h1>\n        <p class=\"subtitle\">Interactive visualization: find two numbers that add up to a target using the two-pointer technique.</p>\n      </div>\n      <div style=\"display:flex;gap:12px;align-items:center;\">\n        <div style=\"color:var(--muted);font-size:13px;\">Safe margins: 24px · Min gap: 16px</div>\n        <button class=\"ghost\" id=\"helpToggle\" aria-expanded=\"false\">Show Design Plan</button>\n      </div>\n    </header>\n\n    <div class=\"main\">\n      <!-- Controls column -->\n      <section class=\"panel controls\" aria-labelledby=\"controlsHeading\">\n        <h2 id=\"controlsHeading\" style=\"margin:0 0 8px 0;font-size:15px;\">Controls</h2>\n\n        <div>\n          <label for=\"arrayInput\">Array (comma-separated)</label>\n          <input id=\"arrayInput\" type=\"text\" placeholder=\"e.g. 1,2,3,4,6\" value=\"1,2,3,4,6\" />\n        </div>\n\n        <div>\n          <label for=\"targetInput\">Target Sum</label>\n          <input id=\"targetInput\" type=\"number\" value=\"7\" />\n        </div>\n\n        <div class=\"row\">\n          <label class=\"checkbox\" title=\"Sort the input array before running\">\n            <input type=\"checkbox\" id=\"sortToggle\" checked />\n            <span style=\"color:var(--muted);font-size:13px;\">Sort input automatically</span>\n          </label>\n          <label style=\"margin-left:8px;color:var(--muted);font-size:13px;\">Animation speed</label>\n          <input id=\"speed\" type=\"range\" min=\"200\" max=\"1600\" value=\"800\" style=\"width:100%;\" aria-label=\"Animation speed\" />\n        </div>\n\n        <div class=\"buttons\">\n          <button id=\"applyBtn\" class=\"primary\">Apply</button>\n          <button id=\"resetBtn\" class=\"small\">Reset</button>\n        </div>\n\n        <div style=\"display:flex;gap:12px;align-items:center;margin-top:4px;\">\n          <button id=\"stepBack\" class=\"small\" title=\"Step backward\">◀ Step</button>\n          <button id=\"playPause\" class=\"small\" title=\"Play/Pause\">Play ▶</button>\n          <button id=\"stepForward\" class=\"small\" title=\"Step forward\">Step ▶</button>\n        </div>\n\n        <div style=\"margin-top:8px;\">\n          <div style=\"font-size:13px;color:var(--muted);margin-bottom:8px;\">Examples</div>\n          <div class=\"examples\" role=\"list\">\n            <button class=\"chip\" data-arr=\"1,2,3,4,6\" data-target=\"7\">[1,2,3,4,6] t=7</button>\n            <button class=\"chip\" data-arr=\"2,3,4,7,11\" data-target=\"9\">[2,3,4,7,11] t=9</button>\n            <button class=\"chip\" data-arr=\"-3,-1,0,2,4,5\" data-target=\"1\">[-3,-1,0,2,4,5] t=1</button>\n            <button class=\"chip\" data-arr=\"1,2,3,4,5,6,7,8\" data-target=\"15\">1..8 t=15</button>\n          </div>\n        </div>\n\n        <div class=\"spacer\"></div>\n\n        <div>\n          <div class=\"card-title\">Concept Title</div>\n          <div class=\"card\">\n            <p>Two Pointers: Efficiently find a pair in a sorted array whose values sum to a target by moving one pointer from each end toward the center.</p>\n          </div>\n        </div>\n\n        <div style=\"margin-top:10px;\">\n          <div class=\"card-title\">Learning Objective</div>\n          <div class=\"card\">\n            <p>After interacting with this module you will understand how two pointers (left & right) progressively narrow the search space on a sorted array, how comparisons guide pointer movement, and why this is O(n).</p>\n          </div>\n        </div>\n      </section>\n\n      <!-- Visualization column -->\n      <section class=\"panel viz\" aria-labelledby=\"vizHeading\">\n        <h2 id=\"vizHeading\" style=\"margin:0 0 6px 0;font-size:15px;\">Visualization</h2>\n\n        <div class=\"canvas\" id=\"canvas\" aria-live=\"polite\">\n          <div class=\"array-row\" id=\"arrayRow\" role=\"list\" aria-label=\"Array elements\">\n            <!-- Cells are inserted here -->\n          </div>\n\n          <!-- Left pointer -->\n          <div class=\"pointer left\" id=\"ptrLeft\" data-side=\"left\" role=\"slider\" tabindex=\"0\" aria-label=\"Left pointer\" aria-valuemin=\"0\" aria-valuemax=\"0\" aria-valuenow=\"0\" style=\"left:var(--leftPos,0px);\">\n            <div class=\"arrow\" style=\"border-bottom-color: var(--accent);\"></div>\n            <div class=\"label\">L</div>\n          </div>\n\n          <!-- Right pointer -->\n          <div class=\"pointer right\" id=\"ptrRight\" data-side=\"right\" role=\"slider\" tabindex=\"0\" aria-label=\"Right pointer\" aria-valuemin=\"0\" aria-valuemax=\"0\" aria-valuenow=\"0\" style=\"left:var(--rightPos,0px);\">\n            <div class=\"arrow\" style=\"border-bottom-color: var(--accent); transform: rotate(180deg);\"></div>\n            <div class=\"label\">R</div>\n          </div>\n        </div>\n\n        <div class=\"info\">\n          <div class=\"status\" id=\"statusText\">Idle — press Apply</div>\n          <div class=\"log\" id=\"log\" aria-live=\"polite\"></div>\n          <div class=\"legend\">\n            <div style=\"width:12px;height:12px;border-radius:3px;background:linear-gradient(180deg, rgba(6,182,212,0.12), rgba(6,182,212,0.06));\"></div>\n            <div style=\"color:var(--muted);font-size:13px;\">Comparing</div>\n            <div style=\"width:12px;height:12px;border-radius:3px;background:linear-gradient(180deg, rgba(22,163,74,0.12), rgba(22,163,74,0.06));margin-left:10px;\"></div>\n            <div style=\"color:var(--muted);font-size:13px;\">Match</div>\n          </div>\n        </div>\n\n        <div class=\"meta\" style=\"margin-top:12px;\">\n          <div class=\"panel\" style=\"background:transparent;padding:12px;\">\n            <div class=\"card-title\">Interaction Design</div>\n            <div class=\"card\">\n              <p>Users type or pick an example array and target. Press Apply to initialize (array sorted if enabled). Use Play/Pause to run automatically, Step to advance one comparison, or drag pointer handles to experiment manually. Visual highlights and animated pointer moves reveal decisions: sum &lt; target → move left; sum &gt; target → move right; sum = target → success.</p>\n            </div>\n          </div>\n\n          <div class=\"panel\" style=\"background:transparent;padding:12px;\">\n            <div class=\"card-title\">Layout Description</div>\n            <div class=\"card\">\n              <p>The left panel holds controls and learning objectives; the right panel centers the array visualization with pointer handles above. Safe margins are preserved (24px), controls have at least 16px spacing, and the layout is responsive: two-column on wide screens, stacked on narrow screens. Elements are keyboard-focusable for accessibility.</p>\n            </div>\n          </div>\n        </div>\n      </section>\n    </div>\n\n    <!-- Hidden detailed design plan popup -->\n    <div id=\"helpPanel\" style=\"display:none;position:fixed;inset:0;align-items:center;justify-content:center;\">\n      <div style=\"background:rgba(3,7,18,0.9);border-radius:12px;padding:20px;max-width:900px;margin:24px;border:1px solid rgba(6,182,212,0.06);\">\n        <div style=\"display:flex;justify-content:space-between;gap:12px;align-items:start;\">\n          <div>\n            <h3 style=\"margin:0 0 8px 0;\">Design Plan — Two Pointers Module</h3>\n            <p style=\"color:var(--muted);margin-top:0;\">This popup documents the required design plan and how the interactive page teaches the concept.</p>\n          </div>\n          <button id=\"closeHelp\" class=\"small\">Close</button>\n        </div>\n\n        <div style=\"display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:12px;\">\n          <div style=\"background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;\">\n            <strong>Concept Title</strong>\n            <p style=\"color:var(--muted);margin:8px 0 0 0;\">Two Pointers — Pair Sum on Sorted Array</p>\n            <strong style=\"margin-top:10px;display:block;\">Learning Objective</strong>\n            <p style=\"color:var(--muted);margin:8px 0 0 0;\">Understand pointer initialization at array ends, how comparisons affect movement, and why this yields linear time.</p>\n          </div>\n\n          <div style=\"background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;\">\n            <strong>Interaction Design</strong>\n            <p style=\"color:var(--muted);margin:8px 0 0 0;\">\n              - Typing: Input array and target. <br>\n              - Clicking: Apply, Play/Pause, Step controls to progress algorithm. <br>\n              - Dragging: Move left/right pointer handles to explore manual states. <br>\n              - Visual feedback: animated pointer transitions, cell highlighting for comparisons and matches, status log. <br>\n              - Reinforcement: step-by-step guidance plus ability to experiment manually deepens intuition.\n            </p>\n          </div>\n\n          <div style=\"background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;\">\n            <strong>Layout Description</strong>\n            <p style=\"color:var(--muted);margin:8px 0 0 0;\">Top header, left control column (inputs, controls, examples, objectives), right visualization column (array row centered, pointers absolutely positioned above array, status/log beneath). Spacing respects 24px safe margin and 16px minimum between interactive items. Design is responsive and keyboard-friendly.</p>\n          </div>\n\n          <div style=\"background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;\">\n            <strong>Accessibility & Responsiveness</strong>\n            <p style=\"color:var(--muted);margin:8px 0 0 0;\">Controls are keyboard-focusable, aria-live regions notify status changes, and pointer handles are accessible. The layout collapses to single column on small devices, preserving spacing and touch targets.</p>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Two Pointers Interactive Module\n    (function(){\n      // Elements\n      const arrayInput = document.getElementById('arrayInput');\n      const targetInput = document.getElementById('targetInput');\n      const sortToggle = document.getElementById('sortToggle');\n      const applyBtn = document.getElementById('applyBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const stepForwardBtn = document.getElementById('stepForward');\n      const stepBackBtn = document.getElementById('stepBack');\n      const playPauseBtn = document.getElementById('playPause');\n      const arrayRow = document.getElementById('arrayRow');\n      const ptrLeft = document.getElementById('ptrLeft');\n      const ptrRight = document.getElementById('ptrRight');\n      const statusText = document.getElementById('statusText');\n      const logEl = document.getElementById('log');\n      const speedInput = document.getElementById('speed');\n      const examples = document.querySelectorAll('.chip');\n      const helpToggle = document.getElementById('helpToggle');\n      const helpPanel = document.getElementById('helpPanel');\n      const closeHelp = document.getElementById('closeHelp');\n\n      // State\n      let arr = [];\n      let n = 0;\n      let target = 0;\n      let l = 0;\n      let r = 0;\n      let history = []; // stores states for stepping back\n      let autoPlay = false;\n      let autoTimer = null;\n      let speed = Number(speedInput.value);\n      let cells = [];\n      let dragging = null; // 'left' or 'right' or null\n      let boxCenters = []; // px centers of cells relative to arrayRow\n      let isSorted = true;\n      let found = false;\n\n      // Utility helpers\n      function log(msg){\n        const p = document.createElement('p');\n        p.textContent = msg;\n        logEl.prepend(p);\n      }\n      function setStatus(msg, type){\n        statusText.textContent = msg;\n        // color hints could be added\n      }\n\n      function parseArrayInput(txt){\n        // parse numbers, ignore empty entries\n        return txt.split(',').map(s => s.trim()).filter(s => s!=='').map(Number).filter(n => !Number.isNaN(n));\n      }\n\n      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }\n\n      // Render array cells\n      function renderArray(){\n        arrayRow.innerHTML = '';\n        cells = [];\n        boxCenters = [];\n        for (let i=0;i<n;i++){\n          const cell = document.createElement('div');\n          cell.className = 'cell';\n          cell.setAttribute('data-index', i);\n          cell.setAttribute('role','listitem');\n          cell.textContent = String(arr[i]);\n          arrayRow.appendChild(cell);\n          cells.push(cell);\n        }\n        // After DOM inserted, compute centers\n        requestAnimationFrame(() => {\n          boxCenters = cells.map(c => {\n            const rect = c.getBoundingClientRect();\n            const parentRect = arrayRow.getBoundingClientRect();\n            return rect.left + rect.width/2 - parentRect.left;\n          });\n          // Initialize pointer positions visually\n          updatePointerPosition('left', l, true);\n          updatePointerPosition('right', r, true);\n          ptrLeft.setAttribute('aria-valuemin', 0);\n          ptrLeft.setAttribute('aria-valuemax', Math.max(0,n-1));\n          ptrRight.setAttribute('aria-valuemin', 0);\n          ptrRight.setAttribute('aria-valuemax', Math.max(0,n-1));\n          ptrLeft.setAttribute('aria-valuenow', l);\n          ptrRight.setAttribute('aria-valuenow', r);\n        });\n      }\n\n      function updatePointerPosition(side, index, instant){\n        if (!boxCenters.length) return;\n        index = clamp(index, 0, Math.max(0,n-1));\n        const leftPx = boxCenters[index] + arrayRow.getBoundingClientRect().left - arrayRow.getBoundingClientRect().left;\n        // position relative to arrayRow left, but using percent left style\n        const offset = boxCenters[index] + 'px';\n        const el = side==='left' ? ptrLeft : ptrRight;\n        if (instant){\n          el.style.transition = 'none';\n        } else {\n          el.style.transition = 'left 300ms ease';\n        }\n        el.style.left = offset;\n        el.setAttribute('aria-valuenow', index);\n        // clear inline transition after frame\n        if (instant){\n          requestAnimationFrame(()=> el.style.transition = '');\n        }\n      }\n\n      // Visual state update (highlight cells, etc.)\n      function highlightCompare(i,j, action){\n        // action: \"compare\" | \"moveL\" | \"moveR\" | \"match\"\n        cells.forEach(c => c.classList.remove('highlight','match'));\n        if (i>=0 && i<n) cells[i].classList.add(action==='match' ? 'match' : 'highlight');\n        if (j>=0 && j<n) cells[j].classList.add(action==='match' ? 'match' : 'highlight');\n      }\n\n      // Initialize algorithm with current inputs\n      function applySettings(){\n        const parsed = parseArrayInput(arrayInput.value);\n        if (parsed.length === 0){\n          setStatus('Enter at least one number', 'warn');\n          return;\n        }\n        isSorted = !!sortToggle.checked;\n        arr = parsed.slice();\n        if (isSorted){\n          arr.sort((a,b)=>a-b);\n        }\n        n = arr.length;\n        target = Number(targetInput.value);\n        if (Number.isNaN(target)){\n          setStatus('Invalid target', 'warn');\n          return;\n        }\n        // init pointers\n        l = 0;\n        r = Math.max(0, n-1);\n        history = [];\n        found = false;\n        setStatus('Initialized. Step or Play to run.');\n        log(`Applied array (${isSorted? 'sorted':'as-is'}): [${arr.join(', ')}], target=${target}`);\n        renderArray();\n        refreshControls();\n        clearHighlights();\n      }\n\n      function clearHighlights(){\n        cells.forEach(c => c.classList.remove('highlight','match'));\n      }\n\n      // Perform one algorithm step forward\n      function stepForward(){\n        if (found || l >= r){\n          setStatus('No more pairs to check');\n          return false;\n        }\n        const sum = arr[l] + arr[r];\n        history.push({l, r, sum});\n        highlightCompare(l, r, 'compare');\n        setStatus(`Comparing arr[${l}]=${arr[l]} + arr[${r}]=${arr[r]} -> ${sum}`);\n        log(`Compare: ${arr[l]} + ${arr[r]} = ${sum}`);\n        if (sum === target){\n          highlightCompare(l, r, 'match');\n          setStatus(`Found! arr[${l}] + arr[${r}] = ${target}`);\n          log(`Match found at indices ${l} and ${r} -> values ${arr[l]}, ${arr[r]}`);\n          found = true;\n          refreshControls();\n          return false;\n        } else if (sum < target){\n          // move left pointer right\n          l = l + 1;\n          animatePointers();\n          setTimeout(()=> {\n            highlightCompare(Math.max(0,l-1), r, 'moveL');\n          }, 120);\n        } else { // sum > target\n          r = r - 1;\n          animatePointers();\n          setTimeout(()=> {\n            highlightCompare(l, Math.min(n-1,r+1), 'moveR');\n          }, 120);\n        }\n        refreshControls();\n        return true;\n      }\n\n      // Step backward (revert last step)\n      function stepBackward(){\n        if (history.length === 0){\n          setStatus('At initial state');\n          return;\n        }\n        const prev = history.pop();\n        // revert to prev.l, prev.r\n        l = prev.l;\n        r = prev.r;\n        found = false;\n        animatePointers();\n        setStatus('Stepped back');\n        log('Stepped back');\n        clearHighlights();\n        refreshControls();\n      }\n\n      // Animate pointer positions\n      function animatePointers(){\n        updatePointerPosition('left', l, false);\n        updatePointerPosition('right', r, false);\n        // update aria\n        ptrLeft.setAttribute('aria-valuenow', l);\n        ptrRight.setAttribute('aria-valuenow', r);\n      }\n\n      // Play/pause logic\n      function togglePlay(){\n        if (autoPlay){\n          stopAuto();\n        } else {\n          startAuto();\n        }\n      }\n\n      function startAuto(){\n        if (found || l >= r){ setStatus('Nothing to play'); return; }\n        autoPlay = true;\n        playPauseBtn.textContent = 'Pause ⏸';\n        speed = Number(speedInput.value);\n        autoTimer = setInterval(()=> {\n          const continuePlay = stepForward();\n          if (!continuePlay || found || l >= r){\n            stopAuto();\n          }\n        }, speed);\n      }\n\n      function stopAuto(){\n        autoPlay = false;\n        playPauseBtn.textContent = 'Play ▶';\n        if (autoTimer) { clearInterval(autoTimer); autoTimer = null; }\n      }\n\n      function reset(){\n        stopAuto();\n        history = [];\n        const parsed = parseArrayInput(arrayInput.value);\n        if (parsed.length === 0) return;\n        arr = parsed.slice();\n        if (isSorted) arr.sort((a,b)=>a-b);\n        n = arr.length;\n        l = 0; r = Math.max(0,n-1);\n        found = false;\n        renderArray();\n        setStatus('Reset to initial state');\n        log('Reset');\n        clearHighlights();\n        refreshControls();\n      }\n\n      function refreshControls(){\n        stepBackBtn.disabled = history.length === 0;\n        stepForwardBtn.disabled = found || l >= r;\n        playPauseBtn.disabled = found || l >= r;\n      }\n\n      // Dragging pointers\n      function initPointerDrag(){\n        let active = null;\n        let startX = 0;\n        let el = null;\n\n        function getClosestIndex(clientX){\n          if (!boxCenters.length) return 0;\n          const parentRect = arrayRow.getBoundingClientRect();\n          // find x relative to arrayRow\n          const x = clientX - parentRect.left;\n          // find closest center\n          let bestIdx = 0;\n          let bestDist = Infinity;\n          for (let i=0;i<boxCenters.length;i++){\n            const d = Math.abs(boxCenters[i] - x);\n            if (d < bestDist){\n              bestDist = d;\n              bestIdx = i;\n            }\n          }\n          return bestIdx;\n        }\n\n        function onPointerDown(e){\n          if (autoPlay) return; // disable manual drag during autoplay\n          const side = this.dataset.side;\n          active = side;\n          el = this;\n          startX = (e.touches ? e.touches[0].clientX : e.clientX);\n          dragging = side;\n          el.classList.add('dragging');\n          document.addEventListener('pointermove', onPointerMove);\n          document.addEventListener('pointerup', onPointerUp);\n          document.addEventListener('touchmove', onPointerMove, {passive:false});\n          document.addEventListener('touchend', onPointerUp);\n        }\n\n        function onPointerMove(e){\n          if (!active) return;\n          e.preventDefault();\n          const clientX = (e.touches ? e.touches[0].clientX : e.clientX);\n          const idx = getClosestIndex(clientX);\n          if (active === 'left'){\n            // prevent crossing\n            const safeIdx = Math.min(idx, r-1);\n            if (safeIdx !== l){\n              l = safeIdx;\n              updatePointerPosition('left', l, true);\n              setStatus(`Moved left pointer to index ${l}`);\n              highlightCompare(l, r, 'compare');\n            }\n          } else {\n            const safeIdx = Math.max(idx, l+1);\n            if (safeIdx !== r){\n              r = safeIdx;\n              updatePointerPosition('right', r, true);\n              setStatus(`Moved right pointer to index ${r}`);\n              highlightCompare(l, r, 'compare');\n            }\n          }\n        }\n\n        function onPointerUp(e){\n          if (!active) return;\n          dragging = null;\n          active = null;\n          el.classList.remove('dragging');\n          document.removeEventListener('pointermove', onPointerMove);\n          document.removeEventListener('pointerup', onPointerUp);\n          document.removeEventListener('touchmove', onPointerMove);\n          document.removeEventListener('touchend', onPointerUp);\n          // When user releases, evaluate current pair but do not push to history automatically\n          const sum = arr[l] + arr[r];\n          setStatus(`Manual: arr[${l}] + arr[${r}] = ${sum}`);\n          log(`Manual move: indices ${l},${r} -> sum ${sum}`);\n          highlightCompare(l, r, sum===target ? 'match':'compare');\n          ptrLeft.setAttribute('aria-valuenow', l);\n          ptrRight.setAttribute('aria-valuenow', r);\n        }\n\n        ptrLeft.addEventListener('pointerdown', onPointerDown);\n        ptrRight.addEventListener('pointerdown', onPointerDown);\n        // keyboard support for pointer handles\n        function onKeyAdjust(e){\n          const side = this.dataset.side;\n          if (e.key === 'ArrowLeft' || e.key === 'ArrowRight'){\n            const dir = e.key === 'ArrowLeft' ? -1 : 1;\n            if (side === 'left'){\n              l = clamp(l + dir, 0, Math.max(0, r-1));\n              updatePointerPosition('left', l, false);\n            } else {\n              r = clamp(r + dir, Math.min(n-1, l+1), n-1);\n              updatePointerPosition('right', r, false);\n            }\n            highlightCompare(l, r, 'compare');\n            ptrLeft.setAttribute('aria-valuenow', l);\n            ptrRight.setAttribute('aria-valuenow', r);\n            e.preventDefault();\n          }\n          if (e.key === 'Enter'){\n            // evaluate manual pair\n            const sum = arr[l] + arr[r];\n            setStatus(`Manual: arr[${l}] + arr[${r}] = ${sum}`);\n            highlightCompare(l, r, sum===target ? 'match':'compare');\n            log(`Manual key move: indices ${l},${r} -> sum ${sum}`);\n          }\n        }\n        ptrLeft.addEventListener('keydown', onKeyAdjust);\n        ptrRight.addEventListener('keydown', onKeyAdjust);\n      }\n\n      // Hook up controls\n      applyBtn.addEventListener('click', e => {\n        applySettings();\n      });\n\n      resetBtn.addEventListener('click', e => {\n        reset();\n      });\n\n      stepForwardBtn.addEventListener('click', e => {\n        stopAuto();\n        stepForward();\n      });\n\n      stepBackBtn.addEventListener('click', e => {\n        stopAuto();\n        stepBackward();\n      });\n\n      playPauseBtn.addEventListener('click', e => {\n        togglePlay();\n      });\n\n      speedInput.addEventListener('input', e => {\n        speed = Number(speedInput.value);\n        if (autoPlay){\n          stopAuto();\n          startAuto();\n        }\n      });\n\n      examples.forEach(btn => {\n        btn.addEventListener('click', e => {\n          arrayInput.value = btn.dataset.arr;\n          targetInput.value = btn.dataset.target;\n          applySettings();\n        });\n      });\n\n      // Help toggle\n      helpToggle.addEventListener('click', () => {\n        const expanded = helpToggle.getAttribute('aria-expanded') === 'true';\n        helpToggle.setAttribute('aria-expanded', String(!expanded));\n        helpPanel.style.display = expanded ? 'none' : 'flex';\n      });\n      closeHelp.addEventListener('click', () => {\n        helpPanel.style.display = 'none';\n        helpToggle.setAttribute('aria-expanded', 'false');\n      });\n\n      // Keyboard shortcuts\n      document.addEventListener('keydown', e => {\n        if (e.key === ' ' && document.activeElement.tagName.toLowerCase() !== 'input'){\n          // space toggles play\n          e.preventDefault();\n          togglePlay();\n        } else if (e.key === 'ArrowRight' && (e.ctrlKey || e.metaKey)){\n          // Ctrl+Right step forward\n          stepForward();\n        } else if (e.key === 'ArrowLeft' && (e.ctrlKey || e.metaKey)){\n          stepBackward();\n        }\n      });\n\n      // Initial setup\n      function init(){\n        applySettings();\n        initPointerDrag();\n        refreshControls();\n      }\n\n      init();\n\n      // Expose to window for debugging (optional)\n      window._twoPointers = {\n        get state(){ return {arr,l,r,target,history,found}; }\n      };\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Two Pointers.\n\n**Project Overview:**\nTopic: Two Pointers\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Two Pointers"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "60e2c680-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:51:22.984Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Linear Regression",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Linear Regression Module</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --card: #071024;\n      --accent: #00b4d8;\n      --muted: #94a3b8;\n      --good: #22c55e;\n      --danger: #ef4444;\n      --glass: rgba(255,255,255,0.035);\n      --transition: 260ms cubic-bezier(.2,.9,.3,1);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      color-scheme: dark;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#020617 0%, #071028 60%);\n      color: #e6eef8;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .app{\n      box-sizing:border-box;\n      padding:var(--safe-margin);\n      min-height:100vh;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    /* Header / meta info */\n    .meta {\n      display:flex;\n      justify-content:space-between;\n      gap:var(--gap);\n      align-items:flex-start;\n      flex-wrap:wrap;\n    }\n    .title {\n      min-width:0;\n    }\n    .title h1 {\n      margin:0 0 6px 0;\n      font-size:20px;\n      line-height:1.1;\n      letter-spacing: -0.2px;\n    }\n    .title p {\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .objectives {\n      background:var(--glass);\n      border-radius:10px;\n      padding:12px;\n      min-width:260px;\n      max-width:420px;\n      font-size:13px;\n      color:#d8eefd;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .objectives small { color:var(--muted); display:block; margin-bottom:6px; font-weight:600; font-size:11px; text-transform:uppercase; letter-spacing:1px;}\n\n    /* Main layout */\n    .panel {\n      display:grid;\n      grid-template-columns: 360px 1fr;\n      gap:var(--gap);\n      align-items:start;\n    }\n    @media (max-width:920px){\n      .panel { grid-template-columns: 1fr; }\n    }\n\n    /* Controls card */\n    .card {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:16px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .controls h3 {\n      margin:0 0 8px 0;\n      font-size:14px;\n    }\n    .controls p {\n      margin:0 0 12px 0;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .control-row {\n      display:flex;\n      gap:12px;\n      align-items:center;\n      margin-bottom:12px;\n    }\n    .control-row label { font-size:13px; min-width:110px; color:var(--muted); }\n    .control-row input[type=\"range\"] {\n      -webkit-appearance:none;\n      width:100%;\n      height:6px;\n      background:rgba(255,255,255,0.04);\n      border-radius:6px;\n      outline:none;\n    }\n    .control-row input[type=\"range\"]::-webkit-slider-thumb {\n      -webkit-appearance:none;\n      width:14px;\n      height:14px;\n      background:var(--accent);\n      border-radius:50%;\n      box-shadow:0 2px 6px rgba(0,0,0,0.5);\n      border:2px solid rgba(255,255,255,0.06);\n    }\n    .btn-row {\n      display:flex;\n      gap:12px;\n      margin-top:6px;\n      flex-wrap:wrap;\n    }\n    button {\n      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n      color: #e6eef8;\n      border:1px solid rgba(255,255,255,0.04);\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      transition:var(--transition);\n      font-size:13px;\n    }\n    button:hover { transform:translateY(-2px); }\n    button.primary{\n      background: linear-gradient(90deg, var(--accent), #0077b6);\n      border: none;\n    }\n    button.warn { background: linear-gradient(90deg,#ff7b7b,#ff5252); border:none; }\n    .small { font-size:12px; padding:6px 8px; }\n\n    .metric {\n      display:flex;\n      justify-content:space-between;\n      background:rgba(255,255,255,0.02);\n      padding:10px;\n      border-radius:8px;\n      font-size:13px;\n      margin-bottom:8px;\n      border:1px solid rgba(255,255,255,0.015);\n    }\n    .metric b { color:#fff; }\n\n    /* Plot card */\n    .plot-card {\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    .plot {\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:12px;\n      padding:12px;\n      border:1px solid rgba(255,255,255,0.03);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      min-height:380px;\n    }\n    .plot-header {\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:12px;\n    }\n    .plot-header .explain { color:var(--muted); font-size:13px; }\n    .canvas-wrap {\n      width:100%;\n      height:480px;\n      position:relative;\n    }\n    @media (max-width:920px){\n      .canvas-wrap { height:360px; }\n    }\n    svg { width:100%; height:100%; display:block; border-radius:8px; }\n\n    /* Accessibility focus outlines */\n    button:focus, input[type=\"range\"]:focus, .draggable:focus {\n      outline:3px solid rgba(0,180,216,0.16);\n      outline-offset:2px;\n    }\n\n    /* Residuals style */\n    .residual {\n      stroke:rgba(255,255,255,0.25);\n      stroke-width:1.5;\n      stroke-dasharray:3 3;\n    }\n    .regression-line {\n      stroke: #ffd166;\n      stroke-width:2.5;\n      stroke-linecap:round;\n    }\n    .ols-line {\n      stroke: #90ee90;\n      stroke-width:2;\n      stroke-dasharray:6 4;\n    }\n    .point {\n      fill: #00b4d8;\n      stroke: rgba(0,0,0,0.3);\n      stroke-width:1;\n      cursor:grab;\n    }\n    .point:active { cursor:grabbing; }\n\n    .footer-note {\n      color:var(--muted);\n      font-size:13px;\n    }\n\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"main\">\n    <!-- Header: Title + Learning Objective -->\n    <div class=\"meta\">\n      <div class=\"title\" aria-hidden=\"false\">\n        <h1>Linear Regression — Interactive Exploration</h1>\n        <p>Drag data points, adjust the line, fit with analytic OLS or animate gradient descent to see how the model learns.</p>\n      </div>\n\n      <div class=\"objectives\" role=\"region\" aria-label=\"Learning objective\">\n        <small>Learning Objective</small>\n        <div><strong>After interacting with this module you will:</strong></div>\n        <ul style=\"margin:8px 0 0 16px; padding:0; color:var(--muted); font-size:13px;\">\n          <li>Understand slope and intercept and how they shape the best-fit line.</li>\n          <li>See residuals and the sum of squared errors (SSE) change as points or the line change.</li>\n          <li>Observe analytic OLS vs iterative gradient descent convergence.</li>\n        </ul>\n      </div>\n    </div>\n\n    <!-- Main panel: controls + plot -->\n    <div class=\"panel\">\n\n      <!-- Controls column -->\n      <div class=\"card controls\" aria-label=\"Controls\">\n        <h3>Interaction Design</h3>\n        <p>Manipulate data and model. The visual updates show the relationship between parameters and error.</p>\n\n        <div class=\"control-row\" style=\"margin-top:6px;\">\n          <label for=\"mode\">Mode</label>\n          <select id=\"mode\" aria-label=\"Mode selector\" style=\"padding:8px; border-radius:8px; background:transparent; color:inherit;\">\n            <option value=\"manual\">Manual (drag or sliders)</option>\n            <option value=\"auto\">Auto-fit on drag</option>\n          </select>\n        </div>\n\n        <div class=\"control-row\">\n          <label for=\"slope\">Slope (m)</label>\n          <input id=\"slope\" type=\"range\" min=\"-5\" max=\"5\" step=\"0.01\" value=\"1\" />\n          <div style=\"width:64px; text-align:right; font-weight:600;\" id=\"slopeVal\">1.00</div>\n        </div>\n\n        <div class=\"control-row\">\n          <label for=\"intercept\">Intercept (b)</label>\n          <input id=\"intercept\" type=\"range\" min=\"-50\" max=\"50\" step=\"0.1\" value=\"0\" />\n          <div style=\"width:64px; text-align:right; font-weight:600;\" id=\"interceptVal\">0.0</div>\n        </div>\n\n        <div class=\"control-row\">\n          <label for=\"lr\">GD lr</label>\n          <input id=\"lr\" type=\"range\" min=\"0.0005\" max=\"0.1\" step=\"0.0005\" value=\"0.01\" />\n          <div style=\"width:64px; text-align:right; font-weight:600;\" id=\"lrVal\">0.010</div>\n        </div>\n\n        <div style=\"margin-top:6px;\">\n          <div class=\"btn-row\" role=\"group\" aria-label=\"Actions\">\n            <button id=\"fitBtn\" class=\"primary\" title=\"Compute analytic OLS\">Fit (Analytic OLS)</button>\n            <button id=\"gdBtn\" class=\"small\" title=\"Animate gradient descent\">Start GD</button>\n            <button id=\"toggleResiduals\" class=\"small\" title=\"Show or hide residuals\">Toggle Residuals</button>\n            <button id=\"resetData\" class=\"small\" title=\"Randomize dataset\">Reset Data</button>\n            <button id=\"randomOutlier\" class=\"small\" title=\"Add a random outlier\">Add Outlier</button>\n          </div>\n        </div>\n\n        <hr style=\"border:none;border-top:1px solid rgba(255,255,255,0.03); margin:12px 0;\" />\n\n        <div>\n          <div class=\"metric\"><span>Current slope (m)</span><b id=\"mMetric\">1.00</b></div>\n          <div class=\"metric\"><span>Intercept (b)</span><b id=\"bMetric\">0.0</b></div>\n          <div class=\"metric\"><span>Sum of Squared Errors (SSE)</span><b id=\"sseMetric\">0.00</b></div>\n          <div class=\"metric\"><span>R²</span><b id=\"r2\">0.00</b></div>\n        </div>\n\n        <div style=\"margin-top:10px; color:var(--muted); font-size:13px;\">\n          <strong>Interaction Design (text):</strong>\n          <ol style=\"margin:8px 0 0 18px; padding:0;\">\n            <li>Drag points to change data. If Mode=Auto-fit, OLS updates immediately.</li>\n            <li>Adjust slope/intercept sliders to experiment with the model manually.</li>\n            <li>Click Fit to compute analytic OLS (yellow dashed shows iterative GD).</li>\n            <li>Start GD to animate gradient descent; watch SSE decrease and the line converge.</li>\n            <li>Toggle residuals to see vertical errors between points and the line.</li>\n          </ol>\n        </div>\n      </div>\n\n      <!-- Plot and explanations -->\n      <div class=\"plot-card\">\n        <div class=\"plot\">\n          <div class=\"plot-header\">\n            <div>\n              <strong>Plot</strong>\n              <div class=\"explain\">Blue points are data. Yellow line is the current model. Green dashed line indicates analytic OLS fit.</div>\n            </div>\n            <div style=\"display:flex; gap:12px; align-items:center;\">\n              <div class=\"footer-note\">Drag points or use controls. Use keyboard arrows when a point is focused.</div>\n            </div>\n          </div>\n\n          <!-- SVG Canvas -->\n          <div class=\"canvas-wrap\" role=\"region\" aria-label=\"Scatter plot with regression line\">\n            <svg id=\"svg\" viewBox=\"0 0 800 520\" preserveAspectRatio=\"xMidYMid meet\" tabindex=\"0\" aria-hidden=\"false\">\n              <defs>\n                <linearGradient id=\"gridGrad\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"1\">\n                  <stop offset=\"0%\" stop-color=\"rgba(255,255,255,0.02)\"></stop>\n                  <stop offset=\"100%\" stop-color=\"rgba(255,255,255,0.01)\"></stop>\n                </linearGradient>\n              </defs>\n\n              <!-- background rect for pointer capture -->\n              <rect x=\"0\" y=\"0\" width=\"800\" height=\"520\" fill=\"transparent\"></rect>\n\n              <!-- axes and grids -->\n              <g id=\"grid\"></g>\n              <g id=\"axes\"></g>\n\n              <!-- regression lines -->\n              <line id=\"regLine\" class=\"regression-line\" x1=\"0\" y1=\"0\" x2=\"800\" y2=\"0\" stroke-linejoin=\"round\" stroke-linecap=\"round\"/>\n              <line id=\"olsLine\" class=\"ols-line\" x1=\"0\" y1=\"0\" x2=\"800\" y2=\"0\" style=\"opacity:0\" />\n\n              <!-- residuals -->\n              <g id=\"residuals\"></g>\n\n              <!-- points -->\n              <g id=\"points\"></g>\n            </svg>\n          </div>\n\n        </div>\n\n        <div style=\"display:flex; gap:var(--gap); align-items:flex-start; flex-wrap:wrap;\">\n          <div style=\"flex:1; min-width:220px;\">\n            <h4 style=\"margin:0 0 8px 0;\">Layout Description</h4>\n            <p style=\"margin:0; color:var(--muted); font-size:13px;\">\n              Safe area margins = 24px. Controls are left column, visual plot on the right. Spacing between controls >= 16px.\n              The SVG canvas is responsive and scales while keeping control sizes comfortable. Interactive elements have focus outlines for keyboard users.\n            </p>\n          </div>\n          <div style=\"min-width:220px;\">\n            <h4 style=\"margin:0 0 8px 0;\">Concept Title</h4>\n            <p style=\"margin:0; color:var(--muted); font-size:13px;\">Simple Linear Regression: Fitting a line y = m*x + b to minimize SSE</p>\n          </div>\n        </div>\n\n      </div>\n    </div>\n  </div>\n\n  <script>\n    /******************************************************************\n     * Interactive Linear Regression Module (Vanilla JS)\n     * Features:\n     * - Draggable points (pointer + keyboard)\n     * - Slope/intercept sliders for manual control\n     * - Analytic OLS fit (closed-form)\n     * - Gradient descent animation for m,b\n     * - Residual visualization\n     *\n     * Accessibility:\n     * - Buttons and sliders labeled\n     * - Points focusable for keyboard nudging\n     *\n     * Layout constraint: safe margin 24px enforced via CSS.\n     ******************************************************************/\n\n    (function(){\n      // SVG & layout settings\n      const svg = document.getElementById('svg');\n      const ptsLayer = document.getElementById('points');\n      const resLayer = document.getElementById('residuals');\n      const gridLayer = document.getElementById('grid');\n      const axesLayer = document.getElementById('axes');\n      const regLine = document.getElementById('regLine');\n      const olsLine = document.getElementById('olsLine');\n\n      // controls\n      const slopeRange = document.getElementById('slope');\n      const interceptRange = document.getElementById('intercept');\n      const slopeVal = document.getElementById('slopeVal');\n      const interceptVal = document.getElementById('interceptVal');\n      const lrRange = document.getElementById('lr');\n      const lrVal = document.getElementById('lrVal');\n      const fitBtn = document.getElementById('fitBtn');\n      const gdBtn = document.getElementById('gdBtn');\n      const resetDataBtn = document.getElementById('resetData');\n      const toggleResidualsBtn = document.getElementById('toggleResiduals');\n      const modeSelect = document.getElementById('mode');\n      const randomOutlierBtn = document.getElementById('randomOutlier');\n\n      const mMetric = document.getElementById('mMetric');\n      const bMetric = document.getElementById('bMetric');\n      const sseMetric = document.getElementById('sseMetric');\n      const r2Metric = document.getElementById('r2');\n\n      const POINT_RADIUS = 7;\n      const WIDTH = 800, HEIGHT = 520;\n      const MARGIN = {left:60, right:30, top:20, bottom:60};\n      const PLOT_WIDTH = WIDTH - MARGIN.left - MARGIN.right;\n      const PLOT_HEIGHT = HEIGHT - MARGIN.top - MARGIN.bottom;\n\n      // Data space ranges\n      let xMin = 0, xMax = 100;\n      let yMin = -40, yMax = 140;\n\n      // dataset: array of {x,y,svgEl}\n      let data = [];\n\n      // model params (slope m and intercept b)\n      let m = parseFloat(slopeRange.value);\n      let b = parseFloat(interceptRange.value);\n\n      // analytic OLS params (computed when Fit pressed)\n      let olsParams = null;\n\n      // residual visibility\n      let showResiduals = true;\n\n      // gradient descent state\n      let gdRunning = false;\n      let gdReq = null;\n\n      // initialize\n      function init() {\n        drawGridAndAxes();\n        generateData();\n        renderPoints();\n        updateLine();\n        updateMetrics();\n        attachEvents();\n      }\n\n      // Scale helpers: data -> screen coordinates\n      function sx(x) {\n        return MARGIN.left + ((x - xMin) / (xMax - xMin)) * PLOT_WIDTH;\n      }\n      function sy(y) {\n        // invert y: data yMax at top margin\n        return MARGIN.top + ((yMax - y) / (yMax - yMin)) * PLOT_HEIGHT;\n      }\n      function ix(px) {\n        return xMin + ((px - MARGIN.left) / PLOT_WIDTH) * (xMax - xMin);\n      }\n      function iy(py) {\n        return yMax - ((py - MARGIN.top) / PLOT_HEIGHT) * (yMax - yMin);\n      }\n\n      // Grid & axes\n      function drawGridAndAxes(){\n        gridLayer.innerHTML = '';\n        axesLayer.innerHTML = '';\n\n        // vertical grid lines (x)\n        let xTicks = 10;\n        for(let i=0;i<=xTicks;i++){\n          const x = xMin + (i/xTicks)*(xMax-xMin);\n          const px = sx(x);\n          const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n          line.setAttribute('x1', px);\n          line.setAttribute('x2', px);\n          line.setAttribute('y1', MARGIN.top);\n          line.setAttribute('y2', HEIGHT - MARGIN.bottom);\n          line.setAttribute('stroke', 'rgba(255,255,255,0.03)');\n          line.setAttribute('stroke-width', '1');\n          gridLayer.appendChild(line);\n\n          const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');\n          lbl.setAttribute('x', px);\n          lbl.setAttribute('y', HEIGHT - MARGIN.bottom + 18);\n          lbl.setAttribute('text-anchor', 'middle');\n          lbl.setAttribute('fill', '#9fb8cc');\n          lbl.setAttribute('font-size', '11');\n          lbl.textContent = Math.round(x);\n          axesLayer.appendChild(lbl);\n        }\n\n        // horizontal grid lines (y)\n        let yTicks = 8;\n        for(let j=0;j<=yTicks;j++){\n          const y = yMin + (j/yTicks)*(yMax-yMin);\n          const py = sy(y);\n          const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n          line.setAttribute('x1', MARGIN.left);\n          line.setAttribute('x2', WIDTH - MARGIN.right);\n          line.setAttribute('y1', py);\n          line.setAttribute('y2', py);\n          line.setAttribute('stroke', 'rgba(255,255,255,0.02)');\n          line.setAttribute('stroke-width', '1');\n          gridLayer.appendChild(line);\n\n          const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');\n          lbl.setAttribute('x', MARGIN.left - 10);\n          lbl.setAttribute('y', py + 4);\n          lbl.setAttribute('text-anchor', 'end');\n          lbl.setAttribute('fill', '#9fb8cc');\n          lbl.setAttribute('font-size', '11');\n          lbl.textContent = Math.round(y);\n          axesLayer.appendChild(lbl);\n        }\n\n        // axis lines\n        const xAxis = document.createElementNS('http://www.w3.org/2000/svg','line');\n        xAxis.setAttribute('x1', MARGIN.left);\n        xAxis.setAttribute('x2', WIDTH - MARGIN.right);\n        xAxis.setAttribute('y1', HEIGHT - MARGIN.bottom);\n        xAxis.setAttribute('y2', HEIGHT - MARGIN.bottom);\n        xAxis.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n        xAxis.setAttribute('stroke-width', '1.5');\n        axesLayer.appendChild(xAxis);\n\n        const yAxis = document.createElementNS('http://www.w3.org/2000/svg','line');\n        yAxis.setAttribute('x1', MARGIN.left);\n        yAxis.setAttribute('x2', MARGIN.left);\n        yAxis.setAttribute('y1', MARGIN.top);\n        yAxis.setAttribute('y2', HEIGHT - MARGIN.bottom);\n        yAxis.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n        yAxis.setAttribute('stroke-width', '1.5');\n        axesLayer.appendChild(yAxis);\n      }\n\n      // Generate synthetic data\n      function generateData(n=12) {\n        data = [];\n        // underlying true line (for generating synthetic data)\n        const trueM = 0.9 + Math.random()*1.6 - 0.3;\n        const trueB = 10 + Math.random()*30 - 10;\n        for(let i=0;i<n;i++){\n          const x = 5 + Math.random()*90;\n          const y = trueM * x + trueB + (Math.random()*40 - 20);\n          data.push({x: x, y: y});\n        }\n        // set sliders to default m and b such that line roughly matches data center\n        m = parseFloat(slopeRange.value);\n        b = parseFloat(interceptRange.value);\n        olsParams = null;\n      }\n\n      // Render points\n      function renderPoints(){\n        ptsLayer.innerHTML = '';\n        data.forEach((pt, idx) => {\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('transform', `translate(${sx(pt.x)},${sy(pt.y)})`);\n          g.setAttribute('tabindex', '0');\n          g.classList.add('draggable');\n          g.setAttribute('data-idx', idx);\n\n          // circle\n          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          c.setAttribute('r', POINT_RADIUS.toString());\n          c.setAttribute('class', 'point');\n          c.setAttribute('cx', '0');\n          c.setAttribute('cy', '0');\n          g.appendChild(c);\n\n          // label (small)\n          const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');\n          lbl.setAttribute('x', 12);\n          lbl.setAttribute('y', 4);\n          lbl.setAttribute('fill', '#dff8ff');\n          lbl.setAttribute('font-size', '11');\n          lbl.textContent = `(${Math.round(pt.x)}, ${Math.round(pt.y)})`;\n          lbl.setAttribute('opacity', '0.9');\n          g.appendChild(lbl);\n\n          ptsLayer.appendChild(g);\n\n          // attach pointer events for dragging\n          attachDragHandlers(g, idx);\n          attachKeyboardHandlers(g, idx, lbl);\n        });\n      }\n\n      // attach pointer dragging handlers to a group\n      function attachDragHandlers(el, idx){\n        let dragging = false;\n        let pointerId = null;\n\n        function onPointerDown(e){\n          if(e.pointerType === 'mouse' && e.button !== 0) return;\n          e.preventDefault();\n          el.setPointerCapture(e.pointerId);\n          pointerId = e.pointerId;\n          dragging = true;\n        }\n        function onPointerMove(e){\n          if(!dragging || e.pointerId !== pointerId) return;\n          const {clientX, clientY} = e;\n          // map client coords to svg coordinates\n          const pt = clientToSvg(e);\n          const newX = Math.max(xMin, Math.min(xMax, ix(pt.x)));\n          const newY = Math.max(yMin, Math.min(yMax, iy(pt.y)));\n          data[idx].x = newX;\n          data[idx].y = newY;\n          el.setAttribute('transform', `translate(${sx(newX)},${sy(newY)})`);\n          // update label\n          const text = el.querySelector('text');\n          if(text) text.textContent = `(${Math.round(newX)}, ${Math.round(newY)})`;\n          // if mode auto-fit, compute OLS immediately\n          if(modeSelect.value === 'auto'){\n            computeOLS();\n            animateToOLS();\n          }\n          // when dragging, update residuals and current line\n          updateLine();\n        }\n        function onPointerUp(e){\n          if(e.pointerId !== pointerId) return;\n          dragging = false;\n          el.releasePointerCapture(e.pointerId);\n          pointerId = null;\n        }\n\n        el.addEventListener('pointerdown', onPointerDown);\n        window.addEventListener('pointermove', onPointerMove);\n        window.addEventListener('pointerup', onPointerUp);\n        window.addEventListener('pointercancel', onPointerUp);\n      }\n\n      // attach keyboard nudging for focused point\n      function attachKeyboardHandlers(el, idx, labelEl){\n        el.addEventListener('keydown', (ev) => {\n          let changed = false;\n          if(ev.key === 'ArrowLeft'){ data[idx].x = Math.max(xMin, data[idx].x - 1); changed = true; }\n          if(ev.key === 'ArrowRight'){ data[idx].x = Math.min(xMax, data[idx].x + 1); changed = true; }\n          if(ev.key === 'ArrowUp'){ data[idx].y = Math.min(yMax, data[idx].y + 1); changed = true; }\n          if(ev.key === 'ArrowDown'){ data[idx].y = Math.max(yMin, data[idx].y - 1); changed = true; }\n          if(changed){\n            el.setAttribute('transform', `translate(${sx(data[idx].x)},${sy(data[idx].y)})`);\n            labelEl.textContent = `(${Math.round(data[idx].x)}, ${Math.round(data[idx].y)})`;\n            ev.preventDefault();\n            if(modeSelect.value === 'auto'){\n              computeOLS();\n              animateToOLS();\n            }\n            updateLine();\n          }\n        });\n      }\n\n      // convert client pointer to svg coords\n      function clientToSvg(evt){\n        const pt = svg.createSVGPoint();\n        pt.x = evt.clientX;\n        pt.y = evt.clientY;\n        const ctm = svg.getScreenCTM().inverse();\n        const sp = pt.matrixTransform(ctm);\n        return {x: sp.x, y: sp.y};\n      }\n\n      // update regression line based on current m,b\n      function updateLine(animate=false){\n        // compute endpoints in screen coordinates\n        const x1 = xMin, x2 = xMax;\n        const y1 = m * x1 + b, y2 = m * x2 + b;\n        const px1 = sx(x1), py1 = sy(y1), px2 = sx(x2), py2 = sy(y2);\n\n        // animate via transition by updating attributes; browsers animate SVG attributes automatically if CSS transition is not available; we emulate smooth animation\n        regLine.setAttribute('x1', px1);\n        regLine.setAttribute('y1', py1);\n        regLine.setAttribute('x2', px2);\n        regLine.setAttribute('y2', py2);\n\n        // residuals\n        drawResiduals();\n\n        // update displayed slider labels and metrics\n        slopeVal.textContent = m.toFixed(2);\n        interceptVal.textContent = b.toFixed(1);\n        mMetric.textContent = m.toFixed(2);\n        bMetric.textContent = b.toFixed(1);\n        updateMetrics();\n      }\n\n      // draw or clear residual lines\n      function drawResiduals(){\n        resLayer.innerHTML = '';\n        if(!showResiduals) return;\n        data.forEach((pt, i) => {\n          // predicted y on current line at pt.x\n          const yHat = m * pt.x + b;\n          const xS = sx(pt.x), yS = sy(pt.y), yHatS = sy(yHat);\n\n          const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n          line.setAttribute('x1', xS);\n          line.setAttribute('x2', xS);\n          line.setAttribute('y1', yS);\n          line.setAttribute('y2', yHatS);\n          line.setAttribute('class', 'residual');\n          resLayer.appendChild(line);\n        });\n      }\n\n      // compute metrics: SSE and R^2\n      function updateMetrics(){\n        const n = data.length;\n        const yMean = data.reduce((s,p)=>s+p.y,0)/n;\n        let ssTot = 0, ssRes = 0;\n        data.forEach(pt=>{\n          const yHat = m*pt.x + b;\n          ssRes += (pt.y - yHat)*(pt.y - yHat);\n          ssTot += (pt.y - yMean)*(pt.y - yMean);\n        });\n        const r2 = ssTot === 0 ? 0 : Math.max(0, 1 - ssRes/ssTot);\n        sseMetric.textContent = ssRes.toFixed(2);\n        r2Metric.textContent = r2.toFixed(3);\n      }\n\n      // analytic OLS solution (m,b)\n      function computeOLS(){\n        const n = data.length;\n        const meanX = data.reduce((s,p)=>s+p.x,0)/n;\n        const meanY = data.reduce((s,p)=>s+p.y,0)/n;\n        let num = 0, den = 0;\n        data.forEach(pt=>{\n          num += (pt.x - meanX)*(pt.y - meanY);\n          den += (pt.x - meanX)*(pt.x - meanX);\n        });\n        const mm = den === 0 ? 0 : num/den;\n        const bb = meanY - mm * meanX;\n        olsParams = {m: mm, b: bb};\n        return olsParams;\n      }\n\n      // animate to OLS (smoothly move m,b to olsParams)\n      function animateToOLS(duration=500){\n        if(!olsParams) computeOLS();\n        const startM = m, startB = b;\n        const endM = olsParams.m, endB = olsParams.b;\n        const t0 = performance.now();\n        const step = (ts)=>{\n          const p = Math.min(1, (ts - t0) / duration);\n          // simple easeOutQuad\n          const ease = 1 - Math.pow(1-p,2);\n          m = startM + (endM - startM) * ease;\n          b = startB + (endB - startB) * ease;\n          updateLine();\n          if(p < 1) requestAnimationFrame(step);\n          else {\n            // show OLS dashed line as final (green dashed)\n            showOLSLine();\n          }\n        };\n        requestAnimationFrame(step);\n      }\n\n      // show analytic OLS line as dashed green\n      function showOLSLine(){\n        if(!olsParams) return;\n        const x1 = xMin, x2 = xMax;\n        const y1 = olsParams.m * x1 + olsParams.b, y2 = olsParams.m * x2 + olsParams.b;\n        olsLine.setAttribute('x1', sx(x1));\n        olsLine.setAttribute('y1', sy(y1));\n        olsLine.setAttribute('x2', sx(x2));\n        olsLine.setAttribute('y2', sy(y2));\n        olsLine.style.opacity = 1;\n        // fade out after a bit\n        setTimeout(()=>{ olsLine.style.transition = 'opacity 1200ms'; olsLine.style.opacity = 0; setTimeout(()=>olsLine.style.transition='none', 1400); }, 1300);\n      }\n\n      // gradient descent for linear regression (batch)\n      function startGradientDescent(){\n        if(gdRunning) return;\n        gdRunning = true;\n        gdBtn.textContent = 'Pause GD';\n        // starting from current m,b\n        let steps = 0;\n        function step(){\n          if(!gdRunning) return;\n          const lr = parseFloat(lrRange.value);\n          // compute gradients: d/dm SSE = -2 * sum x*(y - (m x + b)), d/db SSE = -2 * sum (y - (m x + b))\n          let gradM = 0, gradB = 0;\n          data.forEach(pt => {\n            const err = pt.y - (m*pt.x + b);\n            gradM += -2 * pt.x * err;\n            gradB += -2 * err;\n          });\n          // normalize by n to get average gradient (optional)\n          const n = data.length;\n          gradM /= n;\n          gradB /= n;\n          // update\n          m = m - lr * gradM;\n          b = b - lr * gradB;\n\n          updateLine();\n          steps++;\n          // stop condition: small gradients or many steps\n          if(steps < 2000 && (Math.abs(gradM) > 1e-4 || Math.abs(gradB) > 1e-3)){\n            gdReq = requestAnimationFrame(step);\n          } else {\n            // finish\n            gdRunning = false;\n            gdBtn.textContent = 'Start GD';\n            computeOLS(); // compute analytic as reference\n            showOLSLine();\n          }\n        }\n        gdReq = requestAnimationFrame(step);\n      }\n      function pauseGradientDescent(){\n        gdRunning = false;\n        if(gdReq) cancelAnimationFrame(gdReq);\n        gdBtn.textContent = 'Start GD';\n      }\n\n      // attach UI event handlers\n      function attachEvents(){\n        slopeRange.addEventListener('input', (e)=>{\n          m = parseFloat(e.target.value);\n          updateLine();\n        });\n        interceptRange.addEventListener('input', (e)=>{\n          b = parseFloat(e.target.value);\n          updateLine();\n        });\n        lrRange.addEventListener('input', (e)=>{\n          lrVal.textContent = parseFloat(e.target.value).toFixed(3);\n        });\n\n        fitBtn.addEventListener('click', ()=>{\n          computeOLS();\n          animateToOLS(700);\n        });\n\n        gdBtn.addEventListener('click', ()=>{\n          if(gdRunning) pauseGradientDescent();\n          else startGradientDescent();\n        });\n\n        resetDataBtn.addEventListener('click', ()=>{\n          pauseGradientDescent();\n          generateData();\n          renderPoints();\n          olsLine.style.opacity = 0;\n          updateLine();\n        });\n\n        toggleResidualsBtn.addEventListener('click', ()=>{\n          showResiduals = !showResiduals;\n          drawResiduals();\n        });\n\n        modeSelect.addEventListener('change', ()=>{\n          // if switching away from auto, nothing special; if switch to auto, trigger fit\n          if(modeSelect.value === 'auto'){\n            computeOLS();\n            animateToOLS(300);\n          }\n        });\n\n        randomOutlierBtn.addEventListener('click', ()=>{\n          const x = 10 + Math.random()*80;\n          const y = yMax - 10 - Math.random()*80; // high outlier\n          data.push({x,y});\n          renderPoints();\n          updateLine();\n          computeOLS();\n          animateToOLS(600);\n        });\n\n        // sync displayed slider values\n        slopeVal.textContent = m.toFixed(2);\n        interceptVal.textContent = b.toFixed(1);\n        lrVal.textContent = parseFloat(lrRange.value).toFixed(3);\n\n        // update m,b on model changes to sync sliders (particularly after GD)\n        const syncLoop = ()=>{\n          // update sliders only if user not currently dragging them\n          if(document.activeElement !== slopeRange) slopeRange.value = m;\n          if(document.activeElement !== interceptRange) interceptRange.value = b;\n          requestAnimationFrame(syncLoop);\n        };\n        requestAnimationFrame(syncLoop);\n\n        // keyboard shortcut: press 'f' to fit, 'g' to toggle gd\n        window.addEventListener('keydown', (e)=>{\n          if(e.key === 'f') { computeOLS(); animateToOLS(500); }\n          if(e.key === 'g') { if(gdRunning) pauseGradientDescent(); else startGradientDescent(); }\n        });\n      }\n\n      // initial render\n      init();\n\n      // Expose for debugging (not necessary)\n      window.__linReg = {data, computeOLS, updateLine, generateData};\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Linear Regression.\n\n**Project Overview:**\nTopic: Linear Regression\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Linear Regression"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "6b68de00-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:51:40.640Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "K-Means Clustering",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>K‑Means Clustering — Interactive Module</title>\n  <style>\n    :root{\n      --safe-padding: 24px;\n      --gap: 16px;\n      --bg: #0f1720;\n      --panel: #0b1220;\n      --card: #0e1622;\n      --muted: #9aa6b2;\n      --accent: #4f46e5;\n      --white: #f8fafc;\n    }\n    /* Safe area margins: 24px on all sides */\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071027 0%, #071827 100%);\n      color:var(--white);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    main{\n      padding: var(--safe-padding);\n      box-sizing:border-box;\n      min-height:100vh;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    header{\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      max-width:1100px;\n      margin:0 auto;\n    }\n    h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing:0.2px;\n    }\n    p.lead{\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n      max-width:1100px;\n    }\n\n    /* Layout: left controls + right canvas area */\n    .module{\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      width:100%;\n      max-width:1200px;\n      margin:0 auto;\n      box-sizing:border-box;\n    }\n\n    /* Left column (explanation + controls) */\n    .panel{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      padding:16px;\n      border-radius:10px;\n      width:360px;\n      min-width:260px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    .section-title{\n      font-weight:600;\n      font-size:13px;\n      margin:0;\n    }\n    .small{\n      font-size:13px;\n      color:var(--muted);\n      margin:0;\n    }\n    .controls{\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    label{\n      font-size:13px;\n      color:var(--muted);\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n    input[type=\"range\"]{\n      accent-color:var(--accent);\n      width:100%;\n    }\n    input[type=\"number\"], select{\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.06);\n      background:transparent;\n      color:var(--white);\n      width:100%;\n      box-sizing:border-box;\n    }\n    .button-row{\n      display:flex;\n      gap:var(--gap);\n      flex-wrap:wrap;\n    }\n    button{\n      background:var(--accent);\n      color:var(--white);\n      border:0;\n      padding:10px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      min-height:44px;\n    }\n    button.secondary{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--white);\n    }\n    .muted-btn{\n      background:transparent;\n      border:1px dashed rgba(255,255,255,0.04);\n      color:var(--muted);\n    }\n    .info{\n      font-size:13px;\n      color:var(--muted);\n      line-height:1.4;\n    }\n\n    /* Right column (visualization) */\n    .visual{\n      flex:1;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      min-width:320px;\n      box-sizing:border-box;\n    }\n    .canvas-card{\n      background:linear-gradient(180deg,#051427, #041022);\n      border-radius:12px;\n      padding:12px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      align-items:stretch;\n    }\n    .canvas-wrapper{\n      background:linear-gradient(180deg,#062036, #041322);\n      border-radius:8px;\n      height:480px;\n      position:relative;\n      overflow:hidden;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n    }\n    canvas{\n      width:100%;\n      height:100%;\n      border-radius:8px;\n      touch-action:none;\n      display:block;\n    }\n    .legend{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content:space-between;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .stats{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      color:var(--muted);\n      font-size:13px;\n      flex-wrap:wrap;\n    }\n\n    /* Responsive: stack on small viewports */\n    @media (max-width:980px){\n      .module{\n        flex-direction:column;\n      }\n      .panel{\n        width:100%;\n      }\n      .visual{\n        width:100%;\n      }\n      .canvas-wrapper{\n        height:360px;\n      }\n    }\n\n    /* Accessibility focus */\n    button:focus, input:focus, select:focus{\n      outline:2px solid rgba(79,70,229,0.28);\n      outline-offset:2px;\n    }\n\n    /* little helper */\n    .hint{\n      font-size:12px;\n      color:var(--muted);\n    }\n  </style>\n</head>\n<body>\n  <main>\n    <header aria-labelledby=\"title\">\n      <h1 id=\"title\">K‑Means Clustering — Interactive Module</h1>\n      <p class=\"lead\">Explore how K-Means partitions data into clusters by manipulating points and centroids. Drag points, change K, and step through the algorithm to see assignments and centroid movement in real time.</p>\n    </header>\n\n    <div class=\"module\" role=\"application\" aria-label=\"K-Means interactive module\">\n      <!-- Left panel: explanation and controls -->\n      <aside class=\"panel\" aria-labelledby=\"controls-title\">\n        <div>\n          <h2 class=\"section-title\" id=\"controls-title\">Learning Objective</h2>\n          <p class=\"small\" id=\"objective\">After interacting with this module you will be able to:\n            <ul style=\"margin:8px 0 0 18px; color:var(--muted); font-size:13px; padding:0;\">\n              <li>Understand assignment and update steps in K‑Means</li>\n              <li>See how different initial centroids affect convergence</li>\n              <li>Observe inertia (sum of squared distances) changing across iterations</li>\n            </ul>\n          </p>\n        </div>\n\n        <div>\n          <h3 class=\"section-title\">Interaction Design</h3>\n          <p class=\"info\">\n            - Click the canvas to add points. Drag points (or centroids) to see real-time reassignments.<br>\n            - Use \"Step\" to run one assign+update iteration. \"Play\" animates iterations until convergence.<br>\n            - Toggle \"Init by click\" to place centroids manually. Shift‑click a point to remove it.\n          </p>\n        </div>\n\n        <div>\n          <h3 class=\"section-title\">Controls</h3>\n          <div class=\"controls\" role=\"form\" aria-label=\"K-Means controls\">\n            <label>\n              Number of clusters (K)\n              <input id=\"k-range\" type=\"range\" min=\"1\" max=\"8\" value=\"3\" aria-label=\"Number of clusters\">\n            </label>\n            <label>\n              K (numeric)\n              <input id=\"k-number\" type=\"number\" min=\"1\" max=\"8\" value=\"3\" aria-label=\"Number of clusters numeric\">\n            </label>\n\n            <label>\n              Points to generate\n              <input id=\"n-range\" type=\"range\" min=\"10\" max=\"500\" value=\"120\" aria-label=\"Number of points to generate\">\n            </label>\n\n            <div class=\"button-row\" role=\"group\" aria-label=\"generation actions\">\n              <button id=\"generate-btn\" title=\"Generate random points\">Generate Points</button>\n              <button id=\"clear-btn\" class=\"secondary\" title=\"Clear points and centroids\">Clear</button>\n              <button id=\"randomize-centroids\" class=\"secondary\" title=\"Place centroids at random\">Randomize Centroids</button>\n            </div>\n\n            <div style=\"display:flex;gap:var(--gap);align-items:center;flex-wrap:wrap;\">\n              <button id=\"step-btn\" class=\"muted-btn\" title=\"Perform one K-means iteration\">Step</button>\n              <button id=\"play-btn\" title=\"Play / Pause iterations\">Play</button>\n              <button id=\"converge-btn\" class=\"secondary\" title=\"Run until convergence\">Run to Convergence</button>\n            </div>\n\n            <label style=\"display:flex;gap:8px;align-items:center;\">\n              <input id=\"init-by-click\" type=\"checkbox\" aria-label=\"Initialize centroids by clicking\"> Initialize centroids by click\n              <span class=\"hint\" style=\"margin-left:auto;color:var(--muted);font-size:12px;\">(Click canvas to place)</span>\n            </label>\n\n            <div class=\"info\" id=\"interaction-hint\">\n              Tip: Drag points to change cluster geometry. Press Space to toggle Play/Pause.\n            </div>\n          </div>\n        </div>\n\n        <div>\n          <h3 class=\"section-title\">Layout Description</h3>\n          <p class=\"info\">\n            The module places explanatory text and controls in a left column and the interactive visualization on the right.\n            Safe area margins are 24px and controls maintain at least 16px spacing. The canvas is responsive and supports mouse & touch.\n          </p>\n        </div>\n      </aside>\n\n      <!-- Right: visualization -->\n      <section class=\"visual\" aria-labelledby=\"visual-title\">\n        <div class=\"canvas-card\">\n          <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n            <h3 id=\"visual-title\" class=\"section-title\" style=\"margin:0;\">Visualization</h3>\n            <div class=\"legend\" aria-hidden=\"true\">\n              <div id=\"iteration\">Iteration: 0</div>\n              <div id=\"inertia\">Inertia: 0.00</div>\n            </div>\n          </div>\n\n          <div class=\"canvas-wrapper\" id=\"canvas-wrapper\" tabindex=\"0\" aria-label=\"K-means canvas (click to add points)\">\n            <canvas id=\"canvas\" role=\"img\" aria-label=\"K-means scatter plot\"></canvas>\n          </div>\n\n          <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n            <div class=\"stats\">\n              <div>Points: <span id=\"num-points\">0</span></div>\n              <div>Clusters: <span id=\"num-clusters\">3</span></div>\n              <div>Mode: <span id=\"mode-indicator\">interactive</span></div>\n            </div>\n            <div style=\"color:var(--muted);font-size:13px;\">Keyboard: Space to play/pause · Shift+Click to remove point</div>\n          </div>\n        </div>\n      </section>\n    </div>\n  </main>\n\n  <script>\n  /*********************************************************************\n   * K-Means Interactive Module\n   * Self-contained vanilla JS, HTML5 Canvas, and CSS.\n   * - Click canvas to add points\n   * - Drag points or centroids\n   * - Shift+Click to remove a point\n   * - Init centroids by click when checkbox is enabled\n   * - Step, Play (animate), Run to convergence\n   *********************************************************************/\n\n  (function(){\n    // DOM references\n    const canvas = document.getElementById('canvas');\n    const wrapper = document.getElementById('canvas-wrapper');\n    const kRange = document.getElementById('k-range');\n    const kNumber = document.getElementById('k-number');\n    const nRange = document.getElementById('n-range');\n    const generateBtn = document.getElementById('generate-btn');\n    const clearBtn = document.getElementById('clear-btn');\n    const randomizeCentroidsBtn = document.getElementById('randomize-centroids');\n    const stepBtn = document.getElementById('step-btn');\n    const playBtn = document.getElementById('play-btn');\n    const convergeBtn = document.getElementById('converge-btn');\n    const initByClick = document.getElementById('init-by-click');\n    const iterationLabel = document.getElementById('iteration');\n    const inertiaLabel = document.getElementById('inertia');\n    const numPointsLabel = document.getElementById('num-points');\n    const numClustersLabel = document.getElementById('num-clusters');\n    const modeIndicator = document.getElementById('mode-indicator');\n\n    // Canvas setup & scaling for high-dpi\n    function resizeCanvas(){\n      const rect = wrapper.getBoundingClientRect();\n      const dpr = window.devicePixelRatio || 1;\n      canvas.width = Math.max(300, Math.floor(rect.width * dpr));\n      canvas.height = Math.max(200, Math.floor(rect.height * dpr));\n      canvas.style.width = rect.width + 'px';\n      canvas.style.height = rect.height + 'px';\n      ctx.setTransform(dpr,0,0,dpr,0,0);\n      draw();\n    }\n    const ctx = canvas.getContext('2d');\n\n    // Data structures\n    let points = []; // {x,y,assignIndex}\n    let centroids = []; // {x,y,color}\n    let k = parseInt(kRange.value,10);\n    let iteration = 0;\n    let playing = false;\n    let animating = false;\n    let animationRequest = null;\n    let playInterval = null;\n    let maxIterations = 200;\n    let lastAssignments = null;\n\n    // Constants for visuals\n    const POINT_RADIUS = 6;\n    const CENTROID_RADIUS = 10;\n    const COLORS = [\n      '#ef4444','#f97316','#f59e0b','#eab308','#84cc16','#10b981','#06b6d4','#60a5fa'\n    ];\n\n    // Utility\n    function rand(min,max){ return Math.random()*(max-min)+min; }\n\n    // Initialize\n    function init(){\n      window.addEventListener('resize', resizeCanvas);\n      resizeCanvas();\n\n      // Sync controls\n      kRange.addEventListener('input', ()=>{ k = parseInt(kRange.value,10); kNumber.value = k; numClustersLabel.textContent = k; ensureCentroidsCount(); draw(); });\n      kNumber.addEventListener('change', ()=>{\n        let v = parseInt(kNumber.value,10) || 1;\n        v = Math.max(1, Math.min(8, v));\n        k = v;\n        kRange.value = v;\n        kNumber.value = v;\n        numClustersLabel.textContent = k;\n        ensureCentroidsCount();\n        draw();\n      });\n      generateBtn.addEventListener('click', ()=>{ generatePoints(parseInt(nRange.value,10)); });\n      clearBtn.addEventListener('click', clearAll);\n      randomizeCentroidsBtn.addEventListener('click', randomizeCentroids);\n      stepBtn.addEventListener('click', stepOnce);\n      playBtn.addEventListener('click', togglePlay);\n      convergeBtn.addEventListener('click', runToConvergence);\n\n      // Canvas interactions\n      canvas.addEventListener('pointerdown', onPointerDown);\n      canvas.addEventListener('pointermove', onPointerMove);\n      window.addEventListener('pointerup', onPointerUp);\n      canvas.addEventListener('click', onCanvasClick);\n\n      // Keyboard: space toggles play\n      window.addEventListener('keydown', (e)=>{\n        if(e.code === 'Space'){\n          e.preventDefault();\n          togglePlay();\n        }\n      });\n\n      // initial sample\n      generatePoints(120);\n      randomizeCentroids();\n      draw();\n    }\n\n    // Generate random points clustered somewhat\n    function generatePoints(n){\n      points = [];\n      // Use a few gaussian blobs to make structure\n      const blobs = Math.max(2, Math.min(6, Math.round(Math.sqrt(n)/2)));\n      const rect = wrapper.getBoundingClientRect();\n      for(let b=0;b<blobs;b++){\n        const cx = rand(0.2,0.8)*rect.width;\n        const cy = rand(0.2,0.8)*rect.height;\n        const spread = Math.max(20, rect.width*0.04 + Math.random()*rect.width*0.12);\n        const count = Math.round(n/blobs) + (Math.random()<0.5?1:0);\n        for(let i=0;i<count;i++){\n          const angle = Math.random()*Math.PI*2;\n          const r = Math.abs(normalizeRandom())*spread;\n          const x = Math.max(8, Math.min(rect.width-8, cx + Math.cos(angle)*r));\n          const y = Math.max(8, Math.min(rect.height-8, cy + Math.sin(angle)*r));\n          points.push({x,y,assign:-1});\n        }\n      }\n      iteration = 0; lastAssignments = null;\n      numPointsLabel.textContent = points.length;\n      ensureCentroidsCount();\n      draw();\n    }\n\n    // Simple normal-like generator (Box-Muller-ish)\n    function normalizeRandom(){\n      // Marsaglia polar method\n      let u,v,s;\n      do{\n        u = Math.random()*2-1;\n        v = Math.random()*2-1;\n        s = u*u+v*v;\n      } while(s===0 || s>=1);\n      return u*Math.sqrt(-2*Math.log(s)/s);\n    }\n\n    function clearAll(){\n      points = [];\n      centroids = [];\n      iteration = 0;\n      lastAssignments = null;\n      numPointsLabel.textContent = 0;\n      draw();\n    }\n\n    function ensureCentroidsCount(){\n      // Ensure centroids array length == k; if less, add random ones; if more, trim\n      const rect = wrapper.getBoundingClientRect();\n      while(centroids.length < k){\n        centroids.push({x: rand(0.1,0.9)*rect.width, y: rand(0.1,0.9)*rect.height, color: COLORS[centroids.length % COLORS.length]});\n      }\n      while(centroids.length > k){\n        centroids.pop();\n      }\n      numClustersLabel.textContent = k;\n    }\n\n    function randomizeCentroids(){\n      const rect = wrapper.getBoundingClientRect();\n      for(let i=0;i<k;i++){\n        if(!centroids[i]) centroids[i] = {};\n        centroids[i].x = rand(0.1,0.9)*rect.width;\n        centroids[i].y = rand(0.1,0.9)*rect.height;\n        centroids[i].color = COLORS[i%COLORS.length];\n      }\n      iteration = 0; lastAssignments = null;\n      draw();\n    }\n\n    // K-Means core: assign and update\n    function assignPoints(){\n      let changed = false;\n      for(let p of points){\n        let best = -1;\n        let bestDist = Infinity;\n        for(let i=0;i<centroids.length;i++){\n          const c = centroids[i];\n          const dx = p.x - c.x;\n          const dy = p.y - c.y;\n          const d2 = dx*dx + dy*dy;\n          if(d2 < bestDist){ bestDist = d2; best = i; }\n        }\n        if(p.assign !== best){\n          changed = true;\n        }\n        p.assign = best;\n      }\n      return changed;\n    }\n\n    function updateCentroids(){\n      const sums = centroids.map(_=>({x:0,y:0,count:0}));\n      for(const p of points){\n        if(p.assign>=0 && sums[p.assign]){\n          sums[p.assign].x += p.x;\n          sums[p.assign].y += p.y;\n          sums[p.assign].count += 1;\n        }\n      }\n      const newPositions = [];\n      for(let i=0;i<centroids.length;i++){\n        if(sums[i].count > 0){\n          newPositions.push({x: sums[i].x / sums[i].count, y: sums[i].y / sums[i].count});\n        } else {\n          // No points assigned -> place randomly to a point location or random position\n          if(points.length>0){\n            const p = points[Math.floor(Math.random()*points.length)];\n            newPositions.push({x: p.x + rand(-20,20), y: p.y + rand(-20,20)});\n          } else {\n            const rect = wrapper.getBoundingClientRect();\n            newPositions.push({x: rand(0.1,0.9)*rect.width, y: rand(0.1,0.9)*rect.height});\n          }\n        }\n      }\n      return newPositions;\n    }\n\n    // Animate centroid movement from old to new (returns a promise-like thenable)\n    function animateCentroidMove(newPositions, duration=500){\n      animating = true;\n      const startPositions = centroids.map(c=>({x:c.x,y:c.y}));\n      const start = performance.now();\n      return new Promise(resolve=>{\n        function step(now){\n          const t = Math.min(1, (now - start)/duration);\n          const ease = easeOutCubic(t);\n          for(let i=0;i<centroids.length;i++){\n            centroids[i].x = startPositions[i].x + (newPositions[i].x - startPositions[i].x) * ease;\n            centroids[i].y = startPositions[i].y + (newPositions[i].y - startPositions[i].y) * ease;\n          }\n          draw();\n          if(t < 1){\n            animationRequest = requestAnimationFrame(step);\n          } else {\n            animating = false;\n            resolve();\n          }\n        }\n        animationRequest = requestAnimationFrame(step);\n      });\n    }\n\n    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }\n\n    // Single iteration step (assign + update + animate)\n    async function stepOnce(){\n      if(points.length===0 || centroids.length===0) return;\n      // assign\n      assignPoints();\n      // compute new centroid positions\n      const newPos = updateCentroids();\n      iteration++;\n      iterationLabel.textContent = `Iteration: ${iteration}`;\n      // animate movement\n      await animateCentroidMove(newPos, 450);\n      // after move, update assignment once more for consistency\n      assignPoints();\n      computeAndDisplayInertia();\n      draw();\n    }\n\n    // Run until convergence\n    async function runToConvergence(){\n      playing = false;\n      playBtn.textContent = 'Play';\n      let iterations = 0;\n      let stable = false;\n      // store previous centroid positions to check movement\n      while(iterations < maxIterations){\n        // compute assignments and new positions\n        assignPoints();\n        const newPos = updateCentroids();\n        // check movement magnitude\n        let maxMove = 0;\n        for(let i=0;i<centroids.length;i++){\n          const dx = centroids[i].x - newPos[i].x;\n          const dy = centroids[i].y - newPos[i].y;\n          const d = Math.sqrt(dx*dx+dy*dy);\n          if(d > maxMove) maxMove = d;\n        }\n        iteration++;\n        iterationLabel.textContent = `Iteration: ${iteration}`;\n        await animateCentroidMove(newPos, 350);\n        // after move, reassign\n        const changed = assignPoints();\n        computeAndDisplayInertia();\n        draw();\n        iterations++;\n        if(!changed && maxMove < 0.5) { stable = true; break; }\n      }\n      if(!stable){\n        // finished loop\n      }\n    }\n\n    // Play/pause: continuously step with a delay\n    function togglePlay(){\n      if(playing){\n        playing = false;\n        playBtn.textContent = 'Play';\n        clearInterval(playInterval);\n      } else {\n        playing = true;\n        playBtn.textContent = 'Pause';\n        playInterval = setInterval(async ()=>{\n          if(!playing) return;\n          if(animating) return;\n          await stepOnce();\n        }, 600);\n      }\n    }\n\n    // Compute inertia (sum of squared distances)\n    function computeAndDisplayInertia(){\n      let s = 0;\n      for(const p of points){\n        if(p.assign>=0 && centroids[p.assign]){\n          const dx = p.x - centroids[p.assign].x;\n          const dy = p.y - centroids[p.assign].y;\n          s += dx*dx + dy*dy;\n        }\n      }\n      inertiaLabel.textContent = `Inertia: ${s.toFixed(2)}`;\n    }\n\n    /*********************\n     * Interaction: pointer (mouse/touch)\n     *********************/\n    let dragging = null; // {type:'point'|'centroid', index, offsetX, offsetY}\n    function getPointerPos(evt){\n      const rect = canvas.getBoundingClientRect();\n      const x = evt.clientX - rect.left;\n      const y = evt.clientY - rect.top;\n      return {x,y};\n    }\n    function findNearbyPoint(x,y, radius=12){\n      for(let i=points.length-1;i>=0;i--){\n        const p = points[i];\n        const dx = p.x - x;\n        const dy = p.y - y;\n        if(dx*dx + dy*dy <= radius*radius) return i;\n      }\n      return -1;\n    }\n    function findNearbyCentroid(x,y, radius=14){\n      for(let i=0;i<centroids.length;i++){\n        const c = centroids[i];\n        const dx = c.x - x;\n        const dy = c.y - y;\n        if(dx*dx + dy*dy <= radius*radius) return i;\n      }\n      return -1;\n    }\n\n    function onPointerDown(evt){\n      evt.preventDefault();\n      const p = getPointerPos(evt);\n      const shift = evt.shiftKey;\n      // check centroid first\n      const ci = findNearbyCentroid(p.x, p.y, 14);\n      if(ci >= 0){\n        dragging = {type:'centroid', index:ci, offsetX: centroids[ci].x - p.x, offsetY: centroids[ci].y - p.y};\n        modeIndicator.textContent = 'dragging centroid';\n        return;\n      }\n      // check point\n      const pi = findNearbyPoint(p.x, p.y, 10);\n      if(pi >= 0){\n        dragging = {type:'point', index:pi, offsetX: points[pi].x - p.x, offsetY: points[pi].y - p.y};\n        modeIndicator.textContent = 'dragging point';\n        return;\n      }\n      // else nothing selected; fire pointer capture for potential adding if not in init mode\n    }\n\n    function onPointerMove(evt){\n      if(!dragging) return;\n      evt.preventDefault();\n      const p = getPointerPos(evt);\n      const nx = p.x + dragging.offsetX;\n      const ny = p.y + dragging.offsetY;\n      if(dragging.type === 'point'){\n        points[dragging.index].x = clamp(nx,8,canvas.clientWidth-8);\n        points[dragging.index].y = clamp(ny,8,canvas.clientHeight-8);\n        // reassign in real time\n        assignPoints();\n        computeAndDisplayInertia();\n        draw();\n      } else if(dragging.type === 'centroid'){\n        centroids[dragging.index].x = clamp(nx,8,canvas.clientWidth-8);\n        centroids[dragging.index].y = clamp(ny,8,canvas.clientHeight-8);\n        // reassign in real time\n        assignPoints();\n        computeAndDisplayInertia();\n        draw();\n      }\n    }\n\n    function onPointerUp(evt){\n      if(dragging){\n        dragging = null;\n        modeIndicator.textContent = 'interactive';\n      }\n    }\n\n    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }\n\n    // Canvas click: add point or remove with shift, or place centroid if init-by-click enabled\n    function onCanvasClick(evt){\n      const p = getPointerPos(evt);\n      const shift = evt.shiftKey;\n      if(initByClick.checked){\n        // place centroid (or replace nearest)\n        const i = centroids.length;\n        if(centroids.length < k){\n          centroids.push({x:p.x, y:p.y, color: COLORS[centroids.length % COLORS.length]});\n        } else {\n          // replace nearest centroid\n          let nearest = 0; let best = Infinity;\n          for(let j=0;j<centroids.length;j++){\n            const dx = centroids[j].x - p.x;\n            const dy = centroids[j].y - p.y;\n            const d2 = dx*dx + dy*dy;\n            if(d2 < best){ best = d2; nearest = j; }\n          }\n          centroids[nearest].x = p.x;\n          centroids[nearest].y = p.y;\n        }\n        assignPoints();\n        draw();\n        return;\n      }\n\n      if(shift){\n        // remove nearby point\n        const idx = findNearbyPoint(p.x, p.y, 12);\n        if(idx>=0){\n          points.splice(idx,1);\n          numPointsLabel.textContent = points.length;\n          assignPoints();\n          draw();\n        }\n        return;\n      }\n      // add a point\n      points.push({x:p.x, y:p.y, assign:-1});\n      numPointsLabel.textContent = points.length;\n      assignPoints();\n      computeAndDisplayInertia();\n      draw();\n    }\n\n    /*********************\n     * Drawing\n     *********************/\n    function draw(){\n      const w = canvas.clientWidth;\n      const h = canvas.clientHeight;\n      // background\n      ctx.clearRect(0,0,w,h);\n      // subtle grid\n      drawGrid(w,h);\n\n      // draw Voronoi-like filled regions (approx via convex colored circles under points)\n      // For simplicity and performance, we will draw translucent filled circles per cluster center.\n      for(let i=0;i<centroids.length;i++){\n        const c = centroids[i];\n        ctx.beginPath();\n        const gradient = ctx.createRadialGradient(c.x, c.y, 10, c.x, c.y, Math.max(w,h)/2);\n        gradient.addColorStop(0, hexToRGBA(c.color, 0.06));\n        gradient.addColorStop(1, hexToRGBA(c.color, 0.0));\n        ctx.fillStyle = gradient;\n        ctx.arc(c.x, c.y, Math.max(w,h)*0.8, 0, Math.PI*2);\n        ctx.fill();\n      }\n\n      // draw assignment lines lightly (optional)\n      ctx.lineWidth = 1;\n      for(const p of points){\n        if(p.assign>=0 && centroids[p.assign]){\n          ctx.strokeStyle = hexToRGBA(centroids[p.assign].color, 0.08);\n          ctx.beginPath();\n          ctx.moveTo(p.x, p.y);\n          ctx.lineTo(centroids[p.assign].x, centroids[p.assign].y);\n          ctx.stroke();\n        }\n      }\n\n      // draw points\n      for(const p of points){\n        const color = (p.assign>=0 && centroids[p.assign]) ? centroids[p.assign].color : '#7c8794';\n        // outer halo\n        ctx.beginPath();\n        ctx.fillStyle = hexToRGBA(color, 0.12);\n        ctx.arc(p.x, p.y, POINT_RADIUS+4, 0, Math.PI*2);\n        ctx.fill();\n        // inner dot\n        ctx.beginPath();\n        ctx.fillStyle = color;\n        ctx.arc(p.x, p.y, POINT_RADIUS-1, 0, Math.PI*2);\n        ctx.fill();\n        // point border\n        ctx.beginPath();\n        ctx.strokeStyle = 'rgba(0,0,0,0.25)';\n        ctx.lineWidth = 1;\n        ctx.arc(p.x, p.y, POINT_RADIUS-1, 0, Math.PI*2);\n        ctx.stroke();\n      }\n\n      // draw centroids on top\n      for(let i=0;i<centroids.length;i++){\n        const c = centroids[i];\n        // shadow\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,0.45)';\n        ctx.arc(c.x+2, c.y+3, CENTROID_RADIUS+3, 0, Math.PI*2);\n        ctx.fill();\n        // centroid circle\n        ctx.beginPath();\n        ctx.fillStyle = c.color;\n        ctx.arc(c.x, c.y, CENTROID_RADIUS, 0, Math.PI*2);\n        ctx.fill();\n        // label\n        ctx.fillStyle = '#02121a';\n        ctx.font = '600 12px Inter, sans-serif';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(String(i+1), c.x, c.y);\n      }\n    }\n\n    function drawGrid(w,h){\n      ctx.save();\n      ctx.fillStyle = 'rgba(255,255,255,0.01)';\n      ctx.fillRect(0,0,w,h);\n      ctx.strokeStyle = 'rgba(255,255,255,0.02)';\n      ctx.lineWidth = 1;\n      const step = 40;\n      ctx.beginPath();\n      for(let x=0.5;x<w;x+=step){\n        ctx.moveTo(x,0);\n        ctx.lineTo(x,h);\n      }\n      for(let y=0.5;y<h;y+=step){\n        ctx.moveTo(0,y);\n        ctx.lineTo(w,y);\n      }\n      ctx.stroke();\n      ctx.restore();\n    }\n\n    function hexToRGBA(hex, alpha){\n      const c = hex.replace('#','');\n      const bigint = parseInt(c,16);\n      const r = (bigint >> 16) & 255;\n      const g = (bigint >> 8) & 255;\n      const b = bigint & 255;\n      return `rgba(${r},${g},${b},${alpha})`;\n    }\n\n    // compute inertia every now and then\n    function computeAndDisplayInertiaPeriodically(){\n      computeAndDisplayInertia();\n      setTimeout(computeAndDisplayInertiaPeriodically, 1000);\n    }\n\n    // initialize and auto-update\n    init();\n    computeAndDisplayInertiaPeriodically();\n\n    // ensure canvas resized on load\n    setTimeout(resizeCanvas, 100);\n\n  })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of K-Means Clustering.\n\n**Project Overview:**\nTopic: K-Means Clustering\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "K-Means Clustering"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "7c685e60-bdcf-11f0-9d31-adfdd0a1a4cb",
    "timestamp": "2025-11-10T00:53:26.132Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "K-Nearest Neighbors (KNN)",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>K-Nearest Neighbors (KNN) Interactive Module</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --panel-bg: #fafafa;\n      --accent: #0b74de;\n      --success: #2d9f6f;\n      --danger: #e04e4e;\n      --muted: #64748b;\n      --card-radius: 10px;\n      --shadow: 0 4px 16px rgba(12,17,24,0.06);\n      --font-sans: Inter, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n\n    html,body{\n      height:100%;\n      margin:0;\n      padding:var(--safe-margin);\n      font-family:var(--font-sans);\n      background:linear-gradient(180deg,#ffffff,#f7fbff);\n      color:#0b1120;\n      box-sizing:border-box;\n    }\n    *{box-sizing:inherit}\n\n    /* Layout: two-column responsive */\n    .container{\n      display:grid;\n      grid-template-columns: 360px 1fr;\n      gap: var(--gap);\n      height: calc(100% - (var(--safe-margin) * 0)); /* leave room for padding already */\n    }\n    @media (max-width:900px){\n      .container{\n        grid-template-columns: 1fr;\n      }\n    }\n\n    /* Left panel: text and controls */\n    .panel{\n      background:var(--panel-bg);\n      border-radius:var(--card-radius);\n      padding:20px;\n      box-shadow:var(--shadow);\n      min-width:0;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      align-self:start;\n    }\n\n    h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing:0.2px;\n    }\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n      line-height:1.4;\n    }\n\n    .section{\n      background:white;\n      border-radius:8px;\n      padding:12px;\n      box-shadow:0 2px 6px rgba(11,17,32,0.04);\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n\n    /* Controls */\n    .controls{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    label{font-size:13px;color:#223;}\n    .row{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n\n    input[type=\"range\"]{\n      width:100%;\n    }\n    .btn{\n      background:var(--accent);\n      color:white;\n      border:none;\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n    }\n    .btn.secondary{\n      background:#f3f6fb;\n      color:#042b55;\n      border:1px solid rgba(4,43,85,0.06);\n    }\n    .mode-toggle{\n      display:flex;\n      gap:8px;\n    }\n    .mode-toggle button{\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid rgba(2,8,23,0.06);\n      background:white;\n      cursor:pointer;\n      flex:1;\n    }\n    .mode-toggle button.active{\n      background:linear-gradient(180deg,#0b74de,#0960b8);\n      color:white;\n      border-color:transparent;\n    }\n    .legend{\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n    .swatch{\n      width:14px;height:14px;border-radius:12px;\n      display:inline-block;\n    }\n\n    /* Right: canvas area */\n    .canvas-card{\n      background:white;\n      border-radius:var(--card-radius);\n      padding:12px;\n      box-shadow:var(--shadow);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      min-height:360px;\n    }\n    .toolbar{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content:space-between;\n    }\n\n    .canvas-wrap{\n      position:relative;\n      flex:1;\n      min-height:420px;\n      border-radius:8px;\n      overflow:hidden;\n      background:linear-gradient(180deg,#ffffff,#f7fbff);\n      border:1px solid rgba(2,8,23,0.04);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n    }\n\n    canvas{\n      width:100%;\n      height:100%;\n      display:block;\n      touch-action:none;\n    }\n\n    /* Info pill */\n    .info-pill{\n      display:inline-flex;\n      align-items:center;\n      gap:10px;\n      padding:8px 12px;\n      border-radius:999px;\n      background:rgba(8,12,23,0.04);\n      font-weight:600;\n    }\n\n    .stat-block{\n      display:flex;\n      flex-direction:column;\n      gap:6px;\n    }\n    .stat-value{\n      font-size:18px;\n      font-weight:700;\n    }\n    .muted-small{color:var(--muted);font-size:13px}\n\n    /* Point highlighting pulse animation */\n    @keyframes pulse {\n      0%{ box-shadow:0 0 0 0 rgba(11,74,222,0.35) }\n      70%{ box-shadow:0 0 0 10px rgba(11,74,222,0) }\n      100%{ box-shadow:0 0 0 0 rgba(11,74,222,0) }\n    }\n\n    /* Footer instructions */\n    .instructions{\n      font-size:13px;\n      color:var(--muted);\n      line-height:1.4;\n    }\n\n    /* Accessibility focus */\n    button:focus, input:focus{\n      outline:3px solid rgba(11,116,222,0.18);\n      outline-offset:3px;\n    }\n\n    /* ensure spacing minimum */\n    .panel > * { margin-bottom: 0; }\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"application\" aria-label=\"K-Nearest Neighbors interactive module\">\n    <!-- Left column: Title, objectives, controls -->\n    <aside class=\"panel\" aria-labelledby=\"module-title\">\n      <div>\n        <h1 id=\"module-title\">K-Nearest Neighbors (KNN) — Interactive Explorer</h1>\n        <p class=\"muted\">Experiment with labeled points, K, and distance metrics to observe how KNN classifies a query.</p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"objective-heading\">\n        <strong id=\"objective-heading\">Learning Objective</strong>\n        <p class=\"muted\">\n          After interacting you should understand how the number of neighbors (K), the distance metric,\n          and weighting affect classification decisions and local decision boundaries in KNN.\n        </p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"interaction-heading\">\n        <strong id=\"interaction-heading\">Interaction Design</strong>\n        <p class=\"muted\">\n          - Click on the canvas to add training points for Class A (blue) or Class B (red).<br>\n          - Place the query point by selecting \"Place Query\" then clicking the canvas (black ring).<br>\n          - Drag points to move them. Click a point and press Delete to remove it.<br>\n          - Adjust K with the slider, switch distance metric, and toggle inverse-distance weighting.<br>\n          - Press \"Animate Neighbors\" to visually step through nearest neighbors (animated highlight),\n            then see the predicted class and class probabilities.\n        </p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"layout-heading\">\n        <strong id=\"layout-heading\">Layout Description</strong>\n        <p class=\"muted\">\n          The module uses a two-column responsive layout: controls and explanations on the left (fixed,\n          360px minimum), and an interactive canvas on the right. Safe margins of 24px are applied to the viewport,\n          and 16px minimum spacing is used between interactive elements to maintain clarity. Controls are grouped\n          and keyboard-accessible; the canvas is responsive and supports pointer and touch input.\n        </p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"controls-heading\">\n        <strong id=\"controls-heading\">Controls</strong>\n        <div class=\"controls\" role=\"region\" aria-label=\"KNN controls\">\n          <div>\n            <label for=\"kRange\">K (neighbors): <span id=\"kValue\">3</span></label>\n            <input id=\"kRange\" type=\"range\" min=\"1\" max=\"25\" value=\"3\" />\n          </div>\n\n          <div class=\"row\">\n            <div style=\"flex:1\">\n              <label for=\"metric\">Distance Metric</label>\n              <select id=\"metric\" style=\"width:100%;padding:8px;border-radius:8px;\">\n                <option value=\"euclidean\">Euclidean (L2)</option>\n                <option value=\"manhattan\">Manhattan (L1)</option>\n              </select>\n            </div>\n            <div style=\"min-width:140px\">\n              <label for=\"weighted\">Weighted</label>\n              <div style=\"display:flex;align-items:center;gap:8px;\">\n                <input id=\"weighted\" type=\"checkbox\" />\n                <span class=\"muted-small\">Inverse-distance weighting</span>\n              </div>\n            </div>\n          </div>\n\n          <div>\n            <label>Mode</label>\n            <div class=\"mode-toggle\" role=\"tablist\" aria-label=\"mode selection\">\n              <button id=\"modeA\" class=\"active\" aria-pressed=\"true\">Place Class A</button>\n              <button id=\"modeB\" aria-pressed=\"false\">Place Class B</button>\n              <button id=\"modeQ\" aria-pressed=\"false\">Place Query</button>\n              <button id=\"modeMove\" aria-pressed=\"false\">Move / Delete</button>\n            </div>\n          </div>\n\n          <div class=\"row\" style=\"justify-content:space-between;\">\n            <button id=\"animateBtn\" class=\"btn secondary\" aria-live=\"polite\">Animate Neighbors</button>\n            <button id=\"clearBtn\" class=\"btn\">Clear All</button>\n          </div>\n\n          <div class=\"legend\" aria-hidden=\"false\">\n            <span class=\"swatch\" style=\"background:#2b7de9\"></span><span class=\"muted-small\">Class A</span>\n            <span class=\"swatch\" style=\"background:#e04e4e\"></span><span class=\"muted-small\">Class B</span>\n            <span style=\"width:8px;\"></span>\n            <span class=\"muted-small\">Tip: Click a point then press Delete to remove it.</span>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"section\" aria-label=\"instructions\">\n        <strong>Quick Tips</strong>\n        <p class=\"instructions\">\n          Add a few points for each class, then place the query. Try small and large K values to see how local vs.\n          global structure affects classification. Use Manhattan metric to see axis-aligned influence.\n        </p>\n      </div>\n    </aside>\n\n    <!-- Right column: Interactive canvas -->\n    <main class=\"canvas-card\" aria-labelledby=\"canvas-heading\">\n      <div class=\"toolbar\">\n        <div style=\"display:flex;gap:12px;align-items:center;\">\n          <div class=\"info-pill\" aria-hidden=\"true\">\n            <span id=\"predictedBadge\" style=\"width:12px;height:12px;border-radius:999px;display:inline-block;background:#999;\"></span>\n            <div style=\"display:flex;flex-direction:column;line-height:1\">\n              <span style=\"font-weight:700\" id=\"predictionText\">No query</span>\n              <span class=\"muted-small\" id=\"probText\"></span>\n            </div>\n          </div>\n        </div>\n\n        <div style=\"display:flex;gap:12px;align-items:center\">\n          <div class=\"stat-block\" aria-live=\"polite\">\n            <span class=\"muted-small\">Class A</span>\n            <span class=\"stat-value\" id=\"countA\">0</span>\n          </div>\n          <div class=\"stat-block\" aria-live=\"polite\">\n            <span class=\"muted-small\">Class B</span>\n            <span class=\"stat-value\" id=\"countB\">0</span>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"canvas-wrap\" id=\"canvasWrap\">\n        <canvas id=\"plotCanvas\" role=\"img\" aria-label=\"KNN plot area\"></canvas>\n      </div>\n\n      <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n        <div class=\"muted-small\">Canvas interactions: click to add, drag to move, select Move mode to edit.</div>\n        <div class=\"muted-small\">Decision surface approximated for visualization only.</div>\n      </div>\n    </main>\n  </div>\n\n  <script>\n    /**************************************************\n     * K-Nearest Neighbors Interactive Module\n     * Self-contained: vanilla JS, CSS, HTML.\n     *\n     * Features:\n     * - Add/drag/remove training points (Class A / B).\n     * - Place query point.\n     * - Adjust K, metric (Euclidean/Manhattan), weighted/inverse-distance.\n     * - Animated neighbor highlighting.\n     * - Decision surface shading (grid approximation).\n     *\n     * Accessibility:\n     * - Controls keyboard focusable; button states indicate active mode.\n     **************************************************/\n\n    (function(){\n      // DOM elements\n      const canvas = document.getElementById('plotCanvas');\n      const wrap = document.getElementById('canvasWrap');\n      const kRange = document.getElementById('kRange');\n      const kValue = document.getElementById('kValue');\n      const metricSelect = document.getElementById('metric');\n      const weightedCheckbox = document.getElementById('weighted');\n      const modeButtons = {\n        A: document.getElementById('modeA'),\n        B: document.getElementById('modeB'),\n        Q: document.getElementById('modeQ'),\n        Move: document.getElementById('modeMove')\n      };\n      const animateBtn = document.getElementById('animateBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const countA = document.getElementById('countA');\n      const countB = document.getElementById('countB');\n      const predictionText = document.getElementById('predictionText');\n      const probText = document.getElementById('probText');\n      const predictedBadge = document.getElementById('predictedBadge');\n\n      // Canvas context and sizing\n      const ctx = canvas.getContext('2d', { alpha: false });\n\n      function resizeCanvas(){\n        const rect = wrap.getBoundingClientRect();\n        // Use devicePixelRatio for crispness\n        const dpr = Math.max(window.devicePixelRatio || 1, 1);\n        canvas.width = Math.floor(rect.width * dpr);\n        canvas.height = Math.floor(rect.height * dpr);\n        canvas.style.width = rect.width + 'px';\n        canvas.style.height = rect.height + 'px';\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        draw();\n      }\n      window.addEventListener('resize', resizeCanvas);\n      // initial resize after DOM loaded\n      setTimeout(resizeCanvas, 50);\n\n      // Data model\n      let points = []; // {x:0..1, y:0..1, label: 'A'|'B'}\n      let query = null; // {x,y}\n      let mode = 'A'; // A/B/Q/Move\n      let dragging = null; // {type:'point'|'query', idx}\n      let highlightedNeighbors = []; // indices of neighbors currently highlighted during animation\n      let animating = false;\n\n      // Styling\n      const styles = {\n        A: '#2b7de9',\n        B: '#e04e4e',\n        queryStroke: '#111827',\n        gridSteps: 60, // decision surface resolution\n        pointRadius: 8,\n        queryRadius: 10\n      };\n\n      // Utility: convert canvas pixel to normalized coordinates (0..1)\n      function toNorm(px, py){\n        const r = canvas.getBoundingClientRect();\n        // use CSS width/height for pointer coordinates\n        const cw = r.width;\n        const ch = r.height;\n        return { x: Math.min(1, Math.max(0, px / cw)), y: Math.min(1, Math.max(0, 1 - py / ch)) };\n      }\n      function fromNorm(nx, ny){\n        const r = canvas.getBoundingClientRect();\n        const cw = r.width;\n        const ch = r.height;\n        return { x: nx * cw, y: (1 - ny) * ch };\n      }\n\n      // Distance metrics\n      function distance(a, b, metric){\n        if(metric === 'manhattan'){\n          return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n        }\n        // euclidean\n        const dx = a.x - b.x, dy = a.y - b.y;\n        return Math.sqrt(dx*dx + dy*dy);\n      }\n\n      // Core KNN prediction\n      function knnPredict(pt, K, metric, weighted){\n        if(points.length === 0) return null;\n        // compute distances\n        const dists = points.map((p, i) => ({i, label: p.label, d: distance(pt, p, metric)}));\n        dists.sort((a,b) => a.d - b.d);\n        const kNeighbors = dists.slice(0, Math.min(K, dists.length));\n        // handle zero distance (exact overlap) -> immediate class\n        const zero = kNeighbors.find(n => n.d === 0);\n        if(zero) {\n          return {pred: zero.label, prob: (zero.label === 'A') ? 1 : 0, neighbors: kNeighbors, raw: kNeighbors};\n        }\n        // aggregate\n        let scoreA = 0, scoreB = 0;\n        for(const n of kNeighbors){\n          const w = weighted ? 1 / (n.d + 1e-6) : 1;\n          if(n.label === 'A') scoreA += w; else scoreB += w;\n        }\n        const total = scoreA + scoreB;\n        const probA = total === 0 ? 0.5 : scoreA / total;\n        const pred = probA >= 0.5 ? 'A' : 'B';\n        return { pred, prob: probA, neighbors: kNeighbors, raw: kNeighbors };\n      }\n\n      // Drawing utilities\n      function clearCanvas(){\n        ctx.fillStyle = '#ffffff';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n      }\n\n      function drawDecisionSurface(){\n        // approximate classification at grid points and shade background\n        const steps = styles.gridSteps;\n        const {width, height} = canvas.getBoundingClientRect();\n        const cellW = width / steps;\n        const cellH = height / steps;\n        const metric = metricSelect.value;\n        const weighted = weightedCheckbox.checked;\n        if(points.length === 0 || !query) {\n          // lighten surface only if there are points\n          if(points.length === 0) return;\n        }\n        // For performance, draw rectangles directly\n        for(let xi=0; xi<steps; xi++){\n          for(let yi=0; yi<steps; yi++){\n            const nx = (xi + 0.5) / steps;\n            const ny = (yi + 0.5) / steps;\n            const pred = knnPredict({x:nx,y:ny}, parseInt(kRange.value,10), metric, weighted);\n            let color;\n            if(!pred) color = 'rgba(220,220,220,0.02)';\n            else {\n              const a = Math.abs(pred.prob - 0.5) * 0.6 + 0.15; // opacity based on confidence\n              if(pred.pred === 'A') color = `rgba(43,125,233,${a})`;\n              else color = `rgba(224,78,78,${a})`;\n            }\n            ctx.fillStyle = color;\n            ctx.fillRect(Math.round(xi*cellW), Math.round(yi*cellH), Math.ceil(cellW)+1, Math.ceil(cellH)+1);\n          }\n        }\n      }\n\n      function drawPoints(){\n        // draw training points\n        const r = canvas.getBoundingClientRect();\n        for(let i=0;i<points.length;i++){\n          const p = points[i];\n          const screen = fromNorm(p.x, p.y);\n          // shadow\n          ctx.beginPath();\n          ctx.fillStyle = 'rgba(0,0,0,0.06)';\n          ctx.arc(screen.x+1, screen.y+2, styles.pointRadius+1.2, 0, Math.PI*2);\n          ctx.fill();\n\n          // fill\n          ctx.beginPath();\n          ctx.fillStyle = (p.label === 'A') ? styles.A : styles.B;\n          ctx.arc(screen.x, screen.y, styles.pointRadius, 0, Math.PI*2);\n          ctx.fill();\n\n          // border for selected neighbor highlight\n          if(highlightedNeighbors.includes(i)){\n            ctx.beginPath();\n            ctx.lineWidth = 3;\n            ctx.strokeStyle = 'rgba(255,255,255,0.9)';\n            ctx.arc(screen.x, screen.y, styles.pointRadius+3, 0, Math.PI*2);\n            ctx.stroke();\n            // colored ring\n            ctx.beginPath();\n            ctx.lineWidth = 2;\n            ctx.strokeStyle = 'rgba(255,255,255,0.0)';\n            ctx.arc(screen.x, screen.y, styles.pointRadius+6, 0, Math.PI*2);\n            ctx.stroke();\n            // subtle external ring matching class\n            ctx.beginPath();\n            ctx.lineWidth = 4;\n            ctx.strokeStyle = 'rgba(11,116,222,0.18)';\n            ctx.arc(screen.x, screen.y, styles.pointRadius+8, 0, Math.PI*2);\n            ctx.stroke();\n          }\n        }\n        // draw query\n        if(query){\n          const qScreen = fromNorm(query.x, query.y);\n          // outer ring\n          ctx.beginPath();\n          ctx.lineWidth = 3;\n          ctx.strokeStyle = styles.queryStroke;\n          ctx.arc(qScreen.x, qScreen.y, styles.queryRadius, 0, Math.PI*2);\n          ctx.stroke();\n\n          // inner hollow\n          ctx.beginPath();\n          ctx.fillStyle = '#ffffff';\n          ctx.arc(qScreen.x, qScreen.y, styles.queryRadius-4, 0, Math.PI*2);\n          ctx.fill();\n        }\n      }\n\n      function drawNeighborsOverlay(neighborList){\n        // visually connect query to neighbors with lines\n        if(!query || !neighborList || neighborList.length===0) return;\n        const qScreen = fromNorm(query.x, query.y);\n        ctx.save();\n        ctx.globalAlpha = 0.9;\n        neighborList.forEach((n, idx) => {\n          const p = points[n.i];\n          const pScreen = fromNorm(p.x, p.y);\n          // line\n          ctx.beginPath();\n          ctx.moveTo(qScreen.x, qScreen.y);\n          ctx.lineTo(pScreen.x, pScreen.y);\n          ctx.lineWidth = 2;\n          ctx.strokeStyle = (p.label==='A') ? 'rgba(43,125,233,0.9)' : 'rgba(224,78,78,0.9)';\n          ctx.stroke();\n\n          // neighbor index label\n          ctx.fillStyle = '#ffffff';\n          ctx.strokeStyle = 'rgba(0,0,0,0.08)';\n          ctx.lineWidth = 1;\n          ctx.beginPath();\n          ctx.arc(pScreen.x, pScreen.y-18, 10, 0, Math.PI*2);\n          ctx.fill();\n          ctx.stroke();\n          ctx.fillStyle = '#0b1120';\n          ctx.font = '11px sans-serif';\n          ctx.textAlign = 'center';\n          ctx.textBaseline = 'middle';\n          ctx.fillText(String(idx+1), pScreen.x, pScreen.y-18);\n        });\n        ctx.restore();\n      }\n\n      function draw(){\n        clearCanvas();\n        // draw decision surface first\n        drawDecisionSurface();\n        // then points & overlays\n        drawPoints();\n        // draw neighbor connections if query exists\n        if(query){\n          const pred = knnPredict(query, parseInt(kRange.value,10), metricSelect.value, weightedCheckbox.checked);\n          if(pred && pred.neighbors){\n            drawNeighborsOverlay(pred.neighbors.slice(0, highlightedNeighbors.length));\n          }\n        }\n        // update stats UI\n        updateStatsUI();\n      }\n\n      // Update counts and prediction text\n      function updateStatsUI(){\n        const aCount = points.filter(p => p.label === 'A').length;\n        const bCount = points.filter(p => p.label === 'B').length;\n        countA.textContent = aCount;\n        countB.textContent = bCount;\n\n        if(query){\n          const pred = knnPredict(query, parseInt(kRange.value,10), metricSelect.value, weightedCheckbox.checked);\n          if(pred){\n            predictionText.textContent = `Predicted: Class ${pred.pred}`;\n            pred.prob = pred.prob !== undefined ? pred.prob : (pred.pred === 'A' ? 1 : 0);\n            probText.textContent = `P(A) = ${(pred.prob*100).toFixed(1)}%`;\n            predictedBadge.style.background = pred.pred === 'A' ? styles.A : styles.B;\n          } else {\n            predictionText.textContent = 'No prediction';\n            probText.textContent = '';\n            predictedBadge.style.background = '#999';\n          }\n        } else {\n          predictionText.textContent = 'No query';\n          probText.textContent = '';\n          predictedBadge.style.background = '#999';\n        }\n      }\n\n      // Interaction handlers\n      function setMode(newMode){\n        mode = newMode;\n        // update button visuals and aria-pressed\n        Object.entries(modeButtons).forEach(([k,btn])=>{\n          if(k === newMode) { btn.classList.add('active'); btn.setAttribute('aria-pressed','true'); }\n          else { btn.classList.remove('active'); btn.setAttribute('aria-pressed','false'); }\n        });\n      }\n\n      // pointer events\n      let isPointerDown = false;\n      canvas.addEventListener('pointerdown', (ev) => {\n        ev.preventDefault();\n        const rect = canvas.getBoundingClientRect();\n        const x = ev.clientX - rect.left;\n        const y = ev.clientY - rect.top;\n        const norm = toNorm(x, y);\n\n        if(mode === 'A' || mode === 'B'){\n          // add training point of selected label\n          points.push({x: norm.x, y: norm.y, label: mode});\n          highlightedNeighbors = [];\n          draw();\n          isPointerDown = false;\n        } else if(mode === 'Q'){\n          // place query\n          query = {x: norm.x, y: norm.y};\n          highlightedNeighbors = [];\n          draw();\n        } else if(mode === 'Move'){\n          // find nearest point within radius or query\n          const pick = pickPointAt(norm);\n          if(pick){\n            dragging = pick;\n            isPointerDown = true;\n          } else {\n            // perhaps picking the query\n            if(query){\n              const qDist = distance(norm, query, 'euclidean');\n              const qThresh = 0.04;\n              if(qDist < qThresh){\n                dragging = { type: 'query' };\n                isPointerDown = true;\n              }\n            }\n          }\n        }\n      });\n\n      canvas.addEventListener('pointermove', (ev) => {\n        if(!isPointerDown || !dragging) return;\n        ev.preventDefault();\n        const rect = canvas.getBoundingClientRect();\n        const x = ev.clientX - rect.left;\n        const y = ev.clientY - rect.top;\n        const norm = toNorm(x, y);\n        if(dragging.type === 'point'){\n          points[dragging.idx].x = norm.x;\n          points[dragging.idx].y = norm.y;\n          draw();\n        } else if(dragging.type === 'query'){\n          query.x = norm.x;\n          query.y = norm.y;\n          draw();\n        }\n      });\n\n      window.addEventListener('pointerup', (ev) => {\n        if(isPointerDown) {\n          isPointerDown = false;\n          dragging = null;\n        }\n      });\n\n      // pick nearest training point within threshold\n      function pickPointAt(norm) {\n        let nearest = null;\n        let bestD = 1e9;\n        for(let i=0;i<points.length;i++){\n          const d = distance(norm, points[i], 'euclidean');\n          if(d < bestD){\n            nearest = i; bestD = d;\n          }\n        }\n        // threshold in normalized coords (approx)\n        if(bestD < 0.03) return { type: 'point', idx: nearest };\n        return null;\n      }\n\n      // allow clicking on a point to select then delete with Delete key\n      canvas.addEventListener('click', (ev) => {\n        if(mode !== 'Move') return;\n        const rect = canvas.getBoundingClientRect();\n        const x = ev.clientX - rect.left;\n        const y = ev.clientY - rect.top;\n        const norm = toNorm(x, y);\n        const picked = pickPointAt(norm);\n        if(picked){\n          // toggle selection by setting dragging to that point temporarily\n          dragging = picked;\n          draw();\n        } else {\n          dragging = null;\n        }\n      });\n\n      window.addEventListener('keydown', (ev) => {\n        if(ev.key === 'Delete' || ev.key === 'Backspace'){\n          if(dragging && dragging.type === 'point'){\n            // remove point\n            points.splice(dragging.idx, 1);\n            dragging = null;\n            draw();\n          }\n        }\n      });\n\n      // control events\n      kRange.addEventListener('input', () => {\n        kValue.textContent = kRange.value;\n        highlightedNeighbors = [];\n        draw();\n      });\n      metricSelect.addEventListener('change', () => { highlightedNeighbors = []; draw(); });\n      weightedCheckbox.addEventListener('change', () => { highlightedNeighbors = []; draw(); });\n\n      Object.entries(modeButtons).forEach(([k,btn])=>{\n        btn.addEventListener('click', ()=> setMode(k));\n      });\n\n      clearBtn.addEventListener('click', ()=>{\n        points = [];\n        query = null;\n        highlightedNeighbors = [];\n        draw();\n      });\n\n      animateBtn.addEventListener('click', async ()=>{\n        if(animating) return;\n        if(!query || points.length===0) return;\n        animating = true;\n        const K = Math.min(parseInt(kRange.value,10), points.length);\n        const metric = metricSelect.value;\n        const weighted = weightedCheckbox.checked;\n        const pred = knnPredict(query, K, metric, weighted);\n        if(!pred) { animating=false; return; }\n        highlightedNeighbors = [];\n        draw();\n        // sequentially highlight neighbors\n        for(let i=0;i<pred.neighbors.length;i++){\n          highlightedNeighbors.push(pred.neighbors[i].i);\n          draw();\n          // animate pause (shorter for larger K)\n          await new Promise(r => setTimeout(r, 350));\n        }\n        // final highlight stays\n        animating = false;\n        // set UI to reflect final prediction\n        updateStatsUI();\n      });\n\n      // initial sample points for exploration\n      function seedPoints(){\n        points = [\n          {x:0.18,y:0.78,label:'A'},\n          {x:0.22,y:0.62,label:'A'},\n          {x:0.14,y:0.48,label:'A'},\n          {x:0.3,y:0.35,label:'A'},\n          {x:0.7,y:0.25,label:'B'},\n          {x:0.81,y:0.42,label:'B'},\n          {x:0.6,y:0.6,label:'B'},\n          {x:0.78,y:0.78,label:'B'}\n        ];\n        query = {x:0.5, y:0.5};\n        draw();\n      }\n      seedPoints();\n\n      // expose draw on demand\n      window.addEventListener('resize', () => { highlightedNeighbors=[]; draw(); });\n\n      // initial UI states\n      setMode('A');\n      kValue.textContent = kRange.value;\n      updateStatsUI();\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of K-Nearest Neighbors (KNN).\n\n**Project Overview:**\nTopic: K-Nearest Neighbors (KNN)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "K-Nearest Neighbors (KNN)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "KNN Interactive Module",
      "description": "Finite state machine modeling user interactions for the K-Nearest Neighbors interactive canvas (modes, adding points, placing query, moving/draging/deleting points, animation, and control changes).",
      "states": [
        {
          "name": "mode_A",
          "onEnter": "updateModeUI",
          "onExit": "noop",
          "on": {
            "MODE_SELECT_B": "mode_B",
            "MODE_SELECT_Q": "mode_Q",
            "MODE_SELECT_MOVE": "mode_Move",
            "CANVAS_CLICK": "add_point",
            "ANIMATE_START": "animating",
            "CLEAR_ALL": "cleared",
            "K_CHANGE": "mode_A",
            "METRIC_CHANGE": "mode_A",
            "WEIGHTED_TOGGLE": "mode_A",
            "RESIZE": "mode_A"
          }
        },
        {
          "name": "mode_B",
          "onEnter": "updateModeUI",
          "onExit": "noop",
          "on": {
            "MODE_SELECT_A": "mode_A",
            "MODE_SELECT_Q": "mode_Q",
            "MODE_SELECT_MOVE": "mode_Move",
            "CANVAS_CLICK": "add_point",
            "ANIMATE_START": "animating",
            "CLEAR_ALL": "cleared",
            "K_CHANGE": "mode_B",
            "METRIC_CHANGE": "mode_B",
            "WEIGHTED_TOGGLE": "mode_B",
            "RESIZE": "mode_B"
          }
        },
        {
          "name": "mode_Q",
          "onEnter": "updateModeUI",
          "onExit": "noop",
          "on": {
            "MODE_SELECT_A": "mode_A",
            "MODE_SELECT_B": "mode_B",
            "MODE_SELECT_MOVE": "mode_Move",
            "CANVAS_CLICK": "place_query",
            "ANIMATE_START": "animating",
            "CLEAR_ALL": "cleared",
            "K_CHANGE": "mode_Q",
            "METRIC_CHANGE": "mode_Q",
            "WEIGHTED_TOGGLE": "mode_Q",
            "RESIZE": "mode_Q"
          }
        },
        {
          "name": "mode_Move",
          "onEnter": "updateModeUI",
          "onExit": "noop",
          "on": {
            "MODE_SELECT_A": "mode_A",
            "MODE_SELECT_B": "mode_B",
            "MODE_SELECT_Q": "mode_Q",
            "CANVAS_POINTER_DOWN_POINT": "dragging_point",
            "CANVAS_CLICK_POINT": "selected_point",
            "CANVAS_POINTER_DOWN_QUERY": "dragging_query",
            "ANIMATE_START": "animating",
            "CLEAR_ALL": "cleared",
            "K_CHANGE": "mode_Move",
            "METRIC_CHANGE": "mode_Move",
            "WEIGHTED_TOGGLE": "mode_Move",
            "RESIZE": "mode_Move"
          }
        },
        {
          "name": "add_point",
          "onEnter": "addTrainingPoint",
          "onExit": "draw",
          "on": {
            "POINT_ADDED": "mode_A",
            "POINT_ADDED_TO_B": "mode_B",
            "CANCEL": "mode_A",
            "RESIZE": "mode_A"
          }
        },
        {
          "name": "place_query",
          "onEnter": "placeQueryPoint",
          "onExit": "draw",
          "on": {
            "QUERY_PLACED": "mode_Q",
            "CANCEL": "mode_Q",
            "RESIZE": "mode_Q"
          }
        },
        {
          "name": "selected_point",
          "onEnter": "selectPoint",
          "onExit": "noop",
          "on": {
            "DELETE_KEY": "delete_point",
            "POINTER_DOWN": "dragging_point",
            "CANCEL": "mode_Move",
            "RESIZE": "mode_Move"
          }
        },
        {
          "name": "delete_point",
          "onEnter": "deleteSelectedPoint",
          "onExit": "draw",
          "on": {
            "POINT_DELETED": "mode_Move",
            "RESIZE": "mode_Move"
          }
        },
        {
          "name": "dragging_point",
          "onEnter": "startDraggingPoint",
          "onExit": "stopDraggingPoint",
          "on": {
            "POINTER_MOVE": "dragging_point",
            "POINTER_UP": "mode_Move",
            "DELETE_KEY": "delete_point",
            "RESIZE": "mode_Move"
          }
        },
        {
          "name": "dragging_query",
          "onEnter": "startDraggingQuery",
          "onExit": "stopDraggingQuery",
          "on": {
            "POINTER_MOVE": "dragging_query",
            "POINTER_UP": "mode_Move",
            "RESIZE": "mode_Move"
          }
        },
        {
          "name": "animating",
          "onEnter": "startAnimation",
          "onExit": "stopAnimation",
          "on": {
            "ANIMATION_STEP": "animating",
            "ANIMATION_END": "idle",
            "MODE_SELECT_A": "mode_A",
            "MODE_SELECT_B": "mode_B",
            "MODE_SELECT_Q": "mode_Q",
            "MODE_SELECT_MOVE": "mode_Move",
            "CLEAR_ALL": "cleared",
            "RESIZE": "animating"
          }
        },
        {
          "name": "cleared",
          "onEnter": "clearAll",
          "onExit": "draw",
          "on": {
            "CLEARED": "idle",
            "MODE_SELECT_A": "mode_A",
            "MODE_SELECT_B": "mode_B",
            "MODE_SELECT_Q": "mode_Q",
            "MODE_SELECT_MOVE": "mode_Move",
            "RESIZE": "idle"
          }
        },
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "MODE_SELECT_A": "mode_A",
            "MODE_SELECT_B": "mode_B",
            "MODE_SELECT_Q": "mode_Q",
            "MODE_SELECT_MOVE": "mode_Move",
            "ANIMATE_START": "animating",
            "CLEAR_ALL": "cleared",
            "RESIZE": "idle"
          }
        }
      ],
      "events": [
        "MODE_SELECT_A",
        "MODE_SELECT_B",
        "MODE_SELECT_Q",
        "MODE_SELECT_MOVE",
        "CANVAS_CLICK",
        "CANVAS_CLICK_POINT",
        "CANVAS_POINTER_DOWN_POINT",
        "CANVAS_POINTER_DOWN_QUERY",
        "CANVAS_CLICK_QUERY",
        "POINTER_DOWN",
        "POINTER_MOVE",
        "POINTER_UP",
        "POINTER_MOVE_RAW",
        "K_CHANGE",
        "METRIC_CHANGE",
        "WEIGHTED_TOGGLE",
        "ANIMATE_START",
        "ANIMATION_STEP",
        "ANIMATION_END",
        "CLEAR_ALL",
        "DELETE_KEY",
        "POINT_ADDED",
        "POINT_ADDED_TO_B",
        "QUERY_PLACED",
        "POINT_DELETED",
        "CANCEL",
        "RESIZE",
        "DRAW_REQUEST"
      ],
      "notes": "This FSM models UI modes (Place Class A/B, Place Query, Move/Delete), transient actions (add_point, place_query, delete_point), drag interactions (dragging_point, dragging_query), and the animation sequence (animating). Transient states (add_point, place_query, delete_point) perform onEnter actions and then return to a mode. 'idle' is a neutral non-animating state. Events like CANVAS_CLICK_POINT vs CANVAS_CLICK are used to differentiate clicks on an existing training point, the query, or empty canvas. Some transitions are intentionally simplified (ANIMATION_END returns to 'idle'), representing returning to a settled non-animating UI; implementations track the current mode context to resume the precise mode when needed."
    }
  }
]