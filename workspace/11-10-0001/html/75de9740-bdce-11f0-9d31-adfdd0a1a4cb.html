<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Set — Interactive Module (Sets & Operations)</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg:#f6f8fb;
      --card:#ffffff;
      --accentA:#4f83ff;
      --accentB:#ff7a59;
      --accentResult:#56c596;
      --text:#0b2140;
      --muted:#5b6b7a;
      --token-size:48px;
      --circle-radius:160px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:var(--safe-margin);
    }

    /* Layout */
    .module{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      min-height:520px;
    }
    /* Responsive: stack on narrow screens */
    @media (max-width:980px){
      .module{flex-direction:column}
    }

    /* Left column (controls + overview) */
    .col{
      background:var(--card);
      border-radius:12px;
      padding:16px;
      box-shadow:0 6px 18px rgba(10,25,50,0.06);
    }
    .left{
      flex:0 0 320px;
      min-width:260px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      padding:20px;
    }
    .main{
      flex:1;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }
    .right{
      flex:0 0 320px;
      min-width:260px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      padding:20px;
    }

    h1{font-size:18px;margin:0 0 8px 0}
    .muted{color:var(--muted);font-size:13px}
    .card-title{display:flex;align-items:center;justify-content:space-between;gap:8px}

    /* Input palette */
    .add-row{display:flex;gap:8px;align-items:center}
    input[type="text"]{
      flex:1;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid #d9e2ef;
      font-size:14px;
      outline:none;
    }
    .btn{
      background:linear-gradient(180deg,#ffffff,#eef4ff);
      border:1px solid #d0ddff;
      padding:8px 12px;
      border-radius:8px;
      font-weight:600;
      cursor:pointer;
      color:var(--text);
      min-width:72px;
    }
    .btn:active{transform:translateY(1px)}
    .small{padding:6px 8px;font-size:13px}

    .instructions{
      font-size:13px;
      color:var(--muted);
      line-height:1.4;
      padding:10px;
      background:#fbfdff;
      border-radius:8px;
      border:1px solid #eef6ff;
    }

    /* Venn diagram container */
    .venn-wrap{
      position:relative;
      width:100%;
      max-width:720px;
      height:420px;
      min-height:320px;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }
    .venn{
      position:relative;
      width:100%;
      height:100%;
      max-width:680px;
      max-height:380px;
      min-width:320px;
      min-height:260px;
      margin:auto;
    }
    svg.venn-svg{width:100%;height:100%;overflow:visible}

    /* Labels for sets */
    .set-label{
      position:absolute;
      font-weight:700;
      font-size:14px;
      color:rgba(255,255,255,0.95);
      padding:6px 10px;
      border-radius:20px;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .label-A{background:linear-gradient(180deg,var(--accentA),#2d63d6)}
    .label-B{background:linear-gradient(180deg,var(--accentB),#e65a40)}

    /* Tokens (elements) */
    .token{
      position:absolute;
      width:var(--token-size);
      height:var(--token-size);
      border-radius:10px;
      background:#fff;
      border:2px solid rgba(8,22,48,0.06);
      box-shadow:0 6px 16px rgba(8,22,48,0.08);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      cursor:grab;
      user-select:none;
      transition:transform 300ms cubic-bezier(.2,.9,.2,1), box-shadow 200ms;
      z-index:3;
    }
    .token:active{cursor:grabbing; transform:scale(0.98)}
    .token.small{width:40px;height:40px;font-size:13px}
    .token.badgeA{border-color:rgba(79,131,255,0.9)}
    .token.badgeB{border-color:rgba(255,122,89,0.95)}
    .token.badgeAB{border-image:linear-gradient(90deg,var(--accentA),var(--accentB)) 1 0 0 0; border-style:solid}
    .token.outside{opacity:0.88}

    /* Counters */
    .counters{display:flex;gap:12px;flex-wrap:wrap;font-size:13px;color:var(--muted)}
    .counter{
      background:#fbfdff;border:1px solid #eef6ff;padding:8px 10px;border-radius:10px;
      display:flex;gap:8px;align-items:center;
    }
    .counter .dot{width:10px;height:10px;border-radius:50%}

    /* Controls and result area on right */
    .ops{display:flex;flex-wrap:wrap;gap:10px}
    .ops .btn{background:#fff;border:1px solid #dfeaf7}
    .result{
      margin-top:6px;
      padding:12px;
      background:linear-gradient(180deg,#ffffff,#fbfffb);
      border:1px solid #e8f7ee;
      border-radius:8px;
      min-height:72px;
    }
    .result .items{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .result .items .token{position:static;transform:none;box-shadow:none;cursor:default}

    /* Anim move layer */
    .move-layer{
      position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:60;
    }

    /* Footer small text sections */
    .meta{font-size:13px;color:var(--muted);line-height:1.45}
    .section{background:#fff;padding:12px;border-radius:8px;border:1px solid #eef4ff}
    .kbd{display:inline-block;padding:4px 6px;border-radius:6px;background:#f3f6fb;border:1px solid #e7eefc;font-weight:600;font-size:13px}

    /* Accessibility focus */
    .token:focus{outline:3px solid rgba(80,120,245,0.18);box-shadow:0 6px 16px rgba(37,71,251,0.08)}
    .btn:focus{outline:3px solid rgba(37,71,251,0.12)}
  </style>
</head>
<body>
  <div class="module" role="application" aria-labelledby="title">
    <!-- LEFT: Title, objectives, controls -->
    <aside class="col left" aria-label="Module controls and overview">
      <div>
        <div class="card-title">
          <div>
            <h1 id="title">Set — Interactive: visualizing set membership & operations</h1>
            <div class="muted">Explore sets A and B by placing elements, then apply set operations.</div>
          </div>
          <div class="muted" style="text-align:right;font-size:12px">Safe margins: 24px</div>
        </div>
      </div>

      <div class="section">
        <strong>Learning objective</strong>
        <div class="muted" style="margin-top:8px">
          After interacting you'll be able to:
          - Visually interpret membership of elements in A, B, and A∩B.
          - Predict outcomes of union, intersection and differences.
          - See how operations manipulate element membership.
        </div>
      </div>

      <div class="section">
        <strong>Add elements</strong>
        <div style="margin-top:8px">
          <form id="addForm" class="add-row" onsubmit="return false;" aria-label="Add element form">
            <input id="elemInput" type="text" aria-label="Element label" placeholder="Label (e.g. 1 or x)" maxlength="6"/>
            <button id="addBtn" class="btn" type="button">Add</button>
          </form>
          <div style="margin-top:10px" class="muted">Click token to cycle membership: Outside → A → B → A∩B → Outside. You can also drag tokens into circles. Keyboard: tab to token and press Space to cycle.</div>
        </div>
      </div>

      <div class="section" aria-hidden="false">
        <strong>Interaction design</strong>
        <div class="muted" style="margin-top:8px">
          - Drag tokens into circle regions (A or B) to change membership. Release to snap into region. Animation shows membership change.<br>
          - Click or press Space on a token to cycle its region (accessible alternative to drag).<br>
          - Use operation buttons (Union, Intersection, A−B, B−A, Symmetric) to animate the result set into the Result area.<br>
          - Add new labels by typing and pressing Add or Enter.
        </div>
      </div>
    </aside>

    <!-- MAIN: Venn diagram -->
    <main class="col main" aria-label="Interactive venn diagram area">
      <div class="venn-wrap" id="vennWrap">
        <div class="venn" id="venn" tabindex="0" aria-label="Venn diagram with two sets A and B">
          <svg class="venn-svg" id="svg" viewBox="0 0 800 480" preserveAspectRatio="xMidYMid meet" aria-hidden="true">
            <!-- Circle A -->
            <defs>
              <filter id="soft" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="10" />
              </filter>
            </defs>
            <g id="circles" transform="translate(40,40)">
              <circle id="circleA" cx="260" cy="200" r="160" fill="rgba(79,131,255,0.14)" stroke="rgba(79,131,255,0.3)" stroke-width="2"/>
              <circle id="circleB" cx="420" cy="200" r="160" fill="rgba(255,122,89,0.12)" stroke="rgba(255,122,89,0.28)" stroke-width="2"/>
              <!-- subtle intersection highlight -->
              <path id="intersectionPath" d="" fill="rgba(140,160,220,0.12)" stroke="none"/>
            </g>
          </svg>

          <!-- set labels -->
          <div class="set-label label-A" id="labelA" style="left:110px; top:18px;">A</div>
          <div class="set-label label-B" id="labelB" style="left:470px; top:18px;">B</div>

          <!-- counters -->
          <div style="position:absolute; left:8px; bottom:12px;">
            <div class="counters" role="status" aria-live="polite">
              <div class="counter"><div class="dot" style="background:var(--accentA)"></div> A: <span id="countA" style="margin-left:6px;font-weight:700">0</span></div>
              <div class="counter"><div class="dot" style="background:var(--accentB)"></div> B: <span id="countB" style="margin-left:6px;font-weight:700">0</span></div>
              <div class="counter"><div class="dot" style="background:var(--accentResult)"></div> A∩B: <span id="countAB" style="margin-left:6px;font-weight:700">0</span></div>
              <div class="counter"><div class="dot" style="background:#bfc7d9"></div> Outside: <span id="countOut" style="margin-left:6px;font-weight:700">0</span></div>
            </div>
          </div>

          <!-- tokens will be appended here -->
          <div id="tokensLayer" style="position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:auto"></div>

          <!-- move layer for animations -->
          <div class="move-layer" id="moveLayer" aria-hidden="true"></div>
        </div>
      </div>
    </main>

    <!-- RIGHT: operations and result -->
    <aside class="col right" aria-label="Operations and result">
      <div class="section">
        <strong>Set operations</strong>
        <div class="muted" style="margin-top:8px">Apply an operation to see which elements belong to the resulting set.</div>
        <div class="ops" style="margin-top:12px">
          <button class="btn small" data-op="union" id="opUnion">Union (A ∪ B)</button>
          <button class="btn small" data-op="inter" id="opInter">Intersection (A ∩ B)</button>
          <button class="btn small" data-op="adiff" id="opADiff">A − B</button>
          <button class="btn small" data-op="bdiff" id="opBDiff">B − A</button>
          <button class="btn small" data-op="sym" id="opSym">Symmetric</button>
          <button class="btn small" id="opClear">Clear Result</button>
        </div>
      </div>

      <div class="section">
        <strong>Result</strong>
        <div class="result" id="resultArea" aria-live="polite" aria-atomic="true">
          <div class="muted" style="margin-bottom:8px">Animated result elements:</div>
          <div class="items" id="resultItems"></div>
        </div>
      </div>

      <div class="section">
        <strong>Quick actions</strong>
        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
          <button class="btn small" id="randomFill">Random sample</button>
          <button class="btn small" id="resetAll">Reset</button>
        </div>
        <div class="muted" style="margin-top:8px">Tip: Use Random sample to populate tokens for experimentation.</div>
      </div>

      <div class="meta" style="margin-top:8px">
        <strong>Layout description</strong>
        <div class="muted" style="margin-top:6px">
          The module uses a three-column responsive layout: left controls & instructions, center Venn diagram workspace, right operations & results. Safe area margin 24px and minimum spacing 16px are enforced. Interactive tokens are reachable by keyboard and screen readers are supported via ARIA attributes.
        </div>
      </div>
    </aside>
  </div>

  <script>
    // Self-contained interactive Venn diagram set module
    (function(){
      // Constants & DOM refs
      const venn = document.getElementById('venn');
      const svg = document.getElementById('svg');
      const circleA = document.getElementById('circleA');
      const circleB = document.getElementById('circleB');
      const tokensLayer = document.getElementById('tokensLayer');
      const moveLayer = document.getElementById('moveLayer');
      const resultItems = document.getElementById('resultItems');
      const countA = document.getElementById('countA');
      const countB = document.getElementById('countB');
      const countAB = document.getElementById('countAB');
      const countOut = document.getElementById('countOut');

      const addForm = document.getElementById('addForm');
      const elemInput = document.getElementById('elemInput');
      const addBtn = document.getElementById('addBtn');
      const opButtons = document.querySelectorAll('[data-op]');
      const opClear = document.getElementById('opClear');
      const randomFill = document.getElementById('randomFill');
      const resetAll = document.getElementById('resetAll');

      // state
      let tokens = []; // {id, label, el, membership:{inA:bool,inB:bool}}
      let idCounter = 1;

      // For responsive circle geometry, compute current circle centers & radii in pixels relative to venn
      function getCircleGeom() {
        const svgRect = svg.getBoundingClientRect();
        // circle elements have cx/cy/r from viewBox coords; viewBox offset (0,0) then translate(40,40) used in group
        // we will read cx,cy,r and transform them using the svg bounding box scale
        const vb = svg.viewBox.baseVal; // 0 0 800 480
        const scaleX = svgRect.width / vb.width;
        const scaleY = svgRect.height / vb.height;
        // group transform translates by (40,40) -- that was in the markup
        const groupOffsetX = 40 * scaleX;
        const groupOffsetY = 40 * scaleY;

        const cxA = parseFloat(circleA.getAttribute('cx')) * scaleX + groupOffsetX + svgRect.left;
        const cyA = parseFloat(circleA.getAttribute('cy')) * scaleY + groupOffsetY + svgRect.top;
        const rA  = parseFloat(circleA.getAttribute('r')) * ((scaleX+scaleY)/2);

        const cxB = parseFloat(circleB.getAttribute('cx')) * scaleX + groupOffsetX + svgRect.left;
        const cyB = parseFloat(circleB.getAttribute('cy')) * scaleY + groupOffsetY + svgRect.top;
        const rB  = parseFloat(circleB.getAttribute('r')) * ((scaleX+scaleY)/2);

        // Also compute local positions for placing tokens inside the venn container (relative coordinates)
        const vennRect = venn.getBoundingClientRect();
        const localA = {
          cx: cxA - vennRect.left,
          cy: cyA - vennRect.top,
          r: rA
        };
        const localB = {
          cx: cxB - vennRect.left,
          cy: cyB - vennRect.top,
          r: rB
        };
        return {A: localA, B: localB, svgRect, vennRect};
      }

      // Helper for membership test: whether a point (relative to venn container) is inside circle
      function pointInCircle(px, py, circle){
        const dx = px - circle.cx;
        const dy = py - circle.cy;
        return (dx*dx + dy*dy) <= (circle.r*circle.r);
      }

      // Create token element and initial placement (outside)
      function createToken(label, initialPos){
        const t = document.createElement('div');
        const id = 't' + (idCounter++);
        t.className = 'token outside';
        t.setAttribute('role','button');
        t.setAttribute('tabindex','0');
        t.setAttribute('aria-pressed','false');
        t.setAttribute('data-id', id);
        t.textContent = label;
        // initial position relative to venn
        const rect = venn.getBoundingClientRect();
        const x = (initialPos && initialPos.x) || (20 + Math.random()*(rect.width-80));
        const y = (initialPos && initialPos.y) || (rect.height*0.7 - 24 + Math.random()*40);
        t.style.left = x + 'px';
        t.style.top = y + 'px';

        // token state
        const state = {id, label, el: t, membership:{inA:false,inB:false}};

        // interactions: drag, click/keyboard to cycle
        makeDraggable(t, state);
        t.addEventListener('click', (e)=>{ e.preventDefault(); cycleMembership(state); });
        t.addEventListener('keydown', (e)=>{ if(e.key === ' ' || e.key === 'Enter'){ e.preventDefault(); cycleMembership(state); }});

        tokensLayer.appendChild(t);
        tokens.push(state);
        updateVisual(state);
        updateCounts();
        return state;
      }

      // Update token visual classes based on membership
      function updateVisual(state){
        const el = state.el;
        el.classList.remove('badgeA','badgeB','badgeAB','outside');
        const inA = state.membership.inA;
        const inB = state.membership.inB;
        if(inA && inB){ el.classList.add('badgeAB'); el.style.borderColor = ''; }
        else if(inA){ el.classList.add('badgeA'); }
        else if(inB){ el.classList.add('badgeB'); }
        else { el.classList.add('outside'); }
        el.setAttribute('aria-label', `Element ${state.label}. In A: ${inA ? 'yes' : 'no'}. In B: ${inB ? 'yes' : 'no'}.`);
      }

      // Cycle membership states: outside -> A -> B -> A∩B -> outside
      function cycleMembership(state){
        const s = state.membership;
        if(!s.inA && !s.inB){ s.inA=true; s.inB=false; }
        else if(s.inA && !s.inB){ s.inA=false; s.inB=true; }
        else if(!s.inA && s.inB){ s.inA=true; s.inB=true; }
        else { s.inA=false; s.inB=false; }
        // Snap token to appropriate region visually
        snapTokenToRegion(state);
        updateVisual(state);
        updateCounts();
      }

      // Snap token position to the chosen region (center-ish) with small random offset
      function snapTokenToRegion(state){
        const geom = getCircleGeom();
        const el = state.el;
        const rect = venn.getBoundingClientRect();
        let targetX = parseFloat(el.style.left);
        let targetY = parseFloat(el.style.top);
        const margin = 16;

        if(state.membership.inA && state.membership.inB){
          // intersection: midpoint between centers
          const cx = (geom.A.cx + geom.B.cx)/2;
          const cy = (geom.A.cy + geom.B.cy)/2;
          targetX = cx - rect.left + (Math.random()-0.5)*24;
          targetY = cy - rect.top + (Math.random()-0.5)*24;
        } else if(state.membership.inA){
          targetX = geom.A.cx - rect.left + (Math.random()-0.5)*(geom.A.r*0.4);
          targetY = geom.A.cy - rect.top + (Math.random()-0.5)*(geom.A.r*0.4);
        } else if(state.membership.inB){
          targetX = geom.B.cx - rect.left + (Math.random()-0.5)*(geom.B.r*0.4);
          targetY = geom.B.cy - rect.top + (Math.random()-0.5)*(geom.B.r*0.4);
        } else {
          // outside region (bottom-left area)
          targetX = 12 + (Math.random()*120);
          targetY = rect.height*0.72 + (Math.random()*24);
        }
        // animate move
        animateMove(el, targetX, targetY);
      }

      // Simple CSS transform-free animate by transitioning left/top (these are not GPU-accelerated but fine here)
      function animateMove(el, left, top, duration=240){
        el.style.transition = `left ${duration}ms cubic-bezier(.2,.9,.2,1), top ${duration}ms cubic-bezier(.2,.9,.2,1)`;
        requestAnimationFrame(()=>{
          el.style.left = left + 'px';
          el.style.top = top + 'px';
        });
        setTimeout(()=>{ el.style.transition = ''; }, duration+50);
      }

      // Update counts display
      function updateCounts(){
        let a=0,b=0,ab=0,out=0;
        tokens.forEach(t=>{
          const inA = t.membership.inA;
          const inB = t.membership.inB;
          if(inA && inB) { ab++; a++; b++; }
          else if(inA) { a++; }
          else if(inB) { b++; }
          else out++;
        });
        countA.textContent = a;
        countB.textContent = b;
        countAB.textContent = ab;
        countOut.textContent = out;
      }

      // Draggable implementation (pointer events)
      function makeDraggable(el, state){
        let dragging = false;
        let startX=0, startY=0, origLeft=0, origTop=0;
        el.addEventListener('pointerdown', (e)=>{
          if(e.button !== 0) return;
          el.setPointerCapture(e.pointerId);
          dragging = true;
          startX = e.clientX; startY = e.clientY;
          origLeft = parseFloat(el.style.left);
          origTop = parseFloat(el.style.top);
          el.style.transition = ''; // cancel snap transition
          el.style.zIndex = 100;
          el.style.boxShadow = '0 10px 26px rgba(8,22,48,0.12)';
        });
        window.addEventListener('pointermove', (e)=>{
          if(!dragging) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          el.style.left = (origLeft + dx) + 'px';
          el.style.top = (origTop + dy) + 'px';
        });
        window.addEventListener('pointerup', (e)=>{
          if(!dragging) return;
          dragging=false;
          el.releasePointerCapture(e.pointerId);
          el.style.zIndex = '';
          el.style.boxShadow = '';
          // determine membership by testing center point
          const rect = el.getBoundingClientRect();
          const centerX = rect.left + rect.width/2;
          const centerY = rect.top + rect.height/2;
          const geom = getCircleGeom();
          const inA = pointInCircle(centerX - geom.vennRect.left, centerY - geom.vennRect.top, geom.A);
          const inB = pointInCircle(centerX - geom.vennRect.left, centerY - geom.vennRect.top, geom.B);
          state.membership.inA = !!inA;
          state.membership.inB = !!inB;
          updateVisual(state);
          // snap into region slightly to improve look
          snapTokenToRegion(state);
          updateCounts();
        });
      }

      // Result animation: move copies of elements into result area
      function showResult(setElements){
        // clear previous
        resultItems.innerHTML = '';
        // for each token in result, create a small duplicate and animate from token to result container
        const resultRect = resultItems.getBoundingClientRect();
        setElements.forEach((t, i)=>{
          const srcRect = t.el.getBoundingClientRect();
          const clone = t.el.cloneNode(true);
          clone.style.position='absolute';
          clone.style.margin='0';
          clone.style.left = srcRect.left + 'px';
          clone.style.top  = srcRect.top + 'px';
          clone.style.width = srcRect.width + 'px';
          clone.style.height = srcRect.height + 'px';
          clone.style.transform = 'none';
          clone.style.transition = 'transform 520ms cubic-bezier(.2,.9,.2,1), left 520ms, top 520ms, opacity 360ms';
          moveLayer.appendChild(clone);

          // destination position inside result area
          const destX = resultRect.left + 12 + ((i % 6) * (parseFloat(getComputedStyle(clone).width) + 10));
          const destY = resultRect.top + 28 + (Math.floor(i/6) * (parseFloat(getComputedStyle(clone).height) + 10));

          // animate using left/top
          requestAnimationFrame(()=>{
            clone.style.left = destX + 'px';
            clone.style.top = destY + 'px';
            clone.style.opacity = '0.98';
            clone.style.transform = 'scale(0.92)';
          });

          // when animation ends, append a static small token into resultItems and remove clone
          setTimeout(()=>{
            const small = document.createElement('div');
            small.className = 'token small';
            small.textContent = t.label;
            small.setAttribute('aria-hidden','true');
            resultItems.appendChild(small);
            clone.remove();
          }, 560 + (i*30));
        });
      }

      // Compute element sets for operations
      function computeOperation(op){
        const selection = [];
        tokens.forEach(t=>{
          const a = t.membership.inA;
          const b = t.membership.inB;
          let take=false;
          switch(op){
            case 'union': take = a || b; break;
            case 'inter': take = a && b; break;
            case 'adiff': take = a && !b; break;
            case 'bdiff': take = b && !a; break;
            case 'sym': take = (a || b) && !(a && b); break;
            default: break;
          }
          if(take) selection.push(t);
        });
        return selection;
      }

      // Wire up add form
      addBtn.addEventListener('click', ()=>{
        const val = elemInput.value.trim();
        if(!val) return;
        createToken(val);
        elemInput.value='';
        elemInput.focus();
      });
      elemInput.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){ e.preventDefault(); addBtn.click(); }
      });

      // Operation buttons
      opButtons.forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const op = btn.dataset.op;
          const result = computeOperation(op);
          showResult(result);
        });
      });
      opClear.addEventListener('click', ()=>{ resultItems.innerHTML=''; });

      // Random sample populate
      randomFill.addEventListener('click', ()=>{
        // create 7 tokens, random membership
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        for(let i=0;i<7;i++){
          const label = chars.charAt(Math.floor(Math.random()*chars.length));
          const t = createToken(label);
          t.membership.inA = Math.random()<0.5;
          t.membership.inB = Math.random()<0.5;
          updateVisual(t);
          snapTokenToRegion(t);
        }
        updateCounts();
      });

      // Reset
      resetAll.addEventListener('click', ()=>{
        tokens.forEach(t=>{ if(t.el) t.el.remove(); });
        tokens = [];
        resultItems.innerHTML = '';
        updateCounts();
      });

      // Initialize intersection path (for a subtle highlight)
      function updateIntersectionPath(){
        // We'll compute intersection area path using simple circle intersection approximation by SVG arc commands
        // For visual only, we compute midpoint and draw an ellipse-like shape between intersecting area
        const vb = svg.viewBox.baseVal;
        const scaleX = svg.getBoundingClientRect().width / vb.width;
        const scaleY = svg.getBoundingClientRect().height / vb.height;
        const groupOffsetX = 40 * scaleX;
        const groupOffsetY = 40 * scaleY;
        const cxA = parseFloat(circleA.getAttribute('cx')) * scaleX + groupOffsetX;
        const cyA = parseFloat(circleA.getAttribute('cy')) * scaleY + groupOffsetY;
        const rA  = parseFloat(circleA.getAttribute('r')) * ((scaleX+scaleY)/2);
        const cxB = parseFloat(circleB.getAttribute('cx')) * scaleX + groupOffsetX;
        const cyB = parseFloat(circleB.getAttribute('cy')) * scaleY + groupOffsetY;
        const rB  = parseFloat(circleB.getAttribute('r')) * ((scaleX+scaleY)/2);

        // if not intersecting, hide
        const d = Math.hypot(cxB-cxA, cyB-cyA);
        const path = document.getElementById('intersectionPath');
        if(d > rA + rB){ path.setAttribute('d',''); return; }
        // draw simple ellipse at midpoint sized proportionally
        const mx = (cxA+cxB)/2;
        const my = (cyA+cyB)/2;
        const rx = Math.min(120, Math.max(40, (rA + rB - d)/2 + 20));
        const ry = Math.min(60, Math.max(24, rx * 0.6));
        const dstr = `M ${mx-rx} ${my} a ${rx} ${ry} 0 1 0 ${2*rx} 0 a ${rx} ${ry} 0 1 0 ${-2*rx} 0`;
        path.setAttribute('d', dstr);
      }

      // Handle resize to recompute geometry & reposition tokens that have membership
      function onResize(){
        updateIntersectionPath();
        tokens.forEach(t=>{
          // reposition tokens if they are within A/B to snap properly
          if(t.membership.inA || t.membership.inB) snapTokenToRegion(t);
        });
      }
      window.addEventListener('resize', ()=>{ setTimeout(onResize,60); });
      window.addEventListener('orientationchange', ()=>{ setTimeout(onResize,120); });

      // Initial sample tokens
      ['1','2','3','x','y'].forEach(l=>createToken(l));
      onResize();

      // Expose small debug (optional)
      window._setModule = { tokens, createToken, computeOperation };

    })();
  </script>
</body>
</html>