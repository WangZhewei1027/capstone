<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Breadth-First Search (BFS) Interactive</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --control-width: 340px;
      --bg: #0f1724;
      --panel: #071028;
      --accent: #06b6d4;
      --muted: #9aa5b1;
      --node-size: 36px;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071028 0%, #08172a 60%);
      color:#e6eef6;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .wrap{
      padding: var(--safe-margin);
      box-sizing:border-box;
      min-height:100%;
      display:flex;
      gap: var(--gap);
    }
    /* Responsive columns: left controls, right canvas */
    .left {
      width: var(--control-width);
      min-width: 280px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:16px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
      display:flex;
      flex-direction:column;
      gap:16px;
      align-self:stretch;
    }
    .title {
      margin:0;
      font-size:18px;
      font-weight:600;
      color: #e7f8ff;
    }
    .subtitle{
      margin:0;
      font-size:13px;
      color: var(--muted);
    }
    .controls {
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .row {
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    button, select, input[type="range"]{
      background:rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.04);
      color:var(--muted);
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
    }
    button:hover { border-color: rgba(255,255,255,0.08); color:#e8f6ff; }
    .btn-primary{
      background: linear-gradient(90deg,#06b6d4, #7c3aed);
      color:white;
      border: none;
      box-shadow: 0 6px 18px rgba(7,18,28,0.6);
    }
    .toggle {
      display:flex;
      gap:8px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
    }
    .small {
      font-size:12px;
      color:var(--muted);
    }
    .canvas-wrap{
      flex:1;
      min-width:0;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:12px;
      padding:12px;
      position:relative;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .svg-area{
      flex:1;
      position:relative;
      border-radius:10px;
      background:
        radial-gradient(800px 400px at 10% 10%, rgba(6,182,212,0.03), transparent 2%),
        linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.02));
      overflow:hidden;
    }
    svg{ width:100%; height:100%; display:block; }
    .hint{
      font-size:12px;
      color:var(--muted);
    }
    .pane{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .chip {
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.03);
      padding:6px 8px;
      border-radius:999px;
      font-size:13px;
      color:var(--muted);
    }
    .queue {
      display:flex;
      gap:8px;
      align-items:center;
      min-height:42px;
      padding:6px;
      border-radius:8px;
      background: rgba(255,255,255,0.015);
      border:1px dashed rgba(255,255,255,0.02);
      overflow-x:auto;
    }
    .queue .node-chip {
      min-width:36px;
      height:36px;
      border-radius:9px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      color:#071428;
      font-weight:700;
      transition: transform 250ms ease, opacity 220ms ease;
      background: #ffd966;
      box-shadow: 0 8px 18px rgba(0,0,0,0.4);
    }
    .visited-list {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .status {
      font-size:12px;
      color:var(--muted);
    }

    /* Node / edge visuals */
    .node {
      cursor:pointer;
      transition: transform 200ms ease;
    }
    .node-circle {
      fill: #94a3b8; /* neutral */
      stroke: rgba(255,255,255,0.06);
      stroke-width:1.5;
      transition: fill 300ms ease, r 200ms ease, filter 220ms ease;
    }
    .label {
      fill:#071428;
      font-size:13px;
      font-weight:700;
      pointer-events:none;
      user-select:none;
    }
    .edge {
      stroke: rgba(255,255,255,0.06);
      stroke-width:2;
      transition: stroke 220ms ease, stroke-width 120ms ease, opacity 200ms ease;
    }

    /* States */
    .state-unvisited .node-circle{ fill:#94a3b8; }
    .state-queued .node-circle{ fill: #ffd966; }
    .state-current .node-circle{ fill: #60a5fa; filter: drop-shadow(0 6px 14px rgba(96,165,250,0.12)); }
    .state-visited .node-circle{ fill: #34d399; }

    .edge-traverse { stroke: #fb923c; stroke-width:4px; }

    /* Node pulsing while queued */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.08); }
      100% { transform: scale(1); }
    }
    .state-queued .node-circle { animation: pulse 1200ms ease-in-out infinite; transform-origin:center; }

    /* small responsive tweaks */
    @media (max-width: 880px){
      .wrap { flex-direction:column; padding:18px; }
      .left { width:100%; min-width:0; order:1; }
      .canvas-wrap { order:2; min-height:420px; }
    }
    /* subtle scrollbar style for queue */
    .queue::-webkit-scrollbar { height:8px; }
    .queue::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.04); border-radius:6px; }
    /* accessibility focus */
    button:focus, select:focus { outline: 2px solid rgba(6,182,212,0.16); outline-offset:2px; }
    .sr { position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden; }
  </style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Breadth First Search interactive module">
    <aside class="left" aria-labelledby="title">
      <div>
        <h1 id="title" class="title">Breadth-First Search (BFS)</h1>
        <p class="subtitle">Explore BFS visually: build graphs, then step through how BFS expands nodes level-by-level.</p>
      </div>

      <div class="controls" role="region" aria-label="Controls">
        <div>
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div class="small">Graph Editing</div>
            <div class="small hint">Click canvas to add nodes</div>
          </div>
          <div class="row" style="margin-top:8px;">
            <button id="btn-rand" title="Generate a small random graph">Random Graph</button>
            <button id="btn-clear" title="Clear all nodes and edges">Clear</button>
            <label class="toggle" title="Toggle edge creation mode">
              <input id="toggle-edge" type="checkbox" aria-label="Toggle add edge mode" />
              <span class="small">Add Edge</span>
            </label>
          </div>
        </div>

        <div>
          <div class="small">BFS Controls</div>
          <div class="row" style="margin-top:8px;">
            <select id="start-select" aria-label="Start node for BFS">
              <option value="">Select start node</option>
            </select>
            <button id="btn-run" class="btn-primary">Run BFS</button>
          </div>
          <div class="row" style="margin-top:8px;">
            <button id="btn-play">Play</button>
            <button id="btn-step">Step</button>
            <button id="btn-reset">Reset</button>
            <div style="display:flex;align-items:center;gap:8px;">
              <input id="speed" type="range" min="200" max="1600" step="100" value="700" aria-label="Animation speed" />
            </div>
          </div>
          <div style="margin-top:8px;" class="status" id="action-status">Status: idle</div>
        </div>

        <div>
          <div class="small">Queue (Frontier)</div>
          <div class="queue" id="queue" aria-live="polite" aria-atomic="true"></div>
        </div>

        <div>
          <div class="small">Visited (with distances)</div>
          <div class="visited-list" id="visited"></div>
        </div>

        <div class="hint" style="margin-top:8px">
          Tips: Use "Add Edge" then click two nodes to connect them. Drag nodes to rearrange. Press Delete after selecting a node to remove it.
        </div>
      </div>
    </aside>

    <main class="canvas-wrap">
      <div class="svg-area" id="canvas-area" role="region" aria-label="Graph drawing area">
        <svg id="svg" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid meet" tabindex="0" aria-label="Graph visualization">
          <!-- edges and nodes are drawn here -->
        </svg>
      </div>
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div class="small hint">Click the canvas to add nodes. Toggle "Add Edge" to connect nodes.</div>
        <div class="small hint">Nodes animate color: queued → current → visited.</div>
      </div>
    </main>
  </div>

  <script>
    (function(){
      // Basic graph data
      let nodes = []; // {id,label,x,y}
      let edges = []; // {id, a, b}
      let nodeCounter = 0;

      // UI elements
      const svg = document.getElementById('svg');
      const queueEl = document.getElementById('queue');
      const visitedEl = document.getElementById('visited');
      const startSelect = document.getElementById('start-select');
      const btnRand = document.getElementById('btn-rand');
      const btnClear = document.getElementById('btn-clear');
      const toggleEdge = document.getElementById('toggle-edge');
      const btnRun = document.getElementById('btn-run');
      const btnPlay = document.getElementById('btn-play');
      const btnStep = document.getElementById('btn-step');
      const btnReset = document.getElementById('btn-reset');
      const speedInput = document.getElementById('speed');
      const actionStatus = document.getElementById('action-status');

      // Animation / BFS state
      let animScript = []; // sequence of actions for animation
      let animIndex = 0;
      let animTimer = null;
      let isPlaying = false;
      let selectedNodeId = null; // for edge creation or selection
      let focusedNodeId = null; // for deletion
      let dragState = null;

      // Utility
      function genLabel(i){
        // Label A, B, C... then AA, AB...
        let s = '';
        i += 1;
        while(i > 0){
          i--; s = String.fromCharCode(65 + (i % 26)) + s;
          i = Math.floor(i / 26);
        }
        return s;
      }
      function getNodeById(id){ return nodes.find(n=>n.id===id); }
      function getNodeIndex(id){ return nodes.findIndex(n=>n.id===id); }
      function addNodeAt(x,y){
        const id = 'n'+(++nodeCounter);
        const label = genLabel(nodes.length);
        nodes.push({id,label,x,y});
        render();
      }
      function addEdge(a,b){
        if(a===b) return;
        // avoid duplicate undirected edges
        const exists = edges.some(e => (e.a===a&&e.b===b) || (e.a===b&&e.b===a));
        if(!exists){
          edges.push({id:'e'+(edges.length+1), a, b});
          render();
        }
      }
      function removeNode(id){
        nodes = nodes.filter(n=>n.id!==id);
        edges = edges.filter(e=>e.a!==id && e.b!==id);
        render();
      }
      function clearGraph(){
        nodes = []; edges = []; nodeCounter = 0;
        resetAnimation();
        render();
      }

      // SVG rendering
      function render(){
        // update start-select
        const prev = startSelect.value;
        startSelect.innerHTML = '<option value="">Select start node</option>';
        nodes.forEach(n=>{
          const opt = document.createElement('option');
          opt.value = n.id; opt.textContent = n.label;
          startSelect.appendChild(opt);
        });
        if(nodes.some(n=>n.id===prev)) startSelect.value = prev;

        // clear svg
        while(svg.firstChild) svg.removeChild(svg.firstChild);

        // adapt viewBox to container size
        const vbW = 1200, vbH = 800;
        svg.setAttribute('viewBox', `0 0 ${vbW} ${vbH}`);

        // draw edges first
        edges.forEach(e=>{
          const a = getNodeById(e.a), b = getNodeById(e.b);
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', a.x);
          line.setAttribute('y1', a.y);
          line.setAttribute('x2', b.x);
          line.setAttribute('y2', b.y);
          line.setAttribute('class','edge');
          line.setAttribute('data-id', e.id);
          g.appendChild(line);
          svg.appendChild(g);
        });

        // draw nodes on top
        nodes.forEach(n=>{
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('class', 'node state-unvisited');
          g.setAttribute('transform', `translate(${n.x},${n.y})`);
          g.setAttribute('data-id', n.id);
          g.setAttribute('tabindex', 0);
          g.setAttribute('role', 'button');
          g.setAttribute('aria-label', `Node ${n.label}`);

          // circle
          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('r', 18);
          c.setAttribute('class','node-circle');
          g.appendChild(c);

          // label background (small rounded rect via rect)
          const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
          rect.setAttribute('x', -16);
          rect.setAttribute('y', -10);
          rect.setAttribute('width', 32);
          rect.setAttribute('height', 20);
          rect.setAttribute('rx', 6);
          rect.setAttribute('fill', 'transparent');
          rect.setAttribute('pointer-events', 'none');
          // append rect after circle to keep it below text
          // label text
          const t = document.createElementNS('http://www.w3.org/2000/svg','text');
          t.setAttribute('class','label');
          t.setAttribute('x',0);
          t.setAttribute('y',5);
          t.setAttribute('text-anchor','middle');
          t.textContent = n.label;

          g.appendChild(t);

          // events
          g.addEventListener('mousedown', onNodeMouseDown);
          g.addEventListener('click', onNodeClick);
          g.addEventListener('keydown', (ev)=>{
            if(ev.key === 'Delete'){ removeNode(n.id); }
          });

          svg.appendChild(g);
        });

        updateVisualStates();
      }

      // Update node/edge classes based on runtime states (visited/queued/current)
      let nodeState = {}; // id -> 'unvisited'|'queued'|'current'|'visited'
      let edgeState = {}; // id -> 'normal'|'traverse'

      function updateVisualStates(){
        // nodes
        nodes.forEach(n=>{
          const g = svg.querySelector(`g.node[data-id="${n.id}"]`);
          if(!g) return;
          const state = nodeState[n.id] || 'unvisited';
          g.classList.remove('state-unvisited','state-queued','state-current','state-visited');
          g.classList.add('state-'+state);
        });
        // edges
        edges.forEach(e=>{
          const line = svg.querySelector(`line[data-id="${e.id}"]`);
          if(!line) return;
          if(edgeState[e.id] === 'traverse'){
            line.classList.add('edge-traverse');
          } else {
            line.classList.remove('edge-traverse');
          }
        });
      }

      // Canvas events
      const canvasArea = document.getElementById('canvas-area');
      let svgPoint = function(x,y){
        // convert client coordinates to svg coords using viewBox mapping
        const rect = svg.getBoundingClientRect();
        const vb = svg.viewBox.baseVal;
        const scaleX = vb.width / rect.width;
        const scaleY = vb.height / rect.height;
        const vx = (x - rect.left) * scaleX + vb.x;
        const vy = (y - rect.top) * scaleY + vb.y;
        return {x: vx, y: vy};
      };

      svg.addEventListener('click', function(ev){
        // add node unless clicked on an existing node or in edge mode (in edge mode only click node to create edges)
        if(ev.target.closest('g.node')) return;
        const p = svgPoint(ev.clientX, ev.clientY);
        addNodeAt(p.x, p.y);
      });

      function onNodeClick(ev){
        ev.stopPropagation();
        const gid = this.getAttribute('data-id');
        // selection for edge creation
        if(toggleEdge.checked){
          if(!selectedNodeId){
            selectedNodeId = gid;
            highlightNode(gid, true);
            actionStatus.textContent = `Selected ${getNodeById(gid).label} as source. Click target to create edge.`;
          } else if(selectedNodeId === gid){
            // cancel
            highlightNode(gid, false);
            selectedNodeId = null;
            actionStatus.textContent = 'Edge selection canceled.';
          } else {
            addEdge(selectedNodeId, gid);
            highlightNode(selectedNodeId, false);
            actionStatus.textContent = `Edge created between ${getNodeById(selectedNodeId).label} and ${getNodeById(gid).label}.`;
            selectedNodeId = null;
          }
          return;
        }

        // Selection for deletion or focus
        focusedNodeId = gid;
        // toggle focus visual with a subtle transform
        const g = svg.querySelector(`g.node[data-id="${gid}"]`);
        if(g) {
          // briefly scale
          g.style.transform = 'scale(1.04)';
          setTimeout(()=> g.style.transform = '', 220);
        }
      }

      function highlightNode(id, on){
        const g = svg.querySelector(`g.node[data-id="${id}"]`);
        if(g){
          if(on) g.style.transform = 'scale(1.06)';
          else g.style.transform = '';
        }
      }

      // Dragging
      function onNodeMouseDown(ev){
        ev.stopPropagation();
        const g = this;
        const id = g.getAttribute('data-id');
        const startPoint = svgPoint(ev.clientX, ev.clientY);
        const node = getNodeById(id);
        dragState = {id, ox: node.x, oy: node.y, sx:startPoint.x, sy:startPoint.y, g};
        window.addEventListener('mousemove', onDrag);
        window.addEventListener('mouseup', endDrag);
      }
      function onDrag(ev){
        if(!dragState) return;
        const p = svgPoint(ev.clientX, ev.clientY);
        const dx = p.x - dragState.sx;
        const dy = p.y - dragState.sy;
        const node = getNodeById(dragState.id);
        node.x = dragState.ox + dx;
        node.y = dragState.oy + dy;
        // update transform
        dragState.g.setAttribute('transform', `translate(${node.x},${node.y})`);
        // update edges positions quickly by re-rendering edges only
        edges.forEach(e=>{
          const line = svg.querySelector(`line[data-id="${e.id}"]`);
          if(line){
            const a = getNodeById(e.a), b = getNodeById(e.b);
            line.setAttribute('x1', a.x);
            line.setAttribute('y1', a.y);
            line.setAttribute('x2', b.x);
            line.setAttribute('y2', b.y);
          }
        });
      }
      function endDrag(){
        window.removeEventListener('mousemove', onDrag);
        window.removeEventListener('mouseup', endDrag);
        dragState = null;
      }

      // Random graph generator
      btnRand.addEventListener('click', ()=>{
        clearGraph();
        const w = 1200, h = 800;
        const n = 7 + Math.floor(Math.random()*3);
        for(let i=0;i<n;i++){
          addNodeAt(150 + Math.random()*(w-300), 120 + Math.random()*(h-240));
        }
        // add some edges
        for(let i=0;i<n;i++){
          for(let j=i+1;j<n;j++){
            if(Math.random() < 0.22) addEdge(nodes[i].id, nodes[j].id);
          }
        }
        actionStatus.textContent = 'Random graph generated.';
      });

      // Clear
      btnClear.addEventListener('click', ()=> { clearGraph(); actionStatus.textContent='Graph cleared.'; });

      // Delete key for removing focused node
      window.addEventListener('keydown', (ev)=>{
        if(ev.key === 'Delete' && focusedNodeId){
          removeNode(focusedNodeId);
          focusedNodeId = null;
        }
      });

      // BFS algorithm: build script of actions for visual animation
      // Actions: {type:'enqueue',nodeId}, {type:'dequeue',nodeId}, {type:'visit',nodeId,dist}, {type:'edge',edgeId}
      function buildBFSScript(startId){
        const script = [];
        nodeState = {}; edgeState = {};
        nodes.forEach(n=>{ nodeState[n.id] = 'unvisited'; });
        edges.forEach(e=>{ edgeState[e.id] = 'normal'; });

        const q = [];
        const dist = {};
        q.push(startId);
        nodeState[startId] = 'queued';
        script.push({type:'enqueue', id:startId});
        dist[startId] = 0;

        while(q.length){
          const cur = q.shift();
          script.push({type:'dequeue', id:cur});
          script.push({type:'current', id:cur});
          // get neighbors (undirected)
          const neighbors = edges.reduce((acc,e)=>{
            if(e.a === cur) acc.push({id:e.b, edge:e.id});
            else if(e.b === cur) acc.push({id:e.a, edge:e.id});
            return acc;
          }, []);
          // sort neighbors by label to make deterministic
          neighbors.sort((A,B)=> {
            const la = getNodeById(A.id).label, lb = getNodeById(B.id).label;
            return la.localeCompare(lb);
          });
          neighbors.forEach(nbr => {
            // edge traversal highlight
            script.push({type:'edge', id:nbr.edge});
            if(nodeState[nbr.id] === 'unvisited'){
              nodeState[nbr.id] = 'queued';
              dist[nbr.id] = dist[cur] + 1;
              q.push(nbr.id);
              script.push({type:'enqueue', id:nbr.id});
            } else {
              // still show considered neighbor
              script.push({type:'considered', id:nbr.id});
            }
          });
          script.push({type:'visit', id:cur, dist:dist[cur]});
        }
        return script;
      }

      function resetAnimation(){
        if(animTimer) { clearInterval(animTimer); animTimer = null; }
        animScript = []; animIndex = 0; isPlaying = false;
        nodeState = {}; edgeState = {};
        nodes.forEach(n=> nodeState[n.id]='unvisited');
        edges.forEach(e=> edgeState[e.id]='normal');
        updateVisualStates();
        queueEl.innerHTML = '';
        visitedEl.innerHTML = '';
        actionStatus.textContent = 'Status: idle';
        btnPlay.textContent = 'Play';
      }

      function runBFS(){
        const startId = startSelect.value;
        if(!startId){ actionStatus.textContent = 'Choose a start node.'; return; }
        resetAnimation();
        animScript = buildBFSScript(startId);
        animIndex = 0;
        actionStatus.textContent = 'BFS script prepared. Step or Play to begin.';
      }

      // animate next action
      function stepAnimation(){
        if(!animScript || animIndex >= animScript.length){
          actionStatus.textContent = 'Finished.';
          isPlaying = false;
          btnPlay.textContent = 'Play';
          return;
        }
        const a = animScript[animIndex++];
        handleAction(a);
        updateVisualStates();
      }

      function handleAction(a){
        switch(a.type){
          case 'enqueue':
            nodeState[a.id] = 'queued';
            animateQueueEnqueue(a.id);
            actionStatus.textContent = `Enqueue ${getNodeById(a.id).label}`;
            break;
          case 'dequeue':
            // will be set to current after
            // remove from queue visualization
            animateQueueDequeue(a.id);
            actionStatus.textContent = `Dequeue ${getNodeById(a.id).label}`;
            break;
          case 'current':
            // mark current
            Object.keys(nodeState).forEach(k=>{
              if(nodeState[k] === 'current') nodeState[k] = 'visited'; // finalize previous current
            });
            nodeState[a.id] = 'current';
            actionStatus.textContent = `Expanding ${getNodeById(a.id).label}`;
            break;
          case 'edge':
            // highlight edge briefly
            edgeState[a.id] = 'traverse';
            actionStatus.textContent = `Considering edge ${a.id}`;
            // clear after short timeout
            setTimeout(()=>{ edgeState[a.id] = 'normal'; updateVisualStates(); }, Math.max(180, parseInt(speedInput.value)/2));
            break;
          case 'considered':
            // flash considered node briefly
            actionStatus.textContent = `Considered ${getNodeById(a.id).label}`;
            break;
          case 'visit':
            nodeState[a.id] = 'visited';
            // add to visited list with distance
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = `${getNodeById(a.id).label} (d=${a.dist})`;
            visitedEl.appendChild(chip);
            actionStatus.textContent = `Visited ${getNodeById(a.id).label} (distance ${a.dist})`;
            break;
        }
        // keep UI updated
        updateVisualStates();
      }

      // Queue visual helpers
      function animateQueueEnqueue(id){
        const node = getNodeById(id);
        const chip = document.createElement('div');
        chip.className = 'node-chip';
        chip.textContent = node.label;
        chip.setAttribute('data-id', id);
        chip.style.opacity = '0';
        chip.style.transform = 'translateY(-6px)';
        queueEl.appendChild(chip);
        // animate in
        requestAnimationFrame(()=> {
          chip.style.transition = 'transform 260ms ease, opacity 220ms ease';
          chip.style.opacity = '1';
          chip.style.transform = 'translateY(0)';
        });
      }
      function animateQueueDequeue(id){
        const chip = queueEl.querySelector(`.node-chip[data-id="${id}"]`);
        if(chip){
          chip.style.transition = 'transform 260ms ease, opacity 200ms ease';
          chip.style.transform = 'translateY(-8px) scale(0.9)';
          chip.style.opacity = '0';
          setTimeout(()=> chip.remove(), 260);
        }
      }

      // Play controls
      btnRun.addEventListener('click', runBFS);

      btnPlay.addEventListener('click', ()=>{
        if(!animScript || animScript.length === 0){ actionStatus.textContent = 'No BFS prepared. Click Run BFS first.'; return; }
        if(isPlaying){
          // pause
          isPlaying = false;
          if(animTimer){ clearInterval(animTimer); animTimer = null; }
          btnPlay.textContent = 'Play';
          actionStatus.textContent = 'Paused.';
        } else {
          // play
          isPlaying = true;
          btnPlay.textContent = 'Pause';
          const speed = parseInt(speedInput.value);
          animTimer = setInterval(()=> {
            if(animIndex >= animScript.length){
              clearInterval(animTimer); animTimer = null;
              isPlaying = false;
              btnPlay.textContent = 'Play';
              actionStatus.textContent = 'Finished.';
              return;
            }
            stepAnimation();
          }, speed);
          actionStatus.textContent = 'Playing...';
        }
      });
      btnStep.addEventListener('click', ()=>{
        if(!animScript || animScript.length === 0){ actionStatus.textContent = 'No BFS prepared. Click Run BFS first.'; return; }
        if(isPlaying){
          // if playing, step should pause
          isPlaying = false;
          if(animTimer){ clearInterval(animTimer); animTimer = null; }
          btnPlay.textContent = 'Play';
        }
        stepAnimation();
      });
      btnReset.addEventListener('click', ()=>{
        resetAnimation();
        actionStatus.textContent = 'Reset animation state.';
      });

      // initialize empty state
      resetAnimation();
      render();

      // keyboard: space to step when Run button focused
      btnStep.addEventListener('keydown', function(ev){
        if(ev.key === ' ' || ev.key === 'Enter') { ev.preventDefault(); stepAnimation(); }
      });

      // small accessibility: announce nodes added
      const live = document.createElement('div'); live.className='sr'; live.setAttribute('aria-live','polite'); document.body.appendChild(live);
      const origAddNode = addNodeAt;
      // override to announce (not strictly necessary; we will just set text when adding)
      // but we use actionStatus for feedback already.

    })();
  </script>
</body>
</html>