<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kruskal’s Algorithm — Interactive Module</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe-margin: 24px;
      --gap: 16px; /* Minimum spacing between interactive elements */
      --bg: #0f1720;
      --panel: #0b1220;
      --muted: #98a8b9;
      --accent: #60a5fa;
      --success: #22c55e;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.04);
      --font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html,body {
      height: 100%;
      margin: 0;
      padding: var(--safe-margin);
      background: linear-gradient(180deg, #05060a 0%, #071026 100%);
      color: #e6eef8;
      font-family: var(--font-family);
      box-sizing: border-box;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    * { box-sizing: inherit; }
    a { color: var(--accent); }

    header {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-width: 1200px;
      margin: 0 auto 16px;
    }

    h1 {
      margin: 0;
      font-size: 20px;
      letter-spacing: -0.2px;
    }

    .meta {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      color: var(--muted);
      font-size: 13px;
    }

    .container {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: var(--gap);
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Responsive: stack on small screens */
    @media (max-width: 900px) {
      .container {
        grid-template-columns: 1fr;
      }
    }

    /* Left: interactive canvas */
    .canvas-panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 10px;
      padding: 12px;
      min-height: 520px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: stretch;
    }

    .top-controls {
      display: flex;
      gap: var(--gap);
      align-items: center;
      flex-wrap: wrap;
    }

    .btn {
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.04);
      color: var(--accent);
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      min-height: 40px;
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    .btn.primary {
      background: linear-gradient(90deg, rgba(96,165,250,0.12), rgba(96,165,250,0.06));
      color: #d9f4ff;
      border: 1px solid rgba(96,165,250,0.18);
    }

    .btn.danger {
      color: #ffdfe1;
      border: 1px solid rgba(239,68,68,0.16);
      background: linear-gradient(90deg, rgba(239,68,68,0.06), rgba(239,68,68,0.02));
    }

    .btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .tools {
      display: flex;
      gap: var(--gap);
      align-items: center;
    }

    .info {
      color: var(--muted);
      font-size: 13px;
      padding: 8px 12px;
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
    }

    .stage {
      flex: 1;
      border-radius: 8px;
      background: radial-gradient(600px 200px at 10% 10%, rgba(96,165,250,0.02), transparent),
                  linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      position: relative;
      overflow: hidden;
      min-height: 420px;
    }

    /* SVG fills the stage */
    svg {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    .right-panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 10px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 520px;
    }

    h2 {
      margin: 0;
      font-size: 16px;
    }

    .section {
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .small {
      font-size: 13px;
      color: var(--muted);
    }

    .edge-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 200px;
      overflow: auto;
      padding-right: 8px;
    }

    .edge-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255,255,255,0.01);
      padding: 8px;
      border-radius: 6px;
      gap: 8px;
      font-size: 13px;
    }

    .edge-item span.weight {
      color: var(--muted);
      font-weight: 600;
      padding: 4px 8px;
      background: rgba(255,255,255,0.02);
      border-radius: 6px;
    }

    .status {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .chip {
      padding: 6px 8px;
      border-radius: 999px;
      font-size: 12px;
      background: rgba(255,255,255,0.02);
      color: var(--muted);
    }

    .sets {
      display: flex;
      gap: 8px;
      flex-direction: column;
      max-height: 180px;
      overflow: auto;
    }

    .set {
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      padding: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      font-size: 13px;
    }

    .legend {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .legend .box {
      width: 14px;
      height: 14px;
      border-radius: 4px;
    }

    /* Node styles (SVG) */
    .node {
      cursor: grab;
    }

    .node:active {
      cursor: grabbing;
    }

    .node circle {
      fill: rgba(255,255,255,0.04);
      stroke: rgba(255,255,255,0.06);
      stroke-width: 1.5px;
    }

    .node text {
      fill: #e6eef8;
      font-size: 12px;
      pointer-events: none;
    }

    /* Edge base */
    .edge {
      stroke: rgba(255,255,255,0.08);
      stroke-width: 3px;
      transition: stroke 200ms, stroke-width 200ms, opacity 200ms;
      stroke-linecap: round;
    }

    /* Edge states */
    .edge.highlight {
      stroke: #fbbf24; /* amber */
      stroke-width: 5px;
      filter: drop-shadow(0 4px 8px rgba(249,115,22,0.12));
    }

    .edge.accepted {
      stroke: var(--success);
      stroke-width: 5px;
      filter: drop-shadow(0 6px 12px rgba(34,197,94,0.12));
    }

    .edge.rejected {
      stroke: var(--danger);
      stroke-width: 4px;
      opacity: 0.75;
      filter: drop-shadow(0 4px 8px rgba(239,68,68,0.06));
    }

    .weight-label {
      font-size: 12px;
      fill: #e6eef8;
      pointer-events: none;
      background: transparent;
    }

    .muted-label {
      fill: var(--muted);
      font-size: 12px;
    }

    .node-merged circle {
      stroke-width: 2.5px;
      stroke: rgba(96,165,250,0.7);
    }

    footer {
      max-width: 1200px;
      margin: 12px auto 0;
      color: var(--muted);
      font-size: 13px;
    }

    /* small animations */
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.03); opacity: 0.95; }
      100% { transform: scale(1); opacity: 1; }
    }

    .pulse {
      animation: pulse 700ms ease-in-out;
    }

    /* subtle shadow container for accessibility */
    .sr-only { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px,1px,1px,1px); white-space: nowrap; }
  </style>
</head>
<body>
  <header aria-labelledby="title">
    <h1 id="title">Kruskal’s Algorithm — Minimum Spanning Tree (Interactive)</h1>
    <div class="meta">
      <div class="small"><strong>Concept Title:</strong> Kruskal’s Algorithm — Build an MST by processing edges in increasing weight.</div>
      <div class="small"><strong>Learning Objective:</strong> Understand how Kruskal’s algorithm chooses edges, uses a union-find structure to avoid cycles, and constructs the minimum spanning tree step-by-step.</div>
    </div>
  </header>

  <div class="container" role="main">
    <div class="canvas-panel" aria-label="Graph editor and visualization">
      <div class="top-controls" role="toolbar" aria-label="Graph controls">
        <div class="tools" style="flex:1">
          <button id="add-node-btn" class="btn" aria-pressed="false" title="Add node by clicking canvas">Add Node</button>
          <button id="add-edge-btn" class="btn" aria-pressed="false" title="Connect two nodes to add an edge">Add Edge</button>
          <button id="move-btn" class="btn primary" aria-pressed="true" title="Move nodes">Move</button>
        </div>

        <div style="display:flex; gap:var(--gap); align-items:center;">
          <button id="load-sample" class="btn" title="Load a sample graph">Load Example</button>
          <button id="clear-btn" class="btn danger" title="Remove all nodes and edges">Clear</button>
        </div>
      </div>

      <div class="stage" id="stage" tabindex="0" aria-label="Graph canvas. Click to add nodes when Add Node is active. Drag nodes to move them.">
        <!-- SVG drawing area -->
        <svg id="svg" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Graph drawing">
          <!-- edges and nodes injected by JavaScript -->
        </svg>
      </div>

      <div class="top-controls" style="justify-content: space-between;">
        <div class="tools">
          <button id="step-btn" class="btn primary" title="Process next edge (step-by-step)">Step</button>
          <button id="play-btn" class="btn" title="Play through remaining steps">Play</button>
          <button id="pause-btn" class="btn" title="Pause auto-play" disabled>Pause</button>
          <button id="run-btn" class="btn" title="Run to completion">Run to Completion</button>
          <button id="reset-step-btn" class="btn" title="Reset Kruskal steps (keeps graph)">Reset Steps</button>
        </div>

        <div class="info small" id="status-text" aria-live="polite">Mode: Move — Create or edit a graph, then run Kruskal.</div>
      </div>
    </div>

    <aside class="right-panel" aria-label="Kruskal controls and information">
      <div class="section" aria-live="polite">
        <h2>Algorithm Controls</h2>
        <div class="small">Edge sorting: ascending by weight. Use Step to see each decision (accept/reject).</div>
        <div class="status" style="margin-top:8px;">
          <div class="chip">Edges: <span id="edge-count">0</span></div>
          <div class="chip">Nodes: <span id="node-count">0</span></div>
          <div class="chip">Selected MST weight: <strong id="mst-weight">0</strong></div>
        </div>
      </div>

      <div class="section" aria-label="Edges sorted by weight">
        <h2>Sorted Edge List</h2>
        <div class="small">Click an edge to highlight it on the canvas.</div>
        <div class="edge-list" id="edge-list" tabindex="0">
          <!-- edges injected here -->
        </div>
      </div>

      <div class="section" aria-label="Union-Find sets">
        <h2>Union-Find (Components)</h2>
        <div class="small">Components show which nodes are connected so far in the MST.</div>
        <div class="sets" id="sets">
          <!-- sets injected here -->
        </div>
      </div>

      <div class="section">
        <h2>Legend</h2>
        <div class="legend small">
          <div style="display:flex; gap:8px; align-items:center;">
            <div class="box" style="background:var(--success)"></div><div>MST edge (accepted)</div>
          </div>
          <div style="display:flex; gap:8px; align-items:center;">
            <div class="box" style="background:var(--danger)"></div><div>Rejected edge (creates cycle)</div>
          </div>
          <div style="display:flex; gap:8px; align-items:center;">
            <div class="box" style="background:#fbbf24"></div><div>Currently processing</div>
          </div>
        </div>
      </div>
    </aside>
  </div>

  <footer>
    <div><strong>Interaction Design:</strong> Use Add Node to place nodes by clicking inside the canvas. Use Add Edge to click a source node then a target node — a prompt will ask for the edge weight. Use Move to drag nodes. After building a graph, use Step to process the next smallest edge according to Kruskal's algorithm. On Step, the chosen edge is highlighted (amber). If it connects two different components it is accepted (turns green and animates into the MST) and the union-find components merge; otherwise it is rejected (turns red). Play runs steps automatically; Pause stops it. Reset Steps clears only the algorithm state so you can re-run Kruskal without rebuilding the graph. Visual feedback includes animated edge highlights, color transitions for accepted/rejected edges, and a live display of components and total MST weight.</div>
    <div style="margin-top:8px; color:var(--muted)"><strong>Layout Description:</strong> The page uses a two-column responsive layout. The left column (canvas-panel) contains the interactive SVG stage with top and bottom control bars for graph editing and algorithm controls. The right column (right-panel) contains algorithm controls, a sorted edge list, and a union-find view. Spacing respects a 24px safe margin and 16px minimum gaps. Controls are keyboard-focusable and labeled for assistive technologies. The design maintains clear visual hierarchy with compact sections and consistent spacing to keep focus on the canvas while providing contextual information at the side.</div>
  </footer>

  <script>
    /**
     * Kruskal Interactive Module (vanilla JS)
     *
     * Features:
     * - Add nodes by clicking canvas (Add Node mode)
     * - Add edges by selecting two nodes (Add Edge mode) with weight prompt
     * - Move nodes (Move mode)
     * - Load sample graph
     * - Step through Kruskal's algorithm (edge-by-edge), with animations for accept/reject
     * - Play/Pause/Run to completion
     * - Reset algorithm state
     * - Visual union-find sets and edge list
     *
     * No external libraries. Accessible buttons and basic keyboard focus.
     */

    (function () {
      // State
      let mode = 'move'; // 'move' | 'add-node' | 'add-edge'
      let nodes = []; // {id, x, y}
      let edges = []; // {id, a, b, weight, state: 'idle'|'processing'|'accepted'|'rejected'}
      let nextNodeId = 1;
      let nextEdgeId = 1;

      // Kruskal state
      let sortedEdges = []; // references to edges sorted by weight
      let kruskalIndex = 0;
      let playing = false;
      let playTimer = null;
      let uf = null; // union-find structure

      // DOM
      const svg = document.getElementById('svg');
      const stage = document.getElementById('stage');
      const addNodeBtn = document.getElementById('add-node-btn');
      const addEdgeBtn = document.getElementById('add-edge-btn');
      const moveBtn = document.getElementById('move-btn');
      const loadSampleBtn = document.getElementById('load-sample');
      const clearBtn = document.getElementById('clear-btn');

      const stepBtn = document.getElementById('step-btn');
      const playBtn = document.getElementById('play-btn');
      const pauseBtn = document.getElementById('pause-btn');
      const runBtn = document.getElementById('run-btn');
      const resetStepBtn = document.getElementById('reset-step-btn');

      const edgeListDiv = document.getElementById('edge-list');
      const setsDiv = document.getElementById('sets');
      const nodeCountSpan = document.getElementById('node-count');
      const edgeCountSpan = document.getElementById('edge-count');
      const statusText = document.getElementById('status-text');
      const mstWeightSpan = document.getElementById('mst-weight');

      // SVG groups
      const edgeGroup = createSvgElement('g');
      const edgeWeightGroup = createSvgElement('g');
      const nodeGroup = createSvgElement('g');
      svg.appendChild(edgeGroup);
      svg.appendChild(edgeWeightGroup);
      svg.appendChild(nodeGroup);

      // Interaction helpers
      let pendingEdgeSource = null;
      let selectedNodeId = null;
      let dragOffset = {x:0,y:0};
      let dragging = false;

      // Initialize
      setMode('move');
      bindEvents();
      render();

      // -------------------------
      // Utility functions
      function createSvgElement(tag, attrs={}) {
        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const k in attrs) el.setAttribute(k, attrs[k]);
        return el;
      }

      function setMode(m) {
        mode = m;
        addNodeBtn.classList.toggle('primary', mode === 'add-node');
        addEdgeBtn.classList.toggle('primary', mode === 'add-edge');
        moveBtn.classList.toggle('primary', mode === 'move');
        addNodeBtn.setAttribute('aria-pressed', mode === 'add-node');
        addEdgeBtn.setAttribute('aria-pressed', mode === 'add-edge');
        moveBtn.setAttribute('aria-pressed', mode === 'move');
        if (mode !== 'add-edge') pendingEdgeSource = null;
        setStatus(`Mode: ${capitalize(mode)} — ${mode === 'move' ? 'Drag nodes to reposition.' : mode === 'add-node' ? 'Click canvas to add a node.' : 'Click two nodes to add an edge.'}`);
      }

      function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

      function setStatus(text) {
        statusText.textContent = text;
      }

      function getSvgPoint(clientX, clientY) {
        const pt = svg.createSVGPoint();
        pt.x = clientX;
        pt.y = clientY;
        const ctm = svg.getScreenCTM().inverse();
        const svgPt = pt.matrixTransform(ctm);
        return {x: svgPt.x, y: svgPt.y};
      }

      function findNodeAt(x, y, radius=18) {
        return nodes.find(n => {
          const dx = n.x - x;
          const dy = n.y - y;
          return dx*dx + dy*dy <= radius*radius;
        });
      }

      function updateCounts() {
        nodeCountSpan.textContent = nodes.length;
        edgeCountSpan.textContent = edges.length;
      }

      // -------------------------
      // Node & Edge creation
      function addNode(x, y) {
        const id = nextNodeId++;
        nodes.push({id, x, y});
        render();
        return id;
      }

      function addEdge(a, b, weight) {
        if (a === b) return null;
        // prevent multi-edge duplicates (a,b) or (b,a) existing
        const exists = edges.some(e => (e.a === a && e.b === b) || (e.a === b && e.b === a));
        if (exists) return null;
        const id = nextEdgeId++;
        edges.push({id, a, b, weight: Number(weight), state: 'idle'});
        render();
        return id;
      }

      // -------------------------
      // Rendering
      function render() {
        // Clear SVG groups
        while (edgeGroup.firstChild) edgeGroup.removeChild(edgeGroup.firstChild);
        while (edgeWeightGroup.firstChild) edgeWeightGroup.removeChild(edgeWeightGroup.firstChild);
        while (nodeGroup.firstChild) nodeGroup.removeChild(nodeGroup.firstChild);

        // Draw edges (z-order: edges below nodes)
        for (const e of edges) {
          const na = nodes.find(n => n.id === e.a);
          const nb = nodes.find(n => n.id === e.b);
          if (!na || !nb) continue;
          const line = createSvgElement('line', {
            x1: na.x, y1: na.y, x2: nb.x, y2: nb.y,
            class: 'edge ' + (e.state !== 'idle' ? e.state : ''),
            'data-edge-id': e.id
          });
          line.addEventListener('click', () => focusEdge(e.id));
          edgeGroup.appendChild(line);

          // weight label positioned at midpoint
          const mx = (na.x + nb.x) / 2;
          const my = (na.y + nb.y) / 2;
          const label = createSvgElement('text', {
            x: mx + 6,
            y: my - 6,
            class: 'weight-label',
            'data-edge-id': e.id
          });
          label.textContent = e.weight;
          edgeWeightGroup.appendChild(label);
        }

        // Draw nodes (on top)
        for (const n of nodes) {
          const g = createSvgElement('g', {class: 'node', 'data-node-id': n.id});
          g.style.cursor = (mode === 'move') ? 'grab' : 'pointer';
          g.setAttribute('transform', `translate(${n.x}, ${n.y})`);
          const circle = createSvgElement('circle', {r: 16});
          g.appendChild(circle);
          const label = createSvgElement('text', {x: 0, y: 4, 'text-anchor': 'middle'});
          label.textContent = n.id;
          g.appendChild(label);
          // mouse events
          g.addEventListener('pointerdown', onNodePointerDown);
          g.addEventListener('click', onNodeClick);
          nodeGroup.appendChild(g);
        }

        updateEdgeList();
        updateSets();
        updateCounts();
      }

      // -------------------------
      // Edge list UI
      function updateEdgeList() {
        // sorted copy for UI display (by weight asc)
        const arr = edges.slice().sort((a,b) => a.weight - b.weight || a.id - b.id);
        sortedEdges = arr;
        edgeListDiv.innerHTML = '';
        for (const e of arr) {
          const div = document.createElement('div');
          div.className = 'edge-item';
          div.tabIndex = 0;
          div.setAttribute('data-edge-id', e.id);
          div.innerHTML = `<div>(${e.a} — ${e.b})</div><div style="display:flex; gap:8px; align-items:center;"><span class="weight">${e.weight}</span><span style="opacity:0.8; font-size:12px;">${e.state === 'accepted' ? 'accepted' : e.state === 'rejected' ? 'rejected' : 'idle'}</span></div>`;
          div.addEventListener('click', () => focusEdge(e.id));
          div.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); focusEdge(e.id); }});
          edgeListDiv.appendChild(div);
        }
      }

      function focusEdge(edgeId) {
        // highlight edge on canvas briefly
        const lines = edgeGroup.querySelectorAll(`[data-edge-id="${edgeId}"]`);
        lines.forEach(l => {
          l.classList.add('pulse');
          setTimeout(() => l.classList.remove('pulse'), 700);
        });
        // also scroll edge list into view
        const item = edgeListDiv.querySelector(`[data-edge-id="${edgeId}"]`);
        if (item) item.scrollIntoView({behavior:'smooth', block:'center'});
      }

      // -------------------------
      // Union-Find (DSU) implementation
      function makeUnionFind(nNodes) {
        const parent = {};
        const rank = {};
        // init with existing node ids
        for (const node of nodes) {
          parent[node.id] = node.id;
          rank[node.id] = 0;
        }
        return {
          find(x) {
            if (parent[x] !== x) parent[x] = this.find(parent[x]);
            return parent[x];
          },
          union(x, y) {
            const rx = this.find(x);
            const ry = this.find(y);
            if (rx === ry) return false;
            if (rank[rx] < rank[ry]) parent[rx] = ry;
            else if (rank[ry] < rank[rx]) parent[ry] = rx;
            else { parent[ry] = rx; rank[rx]++; }
            return true;
          },
          parent,
          rank
        };
      }

      // Build sets view from current accepted edges
      function updateSets() {
        const comp = {};
        // initially, each node alone
        for (const n of nodes) comp[n.id] = [n.id];
        // union per accepted edges
        const dsu = makeUnionFind();
        for (const e of edges) {
          if (e.state === 'accepted') {
            dsu.union(e.a, e.b);
          }
        }
        // group nodes by root
        const groups = {};
        for (const n of nodes) {
          const r = dsu.find(n.id);
          if (!groups[r]) groups[r] = [];
          groups[r].push(n.id);
        }

        setsDiv.innerHTML = '';
        for (const root in groups) {
          const div = document.createElement('div');
          div.className = 'set';
          div.innerHTML = `<div>Set ${root}</div><div style="opacity:0.9">${groups[root].join(', ')}</div>`;
          setsDiv.appendChild(div);
        }

        // Update mst total weight
        const total = edges.filter(e => e.state === 'accepted').reduce((s,e) => s + e.weight, 0);
        mstWeightSpan.textContent = total;
      }

      // -------------------------
      // Node events (pointer)
      function onNodePointerDown(evt) {
        evt.stopPropagation();
        const nid = Number(this.getAttribute('data-node-id'));
        if (mode === 'move') {
          selectedNodeId = nid;
          dragging = true;
          const pt = getSvgPoint(evt.clientX, evt.clientY);
          const node = nodes.find(n => n.id === nid);
          dragOffset.x = node.x - pt.x;
          dragOffset.y = node.y - pt.y;
          this.setPointerCapture(evt.pointerId);
        } else if (mode === 'add-edge') {
          // clicked node to build edge
          if (!pendingEdgeSource) {
            pendingEdgeSource = nid;
            setStatus(`Selected source node ${nid}. Now click target node.`);
            // highlight selected node visually by adding class
            highlightNode(nid, true);
          } else {
            const source = pendingEdgeSource;
            const target = nid;
            if (source === target) {
              setStatus('Cannot connect a node to itself. Choose a different target.');
              highlightNode(source, false);
              pendingEdgeSource = null;
              return;
            }
            // prompt for weight
            const input = prompt(`Enter edge weight for (${source} — ${target}):`, "1");
            const w = input === null ? null : Number(input);
            if (w === null || isNaN(w)) {
              setStatus('Edge creation canceled or invalid weight.');
            } else {
              const added = addEdge(source, target, w);
              if (added == null) setStatus('Edge not created (duplicate or invalid).');
              else setStatus(`Edge (${source} — ${target}) with weight ${w} created.`);
            }
            highlightNode(source, false);
            pendingEdgeSource = null;
          }
        }
      }

      function onNodeClick(evt) {
        evt.stopPropagation();
        // prevent click when dragging
        if (dragging) return;
        const nid = Number(this.getAttribute('data-node-id'));
        if (mode === 'move') {
          // maybe in move mode clicking can be selecting node (future)
        }
      }

      // highlight a node by id (temporary style)
      function highlightNode(id, on) {
        const g = nodeGroup.querySelector(`[data-node-id="${id}"]`);
        if (!g) return;
        const circle = g.querySelector('circle');
        if (on) {
          circle.classList.add('node-merged');
          circle.style.stroke = 'rgba(96,165,250,0.8)';
          circle.style.strokeWidth = '2.5px';
        } else {
          circle.classList.remove('node-merged');
          circle.style.stroke = '';
          circle.style.strokeWidth = '';
        }
      }

      // -------------------------
      // Stage events (canvas)
      svg.addEventListener('pointermove', (evt) => {
        if (!dragging || !selectedNodeId) return;
        const pt = getSvgPoint(evt.clientX, evt.clientY);
        const node = nodes.find(n => n.id === selectedNodeId);
        node.x = pt.x + dragOffset.x;
        node.y = pt.y + dragOffset.y;
        render();
      });

      svg.addEventListener('pointerup', (evt) => {
        if (dragging && selectedNodeId) {
          const nodeEl = nodeGroup.querySelector(`[data-node-id="${selectedNodeId}"]`);
          if (nodeEl) nodeEl.releasePointerCapture(evt.pointerId);
        }
        dragging = false;
        selectedNodeId = null;
      });

      svg.addEventListener('click', (evt) => {
        const pt = getSvgPoint(evt.clientX, evt.clientY);
        if (mode === 'add-node') {
          addNode(pt.x, pt.y);
          setStatus('Node added.');
        } else {
          // if clicking empty canvas in add-edge mode, cancel selection
          if (mode === 'add-edge' && pendingEdgeSource) {
            highlightNode(pendingEdgeSource, false);
            pendingEdgeSource = null;
            setStatus('Edge creation canceled.');
          }
        }
      });

      // -------------------------
      // Button bindings
      function bindEvents() {
        addNodeBtn.addEventListener('click', () => setMode('add-node'));
        addEdgeBtn.addEventListener('click', () => setMode('add-edge'));
        moveBtn.addEventListener('click', () => setMode('move'));

        loadSampleBtn.addEventListener('click', loadSampleGraph);
        clearBtn.addEventListener('click', () => {
          if (!confirm('Clear the graph? This removes all nodes and edges.')) return;
          nodes = []; edges = []; nextNodeId = 1; nextEdgeId = 1;
          resetKruskalState();
          render();
        });

        stepBtn.addEventListener('click', () => {
          if (edges.length === 0 || nodes.length === 0) { setStatus('Graph is empty.'); return; }
          ensureKruskalPrepared();
          processNextEdge();
        });

        playBtn.addEventListener('click', () => {
          if (playing) return;
          if (edges.length === 0 || nodes.length === 0) { setStatus('Graph is empty.'); return; }
          ensureKruskalPrepared();
          playing = true;
          playBtn.disabled = true;
          pauseBtn.disabled = false;
          playTimer = setInterval(() => {
            if (kruskalIndex >= sortedEdges.length) {
              stopPlaying();
              return;
            }
            processNextEdge();
          }, 900);
          setStatus('Playing Kruskal steps...');
        });

        pauseBtn.addEventListener('click', () => {
          stopPlaying();
          setStatus('Paused.');
        });

        runBtn.addEventListener('click', () => {
          if (edges.length === 0 || nodes.length === 0) { setStatus('Graph is empty.'); return; }
          ensureKruskalPrepared();
          // process remaining quickly
          const interval = setInterval(() => {
            if (kruskalIndex >= sortedEdges.length) {
              clearInterval(interval);
              setStatus('Kruskal completed.');
              return;
            }
            processNextEdge();
          }, 250);
        });

        resetStepBtn.addEventListener('click', () => {
          resetKruskalState();
          setStatus('Kruskal state reset (graph preserved).');
          render();
        });

        // keyboard shortcuts for Step (Space), Play (P), Reset (R)
        document.addEventListener('keydown', (ev) => {
          if (ev.target.tagName === 'INPUT' || ev.target.tagName === 'TEXTAREA') return;
          if (ev.code === 'Space') { ev.preventDefault(); stepBtn.click(); }
          if (ev.key.toLowerCase() === 'p') { playBtn.click(); }
          if (ev.key.toLowerCase() === 'r') { resetStepBtn.click(); }
        });
      }

      function stopPlaying() {
        playing = false;
        playBtn.disabled = false;
        pauseBtn.disabled = true;
        if (playTimer) { clearInterval(playTimer); playTimer = null; }
      }

      // -------------------------
      // Kruskal algorithm control
      function ensureKruskalPrepared() {
        // initialize union-find and sorted edge list if not already
        if (!uf || !sortedEdges || kruskalIndex === 0) {
          uf = makeUnionFind();
          sortedEdges = edges.slice().sort((a,b) => a.weight - b.weight || a.id - b.id);
          kruskalIndex = 0;
          // reset any previous markings
          for (const e of edges) e.state = 'idle';
          render();
        }
      }

      function processNextEdge() {
        if (!sortedEdges || kruskalIndex >= sortedEdges.length) {
          setStatus('No more edges to process. Kruskal finished.');
          stopPlaying();
          return;
        }
        // find the next edge that is still idle (some edges might have been added after initialization)
        let e = sortedEdges[kruskalIndex];
        // If the edge object was removed or changed, skip gracefully
        while (e && !edges.includes(e) && kruskalIndex < sortedEdges.length - 1) {
          kruskalIndex++;
          e = sortedEdges[kruskalIndex];
        }
        if (!e) {
          kruskalIndex++;
          processNextEdge();
          return;
        }

        // Mark as processing
        e.state = 'processing';
        render();
        setStatus(`Processing edge (${e.a} — ${e.b}) weight ${e.weight}...`);
        // highlight visually
        highlightEdgeVisual(e.id, 'processing');

        // small delay to show processing
        setTimeout(() => {
          const ra = uf.find(e.a);
          const rb = uf.find(e.b);
          if (ra !== rb) {
            // accept edge
            uf.union(ra, rb);
            e.state = 'accepted';
            setStatus(`Accepted edge (${e.a} — ${e.b}) weight ${e.weight}.`);
            highlightEdgeVisual(e.id, 'accepted');
          } else {
            // reject edge (forms cycle)
            e.state = 'rejected';
            setStatus(`Rejected edge (${e.a} — ${e.b}) — would form a cycle.`);
            highlightEdgeVisual(e.id, 'rejected');
          }
          kruskalIndex++;
          render();
          // stop playing if finished
          if (kruskalIndex >= sortedEdges.length) {
            setTimeout(() => {
              setStatus('Kruskal completed.');
              stopPlaying();
            }, 200);
          }
        }, 600);
      }

      function resetKruskalState() {
        uf = null;
        sortedEdges = [];
        kruskalIndex = 0;
        for (const e of edges) e.state = 'idle';
        stopPlaying();
      }

      // Visual edge highlighting helper
      function highlightEdgeVisual(edgeId, state) {
        // remove processing classes from all
        const el = edgeGroup.querySelector(`[data-edge-id="${edgeId}"]`);
        if (!el) return;
        const original = el.className.baseVal;
        // apply temporary style
        el.classList.remove('accepted','rejected','highlight','processing');
        if (state === 'processing') {
          el.classList.add('highlight');
          // small pulsing
          el.classList.add('pulse');
          setTimeout(() => el.classList.remove('pulse'), 700);
        } else if (state === 'accepted') {
          el.classList.remove('highlight');
          el.classList.add('accepted');
          el.classList.add('pulse');
          setTimeout(() => el.classList.remove('pulse'), 700);
        } else if (state === 'rejected') {
          el.classList.remove('highlight');
          el.classList.add('rejected');
          el.classList.add('pulse');
          setTimeout(() => el.classList.remove('pulse'), 700);
        }
      }

      // -------------------------
      // Sample graph loader
      function loadSampleGraph() {
        // a somewhat connected sample graph
        nodes = [];
        edges = [];
        nextNodeId = 1;
        nextEdgeId = 1;
        // coordinates scaled for svg area: use relative positions
        const w = svg.clientWidth || 800;
        const h = svg.clientHeight || 420;
        const coords = [
          {x: w*0.2, y: h*0.2},
          {x: w*0.5, y: h*0.1},
          {x: w*0.8, y: h*0.2},
          {x: w*0.3, y: h*0.45},
          {x: w*0.6, y: h*0.4},
          {x: w*0.2, y: h*0.75},
          {x: w*0.5, y: h*0.65},
          {x: w*0.78, y: h*0.72}
        ];
        for (const c of coords) addNode(c.x, c.y);
        // edges with weights
        addEdge(1,2,3);
        addEdge(2,3,4);
        addEdge(1,4,2);
        addEdge(4,5,4);
        addEdge(2,5,6);
        addEdge(3,5,2);
        addEdge(4,6,7);
        addEdge(6,7,3);
        addEdge(5,7,1);
        addEdge(7,8,5);
        addEdge(3,8,9);

        resetKruskalState();
        setStatus('Sample graph loaded. Use Step to run Kruskal.');
      }
    })();
  </script>
</body>
</html>