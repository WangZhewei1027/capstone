<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Fibonacci Sequence Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --min-gap: 16px;
      --bg: #f7fafc;
      --card: #ffffff;
      --accent: #0b84ff;
      --muted: #6b7280;
      --success: #10b981;
      --danger: #ef4444;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#f8fbff 0%, var(--bg) 100%);
      color:#0f172a;
    }

    /* Safe area margins */
    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: calc(100vh - calc(var(--safe-margin) * 2));
      display:flex;
      flex-direction:column;
      gap: var(--min-gap);
    }

    header {
      display:flex;
      align-items:baseline;
      gap: 12px;
      flex-wrap:wrap;
    }

    h1 {
      margin:0;
      font-size:1.25rem;
      letter-spacing: -0.01em;
    }

    .meta {
      display:flex;
      gap: 8px;
      align-items:center;
      color:var(--muted);
      font-size:0.95rem;
    }

    /* Layout: controls left, canvas right on wide screens */
    .module {
      display:grid;
      grid-template-columns: 360px 1fr;
      gap: var(--min-gap);
      align-items:start;
    }

    @media (max-width:900px){
      .module {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: var(--card);
      border-radius: 12px;
      padding:16px;
      box-shadow: 0 2px 8px rgba(12,18,31,0.06);
    }

    /* Controls panel */
    .controls {
      display:flex;
      flex-direction:column;
      gap: var(--min-gap);
    }

    label {
      font-size:0.9rem;
      color:#0f172a;
      display:block;
      margin-bottom:6px;
    }

    .row {
      display:flex;
      gap: var(--min-gap);
      align-items:center;
    }

    .row.wrap{
      flex-wrap:wrap;
    }

    input[type="range"]{
      width:100%;
    }

    .small {
      font-size:0.85rem;
      color:var(--muted);
    }

    .btn {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      padding:8px 12px;
      border-radius:8px;
      border: 1px solid rgba(2,6,23,0.06);
      background:linear-gradient(180deg,#ffffff,#fbfdff);
      cursor:pointer;
      font-weight:600;
      color: #0b1730;
    }

    .btn:active { transform: translateY(1px); }

    .btn.primary {
      background: linear-gradient(180deg,var(--accent),#0577e6);
      color: white;
      border: none;
    }

    .btn.ghost {
      background: transparent;
      border: 1px dashed rgba(2,6,23,0.06);
    }

    input[type="number"]{
      width:92px;
      padding:8px;
      border-radius:8px;
      border:1px solid #e6eefb;
      background:#fbfdff;
    }

    .info {
      font-size:0.95rem;
      color:var(--muted);
    }

    ul.sequence {
      list-style:none;
      padding:0;
      margin:0;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }

    ul.sequence li{
      min-width:48px;
      padding:8px;
      border-radius:8px;
      background:linear-gradient(180deg,#fcfeff,#f6fbff);
      border:1px solid rgba(12,18,31,0.04);
      text-align:center;
      font-weight:700;
      cursor:pointer;
      transition: transform .12s ease, box-shadow .12s ease;
    }

    ul.sequence li:focus,
    ul.sequence li:hover{
      transform: translateY(-4px);
      box-shadow: 0 6px 16px rgba(11,132,255,0.08);
      outline:none;
    }

    ul.sequence li.selected{
      background: linear-gradient(180deg,#e6f3ff,#d4eefe);
      border: 1px solid rgba(11,132,255,0.18);
      color: var(--accent);
    }

    .canvas-wrap {
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    canvas{
      width:100%;
      background: linear-gradient(180deg,#ffffff,#fbfdff);
      border-radius:12px;
      border:1px solid rgba(12,18,31,0.04);
    }

    .legend {
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }

    .ratio {
      font-weight:700;
      font-size:1.25rem;
      color:#0b1730;
    }

    .muted-sm {
      color:var(--muted);
      font-size:0.9rem;
    }

    .footer-note {
      font-size:0.85rem;
      color:var(--muted);
    }

    /* Accessibility focus outlines */
    button:focus, input:focus, li:focus{
      outline: 3px solid rgba(11,132,255,0.16);
      outline-offset:2px;
    }

    /* spacing constraints */
    .controls > * { margin-bottom: 0; }

    /* small helper */
    .pill {
      padding:6px 10px;
      border-radius:999px;
      background:#f1f7ff;
      border:1px solid rgba(11,132,255,0.08);
      color:var(--accent);
      font-weight:700;
      font-size:0.85rem;
    }
  </style>
</head>
<body>
  <div class="app" role="main">
    <header>
      <div>
        <h1>Fibonacci Sequence — Interactive Exploration</h1>
        <div class="meta">
          <span class="pill" aria-hidden="true">Hands‑on</span>
          <span class="small">One concept • Visual & numeric intuition</span>
        </div>
      </div>
    </header>

    <!-- Explanatory meta sections required by the design plan -->
    <div class="module" aria-labelledby="module-heading">
      <div class="panel controls" aria-hidden="false">
        <section aria-labelledby="concept-title">
          <h2 id="concept-title" style="margin:0 0 6px 0; font-size:1rem;">Concept Title</h2>
          <div class="info">Fibonacci Sequence (recursive integer sequence where each term is the sum of the two preceding terms).</div>
        </section>

        <section aria-labelledby="learning-objective">
          <h3 id="learning-objective" style="margin:12px 0 6px 0; font-size:0.95rem;">Learning Objective</h3>
          <div class="info">
            After using this module you will:
            <ul style="margin:8px 0 0 18px; color:var(--muted);">
              <li>Generate the Fibonacci numbers and see how they grow.</li>
              <li>Visualize the Fibonacci squares and spiral and observe how ratios converge to the golden ratio (~1.618).</li>
              <li>Interactively change how many terms to show and watch the visual build-up step by step.</li>
            </ul>
          </div>
        </section>

        <section aria-labelledby="interaction-design" style="margin-top:12px;">
          <h3 id="interaction-design" style="margin:0 0 6px 0; font-size:0.95rem;">Interaction Design</h3>
          <div class="info">
            Controls:
            <ul style="margin:8px 0 0 18px; color:var(--muted);">
              <li>Use the slider or number box to set how many terms are shown (2–12).</li>
              <li>Step through terms with Next / Prev, or Play to auto-build the sequence with animated squares and spiral arcs.</li>
              <li>Click any term in the sequence list to highlight its square on the canvas and view its ratio to the previous term.</li>
            </ul>
            Visual feedback:
            <ul style="margin:8px 0 0 18px; color:var(--muted);">
              <li>Squares animate as they are added; quarter‑circle arcs draw to form the spiral.</li>
              <li>Bar chart displays values; ratio chart shows convergence toward the golden ratio.</li>
              <li>Hover/focus states and keyboard operability ensure accessibility.</li>
            </ul>
          </div>
        </section>

        <section aria-labelledby="layout-desc" style="margin-top:12px;">
          <h3 id="layout-desc" style="margin:0 0 6px 0; font-size:0.95rem;">Layout Description</h3>
          <div class="info">
            Spatial organization:
            <ul style="margin:8px 0 0 18px; color:var(--muted);">
              <li>Left column (controls): textual info, slider, seeds, play/step, and the numeric sequence list for quick selection.</li>
              <li>Right column (visual): large responsive canvas showing Fibonacci squares and spiral, with two small ratio/value charts beneath.</li>
              <li>Safe area margins of 24px applied; minimum spacing 16px between interactive elements using gaps and padding.</li>
            </ul>
            Responsiveness & accessibility:
            <ul style="margin:8px 0 0 18px; color:var(--muted);">
              <li>On narrow screens the layout stacks vertically; controls remain at top for immediate access.</li>
              <li>All controls keyboard accessible; color contrast chosen for clarity.</li>
            </ul>
          </div>
        </section>

        <!-- Controls -->
        <div style="margin-top:14px;">
          <label for="termsRange">Number of terms: <span id="termsLabel" class="pill">8</span></label>
          <div class="row">
            <input id="termsRange" type="range" min="2" max="12" value="8" aria-valuemin="2" aria-valuemax="12" />
            <input id="termsNumber" type="number" min="2" max="12" value="8" aria-label="Number of terms" />
          </div>
        </div>

        <div>
          <label for="seed1">Starting seeds (optional):</label>
          <div class="row wrap">
            <div style="display:flex;flex-direction:column;">
              <input id="seed1" type="number" value="1" aria-label="Seed A" />
              <span class="small" style="margin-top:6px;">F0 (default 1)</span>
            </div>
            <div style="display:flex;flex-direction:column;">
              <input id="seed2" type="number" value="1" aria-label="Seed B" />
              <span class="small" style="margin-top:6px;">F1 (default 1)</span>
            </div>
            <button id="applySeeds" class="btn" aria-label="Apply seeds">Apply</button>
            <button id="resetSeeds" class="btn ghost" aria-label="Reset seeds">Reset</button>
          </div>
          <div class="small" style="margin-top:8px;">Changing seeds shows generalized Fibonacci growth (keeps other interactions the same).</div>
        </div>

        <div style="margin-top:8px;">
          <div class="row">
            <button id="prevBtn" class="btn" aria-label="Previous term">Prev</button>
            <button id="playBtn" class="btn primary" aria-pressed="false" aria-label="Play animation">Play</button>
            <button id="nextBtn" class="btn" aria-label="Next term">Next</button>
            <button id="toggleSpiral" class="btn" aria-pressed="true" style="margin-left:auto;" aria-label="Toggle spiral">Spiral ON</button>
          </div>
        </div>

        <div style="margin-top:8px;">
          <label>Sequence:</label>
          <ul class="sequence" id="sequenceList" role="listbox" aria-label="Fibonacci terms"></ul>
          <div class="small" style="margin-top:8px;">Click a term to highlight it on the canvas and view its ratio to the previous term.</div>
        </div>

        <div style="margin-top:12px;">
          <div class="footer-note">Tip: Use keyboard to focus the numeric list (Tab) and press Enter to select a term. Play will animate the squares and arcs to build the spiral step by step.</div>
        </div>
      </div>

      <!-- Visual column -->
      <div class="canvas-wrap">
        <div class="panel" style="padding:12px;">
          <div class="legend" role="status" aria-live="polite">
            <div>
              <div class="muted-sm">Selected index</div>
              <div class="ratio" id="selectedInfo">n=7 • F7 = 21</div>
            </div>
            <div style="text-align:right;">
              <div class="muted-sm">Latest ratio</div>
              <div id="ratioValue" class="ratio">21 / 13 ≈ 1.615</div>
            </div>
          </div>
        </div>

        <canvas id="fibCanvas" width="1200" height="640" aria-label="Fibonacci squares and spiral visualization"></canvas>

        <div class="panel" style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
          <canvas id="barCanvas" width="600" height="180" aria-label="Fibonacci bar chart"></canvas>
          <canvas id="ratioCanvas" width="600" height="180" aria-label="Ratio convergence chart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Fibonacci Interactive Module
    (function () {
      // DOM elements
      const termsRange = document.getElementById('termsRange');
      const termsNumber = document.getElementById('termsNumber');
      const termsLabel = document.getElementById('termsLabel');
      const sequenceList = document.getElementById('sequenceList');
      const seed1Input = document.getElementById('seed1');
      const seed2Input = document.getElementById('seed2');
      const applySeedsBtn = document.getElementById('applySeeds');
      const resetSeedsBtn = document.getElementById('resetSeeds');
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');
      const playBtn = document.getElementById('playBtn');
      const toggleSpiralBtn = document.getElementById('toggleSpiral');
      const selectedInfo = document.getElementById('selectedInfo');
      const ratioValue = document.getElementById('ratioValue');

      const fibCanvas = document.getElementById('fibCanvas');
      const barCanvas = document.getElementById('barCanvas');
      const ratioCanvas = document.getElementById('ratioCanvas');

      const fibCtx = fibCanvas.getContext('2d');
      const barCtx = barCanvas.getContext('2d');
      const ratioCtx = ratioCanvas.getContext('2d');

      // State
      let maxTerms = parseInt(termsRange.value, 10);
      let seedA = parseInt(seed1Input.value, 10) || 1;
      let seedB = parseInt(seed2Input.value, 10) || 1;
      let sequence = [];
      let selectedIndex = maxTerms - 1; // 0-based index
      let isPlaying = false;
      let playProgress = 1; // how many terms currently shown during play
      let showSpiral = true;
      let animationFrame = null;

      // Constants
      const MAX_CANVAS_PADDING = 24;
      const COLORS = {
        squareFill: '#dbeeff',
        squareStroke: '#0b84ff',
        selectedFill: '#e8f5ff',
        arcStroke: '#0b84ff',
        barFill: '#0b84ff',
        barFade: 'rgba(11,132,255,0.18)',
        ratioLine: '#ef4444',
      };

      // Initialize
      function init() {
        bindEvents();
        updateSequence();
        renderAll();
      }

      // Event bindings
      function bindEvents() {
        termsRange.addEventListener('input', onTermsChange);
        termsNumber.addEventListener('change', onTermsNumberChange);
        termsNumber.addEventListener('input', onTermsNumberChange);
        applySeedsBtn.addEventListener('click', onApplySeeds);
        resetSeedsBtn.addEventListener('click', onResetSeeds);
        prevBtn.addEventListener('click', onPrev);
        nextBtn.addEventListener('click', onNext);
        playBtn.addEventListener('click', onPlayToggle);
        toggleSpiralBtn.addEventListener('click', onToggleSpiral);

        sequenceList.addEventListener('click', onSequenceClick);
        sequenceList.addEventListener('keydown', onSequenceKeydown);

        // Resize handling: keep canvases crisp for css width
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();
      }

      function resizeCanvases() {
        // Make the internal canvas size match CSS pixel size * devicePixelRatio
        [fibCanvas, barCanvas, ratioCanvas].forEach((c) => {
          const rect = c.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;
          c.width = Math.max(300, Math.floor(rect.width * dpr));
          c.height = Math.max(150, Math.floor(rect.height * dpr));
        });
        renderAll();
      }

      // Update sequence array
      function updateSequence() {
        const n = maxTerms;
        sequence = [];
        if (n >= 1) sequence.push(seedA);
        if (n >= 2) sequence.push(seedB);
        for (let i = 2; i < n; i++) {
          sequence[i] = sequence[i - 1] + sequence[i - 2];
        }
        // Cap huge values for display (no external resources)
        selectedIndex = Math.min(selectedIndex, sequence.length - 1);
        playProgress = Math.min(playProgress, sequence.length);
        updateSequenceList();
        updateSelectedInfo();
      }

      // UI: sequence list
      function updateSequenceList() {
        sequenceList.innerHTML = '';
        sequence.forEach((val, idx) => {
          const li = document.createElement('li');
          li.tabIndex = 0;
          li.dataset.index = idx;
          li.textContent = val;
          li.title = `n=${idx} • F${idx} = ${val}`;
          if (idx === selectedIndex) li.classList.add('selected');
          sequenceList.appendChild(li);
        });
      }

      // Handlers
      function onTermsChange(e) {
        maxTerms = parseInt(e.target.value, 10);
        termsNumber.value = maxTerms;
        termsLabel.textContent = maxTerms;
        updateSequence();
        renderAll();
      }

      function onTermsNumberChange(e) {
        let val = parseInt(e.target.value, 10);
        if (isNaN(val)) val = maxTerms;
        val = Math.max(2, Math.min(12, val));
        termsNumber.value = val;
        termsRange.value = val;
        maxTerms = val;
        termsLabel.textContent = val;
        updateSequence();
        renderAll();
      }

      function onApplySeeds() {
        const a = parseInt(seed1Input.value, 10);
        const b = parseInt(seed2Input.value, 10);
        if (!Number.isFinite(a) || !Number.isFinite(b)) return;
        seedA = a;
        seedB = b;
        updateSequence();
        renderAll();
      }

      function onResetSeeds() {
        seedA = 1; seedB = 1;
        seed1Input.value = 1; seed2Input.value = 1;
        updateSequence();
        renderAll();
      }

      function onPrev() {
        if (isPlaying) stopPlaying();
        if (playProgress > 1) {
          playProgress = Math.max(1, playProgress - 1);
        } else {
          // shift selection left
          selectedIndex = Math.max(0, selectedIndex - 1);
        }
        updateSelectedInfo();
        renderAll();
      }

      function onNext() {
        if (isPlaying) stopPlaying();
        if (playProgress < sequence.length) {
          playProgress = Math.min(sequence.length, playProgress + 1);
        } else {
          selectedIndex = Math.min(sequence.length - 1, selectedIndex + 1);
        }
        updateSelectedInfo();
        renderAll();
      }

      function onPlayToggle() {
        if (isPlaying) {
          stopPlaying();
        } else {
          startPlaying();
        }
      }

      function startPlaying() {
        isPlaying = true;
        playBtn.textContent = 'Pause';
        playBtn.classList.add('primary');
        playBtn.setAttribute('aria-pressed', 'true');
        playProgress = 1;
        animateBuild();
      }

      function stopPlaying() {
        isPlaying = false;
        playBtn.textContent = 'Play';
        playBtn.classList.remove('primary');
        playBtn.setAttribute('aria-pressed', 'false');
        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
          animationFrame = null;
        }
      }

      function onToggleSpiral() {
        showSpiral = !showSpiral;
        toggleSpiralBtn.textContent = showSpiral ? 'Spiral ON' : 'Spiral OFF';
        toggleSpiralBtn.setAttribute('aria-pressed', String(showSpiral));
        renderAll();
      }

      function onSequenceClick(e) {
        const li = e.target.closest('li');
        if (!li) return;
        const idx = parseInt(li.dataset.index, 10);
        selectedIndex = idx;
        if (isPlaying) stopPlaying();
        updateSequenceList();
        updateSelectedInfo();
        renderAll();
      }

      function onSequenceKeydown(e) {
        const li = document.activeElement;
        if (!li || li.tagName !== 'LI') return;
        const idx = parseInt(li.dataset.index, 10);
        if (e.key === 'Enter' || e.key === ' ') {
          selectedIndex = idx;
          updateSequenceList();
          updateSelectedInfo();
          renderAll();
          e.preventDefault();
        } else if (e.key === 'ArrowRight') {
          const next = li.nextElementSibling;
          if (next) next.focus();
        } else if (e.key === 'ArrowLeft') {
          const prev = li.previousElementSibling;
          if (prev) prev.focus();
        }
      }

      // Selection info
      function updateSelectedInfo() {
        if (!sequence.length) {
          selectedInfo.textContent = '—';
          ratioValue.textContent = '—';
          return;
        }
        const idx = selectedIndex;
        const val = sequence[idx];
        selectedInfo.textContent = `n=${idx} • F${idx} = ${val}`;
        if (idx >= 1) {
          const prev = sequence[idx - 1];
          const ratio = (val / prev);
          ratioValue.textContent = `${val} / ${prev} ≈ ${ratio.toFixed(6)}`;
        } else {
          ratioValue.textContent = 'No previous term';
        }
      }

      // Build animation: animate adding squares one by one
      function animateBuild() {
        const target = sequence.length;
        if (!isPlaying) return;
        if (playProgress >= target) {
          // stop at end
          isPlaying = false;
          playBtn.textContent = 'Play';
          playBtn.classList.remove('primary');
          playBtn.setAttribute('aria-pressed', 'false');
          return;
        }
        playProgress++;
        // animate drawing until next increment or stop
        renderAll(true);
        // schedule next step after a delay
        setTimeout(() => {
          if (isPlaying) {
            animateBuild();
          }
        }, 700); // pause to appreciate each step
      }

      // Rendering: orchestrates canvas drawings
      function renderAll(animated = false) {
        updateSelectedInfo();
        updateSequenceList();
        drawFibCanvas(animated);
        drawBarChart();
        drawRatioChart();
      }

      // Drawing Fibonacci squares & spirals
      function drawFibCanvas(animated = false) {
        const ctx = fibCtx;
        const dpr = window.devicePixelRatio || 1;
        const width = fibCanvas.width;
        const height = fibCanvas.height;
        ctx.clearRect(0, 0, width, height);
        ctx.save();
        ctx.scale(dpr, dpr);

        // CSS size (logical)
        const cssW = width / dpr;
        const cssH = height / dpr;
        // compute scale factor so the largest square fits comfortably
        const visibleCount = Math.max(1, Math.min(sequence.length, playProgress));
        const values = sequence.slice(0, visibleCount);
        const maxVal = Math.max(...values, 1);

        // Determine layout scale. We'll map largest side to at most ~40% of min dimension.
        const padding = MAX_CANVAS_PADDING;
        const available = Math.min(cssW, cssH) - padding * 2;
        const maxSidePx = Math.max(available * 0.5, 40);
        const scale = maxSidePx / maxVal;

        // Center starting point
        let centerX = cssW / 2;
        let centerY = cssH / 2;

        // We'll place squares in a spiral: start with first square at center.
        // We'll keep track of the bounding box (for adjusting positions).
        let squares = []; // {x,y,size,dir}
        // Directions sequence: 0:right,1:up,2:left,3:down (clockwise)
        // Placement algorithm: each new square adjacent to previous, rotating direction.
        // For visual clarity, we start first square centered, then place next to its right, etc.

        // Compute scaled sizes
        const sizes = values.map(v => Math.max(2, v * scale));

        // Start with first square at origin (0,0). We'll later translate to center.
        let x = 0, y = 0;
        // Keep track of current bounding box
        let minX = 0, minY = 0, maxX = sizes[0], maxY = sizes[0];

        // Store first square
        squares.push({ x: 0, y: 0, s: sizes[0], dir: 0 });

        for (let i = 1; i < sizes.length; i++) {
          const s = sizes[i];
          const prev = squares[i - 1];
          // direction rotates: right, up, left, down, right...
          const dir = (i - 1) % 4;
          let nx = prev.x, ny = prev.y;
          if (dir === 0) {
            // right: place to the right of prev
            nx = prev.x + prev.s;
            ny = prev.y + (prev.s - s);
          } else if (dir === 1) {
            // up
            nx = prev.x + (prev.s - s);
            ny = prev.y - s;
          } else if (dir === 2) {
            // left
            nx = prev.x - s;
            ny = prev.y + (prev.s - s);
          } else if (dir === 3) {
            // down
            nx = prev.x + (prev.s - s);
            ny = prev.y + prev.s;
          }
          squares.push({ x: nx, y: ny, s: s, dir: (dir + 1) % 4 });
          minX = Math.min(minX, nx);
          minY = Math.min(minY, ny);
          maxX = Math.max(maxX, nx + s);
          maxY = Math.max(maxY, ny + s);
        }

        // Translate to center in canvas
        const totalW = maxX - minX;
        const totalH = maxY - minY;
        const offsetX = centerX - (minX + totalW / 2);
        const offsetY = centerY - (minY + totalH / 2);

        // Drawing squares
        ctx.lineWidth = 1.4;
        ctx.strokeStyle = COLORS.squareStroke;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = 'bold 12px system-ui, sans-serif';

        // Draw grid background subtle
        ctx.fillStyle = '#f7fbff';
        ctx.fillRect(0, 0, cssW, cssH);

        // Optionally animate: show each square with a scale effect
        const now = performance.now();

        for (let i = 0; i < squares.length; i++) {
          const sq = squares[i];
          const drawX = sq.x + offsetX;
          const drawY = sq.y + offsetY;
          const size = sq.s;

          // Determine visibility based on playProgress
          if (i >= playProgress) break;

          // Animation for the newest square if playing and animated flag is set
          let animProgress = 1;
          if (animated && isPlaying && i === playProgress - 1) {
            // use a smooth scale in based on time
            const t = Math.min(1, ((now % 1000) / 600));
            animProgress = easeOutCubic(t);
          }

          const drawS = size * animProgress;
          const drawCX = drawX + (size - drawS) / 2;
          const drawCY = drawY + (size - drawS) / 2;

          // Fill
          ctx.fillStyle = (i === selectedIndex) ? COLORS.selectedFill : COLORS.squareFill;
          roundRect(ctx, drawCX, drawCY, drawS, drawS, 6);
          ctx.fill();

          // Stroke
          ctx.strokeStyle = COLORS.squareStroke;
          ctx.strokeRect(drawCX + 0.5, drawCY + 0.5, drawS - 1, drawS - 1);

          // Value label
          ctx.fillStyle = '#0b1730';
          ctx.font = `${Math.max(10, Math.min(16, drawS / 4))}px system-ui, sans-serif`;
          ctx.fillText(sequence[i], drawCX + drawS / 2, drawCY + drawS / 2);
        }

        // Draw spiral arcs if enabled
        if (showSpiral) {
          ctx.lineWidth = 2;
          ctx.strokeStyle = COLORS.arcStroke;
          ctx.beginPath();
          for (let i = 0; i < squares.length && i < playProgress; i++) {
            const sq = squares[i];
            const cx = sq.x + offsetX;
            const cy = sq.y + offsetY;
            const s = sq.s;

            // Arc center and radius depend on dir pattern; we'll draw quarter circles inside each square.
            // Determine arc center/angles for each placement step
            const dir = (i - 1) % 4;
            // For consistent spiral, compute arc center at the corner opposite rotation
            let arcCx, arcCy, startAng, endAng, r;
            if (i === 0) {
              // first square - draw a tiny arc
              arcCx = cx + s;
              arcCy = cy + s;
              startAng = Math.PI;
              endAng = 1.5 * Math.PI;
              r = s;
            } else {
              // Use square position and direction to compute appropriate arc
              // We can approximate: place quarter circle inside this square connecting to previous square
              const dirIdx = (i - 1) % 4;
              if (dirIdx === 0) {
                // right: arc centered at bottom-right of square
                arcCx = cx + s;
                arcCy = cy + s;
                startAng = Math.PI;
                endAng = 1.5 * Math.PI;
              } else if (dirIdx === 1) {
                // up: arc centered at bottom-left
                arcCx = cx;
                arcCy = cy + s;
                startAng = 1.5 * Math.PI;
                endAng = 0;
              } else if (dirIdx === 2) {
                // left: arc centered at top-left
                arcCx = cx;
                arcCy = cy;
                startAng = 0;
                endAng = 0.5 * Math.PI;
              } else {
                // down: arc centered at top-right
                arcCx = cx + s;
                arcCy = cy;
                startAng = 0.5 * Math.PI;
                endAng = Math.PI;
              }
              r = s;
            }
            // Draw arc with slight animation if newest
            if (animated && isPlaying && i === playProgress - 1) {
              const t = Math.min(1, ((now % 1000) / 600));
              const eased = easeOutCubic(t);
              // interpolate angle range
              const mid = startAng + (endAng - startAng) * eased;
              ctx.beginPath();
              ctx.arc(arcCx, arcCy, r, startAng, mid);
              ctx.stroke();
            } else {
              ctx.beginPath();
              ctx.arc(arcCx, arcCy, r, startAng, endAng);
              ctx.stroke();
            }
          }
        }

        ctx.restore();
      }

      // Simple rounded rectangle helper
      function roundRect(ctx, x, y, w, h, r) {
        const radius = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + w, y, x + w, y + h, radius);
        ctx.arcTo(x + w, y + h, x, y + h, radius);
        ctx.arcTo(x, y + h, x, y, radius);
        ctx.arcTo(x, y, x + w, y, radius);
        ctx.closePath();
      }

      // Bar chart for values
      function drawBarChart() {
        const ctx = barCtx;
        const dpr = window.devicePixelRatio || 1;
        const W = barCanvas.width;
        const H = barCanvas.height;
        ctx.clearRect(0, 0, W, H);
        ctx.save();
        ctx.scale(dpr, dpr);

        const cssW = W / dpr;
        const cssH = H / dpr;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, cssW, cssH);

        const visible = sequence.slice(0, playProgress);
        if (!visible.length) {
          ctx.restore();
          return;
        }
        const maxVal = Math.max(...visible);
        const padding = 12;
        const barGap = 8;
        const barWidth = (cssW - padding * 2 - barGap * (visible.length - 1)) / visible.length;

        for (let i = 0; i < visible.length; i++) {
          const v = visible[i];
          const x = padding + i * (barWidth + barGap);
          const h = (v / maxVal) * (cssH - padding * 2);
          const y = cssH - padding - h;
          ctx.fillStyle = (i === selectedIndex) ? COLORS.barFade : COLORS.barFill;
          roundRect(ctx, x, y, barWidth, h, 6);
          ctx.fill();

          // label
          ctx.fillStyle = '#0b1730';
          ctx.font = 'bold 11px system-ui, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(v, x + barWidth / 2, y - 10);
        }

        ctx.restore();
      }

      // Ratio chart: plot Fn/F(n-1) convergence
      function drawRatioChart() {
        const ctx = ratioCtx;
        const dpr = window.devicePixelRatio || 1;
        const W = ratioCanvas.width;
        const H = ratioCanvas.height;
        ctx.clearRect(0, 0, W, H);
        ctx.save();
        ctx.scale(dpr, dpr);

        const cssW = W / dpr;
        const cssH = H / dpr;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, cssW, cssH);

        const visible = sequence.slice(0, playProgress);
        const ratios = [];
        for (let i = 1; i < visible.length; i++) {
          ratios.push(visible[i] / visible[i - 1]);
        }
        if (!ratios.length) {
          ctx.restore();
          return;
        }

        const padding = 18;
        const xStep = (cssW - padding * 2) / (ratios.length - 1 || 1);
        // target/golden ratio
        const phi = (1 + Math.sqrt(5)) / 2;

        // find y scale: min and max near phi for clarity
        let minY = Math.min(...ratios, phi);
        let maxY = Math.max(...ratios, phi);
        // pad slightly
        const pad = (maxY - minY) * 0.15 || 0.1;
        minY -= pad; maxY += pad;

        // background grid lines
        ctx.strokeStyle = '#eef5ff';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
          const y = padding + (cssH - padding * 2) * (i / 4);
          ctx.beginPath();
          ctx.moveTo(padding, y);
          ctx.lineTo(cssW - padding, y);
          ctx.stroke();
        }

        // draw phi reference
        const phiY = mapY(phi, minY, maxY, cssH, padding);
        ctx.beginPath();
        ctx.strokeStyle = '#0b84ff';
        ctx.setLineDash([4, 6]);
        ctx.moveTo(padding, phiY);
        ctx.lineTo(cssW - padding, phiY);
        ctx.stroke();
        ctx.setLineDash([]);

        // draw ratio polyline
        ctx.beginPath();
        ctx.strokeStyle = COLORS.ratioLine;
        ctx.lineWidth = 2;
        ctx.moveTo(padding, mapY(ratios[0], minY, maxY, cssH, padding));
        for (let i = 1; i < ratios.length; i++) {
          const x = padding + i * xStep;
          const y = mapY(ratios[i], minY, maxY, cssH, padding);
          ctx.lineTo(x, y);
        }
        ctx.stroke();

        // draw points
        ctx.fillStyle = COLORS.ratioLine;
        for (let i = 0; i < ratios.length; i++) {
          const x = padding + i * xStep;
          const y = mapY(ratios[i], minY, maxY, cssH, padding);
          ctx.beginPath();
          ctx.arc(x, y, 3.5, 0, Math.PI * 2);
          ctx.fill();
        }

        // labels
        ctx.fillStyle = '#0b1730';
        ctx.font = '12px system-ui, sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(`φ ≈ ${phi.toFixed(6)}`, cssW - padding, phiY - 8);

        ctx.restore();

        // helpers
        function mapY(val, min, max, height, padding) {
          const t = (val - min) / (max - min || 1);
          return padding + (1 - t) * (height - padding * 2);
        }
      }

      // Utilities
      function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      // Initialize sequence from current inputs
      init();

      // Expose nothing globally
    })();
  </script>
</body>
</html>