<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Heap (Min/Max) — Interactive Module</title>
  <style>
    :root{
      --safe:24px;
      --gap:16px;
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#06b6d4;
      --muted:#94a3b8;
      --card:#071024;
      --success:#10b981;
      --danger:#ef4444;
      --node-size:56px;
    }
    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,#071428 0%, #031528 100%);
      color:#e6eef8;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    /* Safe area margin 24px */
    .app {
      padding: var(--safe);
      box-sizing: border-box;
      min-height:100%;
      display:flex;
      gap:var(--gap);
    }

    /* Left column: description */
    .sidebar {
      min-width:320px;
      max-width:380px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:20px;
      box-sizing:border-box;
      border:1px solid rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .title {
      font-size:20px;
      font-weight:700;
      color:var(--accent);
      display:flex;
      align-items:center;
      gap:10px;
    }
    .subtitle{
      color:var(--muted);
      font-size:13px;
    }
    .section {
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      border-radius:8px;
      padding:12px;
      box-sizing:border-box;
      border:1px solid rgba(255,255,255,0.02);
    }
    .section h3{
      margin:0 0 8px 0;
      font-size:13px;
      color:#cfeaf2;
    }
    .section p{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    /* Right column: interactive module */
    .main {
      flex:1;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      min-width:0;
    }

    .controls {
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
      background: linear-gradient(180deg, rgba(255,255,255,0.012), transparent);
      border:1px solid rgba(255,255,255,0.02);
      padding:14px;
      border-radius:12px;
    }
    .controls .group {
      display:flex;
      gap:10px;
      align-items:center;
    }
    input[type="text"]{
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:rgba(255,255,255,0.02);
      color:inherit;
      min-width:120px;
      outline:none;
    }
    button, .toggle {
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:rgba(255,255,255,0.02);
      color:inherit;
      cursor:pointer;
      font-weight:600;
    }
    button:active { transform:translateY(1px); }
    .primary {
      background:linear-gradient(90deg,var(--accent),#7dd3fc22);
      border:1px solid rgba(6,182,212,0.2);
      color:#021823;
    }
    .danger {
      background:linear-gradient(90deg,var(--danger),#ff8787cc);
      border:1px solid rgba(239,68,68,0.18);
      color:white;
    }
    .muted {
      background:transparent;
      color:var(--muted);
    }

    .toggles { display:flex; gap:8px; align-items:center; }

    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:12px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.02);
      display:flex;
      gap:var(--gap);
    }

    /* Visual area */
    .visual {
      flex:1;
      min-height:420px;
      position:relative;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    /* Tree area */
    .tree-area {
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      border-radius:10px;
      padding:12px;
      position:relative;
      flex:1;
      min-height:320px;
      overflow:hidden;
    }

    .tree-canvas {
      position:relative;
      width:100%;
      height:100%;
      box-sizing:border-box;
    }

    .node {
      position:absolute;
      width:var(--node-size);
      height:var(--node-size);
      border-radius:50%;
      background:linear-gradient(180deg,#072a3a, #06323f);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      color:#e6faff;
      box-shadow:0 6px 18px rgba(2,6,23,0.6), inset 0 -6px 10px rgba(255,255,255,0.02);
      border:2px solid rgba(255,255,255,0.03);
      transition: transform 350ms ease, top 350ms ease, left 350ms ease;
      transform:translate(-50%, -50%);
      z-index:2;
    }
    .node .idx {
      position:absolute;
      bottom:-18px;
      right:-10px;
      background:rgba(255,255,255,0.03);
      color:var(--muted);
      font-size:11px;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.02);
      font-weight:600;
    }
    .node.highlight {
      box-shadow:0 10px 28px rgba(6,182,212,0.14), 0 0 0 6px rgba(6,182,212,0.06);
      transform:translate(-50%,-50%) scale(1.06);
    }
    .node.swap {
      background: linear-gradient(180deg,#3b82f6,#1e40af);
    }
    .node.min { border-color: rgba(16,185,129,0.12); }
    .node.max { border-color: rgba(245,158,11,0.12); }

    /* Array representation */
    .array {
      display:flex;
      gap:8px;
      align-items:center;
      padding:8px;
      border-radius:8px;
      background:rgba(255,255,255,0.01);
      border:1px solid rgba(255,255,255,0.02);
      flex-wrap:wrap;
      min-height:64px;
    }
    .arr-item {
      min-width:56px;
      height:48px;
      background:linear-gradient(180deg,#031827,#042235);
      border-radius:8px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#cfeaf2;
      font-weight:700;
      border:1px solid rgba(255,255,255,0.02);
      position:relative;
      padding:0 8px;
    }
    .arr-item.idx {
      font-size:12px;
      color:var(--muted);
    }
    .arr-item.highlight {
      outline:3px solid rgba(6,182,212,0.08);
      transform:scale(1.04);
    }

    /* Log */
    .log {
      background:rgba(0,0,0,0.06);
      border-radius:8px;
      padding:10px;
      min-height:72px;
      max-height:120px;
      overflow:auto;
      font-size:13px;
      color:var(--muted);
    }
    .log .entry { margin-bottom:6px; }
    .log .entry strong { color:var(--accent); font-weight:700; }

    /* small screens */
    @media (max-width:920px){
      .app { flex-direction:column; }
      .sidebar { max-width:100%; min-width:0; order:2; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Heap interactive module">
    <!-- Sidebar: Concept Title, Learning Objective, Interaction Design, Layout Description -->
    <aside class="sidebar" aria-labelledby="module-title">
      <div>
        <div id="module-title" class="title">Heap (Min / Max)</div>
        <div class="subtitle">Visual, step-by-step build, insert, and extract with animations</div>
      </div>

      <div class="section" aria-labelledby="learning-objective">
        <h3 id="learning-objective">Learning Objective</h3>
        <p>
          Understand how a binary heap enforces the min-heap or max-heap property.
          Interactively observe insert (sift-up), extract-root (sift-down), and build-heap operations.
          After interacting, you should be able to trace comparisons and swaps and explain why the structure maintains its invariant.
        </p>
      </div>

      <div class="section" aria-labelledby="interaction-design">
        <h3 id="interaction-design">Interaction Design</h3>
        <p>
          Controls let you Insert values, Extract the root, Build from an array, or generate Random data.
          Toggle between Min and Max mode. Use "Step Mode" to advance each comparison/swap manually, or run animations at adjustable speed.
          Visual cues: nodes being compared highlight, swaps animate, and array representation syncs.
        </p>
      </div>

      <div class="section" aria-labelledby="layout-description">
        <h3 id="layout-description">Layout Description</h3>
        <p>
          Left panel (this column) contains explanations and guidance. The right panel is the interactive module: controls on top, tree visualization in the middle, array view and action log below.
          Spacing: 24px safe margins, 16px minimum gap between interactive elements. Responsive: columns stack on narrow screens. All interactive controls are keyboard-focusable and labeled.
        </p>
      </div>
    </aside>

    <!-- Main interactive area -->
    <main class="main" aria-live="polite">
      <!-- Controls -->
      <div class="controls" role="region" aria-label="Controls">
        <div class="group">
          <input id="value-input" type="text" inputmode="numeric" placeholder="Enter value e.g. 42" aria-label="Value to insert" />
          <button id="insert-btn" class="primary" title="Insert value (Enter)" aria-label="Insert value">Insert</button>
          <button id="extract-btn" class="danger" aria-label="Extract root">Extract Root</button>
        </div>

        <div class="group">
          <input id="array-input" type="text" placeholder="Array e.g. 4,1,7,3" aria-label="Array to build" />
          <button id="build-btn" class="muted" aria-label="Build heap from array">Build Heap</button>
          <button id="random-btn" class="muted" aria-label="Randomize heap">Random</button>
        </div>

        <div class="toggles" style="margin-left:auto;">
          <label class="muted" style="font-size:13px;align-self:center;">Mode</label>
          <select id="mode-select" aria-label="Heap mode: Min or Max" title="Min or Max">
            <option value="min">Min-Heap</option>
            <option value="max">Max-Heap</option>
          </select>

          <label style="font-size:13px;align-self:center;margin-left:8px;">Speed</label>
          <input id="speed-range" type="range" min="50" max="1000" value="350" aria-label="Animation speed" title="Animation delay (ms)" />

          <label class="muted" style="margin-left:8px;">Step Mode</label>
          <button id="step-toggle" class="toggle" aria-pressed="false" aria-label="Toggle step mode">Off</button>
          <button id="next-step" class="muted" aria-label="Advance step" disabled>Next Step</button>
        </div>
      </div>

      <!-- Panel with visual tree and array -->
      <div class="panel" role="region" aria-label="Heap visualization">
        <div class="visual" style="flex:1;">
          <div class="tree-area" id="tree-area" aria-label="Heap tree visualization">
            <svg id="links" style="position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:1;"></svg>
            <div class="tree-canvas" id="tree-canvas" aria-hidden="false"></div>
          </div>

          <div>
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
              <div style="color:var(--muted);font-size:13px;">Array Representation (indices)</div>
              <div style="display:flex;gap:8px;align-items:center;">
                <button id="peek-btn" class="muted" aria-label="Peek root">Peek Root</button>
                <button id="clear-btn" class="muted" aria-label="Clear heap">Clear</button>
              </div>
            </div>
            <div class="array" id="array-view" aria-live="polite"></div>
          </div>
        </div>

        <div style="width:320px;display:flex;flex-direction:column;gap:12px;">
          <div style="font-size:13px;color:var(--muted);">Action Log</div>
          <div class="log" id="log" aria-live="polite"></div>
          <div style="font-size:12px;color:var(--muted);">Tips: Use Step Mode to trace each compare/swap. Toggle Min/Max to observe different invariants.</div>
        </div>
      </div>
    </main>
  </div>

  <script>
    // Heap Interactive Module
    // Vanilla JS, self-contained. Implements a visual binary heap with animated sift-up/sift-down,
    // build-heap, insertion, extraction, and step-by-step mode.

    (function(){
      // Utilities
      const $ = sel => document.querySelector(sel);
      const qs = (el, sel) => el.querySelector(sel);
      const treeCanvas = $('#tree-canvas');
      const linksSVG = $('#links');
      const arrayView = $('#array-view');
      const logEl = $('#log');

      // Controls
      const inputVal = $('#value-input');
      const insertBtn = $('#insert-btn');
      const extractBtn = $('#extract-btn');
      const buildBtn = $('#build-btn');
      const arrayInput = $('#array-input');
      const randomBtn = $('#random-btn');
      const modeSelect = $('#mode-select');
      const speedRange = $('#speed-range');
      const stepToggle = $('#step-toggle');
      const nextStepBtn = $('#next-step');
      const peekBtn = $('#peek-btn');
      const clearBtn = $('#clear-btn');

      // Config
      let mode = 'min'; // 'min' or 'max'
      let delay = Number(speedRange.value); // ms
      let stepMode = false;
      let awaitingStep = null;

      // Data model: array of {value:number, el:HTMLElement}
      let heap = [];

      // Animation control
      let animTicker = null;
      let animActive = false;

      // Accessibility: announce to log
      function log(text, strong) {
        const entry = document.createElement('div');
        entry.className = 'entry';
        entry.innerHTML = strong ? `<strong>${strong}</strong> ${text}` : text;
        logEl.prepend(entry);
      }

      // Comparator
      function cmp(a, b){
        if (mode === 'min') return a < b;
        return a > b;
      }

      // Create node element for a value
      function createNode(value){
        const node = document.createElement('div');
        node.className = 'node';
        node.setAttribute('role','img');
        node.setAttribute('aria-label','Heap node value '+String(value));
        node.innerHTML = `<span class="val">${value}</span><span class="idx">0</span>`;
        treeCanvas.appendChild(node);
        // transitions are CSS based: left/top are set in positioning
        return node;
      }

      // Layout calculation: position nodes by index
      function computePosition(index, totalWidth, totalHeight){
        // level of node:
        const level = Math.floor(Math.log2(index+1));
        const levelStart = (1<<level)-1;
        const posInLevel = index - levelStart;
        const nodesInLevel = 1<<level;
        const paddingX = 40;
        const availableWidth = Math.max(100, totalWidth - paddingX*2);
        const x = paddingX + (posInLevel + 1) * (availableWidth / (nodesInLevel + 1));
        const levelGap = Math.max(72, (totalHeight - 60) / Math.max(3, Math.ceil(Math.log2(heap.length+1))));
        const y = 30 + level * levelGap;
        return {x, y};
      }

      // Render positions of all nodes; animate via CSS transitions on left/top
      function renderPositions(animate=true){
        const rect = treeCanvas.getBoundingClientRect();
        const w = rect.width;
        const h = rect.height;
        heap.forEach((item, idx) => {
          const pos = computePosition(idx, w, h);
          const el = item.el;
          el.style.left = pos.x + 'px';
          el.style.top = pos.y + 'px';
          const idxLabel = el.querySelector('.idx');
          if (idxLabel) idxLabel.textContent = idx;
          el.querySelector('.val').textContent = item.value;
          // Mark min/max via class
          el.classList.toggle('min', mode === 'min');
          el.classList.toggle('max', mode === 'max');
        });
        updateLinks();
        // set running ticker while transitions are active
        if (animate){
          startAnimTicker();
        }
        renderArray();
      }

      // Draw connecting lines using SVG between parent and child centers
      function updateLinks(){
        const svg = linksSVG;
        while(svg.firstChild) svg.removeChild(svg.firstChild);
        const rect = treeCanvas.getBoundingClientRect();
        const offset = {left: treeCanvas.offsetLeft, top: treeCanvas.offsetTop};
        // We need coordinates relative to svg
        heap.forEach((item, idx) => {
          const left = item.el.offsetLeft + (item.el.offsetWidth/2);
          const top = item.el.offsetTop + (item.el.offsetHeight/2);
          const leftRel = left;
          const topRel = top;
          const leftChildIdx = 2*idx + 1;
          const rightChildIdx = 2*idx + 2;
          [leftChildIdx, rightChildIdx].forEach(ci => {
            if (ci < heap.length){
              const child = heap[ci];
              const childLeft = child.el.offsetLeft + (child.el.offsetWidth/2);
              const childTop = child.el.offsetTop + (child.el.offsetHeight/2);
              const line = document.createElementNS("http://www.w3.org/2000/svg","line");
              line.setAttribute('x1', leftRel);
              line.setAttribute('y1', topRel+18);
              line.setAttribute('x2', childLeft);
              line.setAttribute('y2', childTop-18);
              line.setAttribute('stroke', 'rgba(255,255,255,0.06)');
              line.setAttribute('stroke-width', '2');
              line.setAttribute('stroke-linecap','round');
              svg.appendChild(line);
            }
          });
        });
      }

      // Render array view
      function renderArray(highlights){
        // highlight is {i,j} or indices array
        arrayView.innerHTML = '';
        heap.forEach((item, idx) => {
          const div = document.createElement('div');
          div.className = 'arr-item';
          if (highlights && highlights.includes(idx)) div.classList.add('highlight');
          div.textContent = String(item.value);
          const idxBadge = document.createElement('div');
          idxBadge.className = 'idx';
          idxBadge.textContent = idx;
          div.appendChild(idxBadge);
          arrayView.appendChild(div);
        });
      }

      // Animation ticker updates links continuously while nodes move
      function startAnimTicker(){
        if (animActive) return;
        animActive = true;
        let last = performance.now();
        const tick = (t) => {
          updateLinks();
          const any = heap.some(it => {
            // We'll approximate whether a transition is in progress by seeing transform style
            // but simpler: keep a small timeout after start
            return true;
          });
          // Keep ticker running for short while: stop after delay + 80ms
          const now = performance.now();
          if (now - last < delay + 120){
            animTicker = requestAnimationFrame(tick);
          } else {
            animActive = false;
            cancelAnimationFrame(animTicker);
          }
        };
        animTicker = requestAnimationFrame(tick);
      }

      // Helpers for async stepping and delays
      function wait(ms){
        return new Promise(res => setTimeout(res, ms));
      }

      function stepPause(){
        if (!stepMode) return wait(delay);
        // Step mode: return promise that resolves when user clicks Next Step
        return new Promise(res => {
          awaitingStep = res;
          nextStepBtn.disabled = false;
          nextStepBtn.focus();
        });
      }

      // Public control interactions
      insertBtn.addEventListener('click', () => {
        const v = inputVal.value.trim();
        if (!v) return;
        const num = Number(v);
        if (!isFinite(num)){
          log('Please enter a valid number');
          return;
        }
        inputVal.value = '';
        insertValue(num);
      });
      inputVal.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') insertBtn.click();
      });

      extractBtn.addEventListener('click', () => {
        extractRoot();
      });

      buildBtn.addEventListener('click', async () => {
        const raw = arrayInput.value.trim();
        if (!raw) return;
        const items = raw.split(',').map(s=>s.trim()).filter(Boolean).map(Number).filter(n=>isFinite(n));
        if (!items.length) return;
        await buildHeap(items);
      });

      randomBtn.addEventListener('click', async () => {
        const size = Math.floor(Math.random()*7)+3;
        const items = Array.from({length:size}, ()=>Math.floor(Math.random()*100));
        arrayInput.value = items.join(',');
        await buildHeap(items);
      });

      modeSelect.addEventListener('change', async () => {
        mode = modeSelect.value;
        log('Mode changed to '+mode.toUpperCase());
        // Rebuild in new mode preserving values: heapify
        await heapifyAnimated();
      });

      speedRange.addEventListener('input', () => {
        delay = Number(speedRange.value);
      });

      stepToggle.addEventListener('click', () => {
        stepMode = !stepMode;
        stepToggle.textContent = stepMode ? 'On' : 'Off';
        stepToggle.setAttribute('aria-pressed', String(stepMode));
        nextStepBtn.disabled = !stepMode;
        log('Step Mode ' + (stepMode ? 'enabled' : 'disabled'));
      });

      nextStepBtn.addEventListener('click', () => {
        if (awaitingStep){
          awaitingStep();
          awaitingStep = null;
          nextStepBtn.disabled = true;
        }
      });

      peekBtn.addEventListener('click', () => {
        if (!heap.length) { log('Heap is empty'); return; }
        log('Root: ' + heap[0].value, 'Peek:');
      });

      clearBtn.addEventListener('click', () => {
        clearHeap();
      });

      // Core heap operations with animated steps
      async function insertValue(value){
        const nodeEl = createNode(value);
        const nodeObj = {value, el: nodeEl};
        heap.push(nodeObj);
        renderPositions();
        log('Inserted ' + value, 'Insert:');
        await wait(20);
        // sift-up with animations
        await siftUp(heap.length - 1);
      }

      async function extractRoot(){
        if (!heap.length){
          log('Heap is empty');
          return;
        }
        const rootVal = heap[0].value;
        log('Extracting root ' + rootVal, 'Extract:');
        // replace root with last
        if (heap.length === 1){
          // remove node element
          const lone = heap.pop();
          lone.el.remove();
          renderPositions();
          return;
        }
        // swap 0 and last, then pop last (animate)
        await highlightIndices([0, heap.length-1], 'highlight');
        // swap items in array
        swapItems(0, heap.length-1);
        await stepPause();
        renderPositions();
        await wait(delay);
        // remove last node element
        const removed = heap.pop();
        removed.el.remove();
        renderPositions();
        // sift-down new root
        await siftDown(0);
      }

      // Swap helper (data model swap)
      function swapItems(i,j){
        const tmp = heap[i];
        heap[i] = heap[j];
        heap[j] = tmp;
      }

      // Highlight indices helper
      async function highlightIndices(indices, cls='highlight'){
        indices.forEach(i => {
          if (heap[i]) heap[i].el.classList.add(cls);
        });
        renderArray(indices);
        await wait(Math.min(200, delay));
        indices.forEach(i => {
          if (heap[i]) heap[i].el.classList.remove(cls);
        });
        renderArray();
      }

      // Sift-up from index i
      async function siftUp(i){
        let idx = i;
        while (idx > 0){
          const parent = Math.floor((idx-1)/2);
          // highlight compare
          heap[idx].el.classList.add('highlight');
          heap[parent].el.classList.add('highlight');
          renderArray([idx, parent]);
          log(`Compare ${heap[idx].value} and parent ${heap[parent].value}`);
          await stepPause();
          // compare values
          if (cmp(heap[idx].value, heap[parent].value)){
            // swap
            heap[idx].el.classList.add('swap');
            heap[parent].el.classList.add('swap');
            log(`Swap ${heap[idx].value} ↔ ${heap[parent].value}`, 'Swap:');
            swapItems(idx, parent);
            renderPositions();
            await wait(delay);
            heap[idx].el.classList.remove('swap');
            heap[parent].el.classList.remove('swap');
            // continue up
            heap[idx].el.classList.remove('highlight');
            heap[parent].el.classList.remove('highlight');
            idx = parent;
          } else {
            // no swap, done
            heap[idx].el.classList.remove('highlight');
            heap[parent].el.classList.remove('highlight');
            renderArray();
            break;
          }
        }
      }

      // Sift-down from index i
      async function siftDown(i){
        let idx = i;
        const n = () => heap.length;
        while (true){
          const left = 2*idx + 1;
          const right = 2*idx + 2;
          let chosen = idx;
          if (left < n()){
            // compare with left
            heap[idx].el.classList.add('highlight');
            heap[left].el.classList.add('highlight');
            renderArray([idx,left]);
            log(`Compare ${heap[idx].value} and left ${heap[left].value}`);
            await stepPause();
            if (cmp(heap[left].value, heap[chosen].value)) chosen = left;
            heap[idx].el.classList.remove('highlight');
            heap[left].el.classList.remove('highlight');
          }
          if (right < n()){
            heap[chosen].el.classList.add('highlight');
            heap[right].el.classList.add('highlight');
            renderArray([chosen,right]);
            log(`Compare ${heap[chosen].value} and right ${heap[right].value}`);
            await stepPause();
            if (cmp(heap[right].value, heap[chosen].value)) chosen = right;
            heap[chosen].el.classList.remove('highlight');
            heap[right].el.classList.remove('highlight');
          }
          if (chosen !== idx){
            heap[idx].el.classList.add('swap');
            heap[chosen].el.classList.add('swap');
            log(`Swap ${heap[idx].value} ↔ ${heap[chosen].value}`, 'Swap:');
            swapItems(idx, chosen);
            renderPositions();
            await wait(delay);
            heap[idx].el.classList.remove('swap');
            heap[chosen].el.classList.remove('swap');
            idx = chosen;
          } else break;
        }
      }

      // Heapify (build-heap) animated: perform sift-down from last non-leaf down to 0
      async function buildHeap(values){
        // clear current
        clearHeap(false);
        // create nodes
        values.forEach(v => {
          const el = createNode(v);
          heap.push({value:v, el});
        });
        renderPositions();
        log('Building heap from array', 'Build:');
        // perform sift-down from floor(n/2)-1 down to 0
        const start = Math.floor(heap.length/2) - 1;
        for (let i = start; i >= 0; i--){
          log(`Sift-down at index ${i}`, 'Heapify:');
          await siftDown(i);
        }
        renderPositions();
        log('Build complete');
      }

      async function heapifyAnimated(){
        // rebuild current values in new mode
        const values = heap.map(h => h.value);
        await buildHeap(values);
      }

      function clearHeap(logIt=true){
        heap.forEach(it => it.el.remove());
        heap = [];
        renderArray();
        if (logIt) log('Cleared heap');
      }

      // Initial render
      renderPositions();

      // Responsive: reposition nodes on resize
      window.addEventListener('resize', () => renderPositions(false));

      // Initialize with a sample
      (async function initSample(){
        const sample = [42,31,28,10,18,15,7];
        arrayInput.value = sample.join(',');
        await buildHeap(sample);
      })();

      // Expose some internals for debugging (not required)
      window.HeapViz = {
        insertValue, extractRoot, buildHeap, clearHeap, heapRef: heap
      };
    })();
  </script>
</body>
</html>