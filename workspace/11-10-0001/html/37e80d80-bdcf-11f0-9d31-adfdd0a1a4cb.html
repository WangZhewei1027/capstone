<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Huffman Coding Module</title>
  <style>
    /* Safe area margins: 24px on all sides */
    html,body {
      height: 100%;
      margin: 0;
    }
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      padding: 24px;
      box-sizing: border-box;
      background: linear-gradient(180deg,#f7fbff,#ffffff);
      color: #0b2545;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Layout: responsive two-column, stacks on narrow screens */
    .container {
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 24px; /* ensure at least 16px between elements; using 24 for comfortable spacing */
      min-height: calc(100vh - 48px);
      align-items: start;
    }

    @media (max-width: 880px) {
      .container {
        grid-template-columns: 1fr;
      }
    }

    /* Left panel: controls and description */
    .panel {
      background: #ffffff;
      border-radius: 10px;
      box-shadow: 0 6px 18px rgba(8,30,63,0.08);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    h1 {
      margin: 0;
      font-size: 20px;
      color: #04213a;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .meta {
      font-size: 13px;
      color: #25425a;
      line-height: 1.35;
    }

    /* Symbol editor */
    .symbols {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 6px;
    }

    .symbol-row {
      display: grid;
      grid-template-columns: 60px 1fr 80px;
      gap: 12px;
      align-items: center;
    }

    .symbol-row input[type="text"],
    .symbol-row input[type="number"] {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #d6e2ee;
      font-size: 14px;
      background: #fbfdff;
    }

    .symbol-row button {
      padding: 8px 10px;
      border-radius: 8px;
      border: none;
      background: #0b66ff;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: transform .12s ease;
    }
    .symbol-row button:active { transform: scale(.98); }

    .controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    button.control {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(11,102,255,0.12);
      background: #fff;
      color: #063b7a;
      font-weight: 600;
      cursor: pointer;
    }

    button.control.primary {
      background: linear-gradient(180deg,#0b66ff,#0954d1);
      color: white;
      border: none;
      box-shadow: 0 6px 18px rgba(11,102,255,0.12);
    }

    button.control.secondary {
      background: #f6f9ff;
      color: #063b7a;
    }

    /* Priority queue display */
    .queue-box {
      background: linear-gradient(180deg,#fbfdff,#f4f9ff);
      padding: 12px;
      border-radius: 10px;
      border: 1px solid #e6eefb;
      min-height: 64px;
      display: flex;
      gap: 12px;
      align-items: center;
      overflow-x: auto;
    }

    .queue-item {
      background: #ffffff;
      border-radius: 10px;
      padding: 10px 12px;
      min-width: 72px;
      text-align: center;
      box-shadow: 0 4px 14px rgba(9,33,63,0.06);
      border: 1px solid #e6eefb;
      transition: transform .25s cubic-bezier(.2,.9,.2,1), box-shadow .2s;
      display: inline-block;
      font-weight: 700;
      color: #053057;
    }

    .queue-item.small {
      opacity: 0.88;
      font-weight: 600;
      font-size: 13px;
    }

    .queue-item.highlight {
      transform: translateY(-8px) scale(1.04);
      box-shadow: 0 10px 26px rgba(11,102,255,0.14);
      border-color: #a8cffb;
    }

    /* Right panel: visualization */
    .visual {
      background: #fff;
      border-radius: 10px;
      padding: 18px;
      min-height: 420px;
      box-shadow: 0 6px 18px rgba(8,30,63,0.06);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .vis-top {
      display: flex;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
    }

    /* SVG container will be responsive */
    .tree-area {
      background: linear-gradient(180deg,#ffffff,#fbfdff);
      border-radius: 10px;
      padding: 12px;
      border: 1px solid #eef6ff;
      flex: 1 1 auto;
      min-height: 260px;
      position: relative;
      overflow: auto;
    }

    svg.tree {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Node styles (SVG) */
    .node-circle {
      fill: #ffffff;
      stroke: #0b66ff;
      stroke-opacity: 0.12;
      stroke-width: 2;
      filter: drop-shadow(0 6px 14px rgba(11,102,255,0.06));
      transition: transform .36s cubic-bezier(.2,.9,.2,1), opacity .28s;
    }
    .node-circle.highlight {
      fill: #eaf4ff;
      stroke-opacity: 0.6;
      transform: scale(1.06);
    }
    .node-text {
      font-weight: 700;
      fill: #052a4a;
      font-size: 12px;
      pointer-events: none;
    }
    .edge {
      stroke: #8fbcf7;
      stroke-width: 2;
      stroke-linecap: round;
      opacity: 0.9;
      transition: stroke-opacity .2s, stroke .2s;
    }
    .edge.weak {
      stroke: #cfe6ff;
      opacity: 0.6;
    }

    /* Code table */
    .codes {
      display: grid;
      grid-template-columns: repeat(auto-fit,minmax(120px,1fr));
      gap: 10px;
      margin-top: 8px;
    }

    .code-card {
      background: #fbfdff;
      border-radius: 8px;
      padding: 8px 10px;
      border: 1px solid #e8f2ff;
      font-weight: 700;
      color: #053057;
    }

    /* Encoding area */
    .encoder {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    .encoder input[type="text"] {
      flex: 1 1 240px;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #d6e2ee;
      background: #fbfdff;
    }

    .bit-output {
      background: #ffffff;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #e6eefb;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      color: #052a4a;
      min-height: 48px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .bit-pill {
      background: #f1f8ff;
      color: #04407a;
      padding: 4px 8px;
      border-radius: 6px;
      font-weight: 700;
      border: 1px solid #d9eeff;
      transition: transform .14s;
    }

    .bit-pill.playing {
      transform: translateY(-6px) scale(1.04);
      background: linear-gradient(180deg,#dff0ff,#bfe5ff);
      border-color: #9ad4ff;
    }

    /* Explanation / step text */
    .explain {
      background: linear-gradient(180deg,#fff,#fbfdff);
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #e6eefb;
      min-height: 56px;
      color: #12314a;
      font-size: 14px;
    }

    footer.note {
      margin-top: 6px;
      font-size: 12px;
      color: #3b596e;
    }

    /* Accessibility focus */
    button:focus, input:focus {
      outline: 3px solid rgba(11,102,255,0.12);
      outline-offset: 2px;
    }

    /* Small helpers */
    .muted { color: #5a778e; font-size: 13px; }
    .row { display:flex; gap:12px; align-items:center; }
    .spacer { flex:1 1 auto; }

  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Huffman Coding interactive module">
    <!-- LEFT PANEL: controls and description -->
    <section class="panel" aria-labelledby="title">
      <div>
        <h1 id="title">Huffman Coding — Build an optimal prefix code</h1>
        <p class="meta">Interactively create symbols and frequencies, step through the Huffman algorithm, and see how the optimal binary codes are formed and used to encode text.</p>
      </div>

      <div>
        <strong>Learning Objective</strong>
        <p class="muted" id="objective">
          After interacting with this module you will understand how Huffman Coding builds a minimum-redundancy binary prefix code from symbol frequencies, how the Huffman tree is constructed step-by-step, and how codes are derived and applied to encode a message.
        </p>
      </div>

      <div>
        <strong>Symbol Frequencies</strong>
        <p class="muted">Add symbols (single character labels) and set their frequencies. Minimum two symbols required.</p>

        <div class="symbols" id="symbolsList" aria-live="polite">
          <!-- symbol rows inserted here -->
        </div>

        <div style="margin-top:8px;" class="controls">
          <button class="control primary" id="addSymbolBtn" title="Add a new symbol">Add Symbol</button>
          <button class="control" id="randomBtn" title="Fill with random example">Random Example</button>
          <button class="control" id="resetBtn" title="Reset to default">Reset</button>
        </div>
      </div>

      <div>
        <strong>Priority Queue</strong>
        <div class="queue-box" id="queueBox" aria-live="polite" aria-label="Priority queue of nodes">
          <!-- queue items -->
        </div>
      </div>

      <div>
        <strong>Controls</strong>
        <div style="display:flex; gap:12px; margin-top:8px; flex-wrap:wrap;">
          <button class="control primary" id="stepBtn">Build Step</button>
          <button class="control" id="playBtn">Auto-Play</button>
          <button class="control secondary" id="buildAllBtn">Build All</button>
          <button class="control" id="undoBtn" title="Undo one step">Undo</button>
        </div>
      </div>

      <div>
        <strong>About this module</strong>
        <div class="muted" style="font-size:13px;">
          <p style="margin:6px 0;"><strong>Interaction Design:</strong> Edit or add symbols. Use "Build Step" to merge the two smallest-frequency nodes; each merge animates the creation of a parent node in the tree and updates the priority queue. Use Auto-Play to animate all steps. When complete, codes are shown and you can encode/decode a message using them. The visualization animates node highlights and code bit playback to reinforce how tree structure determines bit prefixes.</p>
          <p style="margin:6px 0;"><strong>Layout Description:</strong> Left column contains controls and the priority queue; right column shows the Huffman tree visualization, the resulting codes, and an encoder/decoder. Safe area margin is 24px; elements have at least 16px gaps and scale responsively for smaller screens. All interactive controls are keyboard-accessible and labeled for screen readers.</p>
        </div>
      </div>

    </section>

    <!-- RIGHT PANEL: visualization and encoder -->
    <main class="visual" aria-live="polite">
      <div class="vis-top">
        <div>
          <strong>Huffman Tree</strong>
          <div class="muted" style="font-size:13px;">Watch merges animate and observe code assignment.</div>
        </div>
        <div style="display:flex; gap:12px; align-items:center;">
          <div class="muted">Total bits: <span id="totalBits">—</span></div>
          <div class="muted">Fixed-length bits: <span id="fixedBits">—</span></div>
        </div>
      </div>

      <div class="tree-area" id="treeArea" tabindex="0" aria-label="Huffman tree visualization">
        <!-- SVG tree -->
        <svg class="tree" id="svgTree" viewBox="0 0 1000 360" preserveAspectRatio="xMidYMin meet" role="img" aria-hidden="false"></svg>
      </div>

      <div>
        <strong>Codes</strong>
        <div class="codes" id="codesGrid" aria-live="polite">
          <!-- code cards -->
        </div>
      </div>

      <div>
        <strong>Encode / Decode</strong>
        <div class="encoder">
          <input type="text" id="messageInput" placeholder="Type message to encode (characters must match symbols)" aria-label="Message to encode" />
          <button class="control primary" id="encodeBtn">Encode</button>
          <button class="control" id="decodeBtn">Decode</button>
        </div>
        <div style="margin-top:8px;">
          <div class="bit-output" id="bitOutput" aria-live="polite">Encoded bits will appear here</div>
        </div>
      </div>

      <div>
        <strong>Step Explanation</strong>
        <div class="explain" id="explain" aria-live="assertive">Ready. Add symbols or press "Random Example" to try a preset built example.</div>
      </div>

      <footer class="note">Tip: For clarity use small alphabets first (3–7 symbols). The algorithm always chooses the two smallest current nodes to merge; ties are broken by insertion order.</footer>
    </main>
  </div>

  <script>
    // Huffman Interactive Module - Vanilla JS
    (function () {
      // Utility short-hands
      const $ = (sel, ctx = document) => ctx.querySelector(sel);
      const $$ = (sel, ctx = document) => Array.from(ctx.querySelectorAll(sel));
      const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;

      // DOM elements
      const symbolsList = $('#symbolsList');
      const addSymbolBtn = $('#addSymbolBtn');
      const randomBtn = $('#randomBtn');
      const resetBtn = $('#resetBtn');
      const queueBox = $('#queueBox');
      const stepBtn = $('#stepBtn');
      const playBtn = $('#playBtn');
      const buildAllBtn = $('#buildAllBtn');
      const undoBtn = $('#undoBtn');
      const svgTree = $('#svgTree');
      const codesGrid = $('#codesGrid');
      const explain = $('#explain');
      const totalBitsEl = $('#totalBits');
      const fixedBitsEl = $('#fixedBits');
      const messageInput = $('#messageInput');
      const encodeBtn = $('#encodeBtn');
      const decodeBtn = $('#decodeBtn');
      const bitOutput = $('#bitOutput');

      // Module state
      let nodes = [];       // active nodes in PQ (objects)
      let history = [];     // history of merges (for undo)
      let allNodes = {};    // id->node for tree drawing
      let nextId = 1;
      let autoPlayTimer = null;
      let playing = false;
      let codes = null;

      // Accessibility: announce changes
      function announce(text) {
        explain.textContent = text;
      }

      // Node structure: { id, symbols: [chars], freq, left, right, createdAt }
      function createLeaf(symbol, freq) {
        const id = String(nextId++);
        const node = { id, symbols: [symbol], freq: Number(freq), left: null, right: null, createdAt: Date.now() + Math.random() };
        allNodes[id] = node;
        return node;
      }

      function createInternal(left, right) {
        const id = String(nextId++);
        const node = { id, symbols: left.symbols.concat(right.symbols), freq: left.freq + right.freq, left: left.id, right: right.id, createdAt: Date.now() + Math.random() };
        allNodes[id] = node;
        return node;
      }

      // Priority: sort by freq asc, tie-break by createdAt
      function sortQueue(q) {
        q.sort((a,b) => {
          if (a.freq !== b.freq) return a.freq - b.freq;
          return a.createdAt - b.createdAt;
        });
      }

      // Render symbol editor rows
      function renderSymbolRows() {
        symbolsList.innerHTML = '';
        if (nodes.length === 0) {
          // default two symbols
          addSymbolRow('A', 5);
          addSymbolRow('B', 9);
          return;
        }
        // show leaves (only symbols, not internal parents)
        const leaves = Object.values(allNodes).filter(n => !n.left && !n.right && nodes.some(q => q.id === n.id));
        leaves.forEach(n => {
          const row = document.createElement('div');
          row.className = 'symbol-row';
          const symInput = document.createElement('input');
          symInput.type = 'text';
          symInput.maxLength = 2;
          symInput.value = n.symbols[0];
          symInput.setAttribute('aria-label', 'Symbol label');
          const freqInput = document.createElement('input');
          freqInput.type = 'number';
          freqInput.min = 1;
          freqInput.value = n.freq;
          freqInput.setAttribute('aria-label', 'Symbol frequency');
          const removeBtn = document.createElement('button');
          removeBtn.textContent = 'Remove';
          removeBtn.title = 'Remove symbol';
          removeBtn.addEventListener('click', () => {
            removeSymbol(n.id);
          });
          // Update handlers
          symInput.addEventListener('input', (e) => {
            const v = e.target.value || '';
            n.symbols[0] = v.slice(0,1) || '?';
            updateQueueDisplay();
            updateCodesIfReady();
          });
          freqInput.addEventListener('change', (e) => {
            const v = Math.max(1, Math.floor(Number(e.target.value) || 1));
            n.freq = v;
            updateQueueFromLeaves();
            updateCodesIfReady();
          });
          row.appendChild(symInput);
          row.appendChild(freqInput);
          row.appendChild(removeBtn);
          symbolsList.appendChild(row);
        });
      }

      function addSymbolRow(symbol='?', freq=1) {
        // create new leaf node and add to PQ
        const leaf = createLeaf(symbol, freq);
        nodes.push(leaf);
        sortQueue(nodes);
        renderSymbolRows();
        updateQueueDisplay();
        announce(`Added symbol "${symbol}" with frequency ${freq}.`);
      }

      function removeSymbol(id) {
        // remove leaf only if leaf present in nodes
        const idx = nodes.findIndex(n => n.id === id);
        if (idx >= 0) {
          const sym = nodes[idx].symbols[0];
          nodes.splice(idx,1);
          delete allNodes[id];
          renderSymbolRows();
          updateQueueDisplay();
          announce(`Removed symbol "${sym}".`);
        }
      }

      function updateQueueFromLeaves() {
        // Keep only leaf nodes in nodes (for when freq changed via editor)
        // nodes currently contains leaves and possibly internals; but editor only edits leaves.
        // We will re-create nodes array to contain current leaves from allNodes that are leaves.
        const leafNodes = Object.values(allNodes).filter(n => !n.left && !n.right);
        // Keep only those that also exist in nodes list previously OR all leaf nodes.
        nodes = leafNodes.slice(); // shallow copy
        sortQueue(nodes);
        renderSymbolRows();
        updateQueueDisplay();
      }

      function clearAll() {
        nodes = [];
        history = [];
        allNodes = {};
        nextId = 1;
        codes = null;
        svgTree.innerHTML = '';
        codesGrid.innerHTML = '';
        totalBitsEl.textContent = '—';
        fixedBitsEl.textContent = '—';
        bitOutput.textContent = 'Encoded bits will appear here';
        renderSymbolRows();
        updateQueueDisplay();
        announce('Reset complete.');
      }

      // Update the visual priority queue
      function updateQueueDisplay(highlightIds=[]) {
        queueBox.innerHTML = '';
        sortQueue(nodes);
        nodes.forEach(n => {
          const div = document.createElement('div');
          div.className = 'queue-item small';
          if (highlightIds.includes(n.id)) div.classList.add('highlight');
          const sym = n.symbols.length === 1 ? n.symbols[0] : n.symbols.join(',');
          div.innerHTML = `<div style="font-size:12px;opacity:.9">${sym}</div><div style="font-size:14px">${n.freq}</div>`;
          queueBox.appendChild(div);
        });
      }

      // Render the Huffman tree using SVG
      function renderTree(rootId) {
        svgTree.innerHTML = '';
        if (!rootId) return;
        // compute layout: assign x positions to leaves via inorder, depth for y
        const root = allNodes[rootId];
        const positions = {};
        let leafCount = 0;
        function dfsCount(nId, depth) {
          const n = allNodes[nId];
          if (!n) return;
          if (!n.left && !n.right) {
            positions[nId] = { xIndex: leafCount++, depth };
            return;
          }
          dfsCount(n.left, depth+1);
          dfsCount(n.right, depth+1);
          // internal node x is average of children
          const leftPos = positions[n.left], rightPos = positions[n.right];
          positions[nId] = { xIndex: (leftPos.xIndex + rightPos.xIndex)/2, depth };
        }
        dfsCount(rootId, 0);
        const width = Math.max(600, svgTree.clientWidth || 800);
        const height = Math.max(300, svgTree.clientHeight || 360);
        const marginX = 40, marginY = 40;
        const availW = width - marginX*2;
        const maxDepth = Math.max(...Object.values(positions).map(p=>p.depth));
        const vgap = (height - marginY*2) / Math.max(1, maxDepth + 1);
        const hstep = leafCount > 1 ? availW / (leafCount - 1) : 0;
        // draw edges first
        const edges = [];
        for (const id in positions) {
          const p = positions[id];
          const n = allNodes[id];
          if (n.left && n.right) {
            const x = marginX + p.xIndex * hstep;
            const y = marginY + p.depth * vgap;
            const leftPos = positions[n.left];
            const rightPos = positions[n.right];
            const lx = marginX + leftPos.xIndex * hstep;
            const ly = marginY + leftPos.depth * vgap;
            const rx = marginX + rightPos.xIndex * hstep;
            const ry = marginY + rightPos.depth * vgap;
            edges.push({ from: {x,y}, to: {x:lx,y:ly}, parentId:id, childId:n.left, label: '0' });
            edges.push({ from: {x,y}, to: {x:rx,y:ry}, parentId:id, childId:n.right, label: '1' });
          }
        }
        // build svg
        svgTree.setAttribute('viewBox', `0 0 ${width} ${height}`);
        // edges
        edges.forEach(e => {
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const d = `M ${e.from.x} ${e.from.y} C ${e.from.x} ${ (e.from.y + e.to.y)/2 } ${e.to.x} ${ (e.from.y + e.to.y)/2 } ${e.to.x} ${e.to.y}`;
          path.setAttribute('d', d);
          path.setAttribute('class','edge');
          path.setAttribute('data-parent', e.parentId);
          path.setAttribute('data-child', e.childId);
          svgTree.appendChild(path);

          // label near child
          const midX = (e.from.x + e.to.x)/2;
          const midY = (e.from.y + e.to.y)/2 - 6;
          const t = document.createElementNS('http://www.w3.org/2000/svg','text');
          t.setAttribute('x', midX);
          t.setAttribute('y', midY);
          t.setAttribute('text-anchor','middle');
          t.setAttribute('fill','#1b567f');
          t.setAttribute('font-size','11');
          t.setAttribute('font-weight','700');
          t.textContent = e.label;
          svgTree.appendChild(t);
        });
        // nodes
        for (const id in positions) {
          const p = positions[id];
          const n = allNodes[id];
          const cx = marginX + p.xIndex * hstep;
          const cy = marginY + p.depth * vgap;
          // group
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('transform', `translate(${cx},${cy})`);
          g.setAttribute('data-id', id);

          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circle.setAttribute('r','20');
          circle.setAttribute('class','node-circle');
          circle.setAttribute('data-id', id);
          g.appendChild(circle);

          const text = document.createElementNS('http://www.w3.org/2000/svg','text');
          text.setAttribute('y','6');
          text.setAttribute('text-anchor','middle');
          text.setAttribute('class','node-text');
          text.textContent = `${n.freq}`;
          g.appendChild(text);

          svgTree.appendChild(g);
        }
      }

      // Compute codes from final root
      function computeCodes(rootId) {
        const map = {};
        function dfs(id, prefix='') {
          const n = allNodes[id];
          if (!n.left && !n.right) {
            map[n.symbols[0]] = prefix || '0'; // single symbol edge-case -> assign '0'
            return;
          }
          dfs(n.left, prefix + '0');
          dfs(n.right, prefix + '1');
        }
        dfs(rootId, '');
        return map;
      }

      function updateCodesIfReady() {
        // if only one node -> trivial codes
        if (nodes.length === 1 && allNodes[nodes[0].id]) {
          const rootId = nodes[0].id;
          codes = computeCodes(rootId);
          showCodes(codes);
          updateBitCounts();
        } else {
          codes = null;
          codesGrid.innerHTML = '';
          totalBitsEl.textContent = '—';
          fixedBitsEl.textContent = '—';
        }
      }

      function showCodes(map) {
        codesGrid.innerHTML = '';
        Object.keys(map).sort().forEach(sym => {
          const div = document.createElement('div');
          div.className = 'code-card';
          div.textContent = `${sym}: ${map[sym]}`;
          codesGrid.appendChild(div);
        });
      }

      function updateBitCounts() {
        if (!codes) {
          totalBitsEl.textContent = '—';
          fixedBitsEl.textContent = '—';
          return;
        }
        // compute total bits for encoding all symbols once (weighted by freq)
        let total = 0;
        let fixed = 0;
        const leafNodes = Object.values(allNodes).filter(n => !n.left && !n.right);
        const uniqueSymbols = leafNodes.length;
        leafNodes.forEach(n => {
          const sym = n.symbols[0];
          const len = codes[sym].length;
          total += n.freq * len;
        });
        fixed = Math.ceil(Math.log2(Math.max(2, uniqueSymbols))) * leafNodes.reduce((s,n)=>s+n.freq,0);
        totalBitsEl.textContent = String(total);
        fixedBitsEl.textContent = String(fixed);
      }

      // Step algorithm: pick two smallest nodes, create parent, update nodes and history, animate
      function buildStep() {
        if (nodes.length < 2) {
          announce('Not enough symbols to merge. Add more symbols.');
          return;
        }
        sortQueue(nodes);
        const a = nodes.shift();
        const b = nodes.shift();
        // choice: left = a, right = b (a has <= freq)
        const parent = createInternal(a,b);
        // remove a and b from nodes array if not present (they were removed)
        nodes.push(parent);
        sortQueue(nodes);
        history.push({ left:a, right:b, parent:parent });
        // Animate: highlight a and b in queue, then create parent in queue and update tree
        updateQueueDisplay([a.id,b.id]);
        announce(`Merging "${a.symbols.join(',')}" (${a.freq}) and "${b.symbols.join(',')}" (${b.freq}) to create parent (${parent.freq}).`);
        // Slight delay to show highlight, then update tree with a small visual pop
        setTimeout(() => {
          renderTree(parent.id);
          updateQueueDisplay();
          playMergeAnimation(a.id, b.id, parent.id);
          updateCodesIfReady();
        }, 450);
      }

      // Undo last merge
      function undoStep() {
        if (history.length === 0) {
          announce('Nothing to undo.');
          return;
        }
        const last = history.pop();
        // remove parent node from allNodes and nodes list, add back children
        delete allNodes[last.parent.id];
        // remove parent from nodes array
        const pIdx = nodes.findIndex(n => n.id === last.parent.id);
        if (pIdx >= 0) nodes.splice(pIdx,1);
        // re-add children (ensure they're present)
        nodes.push(last.left);
        nodes.push(last.right);
        sortQueue(nodes);
        renderSymbolRows();
        updateQueueDisplay();
        // Re-render tree if there is a root left
        let rootId = null;
        if (nodes.length === 1) rootId = nodes[0].id;
        else {
          // find node that is ancestor of others? We'll render nothing until finished
          rootId = null;
        }
        svgTree.innerHTML = '';
        if (rootId) renderTree(rootId);
        updateCodesIfReady();
        announce('Undid last merge.');
      }

      // Play/pause auto-play merges
      function togglePlay() {
        if (playing) {
          playing = false;
          clearInterval(autoPlayTimer);
          playBtn.textContent = 'Auto-Play';
          announce('Auto-play paused.');
          return;
        }
        if (nodes.length < 2) {
          announce('Not enough symbols to auto-play.');
          return;
        }
        playing = true;
        playBtn.textContent = 'Pause';
        announce('Auto-play started.');
        autoPlayTimer = setInterval(() => {
          if (nodes.length < 2) {
            clearInterval(autoPlayTimer);
            playing = false;
            playBtn.textContent = 'Auto-Play';
            finalizeTreeAfterBuild();
            return;
          }
          buildStep();
          // if after step nodes length == 1, stop playing and finalize
          if (nodes.length === 1) {
            clearInterval(autoPlayTimer);
            playing = false;
            playBtn.textContent = 'Auto-Play';
            finalizeTreeAfterBuild();
          }
        }, 900);
      }

      function finalizeTreeAfterBuild() {
        if (nodes.length === 1) {
          const rootId = nodes[0].id;
          renderTree(rootId);
          codes = computeCodes(rootId);
          showCodes(codes);
          updateBitCounts();
          announce('Build complete. Codes generated.');
        }
      }

      function buildAll() {
        if (nodes.length < 2) {
          announce('Not enough symbols to build.');
          return;
        }
        // Perform steps with small delays to animate sequentially
        const iterate = () => {
          if (nodes.length < 2) {
            finalizeTreeAfterBuild();
            return;
          }
          buildStep();
          setTimeout(iterate, 600);
        };
        iterate();
      }

      // Play a small animation when merging: highlight nodes in SVG (if present)
      function playMergeAnimation(leftId, rightId, parentId) {
        // Highlight the nodes by adding class
        const leftCircle = svgTree.querySelector(`.node-circle[data-id="${leftId}"]`);
        const rightCircle = svgTree.querySelector(`.node-circle[data-id="${rightId}"]`);
        const parentCircle = svgTree.querySelector(`.node-circle[data-id="${parentId}"]`);
        if (leftCircle) leftCircle.classList.add('highlight');
        if (rightCircle) rightCircle.classList.add('highlight');
        if (parentCircle) {
          parentCircle.style.opacity = '0';
          setTimeout(() => {
            parentCircle.style.transition = 'opacity .28s ease, transform .28s ease';
            parentCircle.style.opacity = '1';
            parentCircle.classList.add('highlight');
          }, 200);
        }
        // Remove highlights after a moment
        setTimeout(() => {
          if (leftCircle) leftCircle.classList.remove('highlight');
          if (rightCircle) rightCircle.classList.remove('highlight');
          if (parentCircle) parentCircle.classList.remove('highlight');
        }, 900);
      }

      // Encoding and decoding
      function encodeMessage(text) {
        if (!codes) {
          announce('Codes not ready. Complete the tree first.');
          return;
        }
        const bits = [];
        for (const ch of text) {
          if (!(ch in codes)) {
            announce(`Character "${ch}" not found in current symbol set.`);
            return;
          }
          bits.push(codes[ch]);
        }
        const bitString = bits.join('');
        bitOutput.innerHTML = '';
        // create bit pills with small playback animation
        const pills = bitString.split('').map(b => {
          const span = document.createElement('div');
          span.className = 'bit-pill';
          span.textContent = b;
          bitOutput.appendChild(span);
          return span;
        });
        // animate playback: highlight each pill sequentially
        let i = 0;
        const interval = setInterval(() => {
          if (i > 0) pills[i-1].classList.remove('playing');
          if (i >= pills.length) {
            clearInterval(interval);
            announce(`Encoded message to ${bitString.length} bits.`);
            return;
          }
          pills[i].classList.add('playing');
          i++;
        }, 60);
      }

      function decodeBits(bitString) {
        if (!codes) {
          announce('Codes not ready. Complete the tree first.');
          return;
        }
        // build reverse mapping
        const rev = {};
        Object.entries(codes).forEach(([k,v]) => rev[v] = k);
        // decode using tree traversal
        let out = '';
        let cur = '';
        for (const bit of bitString) {
          cur += bit;
          if (cur in rev) {
            out += rev[cur];
            cur = '';
          } else {
            // continue
          }
        }
        if (cur.length) {
          announce('Bit string does not terminate at a valid code (incomplete).');
        } else {
          bitOutput.innerHTML = '';
          const span = document.createElement('div');
          span.textContent = out;
          span.style.fontWeight = '700';
          span.style.color = '#063b7a';
          bitOutput.appendChild(span);
          announce('Decoded bitstring to message.');
        }
      }

      // UI wiring
      addSymbolBtn.addEventListener('click', () => {
        // Choose a default symbol label not used
        const used = new Set(Object.values(allNodes).filter(n=>!n.left&&!n.right).map(n=>n.symbols[0]));
        let ch = 'A';
        for (let i=65;i<91;i++) {
          if (!used.has(String.fromCharCode(i))) { ch = String.fromCharCode(i); break;}
        }
        addSymbolRow(ch, randInt(1,16));
      });

      randomBtn.addEventListener('click', () => {
        // create random example: common illustrative set
        clearAll();
        const examples = [
          [['A',45],['B',13],['C',12],['D',16],['E',9],['F',5]],
          [['a',5],['b',9],['c',12],['d',13],['e',16],['f',45]],
          [['X',3],['Y',7],['Z',2],['W',8]],
        ];
        const ex = examples[randInt(0, examples.length-1)];
        ex.forEach(([s,f]) => {
          addSymbolRow(s,f);
        });
        announce('Random example loaded.');
      });

      resetBtn.addEventListener('click', () => clearAll());

      stepBtn.addEventListener('click', () => buildStep());
      buildAllBtn.addEventListener('click', () => buildAll());
      playBtn.addEventListener('click', () => togglePlay());
      undoBtn.addEventListener('click', () => undoStep());

      encodeBtn.addEventListener('click', () => {
        const txt = messageInput.value || '';
        if (!txt) {
          announce('Enter a message to encode.');
          return;
        }
        encodeMessage(txt);
      });

      decodeBtn.addEventListener('click', () => {
        const txt = messageInput.value || '';
        if (!txt) {
          announce('Enter a bit string to decode.');
          return;
        }
        decodeBits(txt);
      });

      // initial default seed
      (function init() {
        clearAll();
        // create a simple default example
        addSymbolRow('A', 5);
        addSymbolRow('B', 9);
        addSymbolRow('C', 12);
        addSymbolRow('D', 13);
        addSymbolRow('E', 16);
        addSymbolRow('F', 45);
        renderSymbolRows();
        updateQueueDisplay();
        announce('Module ready. Use Build Step to start constructing the tree.');
      })();

      // Keyboard accessibility: Enter on message input encodes
      messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          // by default encode if codes ready, else try decode if looks like bits
          const txt = messageInput.value || '';
          if (/^[01\s]+$/.test(txt.trim())) {
            decodeBits(txt.replace(/\s+/g,''));
          } else {
            encodeMessage(txt);
          }
        }
      });

      // Keep visuals responsive on resize
      window.addEventListener('resize', () => {
        if (nodes.length === 1) renderTree(nodes[0].id);
      });

    })();
  </script>
</body>
</html>