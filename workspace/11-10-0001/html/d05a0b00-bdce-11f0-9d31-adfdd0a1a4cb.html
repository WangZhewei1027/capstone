<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Adjacency List — Interactive Module</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #22c1c3;
      --accent-2: #7dd3fc;
      --muted: #93a2b8;
      --success: #16a34a;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.03);
      --transition: 220ms cubic-bezier(.2,.9,.3,1);
    }

    /* Safe area margins */
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071022 0%, #082034 40%);
      color:#e6eef6;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    body{
      padding: var(--safe-padding);
      box-sizing: border-box;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      min-height:100vh;
    }

    /* Header */
    header{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .title{
      display:flex;
      align-items:center;
      gap:12px;
    }
    .badge{
      background:linear-gradient(90deg,var(--accent),var(--accent-2));
      color:#042027;
      padding:6px 10px;
      border-radius:8px;
      font-weight:600;
      font-size:14px;
      box-shadow:0 4px 18px rgba(34,193,195,0.12);
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:-0.01em;
    }
    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
      max-width:980px;
    }

    /* Main layout */
    main{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      width:100%;
      flex:1;
    }

    /* Left: interactive workspace */
    .workspace{
      flex:1 1 680px;
      min-width:260px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:16px;
      box-shadow: 0 6px 30px rgba(2,6,23,0.5);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .controls{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
      align-items:center;
    }
    button, .toggle{
      background:var(--glass);
      border:1px solid rgba(255,255,255,0.04);
      color:var(--accent-2);
      padding:8px 12px;
      border-radius:10px;
      font-weight:600;
      cursor:pointer;
      min-height:40px;
      transition:all var(--transition);
    }
    button:focus{ outline:2px solid rgba(125,211,252,0.15); outline-offset:2px; }
    .btn-primary{
      background:linear-gradient(90deg,var(--accent),var(--accent-2));
      color:#042027;
      border:0;
      box-shadow:0 8px 30px rgba(34,193,195,0.12);
    }
    .mode{
      display:flex;
      gap:8px;
      align-items:center;
    }

    .status{
      color:var(--muted);
      font-size:13px;
      margin-left:auto;
    }

    /* Canvas area */
    .canvas-wrap{
      background:transparent;
      border-radius:10px;
      flex:1;
      min-height:420px;
      position:relative;
      overflow:hidden;
    }
    svg{
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
      user-select:none;
      cursor:grab;
    }
    svg:active{ cursor:grabbing; }

    .instructions{
      color:var(--muted);
      font-size:13px;
      padding:8px 10px;
    }

    /* Right panel: adjacency list & explanation */
    .panel{
      width:360px;
      min-width:240px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:16px;
      box-shadow: 0 6px 30px rgba(2,6,23,0.5);
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .panel h3{ margin:0; font-size:15px; color:#fff; }
    .panel p{ margin:0; color:var(--muted); font-size:13px; }

    .adj-list{
      display:flex;
      flex-direction:column;
      gap:10px;
      max-height:320px;
      overflow:auto;
      padding-right:6px;
    }

    .node-entry{
      background: rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      padding:10px;
      border-radius:10px;
      display:flex;
      gap:10px;
      align-items:center;
      transition: transform var(--transition), box-shadow var(--transition);
    }
    .node-entry.selected{
      box-shadow: 0 6px 20px rgba(20,132,142,0.12);
      transform:translateY(-4px);
      border-color: rgba(125,211,252,0.18);
    }
    .node-key{
      width:40px;
      height:40px;
      border-radius:10px;
      background:linear-gradient(180deg,#032b30,#06343a);
      color:var(--accent-2);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      font-size:14px;
      flex-shrink:0;
    }
    .neighbors{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .pill{
      background:rgba(255,255,255,0.03);
      padding:6px 8px;
      border-radius:999px;
      color:var(--muted);
      font-size:13px;
      border:1px solid rgba(255,255,255,0.02);
      display:inline-flex;
      gap:8px;
      align-items:center;
      cursor:pointer;
      transition: all 180ms ease;
    }
    .pill:hover{ transform: translateY(-3px); color:#eaf6fb; }

    /* code block */
    pre.code{
      background: rgba(1,6,11,0.6);
      border-radius:8px;
      padding:10px;
      margin:0;
      color:#cfeffd;
      font-size:13px;
      overflow:auto;
      max-height:130px;
      border:1px solid rgba(125,211,252,0.06);
    }

    /* small helpers */
    .row{ display:flex; gap:var(--gap); align-items:center; }
    .muted{ color:var(--muted); font-size:13px; }
    .tiny{ font-size:12px; color:var(--muted); }
    .kbd{
      background:rgba(255,255,255,0.03);
      padding:6px 8px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.02);
      font-weight:700;
      color:var(--muted);
      font-size:12px;
    }

    /* animations */
    .fade-in{
      animation: fadeIn 260ms ease both;
    }
    @keyframes fadeIn{
      from{ opacity:0; transform: translateY(6px); }
      to{ opacity:1; transform: translateY(0); }
    }

    /* Responsive: stack */
    @media (max-width:980px){
      main{ flex-direction:column; }
      .panel{ width:100%; }
    }

    /* Accessibility focus */
    button:focus-visible, .pill:focus{ outline:2px solid rgba(125,211,252,0.18); outline-offset:2px; }

    /* Graph styling helpers via classes added by JS */
    .node-circle{
      fill: linear-gradient(180deg,#052f35,#06343a);
      stroke: rgba(255,255,255,0.06);
      stroke-width:1.5px;
      transition: transform var(--transition), filter var(--transition);
      filter: drop-shadow(0 8px 20px rgba(0,0,0,0.4));
    }
    .node-text{ pointer-events:none; font-weight:700; fill:#e6eef6; font-size:12px; }
    .edge-line{
      stroke: rgba(255,255,255,0.07);
      stroke-width:2;
      fill:none;
      transition: stroke var(--transition);
    }
    .edge-highlight{
      stroke: linear-gradient(90deg,var(--accent),var(--accent-2));
      stroke: rgba(34,193,195,0.9);
      stroke-width:3.6;
    }
    .node-selected{
      transform: scale(1.06);
      filter: drop-shadow(0 14px 30px rgba(34,193,195,0.08));
    }

  </style>
</head>
<body>
  <header>
    <div class="title">
      <div class="badge">Data Structure</div>
      <h1>Adjacency List — Visual, Editable, Interactive</h1>
    </div>
    <p class="lead">Explore how adjacency lists represent graphs. Add nodes, create edges (directed or undirected), drag nodes around, and watch the adjacency list update instantly with smooth animations and live code-like representation.</p>
  </header>

  <main>
    <!-- LEFT: Workspace -->
    <section class="workspace" aria-label="Graph workspace">
      <div class="controls" role="toolbar" aria-label="Graph controls">
        <div class="mode" style="gap:8px;">
          <button id="btnAddNode" class="btn-primary" title="Add a node (then click canvas to place) or press N">Add Node (N)</button>
          <button id="btnAddEdge" title="Toggle Add Edge mode">Add Edge</button>
          <button id="btnDelete" title="Delete selected node or edge">Delete</button>
          <button id="btnClear" title="Clear graph">Clear</button>
        </div>

        <label class="toggle" title="Toggle directed/undirected graph" style="display:inline-flex; align-items:center; gap:8px;">
          <input id="directedToggle" type="checkbox" aria-label="Directed edges" style="display:none;">
          <span id="directedVisual" style="padding:6px 8px; border-radius:8px; background:rgba(255,255,255,0.02); color:var(--accent-2); font-weight:700;">Undirected</span>
        </label>

        <div class="status" id="status">Mode: Browse • Nodes: 0 • Edges: 0</div>
      </div>

      <div class="canvas-wrap" aria-hidden="false" role="region" aria-label="Graph canvas">
        <svg id="svgCanvas" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMid meet" tabindex="0" aria-label="Interactive graph area">
          <defs>
            <marker id="arrowhead" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#16a3a5"></path>
            </marker>
          </defs>

          <!-- edges group -->
          <g id="edges"></g>

          <!-- nodes group -->
          <g id="nodes"></g>
        </svg>

        <div class="instructions tiny" id="instructions" style="position:absolute; bottom:12px; left:12px;">
          Click nodes to select. Drag to move. In "Add Edge", click two nodes to create an edge.
        </div>
      </div>
    </section>

    <!-- RIGHT: Adjacency List Panel -->
    <aside class="panel" aria-label="Adjacency list and explanation">
      <div>
        <h3>Learning Objective</h3>
        <p>After using this module you will be able to: understand how adjacency lists store graph connectivity, see how operations (adding/removing edges/nodes) update the structure, and read an adjacency-list representation as a JavaScript-like object.</p>
      </div>

      <div>
        <h3>Interaction Design</h3>
        <p class="tiny muted">
          - Add Node: click "Add Node" then click on the canvas to place a node (or press N to auto-place).<br>
          - Add Edge: toggle "Add Edge", then click two nodes: the first is source, the second is destination. If "Directed" is on, an arrow is drawn; otherwise an undirected connection is created.<br>
          - Select: click any node to highlight it and reveal its neighbors in the adjacency list. Click a neighbor pill to highlight that node in the canvas.<br>
          - Drag: click and drag nodes to reposition; edges and the adjacency view update in real time.<br>
          - Delete: delete selected node (removes its incident edges) or click an edge to remove it. All UI updates animate for clarity.
        </p>
      </div>

      <div>
        <h3>Layout Description</h3>
        <p class="tiny muted">
          Safe area: 24px padding around the viewport. Minimum spacing between interactive elements: 16px. The page uses a two-column layout: the left column is the interactive canvas with controls above; the right column is a compact panel showing the adjacency list, a live code representation, and textual instructions. On narrow screens the layout stacks vertically. Controls use clear affordances and high-contrast color; buttons and pills are keyboard-focusable for accessibility.
        </p>
      </div>

      <div>
        <h3>Adjacency List (visual)</h3>
        <div class="adj-list" id="adjList" aria-live="polite" aria-atomic="true">
          <!-- entries inserted here -->
        </div>
      </div>

      <div>
        <h3>Adjacency List (code)</h3>
        <pre class="code" id="codeBlock">// Empty graph</pre>
      </div>

      <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
        <div class="tiny muted">Click a node to inspect its adjacency list.</div>
        <div>
          <span class="kbd">Drag</span>
        </div>
      </div>
    </aside>
  </main>

  <script>
    // Adjacency List Interactive Module
    // Self-contained, vanilla JS/CSS/HTML
    (function(){
      // Basic state
      const state = {
        nodes: [], // {id, x, y, label}
        edges: [], // {id, a, b, directed}
        adj: {},   // adjacency list: {id: [neighborIds...]}
        nextNodeId: 1,
        nextEdgeId: 1,
        mode: 'browse', // 'browse' | 'addNode' | 'addEdge' | 'delete'
        addEdgeFirst: null,
        directed: false,
        selectedNode: null,
        selectedEdge: null,
      };

      // Element refs
      const svg = document.getElementById('svgCanvas');
      const nodesGroup = document.getElementById('nodes');
      const edgesGroup = document.getElementById('edges');
      const btnAddNode = document.getElementById('btnAddNode');
      const btnAddEdge = document.getElementById('btnAddEdge');
      const btnDelete = document.getElementById('btnDelete');
      const btnClear = document.getElementById('btnClear');
      const status = document.getElementById('status');
      const directedToggle = document.getElementById('directedToggle');
      const directedVisual = document.getElementById('directedVisual');
      const adjListEl = document.getElementById('adjList');
      const codeBlock = document.getElementById('codeBlock');
      const instructions = document.getElementById('instructions');

      // Helper utilities
      const ns = "http://www.w3.org/2000/svg";
      function createNodeElement(node){
        const g = document.createElementNS(ns,'g');
        g.setAttribute('data-id', node.id);
        g.setAttribute('class','node');
        g.setAttribute('transform', `translate(${node.x} ${node.y})`);
        g.style.cursor = 'grab';
        // circle
        const circle = document.createElementNS(ns,'circle');
        circle.setAttribute('r', 26);
        circle.setAttribute('class','node-circle');
        circle.setAttribute('fill', '#052f35');
        circle.setAttribute('stroke', 'rgba(255,255,255,0.06)');
        circle.setAttribute('stroke-width', '1.5');

        // label
        const text = document.createElementNS(ns,'text');
        text.setAttribute('class','node-text');
        text.setAttribute('text-anchor','middle');
        text.setAttribute('dy','5');
        text.textContent = node.label;

        // append
        g.appendChild(circle);
        g.appendChild(text);

        // event listeners
        g.tabIndex = 0;
        g.addEventListener('pointerdown', nodePointerDown);
        g.addEventListener('click', nodeClick);
        g.addEventListener('keydown', (e) => {
          if(e.key === 'Enter') nodeClick(e);
        });

        return g;
      }

      function createEdgeElement(edge){
        const g = document.createElementNS(ns,'g');
        g.setAttribute('data-id', edge.id);
        g.setAttribute('class','edge-group');

        const line = document.createElementNS(ns,'path');
        line.setAttribute('class','edge-line');
        line.setAttribute('fill','none');
        line.setAttribute('stroke-linecap','round');
        line.setAttribute('stroke-linejoin','round');
        if(edge.directed){
          line.setAttribute('marker-end','url(#arrowhead)');
        } else {
          line.removeAttribute('marker-end');
        }
        g.appendChild(line);

        // clickable hit area for deletion (wider transparent stroke)
        const hit = document.createElementNS(ns,'path');
        hit.setAttribute('class','edge-hit');
        hit.setAttribute('fill','none');
        hit.setAttribute('stroke','transparent');
        hit.setAttribute('stroke-width','18');
        hit.style.cursor = 'pointer';
        hit.addEventListener('click',(e)=> {
          e.stopPropagation();
          selectEdge(edge.id);
        });
        g.appendChild(hit);

        return g;
      }

      // Render functions
      function render(){
        renderEdges();
        renderNodes();
        renderAdjList();
        renderCode();
        updateStatus();
      }

      function renderNodes(){
        // Clear and re-add
        nodesGroup.innerHTML = '';
        for(const n of state.nodes){
          const el = createNodeElement(n);
          nodesGroup.appendChild(el);
          if(state.selectedNode === n.id){
            el.querySelector('circle').classList.add('node-selected');
          }
        }
        // Update transforms
        requestAnimationFrame(()=> {
          for(const g of nodesGroup.querySelectorAll('g.node')){
            const id = +g.getAttribute('data-id');
            const node = state.nodes.find(x=>x.id===id);
            if(node) g.setAttribute('transform', `translate(${node.x} ${node.y})`);
          }
        });
      }

      function renderEdges(){
        edgesGroup.innerHTML = '';
        for(const e of state.edges){
          const g = createEdgeElement(e);
          edgesGroup.appendChild(g);
          updateEdgeElement(e);
        }
      }

      function updateEdgeElement(edge){
        const g = edgesGroup.querySelector(`[data-id="${edge.id}"]`);
        if(!g) return;
        const path = g.querySelector('path.edge-line');
        const hit = g.querySelector('path.edge-hit');

        const a = state.nodes.find(n=>n.id===edge.a);
        const b = state.nodes.find(n=>n.id===edge.b);
        if(!a || !b) return;
        // compute a nice path (curved if needed)
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.hypot(dx,dy);
        const offset = Math.min(40, dist*0.2);
        const nx = dx / dist || 0;
        const ny = dy / dist || 0;
        const cx = (a.x + b.x)/2 - ny * offset;
        const cy = (a.y + b.y)/2 + nx * offset;
        const d = `M ${a.x} ${a.y} Q ${cx} ${cy} ${b.x} ${b.y}`;
        // animate stroke drawing
        path.setAttribute('d', d);
        hit.setAttribute('d', d);
        // stroke dash animation
        path.style.transition = 'stroke-dashoffset 420ms ease, stroke 220ms ease';
        path.style.stroke = (state.selectedEdge===edge.id) ? 'rgba(125,211,252,0.95)' : 'rgba(255,255,255,0.07)';
        if(edge.directed){
          path.setAttribute('marker-end','url(#arrowhead)');
        } else {
          path.removeAttribute('marker-end');
        }
        // create an animated draw effect
        const length = path.getTotalLength ? path.getTotalLength() : dist * 1.2;
        path.style.strokeDasharray = length;
        path.style.strokeDashoffset = length;
        requestAnimationFrame(()=> {
          path.style.strokeDashoffset = 0;
        });
      }

      function renderAdjList(){
        adjListEl.innerHTML = '';
        // For visual clarity, sort nodes by id
        const nodesSorted = state.nodes.slice().sort((a,b)=>a.id - b.id);
        for(const n of nodesSorted){
          const entry = document.createElement('div');
          entry.className = 'node-entry fade-in';
          if(state.selectedNode === n.id) entry.classList.add('selected');
          entry.setAttribute('data-id', n.id);

          const key = document.createElement('div');
          key.className = 'node-key';
          key.textContent = n.label;

          const neighbors = document.createElement('div');
          neighbors.className = 'neighbors';

          const list = state.adj[n.id] ? state.adj[n.id].slice() : [];
          if(list.length === 0){
            const none = document.createElement('div');
            none.className = 'pill';
            none.textContent = '—';
            neighbors.appendChild(none);
          } else {
            for(const nb of list){
              const pill = document.createElement('button');
              pill.className = 'pill';
              pill.textContent = (state.nodes.find(s=>s.id===nb) || {label:'?'}).label;
              pill.setAttribute('aria-label', 'Highlight node ' + pill.textContent);
              pill.addEventListener('click', ()=> {
                // highlight node on canvas
                selectNode(nb);
                pulseNode(nb);
              });
              neighbors.appendChild(pill);
            }
          }

          entry.appendChild(key);
          entry.appendChild(neighbors);
          adjListEl.appendChild(entry);
        }
      }

      function renderCode(){
        // Build a JS-like object string
        const lines = [];
        lines.push('const adjacencyList = {');
        for(const n of state.nodes.sort((a,b)=>a.id-b.id)){
          const arr = (state.adj[n.id] || []).map(id => {
            const lab = (state.nodes.find(s=>s.id===id) || {}).label || id;
            return `${id} /* ${lab} */`;
          });
          lines.push(`  ${n.id}: [ ${arr.join(', ')} ],`);
        }
        lines.push('};');
        if(state.nodes.length===0) codeBlock.textContent = '// Empty graph';
        else codeBlock.textContent = lines.join('\n');
      }

      function updateStatus(){
        status.textContent = `Mode: ${state.mode === 'browse' ? 'Browse' : state.mode === 'addEdge' ? 'Add Edge' : state.mode === 'addNode' ? 'Add Node' : 'Delete'} • Nodes: ${state.nodes.length} • Edges: ${state.edges.length}`;
        directedVisual.textContent = state.directed ? 'Directed' : 'Undirected';
      }

      // Selection logic
      function selectNode(id){
        state.selectedNode = id;
        state.selectedEdge = null;
        // highlight node visually
        highlightNode(id);
        render();
      }

      function selectEdge(edgeId){
        state.selectedEdge = edgeId;
        state.selectedNode = null;
        render();
      }

      function highlightNode(id){
        // temporarily enlarge circle
        for(const g of nodesGroup.querySelectorAll('g.node')){
          const nid = +g.getAttribute('data-id');
          const circle = g.querySelector('circle');
          if(nid === id){
            circle.classList.add('node-selected');
            g.querySelector('text').style.fill = '#e6eef6';
          } else {
            circle.classList.remove('node-selected');
          }
        }
      }

      function pulseNode(id){
        // quick animation to draw attention
        const g = nodesGroup.querySelector(`g.node[data-id="${id}"]`);
        if(!g) return;
        const c = g.querySelector('circle');
        c.animate([
          { transform: 'scale(1)', filter: 'drop-shadow(0 8px 20px rgba(0,0,0,0.4))' },
          { transform: 'scale(1.12)', filter: 'drop-shadow(0 20px 40px rgba(34,193,195,0.09))' },
          { transform: 'scale(1)' }
        ], { duration: 420, easing: 'cubic-bezier(.2,.9,.3,1)' });
      }

      // Graph modification functions
      function addNodeAt(x,y){
        const id = state.nextNodeId++;
        const label = String(id);
        const node = { id, x, y, label };
        state.nodes.push(node);
        state.adj[id] = [];
        render();
        // auto-select the new node
        selectNode(id);
      }

      function addEdge(a, b, directed){
        // prevent duplicates
        const exists = state.edges.find(e => (e.a === a && e.b === b && e.directed === !!directed) || (!e.directed && !directed && ((e.a===a && e.b===b)||(e.a===b && e.b===a))));
        if(exists) return;
        const id = state.nextEdgeId++;
        const edge = { id, a, b, directed: !!directed };
        state.edges.push(edge);
        // update adj lists
        if(!state.adj[a]) state.adj[a] = [];
        if(!state.adj[b]) state.adj[b] = [];
        state.adj[a].push(b);
        if(!directed){
          state.adj[b].push(a);
        }
        render();
        // highlight the new edge
        state.selectedEdge = id;
        setTimeout(()=> state.selectedEdge = null, 900);
      }

      function removeNode(id){
        // remove node, its edges and references
        state.nodes = state.nodes.filter(n=>n.id!==id);
        state.edges = state.edges.filter(e=>e.a!==id && e.b!==id);
        delete state.adj[id];
        for(const k in state.adj){
          state.adj[k] = state.adj[k].filter(v=>v!==id);
        }
        if(state.selectedNode === id) state.selectedNode = null;
        render();
      }

      function removeEdge(id){
        const edge = state.edges.find(e=>e.id===id);
        if(!edge) return;
        // remove from edges
        state.edges = state.edges.filter(e=>e.id!==id);
        // update adjacency lists
        state.adj[edge.a] = (state.adj[edge.a]||[]).filter(v=>v!==edge.b);
        if(!edge.directed){
          state.adj[edge.b] = (state.adj[edge.b]||[]).filter(v=>v!==edge.a);
        }
        if(state.selectedEdge === id) state.selectedEdge = null;
        render();
      }

      function clearGraph(){
        state.nodes = [];
        state.edges = [];
        state.adj = {};
        state.nextNodeId = 1;
        state.nextEdgeId = 1;
        state.selectedNode = null;
        state.selectedEdge = null;
        render();
      }

      // Event handlers for nodes (dragging etc)
      let dragging = null;
      let pointerOffset = {x:0,y:0};
      function nodePointerDown(e){
        e.stopPropagation();
        const g = e.currentTarget;
        const id = +g.getAttribute('data-id');
        if(state.mode === 'addEdge'){
          // treat as part of add-edge flow
          if(state.addEdgeFirst == null){
            state.addEdgeFirst = id;
            // brief visual
            selectNode(id);
            instructions.textContent = 'Select second node to complete the edge (or click same to cancel).';
          } else {
            if(state.addEdgeFirst === id){
              // cancel
              state.addEdgeFirst = null;
              instructions.textContent = 'Add Edge canceled.';
            } else {
              addEdge(state.addEdgeFirst, id, state.directed);
              state.addEdgeFirst = null;
              instructions.textContent = 'Edge added.';
            }
          }
          return;
        }

        // if delete mode, select node for deletion
        if(state.mode === 'delete'){
          selectNode(id);
          removeNode(id);
          instructions.textContent = 'Node deleted.';
          return;
        }

        // otherwise begin dragging
        dragging = id;
        const pt = getPoint(e);
        const node = state.nodes.find(n=>n.id===id);
        pointerOffset.x = pt.x - node.x;
        pointerOffset.y = pt.y - node.y;
        this.setPointerCapture(e.pointerId);
        this.style.cursor = 'grabbing';
      }

      function nodeClick(e){
        e.stopPropagation();
        const id = +e.currentTarget.getAttribute('data-id');
        // Select node
        selectNode(id);
        instructions.textContent = 'Node selected.';
      }

      function svgPointerDown(e){
        // place node if in addNode mode
        if(state.mode === 'addNode'){
          const pt = getPoint(e);
          addNodeAt(pt.x, pt.y);
          state.mode = 'browse';
          instructions.textContent = 'Node placed.';
          render();
        } else {
          // clear selections
          state.selectedNode = null;
          state.selectedEdge = null;
          state.addEdgeFirst = null;
          render();
        }
      }

      // pointer move/up on svg for dragging
      svg.addEventListener('pointermove', (e)=>{
        if(!dragging) return;
        const pt = getPoint(e);
        const node = state.nodes.find(n=>n.id===dragging);
        if(!node) return;
        node.x = Math.max(40, Math.min(pt.x - pointerOffset.x, 1160));
        node.y = Math.max(40, Math.min(pt.y - pointerOffset.y, 660));
        // update edges connected to this node
        for(const ed of state.edges.filter(ed => ed.a === node.id || ed.b === node.id)){
          updateEdgeElement(ed);
        }
        // update node position transform
        const g = nodesGroup.querySelector(`g.node[data-id="${node.id}"]`);
        if(g) g.setAttribute('transform', `translate(${node.x} ${node.y})`);
      });

      svg.addEventListener('pointerup', (e)=>{
        if(dragging){
          const g = nodesGroup.querySelector(`g.node[data-id="${dragging}"]`);
          if(g) g.style.cursor = 'grab';
          dragging = null;
          render();
        }
      });

      svg.addEventListener('click', svgPointerDown);
      svg.addEventListener('contextmenu', (e)=> e.preventDefault());

      // UI control handlers
      btnAddNode.addEventListener('click', ()=> {
        state.mode = state.mode === 'addNode' ? 'browse' : 'addNode';
        instructions.textContent = state.mode === 'addNode' ? 'Click anywhere on the canvas to place the new node.' : 'Cancelled node placement.';
        render();
      });
      btnAddEdge.addEventListener('click', ()=> {
        state.mode = state.mode === 'addEdge' ? 'browse' : 'addEdge';
        state.addEdgeFirst = null;
        instructions.textContent = state.mode === 'addEdge' ? 'Add Edge: select source node.' : 'Add Edge cancelled.';
        render();
      });
      btnDelete.addEventListener('click', ()=> {
        state.mode = state.mode === 'delete' ? 'browse' : 'delete';
        instructions.textContent = state.mode === 'delete' ? 'Delete mode: click a node or edge to remove it.' : 'Delete cancelled.';
        render();
      });
      btnClear.addEventListener('click', ()=>{
        if(confirm('Clear all nodes and edges?')) clearGraph();
      });

      directedToggle.addEventListener('change', (e)=>{
        state.directed = e.target.checked;
        render();
      });

      // keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if(e.key === 'n' || e.key === 'N'){
          state.mode = 'addNode';
          instructions.textContent = 'Press N: Click on canvas to place node.';
          render();
        } else if(e.key === 'Escape'){
          state.mode = 'browse';
          state.addEdgeFirst = null;
          instructions.textContent = 'Mode reset.';
          render();
        } else if(e.key === 'Delete' || e.key === 'Backspace'){
          if(state.selectedNode) removeNode(state.selectedNode);
          else if(state.selectedEdge) removeEdge(state.selectedEdge);
        }
      });

      // Utility: get mouse position relative to SVG coordinate system
      function getPoint(evt){
        const pt = svg.createSVGPoint();
        pt.x = evt.clientX;
        pt.y = evt.clientY;
        const ctm = svg.getScreenCTM();
        if(ctm) return pt.matrixTransform(ctm.inverse());
        return {x: evt.offsetX, y: evt.offsetY};
      }

      // Initial guidance: populate with a small example
      (function seedExample(){
        // center-ish positions mapped to viewBox 1200x700
        addNodeAt(250, 200); // 1
        addNodeAt(430, 140); // 2
        addNodeAt(550, 280); // 3
        addNodeAt(350, 360); // 4
        addNodeAt(720, 200); // 5
        addEdge(1,2,false);
        addEdge(1,4,false);
        addEdge(2,3,false);
        addEdge(3,5,true);
        state.selectedNode = 1;
        render();
      })();

      // Accessibility: clicking outside clears selection
      document.body.addEventListener('click', (e)=>{
        const inside = e.target.closest('.panel') || e.target.closest('.workspace');
        if(!inside){
          state.selectedNode = null;
          state.selectedEdge = null;
          render();
        }
      });

      // Expose some functions for console debugging (optional)
      window.__adj = {
        state,
        addNodeAt,
        addEdge,
        removeNode,
        removeEdge,
        clearGraph,
      };

      // Initial render call (ensures UI elements reflect state)
      render();
    })();
  </script>
</body>
</html>