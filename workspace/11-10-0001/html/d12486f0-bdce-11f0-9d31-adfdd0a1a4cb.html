<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Counting Sort — Interactive Module</title>
  <style>
    :root{
      --safe: 24px;
      --gap: 16px;
      --bg:#0f1720;
      --panel:#0b1220;
      --card:#0f1728;
      --muted:#9aa6b2;
      --accent:#22c1c3;
      --accent-2:#6be3b8;
      --danger:#ff6b6b;
      --glass: rgba(255,255,255,0.03);
      --max-bar-height:180px;
      --bar-width:44px;
    }
    /* Safe area margins */
    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,#041018 0%, #071827 60%);
      color:#e6f2f1;
      font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    .app{
      min-height:100vh;
      padding:var(--safe);
      box-sizing:border-box;
      display:flex;
      align-items:flex-start;
      justify-content:center;
    }
    .container{
      width:100%;
      max-width:1200px;
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:var(--gap);
      align-items:start;
    }

    /* Left column: controls & explanation */
    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      padding:18px;
      border-radius:12px;
      box-sizing:border-box;
    }
    header.title{
      margin-bottom:12px;
    }
    header.title h1{
      margin:0 0 6px 0;
      font-size:18px;
      letter-spacing:0.2px;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
      margin:0;
    }
    .controls{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      margin-top:18px;
    }
    .control-row{
      display:flex;
      gap:12px;
      align-items:center;
    }
    label { font-size:13px; color:var(--muted); min-width:120px; }
    input[type="range"]{ flex:1; }
    input[type="text"]{
      width:100%;
      background:transparent;
      color:inherit;
      border:1px solid rgba(255,255,255,0.06);
      padding:8px 10px;
      border-radius:8px;
      outline:none;
    }
    .btn-row{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
    }
    button{
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      color:inherit;
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      font-size:13px;
      min-height:40px;
      outline:none;
    }
    button.primary{
      background:linear-gradient(180deg,var(--accent), var(--accent-2));
      color:#042022;
      border: none;
      font-weight:600;
    }
    button.danger{ background: linear-gradient(180deg,var(--danger), #ff8787); color:#2b0202; border:none; }
    .small{ font-size:13px; padding:8px 10px; min-height:36px; }

    /* Right column: visualization */
    .viz{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      padding:18px;
      border-radius:12px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      min-height:520px;
    }
    .viz-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:var(--gap);
    }
    .status{
      color:var(--muted);
      font-size:13px;
    }
    .stage-pill{
      background:var(--glass);
      padding:6px 10px;
      border-radius:999px;
      font-size:13px;
    }

    /* Arrays layout */
    .arrays{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      align-items:stretch;
    }
    .array-row{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      padding:12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .array-title{
      font-size:13px;
      color:var(--muted);
      margin-bottom:10px;
    }
    .bars{
      display:flex;
      gap:12px;
      align-items:end;
      min-height:120px;
      padding:6px;
      overflow:auto;
    }
    .bar{
      width:var(--bar-width);
      min-width:var(--bar-width);
      display:flex;
      align-items:end;
      justify-content:center;
      flex-direction:column;
      cursor:grab;
      user-select:none;
      position:relative;
      transition:transform 400ms ease, opacity 300ms ease;
    }
    .bar:active{ cursor:grabbing; }
    .bar-inner{
      width:100%;
      background:linear-gradient(180deg,#20b8d3,#1a99a0);
      border-radius:8px 8px 6px 6px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#042022;
      font-weight:700;
      box-shadow:0 6px 18px rgba(0,0,0,0.35);
      transition:height 400ms ease;
    }
    .bar-label{
      margin-top:8px;
      text-align:center;
      font-size:12px;
      color:var(--muted);
    }
    .count-bar-inner{
      background:linear-gradient(180deg,#f6d365,#fda085);
      color:#2b0202;
    }
    .output-bar-inner{
      background:linear-gradient(180deg,#c6f6d5,#7ae3b3);
      color:#042022;
    }
    .ghost{
      opacity:0.15;
      transform:scale(0.95);
    }
    .highlight{
      box-shadow:0 0 0 4px rgba(34,193,195,0.12);
      transform:translateY(-6px);
    }

    /* small labels underneath arrays */
    .array-foot{
      display:flex;
      gap:12px;
      font-size:12px;
      color:var(--muted);
      margin-top:8px;
      flex-wrap:wrap;
    }

    /* animate moving clones */
    .floating{
      position:absolute;
      pointer-events:none;
      z-index:9999;
      transition:transform 500ms cubic-bezier(.2,.9,.2,1), opacity 300ms ease;
    }

    /* explanation area */
    .explain{
      font-size:13px;
      color:var(--muted);
      line-height:1.45;
      background:rgba(255,255,255,0.015);
      padding:12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.02);
    }

    footer.attribution{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-top:8px;
      color:var(--muted);
      font-size:12px;
    }

    /* responsive */
    @media (max-width:980px){
      .container{ grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Counting Sort interactive module">
    <div class="container" role="region" aria-label="Module container">
      <!-- LEFT PANEL -->
      <aside class="panel" aria-labelledby="title">
        <header class="title">
          <h1 id="title">Counting Sort — Stable, Integer Sorting</h1>
          <p class="muted">A focused interactive exploration: see how Counting Sort builds counts, computes cumulative counts, and places elements into a stable output.</p>
        </header>

        <div class="controls" aria-hidden="false">
          <div class="control-row" title="Number of elements in the input array">
            <label for="sizeRange">Array size (n)</label>
            <input id="sizeRange" type="range" min="1" max="16" value="8" aria-label="Array size">
            <div id="sizeVal" class="muted" style="min-width:36px;text-align:right">8</div>
          </div>

          <div class="control-row" title="Maximum value (k)">
            <label for="maxRange">Max value (k)</label>
            <input id="maxRange" type="range" min="1" max="20" value="9" aria-label="Maximum value">
            <div id="maxVal" class="muted" style="min-width:36px;text-align:right">9</div>
          </div>

          <div class="control-row" style="align-items:flex-start;">
            <label for="manualInput">Manual array</label>
            <input id="manualInput" type="text" aria-label="Enter array as comma separated integers" placeholder="e.g. 3,1,4,1,5" />
          </div>

          <div class="btn-row" role="group" aria-label="Primary controls">
            <button id="randomBtn" class="small" title="Create a random array">Randomize</button>
            <button id="initBtn" class="primary small" title="Initialize counts and arrays">Initialize</button>
            <button id="stepBtn" class="small" title="Advance one step">Step</button>
            <button id="playBtn" class="small" title="Automatically play steps">Auto</button>
            <button id="resetBtn" class="danger small" title="Reset to empty state">Reset</button>
          </div>

          <div class="control-row" style="margin-top:6px;">
            <label>Speed</label>
            <input id="speedRange" type="range" min="200" max="1500" value="700" aria-label="Playback speed (ms per step)">
            <div id="speedVal" class="muted" style="min-width:48px;text-align:right">700ms</div>
          </div>

          <div style="margin-top:8px;" class="explain" aria-live="polite">
            <strong>Concept Title:</strong>
            <div>Counting Sort (stable integer sort using counts)</div>
            <hr style="opacity:0.06;border:none;height:8px"/>
            <strong>Learning Objective:</strong>
            <div>After interacting with this module you should be able to:
              - Understand how Counting Sort builds a frequency (count) array,
              - See how cumulative counts map values to output indices,
              - Observe stable placement of equal keys (processing input from right to left),
              - Experiment with different n and k to see performance/space trade-offs.
            </div>
            <hr style="opacity:0.06;border:none;height:8px"/>
            <strong>Interaction Design:</strong>
            <div style="margin-top:6px;">Use the sliders or manual input to create arrays. Drag input bars left/right to reorder before initializing. Press Initialize to set up count and output arrays. Use Step to advance through building counts, computing cumulative counts, and placing elements (each step animates a bar moving into the output and highlights count updates). Auto plays steps continuously. Reset clears state.</div>
            <hr style="opacity:0.06;border:none;height:8px"/>
            <strong>Layout Description:</strong>
            <div style="margin-top:6px;">Controls on the left (safe margins 24px) and the visualization on the right. The visualization shows three horizontal rows: Input (top), Count array (middle), Output (bottom). Spacing between interactive elements >=16px. Colors and contrast selected for clarity; keyboard-accessible buttons and aria labels included. Responsive: on small screens the controls stack above visualization.</div>
          </div>

          <footer class="attribution" style="margin-top:12px;">
            <div>Stable Counting Sort demo</div>
            <div class="muted">Only non-negative integers</div>
          </footer>
        </div>
      </aside>

      <!-- RIGHT PANEL: Visualization -->
      <main class="viz" role="main" aria-label="Visualization area">
        <div class="viz-top">
          <div class="status">State: <span id="stateText">Ready</span></div>
          <div class="stage-pill" id="stepInfo" aria-live="polite">Idle</div>
        </div>

        <div class="arrays" id="arraysContainer">
          <!-- Input Array -->
          <section class="array-row" aria-label="Input array">
            <div class="array-title">Input Array (drag to reorder before Initialize)</div>
            <div id="inputBars" class="bars" tabindex="0" aria-describedby="inputDesc"></div>
            <div class="array-foot" id="inputFoot"></div>
          </section>

          <!-- Count Array -->
          <section class="array-row" aria-label="Count array">
            <div class="array-title">Count Array (frequency of each value)</div>
            <div id="countBars" class="bars" aria-live="polite"></div>
            <div class="array-foot" id="countFoot"></div>
          </section>

          <!-- Output Array -->
          <section class="array-row" aria-label="Output array">
            <div class="array-title">Output Array (stable result)</div>
            <div id="outputBars" class="bars" aria-live="polite"></div>
            <div class="array-foot" id="outputFoot"></div>
          </section>
        </div>
      </main>
    </div>
  </div>

  <script>
    // Counting Sort Interactive Module
    (function(){
      // Utility
      const qs = s => document.querySelector(s);
      const qsa = s => Array.from(document.querySelectorAll(s));
      const clamp = (v,min,max)=>Math.max(min, Math.min(max, v));
      // Elements
      const sizeRange = qs('#sizeRange');
      const sizeVal = qs('#sizeVal');
      const maxRange = qs('#maxRange');
      const maxVal = qs('#maxVal');
      const manualInput = qs('#manualInput');
      const randomBtn = qs('#randomBtn');
      const initBtn = qs('#initBtn');
      const stepBtn = qs('#stepBtn');
      const playBtn = qs('#playBtn');
      const resetBtn = qs('#resetBtn');
      const speedRange = qs('#speedRange');
      const speedVal = qs('#speedVal');

      const inputBars = qs('#inputBars');
      const countBars = qs('#countBars');
      const outputBars = qs('#outputBars');
      const stateText = qs('#stateText');
      const stepInfo = qs('#stepInfo');

      // State
      let inputArray = [];
      let k = parseInt(maxRange.value,10);
      let n = parseInt(sizeRange.value,10);
      let countArray = [];
      let outputArray = [];
      let phase = 'idle'; // 'idle' | 'counting' | 'cumulative' | 'placing' | 'done'
      let stepIndex = 0; // index inside current phase
      let autoTimer = null;
      let speed = parseInt(speedRange.value,10);
      let lastAction = null;
      let allowDrag = true;

      // Initialize with random
      function randomArray(n, k){
        const arr = [];
        for(let i=0;i<n;i++){
          arr.push(Math.floor(Math.random()*(k+1)));
        }
        return arr;
      }

      function parseManualInput(text){
        if(!text.trim()) return null;
        const parts = text.split(',').map(s=>s.trim()).filter(s=>s.length);
        const vals = [];
        for(const p of parts){
          const v = Number(p);
          if(!Number.isFinite(v) || v<0 || Math.floor(v)!==v) return null;
          vals.push(v);
        }
        return vals;
      }

      function renderAll(){
        renderInput();
        renderCount();
        renderOutput();
        updateStatus();
      }

      function updateStatus(){
        stateText.textContent = phase.charAt(0).toUpperCase()+phase.slice(1);
        if(phase === 'idle') stepInfo.textContent = 'Ready — initialize to begin';
        else if(phase === 'counting') stepInfo.textContent = `Counting frequencies — processing input index ${stepIndex}/${n-1}`;
        else if(phase === 'cumulative') stepInfo.textContent = 'Computing cumulative counts';
        else if(phase === 'placing') stepInfo.textContent = `Placing items — processing input index ${stepIndex}/${n-1}`;
        else if(phase === 'done') stepInfo.textContent = 'Done — output is sorted';
      }

      // Render input bars with drag-and-drop support
      function renderInput(){
        inputBars.innerHTML = '';
        inputArray.forEach((v,idx)=>{
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.setAttribute('draggable','true');
          bar.setAttribute('role','button');
          bar.setAttribute('tabindex','0');
          bar.setAttribute('aria-label',`Value ${v} at index ${idx}`);
          bar.dataset.index = idx;

          const inner = document.createElement('div');
          inner.className = 'bar-inner';
          inner.style.height = (Math.max(24, v/(k||1) * parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-bar-height') || 180))) + 'px';
          inner.textContent = v;

          const label = document.createElement('div');
          label.className = 'bar-label';
          label.textContent = idx;

          bar.appendChild(inner);
          bar.appendChild(label);
          inputBars.appendChild(bar);

          // Drag handlers
          bar.addEventListener('dragstart', (e)=> {
            if(!allowDrag) { e.preventDefault(); return; }
            e.dataTransfer.setData('text/plain', idx);
            bar.classList.add('ghost');
          });
          bar.addEventListener('dragend', ()=> {
            bar.classList.remove('ghost');
          });
          bar.addEventListener('keydown', (e)=>{
            if(e.key === 'Enter' || e.key === ' '){
              // select and swap mode could be implemented; for simplicity ignore
            }
          });
          // Allow dropping onto other bars to swap
          bar.addEventListener('dragover', (e)=> {
            e.preventDefault();
            bar.classList.add('highlight');
          });
          bar.addEventListener('dragleave', ()=> {
            bar.classList.remove('highlight');
          });
          bar.addEventListener('drop', (e)=> {
            e.preventDefault();
            bar.classList.remove('highlight');
            const fromIdx = Number(e.dataTransfer.getData('text/plain'));
            const toIdx = Number(bar.dataset.index);
            if(Number.isFinite(fromIdx) && fromIdx!==toIdx){
              swapInputIndices(fromIdx,toIdx);
              renderAll();
            }
          });
        });
        qs('#inputFoot').textContent = `n = ${inputArray.length}`;
      }

      function swapInputIndices(i,j){
        const t = inputArray[i];
        inputArray[i] = inputArray[j];
        inputArray[j] = t;
      }

      function renderCount(){
        countBars.innerHTML = '';
        const len = countArray.length;
        for(let i=0;i<len;i++){
          const v = countArray[i] ?? 0;
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.dataset.index = i;
          const inner = document.createElement('div');
          inner.className = 'bar-inner count-bar-inner';
          // height relative to max count for visual clarity
          const maxC = Math.max(1, ...countArray);
          inner.style.height = (Math.max(18, v/maxC * parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-bar-height') || 180))) + 'px';
          inner.textContent = v;
          const label = document.createElement('div');
          label.className = 'bar-label';
          label.textContent = i;
          bar.appendChild(inner);
          bar.appendChild(label);
          countBars.appendChild(bar);
        }
        qs('#countFoot').textContent = `k+1 = ${countArray.length}`;
      }

      function renderOutput(){
        outputBars.innerHTML = '';
        for(let i=0;i<outputArray.length;i++){
          const v = outputArray[i];
          const bar = document.createElement('div');
          bar.className = 'bar';
          const inner = document.createElement('div');
          inner.className = 'bar-inner output-bar-inner';
          if(v===null || v===undefined){
            inner.style.height = '18px';
            inner.style.background = 'linear-gradient(180deg,#111827,#0b1220)';
            inner.textContent = '';
            inner.style.opacity = 0.35;
          } else {
            inner.textContent = v;
            inner.style.height = (Math.max(18, v/(k||1) * parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-bar-height') || 180))) + 'px';
          }
          const label = document.createElement('div');
          label.className = 'bar-label';
          label.textContent = i;
          bar.appendChild(inner);
          bar.appendChild(label);
          outputBars.appendChild(bar);
        }
        qs('#outputFoot').textContent = `indices 0..${Math.max(0,outputArray.length-1)}`;
      }

      // Initialization workflow
      function initialize(){
        // parse manual input if present
        const manual = parseManualInput(manualInput.value || '');
        if(manual){
          inputArray = manual.slice();
          n = inputArray.length;
          clampRanges();
          sizeRange.value = n;
          sizeVal.textContent = n;
        } else {
          // ensure n and k current
          n = parseInt(sizeRange.value,10);
          inputArray = randomArray(n,k);
        }

        // ensure values within k
        const tooBig = inputArray.some(v => v > k);
        if(tooBig){
          // increase k automatically
          k = Math.max(...inputArray);
          maxRange.value = k;
          maxVal.textContent = k;
        }

        // prepare arrays
        countArray = new Array(k+1).fill(0);
        outputArray = new Array(n).fill(null);

        phase = 'counting';
        stepIndex = 0;
        allowDrag = false;
        renderAll();
        updateStatus();
      }

      // Step controller: one atomic step per press
      function step(){
        if(phase === 'idle'){
          // not initialized
          return;
        }
        if(phase === 'counting'){
          if(stepIndex < n){
            // process input[stepIndex]
            const val = inputArray[stepIndex];
            countArray[val] = (countArray[val] || 0) + 1;
            animateCountIncrement(val, stepIndex);
            stepIndex++;
            renderCount();
            updateStatus();
          } else {
            // move to cumulative
            phase = 'cumulative';
            stepIndex = 0;
            computeCumulativeStep(); // may animate quickly
            phase = 'placing';
            // placing processes input from right to left
            stepIndex = n-1;
            renderAll();
            updateStatus();
          }
        } else if(phase === 'placing'){
          if(stepIndex >= 0){
            const val = inputArray[stepIndex];
            // determine placement index from countArray
            const idx = (countArray[val] || 0) - 1;
            // place into output[idx]
            outputArray[idx] = val;
            animatePlace(val, stepIndex, idx);
            // decrement count
            countArray[val] = idx;
            renderCount();
            renderOutput();
            stepIndex--;
            updateStatus();
          } else {
            phase = 'done';
            allowDrag = true;
            renderAll();
            updateStatus();
            stopAuto();
          }
        } else if(phase === 'done'){
          // no-op
        }
      }

      function animateCountIncrement(value, inputIdx){
        // Highlight the corresponding count bar briefly
        const cb = countBars.children[value];
        if(!cb) return;
        cb.classList.add('highlight');
        setTimeout(()=> cb.classList.remove('highlight'), 520);
      }

      function computeCumulativeStep(){
        // transform countArray into cumulative counts
        for(let i=1;i<countArray.length;i++){
          countArray[i] = (countArray[i] || 0) + (countArray[i-1] || 0);
        }
        // animate a gentle highlight across count bars
        countBars.querySelectorAll('.bar').forEach((b,idx)=>{
          setTimeout(()=> b.classList.add('highlight'), idx*60);
          setTimeout(()=> b.classList.remove('highlight'), 500 + idx*60);
        });
        renderCount();
      }

      function animatePlace(value, fromIndex, toIndex){
        // create a floating clone from input bar to output bar
        const inputBar = inputBars.children[fromIndex];
        const outBar = outputBars.children[toIndex];
        if(!inputBar || !outBar) return;
        const clone = inputBar.cloneNode(true);
        clone.classList.add('floating');
        document.body.appendChild(clone);
        // measure positions
        const inRect = inputBar.getBoundingClientRect();
        const outRect = outBar.getBoundingClientRect();
        // initial style
        clone.style.left = inRect.left + 'px';
        clone.style.top = inRect.top + 'px';
        clone.style.width = inRect.width + 'px';
        clone.style.height = inRect.height + 'px';
        clone.style.opacity = 1;
        // force reflow then transform
        requestAnimationFrame(()=>{
          const dx = outRect.left - inRect.left;
          const dy = outRect.top - inRect.top;
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(0.95)`;
          clone.style.opacity = 0.92;
        });
        setTimeout(()=> {
          clone.style.opacity = 0;
          setTimeout(()=> clone.remove(), 420);
        }, 520);
      }

      // Auto play
      function toggleAuto(){
        if(autoTimer) stopAuto();
        else startAuto();
      }
      function startAuto(){
        if(phase === 'idle') return;
        autoTimer = setInterval(()=> {
          step();
          if(phase === 'done') stopAuto();
        }, speed);
        playBtn.textContent = 'Pause';
        playBtn.classList.add('primary');
        playBtn.setAttribute('aria-pressed','true');
      }
      function stopAuto(){
        if(autoTimer){ clearInterval(autoTimer); autoTimer = null; }
        playBtn.textContent = 'Auto';
        playBtn.classList.remove('primary');
        playBtn.setAttribute('aria-pressed','false');
      }

      function resetAll(){
        inputArray = [];
        n = parseInt(sizeRange.value,10);
        k = parseInt(maxRange.value,10);
        countArray = new Array(k+1).fill(0);
        outputArray = new Array(n).fill(null);
        phase = 'idle';
        stepIndex = 0;
        allowDrag = true;
        stopAuto();
        renderAll();
      }

      function clampRanges(){
        // keep ranges consistent with new n,k
        n = clamp(n, 1, 16);
        k = clamp(k, 1, 20);
      }

      // Event listeners
      sizeRange.addEventListener('input', (e)=>{
        n = Number(e.target.value);
        sizeVal.textContent = n;
        if(phase==='idle'){
          inputArray = randomArray(n,k);
          renderAll();
        }
      });
      maxRange.addEventListener('input', (e)=>{
        k = Number(e.target.value);
        maxVal.textContent = k;
        if(phase==='idle'){
          // adjust input values if necessary
          inputArray = inputArray.map(v => Math.min(v,k));
          renderAll();
        }
      });
      randomBtn.addEventListener('click', ()=>{
        n = parseInt(sizeRange.value,10);
        k = parseInt(maxRange.value,10);
        inputArray = randomArray(n,k);
        manualInput.value = '';
        renderAll();
      });
      initBtn.addEventListener('click', ()=>{
        k = parseInt(maxRange.value,10);
        n = parseInt(sizeRange.value,10);
        initialize();
      });
      stepBtn.addEventListener('click', ()=>{
        step();
      });
      playBtn.addEventListener('click', ()=>{
        if(!autoTimer) startAuto();
        else stopAuto();
      });
      resetBtn.addEventListener('click', ()=>{
        resetAll();
      });
      speedRange.addEventListener('input', (e)=>{
        speed = parseInt(e.target.value,10);
        speedVal.textContent = speed + 'ms';
        if(autoTimer){ stopAuto(); startAuto(); }
      });

      // Initial render
      (function start(){
        k = parseInt(maxRange.value,10);
        n = parseInt(sizeRange.value,10);
        inputArray = randomArray(n,k);
        countArray = new Array(k+1).fill(0);
        outputArray = new Array(n).fill(null);
        renderAll();
      })();

      // Keyboard accessibility: allow step with space on Step button
      stepBtn.addEventListener('keydown', (e)=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); step(); } });

      // Allow manual input pressing Enter to initialize
      manualInput.addEventListener('keydown', (e)=> {
        if(e.key === 'Enter'){
          const parsed = parseManualInput(manualInput.value || '');
          if(parsed){
            inputArray = parsed.slice();
            sizeRange.value = inputArray.length;
            sizeVal.textContent = inputArray.length;
            // expand k if needed
            const maxv = Math.max(...inputArray);
            if(maxv > k){
              k = maxv;
              maxRange.value = k;
              maxVal.textContent = k;
            }
            renderAll();
          } else {
            alert('Please enter comma-separated non-negative integers (e.g. 3,1,4,1)');
          }
        }
      });

      // Provide simple tooltip feedback
      [randomBtn, initBtn, stepBtn, playBtn, resetBtn].forEach(b=>{
        b.addEventListener('focus', ()=> b.style.boxShadow = '0 6px 20px rgba(34,193,195,0.08)');
        b.addEventListener('blur', ()=> b.style.boxShadow = 'none');
      });

      // ensure safe spacing between interactive elements (CSS obeys)
      // End module
    })();
  </script>
</body>
</html>