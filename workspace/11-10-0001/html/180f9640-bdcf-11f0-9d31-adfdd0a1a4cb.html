<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Module — Knapsack Problem (0/1)</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --card: #0b1220;
      --muted: #9aa4b2;
      --accent: #4f46e5;
      --good: #059669;
      --bad: #ef4444;
      --glass: rgba(255,255,255,0.04);
      --radius: 12px;
      --max-width: 1100px;
    }

    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#061025 0%, #071029 100%);
      color:#e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .wrap{
      padding: var(--safe-padding);
      box-sizing:border-box;
      max-width: var(--max-width);
      margin: 0 auto;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    header{
      display:flex;
      justify-content:space-between;
      align-items: flex-start;
      gap: var(--gap);
      flex-wrap:wrap;
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:-0.2px;
    }
    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
      max-width:60ch;
    }

    main{
      display:flex;
      gap: var(--gap);
      align-items:flex-start;
      width:100%;
    }

    /* Left column: controls & explanation */
    .panel{
      flex: 0 0 380px;
      min-width: 260px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius: var(--radius);
      padding: var(--gap);
      box-sizing:border-box;
      gap: var(--gap);
      display:flex;
      flex-direction:column;
    }

    .panel h2{
      margin:0 0 4px 0;
      font-size:16px;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
      margin:0;
    }

    .controls{
      display:flex;
      gap: var(--gap);
      align-items:center;
      flex-wrap:wrap;
      margin-top:8px;
    }

    .control-block{
      display:flex;
      flex-direction:column;
      gap:8px;
      min-width:120px;
    }
    label{
      font-size:13px;
      color:var(--muted);
    }

    input[type="range"]{
      width:100%;
    }
    .btn{
      background:var(--accent);
      color:white;
      border:0;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      transition:transform .12s ease, box-shadow .12s ease;
      box-shadow: 0 6px 18px rgba(79,70,229,0.12);
    }
    .btn.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      box-shadow:none;
    }
    .btn:active{ transform: translateY(1px); }

    /* Right column: visuals */
    .visual{
      flex:1 1 auto;
      min-width:320px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding: var(--gap);
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      box-sizing:border-box;
    }

    .top-row{
      display:flex;
      justify-content:space-between;
      gap: var(--gap);
      align-items:center;
    }

    .items-area{
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:8px;
      border-radius:10px;
      background: var(--glass);
    }

    .items-list{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      align-items:flex-start;
    }

    .item{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:10px;
      padding:10px 12px;
      min-width:110px;
      display:flex;
      gap:8px;
      align-items:center;
      cursor:grab;
      border:1px solid rgba(255,255,255,0.03);
      transition:transform .14s ease, box-shadow .14s ease;
      user-select:none;
    }

    .item:active{ cursor:grabbing; transform:scale(.995); }
    .item .meta{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .badge{
      font-size:12px;
      padding:6px 8px;
      border-radius:10px;
      color:white;
      font-weight:700;
    }
    .w-badge{ background: linear-gradient(180deg,#0ea5a7,#0891b2); }
    .v-badge{ background: linear-gradient(180deg,#f97316,#fb923c); }

    .knapsack{
      margin-top:12px;
      border-radius:12px;
      min-height:140px;
      position:relative;
      padding:14px;
      background: linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border:1px dashed rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:flex-start;
      overflow:hidden;
    }

    .capacity-row{
      width:100%;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }

    .progress-bar{
      height:12px;
      background: rgba(255,255,255,0.03);
      border-radius:999px;
      flex:1;
      overflow:hidden;
      display:flex;
      align-items:center;
    }

    .progress-fill{
      height:100%;
      background: linear-gradient(90deg,var(--accent),#06b6d4);
      width:0%;
      transition: width .4s ease, background .2s ease;
    }

    .status{
      font-size:13px;
      font-weight:700;
      min-width:84px;
      text-align:right;
    }

    .knap-items{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }

    .small{
      font-size:13px;
      color:var(--muted);
    }

    /* DP table */
    .dp-area{
      margin-top:12px;
      border-radius:10px;
      padding:12px;
      background: rgba(255,255,255,0.02);
      overflow:auto;
    }

    table.dp{
      border-collapse:collapse;
      font-size:13px;
      min-width:480px;
    }
    table.dp td, table.dp th{
      border:1px solid rgba(255,255,255,0.03);
      padding:6px 8px;
      text-align:center;
      min-width:36px;
      white-space:nowrap;
    }
    table.dp td.active{
      background: linear-gradient(90deg, rgba(79,70,229,0.12), rgba(6,182,212,0.06));
      transition: background .18s ease;
      font-weight:700;
      color:white;
    }
    table.dp td.chosen{
      box-shadow: inset 0 0 0 2px rgba(5,150,105,0.16);
      background: linear-gradient(90deg, rgba(5,150,105,0.12), rgba(79,70,229,0.06));
    }

    /* small helpers */
    .flex{
      display:flex;
      gap:12px;
      align-items:center;
    }

    .controls-row{
      display:flex;
      gap:12px;
      margin-top:8px;
      flex-wrap:wrap;
    }

    /* responsive */
    @media (max-width: 980px){
      main{ flex-direction:column; }
      .panel{ width:100%; }
      .visual{ width:100%; }
    }

    /* focus & accessibility */
    button:focus, .btn:focus, input:focus, .item:focus{
      outline: 3px solid rgba(79,70,229,0.24);
      outline-offset:2px;
    }

    /* animation helper for flying items */
    .flying-clone{
      position:fixed;
      z-index:9999;
      transition: transform .45s cubic-bezier(.2,.9,.25,1), opacity .3s ease;
      pointer-events:none;
      will-change:transform, opacity;
    }

    .note{
      color:var(--muted);
      font-size:13px;
      background:transparent;
    }
  </style>
</head>
<body>
  <div class="wrap" role="main">
    <header>
      <div class="title" aria-hidden="false">
        <h1>Knapsack Problem — Interactive 0/1 Exploration</h1>
        <p class="lead">Drag items into the knapsack, adjust capacity, and visualize the dynamic programming table that finds the optimal selection. Animations show how choices are made.</p>
      </div>
      <div style="min-width:220px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
        <div class="small muted">Safe area: 24px — Spacing: 16px</div>
        <button class="btn" id="helpBtn" title="Show learning objective">Learning objective</button>
      </div>
    </header>

    <main>
      <!-- Left panel contains overview, controls, and explanations -->
      <aside class="panel" aria-labelledby="conceptTitle">
        <h2 id="conceptTitle">Concept Title</h2>
        <p class="muted">0/1 Knapsack: choose a subset of items (each either taken or not) to maximize total value without exceeding capacity.</p>

        <h2>Learning Objective</h2>
        <p class="muted">After interacting with this module you will:
          <ul style="margin:6px 0 0 18px; color:var(--muted); padding:0;">
            <li>Understand how item weight/value trade-offs affect selection</li>
            <li>See how the dynamic programming table computes optimal value step-by-step</li>
            <li>Compare manual selections to the algorithm's optimal set</li>
          </ul>
        </p>

        <div style="height:8px;"></div>

        <div class="controls" aria-hidden="false">
          <div class="control-block" style="min-width:160px;">
            <label for="capacityRange">Knapsack capacity</label>
            <input id="capacityRange" type="range" min="5" max="60" value="25" aria-describedby="capacityVal" />
            <div class="flex" style="justify-content:space-between;">
              <div class="small">Capacity limit</div>
              <div id="capacityVal" class="small" style="font-weight:700">25</div>
            </div>
          </div>

          <div class="control-block" style="min-width:140px;">
            <label for="maxItems">Items</label>
            <div style="display:flex; gap:8px; align-items:center;">
              <input id="maxItems" type="number" min="3" max="10" value="6" step="1" style="width:64px; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit;" />
              <button class="btn secondary" id="regen">New set</button>
            </div>
            <div class="small muted" style="margin-top:6px;">Randomize item list (weights 1–20, values 1–50)</div>
          </div>
        </div>

        <div class="controls-row">
          <button class="btn" id="computeBtn">Compute Optimal</button>
          <button class="btn secondary" id="clearBtn">Clear Knapsack</button>
          <button class="btn secondary" id="resetBtn">Reset Items</button>
        </div>

        <div style="margin-top:var(--gap);">
          <h2 style="margin-bottom:6px;">Interaction Design</h2>
          <p class="muted">How to interact:
            <ul style="margin:6px 0 0 18px; color:var(--muted); padding:0;">
              <li>Drag an item from the left list into the knapsack area (or click to toggle).</li>
              <li>Adjust capacity with the slider. The weight bar animates to show fill.</li>
              <li>Press Compute Optimal to see the DP table fill step-by-step and auto-select the best subset.</li>
              <li>If selection exceeds capacity, the status turns red and prevents Compute from accepting that manual selection as optimal.</li>
            </ul>
          </p>
        </div>

        <div style="margin-top:6px;">
          <h2 style="margin-bottom:6px;">Layout Description</h2>
          <p class="muted">A two-column layout:
            <ul style="margin:6px 0 0 18px; color:var(--muted); padding:0;">
              <li>Left panel: explanations and controls (capacity slider, number of items, action buttons).</li>
              <li>Right panel: interactive visualization — item list, knapsack dropzone, progress bar, and DP table.</li>
              <li>Spacing: 24px padding on all sides, minimum 16px gap between interactive elements. Responsive: stacks vertically on narrow viewports.</li>
            </ul>
          </p>
        </div>
      </aside>

      <!-- Right visual area -->
      <section class="visual" aria-live="polite">
        <div class="top-row">
          <div style="flex:1;">
            <h2 style="margin:0 0 6px 0;">Available Items</h2>
            <div class="items-area" aria-label="Available items">
              <div class="items-list" id="itemsList" tabindex="0">
                <!-- Items generated by JS -->
              </div>
            </div>
            <div style="margin-top:8px; display:flex; gap:12px; align-items:center;">
              <div class="note">Tip: drag items to the knapsack, or select and press "Add to knapsack" (keyboard accessible).</div>
              <div style="margin-left:auto; display:flex; gap:8px;">
                <button class="btn secondary" id="addBtn">Add selected</button>
                <button class="btn secondary" id="removeBtn">Remove selected</button>
              </div>
            </div>
          </div>

          <div style="width:320px;">
            <h2 style="margin:0 0 6px 0;">Knapsack</h2>
            <div class="knapsack" id="knapsack" aria-label="Knapsack dropzone" tabindex="0">
              <div class="capacity-row">
                <div style="display:flex; flex-direction:column;">
                  <div class="small">Capacity</div>
                  <div style="font-weight:800; font-size:18px;" id="capDisplay">25</div>
                </div>

                <div class="progress-bar" aria-hidden="true">
                  <div class="progress-fill" id="progressFill" style="width:0%"></div>
                </div>

                <div class="status" id="capStatus">0 / 25</div>
              </div>

              <div class="knap-items" id="knapItems" aria-live="polite" style="min-height:40px;">
                <!-- dropped items appear here -->
              </div>

              <div style="width:100%; display:flex; justify-content:space-between; align-items:center; margin-top:6px;">
                <div class="small muted">Total value: <span id="totalValue" style="font-weight:800">0</span></div>
                <div class="small muted">Total weight: <span id="totalWeight" style="font-weight:800">0</span></div>
              </div>
            </div>
          </div>
        </div>

        <div class="dp-area" aria-live="polite" id="dpArea" style="margin-top:12px;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div>
              <h2 style="margin:0 0 6px 0;">Dynamic Programming Table (0/1)</h2>
              <div class="small muted">Watch the table fill. Highlighted cells show the best known value at each step.</div>
            </div>
            <div class="small muted">Capacity columns: 0..W</div>
          </div>

          <div style="margin-top:12px; overflow:auto;">
            <table class="dp" id="dpTable" role="table" aria-label="Dynamic programming table"></table>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script>
    // Utility and state
    (function(){
      const itemsListEl = document.getElementById('itemsList');
      const knapEl = document.getElementById('knapsack');
      const knapItemsEl = document.getElementById('knapItems');
      const capacityRange = document.getElementById('capacityRange');
      const capacityVal = document.getElementById('capacityVal');
      const capDisplay = document.getElementById('capDisplay');
      const capStatus = document.getElementById('capStatus');
      const progressFill = document.getElementById('progressFill');
      const totalValueEl = document.getElementById('totalValue');
      const totalWeightEl = document.getElementById('totalWeight');
      const regenBtn = document.getElementById('regen');
      const computeBtn = document.getElementById('computeBtn');
      const clearBtn = document.getElementById('clearBtn');
      const resetBtn = document.getElementById('resetBtn');
      const dpTableEl = document.getElementById('dpTable');
      const maxItemsInput = document.getElementById('maxItems');
      const addBtn = document.getElementById('addBtn');
      const removeBtn = document.getElementById('removeBtn');
      const helpBtn = document.getElementById('helpBtn');

      let capacity = parseInt(capacityRange.value,10);
      let items = []; // {id,w,v,el}
      let selectedItemId = null;
      let inKnap = new Set();

      // Initialize
      function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

      function createItems(n){
        items = [];
        for(let i=0;i<n;i++){
          const w = rand(1,20);
          const v = rand(1,50);
          items.push({ id: 'i'+i, w, v });
        }
        renderItems();
        clearKnapsack();
      }

      function renderItems(){
        itemsListEl.innerHTML = '';
        items.forEach(it=>{
          const el = document.createElement('div');
          el.className = 'item';
          el.setAttribute('draggable','true');
          el.setAttribute('tabindex','0');
          el.id = 'item-' + it.id;
          el.dataset.id = it.id;
          el.innerHTML = `
            <div style="display:flex; flex-direction:column;">
              <div style="font-weight:700">${'Item ' + it.id.slice(1)}</div>
              <div class="small muted">weight ${it.w} · value ${it.v}</div>
            </div>
            <div style="margin-left:auto; display:flex; gap:6px;">
              <div class="badge w-badge">${it.w}</div>
              <div class="badge v-badge">${it.v}</div>
            </div>
          `;
          // event handlers
          el.addEventListener('dragstart', onDragStart);
          el.addEventListener('click', ()=>toggleSelect(it.id));
          el.addEventListener('keydown', (e)=>{
            if(e.key === 'Enter' || e.key === ' '){
              e.preventDefault();
              toggleSelect(it.id);
            }
            if(e.key === 'a'){ // quick add via keyboard
              addToKnapsackById(it.id);
            }
          });
          itemsListEl.appendChild(el);
          it.el = el;
        });
      }

      function toggleSelect(id){
        // visually select a single item; used by Add/Remove buttons
        if(selectedItemId === id) {
          selectedItemId = null;
          updateSelectionVisual();
          return;
        }
        selectedItemId = id;
        updateSelectionVisual();
      }
      function updateSelectionVisual(){
        items.forEach(it=>{
          if(it.id === selectedItemId){
            it.el.style.boxShadow = '0 6px 18px rgba(79,70,229,0.12)';
            it.el.style.border = '1px solid rgba(79,70,229,0.14)';
          } else {
            it.el.style.boxShadow = 'none';
            it.el.style.border = '1px solid rgba(255,255,255,0.03)';
          }
        });
      }

      // Drag & Drop handlers
      let draggingId = null;
      function onDragStart(e){
        const id = e.currentTarget.dataset.id;
        draggingId = id;
        e.dataTransfer.setData('text/plain', id);
        // create a ghost dragging image
        const crt = e.currentTarget.cloneNode(true);
        crt.style.width = getComputedStyle(e.currentTarget).width;
        crt.style.boxShadow = '0 20px 40px rgba(0,0,0,0.6)';
        crt.classList.add('flying-clone');
        document.body.appendChild(crt);
        e.dataTransfer.setDragImage(crt, 40, 20);
        setTimeout(()=>document.body.removeChild(crt), 0);
      }

      knapEl.addEventListener('dragover', (e)=>{ e.preventDefault(); knapEl.style.borderColor = 'rgba(79,70,229,0.18)';});
      knapEl.addEventListener('dragleave', ()=>{ knapEl.style.borderColor = 'rgba(255,255,255,0.03)';});
      knapEl.addEventListener('drop', (e)=>{
        e.preventDefault();
        knapEl.style.borderColor = 'rgba(255,255,255,0.03)';
        const id = e.dataTransfer.getData('text/plain') || draggingId;
        if(id) addToKnapsackById(id);
        draggingId = null;
      });

      // Add / Remove by id
      function addToKnapsackById(id){
        if(inKnap.has(id)) return; // already in knapsack
        inKnap.add(id);
        animateAddItem(id);
        updateTotals();
      }

      function removeFromKnapsackById(id){
        if(!inKnap.has(id)) return;
        inKnap.delete(id);
        const el = knapItemsEl.querySelector('[data-id="'+id+'"]');
        if(el) el.remove();
        updateTotals();
      }

      // Clicking in knapsack to remove
      knapItemsEl.addEventListener('click', (e)=>{
        const card = e.target.closest('.item');
        if(card && card.dataset.id){
          removeFromKnapsackById(card.dataset.id);
        }
      });

      // Keyboard support: add/remove selected
      addBtn.addEventListener('click', ()=>{
        if(selectedItemId) addToKnapsackById(selectedItemId);
      });
      removeBtn.addEventListener('click', ()=>{
        if(selectedItemId) removeFromKnapsackById(selectedItemId);
      });

      // Animates copying visual from items list to knapsack area
      function animateAddItem(id){
        const it = items.find(x=>x.id===id);
        if(!it) return;
        const source = it.el;
        const clone = source.cloneNode(true);
        clone.classList.add('flying-clone');
        document.body.appendChild(clone);
        const srcRect = source.getBoundingClientRect();
        const destRect = knapItemsEl.getBoundingClientRect();
        // place clone at source
        clone.style.left = srcRect.left + 'px';
        clone.style.top = srcRect.top + 'px';
        clone.style.width = srcRect.width + 'px';
        clone.style.opacity = '1';
        // compute target position
        const targetX = destRect.left + 8 + (knapItemsEl.children.length % 6) * 120;
        const targetY = destRect.top + Math.floor(knapItemsEl.children.length / 6) * 48;
        // use transform to animate
        requestAnimationFrame(()=>{
          clone.style.transform = `translate(${targetX - srcRect.left}px, ${targetY - srcRect.top}px) scale(.94)`;
          clone.style.opacity = '0.98';
        });
        setTimeout(()=>{
          // append a real item inside knapsack
          const knEl = source.cloneNode(true);
          knEl.classList.remove('flying-clone');
          knEl.style.cursor = 'pointer';
          knEl.style.transform = 'none';
          knEl.style.boxShadow = 'none';
          knEl.setAttribute('data-id', id);
          // adjust look slightly
          knEl.querySelector('.badge').style.opacity = '1';
          knapItemsEl.appendChild(knEl);
          updateTotals();
          // fade & remove clone
          clone.style.opacity = '0';
          clone.style.transform += ' scale(.86)';
          setTimeout(()=>{ if(clone.parentNode) clone.parentNode.removeChild(clone); }, 400);
        }, 420);
      }

      // Totals & progress
      function updateTotals(){
        const chosen = Array.from(inKnap).map(id => items.find(x=>x.id===id));
        const totalW = chosen.reduce((s, it)=> s + (it ? it.w : 0), 0);
        const totalV = chosen.reduce((s, it)=> s + (it ? it.v : 0), 0);
        totalWeightEl.textContent = totalW;
        totalValueEl.textContent = totalV;
        capStatus.textContent = `${totalW} / ${capacity}`;
        const pct = Math.min(100, Math.round(totalW / capacity * 100));
        progressFill.style.width = pct + '%';
        if(totalW > capacity){
          progressFill.style.background = 'linear-gradient(90deg,var(--bad), #fb7185)';
          capStatus.style.color = 'var(--bad)';
        } else {
          progressFill.style.background = '';
          capStatus.style.color = '';
        }
      }

      // Clear knapsack
      function clearKnapsack(){
        inKnap.clear();
        knapItemsEl.innerHTML = '';
        updateTotals();
      }

      // Reset items to current list
      function resetItems(){
        renderItems();
        clearKnapsack();
      }

      // DP Table visualization
      async function computeOptimal(){
        computeBtn.disabled = true;
        const n = items.length;
        const W = capacity;
        // prepare DP matrix (n+1) x (W+1)
        const dp = Array.from({length: n+1}, ()=> new Array(W+1).fill(0));
        // build table visually
        buildEmptyTable(n, W);
        // animate filling
        for(let i=1;i<=n;i++){
          const it = items[i-1];
          for(let w=0; w<=W; w++){
            // highlight current cell
            highlightCell(i, w, 'active');
            await sleep(20);
            if(it.w <= w){
              const without = dp[i-1][w];
              const withVal = dp[i-1][w - it.w] + it.v;
              dp[i][w] = Math.max(without, withVal);
            } else {
              dp[i][w] = dp[i-1][w];
            }
            // update cell text
            setCellValue(i, w, dp[i][w]);
            await sleep(24);
            highlightCell(i, w, ''); // remove active
          }
        }
        // backtrack to find chosen items
        const chosen = [];
        let w = W;
        for(let i = n; i>0; i--){
          if(dp[i][w] !== dp[i-1][w]){
            // item i-1 chosen
            chosen.push(items[i-1].id);
            highlightCell(i, w, 'chosen');
            w -= items[i-1].w;
          }
        }
        // animate selected items into knapsack
        // clear existing knapsack first so animation is clear
        clearKnapsack();
        await sleep(350);
        for(let i = chosen.length - 1; i >= 0; i--){
          addToKnapsackById(chosen[i]);
          await sleep(260);
        }
        computeBtn.disabled = false;
      }

      function buildEmptyTable(n,W){
        dpTableEl.innerHTML = '';
        // header row
        const header = document.createElement('tr');
        header.appendChild(document.createElement('th')); // corner
        for(let w=0; w<=W; w++){
          const th = document.createElement('th');
          th.textContent = w;
          header.appendChild(th);
        }
        dpTableEl.appendChild(header);
        // rows for each item
        for(let i=0;i<=n;i++){
          const tr = document.createElement('tr');
          const firstCell = document.createElement('th');
          firstCell.textContent = (i===0) ? '0 (base)' : `Item ${items[i-1].id.slice(1)} (w${items[i-1].w},v${items[i-1].v})`;
          tr.appendChild(firstCell);
          for(let w=0; w<=W; w++){
            const td = document.createElement('td');
            td.dataset.row = i;
            td.dataset.col = w;
            td.textContent = '0';
            tr.appendChild(td);
          }
          dpTableEl.appendChild(tr);
        }
      }

      function setCellValue(i,w,val){
        const td = dpTableEl.querySelector('td[data-row="'+i+'"][data-col="'+w+'"]');
        if(td) td.textContent = val;
      }
      function highlightCell(i,w,cls){
        const td = dpTableEl.querySelector('td[data-row="'+i+'"][data-col="'+w+'"]');
        if(!td) return;
        td.classList.remove('active','chosen');
        if(cls) td.classList.add(cls);
      }

      function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

      // Event wiring
      capacityRange.addEventListener('input', (e)=>{
        capacity = parseInt(e.target.value,10);
        capacityVal.textContent = capacity;
        capDisplay.textContent = capacity;
        updateTotals();
      });

      regenBtn.addEventListener('click', ()=>{
        const n = Math.max(3, Math.min(10, parseInt(maxItemsInput.value,10) || 6));
        maxItemsInput.value = n;
        createItems(n);
      });

      computeBtn.addEventListener('click', async ()=>{
        // cap sanity
        if(items.length === 0) return;
        // ensure capacity reasonable
        if(capacity > 120) {
          alert('Capacity too large for visualization. Reduce it.');
          return;
        }
        await computeOptimal();
      });

      clearBtn.addEventListener('click', ()=>{
        clearKnapsack();
      });

      resetBtn.addEventListener('click', ()=>{
        resetItems();
      });

      helpBtn.addEventListener('click', ()=>{
        alert("Learning Objective:\n\n• Understand how item weights and values influence selection.\n• Watch the dynamic programming table compute optimal value step-by-step.\n\nTry dragging items or pressing 'Compute Optimal'.");
      });

      // init defaults
      createItems(parseInt(maxItemsInput.value,10) || 6);
      updateTotals();

      // Ensure keyboard users can drop: pressing Enter on knapsack adds selected
      knapEl.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter' && selectedItemId){
          addToKnapsackById(selectedItemId);
        }
      });

      // Accessibility: allow selecting item with arrow keys inside itemsList
      itemsListEl.addEventListener('keydown', (e)=>{
        const focusable = Array.from(itemsListEl.querySelectorAll('.item'));
        if(!focusable.length) return;
        const idx = focusable.indexOf(document.activeElement);
        if(e.key === 'ArrowRight' || e.key === 'ArrowDown'){
          e.preventDefault();
          const next = focusable[Math.min(focusable.length-1, (idx===-1?0:idx+1))];
          next.focus();
        } else if(e.key === 'ArrowLeft' || e.key === 'ArrowUp'){
          e.preventDefault();
          const prev = focusable[Math.max(0, (idx<=0?0:idx-1))];
          prev.focus();
        }
      });

      // Provide window resize safe recalculation for animation; nothing extra needed here.

    })();
  </script>
</body>
</html>