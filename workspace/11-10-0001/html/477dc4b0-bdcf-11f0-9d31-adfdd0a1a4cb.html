<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sliding Window — Max Sum of Fixed-Size Window (Interactive)</title>
  <style>
    :root{
      --safe: 24px;
      --gap: 16px;
      --panel-width: 380px;
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #38bdf8;
      --good: #10b981;
      --bad: #ef4444;
      --gold: #f59e0b;
      --muted: #94a3b8;
      --glass: rgba(255,255,255,0.03);
      --radius: 10px;
      --transition: 350ms cubic-bezier(.2,.9,.2,1);
    }
    /* Page safe area */
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071023 0%, #071226 60%);
      color:#e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .wrap{
      padding: var(--safe);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      justify-content:center;
    }

    /* Layout: responsive two-column */
    .left, .right{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding:20px;
      box-sizing:border-box;
      box-shadow: 0 6px 24px rgba(2,6,23,0.6);
    }
    .left{
      width: min(var(--panel-width), 92vw);
      flex: 0 0 auto;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .right{
      flex:1 1 auto;
      min-width: 280px;
      display:flex;
      flex-direction:column;
      gap:20px;
    }

    header h1{
      font-size:18px;
      margin:0 0 4px 0;
      color:var(--accent);
    }
    header p{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    /* Controls styling */
    .control-group{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    label{
      font-size:13px;
      color:#cfe8ff;
      display:block;
    }
    input[type="text"], input[type="number"]{
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:var(--glass);
      color:inherit;
      outline:none;
      box-sizing:border-box;
      font-size:14px;
    }
    .row{
      display:flex;
      gap:var(--gap);
      align-items:center;
    }
    .toolbar{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }
    button{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.06);
      color:inherit;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-size:14px;
      transition: transform 160ms ease, box-shadow 160ms ease;
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    button:active{ transform: translateY(1px); }
    .primary{
      background: linear-gradient(180deg,var(--accent), #2bb0df);
      color:#042027;
      font-weight:600;
      border: none;
    }
    .small{
      padding:6px 8px;
      font-size:13px;
    }

    /* Visualization */
    .viscard{
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:stretch;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
    }
    .stats{
      display:flex;
      gap:20px;
      align-items:center;
      flex-wrap:wrap;
    }
    .stat{
      background: rgba(255,255,255,0.02);
      padding:8px 10px;
      border-radius:8px;
      min-width:140px;
      font-size:14px;
      color:var(--muted);
    }
    .stat .value{
      display:block;
      font-size:16px;
      font-weight:700;
      color:#e6f8ff;
      margin-top:6px;
    }

    /* Chart area */
    .chart-wrap{
      position:relative;
      height:260px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      background: linear-gradient(180deg, rgba(255,255,255,0.00), rgba(255,255,255,0.00));
      border-radius:8px;
      padding:14px;
      overflow:hidden;
    }
    .bars{
      display:flex;
      align-items:end;
      gap:10px;
      transition: transform var(--transition);
      position:relative;
      padding-bottom:28px;
    }
    .bar{
      width:44px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
      user-select:none;
    }
    .bar-rect{
      width:100%;
      border-radius:8px 8px 4px 4px;
      background: linear-gradient(180deg,#2b6a8f,#174b64);
      display:flex;
      align-items:flex-end;
      justify-content:center;
      transition: transform var(--transition), box-shadow 220ms ease, background 220ms ease;
      position:relative;
    }
    .bar-label{
      font-size:12px;
      color:var(--muted);
      margin-top:6px;
      text-align:center;
      word-break:break-word;
    }
    .bar-value{
      font-size:12px;
      color:#e6f8ff;
      padding:4px 6px;
      border-radius:6px;
      background: rgba(255,255,255,0.03);
      margin-bottom:6px;
    }

    /* Window overlay */
    .window-overlay{
      position:absolute;
      top:12px;
      bottom:28px;
      background: rgba(60,120,180,0.14);
      border: 2px dashed rgba(60,160,220,0.25);
      border-radius:12px;
      pointer-events:none;
      transition: transform var(--transition), width var(--transition);
      box-shadow: 0 6px 18px rgba(11,31,55,0.45);
      display:flex;
      align-items:flex-start;
      justify-content:center;
      overflow:visible;
    }
    .window-overlay .label{
      margin-top:8px;
      font-size:12px;
      color:#e6f8ff;
      background: rgba(255,255,255,0.03);
      padding:6px 10px;
      border-radius:6px;
      backdrop-filter: blur(4px);
    }

    /* Highlights */
    .bar.best .bar-rect{
      outline: 3px solid rgba(245,158,11,0.18);
      box-shadow: 0 8px 30px rgba(245,158,11,0.06), inset 0 -6px 18px rgba(245,158,11,0.02);
      background: linear-gradient(180deg,#f59e0b,#dea42b);
    }
    .bar.outgoing .bar-rect{
      box-shadow: 0 8px 18px rgba(239,68,68,0.12);
      background: linear-gradient(180deg,#ff6b6b,#da3b3b);
    }
    .bar.incoming .bar-rect{
      box-shadow: 0 8px 18px rgba(16,185,129,0.12);
      background: linear-gradient(180deg,#34d399,#10b981);
    }

    /* delta animations (floating labels) */
    .float-delta{
      position:absolute;
      top:-26px;
      left:50%;
      transform:translateX(-50%);
      font-size:13px;
      padding:6px 8px;
      border-radius:6px;
      color:#042027;
      font-weight:700;
      opacity:0;
      transition: transform 420ms cubic-bezier(.2,.9,.2,1), opacity 320ms ease;
      pointer-events:none;
    }
    .bar.outgoing .float-delta{
      background: rgba(239,68,68,0.95);
      color:white;
      opacity:1;
      transform: translate(-50%,-18px);
    }
    .bar.incoming .float-delta{
      background: rgba(16,185,129,0.95);
      color:white;
      opacity:1;
      transform: translate(-50%,-18px);
    }

    /* pseudocode block */
    pre{
      background: rgba(255,255,255,0.02);
      padding:12px;
      border-radius:8px;
      color: #dff7ff;
      font-size:13px;
      margin:0;
      overflow:auto;
    }

    /* small helpers */
    .muted{ color:var(--muted); font-size:13px; }
    .kbd{
      background: rgba(255,255,255,0.03);
      padding:6px 8px;
      border-radius:6px;
      font-weight:600;
      font-size:13px;
      color:var(--muted);
    }

    /* Responsive adjustments */
    @media (max-width:900px){
      .wrap{ flex-direction:column; gap:var(--gap); padding: var(--safe); }
      .left{ width:100%; order:1; }
      .right{ order:2; }
      .bars{ gap:8px; }
      .bar{ width:38px; }
    }
  </style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Sliding window interactive module">
    <div class="left" aria-hidden="false">
      <header>
        <h1>Sliding Window — Fixed Window Max Sum</h1>
        <p>Interactively explore how a sliding window finds the maximum sum of any contiguous window of size k in O(n) time.</p>
      </header>

      <div class="control-group" style="margin-top:6px;">
        <div>
          <label for="arrayInput">Array (comma or space separated integers)</label>
          <input id="arrayInput" type="text" aria-label="Array input" value="2 1 5 1 3 2" />
        </div>

        <div style="display:flex; gap:12px; align-items:center;">
          <div style="flex:1;">
            <label for="kRange">Window size k</label>
            <input id="kRange" type="range" min="1" max="6" value="3" aria-label="Window size slider" />
          </div>
          <div style="width:84px;">
            <label for="kNumber" class="muted">k</label>
            <input id="kNumber" type="number" min="1" max="6" value="3" aria-label="Window size numeric" />
          </div>
        </div>

        <div class="row toolbar" role="toolbar" aria-label="Playback controls">
          <button id="btnRandom" class="small" title="Randomize array">Randomize</button>
          <button id="btnReset" class="small" title="Reset">Reset</button>
          <button id="btnBack" class="small" title="Step back (Left arrow)">◀ Step</button>
          <button id="btnPlay" class="small primary" title="Play / Pause (Space)">Play</button>
          <button id="btnForward" class="small" title="Step forward (Right arrow)">Step ▶</button>
        </div>

        <div style="display:flex; gap:12px; align-items:center;">
          <div style="flex:1;">
            <label for="speedRange">Animation speed</label>
            <input id="speedRange" type="range" min="200" max="1400" step="50" value="700" />
          </div>
          <div style="width:64px;">
            <label class="muted">Speed</label>
            <div id="speedLabel" style="font-weight:600;">700 ms</div>
          </div>
        </div>

        <div>
          <label class="muted">Hints & Shortcuts</label>
          <div style="display:flex; gap:8px; margin-top:8px;">
            <span class="kbd">Space</span><span class="muted">Play/Pause</span>
            <span class="kbd">←</span><span class="muted">Step back</span>
            <span class="kbd">→</span><span class="muted">Step forward</span>
          </div>
        </div>
      </div>

      <div aria-live="polite" id="ariaAnnounce" style="position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden;"></div>
    </div>

    <div class="right">
      <div class="viscard">
        <div class="stats">
          <div class="stat" aria-live="polite">
            <div class="muted">Current window sum</div>
            <div id="currentSum" class="value">—</div>
            <div style="font-size:12px; color:var(--muted); margin-top:6px;" id="currentDelta"> </div>
          </div>

          <div class="stat">
            <div class="muted">Best window sum</div>
            <div id="bestSum" class="value">—</div>
            <div style="font-size:12px; color:var(--muted); margin-top:6px;" id="bestRange"> </div>
          </div>

          <div class="stat">
            <div class="muted">Complexity</div>
            <div class="value">O(n)</div>
            <div style="font-size:12px; color:var(--muted); margin-top:6px;">Sliding window update: sum += in - out</div>
          </div>
        </div>

        <div class="chart-wrap" id="chartWrap" aria-hidden="false">
          <div class="bars" id="bars"></div>
          <div class="window-overlay" id="windowOverlay" style="width:0; transform:translateX(0px);">
            <div class="label" id="overlayLabel">Window</div>
          </div>
        </div>

        <div>
          <label class="muted">Algorithm (pseudocode)</label>
          <pre id="pseudocode">
best = -∞
current = sum(first k elements)
best = current
for i = k to n-1:
    current = current - nums[i-k] + nums[i]
    if current > best:
        best = current
          </pre>
        </div>
      </div>

      <div style="display:flex; gap:12px; align-items:center;">
        <div class="muted" style="flex:1">Try different arrays and window sizes. Watch outgoing (red) and incoming (green) elements and the incremental update.</div>
      </div>
    </div>
  </div>

  <script>
    // Self-contained sliding window interactive implementation
    (function () {
      // Elements
      const arrayInput = document.getElementById('arrayInput');
      const kRange = document.getElementById('kRange');
      const kNumber = document.getElementById('kNumber');
      const barsEl = document.getElementById('bars');
      const windowOverlay = document.getElementById('windowOverlay');
      const currentSumEl = document.getElementById('currentSum');
      const bestSumEl = document.getElementById('bestSum');
      const bestRangeEl = document.getElementById('bestRange');
      const currentDeltaEl = document.getElementById('currentDelta');
      const btnRandom = document.getElementById('btnRandom');
      const btnReset = document.getElementById('btnReset');
      const btnPlay = document.getElementById('btnPlay');
      const btnBack = document.getElementById('btnBack');
      const btnForward = document.getElementById('btnForward');
      const speedRange = document.getElementById('speedRange');
      const speedLabel = document.getElementById('speedLabel');
      const ariaAnnounce = document.getElementById('ariaAnnounce');

      // State
      let nums = [2,1,5,1,3,2];
      let baseNums = nums.slice();
      let k = 3;
      let index = 0; // start index of window
      let currentSum = 0;
      let bestSum = -Infinity;
      let bestStart = 0;
      let playing = false;
      let timer = null;

      // Visual parameters
      const BAR_WIDTH = 44; // CSS width of .bar
      const GAP = 10; // matches CSS .bars gap
      const MAX_BAR_HEIGHT = 180; // px area for height mapping

      // Helpers
      function parseInputArray(value) {
        const parts = value.trim().split(/[\s,]+/).filter(Boolean);
        const parsed = parts.map(s => {
          const n = Number(s);
          return Number.isFinite(n) ? Math.trunc(n) : NaN;
        }).filter(x => !Number.isNaN(x));
        return parsed;
      }

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      function normalizeHeights(values) {
        // Normalize to [28, MAX_BAR_HEIGHT] based on absolute values
        const absMax = Math.max(1, ...values.map(v => Math.abs(v)));
        return values.map(v => {
          // Add small offset for almost-zero visuals
          const relative = Math.abs(v) / absMax;
          const min = 28;
          return min + Math.round(relative * (MAX_BAR_HEIGHT - min)) * Math.sign(v);
        });
      }

      // Render bars based on nums
      function renderBars() {
        barsEl.innerHTML = '';
        const values = nums.slice();
        const heights = normalizeHeights(values);
        values.forEach((val, i) => {
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.dataset.index = i;
          bar.innerHTML = `
            <div class="bar-rect" style="height:${Math.abs(heights[i])}px;" aria-hidden="false">
              <div class="float-delta"></div>
            </div>
            <div class="bar-value">${val}</div>
            <div class="bar-label">idx ${i}</div>
          `;
          barsEl.appendChild(bar);
        });

        // Update range slider max/min
        kRange.max = Math.max(1, nums.length);
        kNumber.max = Math.max(1, nums.length);
        if (k > nums.length) {
          k = nums.length;
          kRange.value = k;
          kNumber.value = k;
        }

        // Position overlay and width
        updateOverlayVisual();
      }

      function updateOverlayVisual(immediate) {
        const barsCount = nums.length;
        if (!barsCount) {
          windowOverlay.style.width = '0';
          return;
        }
        const barEl = barsEl.querySelector('.bar');
        const barRect = barEl ? barEl.getBoundingClientRect() : { width: BAR_WIDTH };
        const width = (barRect.width * k) + (GAP * (k - 1));
        // compute translate X relative to bars container
        const offset = index * (barRect.width + GAP);
        // apply transition duration according to speed (faster speed = shorter CSS transition)
        const ms = Number(speedRange.value) || 700;
        windowOverlay.style.transitionDuration = Math.max(120, ms * 0.6) + 'ms';
        windowOverlay.style.width = width + 'px';
        windowOverlay.style.transform = `translateX(${offset}px)`;
        // overlay label shows start..end
        const overlayLabel = windowOverlay.querySelector('.label');
        overlayLabel.textContent = `window: [${index} .. ${index + k - 1}]`;
      }

      // Compute initial sums
      function computeInitialSums() {
        if (k <= 0 || nums.length < k) {
          currentSum = 0;
          bestSum = -Infinity;
          bestStart = 0;
          index = 0;
          updateUI();
          return;
        }
        currentSum = nums.slice(0, k).reduce((a,b) => a+b, 0);
        bestSum = currentSum;
        bestStart = 0;
        index = 0;
        updateUI();
      }

      function updateUI(deltaInfo) {
        // Clear all highlights
        const allBars = barsEl.querySelectorAll('.bar');
        allBars.forEach(b => b.classList.remove('incoming','outgoing','best'));

        // Mark best bars
        for (let i=bestStart; i<bestStart + k; i++){
          const b = barsEl.querySelector(`.bar[data-index="${i}"]`);
          if (b) b.classList.add('best');
        }

        // Mark current incoming/outgoing if provided
        if (deltaInfo) {
          const outEl = barsEl.querySelector(`.bar[data-index="${deltaInfo.outIndex}"]`);
          const inEl = barsEl.querySelector(`.bar[data-index="${deltaInfo.inIndex}"]`);
          if (outEl) {
            outEl.classList.add('outgoing');
            const fd = outEl.querySelector('.float-delta');
            if (fd) fd.textContent = `-${deltaInfo.outVal}`;
            // remove highlight after animation
            setTimeout(() => { outEl.classList.remove('outgoing'); }, 700);
          }
          if (inEl) {
            inEl.classList.add('incoming');
            const fd = inEl.querySelector('.float-delta');
            if (fd) fd.textContent = `+${deltaInfo.inVal}`;
            setTimeout(() => { inEl.classList.remove('incoming'); }, 700);
          }
        }

        currentSumEl.textContent = String(currentSum);
        bestSumEl.textContent = Number.isFinite(bestSum) ? String(bestSum) : '—';
        bestRangeEl.textContent = Number.isFinite(bestSum) ? `best window: [${bestStart} .. ${bestStart + k - 1}]` : '';
        if (deltaInfo) {
          currentDeltaEl.textContent = `${currentSum} = (prev ${deltaInfo.prevSum}) - ${deltaInfo.outVal} + ${deltaInfo.inVal}`;
        } else {
          currentDeltaEl.textContent = '';
        }
        updateOverlayVisual();
        // announce for screen readers
        ariaAnnounce.textContent = `Window at ${index}. current sum ${currentSum}. best ${bestSum} at ${bestStart}`;
      }

      // Step forward: perform sliding update at index -> index+1
      function stepForward(animate=true) {
        if (nums.length === 0 || k <= 0 || index >= nums.length - k) {
          // reached end
          playing = false;
          updatePlayButton();
          return;
        }
        const outIndex = index;
        const inIndex = index + k;
        const outVal = nums[outIndex];
        const inVal = nums[inIndex];
        const prev = currentSum;
        currentSum = currentSum - outVal + inVal;
        index++;
        // check best
        if (currentSum > bestSum) {
          bestSum = currentSum;
          bestStart = index;
        }
        updateUI({ outIndex, inIndex, outVal, inVal, prevSum: prev });
      }

      // Step back: reverse update (index -> index-1)
      function stepBack(animate=true) {
        if (nums.length === 0 || k <= 0 || index <= 0) return;
        // reverse the forward operation
        const inIndex = index - 1;
        const outIndex = index + k - 1;
        const inVal = nums[inIndex];
        const outVal = nums[outIndex];
        const prev = currentSum;
        currentSum = currentSum - outVal + inVal; // reverse: subtract outgoing (rightmost), add incoming (new left)
        index--;
        // if best was at a later start, we keep best as is (we don't retroactively undo best)
        updateUI({ outIndex, inIndex, outVal, inVal, prevSum: prev });
      }

      function resetToBase() {
        nums = baseNums.slice();
        k = Math.min(k, nums.length || 1);
        kRange.value = k;
        kNumber.value = k;
        index = 0;
        renderBars();
        computeInitialSums();
      }

      function randomizeArray() {
        const len = Math.max(3, Math.min(18, Math.round(3 + Math.random() * 12)));
        nums = new Array(len).fill(0).map(() => Math.round((Math.random()*20)-10)); // -10..10
        baseNums = nums.slice();
        k = Math.min(k, nums.length);
        k = Math.max(1, Math.min(k, nums.length));
        kRange.max = nums.length;
        kNumber.max = nums.length;
        kRange.value = k;
        kNumber.value = k;
        renderBars();
        computeInitialSums();
      }

      // Playback management
      function play() {
        if (playing) return;
        playing = true;
        updatePlayButton();
        const ms = Number(speedRange.value) || 700;
        timer = setInterval(() => {
          if (index >= nums.length - k) {
            stop();
            return;
          }
          stepForward();
        }, ms);
      }
      function stop() {
        playing = false;
        updatePlayButton();
        if (timer) { clearInterval(timer); timer = null; }
      }
      function togglePlay() {
        if (playing) stop(); else play();
      }
      function updatePlayButton() {
        btnPlay.textContent = playing ? 'Pause' : 'Play';
      }

      // UI events
      arrayInput.addEventListener('change', () => {
        const parsed = parseInputArray(arrayInput.value);
        if (parsed.length === 0) {
          alert('Please enter at least one integer.');
          return;
        }
        nums = parsed;
        baseNums = nums.slice();
        k = Math.min(k, nums.length);
        kRange.max = nums.length;
        kNumber.max = nums.length;
        kRange.value = k;
        kNumber.value = k;
        index = 0;
        renderBars();
        computeInitialSums();
      });

      arrayInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          arrayInput.dispatchEvent(new Event('change'));
        }
      });

      kRange.addEventListener('input', () => {
        k = Number(kRange.value);
        kNumber.value = k;
        index = 0;
        renderBars();
        computeInitialSums();
      });

      kNumber.addEventListener('change', () => {
        let v = Number(kNumber.value);
        if (!Number.isFinite(v) || v < 1) v = 1;
        v = Math.round(v);
        v = Math.min(v, nums.length || v);
        k = v;
        kRange.value = k;
        kNumber.value = k;
        index = 0;
        renderBars();
        computeInitialSums();
      });

      btnRandom.addEventListener('click', () => {
        randomizeArray();
      });
      btnReset.addEventListener('click', () => {
        // restore baseNums if changed; reset to initial seed
        nums = baseNums.slice();
        index = 0;
        k = Math.min(k, nums.length || 1);
        kRange.value = k;
        kNumber.value = k;
        renderBars();
        computeInitialSums();
      });

      btnBack.addEventListener('click', () => {
        stop();
        stepBack();
      });

      btnForward.addEventListener('click', () => {
        stop();
        stepForward();
      });

      btnPlay.addEventListener('click', () => {
        togglePlay();
      });

      speedRange.addEventListener('input', () => {
        speedLabel.textContent = `${speedRange.value} ms`;
        // adjust overlay transition duration immediately
        updateOverlayVisual();
        // if playing, restart timer with new speed
        if (playing) {
          stop();
          play();
        }
      });

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) {
          // allow typing in inputs
          return;
        }
        if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
        else if (e.code === 'ArrowRight') { e.preventDefault(); stop(); stepForward(); }
        else if (e.code === 'ArrowLeft') { e.preventDefault(); stop(); stepBack(); }
      });

      // Resize observer to adapt overlay width when bar widths change (responsive)
      new ResizeObserver(() => {
        updateOverlayVisual();
      }).observe(barsEl);

      // Initial render
      function init() {
        // parse initial array input
        const p = parseInputArray(arrayInput.value);
        if (p.length) {
          nums = p;
          baseNums = p.slice();
        }
        k = Math.min(Number(kRange.value) || 1, nums.length);
        kRange.max = Math.max(1, nums.length);
        kNumber.max = Math.max(1, nums.length);
        kRange.value = k;
        kNumber.value = k;
        renderBars();
        computeInitialSums();
        updatePlayButton();
      }

      init();

      // expose some debug (not necessary)
      window._slidingWindow = {
        get nums(){ return nums; },
        get k(){ return k; },
        get index(){ return index; },
        stepForward, stepBack, play, stop
      };
    })();
  </script>
</body>
</html>