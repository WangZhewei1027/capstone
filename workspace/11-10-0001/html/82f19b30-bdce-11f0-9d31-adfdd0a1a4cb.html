<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Adjacency Matrix — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1720;
      --panel: #0b1220;
      --accent: #40c4ff;
      --muted: #9aa6b2;
      --success: #6ee7b7;
      --danger: #ff7b7b;
      --glass: rgba(255,255,255,0.03);
      --cell-on: rgba(64,196,255,0.18);
      --cell-on-strong: rgba(64,196,255,0.35);
      --focus: 0 0 0 3px rgba(64,196,255,0.12);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#051021 0%, #071426 100%);
      color:#dbeafe;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Safe area margins */
    .app{
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100vh;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    header{
      display:flex;
      gap: var(--gap);
      align-items:flex-start;
      flex-wrap:wrap;
    }

    .title{
      flex:1 1 480px;
      min-width: 220px;
    }

    h1{
      margin:0 0 8px 0;
      font-size:20px;
      letter-spacing: -0.01em;
      color: #e6f8ff;
    }

    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    .info{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      padding:12px;
      border-radius:10px;
      min-width: 260px;
      max-width: 420px;
      font-size:13px;
      color:var(--muted);
    }

    .info h3{
      margin:0 0 8px 0;
      font-size:13px;
      color:#e6f8ff;
    }

    /* Main area layout */
    .main{
      display:flex;
      gap: var(--gap);
      align-items:stretch;
      justify-content:stretch;
      flex:1;
    }

    /* Left: graph area */
    .panel{
      flex:1 1 560px;
      background: var(--panel);
      border-radius:12px;
      padding:var(--gap);
      display:flex;
      flex-direction:column;
      min-width:280px;
      min-height:360px;
      box-shadow: 0 6px 18px rgba(1,10,18,0.5);
    }

    .top-controls{
      display:flex;
      gap: var(--gap);
      align-items:center;
      margin-bottom: 8px;
      flex-wrap:wrap;
    }

    .controls-left{
      display:flex;
      gap: var(--gap);
      align-items:center;
    }

    button, .toggle{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      color: #e6f8ff;
      border: 1px solid rgba(255,255,255,0.04);
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
    }

    button:focus, .toggle:focus{
      outline: none;
      box-shadow: var(--focus);
    }

    .toggle.active{
      background: linear-gradient(180deg, rgba(64,196,255,0.12), rgba(64,196,255,0.06));
      border-color: rgba(64,196,255,0.18);
      color: #e9fbff;
    }

    .desc{
      color:var(--muted);
      font-size:13px;
      margin-bottom:8px;
    }

    /* Graph canvas area */
    .canvas-wrap{
      flex:1;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:10px;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
      position:relative;
      overflow:hidden;
      min-height:260px;
      border: 1px dashed rgba(255,255,255,0.03);
    }

    svg{
      width:100%;
      height:100%;
      display:block;
      cursor:default;
    }

    /* Nodes & edges */
    .node{
      transition: transform 0.18s ease, r 0.18s ease;
    }

    .node circle{
      fill: linear-gradient(180deg,#183a5a,#0d1e2a);
      fill: #072138;
      stroke: rgba(255,255,255,0.06);
      stroke-width:1.5px;
    }

    .node text{
      fill:#dbeafe;
      font-size:12px;
      pointer-events:none;
      user-select:none;
    }

    .node:hover circle{
      transform: scale(1.06);
      stroke: rgba(64,196,255,0.4);
      stroke-width:2px;
    }

    .edge{
      stroke: rgba(255,255,255,0.12);
      stroke-width:2px;
      fill:none;
      transition: stroke 0.18s ease, stroke-width 0.18s ease, opacity 0.18s ease;
    }

    .edge.on{
      stroke: var(--accent);
      stroke-width:3px;
      opacity:1;
      filter: drop-shadow(0 6px 14px rgba(64,196,255,0.06));
      animation: dash 600ms ease-out;
    }

    @keyframes dash{
      from{ stroke-dasharray: 12; stroke-dashoffset: 12; }
      to{ stroke-dasharray: 12; stroke-dashoffset: 0; }
    }

    .edge.hover{
      stroke: var(--success);
      stroke-width:4px;
    }

    /* Matrix area */
    .matrix-panel{
      width: 360px;
      max-width: 45%;
      min-width:260px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      border-radius:12px;
      padding:var(--gap);
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .matrix-title{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:var(--gap);
    }

    .matrix-grid{
      overflow:auto;
      border-radius:8px;
      border: 1px solid rgba(255,255,255,0.02);
      background: rgba(4,10,15,0.4);
      padding:8px;
    }

    table{
      border-collapse:collapse;
      width:100%;
      table-layout:fixed;
      font-size:13px;
      color:var(--muted);
    }

    th, td{
      padding:6px;
      text-align:center;
      border: 1px solid rgba(255,255,255,0.02);
    }

    th{
      background: rgba(255,255,255,0.02);
      color:#dbeafe;
      font-weight:600;
    }

    td button{
      width:100%;
      padding:6px;
      border-radius:6px;
      background:transparent;
      border:none;
      color:var(--muted);
      cursor:pointer;
      transition: background 160ms ease, color 160ms ease, transform 120ms ease;
      font-size:13px;
    }

    td button:focus{
      outline:none;
      box-shadow: var(--focus);
    }

    td.on button{
      background: var(--cell-on);
      color: #e6f8ff;
    }

    td.on-strong button{
      background: var(--cell-on-strong);
      color:#e6f8ff;
    }

    td.hover button{
      background: rgba(110,231,183,0.08);
      color:#e6f8ff;
      transform: translateY(-2px);
    }

    /* small screens: stack */
    @media (max-width: 900px){
      .main{
        flex-direction:column;
      }
      .matrix-panel{
        width:100%;
      }
    }

    /* footer notes */
    .notes{
      color:var(--muted);
      font-size:13px;
      background: rgba(255,255,255,0.02);
      border-radius:8px;
      padding:10px;
    }

    /* Accessibility helper for keyboard users when nodes are focusable */
    .node circle:focus{
      outline:none;
      stroke: var(--accent);
      stroke-width:2px;
      filter: none;
    }

    /* Flash animation for matrix cell change */
    @keyframes flashCell {
      0% { background: rgba(64,196,255,0.0); }
      30% { background: rgba(64,196,255,0.26); }
      100% { background: transparent; }
    }

    .flash{
      animation: flashCell 700ms ease;
    }

  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Adjacency Matrix interactive module">
    <header>
      <div class="title">
        <h1>Adjacency Matrix — Visual & Interactive</h1>
        <p class="lead">Toggle edges between nodes and observe how the adjacency matrix changes. Hover to reveal relationships and learn the mapping between graph and matrix.</p>
      </div>

      <aside class="info" aria-live="polite">
        <h3>Learning Objective</h3>
        <div>
          After interacting with this module you will:
          <ul style="margin:8px 0 0 18px; padding:0; color:var(--muted); font-size:13px;">
            <li>Understand how edges in a graph map to entries in an adjacency matrix.</li>
            <li>See differences between directed and undirected adjacency matrices.</li>
            <li>Practice toggling edges via the visual graph and the matrix table.</li>
          </ul>
        </div>
        <hr style="border:none; height:1px; margin:8px 0; background: rgba(255,255,255,0.02)"/>
        <strong style="font-size:13px; color:#e6f8ff">Interaction Design</strong>
        <p style="margin:8px 0 0 0; color:var(--muted); font-size:13px;">
          Click two nodes (source then target) or click a matrix cell to add/remove an edge. Drag nodes to reposition them. Hover a node or a matrix cell to highlight corresponding row/column and edge. Toggle "Directed" mode to observe asymmetric matrices.
        </p>
      </aside>
    </header>

    <div class="main" role="region" aria-labelledby="module-main">
      <section class="panel" aria-label="Graph area">
        <div class="top-controls" role="toolbar" aria-label="Graph controls">
          <div class="controls-left">
            <button id="add-node" title="Add node (max 8)">＋ Add Node</button>
            <button id="remove-node" title="Remove last node">－ Remove Node</button>
            <button id="reset" title="Reset graph">⟲ Reset</button>
          </div>

          <div style="margin-left:auto; display:flex; gap:12px;">
            <button id="directed-toggle" class="toggle" aria-pressed="false" title="Toggle directed/undirected">Directed: off</button>
            <button id="weight-toggle" class="toggle" aria-pressed="false" title="Toggle weighted edges">Weighted: off</button>
          </div>
        </div>

        <div class="desc" id="interaction-hint">Click node A then node B to toggle edge A → B (or A—B if undirected). Hover a cell or node to highlight.</div>

        <div class="canvas-wrap" id="canvas-wrap" aria-hidden="false">
          <svg id="svg" viewBox="0 0 800 520" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Graph visualization">
            <defs>
              <marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L10,5 L0,10 z" fill="#40c4ff"></path>
              </marker>
            </defs>

            <g id="edges" aria-hidden="true"></g>
            <g id="nodes" aria-hidden="true"></g>
          </svg>
        </div>
      </section>

      <aside class="matrix-panel" aria-label="Adjacency matrix panel">
        <div class="matrix-title">
          <div>
            <strong style="font-size:15px; color:#e6f8ff">Adjacency Matrix</strong>
            <div style="font-size:12px; color:var(--muted)">Click cells to toggle edges. Rows = source, Columns = target.</div>
          </div>
          <div style="text-align:right; color:var(--muted); font-size:12px;">
            Nodes: <span id="node-count">4</span>
          </div>
        </div>

        <div class="matrix-grid" id="matrix-grid" tabindex="0" aria-label="Adjacency matrix grid">
          <!-- matrix table is injected here -->
        </div>

        <div style="display:flex; gap:12px; align-items:center; justify-content:space-between;">
          <div style="color:var(--muted); font-size:13px;">Mode: <span id="mode-label">Undirected</span></div>
          <div style="color:var(--muted); font-size:13px;">Tip: Hover or tab into a cell to highlight the corresponding edge.</div>
        </div>
      </aside>
    </div>

    <div class="notes" aria-hidden="false">
      <strong>Layout Description</strong>
      <p style="margin:6px 0 0 0; color:var(--muted); font-size:13px;">
        Safe margins of 24px surround the module. The interface uses two primary panes arranged with a responsive flex layout:
        left — interactive graph canvas with controls above; right — adjacency matrix table with scrollable grid. Minimum spacing of 16px is enforced between controls and panels. On narrow screens the matrix stacks below the graph. Interactive elements are focusable and labeled for accessibility.
      </p>
    </div>
  </div>

  <script>
    // Adjacency Matrix Interactive Module
    // Vanilla JS, self-contained. No external assets.
    (function(){
      const MAX_NODES = 8;
      const svg = document.getElementById('svg');
      const edgesGroup = document.getElementById('edges');
      const nodesGroup = document.getElementById('nodes');
      const matrixGrid = document.getElementById('matrix-grid');
      const addBtn = document.getElementById('add-node');
      const removeBtn = document.getElementById('remove-node');
      const resetBtn = document.getElementById('reset');
      const directedToggle = document.getElementById('directed-toggle');
      const weightToggle = document.getElementById('weight-toggle');
      const nodeCountEl = document.getElementById('node-count');
      const modeLabel = document.getElementById('mode-label');
      const interactionHint = document.getElementById('interaction-hint');

      let directed = false;
      let weighted = false;

      let nodes = []; // {id, x, y}
      let adj = [];   // 2D array [i][j] = 0 or weight>0
      let selectedNode = null; // for click-to-connect
      let dragging = null;
      let dragOffset = {x:0,y:0};

      // init with 4 nodes positioned in circle
      function reset(){
        nodes = [];
        adj = [];
        selectedNode = null;
        const initial = 4;
        for (let i=0;i<initial;i++){
          nodes.push({id:i, x: 400 + 160*Math.cos(2*Math.PI*i/initial), y: 260 + 120*Math.sin(2*Math.PI*i/initial)});
        }
        adj = makeMatrix(nodes.length);
        renderAll();
      }

      function makeMatrix(n){
        const m = new Array(n);
        for (let i=0;i<n;i++){
          m[i] = new Array(n).fill(0);
        }
        return m;
      }

      function renderAll(){
        renderNodes();
        renderEdges();
        renderMatrix();
        updateCount();
      }

      function updateCount(){ nodeCountEl.textContent = nodes.length; modeLabel.textContent = directed ? 'Directed' : 'Undirected'; directedToggle.textContent = 'Directed: ' + (directed ? 'on' : 'off'); directedToggle.setAttribute('aria-pressed', String(directed)); weightToggle.textContent = 'Weighted: ' + (weighted ? 'on' : 'off'); weightToggle.setAttribute('aria-pressed', String(weighted)); }

      // --- Render Nodes ---
      function renderNodes(){
        nodesGroup.innerHTML = '';
        nodes.forEach(n=>{
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('class','node');
          g.setAttribute('data-id', n.id);
          g.setAttribute('tabindex','0');
          g.setAttribute('role','button');
          g.setAttribute('aria-label','Node '+labelFor(n.id));
          g.style.cursor = 'pointer';

          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circle.setAttribute('cx', n.x);
          circle.setAttribute('cy', n.y);
          circle.setAttribute('r', 20);
          circle.setAttribute('fill','#072138');

          const text = document.createElementNS('http://www.w3.org/2000/svg','text');
          text.setAttribute('x', n.x);
          text.setAttribute('y', n.y+4);
          text.setAttribute('text-anchor','middle');
          text.setAttribute('font-family','inherit');
          text.setAttribute('font-size','12');
          text.textContent = labelFor(n.id);

          g.appendChild(circle);
          g.appendChild(text);
          nodesGroup.appendChild(g);

          // Events: click to select target/source; drag
          g.addEventListener('pointerdown', nodePointerDown);
          g.addEventListener('click', nodeClickHandler);
          g.addEventListener('keydown', nodeKeyHandler);
          g.addEventListener('pointerenter', ()=>onNodeHover(n.id, true));
          g.addEventListener('pointerleave', ()=>onNodeHover(n.id, false));
        });
      }

      function labelFor(i){
        // Labels A, B, C...
        return String.fromCharCode(65 + i);
      }

      // --- Render Edges ---
      function renderEdges(){
        edgesGroup.innerHTML = '';
        for (let i=0;i<nodes.length;i++){
          for (let j=0;j<nodes.length;j++){
            if (adj[i][j]){
              const a = nodes[i];
              const b = nodes[j];
              const line = document.createElementNS('http://www.w3.org/2000/svg','path');
              // curved path for better visuals if self-loop or overlap
              const d = computePath(a.x, a.y, b.x, b.y, i===j);
              line.setAttribute('d', d);
              line.setAttribute('class', 'edge on');
              // arrow marker for directed graphs
              if (directed){
                line.setAttribute('marker-end','url(#arrow)');
              } else {
                line.removeAttribute('marker-end');
              }
              line.setAttribute('data-from', i);
              line.setAttribute('data-to', j);
              edgesGroup.appendChild(line);

              // optional weight label
              if (weighted && adj[i][j] !== 1){
                const mid = midPointOnPath(a.x,a.y,b.x,b.y);
                const t = document.createElementNS('http://www.w3.org/2000/svg','text');
                t.setAttribute('x', mid.x);
                t.setAttribute('y', mid.y - 6);
                t.setAttribute('text-anchor','middle');
                t.setAttribute('font-size','12');
                t.setAttribute('fill','#e6f8ff');
                t.textContent = adj[i][j];
                edgesGroup.appendChild(t);
              }

              // click to remove edge
              line.addEventListener('click', (ev)=>{
                ev.stopPropagation();
                toggleEdge(i,j,false);
              });

              // hover highlights matrix cell
              line.addEventListener('pointerenter', ()=>highlightMatrixCell(i,j,true));
              line.addEventListener('pointerleave', ()=>highlightMatrixCell(i,j,false));
            }
          }
        }
      }

      function computePath(x1,y1,x2,y2,self){
        if (self){
          // loop
          const r = 30;
          return `M ${x1} ${y1} C ${x1-r} ${y1-r} ${x1+r} ${y1-r} ${x1} ${y1}`;
        }
        // simple quadratic curve offset by perpendicular
        const dx = x2 - x1;
        const dy = y2 - y1;
        const mx = (x1 + x2)/2;
        const my = (y1 + y2)/2;
        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
        // offset proportional to distance
        const offset = Math.min(80, Math.max(16, dist * 0.12));
        // perp vector
        const px = -dy / dist;
        const py = dx / dist;
        const cx = mx + px * offset;
        const cy = my + py * offset;
        return `M ${x1} ${y1} Q ${cx} ${cy} ${x2} ${y2}`;
      }

      function midPointOnPath(x1,y1,x2,y2){
        return { x: (x1 + x2)/2, y: (y1 + y2)/2 };
      }

      // --- Matrix Rendering ---
      function renderMatrix(){
        matrixGrid.innerHTML = '';
        const n = nodes.length;
        if (n === 0){
          matrixGrid.innerHTML = '<div style="color:var(--muted)">No nodes yet. Add nodes to see the adjacency matrix.</div>';
          return;
        }
        const table = document.createElement('table');
        // header row
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        headerRow.appendChild(document.createElement('th')); // empty corner
        for (let j=0;j<n;j++){
          const th = document.createElement('th');
          th.textContent = labelFor(j);
          headerRow.appendChild(th);
        }
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        for (let i=0;i<n;i++){
          const tr = document.createElement('tr');
          const th = document.createElement('th');
          th.textContent = labelFor(i);
          tr.appendChild(th);

          for (let j=0;j<n;j++){
            const td = document.createElement('td');
            const btn = document.createElement('button');
            btn.setAttribute('aria-label', `Cell ${labelFor(i)} to ${labelFor(j)}: ${adj[i][j] ? '1' : '0'}`);
            btn.textContent = adj[i][j] ? (weighted ? String(adj[i][j]) : '1') : '0';
            btn.addEventListener('click', ()=> {
              toggleEdge(i,j,true);
            });
            btn.addEventListener('pointerenter', ()=> onMatrixHover(i,j,true));
            btn.addEventListener('pointerleave', ()=> onMatrixHover(i,j,false));
            btn.addEventListener('focus', ()=> onMatrixHover(i,j,true));
            btn.addEventListener('blur', ()=> onMatrixHover(i,j,false));
            td.appendChild(btn);
            if (adj[i][j]) td.classList.add('on');
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }

        table.appendChild(tbody);
        matrixGrid.appendChild(table);
      }

      // --- Edge toggle ---
      function toggleEdge(i,j,fromUI){
        if (i < 0 || j < 0 || i >= nodes.length || j >= nodes.length) return;

        if (adj[i][j]){
          // remove
          adj[i][j] = 0;
          if (!directed){
            adj[j][i] = 0;
          }
        } else {
          // add
          let val = 1;
          if (weighted){
            const entered = prompt('Enter weight for edge ' + labelFor(i) + '→' + labelFor(j), '1');
            if (entered === null) return;
            const parsed = Number(entered);
            if (isNaN(parsed)) val = 1;
            else val = parsed;
          }
          adj[i][j] = val;
          if (!directed){
            adj[j][i] = val;
          }
        }
        renderEdges();
        // flash matrix cells that changed, with class .flash
        flashMatrixCells(i,j);
        renderMatrix();

        // if change was initiated by clicking a node (fromUI param false when clicking edge), reset selection
        if (!fromUI){
          selectedNode = null;
          updateInteractionHint();
        }
      }

      function flashMatrixCells(i,j){
        // find table cell(s) corresponding and add flash
        const table = matrixGrid.querySelector('table');
        if (!table) return;
        // rows start at 1 because of header
        const tbody = table.tBodies[0];
        if (!tbody) return;
        const rowI = tbody.rows[i];
        if (rowI){
          const cell = rowI.cells[j+1]; // +1 offset for row header
          if (cell){
            cell.classList.add('flash');
            setTimeout(()=>cell.classList.remove('flash'), 700);
          }
        }
        if (!directed){
          // also symmetric cell
          const rowJ = tbody.rows[j];
          if (rowJ){
            const cell2 = rowJ.cells[i+1];
            if (cell2){
              cell2.classList.add('flash');
              setTimeout(()=>cell2.classList.remove('flash'), 700);
            }
          }
        }
      }

      // --- Node interactions ---
      function nodePointerDown(ev){
        ev.preventDefault();
        const g = ev.currentTarget;
        const id = Number(g.getAttribute('data-id'));
        dragging = id;
        const node = nodes.find(n=>n.id===id);
        const pt = getPointFromEvent(ev);
        dragOffset.x = node.x - pt.x;
        dragOffset.y = node.y - pt.y;
        g.setPointerCapture(ev.pointerId);
        g.addEventListener('pointermove', nodePointerMove);
        g.addEventListener('pointerup', nodePointerUp, { once: true });
      }

      function nodePointerMove(ev){
        ev.preventDefault();
        const g = ev.currentTarget;
        const id = Number(g.getAttribute('data-id'));
        if (dragging !== id) return;
        const pt = getPointFromEvent(ev);
        const node = nodes.find(n=>n.id===id);
        node.x = pt.x + dragOffset.x;
        node.y = pt.y + dragOffset.y;
        // constrain inside viewBox margins
        node.x = Math.max(26, Math.min(774, node.x));
        node.y = Math.max(26, Math.min(494, node.y));
        // update visuals live
        // update node circle and text positions
        const circle = g.querySelector('circle');
        const text = g.querySelector('text');
        circle.setAttribute('cx', node.x);
        circle.setAttribute('cy', node.y);
        text.setAttribute('x', node.x);
        text.setAttribute('y', node.y + 4);
        // update edges
        renderEdges();
      }

      function nodePointerUp(ev){
        const g = ev.currentTarget;
        const id = Number(g.getAttribute('data-id'));
        dragging = null;
        try{
          g.releasePointerCapture(ev.pointerId);
        }catch(e){}
        g.removeEventListener('pointermove', nodePointerMove);
      }

      function nodeClickHandler(ev){
        ev.stopPropagation();
        const id = Number(ev.currentTarget.getAttribute('data-id'));
        if (selectedNode === null){
          selectedNode = id;
          updateInteractionHint();
          // highlight selected node visually
          highlightNode(id, true);
        } else {
          // if same node clicked twice, toggle self-loop
          if (selectedNode === id){
            toggleEdge(id,id,true);
            highlightNode(id,false);
            selectedNode = null;
            updateInteractionHint();
          } else {
            // toggle edge from selectedNode -> id
            const from = selectedNode;
            const to = id;
            toggleEdge(from,to,true);
            highlightNode(selectedNode,false);
            selectedNode = null;
            updateInteractionHint();
          }
        }
      }

      function nodeKeyHandler(ev){
        // Allow keyboard users to toggle self-loop on Enter or Space
        if (ev.key === 'Enter' || ev.key === ' '){
          ev.preventDefault();
          const id = Number(ev.currentTarget.getAttribute('data-id'));
          toggleEdge(id,id,true);
        }
      }

      function updateInteractionHint(){
        if (selectedNode === null){
          interactionHint.textContent = 'Click node A then node B to toggle edge A → B (or A—B if undirected). Hover a cell or node to highlight.';
        } else {
          interactionHint.textContent = 'Selected node ' + labelFor(selectedNode) + '. Click another node to connect, click same node to toggle self-loop.';
        }
      }

      function highlightNode(id, on){
        const g = nodesGroup.querySelector(`g[data-id="${id}"]`);
        if (!g) return;
        const circle = g.querySelector('circle');
        if (on){
          circle.style.stroke = 'rgba(64,196,255,0.5)';
          circle.style.strokeWidth = '2px';
        } else {
          circle.style.stroke = '';
          circle.style.strokeWidth = '';
        }
      }

      // --- Matrix hover/graph highlight ---
      function onMatrixHover(i,j,on){
        // Highlight corresponding edge (if exists) or simulated edge path
        highlightMatrixCell(i,j,on);
      }

      function highlightMatrixCell(i,j,on){
        // Highlight edge visuals
        // find matching edge path (if exists) and add 'hover' class, else draw a temporary path?
        const existing = Array.from(edgesGroup.querySelectorAll('.edge')).find(p=>{
          return Number(p.getAttribute('data-from'))===i && Number(p.getAttribute('data-to'))===j;
        });
        if (on){
          if (existing){
            existing.classList.add('hover');
          } else {
            // draw a temporary dashed path for preview
            const a = nodes[i];
            const b = nodes[j];
            if (!a || !b) return;
            const temp = document.createElementNS('http://www.w3.org/2000/svg','path');
            temp.setAttribute('d', computePath(a.x,a.y,b.x,b.y, i===j));
            temp.setAttribute('class','edge');
            temp.setAttribute('stroke-dasharray','8 6');
            temp.setAttribute('stroke','rgba(110,231,183,0.25)');
            temp.setAttribute('data-temp','true');
            edgesGroup.appendChild(temp);
            // remove later on mouseleave
          }
        } else {
          // remove temp and hover class
          if (existing) existing.classList.remove('hover');
          const temps = edgesGroup.querySelectorAll('[data-temp]');
          temps.forEach(t=>t.remove());
        }

        // matrix cell highlight
        const table = matrixGrid.querySelector('table');
        if (!table) return;
        const tbody = table.tBodies[0];
        if (!tbody) return;
        // clear previous hover classes
        Array.from(tbody.querySelectorAll('td')).forEach(td=>td.classList.remove('hover'));
        if (on){
          const cell = tbody.rows[i].cells[j+1];
          if (cell) cell.classList.add('hover');
        }
      }

      function onNodeHover(id, on){
        // highlight corresponding row/column in matrix
        const table = matrixGrid.querySelector('table');
        if (!table) return;
        const tbody = table.tBodies[0];
        if (!tbody) return;
        // clear previous hover classes
        Array.from(tbody.querySelectorAll('td')).forEach(td=>td.classList.remove('hover'));
        if (on){
          for (let j=0;j<nodes.length;j++){
            const row = tbody.rows[id];
            if (row){
              const cell = row.cells[j+1];
              if (cell) cell.classList.add('hover');
            }
            const colRow = tbody.rows[j];
            if (colRow){
              const colCell = colRow.cells[id+1];
              if (colCell) colCell.classList.add('hover');
            }
          }
        }
      }

      // --- Utility: get point in SVG coordinates ---
      function getPointFromEvent(ev){
        const pt = svg.createSVGPoint();
        pt.x = ev.clientX;
        pt.y = ev.clientY;
        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
        return { x: svgP.x, y: svgP.y };
      }

      // --- Buttons ---
      addBtn.addEventListener('click', ()=>{
        if (nodes.length >= MAX_NODES) { alert('Max nodes: ' + MAX_NODES); return; }
        const id = nodes.length;
        // place new node near center with slight offset
        nodes.push({id:id, x: 400 + (Math.random()*260-130), y: 260 + (Math.random()*160-80)});
        // expand matrix
        adj.forEach(row => row.push(0));
        adj.push(new Array(nodes.length).fill(0));
        renderAll();
      });

      removeBtn.addEventListener('click', ()=>{
        if (nodes.length === 0) return;
        nodes.pop();
        adj.pop();
        adj.forEach(row => row.pop());
        selectedNode = null;
        renderAll();
      });

      resetBtn.addEventListener('click', ()=>{
        if (!confirm('Reset graph to default?')) return;
        reset();
      });

      directedToggle.addEventListener('click', ()=>{
        directed = !directed;
        if (!directed){
          // when switching to undirected, make symmetric
          for (let i=0;i<nodes.length;i++){
            for (let j=0;j<nodes.length;j++){
              if (adj[i][j] || adj[j][i]){
                const val = adj[i][j] || adj[j][i];
                adj[i][j] = val;
                adj[j][i] = val;
              }
            }
          }
        }
        renderAll();
        updateCount();
      });

      weightToggle.addEventListener('click', ()=>{
        weighted = !weighted;
        renderAll();
        updateCount();
      });

      // clicking background clears selection
      svg.addEventListener('click', (ev)=>{
        selectedNode = null;
        updateInteractionHint();
        // clear any temporary hover lines
        highlightMatrixCell(-1,-1,false);
        // clear node highlight
        Array.from(nodesGroup.querySelectorAll('g')).forEach(g=>{
          const circle = g.querySelector('circle');
          if (circle) { circle.style.stroke = ''; circle.style.strokeWidth=''; }
        });
      });

      // init
      reset();

      // Accessibility: keyboard nav for matrix: allow arrow keys to move focus within matrix buttons
      matrixGrid.addEventListener('keydown', (ev)=>{
        const active = document.activeElement;
        if (!active || active.tagName !== 'BUTTON') return;
        const table = matrixGrid.querySelector('table');
        if (!table) return;
        // find position
        const td = active.closest('td');
        if (!td) return;
        const row = td.parentElement;
        const body = table.tBodies[0];
        const rIndex = Array.prototype.indexOf.call(body.rows, row);
        const cIndex = Array.prototype.indexOf.call(row.cells, td) - 1; // offset for row header
        let nr = rIndex, nc = cIndex;
        if (ev.key === 'ArrowRight') nc = Math.min(nodes.length-1, nc+1);
        else if (ev.key === 'ArrowLeft') nc = Math.max(0, nc-1);
        else if (ev.key === 'ArrowDown') nr = Math.min(nodes.length-1, nr+1);
        else if (ev.key === 'ArrowUp') nr = Math.max(0, nr-1);
        else return;
        ev.preventDefault();
        const target = body.rows[nr].cells[nc+1].querySelector('button');
        if (target) target.focus();
      });

      // make module responsive on resize by adjusting viewBox if needed (kept static for simplicity)
    })();
  </script>
</body>
</html>