<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Binary Search — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #3b82f6;
      --muted: #94a3b8;
      --ok: #16a34a;
      --bad: #ef4444;
      --glass: rgba(255,255,255,0.03);
      --duration: 450ms;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI",
                   Roboto, "Helvetica Neue", Arial;
    }

    /* Safe area */
    html,body{height:100%;}
    body{
      margin:0;
      padding:var(--safe-margin);
      background:linear-gradient(180deg,#071022 0%, #071322 60%);
      color:#e6eef8;
      box-sizing:border-box;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }

    /* Container */
    .module{
      width:100%;
      max-width:1100px;
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
    }

    /* Left: Visual board */
    .board{
      flex:1 1 620px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      border-radius:12px;
      padding:20px;
      box-shadow:0 6px 30px rgba(2,6,23,0.6);
      min-width:300px;
    }
    .header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:var(--gap);
    }
    h1{
      font-size:20px;
      margin:0;
      letter-spacing:0.2px;
    }
    p.lead{
      margin:8px 0 0 0;
      color:var(--muted);
      font-size:13px;
    }

    /* Control and info area to the right */
    .side{
      width:360px;
      min-width:280px;
      background:var(--card);
      border-radius:12px;
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      box-shadow:0 6px 20px rgba(2,6,23,0.5);
    }

    /* Array visualization */
    .array-wrap{
      margin-top:18px;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
    }
    .array-line{
      display:flex;
      gap:12px;
      align-items:center;
      overflow:auto;
      padding:12px;
      width:100%;
    }

    .cell{
      min-width:56px;
      height:56px;
      display:flex;
      align-items:center;
      justify-content:center;
      background:var(--glass);
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--muted);
      font-weight:600;
      font-size:16px;
      position:relative;
      transition:transform var(--duration) ease, background-color var(--duration), opacity var(--duration), color var(--duration);
      cursor:pointer;
      flex:0 0 56px;
      user-select:none;
    }
    .cell:focus{outline:2px solid rgba(59,130,246,0.25);}

    .cell.selected{
      background:linear-gradient(180deg, rgba(59,130,246,0.18), rgba(59,130,246,0.08));
      color:var(--accent);
      transform:scale(1.05);
      box-shadow:0 6px 20px rgba(59,130,246,0.08);
    }
    .cell.mid{
      background: linear-gradient(180deg, rgba(99,102,241,0.14), rgba(99,102,241,0.06));
      color:#c7d8ff;
      transform:scale(1.08);
      box-shadow:0 10px 30px rgba(99,102,241,0.06);
      animation:midPulse 1s infinite ease-in-out;
    }
    @keyframes midPulse{
      0%{ box-shadow:0 6px 18px rgba(99,102,241,0.05); transform:scale(1.06);}
      50%{ box-shadow:0 16px 36px rgba(99,102,241,0.09); transform:scale(1.08);}
      100%{ box-shadow:0 6px 18px rgba(99,102,241,0.05); transform:scale(1.06);}
    }

    .cell.eliminated{
      opacity:0.28;
      transform:scale(0.98);
      color:rgba(255,255,255,0.45);
      background:transparent;
      cursor:default;
    }

    /* Pointers above array */
    .pointer-row{
      height:36px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:flex-start;
      width:100%;
      padding-left:2px;
    }
    .pointer{
      position:relative;
      min-width:56px;
      height:36px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      transform-origin:center;
      transition:transform var(--duration) ease, opacity var(--duration) ease;
    }
    .pointer .label{
      background:rgba(255,255,255,0.03);
      font-size:12px;
      color:var(--muted);
      padding:4px 8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
    }
    .arrow{
      width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:10px solid var(--muted);
      margin-top:4px;
      opacity:0.9;
    }
    .pointer.faded{opacity:0.28;}
    .pointer.found .label{background:rgba(22,163,74,0.12); color:var(--ok); border-color:rgba(22,163,74,0.1);}
    .pointer.found .arrow{border-top-color:var(--ok);}

    /* Controls */
    .controls{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .row{display:flex;gap:12px;align-items:center;}
    .btn{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      color:var(--muted);
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
      min-height:40px;
      flex:0 0 auto;
      transition:transform 160ms ease, background-color 160ms;
    }
    .btn:active{transform:translateY(1px);}
    .btn.primary{
      background:linear-gradient(180deg,#1e3a8a22,#1e40af11);
      color:var(--accent);
      border-color:rgba(59,130,246,0.12);
      box-shadow:0 6px 14px rgba(59,130,246,0.04);
    }
    .btn.ghost{
      background:transparent;
      border:1px dashed rgba(255,255,255,0.03);
      color:var(--muted);
    }
    input[type="number"], input[type="range"]{
      appearance:none;
      -webkit-appearance:none;
      background:transparent;
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.03);
      padding:10px 12px;
      border-radius:10px;
      min-height:40px;
      font-weight:600;
    }
    input[type="number"]::-webkit-inner-spin-button{opacity:0.4;}

    .small{font-size:13px;color:var(--muted);}

    .status{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      padding:12px;
      border-radius:10px;
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.02);
      font-size:13px;
    }

    /* Pseudocode */
    .pseudocode{
      background:rgba(255,255,255,0.02);
      padding:12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.02);
      color:var(--muted);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:13px;
    }
    .pseudocode .line{
      padding:6px 8px;
      border-radius:6px;
      display:block;
      transition:background-color 220ms ease, color 220ms;
    }
    .pseudocode .line.active{
      background:linear-gradient(90deg, rgba(59,130,246,0.14), rgba(99,102,241,0.06));
      color:#cfe1ff;
      border-left:3px solid rgba(59,130,246,0.18);
    }

    /* Narration / explanation */
    .narration{
      background:transparent;
      color:var(--muted);
      font-size:13px;
      min-height:48px;
      padding:8px;
    }

    /* Footer small */
    .meta{font-size:12px;color:var(--muted);}

    /* Responsive stacking */
    @media (max-width:980px){
      .module{flex-direction:column;padding-bottom:40px;}
      .side{width:100%;}
    }
    /* Ensure minimum spacing between interactive elements (16px) where applicable */
    .controls > * { margin:0; }
  </style>
</head>
<body>
  <main class="module" id="module">
    <!-- Left: Visual + description -->
    <section class="board" aria-labelledby="title">
      <div class="header">
        <div>
          <h1 id="title">Binary Search — Visual Explorer</h1>
          <p class="lead">Click a value to set the search target (or type a number on the right). Step through how binary search narrows the array.</p>
        </div>
        <div class="meta">Interactive module — vanilla HTML/CSS/JS</div>
      </div>

      <!-- Concept & Learning Objective & Interaction Design & Layout Description -->
      <div style="margin-top:16px;display:flex;flex-direction:column;gap:12px">
        <div style="background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);">
          <strong>Concept Title:</strong> Binary Search (on sorted arrays)
          <div style="margin-top:6px;color:var(--muted);font-size:13px">
            <strong>Learning Objective:</strong> After interacting, you will be able to explain how binary search halves a sorted array each comparison, identify mid/low/high pointers, and count comparisons and steps needed to find (or not find) a target.
          </div>
        </div>

        <div style="background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);color:var(--muted);font-size:13px">
          <strong>Interaction Design:</strong>
          <ul style="margin:8px 0 0 18px">
            <li>Click any cell to select the target number, or type a number and press "Set target".</li>
            <li>Use Next / Prev to step through the algorithm. "Auto" runs the steps with animation; speed is adjustable.</li>
            <li>Visual feedback: the mid cell pulses; eliminated segments fade out; L/R pointers move and highlight. Pseudocode lines are highlighted in sync with the current step and a short narration explains the decision.</li>
            <li>Accessible controls: keyboard arrows for step navigation, Space to play/pause.</li>
          </ul>
        </div>

        <div style="background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);color:var(--muted);font-size:13px">
          <strong>Layout Description:</strong> The left panel shows the array visualization and brief module header. The right panel contains controls, target input, playback, pseudocode, and narration. Safe-area margins are 24px; minimum spacing between controls is 16px. The layout is responsive: panels sit side-by-side on wide screens and stack on narrow screens. Visual focus is enforced by clear color contrast and motion for the active elements.
        </div>
      </div>

      <!-- Visualizer: pointers and array -->
      <div class="array-wrap" aria-hidden="false" style="margin-top:18px">
        <div class="pointer-row" id="pointerRow" aria-hidden="true"></div>
        <div class="array-line" id="arrayLine" role="list" aria-label="Sorted array elements"></div>
      </div>
    </section>

    <!-- Right: Controls, pseudocode, narration -->
    <aside class="side" aria-label="Controls and explanation">
      <div class="controls">
        <div style="display:flex;gap:12px;align-items:center;">
          <label class="small" for="sizeRange">Array size</label>
          <input id="sizeRange" type="range" min="5" max="21" value="11" aria-label="Array size slider" />
          <button class="btn ghost" id="regenBtn" aria-label="Regenerate array">Regenerate</button>
        </div>

        <div style="display:flex;gap:12px;align-items:center;">
          <input id="targetInput" type="number" placeholder="Type target value" aria-label="Target value input" />
          <button class="btn primary" id="setTargetBtn" aria-label="Set target by number">Set target</button>
          <button class="btn" id="clearTargetBtn" aria-label="Clear target">Clear</button>
        </div>

        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
          <div style="display:flex;gap:8px;">
            <button class="btn" id="prevBtn" aria-label="Previous step">◀ Prev</button>
            <button class="btn primary" id="nextBtn" aria-label="Next step">Next ▶</button>
            <button class="btn" id="playBtn" aria-label="Auto play">Auto ▶</button>
            <button class="btn ghost" id="resetBtn" aria-label="Reset">Reset</button>
          </div>
        </div>

        <div style="display:flex;gap:12px;align-items:center;">
          <label class="small" for="speedRange">Speed</label>
          <input id="speedRange" type="range" min="200" max="1600" value="800" />
          <div class="small" id="comparisons">Comparisons: 0</div>
        </div>

        <div class="status" aria-live="polite">
          <div><strong>State:</strong> <span id="stateLabel">idle</span></div>
          <div><strong>Step:</strong> <span id="stepLabel">0</span></div>
        </div>

        <div class="pseudocode" aria-hidden="false" id="pseudocode">
          <div class="line" data-line="1">function binarySearch(arr, target):</div>
          <div class="line" data-line="2" style="margin-left:12px">low = 0</div>
          <div class="line" data-line="3" style="margin-left:12px">high = arr.length - 1</div>
          <div class="line" data-line="4" style="margin-left:12px">while low <= high:</div>
          <div class="line" data-line="5" style="margin-left:24px">mid = floor((low + high) / 2)</div>
          <div class="line" data-line="6" style="margin-left:24px">if arr[mid] == target: return mid</div>
          <div class="line" data-line="7" style="margin-left:24px">else if arr[mid] < target: low = mid + 1</div>
          <div class="line" data-line="8" style="margin-left:24px">else: high = mid - 1</div>
          <div class="line" data-line="9" style="margin-left:12px">return -1  # not found</div>
        </div>

        <div class="narration" id="narration" aria-live="polite">Select a target to begin.</div>

      </div>
    </aside>
  </main>

  <script>
    // ===== Binary Search Visual Module (vanilla JS) =====
    (function(){
      // Elements
      const arrayLine = document.getElementById('arrayLine');
      const pointerRow = document.getElementById('pointerRow');
      const sizeRange = document.getElementById('sizeRange');
      const regenBtn = document.getElementById('regenBtn');
      const targetInput = document.getElementById('targetInput');
      const setTargetBtn = document.getElementById('setTargetBtn');
      const clearTargetBtn = document.getElementById('clearTargetBtn');
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');
      const playBtn = document.getElementById('playBtn');
      const resetBtn = document.getElementById('resetBtn');
      const speedRange = document.getElementById('speedRange');

      const comparisonsLabel = document.getElementById('comparisons');
      const stateLabel = document.getElementById('stateLabel');
      const stepLabel = document.getElementById('stepLabel');
      const pseudocode = document.getElementById('pseudocode');
      const narration = document.getElementById('narration');

      // State
      let arr = [];
      let size = parseInt(sizeRange.value,10) || 11;
      let target = null;
      let low = 0, high = -1, mid = -1;
      let history = []; // records snapshots for stepping
      let stepIndex = -1;
      let playing = false;
      let playTimer = null;
      let comparisons = 0;

      // Generate a sorted array (increasing but not necessarily consecutive)
      function generateArray(n){
        const out = [];
        let cur = Math.max(1, Math.floor(Math.random()*3));
        for(let i=0;i<n;i++){
          cur += Math.floor(Math.random()*5) + 1;
          out.push(cur);
        }
        return out;
      }

      // Render array elements and attach click behavior
      function renderArray(){
        arrayLine.innerHTML = '';
        pointerRow.innerHTML = '';
        arr.forEach((val, idx) => {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.setAttribute('role','button');
          cell.setAttribute('tabindex','0');
          cell.setAttribute('aria-label', 'Value ' + val + ' at index ' + idx);
          cell.textContent = val;
          cell.dataset.index = idx;
          cell.addEventListener('click', () => setTargetByIndex(idx));
          cell.addEventListener('keydown', (e) => {
            if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); setTargetByIndex(idx); }
          });
          arrayLine.appendChild(cell);

          // pointer placeholders (same number)
          const p = document.createElement('div');
          p.className = 'pointer faded';
          p.innerHTML = '<div class="label"></div>';
          p.style.width = cell.style.width;
          pointerRow.appendChild(p);
        });
        syncVisualState();
      }

      // Sync UI elements to current search state
      function syncVisualState(){
        const cells = Array.from(arrayLine.children);
        const pointers = Array.from(pointerRow.children);

        cells.forEach((cell, i) => {
          cell.classList.remove('mid','selected','eliminated');
          cell.style.transitionDelay = '0ms';
          // default: interactive
          if (target !== null && arr[i] === target) {
            // if target set but not found yet, mark selected as target
            cell.classList.add('selected');
          }
        });

        // mark eliminated (outside [low,high])
        cells.forEach((cell, i) => {
          if (low !== null && high !== null && (i < low || i > high)) {
            cell.classList.add('eliminated');
          }
        });

        // highlight mid if defined and within bounds
        if (mid !== null && mid >= 0 && mid < arr.length) {
          const mc = cells[mid];
          if(mc) mc.classList.add('mid');
        }

        // pointers: map labels L and R above their positions (faded if out)
        pointers.forEach((p, i) => {
          p.innerHTML = '';
          p.classList.remove('faded','found');
          const labelDiv = document.createElement('div');
          labelDiv.className='label';
          p.appendChild(labelDiv);
          const arrow = document.createElement('div');
          arrow.className='arrow';
          p.appendChild(arrow);
          if (i === low && low <= high) {
            labelDiv.textContent = 'L';
            p.classList.remove('faded');
          } else if (i === high && low <= high) {
            labelDiv.textContent = 'R';
            p.classList.remove('faded');
          } else if (i === mid && mid >= 0 && mid < arr.length) {
            labelDiv.textContent = 'mid';
            p.classList.remove('faded');
          } else {
            p.classList.add('faded');
          }

          // Found pointer: if mid is found
          if (mid>=0 && mid<arr.length && arr[mid] === target) {
            if(i === mid) p.classList.add('found');
          }
        });

        // update labels & counters
        comparisonsLabel.textContent = 'Comparisons: ' + comparisons;
        stepLabel.textContent = Math.max(0, stepIndex+1);
      }

      // Save a snapshot for history (for stepping backward)
      function snapshot(note=''){
        history = history.slice(0, stepIndex+1);
        history.push({
          arr: arr.slice(),
          target,
          low, high, mid,
          comparisons,
          note
        });
        stepIndex = history.length - 1;
      }

      // Initialize or reset search variables
      function initSearch(resetComparisons=true){
        low = 0;
        high = arr.length - 1;
        mid = Math.floor((low + high)/2);
        if(resetComparisons) comparisons = 0;
        history = [];
        stepIndex = -1;
        snapshot('start');
        stateLabel.textContent = 'idle';
        syncPseudocode(null);
        narration.textContent = 'Ready. Select a target (click cell or use the input).';
        syncVisualState();
      }

      // Set target by clicking an index
      function setTargetByIndex(idx){
        target = arr[idx];
        targetInput.value = target;
        narration.textContent = 'Target set to ' + target + '. Use Next to step or Auto to run.';
        initSearch();
      }

      // Set target by input value
      function setTargetByInput(){
        const v = Number(targetInput.value);
        if(Number.isNaN(v)) {
          narration.textContent = 'Please enter a valid number.';
          return;
        }
        target = v;
        narration.textContent = 'Target set to ' + target + '.';
        initSearch();
      }

      // Clear target
      function clearTarget(){
        target = null;
        targetInput.value = '';
        initSearch();
        narration.textContent = 'Target cleared.';
      }

      // Perform one binary search step (returns outcome string)
      function doStep(){
        if(target === null){
          narration.textContent = 'No target selected. Choose one to begin.';
          return;
        }
        if(low > high){
          snapshot('not found');
          syncVisualState();
          narration.textContent = 'Search ended: target not found (low > high).';
          stateLabel.textContent = 'finished';
          syncPseudocode(9);
          return;
        }

        mid = Math.floor((low + high)/2);
        comparisons++;
        snapshot('compare mid');
        syncVisualState();
        syncPseudocode(5);
        // small delay to allow mid pulsing then evaluate
        return new Promise(resolve => {
          setTimeout(() => {
            if(arr[mid] === target){
              snapshot('found');
              syncPseudocode(6);
              syncVisualState();
              narration.textContent = 'Found target at index ' + mid + ' after ' + comparisons + ' comparisons.';
              stateLabel.textContent = 'found';
              resolve('found');
            } else if (arr[mid] < target){
              snapshot('mid < target -> shift low');
              syncPseudocode(7);
              narration.textContent = 'arr[mid] ('+arr[mid]+') < target ('+target+') → move L to mid+1.';
              low = mid + 1;
              mid = Math.floor((low + high)/2);
              syncVisualState();
              stateLabel.textContent = 'searching';
              resolve('low');
            } else {
              snapshot('mid > target -> shift high');
              syncPseudocode(8);
              narration.textContent = 'arr[mid] ('+arr[mid]+') > target ('+target+') → move R to mid-1.';
              high = mid - 1;
              mid = Math.floor((low + high)/2);
              syncVisualState();
              stateLabel.textContent = 'searching';
              resolve('high');
            }
          }, 420);
        });
      }

      // Step backward to previous snapshot
      function stepBack(){
        if(stepIndex <= 0) {
          narration.textContent = 'At start. Nothing before this step.';
          return;
        }
        stepIndex--;
        restoreSnapshot(history[stepIndex]);
        narration.textContent = 'Step ' + (stepIndex+1) + ' (rewound).';
      }

      // Restore snapshot to UI
      function restoreSnapshot(snap){
        arr = snap.arr.slice();
        target = snap.target;
        low = snap.low;
        high = snap.high;
        mid = snap.mid;
        comparisons = snap.comparisons;
        syncVisualState();
        syncPseudocodeForSnapshot(snap);
        stateLabel.textContent = (low>high)?'finished':'idle';
        stepLabel.textContent = Math.max(0, stepIndex+1);
      }

      // Play auto steps
      function togglePlay(){
        if(playing){
          stopPlay();
        } else {
          startPlay();
        }
      }
      function startPlay(){
        if(!target){
          narration.textContent = 'Set a target first.';
          return;
        }
        playing = true;
        playBtn.textContent = 'Pause ⏸';
        stateLabel.textContent = 'playing';
        playLoop();
      }
      function stopPlay(){
        playing = false;
        playBtn.textContent = 'Auto ▶';
        stateLabel.textContent = 'idle';
        if(playTimer) { clearTimeout(playTimer); playTimer = null; }
      }

      function playLoop(){
        if(!playing) return;
        // if finished, stop
        if(low > high){
          narration.textContent = 'Target not found. Auto stopped.';
          stopPlay();
          return;
        }
        // if last snapshot was found, stop
        if(mid>=0 && arr[mid]===target){
          narration.textContent = 'Target found. Auto stopped.';
          stopPlay();
          return;
        }
        doStep().then(() => {
          // schedule next
          if(playing){
            playTimer = setTimeout(playLoop, Number(speedRange.value) || 800);
          }
        });
      }

      // Reset to beginning (but keep target)
      function resetToStart(){
        if(history.length === 0) {
          initSearch();
          return;
        }
        stepIndex = 0;
        restoreSnapshot(history[0]);
        narration.textContent = 'Reset to start.';
      }

      // Regenerate array
      function regenerate(){
        size = Math.max(5, Math.min(21, Number(sizeRange.value)));
        arr = generateArray(size);
        target = null;
        targetInput.value = '';
        initSearch(true);
        renderArray();
      }

      // Update pseudocode highlight
      function syncPseudocode(line){
        const lines = pseudocode.querySelectorAll('.line');
        lines.forEach(l => l.classList.remove('active'));
        if(line){
          const selected = pseudocode.querySelector('.line[data-line="'+line+'"]');
          if(selected) selected.classList.add('active');
        }
      }

      // Sync based on snapshot's note (for stepping)
      function syncPseudocodeForSnapshot(snap){
        if(!snap) { syncPseudocode(null); return; }
        // Simple mapping: use note to highlight approximate line
        if(snap.note === 'start') syncPseudocode(2);
        else if(snap.note === 'compare mid') syncPseudocode(5);
        else if(snap.note === 'found') syncPseudocode(6);
        else if(snap.note.indexOf('mid < target')>=0) syncPseudocode(7);
        else if(snap.note.indexOf('mid > target')>=0) syncPseudocode(8);
        else if(snap.note === 'not found') syncPseudocode(9);
        else syncPseudocode(null);
      }

      // Event bindings
      nextBtn.addEventListener('click', () => {
        stopPlay();
        doStep();
      });
      prevBtn.addEventListener('click', () => {
        stopPlay();
        stepBack();
      });
      playBtn.addEventListener('click', togglePlay);
      resetBtn.addEventListener('click', () => {
        stopPlay();
        resetToStart();
      });
      regenBtn.addEventListener('click', () => {
        stopPlay();
        regenerate();
      });
      setTargetBtn.addEventListener('click', () => {
        stopPlay();
        setTargetByInput();
      });
      clearTargetBtn.addEventListener('click', () => {
        stopPlay();
        clearTarget();
      });
      sizeRange.addEventListener('input', () => {
        // visual update of size but do not auto regenerate until button or change end
      });
      // regenerate on release for friendliness
      sizeRange.addEventListener('change', () => {
        stopPlay();
        regenerate();
      });

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if(e.key === 'ArrowRight') { e.preventDefault(); stopPlay(); doStep(); }
        if(e.key === 'ArrowLeft') { e.preventDefault(); stopPlay(); stepBack(); }
        if(e.key === ' ') { e.preventDefault(); togglePlay(); }
      });

      // Initial bootstrap
      arr = generateArray(size);
      renderArray();
      initSearch();

      // Helper: restore initial when window resized to keep pointer alignment (not required but helps)
      window.addEventListener('resize', () => { syncVisualState(); });

      // Accessibility tip: focusing elements
      document.querySelectorAll('.cell').forEach(c => c.setAttribute('tabindex','0'));

    })();
  </script>
</body>
</html>