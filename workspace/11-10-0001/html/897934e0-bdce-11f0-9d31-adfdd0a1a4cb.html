<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Graph: Directed vs Undirected — Interactive Module</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --accent-2: #7c3aed;
      --success: #10b981;
      --danger: #ef4444;
    }

    /* Safe area margins */
    html,body{
      height:100%;
      margin:0;
      padding:var(--safe-padding);
      background: linear-gradient(180deg, #071029 0%, #081323 100%);
      color:#e6eef8;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      box-sizing:border-box;
    }
    *{box-sizing:inherit}

    /* Layout */
    .container{
      display:flex;
      gap:var(--gap);
      height:calc(100% - (var(--safe-padding) * 2));
    }

    /* Left column: textual explanation & controls */
    .left{
      width:320px;
      min-width:260px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      border-radius:12px;
      padding:20px;
      display:flex;
      flex-direction:column;
      gap:16px;
      overflow:auto;
    }

    h1{
      font-size:18px;
      margin:0 0 4px 0;
      color:#f8fafc;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
      margin:0 0 8px 0;
    }
    .box{
      background:rgba(255,255,255,0.01);
      border-radius:8px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.02);
      font-size:13px;
      color:#dbeafe;
    }

    .controls{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .row{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }

    button, .toggle {
      cursor:pointer;
      border:0;
      border-radius:8px;
      padding:8px 12px;
      font-size:13px;
      color:#0b1220;
      background:var(--accent);
      transition:transform .12s ease, box-shadow .12s ease;
    }
    button:hover{ transform:translateY(-2px); box-shadow:0 6px 18px rgba(0,0,0,0.4); }
    .secondary{
      background:transparent;
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.03);
    }

    .toggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
    }

    .mode-pill{
      padding:6px 10px;
      border-radius:999px;
      font-weight:600;
      font-size:13px;
      color:#0b1220;
    }
    .mode-directed{ background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:white; }
    .mode-undirected{ background:linear-gradient(90deg,#94a3b8,#64748b); color:white; }

    .hint{
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    /* Main canvas */
    .main{
      flex:1 1 0%;
      min-width:280px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .canvas-wrap{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.03);
      flex:1 1 auto;
      position:relative;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }

    .toolbar{
      display:flex;
      gap:12px;
      align-items:center;
      padding:12px;
      border-bottom:1px solid rgba(255,255,255,0.02);
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
    }
    .toolbar .note{
      color:var(--muted);
      font-size:13px;
      margin-left:auto;
    }

    /* SVG area */
    svg#graph{
      flex:1 1 auto;
      width:100%;
      height:100%;
      display:block;
      cursor:crosshair;
    }

    /* Right info panel */
    .right{
      width:360px;
      max-width:40%;
      min-width:240px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));
      border-radius:12px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
      border:1px solid rgba(255,255,255,0.03);
      overflow:auto;
    }
    .panel-title{ font-size:14px; margin:0; color:#cfe8ff; }
    pre, code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; font-size:13px; color:#e2f1ff; background:transparent; margin:0; }

    /* Node and edge visuals (SVG classes) */
    .node{
      fill:linear-gradient(180deg,#60a5fa,#7c3aed);
      stroke:#0b1220;
      stroke-width:2px;
      transition:transform .14s ease;
    }
    circle.node {
      fill: #0ea5e9;
      stroke: rgba(11,18,32,0.9);
      stroke-width:2px;
      filter: drop-shadow(0 6px 16px rgba(14,165,233,0.12));
    }
    text.nlabel{
      font-size:12px;
      font-weight:600;
      fill:#071025;
      text-anchor:middle;
      dominant-baseline:middle;
      pointer-events:none;
    }

    path.edge-line{
      stroke:#94a3b8;
      stroke-width:2.5;
      fill:none;
      opacity:0.9;
      transition:stroke .12s ease, stroke-width .12s ease;
    }
    path.edge-line.selected{
      stroke:var(--accent);
      stroke-width:3.6;
      filter: drop-shadow(0 6px 14px rgba(96,165,250,0.14));
    }
    /* arrowhead marker styling is inlined in SVG defs */

    /* small floating controls when edge selected */
    .edge-controls{
      position:absolute;
      background:rgba(3,7,18,0.9);
      border:1px solid rgba(255,255,255,0.03);
      padding:8px;
      border-radius:8px;
      display:flex;
      gap:8px;
      align-items:center;
      z-index:6;
      transform:translate(-50%,-120%);
    }
    .edge-controls button{ padding:6px 8px; font-size:13px; }

    /* Responsive adjustments */
    @media (max-width:980px){
      .container{ flex-direction:column; }
      .left, .right{ width:100%; max-width:none; }
      .main{ order:2; min-height:420px; }
    }
    /* Animations */
    @keyframes pop {
      0%{ transform:scale(.6); opacity:0; }
      60%{ transform:scale(1.05); opacity:1; }
      100%{ transform:scale(1); }
    }

    .node-pop{
      animation: pop .26s cubic-bezier(.2,.9,.3,1);
    }

    .glow {
      filter: drop-shadow(0 8px 18px rgba(124,58,237,0.18));
    }

    /* small helpers */
    .muted-note{ color:var(--muted); font-size:13px; }
    .kbd{ background:rgba(255,255,255,0.03); border-radius:6px; padding:4px 6px; font-weight:600; font-size:13px; color:#e6eef8; }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Interactive module: Directed vs Undirected Graphs">
    <aside class="left" aria-label="Explanation and controls">
      <div>
        <h1>Concept: Directed vs Undirected Graph</h1>
        <p class="muted">Explore how edge direction changes adjacency, degrees, and representation.</p>
      </div>

      <div class="box" aria-hidden="false">
        <strong>Learning objective</strong>
        <p class="hint" style="margin-top:8px">
          After interacting you will be able to:
          <ul style="margin:8px 0 0 18px; padding:0;">
            <li>Construct graphs by placing nodes and connecting them.</li>
            <li>Switch between Directed and Undirected modes to observe differences.</li>
            <li>See how adjacency lists, matrices, and node degrees change with direction.</li>
          </ul>
        </p>
      </div>

      <div class="controls" aria-hidden="false">
        <div class="box">
          <div style="display:flex;gap:8px;align-items:center;">
            <div>
              <strong>Interaction design</strong>
              <div class="muted-note" style="margin-top:6px">
                Click canvas to create nodes. Click a node to select source, then click target to create an edge. Drag nodes to reposition. Click an edge to select and reverse (in Directed mode).
              </div>
            </div>
          </div>
        </div>

        <div class="box">
          <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
            <div>
              <div style="font-size:13px;color:var(--muted);">Graph mode</div>
              <div style="margin-top:8px;display:flex;gap:8px;">
                <button id="btn-directed" class="mode-pill mode-directed" aria-pressed="true">Directed</button>
                <button id="btn-undirected" class="mode-pill mode-undirected secondary" aria-pressed="false">Undirected</button>
              </div>
            </div>
            <div style="margin-left:auto;">
              <button id="btn-clear" class="secondary">Clear</button>
            </div>
          </div>

          <div style="margin-top:12px" class="muted-note">
            Shortcuts: <span class="kbd">Esc</span> to cancel selection, <span class="kbd">Delete</span> to remove selected node/edge.
          </div>
        </div>

        <div class="box">
          <strong>How the interaction reinforces learning</strong>
          <p class="muted-note" style="margin-top:8px">
            Visual arrows, adjacency views, and degree counters update immediately when you toggle mode or create edges — making the abstract notion of direction concrete and observable.
          </p>
        </div>

      </div>
    </aside>

    <main class="main" aria-label="Interactive canvas and controls">
      <div class="canvas-wrap" aria-live="polite">
        <div class="toolbar" role="toolbar" aria-label="Canvas toolbar">
          <div>
            <button id="mode-info" class="secondary">Mode: <span id="mode-pill" style="font-weight:700;margin-left:8px;color:#cfe8ff">Directed</span></button>
          </div>
          <div class="note">Click canvas to add nodes • Click node → node to add edge • Drag nodes to move</div>
        </div>

        <!-- SVG graph area -->
        <svg id="graph" tabindex="0" aria-label="Graph drawing area">
          <defs>
            <marker id="arrow" markerWidth="10" markerHeight="10" refX="14" refY="5" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L10,5 L0,10 z" fill="#94a3b8"></path>
            </marker>
            <marker id="arrow-selected" markerWidth="12" markerHeight="12" refX="16" refY="6" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L12,6 L0,12 z" fill="#60a5fa"></path>
            </marker>
          </defs>

          <!-- edges group -->
          <g id="edges"></g>
          <!-- nodes group -->
          <g id="nodes"></g>
        </svg>

        <!-- floating edge controls -->
        <div id="edge-controls" class="edge-controls" style="display:none;">
          <div id="edge-info" style="color:#cfe8ff;font-size:13px">Edge controls</div>
          <button id="btn-reverse">Reverse</button>
          <button id="btn-delete-edge" class="secondary">Delete</button>
        </div>

      </div>
    </main>

    <aside class="right" aria-label="Adjacency and matrix details">
      <div>
        <h3 class="panel-title">Adjacency & Degrees</h3>
        <div class="muted" style="margin-top:6px">Updates live when graph changes or when you toggle mode.</div>
      </div>

      <div class="box" style="overflow:auto;">
        <div style="display:flex;gap:12px;align-items:center;margin-bottom:8px;">
          <strong style="font-size:13px">Adjacency list</strong>
          <div style="margin-left:auto" class="muted-note">Current mode: <span id="small-mode" style="font-weight:700;color:#cfe8ff">Directed</span></div>
        </div>
        <pre id="adj-list" style="white-space:pre-wrap;min-height:90px;">(empty)</pre>
      </div>

      <div class="box" style="overflow:auto;">
        <strong style="font-size:13px">Adjacency matrix</strong>
        <div style="margin-top:8px; font-size:13px; color:var(--muted);">Rows = sources, Columns = targets</div>
        <pre id="adj-matrix" style="margin-top:8px; white-space:pre; min-height:120px;">(empty)</pre>
      </div>

      <div class="box">
        <strong style="font-size:13px">Node degrees</strong>
        <div id="deg-list" style="margin-top:8px; font-size:13px; color:var(--muted)">(empty)</div>
      </div>

    </aside>
  </div>

  <script>
    /*****************************************************************************
     * Graph module (vanilla JS)
     *
     * - Single concept: Directed vs Undirected graphs
     * - Interactions:
     *   * Click empty SVG to create node
     *   * Click a node to select as source; click another to create edge
     *   * Drag nodes to reposition
     *   * Click edge to select; reverse/delete via floating controls (Reverse only in Directed mode)
     *   * Toggle global graph mode (Directed/Undirected) via buttons
     * - Visual feedback:
     *   * Nodes pop in
     *   * Edges get arrows in Directed mode (smooth fade)
     *   * Selected edge glows; selected node glows; edges and lists update immediately
     *
     *****************************************************************************/

    (function(){
      // DOM elements
      const svg = document.getElementById('graph');
      const nodesG = document.getElementById('nodes');
      const edgesG = document.getElementById('edges');
      const btnDirected = document.getElementById('btn-directed');
      const btnUndirected = document.getElementById('btn-undirected');
      const modePill = document.getElementById('mode-pill');
      const smallMode = document.getElementById('small-mode');
      const btnClear = document.getElementById('btn-clear');
      const adjListPre = document.getElementById('adj-list');
      const adjMatrixPre = document.getElementById('adj-matrix');
      const degListDiv = document.getElementById('deg-list');
      const edgeControls = document.getElementById('edge-controls');
      const btnReverse = document.getElementById('btn-reverse');
      const btnDeleteEdge = document.getElementById('btn-delete-edge');

      // Data model
      let nodes = []; // {id, x, y}
      let edges = []; // {id, sourceId, targetId}
      let nextNodeId = 1;
      let nextEdgeId = 1;

      let state = {
        mode: 'directed', // or 'undirected'
        selectedNode: null, // nodeId used as source when creating edge
        dragging: null, // {id, offsetX, offsetY}
        selectedEdge: null, // edgeId
      };

      // Basic helpers
      function svgPoint(evt){
        const rect = svg.getBoundingClientRect();
        return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
      }

      function findNodeById(id){ return nodes.find(n => n.id === id); }
      function findEdgeById(id){ return edges.find(e => e.id === id); }

      // Render functions
      function render(){
        renderEdges();
        renderNodes();
        updateAdjViews();
      }

      function renderNodes(){
        // Clear
        nodesG.innerHTML = '';
        for (const n of nodes){
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('transform', `translate(${n.x},${n.y})`);
          g.dataset.id = n.id;
          g.classList.add('node-group');

          // circle
          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circle.setAttribute('r', 20);
          circle.setAttribute('class','node');
          circle.setAttribute('cx',0);
          circle.setAttribute('cy',0);
          circle.style.cursor = 'grab';
          g.appendChild(circle);

          // label
          const label = document.createElementNS('http://www.w3.org/2000/svg','text');
          label.setAttribute('class','nlabel');
          label.setAttribute('x',0);
          label.setAttribute('y',0);
          label.textContent = n.id;
          g.appendChild(label);

          // Event handlers
          g.addEventListener('mousedown', nodeMouseDown);
          g.addEventListener('mouseup', nodeMouseUp);
          g.addEventListener('dblclick', nodeDoubleClick);
          g.addEventListener('click', nodeClick);

          // Visual highlight if selected as source
          if (state.selectedNode === n.id){
            circle.classList.add('glow');
            circle.style.filter = 'drop-shadow(0 6px 22px rgba(60,130,250,0.14))';
          }

          // Apply pop animation for recently created node
          if (n._new){ circle.classList.add('node-pop'); delete n._new; }

          nodesG.appendChild(g);
        }
      }

      function renderEdges(){
        edgesG.innerHTML = '';
        for (const e of edges){
          // if self-loop, render arc; otherwise render path between centers
          const s = findNodeById(e.sourceId);
          const t = findNodeById(e.targetId);
          if (!s || !t) continue;

          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          path.classList.add('edge-line');
          path.dataset.id = e.id;

          // For undirected mode we show symmetric lines without arrow markers
          const isDirectedMode = (state.mode === 'directed');

          // Compute path
          if (s.id === t.id){
            // self-loop as a circular arc
            const r = 28;
            const sx = s.x;
            const sy = s.y;
            const d = `M ${sx+20} ${sy} C ${sx+60} ${sy-40}, ${sx+60} ${sy+40}, ${sx+20} ${sy}`;
            path.setAttribute('d', d);
          } else {
            // line with a slight curve offset for readability if opposite edge exists
            const dx = t.x - s.x;
            const dy = t.y - s.y;
            const mx = (s.x + t.x) / 2;
            const my = (s.y + t.y) / 2;
            // check for opposite edge to curve
            const opposite = edges.find(o => o.sourceId === e.targetId && o.targetId === e.sourceId && o.id !== e.id);
            const curve = opposite ? 30 : 0;
            const nx = mx + (dy / Math.hypot(dx,dy)) * curve;
            const ny = my - (dx / Math.hypot(dx,dy)) * curve;
            const d = `M ${s.x} ${s.y} Q ${nx} ${ny} ${t.x} ${t.y}`;
            path.setAttribute('d', d);
          }

          // marker for arrow
          if (isDirectedMode){
            // directed mode: show arrow at end
            path.setAttribute('marker-end', state.selectedEdge === e.id ? 'url(#arrow-selected)' : 'url(#arrow)');
          } else {
            path.removeAttribute('marker-end');
          }

          // selected styling
          if (state.selectedEdge === e.id) path.classList.add('selected');

          // events
          path.addEventListener('click', edgeClick);
          path.addEventListener('mouseenter', () => path.style.strokeWidth = '3.4');
          path.addEventListener('mouseleave', () => { if (!path.classList.contains('selected')) path.style.strokeWidth = ''; });

          edgesG.appendChild(path);
        }
      }

      // Adjacency and matrix views
      function updateAdjViews(){
        if (nodes.length === 0){
          adjListPre.textContent = '(empty)';
          adjMatrixPre.textContent = '(empty)';
          degListDiv.textContent = '(empty)';
          return;
        }
        const ordered = nodes.map(n => n.id);
        // adjacency list
        const isDirected = (state.mode === 'directed');
        const adj = {};
        for (const id of ordered) adj[id] = [];
        for (const e of edges){
          if (isDirected){
            adj[e.sourceId].push(e.targetId);
          } else {
            // undirected: add both ways but avoid duplicates
            adj[e.sourceId].push(e.targetId);
            if (e.sourceId !== e.targetId) adj[e.targetId].push(e.sourceId);
          }
        }
        // build text
        let listText = '';
        for (const id of ordered){
          const neighbors = adj[id].length ? adj[id].join(', ') : '-';
          listText += id + ': ' + neighbors + '\n';
        }
        adjListPre.textContent = listText.trim();

        // adjacency matrix
        const matrix = [];
        for (let i=0;i<ordered.length;i++){
          matrix[i] = Array(ordered.length).fill(0);
        }
        for (const e of edges){
          const si = ordered.indexOf(e.sourceId);
          const ti = ordered.indexOf(e.targetId);
          if (si >= 0 && ti >= 0){
            matrix[si][ti] = 1;
            if (!isDirected){
              matrix[ti][si] = 1;
            }
          }
        }
        let matrixText = '   ' + ordered.map(x=>(' '+x).slice(-3)).join('') + '\n';
        for (let i=0;i<ordered.length;i++){
          matrixText += (' '+ordered[i]).slice(-3) + ' ' + matrix[i].map(v=>('  '+v).slice(-3)).join('') + '\n';
        }
        adjMatrixPre.textContent = matrixText.trim();

        // degrees
        let degText = '';
        if (isDirected){
          // compute in/out
          const inDeg = {};
          const outDeg = {};
          for (const id of ordered){ inDeg[id] = 0; outDeg[id] = 0; }
          for (const e of edges){
            outDeg[e.sourceId]++;
            inDeg[e.targetId]++;
          }
          for (const id of ordered){
            degText += `${id}: in=${inDeg[id]} | out=${outDeg[id]}\n`;
          }
        } else {
          const deg = {};
          for (const id of ordered) deg[id] = 0;
          for (const e of edges){
            deg[e.sourceId]++;
            if (e.sourceId !== e.targetId) deg[e.targetId]++;
          }
          for (const id of ordered){
            degText += `${id}: degree=${deg[id]}\n`;
          }
        }
        degListDiv.textContent = degText.trim();
      }

      // Interaction handlers
      svg.addEventListener('click', (evt) => {
        // Create node if clicking on empty space (not on nodes or edges)
        // we check event target; only create if background area clicked
        if (evt.target === svg){
          const p = svgPoint(evt);
          createNode(p.x, p.y);
        }
      });

      function createNode(x,y){
        const id = nextNodeId++;
        nodes.push({ id, x, y, _new:true });
        // reset selections
        state.selectedNode = null;
        state.selectedEdge = null;
        updateSelectionUI();
        render();
      }

      // Node events: mousedown for drag, click for selection, double click to delete
      let dragInfo = null;
      function nodeMouseDown(evt){
        evt.stopPropagation();
        const g = evt.currentTarget;
        const id = Number(g.dataset.id);
        const point = svgPoint(evt);
        const n = findNodeById(id);
        dragInfo = { id, offsetX: point.x - n.x, offsetY: point.y - n.y };
        state.dragging = true;
        svg.style.cursor = 'grabbing';
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
      }

      function onMouseMove(evt){
        if (!dragInfo) return;
        const point = svgPoint(evt);
        const n = findNodeById(dragInfo.id);
        n.x = point.x - dragInfo.offsetX;
        n.y = point.y - dragInfo.offsetY;
        // keep within bounds (small padding)
        const pad = 28;
        n.x = Math.max(pad, Math.min(svg.clientWidth - pad, n.x));
        n.y = Math.max(pad, Math.min(svg.clientHeight - pad, n.y));
        render();
      }

      function onMouseUp(evt){
        dragInfo = null;
        state.dragging = false;
        svg.style.cursor = 'crosshair';
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
      }

      function nodeMouseUp(evt){
        evt.stopPropagation();
      }

      function nodeClick(evt){
        evt.stopPropagation();
        const id = Number(evt.currentTarget.dataset.id);
        // If there is a selected node waiting, create edge from selectedNode -> id
        if (state.selectedNode === null){
          // select this node as source
          state.selectedNode = id;
          state.selectedEdge = null;
          updateSelectionUI();
          render();
        } else if (state.selectedNode === id){
          // clicked same node: interpret as cancel selection
          state.selectedNode = null;
          updateSelectionUI();
          render();
        } else {
          // create edge from selectedNode to this id
          const source = state.selectedNode;
          const target = id;
          createEdge(source, target);
          state.selectedNode = null;
          updateSelectionUI();
          render();
        }
      }

      function nodeDoubleClick(evt){
        evt.stopPropagation();
        const id = Number(evt.currentTarget.dataset.id);
        // delete node and connected edges
        nodes = nodes.filter(n => n.id !== id);
        edges = edges.filter(e => e.sourceId !== id && e.targetId !== id);
        if (state.selectedNode === id) state.selectedNode = null;
        if (state.selectedEdge && !findEdgeById(state.selectedEdge)) state.selectedEdge = null;
        render();
      }

      function createEdge(sourceId, targetId){
        // avoid duplicate identical edges (for directed allow multiple? keep simple: no duplicates)
        const exists = edges.find(e => e.sourceId === sourceId && e.targetId === targetId);
        if (exists) return;
        const id = nextEdgeId++;
        edges.push({ id, sourceId, targetId });
      }

      // Edge click
      function edgeClick(evt){
        evt.stopPropagation();
        const id = Number(evt.currentTarget.dataset.id);
        state.selectedEdge = id;
        state.selectedNode = null;
        updateSelectionUI();
        render();
        // show edge controls near mouse
        const rect = svg.getBoundingClientRect();
        const clientX = evt.clientX;
        const clientY = evt.clientY;
        edgeControls.style.display = 'flex';
        edgeControls.style.left = (clientX - rect.left) + 'px';
        edgeControls.style.top = (clientY - rect.top) + 'px';
        // show or hide reverse based on mode
        btnReverse.disabled = (state.mode !== 'directed');
        btnReverse.style.opacity = (state.mode === 'directed') ? '1' : '0.5';
      }

      // Outside click to clear selection
      document.addEventListener('click', (evt) => {
        if (!evt.target.closest('#graph') && !evt.target.closest('.edge-controls')){
          state.selectedNode = null;
          state.selectedEdge = null;
          updateSelectionUI();
          render();
          edgeControls.style.display = 'none';
        }
      });

      // Edge controls
      btnReverse.addEventListener('click', () => {
        if (!state.selectedEdge) return;
        if (state.mode !== 'directed') return;
        const e = findEdgeById(state.selectedEdge);
        if (e){
          // reverse
          const tmp = e.sourceId;
          e.sourceId = e.targetId;
          e.targetId = tmp;
          render();
        }
      });

      btnDeleteEdge.addEventListener('click', () => {
        if (!state.selectedEdge) return;
        edges = edges.filter(e => e.id !== state.selectedEdge);
        state.selectedEdge = null;
        edgeControls.style.display = 'none';
        render();
      });

      // Mode buttons
      function setMode(m){
        state.mode = m;
        modePill.textContent = m[0].toUpperCase() + m.slice(1);
        smallMode.textContent = modePill.textContent;
        btnDirected.setAttribute('aria-pressed', m === 'directed');
        btnUndirected.setAttribute('aria-pressed', m === 'undirected');
        if (m === 'directed'){
          btnDirected.classList.remove('secondary');
          btnDirected.classList.add('mode-directed');
          btnUndirected.classList.remove('mode-undirected');
          btnUndirected.classList.add('secondary');
        } else {
          btnUndirected.classList.remove('secondary');
          btnUndirected.classList.add('mode-undirected');
          btnDirected.classList.remove('mode-directed');
          btnDirected.classList.add('secondary');
        }
        // toggling mode updates rendering (arrows appear/disappear) and adjacency views
        render();
      }

      btnDirected.addEventListener('click', () => setMode('directed'));
      btnUndirected.addEventListener('click', () => setMode('undirected'));
      btnClear.addEventListener('click', () => {
        nodes = []; edges = []; nextNodeId = 1; nextEdgeId = 1;
        state.selectedNode = null; state.selectedEdge = null;
        render();
      });

      // Keyboard shortcuts
      window.addEventListener('keydown', (evt) => {
        if (evt.key === 'Escape'){
          state.selectedNode = null;
          state.selectedEdge = null;
          edgeControls.style.display = 'none';
          render();
        }
        if (evt.key === 'Delete' || evt.key === 'Backspace'){
          if (state.selectedEdge){
            edges = edges.filter(e => e.id !== state.selectedEdge);
            state.selectedEdge = null;
            edgeControls.style.display = 'none';
            render();
            evt.preventDefault();
          } else if (state.selectedNode){
            const id = state.selectedNode;
            nodes = nodes.filter(n => n.id !== id);
            edges = edges.filter(e => e.sourceId !== id && e.targetId !== id);
            state.selectedNode = null;
            render();
            evt.preventDefault();
          }
        }
      });

      // Cancel drag on mouse up anywhere
      svg.addEventListener('mouseup', () => {
        dragInfo = null;
        state.dragging = false;
      });

      // Initialize with some sample nodes to quickly show differences
      (function seed(){
        // optional: create a small example
        createNode(140, 120);
        createNode(340, 120);
        createNode(240, 240);
        // create sample edges
        createEdge(1,2);
        createEdge(2,3);
        createEdge(3,1);
        render();
      })();

      // Selection UI update
      function updateSelectionUI(){
        // hide edge controls if no edge selected
        if (!state.selectedEdge) edgeControls.style.display = 'none';
      }

      // Initial render
      render();

      // Accessibility: focus the SVG for keyboard hints
      svg.addEventListener('focus', () => {
        svg.style.outline = '2px solid rgba(96,165,250,0.18)';
      });
      svg.addEventListener('blur', () => {
        svg.style.outline = '';
      });

      // Make sure adj view updates when window resizes (for aesthetic)
      window.addEventListener('resize', render);
    })();
  </script>
</body>
</html>