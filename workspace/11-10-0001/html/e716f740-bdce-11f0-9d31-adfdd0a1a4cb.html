<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Quick Sort Explorer</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --accent: #2b7cff;
      --accent-2: #ff7a59;
      --bg: #0f1724;
      --card: #0b1220;
      --muted: #94a3b8;
      --success: #16a34a;
      --danger: #ef4444;
      --panel-radius: 12px;
      --transition: 300ms cubic-bezier(.2,.9,.3,1);
      --font-sans: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    /* Safe area */
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071025 0%, #07131f 100%);
      font-family: var(--font-sans);
      color: #e6eef8;
    }
    .safe {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100vh;
    }

    .container{
      display: grid;
      grid-template-columns: 320px 1fr 300px;
      gap: var(--gap);
      align-items: start;
    }

    /* Top header across full width */
    header{
      grid-column: 1 / -1;
      display:flex;
      align-items:center;
      gap: var(--gap);
      margin-bottom: 8px;
    }
    h1{
      font-size: 20px;
      margin:0;
      letter-spacing: -0.2px;
    }
    .subtitle{
      color: var(--muted);
      font-size: 13px;
    }

    /* Left controls card */
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--panel-radius);
      padding: 16px;
      box-shadow: 0 4px 18px rgba(2,6,23,0.6);
    }

    .controls{
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    label{
      font-size: 13px;
      color: var(--muted);
    }

    input[type="text"]{
      padding: 8px 10px;
      border-radius: 8px;
      border: none;
      background: rgba(255,255,255,0.03);
      color: #e6eef8;
      outline: 2px solid transparent;
      transition: outline var(--transition);
    }
    input[type="text"]:focus{ outline: 2px solid rgba(43,124,255,.18); }

    .row {
      display:flex;
      gap: var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }

    .btn {
      background: linear-gradient(180deg,var(--accent), #196eec);
      color:#fff;
      border:none;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      box-shadow: 0 6px 18px rgba(43,124,255,0.18);
      transition: transform 140ms ease, opacity 120ms ease;
      font-weight:600;
    }
    .btn.secondary{
      background: rgba(255,255,255,0.03);
      color:#cfe4ff;
      border: 1px solid rgba(255,255,255,0.03);
      box-shadow: none;
      font-weight:600;
    }
    .btn:active{ transform: translateY(1px); }

    .toggles{ display:flex; gap:8px; flex-wrap:wrap; }
    .option{
      background: rgba(255,255,255,0.02);
      padding:6px 8px;
      border-radius:8px;
      font-size:13px;
      cursor:pointer;
      border:1px solid transparent;
    }
    .option.active{
      border-color: rgba(255,255,255,0.06);
      background: rgba(43,124,255,0.12);
    }

    .small{
      font-size:13px;
      color:var(--muted);
    }

    /* Center visualization */
    .viz-card{
      overflow:hidden;
      position:relative;
      min-height: 420px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .viz-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }

    .controls-inline{
      display:flex;
      gap:12px;
      align-items:center;
    }

    .speed{
      display:flex;
      gap:8px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    input[type="range"]{ width:140px; }

    .visualization{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      padding: 18px;
      border-radius: 12px;
      position:relative;
      height:320px;
      display:block;
      border: 1px solid rgba(255,255,255,0.02);
    }

    .array-area{
      position:relative;
      height:100%;
      width:100%;
      margin:0;
      user-select:none;
      display:block;
    }

    .bar {
      position:absolute;
      bottom: 18px;
      width: 48px;
      border-radius: 8px;
      background: linear-gradient(180deg,#3777ff,#2458cc);
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color:#fff;
      font-weight:700;
      transition: left var(--transition), height var(--transition), transform var(--transition), background-color var(--transition), opacity var(--transition);
      box-shadow: 0 6px 14px rgba(7,12,23,0.6);
      padding-bottom:8px;
    }
    .bar.small{ width:40px; border-radius:6px; font-size:12px; padding-bottom:6px; }
    .bar .val {
      pointer-events:none;
      font-size:13px;
    }

    .bar.pivot { background: linear-gradient(180deg,#ffb36b,#ff8a3b); box-shadow: 0 8px 20px rgba(255,122,89,0.12); }
    .bar.compare { outline: 3px solid rgba(255,255,255,0.06); transform: translateY(-8px) scale(1.02); }
    .bar.sorted { background: linear-gradient(180deg,#33d17a,#16a34a); box-shadow: 0 8px 20px rgba(22,163,74,0.08); }
    .bar.swap { background: linear-gradient(180deg,#7cd3ff,#2b9bff); }

    .legend{
      display:flex;
      gap:12px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .legend .item{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .chip{ width:14px; height:14px; border-radius:4px; }

    /* Right panel code & stack */
    .code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size: 13px;
      background: rgba(255,255,255,0.02);
      padding: 12px;
      border-radius: 12px;
      line-height:1.5;
      color:#cfe4ff;
      min-height: 220px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .line { padding:4px 8px; border-radius:8px; display:block; }
    .line.active { background: rgba(43,124,255,0.08); color: #eaf4ff; border-left: 3px solid var(--accent); }

    .stack{
      margin-top:12px;
      background: rgba(255,255,255,0.01);
      padding:10px;
      border-radius:8px;
      color:var(--muted);
      font-size:13px;
    }
    .stack .range{
      background: rgba(255,255,255,0.02);
      padding:6px 8px;
      border-radius:8px;
      margin-bottom:8px;
      display:flex;
      justify-content:space-between;
      align-items:center;
    }

    .explain{
      margin-top:12px;
      color:var(--muted);
      font-size:13px;
      min-height:48px;
    }

    /* Responsive */
    @media (max-width: 1000px){
      .container{ grid-template-columns: 1fr; }
      header{ flex-direction:column; align-items:flex-start; gap:8px; }
    }
  </style>
</head>
<body>
  <div class="safe" role="main">
    <header>
      <div>
        <h1>Quick Sort — Interactive Explorer</h1>
        <div class="subtitle">Step through partitioning, choose pivot strategies, and watch recursive ranges resolve.</div>
      </div>
      <div style="margin-left:auto; text-align:right">
        <div class="subtitle">Safe margins: 24px • Spacing ≥ 16px • Accessible controls</div>
      </div>
    </header>

    <div class="container" aria-live="polite">
      <!-- Left: Info & Controls -->
      <div class="card" aria-label="Controls">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <strong>Quick Sort Module</strong>
            <div class="small">One concept: Quick Sort (Lomuto partition visualized)</div>
          </div>
          <div style="font-size:12px;color:var(--muted)">Interactive</div>
        </div>

        <hr style="border:none;height:1px;background:rgba(255,255,255,0.02);margin:12px 0">

        <div class="controls">
          <div>
            <label for="arrayInput">Array (comma-separated numbers)</label>
            <input id="arrayInput" type="text" aria-label="Array input" value="7,2,1,6,8,5,3,4" />
            <div style="margin-top:8px" class="row">
              <button id="updateBtn" class="btn">Update Array</button>
              <button id="shuffleBtn" class="btn secondary">Shuffle</button>
              <button id="randomBtn" class="btn secondary">Random</button>
            </div>
          </div>

          <div>
            <label>Pivot selection</label>
            <div class="toggles" role="tablist" aria-label="Pivot selection">
              <button class="option active" data-pivot="last">Last</button>
              <button class="option" data-pivot="first">First</button>
              <button class="option" data-pivot="random">Random</button>
              <button class="option" data-pivot="median">Median-of-3</button>
              <button class="option" data-pivot="manual">Manual</button>
            </div>
            <div class="small" style="margin-top:8px">Manual: click a bar to set pivot for current range.</div>
          </div>

          <div>
            <label>Controls</label>
            <div class="row">
              <button id="stepBtn" class="btn">Step</button>
              <button id="playBtn" class="btn secondary">Play</button>
              <button id="runBtn" class="btn">Run to End</button>
              <button id="resetBtn" class="btn secondary">Reset</button>
            </div>
            <div style="margin-top:8px" class="row">
              <div class="speed">
                <span class="small">Speed</span>
                <input id="speed" type="range" min="50" max="1200" value="450" />
              </div>
              <div class="small" style="margin-left:8px">Delay (ms)</div>
            </div>
          </div>

          <div>
            <label>Learning objective</label>
            <div class="small">Understand how Quick Sort partitions around a pivot, how comparisons and swaps place the pivot in final position, and how recursive subproblems resolve.</div>
          </div>

          <div>
            <label>Interaction design (summary)</label>
            <div class="small">Users update the array, select a pivot strategy, then step through or play the algorithm. Visual bars animate comparisons and swaps; pseudo-code and recursion stack update to reinforce mapping between code and action.</div>
          </div>
        </div>
      </div>

      <!-- Center: Visualization -->
      <div class="viz-card card" aria-label="Visualization area">
        <div class="viz-top">
          <div style="display:flex;flex-direction:column">
            <div style="font-weight:600">Array visualization</div>
            <div class="small">Bars represent array values. Watch pivot (orange), compares (lifted), swaps (blue), and sorted positions (green).</div>
          </div>

          <div style="display:flex;flex-direction:column;align-items:flex-end;gap:6px">
            <div class="legend" aria-hidden="true">
              <div class="item"><div class="chip" style="background:#ffb36b"></div><div class="small">Pivot</div></div>
              <div class="item"><div class="chip" style="background:#7cd3ff"></div><div class="small">Swap</div></div>
              <div class="item"><div class="chip" style="background:#33d17a"></div><div class="small">Placed/Sorted</div></div>
            </div>
            <div class="small">Range stack and pseudo-code to the right map algorithm progress.</div>
          </div>
        </div>

        <div class="visualization" id="visualization" role="application" aria-label="Quick sort visualization">
          <div class="array-area" id="arrayArea"></div>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:6px;">
          <div class="explain" id="explain">Ready. Load or shuffle an array and press Step.</div>
          <div style="font-size:12px;color:var(--muted)">Elements: <span id="count">8</span></div>
        </div>
      </div>

      <!-- Right: Pseudocode & Stack -->
      <div class="card" aria-label="Pseudocode and stack">
        <div style="font-weight:600">Pseudocode (Lomuto partition)</div>

        <div class="code" id="codeArea" tabindex="0" aria-label="Pseudocode">
          <div class="line" data-line="1">quicksort(arr, low, high)</div>
          <div class="line" data-line="2">  if low &lt; high</div>
          <div class="line" data-line="3">    p = partition(arr, low, high)</div>
          <div class="line" data-line="4">    quicksort(arr, low, p - 1)</div>
          <div class="line" data-line="5">    quicksort(arr, p + 1, high)</div>
          <hr style="border:none;height:1px;background:rgba(255,255,255,0.02);margin:8px 0">
          <div class="line" data-line="10">partition(arr, low, high)</div>
          <div class="line" data-line="11">  pivot = arr[high]</div>
          <div class="line" data-line="12">  i = low</div>
          <div class="line" data-line="13">  for j = low to high-1</div>
          <div class="line" data-line="14">    if arr[j] &lt; pivot</div>
          <div class="line" data-line="15">      swap arr[i], arr[j]</div>
          <div class="line" data-line="16">      i = i + 1</div>
          <div class="line" data-line="17">  swap arr[i], arr[high]</div>
          <div class="line" data-line="18">  return i</div>
        </div>

        <div class="stack" aria-live="polite" aria-atomic="true">
          <div style="font-weight:600;margin-bottom:6px">Range stack (next to sort)</div>
          <div id="stackList">
            <!-- dynamic -->
          </div>
        </div>

        <div style="margin-top:12px" class="small">
          Layout description: Controls (left), visualization (center), code/stack (right). Safe margins 24px; interactive elements spaced ≥16px. Responsive: stacks vertically on narrow screens.
        </div>
      </div>
    </div>
  </div>

  <script>
    // Quick Sort Interactive Module (vanilla JS)
    (function(){
      // Utilities
      function $(sel){ return document.querySelector(sel); }
      function $all(sel){ return Array.from(document.querySelectorAll(sel)); }

      // DOM refs
      const arrayInput = $('#arrayInput');
      const updateBtn = $('#updateBtn');
      const shuffleBtn = $('#shuffleBtn');
      const randomBtn = $('#randomBtn');
      const stepBtn = $('#stepBtn');
      const playBtn = $('#playBtn');
      const runBtn = $('#runBtn');
      const resetBtn = $('#resetBtn');
      const speedInput = $('#speed');
      const pivotOptions = $all('.option');
      const arrayArea = $('#arrayArea');
      const explain = $('#explain');
      const countLabel = $('#count');
      const stackList = $('#stackList');
      const codeLines = $all('.line');

      // State
      let baseArray = [];
      let items = []; // {value, id, index}
      let positions = []; // left positions
      let barWidth = 56;
      let vizRect;
      let generator = null;
      let playing = false;
      let playTimer = null;
      let currentStep = null;
      let pivotMode = 'last';
      let manualPivotIdx = null;
      let speed = parseInt(speedInput.value,10);
      let sortedIndices = new Set();

      // Initialize
      function initFromInput(){
        const txt = arrayInput.value.trim();
        let arr;
        if(!txt){
          arr = [5,4,3,2,1];
        } else {
          arr = txt.split(',').map(s=>s.trim()).filter(Boolean).map(Number).filter(n=>!Number.isNaN(n));
        }
        baseArray = arr.slice(0, 24); // cap length
        setupArray(baseArray);
      }

      function setupArray(arr){
        stopPlay();
        generator = null;
        playing = false;
        manualPivotIdx = null;
        sortedIndices.clear();
        items = arr.map((v,i)=>({value: v, id: Math.random().toString(36).slice(2,9), index: i}));
        renderArray();
        countLabel.textContent = items.length;
        explain.textContent = 'Array loaded. Choose pivot mode and press Step to start.';
        updateStack([]);
        highlightCode(null);
      }

      function renderArray(){
        arrayArea.innerHTML = '';
        vizRect = arrayArea.getBoundingClientRect();
        const n = items.length;
        const areaW = arrayArea.clientWidth || (window.innerWidth - 200);
        // compute bar width responsively
        let maxBarW = 72;
        let minBarW = 34;
        barWidth = Math.max(minBarW, Math.min(maxBarW, Math.floor((areaW - 20) / n) - 8));
        const gap = 12;
        // heights based on values scaled
        const values = items.map(it=>it.value);
        const maxV = Math.max(1, ...values.map(Math.abs));
        const minV = Math.min(...values);
        const availableH = arrayArea.clientHeight - 36;
        items.forEach((it, idx)=>{
          it.index = idx;
        });
        items.forEach((it, idx)=>{
          const el = document.createElement('div');
          el.className = 'bar';
          if(items.length > 12) el.classList.add('small');
          el.setAttribute('data-id', it.id);
          el.setAttribute('tabindex', 0);
          el.setAttribute('role', 'button');
          el.setAttribute('aria-label', 'Value ' + it.value);
          const h = Math.max(18, Math.round((Math.abs(it.value)/maxV) * (availableH - 20))) + 24;
          el.style.height = h + 'px';
          const left = idx * (barWidth + 8) + 12;
          el.style.left = left + 'px';
          el.style.width = barWidth + 'px';
          el.style.transition = 'left ' + (speed*0.6) + 'ms cubic-bezier(.2,.9,.3,1), height 240ms';
          el.innerHTML = '<div class="val">' + it.value + '</div>';
          el.addEventListener('click', ()=> onBarClick(idx));
          arrayArea.appendChild(el);
        });
        // store base positions
      }

      function onBarClick(idx){
        if(pivotMode === 'manual' && currentStep && currentStep.type === 'choosePivot' && currentStep.range){
          const [low, high] = currentStep.range;
          if(idx >= low && idx <= high){
            manualPivotIdx = idx;
            explain.textContent = 'Manual pivot selected at index ' + idx + ' (value ' + items[idx].value + '). Press Step.';
          } else {
            explain.textContent = 'Click must be inside current partition range ['+low+','+high+'].';
          }
        }
      }

      // Pivot option buttons
      pivotOptions.forEach(btn=>{
        btn.addEventListener('click', ()=>{
          pivotOptions.forEach(b=>b.classList.remove('active'));
          btn.classList.add('active');
          pivotMode = btn.dataset.pivot;
          explain.textContent = 'Pivot mode: ' + pivotMode + '.';
        });
      });

      // Generate steps via iterative simulation (Lomuto)
      function* quickSortGenerator(arr){
        // arr is array of values
        // use stack of ranges to simulate recursion
        const stack = [];
        stack.push([0, arr.length - 1]);
        updateStack(stack.slice().reverse());
        while(stack.length){
          const range = stack.pop();
          const [low, high] = range;
          // yield stack update
          yield {type:'popRange', range: [low,high], stack: stack.slice().reverse()};
          if(low < high){
            // choose pivot index based on mode
            yield {type:'choosePivot', range:[low,high]};
            let pivotIdx = high; // default last
            if(pivotMode === 'first') pivotIdx = low;
            else if(pivotMode === 'random') pivotIdx = Math.floor(Math.random()*(high-low+1))+low;
            else if(pivotMode === 'median'){
              const a = arr[low], b = arr[Math.floor((low+high)/2)], c = arr[high];
              const vals = [[a,low],[b,Math.floor((low+high)/2)],[c,high]];
              vals.sort((x,y)=>x[0]-y[0]);
              pivotIdx = vals[1][1];
            } else if(pivotMode === 'manual'){
              // wait for manualPivotIdx to be set externally
              yield {type:'awaitManual', range:[low,high]};
              // external code will set manualPivotIdx variable and then continue
              // yield until manualPivotIdx is set
              while(manualPivotIdx === null || manualPivotIdx < low || manualPivotIdx > high){
                yield {type:'waitingManual', range:[low,high]};
              }
              pivotIdx = manualPivotIdx;
              manualPivotIdx = null;
            }
            yield {type:'pivotChosen', pivotIdx, range:[low,high]};

            // Move pivot to end (swap pivotIdx and high)
            if(pivotIdx !== high){
              yield {type:'swap', a: pivotIdx, b: high, values:[arr[pivotIdx], arr[high]], range:[low,high]};
              const tmp = arr[pivotIdx]; arr[pivotIdx] = arr[high]; arr[high] = tmp;
            }

            // Lomuto partition
            const pivot = arr[high];
            let i = low;
            yield {type:'setI', i, pivot, range:[low,high]};
            for(let j = low; j <= high - 1; j++){
              yield {type:'compare', j, pivot, range:[low,high]};
              if(arr[j] < pivot){
                yield {type:'swap', a: i, b: j, values:[arr[i],arr[j]], range:[low,high]};
                const tmp = arr[i]; arr[i]=arr[j]; arr[j]=tmp;
                i++;
                yield {type:'updateI', i, range:[low,high]};
              }
            }
            // place pivot at i
            yield {type:'swap', a: i, b: high, values:[arr[i],arr[high]], range:[low,high]};
            const tmp2 = arr[i]; arr[i] = arr[high]; arr[high] = tmp2;
            yield {type:'partitionDone', p: i, range:[low,high]};

            // push right and left ranges (so left is processed first we push right then left)
            stack.push([i+1, high]);
            yield {type:'pushRange', range:[i+1,high], stack: stack.slice().reverse()};
            stack.push([low, i-1]);
            yield {type:'pushRange', range:[low,i-1], stack: stack.slice().reverse()};
            updateStack(stack.slice().reverse());
          } else {
            // single element or invalid
            if(low === high){
              yield {type:'markSorted', idx: low, range:[low,high]};
            }
          }
          updateStack(stack.slice().reverse());
        }
        yield {type:'done'};
      }

      // Visual update helpers
      function queryBarByIdx(idx){
        return arrayArea.querySelectorAll('.bar')[idx];
      }
      function highlightCode(line){
        codeLines.forEach(l=>l.classList.toggle('active', Number(l.dataset.line) === line));
      }

      function updateStack(stack){
        stackList.innerHTML = '';
        if(!stack || stack.length===0){
          stackList.innerHTML = '<div class="small" style="color:var(--muted)">Stack empty (done or ready)</div>';
          return;
        }
        stack.forEach(r=>{
          const el = document.createElement('div');
          el.className = 'range';
          el.textContent = '['+r[0]+', '+r[1]+']';
          stackList.appendChild(el);
        });
      }

      // Perform a single step from generator
      function stepOnce(){
        if(!generator){
          // create a copy of array values for algorithm simulation
          const arr = items.map(it=>it.value);
          generator = quickSortGenerator(arr);
        }
        const res = generator.next();
        if(res.done){
          explain.textContent = 'Complete.';
          highlightCode(null);
          updateStack([]);
          generator = null;
          stopPlay();
          return;
        }
        const step = res.value;
        currentStep = step;
        handleStep(step);
      }

      // Animate swap between two indices
      function animateSwap(a,b, fast=false){
        const bars = arrayArea.querySelectorAll('.bar');
        const barA = bars[a];
        const barB = bars[b];
        if(!barA || !barB) return;
        // mark
        barA.classList.add('swap');
        barB.classList.add('swap');

        // compute left positions
        const leftA = parseFloat(barA.style.left);
        const leftB = parseFloat(barB.style.left);
        // swap lefts
        barA.style.left = leftB + 'px';
        barB.style.left = leftA + 'px';

        // swap DOM order to keep index mapping stable for queries
        const parent = arrayArea;
        if(a < b){
          parent.insertBefore(barB, barA);
          // then insert barA where barB was
          // (insertBefore handles)
        } else {
          parent.insertBefore(barA, barB);
        }

        return new Promise(resolve=>{
          setTimeout(()=>{
            barA.classList.remove('swap');
            barB.classList.remove('swap');
            // also swap items array entries
            const tmp = items[a];
            items[a] = items[b];
            items[b] = tmp;
            resolve();
          }, fast ? 160 : Math.max(220, speed * 0.6));
        });
      }

      function handleStep(step){
        // clear transient styles
        clearTransient();
        switch(step.type){
          case 'popRange':
            explain.textContent = 'Popped range ['+step.range[0]+','+step.range[1]+'] from stack.';
            updateStack(step.stack);
            highlightCode(2);
            break;
          case 'choosePivot':
            explain.textContent = 'Choosing pivot for range ['+step.range[0]+','+step.range[1]+'].';
            highlightRange(step.range);
            highlightCode(11);
            break;
          case 'awaitManual':
            explain.textContent = 'Awaiting manual pivot selection inside range ['+step.range[0]+','+step.range[1]+'] — click a bar.';
            highlightRange(step.range);
            highlightCode(11);
            break;
          case 'waitingManual':
            explain.textContent = 'Still waiting for manual pivot. Click an element inside the range.';
            highlightRange(step.range);
            highlightCode(11);
            break;
          case 'pivotChosen':
            explain.textContent = 'Pivot chosen at index '+step.pivotIdx+' value '+items[step.pivotIdx].value;
            highlightBar(step.pivotIdx, 'pivot');
            highlightCode(11);
            break;
          case 'swap':
            explain.textContent = 'Swapping indices ' + step.a + ' and ' + step.b + ' (' + step.values[0] + ' ↔ ' + step.values[1] + ').';
            // animate: swap in items array visually
            highlightCode(15);
            animateSwap(step.a, step.b).then(()=>{
              // After swap, we continue when Play is active or user presses Step
            });
            break;
          case 'setI':
            explain.textContent = 'Set i = ' + step.i + '. Pivot value = ' + step.pivot;
            highlightCode(12);
            break;
          case 'compare':
            explain.textContent = 'Compare index ' + step.j + ' value ' + items[step.j].value + ' with pivot ' + step.pivot + '.';
            highlightBar(step.j, 'compare');
            highlightCode(14);
            break;
          case 'updateI':
            explain.textContent = 'Increment i → ' + step.i;
            highlightCode(16);
            break;
          case 'partitionDone':
            explain.textContent = 'Partition complete. Pivot placed at index ' + step.p + '.';
            highlightBar(step.p, 'sorted');
            highlightCode(17);
            sortedIndices.add(step.p);
            break;
          case 'pushRange':
            explain.textContent = 'Pushed range ['+step.range[0]+','+step.range[1]+'] onto stack.';
            updateStack(step.stack);
            highlightCode(4);
            break;
          case 'markSorted':
            explain.textContent = 'Single element at index ' + step.idx + ' considered sorted.';
            highlightBar(step.idx, 'sorted');
            break;
          case 'done':
            explain.textContent = 'Sorting complete! All elements placed.';
            highlightAllSorted();
            highlightCode(null);
            stopPlay();
            break;
          default:
            explain.textContent = JSON.stringify(step);
        }
      }

      function highlightRange(range){
        const [low, high] = range;
        const bars = arrayArea.querySelectorAll('.bar');
        bars.forEach((b,idx)=>{
          b.classList.toggle('compare', idx >= low && idx <= high);
          if(idx >= low && idx <= high){
            // lighten slightly
            b.style.opacity = 1;
          } else {
            b.style.opacity = 0.6;
          }
        });
      }

      function highlightBar(idx, kind){
        const bars = arrayArea.querySelectorAll('.bar');
        bars.forEach(b=>b.classList.remove('pivot','compare','sorted'));
        if(typeof idx === 'number'){
          const b = bars[idx];
          if(b) b.classList.add(kind);
        }
      }

      function highlightAllSorted(){
        const bars = arrayArea.querySelectorAll('.bar');
        bars.forEach(b=>{
          b.classList.remove('compare','pivot');
          b.classList.add('sorted');
          b.style.opacity = 1;
        });
      }

      function clearTransient(){
        const bars = arrayArea.querySelectorAll('.bar');
        bars.forEach(b=>{
          b.classList.remove('compare');
        });
      }

      // Control actions
      updateBtn.addEventListener('click', ()=>{
        initFromInput();
      });
      randomBtn.addEventListener('click', ()=>{
        const n = Math.floor(Math.random()*9)+6;
        const arr = [];
        for(let i=0;i<n;i++) arr.push(Math.floor(Math.random()*90)-10);
        arrayInput.value = arr.join(',');
        initFromInput();
      });
      shuffleBtn.addEventListener('click', ()=>{
        if(items.length === 0) return;
        // Fisher-Yates on items array, then rerender with same values
        for(let i=items.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          const tmp = items[i].value; items[i].value = items[j].value; items[j].value = tmp;
        }
        // update DOM labels and heights
        const bars = arrayArea.querySelectorAll('.bar');
        const values = items.map(it=>it.value);
        const maxV = Math.max(1, ...values.map(Math.abs));
        const availableH = arrayArea.clientHeight - 36;
        bars.forEach((b,idx)=>{
          const h = Math.max(18, Math.round((Math.abs(items[idx].value)/maxV) * (availableH - 20))) + 24;
          b.style.height = h + 'px';
          b.querySelector('.val').textContent = items[idx].value;
        });
        explain.textContent = 'Array shuffled.';
      });

      resetBtn.addEventListener('click', ()=>{
        initFromInput();
      });

      stepBtn.addEventListener('click', ()=>{
        if(playing){
          stopPlay();
        }
        stepOnce();
      });

      function playLoop(){
        if(!generator) stepOnce(); // initializes generator
        stepOnce();
        if(playing){
          playTimer = setTimeout(playLoop, speed);
        }
      }

      playBtn.addEventListener('click', ()=>{
        if(!playing){
          playing = true;
          playBtn.classList.add('active');
          playBtn.textContent = 'Pause';
          playLoop();
        } else {
          stopPlay();
        }
      });

      runBtn.addEventListener('click', ()=>{
        if(!generator) stepOnce();
        // run until done
        const runUntilDone = () => {
          const next = generator.next();
          if(next.done){
            explain.textContent = 'Complete.';
            highlightAllSorted();
            generator = null;
            return;
          }
          handleStep(next.value);
          setTimeout(runUntilDone, Math.max(30, speed*0.2));
        };
        runUntilDone();
      });

      speedInput.addEventListener('input', (e)=>{
        speed = parseInt(e.target.value,10);
      });

      function stopPlay(){
        playing = false;
        playBtn.classList.remove('active');
        playBtn.textContent = 'Play';
        if(playTimer) clearTimeout(playTimer);
        playTimer = null;
      }

      // keyboard accessibility
      document.addEventListener('keydown', (e)=>{
        if(e.code === 'Space'){
          e.preventDefault();
          stepBtn.click();
        } else if(e.key === 'p'){
          playBtn.click();
        }
      });

      // Initialize on load
      initFromInput();

      // Resize handling: reposition bars based on new width
      window.addEventListener('resize', ()=>{
        if(items.length === 0) return;
        // recompute left positions
        const bars = arrayArea.querySelectorAll('.bar');
        const areaW = arrayArea.clientWidth;
        let maxBarW = 72;
        let minBarW = 34;
        barWidth = Math.max(minBarW, Math.min(maxBarW, Math.floor((areaW - 20) / items.length) - 8));
        bars.forEach((b,idx)=>{
          const left = idx * (barWidth + 8) + 12;
          b.style.width = barWidth + 'px';
          b.style.left = left + 'px';
        });
      });

      // Ensure announcements are polite for screen readers
      const live = document.createElement('div');
      live.setAttribute('aria-live','polite');
      live.style.position = 'absolute';
      live.style.left = '-9999px';
      document.body.appendChild(live);
    })();
  </script>
</body>
</html>