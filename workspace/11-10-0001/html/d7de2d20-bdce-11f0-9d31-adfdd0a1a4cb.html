<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Radix Sort — Interactive Module</title>
  <style>
    :root{
      --safe:24px;
      --gap:16px;
      --bg:#0f1724;
      --card:#0b1220;
      --muted:#98a0b3;
      --accent:#6ee7b7;
      --accent-2:#60a5fa;
      --tile:#111827;
      --tile-border:#233044;
      --success:#16a34a;
      --danger:#ef4444;
      --glass: rgba(255,255,255,0.03);
      --radius:10px;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    /* Safe area margins */
    html,body{height:100%}
    body{
      margin:0;
      padding:var(--safe);
      background:linear-gradient(180deg,#021028 0%, #071428 60%);
      color:#e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      box-sizing:border-box;
      min-height:100%;
    }
    *,*:before,*:after{box-sizing:inherit}

    /* Layout container */
    .module {
      display:grid;
      grid-template-columns: 380px 1fr;
      gap:var(--gap);
      align-items:start;
      max-width:1400px;
      margin:0 auto;
    }
    @media (max-width:900px){
      .module{grid-template-columns:1fr; padding-bottom:40px}
    }

    /* Left column (info + controls) */
    .panel {
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:20px;
      border-radius:var(--radius);
      min-height:220px;
      border:1px solid rgba(255,255,255,0.03);
    }
    h1{
      margin:0 0 8px 0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    p.lead{
      margin:0 0 12px 0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    .section-title{margin-top:10px;margin-bottom:8px;font-weight:600;font-size:13px;color:#cfe7ff;}

    .controls{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    label.small{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}

    /* inputs */
    .row{
      display:flex;
      gap:12px;
      align-items:center;
    }
    input[type="text"], input[type="number"], select{
      background:var(--glass);
      border:1px solid rgba(255,255,255,0.03);
      color:inherit;
      padding:8px 10px;
      border-radius:8px;
      outline:none;
      font-size:13px;
      width:100%;
    }
    input[type="range"]{
      width:100%;
    }
    .small-btn{
      background:#0b1220;
      border:1px solid rgba(255,255,255,0.03);
      color:var(--accent-2);
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
    }
    .small-btn:focus{outline:2px solid rgba(96,165,250,0.25)}
    .danger{color:var(--danger); border-color:rgba(239,68,68,0.15)}
    .muted{color:var(--muted); font-size:13px}

    /* main visual area */
    .visual {
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--radius);
      padding:20px;
      border:1px solid rgba(255,255,255,0.03);
      min-height:480px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .status{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .badge{
      background:rgba(255,255,255,0.03);
      padding:8px 12px;
      border-radius:999px;
      font-weight:600;
      font-size:13px;
      color:var(--muted);
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .badge .num{color:var(--accent-2); font-weight:700}

    /* canvas area for tiles and buckets */
    .canvas {
      position:relative;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.0));
      border-radius:10px;
      padding:20px;
      height:370px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .array-row{
      position:relative;
      height:72px;
      border-radius:8px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border:1px dashed rgba(255,255,255,0.03);
      display:flex;
      align-items:center;
      padding:12px;
      gap:12px;
    }

    /* tile */
    .tile{
      min-width:56px;
      height:48px;
      background:linear-gradient(180deg,#0b1224,#071428);
      border-radius:10px;
      border:1px solid var(--tile-border);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      color:#eaf5ff;
      font-size:15px;
      box-shadow:0 6px 18px rgba(2,6,23,0.6);
      position:absolute;
      left:0;
      top:0;
      transition:transform 400ms cubic-bezier(.2,.9,.2,1), box-shadow 200ms;
      padding:6px;
      text-align:center;
      line-height:1;
    }
    .tile:focus{outline:3px solid rgba(96,165,250,0.18)}
    .digit{
      display:block;
      color:var(--muted);
      font-size:11px;
      font-weight:600;
      margin-top:6px;
    }

    /* bucket area */
    .buckets {
      flex:1;
      display:flex;
      gap:8px;
      align-items:flex-start;
      padding-top:6px;
    }
    .bucket {
      flex:1;
      min-width:48px;
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.02);
      border-radius:8px;
      padding:8px;
      height:200px;
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:center;
      position:relative;
    }
    .bucket-label{
      position:absolute;
      top:8px;
      left:8px;
      background:rgba(0,0,0,0.25);
      padding:4px 6px;
      border-radius:6px;
      font-weight:700;
      color:var(--muted);
      font-size:12px;
    }
    .bucket-queue{
      margin-top:32px;
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:center;
    }

    .hint{
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    .controls-row{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }

    /* small helpers */
    .muted-block{color:var(--muted); font-size:13px}
    .error{color:var(--danger); font-weight:700;margin-top:6px}
    footer{margin-top:12px;color:var(--muted);font-size:12px}

    /* Responsive adjustments */
    @media (max-width:500px){
      .tile{min-width:48px;height:42px;font-size:13px}
      .array-row{height:62px;padding:8px}
    }
  </style>
</head>
<body>
  <div class="module" role="main" aria-label="Radix Sort interactive module">
    <!-- Left panel: explanation and controls -->
    <aside class="panel" aria-labelledby="title">
      <h1 id="title">Radix Sort (LSD) — Interactive</h1>
      <p class="lead">Explore least-significant-digit (LSD) Radix Sort for non-negative integers. Visualize distribution by digit (buckets) and how stable collecting produces a fully sorted list.</p>

      <div class="section-title">Learning Objective</div>
      <p class="muted">After interacting with this module you will be able to:</p>
      <ul class="muted" style="margin:8px 0 0 18px; padding:0; line-height:1.4">
        <li>See how numbers are grouped by digits (least significant to most).</li>
        <li>Understand why stability of each pass is essential.</li>
        <li>Observe how multiple passes produce a sorted list without direct comparisons.</li>
      </ul>

      <div class="section-title" style="margin-top:18px">Interaction Design</div>
      <p class="muted" style="margin-top:0">
        Controls let you enter a custom list or randomize it, choose base (radix), step through each distribution/collection phase, or autoplay. Each number is a movable tile:
      </p>
      <ul class="muted" style="margin:8px 0 0 18px">
        <li>Apply: parse numbers (non-negative integers). Errors display immediately.</li>
        <li>Step: advance one animation step — either place next item into its bucket or collect next item back into the array.</li>
        <li>Play/Pause: animate full passes sequentially; speed slider adjusts timing.</li>
        <li>Randomize / Reset: generate a small array or restore original input.</li>
      </ul>

      <div class="section-title" style="margin-top:18px">Layout Description</div>
      <p class="muted" style="margin-top:0">
        Two-column layout: left column contains descriptions and controls; right column is the visualization canvas. Safe margin of 24px on all sides and 16px minimum spacing between controls. The canvas shows:
      </p>
      <ul class="muted" style="margin:8px 0 0 18px">
        <li>Top row: current array as movable tiles.</li>
        <li>Lower: equally spaced buckets labeled 0…(base-1).</li>
        <li>Status bar: current pass and phase, accessible badges and hints.</li>
      </ul>

      <div style="height:18px"></div>

      <!-- Controls -->
      <div class="controls" aria-label="Controls">
        <div>
          <label class="small" for="inputArray">Array (comma or space separated)</label>
          <div style="display:flex;gap:8px">
            <input id="inputArray" type="text" placeholder="e.g. 170, 45, 75, 90, 802, 24, 2, 66" aria-label="Array input" />
            <button id="applyBtn" class="small-btn" aria-label="Apply array">Apply</button>
          </div>
          <div class="muted" style="margin-top:8px">Only non-negative integers. Max 12 elements recommended for clarity.</div>
        </div>

        <div style="display:flex;gap:12px;align-items:center">
          <div style="flex:1">
            <label class="small" for="base">Base (radix)</label>
            <input id="base" type="number" min="2" max="16" value="10" aria-label="Radix base" />
          </div>
          <div style="width:120px">
            <label class="small" for="speed">Speed</label>
            <input id="speed" type="range" min="200" max="1800" step="100" value="800" aria-label="Animation speed" />
            <div class="muted" style="font-size:12px;margin-top:6px">Lower is faster</div>
          </div>
        </div>

        <div class="controls-row">
          <button id="stepBtn" class="small-btn" aria-label="Step one action">Step</button>
          <button id="playBtn" class="small-btn" aria-label="Play or pause">Play</button>
          <button id="resetBtn" class="small-btn" aria-label="Reset to original">Reset</button>
          <button id="randBtn" class="small-btn" aria-label="Randomize array">Randomize</button>
        </div>

        <div>
          <div class="muted-block" id="statusText" aria-live="polite" style="margin-bottom:6px">Status: Idle</div>
          <div id="error" class="error" role="alert" style="display:none"></div>
        </div>
      </div>

      <footer>
        Tip: Try base 2 (binary) to see many passes; base 16 reduces passes but increases bucket count — both illustrate the same stable-digit grouping idea.
      </footer>
    </aside>

    <!-- Right panel: visualization -->
    <main class="visual" aria-labelledby="vis-title">
      <div class="status" role="status" aria-live="polite">
        <div class="badge">Pass <span class="num" id="passNum">0</span></div>
        <div class="badge">Phase <span class="num" id="phaseText">Idle</span></div>
        <div class="badge">Base <span class="num" id="baseDisplay">10</span></div>
        <div class="muted" style="margin-left:auto" id="stabilityHint">Stable order preserved each pass</div>
      </div>

      <div class="canvas" id="canvas" tabindex="0">
        <div class="array-row" id="arrayRow" aria-label="Current array">
          <!-- tiles will be absolutely positioned inside canvas; arrayRow used to compute coordinates -->
        </div>

        <div class="buckets" id="buckets" aria-label="Buckets area">
          <!-- bucket columns generated dynamically -->
        </div>

        <div class="hint" id="explain">
          Interactive steps: Distribute numbers into buckets according to the current digit (least significant first). Then collect buckets from lowest to highest, preserving the order inside each bucket (stability). Repeat for next more significant digit until no further digits remain.
        </div>
      </div>
    </main>
  </div>

  <script>
    /* Radix Sort Interactive Module (vanilla JS)
       - Implements LSD Radix Sort for non-negative integers
       - Animates tiles moving to buckets and back to the array
       - Supports stepping and autoplay
    */

    (function(){
      // DOM elements
      const input = document.getElementById('inputArray');
      const baseInput = document.getElementById('base');
      const applyBtn = document.getElementById('applyBtn');
      const stepBtn = document.getElementById('stepBtn');
      const playBtn = document.getElementById('playBtn');
      const resetBtn = document.getElementById('resetBtn');
      const randBtn = document.getElementById('randBtn');
      const speedSlider = document.getElementById('speed');
      const errorEl = document.getElementById('error');
      const statusText = document.getElementById('statusText');
      const passNumEl = document.getElementById('passNum');
      const phaseTextEl = document.getElementById('phaseText');
      const baseDisplay = document.getElementById('baseDisplay');
      const canvas = document.getElementById('canvas');
      const arrayRow = document.getElementById('arrayRow');
      const bucketsEl = document.getElementById('buckets');
      const explain = document.getElementById('explain');

      // State
      let originalArray = [170,45,75,90,802,24,2,66];
      let array = [];
      let tiles = []; // tile objects {value, el}
      let base = 10;
      let maxDigits = 0;
      let pass = 0; // current digit index (0 = least significant)
      let phase = 'idle'; // 'idle'|'distributing'|'collecting'
      let buckets = []; // arrays of tile indices
      let playing = false;
      let timer = null;
      let speed = 800; // ms per animated move default

      // Config
      const tileWidth = 56;
      const tileHeight = 48;
      const maxElements = 12;
      const animationDuration = 400;

      // Helpers: show error or status
      function showError(msg){
        errorEl.textContent = msg;
        errorEl.style.display = msg ? 'block' : 'none';
      }
      function setStatus(s){
        statusText.textContent = 'Status: ' + s;
      }
      function setPhase(p){
        phase = p;
        phaseTextEl.textContent = p === 'idle' ? 'Idle' : (p === 'distributing' ? 'Distributing' : 'Collecting');
      }
      function setPass(n){
        pass = n;
        passNumEl.textContent = n;
      }
      function clamp(v,min,max){return Math.max(min,Math.min(max,v))}

      // Parse input into array of non-negative integers
      function parseInput(str){
        const parts = str.split(/[\s,]+/).filter(Boolean);
        if(parts.length === 0) return null;
        if(parts.length > maxElements) { showError('Limit: max ' + maxElements + ' elements.'); return null; }
        const out = [];
        for(const p of parts){
          if(!/^\d+$/.test(p)){ showError('All values must be non-negative integers.'); return null; }
          out.push(Number(p));
        }
        showError('');
        return out;
      }

      // Create bucket DOMs depending on base
      function createBuckets(b){
        bucketsEl.innerHTML = '';
        buckets = [];
        for(let i=0;i<b;i++){
          const bucket = document.createElement('div');
          bucket.className = 'bucket';
          bucket.setAttribute('aria-label','Bucket ' + i);
          const label = document.createElement('div');
          label.className = 'bucket-label';
          label.textContent = i;
          bucket.appendChild(label);
          const queue = document.createElement('div');
          queue.className = 'bucket-queue';
          bucket.appendChild(queue);
          bucketsEl.appendChild(bucket);
          buckets.push({el:bucket, queueEl:queue, items:[]});
        }
      }

      // Render initial array tiles at positions inside canvas
      function renderArray(){
        arrayRow.innerHTML = '';
        tiles = [];
        // compute start positions inside canvas (arrayRow has padding and gap; we will position tiles absolutely relative to canvas)
        const canvasRect = canvas.getBoundingClientRect();
        const rowRect = arrayRow.getBoundingClientRect();
        const startX = 12; // left padding in arrayRow
        const gap = 12;
        const elLeft = arrayRow.offsetLeft;
        const elTop = arrayRow.offsetTop;

        // For responsive placement, compute tile horizontal spacing to fit
        const available = arrayRow.clientWidth - 24; // padding both sides
        const used = Math.min(array.length, maxElements);
        const spacing = Math.max(tileWidth + gap, Math.floor(available / used) - 4);

        for(let i=0;i<array.length;i++){
          const val = array[i];
          const tile = document.createElement('div');
          tile.className = 'tile';
          tile.setAttribute('tabindex','0');
          tile.setAttribute('role','img');
          tile.setAttribute('aria-label', 'Value ' + val);
          tile.dataset.index = i;
          tile.style.width = tileWidth + 'px';
          tile.style.height = tileHeight + 'px';
          tile.style.lineHeight = tileHeight + 'px';
          tile.innerHTML = '<div style="font-size:14px;">' + val + '</div><span class="digit" aria-hidden="true"></span>';
          // initial absolute placement relative to canvas
          const x = startX + i * spacing;
          const y = arrayRow.offsetTop + (arrayRow.clientHeight - tileHeight)/2;
          // use transform so transitions are visible
          tile.style.transform = `translate(${x}px, ${y}px)`;
          canvas.appendChild(tile);
          tiles.push({value: val, el: tile, x:x, y:y});
        }
      }

      // Utility: compute digit at pass (0 = LSD) for given base
      function digitAt(value, passIdx, b){
        return Math.floor(value / Math.pow(b, passIdx)) % b;
      }

      // Prepare for sorting: compute max digits and reset pass
      function prepare(){
        base = clamp(Number(baseInput.value) || 10, 2, 16);
        baseDisplay.textContent = base;
        maxDigits = 0;
        for(const v of array){
          const digits = v === 0 ? 1 : Math.floor(Math.log(v)/Math.log(base)) + 1;
          maxDigits = Math.max(maxDigits, digits);
        }
        setPass(0);
        setPhase('idle');
        createBuckets(base);
        renderArray();
        updateDigitsOnTiles();
        setStatus('Ready — ' + array.length + ' items, ' + maxDigits + ' passes');
      }

      function updateDigitsOnTiles(){
        tiles.forEach(t=>{
          const d = digitAt(t.value, pass, base);
          const span = t.el.querySelector('.digit');
          span.textContent = 'd' + pass + ': ' + d;
        });
      }

      // Animate moving a tile to a target transform position (x,y)
      function moveTileTo(tileObj, targetX, targetY, delay=0){
        return new Promise(resolve=>{
          const el = tileObj.el;
          setTimeout(()=>{
            // apply transition then resolve after duration
            el.style.transition = `transform ${animationDuration}ms cubic-bezier(.2,.9,.2,1)`;
            el.style.transform = `translate(${targetX}px, ${targetY}px)`;
            // update stored coordinates
            tileObj.x = targetX;
            tileObj.y = targetY;
            const handler = (e)=>{
              if(e.propertyName === 'transform'){
                el.removeEventListener('transitionend', handler);
                resolve();
              }
            };
            el.addEventListener('transitionend', handler);
          }, delay);
        });
      }

      // Distribute phase: place each array tile into appropriate bucket one by one
      async function distributeStep(startIndex=0){
        setPhase('distributing');
        // clear bucket arrays
        buckets.forEach(b => b.items = []);
        for(let i=startIndex;i<tiles.length;i++){
          const t = tiles[i];
          const d = digitAt(t.value, pass, base);
          // compute target position in bucket
          const bucket = buckets[d];
          const queueLen = bucket.items.length;
          // compute bucket center x relative to canvas
          const bucketRect = bucket.el.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          // compute local x,y inside canvas for where tile should go
          const targetX = (bucketRect.left - canvasRect.left) + (bucketRect.width - tileWidth)/2;
          const targetY = bucket.el.offsetTop + 36 + queueLen * (tileHeight + 8);
          // append tile visually to canvas (it's already in canvas)
          bucket.items.push(t);
          bucket.queueEl.appendChild(t.el); // move DOM into bucket for visual stacking (keeps transform relative)
          // compute relative transform to keep same coordinates; we recompute target transform below
          // set transform relative to canvas
          const relX = (bucketRect.left - canvasRect.left) + (bucketRect.width - tileWidth)/2;
          const relY = bucket.el.offsetTop + 36 + queueLen * (tileHeight + 8);
          const delay = 0;
          // Attach digit label update
          const span = t.el.querySelector('.digit');
          if(span) span.textContent = 'd' + pass + ': ' + d;
          // move tile to bucket spot
          await moveTileTo(t, relX, relY, delay);
          // small inset shadow to show it's been placed
          t.el.style.boxShadow = '0 8px 20px rgba(2,6,23,0.6)';
          // Pause between placements depending on speed
          await sleep(Math.max(80, speed/8));
          if(!playing) {
            // if playing was turned off, we still finish step as part of this step invocation
          }
        }
      }

      // Collect phase: gather buckets from 0..base-1 preserving order
      async function collectStep(){
        setPhase('collecting');
        const canvasRect = canvas.getBoundingClientRect();
        // We'll build a new tiles array in collected order
        const newTiles = [];
        let index = 0;
        // compute spacing for final array positions
        const available = arrayRow.clientWidth - 24;
        const used = Math.max(1, tiles.length);
        const spacing = Math.max(tileWidth + 12, Math.floor(available / used) - 4);
        for(let b=0;b<buckets.length;b++){
          const bucket = buckets[b];
          for(const t of bucket.items){
            // compute target x,y back in array row
            const targetX = 12 + index * spacing;
            const targetY = arrayRow.offsetTop + (arrayRow.clientHeight - tileHeight)/2;
            // move tile back to canvas root (so z-order)
            canvas.appendChild(t.el);
            await moveTileTo(t, targetX, targetY, 0);
            // update digit label for clarity (unchanged)
            const span = t.el.querySelector('.digit');
            if(span) span.textContent = 'd' + pass + ': ' + b;
            newTiles.push(t);
            index++;
            await sleep(Math.max(80, speed/8));
          }
        }
        // reorder tiles array to new order
        tiles = newTiles;
        // update underlying array values to match collected order
        array = tiles.map(t => t.value);
        setStatus('After pass ' + pass + ': ' + array.join(', '));
      }

      // Step controller: perform either distributing or collecting for current pass and progress state
      async function stepOnce(){
        if(phase === 'idle'){
          if(pass >= maxDigits){
            setStatus('Sorting complete');
            setPhase('idle');
            return;
          }
          // start distributing
          await distributeStep(0);
          setStatus('Distributed pass ' + pass);
          // after distributing, set phase to collecting automatically
          setPhase('collecting');
        } else if(phase === 'distributing'){
          // we assume distributeStep completed in our implementation; move to collecting
          setPhase('collecting');
        }
        if(phase === 'collecting'){
          await collectStep();
          // increment pass
          setPass(pass + 1);
          updateDigitsOnTiles();
          // clear buckets
          createBuckets(base);
          // update tiles' DOM parent to canvas
          tiles.forEach((t,idx)=>{
            canvas.appendChild(t.el);
          });
          if(pass >= maxDigits){
            setPhase('idle');
            setStatus('Sorting complete');
          } else {
            setPhase('idle'); // ready to start next pass with a new step
            setStatus('Ready for next pass');
          }
        }
      }

      // Sleep helper
      function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

      // Play controller: runs steps automatically until finish or pause
      async function playLoop(){
        playing = true;
        playBtn.textContent = 'Pause';
        setStatus('Playing...');
        while(playing){
          // If sorting complete
          if(pass >= maxDigits){
            setStatus('Sorting complete');
            setPhase('idle');
            playing = false;
            playBtn.textContent = 'Play';
            break;
          }
          // Start distribute then collect for this pass
          setPhase('distributing');
          await distributeStep(0);
          await sleep(120);
          setPhase('collecting');
          await collectStep();
          setPass(pass + 1);
          updateDigitsOnTiles();
          createBuckets(base);
          tiles.forEach(t => canvas.appendChild(t.el));
          await sleep(120);
          if(pass >= maxDigits){
            setStatus('Sorting complete');
            setPhase('idle');
            playing = false;
            playBtn.textContent = 'Play';
            break;
          }
          // short pause before next pass
          await sleep(200);
        }
      }

      // UI bindings
      applyBtn.addEventListener('click', ()=>{
        const parsed = parseInput(input.value || '');
        if(!parsed) return;
        originalArray = parsed.slice();
        array = parsed.slice();
        prepare();
      });

      baseInput.addEventListener('change', ()=>{
        const b = clamp(Number(baseInput.value) || 10, 2, 16);
        baseInput.value = b;
        baseDisplay.textContent = b;
        if(array.length) prepare();
      });

      stepBtn.addEventListener('click', async ()=>{
        if(playing) return; // disable step while playing
        setStatus('Stepping...');
        await stepOnce();
      });

      playBtn.addEventListener('click', ()=>{
        if(playing){
          playing = false;
          playBtn.textContent = 'Play';
          setStatus('Paused');
        } else {
          // ensure state prepared
          if(array.length === 0){ showError('Apply an array first.'); return; }
          showError('');
          playLoop();
        }
      });

      resetBtn.addEventListener('click', ()=>{
        playing = false;
        playBtn.textContent = 'Play';
        array = originalArray.slice();
        prepare();
      });

      randBtn.addEventListener('click', ()=>{
        // generate random length 6-10
        const n = Math.floor(Math.random() * 5) + 5;
        const arr = [];
        for(let i=0;i<n;i++){
          arr.push(Math.floor(Math.random()*900) + Math.floor(Math.random()*10)); // varied distribution
        }
        originalArray = arr.slice();
        array = arr.slice();
        input.value = arr.join(', ');
        prepare();
      });

      speedSlider.addEventListener('input', ()=>{
        speed = Number(speedSlider.value);
      });

      // Keyboard shortcuts: Space = step, P = play/pause, R = reset
      document.addEventListener('keydown', (e)=>{
        if(e.code === 'Space'){ e.preventDefault(); stepBtn.click(); }
        if(e.key === 'p' || e.key === 'P'){ playBtn.click(); }
        if(e.key === 'r' || e.key === 'R'){ resetBtn.click(); }
      });

      // Initialization
      function init(){
        input.value = originalArray.join(', ');
        array = originalArray.slice();
        prepare();
      }

      // Make sure the canvas is focusable for accessibility
      canvas.setAttribute('tabindex','0');

      init();

      // Expose some actions for easier testing in dev console (optional)
      window.radixModule = {
        getState: () => ({array, pass, phase, base, tiles}),
      };

    })();
  </script>
</body>
</html>