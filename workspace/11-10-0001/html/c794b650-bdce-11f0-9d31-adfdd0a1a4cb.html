<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bubble Sort Interactive Module</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --control-height: 40px;
      --bg: #0f1724;
      --card: #0b1220;
      --text: #e6eef8;
      --muted: #9fb0c8;
      --accent: #60a5fa;
      --compare: #f6d365;
      --swap: #fb923c;
      --done: #34d399;
      --danger: #ef4444;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071025 0%, #071827 100%);
      color:var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    body{
      padding:var(--safe-padding);
      box-sizing:border-box;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      gap:var(--gap);
    }

    /* Container */
    .module {
      width:100%;
      max-width:1100px;
      display:grid;
      grid-template-columns: 1fr 380px;
      gap:var(--gap);
    }

    /* Responsive stack */
    @media (max-width:920px){
      .module{
        grid-template-columns:1fr;
      }
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      border-radius:12px;
      padding:18px;
      box-shadow: 0 6px 24px rgba(2,6,23,0.6);
    }

    header h1{
      margin:0 0 8px 0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    header p {
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    /* Visual area */
    .visual {
      min-height:340px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .array-area {
      background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.006));
      border-radius:10px;
      padding:14px;
      position:relative;
      height:240px;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    /* bars container: relative positioning for children */
    .bars {
      position:relative;
      height:100%;
      width:100%;
      max-width:100%;
      margin:0 6px;
      min-height:120px;
    }

    .bar {
      position:absolute;
      bottom:12px;
      width:48px;
      max-width:16%;
      background:linear-gradient(180deg,#1e293b,#0f1724);
      color:var(--text);
      border-radius:8px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      box-shadow: 0 4px 10px rgba(2,6,23,0.6);
      transition: transform 360ms cubic-bezier(.2,.9,.2,1), background-color 220ms, box-shadow 220ms;
      padding:6px;
      box-sizing:border-box;
      border:1px solid rgba(255,255,255,0.03);
      text-align:center;
      font-weight:600;
      outline: none;
    }
    .bar .val {
      transform: translateY(6px);
      font-size:13px;
      color:var(--text);
      text-shadow: 0 1px 0 rgba(0,0,0,0.6);
    }
    .bar.compare {
      background: linear-gradient(180deg, rgba(255,215,120,0.12), rgba(255,200,80,0.06));
      box-shadow: 0 6px 18px rgba(250,200,60,0.06), 0 0 0 3px rgba(246,211,101,0.06);
    }
    .bar.swap {
      background: linear-gradient(180deg, rgba(251,146,60,0.12), rgba(251,146,60,0.06));
      box-shadow: 0 6px 18px rgba(251,146,60,0.06), 0 0 0 3px rgba(251,146,60,0.04);
    }
    .bar.done {
      background: linear-gradient(180deg, rgba(52,211,153,0.08), rgba(52,211,153,0.04));
      box-shadow: 0 6px 18px rgba(52,211,153,0.06);
      color:#042c1e;
      font-weight:700;
    }

    /* Controls and pseudocode panel */
    .controls {
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .controls .group {
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .row {
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    label {
      font-size:13px;
      color:var(--muted);
    }
    input[type="range"]{
      width:100%;
    }
    input[type="text"]{
      background:transparent;
      border:1px solid rgba(255,255,255,0.05);
      color:var(--text);
      padding:10px;
      border-radius:8px;
      min-width:0;
    }
    .btn {
      height:var(--control-height);
      padding:0 12px;
      background:rgba(255,255,255,0.03);
      color:var(--text);
      border:1px solid rgba(255,255,255,0.04);
      border-radius:8px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-weight:600;
      transition: background 180ms, transform 120ms;
      min-width:78px;
    }
    .btn:active{ transform:translateY(1px); }
    .btn.primary {
      background: linear-gradient(90deg,var(--accent), #3b82f6);
      border: none;
      color:white;
      box-shadow: 0 6px 18px rgba(59,130,246,0.12);
    }
    .btn.ghost {
      background:transparent;
      border:1px dashed rgba(255,255,255,0.04);
    }
    .small {
      font-size:13px;
      padding:8px 10px;
      height:34px;
    }

    /* Pseudocode */
    pre.pseudo {
      background: linear-gradient(180deg, rgba(0,0,0,0.25), rgba(0,0,0,0.12));
      border-radius:8px;
      padding:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:13px;
      color:var(--muted);
      overflow:auto;
      max-height:200px;
    }
    pre.pseudo code {
      white-space:pre;
      display:block;
    }
    .line {
      padding:2px 6px;
      border-radius:6px;
      display:block;
    }
    .line.current {
      background: rgba(96,165,250,0.12);
      color:var(--text);
      box-shadow: inset 0 0 0 1px rgba(96,165,250,0.06);
    }

    /* stats */
    .stats {
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      color:var(--muted);
      font-size:13px;
    }
    .stat {
      background: rgba(255,255,255,0.02);
      padding:8px 10px;
      border-radius:8px;
      min-width:88px;
      text-align:center;
    }

    /* Footer hint */
    .hint {
      font-size:12px;
      color:var(--muted);
    }

    /* Focus */
    .bar:focus {
      outline: 2px solid rgba(96,165,250,0.26);
      outline-offset:4px;
    }
    .btn:focus, input:focus, textarea:focus {
      outline: 2px solid rgba(96,165,250,0.14);
      outline-offset:2px;
    }
  </style>
</head>
<body>
  <main class="module" aria-labelledby="title">
    <section class="card visual" aria-label="Bubble sort visualization">
      <header>
        <h1 id="title">Bubble Sort — Compare & Swap Visualization</h1>
        <p>Step through pairwise comparisons. Swapping animates; passes mark sorted items on the right.</p>
      </header>

      <div class="array-area" role="region" aria-label="Array visualization">
        <div class="bars" id="bars" aria-live="polite"></div>
      </div>

      <div style="display:flex;justify-content:space-between;align-items:center;gap:16px">
        <div class="hint">Keyboard: Space = Play/Pause • → = Step • ← = Back</div>
        <div class="stats" aria-hidden="false" id="stats">
          <div class="stat" id="stat-pass">Pass: 0</div>
          <div class="stat" id="stat-idx">Compare j: 0</div>
          <div class="stat" id="stat-comp">Comparisons: 0</div>
          <div class="stat" id="stat-swaps">Swaps: 0</div>
        </div>
      </div>
    </section>

    <aside class="card controls" aria-label="Controls and pseudocode">
      <div class="group">
        <div class="row" style="align-items:center;">
          <label for="size">Array size</label>
          <input id="size" type="range" min="2" max="20" value="8" aria-label="Array size slider">
          <div style="min-width:48px;text-align:right;color:var(--muted)" id="sizeVal">8</div>
        </div>

        <div class="row">
          <button class="btn" id="randomBtn" aria-label="Randomize array">Randomize</button>
          <button class="btn ghost" id="shuffleBtn" aria-label="Shuffle array">Shuffle</button>
          <button class="btn" id="resetBtn" aria-label="Reset array">Reset</button>
        </div>

        <div class="row" style="flex-direction:column;gap:8px">
          <label for="arrInput">Custom array (comma-separated)</label>
          <input id="arrInput" type="text" placeholder="e.g. 5,1,4,2" aria-label="Array input">
        </div>

        <div class="row" style="justify-content:flex-start;">
          <button class="btn primary" id="playBtn" aria-pressed="false">Play</button>
          <button class="btn" id="stepBtn">Step</button>
          <button class="btn" id="backBtn">Back</button>
          <button class="btn ghost" id="fastFinishBtn" title="Finish algorithm quickly">Finish</button>
        </div>

        <div class="row" style="align-items:center;">
          <label for="speed">Speed</label>
          <input id="speed" type="range" min="60" max="1200" step="10" value="420" aria-label="Animation speed">
          <div style="min-width:56px;text-align:right;color:var(--muted)" id="speedVal">420ms</div>
        </div>
      </div>

      <div class="group">
        <label>Pseudocode (highlights current step)</label>
        <pre class="pseudo" id="pseudocode" tabindex="0" aria-label="Bubble sort pseudocode">
<code>
<span class="line" data-line="1">for i from 0 to n-1:</span>
<span class="line" data-line="2">  for j from 0 to n-2-i:</span>
<span class="line" data-line="3">    if arr[j] &gt; arr[j+1]:</span>
<span class="line" data-line="4">      swap arr[j] and arr[j+1]</span>
</code>
        </pre>
      </div>

      <div class="group" style="margin-top:auto">
        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
          <div style="color:var(--muted);font-size:13px">Status</div>
          <div style="display:flex;gap:8px;">
            <div style="color:var(--muted);font-size:13px" id="statusText">Idle</div>
          </div>
        </div>
      </div>
    </aside>
  </main>

  <script>
    // Safe constants & helpers
    const MIN_BAR_WIDTH = 36; // px
    const GAP = 12; // px gap between bars visually
    const barsEl = document.getElementById('bars');
    const sizeRange = document.getElementById('size');
    const sizeVal = document.getElementById('sizeVal');
    const randomBtn = document.getElementById('randomBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const resetBtn = document.getElementById('resetBtn');
    const arrInput = document.getElementById('arrInput');
    const playBtn = document.getElementById('playBtn');
    const stepBtn = document.getElementById('stepBtn');
    const backBtn = document.getElementById('backBtn');
    const speedRange = document.getElementById('speed');
    const speedVal = document.getElementById('speedVal');
    const fastFinishBtn = document.getElementById('fastFinishBtn');

    const statPass = document.getElementById('stat-pass');
    const statIdx = document.getElementById('stat-idx');
    const statComp = document.getElementById('stat-comp');
    const statSwaps = document.getElementById('stat-swaps');
    const statusText = document.getElementById('statusText');

    const pseudocode = document.getElementById('pseudocode');
    const codeLines = Array.from(pseudocode.querySelectorAll('.line'));

    let array = [];
    let initialArray = [];
    let positions = []; // computed left positions for each index
    let nodeOrder = []; // mapping of logical index -> DOM element
    let history = []; // snapshots for back: {array, i, j, swaps, comps, currentLine}
    let i = 0, j = 0; // bubble variables
    let comparisons = 0, swaps = 0;
    let playing = false;
    let timer = null;

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function makeRandomArray(n){
      const arr = [];
      for(let k=0;k<n;k++){
        arr.push(Math.floor(Math.random()*90)+10);
      }
      return arr;
    }

    function init(){
      sizeVal.textContent = sizeRange.value;
      speedVal.textContent = speedRange.value + 'ms';
      array = makeRandomArray(parseInt(sizeRange.value,10));
      initialArray = array.slice();
      resetAlgorithmState();
      renderBars();
      updateStats();
      highlightPseudocode(1);
    }

    function resetAlgorithmState(){
      i = 0; j = 0;
      comparisons = 0; swaps = 0;
      history = [];
      stop();
    }

    function renderBars(){
      barsEl.innerHTML = '';
      nodeOrder = [];
      const n = array.length;
      // compute element width based on container size
      const rect = barsEl.getBoundingClientRect();
      const containerWidth = Math.max(200, rect.width || 600);
      const totalGap = Math.max(0, (n-1) * GAP);
      let barWidth = Math.max(MIN_BAR_WIDTH, Math.floor((containerWidth - totalGap) / n));
      // limit width to avoid overflow
      barWidth = Math.min(barWidth, Math.floor((containerWidth - totalGap) / Math.max(1,n)));
      // compute x positions
      positions = [];
      let left = 0;
      for(let idx=0; idx<n; idx++){
        positions.push(left);
        left += barWidth + GAP;
      }

      // create DOM bars
      for(let idx=0; idx<n; idx++){
        const val = array[idx];
        const el = document.createElement('button');
        el.className = 'bar';
        el.setAttribute('data-index', idx);
        el.setAttribute('aria-label', 'Value ' + val + ' at position ' + idx);
        el.setAttribute('title', String(val));
        el.style.width = barWidth + 'px';
        const maxVal = Math.max(...array);
        const minVal = Math.min(...array);
        // compute height proportion
        const hMin = 36; const hMax = barsEl.clientHeight - 36;
        const height = hMin + ( (val - minVal) / Math.max(1, (maxVal - minVal)) ) * (hMax - hMin);
        el.style.height = Math.max(44, height) + 'px';
        // content
        const span = document.createElement('div');
        span.className = 'val';
        span.textContent = val;
        el.appendChild(span);

        // position initially
        el.style.transform = `translateX(${positions[idx]}px)`;
        el.style.transition = 'transform 360ms cubic-bezier(.2,.9,.2,1)';
        barsEl.appendChild(el);
        nodeOrder.push(el);
      }

      // mark any done elements if appropriate
      markDoneElements();
    }

    function markDoneElements(){
      const n = array.length;
      for(let idx=0; idx<n; idx++){
        const el = nodeOrder[idx];
        el.classList.remove('done');
        // if element is in a position >= n - i, it's finalized (bubble sorted to right)
        // But since we reorder DOM on swap, we mark elements that are in final right positions after passes complete:
      }
      // after a pass completes (i passes), last i elements are considered done (if i>0)
      const finalized = i;
      for(let k=0;k<finalized;k++){
        const idx = array.length - 1 - k;
        if(nodeOrder[idx]) nodeOrder[idx].classList.add('done');
      }
    }

    function updatePositions(animated = true){
      // recompute positions (in case of resize or array length change)
      const n = array.length;
      const rect = barsEl.getBoundingClientRect();
      const containerWidth = Math.max(200, rect.width || 600);
      const totalGap = Math.max(0, (n-1) * GAP);
      let barWidth = Math.max(MIN_BAR_WIDTH, Math.floor((containerWidth - totalGap) / n));
      barWidth = Math.min(barWidth, Math.floor((containerWidth - totalGap) / Math.max(1,n)));
      positions = [];
      let left = 0;
      for(let idx=0; idx<n; idx++){
        positions.push(left);
        left += barWidth + GAP;
      }
      nodeOrder.forEach((el, idx) => {
        el.style.width = barWidth + 'px';
        if(!animated) el.style.transition = 'none';
        else el.style.transition = 'transform 360ms cubic-bezier(.2,.9,.2,1)';
        el.style.transform = `translateX(${positions[idx]}px)`;
      });
      // re-enable transition
      if(!animated){
        requestAnimationFrame(()=> {
          nodeOrder.forEach(el => el.style.transition = 'transform 360ms cubic-bezier(.2,.9,.2,1)');
        });
      }
    }

    // Pseudocode highlighting utility
    function highlightPseudocode(n){
      codeLines.forEach(ln => {
        ln.classList.toggle('current', parseInt(ln.dataset.line,10) === n);
      });
    }

    // Save snapshot for back navigation
    function pushHistory(currentLine){
      history.push({
        array: array.slice(),
        i, j, comparisons, swaps,
        currentLine
      });
      // limit history size
      if(history.length > 1000) history.shift();
    }

    function restoreHistory(){
      if(history.length === 0) return;
      const snap = history.pop();
      array = snap.array.slice();
      i = snap.i; j = snap.j;
      comparisons = snap.comparisons;
      swaps = snap.swaps;
      renderBars();
      updateStats();
      highlightPseudocode(snap.currentLine || 1);
    }

    function stepOnce(){
      const n = array.length;
      if(n <= 1 || i >= n-1){
        // done
        stop();
        statusText.textContent = 'Sorted';
        highlightPseudocode(1);
        i = n - 1;
        markDoneElements();
        return;
      }
      // Save pre-step snapshot for Back (before making the change)
      pushHistory(2); // line 2 we're entering inner loop
      // compare arr[j] and arr[j+1]
      const leftIdx = j;
      const rightIdx = j+1;
      comparisons++;
      updateStats();
      // highlight comparison
      const leftEl = nodeOrder[leftIdx];
      const rightEl = nodeOrder[rightIdx];
      if(leftEl) leftEl.classList.add('compare');
      if(rightEl) rightEl.classList.add('compare');
      highlightPseudocode(3);
      statusText.textContent = `Comparing index ${j} and ${j+1}`;
      // wait for a bit if playing for visual
      setTimeout(() => {
        // check order
        if(array[leftIdx] > array[rightIdx]){
          // swap in array
          [array[leftIdx], array[rightIdx]] = [array[rightIdx], array[leftIdx]];
          swaps++;
          updateStats();
          // also swap DOM nodes in nodeOrder array and animate positions
          leftEl.classList.remove('compare');
          rightEl.classList.remove('compare');
          leftEl.classList.add('swap');
          rightEl.classList.add('swap');
          highlightPseudocode(4);
          statusText.textContent = `Swapping ${rightIdx} ↔ ${leftIdx}`;
          // perform swap in nodeOrder
          nodeOrder.splice(leftIdx, 2, rightEl, leftEl);
          // animate to new positions
          updatePositions(true);
          // after animation, remove swap class
          setTimeout(() => {
            leftEl.classList.remove('swap');
            rightEl.classList.remove('swap');
            // proceed to next index
            incrementIndexes();
          }, Math.max(220, parseInt(speedRange.value,10)));
        } else {
          // no swap
          leftEl.classList.remove('compare');
          rightEl.classList.remove('compare');
          // small pause to let user see comparison
          setTimeout(() => {
            // proceed to next index
            incrementIndexes();
          }, Math.max(120, parseInt(speedRange.value,10)/2));
        }
      }, Math.max(80, parseInt(speedRange.value,10)/3));
    }

    function incrementIndexes(){
      // advance j; if inner loop done, advance i
      j++;
      const n = array.length;
      if(j >= n - 1 - i){
        // finished a pass
        i++;
        j = 0;
        markDoneElements();
        statusText.textContent = `Pass ${i} complete`;
      }
      updateStats();
      // if sorted complete
      if(i >= n - 1){
        stop();
        statusText.textContent = 'Sorted';
        highlightPseudocode(1);
        markDoneElements();
      } else {
        highlightPseudocode(2);
      }
    }

    function updateStats(){
      statPass.textContent = 'Pass: ' + i;
      statIdx.textContent = 'Compare j: ' + j;
      statComp.textContent = 'Comparisons: ' + comparisons;
      statSwaps.textContent = 'Swaps: ' + swaps;
    }

    // Control handlers
    sizeRange.addEventListener('input', (e)=>{
      sizeVal.textContent = e.target.value;
    });
    sizeRange.addEventListener('change', (e)=>{
      array = makeRandomArray(parseInt(e.target.value,10));
      initialArray = array.slice();
      resetAlgorithmState();
      renderBars();
      updateStats();
    });

    randomBtn.addEventListener('click', ()=>{
      array = makeRandomArray(parseInt(sizeRange.value,10));
      initialArray = array.slice();
      resetAlgorithmState();
      renderBars();
      updateStats();
    });

    shuffleBtn.addEventListener('click', ()=>{
      // shuffle current array
      for(let k=array.length-1;k>0;k--){
        const r = Math.floor(Math.random()*(k+1));
        [array[k], array[r]] = [array[r], array[k]];
      }
      initialArray = array.slice();
      resetAlgorithmState();
      renderBars();
      updateStats();
    });

    resetBtn.addEventListener('click', ()=>{
      array = initialArray.slice();
      resetAlgorithmState();
      renderBars();
      updateStats();
      statusText.textContent = 'Reset';
    });

    arrInput.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter'){
        applyCustomArray();
      }
    });

    function applyCustomArray(){
      const raw = arrInput.value.trim();
      if(!raw) return;
      const parts = raw.split(',').map(s => s.trim()).filter(Boolean);
      const nums = [];
      for(const p of parts){
        const v = Number(p);
        if(Number.isNaN(v)){
          alert('Please enter only numbers separated by commas.');
          return;
        }
        nums.push(v);
      }
      if(nums.length < 2){
        alert('Please provide at least 2 numbers.');
        return;
      }
      array = nums.slice(0, 40); // guard
      initialArray = array.slice();
      sizeRange.value = Math.min(20, array.length);
      sizeVal.textContent = sizeRange.value;
      resetAlgorithmState();
      renderBars();
      updateStats();
      statusText.textContent = 'Custom array applied';
    }

    playBtn.addEventListener('click', togglePlay);
    function togglePlay(){
      if(playing) stop();
      else play();
    }

    function play(){
      if(array.length <= 1) return;
      playing = true;
      playBtn.classList.add('primary');
      playBtn.textContent = 'Pause';
      playBtn.setAttribute('aria-pressed','true');
      // set interval by speed
      const delay = Math.max(40, parseInt(speedRange.value,10));
      timer = setInterval(()=>{
        // if done, stop
        if(i >= array.length - 1){
          stop();
          return;
        }
        stepOnce();
      }, delay);
    }

    function stop(){
      playing = false;
      if(timer) {
        clearInterval(timer);
        timer = null;
      }
      playBtn.classList.remove('primary');
      playBtn.textContent = 'Play';
      playBtn.setAttribute('aria-pressed','false');
    }

    stepBtn.addEventListener('click', ()=>{
      if(playing) stop();
      stepOnce();
    });

    backBtn.addEventListener('click', ()=>{
      if(playing) stop();
      restoreHistory();
    });

    speedRange.addEventListener('input', (e)=>{
      speedVal.textContent = e.target.value + 'ms';
      if(playing){
        stop();
        play();
      }
    });

    fastFinishBtn.addEventListener('click', ()=>{
      if(playing) stop();
      // quickly finish algorithm with no animation (fast)
      while(i < array.length - 1){
        for(j=0;j<array.length-1-i;j++){
          if(array[j] > array[j+1]){
            [array[j], array[j+1]] = [array[j+1], array[j]];
            swaps++; comparisons++;
          } else {
            comparisons++;
          }
        }
        i++;
      }
      // re-render final
      renderBars();
      updateStats();
      statusText.textContent = 'Finished (fast)';
      highlightPseudocode(1);
    });

    // keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if(e.key === ' '){
        e.preventDefault();
        togglePlay();
      } else if(e.key === 'ArrowRight'){
        e.preventDefault();
        if(playing) stop();
        stepOnce();
      } else if(e.key === 'ArrowLeft'){
        e.preventDefault();
        if(playing) stop();
        restoreHistory();
      }
    });

    // on resize recompute positions
    window.addEventListener('resize', ()=>{
      updatePositions(false);
    });

    // initialize
    init();
    // ensure positions recomputed after fonts/layout
    setTimeout(()=> updatePositions(false), 120);

  </script>
</body>
</html>