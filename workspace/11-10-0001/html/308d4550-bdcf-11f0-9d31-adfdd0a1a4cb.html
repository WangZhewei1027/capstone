<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Longest Common Subsequence (LCS) Explorer</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --accent-diag: #2ca58d;
      --accent-side: #3b82f6;
      --accent-tie: #8b5cf6;
      --bg: #0f172a;
      --panel: #0b1220;
      --muted: #94a3b8;
      --cell-size: 44px;
      --cell-font: 16px;
    }
    /* Safe area margins */
    html,body{
      height:100%;
      margin:0;
      padding:0;
      background:linear-gradient(180deg,#071027 0%, #081728 100%);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color:#e6eef8;
    }
    body{
      padding:var(--safe-padding);
      box-sizing:border-box;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .container{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      justify-content:center;
      width:100%;
      max-width:1500px;
      margin:0 auto;
      box-sizing:border-box;
    }
    /* Responsive: stack on narrow */
    @media (max-width:980px){
      .container{flex-direction:column;}
    }

    /* Left column: main interactive area */
    .main{
      flex:1 1 680px;
      min-width:280px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:10px;
      padding:16px;
      box-sizing:border-box;
    }
    .side{
      width:360px;
      min-width:260px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:10px;
      padding:16px;
      box-sizing:border-box;
    }
    @media (max-width:980px){
      .side{width:100%;}
    }

    header h1{
      margin:0 0 8px 0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    header p{margin:0;color:var(--muted);font-size:13px}

    .controls{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
      margin-top:16px;
      align-items:center;
    }
    .field{
      display:flex;
      flex-direction:column;
      gap:8px;
      min-width:180px;
      flex:1 1 220px;
    }
    label{font-size:13px;color:var(--muted)}
    input[type="text"]{
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:rgba(255,255,255,0.02);
      color:inherit;
      font-size:15px;
      outline:none;
    }
    input[type="text"]:focus{box-shadow:0 0 0 3px rgba(59,130,246,0.12);}

    .controls-row{
      display:flex;
      gap:var(--gap);
      align-items:center;
      margin-top:12px;
      flex-wrap:wrap;
    }
    button{
      background:linear-gradient(180deg, #1f2937, #111827);
      color:#e6eef8;
      border:1px solid rgba(255,255,255,0.04);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-size:14px;
    }
    button[aria-pressed="true"]{
      box-shadow:0 6px 18px rgba(0,0,0,0.45);
      transform:translateY(-1px);
    }
    .compact {
      display:flex;
      gap:8px;
      align-items:center;
    }

    /* Matrix area */
    .matrix-wrap{
      margin-top:var(--gap);
      overflow:auto;
      background:linear-gradient(180deg, rgba(255,255,255,0.008), transparent);
      padding:12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
    }
    table.dp{
      border-collapse:collapse;
      font-size:var(--cell-font);
      color:inherit;
    }
    table.dp caption{
      text-align:left;
      padding:8px 0;
      color:var(--muted);
      font-size:13px;
    }
    table.dp td, table.dp th{
      width:var(--cell-size);
      height:var(--cell-size);
      min-width:var(--cell-size);
      min-height:var(--cell-size);
      border:1px solid rgba(255,255,255,0.04);
      text-align:center;
      vertical-align:middle;
      position:relative;
      background:rgba(255,255,255,0.01);
      transition:background-color 300ms ease, transform 200ms ease;
      border-radius:6px;
      padding:4px;
    }
    table.dp th{
      background:rgba(255,255,255,0.02);
      font-weight:600;
      color:#cfe7ff;
    }
    .char-cell{font-weight:700;color:#dbeafe;}

    .cell-value{
      font-size:14px;
      font-weight:700;
      opacity:0;
      transform:translateY(6px);
      transition:opacity 300ms ease, transform 300ms ease;
      display:inline-block;
      min-width:14px;
    }
    td.filled .cell-value{
      opacity:1;
      transform:none;
    }
    /* Source highlights */
    td.source-diag{box-shadow:0 0 0 3px rgba(44,165,141,0.06) inset;}
    td.source-side{box-shadow:0 0 0 3px rgba(59,130,246,0.06) inset;}
    td.source-tie{box-shadow:0 0 0 3px rgba(139,92,246,0.06) inset;}

    /* Predecessor pulse */
    .pulse{
      position:absolute;
      inset:0;
      border-radius:6px;
      pointer-events:none;
      opacity:0;
      transform:scale(0.9);
      transition:opacity 300ms ease, transform 300ms ease;
      box-shadow:0 0 0 4px rgba(255,255,255,0.02) inset;
    }
    .pulse.on{opacity:1;transform:scale(1.02);}

    /* Focus outline for accessibility */
    td:focus{
      outline:3px solid rgba(99,102,241,0.18);
      outline-offset:2px;
    }

    /* Side panel */
    .panel{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .box{
      background:rgba(255,255,255,0.02);
      padding:12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
    }
    .muted{color:var(--muted);font-size:13px}
    .big{
      font-size:20px;
      font-weight:700;
      color:#dff6ef;
    }
    .lcs-result{
      font-size:18px;
      font-weight:700;
      color:#ffd580;
      min-height:28px;
    }

    /* Small helper texts */
    .hint{font-size:13px;color:var(--muted)}

    /* Responsive cell size when wide */
    @media (min-width:1200px){
      :root{--cell-size:56px;--cell-font:17px;}
    }
  </style>
</head>
<body>
  <div class="container" role="main">
    <div class="main" aria-labelledby="title">
      <header>
        <h1 id="title">Interactive: Longest Common Subsequence (LCS)</h1>
        <p>Explore how the DP matrix is filled and how backtracking recovers the LCS.</p>
      </header>

      <div class="controls" aria-hidden="false">
        <div class="field">
          <label for="inputA">String A (top)</label>
          <input id="inputA" type="text" maxlength="28" value="ABCBDAB" aria-label="String A">
        </div>
        <div class="field">
          <label for="inputB">String B (left)</label>
          <input id="inputB" type="text" maxlength="28" value="BDCABC" aria-label="String B">
        </div>
        <div style="min-width:180px">
          <label class="muted">Examples / Actions</label>
          <div style="display:flex;gap:8px;margin-top:8px;">
            <button id="computeBtn" aria-pressed="false">Compute LCS</button>
            <button id="randomBtn" title="Random example">Random Example</button>
          </div>
        </div>
      </div>

      <div class="controls-row">
        <div class="compact">
          <button id="playBtn" aria-pressed="false" title="Play / Pause">Play</button>
          <button id="stepBackBtn" title="Step Back">&larr; Step</button>
          <button id="stepFwdBtn" title="Step Forward">Step &rarr;</button>
        </div>

        <div style="display:flex;align-items:center;gap:8px;">
          <label class="muted" for="speed">Speed</label>
          <input id="speed" type="range" min="0.2" max="2" step="0.1" value="1" style="width:160px" aria-label="Playback speed">
        </div>

        <div style="display:flex;align-items:center;gap:8px;">
          <input id="autoBack" type="checkbox" />
          <label for="autoBack" class="muted">Auto-backtrack</label>
        </div>

        <div style="flex:1"></div>

        <div style="display:flex;gap:8px;">
          <button id="backtrackBtn" style="display:none">Backtrack</button>
        </div>
      </div>

      <div class="matrix-wrap" id="matrixWrap" aria-live="polite">
        <!-- Matrix will be inserted here -->
        <table class="dp" id="dpTable" aria-label="DP matrix for LCS">
          <caption>Press Compute to build the DP matrix</caption>
        </table>
      </div>

      <div style="margin-top:var(--gap);display:flex;gap:var(--gap);flex-wrap:wrap;">
        <div class="box" style="flex:1;min-width:220px;">
          <div class="muted">Recurrence</div>
          <div style="margin-top:8px;color:#dbeafe;">
            If A[j-1] == B[i-1]: dp[i][j] = dp[i-1][j-1] + 1 (from diagonal).<br>
            Else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) (from top or left).
          </div>
        </div>

        <div class="box" style="min-width:220px;flex:1;">
          <div class="muted">Current step</div>
          <div id="stepDesc" style="margin-top:8px;color:#dbeafe;">No calculation yet.</div>
        </div>
      </div>
    </div>

    <aside class="side" aria-labelledby="sideTitle">
      <h2 id="sideTitle" style="margin:0;font-size:16px;">Inspector & Result</h2>

      <div class="panel" style="margin-top:8px;">
        <div class="box">
          <div class="muted">Cell details</div>
          <div id="cellDetail" style="margin-top:8px;color:#dbeafe">Click or focus a cell to inspect how its value was derived.</div>
        </div>

        <div class="box">
          <div class="muted">LCS (revealed)</div>
          <div class="lcs-result" id="lcsResult">—</div>
          <div class="hint" style="margin-top:8px;">Backtracking highlights the chosen path; diagonal moves add a character to the LCS.</div>
        </div>

        <div class="box">
          <div class="muted">Controls hint</div>
          <div style="margin-top:8px;color:#cfe7ff;">
            Use Play to animate filling. Step buttons step cells. Click cells to see predecessors. Toggle Auto-backtrack to run backtracking automatically after filling.
          </div>
        </div>
      </div>
    </aside>
  </div>

  <script>
    // LCS interactive module - vanilla JS
    (function () {
      // DOM elements
      const inputA = document.getElementById('inputA');
      const inputB = document.getElementById('inputB');
      const computeBtn = document.getElementById('computeBtn');
      const randomBtn = document.getElementById('randomBtn');
      const dpTable = document.getElementById('dpTable');
      const matrixWrap = document.getElementById('matrixWrap');
      const playBtn = document.getElementById('playBtn');
      const stepFwdBtn = document.getElementById('stepFwdBtn');
      const stepBackBtn = document.getElementById('stepBackBtn');
      const speedSlider = document.getElementById('speed');
      const stepDesc = document.getElementById('stepDesc');
      const cellDetail = document.getElementById('cellDetail');
      const backtrackBtn = document.getElementById('backtrackBtn');
      const lcsResult = document.getElementById('lcsResult');
      const autoBack = document.getElementById('autoBack');

      // State
      let A = '';
      let B = '';
      let dp = [];        // numeric DP matrix
      let source = [];    // source pointers per cell
      let steps = [];     // list of step objects: {i,j,value,sourceKind}
      let currentStep = -1;
      let playing = false;
      let playTimer = null;
      let speed = 1.0;
      let backtrackPath = []; // array of [i,j] for backtrack
      let cellElements = {}; // keyed by "i,j" store td element

      // Utility
      function clamp(n,min,max){return Math.max(min,Math.min(max,n));}

      function clearTable() {
        dpTable.innerHTML = '<caption>Press Compute to build the DP matrix</caption>';
        cellElements = {};
        dp = [];
        source = [];
        steps = [];
        currentStep = -1;
        backtrackPath = [];
        stepDesc.textContent = 'No calculation yet.';
        cellDetail.textContent = 'Click or focus a cell to inspect how its value was derived.';
        lcsResult.textContent = '—';
        backtrackBtn.style.display = 'none';
      }

      // Build dp arrays and precompute step sequence
      function prepareComputation(a,b) {
        A = a;
        B = b;
        const n = A.length;
        const m = B.length;
        // initialize dp and source matrices (size m+1 x n+1)
        dp = Array.from({length:m+1},()=>Array(n+1).fill(0));
        source = Array.from({length:m+1},()=>Array(n+1).fill(null));
        steps = [];
        // generate steps for each cell (i:1..m, j:1..n)
        for(let i=1;i<=m;i++){
          for(let j=1;j<=n;j++){
            const ai = A[j-1];
            const bi = B[i-1];
            if(ai === bi){
              const val = dp[i-1][j-1] + 1;
              dp[i][j] = val;
              source[i][j] = {kind:'diag', from:[i-1,j-1]};
            } else {
              const top = dp[i-1][j];
              const left = dp[i][j-1];
              if(top > left){
                dp[i][j] = top;
                source[i][j] = {kind:'top', from:[i-1,j]};
              } else if(left > top){
                dp[i][j] = left;
                source[i][j] = {kind:'left', from:[i,j-1]};
              } else {
                dp[i][j] = top; // equal
                source[i][j] = {kind:'tie', from:[[i-1,j],[i,j-1]]};
              }
            }
            // push step snapshot (we store the computed value and source kind)
            steps.push({
              i, j,
              value: dp[i][j],
              kind: source[i][j].kind,
              ai: A[j-1],
              bi: B[i-1],
              top: dp[i-1][j],
              left: dp[i][j-1],
              diag: dp[i-1][j-1]
            });
          }
        }
        // After filling, compute backtrack path (choose one path for demo)
        // We'll follow standard preference: diag when match, else prefer top if >= left, else left.
        backtrackPath = computeBacktrackPath();
      }

      function computeBacktrackPath(){
        const path = [];
        let i = B.length;
        let j = A.length;
        while(i>0 && j>0){
          const s = source[i][j];
          if(!s) break;
          if(s.kind === 'diag' && A[j-1] === B[i-1]) {
            path.push([i,j]);
            i--; j--;
          } else if(s.kind === 'top' || (s.kind === 'tie' && dp[i-1][j] >= dp[i][j-1])) {
            // move up
            path.push([i,j]);
            i = i-1;
          } else {
            // left
            path.push([i,j]);
            j = j-1;
          }
        }
        // include any remaining zero row/col if desired (not necessary)
        return path;
      }

      // Build the HTML table with headers and initial zeros
      function buildTable() {
        const n = A.length;
        const m = B.length;
        dpTable.innerHTML = '';
        // caption
        const cap = document.createElement('caption');
        cap.textContent = `DP matrix: rows = B length (${m}), cols = A length (${n}).`;
        dpTable.appendChild(cap);

        // Create top header row: empty corner then characters of A
        const thead = document.createElement('thead');
        const topRow = document.createElement('tr');
        // top-left empty cell
        const corner = document.createElement('th');
        corner.setAttribute('scope','col');
        corner.textContent = '';
        corner.style.width = 'auto';
        topRow.appendChild(corner);
        // header row of chars
        const emptyHeader = document.createElement('th');
        emptyHeader.textContent = '0';
        emptyHeader.setAttribute('scope','col');
        topRow.appendChild(emptyHeader);
        for(let j=0;j<n;j++){
          const th = document.createElement('th');
          th.className = 'char-cell';
          th.textContent = A[j];
          th.setAttribute('scope','col');
          topRow.appendChild(th);
        }
        thead.appendChild(topRow);
        dpTable.appendChild(thead);

        // tbody with rows: each row begins with header for B char, then numeric cells
        const tbody = document.createElement('tbody');
        for(let i=0;i<=m;i++){
          const tr = document.createElement('tr');
          // first header cell for each row
          const rowLabel = document.createElement('th');
          rowLabel.setAttribute('scope','row');
          if(i===0){
            rowLabel.textContent = '0';
          } else {
            rowLabel.className = 'char-cell';
            rowLabel.textContent = B[i-1];
          }
          tr.appendChild(rowLabel);

          for(let j=0;j<=n;j++){
            const td = document.createElement('td');
            td.tabIndex = 0;
            td.setAttribute('data-i', i);
            td.setAttribute('data-j', j);
            // value span
            const span = document.createElement('span');
            span.className = 'cell-value';
            span.setAttribute('aria-hidden','true');
            span.textContent = (i===0 || j===0) ? '0' : '';
            td.appendChild(span);
            // pulse overlay
            const pulse = document.createElement('div');
            pulse.className = 'pulse';
            td.appendChild(pulse);

            // store element
            cellElements[`${i},${j}`] = td;

            // listeners for click/focus
            td.addEventListener('click', ()=>inspectCell(i,j));
            td.addEventListener('focus', ()=>inspectCell(i,j));
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }
        dpTable.appendChild(tbody);
      }

      function inspectCell(i,j){
        const n = A.length;
        const m = B.length;
        if(i<0||j<0||i>m||j>n) return;
        const val = (i===0 || j===0) ? 0 : dp[i][j];
        let html = `dp[${i}][${j}] = ${val}.`;
        if(i===0||j===0){
          html += ' (base row/column = 0)';
        } else {
          const s = source[i][j];
          if(s){
            html += ` Derived from: dp[${i-1}][${j}] = ${dp[i-1][j]}, dp[${i}][${j-1}] = ${dp[i][j-1]}, dp[${i-1}][${j-1}] = ${dp[i-1][j-1]}.`;
            if(A[j-1] === B[i-1]){
              html += ` Characters matched: A[${j-1}]="${A[j-1]}" = B[${i-1}] — diagonal (+1).`;
            } else {
              if(s.kind === 'top') html += ' Chosen: top (up).';
              else if(s.kind === 'left') html += ' Chosen: left.';
              else if(s.kind === 'tie') html += ' Tie: both top and left have equal value.';
            }
          } else {
            html += ' Not computed yet.';
          }
        }
        cellDetail.textContent = html;
      }

      // Animate a single step: fill cell at stepIndex
      function animateStep(stepIndex, immediate=false) {
        if(stepIndex < 0 || stepIndex >= steps.length) return;
        const step = steps[stepIndex];
        const {i,j,value,kind,ai,bi,top,left,diag} = step;
        const key = `${i},${j}`;
        const td = cellElements[key];
        if(!td) return;
        // Update description
        stepDesc.textContent = `Filling dp[${i}][${j}] for A="${ai}", B="${bi}" => ${value} (${kind})`;
        // Show value with animation
        const span = td.querySelector('.cell-value');
        span.textContent = String(value);
        // mark as filled
        td.classList.add('filled');
        // add source class
        td.classList.remove('source-diag','source-side','source-tie');
        if(kind === 'diag') td.classList.add('source-diag');
        else if(kind === 'tie') td.classList.add('source-tie');
        else td.classList.add('source-side');

        // pulse predecessors
        const predKeys = [];
        if(kind === 'diag'){ predKeys.push(`${i-1},${j-1}`); }
        else if(kind === 'top'){ predKeys.push(`${i-1},${j}`); }
        else if(kind === 'left'){ predKeys.push(`${i},${j-1}`); }
        else if(kind === 'tie'){ predKeys.push(`${i-1},${j}`, `${i},${j-1}`); }

        predKeys.forEach(k=>{
          const pred = cellElements[k];
          if(pred){
            const pulse = pred.querySelector('.pulse');
            pulse.classList.add('on');
            // remove pulse after short delay
            setTimeout(()=>pulse.classList.remove('on'), Math.max(250, 600 / speed));
          }
        });

        // brief highlight effect
        td.style.transform = 'translateY(-3px)';
        setTimeout(()=>td.style.transform='translateY(0)', 250);

        // update cell detail if currently focused
        const active = document.activeElement;
        if(active === td) inspectCell(i,j);
      }

      // Clear all filled states (used when recomputing)
      function clearFilledSet() {
        Object.keys(cellElements).forEach(k=>{
          const td = cellElements[k];
          td.classList.remove('filled','source-diag','source-side','source-tie');
          const span = td.querySelector('.cell-value');
          const [i,j] = k.split(',').map(Number);
          span.textContent = (i===0||j===0)? '0' : '';
        });
      }

      // Play controls
      function play() {
        if(playing) return;
        playing = true;
        playBtn.setAttribute('aria-pressed','true');
        playBtn.textContent = 'Pause';
        const delayBase = 500; // ms per step at speed=1
        function tick(){
          if(currentStep < steps.length - 1){
            currentStep++;
            animateStep(currentStep);
            scheduleNext();
          } else {
            // finished filling
            stopPlay();
            // reveal backtrack if enabled
            backtrackBtn.style.display = 'inline-block';
            if(autoBack.checked) {
              animateBacktrack();
            }
          }
        }
        function scheduleNext(){
          const d = Math.max(80, delayBase / speed);
          playTimer = setTimeout(tick, d);
        }
        scheduleNext();
      }

      function stopPlay(){
        playing = false;
        playBtn.setAttribute('aria-pressed','false');
        playBtn.textContent = 'Play';
        if(playTimer) { clearTimeout(playTimer); playTimer = null; }
      }

      // Step forward/back
      function stepForward(){
        if(currentStep < steps.length - 1){
          currentStep++;
          animateStep(currentStep);
          if(currentStep === steps.length - 1){
            backtrackBtn.style.display = 'inline-block';
            if(autoBack.checked) animateBacktrack();
          }
        }
      }
      function stepBack(){
        if(currentStep >= 0){
          // clear current cell
          const s = steps[currentStep];
          const td = cellElements[`${s.i},${s.j}`];
          if(td){
            const span = td.querySelector('.cell-value');
            span.textContent = '';
            td.classList.remove('filled','source-diag','source-side','source-tie');
          }
          currentStep--;
          stepDesc.textContent = currentStep >= 0 ? `Stepped back to ${currentStep+1}/${steps.length}` : 'No calculation yet.';
          lcsResult.textContent = '—';
          backtrackBtn.style.display = 'none';
        }
      }

      // Backtrack animation: follow backtrackPath, highlight diag moves to reveal chars
      async function animateBacktrack(){
        if(backtrackPath.length === 0) {
          stepDesc.textContent = 'No backtrack path available.';
          return;
        }
        // Ensure matrix is fully filled
        if(currentStep < steps.length - 1){
          stepDesc.textContent = 'Complete the filling before backtracking.';
          return;
        }
        backtrackBtn.disabled = true;
        // Build LCS by walking path; collect matching diag cells where characters matched.
        const collected = [];
        // We'll animate from start of path (bottom-right) to top-left
        const path = backtrackPath.slice(); // already bottom-right to top-left
        // Highlight each visited cell
        for(let k=0;k<path.length;k++){
          const [i,j] = path[k];
          const td = cellElements[`${i},${j}`];
          if(!td) continue;
          td.style.transition = 'background-color 220ms ease, transform 240ms ease';
          td.style.backgroundColor = 'rgba(255,255,255,0.02)';
          td.style.transform = 'scale(1.03)';
          // if diagonal and chars match, reveal char to LCS
          if(A[j-1] === B[i-1]){
            // small delay to emphasize
            await delay(200 / speed);
            collected.push(A[j-1]);
            // flash the cell with diag color
            td.style.boxShadow = `0 0 0 3px rgba(44,165,141,0.22) inset`;
            await delay(200 / speed);
          } else {
            await delay(120 / speed);
          }
          // restore
          td.style.transform = '';
          td.style.boxShadow = '';
        }

        // collected currently in reverse order (from bottom-right backwards), reverse to display
        const result = collected.reverse().join('') || '—';
        lcsResult.textContent = result;
        stepDesc.textContent = `Backtracking complete. LCS = "${result}"`;
        backtrackBtn.disabled = false;
      }

      function delay(ms){ return new Promise(resolve => setTimeout(resolve, ms)); }

      // Event handlers
      computeBtn.addEventListener('click', ()=>{
        const a = inputA.value.trim();
        const b = inputB.value.trim();
        if(a.length === 0 || b.length === 0){
          alert('Both strings must be non-empty to compute LCS.');
          return;
        }
        if(a.length > 28 || b.length > 28){
          alert('Strings should be at most 28 characters for this demo.');
          return;
        }
        stopPlay();
        clearTable();
        A = a;
        B = b;
        prepareComputation(A,B);
        buildTable();
        clearFilledSet();
        currentStep = -1;
        stepDesc.textContent = `Ready: matrix ${B.length+1} x ${A.length+1}. Press Play to animate.`;
        backtrackBtn.style.display = 'none';
      });

      randomBtn.addEventListener('click', ()=>{
        // generate random short strings from uppercase letters
        const letters = 'ABCDEFXYZLMNOP';
        const lenA = 5 + Math.floor(Math.random()*6);
        const lenB = 5 + Math.floor(Math.random()*6);
        const rand = (len) => Array.from({length:len},()=>letters[Math.floor(Math.random()*letters.length)]).join('');
        inputA.value = rand(lenA);
        inputB.value = rand(lenB);
      });

      playBtn.addEventListener('click', ()=>{
        if(!dpTable.querySelector('tbody')){
          alert('Press Compute to build the DP matrix first.');
          return;
        }
        if(playing) stopPlay();
        else play();
      });

      stepFwdBtn.addEventListener('click', ()=>{
        if(!dpTable.querySelector('tbody')){
          alert('Press Compute to build the DP matrix first.');
          return;
        }
        stopPlay();
        stepForward();
      });

      stepBackBtn.addEventListener('click', ()=>{
        if(!dpTable.querySelector('tbody')){
          alert('Press Compute to build the DP matrix first.');
          return;
        }
        stopPlay();
        stepBack();
      });

      speedSlider.addEventListener('input', (e)=>{
        speed = Number(e.target.value) || 1;
      });

      backtrackBtn.addEventListener('click', async ()=>{
        stopPlay();
        await animateBacktrack();
      });

      // Utility: when clicking outside, pause pulses etc.
      document.addEventListener('visibilitychange', ()=>{
        if(document.hidden) stopPlay();
      });

      // Initialize
      clearTable();
      // Preload with default compute to show something
      // auto-trigger compute for initial default values
      computeBtn.click();

    })();
  </script>
</body>
</html>