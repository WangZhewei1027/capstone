<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Prim’s Algorithm Module</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe-margin: 24px;
      --gap: 16px;
      --sidebar-width: 360px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #9aa4b2;
      --accent: #38bdf8;
      --good: #34d399;
      --danger: #fb7185;
      --glass: rgba(255,255,255,0.03);
    }

    html,body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg,#061223 0%, #081827 100%);
      color: #e6eef6;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Container with safe margins */
    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100vh;
      display: flex;
      gap: var(--gap);
    }

    /* Sidebar and main canvas: responsive */
    .sidebar {
      min-width: 280px;
      width: clamp(280px, 28vw, var(--sidebar-width));
      max-width: 420px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      border-radius: 12px;
      padding: 16px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .main {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: -0.2px;
      color: #e8f5ff;
    }

    .muted {
      color: var(--muted);
      font-size: 13px;
    }

    .section {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.03);
      padding: 12px;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    button, .btn {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      color: #e6eef6;
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      min-height: 40px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    button.primary {
      background: linear-gradient(180deg, rgba(56,189,248,0.12), rgba(56,189,248,0.06));
      border: 1px solid rgba(56,189,248,0.18);
      color: #dff8ff;
    }

    button.ghost {
      background: transparent;
      border: 1px dashed rgba(255,255,255,0.04);
    }

    button.toggle.active {
      background: linear-gradient(180deg, rgba(52,211,153,0.10), rgba(52,211,153,0.04));
      border: 1px solid rgba(52,211,153,0.12);
      color: #eafff4;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    label {
      font-size: 13px;
      color: var(--muted);
      min-width: 120px;
    }

    .small {
      font-size: 12px;
      color: var(--muted);
    }

    /* Canvas card */
    .canvas-card {
      background: var(--glass);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.02);
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 520px;
      align-items: stretch;
    }

    /* SVG area */
    .graph-area {
      flex: 1;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius: 10px;
      overflow: hidden;
      position: relative;
      border: 1px solid rgba(255,255,255,0.02);
    }

    svg {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      user-select: none;
    }

    /* Node styles */
    .node {
      cursor: pointer;
      transition: filter 0.18s, transform 0.18s;
    }
    .node circle {
      fill: #0b2340;
      stroke: rgba(255,255,255,0.06);
      stroke-width: 1.5px;
      transition: fill 200ms, r 120ms, stroke 200ms;
    }

    .node.selected circle {
      fill: rgba(56,189,248,0.12);
      stroke: rgba(56,189,248,0.6);
      stroke-width: 2.2px;
    }

    .node.mst circle {
      fill: rgba(52,211,153,0.12);
      stroke: rgba(52,211,153,0.65);
      stroke-width: 2.4px;
    }

    .node.highlight circle {
      stroke: rgba(250,204,21,0.9);
      stroke-width: 2.6px;
      filter: drop-shadow(0 4px 10px rgba(250,204,21,0.08));
    }

    .node text {
      font-size: 12px;
      fill: #e6eef6;
      pointer-events: none;
    }

    .edge {
      stroke: rgba(255,255,255,0.06);
      stroke-width: 2.4px;
      transition: stroke 240ms, stroke-width 160ms, opacity 160ms;
    }

    .edge.weighted text {
      fill: #cfeafc;
      font-size: 12px;
      pointer-events: none;
      user-select: none;
    }

    .edge.candidate {
      stroke: rgba(56,189,248,0.7);
      stroke-width: 3.2px;
      opacity: 1;
    }

    .edge.considering {
      stroke: rgba(250,204,21,0.95);
      stroke-width: 4px;
      filter: drop-shadow(0 6px 14px rgba(250,204,21,0.06));
      animation: pulse 1s infinite ease-in-out;
    }

    .edge.mst {
      stroke: rgba(52,211,153,0.9);
      stroke-width: 4.2px;
      opacity: 1;
    }

    .edge.faded {
      opacity: 0.12;
    }

    @keyframes pulse {
      0% { stroke-dashoffset: 0; }
      50% { stroke-dashoffset: 12; }
      100% { stroke-dashoffset: 0; }
    }

    /* Candidate list */
    .candidate-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 120px;
      overflow: auto;
      padding-right: 6px;
    }

    .candidate-item {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      background: rgba(255,255,255,0.01);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 13px;
      color: #dff8ff;
      border: 1px solid rgba(255,255,255,0.02);
    }

    .candidate-item .edge-label {
      color: var(--muted);
      font-size: 12px;
    }

    .footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    /* Floating weight input popup */
    .weight-popup {
      position: absolute;
      z-index: 30;
      background: rgba(8,12,20,0.96);
      border: 1px solid rgba(255,255,255,0.03);
      padding: 8px;
      border-radius: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
      box-shadow: 0 8px 30px rgba(2,6,23,0.7);
    }

    .weight-popup input[type="number"] {
      width: 80px;
      padding: 6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.04);
      background: rgba(255,255,255,0.02);
      color: #e6eef6;
    }

    .small-muted {
      font-size: 12px;
      color: var(--muted);
    }

    /* Pseudocode area */
    .pseudocode {
      background: rgba(255,255,255,0.01);
      border-radius: 8px;
      padding: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size: 13px;
      color: #cfeafc;
      border: 1px solid rgba(255,255,255,0.02);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .code-line {
      padding: 6px;
      border-radius: 6px;
      transition: background 180ms, color 180ms;
    }

    .code-line.active {
      background: linear-gradient(90deg, rgba(56,189,248,0.08), rgba(56,189,248,0.04));
      color: #e8faff;
    }

    /* Responsive tweaks */
    @media (max-width: 920px) {
      .app {
        flex-direction: column;
      }
      .sidebar { width: 100%; max-width: none; }
    }
  </style>
</head>
<body>
  <div class="app" role="main">
    <!-- Sidebar: descriptive plan and controls -->
    <aside class="sidebar" aria-label="Prim's Algorithm controls and explanation">
      <div>
        <h1>Prim’s Algorithm — Minimum Spanning Tree (MST)</h1>
        <div class="muted small" style="margin-top:6px;">
          Interactive step-by-step visualization and playground.
        </div>
      </div>

      <div class="section" aria-hidden="false">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <div class="small-muted">Concept Title</div>
            <strong>Prim’s Algorithm (MST) — greedy edge selection</strong>
          </div>
          <div style="text-align:right;">
            <div class="small-muted">Nodes</div>
            <div id="node-count">0</div>
          </div>
        </div>

        <div>
          <div class="small-muted">Learning Objective</div>
          <div class="muted small" style="margin-top:6px;">
            After interacting you will be able to: (1) follow Prim’s greedy process choosing the cheapest edge connecting the growing tree to the graph, (2) see candidate edges and the priority decision, and (3) build and test your own graphs.
          </div>
        </div>

        <details style="margin-top:8px;">
          <summary style="cursor:pointer;color:var(--muted);font-size:13px;">Interaction Design (click to expand)</summary>
          <div class="small-muted" style="margin-top:8px;">
            - Add nodes: toggle "Add Node" then click canvas.<br>
            - Create edges: toggle "Connect" then click source node and target node; enter weight in popup.<br>
            - Drag nodes to reposition edges; edit mid-visualization.<br>
            - Select a start node by clicking a node (before running) or use "Preset Example".<br>
            - Controls: Step, Play/Pause (auto-step), Reset, Random Graph, Preset.<br>
            - Visual feedback: candidate edges (blue), currently-considered edge (gold pulse), chosen MST edges (green), faded irrelevant edges; nodes highlight as they join the MST; pseudocode lines highlight to map the code to each visual step.
          </div>
        </details>
      </div>

      <div class="section" aria-label="Controls">
        <div class="controls" role="group" aria-label="Graph tools">
          <button id="preset-btn" class="btn ghost" title="Load example graph">Preset Example</button>
          <button id="random-btn" class="btn" title="Create a random graph">Random Graph</button>
          <button id="reset-btn" class="btn" title="Reset graph and algorithm">Reset</button>
        </div>

        <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
          <button id="add-node-toggle" class="btn toggle" aria-pressed="false">Add Node</button>
          <button id="connect-toggle" class="btn toggle" aria-pressed="false">Connect</button>
          <button id="delete-toggle" class="btn toggle" aria-pressed="false">Delete</button>
        </div>

        <div style="display:flex;gap:8px;margin-top:8px;">
          <button id="step-btn" class="btn primary" title="Perform one Prim step">Step</button>
          <button id="play-btn" class="btn" title="Auto play">Play</button>
          <button id="pause-btn" class="btn" title="Pause autoplay" style="display:none;">Pause</button>
        </div>

        <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
          <label style="min-width:84px;">Speed</label>
          <input id="speed" type="range" min="300" max="2000" value="900" step="100" aria-label="Playback speed" />
        </div>

        <div class="small-muted" style="margin-top:8px;">
          Start node: click any node to set start (before stepping). The algorithm will choose the smallest crossing edge each step.
        </div>
      </div>

      <div class="section" aria-label="Algorithm state">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <div class="small-muted">Current MST Weight</div>
            <strong id="mst-weight">0</strong>
          </div>
          <div>
            <div class="small-muted">Steps</div>
            <div id="step-count">0</div>
          </div>
        </div>

        <div style="margin-top:8px;">
          <div class="small-muted">Candidate edges (min first)</div>
          <div class="candidate-list" id="candidate-list" aria-live="polite"></div>
        </div>
      </div>

      <div class="section" aria-label="Pseudocode">
        <div class="small-muted">Prim's pseudocode (highlights current step)</div>
        <div class="pseudocode" id="pseudocode">
          <div class="code-line" data-line="init">1. Choose start node s; S = {s}, MST = ∅</div>
          <div class="code-line" data-line="add-edges">2. Add all edges (s, v) to candidate set C</div>
          <div class="code-line" data-line="loop">3. while (|S| &lt; n):</div>
          <div class="code-line" data-line="pick">4. &nbsp;&nbsp; e = smallest-weight edge in C that connects S to V\S</div>
          <div class="code-line" data-line="add-edge">5. &nbsp;&nbsp; Add e to MST; let w be the new vertex added</div>
          <div class="code-line" data-line="update">6. &nbsp;&nbsp; Add edges (w, x) to C for x ∉ S</div>
          <div class="code-line" data-line="done">7. return MST</div>
        </div>
      </div>

    </aside>

    <!-- Main visual area -->
    <main class="main" aria-label="Graph visualization">
      <div class="canvas-card">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <div class="small-muted">Graph Canvas</div>
            <div class="muted small">Drag nodes, create edges and run Prim's algorithm. Nodes are labeled automatically.</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;">
            <div class="small-muted">Nodes</div>
            <div id="node-count-top">0</div>
          </div>
        </div>

        <div class="graph-area" id="graph-area" tabindex="0" role="application" aria-label="Graph drawing area">
          <!-- SVG inserted by JS -->
        </div>

        <div class="footer">
          <div class="small-muted">Tips: Toggle Connect to create edges. Click a node to set the start. Use Step/Play to follow Prim.</div>
          <div style="display:flex;gap:8px;align-items:center;">
            <div class="small-muted">Mode:</div>
            <div id="mode-indicator" class="small-muted">None</div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- Floating weight popup template -->
  <div id="weight-popup" class="weight-popup" style="display:none;">
    <label class="small-muted" for="weight-input">Weight</label>
    <input id="weight-input" type="number" min="1" value="5" />
    <button id="weight-add" class="btn primary">Add</button>
    <button id="weight-cancel" class="btn ghost">Cancel</button>
  </div>

  <script>
    /* Prim's Algorithm interactive module - vanilla JS
       - Enforces safe margins and spacing via CSS
       - No external libraries
       - Accessible controls
    */

    /***** Utility helpers *****/
    const $ = (sel, root = document) => root.querySelector(sel);
    const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
    const rand = (a,b) => Math.floor(Math.random()*(b-a+1))+a;

    /***** DOM References *****/
    const graphArea = $('#graph-area');
    const candidateList = $('#candidate-list');
    const mstWeightEl = $('#mst-weight');
    const stepCountEl = $('#step-count');
    const nodeCountEl = $('#node-count');
    const nodeCountTop = $('#node-count-top');
    const modeIndicator = $('#mode-indicator');
    const pseudocode = $('#pseudocode');
    const weightPopup = $('#weight-popup');
    const weightInput = $('#weight-input');
    const weightAddBtn = $('#weight-add');
    const weightCancelBtn = $('#weight-cancel');

    const addNodeToggle = $('#add-node-toggle');
    const connectToggle = $('#connect-toggle');
    const deleteToggle = $('#delete-toggle');
    const presetBtn = $('#preset-btn');
    const randomBtn = $('#random-btn');
    const resetBtn = $('#reset-btn');
    const stepBtn = $('#step-btn');
    const playBtn = $('#play-btn');
    const pauseBtn = $('#pause-btn');
    const speedRange = $('#speed');

    /***** SVG Setup *****/
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, 'svg');
    svg.setAttribute('viewBox','0 0 1000 600');
    svg.setAttribute('preserveAspectRatio','xMidYMid meet');
    graphArea.appendChild(svg);

    // Groups for drawing order
    const edgeGroup = document.createElementNS(svgNS,'g');
    const edgeWeightGroup = document.createElementNS(svgNS,'g');
    const nodeGroup = document.createElementNS(svgNS,'g');
    svg.appendChild(edgeGroup);
    svg.appendChild(edgeWeightGroup);
    svg.appendChild(nodeGroup);

    /***** Graph Data *****/
    let nodes = []; // {id,label,x,y,svg}
    let edges = []; // {id,u,v,weight,svgLine,svgText,state}

    let nextNodeId = 1;
    let nextEdgeId = 1;

    function resetData() {
      nodes = [];
      edges = [];
      nextNodeId = 1;
      nextEdgeId = 1;
      selectedStartNode = null;
      primStateReset();
      renderAll();
    }

    /***** Interaction state *****/
    let mode = null; // 'add-node', 'connect', 'delete', null
    let isDragging = false;
    let dragNode = null;
    let dragOffset = {x:0,y:0};
    let connectSource = null;
    let weightPopupContext = null;

    function setMode(m) {
      mode = m;
      addNodeToggle.classList.toggle('active', mode === 'add-node');
      addNodeToggle.setAttribute('aria-pressed', mode === 'add-node');
      connectToggle.classList.toggle('active', mode === 'connect');
      connectToggle.setAttribute('aria-pressed', mode === 'connect');
      deleteToggle.classList.toggle('active', mode === 'delete');
      deleteToggle.setAttribute('aria-pressed', mode === 'delete');
      modeIndicator.textContent = mode ? mode.replace('-',' ') : 'None';
    }

    addNodeToggle.addEventListener('click', () => {
      setMode(mode === 'add-node' ? null : 'add-node');
    });
    connectToggle.addEventListener('click', () => {
      setMode(mode === 'connect' ? null : 'connect');
      connectSource = null; // reset any partial connection
    });
    deleteToggle.addEventListener('click', () => {
      setMode(mode === 'delete' ? null : 'delete');
    });

    /***** Rendering *****/
    function renderAll() {
      // clear svg groups
      while (edgeGroup.firstChild) edgeGroup.removeChild(edgeGroup.firstChild);
      while (edgeWeightGroup.firstChild) edgeWeightGroup.removeChild(edgeWeightGroup.firstChild);
      while (nodeGroup.firstChild) nodeGroup.removeChild(nodeGroup.firstChild);

      // edges
      edges.forEach(e => {
        const line = document.createElementNS(svgNS,'line');
        line.classList.add('edge');
        line.setAttribute('x1', e.u.x);
        line.setAttribute('y1', e.u.y);
        line.setAttribute('x2', e.v.x);
        line.setAttribute('y2', e.v.y);
        line.setAttribute('stroke-linecap','round');
        if (e.state) line.classList.add(e.state);
        edgeGroup.appendChild(line);
        e.svgLine = line;

        const txt = document.createElementNS(svgNS,'text');
        txt.classList.add('edge-weight');
        txt.setAttribute('x', (e.u.x + e.v.x)/2 );
        txt.setAttribute('y', (e.u.y + e.v.y)/2 - 8 );
        txt.textContent = e.weight;
        txt.setAttribute('text-anchor','middle');
        txt.setAttribute('fill','#cfeafc');
        edgeWeightGroup.appendChild(txt);
        e.svgText = txt;

        // ensure pointer events on edges are disabled so clicks go to nodes or canvas
        line.style.pointerEvents = 'none';
        txt.style.pointerEvents = 'none';
      });

      // nodes
      nodes.forEach(n => {
        const g = document.createElementNS(svgNS,'g');
        g.classList.add('node');
        g.setAttribute('transform', `translate(${n.x},${n.y})`);
        g.setAttribute('data-id', n.id);

        const circle = document.createElementNS(svgNS,'circle');
        circle.setAttribute('r', 18);
        g.appendChild(circle);

        const label = document.createElementNS(svgNS,'text');
        label.setAttribute('y', 5);
        label.setAttribute('text-anchor','middle');
        label.textContent = n.label;
        g.appendChild(label);

        nodeGroup.appendChild(g);
        n.svg = g;

        // Reflect prim state classes
        g.classList.toggle('selected', n === selectedStartNode || primSelectedNodes.has(n.id));
        g.classList.toggle('mst', primMSTNodeSet.has(n.id));
      });

      updateCounts();
      updateCandidateList();
      updatePseudocodeHighlight();
    }

    function updateEdgePositions(e) {
      e.svgLine.setAttribute('x1', e.u.x);
      e.svgLine.setAttribute('y1', e.u.y);
      e.svgLine.setAttribute('x2', e.v.x);
      e.svgLine.setAttribute('y2', e.v.y);
      e.svgText.setAttribute('x', (e.u.x + e.v.x)/2 );
      e.svgText.setAttribute('y', (e.u.y + e.v.y)/2 - 8 );
    }

    function updateCounts() {
      nodeCountEl.textContent = nodes.length;
      nodeCountTop.textContent = nodes.length;
      stepCountEl.textContent = primStepCount;
    }

    /***** Canvas interactions: add node, drag node, connect edges, delete *****/
    // Convert screen click to SVG coordinates (viewBox 1000x600)
    function clientToSvgCoords(clientX, clientY) {
      const rect = svg.getBoundingClientRect();
      const xPct = (clientX - rect.left) / rect.width;
      const yPct = (clientY - rect.top) / rect.height;
      const vb = svg.viewBox.baseVal;
      const x = vb.x + xPct * vb.width;
      const y = vb.y + yPct * vb.height;
      return {x,y};
    }

    graphArea.addEventListener('pointerdown', (ev) => {
      graphArea.focus();
      // check if clicked on a node (use elementFromPoint)
      const pt = document.elementFromPoint(ev.clientX, ev.clientY);
      const nodeEl = pt && pt.closest && pt.closest('.node');

      if (mode === 'add-node' && !nodeEl) {
        // add node
        const p = clientToSvgCoords(ev.clientX, ev.clientY);
        addNode(p.x, p.y);
        renderAll();
        return;
      }

      if (nodeEl) {
        const id = Number(nodeEl.getAttribute('data-id'));
        const node = nodes.find(n => n.id === id);

        if (mode === 'delete') {
          // delete node and related edges
          removeNode(node);
          renderAll();
          return;
        }

        if (mode === 'connect') {
          // handle connect sequence
          if (!connectSource) {
            connectSource = node;
            // visual feedback: highlight
            node.svg.classList.add('highlight');
          } else if (connectSource && connectSource !== node) {
            // open weight popup near pointer
            openWeightPopup(ev.clientX, ev.clientY, {u: connectSource, v: node});
            // clear highlight
            connectSource.svg.classList.remove('highlight');
            connectSource = null;
          } else {
            // clicked same node - cancel
            connectSource.svg.classList.remove('highlight');
            connectSource = null;
          }
          return;
        }

        // If not in a special mode, allow dragging or selecting as start node
        // Setup dragging
        isDragging = true;
        dragNode = node;
        const p = clientToSvgCoords(ev.clientX, ev.clientY);
        dragOffset.x = node.x - p.x;
        dragOffset.y = node.y - p.y;

        // If Prim hasn't started, clicking selects start node
        if (!primRunning && !primHasRun) {
          setStartNode(node);
        }

        ev.preventDefault();
        return;
      } else {
        // clicked empty canvas: clear connectSource if any
        if (connectSource) {
          connectSource.svg.classList.remove('highlight');
          connectSource = null;
        }
      }
    });

    window.addEventListener('pointermove', (ev) => {
      if (isDragging && dragNode) {
        const p = clientToSvgCoords(ev.clientX, ev.clientY);
        dragNode.x = Math.max(20, Math.min(980, p.x + dragOffset.x));
        dragNode.y = Math.max(20, Math.min(580, p.y + dragOffset.y));
        // update node transform and edges
        dragNode.svg.setAttribute('transform', `translate(${dragNode.x},${dragNode.y})`);
        edges.forEach(e => {
          if (e.u === dragNode || e.v === dragNode) updateEdgePositions(e);
        });
      }
    });

    window.addEventListener('pointerup', (ev) => {
      isDragging = false;
      dragNode = null;
    });

    // Keyboard shortcuts for accessibility
    graphArea.addEventListener('keydown', (ev) => {
      if (ev.key === 'a') setMode('add-node');
      if (ev.key === 'c') setMode('connect');
      if (ev.key === 'Escape') setMode(null);
    });

    /***** Node / Edge CRUD *****/
    function addNode(x,y,label) {
      const id = nextNodeId++;
      const node = { id, label: label || String.fromCharCode(64 + id), x, y, svg: null };
      nodes.push(node);
      renderAll();
      return node;
    }

    function removeNode(node) {
      // remove connected edges
      edges = edges.filter(e => {
        if (e.u === node || e.v === node) {
          // remove svg too if present
          return false;
        }
        return true;
      });
      nodes = nodes.filter(n => n !== node);
      // update ids mapping unaffected
      // update prim structures (reset algorithm)
      primStateReset();
    }

    function addEdge(u,v,weight) {
      // prevent duplicate edges
      if (edges.some(e => (e.u===u && e.v===v) || (e.u===v && e.v===u))) return null;
      const id = nextEdgeId++;
      const e = { id, u, v, weight: Number(weight), svgLine: null, svgText: null, state: null };
      edges.push(e);
      renderAll();
      return e;
    }

    /***** Weight popup handling *****/
    function openWeightPopup(clientX, clientY, context) {
      weightPopupContext = context;
      weightPopup.style.display = 'flex';
      // position within graphArea bounds
      const rect = graphArea.getBoundingClientRect();
      let left = clientX - rect.left + 10;
      let top = clientY - rect.top + 10;
      // clamp
      left = Math.max(6, Math.min(rect.width - 160, left));
      top = Math.max(6, Math.min(rect.height - 60, top));
      weightPopup.style.left = (rect.left + left) + 'px';
      weightPopup.style.top = (rect.top + top) + 'px';
      weightInput.value = rand(1, 20);
      weightInput.focus();
    }

    weightAddBtn.addEventListener('click', () => {
      const w = Number(weightInput.value) || 1;
      if (weightPopupContext) {
        addEdge(weightPopupContext.u, weightPopupContext.v, w);
        weightPopupContext = null;
      }
      weightPopup.style.display = 'none';
    });

    weightCancelBtn.addEventListener('click', () => {
      if (connectSource) connectSource.svg.classList.remove('highlight');
      connectSource = null;
      weightPopupContext = null;
      weightPopup.style.display = 'none';
    });

    /***** Preset and random graph generators *****/
    function loadPreset() {
      resetData();
      // Some nodes arranged
      addNode(220,110,'A');
      addNode(420,70,'B');
      addNode(620,120,'C');
      addNode(320,250,'D');
      addNode(520,280,'E');
      addNode(180,340,'F');

      // find node by label
      const find = (label) => nodes.find(n=>n.label===label);
      addEdge(find('A'), find('B'), 7);
      addEdge(find('A'), find('D'), 5);
      addEdge(find('B'), find('C'), 8);
      addEdge(find('B'), find('D'), 9);
      addEdge(find('B'), find('E'), 7);
      addEdge(find('C'), find('E'), 5);
      addEdge(find('D'), find('E'), 15);
      addEdge(find('D'), find('F'), 6);
      addEdge(find('F'), find('E'), 8);
      renderAll();
    }

    function generateRandomGraph() {
      resetData();
      const n = rand(6,10);
      for (let i=0;i<n;i++) {
        addNode(rand(80,920), rand(60,520));
      }
      // ensure connected-ish: connect each node to a few others
      for (let i=0;i<n;i++) {
        const u = nodes[i];
        const connections = rand(2,3);
        for (let k=0;k<connections;k++) {
          const v = nodes[rand(0,n-1)];
          if (v === u) continue;
          addEdge(u,v, rand(1,20));
        }
      }
      renderAll();
    }

    presetBtn.addEventListener('click', loadPreset);
    randomBtn.addEventListener('click', generateRandomGraph);
    resetBtn.addEventListener('click', resetData);

    /***** Prim's Algorithm State & Logic *****/
    // We'll implement Prim step-by-step; maintain sets
    let selectedStartNode = null;
    let primSelectedNodes = new Set(); // nodes in S
    let primMSTEdges = new Set(); // edges included
    let primMSTNodeSet = new Set(); // nodes that are in MST (same as selectedNodes)
    let primCandidates = []; // list of candidate edges: {edge, weight}
    let primRunning = false;
    let primHasRun = false;
    let primStepCount = 0;
    let primTimer = null;

    function primStateReset() {
      primSelectedNodes.clear();
      primMSTEdges.clear();
      primMSTNodeSet.clear();
      primCandidates = [];
      primRunning = false;
      primHasRun = false;
      primStepCount = 0;
      clearTimeout(primTimer);
      pauseBtn.style.display = 'none';
      playBtn.style.display = 'inline-flex';
      mstWeightEl.textContent = '0';
      stepCountEl.textContent = '0';
      // reset edge/node states visuals
      edges.forEach(e => { e.state = null; });
      nodes.forEach(n => { /* nothing */ });
      renderAll();
    }

    function setStartNode(node) {
      selectedStartNode = node;
      primStateReset();
      // highlight
      renderAll();
      node.svg.classList.add('selected');
      // add initial state in pseudocode
      highlightLine('init');
    }

    function gatherCandidates() {
      // candidate edges: edges with exactly one endpoint in primSelectedNodes
      primCandidates = edges.filter(e => {
        const inU = primSelectedNodes.has(e.u.id);
        const inV = primSelectedNodes.has(e.v.id);
        return (inU && !inV) || (!inU && inV);
      }).map(e => ({e, w: e.weight}));
      // sort by weight then by id
      primCandidates.sort((a,b) => a.w - b.w || a.e.id - b.e.id);
      // update edge states
      edges.forEach(e => {
        e.state = null;
      });
      primCandidates.forEach(obj => {
        if (!primMSTEdges.has(obj.e.id)) obj.e.state = 'candidate';
      });
      renderAll();
    }

    function primInitIfNeeded() {
      if (!selectedStartNode) {
        // choose first node by default if available
        if (nodes.length === 0) return false;
        setStartNode(nodes[0]);
      }
      if (!primRunning && !primHasRun) {
        // add start to S
        primSelectedNodes.add(selectedStartNode.id);
        primMSTNodeSet.add(selectedStartNode.id);
        primStepCount = 0;
        gatherCandidates();
        highlightLine('add-edges');
        renderAll();
        return true;
      }
      return primRunning || primHasRun;
    }

    function primStep() {
      if (!nodes.length) return;
      const initOK = primInitIfNeeded();
      if (!initOK && !primRunning && !primHasRun) return;

      primRunning = true;
      // while S size < n, pick smallest candidate that connects S to V\S
      if (primSelectedNodes.size >= nodes.length) {
        primCompleted();
        return;
      }
      // refresh candidates
      gatherCandidates();

      if (primCandidates.length === 0) {
        // No crossing edges — graph disconnected. finish.
        primCompleted();
        return;
      }

      // Consider smallest
      const candidate = primCandidates[0];
      const e = candidate.e;

      // Visual: mark as being considered
      e.state = 'considering';
      renderAll();
      highlightLine('pick');

      // After a short delay show addition
      setTimeout(() => {
        // if both endpoints already in S (might be stale), skip
        const inU = primSelectedNodes.has(e.u.id);
        const inV = primSelectedNodes.has(e.v.id);
        if (inU && inV) {
          // remove and step again
          primCandidates.shift();
          renderAll();
          primStep();
          return;
        }

        // Add edge to MST
        primMSTEdges.add(e.id);
        e.state = 'mst';
        // decide which node was new
        const newNode = inU ? e.v : e.u;
        primSelectedNodes.add(newNode.id);
        primMSTNodeSet.add(newNode.id);
        primStepCount += 1;
        // Update MST weight
        const total = Array.from(primMSTEdges).reduce((acc, eid) => {
          const edge = edges.find(x => x.id === eid);
          return acc + (edge ? edge.weight : 0);
        }, 0);
        mstWeightEl.textContent = String(total);
        stepCountEl.textContent = primStepCount;

        highlightLine('add-edge');

        // Update candidates: add adjacent edges of newNode
        // will be recalculated in next gatherCandidates call
        setTimeout(() => {
          gatherCandidates();
          highlightLine('update');

          // keep running state
          if (primSelectedNodes.size >= nodes.length) {
            primCompleted();
            return;
          }
          // Not auto stepping further here (Step vs Play handled by timer)
        }, 420);
      }, 700);
    }

    function primCompleted() {
      primRunning = false;
      primHasRun = true;
      clearTimeout(primTimer);
      playBtn.style.display = 'inline-flex';
      pauseBtn.style.display = 'none';
      highlightLine('done');
      // fade irrelevant edges
      edges.forEach(e => {
        if (!primMSTEdges.has(e.id)) {
          e.state = 'faded';
        }
      });
      renderAll();
    }

    // Pseudocode highlighting helper
    function highlightLine(name) {
      $$('.code-line', pseudocode).forEach(el => el.classList.remove('active'));
      const el = $(`.code-line[data-line="${name}"]`, pseudocode);
      if (el) el.classList.add('active');
    }

    // Update candidate list UI
    function updateCandidateList() {
      candidateList.innerHTML = '';
      primCandidates.forEach(obj => {
        const e = obj.e;
        const div = document.createElement('div');
        div.className = 'candidate-item';
        div.innerHTML = `<div><span class="edge-label">(${e.u.label} - ${e.v.label})</span></div><div>${e.weight}</div>`;
        candidateList.appendChild(div);
      });
      if (primCandidates.length === 0) {
        const none = document.createElement('div');
        none.className = 'candidate-item';
        none.style.opacity = 0.6;
        none.textContent = '— no candidates —';
        candidateList.appendChild(none);
      }
    }

    /***** Controls: Step / Play / Pause *****/
    stepBtn.addEventListener('click', () => {
      primStep();
    });

    playBtn.addEventListener('click', () => {
      if (!primInitIfNeeded()) primInitIfNeeded();
      playBtn.style.display = 'none';
      pauseBtn.style.display = 'inline-flex';
      startAutoPlay();
    });

    pauseBtn.addEventListener('click', () => {
      stopAutoPlay();
    });

    function startAutoPlay() {
      primRunning = true;
      function loop() {
        // If completed, stop
        if (primSelectedNodes.size >= nodes.length || primCandidates.length === 0 && primHasRun) {
          primCompleted();
          return;
        }
        primStep();
        primTimer = setTimeout(loop, Number(speedRange.value) || 900);
      }
      loop();
    }

    function stopAutoPlay() {
      clearTimeout(primTimer);
      primRunning = false;
      pauseBtn.style.display = 'none';
      playBtn.style.display = 'inline-flex';
    }

    /***** Initialization: load a preset example on start *****/
    resetData();
    loadPreset();

    /***** Accessibility: expose brief instructions in console for keyboard users *****/
    console.log('Prim interactive: Shortcuts - "a": Add Node mode, "c": Connect mode, "Esc": clear mode. Use Tab to focus controls.');

    /***** Small polish: update node visuals when prim structures change *****/
    // Observe prim sets and update node classes after each render call by hooking renderAll (already does)
    // Also update edge classes in DOM when edge.state changes
    const observer = new MutationObserver(() => {});
    // Not necessary further.

  </script>
</body>
</html>