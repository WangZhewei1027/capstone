<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merge Sort — Interactive Module</title>
  <style>
    :root{
      --safe: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --card: #0b1220;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --accent-2: #7c3aed;
      --good: #34d399;
      --danger: #fb7185;
      --surface: #0b1220;
      --text: #e6eef8;
      --panel: #0f1724;
      --action: #f59e0b;
    }

    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,#071127 0%, #07111a 100%);
      color:var(--text);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Safe area container */
    .app {
      padding: var(--safe);
      box-sizing: border-box;
      min-height:100vh;
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
    }

    /* Two-column responsive */
    .left {
      width:360px;
      min-width:280px;
      max-width:40%;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:20px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    .right {
      flex:1;
      min-width:0;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:12px;
      padding:20px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:16px;
      align-items:stretch;
    }

    h1 {
      font-size:18px;
      margin:0 0 4px 0;
      color:var(--text);
    }
    p.small {
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    .section {
      background: rgba(255,255,255,0.02);
      border-radius:8px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    label.block {
      display:block;
      font-size:13px;
      color:var(--muted);
      margin-bottom:6px;
    }

    .controls {
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }

    button, input[type="number"], select, .small-btn {
      font-size:13px;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:transparent;
      color:var(--text);
      cursor:pointer;
    }

    button:active{ transform:translateY(1px); }
    button.primary {
      background:linear-gradient(90deg,var(--accent),var(--accent-2));
      border: none;
      color:white;
      box-shadow:0 6px 18px rgba(124,58,237,0.12);
    }

    .row {
      display:flex;
      gap:12px;
      align-items:center;
    }

    input[type="text"] {
      width:100%;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:transparent;
      color:var(--text);
      font-size:13px;
    }

    .slider {
      width:100%;
    }

    .visual {
      height:360px;
      min-height:260px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:8px;
      padding:16px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:stretch;
    }

    .array-area {
      flex:1;
      position:relative;
      background:linear-gradient(180deg, rgba(0,0,0,0.04), rgba(255,255,255,0.01));
      border-radius:8px;
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:visible;
    }

    .array-line {
      position:relative;
      width:100%;
      height:120px;
      max-height:180px;
      min-height:80px;
      display:block;
    }

    .bar {
      position:absolute;
      bottom:8px;
      width:40px;
      height:40px;
      border-radius:6px;
      background:linear-gradient(180deg,#1e293b,#0b1220);
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--text);
      font-weight:600;
      box-shadow:0 6px 14px rgba(2,6,23,0.6);
      transition:transform 300ms ease, background 250ms ease, opacity 200ms ease;
      user-select:none;
    }

    .bar .val {
      font-size:13px;
    }

    .bar.compare {
      background: linear-gradient(180deg,#f97316,#fb923c);
      box-shadow:0 8px 18px rgba(249,115,22,0.16);
      z-index:6;
    }

    .bar.merged {
      background: linear-gradient(180deg,#10b981,#34d399);
      box-shadow:0 8px 18px rgba(16,185,129,0.12);
      z-index:5;
    }

    .bar.source {
      opacity:0.85;
      transform:translateY(-6px) scale(0.98);
    }

    .temp-layer {
      position:absolute;
      top:0;
      left:0;
      right:0;
      bottom:0;
      pointer-events:none;
    }

    .temp {
      position:absolute;
      width:40px;
      height:40px;
      border-radius:6px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:white;
      font-weight:700;
      background:linear-gradient(180deg,#7c3aed,#60a5fa);
      box-shadow:0 10px 30px rgba(12,8,40,0.6);
      transition:transform 350ms cubic-bezier(.2,.9,.2,1), opacity 250ms ease;
      z-index:10;
    }

    .meta {
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      font-size:13px;
      color:var(--muted);
    }

    .stats {
      display:flex;
      gap:8px;
      align-items:center;
    }

    .stat {
      background:rgba(255,255,255,0.02);
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
      color:var(--muted);
    }

    .legend {
      display:flex;
      gap:8px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
      margin-top:6px;
    }

    .swatch {
      width:12px;
      height:12px;
      border-radius:3px;
      margin-right:6px;
    }

    /* responsive */
    @media (max-width:900px){
      .app { flex-direction:column; }
      .left { width:100%; max-width:none; }
      .right { width:100%; }
    }

    /* small helpers */
    .muted { color:var(--muted); font-size:13px; }
    .center { display:flex; align-items:center; justify-content:center; gap:8px; }
    .small-btn {
      background:transparent;
      border:1px solid rgba(255,255,255,0.03);
      padding:6px 8px;
    }

  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Merge Sort Interactive Module">
    <aside class="left" aria-label="Module Controls and Explanation">
      <div>
        <h1>Merge Sort — Divide & Conquer Visualization</h1>
        <p class="small">Interactive, step-by-step exploration of how Merge Sort splits arrays and merges them back in sorted order.</p>
      </div>

      <div class="section" aria-labelledby="objective-title">
        <div id="objective-title" style="display:flex; justify-content:space-between; align-items:center;">
          <strong>Learning objective</strong>
          <span class="muted" style="font-size:12px">One concept</span>
        </div>
        <p class="small">After using this module you will be able to:
          - understand how merge sort recursively splits an array into halves,
          - follow the merge step where two sorted halves are compared and combined,
          - observe the cost in comparisons and writes, and step through each elementary action.</p>
      </div>

      <div class="section" aria-labelledby="interaction-title">
        <strong id="interaction-title">Interaction design</strong>
        <p class="small">
          Controls:
          - Generate a random array or enter a custom comma-separated array.
          - Set array size, animation speed.
          - Use Start / Pause / Step / Reset to control playback.
        </p>
        <p class="small">
          Visual & tactile feedback:
          - Compare actions highlight two elements (orange).
          - When an element is taken for merge a temporary tile animates to the merge position.
          - Writes copy merged values back and turn elements green for the merged range.
          - A live counter shows comparisons and writes to reinforce algorithm cost.
        </p>
      </div>

      <div class="section" aria-labelledby="layout-title">
        <strong id="layout-title">Layout description</strong>
        <p class="small">
          - Safe area: 24px padding around the viewport; minimum spacing between interactive elements is 16px.
          - Left column holds controls & descriptions; right column contains the visualization, playback controls and stats.
          - Responsive: on narrow screens the left column stacks above the visual area.
        </p>
      </div>

      <div class="section" aria-labelledby="controls-title" style="margin-top:4px">
        <div id="controls-title" style="display:flex; justify-content:space-between; align-items:center;">
          <strong>Controls</strong>
          <span class="muted" style="font-size:12px">Interactive</span>
        </div>

        <div class="row">
          <label class="block">Array size (3–20)</label>
          <input id="size" type="number" min="3" max="20" value="8" />
          <button id="rand" class="small-btn">Randomize</button>
        </div>

        <div class="row">
          <label class="block" style="flex:1">Custom array (comma-separated)</label>
        </div>
        <div class="row">
          <input id="custom" type="text" placeholder="e.g. 5,2,9,1,6" aria-label="Custom array input"/>
          <button id="load" class="small-btn">Load</button>
        </div>

        <div class="row">
          <label class="block" style="width:100%">Speed (animation)</label>
          <input id="speed" class="slider" type="range" min="0.25" max="3" value="1" step="0.25" />
        </div>

        <div class="row controls" style="margin-top:8px;">
          <button id="start" class="primary">Start</button>
          <button id="step" class="small-btn">Step</button>
          <button id="pause" class="small-btn">Pause</button>
          <button id="reset" class="small-btn">Reset</button>
        </div>

        <div style="margin-top:8px; font-size:13px; color:var(--muted);">
          Tips: Use Step to inspect individual comparisons. Pause anytime to examine the state.
        </div>
      </div>

    </aside>

    <main class="right" aria-label="Visualization and Playback">
      <div class="visual" role="region" aria-label="Merge sort visualization">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="display:flex; flex-direction:column;">
            <strong>Array visualization</strong>
            <div class="muted" style="margin-top:4px; font-size:13px">Colors:
              <span style="display:inline-flex; align-items:center; gap:8px; margin-left:8px;">
                <span class="swatch" style="background:#f97316"></span><span class="muted">compare</span>
                <span style="width:16px"></span>
                <span class="swatch" style="background:#10b981"></span><span class="muted">merged</span>
              </span>
            </div>
          </div>

          <div class="meta" style="min-width:240px;">
            <div class="stats">
              <div class="stat">Comparisons: <span id="comp">0</span></div>
              <div class="stat">Writes: <span id="writes">0</span></div>
            </div>
            <div style="font-size:13px; color:var(--muted);">Step: <span id="stepIndex">0</span>/<span id="totalSteps">0</span></div>
          </div>
        </div>

        <div class="array-area" id="arrayArea" aria-live="polite">
          <div class="array-line" id="arrayLine" aria-hidden="false"></div>
          <div class="temp-layer" id="tempLayer" aria-hidden="true"></div>
        </div>

        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div class="muted" style="font-size:13px">
            Playback: <span id="status">idle</span>
          </div>
          <div style="display:flex; gap:8px; align-items:center;">
            <button id="fast" class="small-btn" title="Speed up">+ Speed</button>
            <button id="slow" class="small-btn" title="Slow down">- Speed</button>
            <button id="explain" class="small-btn" title="Short explanation">Explain</button>
          </div>
        </div>
      </div>

      <div class="section" aria-live="polite">
        <strong>Explanation (brief)</strong>
        <p class="small">
          Merge Sort works by recursively splitting the array until single elements remain, then merging
          pairs of sorted subarrays by repeatedly comparing their front elements and selecting the smaller one.
          This module emphasizes the split boundaries, each compare, and each write (copy back), showing the algorithm's mechanics and cost.
        </p>
      </div>

    </main>
  </div>

  <script>
    // Merge Sort Interactive Module — vanilla JS
    (function(){
      // DOM
      const sizeInput = document.getElementById('size');
      const randBtn = document.getElementById('rand');
      const customInput = document.getElementById('custom');
      const loadBtn = document.getElementById('load');
      const speedInput = document.getElementById('speed');
      const startBtn = document.getElementById('start');
      const stepBtn = document.getElementById('step');
      const pauseBtn = document.getElementById('pause');
      const resetBtn = document.getElementById('reset');
      const fastBtn = document.getElementById('fast');
      const slowBtn = document.getElementById('slow');
      const explainBtn = document.getElementById('explain');

      const arrayLine = document.getElementById('arrayLine');
      const tempLayer = document.getElementById('tempLayer');
      const compCounter = document.getElementById('comp');
      const writesCounter = document.getElementById('writes');
      const statusLabel = document.getElementById('status');
      const stepIndexLabel = document.getElementById('stepIndex');
      const totalStepsLabel = document.getElementById('totalSteps');

      // State
      let initialArray = [];
      let arr = [];
      let steps = []; // recorded actions
      let stepPos = 0;
      let playing = false;
      let speed = parseFloat(speedInput.value) || 1;
      let timer = null;
      let comparisons = 0;
      let writes = 0;

      // visual parameters
      const minSize = 3;
      const maxSize = 20;
      const barWidth = 40;
      const barGap = 8;

      // Helpers
      function randArray(n){
        const a = [];
        for(let i=0;i<n;i++) a.push(Math.floor(Math.random()*90)+10);
        return a;
      }

      function clampSize(v){
        v = Math.max(minSize, Math.min(maxSize, Number(v)||minSize));
        sizeInput.value = v;
        return v;
      }

      // UI init
      function init(){
        clampSize(sizeInput.value);
        initialArray = randArray(Number(sizeInput.value));
        loadArray(initialArray);
      }

      function loadArray(a){
        initialArray = a.slice();
        resetState();
        renderArray(initialArray);
      }

      function resetState(){
        if(timer) { clearTimeout(timer); timer = null; }
        playing = false;
        stepPos = 0;
        comparisons = 0;
        writes = 0;
        compCounter.textContent = '0';
        writesCounter.textContent = '0';
        statusLabel.textContent = 'idle';
        stepIndexLabel.textContent = '0';
        totalStepsLabel.textContent = '0';
        // clear temp layer
        tempLayer.innerHTML = '';
        // clear highlights
        const bars = arrayLine.querySelectorAll('.bar');
        bars.forEach(b=> {
          b.classList.remove('compare');
          b.classList.remove('merged');
          b.style.transform = '';
          b.style.opacity = '1';
        });
      }

      // Render main array as bars positioned absolutely
      function renderArray(a){
        arr = a.slice();
        arrayLine.innerHTML = '';
        tempLayer.innerHTML = '';
        const n = arr.length;
        const containerWidth = arrayLine.clientWidth || arrayLine.getBoundingClientRect().width;
        // compute width allocation
        const totalGap = (n-1) * barGap;
        let available = containerWidth - totalGap;
        let w = barWidth;
        // if doesn't fit, scale width
        const needed = n * w;
        if(needed > containerWidth){
          w = Math.max(28, Math.floor((containerWidth - totalGap) / n));
        }
        const effectiveWidth = w;
        // position bars
        for(let i=0;i<n;i++){
          const el = document.createElement('div');
          el.className = 'bar';
          el.style.width = effectiveWidth + 'px';
          el.style.left = (i*(effectiveWidth + barGap)) + 'px';
          el.dataset.index = i;
          el.dataset.value = String(arr[i]);
          el.innerHTML = '<div class="val">'+arr[i]+'</div>';
          arrayLine.appendChild(el);
        }
      }

      // Record actions with a modified merge sort
      function recordActions(inputArray){
        const a = inputArray.slice();
        const actions = [];
        function mergeSort(l, r){
          if(r - l <= 1) return;
          const mid = Math.floor((l + r)/2);
          actions.push({type:'split', l, r, mid});
          mergeSort(l, mid);
          mergeSort(mid, r);
          // merge
          let i = l, j = mid;
          const temp = [];
          while(i < mid || j < r){
            if(i < mid && j < r){
              actions.push({type:'compare', i, j});
              if(a[i] <= a[j]){
                actions.push({type:'take', from:i, value:a[i]});
                temp.push(a[i]); i++;
              } else {
                actions.push({type:'take', from:j, value:a[j]});
                temp.push(a[j]); j++;
              }
            } else if(i < mid){
              actions.push({type:'take', from:i, value:a[i]});
              temp.push(a[i]); i++;
            } else {
              actions.push({type:'take', from:j, value:a[j]});
              temp.push(a[j]); j++;
            }
          }
          for(let k=l;k<r;k++){
            actions.push({type:'write', index:k, value: temp[k-l]});
            a[k] = temp[k-l];
          }
          actions.push({type:'merged', l, r});
        }
        mergeSort(0, a.length);
        return actions;
      }

      // Playback handlers
      function startPlayback(){
        if(playing) return;
        if(steps.length === 0){
          steps = recordActions(initialArray);
          totalStepsLabel.textContent = steps.length;
        }
        playing = true;
        statusLabel.textContent = 'playing';
        scheduleNext();
      }

      function pausePlayback(){
        playing = false;
        statusLabel.textContent = 'paused';
        if(timer){ clearTimeout(timer); timer = null; }
      }

      function resetPlayback(){
        pausePlayback();
        resetState();
        renderArray(initialArray);
        steps = [];
      }

      // step one action (used by Step button)
      function doStep(){
        if(steps.length === 0){
          steps = recordActions(initialArray);
          totalStepsLabel.textContent = steps.length;
        }
        if(stepPos >= steps.length){
          statusLabel.textContent = 'finished';
          playing = false;
          return;
        }
        const action = steps[stepPos++];
        stepIndexLabel.textContent = stepPos;
        executeAction(action);
      }

      // schedule next automatic step using speed
      function scheduleNext(){
        if(!playing) return;
        if(stepPos >= steps.length){
          statusLabel.textContent = 'finished';
          playing = false;
          return;
        }
        const delayBase = 500; // base ms
        const delay = Math.max(70, delayBase / speed);
        timer = setTimeout(() => {
          doStep();
          scheduleNext();
        }, delay);
      }

      // Execute recorded action and trigger visuals
      function executeAction(action){
        switch(action.type){
          case 'split':
            highlightRange(action.l, action.r, 'split');
            break;
          case 'compare':
            comparisons++;
            compCounter.textContent = String(comparisons);
            highlightCompare(action.i, action.j);
            break;
          case 'take':
            animateTake(action.from, action.value);
            break;
          case 'write':
            writes++;
            writesCounter.textContent = String(writes);
            animateWrite(action.index, action.value);
            break;
          case 'merged':
            markMerged(action.l, action.r);
            break;
          default:
            // noop
            break;
        }
      }

      // Visual helpers
      function highlightRange(l, r, why){
        // subtle: dim other bars, and brighten this range temporarily
        const bars = arrayLine.querySelectorAll('.bar');
        bars.forEach(b=>{
          const idx = Number(b.dataset.index);
          if(idx >= l && idx < r){
            b.style.opacity = '1';
            b.style.transform = 'translateY(-4px)';
          } else {
            b.style.opacity = '0.45';
            b.style.transform = 'translateY(0px) scale(0.98)';
          }
        });
        // remove highlight after short time (but don't block)
        setTimeout(()=> {
          bars.forEach(b=>{
            b.style.opacity = '1';
            b.style.transform = '';
          });
        }, 700 / speed);
      }

      function highlightCompare(i,j){
        const b1 = arrayLine.querySelector('.bar[data-index="'+i+'"]');
        const b2 = arrayLine.querySelector('.bar[data-index="'+j+'"]');
        if(!b1 || !b2) return;
        b1.classList.add('compare');
        b2.classList.add('compare');
        // remove after brief moment
        setTimeout(()=> {
          b1.classList.remove('compare');
          b2.classList.remove('compare');
        }, 400 / speed);
      }

      function animateTake(fromIndex, value){
        // create a temp tile at position of source bar and move it to next merge slot visually above the array center
        const source = arrayLine.querySelector('.bar[data-index="'+fromIndex+'"]');
        if(!source) return;
        const rect = arrayLine.getBoundingClientRect();
        const srcRect = source.getBoundingClientRect();
        const layerRect = tempLayer.getBoundingClientRect();
        const tempEl = document.createElement('div');
        tempEl.className = 'temp';
        tempEl.textContent = value;
        tempLayer.appendChild(tempEl);
        // set initial position relative to layer (absolute)
        const startLeft = srcRect.left - layerRect.left;
        const startTop = srcRect.top - layerRect.top;
        tempEl.style.left = startLeft + 'px';
        tempEl.style.top = startTop + 'px';
        tempEl.style.width = source.offsetWidth + 'px';
        tempEl.style.height = source.offsetHeight + 'px';
        tempEl.style.opacity = '1';
        // compute merge target position: we'll place merges centered horizontally in the merged range area.
        // For simplicity, target y is top: 8px; target x is center of array area (progressively left-to-right).
        const targetTop = 8;
        // compute next slot index based on current number of temps in tempLayer
        const existingTemps = tempLayer.querySelectorAll('.temp');
        const slot = existingTemps.length - 1; // since we've already appended, slot is count-1
        // place distributed across width
        const containerWidth = arrayLine.clientWidth || arrayLine.getBoundingClientRect().width;
        const slotX = Math.max(8, (slot * (source.offsetWidth + barGap)) + 8);
        // animate move
        requestAnimationFrame(()=> {
          tempEl.style.transition = 'transform 420ms cubic-bezier(.2,.9,.2,1), opacity 200ms ease';
          const dx = slotX - startLeft;
          const dy = targetTop - startTop;
          tempEl.style.transform = `translate(${dx}px, ${dy}px)`;
        });
        // leave the temp in layer for later "write" step which will remove it when copying back
        // after a timeout, we may dim the source to indicate it's been used
        setTimeout(()=> {
          if(source) source.classList.add('source');
        }, 200 / speed);
      }

      function animateWrite(index, value){
        // find main bar at index and set new value + flash merged color
        const target = arrayLine.querySelector('.bar[data-index="'+index+'"]');
        if(!target) return;
        // optionally, find a temp tile (FIFO) and animate it to target
        const temp = tempLayer.querySelector('.temp');
        if(temp){
          const layerRect = tempLayer.getBoundingClientRect();
          const tarRect = target.getBoundingClientRect();
          const tLeft = parseFloat(temp.style.left || 0);
          const tTop = parseFloat(temp.style.top || 0);
          const dx = tarRect.left - layerRect.left - tLeft;
          const dy = tarRect.top - layerRect.top - tTop;
          temp.style.transform = `translate(${dx}px, ${dy}px)`;
          // after it arrives, update main and remove temp
          setTimeout(()=> {
            target.dataset.value = String(value);
            target.querySelector('.val').textContent = String(value);
            target.classList.add('merged');
            target.classList.remove('source');
            // remove the temp
            if(temp && temp.parentNode) temp.parentNode.removeChild(temp);
          }, 380 / speed);
        } else {
          // fallback: instant update with flash
          target.dataset.value = String(value);
          target.querySelector('.val').textContent = String(value);
          target.classList.add('merged');
          target.classList.remove('source');
        }

        // clean merged class after a while
        setTimeout(()=> {
          if(target) target.classList.remove('merged');
        }, 900 / speed);
      }

      function markMerged(l,r){
        // mark these indices as sorted (green) briefly
        for(let k=l;k<r;k++){
          const b = arrayLine.querySelector('.bar[data-index="'+k+'"]');
          if(b){
            b.classList.add('merged');
            b.style.opacity = '1';
            b.style.transform = '';
          }
        }
        setTimeout(()=> {
          for(let k=l;k<r;k++){
            const b = arrayLine.querySelector('.bar[data-index="'+k+'"]');
            if(b) b.classList.remove('merged');
          }
        }, 900 / speed);
      }

      // UI events
      randBtn.addEventListener('click', ()=>{
        const n = clampSize(sizeInput.value);
        const a = randArray(n);
        loadArray(a);
      });

      loadBtn.addEventListener('click', ()=>{
        const txt = customInput.value.trim();
        if(!txt) return;
        const parts = txt.split(',').map(s=>s.trim()).filter(Boolean);
        if(parts.length < minSize || parts.length > maxSize){
          alert('Please enter between '+minSize+' and '+maxSize+' numbers.');
          return;
        }
        const nums = [];
        for(const p of parts){
          const v = Number(p);
          if(Number.isFinite(v)){
            nums.push(v);
          } else {
            alert('Invalid value: ' + p);
            return;
          }
        }
        sizeInput.value = nums.length;
        loadArray(nums);
      });

      sizeInput.addEventListener('change', ()=>{
        const n = clampSize(sizeInput.value);
        const a = randArray(n);
        loadArray(a);
      });

      speedInput.addEventListener('input', ()=>{
        speed = parseFloat(speedInput.value) || 1;
      });

      startBtn.addEventListener('click', ()=>{
        if(playing) return;
        if(stepPos === 0 && steps.length === 0){
          steps = recordActions(initialArray);
          totalStepsLabel.textContent = steps.length;
        }
        startPlayback();
      });

      pauseBtn.addEventListener('click', ()=> pausePlayback());

      stepBtn.addEventListener('click', ()=>{
        pausePlayback();
        doStep();
      });

      resetBtn.addEventListener('click', ()=>{
        resetPlayback();
      });

      fastBtn.addEventListener('click', ()=>{
        speed = Math.min(3, speed + 0.25);
        speedInput.value = String(speed);
      });
      slowBtn.addEventListener('click', ()=>{
        speed = Math.max(0.25, speed - 0.25);
        speedInput.value = String(speed);
      });

      explainBtn.addEventListener('click', ()=>{
        alert('Merge Sort: recursively split the array into halves until you have single-element arrays. Then repeatedly compare the first elements of two sorted halves and move the smaller into a result array. After merging, write the result back into the original range. This visualization shows each compare, take (moving into merge), and write (copy back).');
      });

      // keep labels in sync
      setInterval(()=>{
        stepIndexLabel.textContent = String(stepPos);
      }, 200);

      // initialize
      init();

      // handle window resize to re-render array positions
      let resizeTimer = null;
      window.addEventListener('resize', ()=>{
        if(resizeTimer) clearTimeout(resizeTimer);
        resizeTimer = setTimeout(()=> {
          renderArray(initialArray);
        }, 200);
      });
    })();
  </script>
</body>
</html>