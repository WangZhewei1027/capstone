<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Recursion Interactive Module — Call Stack & Tree</title>
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#60a5fa;
      --muted:#94a3b8;
      --card:#0b1728;
      --success:#34d399;
      --danger:#fb7185;
      --glass: rgba(255,255,255,0.03);
      --radius:12px;
      --gap:16px; /* minimum spacing */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      padding:24px; /* safe area margin */
      background: linear-gradient(180deg,#07102a 0%, #071021 50%, #04101b 100%);
      color:#e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      line-height:1.4;
      -webkit-user-select:none;
    }

    /* Layout */
    .container{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }

    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      border-radius:var(--radius);
      padding:20px;
      min-width:280px;
      box-shadow:0 6px 24px rgba(2,6,23,0.6);
    }

    /* Left column: Info and controls */
    .left{
      flex:0 1 320px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    h1{
      font-size:18px;
      margin:0 0 6px 0;
      color:var(--accent);
      letter-spacing:0.2px;
    }
    .subtitle{
      margin:0 0 12px 0;
      color:var(--muted);
      font-size:13px;
    }

    .meta-block{
      background:var(--glass);
      border-radius:10px;
      padding:12px;
    }
    .meta-block h3{
      margin:0 0 8px 0;
      font-size:13px;
      color:#cfe8ff;
    }
    .meta-block p{
      margin:0;
      font-size:13px;
      color:var(--muted);
    }

    /* Controls */
    .controls{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .row{
      display:flex;
      gap:12px;
      align-items:center;
    }
    label{font-size:13px;color:var(--muted);min-width:80px}
    input[type="range"]{
      -webkit-appearance:none;
      width:100%;
      height:8px;
      background:linear-gradient(90deg,var(--accent), rgba(96,165,250,0.5));
      border-radius:999px;
      outline:none;
      margin:0;
    }
    input[type="number"]{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      padding:8px 10px;
      border-radius:8px;
      width:84px;
    }
    .buttons{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }
    button{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.04);
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      min-width:64px;
      transition:all 160ms ease;
      font-size:13px;
    }
    button.primary{
      background:linear-gradient(180deg, var(--accent), #2186f4);
      color:#021026;
      border:1px solid rgba(255,255,255,0.06);
      box-shadow:0 6px 18px rgba(33,134,244,0.12);
    }
    button:active{transform:translateY(1px) scale(0.998)}
    button[disabled]{opacity:0.5;cursor:not-allowed}

    /* Visual area */
    .visual{
      flex:1 1 640px;
      min-width:320px;
      display:flex;
      gap:var(--gap);
      flex-direction:column;
    }
    .stage{
      display:flex;
      gap:var(--gap);
      min-height:360px;
    }

    .stack-area, .tree-area{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:12px;
      padding:16px;
      flex:1 1 0;
      min-width:280px;
      position:relative;
      overflow:hidden;
    }
    .area-title{
      display:flex;
      align-items:center;
      gap:10px;
      margin-bottom:12px;
    }
    .area-title h4{margin:0;font-size:14px;color:var(--accent)}
    .area-title p{margin:0;font-size:12px;color:var(--muted)}

    /* Stack frames */
    .stack{
      display:flex;
      flex-direction:column-reverse;
      gap:12px;
      align-items:center;
      padding-bottom:8px;
      height:calc(100% - 36px);
      overflow:auto;
    }
    .frame{
      width:220px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015));
      border:1px solid rgba(255,255,255,0.04);
      padding:10px;
      border-radius:10px;
      color:var(--muted);
      text-align:left;
      transform-origin:center;
      transition:transform 240ms cubic-bezier(.2,.9,.2,1), opacity 200ms ease;
      box-shadow:0 8px 20px rgba(2,6,23,0.6);
    }
    .frame.push{
      transform: translateY(-8px) scale(1.02);
      opacity:0.98;
    }
    .frame.returning{
      border-left:4px solid var(--success);
      transform:translateX(6px) scale(1);
      opacity:0.95;
    }
    .frame .title{font-weight:600;color:#e6f6ff;font-size:13px}
    .frame .body{font-size:13px;color:var(--muted);margin-top:6px}

    /* Tree visualization as nested nodes */
    .tree{
      display:block;
      height: calc(100% - 36px);
      overflow:auto;
      padding:8px 4px;
    }
    .node{
      display:inline-flex;
      align-items:center;
      gap:10px;
      margin:6px 0;
      transition:opacity 240ms ease, transform 240ms ease;
      opacity:0;
      transform:scale(0.9) translateY(6px);
    }
    .node.visible{
      opacity:1;
      transform:scale(1) translateY(0);
    }
    .node .circle{
      width:46px;height:46px;border-radius:50%;
      display:flex;align-items:center;justify-content:center;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      font-weight:700;color:var(--accent);
      box-shadow:0 8px 18px rgba(2,6,23,0.45);
    }
    .node .label{color:var(--muted);font-size:13px}

    .node .sub{
      margin-left:18px;
      border-left:2px dashed rgba(255,255,255,0.03);
      padding-left:12px;
    }

    /* Code pane */
    .code{
      background:#071226;
      border-radius:10px;
      padding:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Helvetica Neue", monospace;
      font-size:13px;
      color:#cfe8ff;
      border:1px solid rgba(255,255,255,0.03);
      margin-top:var(--gap);
      min-height:120px;
    }
    .line{display:block;padding:4px 6px;border-radius:6px}
    .lineno{display:inline-block;width:34px;color:var(--muted);font-size:12px}
    .code .highlight{
      background:linear-gradient(90deg, rgba(96,165,250,0.08), rgba(33,134,244,0.06));
      color:var(--accent);
      box-shadow:inset 0 0 0 1px rgba(96,165,250,0.04);
    }

    /* Footer / result */
    .result{
      margin-top:12px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:flex-start;
    }
    .pill{
      padding:8px 12px;border-radius:999px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03); color:var(--muted);font-size:13px;
    }

    /* Responsive */
    @media (max-width:900px){
      .stage{flex-direction:column}
      .container{padding:0}
      body{padding:16px}
    }
  </style>
</head>
<body>
  <div class="container" role="main">
    <div class="left panel" aria-labelledby="module-title">
      <h1 id="module-title">Recursion: Visualizing the Call Stack & Return Flow</h1>
      <p class="subtitle">Step through a recursive factorial function and watch calls push onto the stack, expand a recursive tree, and then return values back up.</p>

      <div class="meta-block" aria-labelledby="concept-title">
        <h3 id="concept-title">Concept Title</h3>
        <p>Recursion — understanding function calls, local frames, and how results bubble up through the call stack.</p>
      </div>

      <div class="meta-block" aria-labelledby="learning-objective">
        <h3 id="learning-objective">Learning Objective</h3>
        <p>After interacting you should be able to predict how many frames a recursive factorial(n) call creates, visualize the order calls occur, and understand how return values are combined back to the original caller.</p>
      </div>

      <div class="meta-block" aria-labelledby="interaction-design">
        <h3 id="interaction-design">Interaction Design</h3>
        <p>
          Use the slider or number input to pick n (1–10). Press "Step" to advance one event, "Back" to reverse, or "Run" to animate all events. Each step either "pushes" a frame (a function call) or "returns" a value — frames animate into the stack, tree nodes fade in, and code lines are highlighted to map actions to source code.
        </p>
      </div>

      <div class="controls" aria-label="Controls">
        <div class="row">
          <label for="n">n (1–10)</label>
          <input id="n" type="number" min="1" max="10" value="5" aria-label="Recursion input number"/>
        </div>
        <div class="row">
          <label for="range">Quick slider</label>
          <input id="range" type="range" min="1" max="10" value="5" aria-label="Recursion slider"/>
        </div>

        <div class="buttons">
          <button id="stepBtn" title="Advance one step">Step</button>
          <button id="backBtn" title="Go back one step">Back</button>
          <button id="runBtn" class="primary" title="Run animation">Run</button>
          <button id="resetBtn" title="Reset">Reset</button>
        </div>

        <div class="row" role="status" aria-live="polite" style="margin-top:6px">
          <div class="pill" id="status">Idle</div>
          <div class="pill" id="currentEvent" style="background:rgba(96,165,250,0.06);color:var(--accent)">Event: 0 / 0</div>
        </div>

        <div class="code" aria-hidden="false" aria-label="Code example">
          <div class="line"><span class="lineno">1</span> <code>function factorial(n) {</code></div>
          <div class="line"><span class="lineno">2</span> <code>&nbsp;&nbsp;if (n === 1) return 1;</code></div>
          <div class="line highlight" id="line3"><span class="lineno">3</span> <code>&nbsp;&nbsp;let t = factorial(n - 1);</code></div>
          <div class="line"><span class="lineno">4</span> <code>&nbsp;&nbsp;return n * t;</code></div>
          <div class="line"><span class="lineno">5</span> <code>}</code></div>
        </div>

      </div>
    </div>

    <div class="visual panel" aria-labelledby="visual-title">
      <div class="area-title" id="visual-title" style="margin-bottom:0">
        <h4>Interactive Visualization</h4>
        <p style="margin-left:auto;color:var(--muted);font-size:13px">Push / Return animations & code highlighting</p>
      </div>

      <div class="stage">
        <div class="stack-area" aria-label="Call stack area">
          <div class="area-title">
            <h4>Call Stack</h4>
            <p>Newest frame appears on top (bottom of column, reversed visually)</p>
          </div>
          <div class="stack" id="stack" role="list" aria-live="polite"></div>
        </div>

        <div class="tree-area" aria-label="Recursion tree">
          <div class="area-title">
            <h4>Recursive Tree</h4>
            <p>Each node is a call. Nodes appear when a frame is pushed; on return, node shows the return value.</p>
          </div>
          <div class="tree" id="tree" role="tree"></div>
        </div>
      </div>

      <div class="result" aria-live="polite">
        <div class="pill" id="finalResult">Result: —</div>
        <div class="pill" id="framesCount">Frames: 0</div>
      </div>
    </div>
  </div>

  <script>
    /*
      Recursion Visualizer
      - Simulates factorial recursion and records events (push/return)
      - Animates push: add frame to stack and node to tree
      - Animates return: mark frame as returning, show return value on node, pop from stack
      - Controls: step, back, run, reset
      - Code highlight maps to events
    */

    (function(){
      // Elements
      const nInput = document.getElementById('n');
      const range = document.getElementById('range');
      const stepBtn = document.getElementById('stepBtn');
      const backBtn = document.getElementById('backBtn');
      const runBtn = document.getElementById('runBtn');
      const resetBtn = document.getElementById('resetBtn');
      const status = document.getElementById('status');
      const curEvent = document.getElementById('currentEvent');
      const stackEl = document.getElementById('stack');
      const treeEl = document.getElementById('tree');
      const finalResult = document.getElementById('finalResult');
      const framesCount = document.getElementById('framesCount');
      const line3 = document.getElementById('line3');

      // State
      let events = []; // {type: 'push'|'return', n: number, id: string, result?: number}
      let pointer = -1; // index of last-applied event
      let nodesById = new Map();
      let framesById = new Map();
      let running = false;
      let playInterval = null;
      const animationDelay = 450;

      // Utilities
      function uid(prefix='id'){
        return prefix + Math.random().toString(36).slice(2,9);
      }

      // Build events by running a recursive function that logs actions
      function buildEvents(n){
        events = [];
        function fact(x){
          const id = uid('f');
          events.push({type:'push', n:x, id});
          if(x === 1){
            events.push({type:'return', n:x, id, result:1});
            return 1;
          } else {
            const sub = fact(x-1);
            const res = x * sub;
            events.push({type:'return', n:x, id, result:res});
            return res;
          }
        }
        const final = fact(n);
        // After building, we have pushes and returns interleaved.
        return {events, final};
      }

      // Render helpers
      function createFrame(event){
        const el = document.createElement('div');
        el.className = 'frame push';
        el.dataset.id = event.id;
        el.setAttribute('role','listitem');
        el.innerHTML = `<div class="title">factorial(${event.n})</div>
                        <div class="body">state: <span class="state">waiting</span></div>`;
        return el;
      }
      function createNode(event){
        const el = document.createElement('div');
        el.className = 'node';
        el.dataset.id = event.id;
        el.setAttribute('role','treeitem');
        el.innerHTML = `<div class="circle">${event.n}</div>
                        <div class="label">call: factorial(${event.n})</div>`;
        return el;
      }

      // Find insertion parent in tree for a push event:
      // The parent is the most recent pushed node that hasn't yet had its child created for this n.
      // We'll use the current stack order to decide parent.
      function findParentId(){
        // The top of stack (last element's dataset) is the parent candidate.
        // Get latest frame in DOM
        const frames = Array.from(stackEl.querySelectorAll('.frame'));
        if(frames.length === 0) return null;
        const top = frames[frames.length - 1];
        return top ? top.dataset.id : null;
      }

      // Apply next event (pointer -> pointer+1)
      function stepForward(){
        if(pointer >= events.length - 1) return;
        pointer++;
        const ev = events[pointer];
        curEvent.textContent = `Event: ${pointer+1} / ${events.length}`;
        if(ev.type === 'push'){
          status.textContent = `Pushing factorial(${ev.n})`;
          // Add frame
          const frame = createFrame(ev);
          framesById.set(ev.id, frame);
          // push visually (stack is column-reverse so we append to container)
          stackEl.appendChild(frame);
          // slight animation
          requestAnimationFrame(()=> frame.classList.add('push'));
          // Add node to tree under parent
          const node = createNode(ev);
          nodesById.set(ev.id, node);
          // find parent and append into its sub container or root
          const parentId = findParentId();
          if(parentId && parentId !== ev.id){
            const parentNode = nodesById.get(parentId);
            // find or create sub container
            let sub = parentNode.querySelector('.sub');
            if(!sub){
              sub = document.createElement('div');
              sub.className = 'sub';
              parentNode.appendChild(sub);
            }
            sub.appendChild(node);
          } else {
            treeEl.appendChild(node);
          }
          // reveal animation
          setTimeout(()=>node.classList.add('visible'), 20);
          // code highlight: show line with recursive call briefly
          highlightLine(3);
          updateCounts();
        } else if(ev.type === 'return'){
          status.textContent = `Returning ${ev.result} from factorial(${ev.n})`;
          // mark frame as returning then remove after delay
          const frame = framesById.get(ev.id);
          if(frame){
            frame.classList.remove('push');
            frame.classList.add('returning');
            frame.querySelector('.state').textContent = `returned ${ev.result}`;
          }
          // update node label to include return
          const node = nodesById.get(ev.id);
          if(node){
            node.querySelector('.label').textContent = `factorial(${ev.n}) → ${ev.result}`;
            node.classList.add('visible');
          }
          // Simulate a short pause to show return, then pop frame for UX
          setTimeout(()=>{
            if(frame && frame.parentElement) frame.parentElement.removeChild(frame);
            // leave node visible to show final value
            updateCounts();
          }, animationDelay - 50);
          // highlight multiplication/return area by briefly toggling code highlight off then on
          highlightLine(4);
        }
        // Update final result if last event is a return for original call
        const last = events[events.length - 1];
        if(pointer === events.length - 1 && last.type === 'return'){
          finalResult.textContent = `Result: ${last.result}`;
        } else {
          finalResult.textContent = `Result: —`;
        }
      }

      function stepBackward(){
        if(pointer < 0) return;
        const ev = events[pointer];
        curEvent.textContent = `Event: ${pointer} / ${events.length}`;
        if(ev.type === 'push'){
          // reverse pushing: remove frame and node if they exist
          const frame = framesById.get(ev.id);
          if(frame && frame.parentElement) frame.parentElement.removeChild(frame);
          const node = nodesById.get(ev.id);
          if(node && node.parentElement) node.parentElement.removeChild(node);
          framesById.delete(ev.id);
          nodesById.delete(ev.id);
          status.textContent = `Undo push factorial(${ev.n})`;
        } else if(ev.type === 'return'){
          // reverse return: recreate the frame and reset node to pre-return
          const frame = createFrame(ev);
          framesById.set(ev.id, frame);
          stackEl.appendChild(frame);
          const node = nodesById.get(ev.id);
          if(node){
            node.querySelector('.label').textContent = `call: factorial(${ev.n})`;
          } else {
            // create node
            const nodeNew = createNode(ev);
            nodesById.set(ev.id, nodeNew);
            treeEl.appendChild(nodeNew);
            nodeNew.classList.add('visible');
          }
          status.textContent = `Undo return factorial(${ev.n})`;
        }
        pointer--;
        // Update final result
        const last = events[events.length - 1];
        if(pointer >= 0 && events[pointer].type === 'return' && events[pointer].id === last.id){
          finalResult.textContent = `Result: ${events[pointer].result}`;
        } else {
          finalResult.textContent = `Result: —`;
        }
        updateCounts();
      }

      function highlightLine(num){
        // Blink highlight on the code line element(s)
        line3.classList.add('highlight');
        setTimeout(()=>line3.classList.remove('highlight'), 300);
      }

      function updateCounts(){
        framesCount.textContent = `Frames: ${stackEl.querySelectorAll('.frame').length}`;
      }

      // Control bindings
      function prepare(n){
        // reset visuals and build events
        clearAll();
        const built = buildEvents(n);
        events = built.events;
        pointer = -1;
        curEvent.textContent = `Event: 0 / ${events.length}`;
        status.textContent = `Prepared factorial(${n}) — ${events.length} events`;
        finalResult.textContent = `Result: —`;
        framesCount.textContent = `Frames: 0`;
      }

      function clearAll(){
        // clear DOM elements and caches
        stackEl.innerHTML = '';
        treeEl.innerHTML = '';
        framesById.clear();
        nodesById.clear();
        pointer = -1;
        if(playInterval) {clearInterval(playInterval); playInterval = null}
        running = false;
        runBtn.textContent = 'Run';
        status.textContent = 'Idle';
      }

      function runAll(){
        if(events.length === 0) return;
        if(running){
          // pause
          running = false;
          runBtn.textContent = 'Run';
          if(playInterval) {clearInterval(playInterval); playInterval = null}
          status.textContent = 'Paused';
          return;
        }
        running = true;
        runBtn.textContent = 'Pause';
        status.textContent = 'Running';
        playInterval = setInterval(()=>{
          if(pointer < events.length - 1){
            stepForward();
          } else {
            clearInterval(playInterval);
            playInterval = null;
            running = false;
            runBtn.textContent = 'Run';
            status.textContent = 'Finished';
          }
        }, animationDelay);
      }

      // Wire events
      range.addEventListener('input', (e)=>{
        nInput.value = e.target.value;
      });
      nInput.addEventListener('change', (e)=>{
        let v = Number(e.target.value);
        if(isNaN(v)) v = 1;
        v = Math.max(1, Math.min(10, Math.floor(v)));
        nInput.value = v;
        range.value = v;
        prepare(v);
      });

      stepBtn.addEventListener('click', ()=>{
        if(pointer < events.length - 1){
          stepForward();
        } else {
          status.textContent = 'No more events';
        }
      });
      backBtn.addEventListener('click', ()=>{
        if(pointer >= 0) stepBackward();
        else status.textContent = 'At beginning';
      });
      runBtn.addEventListener('click', ()=>{
        runAll();
      });
      resetBtn.addEventListener('click', ()=>{
        const v = Number(nInput.value) || 1;
        clearAll();
        prepare(v);
      });

      // Keyboard accessibility: space to step
      document.addEventListener('keydown',(e)=>{
        if(e.key === ' ' && document.activeElement.tagName !== 'INPUT'){
          e.preventDefault();
          stepBtn.click();
        }
      });

      // Initialize
      (function init(){
        const v = Number(nInput.value) || 5;
        range.value = v;
        prepare(v);
      })();
    })();
  </script>
</body>
</html>