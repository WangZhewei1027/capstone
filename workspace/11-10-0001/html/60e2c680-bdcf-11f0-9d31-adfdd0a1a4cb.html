<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Linear Regression Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --card: #071024;
      --accent: #00b4d8;
      --muted: #94a3b8;
      --good: #22c55e;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.035);
      --transition: 260ms cubic-bezier(.2,.9,.3,1);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color-scheme: dark;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#020617 0%, #071028 60%);
      color: #e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app{
      box-sizing:border-box;
      padding:var(--safe-margin);
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    /* Header / meta info */
    .meta {
      display:flex;
      justify-content:space-between;
      gap:var(--gap);
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .title {
      min-width:0;
    }
    .title h1 {
      margin:0 0 6px 0;
      font-size:20px;
      line-height:1.1;
      letter-spacing: -0.2px;
    }
    .title p {
      margin:0;
      color:var(--muted);
      font-size:13px;
    }
    .objectives {
      background:var(--glass);
      border-radius:10px;
      padding:12px;
      min-width:260px;
      max-width:420px;
      font-size:13px;
      color:#d8eefd;
      border:1px solid rgba(255,255,255,0.03);
    }
    .objectives small { color:var(--muted); display:block; margin-bottom:6px; font-weight:600; font-size:11px; text-transform:uppercase; letter-spacing:1px;}

    /* Main layout */
    .panel {
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:var(--gap);
      align-items:start;
    }
    @media (max-width:920px){
      .panel { grid-template-columns: 1fr; }
    }

    /* Controls card */
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:16px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      border:1px solid rgba(255,255,255,0.03);
    }
    .controls h3 {
      margin:0 0 8px 0;
      font-size:14px;
    }
    .controls p {
      margin:0 0 12px 0;
      color:var(--muted);
      font-size:13px;
    }
    .control-row {
      display:flex;
      gap:12px;
      align-items:center;
      margin-bottom:12px;
    }
    .control-row label { font-size:13px; min-width:110px; color:var(--muted); }
    .control-row input[type="range"] {
      -webkit-appearance:none;
      width:100%;
      height:6px;
      background:rgba(255,255,255,0.04);
      border-radius:6px;
      outline:none;
    }
    .control-row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance:none;
      width:14px;
      height:14px;
      background:var(--accent);
      border-radius:50%;
      box-shadow:0 2px 6px rgba(0,0,0,0.5);
      border:2px solid rgba(255,255,255,0.06);
    }
    .btn-row {
      display:flex;
      gap:12px;
      margin-top:6px;
      flex-wrap:wrap;
    }
    button {
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      color: #e6eef8;
      border:1px solid rgba(255,255,255,0.04);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      transition:var(--transition);
      font-size:13px;
    }
    button:hover { transform:translateY(-2px); }
    button.primary{
      background: linear-gradient(90deg, var(--accent), #0077b6);
      border: none;
    }
    button.warn { background: linear-gradient(90deg,#ff7b7b,#ff5252); border:none; }
    .small { font-size:12px; padding:6px 8px; }

    .metric {
      display:flex;
      justify-content:space-between;
      background:rgba(255,255,255,0.02);
      padding:10px;
      border-radius:8px;
      font-size:13px;
      margin-bottom:8px;
      border:1px solid rgba(255,255,255,0.015);
    }
    .metric b { color:#fff; }

    /* Plot card */
    .plot-card {
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .plot {
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:12px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:380px;
    }
    .plot-header {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }
    .plot-header .explain { color:var(--muted); font-size:13px; }
    .canvas-wrap {
      width:100%;
      height:480px;
      position:relative;
    }
    @media (max-width:920px){
      .canvas-wrap { height:360px; }
    }
    svg { width:100%; height:100%; display:block; border-radius:8px; }

    /* Accessibility focus outlines */
    button:focus, input[type="range"]:focus, .draggable:focus {
      outline:3px solid rgba(0,180,216,0.16);
      outline-offset:2px;
    }

    /* Residuals style */
    .residual {
      stroke:rgba(255,255,255,0.25);
      stroke-width:1.5;
      stroke-dasharray:3 3;
    }
    .regression-line {
      stroke: #ffd166;
      stroke-width:2.5;
      stroke-linecap:round;
    }
    .ols-line {
      stroke: #90ee90;
      stroke-width:2;
      stroke-dasharray:6 4;
    }
    .point {
      fill: #00b4d8;
      stroke: rgba(0,0,0,0.3);
      stroke-width:1;
      cursor:grab;
    }
    .point:active { cursor:grabbing; }

    .footer-note {
      color:var(--muted);
      font-size:13px;
    }

  </style>
</head>
<body>
  <div class="app" role="main">
    <!-- Header: Title + Learning Objective -->
    <div class="meta">
      <div class="title" aria-hidden="false">
        <h1>Linear Regression — Interactive Exploration</h1>
        <p>Drag data points, adjust the line, fit with analytic OLS or animate gradient descent to see how the model learns.</p>
      </div>

      <div class="objectives" role="region" aria-label="Learning objective">
        <small>Learning Objective</small>
        <div><strong>After interacting with this module you will:</strong></div>
        <ul style="margin:8px 0 0 16px; padding:0; color:var(--muted); font-size:13px;">
          <li>Understand slope and intercept and how they shape the best-fit line.</li>
          <li>See residuals and the sum of squared errors (SSE) change as points or the line change.</li>
          <li>Observe analytic OLS vs iterative gradient descent convergence.</li>
        </ul>
      </div>
    </div>

    <!-- Main panel: controls + plot -->
    <div class="panel">

      <!-- Controls column -->
      <div class="card controls" aria-label="Controls">
        <h3>Interaction Design</h3>
        <p>Manipulate data and model. The visual updates show the relationship between parameters and error.</p>

        <div class="control-row" style="margin-top:6px;">
          <label for="mode">Mode</label>
          <select id="mode" aria-label="Mode selector" style="padding:8px; border-radius:8px; background:transparent; color:inherit;">
            <option value="manual">Manual (drag or sliders)</option>
            <option value="auto">Auto-fit on drag</option>
          </select>
        </div>

        <div class="control-row">
          <label for="slope">Slope (m)</label>
          <input id="slope" type="range" min="-5" max="5" step="0.01" value="1" />
          <div style="width:64px; text-align:right; font-weight:600;" id="slopeVal">1.00</div>
        </div>

        <div class="control-row">
          <label for="intercept">Intercept (b)</label>
          <input id="intercept" type="range" min="-50" max="50" step="0.1" value="0" />
          <div style="width:64px; text-align:right; font-weight:600;" id="interceptVal">0.0</div>
        </div>

        <div class="control-row">
          <label for="lr">GD lr</label>
          <input id="lr" type="range" min="0.0005" max="0.1" step="0.0005" value="0.01" />
          <div style="width:64px; text-align:right; font-weight:600;" id="lrVal">0.010</div>
        </div>

        <div style="margin-top:6px;">
          <div class="btn-row" role="group" aria-label="Actions">
            <button id="fitBtn" class="primary" title="Compute analytic OLS">Fit (Analytic OLS)</button>
            <button id="gdBtn" class="small" title="Animate gradient descent">Start GD</button>
            <button id="toggleResiduals" class="small" title="Show or hide residuals">Toggle Residuals</button>
            <button id="resetData" class="small" title="Randomize dataset">Reset Data</button>
            <button id="randomOutlier" class="small" title="Add a random outlier">Add Outlier</button>
          </div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03); margin:12px 0;" />

        <div>
          <div class="metric"><span>Current slope (m)</span><b id="mMetric">1.00</b></div>
          <div class="metric"><span>Intercept (b)</span><b id="bMetric">0.0</b></div>
          <div class="metric"><span>Sum of Squared Errors (SSE)</span><b id="sseMetric">0.00</b></div>
          <div class="metric"><span>R²</span><b id="r2">0.00</b></div>
        </div>

        <div style="margin-top:10px; color:var(--muted); font-size:13px;">
          <strong>Interaction Design (text):</strong>
          <ol style="margin:8px 0 0 18px; padding:0;">
            <li>Drag points to change data. If Mode=Auto-fit, OLS updates immediately.</li>
            <li>Adjust slope/intercept sliders to experiment with the model manually.</li>
            <li>Click Fit to compute analytic OLS (yellow dashed shows iterative GD).</li>
            <li>Start GD to animate gradient descent; watch SSE decrease and the line converge.</li>
            <li>Toggle residuals to see vertical errors between points and the line.</li>
          </ol>
        </div>
      </div>

      <!-- Plot and explanations -->
      <div class="plot-card">
        <div class="plot">
          <div class="plot-header">
            <div>
              <strong>Plot</strong>
              <div class="explain">Blue points are data. Yellow line is the current model. Green dashed line indicates analytic OLS fit.</div>
            </div>
            <div style="display:flex; gap:12px; align-items:center;">
              <div class="footer-note">Drag points or use controls. Use keyboard arrows when a point is focused.</div>
            </div>
          </div>

          <!-- SVG Canvas -->
          <div class="canvas-wrap" role="region" aria-label="Scatter plot with regression line">
            <svg id="svg" viewBox="0 0 800 520" preserveAspectRatio="xMidYMid meet" tabindex="0" aria-hidden="false">
              <defs>
                <linearGradient id="gridGrad" x1="0" x2="0" y1="0" y2="1">
                  <stop offset="0%" stop-color="rgba(255,255,255,0.02)"></stop>
                  <stop offset="100%" stop-color="rgba(255,255,255,0.01)"></stop>
                </linearGradient>
              </defs>

              <!-- background rect for pointer capture -->
              <rect x="0" y="0" width="800" height="520" fill="transparent"></rect>

              <!-- axes and grids -->
              <g id="grid"></g>
              <g id="axes"></g>

              <!-- regression lines -->
              <line id="regLine" class="regression-line" x1="0" y1="0" x2="800" y2="0" stroke-linejoin="round" stroke-linecap="round"/>
              <line id="olsLine" class="ols-line" x1="0" y1="0" x2="800" y2="0" style="opacity:0" />

              <!-- residuals -->
              <g id="residuals"></g>

              <!-- points -->
              <g id="points"></g>
            </svg>
          </div>

        </div>

        <div style="display:flex; gap:var(--gap); align-items:flex-start; flex-wrap:wrap;">
          <div style="flex:1; min-width:220px;">
            <h4 style="margin:0 0 8px 0;">Layout Description</h4>
            <p style="margin:0; color:var(--muted); font-size:13px;">
              Safe area margins = 24px. Controls are left column, visual plot on the right. Spacing between controls >= 16px.
              The SVG canvas is responsive and scales while keeping control sizes comfortable. Interactive elements have focus outlines for keyboard users.
            </p>
          </div>
          <div style="min-width:220px;">
            <h4 style="margin:0 0 8px 0;">Concept Title</h4>
            <p style="margin:0; color:var(--muted); font-size:13px;">Simple Linear Regression: Fitting a line y = m*x + b to minimize SSE</p>
          </div>
        </div>

      </div>
    </div>
  </div>

  <script>
    /******************************************************************
     * Interactive Linear Regression Module (Vanilla JS)
     * Features:
     * - Draggable points (pointer + keyboard)
     * - Slope/intercept sliders for manual control
     * - Analytic OLS fit (closed-form)
     * - Gradient descent animation for m,b
     * - Residual visualization
     *
     * Accessibility:
     * - Buttons and sliders labeled
     * - Points focusable for keyboard nudging
     *
     * Layout constraint: safe margin 24px enforced via CSS.
     ******************************************************************/

    (function(){
      // SVG & layout settings
      const svg = document.getElementById('svg');
      const ptsLayer = document.getElementById('points');
      const resLayer = document.getElementById('residuals');
      const gridLayer = document.getElementById('grid');
      const axesLayer = document.getElementById('axes');
      const regLine = document.getElementById('regLine');
      const olsLine = document.getElementById('olsLine');

      // controls
      const slopeRange = document.getElementById('slope');
      const interceptRange = document.getElementById('intercept');
      const slopeVal = document.getElementById('slopeVal');
      const interceptVal = document.getElementById('interceptVal');
      const lrRange = document.getElementById('lr');
      const lrVal = document.getElementById('lrVal');
      const fitBtn = document.getElementById('fitBtn');
      const gdBtn = document.getElementById('gdBtn');
      const resetDataBtn = document.getElementById('resetData');
      const toggleResidualsBtn = document.getElementById('toggleResiduals');
      const modeSelect = document.getElementById('mode');
      const randomOutlierBtn = document.getElementById('randomOutlier');

      const mMetric = document.getElementById('mMetric');
      const bMetric = document.getElementById('bMetric');
      const sseMetric = document.getElementById('sseMetric');
      const r2Metric = document.getElementById('r2');

      const POINT_RADIUS = 7;
      const WIDTH = 800, HEIGHT = 520;
      const MARGIN = {left:60, right:30, top:20, bottom:60};
      const PLOT_WIDTH = WIDTH - MARGIN.left - MARGIN.right;
      const PLOT_HEIGHT = HEIGHT - MARGIN.top - MARGIN.bottom;

      // Data space ranges
      let xMin = 0, xMax = 100;
      let yMin = -40, yMax = 140;

      // dataset: array of {x,y,svgEl}
      let data = [];

      // model params (slope m and intercept b)
      let m = parseFloat(slopeRange.value);
      let b = parseFloat(interceptRange.value);

      // analytic OLS params (computed when Fit pressed)
      let olsParams = null;

      // residual visibility
      let showResiduals = true;

      // gradient descent state
      let gdRunning = false;
      let gdReq = null;

      // initialize
      function init() {
        drawGridAndAxes();
        generateData();
        renderPoints();
        updateLine();
        updateMetrics();
        attachEvents();
      }

      // Scale helpers: data -> screen coordinates
      function sx(x) {
        return MARGIN.left + ((x - xMin) / (xMax - xMin)) * PLOT_WIDTH;
      }
      function sy(y) {
        // invert y: data yMax at top margin
        return MARGIN.top + ((yMax - y) / (yMax - yMin)) * PLOT_HEIGHT;
      }
      function ix(px) {
        return xMin + ((px - MARGIN.left) / PLOT_WIDTH) * (xMax - xMin);
      }
      function iy(py) {
        return yMax - ((py - MARGIN.top) / PLOT_HEIGHT) * (yMax - yMin);
      }

      // Grid & axes
      function drawGridAndAxes(){
        gridLayer.innerHTML = '';
        axesLayer.innerHTML = '';

        // vertical grid lines (x)
        let xTicks = 10;
        for(let i=0;i<=xTicks;i++){
          const x = xMin + (i/xTicks)*(xMax-xMin);
          const px = sx(x);
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', px);
          line.setAttribute('x2', px);
          line.setAttribute('y1', MARGIN.top);
          line.setAttribute('y2', HEIGHT - MARGIN.bottom);
          line.setAttribute('stroke', 'rgba(255,255,255,0.03)');
          line.setAttribute('stroke-width', '1');
          gridLayer.appendChild(line);

          const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
          lbl.setAttribute('x', px);
          lbl.setAttribute('y', HEIGHT - MARGIN.bottom + 18);
          lbl.setAttribute('text-anchor', 'middle');
          lbl.setAttribute('fill', '#9fb8cc');
          lbl.setAttribute('font-size', '11');
          lbl.textContent = Math.round(x);
          axesLayer.appendChild(lbl);
        }

        // horizontal grid lines (y)
        let yTicks = 8;
        for(let j=0;j<=yTicks;j++){
          const y = yMin + (j/yTicks)*(yMax-yMin);
          const py = sy(y);
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', MARGIN.left);
          line.setAttribute('x2', WIDTH - MARGIN.right);
          line.setAttribute('y1', py);
          line.setAttribute('y2', py);
          line.setAttribute('stroke', 'rgba(255,255,255,0.02)');
          line.setAttribute('stroke-width', '1');
          gridLayer.appendChild(line);

          const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
          lbl.setAttribute('x', MARGIN.left - 10);
          lbl.setAttribute('y', py + 4);
          lbl.setAttribute('text-anchor', 'end');
          lbl.setAttribute('fill', '#9fb8cc');
          lbl.setAttribute('font-size', '11');
          lbl.textContent = Math.round(y);
          axesLayer.appendChild(lbl);
        }

        // axis lines
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg','line');
        xAxis.setAttribute('x1', MARGIN.left);
        xAxis.setAttribute('x2', WIDTH - MARGIN.right);
        xAxis.setAttribute('y1', HEIGHT - MARGIN.bottom);
        xAxis.setAttribute('y2', HEIGHT - MARGIN.bottom);
        xAxis.setAttribute('stroke', 'rgba(255,255,255,0.06)');
        xAxis.setAttribute('stroke-width', '1.5');
        axesLayer.appendChild(xAxis);

        const yAxis = document.createElementNS('http://www.w3.org/2000/svg','line');
        yAxis.setAttribute('x1', MARGIN.left);
        yAxis.setAttribute('x2', MARGIN.left);
        yAxis.setAttribute('y1', MARGIN.top);
        yAxis.setAttribute('y2', HEIGHT - MARGIN.bottom);
        yAxis.setAttribute('stroke', 'rgba(255,255,255,0.06)');
        yAxis.setAttribute('stroke-width', '1.5');
        axesLayer.appendChild(yAxis);
      }

      // Generate synthetic data
      function generateData(n=12) {
        data = [];
        // underlying true line (for generating synthetic data)
        const trueM = 0.9 + Math.random()*1.6 - 0.3;
        const trueB = 10 + Math.random()*30 - 10;
        for(let i=0;i<n;i++){
          const x = 5 + Math.random()*90;
          const y = trueM * x + trueB + (Math.random()*40 - 20);
          data.push({x: x, y: y});
        }
        // set sliders to default m and b such that line roughly matches data center
        m = parseFloat(slopeRange.value);
        b = parseFloat(interceptRange.value);
        olsParams = null;
      }

      // Render points
      function renderPoints(){
        ptsLayer.innerHTML = '';
        data.forEach((pt, idx) => {
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('transform', `translate(${sx(pt.x)},${sy(pt.y)})`);
          g.setAttribute('tabindex', '0');
          g.classList.add('draggable');
          g.setAttribute('data-idx', idx);

          // circle
          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('r', POINT_RADIUS.toString());
          c.setAttribute('class', 'point');
          c.setAttribute('cx', '0');
          c.setAttribute('cy', '0');
          g.appendChild(c);

          // label (small)
          const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
          lbl.setAttribute('x', 12);
          lbl.setAttribute('y', 4);
          lbl.setAttribute('fill', '#dff8ff');
          lbl.setAttribute('font-size', '11');
          lbl.textContent = `(${Math.round(pt.x)}, ${Math.round(pt.y)})`;
          lbl.setAttribute('opacity', '0.9');
          g.appendChild(lbl);

          ptsLayer.appendChild(g);

          // attach pointer events for dragging
          attachDragHandlers(g, idx);
          attachKeyboardHandlers(g, idx, lbl);
        });
      }

      // attach pointer dragging handlers to a group
      function attachDragHandlers(el, idx){
        let dragging = false;
        let pointerId = null;

        function onPointerDown(e){
          if(e.pointerType === 'mouse' && e.button !== 0) return;
          e.preventDefault();
          el.setPointerCapture(e.pointerId);
          pointerId = e.pointerId;
          dragging = true;
        }
        function onPointerMove(e){
          if(!dragging || e.pointerId !== pointerId) return;
          const {clientX, clientY} = e;
          // map client coords to svg coordinates
          const pt = clientToSvg(e);
          const newX = Math.max(xMin, Math.min(xMax, ix(pt.x)));
          const newY = Math.max(yMin, Math.min(yMax, iy(pt.y)));
          data[idx].x = newX;
          data[idx].y = newY;
          el.setAttribute('transform', `translate(${sx(newX)},${sy(newY)})`);
          // update label
          const text = el.querySelector('text');
          if(text) text.textContent = `(${Math.round(newX)}, ${Math.round(newY)})`;
          // if mode auto-fit, compute OLS immediately
          if(modeSelect.value === 'auto'){
            computeOLS();
            animateToOLS();
          }
          // when dragging, update residuals and current line
          updateLine();
        }
        function onPointerUp(e){
          if(e.pointerId !== pointerId) return;
          dragging = false;
          el.releasePointerCapture(e.pointerId);
          pointerId = null;
        }

        el.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
        window.addEventListener('pointercancel', onPointerUp);
      }

      // attach keyboard nudging for focused point
      function attachKeyboardHandlers(el, idx, labelEl){
        el.addEventListener('keydown', (ev) => {
          let changed = false;
          if(ev.key === 'ArrowLeft'){ data[idx].x = Math.max(xMin, data[idx].x - 1); changed = true; }
          if(ev.key === 'ArrowRight'){ data[idx].x = Math.min(xMax, data[idx].x + 1); changed = true; }
          if(ev.key === 'ArrowUp'){ data[idx].y = Math.min(yMax, data[idx].y + 1); changed = true; }
          if(ev.key === 'ArrowDown'){ data[idx].y = Math.max(yMin, data[idx].y - 1); changed = true; }
          if(changed){
            el.setAttribute('transform', `translate(${sx(data[idx].x)},${sy(data[idx].y)})`);
            labelEl.textContent = `(${Math.round(data[idx].x)}, ${Math.round(data[idx].y)})`;
            ev.preventDefault();
            if(modeSelect.value === 'auto'){
              computeOLS();
              animateToOLS();
            }
            updateLine();
          }
        });
      }

      // convert client pointer to svg coords
      function clientToSvg(evt){
        const pt = svg.createSVGPoint();
        pt.x = evt.clientX;
        pt.y = evt.clientY;
        const ctm = svg.getScreenCTM().inverse();
        const sp = pt.matrixTransform(ctm);
        return {x: sp.x, y: sp.y};
      }

      // update regression line based on current m,b
      function updateLine(animate=false){
        // compute endpoints in screen coordinates
        const x1 = xMin, x2 = xMax;
        const y1 = m * x1 + b, y2 = m * x2 + b;
        const px1 = sx(x1), py1 = sy(y1), px2 = sx(x2), py2 = sy(y2);

        // animate via transition by updating attributes; browsers animate SVG attributes automatically if CSS transition is not available; we emulate smooth animation
        regLine.setAttribute('x1', px1);
        regLine.setAttribute('y1', py1);
        regLine.setAttribute('x2', px2);
        regLine.setAttribute('y2', py2);

        // residuals
        drawResiduals();

        // update displayed slider labels and metrics
        slopeVal.textContent = m.toFixed(2);
        interceptVal.textContent = b.toFixed(1);
        mMetric.textContent = m.toFixed(2);
        bMetric.textContent = b.toFixed(1);
        updateMetrics();
      }

      // draw or clear residual lines
      function drawResiduals(){
        resLayer.innerHTML = '';
        if(!showResiduals) return;
        data.forEach((pt, i) => {
          // predicted y on current line at pt.x
          const yHat = m * pt.x + b;
          const xS = sx(pt.x), yS = sy(pt.y), yHatS = sy(yHat);

          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', xS);
          line.setAttribute('x2', xS);
          line.setAttribute('y1', yS);
          line.setAttribute('y2', yHatS);
          line.setAttribute('class', 'residual');
          resLayer.appendChild(line);
        });
      }

      // compute metrics: SSE and R^2
      function updateMetrics(){
        const n = data.length;
        const yMean = data.reduce((s,p)=>s+p.y,0)/n;
        let ssTot = 0, ssRes = 0;
        data.forEach(pt=>{
          const yHat = m*pt.x + b;
          ssRes += (pt.y - yHat)*(pt.y - yHat);
          ssTot += (pt.y - yMean)*(pt.y - yMean);
        });
        const r2 = ssTot === 0 ? 0 : Math.max(0, 1 - ssRes/ssTot);
        sseMetric.textContent = ssRes.toFixed(2);
        r2Metric.textContent = r2.toFixed(3);
      }

      // analytic OLS solution (m,b)
      function computeOLS(){
        const n = data.length;
        const meanX = data.reduce((s,p)=>s+p.x,0)/n;
        const meanY = data.reduce((s,p)=>s+p.y,0)/n;
        let num = 0, den = 0;
        data.forEach(pt=>{
          num += (pt.x - meanX)*(pt.y - meanY);
          den += (pt.x - meanX)*(pt.x - meanX);
        });
        const mm = den === 0 ? 0 : num/den;
        const bb = meanY - mm * meanX;
        olsParams = {m: mm, b: bb};
        return olsParams;
      }

      // animate to OLS (smoothly move m,b to olsParams)
      function animateToOLS(duration=500){
        if(!olsParams) computeOLS();
        const startM = m, startB = b;
        const endM = olsParams.m, endB = olsParams.b;
        const t0 = performance.now();
        const step = (ts)=>{
          const p = Math.min(1, (ts - t0) / duration);
          // simple easeOutQuad
          const ease = 1 - Math.pow(1-p,2);
          m = startM + (endM - startM) * ease;
          b = startB + (endB - startB) * ease;
          updateLine();
          if(p < 1) requestAnimationFrame(step);
          else {
            // show OLS dashed line as final (green dashed)
            showOLSLine();
          }
        };
        requestAnimationFrame(step);
      }

      // show analytic OLS line as dashed green
      function showOLSLine(){
        if(!olsParams) return;
        const x1 = xMin, x2 = xMax;
        const y1 = olsParams.m * x1 + olsParams.b, y2 = olsParams.m * x2 + olsParams.b;
        olsLine.setAttribute('x1', sx(x1));
        olsLine.setAttribute('y1', sy(y1));
        olsLine.setAttribute('x2', sx(x2));
        olsLine.setAttribute('y2', sy(y2));
        olsLine.style.opacity = 1;
        // fade out after a bit
        setTimeout(()=>{ olsLine.style.transition = 'opacity 1200ms'; olsLine.style.opacity = 0; setTimeout(()=>olsLine.style.transition='none', 1400); }, 1300);
      }

      // gradient descent for linear regression (batch)
      function startGradientDescent(){
        if(gdRunning) return;
        gdRunning = true;
        gdBtn.textContent = 'Pause GD';
        // starting from current m,b
        let steps = 0;
        function step(){
          if(!gdRunning) return;
          const lr = parseFloat(lrRange.value);
          // compute gradients: d/dm SSE = -2 * sum x*(y - (m x + b)), d/db SSE = -2 * sum (y - (m x + b))
          let gradM = 0, gradB = 0;
          data.forEach(pt => {
            const err = pt.y - (m*pt.x + b);
            gradM += -2 * pt.x * err;
            gradB += -2 * err;
          });
          // normalize by n to get average gradient (optional)
          const n = data.length;
          gradM /= n;
          gradB /= n;
          // update
          m = m - lr * gradM;
          b = b - lr * gradB;

          updateLine();
          steps++;
          // stop condition: small gradients or many steps
          if(steps < 2000 && (Math.abs(gradM) > 1e-4 || Math.abs(gradB) > 1e-3)){
            gdReq = requestAnimationFrame(step);
          } else {
            // finish
            gdRunning = false;
            gdBtn.textContent = 'Start GD';
            computeOLS(); // compute analytic as reference
            showOLSLine();
          }
        }
        gdReq = requestAnimationFrame(step);
      }
      function pauseGradientDescent(){
        gdRunning = false;
        if(gdReq) cancelAnimationFrame(gdReq);
        gdBtn.textContent = 'Start GD';
      }

      // attach UI event handlers
      function attachEvents(){
        slopeRange.addEventListener('input', (e)=>{
          m = parseFloat(e.target.value);
          updateLine();
        });
        interceptRange.addEventListener('input', (e)=>{
          b = parseFloat(e.target.value);
          updateLine();
        });
        lrRange.addEventListener('input', (e)=>{
          lrVal.textContent = parseFloat(e.target.value).toFixed(3);
        });

        fitBtn.addEventListener('click', ()=>{
          computeOLS();
          animateToOLS(700);
        });

        gdBtn.addEventListener('click', ()=>{
          if(gdRunning) pauseGradientDescent();
          else startGradientDescent();
        });

        resetDataBtn.addEventListener('click', ()=>{
          pauseGradientDescent();
          generateData();
          renderPoints();
          olsLine.style.opacity = 0;
          updateLine();
        });

        toggleResidualsBtn.addEventListener('click', ()=>{
          showResiduals = !showResiduals;
          drawResiduals();
        });

        modeSelect.addEventListener('change', ()=>{
          // if switching away from auto, nothing special; if switch to auto, trigger fit
          if(modeSelect.value === 'auto'){
            computeOLS();
            animateToOLS(300);
          }
        });

        randomOutlierBtn.addEventListener('click', ()=>{
          const x = 10 + Math.random()*80;
          const y = yMax - 10 - Math.random()*80; // high outlier
          data.push({x,y});
          renderPoints();
          updateLine();
          computeOLS();
          animateToOLS(600);
        });

        // sync displayed slider values
        slopeVal.textContent = m.toFixed(2);
        interceptVal.textContent = b.toFixed(1);
        lrVal.textContent = parseFloat(lrRange.value).toFixed(3);

        // update m,b on model changes to sync sliders (particularly after GD)
        const syncLoop = ()=>{
          // update sliders only if user not currently dragging them
          if(document.activeElement !== slopeRange) slopeRange.value = m;
          if(document.activeElement !== interceptRange) interceptRange.value = b;
          requestAnimationFrame(syncLoop);
        };
        requestAnimationFrame(syncLoop);

        // keyboard shortcut: press 'f' to fit, 'g' to toggle gd
        window.addEventListener('keydown', (e)=>{
          if(e.key === 'f') { computeOLS(); animateToOLS(500); }
          if(e.key === 'g') { if(gdRunning) pauseGradientDescent(); else startGradientDescent(); }
        });
      }

      // initial render
      init();

      // Expose for debugging (not necessary)
      window.__linReg = {data, computeOLS, updateLine, generateData};

    })();
  </script>
</body>
</html>