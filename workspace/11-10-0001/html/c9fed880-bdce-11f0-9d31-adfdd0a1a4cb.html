<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Union-Find Interactive Module</title>
  <style>
    :root{
      --safe-pad: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #10b981;
      --accent-2: #2563eb;
      --muted: #94a3b8;
      --white: #e6eef8;
      --danger: #ef4444;
      --node-size: 48px;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071027 0%, #081420 100%);
      color:var(--white);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    /* Safe area margins = 24px */
    .app {
      padding: var(--safe-pad);
      box-sizing: border-box;
      min-height:100vh;
      display:flex;
      gap:var(--gap);
      align-items:stretch;
    }

    /* Left panel: description and controls */
    .panel {
      width:360px;
      min-width:280px;
      max-width:40%;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:20px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    p.small {
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }
    .section {
      background: rgba(255,255,255,0.02);
      padding:12px;
      border-radius:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .label {
      font-size:12px;
      color:var(--muted);
    }

    /* Controls */
    .controls {
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .row {
      display:flex;
      gap:12px;
      align-items:center;
    }
    input[type="number"], select {
      background: rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.04);
      color:var(--white);
      padding:8px 10px;
      border-radius:8px;
      outline:none;
      width:100%;
      box-sizing:border-box;
    }
    .btn {
      background: linear-gradient(180deg,var(--accent), #08966b);
      border:none;
      color:white;
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      box-shadow: 0 6px 14px rgba(16,185,129,0.12);
    }
    .btn.secondary {
      background: linear-gradient(180deg,#2a3b5a,#1b2a44);
      box-shadow:none;
      border:1px solid rgba(255,255,255,0.03);
    }
    .toggle {
      display:flex;
      align-items:center;
      gap:8px;
      font-size:13px;
      color:var(--muted);
    }
    .checkbox {
      appearance:none;
      width:36px;
      height:20px;
      background:rgba(255,255,255,0.06);
      border-radius:12px;
      position:relative;
      outline:none;
      cursor:pointer;
      border:1px solid rgba(255,255,255,0.02);
    }
    .checkbox:after{
      content:'';
      width:16px;
      height:16px;
      border-radius:50%;
      background:white;
      position:absolute;
      left:2px;
      top:1px;
      transition:transform .18s ease;
    }
    .checkbox[aria-checked="true"]{
      background:linear-gradient(90deg,var(--accent-2),#7c3aed);
    }
    .checkbox[aria-checked="true"]:after{
      transform:translateX(16px);
      background:white;
    }

    /* Right panel: visualizer */
    .visual {
      flex:1;
      min-width:0;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:12px;
      padding:18px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      position:relative;
      overflow:hidden;
    }
    .viz-top {
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:center;
    }
    .canvas-wrap {
      flex:1;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:10px;
      position:relative;
      overflow:hidden;
      min-height:360px;
      border:1px dashed rgba(255,255,255,0.03);
    }
    svg {
      width:100%;
      height:100%;
      display:block;
    }

    /* Node style */
    .node {
      cursor:pointer;
      transition:transform .12s ease;
    }
    .node .circle {
      fill: #071a2b;
      stroke: rgba(255,255,255,0.06);
      stroke-width:2;
    }
    .node.root .circle {
      fill: linear-gradient(180deg,#06324a,#05273b);
      stroke: rgba(16,185,129,0.2);
      filter: drop-shadow(0 6px 18px rgba(16,185,129,0.06));
    }
    .node .label {
      fill:var(--white);
      font-weight:700;
      font-size:14px;
      text-anchor:middle;
      dominant-baseline:middle;
      pointer-events:none;
    }
    .node.selected .circle {
      stroke: var(--accent-2);
      stroke-width:3;
      transform-origin:center;
    }
    .pulse {
      animation: pulse 900ms ease-in-out 2;
    }
    @keyframes pulse {
      0% { transform:scale(1); opacity:1;}
      50% { transform:scale(1.12); opacity:0.9;}
      100% { transform:scale(1); opacity:1;}
    }
    /* Arrow style */
    .edge {
      stroke: rgba(255,255,255,0.08);
      stroke-width:2;
      fill:none;
      marker-end: url(#arrow);
      transition:stroke 240ms ease;
    }
    .edge.new {
      stroke: var(--accent);
      stroke-width:2.6;
      opacity:1;
      stroke-dasharray: 1000;
      stroke-dashoffset: 1000;
      animation: draw 700ms forwards ease-out;
    }
    @keyframes draw {
      to { stroke-dashoffset: 0; }
    }

    /* Tables for arrays */
    .arrays {
      display:flex;
      gap:12px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .array-box {
      background: rgba(255,255,255,0.02);
      padding:8px;
      border-radius:8px;
      min-width:120px;
      box-sizing:border-box;
      font-size:13px;
      color:var(--muted);
    }
    .array-box .row {
      justify-content:space-between;
      gap:8px;
    }
    .array-box b {
      color:var(--white);
    }

    /* Footer hint */
    .hint {
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:12px;
      align-items:center;
    }

    /* Responsive */
    @media (max-width:900px){
      .app { flex-direction:column; padding:18px; }
      .panel { width:100%; max-width:none; }
      .visual { width:100%; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Union-Find interactive module">
    <!-- LEFT PANEL -->
    <div class="panel" aria-hidden="false">
      <h1>Union-Find (Disjoint Set) — Interactive Module</h1>
      <p class="small">
        Learn how the Union-Find (Disjoint Set) data structure maintains connected components using union and find operations. Interact to see parent pointers, ranks, and path compression in action.
      </p>

      <div class="section" aria-labelledby="objective">
        <div class="label" id="objective">Learning Objective</div>
        <p class="small">
          After using this module you should be able to:
          - Visually trace find(x) to the set representative (root), see how union(a,b) attaches trees, and observe how path compression shortens paths. You will experiment with union-by-rank and animated path compression.
        </p>
      </div>

      <div class="section" aria-labelledby="interaction">
        <div class="label" id="interaction">Interaction Design (how to use)</div>
        <ol class="small" style="margin:0; padding-left:18px; color:var(--muted);">
          <li>Click a node to select it. Select two nodes and press "Union" to merge their sets.</li>
          <li>Click a single node and press "Find" to animate find(path) and optionally compress paths.</li>
          <li>Toggle "Union by Rank" and "Path Compression" to see different behaviors.</li>
          <li>Drag nodes to rearrange the layout for clarity.</li>
          <li>Use "Random Unions" to apply random merges with animation and observe parent/rank changes.</li>
        </ol>
      </div>

      <div class="section controls" aria-labelledby="controls">
        <div class="label" id="controls">Controls</div>

        <div class="row" style="align-items:center;">
          <input id="nodeCount" type="number" min="2" max="16" value="8" aria-label="number of nodes" />
          <button id="rebuildBtn" class="btn" title="Rebuild nodes">Rebuild</button>
        </div>

        <div class="row">
          <button id="unionBtn" class="btn secondary" title="Union selected nodes">Union</button>
          <button id="findBtn" class="btn secondary" title="Find root of selected node">Find</button>
        </div>

        <div class="row">
          <button id="randomBtn" class="btn" title="Perform random unions">Random Unions</button>
          <button id="resetBtn" class="btn secondary" title="Reset to singleton sets">Reset</button>
        </div>

        <div class="row" style="flex-direction:column; gap:8px;">
          <label class="toggle"><span class="label">Union by Rank</span>
            <button id="rankToggle" class="checkbox" role="switch" aria-checked="true" aria-label="toggle union by rank"></button>
          </label>
          <label class="toggle"><span class="label">Path Compression</span>
            <button id="pcToggle" class="checkbox" role="switch" aria-checked="true" aria-label="toggle path compression"></button>
          </label>
        </div>

      </div>

      <div class="section" aria-labelledby="arrays">
        <div class="label" id="arrays">State Views</div>
        <div class="arrays" id="arraysBox">
          <div class="array-box">
            <div style="margin-bottom:6px;"><b>parent[]</b></div>
            <div id="parentView" style="display:flex;flex-direction:column;gap:6px;"></div>
          </div>
          <div class="array-box">
            <div style="margin-bottom:6px;"><b>rank[]</b></div>
            <div id="rankView" style="display:flex;flex-direction:column;gap:6px;"></div>
          </div>
        </div>
      </div>

      <div class="section" aria-labelledby="layout">
        <div class="label" id="layout">Layout Notes</div>
        <p class="small">
          The right area shows a draggable node graph (SVG). Arrows point from each node to its parent. Selected nodes are highlighted. Animations show new edges being created and path compression rewiring pointers.
        </p>
      </div>

      <div class="hint">
        <span style="color:var(--muted);">Tip:</span>
        <span style="color:var(--white);font-weight:600;">Click nodes → Union / Find → Watch animations</span>
      </div>

    </div>

    <!-- RIGHT PANEL: VISUALIZER -->
    <div class="visual" aria-live="polite">
      <div class="viz-top">
        <div style="display:flex;flex-direction:column;">
          <div style="font-size:13px;color:var(--muted);">Visualizer</div>
          <div style="font-size:12px;color:var(--muted);">Drag nodes to reposition. Click to select.</div>
        </div>
        <div style="display:flex;gap:12px;">
          <div style="font-size:13px;color:var(--muted);">Selected:
            <span id="selLabel" style="color:var(--white); font-weight:700; margin-left:8px;">None</span>
          </div>
        </div>
      </div>

      <div class="canvas-wrap" id="canvasWrap">
        <!-- SVG will be injected here -->
      </div>

    </div>
  </div>

  <script>
    /*****************************************************************************
     * Union-Find Interactive Module
     * - Self-contained vanilla JS, HTML, CSS
     * - Visual, draggable nodes, animated edges, union-by-rank and path compression toggles
     *
     * Spacing rules:
     * - Safe area: 24px via .app padding
     * - Minimum spacing: 16px via CSS gap variables
     *****************************************************************************/

    // Utility
    const clamp = (v,a,b) => Math.max(a,Math.min(b,v));
    const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;

    // DOM
    const canvasWrap = document.getElementById('canvasWrap');
    const nodeCountInput = document.getElementById('nodeCount');
    const rebuildBtn = document.getElementById('rebuildBtn');
    const unionBtn = document.getElementById('unionBtn');
    const findBtn = document.getElementById('findBtn');
    const randomBtn = document.getElementById('randomBtn');
    const resetBtn = document.getElementById('resetBtn');
    const parentView = document.getElementById('parentView');
    const rankView = document.getElementById('rankView');
    const rankToggle = document.getElementById('rankToggle');
    const pcToggle = document.getElementById('pcToggle');
    const selLabel = document.getElementById('selLabel');

    // State
    let N = parseInt(nodeCountInput.value,10) || 8;
    let parent = [];
    let rankArr = [];
    let nodes = []; // {id,x,y,svgGroup}
    let selected = new Set();
    let svg, edgeLayer, nodeLayer;
    let dragging = null;
    let svgRect = null;
    let unionByRank = true;
    let pathCompression = true;
    let animQueue = Promise.resolve();

    // Initialize UI toggles
    function setToggle(btn, enabled){
      btn.setAttribute('aria-checked', enabled ? 'true' : 'false');
    }
    setToggle(rankToggle, unionByRank);
    setToggle(pcToggle, pathCompression);
    rankToggle.addEventListener('click', ()=> {
      unionByRank = !unionByRank;
      setToggle(rankToggle, unionByRank);
    });
    pcToggle.addEventListener('click', ()=> {
      pathCompression = !pathCompression;
      setToggle(pcToggle, pathCompression);
    });

    // Setup and rebuild
    function build(Nnodes){
      N = Math.max(2, Math.min(16, Nnodes));
      nodeCountInput.value = N;
      parent = new Array(N).fill(0).map((_,i)=>i);
      rankArr = new Array(N).fill(0);
      selected.clear();
      selLabel.textContent = 'None';
      // Build SVG
      canvasWrap.innerHTML = '';
      svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      svg.setAttribute('viewBox','0 0 1000 600');
      svg.setAttribute('preserveAspectRatio','xMidYMid meet');
      canvasWrap.appendChild(svg);

      // defs for arrow marker
      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
      marker.setAttribute('id','arrow');
      marker.setAttribute('markerWidth','8');
      marker.setAttribute('markerHeight','8');
      marker.setAttribute('refX','8');
      marker.setAttribute('refY','3');
      marker.setAttribute('orient','auto');
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d','M0,0 L6,3 L0,6 L1,3 z');
      path.setAttribute('fill','rgba(255,255,255,0.08)');
      marker.appendChild(path);
      defs.appendChild(marker);
      svg.appendChild(defs);

      // layers
      edgeLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
      nodeLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
      svg.appendChild(edgeLayer);
      svg.appendChild(nodeLayer);

      // place nodes in circular layout
      nodes = [];
      const cx = 500, cy = 300, radius = Math.min(380, Math.max(200, N*40));
      for(let i=0;i<N;i++){
        const angle = (i/N) * Math.PI*2 - Math.PI/2;
        const x = cx + Math.cos(angle)*radius*0.7 + randInt(-30,30);
        const y = cy + Math.sin(angle)*radius*0.7 + randInt(-20,20);
        nodes.push({id:i,x,y,grp:null});
      }

      // create visuals
      nodes.forEach(n => {
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.classList.add('node');
        g.setAttribute('tabindex','0');
        g.setAttribute('role','button');
        g.setAttribute('aria-label','node ' + n.id);
        // circle
        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.classList.add('circle');
        circle.setAttribute('r', 24);
        circle.setAttribute('cx', n.x);
        circle.setAttribute('cy', n.y);
        // label
        const label = document.createElementNS('http://www.w3.org/2000/svg','text');
        label.classList.add('label');
        label.setAttribute('x', n.x);
        label.setAttribute('y', n.y);
        label.textContent = n.id;
        g.appendChild(circle);
        g.appendChild(label);
        g.style.transformOrigin = `${n.x}px ${n.y}px`;
        nodeLayer.appendChild(g);
        n.grp = g;

        // attach mouse handlers (drag & click)
        g.addEventListener('mousedown', (e)=> onNodeDown(e, n));
        g.addEventListener('touchstart', (e)=> onNodeDown(e, n), {passive:false});
        g.addEventListener('click', (e)=> onNodeClick(e, n));
        // keyboard accessibility
        g.addEventListener('keydown', (e)=> {
          if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onNodeClick(e,n); }
        });
      });

      // initial draw
      updateEdges();
      updateArrays();
      refreshSelectionUI();
      // listen to mouse move/up on document for dragging
      document.addEventListener('mousemove', onDocMove);
      document.addEventListener('mouseup', onDocUp);
      document.addEventListener('touchmove', onDocMove, {passive:false});
      document.addEventListener('touchend', onDocUp);

      // recalc svg rect for bounds on drag
      setTimeout(()=> {
        svgRect = canvasWrap.getBoundingClientRect();
      }, 50);
    }

    // Update parent and rank boxes
    function updateArrays(){
      parentView.innerHTML = '';
      rankView.innerHTML = '';
      for(let i=0;i<N;i++){
        const r1 = document.createElement('div');
        r1.className = 'row';
        const k = document.createElement('div'); k.textContent = i;
        k.style.color = 'var(--muted)';
        const v = document.createElement('div'); v.innerHTML = '<b>' + parent[i] + '</b>';
        r1.appendChild(k); r1.appendChild(v);
        parentView.appendChild(r1);

        const r2 = document.createElement('div'); r2.className='row';
        const k2 = document.createElement('div'); k2.textContent = i;
        k2.style.color = 'var(--muted)';
        const v2 = document.createElement('div'); v2.innerHTML = '<b>' + rankArr[i] + '</b>';
        r2.appendChild(k2); r2.appendChild(v2);
        rankView.appendChild(r2);
      }
    }

    // Draw edges based on parent[]
    function updateEdges(animNew = null){
      // Clear existing edges
      while(edgeLayer.firstChild) edgeLayer.removeChild(edgeLayer.firstChild);
      // For each i where parent[i] != i, draw a curved path from i -> parent[i]
      for(let i=0;i<N;i++){
        const p = parent[i];
        if(p === i) continue;
        const from = nodes[i];
        const to = nodes[p];
        // compute control points for gentle curve
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        const mx = (from.x + to.x)/2;
        const my = (from.y + to.y)/2;
        const nx = -dy*0.12;
        const ny = dx*0.12;
        const c1x = mx + nx, c1y = my + ny;
        const path = document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d', `M ${from.x} ${from.y} Q ${c1x} ${c1y} ${to.x} ${to.y}`);
        path.classList.add('edge');
        if(animNew && animNew.from === i && animNew.to === p) {
          path.classList.add('new');
        }
        edgeLayer.appendChild(path);
      }

      // Update node positions
      nodes.forEach(n => {
        const g = n.grp;
        const circle = g.querySelector('circle');
        const label = g.querySelector('text');
        circle.setAttribute('cx', n.x);
        circle.setAttribute('cy', n.y);
        label.setAttribute('x', n.x);
        label.setAttribute('y', n.y+0.5);
      });

      // Update which nodes are roots (for visual styling)
      nodes.forEach(n => {
        const g = n.grp;
        if(parent[n.id] === n.id) {
          g.classList.add('root');
        } else {
          g.classList.remove('root');
        }
      });
    }

    // Selection UI
    function refreshSelectionUI(){
      // update node visuals
      nodes.forEach(n=>{
        if(selected.has(n.id)){
          n.grp.classList.add('selected');
        } else {
          n.grp.classList.remove('selected');
        }
      });
      selLabel.textContent = (selected.size === 0) ? 'None' : Array.from(selected).join(', ');
    }

    // Node click: toggle selection
    function onNodeClick(e, node){
      e.stopPropagation();
      // toggle selection
      if(selected.has(node.id)){
        selected.delete(node.id);
      } else {
        // if more than 2 selected, keep only latest two (limit for union op)
        if(selected.size >= 2){
          // convert to array, drop first
          const arr = Array.from(selected);
          selected.clear();
          arr.slice(1).forEach(x=>selected.add(x));
        }
        selected.add(node.id);
      }
      refreshSelectionUI();
    }

    // Dragging
    function onNodeDown(e, node){
      e.preventDefault();
      dragging = {node: node, startX: e.clientX || (e.touches && e.touches[0].clientX), startY: e.clientY || (e.touches && e.touches[0].clientY)};
    }
    function onDocMove(e){
      if(!dragging) return;
      e.preventDefault();
      const clientX = e.clientX || (e.touches && e.touches[0].clientX);
      const clientY = e.clientY || (e.touches && e.touches[0].clientY);
      if(!svgRect) svgRect = canvasWrap.getBoundingClientRect();
      const dx = clientX - dragging.startX;
      const dy = clientY - dragging.startY;
      dragging.startX = clientX;
      dragging.startY = clientY;
      // convert screen delta to SVG coordinates (approx using viewBox scale)
      const vb = svg.viewBox.baseVal;
      const sx = vb.width / svgRect.width;
      const sy = vb.height / svgRect.height;
      dragging.node.x = clamp(dragging.node.x + dx * sx, vb.x + 40, vb.x + vb.width - 40);
      dragging.node.y = clamp(dragging.node.y + dy * sy, vb.y + 40, vb.y + vb.height - 40);
      updateEdges();
    }
    function onDocUp(e){
      dragging = null;
    }

    // Union-Find logic with animations.
    function findPath(x){
      // Return array of nodes visited from x up to root (inclusive)
      const path = [];
      let cur = x;
      while(true){
        path.push(cur);
        if(parent[cur] === cur) break;
        cur = parent[cur];
      }
      return path;
    }

    function findRoot(x, animate=true){
      const path = findPath(x);
      const root = path[path.length-1];
      if(animate){
        // highlight the path nodes and edges sequentially
        return animateFindPath(path).then(()=>{
          if(pathCompression){
            return animatePathCompression(path, root);
          } else {
            return root;
          }
        });
      } else {
        if(pathCompression){
          // compress without animation
          for(let v of path) parent[v] = root;
          updateArrays();
          updateEdges();
        }
        return Promise.resolve(root);
      }
    }

    function animateFindPath(path){
      // pulse nodes sequentially to show traversal
      return new Promise(resolve=>{
        let i = 0;
        function step(){
          if(i>0){
            const prev = nodes[path[i-1]];
            prev.grp.classList.remove('pulse');
          }
          if(i >= path.length){
            resolve();
            return;
          }
          const n = nodes[path[i]];
          n.grp.classList.add('pulse');
          // also momentarily highlight text color
          setTimeout(()=> {
            n.grp.classList.remove('pulse');
            i++;
            step();
          }, 500);
        }
        step();
      });
    }

    function animatePathCompression(path, root){
      // For each node in path (except root), animate its edge removal and reattachment directly to root
      return new Promise(async resolve=>{
        for(let i=0;i<path.length-1;i++){
          const v = path[i];
          // visually show removal by fading existing edge and drawing new one
          await animateReparent(v, root);
          parent[v] = root; // update model
          updateArrays();
        }
        updateEdges();
        resolve(root);
      });
    }

    function animateReparent(nodeId, newParentId){
      return new Promise(resolve=>{
        // Draw a temporary new edge with .new class and animate the stroke dash
        const from = nodes[nodeId];
        const to = nodes[newParentId];
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        const mx = (from.x + to.x)/2;
        const my = (from.y + to.y)/2;
        const nx = -dy*0.12;
        const ny = dx*0.12;
        const c1x = mx + nx, c1y = my + ny;
        const path = document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d', `M ${from.x} ${from.y} Q ${c1x} ${c1y} ${to.x} ${to.y}`);
        path.classList.add('edge','new');
        edgeLayer.appendChild(path);

        // Fade the previous edge for nodeId (if exists)
        const oldEdges = Array.from(edgeLayer.querySelectorAll('path.edge')).filter(p=>{
          const d = p.getAttribute('d');
          return d && d.startsWith('M ' + from.x + ' ' + from.y);
        });
        oldEdges.forEach(p => {
          p.style.transition = 'opacity 300ms ease';
          p.style.opacity = 0.12;
        });

        // After animation completes, resolve
        setTimeout(()=> {
          // remove temporary 'new' class (keeps edge but set normal style), remove faded edges if they pointed to old parent
          path.classList.remove('new');
          // fully remove faded edges that were aiming from this node (the old one)
          oldEdges.forEach(p => {
            try{ p.remove(); } catch(e){}
          });
          resolve();
        }, 700);
      });
    }

    // Animate a union between two nodes (their roots)
    function unionAnimate(a,b){
      return new Promise(async resolve=>{
        // find roots (non-compressing)
        const ra = findPath(a).slice(-1)[0];
        const rb = findPath(b).slice(-1)[0];
        // pulse both roots
        nodes[ra].grp.classList.add('pulse');
        nodes[rb].grp.classList.add('pulse');
        await new Promise(r=> setTimeout(r, 520));
        nodes[ra].grp.classList.remove('pulse');
        nodes[rb].grp.classList.remove('pulse');

        if(ra === rb){
          // nothing to do; just highlight briefly
          nodes[ra].grp.classList.add('pulse');
          setTimeout(()=>{ nodes[ra].grp.classList.remove('pulse'); resolve(); }, 400);
          return;
        }

        // decide which root becomes parent based on union-by-rank
        let parentRoot = ra, childRoot = rb;
        if(unionByRank){
          if(rankArr[ra] < rankArr[rb]) { parentRoot = rb; childRoot = ra; }
          else if(rankArr[ra] > rankArr[rb]) { parentRoot = ra; childRoot = rb; }
          else { parentRoot = ra; childRoot = rb; rankArr[parentRoot] += 1; }
        } else {
          // attach b's tree under a
          parentRoot = ra; childRoot = rb;
        }

        // animate reparent of childRoot to parentRoot
        await animateReparent(childRoot, parentRoot);
        parent[childRoot] = parentRoot;
        updateArrays();
        updateEdges({from:childRoot, to:parentRoot});
        // small settle delay
        setTimeout(()=> resolve(), 240);
      });
    }

    // UI actions
    unionBtn.addEventListener('click', ()=> {
      if(selected.size < 2) {
        alert('Select two nodes to union.');
        return;
      }
      const [a,b] = Array.from(selected);
      // disable interactions by chaining animations
      animQueue = animQueue.then(()=> unionAnimate(a,b));
      animQueue.then(()=> {
        // update UI after animation
        updateArrays();
        updateEdges();
      });
      selected.clear();
      refreshSelectionUI();
    });

    findBtn.addEventListener('click', ()=> {
      if(selected.size === 0){
        alert('Select a node to run find() on.');
        return;
      }
      const [x] = Array.from(selected);
      // perform find with animation and optional path compression
      animQueue = animQueue.then(()=> findRoot(x, true));
      animQueue.then(()=> {
        updateArrays();
        updateEdges();
      });
      // keep selection of the node for clarity
    });

    // Random unions
    randomBtn.addEventListener('click', ()=> {
      const steps = Math.max(1, Math.floor(N/2));
      // perform random unions sequentially
      let promise = animQueue;
      for(let i=0;i<steps;i++){
        const a = randInt(0,N-1), b = randInt(0,N-1);
        if(a===b) continue;
        promise = promise.then(()=> unionAnimate(a,b)).then(()=> {
          updateArrays();
          updateEdges();
        });
      }
      animQueue = promise;
    });

    // Reset and rebuild
    resetBtn.addEventListener('click', ()=> {
      build(N);
    });
    rebuildBtn.addEventListener('click', ()=> {
      const v = parseInt(nodeCountInput.value,10) || 8;
      build(v);
    });

    // Initial build
    build(N);

    // Accessibility: clicking canvas clears selection
    canvasWrap.addEventListener('click', (e)=> {
      if(e.target === canvasWrap || e.target.nodeName === 'svg') {
        selected.clear();
        refreshSelectionUI();
      }
    });

    // Make sure arrays update whenever parent/rank change by any action
    // (we call updateArrays explicitly where needed)

    // Expose a console-friendly API (for debugging)
    window.__UF = {
      parents: ()=> parent.slice(),
      ranks: ()=> rankArr.slice(),
      nodes,
      rebuild: ()=> build(N),
    };
  </script>

</body>
</html>