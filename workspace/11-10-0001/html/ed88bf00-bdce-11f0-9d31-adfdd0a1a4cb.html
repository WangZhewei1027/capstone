<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Depth-First Search (DFS) Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #60a5fa;
      --accent-2: #7c3aed;
      --muted: #94a3b8;
      --success: #10b981;
      --danger: #ef4444;
      --node-size: 44px;
    }
    html,body{
      margin:0;
      height:100%;
      background: linear-gradient(180deg,#071022 0%, #07142a 100%);
      color: #dbeafe;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100vh;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    /* Header (planning / description) */
    .header {
      background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 18px;
      display:flex;
      flex-direction:column;
      gap:10px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }
    .title-row{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }
    h1 {
      margin:0;
      font-size:18px;
      letter-spacing: -0.2px;
      color: #e6eef8;
    }
    .meta {
      display:flex;
      gap:12px;
      align-items:center;
      color: var(--muted);
      font-size:13px;
    }
    .pill {
      background: rgba(255,255,255,0.04);
      padding:6px 10px;
      border-radius:999px;
      font-size:13px;
      color:var(--muted);
    }
    .header p { margin:0; color: #cfe8ffcc; font-size:13px; line-height:1.4; }

    /* Main content layout */
    .main {
      display:flex;
      gap: var(--gap);
      align-items:stretch;
      flex: 1;
      min-height: 420px;
    }
    .canvas-panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding:12px;
      flex:1 1 0;
      min-width: 320px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .top-controls {
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .btn{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      color: var(--accent);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      min-height:40px;
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .btn.primary{ background: linear-gradient(90deg,var(--accent),var(--accent-2)); color:#022; border: none;}
    .btn.ghost { color:var(--muted); border:1px dashed rgba(255,255,255,0.03); background:transparent; }
    .btn.small { padding:6px 8px; font-size:13px; min-height:32px;}
    .toggles { display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px;}

    /* Canvas area */
    .board {
      background: linear-gradient(180deg, rgba(255,255,255,0.006), rgba(255,255,255,0.002));
      border-radius:10px;
      height:520px;
      position:relative;
      overflow:hidden;
      touch-action:none;
    }
    svg {
      width:100%;
      height:100%;
      display:block;
    }
    .node {
      cursor:pointer;
      transition: transform 120ms ease, filter 120ms ease;
    }
    .node .circle{
      fill: #0b1220;
      stroke: rgba(255,255,255,0.06);
      stroke-width:2;
      filter: drop-shadow(0 6px 12px rgba(2,6,23,0.6));
      transition: fill 220ms ease, stroke 220ms ease;
    }
    .node text {
      font-size:13px;
      fill: #e6eef8;
      pointer-events:none;
    }
    .node.unvisited .circle { fill: #0b1220; stroke: rgba(255,255,255,0.06); }
    .node.discovered .circle { fill: #07367a; stroke: var(--accent); }
    .node.finished .circle { fill: #08391b; stroke: var(--success); }

    /* Node pulsing when active */
    .node.pulse .pulse-ring {
      opacity:1;
      transform:scale(1);
      transition:opacity 300ms, transform 600ms;
    }
    .pulse-ring{
      fill:none;
      stroke: rgba(96,165,250,0.22);
      stroke-width:6;
      r:30;
      transform-origin:center;
      transform:scale(0.4);
      opacity:0;
    }

    /* Edge styles */
    .edge {
      stroke: rgba(255,255,255,0.06);
      stroke-width:3;
      transition: stroke 220ms ease, stroke-width 220ms ease, opacity 220ms;
      fill:none;
      marker-end: url(#arrow);
    }
    .edge.highlight { stroke: var(--accent); stroke-width:4.4; opacity:1; }
    .edge.dim { opacity:0.25; }

    /* Right panel */
    .side-panel {
      width:340px;
      min-width:260px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:12px;
      padding:12px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .panel-section { background: transparent; padding:8px; border-radius:8px; display:flex; flex-direction:column; gap:8px; }
    label { font-size:13px; color:var(--muted); }
    .controls-row { display:flex; gap:8px; flex-wrap:wrap; }
    .info { font-size:13px; color: #cfe8ffcc; }

    .stack {
      background: rgba(255,255,255,0.02);
      border-radius:8px;
      padding:8px;
      min-height:120px;
      display:flex;
      flex-direction:column;
      gap:8px;
      overflow:auto;
    }
    .stack .frame {
      background: rgba(255,255,255,0.01);
      border:1px solid rgba(255,255,255,0.02);
      padding:8px;
      border-radius:8px;
      display:flex;
      justify-content:space-between;
      gap:8px;
      align-items:center;
      color:var(--muted);
      font-weight:600;
    }
    .trace {
      background: rgba(255,255,255,0.01);
      border-radius:8px;
      padding:8px;
      color:var(--muted);
      font-size:13px;
      min-height:80px;
      overflow:auto;
    }

    /* footer / hints */
    .hints { color:var(--muted); font-size:13px; display:flex; gap:10px; flex-wrap:wrap; }

    /* responsive */
    @media (max-width: 920px) {
      .main { flex-direction:column; }
      .side-panel { width:100%; }
    }

    /* small helper components */
    .kbd { background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:6px; color:var(--muted); font-weight:700; font-size:12px; }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="DFS interactive module">

    <!-- Header / Planning -->
    <div class="header" role="region" aria-label="Module description">
      <div class="title-row">
        <h1>Depth-First Search (DFS) — Interactive Exploration</h1>
        <div class="meta">
          <div class="pill">Concept: Graph Traversal</div>
          <div class="pill">Mode: Visual & Stepwise</div>
        </div>
      </div>

      <!-- Planning Sections -->
      <p><strong>Learning Objective:</strong> Interactively understand how Depth-First Search (DFS) explores a graph: how nodes are discovered, how DFS backtracks, and how the traversal order depends on neighbor order. After using the module, you will be able to trace DFS steps manually and reason about the recursion stack or iterative stack behavior.</p>

      <p><strong>Interaction Design:</strong> This single-page module lets you construct a graph by clicking to add nodes and dragging from one node to another to create edges. Pick a start node, then run DFS either recursively or iteratively. Controls include Play/Pause, Step Forward, Step Back, and Speed. Visual feedback includes node color changes for undiscovered/discovered/finished states, animated edge highlights during exploration, and a live stack/call-frame panel that updates with push/pop events. Reposition nodes by dragging to observe how visual layout doesn't affect traversal logic. All animations are CSS/SVG-based and reversible by stepping back.</p>

      <p><strong>Layout Description:</strong> The page uses a two-column responsive layout: a left canvas panel (graph + controls) and a right side panel (algorithm controls, stack visualization, and event trace). Safe area margins are 24px; minimum spacing between interactive elements is 16px. Buttons and interactive items have clear focus and labels; the SVG canvas supports pointer and touch interactions and scales responsively for small screens.</p>
    </div>

    <!-- Main interactive area -->
    <div class="main" role="region" aria-label="Interactive workspace">

      <!-- Canvas and controls -->
      <div class="canvas-panel" role="region" aria-label="Graph construction panel">
        <div class="top-controls" role="toolbar" aria-label="Top controls">
          <button class="btn" id="helpBtn" title="Quick usage tips">Hints</button>

          <div style="display:flex; gap:8px; align-items:center;">
            <button class="btn" id="addNodeBtn" aria-pressed="true">Add Node (click)</button>
            <button class="btn ghost" id="connectTips" title="Drag from a node to another to create an edge">Drag to Connect</button>
          </div>

          <div style="flex:1"></div>

          <div class="toggles" aria-hidden="false">
            <label for="directedToggle" style="display:flex; gap:8px; align-items:center;">
              <input type="checkbox" id="directedToggle" /> Directed
            </label>
            <label for="modeSelect" style="display:flex; gap:8px; align-items:center;">
              Mode:
              <select id="modeSelect" style="background:transparent; color:var(--accent); border:none; font-weight:700;">
                <option value="recursive">Recursive</option>
                <option value="iterative">Iterative (stack)</option>
              </select>
            </label>
          </div>
        </div>

        <div class="board" id="board" tabindex="0" aria-label="Graph board. Click to add nodes. Drag nodes to move. Drag from a node to another to connect.">
          <!-- SVG inside -->
          <svg id="svgRoot" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Graph visualization">
            <defs>
              <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#bfe1ff" opacity="0.85"></path>
              </marker>
            </defs>
            <g id="edgesLayer"></g>
            <g id="tempEdgeLayer"></g>
            <g id="nodesLayer"></g>
          </svg>
        </div>

        <div style="display:flex; gap:12px; align-items:center; justify-content:space-between;">
          <div style="display:flex; gap:8px; align-items:center;">
            <button class="btn primary" id="playBtn">Play</button>
            <button class="btn" id="stepFwd">Step ›</button>
            <button class="btn" id="stepBack">‹ Step</button>
            <button class="btn ghost" id="resetBtn">Reset</button>
          </div>

          <div style="display:flex; gap:8px; align-items:center;">
            <label class="info" for="speedRange">Speed</label>
            <input id="speedRange" type="range" min="200" max="1600" value="800" step="50" />
          </div>
        </div>

      </div>

      <!-- Side panel -->
      <aside class="side-panel" role="region" aria-label="Controls and stack visualization">
        <div class="panel-section" role="group" aria-label="Algorithm controls">
          <label>Start Node</label>
          <div style="display:flex; gap:8px; align-items:center;">
            <div id="startNodeInfo" class="info">No start node selected</div>
            <button class="btn small" id="pickStartBtn">Pick Start</button>
          </div>

          <div class="controls-row" style="margin-top:6px;">
            <button class="btn small" id="discoverAllBtn">Discover All (multi-component)</button>
            <button class="btn small" id="clearGraphBtn">Clear Graph</button>
          </div>

          <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
            <label style="min-width:74px;">Edge Type</label>
            <div class="info" id="edgeTypeInfo">Undirected by default</div>
          </div>
        </div>

        <div class="panel-section" role="group" aria-label="Stack / Call frames">
          <label>Stack / Call Frames</label>
          <div class="stack" id="stackPanel" aria-live="polite">
            <div class="info">Stack is empty. Start the traversal to see push/pop events.</div>
          </div>

          <label style="margin-top:8px">Event Trace</label>
          <div class="trace" id="tracePanel" aria-live="polite">No events yet.</div>
        </div>

        <div class="panel-section" role="group" aria-label="Tips">
          <label>Quick Tips</label>
          <div class="hints">
            <div class="kbd">Click</div> to add a node
            <div class="kbd">Drag</div> from a node to another to create an edge
            <div class="kbd">Drag node</div> to reposition
            <div class="kbd">Pick Start</div> then Play/Step to run DFS
          </div>
        </div>
      </aside>
    </div>
  </div>

  <script>
    /*
      DFS Interactive Module
      - Build a graph by clicking to add nodes and dragging from node to node to create edges.
      - Select a start node and run DFS in recursive or iterative mode.
      - The traversal is converted to an event log which is animated step-by-step.
      - Supports Play/Pause, Step Forward, Step Back, Reset, and speed control.
      - All visuals are SVG + CSS.
    */

    (function(){

      // Basic constants & DOM
      const board = document.getElementById('board');
      const svg = document.getElementById('svgRoot');
      const nodesLayer = document.getElementById('nodesLayer');
      const edgesLayer = document.getElementById('edgesLayer');
      const tempEdgeLayer = document.getElementById('tempEdgeLayer');

      const addNodeBtn = document.getElementById('addNodeBtn');
      const pickStartBtn = document.getElementById('pickStartBtn');
      const startNodeInfo = document.getElementById('startNodeInfo');
      const modeSelect = document.getElementById('modeSelect');
      const directedToggle = document.getElementById('directedToggle');
      const playBtn = document.getElementById('playBtn');
      const stepFwd = document.getElementById('stepFwd');
      const stepBack = document.getElementById('stepBack');
      const resetBtn = document.getElementById('resetBtn');
      const speedRange = document.getElementById('speedRange');
      const stackPanel = document.getElementById('stackPanel');
      const tracePanel = document.getElementById('tracePanel');
      const discoverAllBtn = document.getElementById('discoverAllBtn');
      const clearGraphBtn = document.getElementById('clearGraphBtn');
      const edgeTypeInfo = document.getElementById('edgeTypeInfo');
      const helpBtn = document.getElementById('helpBtn');

      // State
      let nodes = []; // {id, x, y}
      let edges = []; // {id, from, to}
      let nodeIdSeq = 1;
      let edgeIdSeq = 1;
      let mode = 'recursive';
      let directed = false;
      let startNodeId = null;
      let addNodeMode = true;
      let pickStartMode = false;

      // Interaction state
      let draggingNode = null;
      let dragOffset = {x:0,y:0};
      let isDraggingCanvas = false;

      // Temp edge drawing
      let isDrawingEdge = false;
      let edgeStartNode = null;

      // Traversal playback
      let eventLog = []; // sequence of events
      let currentEventIndex = 0; // events applied [0..currentEventIndex-1]
      let playing = false;
      let playTimer = null;

      // Accessibility: announce small messages to tracePanel/stack live regions
      function announce(text){
        const p = document.createElement('div');
        p.textContent = text;
        tracePanel.appendChild(p);
        tracePanel.scrollTop = tracePanel.scrollHeight;
      }

      // Utility: mouse to svg coordinates
      function getSvgPoint(clientX, clientY){
        const pt = svg.createSVGPoint();
        pt.x = clientX; pt.y = clientY;
        const ctm = svg.getScreenCTM().inverse();
        return pt.matrixTransform(ctm);
      }

      // Node and edge rendering
      function render(){
        // edges first
        edgesLayer.innerHTML = '';
        for (const e of edges){
          const from = nodes.find(n=>n.id===e.from);
          const to = nodes.find(n=>n.id===e.to);
          if (!from || !to) continue;
          const line = document.createElementNS('http://www.w3.org/2000/svg','path');
          line.setAttribute('d', makeEdgePath(from,to));
          line.setAttribute('class','edge');
          line.dataset.id = e.id;
          edgesLayer.appendChild(line);
        }

        // nodes
        nodesLayer.innerHTML = '';
        for (const n of nodes){
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('transform', `translate(${n.x},${n.y})`);
          g.setAttribute('class', 'node unvisited');
          g.dataset.id = n.id;
          g.setAttribute('role','button');
          g.setAttribute('tabindex','0');
          g.setAttribute('aria-label', 'Node ' + n.label);

          const ring = document.createElementNS('http://www.w3.org/2000/svg','circle');
          ring.setAttribute('r','30');
          ring.setAttribute('class','pulse-ring');
          g.appendChild(ring);

          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('r','22');
          c.setAttribute('class','circle');
          g.appendChild(c);

          const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
          txt.setAttribute('x','0');
          txt.setAttribute('y','5');
          txt.setAttribute('text-anchor','middle');
          txt.textContent = n.label;
          g.appendChild(txt);

          // event handlers
          g.addEventListener('mousedown', onNodePointerDown);
          g.addEventListener('touchstart', onNodePointerDown, {passive:false});
          g.addEventListener('click', onNodeClick);
          g.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter' || ev.key===' ') onNodeClick(ev); });

          nodesLayer.appendChild(g);
        }

        updateEdgeTypeInfo();
      }

      function makeEdgePath(a,b){
        // simple straight line; for readability offset a bit if overlapping
        return `M ${a.x} ${a.y} L ${b.x} ${b.y}`;
      }

      // Add node at coordinates
      function addNodeAt(x,y){
        const label = String(nodeIdSeq);
        const n = { id: nodeIdSeq, x, y, label };
        nodeIdSeq++;
        nodes.push(n);
        render();
      }

      // Add edge
      function addEdge(fromId, toId){
        if (!directed) {
          // avoid double (from,to) duplicates in undirected: store smaller->larger
          const a = Math.min(fromId,toId), b = Math.max(fromId,toId);
          if (edges.some(e => (e.from===a && e.to===b) || (e.from===b && e.to===a))) return;
          edges.push({ id: edgeIdSeq++, from: a, to: b });
        } else {
          if (edges.some(e => e.from===fromId && e.to===toId)) return;
          edges.push({ id: edgeIdSeq++, from: fromId, to: toId });
        }
        render();
      }

      // Update edge hint text
      function updateEdgeTypeInfo(){
        edgeTypeInfo.textContent = directed ? 'Directed' : 'Undirected';
      }

      // Node handlers
      function onNodePointerDown(e){
        e.preventDefault();
        const target = e.currentTarget;
        const id = parseInt(target.dataset.id,10);
        const pt = (e.touches && e.touches[0]) ? e.touches[0] : e;
        const svgP = getSvgPoint(pt.clientX, pt.clientY);
        // start dragging node
        draggingNode = nodes.find(n=>n.id===id);
        dragOffset.x = svgP.x - draggingNode.x;
        dragOffset.y = svgP.y - draggingNode.y;

        // For drawing edge: start drawing if shift key is held (or long press)
        if (e.shiftKey || e.button === 2) {
          // start drawing edge
          startDrawingEdge(draggingNode, svgP.x, svgP.y);
          draggingNode = null;
        } else {
          // normal drag move
          window.addEventListener('mousemove', onPointerMove);
          window.addEventListener('mouseup', onPointerUp);
          window.addEventListener('touchmove', onPointerMove, {passive:false});
          window.addEventListener('touchend', onPointerUp);
        }
      }

      function onPointerMove(e){
        e.preventDefault();
        const pt = (e.touches && e.touches[0]) ? e.touches[0] : e;
        const svgP = getSvgPoint(pt.clientX, pt.clientY);
        if (draggingNode){
          draggingNode.x = svgP.x - dragOffset.x;
          draggingNode.y = svgP.y - dragOffset.y;
          render();
        } else if (isDrawingEdge){
          // update temp line
          const from = edgeStartNode;
          tempEdgeLayer.innerHTML = '';
          const line = document.createElementNS('http://www.w3.org/2000/svg','path');
          line.setAttribute('d', `M ${from.x} ${from.y} L ${svgP.x} ${svgP.y}`);
          line.setAttribute('stroke','#7c3aed');
          line.setAttribute('stroke-width','3');
          line.setAttribute('fill','none');
          tempEdgeLayer.appendChild(line);
        }
      }

      function onPointerUp(e){
        e.preventDefault();
        if (draggingNode){
          draggingNode = null;
          window.removeEventListener('mousemove', onPointerMove);
          window.removeEventListener('mouseup', onPointerUp);
          window.removeEventListener('touchmove', onPointerMove);
          window.removeEventListener('touchend', onPointerUp);
        } else if (isDrawingEdge){
          // check where it was released - if on a node, create edge
          tempEdgeLayer.innerHTML = '';
          const pt = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : e;
          const svgP = getSvgPoint(pt.clientX, pt.clientY);
          const target = nearestNodeWithin(svgP.x, svgP.y, 26);
          if (target && target.id !== edgeStartNode.id){
            addEdge(edgeStartNode.id, target.id);
          }
          edgeStartNode = null;
          isDrawingEdge = false;
        }
      }

      function onNodeClick(e){
        if (pickStartMode){
          const id = parseInt(e.currentTarget.dataset.id,10);
          startNodeId = id;
          startNodeInfo.textContent = 'Start: ' + id;
          pickStartMode = false;
          pickStartBtn.classList.remove('btn--active');
          saveUiState();
        } else if (addNodeMode){
          // clicking node selects it (for future features), for now toggle selection highlight
          // small pulse
          const g = e.currentTarget;
          g.classList.add('pulse');
          setTimeout(()=>g.classList.remove('pulse'), 800);
        }
      }

      // Board click: add node
      board.addEventListener('click', function(e){
        // ignore clicks on existing nodes (handled separately)
        if (e.target.closest('.node')) return;
        if (!addNodeMode) return;
        const svgP = getSvgPoint(e.clientX, e.clientY);
        addNodeAt(svgP.x, svgP.y);
      });

      // Start drawing edge from node
      function startDrawingEdge(node, x, y){
        isDrawingEdge = true;
        edgeStartNode = node;
        tempEdgeLayer.innerHTML = '';
        const line = document.createElementNS('http://www.w3.org/2000/svg','path');
        line.setAttribute('d', `M ${x} ${y} L ${x} ${y}`);
        line.setAttribute('stroke','#7c3aed');
        line.setAttribute('stroke-width','3');
        line.setAttribute('fill','none');
        tempEdgeLayer.appendChild(line);
        window.addEventListener('mousemove', onPointerMove);
        window.addEventListener('mouseup', onPointerUp);
        window.addEventListener('touchmove', onPointerMove, {passive:false});
        window.addEventListener('touchend', onPointerUp);
      }

      // find nearest node within radius
      function nearestNodeWithin(x,y,radius){
        let best = null, bestd = radius*radius;
        for (const n of nodes){
          const dx = n.x - x, dy = n.y - y;
          const d = dx*dx + dy*dy;
          if (d < bestd){
            bestd = d; best = n;
          }
        }
        return best;
      }

      // UI button events
      addNodeBtn.addEventListener('click', ()=>{
        addNodeMode = true;
        pickStartMode = false;
        addNodeBtn.setAttribute('aria-pressed','true');
        pickStartBtn.setAttribute('aria-pressed','false');
      });

      pickStartBtn.addEventListener('click', ()=>{
        pickStartMode = !pickStartMode;
        if (pickStartMode){
          addNodeMode = false;
          pickStartBtn.setAttribute('aria-pressed','true');
          addNodeBtn.setAttribute('aria-pressed','false');
        } else {
          pickStartBtn.setAttribute('aria-pressed','false');
        }
      });

      directedToggle.addEventListener('change', (e)=>{
        directed = e.target.checked;
        render();
      });

      modeSelect.addEventListener('change', (e)=>{
        mode = e.target.value;
      });

      clearGraphBtn.addEventListener('click', ()=>{
        nodes = [];
        edges = [];
        nodeIdSeq = 1;
        edgeIdSeq = 1;
        startNodeId = null;
        startNodeInfo.textContent = 'No start node selected';
        resetTraversal();
        render();
      });

      discoverAllBtn.addEventListener('click', ()=>{
        // If no start node, run DFS from each unvisited to cover all components
        if (nodes.length === 0) return;
        startNodeId = nodes[0].id;
        startNodeInfo.textContent = 'Start: All components';
        runTraversalAll();
      });

      helpBtn.addEventListener('click', ()=>{
        alert('Quick tips:\n\n- Click anywhere on the board to add a node.\n- Drag from one node to another to create an edge.\n- Click "Pick Start" then click a node to set start node.\n- Toggle Recursive/Iterative mode and Play to animate DFS.\n- Use Step to go forward/back through events. Shift+Drag on a node also draws an edge.');
      });

      // Playback controls
      playBtn.addEventListener('click', ()=>{
        if (playing) stopPlaying();
        else startPlaying();
      });

      stepFwd.addEventListener('click', ()=>{
        pausePlaying();
        stepForward();
      });

      stepBack.addEventListener('click', ()=>{
        pausePlaying();
        stepBackwards();
      });

      resetBtn.addEventListener('click', ()=>{
        pausePlaying();
        resetTraversal();
      });

      speedRange.addEventListener('input', ()=>{
        if (playing) {
          stopPlaying();
          startPlaying();
        }
      });

      // ---------------------------
      // Traversal: generate event log
      // events: { type:'discover'|'explore'|'finish'|'push'|'pop', node: id, from?:id, to?:id }
      // For both recursive and iterative we will generate events that are easy to play.
      // ---------------------------
      function buildAdjacency(){
        const adj = new Map();
        for (const n of nodes) adj.set(n.id, []);
        for (const e of edges){
          if (!directed){
            // edges stored maybe as smaller->larger; but we should add adjacency both ways
            adj.get(e.from).push(e.to);
            adj.get(e.to).push(e.from);
          } else {
            adj.get(e.from).push(e.to);
          }
        }
        // We'll keep neighbor order as insertion order (i.e., as edges were added).
        return adj;
      }

      function generateEventsRecursive(startId){
        eventLog = [];
        const adj = buildAdjacency();
        const visited = new Set();

        function dfs(u){
          eventLog.push({type:'discover', node:u});
          visited.add(u);
          const neighbors = adj.get(u) || [];
          for (const v of neighbors){
            eventLog.push({type:'explore', from:u, to:v});
            if (!visited.has(v)){
              dfs(v);
            } else {
              // short note: already visited
            }
          }
          eventLog.push({type:'finish', node:u});
        }

        if (startId != null){
          dfs(startId);
        }
        return eventLog;
      }

      function generateEventsIterative(startId){
        eventLog = [];
        const adj = buildAdjacency();
        const visited = new Set();
        if (startId == null) return eventLog;

        // iterative stack contains {node, nextIndex}
        const stack = [];
        stack.push({node:startId, nextIndex:0});
        eventLog.push({type:'push', node:startId});
        eventLog.push({type:'discover', node:startId});
        visited.add(startId);

        while (stack.length){
          const frame = stack[stack.length-1];
          const u = frame.node;
          const neighbors = adj.get(u) || [];
          if (frame.nextIndex < neighbors.length){
            const v = neighbors[frame.nextIndex];
            frame.nextIndex++;
            eventLog.push({type:'explore', from:u, to:v});
            if (!visited.has(v)){
              visited.add(v);
              eventLog.push({type:'push', node:v});
              eventLog.push({type:'discover', node:v});
              stack.push({node:v, nextIndex:0});
            } else {
              // already visited, just note exploration
            }
          } else {
            // finished u
            eventLog.push({type:'pop', node:u});
            eventLog.push({type:'finish', node:u});
            stack.pop();
          }
        }
        return eventLog;
      }

      // If wanting to traverse all components (Discover All)
      function generateEventsAll(modeOption){
        eventLog = [];
        const adj = buildAdjacency();
        const visited = new Set();
        const allNodes = Array.from(adj.keys());
        for (const start of allNodes){
          if (!visited.has(start)){
            if (modeOption === 'recursive'){
              // local recursive that references visited outside
              function dfs(u){
                eventLog.push({type:'discover', node:u});
                visited.add(u);
                const neighbors = adj.get(u) || [];
                for (const v of neighbors){
                  eventLog.push({type:'explore', from:u, to:v});
                  if (!visited.has(v)){
                    dfs(v);
                  }
                }
                eventLog.push({type:'finish', node:u});
              }
              dfs(start);
            } else {
              // iterative from start
              const stack = [];
              stack.push({node:start, nextIndex:0});
              eventLog.push({type:'push', node:start});
              eventLog.push({type:'discover', node:start});
              visited.add(start);
              while (stack.length){
                const frame = stack[stack.length-1];
                const u = frame.node;
                const neighbors = adj.get(u) || [];
                if (frame.nextIndex < neighbors.length){
                  const v = neighbors[frame.nextIndex];
                  frame.nextIndex++;
                  eventLog.push({type:'explore', from:u, to:v});
                  if (!visited.has(v)){
                    visited.add(v);
                    eventLog.push({type:'push', node:v});
                    eventLog.push({type:'discover', node:v});
                    stack.push({node:v, nextIndex:0});
                  }
                } else {
                  eventLog.push({type:'pop', node:u});
                  eventLog.push({type:'finish', node:u});
                  stack.pop();
                }
              }
            }
          }
        }
        return eventLog;
      }

      // Playback: apply events up to a given index. We'll rebuild state from scratch and apply first N events for simplicity.
      function applyEventsUpTo(index){
        // index is number of events to apply
        // reset visuals
        for (const g of Array.from(nodesLayer.children || [])){
          g.classList.remove('discovered','finished','pulse');
          g.classList.add('unvisited');
        }
        for (const e of Array.from(edgesLayer.children || [])){
          e.classList.remove('highlight','dim');
        }
        // clear stack and trace
        stackPanel.innerHTML = '';
        tracePanel.innerHTML = '';

        const stackRep = []; // for display, for iterative mode reflect pushes/pops; for recursive we show call frames
        const discovered = new Set();

        for (let i=0;i<index && i<eventLog.length;i++){
          const ev = eventLog[i];
          handleEvent(ev, stackRep, discovered);
        }
      }

      function handleEvent(ev, stackRep, discovered){
        if (ev.type === 'discover'){
          const g = findNodeGroup(ev.node);
          if (g){
            g.classList.remove('unvisited');
            g.classList.add('discovered');
            // pulse
            g.classList.add('pulse');
            setTimeout(()=>g.classList.remove('pulse'), 600);
          }
          discovered.add(ev.node);
          appendTrace(`Discovered node ${ev.node}`);
        } else if (ev.type === 'explore'){
          highlightEdge(ev.from, ev.to);
          appendTrace(`Exploring edge ${ev.from} → ${ev.to}`);
        } else if (ev.type === 'finish'){
          const g = findNodeGroup(ev.node);
          if (g){
            g.classList.remove('discovered');
            g.classList.add('finished');
          }
          appendTrace(`Finished node ${ev.node}`);
        } else if (ev.type === 'push'){
          stackRep.push(ev.node);
          renderStack(stackRep);
          appendTrace(`Push ${ev.node} onto stack`);
        } else if (ev.type === 'pop'){
          const popped = stackRep.pop();
          renderStack(stackRep);
          appendTrace(`Pop ${popped} from stack`);
        }
      }

      function findNodeGroup(id){
        return nodesLayer.querySelector(`g[data-id="${id}"]`);
      }

      function appendTrace(text){
        const d = document.createElement('div');
        d.textContent = text;
        tracePanel.appendChild(d);
        tracePanel.scrollTop = tracePanel.scrollHeight;
      }

      // Edge highlight animation
      function highlightEdge(from,to){
        // find nearest edge element that matches (undirected or directed)
        const all = Array.from(edgesLayer.children);
        let el = null;
        for (const e of all){
          const ed = edges.find(edg => String(edg.id) === e.dataset.id);
          if (!ed) continue;
          if (!directed){
            // check endpoints
            if ((ed.from === Math.min(from,to) && ed.to === Math.max(from,to)) || (ed.from === Math.max(from,to) && ed.to === Math.min(from,to))){
              el = e; break;
            }
          } else {
            if (ed.from === from && ed.to === to){ el = e; break; }
          }
        }
        if (el){
          el.classList.add('highlight');
          // remove after timeout to create transient effect
          setTimeout(()=> el.classList.remove('highlight'), Math.max(400, parseInt(speedRange.value)/2));
        }
      }

      function renderStack(stackRep){
        stackPanel.innerHTML = '';
        if (stackRep.length === 0){
          const d = document.createElement('div');
          d.className = 'info';
          d.textContent = 'Stack is empty';
          stackPanel.appendChild(d);
          return;
        }
        // show top at top
        for (let i = stackRep.length-1; i >= 0; i--){
          const f = document.createElement('div');
          f.className = 'frame';
          f.textContent = 'Node ' + stackRep[i];
          stackPanel.appendChild(f);
        }
      }

      // play / pause logic
      function startPlaying(){
        if (!prepareEventLog()) return;
        playing = true;
        playBtn.textContent = 'Pause';
        scheduleNext();
      }

      function pausePlaying(){
        playing = false;
        playBtn.textContent = 'Play';
        if (playTimer) clearTimeout(playTimer);
        playTimer = null;
      }

      function stopPlaying(){
        pausePlaying();
      }

      function scheduleNext(){
        if (!playing) return;
        if (currentEventIndex >= eventLog.length){
          // finished
          pausePlaying();
          return;
        }
        const delay = parseInt(speedRange.value,10);
        playTimer = setTimeout(()=>{
          currentEventIndex++;
          applyEventsUpTo(currentEventIndex);
          scheduleNext();
        }, delay);
      }

      function stepForward(){
        if (!prepareEventLog()) return;
        if (currentEventIndex < eventLog.length){
          currentEventIndex++;
          applyEventsUpTo(currentEventIndex);
        }
      }

      function stepBackwards(){
        if (!prepareEventLog()) return;
        if (currentEventIndex > 0){
          currentEventIndex--;
          applyEventsUpTo(currentEventIndex);
        }
      }

      function prepareEventLog(){
        if (nodes.length===0) { alert('No nodes to traverse. Add nodes first.'); return false; }
        if (startNodeId == null && !discoverAllModeRequested) {
          alert('No start node selected. Click "Pick Start" and select a node (or use Discover All).');
          return false;
        }
        // generate eventLog based on mode and start node
        if (discoverAllModeRequested){
          eventLog = generateEventsAll(mode);
          discoverAllModeRequested = false;
        } else {
          if (mode === 'recursive') eventLog = generateEventsRecursive(startNodeId);
          else eventLog = generateEventsIterative(startNodeId);
        }
        currentEventIndex = 0;
        // clear trace and stack
        stackPanel.innerHTML = '';
        tracePanel.innerHTML = '';
        return true;
      }

      // Reset traversal visuals and state
      function resetTraversal(){
        pausePlaying();
        currentEventIndex = 0;
        eventLog = [];
        stackPanel.innerHTML = '';
        tracePanel.innerHTML = '';
        // reset node classes
        for (const g of Array.from(nodesLayer.children || [])){
          g.classList.remove('discovered','finished','pulse');
          g.classList.add('unvisited');
        }
        for (const e of Array.from(edgesLayer.children || [])){
          e.classList.remove('highlight','dim');
        }
      }

      // Discover all mode
      let discoverAllModeRequested = false;
      function runTraversalAll(){
        // set flag so prepareEventLog will generate all
        discoverAllModeRequested = true;
        startPlaying();
      }

      // small helpers to save UI state (not persistent)
      function saveUiState(){
        // stub for future extension
      }

      // initial render
      render();

      // allow keyboard shortcuts for convenience
      window.addEventListener('keydown', (e)=>{
        if (e.key === ' ') { e.preventDefault(); if (playing) stopPlaying(); else startPlaying(); }
        if (e.key === 'ArrowRight') { e.preventDefault(); stepForward(); }
        if (e.key === 'ArrowLeft') { e.preventDefault(); stepBackwards(); }
        if (e.key === 'r') { resetTraversal(); }
      });

      // minimal touch: long touch on node draws edge
      // (we already support shift+drag for edge drawing; touch devices can use long press)
      let longPressTimer = null;
      board.addEventListener('touchstart', (e)=>{
        if (e.target.closest('.node')){
          const nodeEl = e.target.closest('.node');
          longPressTimer = setTimeout(()=>{
            // simulate shift-drag
            const id = parseInt(nodeEl.dataset.id,10);
            const node = nodes.find(n=>n.id===id);
            const client = e.touches[0];
            const svgP = getSvgPoint(client.clientX, client.clientY);
            startDrawingEdge(node, svgP.x, svgP.y);
          }, 450);
        }
      });
      board.addEventListener('touchend', ()=>{ if (longPressTimer) clearTimeout(longPressTimer); });

      // expose some functions for debugging (optional)
      window.__dfs_debug = {
        nodes, edges, addNodeAt, addEdge, render
      };

    })();
  </script>
</body>
</html>