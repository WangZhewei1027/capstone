<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Binary Tree — Interactive Module</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #60a5fa;
      --muted: #94a3b8;
      --card: #071026;
      --success: #34d399;
      --danger: #fb7185;
      --node-bg: linear-gradient(180deg,#1f2937,#111827);
      --glass: rgba(255,255,255,0.03);
      --font-sans: system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
    }
    html,body{
      height:100%;
      margin:0;
      font-family: var(--font-sans);
      background: linear-gradient(180deg,#071021 0%, #081129 60%, #041018 100%);
      color:#e6eef8;
    }
    /* Safe area container */
    .container{
      padding: var(--safe-padding);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      gap:var(--gap);
      align-items:stretch;
    }

    /* Left control column */
    .panel{
      width:360px;
      max-width:40%;
      min-width:300px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:20px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      box-shadow: 0 6px 18px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    }

    h1{
      margin:0;
      font-size:18px;
      letter-spacing:0.2px;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
      margin-top:6px;
    }

    .card{
      background:var(--card);
      border-radius:10px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    label{ font-size:13px; color:var(--muted); }
    input[type="text"], input[type="number"], select {
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:inherit;
      padding:8px 10px;
      border-radius:8px;
      outline:none;
    }
    input:focus, select:focus { box-shadow: 0 0 0 4px rgba(96,165,250,0.08); border-color:var(--accent); }

    .row { display:flex; gap:12px; align-items:center; }
    button {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.06);
      color:inherit;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      transition: transform .08s ease, box-shadow .12s ease;
      font-weight:600;
    }
    button:active{ transform: translateY(1px); }
    button.primary{
      background: linear-gradient(180deg, #60a5fa22, #3b82f622);
      border-color: rgba(96,165,250,0.24);
      box-shadow: 0 6px 18px rgba(59,130,246,0.08), inset 0 -1px 0 rgba(255,255,255,0.02);
    }
    button.ghost{
      background:transparent;
      border:1px dashed rgba(255,255,255,0.04);
      color:var(--muted);
    }
    .small{ padding:6px 8px; font-size:13px; border-radius:7px; }

    /* Right visual area */
    .stage{
      flex:1;
      min-height:600px;
      background: linear-gradient(180deg, rgba(255,255,255,0.014), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:18px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .stage-top{
      display:flex;
      justify-content:space-between;
      gap:var(--gap);
      align-items:center;
    }
    .legend {
      color:var(--muted);
      font-size:13px;
      display:flex;
      gap:10px;
      align-items:center;
    }
    .legend .dot{
      width:12px;height:12px;border-radius:999px;background:var(--accent); box-shadow:0 4px 10px rgba(96,165,250,0.16);
    }

    /* Canvas area */
    .canvas-wrap{
      flex:1;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.03);
      position:relative;
      overflow:auto;
      padding:14px;
    }
    svg {
      width:100%;
      height:100%;
      min-height:420px;
      overflow:visible;
      display:block;
    }

    /* Node styles */
    .node {
      cursor:default;
      transition: transform .18s cubic-bezier(.2,.9,.3,1), filter .18s;
      filter: drop-shadow(0 6px 14px rgba(2,6,23,0.6));
    }
    .node circle{
      fill: url(#nodeGrad);
      stroke: rgba(255,255,255,0.06);
      stroke-width:1.2;
      transition: fill .18s, stroke .12s, r .12s;
    }
    .node text{
      font-size:13px;
      pointer-events:none;
      fill: #e6eef8;
      font-weight:700;
    }
    .node .hint {
      fill: var(--muted);
      font-weight:600;
      font-size:11px;
    }

    .node:hover { transform: translateY(-6px); }
    .node.selected circle{
      stroke: var(--accent);
      stroke-width:2.4;
      box-shadow: 0 8px 28px rgba(96,165,250,0.12);
    }

    .node.empty-child .plus {
      font-size:18px;
      fill:var(--muted);
      cursor:pointer;
    }

    .edge{
      stroke: rgba(255,255,255,0.06);
      stroke-width:2;
      fill:none;
      transition: stroke .12s;
    }
    .edge.highlight{
      stroke: #60a5fa;
      stroke-width:3.2;
      stroke-opacity:1;
    }

    /* Traversal animation */
    .pulse {
      animation: pulse 900ms ease forwards;
    }
    @keyframes pulse {
      0% { transform: scale(1); filter: drop-shadow(0 6px 14px rgba(2,6,23,0.6)); }
      35% { transform: scale(1.26); }
      100% { transform: scale(1); filter: drop-shadow(0 10px 30px rgba(96,165,250,0.12)); }
    }

    /* Control list showing traversal sequence */
    .sequence {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .pill {
      padding:6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.03);
      font-weight:700;
      color:var(--muted);
      min-width:36px;
      text-align:center;
    }
    .pill.current { background: linear-gradient(90deg,#60a5fa33,#3b82f633); color:#e6f3ff; border-color: rgba(96,165,250,0.14); }

    /* footer small notes */
    .note { font-size:13px; color:var(--muted); }

    /* responsive */
    @media (max-width:900px){
      .container{ flex-direction:column; padding:18px; }
      .panel{ width:100%; max-width:none; min-width:0; }
      .stage{ width:100%; }
    }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Binary Tree interactive module">
    <!-- LEFT PANEL: Descriptions & Controls -->
    <aside class="panel" aria-labelledby="title">
      <div>
        <h1 id="title">Binary Tree — Structure & Traversals</h1>
        <div class="muted">Build a binary tree and watch traversals step through nodes visually.</div>
      </div>

      <!-- Learning objective -->
      <div class="card" aria-live="polite">
        <strong>Learning Objective</strong>
        <div class="muted">
          After using this module you will be able to:
          - construct a binary tree by adding left/right children,
          - visualize the tree structure,
          - observe preorder, inorder, postorder and level-order traversals step-by-step.
        </div>
      </div>

      <!-- Interaction Design (textual description required) -->
      <div class="card" id="interaction-design" tabindex="0">
        <strong>Interaction Design</strong>
        <div class="muted">
          - Click a node to select it. Click the small + near an empty child to add a left/right child.<br>
          - Double-click a node value to edit it. Select a node and use "Delete Subtree" to remove it.<br>
          - Use traversal buttons to animate visits. The current node pulses and edges highlight in sequence. A list shows visited order.
        </div>
      </div>

      <!-- Layout Description (textual) -->
      <div class="card" id="layout-desc" tabindex="0">
        <strong>Layout Description</strong>
        <div class="muted">
          Left column: controls, inputs and explanations. Right area: the canvas displaying the tree (SVG) with nodes and edges. Spacing: 24px safe margin; 16px minimum gap between interactive controls. Responsive layout stacks vertically on narrow screens. Controls are keyboard accessible.
        </div>
      </div>

      <!-- Controls -->
      <div class="card" aria-label="Controls">
        <label for="node-value">Node value</label>
        <div class="row">
          <input id="node-value" type="text" placeholder="e.g. 7" aria-label="Node value" />
          <button id="create-root" class="primary small" title="Create root node">Create Root</button>
        </div>

        <div style="height:8px;"></div>

        <label>Selected node</label>
        <div class="row" style="align-items:center;">
          <div id="selected-info" class="muted" style="flex:1">None</div>
          <button id="delete-subtree" class="ghost small" title="Delete selected node and its subtree">Delete Subtree</button>
        </div>

        <div style="height:6px;"></div>

        <label>Traversals</label>
        <div style="display:flex;gap:8px;flex-wrap:wrap;">
          <button class="small" id="btn-pre">Preorder</button>
          <button class="small" id="btn-in">Inorder</button>
          <button class="small" id="btn-post">Postorder</button>
          <button class="small" id="btn-level">Level-Order</button>
        </div>

        <div style="height:8px;"></div>

        <div class="row">
          <button id="btn-random" class="small">Random Tree</button>
          <button id="btn-reset" class="small">Reset</button>
        </div>

        <div style="height:6px;"></div>

        <div class="note">Tip: add nodes by clicking the small + markers near an empty left/right child location in the canvas. Double-click a node to rename it.</div>
      </div>

      <!-- Traversal sequence display -->
      <div class="card" aria-live="polite">
        <label>Traversal sequence (live)</label>
        <div id="sequence" class="sequence" aria-live="polite" style="min-height:44px; align-items:center;"></div>
      </div>

      <div class="muted" style="font-size:12px;">
        Accessibility: All buttons and inputs are keyboard focusable. SVG nodes have accessible titles.
      </div>
    </aside>

    <!-- RIGHT: Canvas / Stage -->
    <main class="stage" aria-labelledby="title">
      <div class="stage-top">
        <div class="legend"><span class="dot" aria-hidden="true"></span> Visual tree</div>
        <div class="muted">Click nodes to select. Use controls on the left to manipulate and traverse.</div>
      </div>

      <div class="canvas-wrap" id="canvas-wrap" tabindex="0" aria-label="Tree canvas">
        <!-- SVG will be injected here -->
        <svg id="svgRoot" viewBox="0 0 1200 600" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Binary tree visualization">
          <defs>
            <linearGradient id="nodeGrad" x1="0" x2="0" y1="0" y2="1">
              <stop offset="0" stop-color="#0ea5e9" stop-opacity="0.08"></stop>
              <stop offset="1" stop-color="#0b1220" stop-opacity="0.6"></stop>
            </linearGradient>
            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
              <feGaussianBlur stdDeviation="6" result="coloredBlur"/>
              <feMerge>
                <feMergeNode in="coloredBlur"/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>
          <g id="edges"></g>
          <g id="nodes"></g>
        </svg>
      </div>
    </main>
  </div>

  <script>
    // Self-contained Binary Tree interactive module
    (function(){
      // Basic data model
      let nodeIdCounter = 1;
      function makeNode(value){
        return {
          id: 'n' + (nodeIdCounter++),
          value: String(value),
          left: null,
          right: null,
          parent: null
        };
      }

      let root = null;
      let selected = null;
      const svg = document.getElementById('svgRoot');
      const nodesLayer = document.getElementById('nodes');
      const edgesLayer = document.getElementById('edges');
      const seqWrap = document.getElementById('sequence');
      const selectedInfo = document.getElementById('selected-info');

      // Layout config
      const canvasW = 1200, canvasH = 600;
      const nodeR = 26;
      const vGap = 110;

      // UI elements
      const inputVal = document.getElementById('node-value');
      const btnCreateRoot = document.getElementById('create-root');
      const btnReset = document.getElementById('btn-reset');
      const btnRandom = document.getElementById('btn-random');
      const btnPre = document.getElementById('btn-pre');
      const btnIn = document.getElementById('btn-in');
      const btnPost = document.getElementById('btn-post');
      const btnLevel = document.getElementById('btn-level');
      const btnDelete = document.getElementById('delete-subtree');

      // Simple helpers
      function setSelected(node){
        selected = node;
        render();
        selectedInfo.textContent = selected ? (selected.value + ' (' + selected.id + ')') : 'None';
      }

      function clearSequence(){
        seqWrap.innerHTML = '';
      }
      function pushSequenceLabel(val, highlight=false){
        const pill = document.createElement('div');
        pill.className = 'pill' + (highlight ? ' current' : '');
        pill.textContent = val;
        seqWrap.appendChild(pill);
      }

      // Tree manipulations
      function insertChild(parent, side, value){
        if(!parent) return;
        if(side==='left'){
          if(parent.left) return alert('Left child exists.');
          const n = makeNode(value);
          parent.left = n; n.parent = parent;
        } else {
          if(parent.right) return alert('Right child exists.');
          const n = makeNode(value);
          parent.right = n; n.parent = parent;
        }
        render();
      }

      function deleteSubtree(node){
        if(!node) return;
        if(node.parent){
          if(node.parent.left === node) node.parent.left = null;
          else if(node.parent.right === node) node.parent.right = null;
        } else {
          root = null;
        }
        setSelected(null);
        render();
      }

      function findNodeById(id, cur=root){
        if(!cur) return null;
        if(cur.id === id) return cur;
        return findNodeById(id, cur.left) || findNodeById(id, cur.right);
      }

      // Traversal generators
      function preorder(n, arr=[]){
        if(!n) return arr;
        arr.push(n);
        preorder(n.left, arr);
        preorder(n.right, arr);
        return arr;
      }
      function inorder(n, arr=[]){
        if(!n) return arr;
        inorder(n.left, arr);
        arr.push(n);
        inorder(n.right, arr);
        return arr;
      }
      function postorder(n, arr=[]){
        if(!n) return arr;
        postorder(n.left, arr);
        postorder(n.right, arr);
        arr.push(n);
        return arr;
      }
      function levelOrder(n){
        const arr=[];
        if(!n) return arr;
        const q=[n];
        while(q.length){
          const cur=q.shift(); arr.push(cur);
          if(cur.left) q.push(cur.left);
          if(cur.right) q.push(cur.right);
        }
        return arr;
      }

      // Layout algorithm: compute x by inorder index scaled to canvas width
      function computePositions(){
        let index = 0;
        const positions = new Map();
        function dfs(node, depth){
          if(!node) return;
          dfs(node.left, depth+1);
          const x = ++index;
          positions.set(node.id, {xIndex:x, depth});
          dfs(node.right, depth+1);
        }
        index = 0;
        dfs(root, 0);
        const total = Math.max(1, index);
        // map xIndex to coordinate with padding
        for(const [id,pos] of positions){
          const cx = (pos.xIndex / (total + 1)) * (canvasW - 120) + 60;
          const cy = 60 + pos.depth * vGap;
          pos.cx = cx;
          pos.cy = cy;
        }
        return positions;
      }

      // Draw utilities
      function clearSVG(){
        nodesLayer.innerHTML = '';
        edgesLayer.innerHTML = '';
      }

      function createEdge(x1,y1,x2,y2, idFrom, idTo){
        const path = document.createElementNS('http://www.w3.org/2000/svg','path');
        const dx = x2 - x1;
        const dy = y2 - y1;
        const mx = x1 + dx * 0.5;
        const my = y1 + dy * 0.25;
        const d = `M ${x1} ${y1} Q ${mx} ${my} ${x2} ${y2}`;
        path.setAttribute('d', d);
        path.setAttribute('class','edge');
        path.setAttribute('data-from', idFrom);
        path.setAttribute('data-to', idTo);
        edgesLayer.appendChild(path);
      }

      function createNodeElement(node, pos, positions){
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.classList.add('node');
        g.setAttribute('transform', `translate(${pos.cx}, ${pos.cy})`);
        g.setAttribute('data-id', node.id);
        g.setAttribute('role','button');
        g.setAttribute('tabindex','0');
        g.setAttribute('aria-label', 'Node ' + node.value);

        if(selected && selected.id === node.id) g.classList.add('selected');

        // main circle
        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('r', nodeR);
        g.appendChild(circle);

        // text
        const text = document.createElementNS('http://www.w3.org/2000/svg','text');
        text.setAttribute('x',0);
        text.setAttribute('y',6);
        text.setAttribute('text-anchor','middle');
        text.textContent = node.value;
        g.appendChild(text);

        // left empty child placeholder
        const leftX = -nodeR*2.4;
        const rightX = nodeR*2.4;
        const childY = nodeR + 10;

        if(!node.left){
          const plus = document.createElementNS('http://www.w3.org/2000/svg','text');
          plus.setAttribute('x', leftX);
          plus.setAttribute('y', childY);
          plus.setAttribute('text-anchor','middle');
          plus.setAttribute('class','hint plus');
          plus.textContent = '+';
          plus.style.cursor = 'pointer';
          plus.addEventListener('click', (e)=>{
            e.stopPropagation();
            promptAddChild(node, 'left');
          });
          g.appendChild(plus);
        } else {
          // marker for left child exists (small filled dot)
          const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
          dot.setAttribute('cx', leftX);
          dot.setAttribute('cy', childY+2);
          dot.setAttribute('r', 4);
          dot.setAttribute('fill', '#60a5fa33');
          g.appendChild(dot);
        }

        if(!node.right){
          const plusr = document.createElementNS('http://www.w3.org/2000/svg','text');
          plusr.setAttribute('x', rightX);
          plusr.setAttribute('y', childY);
          plusr.setAttribute('text-anchor','middle');
          plusr.setAttribute('class','hint plus');
          plusr.textContent = '+';
          plusr.style.cursor = 'pointer';
          plusr.addEventListener('click', (e)=>{
            e.stopPropagation();
            promptAddChild(node, 'right');
          });
          g.appendChild(plusr);
        } else {
          const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
          dot.setAttribute('cx', rightX);
          dot.setAttribute('cy', childY+2);
          dot.setAttribute('r', 4);
          dot.setAttribute('fill', '#60a5fa33');
          g.appendChild(dot);
        }

        // events
        g.addEventListener('click', (e)=>{
          e.stopPropagation();
          setSelected(node);
        });
        g.addEventListener('dblclick', (e)=>{
          e.stopPropagation();
          editNodeValue(node);
        });
        g.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter' || e.key === ' ') setSelected(node);
          if(e.key === 'Delete') { deleteSubtree(node); }
        });

        nodesLayer.appendChild(g);
      }

      // Add child prompt
      function promptAddChild(parent, side){
        const val = prompt('Enter value for ' + side + ' child of ' + parent.value + ':', '');
        if(val === null) return;
        if(val.trim() === '') return alert('Value cannot be empty.');
        insertChild(parent, side, val);
      }

      function editNodeValue(node){
        const val = prompt('Edit value for node (id:' + node.id + ')', node.value);
        if(val === null) return;
        if(val.trim() === '') return alert('Value cannot be empty.');
        node.value = String(val);
        render();
      }

      // Render entire tree
      function render(){
        clearSequence();
        clearSVG();
        if(!root) return;
        const positions = computePositions();

        // draw edges first
        function dfsEdges(node){
          if(!node) return;
          const pos = positions.get(node.id);
          if(node.left){
            const p2 = positions.get(node.left.id);
            createEdge(pos.cx, pos.cy + nodeR - 2, p2.cx, p2.cy - nodeR + 2, node.id, node.left.id);
          }
          if(node.right){
            const p2 = positions.get(node.right.id);
            createEdge(pos.cx, pos.cy + nodeR - 2, p2.cx, p2.cy - nodeR + 2, node.id, node.right.id);
          }
          dfsEdges(node.left);
          dfsEdges(node.right);
        }
        dfsEdges(root);

        // draw nodes
        function dfsNodes(node){
          if(!node) return;
          const pos = positions.get(node.id);
          createNodeElement(node, pos, positions);
          dfsNodes(node.left);
          dfsNodes(node.right);
        }
        dfsNodes(root);
      }

      // Traversal animation
      let animTimer = null;
      function animateTraversal(order){
        if(animTimer) {
          clearInterval(animTimer);
          animTimer = null;
          // remove any pulsing classes left
          document.querySelectorAll('.node').forEach(n=>n.classList.remove('pulse'));
          document.querySelectorAll('.edge').forEach(e=>e.classList.remove('highlight'));
          clearSequence();
        }
        if(!order || order.length===0) return;
        // display sequence labels
        clearSequence();
        order.forEach(n => pushSequenceLabel(n.value));
        let idx = 0;
        const nodesMap = new Map();
        document.querySelectorAll('.node').forEach(el=>{
          nodesMap.set(el.getAttribute('data-id'), el);
        });
        const edges = Array.from(document.querySelectorAll('.edge'));

        animTimer = setInterval(()=>{
          // clear previous highlights
          document.querySelectorAll('.node').forEach(n=>{ n.classList.remove('pulse'); });
          edges.forEach(e => e.classList.remove('highlight'));

          if(idx >= order.length){
            clearInterval(animTimer);
            animTimer = null;
            return;
          }
          const cur = order[idx];
          const el = nodesMap.get(cur.id);
          if(el){
            // highlight the node element
            el.classList.add('pulse');
            // highlight edge from parent if exists
            if(cur.parent){
              const pair = edges.find(e => e.getAttribute('data-from') === cur.parent.id && e.getAttribute('data-to') === cur.id);
              if(pair) pair.classList.add('highlight');
            }
            // mark sequence pill
            const pills = seqWrap.querySelectorAll('.pill');
            pills.forEach(p => p.classList.remove('current'));
            if(pills[idx]) pills[idx].classList.add('current');
            // set selected preview
            selectedInfo.textContent = 'Visiting: ' + cur.value;
          }
          idx++;
        }, 700);
      }

      // Hook up UI events
      btnCreateRoot.addEventListener('click', ()=>{
        const v = inputVal.value.trim();
        if(v === ''){
          alert('Enter a value for root node in "Node value".');
          inputVal.focus();
          return;
        }
        root = makeNode(v);
        setSelected(root);
        render();
      });
      btnReset.addEventListener('click', ()=>{
        if(!confirm('Reset the tree?')) return;
        root = null;
        setSelected(null);
        clearSequence();
        render();
      });
      btnRandom.addEventListener('click', ()=>{
        // generate random small tree
        root = makeNode(Math.floor(Math.random()*99)+1);
        function maybeAdd(node, depth){
          if(depth>3) return;
          if(Math.random() > 0.45){
            node.left = makeNode(Math.floor(Math.random()*99)+1);
            node.left.parent = node;
            maybeAdd(node.left, depth+1);
          }
          if(Math.random() > 0.45){
            node.right = makeNode(Math.floor(Math.random()*99)+1);
            node.right.parent = node;
            maybeAdd(node.right, depth+1);
          }
        }
        maybeAdd(root, 0);
        setSelected(root);
        render();
      });

      btnDelete.addEventListener('click', ()=>{
        if(!selected) { alert('No node selected.'); return; }
        if(!confirm('Delete node ' + selected.value + ' and its subtree?')) return;
        deleteSubtree(selected);
      });

      btnPre.addEventListener('click', ()=>{
        if(!root) return alert('Tree is empty.');
        const order = preorder(root, []);
        animateTraversal(order);
      });
      btnIn.addEventListener('click', ()=>{
        if(!root) return alert('Tree is empty.');
        const order = inorder(root, []);
        animateTraversal(order);
      });
      btnPost.addEventListener('click', ()=>{
        if(!root) return alert('Tree is empty.');
        const order = postorder(root, []);
        animateTraversal(order);
      });
      btnLevel.addEventListener('click', ()=>{
        if(!root) return alert('Tree is empty.');
        const order = levelOrder(root);
        animateTraversal(order);
      });

      // clicking outside clears selection
      document.getElementById('canvas-wrap').addEventListener('click', (e)=>{
        // if clicked background area, deselect
        if(e.target === svg || e.target === document.getElementById('canvas-wrap')){
          setSelected(null);
        }
      });

      // keyboard: Enter on input to create root or add as child if selected
      inputVal.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){
          const v = inputVal.value.trim();
          if(v === '') return;
          if(selected){
            // prompt to choose left or right
            const side = prompt('Add as left or right child? (L/R)', 'L');
            if(!side) return;
            if(side.toLowerCase().startsWith('l')) insertChild(selected, 'left', v);
            else insertChild(selected, 'right', v);
          } else {
            root = makeNode(v);
            setSelected(root);
            render();
          }
        }
      });

      // initial sample
      (function sample(){
        // small default tree
        root = makeNode(8);
        root.left = makeNode(3); root.left.parent = root;
        root.right = makeNode(10); root.right.parent = root;
        root.left.left = makeNode(1); root.left.left.parent = root.left;
        root.left.right = makeNode(6); root.left.right.parent = root.left;
        root.right.right = makeNode(14); root.right.right.parent = root.right;
        setSelected(root);
        render();
      })();

      // Ensure svg viewBox fits content on resize for responsiveness:
      function resizeSVG(){
        // nothing complicated: keep viewBox constant; the wrapper scrolls if necessary
      }
      window.addEventListener('resize', resizeSVG);

      // Accessibility: focus canvas with keyboard will focus root
      document.getElementById('canvas-wrap').addEventListener('keydown', (e)=>{
        if(e.key === 'Tab') return;
        // basic navigation: Arrow keys to move selection to parent/left/right
        if(!selected) return;
        if(e.key === 'ArrowLeft' && selected.left){
          setSelected(selected.left);
        } else if(e.key === 'ArrowRight' && selected.right){
          setSelected(selected.right);
        } else if(e.key === 'ArrowUp' && selected.parent){
          setSelected(selected.parent);
        } else if(e.key === 'Delete'){
          deleteSubtree(selected);
        }
      });

    })();
  </script>
</body>
</html>