<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Priority Queue Explorer</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --accent: #1e88e5;
      --accent-2: #009688;
      --bg: #f7f9fc;
      --card: #ffffff;
      --muted: #6b7280;
      --danger: #e53935;
      --success: #2e7d32;
      --node-size: 56px;
      --level-gap: 96px;
    }

    /* Safe area margins */
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans",sans-serif;
      color:#0f1724;
    }
    .app{
      padding:var(--safe-margin);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    header{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    .sub{
      color:var(--muted);
      font-size:13px;
      margin:0;
    }

    main{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      width:100%;
    }

    /* left controls column */
    .controls{
      flex:0 0 320px;
      min-width:260px;
      background:var(--card);
      border-radius:10px;
      padding:16px;
      box-shadow:0 6px 20px rgba(16,24,40,0.06);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .controls h2{
      margin:0;
      font-size:14px;
      color:#09203a;
    }
    .form-row{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    label{
      font-size:13px;
      color:var(--muted);
    }
    input[type="text"], input[type="number"], select{
      padding:10px 12px;
      border-radius:8px;
      border:1px solid #e6edf3;
      background:transparent;
      font-size:14px;
      flex:1 1 auto;
      min-width:0;
    }
    input[type="number"]{
      width:110px;
      -moz-appearance:textfield;
    }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button{
      -webkit-appearance:none;
      margin:0;
    }

    .btn-row{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
    }
    button{
      padding:10px 14px;
      border-radius:8px;
      border:0;
      background:var(--accent);
      color:white;
      cursor:pointer;
      font-weight:600;
      letter-spacing:0.2px;
    }
    button.secondary{
      background:transparent;
      color:var(--accent);
      border:1px solid rgba(30,136,229,0.12);
    }
    button.warn{
      background:var(--danger);
    }
    button:disabled{
      opacity:0.45;
      cursor:not-allowed;
    }

    .small{
      padding:8px 10px;
      font-size:13px;
      border-radius:8px;
    }

    .toggles{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .muted{
      font-size:13px;
      color:var(--muted);
    }

    /* Visualization area */
    .visual{
      flex:1 1 auto;
      min-height:420px;
      background:var(--card);
      border-radius:10px;
      padding:16px;
      box-shadow:0 6px 20px rgba(16,24,40,0.06);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      position:relative;
      overflow:hidden;
    }

    .vis-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:var(--gap);
    }
    .legend{
      display:flex;
      gap:12px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
    }
    .badge{
      padding:6px 10px;
      border-radius:999px;
      background:#f1f5f9;
      font-weight:600;
      color:#0f1724;
      font-size:13px;
    }

    /* Canvas container for nodes */
    .canvas{
      position:relative;
      background:linear-gradient(180deg, rgba(14,165,233,0.02), transparent 20%);
      border-radius:8px;
      flex:1 1 auto;
      min-height:320px;
      padding:16px;
      display:block;
    }

    /* array display */
    .array{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      padding-top:12px;
    }
    .arr-box{
      min-width:56px;
      height:56px;
      background:#fff;
      border-radius:8px;
      border:1px solid #e6edf3;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      gap:4px;
      padding:6px;
      font-size:13px;
      box-shadow:0 2px 8px rgba(16,24,40,0.04);
    }
    .arr-idx{
      font-size:11px;
      color:var(--muted);
    }
    .arr-val{
      font-weight:700;
      color:#0f1724;
    }

    /* node style */
    .node{
      position:absolute;
      width:var(--node-size);
      height:var(--node-size);
      border-radius:50%;
      background:linear-gradient(180deg,var(--accent),#0b63b8);
      color:white;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      box-shadow:0 8px 18px rgba(30,41,59,0.12);
      cursor:pointer;
      user-select:none;
      transition:transform 300ms cubic-bezier(.2,.9,.2,1), box-shadow 200ms, background 200ms;
      transform-origin:center;
      will-change:transform;
      outline:2px solid transparent;
    }
    .node .prio{
      font-size:12px;
      opacity:0.95;
      font-weight:700;
      line-height:1;
    }
    .node .lbl{
      font-size:11px;
      opacity:0.95;
      line-height:1;
    }
    .node:focus, .node.selected{
      box-shadow:0 12px 28px rgba(16,24,40,0.18);
      transform:translateY(-6px) scale(1.04);
      outline:3px solid rgba(30,136,229,0.18);
    }
    .node.min{
      background:linear-gradient(180deg,#00bfa5,#00897b);
    }

    /* connecting lines use svg */
    .links{
      position:absolute;
      inset:0;
      pointer-events:none;
    }

    /* accessibility helper on small screens */
    @media (max-width:880px){
      main{
        flex-direction:column;
      }
      .controls{
        width:100%;
      }
    }

    /* small helper */
    footer{
      font-size:12px;
      color:var(--muted);
      margin-top:8px;
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Priority Queue interactive module">
    <!-- Concept Title & Learning Objective -->
    <header>
      <h1>Priority Queue — Visual Heap Explorer</h1>
      <p class="sub">Learning Objective: Understand how a priority queue (implemented as a binary heap) organizes elements by priority and how enqueue, dequeue (pop), and update-priority operations re-balance the heap (bubble-up / sift-down).</p>
    </header>

    <main>
      <!-- Controls panel -->
      <section class="controls" aria-labelledby="controls-title">
        <h2 id="controls-title">Controls & Actions</h2>

        <div class="form-row" style="align-items:stretch;">
          <div style="flex:1; min-width:120px;">
            <label for="labelInput">Element label</label>
            <input id="labelInput" type="text" placeholder="e.g., Task A" aria-label="Element label" />
          </div>
          <div style="width:120px;">
            <label for="prioInput">Priority</label>
            <input id="prioInput" type="number" value="10" aria-label="Priority value" />
          </div>
        </div>

        <div class="form-row">
          <label for="modeSelect">Queue type</label>
          <select id="modeSelect" aria-label="Select queue type">
            <option value="max">Max-heap (highest priority first)</option>
            <option value="min">Min-heap (lowest priority first)</option>
          </select>
        </div>

        <div class="btn-row" role="toolbar" aria-label="Primary actions" style="margin-top:4px;">
          <button id="enqueueBtn" class="small">Enqueue</button>
          <button id="dequeueBtn" class="small">Dequeue</button>
          <button id="peekBtn" class="small secondary">Peek</button>
          <button id="clearBtn" class="small secondary">Clear</button>
        </div>

        <div style="border-top:1px dashed #eef3f6; padding-top:12px;">
          <h2 style="font-size:13px; margin:0 0 6px 0;">Node Interaction</h2>
          <p class="muted" style="margin:0 0 6px 0;">Click a node in the visualization to select it, then change its priority or remove it.</p>

          <div class="form-row">
            <div style="flex:1;">
              <label for="selectedPrio">Selected priority</label>
              <input id="selectedPrio" type="number" aria-label="Selected node priority" />
            </div>
            <div style="width:120px;">
              <label>&nbsp;</label>
              <button id="changePrioBtn" class="small secondary" style="width:100%;">Change</button>
            </div>
          </div>

          <div class="btn-row" style="margin-top:8px;">
            <button id="removeBtn" class="small warn">Remove Node</button>
            <button id="randomBtn" class="small">Add Random ×5</button>
          </div>
        </div>

        <div style="border-top:1px dashed #eef3f6; padding-top:12px;">
          <h2 style="font-size:13px; margin:0 0 6px 0;">Animation</h2>
          <div class="form-row" style="align-items:center;">
            <label class="muted" style="margin-right:8px;">Animate</label>
            <input id="animateToggle" type="checkbox" checked aria-label="Toggle animations" />
            <label for="speedRange" class="muted" style="margin-left:12px;">Speed</label>
            <input id="speedRange" type="range" min="0.25" max="2" step="0.25" value="1" style="width:120px;" aria-label="Animation speed" />
          </div>
          <p class="muted" style="margin:6px 0 0 0;">Use "Step" with animation off to inspect each comparison manually (not implemented: optional extension).</p>
        </div>
      </section>

      <!-- Visualization -->
      <section class="visual" aria-labelledby="visual-title">
        <div class="vis-top">
          <div>
            <h2 id="visual-title" style="margin:0;font-size:14px;">Heap Visualization</h2>
            <p class="muted" style="margin:4px 0 0 0;">Click nodes to select. The array view below shows internal heap layout (index 0 = root).</p>
          </div>
          <div class="legend" aria-hidden="true">
            <div class="badge">Selected: <span id="selInfo" style="margin-left:8px;font-weight:700;">—</span></div>
            <div class="muted">Nodes: <strong id="count">0</strong></div>
          </div>
        </div>

        <div class="canvas" id="canvas" tabindex="0" aria-label="Heap canvas">
          <!-- SVG for links -->
          <svg class="links" id="links" aria-hidden="true"></svg>
          <!-- Nodes container (positions absolute) -->
          <div id="nodesContainer" style="position:absolute; inset:0;"></div>
        </div>

        <div>
          <h3 style="margin:0 0 8px 0;font-size:13px;">Array Representation</h3>
          <div class="array" id="arrayView" aria-live="polite"></div>
        </div>
      </section>
    </main>

    <footer>
      Tip: Try both max-heap and min-heap modes. Add several items, then click the root and change its priority to watch bubble-up or sift-down happen.
    </footer>
  </div>

  <script>
    (function(){
      /* --- Data model for the heap (binary heap using array) --- */
      const heap = {
        arr: [], // elements: {label, priority, id}
        mode: 'max' // 'max' or 'min'
      };

      // DOM refs
      const labelInput = document.getElementById('labelInput');
      const prioInput = document.getElementById('prioInput');
      const modeSelect = document.getElementById('modeSelect');
      const enqueueBtn = document.getElementById('enqueueBtn');
      const dequeueBtn = document.getElementById('dequeueBtn');
      const peekBtn = document.getElementById('peekBtn');
      const clearBtn = document.getElementById('clearBtn');
      const randomBtn = document.getElementById('randomBtn');

      const canvas = document.getElementById('canvas');
      const nodesContainer = document.getElementById('nodesContainer');
      const linksSvg = document.getElementById('links');
      const arrayView = document.getElementById('arrayView');
      const countEl = document.getElementById('count');

      const animateToggle = document.getElementById('animateToggle');
      const speedRange = document.getElementById('speedRange');

      const selectedPrio = document.getElementById('selectedPrio');
      const changePrioBtn = document.getElementById('changePrioBtn');
      const removeBtn = document.getElementById('removeBtn');
      const selInfo = document.getElementById('selInfo');

      let selectedNodeId = null;
      let idCounter = 1;
      let animating = false;

      /* Animation configuration */
      function getAnimDuration(){
        // base 350ms scaled by speed
        const speed = parseFloat(speedRange.value) || 1;
        return 350 / speed;
      }

      /* Utility: compare depending on mode */
      function cmp(a,b){
        if(heap.mode === 'max') return a - b;
        return b - a;
      }

      /* Create element object */
      function makeElem(label, prio){
        return {label: label || 'Item '+(idCounter), priority: Number(prio)||0, id: idCounter++};
      }

      /* Heap operations with animation hooks */
      async function enqueue(elem){
        const i = heap.arr.push(elem) - 1;
        await render(); // place at end
        await bubbleUp(i);
      }

      async function dequeue(){
        if(heap.arr.length === 0) return null;
        if(heap.arr.length === 1){
          const x = heap.arr.pop();
          await render();
          return x;
        }
        // swap root with last
        swap(0, heap.arr.length-1);
        await renderSwap(0, heap.arr.length-1);
        const popped = heap.arr.pop();
        await render(); // removes last
        await siftDown(0);
        return popped;
      }

      function peek(){
        return heap.arr.length ? heap.arr[0] : null;
      }

      function swap(i,j){
        const tmp = heap.arr[i];
        heap.arr[i] = heap.arr[j];
        heap.arr[j] = tmp;
      }

      /* Bubble-up operation (while compare with parent) */
      async function bubbleUp(i){
        while(i > 0){
          const p = Math.floor((i-1)/2);
          if(cmp(heap.arr[i].priority, heap.arr[p].priority) > 0){
            swap(i,p);
            await renderSwap(i,p);
            i = p;
          } else break;
        }
      }

      /* Sift-down operation */
      async function siftDown(i){
        const n = heap.arr.length;
        while(true){
          let left = 2*i + 1;
          let right = 2*i + 2;
          let largest = i;
          if(left < n && cmp(heap.arr[left].priority, heap.arr[largest].priority) > 0) largest = left;
          if(right < n && cmp(heap.arr[right].priority, heap.arr[largest].priority) > 0) largest = right;
          if(largest !== i){
            swap(i, largest);
            await renderSwap(i, largest);
            i = largest;
          } else break;
        }
      }

      /* Remove arbitrary node by id */
      async function removeById(id){
        const idx = heap.arr.findIndex(x => x.id === id);
        if(idx === -1) return null;
        const last = heap.arr.length-1;
        if(idx === last){
          const removed = heap.arr.pop();
          await render();
          return removed;
        }
        swap(idx, last);
        await renderSwap(idx,last);
        const removed = heap.arr.pop();
        await render();
        // After swap, bubble or sift as needed
        // Try bubble-up then sift-down
        await bubbleUp(idx);
        await siftDown(idx);
        return removed;
      }

      /* Change priority of a node */
      async function changePriorityById(id, newPrio){
        const idx = heap.arr.findIndex(x => x.id === id);
        if(idx === -1) return;
        const old = heap.arr[idx].priority;
        heap.arr[idx].priority = Number(newPrio);
        await render();
        if(cmp(heap.arr[idx].priority, old) > 0){
          await bubbleUp(idx);
        } else {
          await siftDown(idx);
        }
      }

      /* Rendering functions */
      function clearNodes(){
        nodesContainer.innerHTML = '';
        linksSvg.innerHTML = '';
      }

      // compute layout positions for each index in heap
      function computePositions(){
        const rect = canvas.getBoundingClientRect();
        const width = Math.max(320, rect.width - 32); // padding
        const positions = [];
        const n = heap.arr.length;
        for(let i=0;i<n;i++){
          const level = Math.floor(Math.log2(i+1));
          const levelStart = Math.pow(2, level) - 1;
          const idxInLevel = i - levelStart;
          const nodesInLevel = Math.pow(2, level);
          const gapX = width / (nodesInLevel + 1);
          const x = Math.round(gapX * (idxInLevel + 1)) - 28; // center node (node size / 2)
          const y = level * parseInt(getComputedStyle(document.documentElement).getPropertyValue('--level-gap') || 96) + 16;
          positions.push({x, y});
        }
        return positions;
      }

      // create node DOM element
      function createNodeDom(elem){
        const el = document.createElement('div');
        el.className = 'node';
        el.setAttribute('role','button');
        el.setAttribute('tabindex','0');
        el.setAttribute('data-id', elem.id);
        el.setAttribute('aria-label', `${elem.label} priority ${elem.priority}`);
        el.innerHTML = '<div class="prio"></div><div class="lbl"></div>';
        return el;
      }

      // update one node content
      function populateNode(el, elem){
        el.querySelector('.prio').textContent = elem.priority;
        el.querySelector('.lbl').textContent = elem.label;
      }

      // render everything without animation (but nodes will transition because of CSS)
      async function render(){
        // If animating flagged and we want to suppress intermediate renders, we still update DOM
        const positions = computePositions();
        // update array view
        buildArrayView();

        // update nodes: create or remove accordingly
        const existing = Array.from(nodesContainer.children);
        // map by id
        const existingMap = new Map(existing.map(e => [Number(e.getAttribute('data-id')), e]));
        // create missing nodes
        heap.arr.forEach((elem, idx) => {
          if(!existingMap.has(elem.id)){
            const node = createNodeDom(elem);
            populateNode(node, elem);
            node.style.left = positions[idx].x + 'px';
            node.style.top = positions[idx].y + 'px';
            // color based on mode
            node.classList.toggle('min', heap.mode === 'min');
            node.addEventListener('click', onNodeClick);
            node.addEventListener('keydown', (ev) => {
              if(ev.key === 'Enter' || ev.key === ' '){
                ev.preventDefault();
                onNodeClick(ev);
              }
            });
            nodesContainer.appendChild(node);
          } else {
            const node = existingMap.get(elem.id);
            populateNode(node, elem);
            node.classList.toggle('min', heap.mode === 'min');
          }
        });
        // remove extras
        existing.forEach(e => {
          const id = Number(e.getAttribute('data-id'));
          if(!heap.arr.find(x => x.id === id)){
            // remove element
            e.remove();
          }
        });

        // position nodes
        const nodeEls = Array.from(nodesContainer.children);
        nodeEls.forEach((el, idx) => {
          // find index of this id in heap.arr to get pos
          const id = Number(el.getAttribute('data-id'));
          const newIdx = heap.arr.findIndex(x => x.id === id);
          if(newIdx === -1) return;
          const pos = positions[newIdx];
          // set transform for smooth animation
          el.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
          // also set top/left for later absolute anchors (we keep container relative)
          el.style.left = '0px';
          el.style.top = '0px';
        });

        // draw links between parent-child using svg lines
        drawLinks(positions);
        // update counts and selection details
        countEl.textContent = heap.arr.length;
        updateSelectionDetails();
        await wait(5); // allow layout/transition to apply
      }

      // Render swap animation explicitly: highlight two ids, animate their movement
      async function renderSwap(i,j){
        if(!animateToggle.checked){
          // non-animated: just render resulting positions
          await render();
          return;
        }
        animating = true;
        const duration = getAnimDuration();
        const positions = computePositions();

        // find nodes for indices (ids)
        const idI = heap.arr[i] ? heap.arr[i].id : null;
        const idJ = heap.arr[j] ? heap.arr[j].id : null;

        // store current positions of all nodes
        const nodeEls = Array.from(nodesContainer.children);
        const idToEl = new Map(nodeEls.map(e => [Number(e.getAttribute('data-id')), e]));

        // Highlight swapping nodes
        if(idI) idToEl.get(idI).classList.add('selected');
        if(idJ) idToEl.get(idJ).classList.add('selected');

        // Force reflow
        void nodesContainer.offsetWidth;

        // We'll animate by setting transform to target positions
        // Prepare a map id -> target position
        const targetPos = new Map();
        heap.arr.forEach((elem, idx) => {
          targetPos.set(elem.id, positions[idx]);
        });

        // Apply transitions
        nodeEls.forEach(el => {
          const id = Number(el.getAttribute('data-id'));
          const pos = targetPos.get(id);
          el.style.transition = `transform ${duration}ms cubic-bezier(.2,.9,.2,1)`;
          if(pos){
            el.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
          } else {
            // fading out
            el.style.opacity = 0;
          }
        });

        // animate links by repeatedly redrawing during the animation
        const start = performance.now();
        await new Promise(resolve => {
          function frame(now){
            const t = Math.min(1, (now - start) / duration);
            // recompute current positions from transform computed style
            const positionsNow = [];
            // but simply redraw links based on current transforms of nodes
            drawLinks(); // draw based on node centers
            if(t < 1){
              requestAnimationFrame(frame);
            } else {
              resolve();
            }
          }
          requestAnimationFrame(frame);
        });

        // cleanup: remove transitions
        nodeEls.forEach(el => {
          el.style.transition = '';
          el.style.opacity = '';
        });

        if(idI) idToEl.get(idI).classList.remove('selected');
        if(idJ) idToEl.get(idJ).classList.remove('selected');

        animating = false;
        // final render to ensure consistent positions
        await render();
      }

      // Draw links lines between parent and child using node centers
      function drawLinks(forcePositions){
        // We can compute positions either from forcePositions (array) or from current transforms of nodes
        const positions = forcePositions || computePositions();
        // Build map id -> center coordinates
        const coords = new Map();
        heap.arr.forEach((elem, idx) => {
          const pos = positions[idx];
          const cx = pos.x + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--node-size'))/2 || pos.x + 28;
          const cy = pos.y + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--node-size'))/2 || pos.y + 28;
          coords.set(elem.id, {x: cx, y: cy});
        });

        // Clear SVG
        linksSvg.innerHTML = '';
        // Ensure svg has right size
        const rect = canvas.getBoundingClientRect();
        linksSvg.setAttribute('width', rect.width);
        linksSvg.setAttribute('height', rect.height);
        linksSvg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);

        // For each parent, draw lines to children
        heap.arr.forEach((elem, idx) => {
          const left = 2*idx + 1;
          const right = 2*idx + 2;
          const a = coords.get(elem.id);
          if(!a) return;
          [left, right].forEach(childIdx => {
            if(childIdx < heap.arr.length){
              const child = heap.arr[childIdx];
              const b = coords.get(child.id);
              if(!b) return;
              const line = document.createElementNS('http://www.w3.org/2000/svg','line');
              line.setAttribute('x1', a.x);
              line.setAttribute('y1', a.y);
              line.setAttribute('x2', b.x);
              line.setAttribute('y2', b.y);
              line.setAttribute('stroke', '#cfe9ff');
              line.setAttribute('stroke-width', '2');
              line.setAttribute('stroke-linecap','round');
              line.setAttribute('opacity','0.95');
              linksSvg.appendChild(line);
            }
          });
        });
      }

      // Build array view below visualization
      function buildArrayView(){
        arrayView.innerHTML = '';
        heap.arr.forEach((elem, idx) => {
          const box = document.createElement('div');
          box.className = 'arr-box';
          box.setAttribute('data-id', elem.id);
          box.setAttribute('tabindex','0');
          box.innerHTML = `<div class="arr-val">${elem.priority}</div><div class="arr-idx">${elem.label} • [${idx}]</div>`;
          box.addEventListener('click', () => {
            const id = elem.id;
            focusNodeById(id);
            selectNodeById(id);
          });
          arrayView.appendChild(box);
        });
      }

      // Helper: wait ms
      function wait(ms){
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      /* Event handlers */
      enqueueBtn.addEventListener('click', async () => {
        if(animating) return;
        const label = labelInput.value.trim() || `Item ${idCounter}`;
        const prio = Number(prioInput.value) || 0;
        const elem = makeElem(label, prio);
        await enqueue(elem);
      });

      dequeueBtn.addEventListener('click', async () => {
        if(animating) return;
        const popped = await dequeue();
        if(popped){
          // show brief info
          flashSelection(`Popped: ${popped.label} (prio ${popped.priority})`);
        }
      });

      peekBtn.addEventListener('click', () => {
        const p = peek();
        if(p){
          flashSelection(`Peek: ${p.label} (prio ${p.priority})`);
        } else {
          flashSelection('Queue empty');
        }
      });

      clearBtn.addEventListener('click', async () => {
        if(animating) return;
        heap.arr = [];
        selectedNodeId = null;
        await render();
      });

      modeSelect.addEventListener('change', async (e) => {
        heap.mode = e.target.value;
        // Rebalance? Mode change requires rebuilding heap to match new comparator
        // Simple approach: reconstruct heap by inserting elements into new array
        const items = heap.arr.slice();
        heap.arr = [];
        for(const it of items) {
          heap.arr.push(it);
          // bubble-up to satisfy new ordering
          await bubbleUp(heap.arr.length-1);
        }
        await render();
      });

      randomBtn.addEventListener('click', async () => {
        if(animating) return;
        for(let i=0;i<5;i++){
          const label = `R${Math.floor(Math.random()*90)+10}`;
          const prio = Math.floor(Math.random()*100);
          const elem = makeElem(label, prio);
          await enqueue(elem);
        }
      });

      /* Node click: select */
      function onNodeClick(ev){
        const el = ev.currentTarget;
        const id = Number(el.getAttribute('data-id'));
        selectNodeById(id);
      }

      function selectNodeById(id){
        selectedNodeId = id;
        // update UI selections
        const nodeEls = Array.from(nodesContainer.children);
        nodeEls.forEach(n => {
          const nid = Number(n.getAttribute('data-id'));
          n.classList.toggle('selected', nid === id);
        });
        const elem = heap.arr.find(x => x.id === id);
        if(elem){
          selectedPrio.value = elem.priority;
        } else {
          selectedPrio.value = '';
        }
        updateSelectionDetails();
      }

      function updateSelectionDetails(){
        const elem = heap.arr.find(x => x.id === selectedNodeId);
        if(elem){
          selInfo.textContent = `${elem.label} • ${elem.priority}`;
        } else {
          selInfo.textContent = '—';
        }
      }

      changePrioBtn.addEventListener('click', async () => {
        if(!selectedNodeId) return;
        if(animating) return;
        const newP = Number(selectedPrio.value);
        if(Number.isNaN(newP)) return;
        await changePriorityById(selectedNodeId, newP);
      });

      removeBtn.addEventListener('click', async () => {
        if(!selectedNodeId) return;
        if(animating) return;
        await removeById(selectedNodeId);
        selectedNodeId = null;
        await render();
      });

      // Focus node by id (scroll into view if required)
      function focusNodeById(id){
        const node = nodesContainer.querySelector(`[data-id="${id}"]`);
        if(node){
          node.focus();
        }
      }

      // utility: flash selection message in selInfo briefly
      async function flashSelection(msg){
        const prev = selInfo.textContent;
        selInfo.textContent = msg;
        selInfo.parentElement.style.background = '#e8f4ff';
        await wait(900);
        selInfo.textContent = prev;
        selInfo.parentElement.style.background = '';
      }

      // resize observer for canvas to re-render responsive positions
      const ro = new ResizeObserver(() => {
        render();
      });
      ro.observe(canvas);

      // keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if(e.key === 'e' && document.activeElement.tagName !== 'INPUT') {
          enqueueBtn.click();
        }
        if(e.key === 'd' && document.activeElement.tagName !== 'INPUT') {
          dequeueBtn.click();
        }
      });

      // initial demo content
      (async function initDemo(){
        heap.mode = modeSelect.value;
        const demo = [
          makeElem('A', 40),
          makeElem('B', 15),
          makeElem('C', 30),
          makeElem('D', 50),
          makeElem('E', 20)
        ];
        for(const el of demo) await enqueue(el);
      })();

      // expose for debugging (not necessary)
      window._heap = heap;
    })();
  </script>
</body>
</html>