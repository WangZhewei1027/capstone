<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Floyd–Warshall Interactive Module</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe-margin: 24px;
      --gap: 16px; /* minimum spacing */
      --bg: #0f1720;
      --panel: #0b1320;
      --accent: #38bdf8;
      --muted: #94a3b8;
      --good: #16a34a;
      --bad: #ef4444;
      --glass: rgba(255,255,255,0.03);
      --cell-size: 48px;
      --node-radius: 20;
    }

    html,body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg,#071022 0%, #06121a 100%);
      color: #e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      padding: var(--safe-margin);
      box-sizing: border-box;
    }

    /* Layout container */
    .container {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: var(--gap);
      height: calc(100% - calc(var(--safe-margin) * 2));
      align-items: start;
    }

    @media (max-width: 920px) {
      .container {
        grid-template-columns: 1fr;
        height: auto;
      }
    }

    /* Left panel: controls and explanation */
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      border-radius: 12px;
      padding: 18px;
      min-width: 260px;
    }

    h1 {
      font-size: 18px;
      margin: 0 0 8px 0;
      color: var(--accent);
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .subtitle {
      margin: 0 0 12px 0;
      color: var(--muted);
      font-size: 13px;
    }

    .objective {
      background: var(--glass);
      padding: 12px;
      border-radius: 8px;
      font-size: 13px;
      color: #dbeafe;
      margin-bottom: 12px;
      line-height: 1.4;
    }

    /* Controls area */
    .controls {
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    .row {
      display: flex;
      gap: var(--gap);
      align-items: center;
      flex-wrap: wrap;
    }

    button, input[type="range"], select {
      background: rgba(255,255,255,0.02);
      color: #e6eef8;
      border: 1px solid rgba(255,255,255,0.04);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .control-row {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }

    label.small {
      font-size: 12px;
      color: var(--muted);
    }

    .status {
      background: rgba(255,255,255,0.02);
      padding: 10px;
      border-radius: 8px;
      font-size: 13px;
      color: #dbeafe;
    }

    /* Right panel: visualization */
    .visual {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border: 1px solid rgba(255,255,255,0.03);
      border-radius: 12px;
      padding: 18px;
      min-height: 420px;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    .vis-top {
      display: flex;
      gap: var(--gap);
      align-items: flex-start;
    }

    .canvas {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius: 10px;
      flex: 1;
      min-height: 300px;
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.02);
    }

    svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .matrix-panel {
      width: 360px;
      background: rgba(255,255,255,0.02);
      border-radius: 10px;
      padding: 10px;
      overflow: auto;
    }

    @media (max-width: 920px) {
      .vis-top {
        flex-direction: column;
      }
      .matrix-panel {
        width: 100%;
      }
    }

    table.matrix {
      border-collapse: collapse;
      width: 100%;
      font-size: 13px;
      table-layout: fixed;
      text-align: center;
    }

    table.matrix th, table.matrix td {
      border: 1px solid rgba(255,255,255,0.03);
      padding: 6px;
      min-width: var(--cell-size);
      height: var(--cell-size);
      vertical-align: middle;
      color: #e6eef8;
      position: relative;
      transition: background-color 300ms ease, color 300ms ease;
    }

    table.matrix th {
      background: rgba(255,255,255,0.02);
      font-weight: 600;
      color: var(--muted);
      font-size: 12px;
    }

    .cell-input {
      width: 100%;
      height: 100%;
      border: none;
      background: transparent;
      color: inherit;
      text-align: center;
      font-size: 13px;
      outline: none;
    }

    .cell-highlight {
      animation: pulse 800ms ease;
      background: linear-gradient(90deg, rgba(56,189,248,0.14), rgba(22,163,74,0.06));
      box-shadow: 0 6px 18px rgba(56,189,248,0.06);
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.02); }
      100% { transform: scale(1); }
    }

    .cell-updated {
      background: linear-gradient(90deg, rgba(16,185,129,0.12), rgba(56,189,248,0.06));
      color: #d1fae5;
      font-weight: 700;
    }

    .node {
      cursor: grab;
      user-select: none;
    }

    .node:active {
      cursor: grabbing;
    }

    .node-circle {
      fill: #063249;
      stroke: linear-gradient(180deg,#38bdf8,#06b6d4);
      stroke-width: 2px;
    }

    .node-label {
      font-size: 13px;
      fill: #e6eef8;
      pointer-events: none;
    }

    .edge {
      stroke: rgba(255,255,255,0.06);
      stroke-width: 2.5;
      fill: none;
      marker-end: url(#arrowhead);
      transition: stroke 250ms ease, stroke-width 200ms ease;
    }

    .edge.highlight {
      stroke: #38bdf8;
      stroke-width: 4;
      filter: drop-shadow(0 6px 12px rgba(56,189,248,0.12));
    }

    .weight-label {
      font-size: 12px;
      fill: #cfeefe;
      background: rgba(0,0,0,0.2);
      pointer-events: none;
    }

    .mini-hint {
      font-size: 12px;
      color: var(--muted);
    }

    .legend {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      font-size: 13px;
    }

    .chip {
      border-radius: 8px;
      background: rgba(255,255,255,0.02);
      padding: 6px 8px;
      color: #cfeefe;
      font-size: 13px;
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    .info {
      font-size: 13px;
      color: #dbeafe;
    }

    /* focus states */
    button:focus, input:focus, select:focus {
      outline: 2px solid rgba(56,189,248,0.18);
      outline-offset: 2px;
    }

    /* small helpers */
    .muted { color: var(--muted); font-size: 13px; }
    .tight { margin-top: 6px; }
    .flex { display: flex; gap: 12px; align-items: center; }

  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Floyd–Warshall Interactive Module">
    <!-- LEFT: Title, objective & controls -->
    <aside class="panel" aria-labelledby="title">
      <h1 id="title">Floyd–Warshall Algorithm — All-pairs Shortest Paths</h1>
      <p class="subtitle">Interactive step-through with editable graph and matrices</p>

      <div class="objective" aria-live="polite">
        Learning objective: After interacting with this module you will be able to:
        <ul>
          <li>Observe how Floyd–Warshall updates the distance matrix using each vertex as an intermediate.</li>
          <li>See exactly when and why a particular distance entry is updated (visual + matrix highlight).</li>
          <li>Reconstruct a shortest path using the "next" predecessor table and inspect it on the graph.</li>
        </ul>
      </div>

      <div class="controls" role="region" aria-label="Controls">
        <div class="row control-row">
          <div>
            <label class="small">Nodes</label>
            <select id="nodeCount" aria-label="Node count">
              <option value="4">4 nodes</option>
              <option value="5" selected>5 nodes</option>
              <option value="6">6 nodes</option>
            </select>
          </div>
          <div style="min-width:140px;">
            <label class="small">Directed</label>
            <select id="directedToggle" aria-label="Directed or undirected">
              <option value="true">Directed</option>
              <option value="false">Undirected</option>
            </select>
          </div>
        </div>

        <div class="row">
          <button id="randomizeBtn" title="Create a random weighted graph">Randomize graph</button>
          <button id="resetBtn" title="Reset to initial graph state">Reset</button>
        </div>

        <div class="row control-row">
          <div style="min-width: 180px;">
            <label class="small">Playback</label>
            <div style="display:flex;gap:8px;">
              <button id="backBtn" aria-label="Step backward">◀</button>
              <button id="playBtn" aria-pressed="false" aria-label="Play pause">Play</button>
              <button id="stepBtn" aria-label="Step forward">▶</button>
            </div>
          </div>

          <div style="text-align:right;">
            <label class="small">Speed</label>
            <input id="speed" type="range" min="200" max="2000" step="50" value="900" aria-label="Playback speed ms">
          </div>
        </div>

        <div class="row">
          <div>
            <label class="small">Show path reconstruction</label>
            <select id="showNext" aria-label="Show next table">
              <option value="true" selected>Show next table</option>
              <option value="false">Hide next table</option>
            </select>
          </div>
          <div>
            <label class="small">Animation</label>
            <select id="animateToggle" aria-label="Toggle animation">
              <option value="true" selected>Animate highlights</option>
              <option value="false">Instant</option>
            </select>
          </div>
        </div>

        <div class="status" id="status" aria-live="polite">
          Status: Ready. Build or randomize a graph, then press Play or Step to start.
        </div>

        <div class="mini-hint tight" role="note">
          Tip: Edit any non-diagonal matrix cell to change edge weight (type number or INF). Drag nodes on the graph to reposition.
        </div>
      </div>
    </aside>

    <!-- RIGHT: Visualization (graph SVG) and matrix -->
    <main class="visual" role="main">
      <div class="vis-top" role="region" aria-label="Visualization">
        <div class="canvas" id="canvas" tabindex="0" aria-label="Graph canvas - draggable nodes">
          <!-- Inline SVG for graph drawing -->
          <svg id="svg" viewBox="0 0 800 520" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Graph view"></svg>
        </div>

        <div class="matrix-panel" aria-label="Matrices">
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
            <div class="legend">
              <div class="chip">Distance matrix</div>
              <div class="chip" id="nextChip">Next table</div>
            </div>
            <div class="muted">Click a cell to edit & press Enter</div>
          </div>

          <div id="matrices">
            <!-- Distance table and next table -->
            <div id="distTableWrap"></div>
            <div id="nextTableWrap" style="margin-top:12px;"></div>
          </div>
        </div>
      </div>

      <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
        <div class="info" id="operation">Operation: idle</div>
        <div class="muted">Current snapshot: <span id="snapshotIndex">0</span></div>
      </div>
    </main>
  </div>

  <script>
    /*
      Floyd–Warshall Interactive Module
      - Single-concept: Floyd–Warshall algorithm (all-pairs shortest paths)
      - Vanilla JS, self-contained, responsive, accessible

      Design notes (also visible in UI):
      * Users can edit distances via the distance matrix (type a number or INF).
      * Nodes are draggable. Graph updates reflect matrix values and vice versa.
      * Step-wise snapshots are recorded so users can step forwards/backwards.
      * Visual feedback: when examining triple (i,k,j) we highlight nodes and cells.
      * When an update happens, the matrix cell pulses and edges/path highlight.
    */

    (function () {
      // Config & state
      const svg = document.getElementById('svg');
      const canvas = document.getElementById('canvas');
      const nodeCountSelect = document.getElementById('nodeCount');
      const directedToggle = document.getElementById('directedToggle');
      const randomizeBtn = document.getElementById('randomizeBtn');
      const resetBtn = document.getElementById('resetBtn');
      const playBtn = document.getElementById('playBtn');
      const stepBtn = document.getElementById('stepBtn');
      const backBtn = document.getElementById('backBtn');
      const speedInput = document.getElementById('speed');
      const statusDiv = document.getElementById('status');
      const operationDiv = document.getElementById('operation');
      const snapshotIndexSpan = document.getElementById('snapshotIndex');
      const distTableWrap = document.getElementById('distTableWrap');
      const nextTableWrap = document.getElementById('nextTableWrap');
      const showNext = document.getElementById('showNext');
      const animateToggle = document.getElementById('animateToggle');

      // Layout dims for SVG internal coordinate system
      const W = 800, H = 520;
      svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

      // Algorithm representation
      let N = parseInt(nodeCountSelect.value, 10);
      let directed = (directedToggle.value === 'true');
      let positions = []; // [{x,y}]
      let adj = []; // adjacency matrix weights (number or Infinity)
      let dist = []; // current distances
      let nxt = []; // next matrix for path reconstruction (null or index)
      let snapshots = []; // array of snapshots for stepping
      let stepPos = 0; // index into snapshots
      let playing = false;
      let playTimer = null;

      // Graph visuals
      let nodes = []; // svg group elements for nodes
      let edges = {}; // map key "i-j" -> svg elements (path, weight text)

      // Utility: Infinity representation for UI
      const INF = Number.POSITIVE_INFINITY;
      const INF_STR = 'INF';

      // Helpers for deep clone matrices
      function cloneMatrix(m) {
        return m.map(row => row.slice());
      }

      // Create default positions for N nodes (circle layout)
      function generatePositions(n) {
        const cx = W / 2, cy = H / 2;
        const r = Math.min(W, H) / 2 - 80;
        const arr = [];
        for (let i = 0; i < n; i++) {
          const a = (i / n) * Math.PI * 2 - Math.PI / 2;
          arr.push({ x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) });
        }
        return arr;
      }

      // Random graph generator with some sparsity
      function randomizeGraph(n, directed) {
        const maxWeight = 12;
        const pEdge = 0.45;
        const A = Array.from({ length: n }, () => Array(n).fill(INF));
        for (let i = 0; i < n; i++) {
          A[i][i] = 0;
        }
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            if (i === j) continue;
            if (Math.random() < pEdge) {
              const w = Math.floor(Math.random() * (maxWeight - 1)) + 1;
              A[i][j] = w;
              if (!directed) A[j][i] = w;
            }
          }
        }
        return A;
      }

      // Build initial state
      function buildInitial(n, directedFlag, randomize = true) {
        N = n;
        directed = directedFlag;
        positions = generatePositions(N);
        adj = randomize ? randomizeGraph(N, directed) : Array.from({ length: N }, () => Array(N).fill(INF));
        for (let i = 0; i < N; i++) adj[i][i] = 0;
        resetAlgorithmState();
        renderAll();
      }

      // Reset dist/nxt and snapshots
      function resetAlgorithmState() {
        dist = cloneMatrix(adj);
        nxt = Array.from({ length: N }, () => Array(N).fill(null));
        for (let i = 0; i < N; i++) {
          for (let j = 0; j < N; j++) {
            if (dist[i][j] !== INF && i !== j) nxt[i][j] = j;
          }
        }
        snapshots = [];
        stepPos = 0;
        recordInitialSnapshot();
        updateStatus('Ready: initial snapshot created.');
        updateSnapshotUI();
      }

      // Record snapshot structure:
      // { k, i, j, beforeDist, afterDist, beforeNext, afterNext, updated (bool) }
      function recordInitialSnapshot() {
        const snap = {
          k: -1, i: -1, j: -1,
          beforeDist: cloneMatrix(dist),
          afterDist: cloneMatrix(dist),
          beforeNext: cloneMatrix(nxt),
          afterNext: cloneMatrix(nxt),
          updated: false,
          description: 'Initial state'
        };
        snapshots = [snap];
        stepPos = 0;
      }

      // Run full Floyd–Warshall but record snapshots for each (i,k,j)
      function computeSnapshots() {
        // Start from current adjacency (fresh)
        dist = cloneMatrix(adj);
        nxt = Array.from({ length: N }, () => Array(N).fill(null));
        for (let i = 0; i < N; i++) {
          for (let j = 0; j < N; j++) {
            if (dist[i][j] !== INF && i !== j) nxt[i][j] = j;
          }
        }
        snapshots = [];
        // initial
        snapshots.push({
          k: -1, i: -1, j: -1,
          beforeDist: cloneMatrix(dist),
          afterDist: cloneMatrix(dist),
          beforeNext: cloneMatrix(nxt),
          afterNext: cloneMatrix(nxt),
          updated: false,
          description: 'Initial state'
        });
        for (let k = 0; k < N; k++) {
          for (let i = 0; i < N; i++) {
            for (let j = 0; j < N; j++) {
              const beforeDist = cloneMatrix(dist);
              const beforeNext = cloneMatrix(nxt);
              let updated = false;
              const di = dist[i][j];
              const dik = dist[i][k];
              const dkj = dist[k][j];
              if (dik !== INF && dkj !== INF) {
                const via = dik + dkj;
                if (via < di) {
                  dist[i][j] = via;
                  nxt[i][j] = nxt[i][k];
                  updated = true;
                }
              }
              snapshots.push({
                k, i, j,
                beforeDist, afterDist: cloneMatrix(dist),
                beforeNext, afterNext: cloneMatrix(nxt),
                updated,
                description: updated
                  ? `dist[${i}][${j}] improved via ${k}: ${beforeDist[i][j]} → ${dist[i][j]}`
                  : `Checked dist[${i}][${j}] via ${k}: no improvement`
              });
            }
          }
        }
        // final snapshot state already included as last
        stepPos = 0;
        updateSnapshotUI();
        updateStatus('Snapshots computed. Use Play/Step to traverse.');
      }

      // Render all visuals (nodes, edges, matrices)
      function renderAll() {
        clearSVG();
        renderDefs();
        renderEdgesFromAdj();
        renderNodes();
        renderMatrices();
      }

      // Clear & initialize svg
      function clearSVG() {
        while (svg.firstChild) svg.removeChild(svg.firstChild);
      }

      // SVG defs (arrowhead)
      function renderDefs() {
        const defs = el('defs');
        const marker = el('marker', { id: 'arrowhead', viewBox: '0 0 10 10', refX: 10, refY: 5, markerWidth: 6, markerHeight: 6, orient: 'auto-start-reverse' });
        const path = el('path', { d: 'M 0 0 L 10 5 L 0 10 z', fill: 'rgba(255,255,255,0.08)' });
        marker.appendChild(path);
        defs.appendChild(marker);
        svg.appendChild(defs);
      }

      // Render nodes as draggable circles
      function renderNodes() {
        nodes = [];
        for (let i = 0; i < N; i++) {
          const g = el('g', { class: 'node', 'data-idx': i, transform: `translate(${positions[i].x},${positions[i].y})` });
          const circle = el('circle', { r: 20, fill: '#063249', class: 'node-circle' });
          const label = el('text', { x: 0, y: 6, 'text-anchor': 'middle', class: 'node-label' });
          label.textContent = String(i);
          g.appendChild(circle);
          g.appendChild(label);
          svg.appendChild(g);
          nodes.push(g);

          // drag behavior
          attachDragHandlers(g, i);
        }
      }

      // Render edges using adjacency matrix
      function renderEdgesFromAdj() {
        edges = {};
        for (let i = 0; i < N; i++) {
          for (let j = 0; j < N; j++) {
            if (i === j) continue;
            const w = adj[i][j];
            if (w !== INF) {
              createEdge(i, j, w);
            }
          }
        }
      }

      // Create an edge from i to j with weight w
      function createEdge(i, j, w) {
        const key = `${i}-${j}`;
        const g = el('g', { class: 'edge-group', 'data-key': key });
        const path = el('path', { class: 'edge', 'data-key': key, fill: 'none' });
        const txt = el('text', { class: 'weight-label' });
        txt.textContent = String(w);
        g.appendChild(path);
        g.appendChild(txt);
        svg.appendChild(g);
        edges[key] = { group: g, path, txt, i, j };
        updateEdgePath(key);
      }

      // Update all edge paths (called after node drag)
      function updateAllEdgePaths() {
        Object.keys(edges).forEach(updateEdgePath);
      }

      function updateEdgePath(key) {
        const e = edges[key];
        if (!e) return;
        const sx = positions[e.i].x;
        const sy = positions[e.i].y;
        const tx = positions[e.j].x;
        const ty = positions[e.j].y;
        // simple curved path for readability
        const dx = tx - sx;
        const dy = ty - sy;
        const mx = (sx + tx) / 2;
        const my = (sy + ty) / 2;
        // offset for curve
        const nx = -dy * 0.2;
        const ny = dx * 0.2;
        const cx = mx + nx, cy = my + ny;
        const d = `M ${sx} ${sy} Q ${cx} ${cy} ${tx} ${ty}`;
        e.path.setAttribute('d', d);
        // place weight label near midpoint
        const mid = quadPoint(sx, sy, cx, cy, tx, ty, 0.5);
        e.txt.setAttribute('x', mid.x);
        e.txt.setAttribute('y', mid.y - 8);
      }

      // quadratic curve midpoint util
      function quadPoint(x1, y1, cx, cy, x2, y2, t) {
        // B(t) = (1-t)^2 P0 + 2(1-t)t C + t^2 P2
        const mt = 1 - t;
        return {
          x: mt * mt * x1 + 2 * mt * t * cx + t * t * x2,
          y: mt * mt * y1 + 2 * mt * t * cy + t * t * y2
        };
      }

      // Attach pointer drag to node group
      function attachDragHandlers(g, idx) {
        let dragging = false;
        let offset = { x: 0, y: 0 };

        function onPointerDown(e) {
          e.preventDefault();
          dragging = true;
          g.setPointerCapture(e.pointerId);
          const pt = getEventPoint(e);
          const transform = g.getAttribute('transform'); // translate(x,y)
          const m = transform.match(/translate\((.+),(.+)\)/);
          const curX = parseFloat(m[1]), curY = parseFloat(m[2]);
          offset.x = pt.x - curX;
          offset.y = pt.y - curY;
        }

        function onPointerMove(e) {
          if (!dragging) return;
          const pt = getEventPoint(e);
          const nx = pt.x - offset.x;
          const ny = pt.y - offset.y;
          positions[idx].x = clamp(nx, 40, W - 40);
          positions[idx].y = clamp(ny, 40, H - 40);
          g.setAttribute('transform', `translate(${positions[idx].x},${positions[idx].y})`);
          updateAllEdgePaths();
        }

        function onPointerUp(e) {
          if (!dragging) return;
          dragging = false;
          try { g.releasePointerCapture(e.pointerId); } catch (err) {}
        }

        g.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
      }

      function getEventPoint(e) {
        // Convert client coords to SVG viewBox coords
        const rect = svg.getBoundingClientRect();
        const svgX = (e.clientX - rect.left) * (W / rect.width);
        const svgY = (e.clientY - rect.top) * (H / rect.height);
        return { x: svgX, y: svgY };
      }

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      // Render distance and next matrices as HTML tables with editable inputs
      function renderMatrices() {
        distTableWrap.innerHTML = '';
        nextTableWrap.innerHTML = '';
        // Distance table
        const dTable = document.createElement('table');
        dTable.className = 'matrix';
        const thead = document.createElement('thead');
        const headRow = document.createElement('tr');
        headRow.appendChild(makeTH(''));
        for (let j = 0; j < N; j++) headRow.appendChild(makeTH(String(j)));
        thead.appendChild(headRow);
        dTable.appendChild(thead);
        const tbody = document.createElement('tbody');
        for (let i = 0; i < N; i++) {
          const tr = document.createElement('tr');
          tr.appendChild(makeTH(String(i)));
          for (let j = 0; j < N; j++) {
            const td = document.createElement('td');
            const input = document.createElement('input');
            input.className = 'cell-input';
            input.setAttribute('data-i', i);
            input.setAttribute('data-j', j);
            input.type = 'text';
            input.value = (adj[i][j] === INF) ? INF_STR : String(adj[i][j]);
            input.title = 'Click to edit weight (type INF for no edge). Press Enter to set.';
            input.addEventListener('keydown', onCellKeydown);
            input.addEventListener('blur', onCellBlur);
            td.appendChild(input);
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }
        dTable.appendChild(tbody);
        const distTitle = document.createElement('div');
        distTitle.className = 'muted tight';
        distTitle.textContent = 'Distance (click cells to edit).';
        distTableWrap.appendChild(distTitle);
        distTableWrap.appendChild(dTable);

        // Next/predecessor table
        if (showNext.value === 'true') {
          const nTable = document.createElement('table');
          nTable.className = 'matrix';
          const nhead = document.createElement('thead');
          const nheadRow = document.createElement('tr');
          nheadRow.appendChild(makeTH(''));
          for (let j = 0; j < N; j++) nheadRow.appendChild(makeTH(String(j)));
          nhead.appendChild(nheadRow);
          nTable.appendChild(nhead);
          const nbody = document.createElement('tbody');
          for (let i = 0; i < N; i++) {
            const tr = document.createElement('tr');
            tr.appendChild(makeTH(String(i)));
            for (let j = 0; j < N; j++) {
              const td = document.createElement('td');
              td.textContent = (nxt[i] && nxt[i][j] != null) ? String(nxt[i][j]) : '-';
              tr.appendChild(td);
            }
            nbody.appendChild(tr);
          }
          nTable.appendChild(nbody);
          const nextTitle = document.createElement('div');
          nextTitle.className = 'muted tight';
          nextTitle.textContent = 'Next table (for path reconstruction)';
          nextTableWrap.appendChild(nextTitle);
          nextTableWrap.appendChild(nTable);
          document.getElementById('nextChip').style.display = 'inline-block';
        } else {
          document.getElementById('nextChip').style.display = 'none';
        }
      }

      function makeTH(text) {
        const th = document.createElement('th');
        th.textContent = text;
        return th;
      }

      // Edit matrix cell handlers
      function onCellKeydown(e) {
        if (e.key === 'Enter') {
          e.target.blur();
        }
      }
      function onCellBlur(e) {
        const i = parseInt(e.target.getAttribute('data-i'), 10);
        const j = parseInt(e.target.getAttribute('data-j'), 10);
        const raw = e.target.value.trim().toUpperCase();
        if (raw === INF_STR) {
          adj[i][j] = INF;
          if (!directed) adj[j][i] = INF;
          if (i === j) adj[i][j] = 0;
        } else {
          const v = Number(raw);
          if (!isFinite(v) || isNaN(v)) {
            // revert
            e.target.value = (adj[i][j] === INF) ? INF_STR : String(adj[i][j]);
            return;
          }
          adj[i][j] = v;
          if (!directed) adj[j][i] = v;
        }
        // update edge visuals
        rebuildEdgesFromAdj();
        // recompute snapshots
        computeSnapshots();
        renderMatrices();
      }

      // Remove all edges and recreate based on adj matrix
      function rebuildEdgesFromAdj() {
        // remove existing edge groups
        Object.keys(edges).forEach(k => {
          const g = edges[k].group;
          if (g && g.parentNode) g.parentNode.removeChild(g);
        });
        edges = {};
        renderEdgesFromAdj();
      }

      // Utility to create element with attrs
      function el(tag, attrs = {}) {
        const e = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const k in attrs) {
          e.setAttribute(k, attrs[k]);
        }
        return e;
      }

      // Animation & stepping mechanics
      function updateSnapshotUI() {
        snapshotIndexSpan.textContent = `${stepPos} / ${Math.max(0, snapshots.length - 1)}`;
      }

      function updateStatus(text) {
        statusDiv.textContent = 'Status: ' + text;
      }

      // Apply a snapshot (visual + matrix)
      function applySnapshot(idx, animate = true) {
        if (idx < 0 || idx >= snapshots.length) return;
        stepPos = idx;
        const snap = snapshots[idx];
        operationDiv.textContent = 'Operation: ' + snap.description;
        // update dist & next to snapshot.after
        dist = cloneMatrix(snap.afterDist);
        nxt = cloneMatrix(snap.afterNext);
        // update matrix cells values visually (distance)
        // Update adjacency? No. Adjacency is the base input; dist shows computed distances.
        // We'll reflect changes in the distance table by temporarily highlighting cells that changed.
        renderMatrices();
        // highlight nodes and cells
        highlightForSnapshot(snap, animate);
        updateSnapshotUI();
      }

      // Highlight nodes i,k,j and corresponding table cells
      function highlightForSnapshot(snap, animate) {
        // Clear previous highlights
        clearHighlights();

        const { k, i, j, beforeDist, afterDist, updated } = snap;
        // If it's initial snapshot just show initial
        if (k === -1) {
          // no highlight
          return;
        }

        // Visual highlight: highlight nodes i, k, j
        highlightNode(i, '#38bdf8');
        highlightNode(k, '#facc15'); // intermediate in yellow
        highlightNode(j, '#34d399');

        // Highlight cells in matrix before and after
        const cellElements = distTableWrap.querySelectorAll('.cell-input');
        // compute index in flat order: row-major
        for (const input of cellElements) {
          const ii = parseInt(input.getAttribute('data-i'), 10);
          const jj = parseInt(input.getAttribute('data-j'), 10);
          // if this is the cell being considered
          if (ii === i && jj === j) {
            const td = input.parentElement;
            td.classList.add('cell-highlight');
            if (updated && animateToggle.value === 'true') {
              // animate update: flash then set new text
              setTimeout(() => {
                td.classList.remove('cell-highlight');
                td.classList.add('cell-updated');
                input.value = (afterDist[ii][jj] === INF) ? INF_STR : String(afterDist[ii][jj]);
                setTimeout(() => td.classList.remove('cell-updated'), 900);
              }, (animate ? 250 : 0));
            } else {
              // if not updated just set value to before (no change)
              input.value = (afterDist[ii][jj] === INF) ? INF_STR : String(afterDist[ii][jj]);
            }
          } else {
            // for other cells ensure they display the adjacency (input edits reflect base adj)
            const val = adj[ii][jj];
            input.value = (val === INF) ? INF_STR : String(val);
          }
        }

        // highlight edges used by i->k and k->j path (if exist)
        // show a path reconstruction from i to k and k to j using 'beforeNext' or 'afterNext'?
        // We'll use beforeNext for demonstration of combining.
        const beforeNext = snap.beforeNext;
        const pathIK = reconstructPathWithNext(beforeNext, i, k);
        const pathKJ = reconstructPathWithNext(beforeNext, k, j);
        // highlight edges along pathIK and pathKJ sequentially
        if (pathIK.length > 1) highlightEdgePath(pathIK, '#38bdf8', animate);
        if (pathKJ.length > 1) highlightEdgePath(pathKJ, '#34d399', animate, 200);

        // If updated, highlight the final shortest path i->...->j using afterNext
        if (updated) {
          const afterNext = snap.afterNext;
          const pathIJ = reconstructPathWithNext(afterNext, i, j);
          if (pathIJ.length > 1) {
            // highlight final path in green after a short delay
            highlightEdgePath(pathIJ, '#10b981', animate, 500);
          }
        }
      }

      function clearHighlights() {
        // remove highlight class from edges
        Object.values(edges).forEach(e => {
          e.path.classList.remove('highlight');
          e.path.style.stroke = '';
          e.path.style.strokeWidth = '';
        });
        // clear node highlight outline by removing temporary circles
        const temps = svg.querySelectorAll('.node-outline');
        temps.forEach(t => t.parentNode && t.parentNode.removeChild(t));
        // remove cell highlight classes
        const cells = distTableWrap.querySelectorAll('td');
        cells.forEach(td => {
          td.classList.remove('cell-highlight', 'cell-updated');
        });
      }

      function highlightNode(idx, color) {
        const g = nodes[idx];
        if (!g) return;
        const outline = el('circle', { cx: 0, cy: 0, r: 28, fill: 'none', stroke: color, 'stroke-width': 3, class: 'node-outline' });
        g.insertBefore(outline, g.firstChild);
      }

      function highlightEdgePath(pathNodes, color, animate = true, delay = 0) {
        // pathNodes is array of node indices [a, b, c, ...]
        setTimeout(() => {
          for (let t = 0; t < pathNodes.length - 1; t++) {
            const a = pathNodes[t], b = pathNodes[t + 1];
            const key = `${a}-${b}`;
            if (edges[key]) {
              edges[key].path.classList.add('highlight');
              edges[key].path.style.stroke = color;
            } else {
              // if edge doesn't exist visually, skip (maybe due to INF)
            }
            if (!animate) {
              // no animation further
            } else {
              // small timeout for sequential pulse
              // NOTE: we leave them highlighted; they are cleared on next snapshot
            }
          }
        }, delay);
      }

      // Reconstruct path using a given next matrix (returns [] if unreachable)
      function reconstructPathWithNext(nextMat, u, v) {
        if (!nextMat[u] || nextMat[u][v] == null) return [];
        const path = [u];
        let cur = u;
        const visited = new Set();
        while (cur !== v) {
          if (visited.has(cur)) return []; // cycle protection
          visited.add(cur);
          cur = nextMat[cur][v];
          if (cur == null) return [];
          path.push(cur);
          if (path.length > N + 4) return []; // safety
        }
        return path;
      }

      // Play control
      function playSnapshots() {
        if (playing) return;
        playing = true;
        playBtn.textContent = 'Pause';
        playBtn.setAttribute('aria-pressed', 'true');
        scheduleNext();
      }

      function scheduleNext() {
        if (!playing) return;
        const delay = parseInt(speedInput.value, 10);
        playTimer = setTimeout(() => {
          if (stepPos < snapshots.length - 1) {
            applySnapshot(stepPos + 1, animateToggle.value === 'true');
            scheduleNext();
          } else {
            stopPlaying();
          }
        }, delay);
      }

      function stopPlaying() {
        playing = false;
        if (playTimer) clearTimeout(playTimer);
        playBtn.textContent = 'Play';
        playBtn.setAttribute('aria-pressed', 'false');
      }

      // Step backward (use snapshots history)
      function stepBackward() {
        if (stepPos > 0) {
          applySnapshot(stepPos - 1, false);
        }
      }

      // Step forward
      function stepForward() {
        if (stepPos < snapshots.length - 1) {
          applySnapshot(stepPos + 1, animateToggle.value === 'true');
        }
      }

      // Recompute snapshots when graph edits occur or when user requests
      function recomputeAndRender() {
        computeSnapshots();
        renderMatrices();
        renderAll();
      }

      // UI event bindings
      nodeCountSelect.addEventListener('change', () => {
        const n = parseInt(nodeCountSelect.value, 10);
        buildInitial(n, directed);
      });

      directedToggle.addEventListener('change', () => {
        directed = directedToggle.value === 'true';
        // If switching to undirected, mirror adjacency
        if (!directed) {
          for (let i = 0; i < N; i++) {
            for (let j = 0; j < N; j++) {
              if (adj[i][j] !== INF) adj[j][i] = adj[i][j];
            }
          }
        }
        recomputeAndRender();
      });

      randomizeBtn.addEventListener('click', () => {
        adj = randomizeGraph(N, directed);
        for (let i = 0; i < N; i++) adj[i][i] = 0;
        rebuildEdgesFromAdj();
        computeSnapshots();
        renderMatrices();
        renderAll();
      });

      resetBtn.addEventListener('click', () => {
        // re-create positions and graphs based on current adj
        positions = generatePositions(N);
        resetAlgorithmState();
        renderAll();
      });

      playBtn.addEventListener('click', () => {
        if (!playing) {
          computeSnapshots();
          playSnapshots();
        } else {
          stopPlaying();
        }
      });

      stepBtn.addEventListener('click', () => {
        stopPlaying();
        // ensure snapshots exist
        if (snapshots.length === 0) computeSnapshots();
        stepForward();
      });

      backBtn.addEventListener('click', () => {
        stopPlaying();
        stepBackward();
      });

      // Recompute snapshots on animate toggle or showNext changes
      animateToggle.addEventListener('change', () => { /* no-op visual only */ });
      showNext.addEventListener('change', () => renderMatrices());

      // Keyboard support: space toggles play/pause when focus on canvas
      canvas.addEventListener('keydown', (e) => {
        if (e.key === ' ') {
          e.preventDefault();
          playBtn.click();
        } else if (e.key === 'ArrowRight') {
          stepBtn.click();
        } else if (e.key === 'ArrowLeft') {
          backBtn.click();
        }
      });

      // Start initial graph
      buildInitial(N, directed, true);

      // Precompute snapshots so step controls are immediately usable
      computeSnapshots();

      // Extra: clicking on an edge weight in svg could prompt to edit weight - optional
      svg.addEventListener('dblclick', (e) => {
        // if user double-clicks near a weight label, allow editing that edge
        const target = e.target;
        if (target.tagName === 'text' && target.classList.contains('weight-label')) {
          const g = target.parentNode;
          const key = g.getAttribute('data-key'); // "i-j"
          if (!key) return;
          const parts = key.split('-').map(s => parseInt(s, 10));
          const i = parts[0], j = parts[1];
          const input = prompt(`Set weight for edge ${i} → ${j} (type INF for no edge)`, String(adj[i][j] === INF ? INF_STR : adj[i][j]));
          if (input == null) return;
          const val = input.trim().toUpperCase();
          if (val === INF_STR) {
            adj[i][j] = INF;
            if (!directed) adj[j][i] = INF;
          } else {
            const nval = Number(val);
            if (!isFinite(nval)) return;
            adj[i][j] = nval;
            if (!directed) adj[j][i] = nval;
          }
          rebuildEdgesFromAdj();
          computeSnapshots();
          renderMatrices();
        }
      });

      // Safety: stop playing when page hidden/unloaded
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) stopPlaying();
      });
      window.addEventListener('beforeunload', () => stopPlaying());

    })();
  </script>
</body>
</html>