<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Deque Interactive Module</title>
  <style>
    :root{
      --safe: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #60a5fa;
      --muted: #94a3b8;
      --ok: #10b981;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.03);
      --radius: 10px;
      --shadow: 0 6px 18px rgba(2,6,23,0.6);
    }

    /* Safe area margins */
    html,body{
      height:100%;
      margin:0;
      padding:var(--safe);
      background: linear-gradient(180deg,#071123 0%, #071427 100%);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: #e6eef8;
      box-sizing:border-box;
    }
    *{box-sizing:inherit}
    a{color:inherit}

    /* Layout */
    .container{
      max-width:1200px;
      margin:0 auto;
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
    }

    /* Left explanation column */
    .panel {
      flex: 1 1 360px;
      min-width:280px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--radius);
      padding:20px;
      box-shadow:var(--shadow);
      border:1px solid rgba(255,255,255,0.03);
    }

    h1{margin:0 0 10px 0; font-size:20px}
    p{margin:0 0 12px 0; color:var(--muted); line-height:1.45}
    .section-title{font-weight:600; margin-top:12px; margin-bottom:8px; color:#dbeafe}

    /* Right interactive canvas */
    .canvas {
      flex: 2 1 640px;
      min-width:320px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--radius);
      padding:20px;
      box-shadow:var(--shadow);
      border:1px solid rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    /* Controls layout */
    .controls {
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    .input-group{
      display:flex;
      gap:8px;
      align-items:center;
    }
    input[type="text"]{
      background:var(--glass);
      border:1px solid rgba(255,255,255,0.04);
      padding:10px 12px;
      border-radius:8px;
      color:inherit;
      min-width:160px;
      outline:none;
    }
    input[type="text"]::placeholder{color:rgba(230,238,248,0.5)}
    button{
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      padding:10px 14px;
      border-radius:8px;
      color:inherit;
      cursor:pointer;
      transition:transform .12s ease, box-shadow .12s ease;
      min-width:110px;
    }
    button:active{transform:translateY(1px)}
    button:focus{outline:2px solid rgba(96,165,250,0.2); box-shadow:0 6px 18px rgba(96,165,250,0.06)}
    .primary{
      background:linear-gradient(180deg, #2563eb, #1e40af);
      border:1px solid rgba(255,255,255,0.08);
      box-shadow:0 6px 16px rgba(37,99,235,0.12);
    }
    .danger{
      background:linear-gradient(180deg,#ef4444,#b91c1c);
    }

    /* Toggles and sliders */
    .row {
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    .small{
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:8px;
      align-items:center;
    }
    input[type="range"]{
      width:180px;
    }

    /* Deque visual */
    .deque-viewport{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
      border-radius:12px;
      padding:20px;
      display:flex;
      flex-direction:column;
      gap:14px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .deque-track{
      min-height:120px;
      display:flex;
      align-items:center;
      gap:12px;
      padding:12px;
      overflow:auto;
    }
    .slot{
      width:96px;
      height:72px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
      border:1px dashed rgba(255,255,255,0.03);
      border-radius:10px;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      flex: 0 0 96px;
      transition:transform .25s cubic-bezier(.2,.9,.3,1), box-shadow .2s ease, opacity .2s ease;
    }
    .slot.filled{
      border-style:solid;
      border-color:rgba(96,165,250,0.18);
      background: linear-gradient(180deg, rgba(96,165,250,0.06), rgba(96,165,250,0.02));
    }
    .node {
      background: linear-gradient(180deg,#0ea5e9,#0369a1);
      color:white;
      padding:10px 14px;
      border-radius:8px;
      font-weight:600;
      box-shadow:0 8px 18px rgba(3,105,161,0.18);
      transform:translateY(0);
      transition:transform .28s cubic-bezier(.2,.9,.3,1), opacity .18s ease;
      max-width:88px;
      text-overflow:ellipsis;
      overflow:hidden;
      white-space:nowrap;
    }
    .slot.empty .node{opacity:0.0}
    .slot.head::after, .slot.tail::after{
      content:'';
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      bottom:-16px;
      width:0;height:0;
      border-left:8px solid transparent;
      border-right:8px solid transparent;
    }
    .slot.head::after{
      border-top:8px solid #34d399;
    }
    .slot.tail::after{
      border-top:8px solid #fca5a5;
      bottom:-18px;
    }
    .index {
      font-size:12px;
      color:var(--muted);
      text-align:center;
      margin-top:6px;
    }

    /* Animations for push/pop */
    .animate-in-left{ animation:pushInLeft .36s cubic-bezier(.2,.9,.3,1) both; }
    .animate-in-right{ animation:pushInRight .36s cubic-bezier(.2,.9,.3,1) both; }
    .animate-out-left{ animation:popOutLeft .36s ease both; }
    .animate-out-right{ animation:popOutRight .36s ease both; }
    @keyframes pushInLeft {
      from { transform: translateX(-40px) scale(.98); opacity:0 }
      to   { transform: translateX(0) scale(1); opacity:1 }
    }
    @keyframes pushInRight {
      from { transform: translateX(40px) scale(.98); opacity:0 }
      to   { transform: translateX(0) scale(1); opacity:1 }
    }
    @keyframes popOutLeft {
      from { transform: translateX(0) scale(1); opacity:1 }
      to   { transform: translateX(-40px) scale(.98); opacity:0 }
    }
    @keyframes popOutRight {
      from { transform: translateX(0) scale(1); opacity:1 }
      to   { transform: translateX(40px) scale(.98); opacity:0 }
    }

    /* Feedback messages */
    .message {
      padding:10px 12px;
      border-radius:8px;
      font-size:13px;
      color:#081126;
      display:inline-block;
    }
    .msg-ok{ background: linear-gradient(180deg,#bbf7d0,#86efac); }
    .msg-error{ background: linear-gradient(180deg,#fecaca,#fca5a5); color:#210101; }

    /* Operation log */
    .log{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
      padding:12px;
      border-radius:8px;
      font-size:13px;
      color:var(--muted);
      max-height:140px;
      overflow:auto;
      border:1px solid rgba(255,255,255,0.02);
    }
    .log-entry{ margin-bottom:8px; }
    .controls .spacer{flex:1}

    /* Drag chip */
    .chip {
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background:linear-gradient(180deg,#1f2937,#111827);
      border:1px solid rgba(255,255,255,0.03);
      cursor:grab;
      color:var(--muted);
    }
    .chip:active{cursor:grabbing}
    .chip .value{ color:#e6eef8; font-weight:700 }

    /* Responsive */
    @media (max-width:900px){
      .container{flex-direction:column}
      .panel{order:2}
      .canvas{order:1}
      .slot{width:84px; height:64px; flex:0 0 84px}
    }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Deque interactive module">
    <!-- Left panel: Concept Title, Learning Objective, Interaction Design, Layout Description -->
    <aside class="panel" aria-labelledby="concept-title">
      <h1 id="concept-title">Deque — Double-Ended Queue (Interactive)</h1>
      <p><strong>Learning Objective:</strong> After using this module you will understand deque operations (push/pop from both ends), how a bounded (circular) deque differs from an unbounded deque, and see visual animations that reinforce the head/tail behavior and edge cases (full/empty).</p>

      <div class="section-title">Interaction Design</div>
      <p>
        Interact using buttons, a draggable "chip", or keyboard:
      </p>
      <ul style="color:var(--muted); margin:8px 0 12px 18px;">
        <li>Type a value and use Push Front / Push Back to insert. Watch it slide in from the chosen side.</li>
        <li>Use Pop Front / Pop Back to remove. The removed node animates out and is displayed in the feedback area.</li>
        <li>Enable "Bounded (circular)" to visualize a fixed-capacity ring buffer with head/tail pointers and slot indices.</li>
        <li>Drag the blue chip onto the left/right of the deque to insert from that side (drag-and-drop).</li>
      </ul>

      <div class="section-title">Layout Description</div>
      <p>
        The page keeps a safe area margin of 24px and a minimum spacing of 16px between interactive controls. A left information panel explains the concept; the right interactive canvas contains controls on top, the deque visual in the middle, and an operation log below.
      </p>
      <p style="color:var(--muted)">Accessibility: controls are real buttons and inputs with ARIA annotations, the log uses aria-live to present operation results, and focus styles are provided.</p>
    </aside>

    <!-- Right interactive canvas -->
    <main class="canvas" aria-labelledby="interactive-title">
      <h2 id="interactive-title" style="margin:0;font-size:18px">Interactive Deque Playground</h2>

      <!-- Controls -->
      <div class="controls" role="region" aria-label="Controls">
        <div class="input-group" style="min-width:220px;">
          <input id="valueInput" type="text" placeholder="Enter value (text or number)" aria-label="Value to insert" />
          <button id="makeChip" title="Create a draggable chip from the input">Create Chip</button>
        </div>

        <div class="row">
          <button id="pushFront" class="primary" aria-label="Push to front">Push Front</button>
          <button id="pushBack" class="primary" aria-label="Push to back">Push Back</button>
          <button id="popFront" aria-label="Pop from front">Pop Front</button>
          <button id="popBack" aria-label="Pop from back">Pop Back</button>
          <button id="peekFront" aria-label="Peek front">Peek Front</button>
          <button id="peekBack" aria-label="Peek back">Peek Back</button>
        </div>

        <div class="spacer"></div>

        <div class="small">
          <label for="capacityRange">Capacity</label>
          <input id="capacityRange" type="range" min="3" max="12" value="7" aria-label="Set deque capacity"/>
          <span id="capValue" style="min-width:26px; text-align:center;">7</span>
        </div>

        <div class="small" style="margin-left:8px;">
          <label><input id="boundedToggle" type="checkbox" aria-label="Toggle bounded (circular) mode"/> Bounded (circular)</label>
        </div>

        <div style="min-width:12px"></div>

        <button id="clearBtn" class="danger" aria-label="Clear deque">Clear</button>
      </div>

      <!-- Deque Visual -->
      <section class="deque-viewport" aria-live="polite" aria-atomic="false">
        <div class="small" id="statusLine" aria-hidden="false">
          <span>Mode: <strong id="modeLabel">Unbounded</strong></span>
          <span style="margin-left: 16px;">Length: <strong id="lenLabel">0</strong></span>
        </div>

        <div id="dequeTrack" class="deque-track" role="list" aria-label="Deque visual representation">
          <!-- slots / nodes inserted here -->
        </div>

        <div class="index" id="indicesHint" style="color:var(--muted); display:none;">
          (Circular view: indices show internal ring-buffer positions; marked slots are head/tail.)
        </div>
      </section>

      <!-- Feedback & Log -->
      <div style="display:flex; gap:var(--gap); align-items:flex-start; flex-wrap:wrap;">
        <div style="flex:1 1 360px;">
          <div id="feedback" aria-live="polite"></div>
        </div>

        <div style="flex:1 1 360px;">
          <div class="log" id="log" role="log" aria-live="polite" aria-atomic="false">
            <div style="color:var(--muted); margin-bottom:8px;">Operation log:</div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
    // Deque interactive module (vanilla JS)
    (function(){
      // Elements
      const valueInput = document.getElementById('valueInput');
      const makeChipBtn = document.getElementById('makeChip');
      const pushFrontBtn = document.getElementById('pushFront');
      const pushBackBtn = document.getElementById('pushBack');
      const popFrontBtn = document.getElementById('popFront');
      const popBackBtn = document.getElementById('popBack');
      const peekFrontBtn = document.getElementById('peekFront');
      const peekBackBtn = document.getElementById('peekBack');
      const clearBtn = document.getElementById('clearBtn');
      const dequeTrack = document.getElementById('dequeTrack');
      const boundedToggle = document.getElementById('boundedToggle');
      const capacityRange = document.getElementById('capacityRange');
      const capValue = document.getElementById('capValue');
      const modeLabel = document.getElementById('modeLabel');
      const lenLabel = document.getElementById('lenLabel');
      const feedback = document.getElementById('feedback');
      const log = document.getElementById('log');
      const indicesHint = document.getElementById('indicesHint');

      // Internal state
      let bounded = false;
      let capacity = parseInt(capacityRange.value,10) || 7;
      capValue.textContent = capacity;
      // We maintain two representations:
      // - unboundedArray: simple JS array used when bounded === false
      // - ringBuffer: object with buffer array, head index, count used when bounded === true
      let unboundedArray = [];
      let ringBuffer = createRing(capacity);

      // Utilities
      function createRing(cap) {
        return {
          buf: new Array(cap).fill(null),
          cap: cap,
          head: 0,
          count: 0
        };
      }
      function logOp(text){
        const el = document.createElement('div');
        el.className = 'log-entry';
        el.textContent = `${new Date().toLocaleTimeString()}: ${text}`;
        log.appendChild(el);
        log.scrollTop = log.scrollHeight;
      }
      function showFeedback(text, ok=true){
        feedback.innerHTML = '';
        const div = document.createElement('div');
        div.className = 'message ' + (ok ? 'msg-ok' : 'msg-error');
        div.textContent = text;
        feedback.appendChild(div);
        setTimeout(()=> {
          if (feedback.contains(div)) feedback.removeChild(div);
        }, 2800);
      }
      function updateStatus(){
        const len = bounded ? ringBuffer.count : unboundedArray.length;
        lenLabel.textContent = len;
        modeLabel.textContent = bounded ? `Bounded (cap ${capacity})` : 'Unbounded';
        indicesHint.style.display = bounded ? 'block' : 'none';
      }

      // Rendering functions
      function clearVisual(){
        dequeTrack.innerHTML = '';
      }

      function renderUnbounded(){
        clearVisual();
        // Show up to 24 to avoid overflow; allow horizontal scroll for more
        unboundedArray.forEach((v, i) => {
          const s = makeSlot();
          const node = makeNode(v);
          s.appendChild(node);
          if (i===0) s.classList.add('head');
          if (i===unboundedArray.length-1) s.classList.add('tail');
          s.setAttribute('role','listitem');
          dequeTrack.appendChild(s);
        });
      }

      function renderBounded(){
        clearVisual();
        const {buf, cap, head, count} = ringBuffer;
        // Show fixed slots (internal indices)
        for(let i=0;i<cap;i++){
          const s = makeSlot();
          s.classList.add('empty');
          const indexEl = document.createElement('div');
          indexEl.className = 'index';
          indexEl.textContent = `idx ${i}`;
          s.appendChild(indexEl);

          if (count > 0){
            if (isOccupied(i)){
              s.classList.remove('empty');
              s.classList.add('filled');
              // get logical value
              const val = buf[i];
              const node = makeNode(val);
              // Put node above the index
              s.insertBefore(node, indexEl);
            }
            if (i === ringBuffer.head) s.classList.add('head');
            if (i === tailIndex()) s.classList.add('tail');
          }
          s.setAttribute('role','listitem');
          dequeTrack.appendChild(s);
        }
        function isOccupied(idx){
          // distance from head modulo cap < count
          const dist = (idx - head + cap) % cap;
          return dist < count;
        }
        function tailIndex(){
          // tail is (head + count -1) % cap
          return (head + count - 1 + cap) % cap;
        }
      }

      function makeSlot(){
        const s = document.createElement('div');
        s.className = 'slot empty';
        s.style.minWidth = '96px';
        // allow it to be a drop target (for dragging)
        s.addEventListener('dragover', ev=>ev.preventDefault());
        s.addEventListener('drop', onDropSlot);
        return s;
      }
      function makeNode(value){
        const n = document.createElement('div');
        n.className = 'node';
        n.textContent = String(value);
        n.setAttribute('draggable','false');
        return n;
      }

      // Operations: unbounded
      function pushFrontUnbounded(val, animate=true){
        unboundedArray.unshift(val);
        logOp(`pushFront(${val})`);
        showFeedback(`Pushed "${val}" to front.`);
        refreshVisual('front', animate);
      }
      function pushBackUnbounded(val, animate=true){
        unboundedArray.push(val);
        logOp(`pushBack(${val})`);
        showFeedback(`Pushed "${val}" to back.`);
        refreshVisual('back', animate);
      }
      function popFrontUnbounded(){
        if (unboundedArray.length===0){
          showFeedback('Deque is empty — nothing to pop.', false);
          logOp(`popFront() -> empty`);
          return null;
        }
        const v = unboundedArray.shift();
        logOp(`popFront() -> ${v}`);
        showFeedback(`Popped "${v}" from front.`);
        refreshVisual('frontPop', true, v);
        return v;
      }
      function popBackUnbounded(){
        if (unboundedArray.length===0){
          showFeedback('Deque is empty — nothing to pop.', false);
          logOp(`popBack() -> empty`);
          return null;
        }
        const v = unboundedArray.pop();
        logOp(`popBack() -> ${v}`);
        showFeedback(`Popped "${v}" from back.`);
        refreshVisual('backPop', true, v);
        return v;
      }

      // Operations: bounded (ring buffer)
      function pushFrontBounded(val){
        if (ringBuffer.count === ringBuffer.cap){
          showFeedback('Deque is full — cannot push.', false);
          logOp(`pushFront(${val}) -> full`);
          // visual shake
          flashTrack('danger');
          return false;
        }
        // new head = (head - 1 + cap) % cap
        ringBuffer.head = (ringBuffer.head - 1 + ringBuffer.cap) % ringBuffer.cap;
        ringBuffer.buf[ringBuffer.head] = val;
        ringBuffer.count++;
        logOp(`pushFront(${val})`);
        showFeedback(`Pushed "${val}" to front.`);
        refreshVisual('front', true);
        return true;
      }
      function pushBackBounded(val){
        if (ringBuffer.count === ringBuffer.cap){
          showFeedback('Deque is full — cannot push.', false);
          logOp(`pushBack(${val}) -> full`);
          flashTrack('danger');
          return false;
        }
        const tail = (ringBuffer.head + ringBuffer.count) % ringBuffer.cap;
        ringBuffer.buf[tail] = val;
        ringBuffer.count++;
        logOp(`pushBack(${val})`);
        showFeedback(`Pushed "${val}" to back.`);
        refreshVisual('back', true);
        return true;
      }
      function popFrontBounded(){
        if (ringBuffer.count === 0){
          showFeedback('Deque is empty — nothing to pop.', false);
          logOp(`popFront() -> empty`);
          return null;
        }
        const v = ringBuffer.buf[ringBuffer.head];
        ringBuffer.buf[ringBuffer.head] = null;
        ringBuffer.head = (ringBuffer.head + 1) % ringBuffer.cap;
        ringBuffer.count--;
        logOp(`popFront() -> ${v}`);
        showFeedback(`Popped "${v}" from front.`);
        refreshVisual('frontPop', true, v);
        return v;
      }
      function popBackBounded(){
        if (ringBuffer.count === 0){
          showFeedback('Deque is empty — nothing to pop.', false);
          logOp(`popBack() -> empty`);
          return null;
        }
        const tailIdx = (ringBuffer.head + ringBuffer.count - 1 + ringBuffer.cap) % ringBuffer.cap;
        const v = ringBuffer.buf[tailIdx];
        ringBuffer.buf[tailIdx] = null;
        ringBuffer.count--;
        logOp(`popBack() -> ${v}`);
        showFeedback(`Popped "${v}" from back.`);
        refreshVisual('backPop', true, v);
        return v;
      }

      // Visual helpers: animate in/out
      function refreshVisual(action='none', animate=true, poppedValue){
        updateStatus();
        if (bounded) renderBounded();
        else renderUnbounded();

        // Highlight newest/removed node with animation
        if (!animate) return;

        if (!bounded){
          // find element nodes
          const items = Array.from(dequeTrack.querySelectorAll('.slot'));
          if (action === 'front' && items[0]){
            const node = items[0].querySelector('.node');
            if (node) node.classList.add('animate-in-left');
          } else if (action === 'back' && items.length){
            const node = items[items.length-1].querySelector('.node');
            if (node) node.classList.add('animate-in-right');
          } else if (action === 'frontPop'){
            // create a floating element showing popped node animates out
            if (poppedValue !== undefined && poppedValue !== null){
              animatePop(poppedValue, 'left');
            }
          } else if (action === 'backPop'){
            if (poppedValue !== undefined && poppedValue !== null){
              animatePop(poppedValue, 'right');
            }
          }
        } else {
          // bounded visual: animate slot of head or tail index
          const slots = Array.from(dequeTrack.querySelectorAll('.slot'));
          if (action==='front'){
            const idx = ringBuffer.head;
            const slotEl = slots[idx];
            if (slotEl){
              const node = slotEl.querySelector('.node');
              if (node) node.classList.add('animate-in-left');
            }
          } else if (action==='back'){
            const tailIdx = (ringBuffer.head + ringBuffer.count -1 + ringBuffer.cap) % ringBuffer.cap;
            const slotEl = slots[tailIdx];
            if (slotEl){
              const node = slotEl.querySelector('.node');
              if (node) node.classList.add('animate-in-right');
            }
          } else if (action==='frontPop'){
            if (poppedValue !== undefined && poppedValue !== null) animatePop(poppedValue, 'left');
          } else if (action==='backPop'){
            if (poppedValue !== undefined && poppedValue !== null) animatePop(poppedValue, 'right');
          }
        }
      }

      function animatePop(value, dir){
        // create floating node overlay near start of track
        const float = document.createElement('div');
        float.className = 'node';
        float.textContent = String(value);
        float.style.position = 'absolute';
        float.style.zIndex = 999;
        float.style.opacity = '1';
        // position roughly center-top of dequeTrack
        const rect = dequeTrack.getBoundingClientRect();
        float.style.left = (rect.left + (dir==='left' ? 20 : rect.width - 120)) + 'px';
        float.style.top = (rect.top + 12) + 'px';
        float.style.transition = 'transform .6s ease, opacity .6s ease';
        document.body.appendChild(float);
        requestAnimationFrame(()=>{
          float.style.transform = `translateX(${dir==='left' ? -80 : 80}px) translateY(-20px)`;
          float.style.opacity = '0';
        });
        setTimeout(()=> float.remove(), 650);
      }

      function flashTrack(kind){
        dequeTrack.style.transition = 'box-shadow .18s ease, transform .12s ease';
        dequeTrack.style.transform = 'translateY(-3px)';
        dequeTrack.style.boxShadow = kind === 'danger' ? '0 6px 18px rgba(239,68,68,0.14)' : '0 6px 18px rgba(16,185,129,0.12)';
        setTimeout(()=>{
          dequeTrack.style.transform = '';
          dequeTrack.style.boxShadow = '';
        }, 260);
      }

      // Event handlers for UI controls
      pushFrontBtn.addEventListener('click', ()=>{
        const val = valueInput.value.trim();
        if (val === ''){
          showFeedback('Enter a value first.', false);
          return;
        }
        if (bounded) pushFrontBounded(val);
        else pushFrontUnbounded(val);
        valueInput.value = '';
      });
      pushBackBtn.addEventListener('click', ()=>{
        const val = valueInput.value.trim();
        if (val === ''){
          showFeedback('Enter a value first.', false);
          return;
        }
        if (bounded) pushBackBounded(val);
        else pushBackUnbounded(val);
        valueInput.value = '';
      });
      popFrontBtn.addEventListener('click', ()=> {
        if (bounded) popFrontBounded();
        else popFrontUnbounded();
      });
      popBackBtn.addEventListener('click', ()=> {
        if (bounded) popBackBounded();
        else popBackUnbounded();
      });
      peekFrontBtn.addEventListener('click', ()=>{
        let v = null;
        if (bounded) {
          if (ringBuffer.count === 0) { showFeedback('Deque empty.'); logOp('peekFront -> empty'); return; }
          v = ringBuffer.buf[ringBuffer.head];
        } else {
          if (unboundedArray.length === 0){ showFeedback('Deque empty.'); logOp('peekFront -> empty'); return; }
          v = unboundedArray[0];
        }
        showFeedback(`Front: "${v}"`);
        logOp(`peekFront -> ${v}`);
      });
      peekBackBtn.addEventListener('click', ()=>{
        let v = null;
        if (bounded){
          if (ringBuffer.count === 0){ showFeedback('Deque empty.'); logOp('peekBack -> empty'); return; }
          const tailIdx = (ringBuffer.head + ringBuffer.count - 1 + ringBuffer.cap) % ringBuffer.cap;
          v = ringBuffer.buf[tailIdx];
        } else {
          if (unboundedArray.length === 0){ showFeedback('Deque empty.'); logOp('peekBack -> empty'); return; }
          v = unboundedArray[unboundedArray.length - 1];
        }
        showFeedback(`Back: "${v}"`);
        logOp(`peekBack -> ${v}`);
      });

      clearBtn.addEventListener('click', ()=>{
        unboundedArray = [];
        ringBuffer = createRing(capacity);
        showFeedback('Deque cleared.');
        logOp('clear()');
        refreshVisual('none', false);
      });

      boundedToggle.addEventListener('change', (e)=>{
        bounded = e.target.checked;
        // if switching to bounded and current unbounded length > capacity, trim from back
        if (bounded){
          if (unboundedArray.length > capacity){
            // trim oldest elements from back to fit
            const removed = unboundedArray.splice(capacity);
            logOp(`Switch to bounded: trimmed ${removed.length} items`);
            showFeedback(`Switched to bounded; trimmed ${removed.length} items from back to fit capacity.`, true);
          }
          // populate ringBuffer from unboundedArray
          ringBuffer = createRing(capacity);
          unboundedArray.forEach(v => {
            // pushBackBounded won't animate here; use direct insertion
            const tail = (ringBuffer.head + ringBuffer.count) % ringBuffer.cap;
            ringBuffer.buf[tail] = v;
            ringBuffer.count++;
          });
          unboundedArray = [];
        } else {
          // convert ringBuffer contents into unboundedArray in logical order
          const arr = [];
          for (let i=0;i<ringBuffer.count;i++){
            const idx = (ringBuffer.head + i) % ringBuffer.cap;
            arr.push(ringBuffer.buf[idx]);
          }
          unboundedArray = arr;
          ringBuffer = createRing(capacity);
        }
        refreshVisual('none', false);
      });

      capacityRange.addEventListener('input', (e)=>{
        capacity = parseInt(e.target.value,10);
        capValue.textContent = capacity;
      });
      capacityRange.addEventListener('change', (e)=>{
        const newCap = parseInt(e.target.value,10);
        // If bounded, change ring buffer capacity (attempt to preserve contents)
        if (bounded){
          // extract current logical items
          const items = [];
          for(let i=0;i<ringBuffer.count;i++){
            const idx = (ringBuffer.head + i) % ringBuffer.cap;
            items.push(ringBuffer.buf[idx]);
          }
          // if new cap < items.length, trim from back
          if (newCap < items.length){
            const removed = items.splice(newCap);
            logOp(`Resized capacity to ${newCap}; removed ${removed.length} items`);
            showFeedback(`Capacity reduced: removed ${removed.length} items from back.`, true);
          }
          // create new ring and put items
          ringBuffer = createRing(newCap);
          items.forEach(v=>{
            const tail = (ringBuffer.head + ringBuffer.count) % ringBuffer.cap;
            ringBuffer.buf[tail] = v;
            ringBuffer.count++;
          });
        } else {
          // unbounded: no immediate change needed, but update capacity var
          // if current length > newCap, we keep the unbounded array as-is but warn when switching to bounded
          if (unboundedArray.length > newCap){
            showFeedback(`Note: current length (${unboundedArray.length}) exceeds new capacity (${newCap}). Switching to bounded will trim.`, true);
            logOp(`setCapacity(${newCap}) (unbounded; current length > capacity)`);
          } else {
            logOp(`setCapacity(${newCap})`);
          }
        }
        capacity = newCap;
        capValue.textContent = capacity;
        updateStatus();
        refreshVisual('none', false);
      });

      // Drag & Drop: create a draggable chip from input
      makeChipBtn.addEventListener('click', ()=>{
        const text = valueInput.value.trim();
        if (!text){
          showFeedback('Enter a value first to make a chip.', false);
          return;
        }
        createChip(text);
        valueInput.value = '';
        showFeedback('Draggable chip created. Drag it onto the deque to insert from that side.');
      });

      function createChip(text){
        // create a floating chip appended to control area
        const chip = document.createElement('div');
        chip.className = 'chip';
        chip.setAttribute('draggable','true');
        chip.setAttribute('role','button');
        chip.setAttribute('aria-label','Draggable chip: ' + text);
        const valSpan = document.createElement('span');
        valSpan.className = 'value';
        valSpan.textContent = text;
        chip.appendChild(valSpan);
        chip.addEventListener('dragstart', ev=>{
          ev.dataTransfer.setData('text/plain', text);
          // set drag image (fallback: use the chip itself)
          if (ev.dataTransfer.setDragImage){
            // create small canvas-like element to use as drag image
            const crt = chip.cloneNode(true);
            crt.style.position='absolute';
            crt.style.top='-9999px';
            document.body.appendChild(crt);
            ev.dataTransfer.setDragImage(crt, 10, 10);
            setTimeout(()=> document.body.removeChild(crt), 0);
          }
        });
        chip.addEventListener('click', ()=>{
          // quick shortcut: push back by click
          if (bounded) pushBackBounded(text);
          else pushBackUnbounded(text);
          chip.remove();
        });
        // add a small "remove" on right-click
        chip.addEventListener('contextmenu', ev=>{
          ev.preventDefault();
          chip.remove();
        });
        // append to controls area
        makeChipBtn.parentElement.appendChild(chip);
      }

      // Deque drop behavior: if dropped on leftmost slot area, push front; if on rightmost, push back; else push to nearest
      function onDropSlot(ev){
        ev.preventDefault();
        const val = ev.dataTransfer.getData('text/plain') || ev.target.textContent || '';
        if (!val) return;
        // Determine side by comparing drop position to slot center
        const slotRect = ev.currentTarget.getBoundingClientRect();
        const dropX = ev.clientX;
        const isLeft = dropX < (slotRect.left + slotRect.width/2);
        if (isLeft){
          if (bounded) pushFrontBounded(val);
          else pushFrontUnbounded(val);
        } else {
          if (bounded) pushBackBounded(val);
          else pushBackUnbounded(val);
        }
        // If the dragged element exists in DOM and is a chip, remove it
        // Many browsers don't include reference to the dragged element. Try to delete any chip with matching text near.
        const chips = Array.from(document.querySelectorAll('.chip .value')).filter(n=>n.textContent===val);
        if (chips.length) chips[0].closest('.chip').remove();
      }

      // accessibility: keyboard shortcuts
      // Enter in input -> pushBack
      valueInput.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter'){
          if (bounded) pushBackBounded(valueInput.value.trim());
          else pushBackUnbounded(valueInput.value.trim());
          valueInput.value = '';
        }
      });

      // initial render
      updateStatus();
      refreshVisual('none', false);

      // Expose nothing to window (module encapsulated)
    })();
  </script>
</body>
</html>