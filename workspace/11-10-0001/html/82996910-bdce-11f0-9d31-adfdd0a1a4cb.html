<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Linked List Interactive Module</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe-margin: 24px;
      --gap: 16px; /* minimum spacing between interactive elements */
      --node-w: 90px;
      --node-h: 56px;
      --accent: #0366d6;
      --muted: #6b7280;
      --bg: #f8fafc;
      --card: #ffffff;
      --danger: #d73a49;
      --success: #16a34a;
      --shadow: 0 6px 18px rgba(16,24,40,0.08);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg, #f7f9fc 0%, var(--bg) 100%);
      color: #0f172a;
    }

    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-width: 1100px;
      margin: 0 auto;
    }

    h1 {
      font-size: 1.25rem;
      margin: 0;
      color: #051126;
    }

    p.lead {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    main.module {
      margin: 0 auto;
      width: 100%;
      max-width: 1100px;
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: calc(var(--gap) * 1.5);
      align-items: start;
    }

    /* Responsive: stack on small screens */
    @media (max-width: 880px) {
      main.module {
        grid-template-columns: 1fr;
      }
    }

    /* Left column: description and controls */
    .panel {
      background: var(--card);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
      min-height: 220px;
    }

    .section-title {
      font-weight: 600;
      font-size: 0.95rem;
      color: #0b1220;
    }

    .small {
      font-size: 0.9rem;
      color: var(--muted);
      line-height: 1.4;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    .row {
      display: flex;
      gap: var(--gap);
      align-items: center;
    }

    .row.wrap {
      flex-wrap: wrap;
    }

    label {
      font-size: 0.85rem;
      color: var(--muted);
    }

    input[type="number"],
    input[type="text"] {
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #e6edf3;
      background: #fff;
      outline: none;
      font-size: 0.95rem;
      color: #021124;
      min-width: 0;
    }

    input[type="number"]:focus,
    input[type="text"]:focus {
      border-color: rgba(3,102,214,0.35);
      box-shadow: 0 4px 10px rgba(3,102,214,0.08);
    }

    .btn {
      appearance: none;
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 10px 12px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 6px 12px rgba(3,102,214,0.12);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    .btn:hover { transform: translateY(-2px); }
    .btn:active { transform: translateY(0); }

    .btn.secondary {
      background: #eef2ff;
      color: var(--accent);
      box-shadow: none;
      font-weight: 600;
      border: 1px solid rgba(3,102,214,0.08);
    }

    .btn.danger {
      background: var(--danger);
      box-shadow: none;
    }

    .control-grid {
      display: grid;
      grid-template-columns: repeat(2,1fr);
      gap: var(--gap);
    }

    @media (max-width: 520px) {
      .control-grid { grid-template-columns: 1fr; }
    }

    .hint {
      font-size: 0.85rem;
      color: var(--muted);
    }

    /* Right column: visualization */
    .vis {
      background: linear-gradient(180deg, rgba(255,255,255,0.9), #fff);
      border-radius: 12px;
      padding: 18px;
      box-shadow: var(--shadow);
      min-height: 420px;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
      overflow: hidden;
    }

    .vis-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: var(--gap);
    }

    .status {
      font-size: 0.92rem;
      color: var(--muted);
    }

    .canvas-wrap {
      position: relative;
      flex: 1;
      min-height: 260px;
      border-radius: 8px;
      background: linear-gradient(180deg, #fbfdff, #ffffff);
      border: 1px solid #eef3f8;
      padding: 16px;
      overflow: auto;
    }

    /* Node styles */
    .nodes {
      display: flex;
      gap: 32px; /* visual spacing between nodes horizontally */
      align-items: center;
      min-height: var(--node-h);
      transition: height 220ms ease;
      padding-bottom: 6px;
    }

    .node {
      width: var(--node-w);
      height: var(--node-h);
      border-radius: 10px;
      background: linear-gradient(180deg, #ffffff, #fcfdff);
      border: 1px solid #e6eef8;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      box-shadow: 0 6px 18px rgba(10,20,40,0.04);
      transition: transform 240ms cubic-bezier(.2,.9,.2,1), opacity 240ms ease;
      flex-shrink: 0;
    }

    .node-value {
      font-weight: 700;
      color: #06202b;
      font-size: 1rem;
      user-select: none;
    }

    .node-index {
      position: absolute;
      top: -12px;
      right: -10px;
      background: #f1f5f9;
      color: var(--muted);
      font-size: 0.72rem;
      padding: 4px 6px;
      border-radius: 8px;
    }

    /* Head label */
    .head-label {
      position: absolute;
      left: 8px;
      top: -18px;
      background: transparent;
      font-size: 0.82rem;
      color: var(--accent);
      font-weight: 700;
    }

    /* Current pointer (animated) */
    .current-pointer {
      position: absolute;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: var(--accent);
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.72rem;
      transform: translate(-50%, -50%);
      box-shadow: 0 6px 14px rgba(3,102,214,0.2);
      transition: transform 360ms cubic-bezier(.2,.9,.2,1);
      z-index: 40;
    }

    /* Highlighted node during traversal */
    .node.highlight {
      transform: translateY(-6px) scale(1.02);
      box-shadow: 0 10px 26px rgba(3,102,214,0.12);
      border-color: rgba(3,102,214,0.12);
    }

    /* Deleted node animation */
    .node.removing {
      transform: scale(0.6) translateY(12px);
      opacity: 0;
    }

    .msg {
      font-size: 0.9rem;
      color: var(--muted);
    }

    /* Footer small controls */
    .footer-controls {
      display: flex;
      gap: var(--gap);
      align-items: center;
      flex-wrap: wrap;
    }

    /* SVG overlay that draws arrows between nodes */
    .svg-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 10;
    }

    /* Accessibility focus outline */
    .btn:focus, input:focus {
      outline: 3px solid rgba(3,102,214,0.12);
      outline-offset: 3px;
      border-radius: 8px;
    }

    /* Tiny helper */
    .kbd {
      background: #f1f5f9;
      color: #0b1220;
      padding: 4px 8px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 0.82rem;
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Linked List Interactive Module">
    <header>
      <h1>Linked List — Interactive Exploration</h1>
      <p class="lead">Step through fundamental singly linked list operations: insertion, deletion, and traversal. Visual animations show pointers and node transitions to deepen intuition.</p>
    </header>

    <main class="module" aria-live="polite">
      <!-- Left panel: meta + controls -->
      <aside class="panel" aria-label="Controls and explanations">
        <div>
          <div class="section-title">Concept Title</div>
          <div class="small">Singly Linked List: nodes with value and next pointer. Manage head, insert/delete nodes, and traverse step-by-step.</div>
        </div>

        <div>
          <div class="section-title">Learning Objective</div>
          <div class="small">
            After interacting, you should understand:
            <ul style="margin:8px 0 0 18px; color:var(--muted); font-size:0.92rem;">
              <li>How head and next pointers form a chain of nodes</li>
              <li>How insertions and deletions update pointers</li>
              <li>How traversal moves a current pointer from head along next links</li>
            </ul>
          </div>
        </div>

        <div>
          <div class="section-title">Interaction Design</div>
          <div class="small">
            Use the controls to add nodes (head or tail), insert after an index, delete, or traverse. Visual feedback:
            <ul style="margin:8px 0 0 18px; color:var(--muted); font-size:0.92rem;">
              <li>Pointer (blue circle) animates along arrows during traversal.</li>
              <li>Nodes rise and highlight when visited; arrows redraw on changes.</li>
              <li>Insertions slide in, deletions fade out—so pointer/pointer updates are visible.</li>
            </ul>
          </div>
        </div>

        <div>
          <div class="section-title">Layout Description</div>
          <div class="small">
            Left column: descriptive text and interactive controls (inputs, buttons). Right column: visualization area with nodes and arrows. Safe area margins of 24px applied; spacing between controls at least 16px. The visualization is responsive and scrollable horizontally for long lists. Controls are keyboard accessible.
          </div>
        </div>

        <hr />

        <!-- Controls -->
        <div class="controls" aria-hidden="false">
          <div class="section-title">Create and Modify</div>

          <div class="row wrap">
            <label for="value-input">Node value</label>
            <input id="value-input" type="text" placeholder="e.g. 42 or 'A'" aria-label="Node value" />
          </div>

          <div class="control-grid">
            <button class="btn" id="add-head">Add Head</button>
            <button class="btn secondary" id="add-tail">Add Tail</button>
            <button class="btn" id="random">Random List</button>
            <button class="btn secondary" id="clear">Clear</button>
          </div>

          <div class="row">
            <div style="flex:1;">
              <label for="index-input">Index (0-based)</label>
              <input id="index-input" type="number" min="0" placeholder="e.g. 0" aria-label="Index" />
            </div>
            <div style="display:flex; flex-direction:column; gap:8px;">
              <button class="btn" id="insert-after">Insert After</button>
              <button class="btn secondary" id="delete-at">Delete At</button>
            </div>
          </div>

          <div class="row">
            <button class="btn secondary" id="delete-head">Delete Head</button>
            <button class="btn secondary" id="delete-tail">Delete Tail</button>
          </div>

        </div>

        <hr />

        <div>
          <div class="section-title">Traversal</div>
          <div class="small">
            Click "Step" to move the current pointer along the list. "Auto" plays traversal. Use "Search" to animate traversal until a value is found.
          </div>

          <div class="row">
            <button class="btn" id="step">Step</button>
            <button class="btn secondary" id="auto">Auto</button>
            <button class="btn secondary" id="reset-pointer">Reset Pointer</button>
          </div>

          <div style="display:flex; gap: var(--gap); align-items:center; margin-top:8px;">
            <input id="search-input" type="text" placeholder="Find value" aria-label="Search value" />
            <button class="btn" id="search">Search</button>
          </div>
        </div>

        <div class="hint" style="margin-top:6px;">Tip: Add a few nodes, then use Step/Auto to watch pointers and pointer updates during insert/delete operations.</div>
      </aside>

      <!-- Right panel: visualization -->
      <section class="vis" aria-label="Linked list visualization">
        <div class="vis-top">
          <div class="status" id="list-status">List: empty</div>
          <div class="footer-controls">
            <div class="msg" id="node-count">0 nodes</div>
            <div class="kbd" id="head-label-small">head</div>
          </div>
        </div>

        <div class="canvas-wrap" id="canvas" tabindex="0" aria-label="Linked list canvas">
          <!-- SVG layer for arrows -->
          <svg class="svg-layer" id="svg" aria-hidden="true"></svg>

          <!-- Nodes container (flex) -->
          <div class="nodes" id="nodes" role="list" aria-label="Nodes container"></div>

          <!-- Animated current pointer -->
          <div id="current-pointer" class="current-pointer" aria-hidden="true" style="display:none;">cur</div>
        </div>

        <div style="display:flex; justify-content:space-between; align-items:center; gap:var(--gap);">
          <div class="msg" id="action-msg">Ready.</div>
          <div style="color:var(--muted); font-size:0.88rem;">Accessible controls • keyboard-focusable</div>
        </div>

      </section>
    </main>
  </div>

  <script>
    /******************************************************
     * Linked List Visual Interactive Module (vanilla JS)
     * - Implements a conceptual singly linked list using
     *   an array of nodes to model order; renders nodes and
     *   SVG arrows and animates pointer for traversal.
     *
     * Accessibility:
     * - Buttons and inputs are focusable.
     * - Canvas has tabindex for keyboard focus.
     ******************************************************/

    (function () {
      // DOM references
      const nodesEl = document.getElementById('nodes');
      const svgEl = document.getElementById('svg');
      const pointerEl = document.getElementById('current-pointer');
      const statusEl = document.getElementById('list-status');
      const countEl = document.getElementById('node-count');
      const actionMsg = document.getElementById('action-msg');

      const valueInput = document.getElementById('value-input');
      const indexInput = document.getElementById('index-input');
      const searchInput = document.getElementById('search-input');

      const btnAddHead = document.getElementById('add-head');
      const btnAddTail = document.getElementById('add-tail');
      const btnRandom = document.getElementById('random');
      const btnClear = document.getElementById('clear');
      const btnInsertAfter = document.getElementById('insert-after');
      const btnDeleteAt = document.getElementById('delete-at');
      const btnDeleteHead = document.getElementById('delete-head');
      const btnDeleteTail = document.getElementById('delete-tail');

      const btnStep = document.getElementById('step');
      const btnAuto = document.getElementById('auto');
      const btnResetPointer = document.getElementById('reset-pointer');
      const btnSearch = document.getElementById('search');

      // Model: an array of node objects {id, value}
      let nodes = [];
      let nextId = 1;

      // Traversal state
      let currentIndex = null; // null means pointer is not shown / reset
      let autoTimer = null;
      let isAuto = false;

      // Helper: update status text
      function updateStatus(msg) {
        statusEl.textContent = msg;
        actionMsg.textContent = msg;
      }

      // Helper: render nodes in DOM
      function render() {
        // Clear existing
        nodesEl.innerHTML = '';
        // Create node elements
        nodes.forEach((nd, i) => {
          const el = document.createElement('div');
          el.className = 'node';
          el.setAttribute('role', 'listitem');
          el.setAttribute('data-index', i);
          el.setAttribute('data-id', nd.id);
          // index label
          const idx = document.createElement('div');
          idx.className = 'node-index';
          idx.textContent = i;
          // value
          const val = document.createElement('div');
          val.className = 'node-value';
          val.textContent = nd.value;
          el.appendChild(idx);
          el.appendChild(val);

          nodesEl.appendChild(el);
        });

        // Update count and status
        countEl.textContent = nodes.length + (nodes.length === 1 ? ' node' : ' nodes');
        statusEl.textContent = nodes.length ? 'List: head → ...' : 'List: empty';

        // After DOM updated, redraw arrows and position pointer if present
        requestAnimationFrame(() => {
          drawArrows();
          positionPointerToIndex(currentIndex, /*instant*/ true);
        });
      }

      // Draw SVG arrows between adjacent nodes
      function drawArrows() {
        // Clear svg
        while (svgEl.firstChild) svgEl.removeChild(svgEl.firstChild);

        const containerRect = nodesEl.getBoundingClientRect();
        const svgRect = svgEl.getBoundingClientRect();
        const offsetX = containerRect.left - svgRect.left;
        const offsetY = containerRect.top - svgRect.top;

        // Setup marker for arrowhead
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        marker.setAttribute('id', 'arrowhead');
        marker.setAttribute('markerWidth', '10');
        marker.setAttribute('markerHeight', '10');
        marker.setAttribute('refX', '6');
        marker.setAttribute('refY', '5');
        marker.setAttribute('orient', 'auto');
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M0,0 L10,5 L0,10 z');
        path.setAttribute('fill', '#9fb7e8');
        marker.appendChild(path);
        defs.appendChild(marker);
        svgEl.appendChild(defs);

        // For each pair nodes[i] -> nodes[i+1], draw a cubic bezier arrow
        const nodeEls = Array.from(nodesEl.children);
        for (let i = 0; i < nodeEls.length - 1; i++) {
          const a = nodeEls[i].getBoundingClientRect();
          const b = nodeEls[i + 1].getBoundingClientRect();

          // start at right middle of a
          const x1 = a.right - svgRect.left + 4;
          const y1 = a.top + a.height / 2 - svgRect.top;
          // end at left middle of b
          const x2 = b.left - svgRect.left - 6;
          const y2 = b.top + b.height / 2 - svgRect.top;

          // control points for gentle arc
          const dx = Math.max(30, (x2 - x1) / 2);
          const cx1 = x1 + dx;
          const cy1 = y1;
          const cx2 = x2 - dx;
          const cy2 = y2;

          const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          const d = `M ${x1} ${y1} C ${cx1} ${cy1} ${cx2} ${cy2} ${x2} ${y2}`;
          pathEl.setAttribute('d', d);
          pathEl.setAttribute('stroke', '#cfe3ff');
          pathEl.setAttribute('stroke-width', '4');
          pathEl.setAttribute('fill', 'none');
          pathEl.setAttribute('marker-end', 'url(#arrowhead)');
          pathEl.setAttribute('opacity', '0.98');
          svgEl.appendChild(pathEl);
        }
      }

      // Utility to create a new node object
      function createNode(value) {
        return { id: nextId++, value: String(value) };
      }

      // Add operations
      function addHead(value) {
        const node = createNode(value);
        nodes.unshift(node);
        // show animation: slide in from left
        render();
        const first = nodesEl.children[0];
        first.style.transform = 'translateX(-40px) scale(0.98)';
        first.style.opacity = '0';
        requestAnimationFrame(() => {
          first.style.transition = 'transform 360ms cubic-bezier(.2,.9,.2,1), opacity 260ms ease';
          first.style.transform = 'translateX(0) scale(1)';
          first.style.opacity = '1';
          setTimeout(() => { first.style.transition = ''; }, 400);
        });
        updateStatus('Added node at head.');
      }

      function addTail(value) {
        const node = createNode(value);
        nodes.push(node);
        render();
        const last = nodesEl.children[nodesEl.children.length - 1];
        last.style.transform = 'translateX(40px) scale(0.98)';
        last.style.opacity = '0';
        requestAnimationFrame(() => {
          last.style.transition = 'transform 360ms cubic-bezier(.2,.9,.2,1), opacity 260ms ease';
          last.style.transform = 'translateX(0) scale(1)';
          last.style.opacity = '1';
          setTimeout(() => { last.style.transition = ''; }, 400);
        });
        updateStatus('Added node at tail.');
      }

      function insertAfter(index, value) {
        if (index < 0 || index >= nodes.length) {
          updateStatus('Index out of range.');
          return;
        }
        const node = createNode(value);
        nodes.splice(index + 1, 0, node);
        render();
        // animate the inserted node slightly up
        const el = nodesEl.children[index + 1];
        el.style.transform = 'translateY(-12px)';
        el.style.opacity = '0';
        requestAnimationFrame(() => {
          el.style.transition = 'transform 360ms cubic-bezier(.2,.9,.2,1), opacity 280ms ease';
          el.style.transform = 'translateY(0)';
          el.style.opacity = '1';
          setTimeout(() => { el.style.transition = ''; }, 420);
        });
        updateStatus(`Inserted after index ${index}.`);
      }

      function deleteAt(index) {
        if (index < 0 || index >= nodes.length) {
          updateStatus('Index out of range.');
          return;
        }
        // animate removal
        const el = nodesEl.children[index];
        el.classList.add('removing');
        setTimeout(() => {
          nodes.splice(index, 1);
          render();
        }, 260);
        updateStatus(`Deleted node at index ${index}.`);
        // adjust current pointer if necessary
        if (currentIndex !== null) {
          if (nodes.length === 0) currentIndex = null;
          else if (index < currentIndex) currentIndex -= 1;
          else if (index === currentIndex) currentIndex = null;
        }
        positionPointerToIndex(currentIndex, true);
      }

      function deleteHead() {
        if (!nodes.length) { updateStatus('List is empty.'); return; }
        deleteAt(0);
      }

      function deleteTail() {
        if (!nodes.length) { updateStatus('List is empty.'); return; }
        deleteAt(nodes.length - 1);
      }

      function clearList() {
        nodes = [];
        currentIndex = null;
        render();
        pointerEl.style.display = 'none';
        updateStatus('Cleared list.');
      }

      // Traversal: move pointer to next node, highlight
      function stepTraversal() {
        if (!nodes.length) { updateStatus('List is empty.'); return; }
        if (currentIndex === null) {
          currentIndex = 0;
        } else if (currentIndex < nodes.length - 1) {
          currentIndex += 1;
        } else {
          updateStatus('Reached end of list.');
          return;
        }
        animateVisit(currentIndex);
      }

      // animate visiting a node: pointer moves, highlight node
      function animateVisit(index) {
        // Show pointer if hidden
        pointerEl.style.display = 'flex';
        positionPointerToIndex(index, /*instant*/ false);
        // highlight node
        const el = nodesEl.children[index];
        if (!el) return;
        el.classList.add('highlight');
        setTimeout(() => {
          el.classList.remove('highlight');
        }, 700);
        updateStatus(`Visited index ${index} (value: ${nodes[index].value}).`);
      }

      // Position pointer element to center-top of node at index
      function positionPointerToIndex(index, instant) {
        if (index === null || index === undefined || index < 0 || index >= nodes.length) {
          pointerEl.style.display = 'none';
          return;
        }
        const target = nodesEl.children[index];
        if (!target) {
          pointerEl.style.display = 'none';
          return;
        }
        pointerEl.style.display = 'flex';

        const canvasRect = document.getElementById('canvas').getBoundingClientRect();
        const t = target.getBoundingClientRect();

        const left = (t.left + t.right) / 2 - canvasRect.left;
        const top = t.top - canvasRect.top - 10; // slightly above node

        if (instant) {
          pointerEl.style.transition = 'none';
        } else {
          pointerEl.style.transition = 'transform 420ms cubic-bezier(.2,.9,.2,1)';
        }
        pointerEl.style.transform = `translate(${left}px, ${top}px) translate(-50%, -50%)`;
        // restore transition after short time
        if (instant) {
          setTimeout(() => { pointerEl.style.transition = ''; }, 50);
        }
      }

      // Auto traversal
      function startAutoTraversal() {
        if (isAuto) {
          stopAutoTraversal();
          return;
        }
        if (!nodes.length) { updateStatus('List is empty.'); return; }
        isAuto = true;
        btnAuto.textContent = 'Stop';
        updateStatus('Auto traversal started.');
        if (currentIndex === null) currentIndex = 0;
        animateVisit(currentIndex);
        autoTimer = setInterval(() => {
          if (currentIndex === null) currentIndex = 0;
          else if (currentIndex < nodes.length - 1) currentIndex += 1;
          else {
            stopAutoTraversal();
            updateStatus('Auto traversal finished.');
            return;
          }
          animateVisit(currentIndex);
        }, 900);
      }

      function stopAutoTraversal() {
        isAuto = false;
        btnAuto.textContent = 'Auto';
        clearInterval(autoTimer);
        autoTimer = null;
      }

      // Search animation: traverse until value found (string match)
      function searchValue(value) {
        if (!nodes.length) { updateStatus('List is empty.'); return; }
        // start from head
        currentIndex = null;
        pointerEl.style.display = 'flex';
        let idx = 0;
        updateStatus(`Searching for "${value}"...`);
        const step = () => {
          if (idx >= nodes.length) {
            updateStatus(`Value "${value}" not found.`);
            return;
          }
          currentIndex = idx;
          animateVisit(idx);
          if (String(nodes[idx].value) === String(value)) {
            updateStatus(`Found value at index ${idx}.`);
            return;
          }
          idx++;
          setTimeout(step, 700);
        };
        step();
      }

      // Utility: generate small random list
      function randomList() {
        const len = Math.max(1, Math.floor(Math.random() * 6) + 1);
        nodes = [];
        for (let i = 0; i < len; i++) {
          nodes.push(createNode(Math.floor(Math.random() * 99)));
        }
        currentIndex = null;
        render();
        updateStatus('Random list created.');
      }

      // Wire up buttons
      btnAddHead.addEventListener('click', () => {
        const val = valueInput.value.trim() || '•';
        addHead(val);
        valueInput.value = '';
      });

      btnAddTail.addEventListener('click', () => {
        const val = valueInput.value.trim() || '•';
        addTail(val);
        valueInput.value = '';
      });

      btnRandom.addEventListener('click', () => {
        randomList();
      });

      btnClear.addEventListener('click', () => {
        clearList();
      });

      btnInsertAfter.addEventListener('click', () => {
        const idx = parseInt(indexInput.value, 10);
        const val = valueInput.value.trim() || '•';
        if (isNaN(idx)) {
          updateStatus('Please provide a valid index.');
          return;
        }
        insertAfter(idx, val);
      });

      btnDeleteAt.addEventListener('click', () => {
        const idx = parseInt(indexInput.value, 10);
        if (isNaN(idx)) {
          updateStatus('Please provide a valid index.');
          return;
        }
        deleteAt(idx);
      });

      btnDeleteHead.addEventListener('click', () => { deleteHead(); });
      btnDeleteTail.addEventListener('click', () => { deleteTail(); });

      btnStep.addEventListener('click', () => {
        stopAutoTraversal();
        stepTraversal();
      });

      btnAuto.addEventListener('click', () => {
        if (isAuto) stopAutoTraversal();
        else startAutoTraversal();
      });

      btnResetPointer.addEventListener('click', () => {
        stopAutoTraversal();
        currentIndex = null;
        pointerEl.style.display = 'none';
        updateStatus('Pointer reset.');
      });

      btnSearch.addEventListener('click', () => {
        const v = searchInput.value.trim();
        if (!v) { updateStatus('Enter value to search.'); return; }
        stopAutoTraversal();
        searchValue(v);
      });

      // Keyboard support: Enter on inputs triggers addTail
      valueInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          addTail(valueInput.value.trim() || '•');
          valueInput.value = '';
        }
      });

      indexInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const idx = parseInt(indexInput.value, 10);
          if (!isNaN(idx)) {
            insertAfter(idx, valueInput.value.trim() || '•');
            indexInput.value = '';
          }
        }
      });

      // Resize observer to redraw arrows on layout changes
      let resizeObserver = new ResizeObserver(drawArrows);
      resizeObserver.observe(document.getElementById('canvas'));

      // Clicking a node selects it (move pointer there)
      nodesEl.addEventListener('click', (e) => {
        const nodeEl = e.target.closest('.node');
        if (!nodeEl) return;
        const idx = parseInt(nodeEl.getAttribute('data-index'), 10);
        currentIndex = idx;
        positionPointerToIndex(idx, false);
        nodeEl.classList.add('highlight');
        setTimeout(() => nodeEl.classList.remove('highlight'), 700);
        updateStatus(`Pointer moved to index ${idx}.`);
      });

      // Initial render
      render();

      // Expose some helpful demo content for first load
      (function seedDemo() {
        nodes = [createNode(7), createNode(13), createNode(21)];
        currentIndex = null;
        render();
        updateStatus('Demo list initialized. Try Step or Add Node.');
      })();

    })();
  </script>
</body>
</html>