<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Selection Sort — Interactive Module</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --bg: #f7f9fc;
      --card: #ffffff;
      --muted: #6b7280;
      --accent: #0369a1;
      --success: #059669;
      --danger: #dc2626;
      --shadow: 0 6px 18px rgba(13, 16, 23, 0.08);
      --bar-width: 44px;
      --bar-gap: 12px;
      --max-bars: 12;
    }

    html,body{
      height:100%;
      margin:0;
      font-family: Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
      background: linear-gradient(180deg, #eef2ff 0%, #f7f9fc 100%);
      color:#0f172a;
    }

    /* Safe area margin 24px */
    body{
      padding: var(--safe-padding);
      box-sizing: border-box;
    }

    .container{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      justify-content:space-between;
      max-width:1200px;
      margin:0 auto;
    }

    /* Responsive stacking for narrow screens */
    @media (max-width: 900px){
      .container{
        flex-direction:column;
      }
    }

    /* Left column: info and controls */
    .panel{
      background:var(--card);
      border-radius:12px;
      padding:20px;
      box-shadow:var(--shadow);
      flex:0 0 360px;
      min-width:260px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    @media (max-width:900px){
      .panel{ flex:unset; width:100%; }
    }

    .title{
      font-size:20px;
      font-weight:600;
      color:var(--accent);
      display:flex;
      gap:12px;
      align-items:center;
    }
    .subtitle{
      font-size:14px;
      color:var(--muted);
    }

    .section{
      background: #fbfdff;
      border-radius:8px;
      padding:12px;
      border:1px solid rgba(2,6,23,0.03);
    }

    .section h4{
      margin:0 0 8px 0;
      font-size:13px;
      color:#0b1220;
    }

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:var(--gap);
      align-items:center;
    }

    /* Right column: visual canvas */
    .canvas{
      background:transparent;
      flex:1 1 600px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      min-width:300px;
    }

    .visual-card{
      background:var(--card);
      border-radius:12px;
      padding:20px;
      box-shadow:var(--shadow);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      align-items:stretch;
    }

    .toolbar{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    button{
      background:#0369a18f;
      color:white;
      border:none;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      min-height:40px;
    }
    button.secondary{
      background:#e6eef6;
      color:#0f172a;
      font-weight:600;
    }
    button.ghost{
      background:transparent;
      color:var(--accent);
      border:1px solid rgba(3,105,161,0.12);
    }
    button:disabled{
      opacity:0.5;
      cursor:not-allowed;
    }

    .small{
      padding:6px 10px;
      font-size:13px;
      border-radius:8px;
    }

    .speed{
      display:flex;
      align-items:center;
      gap:8px;
    }
    input[type=range]{
      width:160px;
    }

    .array-area{
      background:linear-gradient(180deg, #ffffff, #fbfdff);
      border-radius:8px;
      padding:18px;
      min-height:220px;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .bars{
      display:flex;
      align-items:flex-end;
      gap:var(--bar-gap);
      padding:8px;
      min-height:160px;
      max-width:100%;
      overflow:hidden;
    }

    .bar{
      width:var(--bar-width);
      background:linear-gradient(180deg,#60a5fa,#0369a1);
      color:white;
      border-radius:6px 6px 4px 4px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      user-select:none;
      position:relative;
      transition: transform 300ms ease, box-shadow 150ms ease;
      box-shadow: 0 3px 8px rgba(3,105,161,0.12);
      cursor:pointer;
    }

    .bar .label{
      position:absolute;
      top:-28px;
      font-size:12px;
      color:#0b1220;
      background:rgba(255,255,255,0.92);
      padding:4px 6px;
      border-radius:6px;
      box-shadow:0 3px 10px rgba(2,6,23,0.06);
    }

    .bar.index{
      font-size:11px;
      position:absolute;
      bottom:-20px;
      color:var(--muted);
      background:transparent;
      box-shadow:none;
      font-weight:600;
    }

    .bar.current{
      outline:3px solid #fde68a;
      transform:translateY(-6px);
    }
    .bar.min{
      outline:3px solid #7dd3fc;
      box-shadow:0 8px 20px rgba(34,197,94,0.06);
      transform:translateY(-8px);
    }
    .bar.comparing{
      outline:3px dashed rgba(2,6,23,0.06);
      transform: translateY(-4px);
      box-shadow:0 6px 18px rgba(3,105,161,0.06);
    }
    .bar.sorted{
      outline:3px solid rgba(5,150,105,0.12);
      background:linear-gradient(180deg,#bbf7d0,#10b981);
    }

    .legend{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .legend .item{
      display:flex;
      gap:8px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
    }
    .swatch{
      width:18px;height:18px;border-radius:4px;
      display:inline-block;
      box-shadow:0 2px 6px rgba(2,6,23,0.06);
    }

    .footer-note{
      font-size:13px;
      color:var(--muted);
    }

    /* Small helper for shake on wrong click */
    @keyframes shake {
      0% { transform: translateX(0px); }
      20% { transform: translateX(-6px); }
      40% { transform: translateX(6px); }
      60% { transform: translateX(-4px); }
      80% { transform: translateX(4px); }
      100% { transform: translateX(0px); }
    }
    .shake{
      animation: shake 360ms ease;
    }

    /* Ensure minimum spacing 16px between controls */
    .controls > * { margin: 0; }

    /* Help text */
    .muted-small { color:var(--muted); font-size:13px; }
  </style>
</head>
<body>
  <div class="container" role="main">
    <!-- Left column: descriptive and instructions -->
    <aside class="panel" aria-labelledby="module-title">
      <div>
        <div class="title" id="module-title">Selection Sort — Visual & Interactive</div>
        <div class="subtitle">A hands-on walkthrough of selection sort's process and swaps.</div>
      </div>

      <div class="section" aria-label="Learning Objective">
        <h4>Learning Objective</h4>
        <p class="muted-small">After interacting with this module you will be able to:
          identify the repeated selection of the minimum element each pass, track comparisons, and understand how and when swaps occur in Selection Sort.</p>
      </div>

      <div class="section" aria-label="Interaction Design">
        <h4>Interaction Design</h4>
        <p class="muted-small">
          Use the controls to step through the algorithm or play it. Visual cues:
        </p>
        <ul class="muted-small" style="margin:8px 0 0 18px; padding:0;">
          <li><strong>Current index (i)</strong>: highlighted (yellow). This is where the next minimum will be placed.</li>
          <li><strong>Current min</strong>: highlighted (cyan). Updated when a smaller value is found.</li>
          <li><strong>Comparing</strong>: element being compared animates slightly upward.</li>
          <li><strong>Sorted</strong>: elements already placed in final positions turn green.</li>
          <li><strong>Swap animation</strong>: bars slide to swap positions so you can see the exchange.</li>
        </ul>
        <p class="muted-small" style="margin-top:8px;">
          Toggle "Manual Swap" to practice: when the pass completes, click the bar you think should swap into position i. If wrong, you'll see a shake and can try again.
        </p>
      </div>

      <div class="section" aria-label="Layout Description">
        <h4>Layout Description</h4>
        <p class="muted-small" style="margin:0">
          The page uses a two-column layout: left for explanatory text and controls, right for the visual canvas and interactive controls.
          The design respects a safe padding of 24px and keeps 16px minimum spacing between interactive elements. Controls are keyboard-accessible (Space = step).
        </p>
      </div>

      <div class="section" aria-label="Tips">
        <h4>Tips for Practice</h4>
        <ul class="muted-small" style="margin:8px 0 0 18px; padding:0;">
          <li>Start with small arrays to follow each comparison.</li>
          <li>Use "Step" to see how minIndex changes during a pass.</li>
          <li>Switch to "Manual Swap" to test your understanding of which element is the minimum.</li>
        </ul>
      </div>

      <div style="margin-top:auto;">
        <div class="footer-note">Author: Interactive Learning · Built with vanilla HTML/CSS/JS</div>
      </div>
    </aside>

    <!-- Right column: interactive visual -->
    <section class="canvas" aria-label="Selection sort visual canvas">
      <div class="visual-card" aria-live="polite">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;">
          <div style="display:flex;flex-direction:column;">
            <div style="font-weight:700">Array</div>
            <div class="muted-small">Click a bar to select in manual swap mode</div>
          </div>

          <div class="toolbar" role="region" aria-label="Controls">
            <button id="shuffleBtn" class="small" title="Shuffle array">Shuffle</button>
            <button id="resetBtn" class="small secondary" title="Reset to original">Reset</button>

            <button id="stepBtn" class="small" title="Step (Space)">Step</button>
            <button id="playBtn" class="small" title="Play / Pause">Play</button>

            <label class="small speed" title="Adjust speed">
              <span style="font-size:13px;color:var(--muted)">Speed</span>
              <input id="speedRange" type="range" min="0.25" max="2" step="0.25" value="1" />
            </label>

            <button id="manualToggle" class="small ghost" title="Toggle manual swap mode">Manual Swap: Off</button>
          </div>
        </div>

        <div class="array-area" role="img" aria-label="Array visualization">
          <div id="bars" class="bars" aria-hidden="false"></div>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:12px;">
          <div class="legend" aria-hidden="false" style="gap:12px;">
            <div class="item"><span class="swatch" style="background:#fde68a;border:1px solid rgba(0,0,0,0.04)"></span> Current index (i)</div>
            <div class="item"><span class="swatch" style="background:#7dd3fc;border:1px solid rgba(0,0,0,0.04)"></span> Current min</div>
            <div class="item"><span class="swatch" style="background:#60a5fa;border:1px solid rgba(0,0,0,0.04)"></span> Comparing</div>
            <div class="item"><span class="swatch" style="background:#bbf7d0;border:1px solid rgba(0,0,0,0.04)"></span> Sorted</div>
          </div>

          <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
            <div class="muted-small">Size:
              <input id="sizeInput" type="number" min="3" max="12" value="8" style="width:64px;margin-left:8px;padding:6px;border-radius:8px;border:1px solid #e6eef6;font-weight:600;" />
            </div>
            <div class="muted-small">Seeded values may repeat; try different sizes.</div>
          </div>
        </div>
      </div>

      <!-- Info Card: current algorithm state -->
      <div class="visual-card">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;">
          <div>
            <div style="font-weight:700">Algorithm State</div>
            <div class="muted-small" id="stateText" style="margin-top:6px">Idle — array ready</div>
          </div>
          <div style="text-align:right">
            <div class="muted-small">Comparisons: <span id="comparisons">0</span></div>
            <div class="muted-small" style="margin-top:6px">Swaps: <span id="swaps">0</span></div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    (function(){
      // Constants and DOM
      const barsContainer = document.getElementById('bars');
      const shuffleBtn = document.getElementById('shuffleBtn');
      const resetBtn = document.getElementById('resetBtn');
      const stepBtn = document.getElementById('stepBtn');
      const playBtn = document.getElementById('playBtn');
      const speedRange = document.getElementById('speedRange');
      const manualToggle = document.getElementById('manualToggle');
      const sizeInput = document.getElementById('sizeInput');
      const stateText = document.getElementById('stateText');
      const comparisonsEl = document.getElementById('comparisons');
      const swapsEl = document.getElementById('swaps');

      let array = [];
      let original = [];
      let n = Math.max(3, Math.min(12, parseInt(sizeInput.value,10) || 8));
      let i = 0, j = 1, minIndex = 0;
      let running = false;
      let timer = null;
      let speed = 1; // multiplier; lower -> faster, but we'll invert
      let comparisons = 0, swaps = 0;
      let manualSwap = false;
      let phase = 'idle'; // 'finding', 'swapping', 'done'
      let animating = false;

      // Utility functions
      function randInt(min, max){ return Math.floor(Math.random()*(max-min+1)) + min; }

      function genRandomArray(sz){
        const a = [];
        for(let k=0;k<sz;k++) a.push(randInt(10,99));
        return a;
      }

      function render(){
        barsContainer.innerHTML = '';
        const maxVal = Math.max(...array);
        array.forEach((val, idx) => {
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.style.height = Math.max(32, (val / maxVal) * 160) + 'px';
          bar.style.width = 'var(--bar-width)';
          bar.dataset.index = idx;
          bar.dataset.value = val;
          bar.tabIndex = 0;
          bar.setAttribute('role','button');
          bar.setAttribute('aria-label', 'Value ' + val + ' at index ' + idx);

          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = val;
          bar.appendChild(label);

          const idxLabel = document.createElement('div');
          idxLabel.className = 'index';
          idxLabel.textContent = idx;
          bar.appendChild(idxLabel);

          bar.addEventListener('click', () => onBarClick(idx, bar));
          bar.addEventListener('keydown', (e) => {
            if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onBarClick(idx, bar); }
          });

          barsContainer.appendChild(bar);
        });
        updateVisualHighlights();
      }

      function updateVisualHighlights(){
        const bars = Array.from(barsContainer.children);
        bars.forEach((bar, idx) => {
          bar.classList.remove('current','min','comparing','sorted','shake');
          if (phase === 'done' || i >= array.length) {
            bar.classList.add('sorted');
          } else {
            if (idx < i) bar.classList.add('sorted');
            if (idx === i) bar.classList.add('current');
            if (idx === minIndex && phase !== 'done') bar.classList.add('min');
            if (idx === j && phase === 'finding') bar.classList.add('comparing');
          }
          // Update label and index text (in case values changed)
          const label = bar.querySelector('.label');
          label.textContent = array[idx];
          const idxLabel = bar.querySelector('.index');
          idxLabel.textContent = idx;
          bar.dataset.index = idx;
          bar.dataset.value = array[idx];
          // update style height
          const maxVal = Math.max(...array);
          bar.style.height = Math.max(32, (array[idx] / maxVal) * 160) + 'px';
        });
        comparisonsEl.textContent = comparisons;
        swapsEl.textContent = swaps;
        if (phase === 'done') {
          stateText.textContent = 'Done — array sorted';
        } else {
          stateText.textContent = `i=${i}  min=${minIndex}  j=${(phase==='finding'?j:'-')}  phase=${phase}`;
        }
      }

      // Selection sort step logic (non-animated)
      async function step(){
        if (animating) return;
        if (phase === 'done') return;
        if (i >= array.length - 1) {
          phase = 'done';
          updateVisualHighlights();
          return;
        }
        phase = 'finding';
        updateVisualHighlights();

        // If j is within bounds, perform one compare step
        if (j < array.length) {
          // compare array[j] with array[minIndex]
          comparisons++;
          // visual: highlight j as comparing
          updateVisualHighlights();

          if (array[j] < array[minIndex]) {
            minIndex = j;
          }
          j++;
          updateVisualHighlights();
          return;
        }

        // j reached end, perform swap if needed
        if (minIndex !== i) {
          phase = 'swapping';
          updateVisualHighlights();
          await animateSwapIndices(i, minIndex);
          swaps++;
          // After swap, proceed
        }
        // move to next i
        i++;
        minIndex = i;
        j = i + 1;
        if (i >= array.length - 1) {
          phase = 'done';
        } else {
          phase = 'finding';
        }
        updateVisualHighlights();
      }

      // animate swap bars at indices a and b
      function animateSwapIndices(a, b){
        return new Promise((resolve) => {
          animating = true;
          const bars = Array.from(barsContainer.children);
          const barA = bars[a];
          const barB = bars[b];
          // compute positions
          const rectA = barA.getBoundingClientRect();
          const rectB = barB.getBoundingClientRect();
          const deltaX = rectB.left - rectA.left;
          // apply transform to visually move them
          barA.style.transition = 'transform 400ms ease';
          barB.style.transition = 'transform 400ms ease';
          barA.style.transform = `translateX(${deltaX}px)`;
          barB.style.transform = `translateX(${-deltaX}px)`;
          // increase z-index while animating
          barA.style.zIndex = '10';
          barB.style.zIndex = '10';

          // after transition, swap actual array and re-render positions without animation
          const cleanup = () => {
            barA.style.transition = '';
            barB.style.transition = '';
            barA.style.transform = '';
            barB.style.transform = '';
            barA.style.zIndex = '';
            barB.style.zIndex = '';
            // swap in data array
            const tmp = array[a];
            array[a] = array[b];
            array[b] = tmp;
            // update DOM: re-render to ensure correct order and indices
            render();
            animating = false;
            resolve();
          };

          // Use event listener for transition end on one of them (safeguard with timeout)
          let done = false;
          const onEnd = (ev) => {
            if(done) return;
            done = true;
            cleanup();
          };
          barB.addEventListener('transitionend', onEnd, {once:true});
          // safety timeout
          setTimeout(() => {
            if(!done) onEnd();
          }, 700);
        });
      }

      // Manual swap handling: if manualSwap mode on, when pass finishes user must click correct bar
      function onBarClick(idx, barEl){
        if (!manualSwap) return;
        if (phase !== 'finding') return;
        // If j hasn't finished scanning, clicking shouldn't swap. Only allow when j >= n (pass finished)
        if (j <= array.length - 1) {
          // optionally inform user to finish scanning
          barEl.classList.add('shake');
          setTimeout(() => barEl.classList.remove('shake'), 350);
          return;
        }
        // Now user must select the minIndex to swap with i
        if (idx === minIndex) {
          // perform actual swap (animated)
          (async () => {
            animating = true;
            await animateSwapIndices(i, minIndex);
            swaps++;
            // advance
            i++;
            minIndex = i;
            j = i+1;
            if (i >= array.length - 1) phase = 'done';
            else phase = 'finding';
            animating = false;
            updateVisualHighlights();
          })();
        } else {
          // wrong choice — shake and hint
          barEl.classList.add('shake');
          setTimeout(() => barEl.classList.remove('shake'), 360);
        }
      }

      function resetState(newArray){
        array = newArray.slice();
        original = newArray.slice();
        n = array.length;
        i = 0; j = 1; minIndex = 0;
        comparisons = 0; swaps = 0;
        phase = 'finding';
        running = false;
        clearInterval(timer);
        timer = null;
        updatePlayBtn();
        render();
      }

      function shuffleArray(){
        const sz = Math.max(3, Math.min(12, parseInt(sizeInput.value,10) || 8));
        const newArr = genRandomArray(sz);
        resetState(newArr);
      }

      function resetToOriginal(){
        resetState(original);
      }

      function updatePlayBtn(){
        playBtn.textContent = running ? 'Pause' : 'Play';
      }

      // Play loop uses step() at interval (adjusted by speed)
      function startPlaying(){
        if (running) return;
        running = true;
        updatePlayBtn();
        const baseDelay = 600; // ms per step at speed 1
        function tick(){
          // If algorithm ends, stop
          if (phase === 'done') {
            stopPlaying();
            return;
          }
          step();
        }
        timer = setInterval(tick, Math.max(120, baseDelay / speed));
      }

      function stopPlaying(){
        running = false;
        updatePlayBtn();
        if (timer) {
          clearInterval(timer);
          timer = null;
        }
      }

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        if (e.code === 'Space') { e.preventDefault(); step(); }
      });

      // Event hooks
      shuffleBtn.addEventListener('click', () => {
        shuffleArray();
      });
      resetBtn.addEventListener('click', () => {
        resetToOriginal();
      });
      stepBtn.addEventListener('click', () => {
        step();
      });
      playBtn.addEventListener('click', () => {
        if (running) stopPlaying(); else startPlaying();
      });
      speedRange.addEventListener('input', (e) => {
        // Mapping: slider value 0.25..2 -> bigger means faster
        speed = parseFloat(e.target.value);
        // If running, restart interval to adjust speed
        if (running) {
          stopPlaying();
          startPlaying();
        }
      });
      manualToggle.addEventListener('click', () => {
        manualSwap = !manualSwap;
        manualToggle.textContent = 'Manual Swap: ' + (manualSwap ? 'On' : 'Off');
        if (manualSwap) {
          manualToggle.classList.add('ghost');
          manualToggle.style.background = '#eaf8ff';
        } else {
          manualToggle.style.background = 'transparent';
        }
      });
      sizeInput.addEventListener('change', () => {
        let v = parseInt(sizeInput.value,10) || 8;
        if (v < 3) v = 3;
        if (v > 12) v = 12;
        sizeInput.value = v;
        shuffleArray();
      });

      // Initialize with a random array
      resetState(genRandomArray(n));

      // Expose some helpers for debugging in console (optional)
      window._selectionSortViz = {
        getArray: () => array.slice(),
        step: step,
        play: startPlaying,
        pause: stopPlaying
      };
    })();
  </script>
</body>
</html>