<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Hash Table (Separate Chaining)</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --accent: #2563eb;
      --muted: #6b7280;
      --bg: #f8fafc;
      --card: #ffffff;
      --success: #16a34a;
      --danger: #dc2626;
      --yellow: #f59e0b;
      --shadow: 0 6px 18px rgba(16,24,40,0.06);
      --area-radius: 12px;
    }
    /* Safe area margins */
    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,#f8fafc,#eef2ff);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: #0f172a;
      -webkit-font-smoothing:antialiased;
    }
    body{
      padding: var(--safe-margin);
      box-sizing: border-box;
    }

    /* Layout container */
    .container{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      justify-content:space-between;
      max-width:1200px;
      margin:0 auto;
    }

    /* Sidebar (controls + descriptions) */
    .sidebar{
      width:360px;
      min-width:280px;
      background:var(--card);
      border-radius:var(--area-radius);
      padding:20px;
      box-shadow:var(--shadow);
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .title{
      font-size:20px;
      font-weight:600;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .subtitle{
      color:var(--muted);
      font-size:13px;
      margin-top:2px;
    }

    /* Controls */
    .controls{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    label{font-size:13px;color:#0f172a;}
    input[type="text"], input[type="number"], select{
      padding:10px 12px;
      border-radius:8px;
      border:1px solid #e6edf3;
      font-size:14px;
      outline:none;
    }
    input[type="number"]{width:120px;}
    .row{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    .btn{
      background:var(--accent);
      color:white;
      border:none;
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      font-size:14px;
      transition:transform .12s ease, box-shadow .12s ease;
    }
    .btn:active{transform:translateY(1px);}
    .btn.secondary{
      background:#e6eefb;
      color:var(--accent);
      font-weight:600;
    }
    .btn.warn{
      background:var(--yellow);
      color:#082032;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
    }

    /* Visualization area */
    .visual{
      flex:1;
      min-width:420px;
      background:linear-gradient(180deg,#ffffff,#fbfdff);
      border-radius:var(--area-radius);
      padding:20px;
      box-shadow:var(--shadow);
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      align-items:stretch;
    }
    .vis-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:var(--gap);
    }
    .metrics{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .metric{
      background:#f8fafc;
      border-radius:10px;
      padding:8px 12px;
      font-size:13px;
      color:#0f172a;
    }

    /* Table of buckets */
    .table-area{
      display:flex;
      gap:16px;
      align-items:flex-start;
      overflow:auto;
      padding-bottom:6px;
    }
    .bucket{
      min-width:120px;
      background:linear-gradient(180deg,#ffffff,#f8fafc);
      border-radius:10px;
      border:1px solid #e6eefb;
      padding:10px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:center;
      position:relative;
    }
    .bucket-index{
      width:36px;
      height:36px;
      border-radius:8px;
      background:#eef2ff;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      color:var(--accent);
      font-size:13px;
    }
    .chain{
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height:40px;
      align-items:center;
      width:100%;
    }
    .node{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background:linear-gradient(90deg,#eef2ff,#f1f5f9);
      border:1px solid #dbeafe;
      font-weight:600;
      color:#04263b;
      box-shadow:0 6px 14px rgba(16,24,40,0.04);
      transform-origin:center;
      transition:transform .25s ease, box-shadow .2s ease, opacity .2s ease;
    }
    .node.small{padding:6px 8px;font-size:13px;}
    .node .del{
      background:transparent;
      border:none;
      color:var(--danger);
      margin-left:6px;
      cursor:pointer;
      font-weight:700;
      font-size:13px;
    }

    /* Highlights and animations */
    .bucket.highlight{
      box-shadow:0 6px 20px rgba(37,99,235,0.12);
      border-color:rgba(37,99,235,0.3);
    }
    .node.highlight{
      transform:scale(1.06);
      box-shadow:0 10px 24px rgba(37,99,235,0.12);
    }
    .node.found{
      background:linear-gradient(90deg,#dcfce7,#bbf7d0);
      border:1px solid rgba(16,185,129,0.2);
      color:#064e3b;
    }
    .node.removing{
      opacity:0.2;
      transform:scale(.9) rotate(-6deg);
    }

    /* moving clone used for animation (absolute) */
    .moving-clone{
      position:fixed;
      z-index:40;
      pointer-events:none;
      transition:transform .6s cubic-bezier(.2,.9,.2,1), opacity .2s ease;
      will-change:transform, opacity;
    }

    /* Explanation panel */
    .explain{
      background:#ffffff;
      padding:12px;
      border-radius:10px;
      border:1px solid #eef2ff;
      font-size:13px;
      color:var(--muted);
    }

    /* Responsive: stack on narrow screens */
    @media (max-width:1000px){
      .container{flex-direction:column;}
      .sidebar{width:100%;}
      .visual{min-width:unset;}
    }

    /* Ensure minimum spacing between interactive elements */
    .controls > * { margin-bottom: 16px; }
    .row > * { margin-bottom: 0; }

  </style>
</head>
<body>
  <div class="container" role="main">
    <aside class="sidebar" aria-label="Controls and description">
      <div>
        <div class="title" id="concept-title">Hash Table — Separate Chaining</div>
        <div class="subtitle">Visual, step-by-step operations: insert, search, delete and collisions</div>
      </div>

      <div class="controls" aria-live="polite">
        <div>
          <label for="key-input">Key (string or number)</label>
          <input id="key-input" type="text" placeholder="e.g., apple or 42" aria-label="Key input" />
        </div>

        <div class="row" aria-hidden="false">
          <div>
            <label for="table-size">Table Size (buckets)</label><br/>
            <input id="table-size" type="number" min="2" max="32" value="8" aria-label="Table size" />
          </div>
          <div>
            <label for="hash-select">Hash Function</label><br/>
            <select id="hash-select" aria-label="Hash function">
              <option value="ascii">ASCII sum mod size (default)</option>
              <option value="firstchar">First char code mod size</option>
              <option value="numeric">Numeric mod size (for numbers)</option>
            </select>
          </div>
        </div>

        <div class="row">
          <button class="btn" id="insert-btn" aria-label="Insert key">Insert</button>
          <button class="btn secondary" id="search-btn" aria-label="Search key">Search</button>
          <button class="btn warn" id="delete-btn" aria-label="Delete key">Delete</button>
        </div>

        <div class="row">
          <button class="btn secondary" id="reset-btn" aria-label="Reset table">Reset Table</button>
          <button class="btn secondary" id="random-btn" aria-label="Fill random keys">Fill Random</button>
        </div>

        <div class="explain" id="learning-objective" aria-label="Learning Objective">
          <strong>Learning objective</strong>
          <div style="margin-top:8px;">
            After interacting, you will understand how hashing maps keys to bucket indices, how collisions are handled using separate chaining (linked lists per bucket), and how insertion, search, and deletion traverse and update chains visually.
          </div>
        </div>

        <div class="explain" style="font-size:13px;" aria-hidden="false">
          <strong>Interaction tips</strong>
          <ul style="margin:8px 0 0 18px; color:var(--muted);">
            <li>Type a key and click Insert to add it.</li>
            <li>Click Search to animate scanning the chain.</li>
            <li>Click Delete to remove the first matching key in the chain.</li>
            <li>Change table size to see distribution differences (reset clears table).</li>
          </ul>
        </div>

        <div aria-live="polite" id="status" class="muted" style="margin-top:4px;">Ready.</div>
      </div>
    </aside>

    <section class="visual" aria-label="Hash Table Visualization">
      <div class="vis-header">
        <div style="display:flex;flex-direction:column;">
          <div style="font-weight:700;">Buckets (index → chain)</div>
          <div class="muted" style="margin-top:6px; font-size:13px;">Separate chaining: nodes appended at head (new items at top)</div>
        </div>

        <div class="metrics" aria-hidden="false">
          <div class="metric" id="metric-load">Load: 0</div>
          <div class="metric" id="metric-size">Size: 8</div>
          <div class="metric" id="metric-collisions">Collisions: 0</div>
        </div>
      </div>

      <div class="table-area" id="table-area" tabindex="0" aria-label="Hash table buckets">
        <!-- buckets injected here -->
      </div>

      <div class="explain" id="interaction-design" aria-label="Interaction Design">
        <strong>Interaction design</strong>
        <ol style="margin:8px 0 0 18px; color:var(--muted);">
          <li>Insert: computes hash → highlights target bucket → animates key moving into chain. If chain non-empty, collision counter increments.</li>
          <li>Search: computes hash → highlights bucket → steps through each node with brief highlight (simulating traversal). Match highlights green.</li>
          <li>Delete: finds first match in chain, animates removal and adjusts chain. Shows message if not found.</li>
        </ol>
      </div>
    </section>
  </div>

  <script>
    // Interactive Hash Table (Separate Chaining) - Vanilla JS implementation
    (function(){
      // Configuration & state
      const state = {
        size: 8,
        buckets: [], // array of arrays (chains), newest inserted at top (unshift)
        load: 0
      };

      // Elements
      const keyInput = document.getElementById('key-input');
      const tableSizeInput = document.getElementById('table-size');
      const hashSelect = document.getElementById('hash-select');
      const insertBtn = document.getElementById('insert-btn');
      const searchBtn = document.getElementById('search-btn');
      const deleteBtn = document.getElementById('delete-btn');
      const resetBtn = document.getElementById('reset-btn');
      const randomBtn = document.getElementById('random-btn');

      const tableArea = document.getElementById('table-area');
      const status = document.getElementById('status');
      const metricLoad = document.getElementById('metric-load');
      const metricSize = document.getElementById('metric-size');
      const metricCollisions = document.getElementById('metric-collisions');

      // Accessibility: ensure keyboard controls
      keyInput.addEventListener('keyup', (e) => {
        if (e.key === 'Enter') insertBtn.focus();
      });

      // Initialize
      function initTable(size){
        state.size = size;
        state.buckets = Array.from({length:size}, ()=>[]);
        state.load = 0;
        render();
        updateMetrics();
      }
      initTable(state.size);

      // Hash functions
      function hashKey(key){
        const size = state.size;
        const mode = hashSelect.value;
        if (mode === 'numeric' && !isNaN(Number(key))){
          return (Number(key) % size + size) % size;
        }
        if (mode === 'firstchar'){
          const ch = String(key)[0] || '';
          return (ch.charCodeAt(0) || 0) % size;
        }
        // default: ascii sum
        const s = String(key);
        let sum = 0;
        for (let i=0;i<s.length;i++){ sum += s.charCodeAt(i); }
        return sum % size;
      }

      // Rendering buckets
      function render(){
        tableArea.innerHTML = '';
        for (let i=0;i<state.size;i++){
          const bucket = document.createElement('div');
          bucket.className = 'bucket';
          bucket.dataset.index = i;
          bucket.setAttribute('role','group');
          bucket.setAttribute('aria-label','Bucket '+i);

          const idx = document.createElement('div');
          idx.className = 'bucket-index';
          idx.textContent = i;

          const chain = document.createElement('div');
          chain.className = 'chain';
          chain.dataset.index = i;

          // populate nodes (newest on top)
          state.buckets[i].forEach((val, j) => {
            const node = document.createElement('div');
            node.className = 'node small';
            node.setAttribute('tabindex','0');
            node.setAttribute('role','button');
            node.setAttribute('aria-label', 'Key ' + val);
            node.textContent = val;

            const del = document.createElement('button');
            del.className = 'del';
            del.title = 'Delete this key';
            del.textContent = '×';
            del.addEventListener('click', (e)=>{
              e.stopPropagation();
              performDelete(val, i, /*direct*/ true);
            });
            node.appendChild(del);
            chain.appendChild(node);
          });

          bucket.appendChild(idx);
          bucket.appendChild(chain);
          tableArea.appendChild(bucket);
        }
      }

      // Metrics
      function updateMetrics(){
        metricLoad.textContent = 'Load: '+ state.load;
        metricSize.textContent = 'Size: '+ state.size;
        const collisions = state.buckets.reduce((acc, chain) => acc + Math.max(0, chain.length - 1), 0);
        metricCollisions.textContent = 'Collisions: '+ collisions;
      }

      // Utility: create a moving clone to animate from input to target
      function animateMove(text, targetElem, callback){
        // create clone element
        const rectStart = keyInput.getBoundingClientRect();
        const clone = document.createElement('div');
        clone.className = 'node moving-clone';
        clone.style.padding = '10px 12px';
        clone.style.borderRadius = '12px';
        clone.style.background = 'linear-gradient(90deg,#eef2ff,#f1f5f9)';
        clone.style.fontWeight = '700';
        clone.style.left = rectStart.left + 'px';
        clone.style.top = rectStart.top + 'px';
        clone.style.opacity = '1';
        clone.textContent = text;
        document.body.appendChild(clone);

        // compute target position
        const rectEnd = targetElem.getBoundingClientRect();
        const dx = rectEnd.left + rectEnd.width/2 - (rectStart.left + rectStart.width/2);
        const dy = rectEnd.top + rectEnd.height/2 - (rectStart.top + rectStart.height/2);

        // apply translate
        requestAnimationFrame(() => {
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(0.92)`;
          clone.style.transition = 'transform .6s cubic-bezier(.2,.9,.2,1), opacity .2s linear';
        });

        // cleanup after animation
        setTimeout(()=>{
          clone.style.opacity = '0';
          setTimeout(()=>{ try{ document.body.removeChild(clone); }catch(e){}; if (callback) callback(); }, 180);
        }, 650);
      }

      // Helpers to highlight bucket and nodes
      function highlightBucket(idx, duration=800){
        const bucket = tableArea.querySelector(`.bucket[data-index="${idx}"]`);
        if (!bucket) return;
        bucket.classList.add('highlight');
        setTimeout(()=> bucket.classList.remove('highlight'), duration);
      }
      function highlightNode(elem, cls='highlight', duration=500){
        elem.classList.add(cls);
        setTimeout(()=> elem.classList.remove(cls), duration);
      }

      // Insert operation
      function performInsert(key){
        if (key === '') {
          setStatus('Please enter a key to insert.', true);
          return;
        }
        const index = hashKey(key);
        setStatus(`Hashing key -> bucket ${index}. Inserting...`);
        highlightBucket(index, 700);

        // animate movement then update data
        const bucketChainElem = tableArea.querySelector(`.bucket[data-index="${index}"] .chain`);
        animateMove(key, bucketChainElem, ()=>{
          // Prepend item to chain (unshift => newest at top)
          state.buckets[index].unshift(String(key));
          state.load++;
          render();
          updateMetrics();
          setStatus(`Inserted "${key}" into bucket ${index}.`);
        });
      }

      // Search operation: animate traversal through chain
      function performSearch(key){
        if (key === '') {
          setStatus('Please enter a key to search.', true);
          return;
        }
        const index = hashKey(key);
        setStatus(`Searching bucket ${index}...`);
        highlightBucket(index, 900);
        const chainElems = tableArea.querySelectorAll(`.bucket[data-index="${index}"] .chain .node`);
        if (chainElems.length === 0){
          setTimeout(()=> setStatus(`Bucket ${index} empty. "${key}" not found.`, true), 450);
          return;
        }
        // step through nodes with delay
        let found = false;
        let i = 0;
        function step(){
          if (i >= chainElems.length){
            if (!found) setStatus(`"${key}" not found in bucket ${index}.`, true);
            return;
          }
          const node = chainElems[i];
          highlightNode(node, 'highlight', 600);
          const val = node.firstChild && node.firstChild.nodeValue ? node.firstChild.nodeValue.trim() : node.textContent.trim();
          if (val === String(key)){
            // found
            setTimeout(()=> {
              node.classList.add('found');
              setStatus(`Found "${key}" at bucket ${index}, position ${i}.`);
            }, 300);
            found = true;
            // remove highlight after a bit
            setTimeout(()=> node.classList.remove('found'), 900);
            return;
          }
          i++;
          setTimeout(step, 650);
        }
        setTimeout(step, 200);
      }

      // Delete operation
      function performDelete(key, expectedBucket=null, direct=false){
        if (!direct && key === '') {
          setStatus('Please enter a key to delete.', true);
          return;
        }
        const index = expectedBucket !== null ? expectedBucket : hashKey(key);
        setStatus(`Attempting delete in bucket ${index}...`);
        highlightBucket(index, 700);

        const chain = state.buckets[index];
        // find index of first matching element
        const matchIdx = chain.findIndex(v => v === String(key));
        if (matchIdx === -1){
          // if direct deletion via delete button provided the value (direct true) then key param was already provided
          if (direct){
            // find using provided key param
            const k = key;
            const foundAt = chain.findIndex(v => v === String(k));
            if (foundAt === -1){ setStatus(`"${k}" not found in bucket ${index}.`, true); return; }
          } else {
            setTimeout(()=> setStatus(`"${key}" not found in bucket ${index}.`, true), 300);
            return;
          }
        }

        // animate removal of element DOM node
        const chainElems = tableArea.querySelectorAll(`.bucket[data-index="${index}"] .chain .node`);
        // if direct and called from delete button, key param is specific; recompute position
        let removePos = matchIdx;
        if (direct){
          removePos = chain.findIndex(v => v === String(key));
        }
        const targetNode = chainElems[removePos];
        if (targetNode){
          targetNode.classList.add('removing');
          setTimeout(()=>{
            // remove from state
            const removed = chain.splice(removePos, 1);
            if (removed.length) state.load--;
            render();
            updateMetrics();
            setStatus(`Deleted "${removed[0]}" from bucket ${index}.`);
          }, 420);
        } else {
          // fallback: just update state
          const removed = chain.splice(removePos, 1);
          if (removed.length) state.load--;
          render();
          updateMetrics();
          setStatus(`Deleted "${removed[0]}" from bucket ${index}.`);
        }
      }

      // Set status message
      function setStatus(msg, warn=false){
        status.textContent = msg;
        status.style.color = warn ? 'var(--danger)' : '#0f172a';
      }

      // Reset and random fill
      function resetTable(){
        const newSize = Math.max(2, Math.min(32, Number(tableSizeInput.value) || 8));
        tableSizeInput.value = newSize;
        initTable(newSize);
        setStatus('Table reset.');
      }

      function fillRandom(){
        resetTable();
        const samples = ['apple','banana','pear','cherry','dog','cat','42','84','xyz','alpha','beta','gamma','delta'];
        const count = Math.min(12, Math.floor(state.size * 1.2));
        for (let i=0;i<count;i++){
          const s = samples[Math.floor(Math.random()*samples.length)] + (Math.random() < 0.5 ? '' : Math.floor(Math.random()*100));
          const idx = hashKey(s);
          state.buckets[idx].unshift(s);
          state.load++;
        }
        render();
        updateMetrics();
        setStatus(`Filled with ${count} random keys.`);
      }

      // Event listeners
      insertBtn.addEventListener('click', ()=>{
        const key = keyInput.value.trim();
        performInsert(key);
      });

      searchBtn.addEventListener('click', ()=>{
        const key = keyInput.value.trim();
        performSearch(key);
      });

      deleteBtn.addEventListener('click', ()=>{
        const key = keyInput.value.trim();
        performDelete(key);
      });

      resetBtn.addEventListener('click', resetTable);
      randomBtn.addEventListener('click', fillRandom);

      tableSizeInput.addEventListener('change', ()=>{
        const v = Number(tableSizeInput.value);
        if (isNaN(v) || v < 2 || v > 32){
          setStatus('Table size must be between 2 and 32.', true);
          tableSizeInput.value = state.size;
          return;
        }
        // Changing size resets table to avoid complex rehash operations (teaching simplification)
        initTable(v);
        setStatus('Table size changed — table reset.');
      });

      // Keyboard accessibility for table nodes (Enter to delete)
      tableArea.addEventListener('keydown', (e)=>{
        const target = e.target;
        if (e.key === 'Enter' && target.classList.contains('node')){
          const text = (target.firstChild && target.firstChild.nodeValue) ? target.firstChild.nodeValue.trim() : target.textContent.trim();
          performDelete(text, Number(target.closest('.bucket').dataset.index), true);
        }
      });

      // Initial sample
      fillRandom();

      // Expose for debugging (optional)
      window.__ht_state = state;
    })();
  </script>
</body>
</html>