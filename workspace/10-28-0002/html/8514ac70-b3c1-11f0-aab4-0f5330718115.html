<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Binary Tree</title>
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
      margin: 24px;
      line-height: 1.55;
    }
    h1 {
      margin: 0 0 8px;
      font-size: 28px;
    }
    p {
      margin: 0 0 12px;
      color: #333;
    }
    #controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin: 12px 0 20px;
    }
    input[type="number"] {
      width: 140px;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: #fff;
    }
    button {
      padding: 6px 12px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: #f7f7f7;
      cursor: pointer;
    }
    button:hover {
      background: #eee;
    }
    svg#svg {
      width: 100%;
      height: 420px;
      border: 1px solid #eee;
      background: #fafafa;
      border-radius: 8px;
    }
    .edge {
      stroke: #888;
      stroke-width: 1.2;
    }
    .node {
      fill: #fff;
      stroke: #333;
      stroke-width: 1.2;
    }
    .label {
      font-size: 12px;
      text-anchor: middle;
      dominant-baseline: middle;
      fill: #111;
    }
    #traversals {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }
    .card {
      border: 1px solid #eee;
      border-radius: 8px;
      padding: 12px;
      background: #fff;
    }
    .code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: #f6f6f6;
      padding: 8px;
      border-radius: 6px;
      min-height: 28px;
    }
    footer {
      margin-top: 20px;
      color: #666;
      font-size: 0.92em;
    }
    @media (prefers-color-scheme: dark) {
      body { color: #eaeaea; }
      p { color: #cfcfcf; }
      input[type="number"], button { border-color: #444; background: #2b2b2b; color: #eaeaea; }
      button:hover { background: #3a3a3a; }
      svg#svg { border-color: #444; background: #1f1f1f; }
      .node { fill: #262626; stroke: #bbb; }
      .edge { stroke: #888; }
      .label { fill: #eaeaea; }
      .card { background: #222; border-color: #444; }
      .code { background: #1c1c1c; }
      footer { color: #aaa; }
    }
  </style>
</head>
<body>
  <h1>Binary Tree</h1>
  <p>A binary tree is a hierarchical data structure in which each node has at most two children: left and right. A Binary Search Tree (BST) keeps values ordered so that all values in the left subtree are less than the node, and all values in the right subtree are greater.</p>

  <div id="controls">
    <input id="value" type="number" placeholder="Insert value" />
    <button id="insertBtn">Insert</button>
    <button id="randomBtn">Insert random</button>
    <button id="sampleBtn">Load sample</button>
    <button id="resetBtn">Reset</button>
  </div>

  <svg id="svg" viewBox="0 0 1000 400" preserveAspectRatio="xMidYMid meet"></svg>

  <div id="traversals">
    <div class="card">
      <strong>In-order</strong>
      <div id="inorder" class="code"></div>
    </div>
    <div class="card">
      <strong>Pre-order</strong>
      <div id="preorder" class="code"></div>
    </div>
    <div class="card">
      <strong>Post-order</strong>
      <div id="postorder" class="code"></div>
    </div>
    <div class="card">
      <strong>Level-order</strong>
      <div id="levelorder" class="code"></div>
    </div>
  </div>

  <footer>Tip: Try inserting numbers and observe how the BST layout and traversals change. Duplicates go to the right subtree.</footer>

  <script>
    class Node {
      constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        this.x = 0;
        this.y = 0;
      }
    }
    class BST {
      constructor() {
        this.root = null;
        this.size = 0;
      }
      insert(value) {
        if (value === null || Number.isNaN(value)) return false;
        if (!this.root) {
          this.root = new Node(value);
          this.size++;
          return true;
        }
        let curr = this.root;
        while (true) {
          if (value < curr.value) {
            if (curr.left) curr = curr.left;
            else { curr.left = new Node(value); this.size++; return true; }
          } else {
            if (curr.right) curr = curr.right;
            else { curr.right = new Node(value); this.size++; return true; }
          }
        }
      }
    }

    const state = { bst: new BST() };
    const svg = document.getElementById('svg');

    function clearSVG() {
      while (svg.firstChild) svg.removeChild(svg.firstChild);
    }

    function layout() {
      const root = state.bst.root;
      if (!root) return;
      const vSpacing = 80;
      const hSpacing = 70;
      const margin = 30;
      let index = 0;
      function inorderAssign(node, depth) {
        if (!node) return;
        inorderAssign(node.left, depth + 1);
        node.x = margin + index * hSpacing;
        node.y = margin + depth * vSpacing;
        index++;
        inorderAssign(node.right, depth + 1);
      }
      inorderAssign(root, 0);
    }

    function render() {
      clearSVG();
      const root = state.bst.root;
      if (!root) {
        const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        txt.setAttribute('x', 16);
        txt.setAttribute('y', 28);
        txt.textContent = 'Tree is empty. Insert values to build a BST.';
        svg.appendChild(txt);
        updateTraversals();
        return;
      }
      layout();
      function drawEdges(node) {
        if (!node) return;
        if (node.left) {
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', node.x);
          line.setAttribute('y1', node.y);
          line.setAttribute('x2', node.left.x);
          line.setAttribute('y2', node.left.y);
          line.setAttribute('class', 'edge');
          svg.appendChild(line);
        }
        if (node.right) {
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', node.x);
          line.setAttribute('y1', node.y);
          line.setAttribute('x2', node.right.x);
          line.setAttribute('y2', node.right.y);
          line.setAttribute('class', 'edge');
          svg.appendChild(line);
        }
        drawEdges(node.left);
        drawEdges(node.right);
      }
      drawEdges(root);

      function drawNodes(node) {
        if (!node) return;
        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');

        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', node.x);
        circle.setAttribute('cy', node.y);
        circle.setAttribute('r', 16);
        circle.setAttribute('class', 'node');

        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', node.x);
        label.setAttribute('y', node.y + 1);
        label.setAttribute('class', 'label');
        label.textContent = node.value;

        group.appendChild(circle);
        group.appendChild(label);
        svg.appendChild(group);

        drawNodes(node.left);
        drawNodes(node.right);
      }
      drawNodes(root);
      updateTraversals();
    }

    function traverse() {
      const root = state.bst.root;
      const inorder = [];
      const preorder = [];
      const postorder = [];
      const levelorder = [];

      function inOrder(node) { if (!node) return; inOrder(node.left); inorder.push(node.value); inOrder(node.right); }
      function preOrder(node) { if (!node) return; preorder.push(node.value); preOrder(node.left); preOrder(node.right); }
      function postOrder(node) { if (!node) return; postOrder(node.left); postOrder(node.right); postorder.push(node.value); }
      function levelOrder(node) {
        if (!node) return;
        const q = [node];
        while (q.length) {
          const n = q.shift();
          levelorder.push(n.value);
          if (n.left) q.push(n.left);
          if (n.right) q.push(n.right);
        }
      }

      inOrder(root);
      preOrder(root);
      postOrder(root);
      levelOrder(root);
      return { inorder, preorder, postorder, levelorder };
    }

    function updateTraversals() {
      const t = traverse();
      document.getElementById('inorder').textContent = t.inorder.join(' ');
      document.getElementById('preorder').textContent = t.preorder.join(' ');
      document.getElementById('postorder').textContent = t.postorder.join(' ');
      document.getElementById('levelorder').textContent = t.levelorder.join(' ');
    }

    function insertFromInput() {
      const input = document.getElementById('value');
      const val = Number(input.value);
      if (!Number.isFinite(val)) return;
      state.bst.insert(val);
      input.value = '';
      render();
    }
    function insertRandom() {
      const val = Math.floor(Math.random() * 100);
      state.bst.insert(val);
      render();
    }
    function reset() {
      state.bst = new BST();
      render();
    }
    function sample() {
      reset();
      [8, 3, 10, 1, 6, 14, 4, 7, 13].forEach(v => state.bst.insert(v));
      render();
    }

    document.getElementById('insertBtn').addEventListener('click', insertFromInput);
    document.getElementById('randomBtn').addEventListener('click', insertRandom);
    document.getElementById('resetBtn').addEventListener('click', reset);
    document.getElementById('sampleBtn').addEventListener('click', sample);
    document.getElementById('value').addEventListener('keydown', e => { if (e.key === 'Enter') insertFromInput(); });

    render();
  </script>
</body>
</html>