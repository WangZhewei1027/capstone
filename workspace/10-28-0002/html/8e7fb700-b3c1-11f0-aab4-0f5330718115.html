<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Binary Search Tree (BST) - Simple Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --card: #111827;
      --muted: #94a3b8;
      --text: #e5e7eb;
      --accent: #22c55e;
      --warn: #f59e0b;
      --danger: #ef4444;
      --node: #1f2937;
      --node-border: #334155;
      --found: #16a34a;
      --empty: #475569;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: linear-gradient(180deg, #0b1025, #0f172a 40%);
      color: var(--text);
      line-height: 1.5;
      padding: 24px;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
    }
    header h1 {
      margin: 0 0 8px 0;
      font-size: 28px;
    }
    header p {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }
    .card {
      background: rgba(17,24,39,0.8);
      border: 1px solid #1f2937;
      border-radius: 12px;
      padding: 16px;
      margin-top: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.02);
      backdrop-filter: blur(4px);
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 8px;
      align-items: end;
    }
    .controls .field {
      grid-column: span 4;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .controls .field.full { grid-column: span 12; }
    label {
      font-size: 12px;
      color: var(--muted);
    }
    input[type="number"], input[type="text"] {
      background: #0b1220;
      color: var(--text);
      border: 1px solid #1f2937;
      border-radius: 8px;
      padding: 10px 12px;
      outline: none;
    }
    input::placeholder { color: #64748b; }
    .buttons {
      grid-column: span 12;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
    }
    button {
      background: #0b1220;
      color: var(--text);
      border: 1px solid #1f2937;
      padding: 10px 14px;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.05s ease, background 0.2s ease, border-color 0.2s ease;
    }
    button:hover { background: #0e1628; border-color: #263244; }
    button:active { transform: translateY(1px); }
    button.primary { background: #122038; border-color: #1f3b63; }
    button.accent { background: rgba(34,197,94,0.1); border-color: rgba(34,197,94,0.35); color: #86efac; }
    button.warn { background: rgba(245,158,11,0.07); border-color: rgba(245,158,11,0.35); color: #fbbf24; }
    button.danger { background: rgba(239,68,68,0.08); border-color: rgba(239,68,68,0.4); color: #fecaca; }
    .status {
      margin-top: 8px;
      font-size: 14px;
      color: var(--muted);
      min-height: 20px;
    }
    .status .ok { color: #86efac; }
    .status .warn { color: #fde68a; }
    .status .err { color: #fecaca; }

    .layout {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    @media (min-width: 900px) {
      .layout {
        grid-template-columns: 1.2fr 0.8fr;
      }
    }

    .tree {
      overflow: auto;
      padding: 12px;
      border: 1px dashed #1f2937;
      border-radius: 10px;
      min-height: 140px;
      background: radial-gradient(1200px 300px at 10% 0%, rgba(255,255,255,0.03), transparent 60%);
    }
    /* Tree visuals using nested ULs */
    .tree ul {
      padding-top: 14px;
      position: relative;
      padding-left: 0;
      display: inline-block;
    }
    .tree li {
      list-style-type: none;
      text-align: center;
      position: relative;
      padding: 14px 6px 0 6px;
    }
    .tree li::before, .tree li::after {
      content: '';
      position: absolute;
      top: 0;
      right: 50%;
      border-top: 1px solid #334155;
      width: 50%;
      height: 14px;
    }
    .tree li::after {
      right: auto;
      left: 50%;
      border-left: none;
      border-right: 1px solid #334155;
    }
    .tree li:only-child::after, .tree li:only-child::before {
      display: none;
    }
    .tree li:only-child { padding-top: 0; }
    .tree li:first-child::before, .tree li:last-child::after {
      border: none;
    }
    .tree li:last-child::before {
      border-right: 1px solid #334155;
      border-radius: 0 5px 0 0;
    }
    .tree li:first-child::after {
      border-radius: 5px 0 0 0;
    }
    .node {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 36px;
      height: 36px;
      padding: 0 10px;
      font-weight: 600;
      border-radius: 999px;
      background: linear-gradient(180deg, #0f172a, #0b1220);
      border: 1px solid var(--node-border);
      color: var(--text);
      box-shadow: 0 1px 0 rgba(255,255,255,0.04), inset 0 0 14px rgba(0,0,0,0.35);
    }
    .node.found {
      background: linear-gradient(180deg, rgba(22,163,74,0.25), rgba(22,163,74,0.12));
      border-color: rgba(34,197,94,0.7);
      color: #bbf7d0;
      box-shadow: 0 0 16px rgba(34,197,94,0.25), inset 0 0 14px rgba(16,185,129,0.25);
    }
    .empty {
      color: var(--empty);
      font-style: italic;
      padding: 2px 6px;
    }
    .children {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 16px;
      margin-top: 8px;
    }
    .label {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .traversals {
      display: grid;
      gap: 10px;
    }
    .traversals .tray {
      background: #0b1220;
      border: 1px solid #1f2937;
      border-radius: 10px;
      padding: 10px 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      color: #cbd5e1;
      overflow-x: auto;
      white-space: nowrap;
    }
    .traversals h3 {
      margin: 0 0 6px 0;
      font-size: 14px;
      color: #c7d2fe;
    }
    .legend {
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
    }

    .about {
      color: var(--muted);
      font-size: 14px;
    }
    .about ul { margin: 6px 0 0 18px; }
    .about li { margin: 2px 0; }
    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: #0b1220;
      border: 1px solid #263244;
      color: #a8c5ff;
      font-size: 12px;
      margin-right: 6px;
    }
    footer {
      margin-top: 18px;
      font-size: 12px;
      color: var(--muted);
      text-align: center;
    }
    .note {
      font-size: 12px;
      color: #9ab5ff;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Binary Search Tree (BST)</h1>
      <p>A simple, interactive BST you can insert into and search. See traversals and structure update live.</p>
    </header>

    <div class="card">
      <div class="controls">
        <div class="field">
          <label for="insertVal">Insert value</label>
          <input id="insertVal" type="number" placeholder="e.g., 8" />
        </div>
        <div class="field">
          <label for="searchVal">Search value</label>
          <input id="searchVal" type="number" placeholder="e.g., 6" />
        </div>
        <div class="buttons">
          <button class="primary" id="btnInsert">Insert</button>
          <button id="btnSearch">Search</button>
          <button class="warn" id="btnSample">Add sample data</button>
          <button class="danger" id="btnClear">Clear tree</button>
        </div>
      </div>
      <div class="status" id="status"></div>
    </div>

    <div class="layout">
      <div class="card">
        <h2 style="margin:0 0 8px 0;">Tree</h2>
        <div id="tree" class="tree" aria-live="polite"></div>
        <div class="note">Tip: Use "Add sample data" to see a non-empty tree quickly.</div>
      </div>

      <div class="card">
        <h2 style="margin:0 0 8px 0;">Traversals</h2>
        <div class="traversals">
          <div>
            <h3>In-order</h3>
            <div id="inorder" class="tray"></div>
          </div>
          <div>
            <h3>Pre-order</h3>
            <div id="preorder" class="tray"></div>
          </div>
          <div>
            <h3>Post-order</h3>
            <div id="postorder" class="tray"></div>
          </div>
          <div>
            <h3>Level-order (BFS)</h3>
            <div id="level" class="tray"></div>
          </div>
        </div>
        <div class="legend">
          <span class="pill">Average O(log n)</span>
          <span class="pill">Worst O(n) if unbalanced</span>
        </div>
      </div>
    </div>

    <div class="card about">
      <h2 style="margin:0 0 8px 0;">What is a BST?</h2>
      <p>A Binary Search Tree is a binary tree where for every node:</p>
      <ul>
        <li>All values in the left subtree are strictly less than the node's value.</li>
        <li>All values in the right subtree are strictly greater than the node's value.</li>
      </ul>
      <p>Common operations and average-time complexities:</p>
      <ul>
        <li>Search: O(log n)</li>
        <li>Insert: O(log n)</li>
        <li>Delete: O(log n)</li>
      </ul>
      <p>Note: Without balancing, a BST can become skewed, degrading operations to O(n).</p>
    </div>

    <footer>
      Built for learning: insert values, search, and inspect traversals.
    </footer>
  </div>

  <script>
    // Simple BST implementation
    let root = null;
    let lastHighlight = null;
    let highlightTimeout = null;

    function createNode(value) {
      return { value, left: null, right: null };
    }

    function insertNode(node, value) {
      if (node === null) return createNode(value);
      if (value === node.value) {
        // ignore duplicates
        return node;
      } else if (value < node.value) {
        node.left = insertNode(node.left, value);
      } else {
        node.right = insertNode(node.right, value);
      }
      return node;
    }

    function searchNode(node, value) {
      let current = node;
      while (current) {
        if (value === current.value) return true;
        current = value < current.value ? current.left : current.right;
      }
      return false;
    }

    function inorder(node, out = []) {
      if (!node) return out;
      inorder(node.left, out);
      out.push(node.value);
      inorder(node.right, out);
      return out;
    }
    function preorder(node, out = []) {
      if (!node) return out;
      out.push(node.value);
      preorder(node.left, out);
      preorder(node.right, out);
      return out;
    }
    function postorder(node, out = []) {
      if (!node) return out;
      postorder(node.left, out);
      postorder(node.right, out);
      out.push(node.value);
      return out;
    }
    function levelOrder(node) {
      const out = [];
      if (!node) return out;
      const q = [node];
      while (q.length) {
        const n = q.shift();
        out.push(n.value);
        if (n.left) q.push(n.left);
        if (n.right) q.push(n.right);
      }
      return out;
    }

    function buildTreeDOM(node, highlightValue) {
      if (!node) {
        const span = document.createElement('span');
        span.className = 'empty';
        span.textContent = '∅';
        return span;
      }
      const ul = document.createElement('ul');
      const li = document.createElement('li');

      const span = document.createElement('span');
      span.className = 'node' + (highlightValue === node.value ? ' found' : '');
      span.textContent = node.value;
      li.appendChild(span);

      const children = document.createElement('div');
      children.className = 'children';

      const leftDiv = document.createElement('div');
      leftDiv.className = 'child';
      const leftLabel = document.createElement('div');
      leftLabel.className = 'label';
      leftLabel.textContent = 'L';
      leftDiv.appendChild(leftLabel);
      leftDiv.appendChild(buildTreeDOM(node.left, highlightValue));

      const rightDiv = document.createElement('div');
      rightDiv.className = 'child';
      const rightLabel = document.createElement('div');
      rightLabel.className = 'label';
      rightLabel.textContent = 'R';
      rightDiv.appendChild(rightLabel);
      rightDiv.appendChild(buildTreeDOM(node.right, highlightValue));

      children.appendChild(leftDiv);
      children.appendChild(rightDiv);
      li.appendChild(children);
      ul.appendChild(li);
      return ul;
    }

    function formatList(arr) {
      return arr.length ? arr.join('  →  ') : '(empty)';
    }

    function updateUI(highlightValue = null) {
      const treeEl = document.getElementById('tree');
      treeEl.innerHTML = '';
      treeEl.appendChild(buildTreeDOM(root, highlightValue));

      document.getElementById('inorder').textContent = formatList(inorder(root, []));
      document.getElementById('preorder').textContent = formatList(preorder(root, []));
      document.getElementById('postorder').textContent = formatList(postorder(root, []));
      document.getElementById('level').textContent = formatList(levelOrder(root));
    }

    function setStatus(msg, cls = '') {
      const el = document.getElementById('status');
      el.className = 'status ' + (cls || '');
      el.textContent = msg;
    }

    // Event handlers
    document.getElementById('btnInsert').addEventListener('click', () => {
      const valStr = document.getElementById('insertVal').value.trim();
      if (valStr === '') {
        setStatus('Enter a value to insert.', 'warn');
        return;
      }
      const val = Number(valStr);
      if (!Number.isFinite(val)) {
        setStatus('Please enter a valid number.', 'err');
        return;
      }
      const exists = searchNode(root, val);
      root = insertNode(root, val);
      updateUI();
      if (exists) {
        setStatus(`Value ${val} already exists (duplicates ignored).`, 'warn');
      } else {
        setStatus(`Inserted ${val}.`, 'ok');
      }
      document.getElementById('insertVal').value = '';
      document.getElementById('insertVal').focus();
    });

    document.getElementById('btnSearch').addEventListener('click', () => {
      const valStr = document.getElementById('searchVal').value.trim();
      if (valStr === '') {
        setStatus('Enter a value to search.', 'warn');
        return;
      }
      const val = Number(valStr);
      if (!Number.isFinite(val)) {
        setStatus('Please enter a valid number.', 'err');
        return;
      }
      const found = searchNode(root, val);
      if (highlightTimeout) clearTimeout(highlightTimeout);
      lastHighlight = found ? val : null;
      updateUI(lastHighlight);
      if (found) {
        setStatus(`Found ${val} in the tree.`, 'ok');
      } else {
        setStatus(`Value ${val} not found.`, 'warn');
      }
      // Clear highlight after a short time for clarity
      highlightTimeout = setTimeout(() => {
        lastHighlight = null;
        updateUI(null);
      }, 1600);
    });

    document.getElementById('btnSample').addEventListener('click', () => {
      const sample = [8, 3, 10, 1, 6, 14, 4, 7, 13];
      sample.forEach(v => { root = insertNode(root, v); });
      updateUI();
      setStatus('Sample data inserted: ' + sample.join(', ') + '.', 'ok');
    });

    document.getElementById('btnClear').addEventListener('click', () => {
      root = null;
      if (highlightTimeout) clearTimeout(highlightTimeout);
      lastHighlight = null;
      updateUI();
      setStatus('Tree cleared.', 'ok');
    });

    // Keyboard helpers
    document.getElementById('insertVal').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') document.getElementById('btnInsert').click();
    });
    document.getElementById('searchVal').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') document.getElementById('btnSearch').click();
    });

    // Initial render
    updateUI();
  </script>
</body>
</html>