<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>K-Nearest Neighbors (KNN) – A Simple Guide</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #0f1220;
      --panel: #171a2c;
      --accent: #6ac1ff;
      --text: #e6e9f5;
      --muted: #9aa3b2;
      --a: #ff6b6b;
      --b: #4dd17d;
      --query: #ffd66b;
      --neighbor: #b48bff;
      --border: #29304a;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 20% 10%, #12152a 0%, #0f1220 55%, #0b0e1a 100%);
      color: var(--text);
      font: 15px/1.55 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    header {
      padding: 28px 22px 8px;
    }
    h1 {
      margin: 0 0 6px;
      font-size: 26px;
      letter-spacing: 0.2px;
    }
    header p {
      margin: 0;
      color: var(--muted);
    }
    main {
      display: grid;
      grid-template-columns: minmax(280px, 520px) minmax(260px, 1fr);
      gap: 18px;
      padding: 18px 22px 28px;
    }
    section, .panel {
      background: linear-gradient(180deg, #171a2c 0%, #13162a 100%);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px 14px 6px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    h2 {
      margin: 2px 0 8px;
      font-size: 18px;
    }
    ul { margin: 8px 0 10px; padding-left: 18px; }
    li { margin: 6px 0; }
    code, pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: #111425;
      color: #dbe0ff;
      border: 1px solid #262c44;
      border-radius: 10px;
    }
    pre {
      padding: 10px 12px;
      overflow: auto;
      max-height: 280px;
    }
    code.inline { padding: 2px 6px; border-radius: 6px; }
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin: 8px 0 12px;
    }
    .control {
      background: #13162a;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
    }
    .control label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--muted);
      font-size: 13px;
    }
    input[type="range"] { width: 100%; }
    select, input[type="number"], input[type="checkbox"] {
      width: 100%;
      background: #0f1326;
      color: var(--text);
      border: 1px solid #2a3151;
      border-radius: 8px;
      padding: 8px;
    }
    .checkbox-wrap {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .btn-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin: 6px 0 8px;
    }
    button {
      background: #1b2140;
      color: var(--text);
      border: 1px solid #2a3151;
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
    }
    button:hover { border-color: #3b466e; }
    .legend {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      font-size: 13px;
      color: var(--muted);
      margin: 8px 0 12px;
    }
    .dot {
      width: 14px; height: 14px; border-radius: 50%;
      display: inline-block; margin-right: 6px; border: 2px solid #0b0e1a;
    }
    .legend .a .dot { background: var(--a); }
    .legend .b .dot { background: var(--b); }
    .legend .q .dot { background: var(--query); }
    .legend .n .dot { background: var(--neighbor); }
    .canvas-wrap {
      background: #101328;
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      position: relative;
    }
    canvas { display: block; width: 100%; height: auto; background: #0f1326; }
    .result {
      margin: 10px 0 8px;
      padding: 10px 12px;
      border: 1px dashed #2a3151;
      border-radius: 10px;
      background: #121634;
      color: var(--text);
    }
    .result strong { color: var(--accent); }
    footer {
      padding: 8px 22px 26px;
      color: var(--muted);
      font-size: 13px;
    }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <header>
    <h1>K-Nearest Neighbors (KNN)</h1>
    <p>A simple, intuitive machine learning method for classification and regression using proximity.</p>
  </header>

  <main>
    <section>
      <h2>Overview</h2>
      <ul>
        <li>KNN predicts a label or value for a new point based on the labels/values of its K closest points in the training set.</li>
        <li>It is a lazy learner: no explicit training phase; it stores data and defers computation to query time.</li>
        <li>Works for classification (majority vote) and regression (average or weighted average).</li>
      </ul>

      <h2>How it works</h2>
      <ul>
        <li>Choose a number K (e.g., 3, 5, 7).</li>
        <li>Select a distance metric (e.g., Euclidean, Manhattan, cosine for high-dimensional data).</li>
        <li>Find the K nearest neighbors of the query point.</li>
        <li>Aggregate their labels:
          <ul>
            <li>Classification: majority vote, optionally weighted by distance.</li>
            <li>Regression: mean or distance-weighted mean.</li>
          </ul>
        </li>
      </ul>

      <h2>Distance metrics</h2>
      <ul>
        <li>Euclidean (L2): square root of sum of squared differences.</li>
        <li>Manhattan (L1): sum of absolute differences.</li>
        <li>Cosine similarity: angle between vectors (useful when magnitude matters less than direction).</li>
      </ul>

      <h2>Choosing K</h2>
      <ul>
        <li>Small K: low bias, high variance; sensitive to noise.</li>
        <li>Large K: smoother decision boundary; may blur class boundaries.</li>
        <li>Pick K via cross‑validation; prefer odd K for binary classification to reduce ties.</li>
      </ul>

      <h2>Pros and cons</h2>
      <ul>
        <li>Pros: simple, non-parametric, effective on well-separated data, naturally supports multi-class.</li>
        <li>Cons: slow at query time on large datasets, memory-heavy, sensitive to feature scaling, struggles in high dimensions.</li>
      </ul>

      <h2>Pseudocode</h2>
      <pre><code>// KNN for classification
function knnClassify(points, query, K, metric, weighted=false):
  // points: array of {x, ..., label}
  distances = []
  for each p in points:
    d = metric(p, query)
    distances.append({point: p, d: d})
  sort distances by d ascending
  neighbors = first K of distances
  votes = map label -> 0
  for each n in neighbors:
    w = weighted ? 1 / (n.d + 1e-9) : 1
    votes[n.point.label] += w
  return argmax_label(votes)</code></pre>

      <h2>Python example</h2>
      <pre><code>from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline

# X: features (n_samples x n_features), y: labels
model = make_pipeline(StandardScaler(), KNeighborsClassifier(n_neighbors=5, weights="distance", metric="minkowski", p=2))
model.fit(X_train, y_train)
print("Accuracy:", model.score(X_test, y_test))

# Predict
preds = model.predict(X_test)</code></pre>
    </section>

    <div class="panel">
      <h2>Try KNN (2D demo)</h2>
      <div class="controls">
        <div class="control">
          <label for="k">K neighbors: <span id="kVal">5</span></label>
          <input id="k" type="range" min="1" max="15" value="5">
        </div>
        <div class="control">
          <label for="metric">Distance metric</label>
          <select id="metric">
            <option value="euclidean">Euclidean (L2)</option>
            <option value="manhattan">Manhattan (L1)</option>
          </select>
        </div>
        <div class="control">
          <label>Weights</label>
          <div class="checkbox-wrap">
            <input id="weighted" type="checkbox">
            <span>Weight by inverse distance</span>
          </div>
        </div>
        <div class="control">
          <label>Mode</label>
          <div class="checkbox-wrap">
            <input id="regression" type="checkbox">
            <span>Regression (predict numeric value)</span>
          </div>
        </div>
      </div>

      <div class="legend">
        <span class="a"><span class="dot" aria-hidden="true"></span> Class A</span>
        <span class="b"><span class="dot" aria-hidden="true"></span> Class B</span>
        <span class="q"><span class="dot" aria-hidden="true"></span> Query point</span>
        <span class="n"><span class="dot" aria-hidden="true"></span> Neighbors</span>
      </div>

      <div class="canvas-wrap">
        <canvas id="canvas" width="520" height="360" aria-label="KNN playground canvas"></canvas>
      </div>

      <div class="btn-row">
        <button id="resetQuery">Reset query</button>
        <button id="shuffleData">Shuffle dataset</button>
        <button id="toggleData">Toggle clusters</button>
      </div>

      <div class="result" id="result">Click on the canvas to add a query point. The K nearest neighbors and prediction will appear here.</div>
    </div>
  </main>

  <footer>
    Tips:
    <ul>
      <li>Scale features to avoid one dimension dominating distance.</li>
      <li>Use cross‑validation to choose K and metric.</li>
      <li>Consider approximate nearest neighbors for speed on large datasets.</li>
    </ul>
  </footer>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const kInput = document.getElementById('k');
    const kVal = document.getElementById('kVal');
    const metricSel = document.getElementById('metric');
    const weightedChk = document.getElementById('weighted');
    const regressionChk = document.getElementById('regression');
    const resultEl = document.getElementById('result');
    const resetBtn = document.getElementById('resetQuery');
    const shuffleBtn = document.getElementById('shuffleData');
    const toggleBtn = document.getElementById('toggleData');

    const W = canvas.width;
    const H = canvas.height;
    const PAD = 24;

    let query = null;
    let dataset = [];
    let mode = 0; // 0: twin clusters, 1: intertwined

    function randn(mean=0, std=1) {
      // Box-Muller
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return mean + std * Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    function makeData(mode = 0) {
      const points = [];
      if (mode === 0) {
        // Two Gaussian blobs A and B with slight overlap
        for (let i = 0; i < 50; i++) {
          const x = clamp(PAD + 140 + randn(0, 28), PAD, W - PAD);
          const y = clamp(PAD + 110 + randn(0, 26), PAD, H - PAD);
          points.push({x, y, label: 'A', value: 1});
        }
        for (let i = 0; i < 50; i++) {
          const x = clamp(W - PAD - 140 + randn(0, 28), PAD, W - PAD);
          const y = clamp(H - PAD - 110 + randn(0, 26), PAD, H - PAD);
          points.push({x, y, label: 'B', value: 3});
        }
      } else {
        // Intertwined semicircles (rough approximation)
        for (let i = 0; i < 60; i++) {
          const t = Math.random() * Math.PI;
          const r = 90 + Math.random() * 20;
          const x = W/2 + Math.cos(t) * r + randn(0, 6);
          const y = H/2 + Math.sin(t) * r + randn(0, 6);
          points.push({x, y, label: 'A', value: 1});
        }
        for (let i = 0; i < 60; i++) {
          const t = Math.random() * Math.PI;
          const r = 90 + Math.random() * 20;
          const x = W/2 + Math.cos(t) * r + 70 + randn(0, 6);
          const y = H/2 - Math.sin(t) * r + randn(0, 6);
          points.push({x, y, label: 'B', value: 3});
        }
      }
      return points;
    }

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    function draw() {
      // Background grid
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = "#0f1326";
      ctx.fillRect(0, 0, W, H);
      ctx.strokeStyle = "#1f2542";
      ctx.lineWidth = 1;
      for (let x = PAD; x <= W - PAD; x += 26) {
        ctx.beginPath(); ctx.moveTo(x, PAD); ctx.lineTo(x, H - PAD); ctx.stroke();
      }
      for (let y = PAD; y <= H - PAD; y += 26) {
        ctx.beginPath(); ctx.moveTo(PAD, y); ctx.lineTo(W - PAD, y); ctx.stroke();
      }

      // Points
      for (const p of dataset) {
        drawPoint(p.x, p.y, p.label === 'A' ? getColor('--a') : getColor('--b'), 5, 0.95);
      }

      // Query and neighbors
      if (query) {
        drawPoint(query.x, query.y, getColor('--query'), 6, 1.0, true);
        const res = knn(dataset, query, parseInt(kInput.value, 10), metricSel.value, weightedChk.checked, regressionChk.checked);
        for (const n of res.neighbors) {
          drawLine(query, n.point, getColor('--neighbor'), 1.5, 0.6);
          drawPoint(n.point.x, n.point.y, getColor('--neighbor'), 7, 0.9, true);
        }
        // Decision boundary hint: circle with radius = farthest neighbor distance
        const r = res.neighbors.length ? res.neighbors[res.neighbors.length - 1].d : 0;
        if (r > 0) {
          ctx.beginPath();
          ctx.arc(query.x, query.y, r, 0, Math.PI * 2);
          ctx.strokeStyle = "rgba(180,139,255,0.25)";
          ctx.lineWidth = 1.2;
          ctx.setLineDash([5, 4]);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        updateResult(res);
      } else {
        resultEl.textContent = "Click on the canvas to add a query point. The K nearest neighbors and prediction will appear here.";
      }
    }

    function drawPoint(x, y, color, radius = 5, alpha = 1.0, ring = false) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      if (ring) {
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#0b0e1a";
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawLine(a, b, color, width = 1, alpha = 1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.stroke();
      ctx.restore();
    }

    function getColor(varName) {
      return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    }

    function dist(a, b, metric = 'euclidean') {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      if (metric === 'manhattan') {
        return Math.abs(dx) + Math.abs(dy);
      }
      return Math.sqrt(dx*dx + dy*dy); // euclidean default
    }

    function knn(points, query, K, metric, weighted, regression) {
      const distances = points.map(p => ({ point: p, d: dist(p, query, metric) }));
      distances.sort((a, b) => a.d - b.d);
      const neighbors = distances.slice(0, Math.max(1, K));

      if (regression) {
        // Predict numeric value via mean or weighted mean
        let num = 0, den = 0;
        for (const n of neighbors) {
          const w = weighted ? 1 / (n.d + 1e-9) : 1;
          num += w * n.point.value;
          den += w;
        }
        const predValue = num / Math.max(den, 1e-9);
        return { neighbors, mode: 'regression', value: predValue };
      } else {
        // Classification majority vote or weighted
        const votes = new Map();
        for (const n of neighbors) {
          const label = n.point.label;
          const w = weighted ? 1 / (n.d + 1e-9) : 1;
          votes.set(label, (votes.get(label) || 0) + w);
        }
        let bestLabel = null, bestScore = -Infinity;
        for (const [label, score] of votes.entries()) {
          if (score > bestScore) { bestScore = score; bestLabel = label; }
        }
        return { neighbors, mode: 'classification', label: bestLabel, score: bestScore };
      }
    }

    function updateResult(res) {
      if (res.mode === 'classification') {
        const aCount = res.neighbors.filter(n => n.point.label === 'A').length;
        const bCount = res.neighbors.filter(n => n.point.label === 'B').length;
        const k = res.neighbors.length;
        resultEl.innerHTML =
          `<strong>Classification</strong> → Predicted: <strong>${res.label}</strong> ` +
          `(K=${k}, A=${aCount}, B=${bCount}${weightedChk.checked ? ", weighted" : ""}, metric=${metricSel.value}).`;
      } else {
        resultEl.innerHTML =
          `<strong>Regression</strong> → Predicted value: <strong>${res.value.toFixed(2)}</strong> ` +
          `(K=${res.neighbors.length}${weightedChk.checked ? ", weighted" : ""}, metric=${metricSel.value}).`;
      }
    }

    // Event handlers
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      query = { x, y };
      draw();
    });

    kInput.addEventListener('input', () => {
      kVal.textContent = kInput.value;
      draw();
    });
    metricSel.addEventListener('change', draw);
    weightedChk.addEventListener('change', draw);
    regressionChk.addEventListener('change', draw);

    resetBtn.addEventListener('click', () => { query = null; draw(); });
    shuffleBtn.addEventListener('click', () => {
      // Slight jitter to points
      dataset.forEach(p => {
        p.x = clamp(p.x + randn(0, 4), PAD, W - PAD);
        p.y = clamp(p.y + randn(0, 4), PAD, H - PAD);
      });
      draw();
    });
    toggleBtn.addEventListener('click', () => {
      mode = (mode + 1) % 2;
      dataset = makeData(mode);
      query = null;
      draw();
    });

    // Initialize
    function init() {
      kVal.textContent = kInput.value;
      dataset = makeData(0);
      draw();
    }
    init();
  </script>
</body>
</html>