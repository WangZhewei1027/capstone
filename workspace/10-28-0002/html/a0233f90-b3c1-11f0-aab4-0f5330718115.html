<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Knapsack Problem (0/1) — Simple Explanation and Solver</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      line-height: 1.5;
      margin: 0;
      padding: 0 1rem 4rem;
      max-width: 1000px;
      margin-inline: auto;
    }
    header, section { margin-block: 1.5rem; }
    header h1 { margin-bottom: .25rem; }
    .card {
      border: 1px solid color-mix(in srgb, CanvasText 20%, Canvas 80%);
      border-radius: 10px;
      padding: 1rem;
    }
    .grid {
      display: grid;
      gap: .75rem;
    }
    .grid-2 { grid-template-columns: 1fr 1fr; }
    .muted { color: color-mix(in srgb, CanvasText 60%, Canvas 40%); }
    small.muted { display: block; margin-top: .25rem; }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: .5rem;
    }
    th, td {
      border-bottom: 1px solid color-mix(in srgb, CanvasText 12%, Canvas 88%);
      padding: .5rem;
      text-align: left;
    }
    tbody tr:hover { background: color-mix(in srgb, CanvasText 6%, Canvas 94%); }
    input[type="number"], input[type="text"] {
      width: 100%;
      box-sizing: border-box;
      padding: .4rem .5rem;
      border-radius: 6px;
      border: 1px solid color-mix(in srgb, CanvasText 22%, Canvas 78%);
      background: Field;
      color: FieldText;
    }
    button {
      padding: .5rem .75rem;
      border: 1px solid color-mix(in srgb, CanvasText 22%, Canvas 78%);
      background: color-mix(in srgb, Canvas 92%, CanvasText 8%);
      color: ButtonText;
      border-radius: 8px;
      cursor: pointer;
    }
    button.primary {
      background: #2563eb;
      color: white;
      border-color: #2563eb;
    }
    button.ghost {
      background: transparent;
    }
    .actions {
      display: flex;
      gap: .5rem;
      flex-wrap: wrap;
      align-items: center;
    }
    .badge {
      display: inline-block;
      padding: .15rem .5rem;
      border-radius: 999px;
      background: color-mix(in srgb, CanvasText 10%, Canvas 90%);
      font-size: .8rem;
    }
    details summary { cursor: pointer; }
    pre {
      background: color-mix(in srgb, CanvasText 8%, Canvas 92%);
      padding: .75rem;
      border-radius: 8px;
      overflow: auto;
    }
    .error { color: #b91c1c; }
    .ok { color: #065f46; }
    .out {
      margin-top: .75rem; 
      padding: .75rem;
      border: 1px dashed color-mix(in srgb, CanvasText 25%, Canvas 75%);
      border-radius: 8px;
    }
    .nowrap { white-space: nowrap; }
    @media (max-width: 720px) {
      .grid-2 { grid-template-columns: 1fr; }
      th.nowrap, td.nowrap { white-space: nowrap; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Knapsack Problem</h1>
    <p class="muted">Choose a subset of items with maximum total value that fits within a weight capacity.</p>
  </header>

  <section class="card">
    <h2>Overview</h2>
    <p>
      The 0/1 Knapsack problem is a classic optimization problem:
    </p>
    <ul>
      <li>Input: a set of items, each with a value and a weight, and a capacity W.</li>
      <li>Goal: pick a subset of items so that the total weight ≤ W and the total value is maximized.</li>
      <li>Constraint: each item can be taken at most once (hence “0/1”).</li>
    </ul>
    <p class="muted">
      0/1 Knapsack is NP-hard in general, but it has a pseudo-polynomial time dynamic programming solution when weights are small integers.
    </p>
  </section>

  <section class="card">
    <h2>Try it: 0/1 Knapsack Solver</h2>

    <div class="grid grid-2">
      <div>
        <label for="capacity"><strong>Capacity</strong> (non-negative integer)</label>
        <input id="capacity" type="number" min="0" step="1" value="10" />
        <small class="muted">Tip: keep capacity under a few thousand for instant results.</small>
      </div>
      <div>
        <span class="badge">Variant: 0/1 Knapsack</span>
        <small class="muted">Each item can be used at most once.</small>
      </div>
    </div>

    <div style="margin-top: .75rem;">
      <strong>Items</strong>
      <table id="itemsTable" aria-label="Items table">
        <thead>
          <tr>
            <th style="width: 40%;">Name</th>
            <th class="nowrap" style="width: 20%;">Weight</th>
            <th class="nowrap" style="width: 20%;">Value</th>
            <th style="width: 20%;">Actions</th>
          </tr>
        </thead>
        <tbody id="itemsBody">
          <tr>
            <td><input type="text" value="A" /></td>
            <td><input type="number" min="0" step="1" value="2" /></td>
            <td><input type="number" min="0" step="1" value="3" /></td>
            <td><button class="ghost" onclick="removeRow(this)">Remove</button></td>
          </tr>
          <tr>
            <td><input type="text" value="B" /></td>
            <td><input type="number" min="0" step="1" value="3" /></td>
            <td><input type="number" min="0" step="1" value="4" /></td>
            <td><button class="ghost" onclick="removeRow(this)">Remove</button></td>
          </tr>
          <tr>
            <td><input type="text" value="C" /></td>
            <td><input type="number" min="0" step="1" value="4" /></td>
            <td><input type="number" min="0" step="1" value="8" /></td>
            <td><button class="ghost" onclick="removeRow(this)">Remove</button></td>
          </tr>
          <tr>
            <td><input type="text" value="D" /></td>
            <td><input type="number" min="0" step="1" value="5" /></td>
            <td><input type="number" min="0" step="1" value="8" /></td>
            <td><button class="ghost" onclick="removeRow(this)">Remove</button></td>
          </tr>
          <tr>
            <td><input type="text" value="E" /></td>
            <td><input type="number" min="0" step="1" value="9" /></td>
            <td><input type="number" min="0" step="1" value="10" /></td>
            <td><button class="ghost" onclick="removeRow(this)">Remove</button></td>
          </tr>
        </tbody>
      </table>

      <div class="actions" style="margin-top: .5rem;">
        <button onclick="addRow()">Add item</button>
        <button class="primary" onclick="solve()">Solve</button>
        <button class="ghost" onclick="loadExample()">Load small example</button>
      </div>

      <div id="msg" role="status" class="muted" style="margin-top: .5rem;"></div>

      <div id="output" class="out" aria-live="polite" style="display:none;"></div>
    </div>
  </section>

  <section class="card">
    <h2>How it works (DP idea)</h2>
    <p>
      Let dp[i][w] be the maximum value achievable using the first i items with capacity w. For item i with weight wi and value vi:
    </p>
    <pre><code>// If we skip item i:
dp[i][w] = dp[i-1][w]

// If we take item i (only if wi ≤ w):
dp[i][w] = dp[i-1][w - wi] + vi

// Choose the better of the two:
dp[i][w] = max(dp[i-1][w], dp[i-1][w - wi] + vi)</code></pre>
    <p>
      Time complexity is O(n · W) and space can be optimized to O(W), where n is number of items and W is capacity. This is pseudo-polynomial in W.
    </p>
    <details>
      <summary>Note on variants</summary>
      <ul>
        <li>0/1 Knapsack (this page): each item can be taken at most once.</li>
        <li>Unbounded Knapsack: unlimited copies of each item allowed.</li>
        <li>Fractional Knapsack: items can be split; a greedy strategy by value/weight ratio is optimal.</li>
      </ul>
    </details>
  </section>

  <footer class="muted">
    <p>Built as a simple, self-contained demo page. No external libraries.</p>
  </footer>

  <script>
    function addRow(name = "", weight = "", value = "") {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><input type="text" value="${String(name)}" /></td>
        <td><input type="number" min="0" step="1" value="${String(weight)}" /></td>
        <td><input type="number" min="0" step="1" value="${String(value)}" /></td>
        <td><button class="ghost" onclick="removeRow(this)">Remove</button></td>
      `;
      document.getElementById("itemsBody").appendChild(tr);
    }

    function removeRow(btn) {
      const tbody = document.getElementById("itemsBody");
      if (tbody.children.length <= 1) {
        setMsg("You need at least one item row.", "error");
        return;
      }
      tbody.removeChild(btn.closest("tr"));
    }

    function loadExample() {
      const tbody = document.getElementById("itemsBody");
      tbody.innerHTML = "";
      const items = [
        { name: "Map", weight: 9, value: 150 },
        { name: "Compass", weight: 13, value: 35 },
        { name: "Water", weight: 153, value: 200 },
        { name: "Sandwich", weight: 50, value: 160 },
        { name: "Glucose", weight: 15, value: 60 },
        { name: "Tin", weight: 68, value: 45 },
        { name: "Banana", weight: 27, value: 60 },
        { name: "Apple", weight: 39, value: 40 }
      ];
      // Scaled-down capacity for demo purposes
      document.getElementById("capacity").value = 200;
      items.forEach(it => addRow(it.name, it.weight, it.value));
      setMsg("Loaded a classic example. Press Solve to compute.", "ok");
      document.getElementById("output").style.display = "none";
    }

    function setMsg(text, tone = "muted") {
      const el = document.getElementById("msg");
      el.textContent = text;
      el.className = tone === "error" ? "error" : tone === "ok" ? "ok" : "muted";
    }

    function readItems() {
      const rows = Array.from(document.querySelectorAll("#itemsBody tr"));
      const items = [];
      let errors = [];
      rows.forEach((tr, idx) => {
        const [nameEl, wEl, vEl] = tr.querySelectorAll("input");
        const name = nameEl.value.trim() || `Item ${idx + 1}`;
        const w = Number(wEl.value);
        const v = Number(vEl.value);
        if (!Number.isFinite(w) || !Number.isInteger(w) || w < 0) {
          errors.push(`Row ${idx + 1}: weight must be a non-negative integer.`);
        }
        if (!Number.isFinite(v) || v < 0) {
          errors.push(`Row ${idx + 1}: value must be a non-negative number.`);
        }
        items.push({ name, weight: w, value: v });
      });
      return { items, errors };
    }

    function solve() {
      setMsg("");
      const capEl = document.getElementById("capacity");
      const Wraw = Number(capEl.value);
      if (!Number.isFinite(Wraw) || !Number.isInteger(Wraw) || Wraw < 0) {
        setMsg("Capacity must be a non-negative integer.", "error");
        return;
      }
      const { items, errors } = readItems();
      if (errors.length) {
        setMsg(errors[0], "error");
        return;
      }
      if (items.length === 0) {
        setMsg("Please add at least one item.", "error");
        return;
      }
      if (Wraw > 20000) {
        setMsg("Capacity too large for this demo; try ≤ 20000.", "error");
        return;
      }
      // Filter items with weight 0 and positive value: can only pick at most once.
      // DP will handle weight 0 by allowing inclusion once due to backtracking.
      const result = knapsack01(items, Wraw);
      renderOutput(result);
      const n = items.length;
      const W = Wraw;
      const estCells = (n + 1) * (W + 1);
      const cellNote = estCells > 2_000_000 ? " (large DP solved — this may be slow on very big inputs)" : "";
      setMsg(`Solved 0/1 knapsack for ${n} items and capacity ${W}.${cellNote}`, "ok");
    }

    function knapsack01(items, capacity) {
      const n = items.length;
      const W = capacity;
      // Use two-row DP to reduce memory, but keep separate to reconstruct choices by storing decisions
      // Alternatively, build full dp table for backtracking. For clarity, we’ll build full table.
      const dp = Array.from({ length: n + 1 }, () => new Array(W + 1).fill(0));

      for (let i = 1; i <= n; i++) {
        const wi = items[i - 1].weight;
        const vi = items[i - 1].value;
        for (let w = 0; w <= W; w++) {
          const skip = dp[i - 1][w];
          const take = wi <= w ? dp[i - 1][w - wi] + vi : -Infinity;
          dp[i][w] = skip >= take ? skip : take;
        }
      }

      // Backtrack to find chosen items
      let w = W;
      const chosen = [];
      for (let i = n; i >= 1; i--) {
        if (dp[i][w] !== dp[i - 1][w]) {
          chosen.push(i - 1);
          w = Math.max(0, w - items[i - 1].weight);
        }
      }
      chosen.reverse();

      const totalValue = dp[n][W];
      const totalWeight = chosen.reduce((acc, idx) => acc + items[idx].weight, 0);
      return { items, capacity: W, totalValue, totalWeight, chosenIndexes: chosen };
    }

    function renderOutput(result) {
      const out = document.getElementById("output");
      const { items, capacity, totalValue, totalWeight, chosenIndexes } = result;
      const chosen = chosenIndexes.map(i => items[i]);
      const list = chosen.length
        ? `<ul>${chosen.map((it, i) => `<li>${escapeHtml(it.name)} — weight ${it.weight}, value ${it.value}</li>`).join("")}</ul>`
        : "<p>No items selected.</p>";

      out.innerHTML = `
        <p><strong>Capacity:</strong> ${capacity}</p>
        <p><strong>Total value:</strong> ${totalValue} &nbsp; <strong>Total weight:</strong> ${totalWeight}</p>
        <p><strong>Chosen items (${chosen.length}):</strong></p>
        ${list}
      `;
      out.style.display = "block";
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }
  </script>
</body>
</html>