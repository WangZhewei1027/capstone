<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Weighted Graph</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f7f7fb;
      --fg: #1f2937;
      --muted: #6b7280;
      --accent: #2563eb;
      --edge: #8b8fa3;
      --edge-label: #0f172a;
      --node: #ffffff;
      --node-stroke: #334155;
      --highlight: #ef4444;
      --highlight-node: #fde68a;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0b1220;
        --fg: #e5e7eb;
        --muted: #9ca3af;
        --edge: #5b6176;
        --edge-label: #e5e7eb;
        --node: #0f172a;
        --node-stroke: #94a3b8;
        --highlight: #f87171;
        --highlight-node: #f59e0b55;
      }
    }
    html, body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--fg);
    }
    .wrap {
      max-width: 980px;
      margin: 0 auto;
      padding: 24px;
    }
    header h1 {
      margin: 0 0 8px 0;
      font-size: 28px;
      letter-spacing: 0.2px;
    }
    header p {
      margin: 0 0 16px 0;
      color: var(--muted);
    }
    .panel {
      background: color-mix(in oklab, var(--bg) 92%, black 8%);
      border: 1px solid color-mix(in oklab, var(--bg), black);
      border-radius: 10px;
      padding: 14px 16px;
      margin: 12px 0 18px;
    }
    form.controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 10px;
    }
    .controls label {
      font-size: 14px;
      color: var(--muted);
      margin-right: 4px;
    }
    .controls select, .controls button {
      font-size: 14px;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid color-mix(in oklab, var(--bg), black 30%);
      background: var(--bg);
      color: var(--fg);
    }
    .controls button {
      background: var(--accent);
      color: white;
      border-color: transparent;
      cursor: pointer;
    }
    .controls button.secondary {
      background: transparent;
      color: var(--accent);
      border-color: var(--accent);
    }
    .legend {
      font-size: 13px;
      color: var(--muted);
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
    }
    .legend .swatch {
      display: inline-block;
      width: 16px;
      height: 3px;
      background: var(--edge);
      border-radius: 2px;
      margin-right: 6px;
      vertical-align: middle;
    }
    .legend .swatch.highlight {
      background: var(--highlight);
    }

    svg {
      width: 100%;
      height: auto;
      max-height: 520px;
      display: block;
      border-radius: 12px;
      background: radial-gradient(1200px 600px at 20% 10%, color-mix(in oklab, var(--bg) 85%, black 10%), var(--bg));
      border: 1px solid color-mix(in oklab, var(--bg), black 18%);
    }
    .edge {
      stroke: var(--edge);
      stroke-width: 2.2;
    }
    .edge.highlight {
      stroke: var(--highlight);
      stroke-width: 4;
    }
    .weight {
      font-size: 12px;
      fill: var(--edge-label);
      user-select: none;
      pointer-events: none;
      paint-order: stroke;
      stroke: color-mix(in oklab, var(--bg), black 40%);
      stroke-width: 2px;
      stroke-linejoin: round;
    }
    .node {
      fill: var(--node);
      stroke: var(--node-stroke);
      stroke-width: 2;
      cursor: pointer;
    }
    .node.highlight {
      fill: var(--highlight-node);
      stroke: var(--highlight);
      stroke-width: 3;
    }
    .label {
      font-size: 12px;
      fill: var(--fg);
      pointer-events: none;
      user-select: none;
      font-weight: 600;
    }
    .note {
      font-size: 13px;
      color: var(--muted);
      margin-top: 8px;
    }
    .result {
      margin-top: 8px;
      font-size: 14px;
    }
    .result b {
      color: var(--accent);
    }
    .tips {
      font-size: 14px;
      color: var(--muted);
      margin-top: 16px;
    }
    ul {
      margin: 8px 0 0 18px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Weighted Graph</h1>
      <p>A weighted graph is a graph where each edge carries a numeric cost, distance, or capacity. Algorithms like Dijkstra can use these weights to find cheapest paths.</p>
    </header>

    <div class="panel">
      <form class="controls" id="pathForm">
        <div>
          <label for="start">Start</label>
          <select id="start"></select>
        </div>
        <div>
          <label for="end">End</label>
          <select id="end"></select>
        </div>
        <button type="submit">Find shortest path</button>
        <button type="button" class="secondary" id="resetBtn">Reset</button>
      </form>
      <div class="legend">
        <span><span class="swatch"></span>Edge (weight)</span>
        <span><span class="swatch highlight"></span>Shortest path</span>
      </div>
      <div class="result" id="result"></div>
      <div class="note">Tip: You can also click two nodes to set Start and End quickly.</div>
    </div>

    <svg id="graph" viewBox="0 0 400 300" aria-label="Weighted graph with six nodes">
      <g id="edges"></g>
      <g id="weights"></g>
      <g id="nodes"></g>
      <g id="labels"></g>
    </svg>

    <div class="panel">
      <h3 style="margin:0 0 8px 0;font-size:18px;">What to know</h3>
      <ul>
        <li>Edges have weights (numbers) that represent cost, distance, or time.</li>
        <li>Shortest paths minimize the sum of weights, not necessarily the number of edges.</li>
        <li>Dijkstra’s algorithm works when all weights are non‑negative.</li>
      </ul>
      <div class="tips">Example uses: road maps (distances), network routing (latency), project planning (costs).</div>
    </div>
  </div>

  <script>
    (function () {
      const nodes = [
        { id: "A", x: 60,  y: 80 },
        { id: "B", x: 220, y: 60 },
        { id: "C", x: 140, y: 140 },
        { id: "D", x: 280, y: 160 },
        { id: "E", x: 120, y: 240 },
        { id: "F", x: 320, y: 240 }
      ];

      // Undirected weighted edges
      const edges = [
        ["A", "B", 4],
        ["A", "C", 2],
        ["B", "C", 1],
        ["B", "D", 5],
        ["C", "D", 8],
        ["C", "E", 10],
        ["D", "E", 2],
        ["D", "F", 6],
        ["E", "F", 3]
      ];

      // DOM elements
      const svg = document.getElementById("graph");
      const gEdges = document.getElementById("edges");
      const gWeights = document.getElementById("weights");
      const gNodes = document.getElementById("nodes");
      const gLabels = document.getElementById("labels");
      const startSel = document.getElementById("start");
      const endSel = document.getElementById("end");
      const resultEl = document.getElementById("result");
      const resetBtn = document.getElementById("resetBtn");
      const form = document.getElementById("pathForm");

      // Build maps
      const nodeById = new Map(nodes.map(n => [n.id, n]));
      const adjacency = {};
      const edgeLineById = new Map();
      const nodeCircleById = new Map();

      nodes.forEach(n => adjacency[n.id] = []);

      edges.forEach(([u, v, w]) => {
        adjacency[u].push({ to: v, weight: w });
        adjacency[v].push({ to: u, weight: w });
      });

      function eid(a, b) {
        return "edge-" + [a, b].sort().join("-");
      }

      function createEdge(u, v, w) {
        const a = nodeById.get(u);
        const b = nodeById.get(v);
        const id = eid(u, v);

        // Line
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", a.x);
        line.setAttribute("y1", a.y);
        line.setAttribute("x2", b.x);
        line.setAttribute("y2", b.y);
        line.setAttribute("class", "edge");
        line.setAttribute("id", id);
        gEdges.appendChild(line);
        edgeLineById.set(id, line);

        // Weight label at midpoint
        const mx = (a.x + b.x) / 2;
        const my = (a.y + b.y) / 2;

        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", mx);
        text.setAttribute("y", my - 4); // slight offset
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("class", "weight");
        text.textContent = String(w);
        gWeights.appendChild(text);
      }

      function createNode(n) {
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", n.x);
        circle.setAttribute("cy", n.y);
        circle.setAttribute("r", 14);
        circle.setAttribute("class", "node");
        circle.setAttribute("data-id", n.id);
        gNodes.appendChild(circle);
        nodeCircleById.set(n.id, circle);

        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("x", n.x);
        label.setAttribute("y", n.y + 4);
        label.setAttribute("text-anchor", "middle");
        label.setAttribute("class", "label");
        label.textContent = n.id;
        gLabels.appendChild(label);

        // Clicking a node helps fill the Start and End fields
        circle.addEventListener("click", () => {
          // if start not set or both set, set start; else set end
          const s = startSel.value;
          const e = endSel.value;
          if (!s || s === e) {
            startSel.value = n.id;
          } else {
            endSel.value = n.id;
          }
          // If both are selected and different, attempt a path find
          if (startSel.value && endSel.value && startSel.value !== endSel.value) {
            findAndHighlightPath();
          }
        });
      }

      function populateSelects() {
        const opts = nodes.map(n => `<option value="${n.id}">${n.id}</option>`).join("");
        startSel.innerHTML = `<option value="" selected disabled>Pick</option>${opts}`;
        endSel.innerHTML = `<option value="" selected disabled>Pick</option>${opts}`;
      }

      function render() {
        // Edges
        edges.forEach(([u, v, w]) => createEdge(u, v, w));
        // Nodes
        nodes.forEach(createNode);
        // Selects
        populateSelects();
      }

      function clearHighlights() {
        // Edges
        edgeLineById.forEach(line => line.classList.remove("highlight"));
        // Nodes
        nodeCircleById.forEach(c => c.classList.remove("highlight"));
      }

      function highlightPath(path) {
        clearHighlights();
        for (let i = 0; i < path.length - 1; i++) {
          const a = path[i], b = path[i + 1];
          const line = edgeLineById.get(eid(a, b));
          if (line) line.classList.add("highlight");
        }
        path.forEach(id => {
          const nodeEl = nodeCircleById.get(id);
          if (nodeEl) nodeEl.classList.add("highlight");
        });
      }

      function dijkstra(start, goal) {
        // Initialize
        const dist = {};
        const prev = {};
        const unvisited = new Set(Object.keys(adjacency));

        for (const v of unvisited) {
          dist[v] = Infinity;
          prev[v] = null;
        }
        dist[start] = 0;

        while (unvisited.size) {
          // Get node with smallest distance
          let u = null, best = Infinity;
          for (const v of unvisited) {
            if (dist[v] < best) {
              best = dist[v];
              u = v;
            }
          }
          if (u === null || best === Infinity) break; // disconnected
          unvisited.delete(u);

          if (u === goal) break;

          for (const nb of adjacency[u]) {
            if (!unvisited.has(nb.to)) continue;
            const alt = dist[u] + nb.weight;
            if (alt < dist[nb.to]) {
              dist[nb.to] = alt;
              prev[nb.to] = u;
            }
          }
        }

        // Reconstruct path
        if (dist[goal] === Infinity) return { distance: Infinity, path: [] };
        const path = [];
        let cur = goal;
        while (cur) {
          path.unshift(cur);
          cur = prev[cur];
        }
        return { distance: dist[goal], path };
      }

      function findAndHighlightPath() {
        const start = startSel.value;
        const end = endSel.value;

        if (!start || !end) {
          resultEl.textContent = "Pick both Start and End nodes.";
          return;
        }
        if (start === end) {
          clearHighlights();
          nodeCircleById.get(start)?.classList.add("highlight");
          resultEl.textContent = "Start and End are the same. Distance is 0.";
          return;
        }

        const { distance, path } = dijkstra(start, end);
        if (!path.length || distance === Infinity) {
          clearHighlights();
          resultEl.textContent = "No path found.";
          return;
        }

        highlightPath(path);
        resultEl.innerHTML = `Shortest path: <b>${path.join(" → ")}</b> (total weight: <b>${distance}</b>)`;
      }

      // Events
      form.addEventListener("submit", (e) => {
        e.preventDefault();
        findAndHighlightPath();
      });

      resetBtn.addEventListener("click", () => {
        clearHighlights();
        populateSelects();
        resultEl.textContent = "";
      });

      // Kick off
      render();
    })();
  </script>
</body>
</html>