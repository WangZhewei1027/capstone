<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Deque (Double-Ended Queue) — Simple Demo</title>
  <style>
    :root {
      --bg: #ffffff;
      --fg: #1f2937;
      --muted: #6b7280;
      --accent: #2563eb;
      --accent-2: #10b981;
      --warn: #ef4444;
      --border: #e5e7eb;
      --chip-bg: #f3f4f6;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--fg);
      background: var(--bg);
      line-height: 1.5;
    }
    header, main, footer {
      max-width: 900px;
      margin: 0 auto;
      padding: 16px;
    }
    header h1 {
      margin: 12px 0 4px;
      font-size: 1.6rem;
    }
    header p {
      margin: 0;
      color: var(--muted);
    }
    .card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      background: #fff;
      margin: 16px 0;
    }
    .controls {
      display: grid;
      gap: 10px;
      grid-template-columns: 1fr;
    }
    @media (min-width: 640px) {
      .controls {
        grid-template-columns: 1fr auto auto auto auto auto;
        align-items: end;
      }
    }
    label {
      display: block;
      font-size: 0.9rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    input[type="text"] {
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 1rem;
      width: 100%;
    }
    .btn {
      padding: 10px 12px;
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.95rem;
      transition: background 0.15s ease, transform 0.02s ease;
      white-space: nowrap;
    }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
    .btn.secondary { background: var(--accent-2); color: #fff; border-color: var(--accent-2); }
    .btn.warn { background: var(--warn); color: #fff; border-color: var(--warn); }
    .btn.ghost { background: #fff; color: var(--fg); }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .deque-viewport {
      border: 1px dashed var(--border);
      border-radius: 10px;
      padding: 16px;
      min-height: 64px;
      display: flex;
      align-items: center;
      overflow-x: auto;
      gap: 8px;
      background: #fafafa;
    }
    .node {
      background: var(--chip-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 14px;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .node small {
      font-weight: 400;
      color: var(--muted);
    }
    .ends {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 0.85rem;
      margin-top: 6px;
    }
    .meta {
      display: flex;
      gap: 16px;
      align-items: center;
      color: var(--muted);
      font-size: 0.95rem;
      margin-top: 10px;
    }
    .badge {
      background: #eef2ff;
      color: #3730a3;
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 0.8rem;
    }
    .status {
      margin-top: 8px;
      min-height: 1.2em;
      color: var(--muted);
      font-size: 0.95rem;
    }
    code, pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 8px;
    }
    code {
      padding: 2px 6px;
    }
    pre {
      padding: 12px;
      overflow: auto;
    }
    footer {
      color: var(--muted);
      font-size: 0.9rem;
      text-align: center;
    }
  </style>
</head>
<body>
  <header>
    <h1>Deque (Double-Ended Queue)</h1>
    <p>A deque is a sequence container that supports fast insertion and removal at both the front and the back.</p>
  </header>

  <main>
    <section class="card" aria-labelledby="demo-title">
      <h2 id="demo-title" style="margin-top:0">Interactive demo</h2>
      <div class="controls" role="group" aria-label="Deque controls">
        <div>
          <label for="value-input">Value</label>
          <input id="value-input" type="text" placeholder="Enter a value, then choose where to push (Enter = push right)" />
        </div>
        <button class="btn primary" id="push-left" title="Push to the front (left)">Push Left ⟸</button>
        <button class="btn primary" id="push-right" title="Push to the back (right)">Push Right ⟹</button>
        <button class="btn ghost" id="pop-left" title="Pop from the front (left)">⟸ Pop Left</button>
        <button class="btn ghost" id="pop-right" title="Pop from the back (right)">Pop Right ⟹</button>
        <button class="btn warn" id="clear">Clear</button>
      </div>

      <div class="meta">
        <div>Size: <strong id="size">0</strong></div>
        <div>Front: <span class="badge" id="front">—</span></div>
        <div>Back: <span class="badge" id="back">—</span></div>
      </div>

      <div class="ends" aria-hidden="true">
        <span>Front (Left)</span>
        <span style="flex:1 1 auto; border-bottom:1px dotted var(--border)"></span>
        <span>Back (Right)</span>
      </div>
      <div id="viewport" class="deque-viewport" aria-live="polite" aria-label="Deque contents"></div>

      <div class="status" id="status" aria-live="polite"></div>

      <div class="row" style="margin-top:12px">
        <button class="btn secondary" id="fill-sample">Fill sample</button>
        <button class="btn ghost" id="peek-left">Peek Left</button>
        <button class="btn ghost" id="peek-right">Peek Right</button>
      </div>
    </section>

    <section class="card" aria-labelledby="about-title">
      <h2 id="about-title" style="margin-top:0">What is a Deque?</h2>
      <p>
        A deque (double-ended queue) is a linear collection that allows insertion and removal at both ends.
        It generalizes stacks (LIFO) and queues (FIFO):
      </p>
      <ul>
        <li>push_front(x), push_back(x): insert at the front/back</li>
        <li>pop_front(), pop_back(): remove from the front/back</li>
        <li>front(), back(): read the first/last element</li>
        <li>size(), empty(): query size and emptiness</li>
      </ul>
      <p>Typical use cases include:</p>
      <ul>
        <li>Sliding window problems</li>
        <li>Monotonic queues for O(n) minima/maxima</li>
        <li>BFS (queue behavior) and undo/redo (stack-like ends)</li>
        <li>Caching/paging (LRU variants)</li>
      </ul>
      <p>
        With a circular buffer or linked structure, push/pop at either end are O(1) amortized.
        Many languages provide a built-in deque:
      </p>
      <ul>
        <li>Python: collections.deque</li>
        <li>C++: std::deque</li>
        <li>Java: ArrayDeque / LinkedList (Deque interface)</li>
        <li>JavaScript: typically implemented with arrays or user-built circular buffers</li>
      </ul>
      <p>
        Note: This demo uses a simple array for clarity; left-end operations may be O(n) in JS arrays.
      </p>
    </section>

    <section class="card" aria-labelledby="pseudo-title">
      <h2 id="pseudo-title" style="margin-top:0">Tiny reference</h2>
      <pre aria-label="Pseudocode for deque operations"><code>// Conceptual deque API
push_front(x)  // insert x at the front
push_back(x)   // insert x at the back
pop_front()    // remove and return front element
pop_back()     // remove and return back element
front()        // read front element without removing
back()         // read back element without removing
size()         // number of elements
empty()        // true if size == 0
</code></pre>
    </section>
  </main>

  <footer>
    Built for learning: try pushing/popping from both ends and watch the structure update.
  </footer>

  <script>
    (function () {
      const input = document.getElementById('value-input');
      const pushL = document.getElementById('push-left');
      const pushR = document.getElementById('push-right');
      const popL = document.getElementById('pop-left');
      const popR = document.getElementById('pop-right');
      const clearBtn = document.getElementById('clear');
      const viewport = document.getElementById('viewport');
      const sizeEl = document.getElementById('size');
      const frontEl = document.getElementById('front');
      const backEl = document.getElementById('back');
      const status = document.getElementById('status');
      const fillSample = document.getElementById('fill-sample');
      const peekLeft = document.getElementById('peek-left');
      const peekRight = document.getElementById('peek-right');

      // Internal deque (array-based for demo)
      const dq = [];

      function setStatus(msg, tone = 'neutral') {
        status.textContent = msg || '';
        status.style.color = tone === 'warn' ? 'var(--warn)' : 'var(--muted)';
      }

      function render() {
        // Update chips
        viewport.innerHTML = '';
        dq.forEach((val, i) => {
          const node = document.createElement('div');
          node.className = 'node';
          const idx = document.createElement('small');
          idx.textContent = i;
          const txt = document.createElement('span');
          // Display as plain text to avoid HTML injection
          txt.textContent = String(val);
          node.appendChild(txt);
          node.appendChild(idx);
          viewport.appendChild(node);
        });

        // Meta
        sizeEl.textContent = dq.length;
        frontEl.textContent = dq.length ? String(dq[0]) : '—';
        backEl.textContent = dq.length ? String(dq[dq.length - 1]) : '—';
      }

      function pushLeft(val) {
        dq.unshift(val);
        render();
        setStatus(`Pushed "${val}" to the left.`);
      }

      function pushRight(val) {
        dq.push(val);
        render();
        setStatus(`Pushed "${val}" to the right.`);
      }

      function popLeftFn() {
        if (!dq.length) {
          setStatus('Deque is empty. Nothing to pop from the left.', 'warn');
          return;
        }
        const v = dq.shift();
        render();
        setStatus(`Popped "${v}" from the left.`);
      }

      function popRightFn() {
        if (!dq.length) {
          setStatus('Deque is empty. Nothing to pop from the right.', 'warn');
          return;
        }
        const v = dq.pop();
        render();
        setStatus(`Popped "${v}" from the right.`);
      }

      function getInputValue() {
        return input.value.trim();
      }

      function tryPushLeft() {
        const v = getInputValue();
        if (!v) {
          setStatus('Enter a value before pushing.', 'warn');
          input.focus();
          return;
        }
        pushLeft(v);
        input.value = '';
        input.focus();
      }

      function tryPushRight() {
        const v = getInputValue();
        if (!v) {
          setStatus('Enter a value before pushing.', 'warn');
          input.focus();
          return;
        }
        pushRight(v);
        input.value = '';
        input.focus();
      }

      function clearAll() {
        dq.length = 0;
        render();
        setStatus('Deque cleared.');
      }

      function fillExample() {
        dq.length = 0;
        ['A', 'B', 'C', 'D'].forEach(x => dq.push(x));
        render();
        setStatus('Sample filled: A, B, C, D');
      }

      function peek(dir) {
        if (!dq.length) {
          setStatus('Deque is empty. Nothing to peek.', 'warn');
          return;
        }
        const v = dir === 'left' ? dq[0] : dq[dq.length - 1];
        setStatus(`Peek ${dir}: "${v}"`);
      }

      // Event wiring
      pushL.addEventListener('click', tryPushLeft);
      pushR.addEventListener('click', tryPushRight);
      popL.addEventListener('click', popLeftFn);
      popR.addEventListener('click', popRightFn);
      clearBtn.addEventListener('click', clearAll);
      fillSample.addEventListener('click', fillExample);
      peekLeft.addEventListener('click', () => peek('left'));
      peekRight.addEventListener('click', () => peek('right'));

      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          tryPushRight();
        }
      });

      // Initial render
      render();
      setStatus('Ready. Type a value and push left/right.');
    })();
  </script>
</body>
</html>