<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Red-Black Tree</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; line-height: 1.6; margin: 2rem; color: #222; }
    h1 { margin-bottom: 0.25rem; }
    .subtitle { color: #555; margin-top: 0; }
    .section { margin-top: 1.5rem; }
    ul { padding-left: 1.25rem; }
    .diagram { margin-top: 1rem; }
    svg { max-width: 460px; width: 100%; height: auto; }
    .node { stroke: #333; stroke-width: 1; }
    .label { font-size: 12px; fill: #fff; text-anchor: middle; dominant-baseline: middle; }
    .edge { stroke: #888; stroke-width: 1.25; }
    .legend { display: flex; gap: 1rem; align-items: center; margin-top: 0.5rem; }
    .dot { width: 14px; height: 14px; border-radius: 50%; display: inline-block; border: 1px solid #333; }
    .dot.red { background: #d9534f; }
    .dot.black { background: #111; }
    footer { margin-top: 2rem; color: #666; font-size: 0.9rem; }
  </style>
</head>
<body>
  <h1>Red-Black Tree</h1>
  <p class="subtitle">A self-balancing binary search tree with guaranteed logarithmic time for search, insert, and delete.</p>

  <div class="section">
    <h2>Key properties</h2>
    <ul>
      <li>Each node is either red or black.</li>
      <li>The root is black.</li>
      <li>All leaves (NIL or sentinel nodes) are black.</li>
      <li>No red node has a red parent (no two reds in a row).</li>
      <li>Every path from a node to its descendant NIL leaves contains the same number of black nodes (black height).</li>
    </ul>
  </div>

  <div class="section">
    <h2>Why it stays balanced</h2>
    <p>These constraints ensure the longest path is at most twice the shortest path, keeping height O(log n) and operations efficient.</p>
  </div>

  <div class="section">
    <h2>Operations and complexity</h2>
    <ul>
      <li>Search: O(log n)</li>
      <li>Insert: O(log n) with at most two rotations plus recoloring to fix violations</li>
      <li>Delete: O(log n) with fix-up steps to restore properties (may propagate a “double black”)</li>
      <li>Space: O(n)</li>
    </ul>
  </div>

  <div class="section">
    <h2>Rotations</h2>
    <p>Rotations locally restructure the tree while preserving in-order sequence:</p>
    <ul>
      <li><strong>Left rotation</strong>: moves a node down-left, its right child up.</li>
      <li><strong>Right rotation</strong>: symmetric to left rotation.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Small example</h2>
    <p>The diagram below shows a valid Red-Black Tree after inserting 10, 5, 15, 2, 7:</p>
    <div class="diagram">
      <svg viewBox="0 0 460 220" aria-label="Red-Black Tree example">
        <!-- Edges -->
        <line class="edge" x1="230" y1="40" x2="130" y2="100"></line>
        <line class="edge" x1="230" y1="40" x2="330" y2="100"></line>
        <line class="edge" x1="130" y1="100" x2="80" y2="160"></line>
        <line class="edge" x1="130" y1="100" x2="180" y2="160"></line>
        <!-- Nodes -->
        <circle class="node" cx="230" cy="40" r="18" fill="#111"></circle>
        <text class="label" x="230" y="40">10</text>

        <circle class="node" cx="130" cy="100" r="18" fill="#d9534f"></circle>
        <text class="label" x="130" y="100">5</text>

        <circle class="node" cx="330" cy="100" r="18" fill="#d9534f"></circle>
        <text class="label" x="330" y="100">15</text>

        <circle class="node" cx="80" cy="160" r="18" fill="#111"></circle>
        <text class="label" x="80" y="160">2</text>

        <circle class="node" cx="180" cy="160" r="18" fill="#111"></circle>
        <text class="label" x="180" y="160">7</text>
      </svg>
    </div>
    <div class="legend">
      <span class="dot red" title="Red node"></span> Red node
      <span class="dot black" title="Black node"></span> Black node
    </div>
  </div>

  <div class="section">
    <h2>Typical insert fix-up cases</h2>
    <ul>
      <li>Parent is black: tree remains valid.</li>
      <li>Parent and uncle are red: recolor parent and uncle to black, grandparent to red; continue upwards.</li>
      <li>Parent is red, uncle is black and node is an inner child: rotate to convert to outer case.</li>
      <li>Parent is red, uncle is black and node is an outer child: rotate at grandparent and recolor parent/grandparent.</li>
    </ul>
  </div>

  <div class="section">
    <h2>When to use</h2>
    <ul>
      <li>Ordered maps/sets where worst-case performance matters.</li>
      <li>Language runtimes and standard libraries (e.g., many TreeMap-like implementations).</li>
      <li>Workloads favoring predictable performance over slightly faster average inserts (compared to AVL trees).</li>
    </ul>
  </div>

  <footer>
    <p>Tip: Red-Black Trees trade a bit of strictness for simpler balancing, yielding consistent O(log n) operations.</p>
  </footer>
</body>
</html>