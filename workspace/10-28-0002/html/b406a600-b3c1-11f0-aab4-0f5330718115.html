<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Graph (Directed / Undirected)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-2: #0b1220;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #3b82f6;
      --accent-2: #60a5fa;
      --line: #64748b;
      --line-2: #475569;
      --danger: #ef4444;
      --success: #22c55e;
      --node: #1f2937;
      --node-border: #94a3b8;
      --node-selected: #3b82f6;
      --shadow: rgba(0,0,0,0.35);
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      height: 100%;
      background: radial-gradient(1200px 600px at 20% -10%, #0a1432, #060b1a 55%, #050913),
                  radial-gradient(900px 900px at 120% 110%, #172034 0%, #0b1220 50%, #070b15 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap {
      max-width: 1100px;
      margin: 24px auto;
      padding: 0 16px 24px;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    .title {
      display: flex;
      align-items: baseline;
      gap: 10px;
    }
    .title h1 {
      font-size: 20px;
      margin: 0;
      letter-spacing: 0.2px;
      font-weight: 650;
    }
    .badge {
      font-size: 12px;
      color: var(--muted);
      padding: 2px 8px;
      border-radius: 999px;
      background: linear-gradient(180deg,#0c1629,#0a1220);
      border: 1px solid #1f2937;
    }
    .panel {
      background: linear-gradient(180deg, #0e1626, #0c1322);
      border: 1px solid #1f2a3d;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.03);
      overflow: hidden;
    }
    .controls {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      border-bottom: 1px solid #1f2a3d;
      background: linear-gradient(180deg,#0f192a,#0a1220);
    }
    .segment {
      display: inline-flex;
      background: #0b1220;
      border: 1px solid #1f2a3d;
      border-radius: 10px;
      overflow: hidden;
    }
    .segment label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      font-size: 13px;
      color: var(--muted);
      cursor: pointer;
      user-select: none;
      border-right: 1px solid #1e293b66;
    }
    .segment label:last-child {
      border-right: none;
    }
    .segment input {
      appearance: none;
      width: 14px;
      height: 14px;
      border: 1px solid #334155;
      border-radius: 999px;
      position: relative;
      display: grid;
      place-items: center;
      background: #0c1424;
    }
    .segment input:checked {
      border-color: var(--accent-2);
      background: radial-gradient(circle at 50% 50%, #1b366c, #0c1629);
      box-shadow: 0 0 0 2px rgba(59,130,246,0.25);
    }
    .segment input:checked::after {
      content: "";
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: linear-gradient(180deg,#60a5fa,#3b82f6);
    }
    .btn {
      background: linear-gradient(180deg,#0e1626,#0c1322);
      border: 1px solid #1f2a3d;
      color: var(--text);
      font-size: 13px;
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: 0.15s ease background, 0.15s ease transform, 0.15s ease box-shadow;
    }
    .btn:hover {
      background: linear-gradient(180deg,#111b2d,#0d1426);
      box-shadow: 0 4px 14px rgba(0,0,0,0.28);
    }
    .btn:active {
      transform: translateY(1px);
    }
    .btn.clear { color: #fecaca; border-color: #7f1d1d; background: linear-gradient(180deg,#1a0c0c,#120909); }
    .btn.layout { color: #bbf7d0; border-color: #064e3b; background: linear-gradient(180deg,#0d1a15,#0a1612); }
    .spacer { flex: 1; }
    .stats {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .stats .dot {
      width: 6px; height: 6px; border-radius: 999px; display: inline-block; margin-right: 6px;
      background: #60a5fa;
      box-shadow: 0 0 10px rgba(96,165,250,0.6);
    }
    .canvas-wrap {
      position: relative;
      width: 100%;
      height: 520px;
      background:
        radial-gradient(800px 400px at 20% -10%, rgba(50,100,200,0.06), transparent 60%),
        radial-gradient(700px 360px at 120% 110%, rgba(50,200,150,0.06), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.0));
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 0 0 14px 14px;
    }
    .hint {
      margin-top: 10px;
      font-size: 13px;
      color: var(--muted);
      display: grid;
      gap: 4px;
    }
    .hint code {
      background: #0a1220;
      border: 1px solid #1f2a3d;
      padding: 2px 6px;
      border-radius: 6px;
      color: #d1d5db;
    }
    .footer-note {
      margin-top: 14px;
      font-size: 12px;
      color: #93c5fd;
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Graph (Directed / Undirected)</h1>
        <span class="badge">click-to-build â€¢ drag-to-move</span>
      </div>
    </header>

    <div class="panel">
      <div class="controls">
        <div class="segment" role="tablist" aria-label="Graph type">
          <label for="type-directed" title="Edges have direction (arrows)">
            <input type="radio" name="graph-type" id="type-directed" value="directed" checked />
            Directed
          </label>
          <label for="type-undirected" title="Edges have no direction">
            <input type="radio" name="graph-type" id="type-undirected" value="undirected" />
            Undirected
          </label>
        </div>

        <button class="btn layout" id="layoutCircle" title="Arrange nodes on a circle">
          Layout: Circle
        </button>

        <button class="btn clear" id="clearGraph" title="Remove all nodes and edges">
          Clear
        </button>

        <div class="spacer"></div>
        <div class="stats" aria-live="polite">
          <span><span class="dot"></span><strong id="modeLabel">Directed</strong></span>
          <span>|</span>
          <span>Nodes: <strong id="nodeCount">0</strong></span>
          <span>Edges: <strong id="edgeCount">0</strong></span>
        </div>
      </div>

      <div class="canvas-wrap">
        <canvas id="graphCanvas"></canvas>
      </div>
    </div>

    <div class="hint">
      <div>Instructions:</div>
      <div>- Click empty space to add a node. Click a node, then another to add an edge. In Directed mode, the edge goes from first to second.</div>
      <div>- Drag nodes to reposition. Right-click a node to delete it.</div>
      <div>- Toggle Directed/Undirected to switch how edges are displayed and added.</div>
      <div>- Tip: With a node selected, clicking empty space adds a new node and connects to it.</div>
      <div class="footer-note">Note: Self-loops and multi-edges are not added in this simple demo.</div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('graphCanvas');
      const ctx = canvas.getContext('2d');

      const modeLabel = document.getElementById('modeLabel');
      const nodeCountEl = document.getElementById('nodeCount');
      const edgeCountEl = document.getElementById('edgeCount');
      const typeDirected = document.getElementById('type-directed');
      const typeUndirected = document.getElementById('type-undirected');
      const clearBtn = document.getElementById('clearGraph');
      const layoutBtn = document.getElementById('layoutCircle');

      const state = {
        isDirected: true,
        nodes: [],
        edges: [], // {source: id, target: id}
        nextId: 1,
        nextLabelIndex: 0,
        selectedNodeId: null,
        hoverNodeId: null,
        dragging: null, // {id, offsetX, offsetY}
        isPointerDown: false,
        pointerDownAt: {x:0, y:0},
        pointerMoved: false,
        mouse: {x:0, y:0},
        radius: 18
      };

      // Device Pixel Ratio handling
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const wrap = canvas.parentElement;
        const displayWidth = wrap.clientWidth;
        const displayHeight = wrap.clientHeight;

        canvas.style.width = displayWidth + 'px';
        canvas.style.height = displayHeight + 'px';
        canvas.width = Math.floor(displayWidth * dpr);
        canvas.height = Math.floor(displayHeight * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        draw();
      }
      window.addEventListener('resize', resizeCanvas, {passive:true});
      resizeCanvas();

      // Helpers
      function indexToLabel(n) {
        let x = n + 1;
        let s = '';
        while (x > 0) {
          x--;
          s = String.fromCharCode(65 + (x % 26)) + s;
          x = Math.floor(x / 26);
        }
        return s;
      }

      function getNodeAt(x, y) {
        for (let i = state.nodes.length - 1; i >= 0; i--) {
          const n = state.nodes[i];
          const dx = x - n.x;
          const dy = y - n.y;
          if (dx*dx + dy*dy <= state.radius*state.radius) {
            return n;
          }
        }
        return null;
      }

      function addNode(x, y) {
        const node = {
          id: state.nextId++,
          label: indexToLabel(state.nextLabelIndex++),
          x, y
        };
        state.nodes.push(node);
        updateStats();
        return node;
      }

      function hasEdge(u, v, considerUndirected = false) {
        return state.edges.some(e => (e.source === u && e.target === v) ||
          (considerUndirected && e.source === v && e.target === u));
      }

      function addEdge(u, v) {
        if (u === v) return; // skip self loop in this demo
        const considerUndirected = !state.isDirected;
        if (hasEdge(u, v, considerUndirected)) return;
        state.edges.push({source: u, target: v});
        updateStats();
      }

      function deleteNode(id) {
        state.nodes = state.nodes.filter(n => n.id !== id);
        state.edges = state.edges.filter(e => e.source !== id && e.target !== id);
        if (state.selectedNodeId === id) state.selectedNodeId = null;
        if (state.hoverNodeId === id) state.hoverNodeId = null;
        updateStats();
      }

      function updateStats() {
        nodeCountEl.textContent = state.nodes.length;
        edgeCountEl.textContent = state.edges.length;
      }

      // Drawing
      function draw() {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;

        // Clear
        ctx.clearRect(0, 0, w, h);

        // Draw edges
        for (const e of state.edges) {
          const a = state.nodes.find(n => n.id === e.source);
          const b = state.nodes.find(n => n.id === e.target);
          if (!a || !b) continue;
          if (state.isDirected) {
            drawDirectedEdge(a, b);
          } else {
            drawUndirectedEdge(a, b);
          }
        }

        // Draw preview edge from selected node to mouse
        if (state.selectedNodeId != null) {
          const a = state.nodes.find(n => n.id === state.selectedNodeId);
          if (a) {
            const tmp = {x: state.mouse.x, y: state.mouse.y};
            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.setLineDash([6, 6]);
            if (state.isDirected) {
              drawDirectedEdge(a, tmp, true);
            } else {
              drawUndirectedEdge(a, tmp, true);
            }
            ctx.setLineDash([]);
            ctx.restore();
          }
        }

        // Draw nodes
        for (const n of state.nodes) {
          drawNode(n);
        }
      }

      function drawUndirectedEdge(a, b, isTemp=false) {
        const {x: x1, y: y1} = a;
        const {x: x2, y: y2} = b;
        const trimmed = trimLineToCircle(x1, y1, x2, y2, state.radius);
        ctx.beginPath();
        ctx.moveTo(trimmed.x1, trimmed.y1);
        ctx.lineTo(trimmed.x2, trimmed.y2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = isTemp ? '#64748b' : '#7aa2d8';
        ctx.shadowColor = 'transparent';
        ctx.stroke();
      }

      function drawDirectedEdge(a, b, isTemp=false) {
        const {x: x1, y: y1} = a;
        const {x: x2, y: y2} = b;

        const trimmed = trimLineToCircle(x1, y1, x2, y2, state.radius);
        const angle = Math.atan2(trimmed.y2 - trimmed.y1, trimmed.x2 - trimmed.x1);

        // Line
        ctx.beginPath();
        ctx.moveTo(trimmed.x1, trimmed.y1);
        ctx.lineTo(trimmed.x2, trimmed.y2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = isTemp ? '#64748b' : '#93c5fd';
        ctx.stroke();

        // Arrowhead
        const len = 12;
        const width = 7;
        const ex = trimmed.x2;
        const ey = trimmed.y2;
        ctx.beginPath();
        ctx.moveTo(ex, ey);
        ctx.lineTo(ex - len * Math.cos(angle - Math.PI / 8), ey - len * Math.sin(angle - Math.PI / 8));
        ctx.lineTo(ex - len * Math.cos(angle + Math.PI / 8), ey - len * Math.sin(angle + Math.PI / 8));
        ctx.closePath();
        ctx.fillStyle = isTemp ? '#64748b' : '#93c5fd';
        ctx.fill();
      }

      function trimLineToCircle(x1, y1, x2, y2, r) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const dist = Math.hypot(dx, dy) || 1;
        const ux = dx / dist;
        const uy = dy / dist;
        const start = { x: x1 + ux * r, y: y1 + uy * r };
        const end = { x: x2 - ux * r, y: y2 - uy * r };
        return { x1: start.x, y1: start.y, x2: end.x, y2: end.y };
      }

      function drawNode(n) {
        const r = state.radius;
        const selected = n.id === state.selectedNodeId;
        const hover = n.id === state.hoverNodeId;

        // Glow
        if (selected || hover) {
          ctx.save();
          ctx.beginPath();
          ctx.arc(n.x, n.y, r + 10, 0, Math.PI * 2);
          ctx.fillStyle = selected ? 'rgba(59,130,246,0.15)' : 'rgba(96,165,250,0.12)';
          ctx.fill();
          ctx.restore();
        }

        // Node circle
        ctx.beginPath();
        ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
        const grad = ctx.createLinearGradient(n.x, n.y - r, n.x, n.y + r);
        grad.addColorStop(0, '#0d1424');
        grad.addColorStop(1, '#0a111f');
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.lineWidth = selected ? 3 : 2;
        ctx.strokeStyle = selected ? '#60a5fa' : (hover ? '#94a3b8' : '#586a87');
        ctx.stroke();

        // Label
        ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        ctx.fillStyle = '#e5e7eb';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(n.label, n.x, n.y);
      }

      // Interaction
      function getMouse(evt) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top
        };
      }

      canvas.addEventListener('mousemove', (e) => {
        const {x, y} = getMouse(e);
        state.mouse.x = x; state.mouse.y = y;

        if (state.dragging) {
          const n = state.nodes.find(nn => nn.id === state.dragging.id);
          if (n) {
            n.x = x - state.dragging.offsetX;
            n.y = y - state.dragging.offsetY;
            state.pointerMoved = true;
            draw();
          }
          return;
        }

        // Hover
        const hit = getNodeAt(x, y);
        const newHover = hit ? hit.id : null;
        if (newHover !== state.hoverNodeId) {
          state.hoverNodeId = newHover;
          draw();
        }
      });

      canvas.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // only left
        const {x, y} = getMouse(e);
        state.isPointerDown = true;
        state.pointerMoved = false;
        state.pointerDownAt = {x, y};
        const hit = getNodeAt(x, y);
        if (hit) {
          state.dragging = { id: hit.id, offsetX: x - hit.x, offsetY: y - hit.y };
        } else {
          state.dragging = null;
        }
      });

      function handleClickAt(x, y) {
        const hit = getNodeAt(x, y);

        if (hit) {
          if (state.selectedNodeId == null) {
            // Select the node
            state.selectedNodeId = hit.id;
          } else {
            if (state.selectedNodeId === hit.id) {
              // Deselect same node
              state.selectedNodeId = null;
            } else {
              // Create edge from selected to this
              addEdge(state.selectedNodeId, hit.id);
              state.selectedNodeId = null;
            }
          }
        } else {
          // Empty space: add node
          const newNode = addNode(x, y);
          // If a node was selected, connect it to the new node
          if (state.selectedNodeId != null) {
            addEdge(state.selectedNodeId, newNode.id);
            state.selectedNodeId = null;
          }
        }
        draw();
      }

      canvas.addEventListener('mouseup', (e) => {
        if (e.button !== 0) return;
        const {x, y} = getMouse(e);
        const movedDist = Math.hypot(x - state.pointerDownAt.x, y - state.pointerDownAt.y);
        const wasDrag = state.pointerMoved || movedDist > 3;

        state.isPointerDown = false;
        state.dragging = null;

        if (!wasDrag) {
          handleClickAt(x, y);
        }
      });

      canvas.addEventListener('mouseleave', () => {
        if (state.dragging) {
          state.dragging = null;
        }
        state.isPointerDown = false;
      });

      // Right-click to delete node
      canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const {x, y} = getMouse(e);
        const hit = getNodeAt(x, y);
        if (hit) {
          deleteNode(hit.id);
          draw();
        }
      });

      // Controls
      typeDirected.addEventListener('change', () => {
        if (typeDirected.checked) {
          state.isDirected = true;
          modeLabel.textContent = 'Directed';
          draw();
        }
      });
      typeUndirected.addEventListener('change', () => {
        if (typeUndirected.checked) {
          state.isDirected = false;
          modeLabel.textContent = 'Undirected';
          draw();
        }
      });

      clearBtn.addEventListener('click', () => {
        state.nodes = [];
        state.edges = [];
        state.selectedNodeId = null;
        state.hoverNodeId = null;
        state.nextId = 1;
        state.nextLabelIndex = 0;
        updateStats();
        draw();
      });

      layoutBtn.addEventListener('click', () => {
        const n = state.nodes.length;
        if (n === 0) return;
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        const cx = w / 2;
        const cy = h / 2;
        const r = Math.min(w, h) * 0.35;

        for (let i = 0; i < n; i++) {
          const angle = (i / n) * Math.PI * 2 - Math.PI / 2;
          state.nodes[i].x = cx + r * Math.cos(angle);
          state.nodes[i].y = cy + r * Math.sin(angle);
        }
        draw();
      });

      // Initial draw and gentle intro nodes
      function quickIntro() {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        const points = [
          {x: w*0.35, y: h*0.35},
          {x: w*0.65, y: h*0.35},
          {x: w*0.50, y: h*0.60}
        ];
        points.forEach(p => addNode(p.x, p.y));
        addEdge(state.nodes[0].id, state.nodes[1].id);
        addEdge(state.nodes[1].id, state.nodes[2].id);
        draw();
      }
      quickIntro();
    })();
  </script>
</body>
</html>