<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Floyd-Warshall Algorithm</title>
<style>
  body { font-family: system-ui, Arial, sans-serif; max-width: 900px; margin: 2rem auto; padding: 0 1rem; line-height: 1.6; color: #222; }
  h1 { font-size: 1.8rem; margin-bottom: 0.5rem; }
  h2 { font-size: 1.4rem; margin-top: 1.5rem; }
  h3 { font-size: 1.2rem; margin-top: 1rem; }
  pre { background: #f7f7f9; padding: 0.75rem; overflow: auto; border: 1px solid #eee; border-radius: 6px; }
  code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  label, button, input, textarea { font-size: 1rem; }
  textarea { width: 100%; min-height: 7rem; box-sizing: border-box; padding: 0.5rem; }
  button { margin-top: 0.5rem; padding: 0.5rem 0.75rem; cursor: pointer; }
  .output { margin-top: 1rem; }
  .alert { color: #b00020; }
  table { border-collapse: collapse; margin-top: 0.5rem; width: 100%; }
  td, th { border: 1px solid #ddd; padding: 0.35rem 0.5rem; text-align: center; }
  th { background: #fafafa; }
  .small { font-size: 0.92rem; color: #555; }
</style>
</head>
<body>
  <h1>Floyd-Warshall Algorithm</h1>
  <p>
    Floydâ€“Warshall computes shortest-path distances between every pair of vertices in a weighted graph.
    It supports negative edge weights but not negative cycles.
  </p>
  <ul>
    <li>Input: weighted directed or undirected graph (adjacency matrix).</li>
    <li>Output: distance matrix where entry (i, j) is the shortest-path distance from i to j.</li>
    <li>Time complexity: O(n^3). Space complexity: O(n^2).</li>
  </ul>

  <h2>Pseudocode</h2>
  <pre><code>for k in 0..n-1:
  for i in 0..n-1:
    for j in 0..n-1:
      if dist[i][k] + dist[k][j] &lt; dist[i][j]:
        dist[i][j] = dist[i][k] + dist[k][j]</code></pre>

  <h2>Try it</h2>
  <p class="small">
    Enter an adjacency matrix (comma- or space-separated rows). Use "inf" for no edge. Diagonal entries can be 0 or "inf" (will be set to 0).
  </p>
  <textarea id="matrix" placeholder="Example:
0,3,inf,7
8,0,2,inf
5,inf,0,1
inf,inf,inf,0"></textarea>
  <div>
    <label><input type="checkbox" id="undirected"> Treat as undirected (symmetrize matrix)</label>
  </div>
  <button id="run">Compute shortest paths</button>
  <div class="output" id="result"></div>

  <script>
    function $(id) { return document.getElementById(id); }

    function parseMatrix(text) {
      const lines = text.trim().split(/\n+/).filter(l => l.trim().length > 0);
      if (lines.length === 0) throw new Error('Please enter an adjacency matrix.');
      const matrix = lines.map((line, idx) => {
        const cells = line.trim().split(/,\s*|\s+/);
        if (cells.length === 0) throw new Error('Empty row at line ' + (idx + 1));
        return cells.map(cell => {
          if (!cell || /^inf(?:inity)?$/i.test(cell)) return Infinity;
          const num = Number(cell);
          if (!Number.isFinite(num)) throw new Error('Invalid number "' + cell + '" at line ' + (idx + 1));
          return num;
        });
      });
      const n = matrix.length;
      for (let i = 0; i < n; i++) {
        if (matrix[i].length !== n) {
          throw new Error('Matrix must be square: row ' + i + ' has ' + matrix[i].length + ' entries, expected ' + n + '.');
        }
      }
      return { matrix, n };
    }

    function showTable(mat) {
      const n = mat.length;
      let html = '<table><thead><tr><th></th>';
      for (let j = 0; j < n; j++) html += '<th>' + j + '</th>';
      html += '</tr></thead><tbody>';
      for (let i = 0; i < n; i++) {
        html += '<tr><th>' + i + '</th>';
        for (let j = 0; j < n; j++) {
          const val = mat[i][j];
          const text = (val === Infinity) ? 'inf' : String(Math.round(val * 1000) / 1000);
          html += '<td>' + text + '</td>';
        }
        html += '</tr>';
      }
      html += '</tbody></table>';
      return html;
    }

    function floydWarshall(dist) {
      const n = dist.length;
      for (let i = 0; i < n; i++) {
        if (dist[i][i] === Infinity) dist[i][i] = 0;
      }
      for (let k = 0; k < n; k++) {
        for (let i = 0; i < n; i++) {
          const dik = dist[i][k];
          if (dik === Infinity) continue;
          for (let j = 0; j < n; j++) {
            const alt = dik + dist[k][j];
            if (alt < dist[i][j]) dist[i][j] = alt;
          }
        }
      }
      return dist;
    }

    function symmetrize(mat) {
      const n = mat.length;
      for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
          const a = mat[i][j], b = mat[j][i];
          // Choose the smaller weight if both directions provided, else whichever is defined
          let w;
          if (a === Infinity && b === Infinity) w = Infinity;
          else if (a === Infinity) w = b;
          else if (b === Infinity) w = a;
          else w = Math.min(a, b);
          mat[i][j] = mat[j][i] = w;
        }
      }
    }

    $('run').addEventListener('click', () => {
      const res = $('result');
      res.textContent = '';
      try {
        const { matrix, n } = parseMatrix($('matrix').value);
        const dist = matrix.map(row => row.slice());
        if ($('undirected').checked) symmetrize(dist);
        floydWarshall(dist);
        const negCycleVertices = [];
        for (let v = 0; v < n; v++) {
          if (dist[v][v] < 0) negCycleVertices.push(v);
        }
        let html = '';
        if (negCycleVertices.length) {
          html += '<p class="alert">Negative cycle detected (reachable from vertices: ' + negCycleVertices.join(', ') + '). Distances may be undefined.</p>';
        }
        html += '<h3>Distance matrix</h3>' + showTable(dist);
        res.innerHTML = html;
      } catch (e) {
        res.innerHTML = '<p class="alert">Error: ' + e.message + '</p>';
      }
    });
  </script>
</body>
</html>