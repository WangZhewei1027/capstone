<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bellman-Ford Algorithm</title>
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
      margin: 0;
      padding: 24px;
      line-height: 1.6;
      max-width: 900px;
    }
    header {
      margin-bottom: 16px;
    }
    h1 {
      font-size: 1.8rem;
      margin: 0 0 8px;
    }
    h2 {
      font-size: 1.3rem;
      margin: 24px 0 8px;
    }
    p {
      margin: 8px 0;
    }
    .container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    .card {
      border: 1px solid rgba(128,128,128,0.3);
      border-radius: 10px;
      padding: 16px;
    }
    label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
    }
    input[type="number"], input[type="text"], textarea, select {
      width: 100%;
      box-sizing: border-box;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid rgba(128,128,128,0.4);
      background: transparent;
      color: inherit;
      font-family: inherit;
      font-size: 0.95rem;
    }
    textarea {
      min-height: 120px;
      resize: vertical;
      white-space: pre;
    }
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 12px;
    }
    button {
      border: 1px solid rgba(128,128,128,0.4);
      background: transparent;
      color: inherit;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }
    button:hover {
      border-color: rgba(128,128,128,0.7);
    }
    .note {
      font-size: 0.95rem;
      opacity: 0.85;
    }
    .muted {
      opacity: 0.75;
    }
    .error {
      color: #c62828;
      margin-top: 8px;
    }
    .success {
      color: #2e7d32;
      margin-top: 8px;
    }
    pre, code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.9rem;
    }
    pre {
      overflow: auto;
      background: rgba(127,127,127,0.08);
      padding: 12px;
      border-radius: 8px;
      border: 1px solid rgba(128,128,128,0.25);
    }
    ul {
      padding-left: 18px;
    }
    .result-list {
      border-top: 1px dashed rgba(128,128,128,0.4);
      margin-top: 10px;
      padding-top: 10px;
    }
    .pill {
      display: inline-block;
      border: 1px solid rgba(128,128,128,0.4);
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 0.85rem;
      margin-right: 6px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Bellman-Ford Algorithm</h1>
    <p class="muted">Single-source shortest paths for weighted graphs with negative edges. Also detects negative-weight cycles.</p>
  </header>

  <div class="container">
    <section class="card">
      <h2>Overview</h2>
      <ul>
        <li>Computes shortest path distances from a source vertex to all other vertices in a directed weighted graph.</li>
        <li>Works with negative edge weights, unlike Dijkstra’s algorithm.</li>
        <li>Detects negative-weight cycles reachable from the source.</li>
      </ul>
      <p class="pill">Time complexity: O(V · E)</p>
      <p class="pill">Space: O(V)</p>
    </section>

    <section class="card">
      <h2>Try it</h2>
      <div class="row">
        <div>
          <label for="vertices">Number of vertices (V)</label>
          <input id="vertices" type="number" min="1" value="4" />
        </div>
        <div>
          <label for="source">Source vertex (0-based)</label>
          <input id="source" type="number" min="0" value="0" />
        </div>
      </div>

      <label for="edges">Edges (one per line: u v w)</label>
      <textarea id="edges">0 1 4
0 2 5
1 2 -3
2 3 4
1 3 2</textarea>
      <p class="note">Vertices are 0-based indices: 0 … V-1. Each line contains "u v w" meaning an edge u → v with weight w.</p>

      <div class="actions">
        <button id="run">Compute shortest paths</button>
        <button id="loadExample">Load example with negative cycle</button>
        <button id="reset">Reset</button>
      </div>

      <div id="message" class="error" style="display:none;"></div>
      <div id="status" class="success" style="display:none;"></div>

      <div id="results" class="result-list"></div>
    </section>

    <section class="card">
      <h2>Pseudocode</h2>
      <pre><code>// Bellman-Ford(G=(V,E), w, source s)
for each v in V:
    dist[v] = +∞
    parent[v] = null
dist[s] = 0

// Relax all edges V-1 times
for i = 1 to |V| - 1:
    for each edge (u, v) in E:
        if dist[u] + w(u,v) < dist[v]:
            dist[v] = dist[u] + w(u,v)
            parent[v] = u

// Check for negative-weight cycles
for each edge (u, v) in E:
    if dist[u] + w(u,v) < dist[v]:
        report "Negative-weight cycle reachable from s"
        // distances not well-defined
</code></pre>
    </section>

    <section class="card">
      <h2>Notes</h2>
      <ul>
        <li>Use Bellman-Ford when edges can be negative or when you need cycle detection.</li>
        <li>Dijkstra’s algorithm is faster but requires non-negative edge weights.</li>
        <li>If a negative cycle is reachable from the source, shortest paths are undefined for vertices affected by that cycle.</li>
      </ul>
    </section>
  </div>

  <script>
    const verticesEl = document.getElementById('vertices');
    const sourceEl = document.getElementById('source');
    const edgesEl = document.getElementById('edges');
    const runBtn = document.getElementById('run');
    const resetBtn = document.getElementById('reset');
    const loadExampleBtn = document.getElementById('loadExample');
    const messageEl = document.getElementById('message');
    const statusEl = document.getElementById('status');
    const resultsEl = document.getElementById('results');

    function showMessage(msg) {
      messageEl.textContent = msg;
      messageEl.style.display = msg ? 'block' : 'none';
      statusEl.style.display = 'none';
      resultsEl.innerHTML = '';
    }
    function showStatus(msg) {
      statusEl.textContent = msg;
      statusEl.style.display = msg ? 'block' : 'none';
      messageEl.style.display = 'none';
    }

    function parseEdges(text, V) {
      const edges = [];
      const lines = text.split('\n').map(l => l.trim()).filter(l => l.length);
      for (let i = 0; i < lines.length; i++) {
        const parts = lines[i].split(/\s+/);
        if (parts.length !== 3) {
          throw new Error(`Invalid edge on line ${i+1}: expected "u v w"`);
        }
        const u = Number(parts[0]);
        const v = Number(parts[1]);
        const w = Number(parts[2]);
        if (!Number.isFinite(u) || !Number.isFinite(v) || !Number.isFinite(w)) {
          throw new Error(`Invalid numbers on line ${i+1}`);
        }
        if (u < 0 || v < 0 || u >= V || v >= V) {
          throw new Error(`Vertex out of range on line ${i+1}: u=${u}, v=${v}, V=${V}`);
        }
        edges.push({ u, v, w });
      }
      return edges;
    }

    function bellmanFord(V, edges, source) {
      const dist = Array(V).fill(Infinity);
      const parent = Array(V).fill(null);
      dist[source] = 0;

      // Relax edges V-1 times
      for (let i = 0; i < V - 1; i++) {
        let updated = false;
        for (const { u, v, w } of edges) {
          if (Number.isFinite(dist[u]) && dist[u] + w < dist[v]) {
            dist[v] = dist[u] + w;
            parent[v] = u;
            updated = true;
          }
        }
        if (!updated) break; // Early stop if no changes
      }

      // Check for negative cycles
      let negativeCycle = false;
      for (const { u, v, w } of edges) {
        if (Number.isFinite(dist[u]) && dist[u] + w < dist[v]) {
          negativeCycle = true;
          break;
        }
      }

      return { dist, parent, negativeCycle };
    }

    function reconstructPath(parent, s, t) {
      if (t === null) return null;
      const path = [];
      let cur = t;
      const visited = new Set();
      while (cur !== null) {
        path.push(cur);
        if (cur === s) break;
        cur = parent[cur];
        // Avoid infinite loop if parent chain is corrupted
        if (cur !== null) {
          if (visited.has(cur)) break;
          visited.add(cur);
        }
      }
      if (path[path.length - 1] !== s) return null;
      return path.reverse();
    }

    function renderResults(V, source, dist, parent, negativeCycle) {
      const infinity = '\u221E';
      let html = '';

      if (negativeCycle) {
        html += '<p class="error">Negative-weight cycle detected that is reachable from the source. Shortest paths are not well-defined for affected vertices.</p>';
      } else {
        html += '<p class="success">No negative-weight cycles detected.</p>';
      }

      html += '<h3>Distances</h3><ul>';
      for (let v = 0; v < V; v++) {
        const d = Number.isFinite(dist[v]) ? dist[v] : infinity;
        html += `<li>dist[${v}] = ${d}</li>`;
      }
      html += '</ul>';

      html += '<h3>Paths from source</h3><ul>';
      for (let v = 0; v < V; v++) {
        if (!Number.isFinite(dist[v])) {
          html += `<li>${source} → ${v}: unreachable</li>`;
          continue;
        }
        const path = reconstructPath(parent, source, v);
        if (path) {
          html += `<li>${source} → ${v}: ${path.join(' → ')}</li>`;
        } else {
          html += `<li>${source} → ${v}: (path unavailable)</li>`;
        }
      }
      html += '</ul>';

      resultsEl.innerHTML = html;
    }

    function onRun() {
      showMessage('');
      showStatus('');
      resultsEl.innerHTML = '';

      const V = Number(verticesEl.value);
      const source = Number(sourceEl.value);

      if (!Number.isInteger(V) || V <= 0) {
        showMessage('Please enter a valid number of vertices (V ≥ 1).');
        return;
      }
      if (!Number.isInteger(source) || source < 0 || source >= V) {
        showMessage(`Please enter a valid source vertex in [0, ${V-1}].`);
        return;
      }

      let edges;
      try {
        edges = parseEdges(edgesEl.value, V);
      } catch (e) {
        showMessage(e.message);
        return;
      }

      const { dist, parent, negativeCycle } = bellmanFord(V, edges, source);
      renderResults(V, source, dist, parent, negativeCycle);
      if (!negativeCycle) {
        showStatus('Computation completed successfully.');
      }
    }

    function onReset() {
      verticesEl.value = 4;
      sourceEl.value = 0;
      edgesEl.value = '0 1 4\n0 2 5\n1 2 -3\n2 3 4\n1 3 2';
      showMessage('');
      showStatus('');
      resultsEl.innerHTML = '';
    }

    function onLoadExample() {
      verticesEl.value = 5;
      sourceEl.value = 0;
      edgesEl.value =
        '0 1 1\n' +
        '1 2 -1\n' +
        '2 3 -1\n' +
        '3 1 -1\n' + // forms a negative cycle 1->2->3->1
        '0 4 10';
      showMessage('');
      showStatus('Loaded example with a reachable negative cycle.');
      resultsEl.innerHTML = '';
    }

    runBtn.addEventListener('click', onRun);
    resetBtn.addEventListener('click', onReset);
    loadExampleBtn.addEventListener('click', onLoadExample);
  </script>
</body>
</html>