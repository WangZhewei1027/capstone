<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Prim’s Algorithm (Minimum Spanning Tree)</title>
  <style>
    :root {
      --bg: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --accent: #2563eb;
      --good: #10b981;
      --edge: #9ca3af;
      --edge-strong: #374151;
      --visited: #fde68a;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
      line-height: 1.55;
    }
    .page {
      max-width: 950px;
      margin: 0 auto;
      padding: 28px 18px 48px;
    }
    header h1 {
      margin: 0 0 8px;
      font-size: 28px;
      font-weight: 700;
    }
    header p {
      margin: 0 0 18px;
      color: var(--muted);
    }
    section {
      margin: 22px 0;
    }
    h2 {
      font-size: 20px;
      margin: 0 0 10px;
    }
    ul {
      padding-left: 18px;
      margin: 8px 0;
    }
    code, pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    pre {
      background: #f8fafc;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 12px 14px;
      overflow: auto;
      margin: 10px 0;
    }
    /* Visualization */
    .viz-wrap {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 16px;
      align-items: start;
    }
    .canvas {
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      padding: 6px;
    }
    svg {
      width: 100%;
      height: 380px;
      display: block;
    }
    .node {
      fill: #ffffff;
      stroke: var(--edge-strong);
      stroke-width: 2.2;
      transition: fill 150ms ease, stroke 150ms ease;
    }
    .node.visited {
      fill: var(--visited);
      stroke: #ca8a04;
    }
    .edge {
      stroke: var(--edge);
      stroke-width: 2.5;
      transition: stroke 150ms ease, stroke-width 150ms ease;
    }
    .edge.mst {
      stroke: var(--good);
      stroke-width: 4.5;
    }
    .edge.considered {
      stroke: #f59e0b;
      stroke-dasharray: 6 4;
    }
    .weight {
      fill: #111827;
      font-size: 12px;
      user-select: none;
      text-anchor: middle;
    }
    .label {
      fill: #111827;
      font-size: 12px;
      font-weight: 600;
      user-select: none;
    }
    .controls {
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      padding: 12px;
      background: #f9fafb;
    }
    .controls .row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    .controls label {
      font-size: 14px;
      color: var(--muted);
    }
    select, button {
      font: inherit;
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      cursor: pointer;
    }
    button {
      background: var(--accent);
      color: #fff;
      border: none;
    }
    button.secondary {
      background: #e5e7eb;
      color: #111827;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .log {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 10px 12px;
      max-height: 180px;
      overflow: auto;
      font-size: 13px;
    }
    .summary {
      margin-top: 6px;
      font-size: 14px;
      color: var(--muted);
    }
    .legend {
      display: flex;
      gap: 14px;
      align-items: center;
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
    }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .swatch {
      width: 18px;
      height: 3px;
      border-radius: 2px;
    }
    .swatch.mst { background: var(--good); }
    .swatch.consider { background: #f59e0b; }
    .swatch.default { background: var(--edge); }
    @media (max-width: 860px) {
      .viz-wrap { grid-template-columns: 1fr; }
      svg { height: 420px; }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <h1>Prim’s Algorithm (Minimum Spanning Tree)</h1>
      <p>Builds a minimum-cost tree that connects all vertices in a connected, weighted, undirected graph. Prim’s is a greedy algorithm.</p>
    </header>

    <section>
      <h2>How it works</h2>
      <ul>
        <li>Start from any vertex. Mark it visited.</li>
        <li>Repeatedly choose the lightest edge that connects the visited set to an unvisited vertex.</li>
        <li>Add that edge to the MST and mark the new vertex visited.</li>
        <li>Stop when all vertices are included. The selected edges form the minimum spanning tree (MST).</li>
      </ul>
      <p><strong>Complexity:</strong> O(E log V) with a min-heap / priority queue; O(V²) with a simple array on dense graphs.</p>
    </section>

    <section>
      <h2>Pseudocode</h2>
      <pre><code>Prim(G, start):
    T = {}                        // edges of the MST
    visited = {start}
    PQ = min-priority queue of edges touching visited

    push all edges (start, v, w) into PQ

    while |visited| &lt; |V(G)| and PQ not empty:
        (u, v, w) = PQ.pop_min() // lightest edge from visited to unvisited
        if u in visited and v not in visited:
            T.add((u, v, w))
            visited.add(v)
            for each edge (v, x, w2):
                if x not in visited:
                    PQ.push((v, x, w2))

    if |visited| &lt; |V(G)|:
        error "Graph is disconnected"

    return T</code></pre>
    </section>

    <section>
      <h2>Interactive example</h2>
      <div class="viz-wrap">
        <div class="canvas">
          <svg viewBox="0 0 450 360" aria-label="Graph visualization">
            <!-- Edges -->
            <line id="edge-A-B" class="edge" x1="70" y1="60" x2="270" y2="50" data-u="A" data-v="B" data-w="4" />
            <line id="edge-A-D" class="edge" x1="70" y1="60" x2="130" y2="200" data-u="A" data-v="D" data-w="3" />
            <line id="edge-A-F" class="edge" x1="70" y1="60" x2="90" y2="320" data-u="A" data-v="F" data-w="8" />

            <line id="edge-B-C" class="edge" x1="270" y1="50" x2="370" y2="160" data-u="B" data-v="C" data-w="6" />
            <line id="edge-B-D" class="edge" x1="270" y1="50" x2="130" y2="200" data-u="B" data-v="D" data-w="5" />
            <line id="edge-B-E" class="edge" x1="270" y1="50" x2="260" y2="240" data-u="B" data-v="E" data-w="7" />

            <line id="edge-C-D" class="edge" x1="370" y1="160" x2="130" y2="200" data-u="C" data-v="D" data-w="7" />
            <line id="edge-C-E" class="edge" x1="370" y1="160" x2="260" y2="240" data-u="C" data-v="E" data-w="4" />

            <line id="edge-D-E" class="edge" x1="130" y1="200" x2="260" y2="240" data-u="D" data-v="E" data-w="2" />
            <line id="edge-D-F" class="edge" x1="130" y1="200" x2="90" y2="320" data-u="D" data-v="F" data-w="6" />
            <line id="edge-E-F" class="edge" x1="260" y1="240" x2="90" y2="320" data-u="E" data-v="F" data-w="5" />

            <!-- Weights -->
            <text class="weight" x="170" y="52">4</text>
            <text class="weight" x="100" y="125">3</text>
            <text class="weight" x="93" y="190">8</text>

            <text class="weight" x="320" y="102">6</text>
            <text class="weight" x="195" y="120">5</text>
            <text class="weight" x="265" y="150">7</text>

            <text class="weight" x="255" y="178">7</text>
            <text class="weight" x="315" y="202">4</text>

            <text class="weight" x="200" y="222">2</text>
            <text class="weight" x="110" y="260">6</text>
            <text class="weight" x="170" y="292">5</text>

            <!-- Nodes -->
            <circle id="node-A" class="node" cx="70" cy="60" r="16" data-name="A"></circle>
            <text class="label" x="70" y="63" text-anchor="middle">A</text>

            <circle id="node-B" class="node" cx="270" cy="50" r="16" data-name="B"></circle>
            <text class="label" x="270" y="53" text-anchor="middle">B</text>

            <circle id="node-C" class="node" cx="370" cy="160" r="16" data-name="C"></circle>
            <text class="label" x="370" y="163" text-anchor="middle">C</text>

            <circle id="node-D" class="node" cx="130" cy="200" r="16" data-name="D"></circle>
            <text class="label" x="130" y="203" text-anchor="middle">D</text>

            <circle id="node-E" class="node" cx="260" cy="240" r="16" data-name="E"></circle>
            <text class="label" x="260" y="243" text-anchor="middle">E</text>

            <circle id="node-F" class="node" cx="90" cy="320" r="16" data-name="F"></circle>
            <text class="label" x="90" y="323" text-anchor="middle">F</text>
          </svg>
          <div class="legend" aria-hidden="true">
            <span class="chip"><span class="swatch mst"></span>MST edge</span>
            <span class="chip"><span class="swatch consider"></span>Frontier (considered)</span>
            <span class="chip"><span class="swatch default"></span>Other edge</span>
          </div>
        </div>

        <div class="controls">
          <div class="row">
            <label for="startSel">Start vertex:</label>
            <select id="startSel" aria-label="Start vertex">
              <option>A</option>
              <option>B</option>
              <option>C</option>
              <option>D</option>
              <option>E</option>
              <option>F</option>
            </select>
          </div>
          <div class="row">
            <button id="stepBtn">Step</button>
            <button id="runBtn" class="secondary">Run</button>
            <button id="resetBtn" class="secondary">Reset</button>
          </div>
          <div class="log" id="log" aria-live="polite"></div>
          <div class="summary" id="summary"></div>
        </div>
      </div>
    </section>

    <section>
      <h2>Notes</h2>
      <ul>
        <li>Prim’s works on connected, weighted, undirected graphs. If the graph is disconnected, the algorithm can’t reach all vertices.</li>
        <li>Edge weights must be non-negative for typical implementations; negative weights still work for MST since cycles aren’t chosen, but beware of other algorithms.</li>
        <li>Kruskal’s algorithm is another MST method; it sorts edges and uses a disjoint-set (union–find) structure.</li>
      </ul>
    </section>
  </div>

  <script>
    (function() {
      const edgesEls = Array.from(document.querySelectorAll('.edge'));
      const nodesEls = Array.from(document.querySelectorAll('.node'));
      const startSel = document.getElementById('startSel');
      const stepBtn = document.getElementById('stepBtn');
      const runBtn = document.getElementById('runBtn');
      const resetBtn = document.getElementById('resetBtn');
      const logEl = document.getElementById('log');
      const summaryEl = document.getElementById('summary');

      const nodes = nodesEls.map(n => n.dataset.name);
      const edges = edgesEls.map(el => ({
        id: el.id,
        u: el.dataset.u,
        v: el.dataset.v,
        w: Number(el.dataset.w)
      }));

      let seq = [];
      let stepIndex = 0;
      let currentStart = startSel.value;

      function clearClasses() {
        edgesEls.forEach(el => {
          el.classList.remove('mst', 'considered');
        });
        nodesEls.forEach(el => el.classList.remove('visited'));
        logEl.innerHTML = '';
        summaryEl.textContent = '';
        stepIndex = 0;
      }

      function log(msg) {
        const line = document.createElement('div');
        line.textContent = msg;
        logEl.appendChild(line);
        logEl.scrollTop = logEl.scrollHeight;
      }

      function formatEdge(e) {
        return `${e.u}–${e.v} (${e.w})`;
      }

      function labelOf(e) {
        // Deterministic label for tie-breaking
        const a = e.u;
        const b = e.v;
        return a < b ? `${a}-${b}` : `${b}-${a}`;
      }

      function primSequence(start) {
        const visited = new Set([start]);
        const chosen = [];
        // Keep track of candidates each step for UI
        const perStepCandidates = [];

        while (visited.size < nodes.length) {
          const candidates = edges.filter(e =>
            (visited.has(e.u) && !visited.has(e.v)) ||
            (visited.has(e.v) && !visited.has(e.u))
          );

          perStepCandidates.push(candidates.map(e => e.id));

          if (candidates.length === 0) break; // disconnected

          // pick minimum by weight then label for stability
          candidates.sort((a, b) => {
            if (a.w !== b.w) return a.w - b.w;
            const la = labelOf(a), lb = labelOf(b);
            return la.localeCompare(lb);
          });

          const e = candidates[0];
          chosen.push(e);

          // mark the new vertex
          const next = visited.has(e.u) ? e.v : e.u;
          visited.add(next);
        }

        return { chosen, perStepCandidates };
      }

      function highlightCandidates(ids) {
        // Clear previous considered
        edgesEls.forEach(el => el.classList.remove('considered'));
        ids.forEach(id => {
          const el = document.getElementById(id);
          if (el && !el.classList.contains('mst')) {
            el.classList.add('considered');
          }
        });
      }

      function highlightStep(i) {
        if (!seq || i < 0 || i >= seq.chosen.length) return;
        const e = seq.chosen[i];
        document.getElementById(e.id)?.classList.add('mst');

        // mark visited nodes
        document.getElementById('node-' + e.u)?.classList.add('visited');
        document.getElementById('node-' + e.v)?.classList.add('visited');

        highlightCandidates(seq.perStepCandidates[i] || []);
        log(`Step ${i + 1}: picked ${formatEdge(e)}`);
      }

      function recomputeIfNeeded() {
        const start = startSel.value;
        if (!seq || start !== currentStart) {
          currentStart = start;
          seq = primSequence(start);
        }
      }

      function summarize() {
        const total = seq.chosen.reduce((s, e) => s + e.w, 0);
        const done = seq.chosen.length === nodes.length - 1;
        if (done) {
          summaryEl.textContent = `MST found. Total weight = ${total}.`;
        } else {
          summaryEl.textContent = `Graph is disconnected from start ${currentStart}. Selected ${seq.chosen.length} edges.`;
        }
      }

      // Initial state
      clearClasses();

      // Events
      startSel.addEventListener('change', () => {
        clearClasses();
        seq = primSequence(startSel.value);
        // Mark start as visited to show context
        document.getElementById('node-' + startSel.value)?.classList.add('visited');
        highlightCandidates(seq.perStepCandidates[0] || []);
        log(`Start at ${startSel.value}.`);
      });

      stepBtn.addEventListener('click', () => {
        recomputeIfNeeded();
        if (stepIndex === 0) {
          // show initial
          clearClasses();
          document.getElementById('node-' + currentStart)?.classList.add('visited');
          highlightCandidates(seq.perStepCandidates[0] || []);
          log(`Start at ${currentStart}.`);
        }
        if (stepIndex < seq.chosen.length) {
          highlightStep(stepIndex);
          stepIndex += 1;
          if (stepIndex === seq.chosen.length) {
            summarize();
          }
        } else {
          summarize();
        }
      });

      runBtn.addEventListener('click', () => {
        recomputeIfNeeded();
        clearClasses();
        document.getElementById('node-' + currentStart)?.classList.add('visited');
        log(`Start at ${currentStart}.`);
        seq.chosen.forEach((e, i) => {
          document.getElementById(e.id)?.classList.add('mst');
          document.getElementById('node-' + e.u)?.classList.add('visited');
          document.getElementById('node-' + e.v)?.classList.add('visited');
          log(`Step ${i + 1}: picked ${formatEdge(e)}`);
        });
        highlightCandidates([]); // none at the end
        stepIndex = seq.chosen.length;
        summarize();
      });

      resetBtn.addEventListener('click', () => {
        clearClasses();
        seq = primSequence(startSel.value);
        document.getElementById('node-' + startSel.value)?.classList.add('visited');
        highlightCandidates(seq.perStepCandidates[0] || []);
        log(`Start at ${startSel.value}.`);
      });

      // Auto-seed initial log and frontier
      seq = primSequence(startSel.value);
      document.getElementById('node-' + startSel.value)?.classList.add('visited');
      highlightCandidates(seq.perStepCandidates[0] || []);
      log(`Start at ${startSel.value}.`);
    })();
  </script>
</body>
</html>