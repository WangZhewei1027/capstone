<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Two Pointers</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; line-height: 1.6; margin: 24px; color: #222; }
    h1, h2 { margin: 0.2em 0 0.2em; }
    h1 { font-size: 1.8em; }
    h2 { font-size: 1.2em; margin-top: 1.2em; }
    p { margin: 0.5em 0; }
    ul { margin: 0.5em 0 0.5em 1.2em; }
    code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    pre { background: #f7f7f9; border: 1px solid #e4e4e7; padding: 12px; overflow: auto; border-radius: 6px; }
    .note { color: #444; font-size: 0.95em; }
    .container { max-width: 820px; margin: 0 auto; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Two Pointers</h1>
    <p>The two pointers technique uses two indices to process data efficiently, often achieving linear time and constant space. It’s useful when the data has structure (like being sorted) or when we can maintain a local invariant while moving pointers.</p>

    <h2>When to Use</h2>
    <ul>
      <li>Finding pairs or ranges in sorted arrays (e.g., sum equals target).</li>
      <li>In-place array transformations (remove duplicates, partitioning, moving zeros).</li>
      <li>String problems from both ends (palindrome checks, reverse vowels).</li>
      <li>Linked list fast/slow cycles (Floyd’s cycle detection) and middle element.</li>
    </ul>

    <h2>Common Patterns</h2>
    <ul>
      <li><b>Opposite ends:</b> left at start, right at end; move inward based on condition.</li>
      <li><b>Same direction (fast/slow):</b> two indices traverse forward at different speeds or roles.</li>
      <li><b>Partitioning:</b> one pointer reads, another writes to maintain an invariant.</li>
    </ul>

    <h2>Complexity</h2>
    <ul>
      <li>Time: typically O(n)</li>
      <li>Space: typically O(1)</li>
    </ul>

    <h2>Example 1: Two Sum in a Sorted Array (Opposite Ends)</h2>
    <p>Given a sorted array, find a pair that sums to target. Move pointers based on sum.</p>
    <pre><code>// Returns 0-based indices of a pair that sums to target, or [-1, -1] if none.
function twoSumSorted(nums, target) {
  let left = 0, right = nums.length - 1;
  while (left &lt; right) {
    const sum = nums[left] + nums[right];
    if (sum === target) return [left, right];
    if (sum &lt; target) left++;
    else right--;
  }
  return [-1, -1];
}

// Example:
console.log(twoSumSorted([1, 2, 3, 4, 6, 8, 11], 10)); // [1, 5] (2 + 8)
</code></pre>

    <h2>Example 2: Remove Duplicates from Sorted Array (Read/Write)</h2>
    <p>Overwrite duplicates in-place and return the length of the unique prefix.</p>
    <pre><code>// Returns the count of unique elements; modifies nums in place.
function removeDuplicates(nums) {
  if (nums.length === 0) return 0;
  let write = 1; // position to write the next unique element
  for (let read = 1; read &lt; nums.length; read++) {
    if (nums[read] !== nums[write - 1]) {
      nums[write] = nums[read];
      write++;
    }
  }
  return write;
}

// Example:
const arr = [1, 1, 2, 2, 2, 3, 4, 4];
const k = removeDuplicates(arr);
console.log(k, arr.slice(0, k)); // 4, [1, 2, 3, 4]
</code></pre>

    <h2>Example 3: Reverse Vowels in a String (Opposite Ends)</h2>
    <p>Swap vowels from both ends until pointers meet.</p>
    <pre><code>function reverseVowels(s) {
  const vowels = new Set(['a','e','i','o','u','A','E','I','O','U']);
  const arr = s.split('');
  let left = 0, right = arr.length - 1;

  while (left &lt; right) {
    while (left &lt; right && !vowels.has(arr[left])) left++;
    while (left &lt; right && !vowels.has(arr[right])) right--;
    if (left &lt; right) {
      [arr[left], arr[right]] = [arr[right], arr[left]];
      left++; right--;
    }
  }
  return arr.join('');
}

// Example:
console.log(reverseVowels("hello world")); // "holle werld"
</code></pre>

    <h2>Example 4: Move Zeros to End (Partitioning)</h2>
    <p>Shift non-zero elements forward, fill remaining with zeros.</p>
    <pre><code>function moveZeroes(nums) {
  let write = 0;
  for (let read = 0; read &lt; nums.length; read++) {
    if (nums[read] !== 0) {
      nums[write] = nums[read];
      write++;
    }
  }
  while (write &lt; nums.length) {
    nums[write] = 0;
    write++;
  }
  return nums;
}

// Example:
console.log(moveZeroes([0,1,0,3,12])); // [1,3,12,0,0]
</code></pre>

    <h2>Pitfalls</h2>
    <ul>
      <li>Requires structure: many opposite-ends solutions need sorted input.</li>
      <li>Watch off-by-one errors: loop conditions like while (left &lt; right) vs (left &lt;= right).</li>
      <li>Duplicates and stability: ensure invariants when skipping or writing elements.</li>
    </ul>

    <p class="note">Tip: Write down the invariant (what must always be true) before coding, and decide which pointer moves based on that invariant.</p>
  </div>
</body>
</html>