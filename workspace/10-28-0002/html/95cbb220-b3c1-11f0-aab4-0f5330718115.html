<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Breadth-First Search (BFS)</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; line-height: 1.5; margin: 2rem; max-width: 900px; }
    h1, h2 { margin: 0.2rem 0 0.6rem; }
    .card { border: 1px solid rgba(0,0,0,0.15); border-radius: 8px; padding: 1rem; margin: 1rem 0; }
    textarea, input[type="text"] { width: 100%; box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    textarea { min-height: 10rem; }
    .row { display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap; }
    .row > * { flex: 1 1 auto; }
    .controls { display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; margin: 0.5rem 0; }
    button { padding: 0.6rem 1rem; border: 1px solid rgba(0,0,0,0.2); border-radius: 6px; background: #2563eb; color: white; cursor: pointer; }
    button.secondary { background: #6b7280; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    pre { background: rgba(0,0,0,0.05); padding: 0.75rem; border-radius: 6px; overflow: auto; }
    .result { white-space: pre-wrap; word-break: break-word; }
    .pill { display:inline-block; padding: 0.1rem 0.5rem; border-radius: 999px; background: #e5e7eb; margin-right: 0.25rem; }
    .muted { color: #6b7280; font-size: 0.95rem; }
  </style>
</head>
<body>
  <h1>Breadth-First Search (BFS)</h1>
  <p>
    Breadth-First Search is a graph traversal algorithm that explores a graph level by level.
    Starting from a source node, it visits all neighbors (distance 1), then all nodes at distance 2, and so on.
    BFS is ideal for finding the shortest number of edges between nodes in an unweighted graph.
  </p>

  <div class="card">
    <h2>Key ideas</h2>
    <ul>
      <li>Uses a queue (FIFO) to process nodes in the order they are discovered.</li>
      <li>Tracks visited nodes to avoid revisiting and infinite loops.</li>
      <li>In unweighted graphs, BFS finds the shortest path (by edge count).</li>
    </ul>
    <p class="muted">
      Complexity: Time O(V + E), Space O(V), where V is the number of vertices and E is the number of edges.
    </p>
  </div>

  <div class="card">
    <h2>Pseudocode</h2>
    <pre><code>procedure BFS(G, s):
  for each vertex v in G:
    visited[v] = false
    parent[v] = null
    dist[v] = +infinity

  create an empty queue Q
  visited[s] = true
  dist[s] = 0
  enqueue(Q, s)

  while Q is not empty:
    u = dequeue(Q)
    for each neighbor w of u:
      if not visited[w]:
        visited[w] = true
        parent[w] = u
        dist[w] = dist[u] + 1
        enqueue(Q, w)
</code></pre>
  </div>

  <div class="card">
    <h2>Try it</h2>
    <p>Enter a graph and a start node. You can provide edges or adjacency lists in flexible formats:</p>
    <ul>
      <li>Edge list (one per line): A B, A C, B D</li>
      <li>CSV: A,B</li>
      <li>Adjacency: A: B C, or A -> B, C</li>
      <li>Single node line (no edges): H</li>
    </ul>

    <div class="row">
      <div>
        <label for="edges"><strong>Graph input</strong></label>
        <textarea id="edges" spellcheck="false">A B
A C
B D
B E
C F
E G</textarea>
        <div class="controls">
          <label><input type="checkbox" id="directed"> Directed graph</label>
          <span class="muted">Unchecked = undirected.</span>
        </div>
      </div>
      <div>
        <label for="start"><strong>Start node</strong></label>
        <input id="start" type="text" value="A" />
        <div class="controls">
          <button id="run">Run BFS</button>
          <button id="reset" class="secondary" type="button">Reset</button>
        </div>
      </div>
    </div>

    <div id="output" class="result"></div>
  </div>

  <div class="card">
    <h2>What BFS is great for</h2>
    <ul>
      <li>Shortest paths in unweighted graphs (routes, friend-of-a-friend, minimum hops).</li>
      <li>Level-order traversal of trees.</li>
      <li>Checking connectivity and computing components (by repeating BFS from unvisited nodes).</li>
      <li>Bipartite testing (2-coloring by levels).</li>
    </ul>
  </div>

  <script>
    function parseGraph(text, directed) {
      const adj = new Map();

      const ensure = (v) => {
        if (!adj.has(v)) adj.set(v, new Set());
      };

      const addEdge = (u, v) => {
        ensure(u); ensure(v);
        adj.get(u).add(v);
        if (!directed) adj.get(v).add(u);
      };

      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      for (const line of lines) {
        // Adjacency formats: "A: B C", "A -> B, C"
        if (line.includes(':') || line.includes('->')) {
          const parts = line.split(/:|->/);
          if (parts.length >= 2) {
            const u = parts[0].trim();
            const right = parts.slice(1).join(' ').trim();
            const neigh = right.split(/[,\s]+/).filter(Boolean);
            ensure(u);
            if (neigh.length === 0) continue;
            for (const v of neigh) addEdge(u, v);
            continue;
          }
        }
        // Edge or list formats: "A B", "A,B", "A B C" (A connected to B and C)
        const toks = line.split(/[,\s]+/).filter(Boolean);
        if (toks.length === 1) {
          ensure(toks[0]);
        } else if (toks.length === 2) {
          addEdge(toks[0], toks[1]);
        } else if (toks.length > 2) {
          const u = toks[0];
          for (let i = 1; i < toks.length; i++) addEdge(u, toks[i]);
        }
      }

      // Normalize to arrays sorted for stable output
      const adjList = {};
      for (const [u, set] of adj.entries()) {
        adjList[u] = Array.from(set).sort();
      }
      return adjList;
    }

    function bfs(adj, start) {
      const nodes = Object.keys(adj);
      const visited = new Set();
      const parent = {};
      const dist = {};
      for (const v of nodes) {
        parent[v] = null;
        dist[v] = Infinity;
      }

      // If start is not known, include it as isolated
      if (!(start in adj)) {
        adj[start] = [];
      }

      const order = [];
      const levels = new Map(); // dist -> nodes in discovery order
      const q = [];
      visited.add(start);
      dist[start] = 0;
      q.push(start);

      while (q.length) {
        const u = q.shift();
        order.push(u);
        const d = dist[u];
        if (!levels.has(d)) levels.set(d, []);
        levels.get(d).push(u);

        for (const w of (adj[u] || [])) {
          if (!visited.has(w)) {
            visited.add(w);
            parent[w] = u;
            dist[w] = d + 1;
            q.push(w);
          }
        }
      }

      return { order, dist, parent, levels };
    }

    function formatLevels(levels) {
      const maxLevel = Math.max(...levels.keys());
      let out = "";
      for (let d = 0; d <= maxLevel; d++) {
        const nodes = levels.get(d) || [];
        out += `Level ${d}: ${nodes.join(", ")}\n`;
      }
      return out.trim();
    }

    function unreachableNodes(adj, visitedList) {
      const all = new Set(Object.keys(adj));
      for (const v of visitedList) all.delete(v);
      return Array.from(all).sort();
    }

    function onRun() {
      const edgesText = document.getElementById('edges').value;
      const start = (document.getElementById('start').value || "").trim();
      const directed = document.getElementById('directed').checked;
      const out = document.getElementById('output');
      out.textContent = "";

      if (!start) {
        out.textContent = "Please provide a start node.";
        return;
      }

      const adj = parseGraph(edgesText, directed);
      const { order, dist, parent, levels } = bfs(adj, start);

      let result = "";
      result += `Traversal order: ${order.join(" -> ")}\n\n`;

      const unreachable = unreachableNodes(adj, order);
      if (unreachable.length) {
        result += `Unreachable from ${start}: ${unreachable.join(", ")}\n\n`;
      }

      result += "Levels (distance from start):\n";
      result += formatLevels(levels) + "\n\n";

      // Show distances for discovered nodes
      const discovered = order.slice();
      const distLines = discovered.map(v => `${v}: ${dist[v]}`);
      result += "Distances:\n" + distLines.join(", ") + "\n\n";

      // Optional: show tree edges (parent pointers)
      const treeEdges = discovered.filter(v => parent[v] !== null).map(v => `${parent[v]} -> ${v}`);
      result += "BFS tree edges:\n" + (treeEdges.length ? treeEdges.join(", ") : "(none)") + "\n";

      out.textContent = result;
    }

    function onReset() {
      document.getElementById('edges').value = `A B
A C
B D
B E
C F
E G`;
      document.getElementById('start').value = "A";
      document.getElementById('directed').checked = false;
      document.getElementById('output').textContent = "";
    }

    document.getElementById('run').addEventListener('click', onRun);
    document.getElementById('reset').addEventListener('click', onReset);
  </script>
</body>
</html>