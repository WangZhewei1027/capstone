<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dijkstra’s Algorithm</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 2rem; line-height: 1.5; }
    h1, h2 { margin: 0.2rem 0 0.6rem; }
    .container { max-width: 900px; }
    .panel { border: 1px solid rgba(0,0,0,0.1); border-radius: 8px; padding: 1rem; margin: 1rem 0; }
    label { display: inline-block; margin-right: 0.5rem; }
    select, button { font: inherit; padding: 0.4rem 0.6rem; margin-right: 0.5rem; }
    code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    pre { background: rgba(127,127,127,0.08); padding: 0.75rem; border-radius: 6px; overflow: auto; }
    ul { margin: 0.4rem 0 0.8rem 1.2rem; }
    .edges { columns: 2 16rem; }
    .result { white-space: pre-wrap; }
    .muted { opacity: 0.8; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Dijkstra’s Algorithm</h1>
    <p>
      Dijkstra’s algorithm finds the shortest-path distances from a single source to all other nodes in a weighted graph with non‑negative edge weights.
      It is widely used in routing, mapping, and network optimization.
    </p>

    <div class="panel">
      <h2>Key ideas</h2>
      <ul>
        <li>Maintain the best known (tentative) distance to each node, starting with 0 for the source and infinity for others.</li>
        <li>Repeatedly select the unvisited node with the smallest tentative distance.</li>
        <li>Relax its outgoing edges: if a shorter path to a neighbor is found, update that neighbor’s distance and predecessor.</li>
        <li>Stop when all nodes are visited or remaining nodes are unreachable.</li>
      </ul>
      <p class="muted">
        Requirements: edge weights must be non‑negative. With a binary heap/priority queue, time complexity is O((V + E) log V).
      </p>
    </div>

    <div class="panel">
      <h2>Pseudocode</h2>
      <pre><code>function dijkstra(G, source):
  for each vertex v in G:
    dist[v] := ∞
    prev[v] := undefined
  dist[source] := 0

  Q := set of all vertices
  while Q is not empty:
    u := vertex in Q with smallest dist[u]
    remove u from Q
    if dist[u] = ∞: break  // remaining vertices are unreachable

    for each edge (u, v) with weight w:
      alt := dist[u] + w
      if alt &lt; dist[v]:
        dist[v] := alt
        prev[v] := u

  return dist, prev</code></pre>
    </div>

    <div class="panel">
      <h2>Try it on a small graph</h2>
      <p>Undirected graph (non‑negative weights):</p>
      <ul class="edges">
        <li>A — B (4)</li>
        <li>A — C (2)</li>
        <li>B — C (1)</li>
        <li>B — D (5)</li>
        <li>C — D (8)</li>
        <li>C — E (10)</li>
        <li>D — E (2)</li>
      </ul>

      <div style="margin: 0.6rem 0;">
        <label for="source">Source</label>
        <select id="source"></select>

        <label for="target">Target</label>
        <select id="target"></select>

        <button id="run">Run Dijkstra</button>
      </div>

      <div id="output" class="result" aria-live="polite"></div>
    </div>

    <p class="muted">Tip: Try different source/target pairs to see how paths and distances change.</p>
  </div>

  <script>
    const graph = {
      A: [{ node: 'B', weight: 4 }, { node: 'C', weight: 2 }],
      B: [{ node: 'A', weight: 4 }, { node: 'C', weight: 1 }, { node: 'D', weight: 5 }],
      C: [{ node: 'A', weight: 2 }, { node: 'B', weight: 1 }, { node: 'D', weight: 8 }, { node: 'E', weight: 10 }],
      D: [{ node: 'B', weight: 5 }, { node: 'C', weight: 8 }, { node: 'E', weight: 2 }],
      E: [{ node: 'C', weight: 10 }, { node: 'D', weight: 2 }]
    };

    function dijkstra(g, source) {
      const nodes = Object.keys(g);
      const dist = Object.fromEntries(nodes.map(n => [n, Infinity]));
      const prev = Object.fromEntries(nodes.map(n => [n, null]));
      const unvisited = new Set(nodes);

      dist[source] = 0;

      while (unvisited.size) {
        // pick the unvisited node with smallest tentative distance
        let u = null;
        let best = Infinity;
        for (const v of unvisited) {
          if (dist[v] < best) { best = dist[v]; u = v; }
        }
        if (u === null || dist[u] === Infinity) break; // unreachable remainder

        unvisited.delete(u);

        for (const { node: v, weight: w } of g[u]) {
          if (!unvisited.has(v)) continue; // already finalized
          const alt = dist[u] + w;
          if (alt < dist[v]) {
            dist[v] = alt;
            prev[v] = u;
          }
        }
      }

      return { dist, prev };
    }

    function reconstructPath(prev, source, target) {
      const path = [];
      let cur = target;
      while (cur != null) {
        path.push(cur);
        if (cur === source) break;
        cur = prev[cur];
      }
      if (path[path.length - 1] !== source) return []; // no path
      return path.reverse();
    }

    function initUI() {
      const srcSel = document.getElementById('source');
      const tgtSel = document.getElementById('target');
      const output = document.getElementById('output');
      const runBtn = document.getElementById('run');
      const nodes = Object.keys(graph);

      for (const n of nodes) {
        const o1 = document.createElement('option'); o1.value = o1.textContent = n;
        const o2 = document.createElement('option'); o2.value = o2.textContent = n;
        srcSel.appendChild(o1);
        tgtSel.appendChild(o2);
      }
      srcSel.value = 'A';
      tgtSel.value = 'E';

      runBtn.addEventListener('click', () => {
        const source = srcSel.value;
        const target = tgtSel.value;
        const { dist, prev } = dijkstra(graph, source);
        const path = reconstructPath(prev, source, target);

        let lines = [];
        lines.push(`Source: ${source}`);
        lines.push('Shortest distances:');
        const ordered = Object.keys(dist).sort();
        for (const n of ordered) {
          lines.push(`  ${n}: ${Number.isFinite(dist[n]) ? dist[n] : 'unreachable'}`);
        }
        lines.push('');
        if (path.length) {
          lines.push(`Shortest path ${source} → ${target}: ${path.join(' → ')}`);
          lines.push(`Total distance: ${dist[target]}`);
        } else {
          lines.push(`No path found from ${source} to ${target}.`);
        }
        output.textContent = lines.join('\n');
      });

      // Run once on load for initial preview
      runBtn.click();
    }

    initUI();
  </script>
</body>
</html>