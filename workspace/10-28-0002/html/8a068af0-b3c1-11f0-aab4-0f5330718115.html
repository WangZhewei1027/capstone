<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Union-Find (Disjoint Set)</title>
  <style>
    :root {
      --bg: #f7f7fb;
      --panel: #ffffff;
      --border: #e2e6ea;
      --text: #1f2937;
      --muted: #56627a;
      --primary: #2563eb;
      --primary-weak: #e5efff;
      --chip: #eef2ff;
      --ok: #16a34a;
      --warn: #dc2626;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 24px;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.5;
    }
    .container {
      max-width: 960px;
      margin: 0 auto;
    }
    h1 { margin: 0 0 8px; font-size: 28px; }
    p { margin: 0 0 12px; color: var(--muted); }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      margin: 16px 0;
    }
    .controls { display: grid; gap: 12px; grid-template-columns: repeat(12, 1fr); align-items: end; }
    .controls .field { grid-column: span 3; }
    .controls .wide { grid-column: span 6; }
    label { display: block; font-size: 13px; color: var(--muted); margin-bottom: 6px; }
    input[type="number"] {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff;
      font-size: 14px;
    }
    button {
      appearance: none;
      border: none;
      background: var(--primary);
      color: #fff;
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
    }
    button.secondary { background: #475569; }
    button.ghost {
      background: transparent;
      color: var(--primary);
      border: 1px solid var(--primary);
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .sets { display: flex; flex-wrap: wrap; gap: 8px; }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: var(--chip);
      border: 1px solid var(--border);
      font-size: 13px;
    }
    .chip .root {
      background: var(--primary-weak);
      color: var(--primary);
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #cfe0ff;
      font-weight: 600;
    }
    .array {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px;
    }
    .cell {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      font-size: 13px;
    }
    .cell .idx { color: var(--muted); font-size: 12px; }
    .badge {
      display: inline-block;
      padding: 2px 6px;
      background: #f3f4f6;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 12px;
      margin-top: 4px;
      color: #374151;
    }
    .log {
      background: #0b1020;
      color: #cbd5e1;
      border-radius: 8px;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      max-height: 180px;
      overflow: auto;
      border: 1px solid #0f172a;
    }
    .log .ok { color: #86efac; }
    .log .warn { color: #fca5a5; }
    pre {
      background: #0b1020;
      color: #e5e7eb;
      border-radius: 8px;
      padding: 12px;
      overflow: auto;
      border: 1px solid #0f172a;
    }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .footer { color: var(--muted); font-size: 12px; margin-top: 8px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Union-Find (Disjoint Set)</h1>
    <p>
      Union-Find efficiently tracks a collection of disjoint sets, supporting two core operations:
      union(a, b) to merge sets, and find(x) to return a representative element (root) of x's set.
      With path compression and union by rank/size, operations run in near-constant amortized time.
    </p>

    <div class="panel">
      <div class="controls">
        <div class="field wide">
          <label for="nInput">Number of elements (0..n-1)</label>
          <input id="nInput" type="number" min="1" max="5000" value="10" />
        </div>
        <div class="field">
          <button id="initBtn">Initialize</button>
        </div>
        <div class="field">
          <button id="resetBtn" class="ghost">Reset</button>
        </div>

        <div class="field">
          <label for="unionA">Union: a</label>
          <input id="unionA" type="number" min="0" value="1" />
        </div>
        <div class="field">
          <label for="unionB">Union: b</label>
          <input id="unionB" type="number" min="0" value="2" />
        </div>
        <div class="field">
          <button id="unionBtn">Union(a, b)</button>
        </div>

        <div class="field">
          <label for="connA">Connected?: a</label>
          <input id="connA" type="number" min="0" value="1" />
        </div>
        <div class="field">
          <label for="connB">Connected?: b</label>
          <input id="connB" type="number" min="0" value="3" />
        </div>
        <div class="field">
          <button id="connBtn" class="secondary">Connected(a, b)</button>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3 style="margin-top:0">Current Sets</h3>
      <div id="setsView" class="sets"></div>
      <div class="footer">Each chip shows a set with its root and members.</div>
    </div>

    <div class="panel">
      <h3 style="margin-top:0">Internal State</h3>
      <p class="footer">Parent and rank arrays after path compression.</p>
      <div id="arraysView" class="array"></div>
    </div>

    <div class="panel">
      <h3 style="margin-top:0">Console</h3>
      <div id="log" class="log"></div>
    </div>

    <div class="panel">
      <h3 style="margin-top:0">Union-Find (JS) Implementation</h3>
      <pre><code>class UnionFind {
  constructor(n) {
    this.n = n;
    this.parent = Array.from({ length: n }, (_, i) =&gt; i);
    this.rank = Array(n).fill(0);
    this.count = n; // number of sets
  }
  find(x) {
    if (this.parent[x] !== x) {
      this.parent[x] = this.find(this.parent[x]); // path compression
    }
    return this.parent[x];
  }
  union(a, b) {
    let ra = this.find(a), rb = this.find(b);
    if (ra === rb) return false; // already same set
    // union by rank
    if (this.rank[ra] &lt; this.rank[rb]) {
      this.parent[ra] = rb;
    } else if (this.rank[ra] &gt; this.rank[rb]) {
      this.parent[rb] = ra;
    } else {
      this.parent[rb] = ra;
      this.rank[ra]++;
    }
    this.count--;
    return true;
  }
  connected(a, b) { return this.find(a) === this.find(b); }
  sets() {
    const groups = new Map();
    for (let i = 0; i &lt; this.n; i++) {
      const r = this.find(i);
      if (!groups.has(r)) groups.set(r, []);
      groups.get(r).push(i);
    }
    return [...groups.entries()].map(([root, members]) =&gt; ({ root, members }));
  }
}
</code></pre>
      <div class="footer">Amortized time per operation is near-constant (inverse Ackermann function).</div>
    </div>
  </div>

  <script>
    class UnionFind {
      constructor(n) {
        this.n = n;
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.rank = Array(n).fill(0);
        this.count = n;
      }
      find(x) {
        if (this.parent[x] !== x) {
          this.parent[x] = this.find(this.parent[x]);
        }
        return this.parent[x];
      }
      union(a, b) {
        const na = this._validIndex(a);
        const nb = this._validIndex(b);
        if (!na || !nb) return null;
        let ra = this.find(a), rb = this.find(b);
        if (ra === rb) return false;
        if (this.rank[ra] < this.rank[rb]) {
          this.parent[ra] = rb;
        } else if (this.rank[ra] > this.rank[rb]) {
          this.parent[rb] = ra;
        } else {
          this.parent[rb] = ra;
          this.rank[ra]++;
        }
        this.count--;
        return true;
      }
      connected(a, b) {
        const na = this._validIndex(a);
        const nb = this._validIndex(b);
        if (!na || !nb) return null;
        return this.find(a) === this.find(b);
      }
      sets() {
        const groups = new Map();
        for (let i = 0; i < this.n; i++) {
          const r = this.find(i);
          if (!groups.has(r)) groups.set(r, []);
          groups.get(r).push(i);
        }
        return [...groups.entries()].map(([root, members]) => ({ root, members }));
      }
      _validIndex(x) { return Number.isInteger(x) && x >= 0 && x < this.n; }
    }

    const els = {
      nInput: document.getElementById('nInput'),
      initBtn: document.getElementById('initBtn'),
      resetBtn: document.getElementById('resetBtn'),
      unionA: document.getElementById('unionA'),
      unionB: document.getElementById('unionB'),
      unionBtn: document.getElementById('unionBtn'),
      connA: document.getElementById('connA'),
      connB: document.getElementById('connB'),
      connBtn: document.getElementById('connBtn'),
      setsView: document.getElementById('setsView'),
      arraysView: document.getElementById('arraysView'),
      log: document.getElementById('log'),
    };

    let uf = null;

    function initUF(n) {
      const size = clampInt(n, 1, 5000) ?? 10;
      uf = new UnionFind(size);
      log(`Initialized UnionFind with n=${size}`);
      render();
      // update max for index inputs
      [els.unionA, els.unionB, els.connA, els.connB].forEach(inp => {
        inp.max = String(size - 1);
        inp.value = clampInt(parseInt(inp.value, 10), 0, size - 1) ?? 0;
      });
    }

    function clampInt(x, min, max) {
      if (!Number.isFinite(x)) return null;
      x = Math.floor(x);
      if (x < min || x > max) return null;
      return x;
    }

    function render() {
      if (!uf) return;
      // Sets
      els.setsView.innerHTML = '';
      const sets = uf.sets();
      if (sets.length === 0) {
        els.setsView.textContent = 'No elements.';
      } else {
        sets.sort((a, b) => a.root - b.root).forEach(set => {
          const chip = document.createElement('div');
          chip.className = 'chip';
          const root = document.createElement('span');
          root.className = 'root';
          root.textContent = `root ${set.root}`;
          const members = document.createElement('span');
          members.textContent = `members: ${set.members.join(', ')}`;
          chip.append(root, members);
          els.setsView.appendChild(chip);
        });
      }
      // Arrays
      els.arraysView.innerHTML = '';
      for (let i = 0; i < uf.n; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        const idx = document.createElement('div');
        idx.className = 'idx';
        idx.textContent = `index ${i}`;
        const parent = document.createElement('div');
        parent.textContent = `parent: ${uf.parent[i]}`;
        const badge = document.createElement('div');
        badge.className = 'badge';
        badge.textContent = `rank: ${uf.rank[i]}`;
        cell.append(idx, parent, badge);
        els.arraysView.appendChild(cell);
      }
    }

    function log(message, kind = 'info') {
      const line = document.createElement('div');
      if (kind === 'ok') line.className = 'ok';
      if (kind === 'warn') line.className = 'warn';
      const ts = new Date().toLocaleTimeString();
      line.textContent = `[${ts}] ${message}`;
      els.log.prepend(line);
    }

    // Event handlers
    els.initBtn.addEventListener('click', () => {
      const n = parseInt(els.nInput.value, 10);
      if (!Number.isFinite(n) || n < 1 || n > 5000) {
        log(`Invalid n. Please choose 1..5000.`, 'warn');
        return;
      }
      initUF(n);
    });

    els.resetBtn.addEventListener('click', () => {
      if (!uf) return;
      initUF(uf.n);
      log('Reset to all singleton sets.', 'ok');
    });

    els.unionBtn.addEventListener('click', () => {
      if (!uf) return;
      const a = parseInt(els.unionA.value, 10);
      const b = parseInt(els.unionB.value, 10);
      if (!uf._validIndex(a) || !uf._validIndex(b)) {
        log(`Union indices must be in 0..${uf.n - 1}.`, 'warn');
        return;
      }
      const result = uf.union(a, b);
      if (result === null) {
        log(`Union failed: invalid indices.`, 'warn');
      } else if (result === false) {
        log(`Union(${a}, ${b}) no-op: already in the same set.`);
      } else {
        log(`Union(${a}, ${b}) merged sets.`, 'ok');
      }
      render();
    });

    els.connBtn.addEventListener('click', () => {
      if (!uf) return;
      const a = parseInt(els.connA.value, 10);
      const b = parseInt(els.connB.value, 10);
      if (!uf._validIndex(a) || !uf._validIndex(b)) {
        log(`Connected indices must be in 0..${uf.n - 1}.`, 'warn');
        return;
      }
      const c = uf.connected(a, b);
      log(`Connected(${a}, ${b}) -> ${c ? 'true' : 'false'}`, c ? 'ok' : 'info');
      render();
    });

    // Initialize on load
    initUF(parseInt(els.nInput.value, 10));
  </script>
</body>
</html>