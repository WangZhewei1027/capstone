<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Linked List</title>
  <style>
    :root {
      --bg: #f8fafc;
      --fg: #0f172a;
      --muted: #475569;
      --accent: #2563eb;
      --accent-weak: #93c5fd;
      --border: #cbd5e1;
      --node-bg: #ffffff;
      --danger: #ef4444;
      --success: #16a34a;
    }
    * { box-sizing: border-box }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.6;
      color: var(--fg);
      background: var(--bg);
    }
    header {
      background: #0ea5e9;
      color: white;
      padding: 1.25rem 1rem;
    }
    header h1 {
      margin: 0 auto;
      max-width: 900px;
      font-size: 1.75rem;
      letter-spacing: 0.2px;
    }
    main {
      max-width: 900px;
      margin: 0 auto;
      padding: 1.25rem 1rem 2rem;
    }
    section + section { margin-top: 1.5rem }
    h2 { margin: 0 0 0.5rem }
    p { margin: 0.5rem 0 }
    ul { margin: 0.5rem 0 0.25rem 1.25rem }
    .note {
      color: var(--muted);
      font-size: 0.95rem;
    }

    /* Visualizer */
    .viz {
      margin-top: 1rem;
      padding: 0.75rem;
      background: #f1f5f9;
      border: 1px solid var(--border);
      border-radius: 10px;
    }
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr 1fr;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }
    .controls input[type="text"] {
      grid-column: span 2;
      padding: 0.5rem;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: white;
    }
    .controls button {
      padding: 0.5rem 0.6rem;
      border: 1px solid var(--border);
      background: white;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.15s;
      font-weight: 600;
      color: #0f172a;
    }
    .controls button:hover { background: #e2e8f0 }
    .controls button.primary {
      border-color: var(--accent-weak);
      background: #eaf2ff;
      color: #0b3bb1;
    }
    .list {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
      min-height: 60px;
    }
    .node {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      min-width: 60px;
      padding: 0.5rem 0.75rem;
      background: var(--node-bg);
      border: 2px solid var(--border);
      border-radius: 10px;
      position: relative;
      box-shadow: 0 1px 0 rgba(0,0,0,0.03);
      font-weight: 600;
    }
    .node::after {
      content: "next";
      position: absolute;
      bottom: -1.15rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: var(--muted);
    }
    .arrow {
      font-size: 1.25rem;
      color: var(--muted);
      user-select: none;
    }
    .null {
      padding: 0.4rem 0.6rem;
      border: 2px dashed #94a3b8;
      border-radius: 8px;
      color: #475569;
      background: #f8fafc;
      font-weight: 600;
    }
    .highlight {
      outline: 3px solid #fde68a;
      background: #fffbeb;
    }
    .found {
      outline: 3px solid #86efac;
      background: #f0fdf4;
    }
    .removed {
      outline: 3px solid #fecaca;
      background: #fff1f2;
    }
    .ops {
      font-size: 0.95rem;
      color: var(--muted);
      margin-top: 0.5rem;
    }
    @media (max-width: 640px) {
      .controls { grid-template-columns: 1fr 1fr; }
      .controls input[type="text"] { grid-column: span 2; }
    }
    code {
      background: #e2e8f0;
      padding: 0.1rem 0.3rem;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Linked List</h1>
  </header>
  <main>
    <section>
      <h2>Overview</h2>
      <p>A linked list is a linear data structure made up of nodes. Each node stores a value and a reference (the “next” pointer) to the next node. Unlike arrays, linked lists do not require contiguous memory; elements can be scattered, and the links connect them.</p>
      <ul>
        <li>Singly linked list: each node has a single pointer to the next node.</li>
        <li>Doubly linked list: nodes have pointers to both next and previous nodes.</li>
        <li>Circular linked list: the last node points back to the first node.</li>
      </ul>
      <p class="note">Because elements are linked by pointers, inserting or deleting at the head can be O(1), while random access like “give me index 42” is O(n).</p>
    </section>

    <section>
      <h2>Core Operations</h2>
      <ul>
        <li>Insert at head: add a new node that points to the current head; update head to the new node.</li>
        <li>Insert at tail: traverse to the end and link the new node there (or keep a tail pointer).</li>
        <li>Search: traverse nodes until the value is found.</li>
        <li>Delete: find the node (and its predecessor) and relink predecessor to skip the deleted node.</li>
      </ul>
      <p class="note">Typical time complexities: insert/delete at head O(1), insert/delete at tail O(n) without tail pointer, search O(n).</p>
    </section>

    <section class="viz" aria-label="Linked list visualizer">
      <div class="controls">
        <input id="valInput" type="text" placeholder="Value (e.g., 42)" aria-label="Node value" />
        <button id="headBtn" class="primary" type="button" aria-label="Insert at head">Insert Head</button>
        <button id="tailBtn" type="button" aria-label="Insert at tail">Insert Tail</button>
        <button id="searchBtn" type="button" aria-label="Search value">Search</button>
        <button id="delBtn" type="button" aria-label="Delete value">Delete</button>
      </div>
      <div id="list" class="list" role="list" aria-live="polite"></div>
      <div id="opsMsg" class="ops" aria-live="polite"></div>
    </section>

    <section>
      <h2>Advantages</h2>
      <ul>
        <li>Efficient insertions/deletions at known positions (especially head).</li>
        <li>Dynamic size; no need to pre-allocate contiguous memory.</li>
      </ul>
      <h2>Disadvantages</h2>
      <ul>
        <li>No constant-time random access; must traverse.</li>
        <li>Extra memory for pointers; potential cache inefficiency.</li>
      </ul>
    </section>
  </main>

  <script>
    (function () {
      const listEl = document.getElementById('list');
      const opsMsg = document.getElementById('opsMsg');
      const input = document.getElementById('valInput');
      const headBtn = document.getElementById('headBtn');
      const tailBtn = document.getElementById('tailBtn');
      const searchBtn = document.getElementById('searchBtn');
      const delBtn = document.getElementById('delBtn');

      // We simulate a singly linked list with an array for visualization purposes.
      /** @type {string[]} */
      let list = [];

      function escapeHTML(str) {
        return String(str).replace(/[&<>"']/g, s => ({
          '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
        }[s]));
      }

      function render(opts = {}) {
        const { highlightIndex = null, foundIndex = null, removedIndex = null } = opts;
        // Build the visualization with nodes and arrows, ending at null
        let html = '';
        if (list.length === 0) {
          html = '<div class="null">null</div>';
        } else {
          list.forEach((val, idx) => {
            const classes = ['node'];
            if (highlightIndex === idx) classes.push('highlight');
            if (foundIndex === idx) classes.push('found');
            if (removedIndex === idx) classes.push('removed');
            html += `<div role="listitem" class="${classes.join(' ')}">${escapeHTML(val)}</div>`;
            html += idx === list.length - 1
              ? '<div class="arrow" aria-hidden="true">→</div><div class="null">null</div>'
              : '<div class="arrow" aria-hidden="true">→</div>';
          });
        }
        listEl.innerHTML = html;
      }

      function setMsg(text) {
        opsMsg.textContent = text;
      }

      function valOrHint() {
        const v = input.value.trim();
        if (!v) {
          setMsg('Enter a value in the input first.');
          input.focus();
          return null;
        }
        return v;
      }

      headBtn.addEventListener('click', () => {
        const v = valOrHint();
        if (v == null) return;
        list.unshift(v);
        render({ highlightIndex: 0 });
        setMsg(`Inserted "${v}" at head.`);
        input.select();
      });

      tailBtn.addEventListener('click', () => {
        const v = valOrHint();
        if (v == null) return;
        list.push(v);
        render({ highlightIndex: list.length - 1 });
        setMsg(`Inserted "${v}" at tail.`);
        input.select();
      });

      searchBtn.addEventListener('click', () => {
        const v = valOrHint();
        if (v == null) return;
        const idx = list.indexOf(v);
        if (idx === -1) {
          render();
          setMsg(`Value "${v}" not found (O(n) traversal).`);
        } else {
          render({ foundIndex: idx });
          setMsg(`Found "${v}" at position ${idx} (0-based).`);
        }
        input.select();
      });

      delBtn.addEventListener('click', () => {
        const v = valOrHint();
        if (v == null) return;
        const idx = list.indexOf(v);
        if (idx === -1) {
          render();
          setMsg(`Cannot delete: "${v}" not found.`);
        } else {
          // Simulate deletion by removing the element and relinking
          list.splice(idx, 1);
          render({ removedIndex: idx });
          setMsg(`Deleted "${v}" and relinked list.`);
        }
        input.select();
      });

      // Initial render
      render();
    })();
  </script>
</body>
</html>