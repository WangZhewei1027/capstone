<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Counting Sort</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 20px; line-height: 1.5; }
    h1 { font-size: 1.6rem; margin-bottom: 0.5rem; }
    .container { max-width: 800px; margin: 0 auto; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; margin: 12px 0; }
    input[type="text"] { flex: 1 1 400px; padding: 8px; font-size: 1rem; }
    button { padding: 8px 12px; font-size: 0.95rem; cursor: pointer; }
    label { display: inline-flex; align-items: center; gap: 6px; font-size: 0.95rem; }
    .note { color: #444; font-size: 0.95rem; }
    .error { color: #b00020; font-weight: 600; }
    .section { margin-top: 14px; }
    .pill { display: inline-block; background: #f3f4f6; padding: 6px 10px; border-radius: 999px; margin: 4px 4px 0 0; }
    .muted { color: #666; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 6px; }
    .card { border: 1px solid #e5e7eb; border-radius: 8px; padding: 8px; }
    .small { font-size: 0.9rem; }
    .footer { margin-top: 24px; color: #555; font-size: 0.9rem; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Counting Sort</h1>
    <p class="note">
      Counting sort is a stable, linear-time sorting algorithm for integers when the range of values is not too large.
      It counts occurrences of each value, builds cumulative counts, then places elements into the result.
      Time: O(n + k), Space: O(n + k), where n is number of elements and k is the value range size.
    </p>

    <div class="controls">
      <input id="numbersInput" type="text" placeholder="Enter integers separated by commas (e.g., 4, 2, 7, 3, 3, 0, -1)" />
      <button id="sortBtn">Sort (Counting Sort)</button>
      <button id="randomBtn">Random</button>
      <label><input id="showSteps" type="checkbox" /> Show steps</label>
    </div>
    <div id="error" class="error" role="alert" aria-live="polite"></div>

    <div class="section">
      <div><strong>Original array:</strong></div>
      <div id="original" aria-live="polite"></div>
    </div>

    <div class="section">
      <div><strong>Sorted array:</strong></div>
      <div id="sorted" aria-live="polite"></div>
    </div>

    <div id="stepsContainer" class="section" style="display:none;">
      <div class="grid">
        <div class="card">
          <div><strong>Range</strong></div>
          <div id="range" class="small muted"></div>
        </div>
        <div class="card">
          <div><strong>Counts (frequency)</strong></div>
          <div id="counts"></div>
        </div>
        <div class="card">
          <div><strong>Cumulative counts</strong></div>
          <div id="cumulative"></div>
        </div>
      </div>
    </div>

    <div class="footer">
      Tip: Counting sort can handle negative numbers by offsetting indices using the minimum value.
    </div>
  </div>

  <script>
    const inputEl = document.getElementById('numbersInput');
    const sortBtn = document.getElementById('sortBtn');
    const randomBtn = document.getElementById('randomBtn');
    const showStepsEl = document.getElementById('showSteps');
    const errorEl = document.getElementById('error');
    const originalEl = document.getElementById('original');
    const sortedEl = document.getElementById('sorted');
    const stepsContainerEl = document.getElementById('stepsContainer');
    const rangeEl = document.getElementById('range');
    const countsEl = document.getElementById('counts');
    const cumulativeEl = document.getElementById('cumulative');

    // Initialize with a demo array
    inputEl.value = "4, 2, 7, 3, 3, 0, -1, 2, 7";

    function parseNumbers(str) {
      const parts = str.split(/[\s,]+/).filter(Boolean);
      if (parts.length === 0) return [];
      const arr = [];
      for (const p of parts) {
        if (!/^[-+]?\d+$/.test(p)) {
          throw new Error(`Invalid integer: "${p}"`);
        }
        arr.push(Number(p));
      }
      return arr;
    }

    function countingSort(arr) {
      const n = arr.length;
      if (n === 0) {
        return { result: [], min: 0, max: 0, counts: [], cumulative: [] };
      }

      let min = arr[0], max = arr[0];
      for (let i = 1; i < n; i++) {
        const v = arr[i];
        if (v < min) min = v;
        if (v > max) max = v;
      }

      const range = max - min + 1;
      const counts = new Array(range).fill(0);
      for (let i = 0; i < n; i++) {
        counts[arr[i] - min]++;
      }

      const cumulative = counts.slice();
      for (let i = 1; i < cumulative.length; i++) {
        cumulative[i] += cumulative[i - 1];
      }

      const result = new Array(n);
      // Stable placement: iterate from end to start
      for (let i = n - 1; i >= 0; i--) {
        const idx = arr[i] - min;
        cumulative[idx]--;
        const pos = cumulative[idx];
        result[pos] = arr[i];
      }

      return { result, min, max, counts, cumulative };
    }

    function renderArray(el, arr) {
      if (!arr || arr.length === 0) {
        el.innerHTML = '<span class="muted">[empty]</span>';
        return;
      }
      el.innerHTML = arr.map(v => `<span class="pill">${v}</span>`).join(' ');
    }

    function renderCounts(el, counts, min) {
      if (!counts || counts.length === 0) {
        el.innerHTML = '<span class="muted small">n/a</span>';
        return;
      }
      el.innerHTML = counts.map((c, i) => {
        const val = i + min;
        return `<div class="small pill">${val}: ${c}</div>`;
      }).join(' ');
    }

    function handleSort() {
      errorEl.textContent = '';
      stepsContainerEl.style.display = showStepsEl.checked ? 'block' : 'none';

      let arr;
      try {
        arr = parseNumbers(inputEl.value);
      } catch (e) {
        errorEl.textContent = e.message;
        renderArray(originalEl, []);
        renderArray(sortedEl, []);
        rangeEl.textContent = '';
        countsEl.innerHTML = '';
        cumulativeEl.innerHTML = '';
        return;
      }

      renderArray(originalEl, arr);

      const { result, min, max, counts, cumulative } = countingSort(arr);
      renderArray(sortedEl, result);

      if (showStepsEl.checked && arr.length > 0) {
        rangeEl.textContent = `min = ${min}, max = ${max}, size = ${max - min + 1}`;
        renderCounts(countsEl, counts, min);
        renderCounts(cumulativeEl, cumulative, min);
        // Simple advisory if range is large
        const rangeSize = max - min + 1;
        if (rangeSize > 50000) {
          rangeEl.textContent += " â€” Warning: large range may be memory-intensive.";
        }
      }
    }

    function handleRandom() {
      errorEl.textContent = '';
      const len = Math.floor(Math.random() * 8) + 8; // 8..15
      const min = Math.floor(Math.random() * 21) - 10; // -10..10
      const max = min + Math.floor(Math.random() * 11) + 5; // ensure modest range
      const arr = [];
      for (let i = 0; i < len; i++) {
        arr.push(Math.floor(Math.random() * (max - min + 1)) + min);
      }
      inputEl.value = arr.join(', ');
      handleSort();
    }

    sortBtn.addEventListener('click', handleSort);
    randomBtn.addEventListener('click', handleRandom);
    showStepsEl.addEventListener('change', () => {
      // Re-render steps if already sorted
      if (sortedEl.innerHTML.trim()) handleSort();
    });

    // Auto-run once
    handleSort();
  </script>
</body>
</html>