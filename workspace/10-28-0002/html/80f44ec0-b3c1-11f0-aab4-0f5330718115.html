<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Adjacency List</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 2rem; line-height: 1.5; }
    h1 { margin: 0 0 0.5rem 0; font-size: 1.6rem; }
    p { margin: 0.5rem 0 1rem 0; max-width: 70ch; }
    .panel { display: grid; gap: 0.75rem; max-width: 800px; }
    textarea { width: 100%; min-height: 160px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding: 0.5rem; resize: vertical; }
    .controls { display: flex; flex-wrap: wrap; gap: 0.5rem 1rem; align-items: center; }
    button { cursor: pointer; padding: 0.5rem 0.8rem; border: 1px solid #888; border-radius: 6px; background: transparent; }
    label { display: inline-flex; align-items: center; gap: 0.5rem; user-select: none; }
    .output { display: grid; gap: 0.5rem; margin-top: 1rem; }
    .box { border: 1px solid #ccc; border-radius: 8px; padding: 0.75rem; overflow: auto; }
    .subtitle { font-weight: 600; margin: 0.25rem 0 0.5rem; }
    ul { padding-left: 1.25rem; }
    code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size: 0.9rem; color: #666; }
  </style>
</head>
<body>
  <h1>Adjacency List</h1>
  <p>
    An adjacency list represents a graph by listing each node and the set of nodes it connects to.
    Enter edges below (one per line) and build the adjacency list. Use formats like
    “A B”, “A,B”, or “A-&gt;B”.
  </p>

  <div class="panel">
    <textarea id="edges" placeholder="Example (one edge per line):
A B
A C
B D
C D"></textarea>

    <div class="controls">
      <label><input type="checkbox" id="directed"> Directed graph</label>
      <button id="exampleBtn" type="button">Load example</button>
      <button id="buildBtn" type="button">Build adjacency list</button>
      <button id="clearBtn" type="button">Clear</button>
    </div>

    <div class="output" id="output" hidden>
      <div class="box">
        <div class="subtitle">Text view</div>
        <div id="textView"></div>
      </div>
      <div class="box">
        <div class="subtitle">JSON</div>
        <pre id="jsonView"></pre>
      </div>
      <div class="small">Tip: Sorts nodes alphabetically and removes duplicate edges automatically.</div>
    </div>
  </div>

  <script>
    const edgesEl = document.getElementById('edges');
    const directedEl = document.getElementById('directed');
    const buildBtn = document.getElementById('buildBtn');
    const exampleBtn = document.getElementById('exampleBtn');
    const clearBtn = document.getElementById('clearBtn');
    const outputEl = document.getElementById('output');
    const textViewEl = document.getElementById('textView');
    const jsonViewEl = document.getElementById('jsonView');

    function normalizeToken(s) {
      return s.trim();
    }

    function parseEdges(text) {
      const edges = [];
      const lines = text.split(/\r?\n/);
      for (let raw of lines) {
        let line = raw.trim();
        if (!line) continue;

        // Normalize separators: spaces, commas, arrows, hyphens
        line = line.replace(/[,]|->|—|–|-/g, ' ');
        const parts = line.split(/\s+/).filter(Boolean);

        if (parts.length >= 2) {
          const u = normalizeToken(parts[0]);
          const v = normalizeToken(parts[1]);
          if (u && v) edges.push([u, v]);
        }
      }
      return edges;
    }

    function buildAdjacencyList(edges, directed = false) {
      const adj = new Map();

      function addNode(n) {
        if (!adj.has(n)) adj.set(n, new Set());
      }

      for (const [u, v] of edges) {
        addNode(u);
        addNode(v);
        adj.get(u).add(v);
        if (!directed) {
          adj.get(v).add(u);
        }
      }

      // Convert to sorted arrays
      const obj = {};
      const nodes = Array.from(adj.keys()).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
      for (const n of nodes) {
        obj[n] = Array.from(adj.get(n)).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
      }
      return obj;
    }

    function renderTextView(adjObj) {
      const container = document.createElement('div');
      const ul = document.createElement('ul');
      for (const node of Object.keys(adjObj)) {
        const li = document.createElement('li');
        const neighbors = adjObj[node];
        li.textContent = `${node}: ${neighbors.join(', ')}`;
        ul.appendChild(li);
      }
      container.appendChild(ul);
      return container;
    }

    function renderJSON(adjObj) {
      return JSON.stringify(adjObj, null, 2);
    }

    function build() {
      const edges = parseEdges(edgesEl.value);
      const directed = directedEl.checked;
      const adj = buildAdjacencyList(edges, directed);

      textViewEl.innerHTML = '';
      textViewEl.appendChild(renderTextView(adj));
      jsonViewEl.textContent = renderJSON(adj);

      outputEl.hidden = false;
    }

    function loadExample() {
      edgesEl.value = [
        'A B',
        'A C',
        'B D',
        'C D',
        'C E',
        'D F',
        'E F',
        'F G'
      ].join('\n');
      directedEl.checked = false;
      build();
    }

    function clearAll() {
      edgesEl.value = '';
      directedEl.checked = false;
      outputEl.hidden = true;
      textViewEl.innerHTML = '';
      jsonViewEl.textContent = '';
    }

    buildBtn.addEventListener('click', build);
    exampleBtn.addEventListener('click', loadExample);
    clearBtn.addEventListener('click', clearAll);

    // Initialize with a small example for convenience
    loadExample();
  </script>
</body>
</html>