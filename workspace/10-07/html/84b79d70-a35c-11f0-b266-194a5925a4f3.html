<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Bubble Sort Visualizer</title>
    <style>
      :root {
        --bg: #0f172a;
        --panel: #111827;
        --text: #e5e7eb;
        --muted: #9ca3af;
        --accent: #60a5fa;
        --bar: #4f46e5;
        --compare: #f59e0b;
        --swap: #ef4444;
        --sorted: #10b981;
        --pass-boundary: rgba(255, 255, 255, 0.07);
        --btn: #1f2937;
        --btn-hover: #374151;
        --good: #34d399;
        --bad: #f87171;
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: radial-gradient(
          1200px 700px at 80% -10%,
          #1f2937 0%,
          #0b1224 45%,
          #0b1020 100%
        );
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial,
          "Apple Color Emoji", "Segoe UI Emoji";
        line-height: 1.35;
      }

      header {
        padding: 24px 18px 4px;
        text-align: center;
      }
      h1 {
        margin: 0 0 8px;
        font-size: clamp(22px, 3.2vw, 36px);
        font-weight: 800;
        letter-spacing: 0.2px;
        background: linear-gradient(
          135deg,
          #93c5fd 0%,
          #d8b4fe 40%,
          #fca5a5 100%
        );
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }
      .subtitle {
        color: var(--muted);
        font-size: 14px;
        margin-bottom: 12px;
      }
      .app {
        max-width: 1100px;
        margin: 0 auto;
        padding: 12px 16px 42px;
      }

      .controls {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.03),
          rgba(255, 255, 255, 0.01)
        );
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 14px;
        padding: 14px 14px 8px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 860px) {
        .controls {
          grid-template-columns: 1.1fr 1fr;
        }
      }

      .row {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      .row .spacer {
        flex: 1;
      }
      .group {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      .label {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 2px;
      }
      .slider-wrap {
        min-width: 220px;
      }
      input[type="range"] {
        appearance: none;
        width: 220px;
        height: 8px;
        background: #1f2937;
        border-radius: 999px;
        outline: none;
      }
      input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: linear-gradient(135deg, #93c5fd, #d8b4fe);
        border: 2px solid #0f172a;
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.4);
        cursor: pointer;
      }

      .btn {
        background: var(--btn);
        color: var(--text);
        border: 1px solid rgba(255, 255, 255, 0.12);
        padding: 9px 12px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
        letter-spacing: 0.2px;
        transition: background 0.12s, transform 0.06s, border-color 0.12s;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      .btn:hover {
        background: var(--btn-hover);
      }
      .btn:active {
        transform: translateY(1px);
      }
      .btn.primary {
        background: linear-gradient(135deg, #60a5fa, #a78bfa);
        border-color: rgba(255, 255, 255, 0.18);
        color: #0b1020;
      }
      .btn.warn {
        background: linear-gradient(135deg, #f87171, #fb923c);
        color: #160b0b;
        border-color: rgba(255, 255, 255, 0.2);
      }
      .btn.ghost {
        background: transparent;
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .input {
        background: #0b1220;
        color: var(--text);
        border: 1px solid rgba(255, 255, 255, 0.12);
        padding: 9px 12px;
        border-radius: 10px;
        min-width: 260px;
        max-width: 100%;
        outline: none;
      }
      .input::placeholder {
        color: #6b7280;
      }

      .board {
        margin-top: 16px;
        display: grid;
        grid-template-columns: 2.2fr 1fr;
        gap: 14px;
      }
      @media (max-width: 860px) {
        .board {
          grid-template-columns: 1fr;
        }
      }

      .panel {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.03),
          rgba(255, 255, 255, 0.01)
        );
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 14px;
        padding: 14px;
      }

      .bars-wrap {
        height: 360px;
        position: relative;
        overflow: hidden;
        border-radius: 10px;
        background: linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.03),
            rgba(255, 255, 255, 0.01)
          ),
          radial-gradient(
            800px 300px at -10% 110%,
            rgba(96, 165, 250, 0.08),
            transparent 50%
          ),
          radial-gradient(
            800px 300px at 110% -10%,
            rgba(167, 139, 250, 0.08),
            transparent 50%
          );
        border: 1px dashed rgba(255, 255, 255, 0.08);
      }
      .bars {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: flex-end;
        gap: 4px;
        padding: 10px 12px 12px;
      }
      .bar {
        flex: 1 1 auto;
        background: var(--bar);
        border-radius: 6px 6px 2px 2px;
        position: relative;
        transition: height 160ms ease, background 120ms ease,
          transform 120ms ease;
      }
      .bar::after {
        content: attr(data-val);
        position: absolute;
        bottom: calc(100% + 4px);
        left: 50%;
        transform: translateX(-50%);
        font-size: 11px;
        color: var(--muted);
        opacity: 0.9;
        white-space: nowrap;
        pointer-events: none;
      }
      .bar.compare {
        background: var(--compare);
      }
      .bar.swap {
        background: var(--swap);
      }
      .bar.sorted {
        background: var(--sorted);
      }
      .pass-overlay {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        pointer-events: none;
      }
      .boundary {
        position: absolute;
        top: 0;
        bottom: 0;
        right: 0;
        background: linear-gradient(90deg, transparent, var(--pass-boundary));
      }

      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 8px;
        color: var(--muted);
        font-size: 12px;
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(255, 255, 255, 0.03);
      }
      .dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
      }
      .dot.bar {
        background: var(--bar);
      }
      .dot.compare {
        background: var(--compare);
      }
      .dot.swap {
        background: var(--swap);
      }
      .dot.sorted {
        background: var(--sorted);
      }
      .dot.boundary {
        background: var(--pass-boundary);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin-top: 4px;
      }
      @media (min-width: 540px) {
        .stats {
          grid-template-columns: repeat(4, 1fr);
        }
      }
      .stat {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 10px;
        border-radius: 10px;
      }
      .stat .k {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
      }
      .stat .v {
        font-size: 18px;
        font-weight: 800;
        letter-spacing: 0.2px;
      }

      .code {
        background: #0b1220;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        padding: 10px 12px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 13px;
        color: #d1d5db;
      }
      .code ol {
        margin: 0;
        padding-left: 18px;
      }
      .code li {
        padding: 2px 8px;
        border-radius: 6px;
      }
      .code li.hl {
        background: rgba(96, 165, 250, 0.15);
        color: #e5efff;
      }

      .note {
        margin-top: 10px;
        color: var(--muted);
        font-size: 12px;
      }
      .badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 999px;
        background: rgba(16, 185, 129, 0.18);
        color: #a7f3d0;
        border: 1px solid rgba(16, 185, 129, 0.3);
        font-weight: 700;
        font-size: 11px;
        letter-spacing: 0.3px;
        vertical-align: middle;
      }
      .error {
        color: var(--bad);
        font-weight: 700;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Bubble Sort Visualizer</h1>
      <div class="subtitle">
        Step through and watch how the largest elements bubble to the end on
        each pass.
      </div>
    </header>

    <div class="app">
      <div class="controls">
        <div class="row">
          <div class="group">
            <button id="randomBtn" class="btn">Randomize</button>
            <button id="resetBtn" class="btn">Reset</button>
            <span id="status" class="badge" title="Status">READY</span>
          </div>
          <div class="spacer"></div>
          <div class="group">
            <button id="startBtn" class="btn primary">Start</button>
            <button id="pauseBtn" class="btn">Pause</button>
            <button id="stepBtn" class="btn">Step</button>
          </div>
        </div>

        <div class="row">
          <div class="slider-wrap">
            <div class="label">Size: <span id="sizeVal">25</span></div>
            <input
              id="size"
              type="range"
              min="5"
              max="75"
              step="1"
              value="25"
            />
          </div>
          <div class="slider-wrap">
            <div class="label">Speed: <span id="speedVal">Medium</span></div>
            <input
              id="speed"
              type="range"
              min="1"
              max="100"
              step="1"
              value="60"
            />
          </div>
          <div class="group" style="flex: 1">
            <input
              id="arrayInput"
              class="input"
              placeholder="Enter numbers (e.g., 5,1,4,2,8)"
            />
            <button id="loadBtn" class="btn">Load</button>
          </div>
        </div>
      </div>

      <div class="board">
        <div class="panel">
          <div class="bars-wrap">
            <div class="bars" id="bars"></div>
            <div class="pass-overlay">
              <div id="boundary" class="boundary" style="width: 0%"></div>
            </div>
          </div>
          <div class="legend">
            <span class="chip"><span class="dot bar"></span> Unsorted</span>
            <span class="chip"
              ><span class="dot compare"></span> Comparing</span
            >
            <span class="chip"><span class="dot swap"></span> Swapping</span>
            <span class="chip"><span class="dot sorted"></span> Sorted</span>
            <span class="chip"
              ><span class="dot boundary"></span> Completed region</span
            >
          </div>
          <div class="stats">
            <div class="stat">
              <div class="k">Pass</div>
              <div id="statPass" class="v">0</div>
            </div>
            <div class="stat">
              <div class="k">Comparisons</div>
              <div id="statComp" class="v">0</div>
            </div>
            <div class="stat">
              <div class="k">Swaps</div>
              <div id="statSwap" class="v">0</div>
            </div>
            <div class="stat">
              <div class="k">Array Size</div>
              <div id="statSize" class="v">0</div>
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="label" style="margin-bottom: 6px">
            Bubble Sort (optimized with early exit)
          </div>
          <div class="code">
            <ol id="code">
              <li data-line="1">function bubbleSort(A):</li>
              <li data-line="2">n = length(A)</li>
              <li data-line="3">repeat</li>
              <li data-line="4">swapped = false</li>
              <li data-line="5">for i from 0 to n-2:</li>
              <li data-line="6">if A[i] > A[i+1]:</li>
              <li data-line="7">swap(A[i], A[i+1])</li>
              <li data-line="8">swapped = true</li>
              <li data-line="9">n = n - 1</li>
              <li data-line="10">until swapped == false</li>
            </ol>
          </div>

          <div class="note">
            - Stable, in-place sorting algorithm<br />
            - Worst/average time: O(n²), Best (nearly sorted): O(n) with early
            exit<br />
            - Each pass places the next largest item at the end of the array
          </div>
        </div>
      </div>
    </div>

    <script>
      (function () {
        // DOM helpers
        const $ = (sel) => document.querySelector(sel);
        const barsEl = $("#bars");
        const boundaryEl = $("#boundary");

        const startBtn = $("#startBtn");
        const pauseBtn = $("#pauseBtn");
        const stepBtn = $("#stepBtn");
        const resetBtn = $("#resetBtn");
        const randomBtn = $("#randomBtn");
        const loadBtn = $("#loadBtn");

        const sizeInput = $("#size");
        const speedInput = $("#speed");
        const sizeVal = $("#sizeVal");
        const speedVal = $("#speedVal");
        const arrayInput = $("#arrayInput");

        const statPass = $("#statPass");
        const statComp = $("#statComp");
        const statSwap = $("#statSwap");
        const statSize = $("#statSize");

        const statusBadge = $("#status");

        const codeBlock = $("#code");
        const codeLines = [...codeBlock.querySelectorAll("li")];

        // State
        let arr = [];
        let initialArr = [];
        let sorting = false;
        let playing = false;
        let pass = 0;
        let comparisons = 0;
        let swaps = 0;
        let runId = 0; // cancellation token
        let stepResolver = null;
        let speedMs = 100; // delay per step
        let lastBoundary = 0; // right-finished region size

        // Utilities
        const clamp = (n, min, max) => Math.max(min, Math.min(max, n));

        function setStatus(text, colorClass) {
          statusBadge.textContent = text;
          statusBadge.style.background = "";
          statusBadge.style.borderColor = "";
          statusBadge.style.color = "";
          if (colorClass === "run") {
            statusBadge.style.background = "rgba(96,165,250,0.18)";
            statusBadge.style.borderColor = "rgba(96,165,250,0.32)";
            statusBadge.style.color = "#bfdbfe";
          } else if (colorClass === "ok") {
            statusBadge.style.background = "rgba(16,185,129,0.18)";
            statusBadge.style.borderColor = "rgba(16,185,129,0.32)";
            statusBadge.style.color = "#a7f3d0";
          } else if (colorClass === "warn") {
            statusBadge.style.background = "rgba(251,146,60,0.18)";
            statusBadge.style.borderColor = "rgba(251,146,60,0.32)";
            statusBadge.style.color = "#fed7aa";
          } else if (colorClass === "err") {
            statusBadge.style.background = "rgba(239,68,68,0.18)";
            statusBadge.style.borderColor = "rgba(239,68,68,0.32)";
            statusBadge.style.color = "#fecaca";
          }
        }

        function mapSpeedToMs(v) {
          // v in [1..100], 1 = slowest, 100 = fastest
          // Map to [700..15] ms with ease-out curve
          const t = v / 100;
          const eased = 1 - Math.pow(1 - t, 2); // quadratic ease-out
          return Math.round(700 - eased * (700 - 15));
        }

        function speedLabel(v) {
          if (v <= 20) return "Very Slow";
          if (v <= 40) return "Slow";
          if (v <= 60) return "Medium";
          if (v <= 80) return "Fast";
          return "Very Fast";
        }

        function highlightCode(lines) {
          codeLines.forEach((li) => li.classList.remove("hl"));
          lines.forEach((n) => {
            const li = codeLines.find((l) => Number(l.dataset.line) === n);
            if (li) li.classList.add("hl");
          });
        }

        // Array and visualization
        function randomArray(n) {
          const out = [];
          for (let i = 0; i < n; i++) {
            // values between 5 and 100
            out.push(5 + Math.floor(Math.random() * 96));
          }
          return out;
        }

        function renderBars(values, active = {}) {
          const maxVal = Math.max(...values, 1);
          const h = barsEl.clientHeight || 340;
          const scale = (h - 30) / maxVal; // leave room for labels
          barsEl.innerHTML = "";
          for (let i = 0; i < values.length; i++) {
            const bar = document.createElement("div");
            bar.className = "bar";
            bar.style.height =
              Math.max(2, Math.round(values[i] * scale)) + "px";
            bar.dataset.val = values[i];
            if (
              active.compare &&
              (i === active.compare[0] || i === active.compare[1])
            )
              bar.classList.add("compare");
            if (active.swap && (i === active.swap[0] || i === active.swap[1]))
              bar.classList.add("swap");
            if (active.sorted && i >= active.sorted.from)
              bar.classList.add("sorted");
            barsEl.appendChild(bar);
          }
        }

        function updateBars(values, active = {}) {
          // update in place to allow CSS transitions
          const nodes = barsEl.children;
          const maxVal = Math.max(...values, 1);
          const h = barsEl.clientHeight || 340;
          const scale = (h - 30) / maxVal;
          for (let i = 0; i < values.length; i++) {
            const bar = nodes[i];
            bar.style.height =
              Math.max(2, Math.round(values[i] * scale)) + "px";
            bar.dataset.val = values[i];
            bar.classList.toggle(
              "compare",
              !!(
                active.compare &&
                (i === active.compare[0] || i === active.compare[1])
              )
            );
            bar.classList.toggle(
              "swap",
              !!(active.swap && (i === active.swap[0] || i === active.swap[1]))
            );
            bar.classList.toggle(
              "sorted",
              !!(active.sorted && i >= active.sorted.from)
            );
          }
        }

        function setBoundary(endIndexExclusive) {
          // Right side completed width: portion of array already sorted at end
          const n = arr.length;
          const done = n - endIndexExclusive;
          const pct = clamp((done / n) * 100, 0, 100);
          boundaryEl.style.width = pct.toFixed(2) + "%";
        }

        function resetStats() {
          pass = 0;
          comparisons = 0;
          swaps = 0;
          lastBoundary = 0;
          statPass.textContent = pass;
          statComp.textContent = comparisons;
          statSwap.textContent = swaps;
          statSize.textContent = arr.length;
        }

        function setButtons() {
          startBtn.disabled = sorting && playing;
          pauseBtn.disabled = !sorting || !playing;
          stepBtn.disabled = sorting && playing ? false : false; // allow step anytime; it will pause if needed
          resetBtn.disabled = false;
        }

        function cancelCurrentRun() {
          runId++;
          sorting = false;
          playing = false;
          if (stepResolver) {
            try {
              stepResolver();
            } catch {}
            stepResolver = null;
          }
          setButtons();
        }

        function sleepOrStep() {
          const myRun = runId;
          return new Promise((resolve) => {
            if (myRun !== runId) return resolve(); // cancelled
            if (playing) {
              setTimeout(() => {
                resolve();
              }, speedMs);
            } else {
              // wait for step
              stepResolver = () => {
                resolve();
                stepResolver = null;
              };
            }
          });
        }

        // Sorting
        async function bubbleSortVisual() {
          const myRun = ++runId;
          sorting = true;
          playing = true;
          setStatus("RUNNING", "run");
          setButtons();
          highlightCode([1, 2]);

          let n = arr.length;
          setBoundary(n); // 0% sorted
          renderBars(arr, { sorted: { from: n } }); // no sorted initially

          await sleepOrStep();
          while (true) {
            if (myRun !== runId) return; // cancelled
            pass++;
            statPass.textContent = pass;
            highlightCode([3, 4]);
            let swapped = false;

            // Inner loop
            highlightCode([5]);
            for (let i = 0; i < n - 1; i++) {
              if (myRun !== runId) return;
              // compare
              highlightCode([5, 6]);
              updateBars(arr, { compare: [i, i + 1], sorted: { from: n } });
              await sleepOrStep();
              comparisons++;
              statComp.textContent = comparisons;

              if (arr[i] > arr[i + 1]) {
                // swap
                highlightCode([6, 7, 8]);
                [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
                swaps++;
                statSwap.textContent = swaps;
                updateBars(arr, { swap: [i, i + 1], sorted: { from: n } });
                await sleepOrStep();
                swapped = true;
              }

              // clear compare/swap for next step but keep sorted overlay
              updateBars(arr, { sorted: { from: n } });
            }

            // one element settled to the end
            n = n - 1;
            highlightCode([9]);
            setBoundary(n);
            updateBars(arr, { sorted: { from: n } });
            await sleepOrStep();

            // early exit
            highlightCode([10]);
            if (!swapped) {
              // mark all as sorted
              setBoundary(0);
              updateBars(arr, { sorted: { from: 0 } });
              break;
            }

            if (n <= 1) {
              // fully sorted
              setBoundary(0);
              updateBars(arr, { sorted: { from: 0 } });
              break;
            }
          }

          sorting = false;
          playing = false;
          setButtons();
          setStatus("DONE", "ok");
        }

        // Input parsing
        function parseArrayInput(text) {
          const parts = text.split(/[\s,]+/).filter(Boolean);
          if (parts.length === 0) return null;
          const nums = parts.map((p) => Number(p));
          if (nums.some((n) => !Number.isFinite(n))) return null;
          // clip values to [0..999] to keep visible
          return nums.map((n) => Math.round(clamp(n, 0, 999)));
        }

        // Event handlers
        randomBtn.addEventListener("click", () => {
          cancelCurrentRun();
          const n = Number(sizeInput.value);
          arr = randomArray(n);
          initialArr = arr.slice();
          resetStats();
          setBoundary(arr.length);
          renderBars(arr, { sorted: { from: arr.length } });
          setStatus("READY", "ok");
        });

        resetBtn.addEventListener("click", () => {
          cancelCurrentRun();
          if (initialArr.length) {
            arr = initialArr.slice();
          }
          resetStats();
          setBoundary(arr.length);
          renderBars(arr, { sorted: { from: arr.length } });
          setStatus("RESET", "ok");
        });

        startBtn.addEventListener("click", async () => {
          if (!sorting) {
            bubbleSortVisual().catch(() => {});
          } else {
            playing = true;
            setButtons();
            if (stepResolver) {
              stepResolver();
              stepResolver = null;
            }
            setStatus("RUNNING", "run");
          }
        });

        pauseBtn.addEventListener("click", () => {
          playing = false;
          setButtons();
          setStatus("PAUSED", "warn");
        });

        stepBtn.addEventListener("click", () => {
          if (!sorting) {
            // start in paused mode
            playing = false;
            bubbleSortVisual().catch(() => {});
            setStatus("STEPPING", "warn");
          } else {
            // ensure paused and advance one step
            playing = false;
            setButtons();
            if (stepResolver) {
              stepResolver();
              stepResolver = null;
            }
            setStatus("STEPPING", "warn");
          }
        });

        loadBtn.addEventListener("click", () => {
          const text = arrayInput.value.trim();
          const nums = parseArrayInput(text);
          if (!nums) {
            setStatus("INPUT ERROR", "err");
            arrayInput.classList.add("error");
            setTimeout(() => arrayInput.classList.remove("error"), 600);
            return;
          }
          cancelCurrentRun();
          arr = nums.slice();
          initialArr = arr.slice();
          sizeInput.value = String(arr.length);
          sizeVal.textContent = String(arr.length);
          resetStats();
          setBoundary(arr.length);
          renderBars(arr, { sorted: { from: arr.length } });
          setStatus("LOADED", "ok");
        });

        sizeInput.addEventListener("input", () => {
          const n = Number(sizeInput.value);
          sizeVal.textContent = n;
        });

        sizeInput.addEventListener("change", () => {
          // regenerate random with new size
          const n = Number(sizeInput.value);
          cancelCurrentRun();
          arr = randomArray(n);
          initialArr = arr.slice();
          resetStats();
          setBoundary(arr.length);
          renderBars(arr, { sorted: { from: arr.length } });
          setStatus("READY", "ok");
        });

        speedInput.addEventListener("input", () => {
          const v = Number(speedInput.value);
          speedMs = mapSpeedToMs(v);
          speedVal.textContent = speedLabel(v);
        });

        // Init
        function init() {
          const n = Number(sizeInput.value);
          speedMs = mapSpeedToMs(Number(speedInput.value));
          speedVal.textContent = speedLabel(Number(speedInput.value));
          arr = randomArray(n);
          initialArr = arr.slice();
          resetStats();
          setBoundary(arr.length);
          renderBars(arr, { sorted: { from: arr.length } });
          highlightCode([1, 2]);
          setButtons();
          setStatus("READY", "ok");
        }

        // Resize handling to keep heights scaled
        let resizeTimer = null;
        window.addEventListener("resize", () => {
          if (resizeTimer) cancelAnimationFrame(resizeTimer);
          resizeTimer = requestAnimationFrame(() => {
            updateBars(arr, {
              sorted: {
                from: sorting
                  ? Math.max(0, arr.length - lastBoundary)
                  : arr.length,
              },
            });
          });
        });

        init();
      })();
    </script>
  </body>
</html>
