<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>K Nearest Neighbors (KNN) Interactive Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #0f1420;
      --panel: #182032;
      --accent: #4ea0ff;
      --text: #eef1f7;
      --muted: #98a4b3;
      --red: #f25f5c;
      --blue: #247ba0;
      --green: #70c1b3;
      --yellow: #ffe066;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(1000px 600px at 20% 0%, #12192a, #0c111b);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', sans-serif;
    }
    header {
      padding: 18px 24px;
      border-bottom: 1px solid #222a3d;
      background: rgba(12, 17, 27, 0.7);
      backdrop-filter: blur(6px);
      position: sticky; top: 0; z-index: 2;
    }
    h1 {
      margin: 0;
      font-size: 20px;
      letter-spacing: 0.2px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .badge {
      font-size: 12px;
      color: var(--muted);
      padding: 2px 8px;
      border: 1px solid #263048;
      border-radius: 999px;
    }
    main {
      display: grid;
      grid-template-columns: 420px 1fr;
      gap: 16px;
      padding: 16px;
    }
    @media (max-width: 980px) {
      main { grid-template-columns: 1fr; }
    }
    .panel {
      background: linear-gradient(180deg, #182032, #131a2a);
      border: 1px solid #263048;
      border-radius: 14px;
      box-shadow: 0 6px 28px rgba(0, 0, 0, 0.35);
    }
    .panel h2 {
      font-size: 16px; margin: 0 0 8px 0; color: var(--text);
    }
    .controls {
      padding: 16px;
      display: grid;
      gap: 14px;
    }
    .control-group {
      border: 1px dashed #263048;
      border-radius: 10px;
      padding: 12px;
    }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    label { color: var(--muted); font-size: 13px; }
    select, input[type="number"], input[type="text"] {
      background: #0d1322;
      border: 1px solid #263048;
      color: var(--text);
      padding: 8px 10px;
      border-radius: 8px;
      outline: none;
    }
    .slider {
      display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 10px;
    }
    input[type="range"] {
      width: 100%;
    }
    .btn {
      background: #0d1322;
      color: var(--text);
      border: 1px solid #34435f;
      border-radius: 10px;
      padding: 10px 12px;
      cursor: pointer;
      transition: transform 0.05s ease, background 0.2s ease, border-color 0.2s;
      font-weight: 600;
      font-size: 13px;
    }
    .btn:hover { background: #101831; border-color: #3f5273; }
    .btn:active { transform: scale(0.98); }
    .btn.primary { background: #173055; border-color: #29508f; }
    .btn.primary:hover { background: #1b3a66; }
    .btn.warn { background: #2a1b1b; border-color: #533333; }
    .inline-help {
      font-size: 12px; color: var(--muted);
    }
    .legend {
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-top: 6px;
    }
    .legend-item { display: flex; gap: 6px; align-items: center; }
    .swatch {
      width: 12px; height: 12px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.15);
      box-shadow: 0 0 0 2px rgba(255,255,255,0.06) inset;
    }
    .canvas-wrap {
      padding: 12px;
    }
    .canvas-toolbar {
      padding: 12px; border-bottom: 1px dashed #263048; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
    }
    #info {
      padding: 12px; border-top: 1px dashed #263048; color: var(--muted); font-size: 13px;
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
      background: radial-gradient(900px 400px at 40% 0%, #0b1220, #0a1020);
      border: 1px solid #263048;
      border-radius: 10px;
    }
    .mode-toggle {
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
    }
    .pill {
      display: inline-flex; gap: 8px; align-items: center;
      background: #0d1322; border: 1px solid #263048; border-radius: 999px; padding: 6px 10px;
      color: var(--text); font-size: 13px;
    }
    .note {
      font-size: 12px; color: var(--muted);
    }
    .footer {
      padding: 10px 16px; color: var(--muted); font-size: 12px; text-align: center;
    }
    .small {
      font-size: 12px;
    }
    .checkbox {
      display: inline-flex; gap: 8px; align-items: center;
      padding: 6px 10px; border-radius: 8px; border: 1px dashed #263048;
    }
    .kbd {
      border: 1px solid #34435f; border-bottom-width: 2px; border-radius: 6px;
      background: #0d1322; padding: 2px 6px; color: var(--text); font-size: 12px;
    }
  </style>
</head>
<body>
  <header>
    <h1>
      K Nearest Neighbors (KNN) Interactive Demo
      <span class="badge">Click to add points, tune K, see predictions</span>
    </h1>
  </header>
  <main>
    <section class="panel">
      <div class="controls">
        <div class="control-group">
          <h2>Mode and Class</h2>
          <div class="mode-toggle">
            <label class="pill"><input type="radio" name="mode" id="modeTrain" checked> Add training point</label>
            <label class="pill"><input type="radio" name="mode" id="modeQuery"> Add/query point</label>
            <span class="note">Click on the canvas to add points. In query mode, a click places the point to classify.</span>
          </div>
          <div class="legend">
            <div class="legend-item">
              <span class="swatch" style="background: var(--red)"></span>
              <label><input type="radio" name="class" id="classA" checked> Class A (red)</label>
            </div>
            <div class="legend-item">
              <span class="swatch" style="background: var(--blue)"></span>
              <label><input type="radio" name="class" id="classB"> Class B (blue)</label>
            </div>
            <div class="legend-item">
              <span class="swatch" style="background: var(--green)"></span>
              <label><input type="radio" name="class" id="classC"> Class C (green)</label>
            </div>
          </div>
        </div>

        <div class="control-group">
          <h2>KNN Settings</h2>
          <div class="row slider">
            <label for="kSlider">K (neighbors)</label>
            <input type="range" id="kSlider" min="1" max="1" step="1" value="1">
            <div><span id="kValue">1</span></div>
          </div>
          <div class="row">
            <label for="metricSelect">Distance</label>
            <select id="metricSelect">
              <option value="euclidean">Euclidean (L2)</option>
              <option value="manhattan">Manhattan (L1)</option>
            </select>
          </div>
          <div class="row">
            <label class="checkbox"><input type="checkbox" id="weighted"> Weighted votes (1 / distance)</label>
            <label class="checkbox"><input type="checkbox" id="showBoundary" checked> Show decision regions</label>
            <label class="checkbox"><input type="checkbox" id="showNeighbors" checked> Show K neighbors</label>
          </div>
          <div class="inline-help">
            - Larger K smooths predictions but may blur class boundaries.<br>
            - Weighted voting gives closer neighbors more influence. If a query exactly matches a training point, it will adopt that label.
          </div>
        </div>

        <div class="control-group">
          <h2>Dataset</h2>
          <div class="row">
            <button id="genData" class="btn primary">Generate clustered dataset</button>
            <button id="clearData" class="btn warn">Clear all</button>
          </div>
          <div class="inline-help">
            Use "Generate" to create three Gaussian clusters. You can add more points to refine boundaries. Press Backspace to undo last training point.
          </div>
        </div>

        <div class="control-group">
          <h2>Prediction Info</h2>
          <div id="prediction" class="small">Place a query point to see prediction.</div>
        </div>
      </div>
    </section>

    <section class="panel">
      <div class="canvas-toolbar">
        <div class="pill">
          Canvas: click to add points. Hold Shift to snap to grid. Current mode:
          <strong id="modeLabel" style="margin-left:6px">Add training point</strong>
        </div>
        <div class="pill">Undo last training: <span class="kbd">Backspace</span></div>
      </div>
      <div class="canvas-wrap">
        <canvas id="canvas" width="900" height="560"></canvas>
      </div>
      <div id="info">
        KNN classifies a query by finding its K closest training points and taking a majority vote. Distance metric and K strongly affect the decision boundary.
      </div>
    </section>
  </main>
  <div class="footer">
    Tip: Toggle "Decision regions" to inspect how K and distance metric change the boundary. You can combine well-separated clusters to get high-confidence predictions.
  </div>

  <script>
    (function() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      const controls = {
        modeTrain: document.getElementById('modeTrain'),
        modeQuery: document.getElementById('modeQuery'),
        modeLabel: document.getElementById('modeLabel'),
        classA: document.getElementById('classA'),
        classB: document.getElementById('classB'),
        classC: document.getElementById('classC'),
        kSlider: document.getElementById('kSlider'),
        kValue: document.getElementById('kValue'),
        metricSelect: document.getElementById('metricSelect'),
        weighted: document.getElementById('weighted'),
        showBoundary: document.getElementById('showBoundary'),
        showNeighbors: document.getElementById('showNeighbors'),
        genData: document.getElementById('genData'),
        clearData: document.getElementById('clearData'),
        prediction: document.getElementById('prediction'),
      };

      const COLORS = {
        A: getComputedStyle(document.documentElement).getPropertyValue('--red').trim() || '#f25f5c',
        B: getComputedStyle(document.documentElement).getPropertyValue('--blue').trim() || '#247ba0',
        C: getComputedStyle(document.documentElement).getPropertyValue('--green').trim() || '#70c1b3',
        border: '#263048',
        grid: 'rgba(255,255,255,0.05)',
        text: getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || '#eef1f7',
        muted: getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#98a4b3',
      };

      const state = {
        points: [], // training points {x, y, label}
        query: null, // {x, y}
        k: 1,
        metric: 'euclidean',
        weighted: false,
        showBoundary: true,
        showNeighbors: true,
        boundaryGridStep: 12,
      };

      // Utils
      function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
      function distEuclidean(a, b) {
        const dx = a.x - b.x, dy = a.y - b.y;
        return Math.hypot(dx, dy);
      }
      function distManhattan(a, b) {
        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
      }
      function distance(a, b) {
        return state.metric === 'euclidean' ? distEuclidean(a, b) : distManhattan(a, b);
      }
      function pxToCanvas(evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
          x: (evt.clientX - rect.left) * scaleX,
          y: (evt.clientY - rect.top) * scaleY,
        };
      }
      function snapToGrid(pt, step) {
        return {
          x: Math.round(pt.x / step) * step,
          y: Math.round(pt.y / step) * step,
        };
      }
      function getSelectedClass() {
        if (controls.classA.checked) return 'A';
        if (controls.classB.checked) return 'B';
        return 'C';
      }

      // KNN classification
      function classify(query, k = state.k) {
        if (!state.points.length) return null;
        const neighbors = state.points.map(p => ({
          point: p,
          distance: distance(query, p),
          label: p.label,
        })).sort((a, b) => a.distance - b.distance);

        const kNeighbors = neighbors.slice(0, Math.min(k, neighbors.length));
        // If any neighbor distance is 0, adopt its label (exact match shortcut)
        const zero = kNeighbors.find(n => n.distance === 0);
        if (zero) {
          return {
            label: zero.label,
            neighbors: kNeighbors,
            scores: { A: zero.label === 'A' ? 1 : 0, B: zero.label === 'B' ? 1 : 0, C: zero.label === 'C' ? 1 : 0 }
          };
        }

        const scores = { A: 0, B: 0, C: 0 };
        if (state.weighted) {
          for (const n of kNeighbors) {
            const w = 1 / (n.distance + 1e-6);
            scores[n.label] += w;
          }
        } else {
          for (const n of kNeighbors) {
            scores[n.label] += 1;
          }
        }

        // Determine label with tie-breaking: nearest among tied
        const entries = Object.entries(scores);
        let maxScore = -Infinity;
        let candidates = [];
        for (const [label, score] of entries) {
          if (score > maxScore) {
            maxScore = score;
            candidates = [label];
          } else if (score === maxScore) {
            candidates.push(label);
          }
        }
        let chosen = candidates[0];
        if (candidates.length > 1) {
          // choose the candidate whose nearest neighbor is closest
          const nearestByLabel = {};
          for (const lab of candidates) nearestByLabel[lab] = Infinity;
          for (const n of kNeighbors) {
            if (nearestByLabel[n.label] > n.distance) nearestByLabel[n.label] = n.distance;
          }
          let bestLab = candidates[0], bestDist = nearestByLabel[bestLab];
          for (const lab of candidates.slice(1)) {
            if (nearestByLabel[lab] < bestDist) {
              bestLab = lab; bestDist = nearestByLabel[lab];
            }
          }
          chosen = bestLab;
        }

        return { label: chosen, neighbors: kNeighbors, scores };
      }

      // Drawing
      function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // subtle background grid
        drawBackgroundGrid();
      }

      function drawBackgroundGrid() {
        const step = 40;
        ctx.save();
        ctx.strokeStyle = COLORS.grid;
        ctx.lineWidth = 1;
        for (let x = step; x < canvas.width; x += step) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for (let y = step; y < canvas.height; y += step) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
        ctx.restore();
      }

      function colorWithAlpha(hex, alpha) {
        // Supports named/hex color; attempt to get rgb via canvas
        ctx.save();
        ctx.fillStyle = hex;
        const computed = ctx.fillStyle;
        ctx.restore();
        // computed is rgb(r, g, b)
        const m = computed.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
        if (m) {
          const r = +m[1], g = +m[2], b = +m[3];
          return `rgba(${r},${g},${b},${alpha})`;
        }
        return hex;
      }

      function drawDecisionBoundary() {
        if (!state.showBoundary || state.points.length === 0) return;
        const step = state.boundaryGridStep;
        const half = step / 2;
        // Use coarse grid classification
        for (let y = half; y < canvas.height; y += step) {
          for (let x = half; x < canvas.width; x += step) {
            const q = { x, y };
            const res = classify(q, state.k);
            if (!res) continue;
            let color = COLORS[res.label];
            ctx.fillStyle = colorWithAlpha(color, 0.12);
            ctx.fillRect(x - half, y - half, step, step);
          }
        }
      }

      function drawPoints() {
        for (const p of state.points) {
          drawDot(p.x, p.y, 5, COLORS[p.label], true);
        }
      }

      function drawDot(x, y, r, color, withStroke = false) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        if (withStroke) {
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.stroke();
          ctx.lineWidth = 1;
          ctx.strokeStyle = COLORS.border;
          ctx.stroke();
        }
      }

      function drawQuery() {
        if (!state.query) return;
        drawDot(state.query.x, state.query.y, 6, '#ffe066', true);
        // halo
        ctx.beginPath();
        ctx.arc(state.query.x, state.query.y, 12, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255,224,102,0.25)';
        ctx.lineWidth = 3;
        ctx.stroke();
      }

      function drawNeighbors(neighbors) {
        if (!state.showNeighbors || !neighbors || !state.query) return;
        ctx.save();
        ctx.lineWidth = 2;
        for (const n of neighbors) {
          ctx.beginPath();
          ctx.moveTo(state.query.x, state.query.y);
          ctx.lineTo(n.point.x, n.point.y);
          ctx.strokeStyle = colorWithAlpha(COLORS[n.label], 0.6);
          ctx.stroke();

          // highlight neighbor point ring
          ctx.beginPath();
          ctx.arc(n.point.x, n.point.y, 8, 0, Math.PI * 2);
          ctx.strokeStyle = colorWithAlpha(COLORS[n.label], 0.5);
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawLegendPrediction(pred) {
        if (!pred || !state.query) {
          controls.prediction.innerHTML = 'Place a query point to see prediction.';
          return;
        }
        const k = Math.min(state.k, state.points.length);
        const scores = pred.scores;
        const formatScore = (v) => state.weighted ? v.toFixed(2) : v.toString();
        const neighborsList = pred.neighbors.map((n, i) => {
          return `#${i+1} ${n.label} d=${n.distance.toFixed(2)}`;
        }).join(', ');
        controls.prediction.innerHTML =
          `Query at (${Math.round(state.query.x)}, ${Math.round(state.query.y)}) predicted: ` +
          `<span style="color:${COLORS[pred.label]}; font-weight:700">${pred.label}</span> ` +
          `(K=${k}, metric=${state.metric}${state.weighted ? ', weighted' : ''})` +
          `<br>Votes: A=${formatScore(scores.A)}, B=${formatScore(scores.B)}, C=${formatScore(scores.C)} ` +
          `<br>Neighbors: ${neighborsList}`;
      }

      function render() {
        clearCanvas();
        drawDecisionBoundary();
        drawPoints();
        drawQuery();
        if (state.query && state.points.length) {
          const pred = classify(state.query, state.k);
          drawNeighbors(pred?.neighbors);
          drawLegendPrediction(pred);
          // draw predicted label badge
          if (pred) {
            const labelColor = COLORS[pred.label];
            ctx.save();
            ctx.fillStyle = colorWithAlpha(labelColor, 0.15);
            ctx.strokeStyle = colorWithAlpha(labelColor, 0.6);
            ctx.lineWidth = 2;
            const w = 100, h = 28;
            const x = clamp(state.query.x + 14, 8, canvas.width - w - 8);
            const y = clamp(state.query.y - h - 10, 8, canvas.height - h - 8);
            roundRect(ctx, x, y, w, h, 8);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = labelColor;
            ctx.font = '12px system-ui, sans-serif';
            ctx.fillText(`Pred: ${pred.label}`, x + 10, y + 18);
            ctx.restore();
          }
        } else {
          drawLegendPrediction(null);
        }
      }

      function roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
      }

      // Event handlers
      canvas.addEventListener('click', (evt) => {
        const pt = pxToCanvas(evt);
        const addPt = evt.shiftKey ? snapToGrid(pt, 20) : pt;
        if (controls.modeTrain.checked) {
          state.points.push({ x: addPt.x, y: addPt.y, label: getSelectedClass() });
          updateKSlider();
        } else {
          state.query = { x: addPt.x, y: addPt.y };
        }
        render();
      });

      window.addEventListener('keydown', (evt) => {
        if (evt.key === 'Backspace') {
          const removed = state.points.pop();
          if (removed) {
            updateKSlider();
            render();
          }
          evt.preventDefault();
        }
      });

      controls.kSlider.addEventListener('input', () => {
        state.k = parseInt(controls.kSlider.value, 10);
        controls.kValue.textContent = String(state.k);
        render();
      });

      controls.metricSelect.addEventListener('change', () => {
        state.metric = controls.metricSelect.value;
        render();
      });

      controls.weighted.addEventListener('change', () => {
        state.weighted = controls.weighted.checked;
        render();
      });

      controls.showBoundary.addEventListener('change', () => {
        state.showBoundary = controls.showBoundary.checked;
        render();
      });

      controls.showNeighbors.addEventListener('change', () => {
        state.showNeighbors = controls.showNeighbors.checked;
        render();
      });

      controls.modeTrain.addEventListener('change', () => updateModeLabel());
      controls.modeQuery.addEventListener('change', () => updateModeLabel());

      function updateModeLabel() {
        controls.modeLabel.textContent = controls.modeTrain.checked ? 'Add training point' : 'Add/query point';
      }

      controls.genData.addEventListener('click', () => {
        generateDataset();
        updateKSlider();
        render();
      });

      controls.clearData.addEventListener('click', () => {
        state.points = [];
        state.query = null;
        updateKSlider();
        render();
      });

      function updateKSlider() {
        const n = state.points.length || 1;
        controls.kSlider.max = String(n);
        state.k = clamp(state.k, 1, n);
        controls.kSlider.value = String(state.k);
        controls.kValue.textContent = String(state.k);
      }

      // Dataset generation
      function randNormal(mean, std) {
        // Box-Muller transform
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        const mag = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        return mean + std * mag;
      }

      function generateCluster(cx, cy, count, label, spreadX, spreadY) {
        for (let i = 0; i < count; i++) {
          let x = randNormal(cx, spreadX), y = randNormal(cy, spreadY);
          x = clamp(x, 10, canvas.width - 10);
          y = clamp(y, 10, canvas.height - 10);
          state.points.push({ x, y, label });
        }
      }

      function generateDataset() {
        state.points = [];
        const count = 60;
        const spread = 55;
        generateCluster(canvas.width * 0.20, canvas.height * 0.35, count, 'A', spread, spread);
        generateCluster(canvas.width * 0.75, canvas.height * 0.30, count, 'B', spread, spread);
        generateCluster(canvas.width * 0.45, canvas.height * 0.75, count, 'C', spread, spread);
        // set a default query point near the middle
        state.query = { x: canvas.width * 0.48, y: canvas.height * 0.50 };
      }

      // Initial setup
      generateDataset();
      updateKSlider();
      updateModeLabel();
      render();

      // Resize handling (optional): keep canvas size fixed for simplicity, but add HiDPI support
      function setupHiDPI() {
        const ratio = Math.max(window.devicePixelRatio || 1, 1);
        const w = canvas.width, h = canvas.height;
        canvas.width = Math.round(w * ratio);
        canvas.height = Math.round(h * ratio);
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
        render();
      }
      // Uncomment if you want crispness on HiDPI:
      // setupHiDPI();

      // Friendly instructions overlay (hover)
      canvas.title = 'Click to add points. Toggle mode in the left panel. Hold Shift to snap to grid.';
    })();
  </script>
</body>
</html>