[
  {
    "id": "257369f0-a34f-11f0-8905-47f4099fddc8",
    "timestamp": "2025-10-07T07:27:57.455Z",
    "model": "gpt-4o-mini",
    "status": "success",
    "question": "k nearest neighbors",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>K-Nearest Neighbors (KNN) Demo</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            background-color: #f4f4f4;\n            margin: 0;\n            padding: 20px;\n        }\n        #chart {\n            width: 600px;\n            height: 400px;\n            background-color: white;\n            border: 1px solid #ddd;\n            position: relative;\n            margin: 20px auto;\n        }\n        .point {\n            width: 10px;\n            height: 10px;\n            border-radius: 50%;\n            position: absolute;\n            transform: translate(-50%, -50%);\n        }\n        .point.red {\n            background-color: red;\n        }\n        .point.blue {\n            background-color: blue;\n        }\n        .knn {\n            border: 2px dashed yellow;\n        }\n    </style>\n</head>\n<body>\n\n<h1>K-Nearest Neighbors (KNN) Visualization</h1>\n<p>\n    Click on the chart to add a new point (make sure to click inside the box). \n    The added point will be colored based on the majority of its nearest neighbors.\n</p>\n<div id=\"chart\"></div>\n\n<script>\n    const chart = document.getElementById('chart');\n    const points = [];\n    const K = 3;\n\n    chart.addEventListener('click', (e) => {\n        const rect = chart.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n\n        const newPoint = { x: x, y: y, color: 'green' };\n        points.push(newPoint);\n        drawChart();\n        classifyPoint(newPoint);\n        drawChart();\n    });\n\n    function classifyPoint(newPoint) {\n        // Calculate distance and find nearest K neighbors\n        const distances = points.map(point => ({\n            point: point,\n            distance: Math.sqrt(Math.pow(point.x - newPoint.x, 2) + Math.pow(point.y - newPoint.y, 2))\n        }));\n\n        // Sort by distance and get the closest K neighbors\n        distances.sort((a, b) => a.distance - b.distance);\n        const neighbors = distances.slice(0, K);\n\n        // Determine the majority class\n        const colorCount = { red: 0, blue: 0 };\n        neighbors.forEach(neighbor => {\n            if (neighbor.point.color) {\n                colorCount[neighbor.point.color]++;\n            }\n        });\n\n        newPoint.color = (colorCount.red > colorCount.blue) ? 'red' : 'blue';\n    }\n\n    function drawChart() {\n        chart.innerHTML = ''; // Clear chart\n\n        points.forEach(point => {\n            const pointDiv = document.createElement('div');\n            pointDiv.className = 'point ' + point.color;\n            pointDiv.style.left = point.x + 'px';\n            pointDiv.style.top = point.y + 'px';\n            chart.appendChild(pointDiv);\n        });\n\n        if (points.length > 0) {\n            const lastPoint = points[points.length - 1];\n            drawKNN(lastPoint);\n        }\n    }\n\n    function drawKNN(newPoint) {\n        const distances = points.filter(point => point !== newPoint).map(point => ({\n            point: point,\n            distance: Math.sqrt(Math.pow(point.x - newPoint.x, 2) + Math.pow(point.y - newPoint.y, 2))\n        }));\n\n        distances.sort((a, b) => a.distance - b.distance);\n        const neighbors = distances.slice(0, K);\n        \n        neighbors.forEach(neighbor => {\n            const line = document.createElement('div');\n            line.className = 'knn';\n            const x1 = newPoint.x;\n            const y1 = newPoint.y;\n            const x2 = neighbor.point.x;\n            const y2 = neighbor.point.y;\n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            \n            line.style.position = 'absolute';\n            line.style.width = length + 'px';\n            line.style.height = '2px';\n            line.style.background = 'yellow';\n            line.style.transformOrigin = '0 0';\n            line.style.transform = `rotate(${angle}deg)`;\n            line.style.left = x1 + 'px';\n            line.style.top = y1 + 'px';\n\n            chart.appendChild(line);\n        });\n    }\n</script>\n\n</body>\n</html>\n```",
      "refusal": null,
      "annotations": []
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "k nearest neighbors"
      }
    ],
    "evaluation": {
      "score": {
        "interactivity_score": 0,
        "user_control_score": 0,
        "visual_clarity_score": 2,
        "missing_features": [
          "interactive elements (buttons, sliders, inputs)",
          "visual representation (canvas, SVG)",
          "animations to illustrate concepts"
        ],
        "comments": "The visualization lacks interactivity and user control, which severely limits its effectiveness for learning. Visual clarity is minimal due to the absence of engaging elements."
      },
      "notes": "",
      "timestamp": "2025-10-07T13:02:10.610Z"
    }
  },
  {
    "id": "b898f060-a34f-11f0-bd8c-b7eda04c8cf8",
    "timestamp": "2025-10-07T07:32:04.326Z",
    "model": "gpt-5",
    "status": "success",
    "question": "k nearest neighbors",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>K Nearest Neighbors (KNN) Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <style>\n    :root {\n      --bg: #0f1420;\n      --panel: #182032;\n      --accent: #4ea0ff;\n      --text: #eef1f7;\n      --muted: #98a4b3;\n      --red: #f25f5c;\n      --blue: #247ba0;\n      --green: #70c1b3;\n      --yellow: #ffe066;\n    }\n    * { box-sizing: border-box; }\n    body {\n      margin: 0;\n      background: radial-gradient(1000px 600px at 20% 0%, #12192a, #0c111b);\n      color: var(--text);\n      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', sans-serif;\n    }\n    header {\n      padding: 18px 24px;\n      border-bottom: 1px solid #222a3d;\n      background: rgba(12, 17, 27, 0.7);\n      backdrop-filter: blur(6px);\n      position: sticky; top: 0; z-index: 2;\n    }\n    h1 {\n      margin: 0;\n      font-size: 20px;\n      letter-spacing: 0.2px;\n      display: flex;\n      align-items: center;\n      gap: 12px;\n    }\n    .badge {\n      font-size: 12px;\n      color: var(--muted);\n      padding: 2px 8px;\n      border: 1px solid #263048;\n      border-radius: 999px;\n    }\n    main {\n      display: grid;\n      grid-template-columns: 420px 1fr;\n      gap: 16px;\n      padding: 16px;\n    }\n    @media (max-width: 980px) {\n      main { grid-template-columns: 1fr; }\n    }\n    .panel {\n      background: linear-gradient(180deg, #182032, #131a2a);\n      border: 1px solid #263048;\n      border-radius: 14px;\n      box-shadow: 0 6px 28px rgba(0, 0, 0, 0.35);\n    }\n    .panel h2 {\n      font-size: 16px; margin: 0 0 8px 0; color: var(--text);\n    }\n    .controls {\n      padding: 16px;\n      display: grid;\n      gap: 14px;\n    }\n    .control-group {\n      border: 1px dashed #263048;\n      border-radius: 10px;\n      padding: 12px;\n    }\n    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }\n    label { color: var(--muted); font-size: 13px; }\n    select, input[type=\"number\"], input[type=\"text\"] {\n      background: #0d1322;\n      border: 1px solid #263048;\n      color: var(--text);\n      padding: 8px 10px;\n      border-radius: 8px;\n      outline: none;\n    }\n    .slider {\n      display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 10px;\n    }\n    input[type=\"range\"] {\n      width: 100%;\n    }\n    .btn {\n      background: #0d1322;\n      color: var(--text);\n      border: 1px solid #34435f;\n      border-radius: 10px;\n      padding: 10px 12px;\n      cursor: pointer;\n      transition: transform 0.05s ease, background 0.2s ease, border-color 0.2s;\n      font-weight: 600;\n      font-size: 13px;\n    }\n    .btn:hover { background: #101831; border-color: #3f5273; }\n    .btn:active { transform: scale(0.98); }\n    .btn.primary { background: #173055; border-color: #29508f; }\n    .btn.primary:hover { background: #1b3a66; }\n    .btn.warn { background: #2a1b1b; border-color: #533333; }\n    .inline-help {\n      font-size: 12px; color: var(--muted);\n    }\n    .legend {\n      display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-top: 6px;\n    }\n    .legend-item { display: flex; gap: 6px; align-items: center; }\n    .swatch {\n      width: 12px; height: 12px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.15);\n      box-shadow: 0 0 0 2px rgba(255,255,255,0.06) inset;\n    }\n    .canvas-wrap {\n      padding: 12px;\n    }\n    .canvas-toolbar {\n      padding: 12px; border-bottom: 1px dashed #263048; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;\n    }\n    #info {\n      padding: 12px; border-top: 1px dashed #263048; color: var(--muted); font-size: 13px;\n    }\n    canvas {\n      display: block;\n      width: 100%;\n      height: auto;\n      background: radial-gradient(900px 400px at 40% 0%, #0b1220, #0a1020);\n      border: 1px solid #263048;\n      border-radius: 10px;\n    }\n    .mode-toggle {\n      display: flex; gap: 10px; align-items: center; flex-wrap: wrap;\n    }\n    .pill {\n      display: inline-flex; gap: 8px; align-items: center;\n      background: #0d1322; border: 1px solid #263048; border-radius: 999px; padding: 6px 10px;\n      color: var(--text); font-size: 13px;\n    }\n    .note {\n      font-size: 12px; color: var(--muted);\n    }\n    .footer {\n      padding: 10px 16px; color: var(--muted); font-size: 12px; text-align: center;\n    }\n    .small {\n      font-size: 12px;\n    }\n    .checkbox {\n      display: inline-flex; gap: 8px; align-items: center;\n      padding: 6px 10px; border-radius: 8px; border: 1px dashed #263048;\n    }\n    .kbd {\n      border: 1px solid #34435f; border-bottom-width: 2px; border-radius: 6px;\n      background: #0d1322; padding: 2px 6px; color: var(--text); font-size: 12px;\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>\n      K Nearest Neighbors (KNN) Interactive Demo\n      <span class=\"badge\">Click to add points, tune K, see predictions</span>\n    </h1>\n  </header>\n  <main>\n    <section class=\"panel\">\n      <div class=\"controls\">\n        <div class=\"control-group\">\n          <h2>Mode and Class</h2>\n          <div class=\"mode-toggle\">\n            <label class=\"pill\"><input type=\"radio\" name=\"mode\" id=\"modeTrain\" checked> Add training point</label>\n            <label class=\"pill\"><input type=\"radio\" name=\"mode\" id=\"modeQuery\"> Add/query point</label>\n            <span class=\"note\">Click on the canvas to add points. In query mode, a click places the point to classify.</span>\n          </div>\n          <div class=\"legend\">\n            <div class=\"legend-item\">\n              <span class=\"swatch\" style=\"background: var(--red)\"></span>\n              <label><input type=\"radio\" name=\"class\" id=\"classA\" checked> Class A (red)</label>\n            </div>\n            <div class=\"legend-item\">\n              <span class=\"swatch\" style=\"background: var(--blue)\"></span>\n              <label><input type=\"radio\" name=\"class\" id=\"classB\"> Class B (blue)</label>\n            </div>\n            <div class=\"legend-item\">\n              <span class=\"swatch\" style=\"background: var(--green)\"></span>\n              <label><input type=\"radio\" name=\"class\" id=\"classC\"> Class C (green)</label>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"control-group\">\n          <h2>KNN Settings</h2>\n          <div class=\"row slider\">\n            <label for=\"kSlider\">K (neighbors)</label>\n            <input type=\"range\" id=\"kSlider\" min=\"1\" max=\"1\" step=\"1\" value=\"1\">\n            <div><span id=\"kValue\">1</span></div>\n          </div>\n          <div class=\"row\">\n            <label for=\"metricSelect\">Distance</label>\n            <select id=\"metricSelect\">\n              <option value=\"euclidean\">Euclidean (L2)</option>\n              <option value=\"manhattan\">Manhattan (L1)</option>\n            </select>\n          </div>\n          <div class=\"row\">\n            <label class=\"checkbox\"><input type=\"checkbox\" id=\"weighted\"> Weighted votes (1 / distance)</label>\n            <label class=\"checkbox\"><input type=\"checkbox\" id=\"showBoundary\" checked> Show decision regions</label>\n            <label class=\"checkbox\"><input type=\"checkbox\" id=\"showNeighbors\" checked> Show K neighbors</label>\n          </div>\n          <div class=\"inline-help\">\n            - Larger K smooths predictions but may blur class boundaries.<br>\n            - Weighted voting gives closer neighbors more influence. If a query exactly matches a training point, it will adopt that label.\n          </div>\n        </div>\n\n        <div class=\"control-group\">\n          <h2>Dataset</h2>\n          <div class=\"row\">\n            <button id=\"genData\" class=\"btn primary\">Generate clustered dataset</button>\n            <button id=\"clearData\" class=\"btn warn\">Clear all</button>\n          </div>\n          <div class=\"inline-help\">\n            Use \"Generate\" to create three Gaussian clusters. You can add more points to refine boundaries. Press Backspace to undo last training point.\n          </div>\n        </div>\n\n        <div class=\"control-group\">\n          <h2>Prediction Info</h2>\n          <div id=\"prediction\" class=\"small\">Place a query point to see prediction.</div>\n        </div>\n      </div>\n    </section>\n\n    <section class=\"panel\">\n      <div class=\"canvas-toolbar\">\n        <div class=\"pill\">\n          Canvas: click to add points. Hold Shift to snap to grid. Current mode:\n          <strong id=\"modeLabel\" style=\"margin-left:6px\">Add training point</strong>\n        </div>\n        <div class=\"pill\">Undo last training: <span class=\"kbd\">Backspace</span></div>\n      </div>\n      <div class=\"canvas-wrap\">\n        <canvas id=\"canvas\" width=\"900\" height=\"560\"></canvas>\n      </div>\n      <div id=\"info\">\n        KNN classifies a query by finding its K closest training points and taking a majority vote. Distance metric and K strongly affect the decision boundary.\n      </div>\n    </section>\n  </main>\n  <div class=\"footer\">\n    Tip: Toggle \"Decision regions\" to inspect how K and distance metric change the boundary. You can combine well-separated clusters to get high-confidence predictions.\n  </div>\n\n  <script>\n    (function() {\n      const canvas = document.getElementById('canvas');\n      const ctx = canvas.getContext('2d');\n\n      const controls = {\n        modeTrain: document.getElementById('modeTrain'),\n        modeQuery: document.getElementById('modeQuery'),\n        modeLabel: document.getElementById('modeLabel'),\n        classA: document.getElementById('classA'),\n        classB: document.getElementById('classB'),\n        classC: document.getElementById('classC'),\n        kSlider: document.getElementById('kSlider'),\n        kValue: document.getElementById('kValue'),\n        metricSelect: document.getElementById('metricSelect'),\n        weighted: document.getElementById('weighted'),\n        showBoundary: document.getElementById('showBoundary'),\n        showNeighbors: document.getElementById('showNeighbors'),\n        genData: document.getElementById('genData'),\n        clearData: document.getElementById('clearData'),\n        prediction: document.getElementById('prediction'),\n      };\n\n      const COLORS = {\n        A: getComputedStyle(document.documentElement).getPropertyValue('--red').trim() || '#f25f5c',\n        B: getComputedStyle(document.documentElement).getPropertyValue('--blue').trim() || '#247ba0',\n        C: getComputedStyle(document.documentElement).getPropertyValue('--green').trim() || '#70c1b3',\n        border: '#263048',\n        grid: 'rgba(255,255,255,0.05)',\n        text: getComputedStyle(document.documentElement).getPropertyValue('--text').trim() || '#eef1f7',\n        muted: getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#98a4b3',\n      };\n\n      const state = {\n        points: [], // training points {x, y, label}\n        query: null, // {x, y}\n        k: 1,\n        metric: 'euclidean',\n        weighted: false,\n        showBoundary: true,\n        showNeighbors: true,\n        boundaryGridStep: 12,\n      };\n\n      // Utils\n      function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }\n      function distEuclidean(a, b) {\n        const dx = a.x - b.x, dy = a.y - b.y;\n        return Math.hypot(dx, dy);\n      }\n      function distManhattan(a, b) {\n        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n      }\n      function distance(a, b) {\n        return state.metric === 'euclidean' ? distEuclidean(a, b) : distManhattan(a, b);\n      }\n      function pxToCanvas(evt) {\n        const rect = canvas.getBoundingClientRect();\n        const scaleX = canvas.width / rect.width;\n        const scaleY = canvas.height / rect.height;\n        return {\n          x: (evt.clientX - rect.left) * scaleX,\n          y: (evt.clientY - rect.top) * scaleY,\n        };\n      }\n      function snapToGrid(pt, step) {\n        return {\n          x: Math.round(pt.x / step) * step,\n          y: Math.round(pt.y / step) * step,\n        };\n      }\n      function getSelectedClass() {\n        if (controls.classA.checked) return 'A';\n        if (controls.classB.checked) return 'B';\n        return 'C';\n      }\n\n      // KNN classification\n      function classify(query, k = state.k) {\n        if (!state.points.length) return null;\n        const neighbors = state.points.map(p => ({\n          point: p,\n          distance: distance(query, p),\n          label: p.label,\n        })).sort((a, b) => a.distance - b.distance);\n\n        const kNeighbors = neighbors.slice(0, Math.min(k, neighbors.length));\n        // If any neighbor distance is 0, adopt its label (exact match shortcut)\n        const zero = kNeighbors.find(n => n.distance === 0);\n        if (zero) {\n          return {\n            label: zero.label,\n            neighbors: kNeighbors,\n            scores: { A: zero.label === 'A' ? 1 : 0, B: zero.label === 'B' ? 1 : 0, C: zero.label === 'C' ? 1 : 0 }\n          };\n        }\n\n        const scores = { A: 0, B: 0, C: 0 };\n        if (state.weighted) {\n          for (const n of kNeighbors) {\n            const w = 1 / (n.distance + 1e-6);\n            scores[n.label] += w;\n          }\n        } else {\n          for (const n of kNeighbors) {\n            scores[n.label] += 1;\n          }\n        }\n\n        // Determine label with tie-breaking: nearest among tied\n        const entries = Object.entries(scores);\n        let maxScore = -Infinity;\n        let candidates = [];\n        for (const [label, score] of entries) {\n          if (score > maxScore) {\n            maxScore = score;\n            candidates = [label];\n          } else if (score === maxScore) {\n            candidates.push(label);\n          }\n        }\n        let chosen = candidates[0];\n        if (candidates.length > 1) {\n          // choose the candidate whose nearest neighbor is closest\n          const nearestByLabel = {};\n          for (const lab of candidates) nearestByLabel[lab] = Infinity;\n          for (const n of kNeighbors) {\n            if (nearestByLabel[n.label] > n.distance) nearestByLabel[n.label] = n.distance;\n          }\n          let bestLab = candidates[0], bestDist = nearestByLabel[bestLab];\n          for (const lab of candidates.slice(1)) {\n            if (nearestByLabel[lab] < bestDist) {\n              bestLab = lab; bestDist = nearestByLabel[lab];\n            }\n          }\n          chosen = bestLab;\n        }\n\n        return { label: chosen, neighbors: kNeighbors, scores };\n      }\n\n      // Drawing\n      function clearCanvas() {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // subtle background grid\n        drawBackgroundGrid();\n      }\n\n      function drawBackgroundGrid() {\n        const step = 40;\n        ctx.save();\n        ctx.strokeStyle = COLORS.grid;\n        ctx.lineWidth = 1;\n        for (let x = step; x < canvas.width; x += step) {\n          ctx.beginPath();\n          ctx.moveTo(x, 0);\n          ctx.lineTo(x, canvas.height);\n          ctx.stroke();\n        }\n        for (let y = step; y < canvas.height; y += step) {\n          ctx.beginPath();\n          ctx.moveTo(0, y);\n          ctx.lineTo(canvas.width, y);\n          ctx.stroke();\n        }\n        ctx.restore();\n      }\n\n      function colorWithAlpha(hex, alpha) {\n        // Supports named/hex color; attempt to get rgb via canvas\n        ctx.save();\n        ctx.fillStyle = hex;\n        const computed = ctx.fillStyle;\n        ctx.restore();\n        // computed is rgb(r, g, b)\n        const m = computed.match(/^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)/i);\n        if (m) {\n          const r = +m[1], g = +m[2], b = +m[3];\n          return `rgba(${r},${g},${b},${alpha})`;\n        }\n        return hex;\n      }\n\n      function drawDecisionBoundary() {\n        if (!state.showBoundary || state.points.length === 0) return;\n        const step = state.boundaryGridStep;\n        const half = step / 2;\n        // Use coarse grid classification\n        for (let y = half; y < canvas.height; y += step) {\n          for (let x = half; x < canvas.width; x += step) {\n            const q = { x, y };\n            const res = classify(q, state.k);\n            if (!res) continue;\n            let color = COLORS[res.label];\n            ctx.fillStyle = colorWithAlpha(color, 0.12);\n            ctx.fillRect(x - half, y - half, step, step);\n          }\n        }\n      }\n\n      function drawPoints() {\n        for (const p of state.points) {\n          drawDot(p.x, p.y, 5, COLORS[p.label], true);\n        }\n      }\n\n      function drawDot(x, y, r, color, withStroke = false) {\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Math.PI * 2);\n        ctx.fillStyle = color;\n        ctx.fill();\n        if (withStroke) {\n          ctx.lineWidth = 2;\n          ctx.strokeStyle = 'rgba(0,0,0,0.35)';\n          ctx.stroke();\n          ctx.lineWidth = 1;\n          ctx.strokeStyle = COLORS.border;\n          ctx.stroke();\n        }\n      }\n\n      function drawQuery() {\n        if (!state.query) return;\n        drawDot(state.query.x, state.query.y, 6, '#ffe066', true);\n        // halo\n        ctx.beginPath();\n        ctx.arc(state.query.x, state.query.y, 12, 0, Math.PI * 2);\n        ctx.strokeStyle = 'rgba(255,224,102,0.25)';\n        ctx.lineWidth = 3;\n        ctx.stroke();\n      }\n\n      function drawNeighbors(neighbors) {\n        if (!state.showNeighbors || !neighbors || !state.query) return;\n        ctx.save();\n        ctx.lineWidth = 2;\n        for (const n of neighbors) {\n          ctx.beginPath();\n          ctx.moveTo(state.query.x, state.query.y);\n          ctx.lineTo(n.point.x, n.point.y);\n          ctx.strokeStyle = colorWithAlpha(COLORS[n.label], 0.6);\n          ctx.stroke();\n\n          // highlight neighbor point ring\n          ctx.beginPath();\n          ctx.arc(n.point.x, n.point.y, 8, 0, Math.PI * 2);\n          ctx.strokeStyle = colorWithAlpha(COLORS[n.label], 0.5);\n          ctx.lineWidth = 2;\n          ctx.stroke();\n        }\n        ctx.restore();\n      }\n\n      function drawLegendPrediction(pred) {\n        if (!pred || !state.query) {\n          controls.prediction.innerHTML = 'Place a query point to see prediction.';\n          return;\n        }\n        const k = Math.min(state.k, state.points.length);\n        const scores = pred.scores;\n        const formatScore = (v) => state.weighted ? v.toFixed(2) : v.toString();\n        const neighborsList = pred.neighbors.map((n, i) => {\n          return `#${i+1} ${n.label} d=${n.distance.toFixed(2)}`;\n        }).join(', ');\n        controls.prediction.innerHTML =\n          `Query at (${Math.round(state.query.x)}, ${Math.round(state.query.y)}) predicted: ` +\n          `<span style=\"color:${COLORS[pred.label]}; font-weight:700\">${pred.label}</span> ` +\n          `(K=${k}, metric=${state.metric}${state.weighted ? ', weighted' : ''})` +\n          `<br>Votes: A=${formatScore(scores.A)}, B=${formatScore(scores.B)}, C=${formatScore(scores.C)} ` +\n          `<br>Neighbors: ${neighborsList}`;\n      }\n\n      function render() {\n        clearCanvas();\n        drawDecisionBoundary();\n        drawPoints();\n        drawQuery();\n        if (state.query && state.points.length) {\n          const pred = classify(state.query, state.k);\n          drawNeighbors(pred?.neighbors);\n          drawLegendPrediction(pred);\n          // draw predicted label badge\n          if (pred) {\n            const labelColor = COLORS[pred.label];\n            ctx.save();\n            ctx.fillStyle = colorWithAlpha(labelColor, 0.15);\n            ctx.strokeStyle = colorWithAlpha(labelColor, 0.6);\n            ctx.lineWidth = 2;\n            const w = 100, h = 28;\n            const x = clamp(state.query.x + 14, 8, canvas.width - w - 8);\n            const y = clamp(state.query.y - h - 10, 8, canvas.height - h - 8);\n            roundRect(ctx, x, y, w, h, 8);\n            ctx.fill();\n            ctx.stroke();\n            ctx.fillStyle = labelColor;\n            ctx.font = '12px system-ui, sans-serif';\n            ctx.fillText(`Pred: ${pred.label}`, x + 10, y + 18);\n            ctx.restore();\n          }\n        } else {\n          drawLegendPrediction(null);\n        }\n      }\n\n      function roundRect(ctx, x, y, w, h, r) {\n        ctx.beginPath();\n        ctx.moveTo(x + r, y);\n        ctx.arcTo(x + w, y, x + w, y + h, r);\n        ctx.arcTo(x + w, y + h, x, y + h, r);\n        ctx.arcTo(x, y + h, x, y, r);\n        ctx.arcTo(x, y, x + w, y, r);\n        ctx.closePath();\n      }\n\n      // Event handlers\n      canvas.addEventListener('click', (evt) => {\n        const pt = pxToCanvas(evt);\n        const addPt = evt.shiftKey ? snapToGrid(pt, 20) : pt;\n        if (controls.modeTrain.checked) {\n          state.points.push({ x: addPt.x, y: addPt.y, label: getSelectedClass() });\n          updateKSlider();\n        } else {\n          state.query = { x: addPt.x, y: addPt.y };\n        }\n        render();\n      });\n\n      window.addEventListener('keydown', (evt) => {\n        if (evt.key === 'Backspace') {\n          const removed = state.points.pop();\n          if (removed) {\n            updateKSlider();\n            render();\n          }\n          evt.preventDefault();\n        }\n      });\n\n      controls.kSlider.addEventListener('input', () => {\n        state.k = parseInt(controls.kSlider.value, 10);\n        controls.kValue.textContent = String(state.k);\n        render();\n      });\n\n      controls.metricSelect.addEventListener('change', () => {\n        state.metric = controls.metricSelect.value;\n        render();\n      });\n\n      controls.weighted.addEventListener('change', () => {\n        state.weighted = controls.weighted.checked;\n        render();\n      });\n\n      controls.showBoundary.addEventListener('change', () => {\n        state.showBoundary = controls.showBoundary.checked;\n        render();\n      });\n\n      controls.showNeighbors.addEventListener('change', () => {\n        state.showNeighbors = controls.showNeighbors.checked;\n        render();\n      });\n\n      controls.modeTrain.addEventListener('change', () => updateModeLabel());\n      controls.modeQuery.addEventListener('change', () => updateModeLabel());\n\n      function updateModeLabel() {\n        controls.modeLabel.textContent = controls.modeTrain.checked ? 'Add training point' : 'Add/query point';\n      }\n\n      controls.genData.addEventListener('click', () => {\n        generateDataset();\n        updateKSlider();\n        render();\n      });\n\n      controls.clearData.addEventListener('click', () => {\n        state.points = [];\n        state.query = null;\n        updateKSlider();\n        render();\n      });\n\n      function updateKSlider() {\n        const n = state.points.length || 1;\n        controls.kSlider.max = String(n);\n        state.k = clamp(state.k, 1, n);\n        controls.kSlider.value = String(state.k);\n        controls.kValue.textContent = String(state.k);\n      }\n\n      // Dataset generation\n      function randNormal(mean, std) {\n        // Box-Muller transform\n        let u = 0, v = 0;\n        while (u === 0) u = Math.random();\n        while (v === 0) v = Math.random();\n        const mag = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n        return mean + std * mag;\n      }\n\n      function generateCluster(cx, cy, count, label, spreadX, spreadY) {\n        for (let i = 0; i < count; i++) {\n          let x = randNormal(cx, spreadX), y = randNormal(cy, spreadY);\n          x = clamp(x, 10, canvas.width - 10);\n          y = clamp(y, 10, canvas.height - 10);\n          state.points.push({ x, y, label });\n        }\n      }\n\n      function generateDataset() {\n        state.points = [];\n        const count = 60;\n        const spread = 55;\n        generateCluster(canvas.width * 0.20, canvas.height * 0.35, count, 'A', spread, spread);\n        generateCluster(canvas.width * 0.75, canvas.height * 0.30, count, 'B', spread, spread);\n        generateCluster(canvas.width * 0.45, canvas.height * 0.75, count, 'C', spread, spread);\n        // set a default query point near the middle\n        state.query = { x: canvas.width * 0.48, y: canvas.height * 0.50 };\n      }\n\n      // Initial setup\n      generateDataset();\n      updateKSlider();\n      updateModeLabel();\n      render();\n\n      // Resize handling (optional): keep canvas size fixed for simplicity, but add HiDPI support\n      function setupHiDPI() {\n        const ratio = Math.max(window.devicePixelRatio || 1, 1);\n        const w = canvas.width, h = canvas.height;\n        canvas.width = Math.round(w * ratio);\n        canvas.height = Math.round(h * ratio);\n        canvas.style.width = w + 'px';\n        canvas.style.height = h + 'px';\n        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);\n        render();\n      }\n      // Uncomment if you want crispness on HiDPI:\n      // setupHiDPI();\n\n      // Friendly instructions overlay (hover)\n      canvas.title = 'Click to add points. Toggle mode in the left panel. Hold Shift to snap to grid.';\n    })();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "k nearest neighbors"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "84b79d70-a35c-11f0-b266-194a5925a4f3",
    "timestamp": "2025-10-07T09:03:40.743Z",
    "model": "gpt-5",
    "status": "success",
    "question": "bubble sort",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Bubble Sort Visualizer</title>\n<style>\n  :root{\n    --bg: #0f172a;\n    --panel: #111827;\n    --text: #e5e7eb;\n    --muted: #9ca3af;\n    --accent: #60a5fa;\n    --bar: #4f46e5;\n    --compare: #f59e0b;\n    --swap: #ef4444;\n    --sorted: #10b981;\n    --pass-boundary: rgba(255,255,255,0.07);\n    --btn: #1f2937;\n    --btn-hover: #374151;\n    --good: #34d399;\n    --bad: #f87171;\n  }\n\n  * { box-sizing: border-box; }\n  html, body { height: 100%; }\n  body {\n    margin: 0;\n    background: radial-gradient(1200px 700px at 80% -10%, #1f2937 0%, #0b1224 45%, #0b1020 100%);\n    color: var(--text);\n    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n    line-height: 1.35;\n  }\n\n  header {\n    padding: 24px 18px 4px;\n    text-align: center;\n  }\n  h1 {\n    margin: 0 0 8px;\n    font-size: clamp(22px, 3.2vw, 36px);\n    font-weight: 800;\n    letter-spacing: 0.2px;\n    background: linear-gradient(135deg, #93c5fd 0%, #d8b4fe 40%, #fca5a5 100%);\n    -webkit-background-clip: text;\n    background-clip: text;\n    color: transparent;\n  }\n  .subtitle {\n    color: var(--muted);\n    font-size: 14px;\n    margin-bottom: 12px;\n  }\n  .app {\n    max-width: 1100px;\n    margin: 0 auto;\n    padding: 12px 16px 42px;\n  }\n\n  .controls {\n    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n    border: 1px solid rgba(255,255,255,0.08);\n    border-radius: 14px;\n    padding: 14px 14px 8px;\n    display: grid;\n    grid-template-columns: 1fr;\n    gap: 10px;\n  }\n  @media (min-width: 860px) {\n    .controls { grid-template-columns: 1.1fr 1fr; }\n  }\n\n  .row {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n  }\n  .row .spacer { flex: 1; }\n  .group {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n  }\n  .label {\n    font-size: 12px;\n    color: var(--muted);\n    margin-bottom: 2px;\n  }\n  .slider-wrap {\n    min-width: 220px;\n  }\n  input[type=\"range\"] {\n    appearance: none;\n    width: 220px;\n    height: 8px;\n    background: #1f2937;\n    border-radius: 999px;\n    outline: none;\n  }\n  input[type=\"range\"]::-webkit-slider-thumb {\n    appearance: none;\n    width: 18px; height: 18px; border-radius: 50%;\n    background: linear-gradient(135deg, #93c5fd, #d8b4fe);\n    border: 2px solid #0f172a;\n    box-shadow: 0 1px 6px rgba(0,0,0,0.4);\n    cursor: pointer;\n  }\n\n  .btn {\n    background: var(--btn);\n    color: var(--text);\n    border: 1px solid rgba(255,255,255,0.12);\n    padding: 9px 12px;\n    border-radius: 10px;\n    cursor: pointer;\n    font-weight: 600;\n    font-size: 14px;\n    letter-spacing: 0.2px;\n    transition: background 0.12s, transform 0.06s, border-color 0.12s;\n    display: inline-flex; align-items: center; gap: 8px;\n  }\n  .btn:hover { background: var(--btn-hover); }\n  .btn:active { transform: translateY(1px); }\n  .btn.primary {\n    background: linear-gradient(135deg, #60a5fa, #a78bfa);\n    border-color: rgba(255,255,255,0.18);\n    color: #0b1020;\n  }\n  .btn.warn {\n    background: linear-gradient(135deg, #f87171, #fb923c);\n    color: #160b0b;\n    border-color: rgba(255,255,255,0.2);\n  }\n  .btn.ghost { background: transparent; }\n  .btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n  }\n\n  .input {\n    background: #0b1220;\n    color: var(--text);\n    border: 1px solid rgba(255,255,255,0.12);\n    padding: 9px 12px;\n    border-radius: 10px;\n    min-width: 260px;\n    max-width: 100%;\n    outline: none;\n  }\n  .input::placeholder { color: #6b7280; }\n\n  .board {\n    margin-top: 16px;\n    display: grid;\n    grid-template-columns: 2.2fr 1fr;\n    gap: 14px;\n  }\n  @media (max-width: 860px) {\n    .board { grid-template-columns: 1fr; }\n  }\n\n  .panel {\n    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n    border: 1px solid rgba(255,255,255,0.08);\n    border-radius: 14px;\n    padding: 14px;\n  }\n\n  .bars-wrap {\n    height: 360px;\n    position: relative;\n    overflow: hidden;\n    border-radius: 10px;\n    background:\n      linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)),\n      radial-gradient(800px 300px at -10% 110%, rgba(96,165,250,0.08), transparent 50%),\n      radial-gradient(800px 300px at 110% -10%, rgba(167,139,250,0.08), transparent 50%);\n    border: 1px dashed rgba(255,255,255,0.08);\n  }\n  .bars {\n    position: absolute; inset: 0;\n    display: flex;\n    align-items: flex-end;\n    gap: 4px;\n    padding: 10px 12px 12px;\n  }\n  .bar {\n    flex: 1 1 auto;\n    background: var(--bar);\n    border-radius: 6px 6px 2px 2px;\n    position: relative;\n    transition: height 160ms ease, background 120ms ease, transform 120ms ease;\n  }\n  .bar::after {\n    content: attr(data-val);\n    position: absolute;\n    bottom: calc(100% + 4px);\n    left: 50%;\n    transform: translateX(-50%);\n    font-size: 11px;\n    color: var(--muted);\n    opacity: 0.9;\n    white-space: nowrap;\n    pointer-events: none;\n  }\n  .bar.compare { background: var(--compare); }\n  .bar.swap { background: var(--swap); }\n  .bar.sorted { background: var(--sorted); }\n  .pass-overlay {\n    position: absolute; left: 0; top: 0; bottom: 0;\n    right: 0;\n    pointer-events: none;\n  }\n  .boundary {\n    position: absolute; top: 0; bottom: 0;\n    right: 0;\n    background: linear-gradient(90deg, transparent, var(--pass-boundary));\n  }\n\n  .legend {\n    display: flex; flex-wrap: wrap; gap: 10px;\n    margin-top: 8px; color: var(--muted); font-size: 12px;\n  }\n  .chip {\n    display: inline-flex; align-items: center; gap: 6px;\n    padding: 6px 10px; border-radius: 999px;\n    border: 1px solid rgba(255,255,255,0.1);\n    background: rgba(255,255,255,0.03);\n  }\n  .dot {\n    width: 10px; height: 10px; border-radius: 50%;\n  }\n  .dot.bar { background: var(--bar); }\n  .dot.compare { background: var(--compare); }\n  .dot.swap { background: var(--swap); }\n  .dot.sorted { background: var(--sorted); }\n  .dot.boundary { background: var(--pass-boundary); border: 1px solid rgba(255,255,255,0.1); }\n\n  .stats {\n    display: grid; grid-template-columns: repeat(2, 1fr);\n    gap: 10px; margin-top: 4px;\n  }\n  @media (min-width: 540px) {\n    .stats { grid-template-columns: repeat(4, 1fr); }\n  }\n  .stat {\n    background: rgba(255,255,255,0.03);\n    border: 1px solid rgba(255,255,255,0.08);\n    padding: 10px; border-radius: 10px;\n  }\n  .stat .k { font-size: 12px; color: var(--muted); margin-bottom: 4px; }\n  .stat .v { font-size: 18px; font-weight: 800; letter-spacing: 0.2px; }\n\n  .code {\n    background: #0b1220;\n    border: 1px solid rgba(255,255,255,0.08);\n    border-radius: 10px;\n    padding: 10px 12px;\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n    font-size: 13px;\n    color: #d1d5db;\n  }\n  .code ol { margin: 0; padding-left: 18px; }\n  .code li {\n    padding: 2px 8px;\n    border-radius: 6px;\n  }\n  .code li.hl {\n    background: rgba(96,165,250,0.15);\n    color: #e5efff;\n  }\n\n  .note {\n    margin-top: 10px;\n    color: var(--muted);\n    font-size: 12px;\n  }\n  .badge {\n    display: inline-block;\n    padding: 3px 8px;\n    border-radius: 999px;\n    background: rgba(16,185,129,0.18);\n    color: #a7f3d0;\n    border: 1px solid rgba(16,185,129,0.3);\n    font-weight: 700;\n    font-size: 11px;\n    letter-spacing: 0.3px;\n    vertical-align: middle;\n  }\n  .error {\n    color: var(--bad);\n    font-weight: 700;\n  }\n</style>\n</head>\n<body>\n  <header>\n    <h1>Bubble Sort Visualizer</h1>\n    <div class=\"subtitle\">Step through and watch how the largest elements bubble to the end on each pass.</div>\n  </header>\n\n  <div class=\"app\">\n    <div class=\"controls\">\n      <div class=\"row\">\n        <div class=\"group\">\n          <button id=\"randomBtn\" class=\"btn\">Randomize</button>\n          <button id=\"resetBtn\" class=\"btn\">Reset</button>\n          <span id=\"status\" class=\"badge\" title=\"Status\">READY</span>\n        </div>\n        <div class=\"spacer\"></div>\n        <div class=\"group\">\n          <button id=\"startBtn\" class=\"btn primary\">Start</button>\n          <button id=\"pauseBtn\" class=\"btn\">Pause</button>\n          <button id=\"stepBtn\" class=\"btn\">Step</button>\n        </div>\n      </div>\n\n      <div class=\"row\">\n        <div class=\"slider-wrap\">\n          <div class=\"label\">Size: <span id=\"sizeVal\">25</span></div>\n          <input id=\"size\" type=\"range\" min=\"5\" max=\"75\" step=\"1\" value=\"25\" />\n        </div>\n        <div class=\"slider-wrap\">\n          <div class=\"label\">Speed: <span id=\"speedVal\">Medium</span></div>\n          <input id=\"speed\" type=\"range\" min=\"1\" max=\"100\" step=\"1\" value=\"60\" />\n        </div>\n        <div class=\"group\" style=\"flex:1\">\n          <input id=\"arrayInput\" class=\"input\" placeholder=\"Enter numbers (e.g., 5,1,4,2,8)\" />\n          <button id=\"loadBtn\" class=\"btn\">Load</button>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"board\">\n      <div class=\"panel\">\n        <div class=\"bars-wrap\">\n          <div class=\"bars\" id=\"bars\"></div>\n          <div class=\"pass-overlay\"><div id=\"boundary\" class=\"boundary\" style=\"width:0%\"></div></div>\n        </div>\n        <div class=\"legend\">\n          <span class=\"chip\"><span class=\"dot bar\"></span> Unsorted</span>\n          <span class=\"chip\"><span class=\"dot compare\"></span> Comparing</span>\n          <span class=\"chip\"><span class=\"dot swap\"></span> Swapping</span>\n          <span class=\"chip\"><span class=\"dot sorted\"></span> Sorted</span>\n          <span class=\"chip\"><span class=\"dot boundary\"></span> Completed region</span>\n        </div>\n        <div class=\"stats\">\n          <div class=\"stat\"><div class=\"k\">Pass</div><div id=\"statPass\" class=\"v\">0</div></div>\n          <div class=\"stat\"><div class=\"k\">Comparisons</div><div id=\"statComp\" class=\"v\">0</div></div>\n          <div class=\"stat\"><div class=\"k\">Swaps</div><div id=\"statSwap\" class=\"v\">0</div></div>\n          <div class=\"stat\"><div class=\"k\">Array Size</div><div id=\"statSize\" class=\"v\">0</div></div>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <div class=\"label\" style=\"margin-bottom:6px;\">Bubble Sort (optimized with early exit)</div>\n        <div class=\"code\">\n          <ol id=\"code\">\n            <li data-line=\"1\">function bubbleSort(A):</li>\n            <li data-line=\"2\">  n = length(A)</li>\n            <li data-line=\"3\">  repeat</li>\n            <li data-line=\"4\">    swapped = false</li>\n            <li data-line=\"5\">    for i from 0 to n-2:</li>\n            <li data-line=\"6\">      if A[i] > A[i+1]:</li>\n            <li data-line=\"7\">        swap(A[i], A[i+1])</li>\n            <li data-line=\"8\">        swapped = true</li>\n            <li data-line=\"9\">    n = n - 1</li>\n            <li data-line=\"10\">  until swapped == false</li>\n          </ol>\n        </div>\n\n        <div class=\"note\">\n          - Stable, in-place sorting algorithm<br />\n          - Worst/average time: O(n²), Best (nearly sorted): O(n) with early exit<br />\n          - Each pass places the next largest item at the end of the array\n        </div>\n      </div>\n    </div>\n  </div>\n\n<script>\n(function() {\n  // DOM helpers\n  const $ = sel => document.querySelector(sel);\n  const barsEl = $('#bars');\n  const boundaryEl = $('#boundary');\n\n  const startBtn = $('#startBtn');\n  const pauseBtn = $('#pauseBtn');\n  const stepBtn = $('#stepBtn');\n  const resetBtn = $('#resetBtn');\n  const randomBtn = $('#randomBtn');\n  const loadBtn   = $('#loadBtn');\n\n  const sizeInput = $('#size');\n  const speedInput = $('#speed');\n  const sizeVal = $('#sizeVal');\n  const speedVal = $('#speedVal');\n  const arrayInput = $('#arrayInput');\n\n  const statPass = $('#statPass');\n  const statComp = $('#statComp');\n  const statSwap = $('#statSwap');\n  const statSize = $('#statSize');\n\n  const statusBadge = $('#status');\n\n  const codeBlock = $('#code');\n  const codeLines = [...codeBlock.querySelectorAll('li')];\n\n  // State\n  let arr = [];\n  let initialArr = [];\n  let sorting = false;\n  let playing = false;\n  let pass = 0;\n  let comparisons = 0;\n  let swaps = 0;\n  let runId = 0;        // cancellation token\n  let stepResolver = null;\n  let speedMs = 100;    // delay per step\n  let lastBoundary = 0; // right-finished region size\n\n  // Utilities\n  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));\n\n  function setStatus(text, colorClass) {\n    statusBadge.textContent = text;\n    statusBadge.style.background = '';\n    statusBadge.style.borderColor = '';\n    statusBadge.style.color = '';\n    if (colorClass === 'run') {\n      statusBadge.style.background = 'rgba(96,165,250,0.18)';\n      statusBadge.style.borderColor = 'rgba(96,165,250,0.32)';\n      statusBadge.style.color = '#bfdbfe';\n    } else if (colorClass === 'ok') {\n      statusBadge.style.background = 'rgba(16,185,129,0.18)';\n      statusBadge.style.borderColor = 'rgba(16,185,129,0.32)';\n      statusBadge.style.color = '#a7f3d0';\n    } else if (colorClass === 'warn') {\n      statusBadge.style.background = 'rgba(251,146,60,0.18)';\n      statusBadge.style.borderColor = 'rgba(251,146,60,0.32)';\n      statusBadge.style.color = '#fed7aa';\n    } else if (colorClass === 'err') {\n      statusBadge.style.background = 'rgba(239,68,68,0.18)';\n      statusBadge.style.borderColor = 'rgba(239,68,68,0.32)';\n      statusBadge.style.color = '#fecaca';\n    }\n  }\n\n  function mapSpeedToMs(v) {\n    // v in [1..100], 1 = slowest, 100 = fastest\n    // Map to [700..15] ms with ease-out curve\n    const t = v / 100;\n    const eased = 1 - Math.pow(1 - t, 2); // quadratic ease-out\n    return Math.round(700 - eased * (700 - 15));\n  }\n\n  function speedLabel(v) {\n    if (v <= 20) return 'Very Slow';\n    if (v <= 40) return 'Slow';\n    if (v <= 60) return 'Medium';\n    if (v <= 80) return 'Fast';\n    return 'Very Fast';\n  }\n\n  function highlightCode(lines) {\n    codeLines.forEach(li => li.classList.remove('hl'));\n    lines.forEach(n => {\n      const li = codeLines.find(l => Number(l.dataset.line) === n);\n      if (li) li.classList.add('hl');\n    });\n  }\n\n  // Array and visualization\n  function randomArray(n) {\n    const out = [];\n    for (let i = 0; i < n; i++) {\n      // values between 5 and 100\n      out.push(5 + Math.floor(Math.random() * 96));\n    }\n    return out;\n  }\n\n  function renderBars(values, active = {}) {\n    const maxVal = Math.max(...values, 1);\n    const h = barsEl.clientHeight || 340;\n    const scale = (h - 30) / maxVal; // leave room for labels\n    barsEl.innerHTML = '';\n    for (let i = 0; i < values.length; i++) {\n      const bar = document.createElement('div');\n      bar.className = 'bar';\n      bar.style.height = Math.max(2, Math.round(values[i] * scale)) + 'px';\n      bar.dataset.val = values[i];\n      if (active.compare && (i === active.compare[0] || i === active.compare[1])) bar.classList.add('compare');\n      if (active.swap && (i === active.swap[0] || i === active.swap[1])) bar.classList.add('swap');\n      if (active.sorted && i >= active.sorted.from) bar.classList.add('sorted');\n      barsEl.appendChild(bar);\n    }\n  }\n\n  function updateBars(values, active = {}) {\n    // update in place to allow CSS transitions\n    const nodes = barsEl.children;\n    const maxVal = Math.max(...values, 1);\n    const h = barsEl.clientHeight || 340;\n    const scale = (h - 30) / maxVal;\n    for (let i = 0; i < values.length; i++) {\n      const bar = nodes[i];\n      bar.style.height = Math.max(2, Math.round(values[i] * scale)) + 'px';\n      bar.dataset.val = values[i];\n      bar.classList.toggle('compare', !!(active.compare && (i === active.compare[0] || i === active.compare[1])));\n      bar.classList.toggle('swap', !!(active.swap && (i === active.swap[0] || i === active.swap[1])));\n      bar.classList.toggle('sorted', !!(active.sorted && i >= active.sorted.from));\n    }\n  }\n\n  function setBoundary(endIndexExclusive) {\n    // Right side completed width: portion of array already sorted at end\n    const n = arr.length;\n    const done = n - endIndexExclusive;\n    const pct = clamp((done / n) * 100, 0, 100);\n    boundaryEl.style.width = pct.toFixed(2) + '%';\n  }\n\n  function resetStats() {\n    pass = 0; comparisons = 0; swaps = 0; lastBoundary = 0;\n    statPass.textContent = pass;\n    statComp.textContent = comparisons;\n    statSwap.textContent = swaps;\n    statSize.textContent = arr.length;\n  }\n\n  function setButtons() {\n    startBtn.disabled = sorting && playing;\n    pauseBtn.disabled = !sorting || !playing;\n    stepBtn.disabled = sorting && playing ? false : false; // allow step anytime; it will pause if needed\n    resetBtn.disabled = false;\n  }\n\n  function cancelCurrentRun() {\n    runId++;\n    sorting = false;\n    playing = false;\n    if (stepResolver) { try { stepResolver(); } catch {} stepResolver = null; }\n    setButtons();\n  }\n\n  function sleepOrStep() {\n    const myRun = runId;\n    return new Promise(resolve => {\n      if (myRun !== runId) return resolve(); // cancelled\n      if (playing) {\n        setTimeout(() => { resolve(); }, speedMs);\n      } else {\n        // wait for step\n        stepResolver = () => { resolve(); stepResolver = null; };\n      }\n    });\n  }\n\n  // Sorting\n  async function bubbleSortVisual() {\n    const myRun = ++runId;\n    sorting = true; playing = true;\n    setStatus('RUNNING', 'run');\n    setButtons();\n    highlightCode([1,2]);\n\n    let n = arr.length;\n    setBoundary(n); // 0% sorted\n    renderBars(arr, { sorted: {from: n} }); // no sorted initially\n\n    await sleepOrStep();\n    while (true) {\n      if (myRun !== runId) return; // cancelled\n      pass++; statPass.textContent = pass;\n      highlightCode([3,4]);\n      let swapped = false;\n\n      // Inner loop\n      highlightCode([5]);\n      for (let i = 0; i < n - 1; i++) {\n        if (myRun !== runId) return;\n        // compare\n        highlightCode([5,6]);\n        updateBars(arr, { compare: [i, i+1], sorted: {from: n} });\n        await sleepOrStep();\n        comparisons++; statComp.textContent = comparisons;\n\n        if (arr[i] > arr[i+1]) {\n          // swap\n          highlightCode([6,7,8]);\n          [arr[i], arr[i+1]] = [arr[i+1], arr[i]];\n          swaps++; statSwap.textContent = swaps;\n          updateBars(arr, { swap: [i, i+1], sorted: {from: n} });\n          await sleepOrStep();\n          swapped = true;\n        }\n\n        // clear compare/swap for next step but keep sorted overlay\n        updateBars(arr, { sorted: {from: n} });\n      }\n\n      // one element settled to the end\n      n = n - 1;\n      highlightCode([9]);\n      setBoundary(n);\n      updateBars(arr, { sorted: {from: n} });\n      await sleepOrStep();\n\n      // early exit\n      highlightCode([10]);\n      if (!swapped) {\n        // mark all as sorted\n        setBoundary(0);\n        updateBars(arr, { sorted: {from: 0} });\n        break;\n      }\n\n      if (n <= 1) {\n        // fully sorted\n        setBoundary(0);\n        updateBars(arr, { sorted: {from: 0} });\n        break;\n      }\n    }\n\n    sorting = false; playing = false;\n    setButtons();\n    setStatus('DONE', 'ok');\n  }\n\n  // Input parsing\n  function parseArrayInput(text) {\n    const parts = text.split(/[\\s,]+/).filter(Boolean);\n    if (parts.length === 0) return null;\n    const nums = parts.map(p => Number(p));\n    if (nums.some(n => !Number.isFinite(n))) return null;\n    // clip values to [0..999] to keep visible\n    return nums.map(n => Math.round(clamp(n, 0, 999)));\n  }\n\n  // Event handlers\n  randomBtn.addEventListener('click', () => {\n    cancelCurrentRun();\n    const n = Number(sizeInput.value);\n    arr = randomArray(n);\n    initialArr = arr.slice();\n    resetStats();\n    setBoundary(arr.length);\n    renderBars(arr, { sorted: {from: arr.length} });\n    setStatus('READY', 'ok');\n  });\n\n  resetBtn.addEventListener('click', () => {\n    cancelCurrentRun();\n    if (initialArr.length) {\n      arr = initialArr.slice();\n    }\n    resetStats();\n    setBoundary(arr.length);\n    renderBars(arr, { sorted: {from: arr.length} });\n    setStatus('RESET', 'ok');\n  });\n\n  startBtn.addEventListener('click', async () => {\n    if (!sorting) {\n      bubbleSortVisual().catch(() => {});\n    } else {\n      playing = true;\n      setButtons();\n      if (stepResolver) { stepResolver(); stepResolver = null; }\n      setStatus('RUNNING', 'run');\n    }\n  });\n\n  pauseBtn.addEventListener('click', () => {\n    playing = false;\n    setButtons();\n    setStatus('PAUSED', 'warn');\n  });\n\n  stepBtn.addEventListener('click', () => {\n    if (!sorting) {\n      // start in paused mode\n      playing = false;\n      bubbleSortVisual().catch(() => {});\n      setStatus('STEPPING', 'warn');\n    } else {\n      // ensure paused and advance one step\n      playing = false;\n      setButtons();\n      if (stepResolver) { stepResolver(); stepResolver = null; }\n      setStatus('STEPPING', 'warn');\n    }\n  });\n\n  loadBtn.addEventListener('click', () => {\n    const text = arrayInput.value.trim();\n    const nums = parseArrayInput(text);\n    if (!nums) {\n      setStatus('INPUT ERROR', 'err');\n      arrayInput.classList.add('error');\n      setTimeout(() => arrayInput.classList.remove('error'), 600);\n      return;\n    }\n    cancelCurrentRun();\n    arr = nums.slice();\n    initialArr = arr.slice();\n    sizeInput.value = String(arr.length);\n    sizeVal.textContent = String(arr.length);\n    resetStats();\n    setBoundary(arr.length);\n    renderBars(arr, { sorted: {from: arr.length} });\n    setStatus('LOADED', 'ok');\n  });\n\n  sizeInput.addEventListener('input', () => {\n    const n = Number(sizeInput.value);\n    sizeVal.textContent = n;\n  });\n\n  sizeInput.addEventListener('change', () => {\n    // regenerate random with new size\n    const n = Number(sizeInput.value);\n    cancelCurrentRun();\n    arr = randomArray(n);\n    initialArr = arr.slice();\n    resetStats();\n    setBoundary(arr.length);\n    renderBars(arr, { sorted: {from: arr.length} });\n    setStatus('READY', 'ok');\n  });\n\n  speedInput.addEventListener('input', () => {\n    const v = Number(speedInput.value);\n    speedMs = mapSpeedToMs(v);\n    speedVal.textContent = speedLabel(v);\n  });\n\n  // Init\n  function init() {\n    const n = Number(sizeInput.value);\n    speedMs = mapSpeedToMs(Number(speedInput.value));\n    speedVal.textContent = speedLabel(Number(speedInput.value));\n    arr = randomArray(n);\n    initialArr = arr.slice();\n    resetStats();\n    setBoundary(arr.length);\n    renderBars(arr, { sorted: {from: arr.length} });\n    highlightCode([1,2]);\n    setButtons();\n    setStatus('READY', 'ok');\n  }\n\n  // Resize handling to keep heights scaled\n  let resizeTimer = null;\n  window.addEventListener('resize', () => {\n    if (resizeTimer) cancelAnimationFrame(resizeTimer);\n    resizeTimer = requestAnimationFrame(() => {\n      updateBars(arr, { sorted: {from: sorting ? Math.max(0, arr.length - lastBoundary) : arr.length } });\n    });\n  });\n\n  init();\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "bubble sort"
      }
    ],
    "evaluation": {
      "score": {
        "interactivity_score": 4,
        "user_control_score": 5,
        "visual_clarity_score": 3,
        "missing_features": [
          "canvas",
          "svg",
          "visual representation of sorting process"
        ],
        "comments": "The visualization offers good interactivity and user control, but lacks visual clarity and representation of the sorting process."
      },
      "notes": "",
      "timestamp": "2025-10-07T12:47:02.724Z"
    }
  }
]