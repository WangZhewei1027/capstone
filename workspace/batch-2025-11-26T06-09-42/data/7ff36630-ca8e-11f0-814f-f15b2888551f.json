{
  "id": "7ff36630-ca8e-11f0-814f-f15b2888551f",
  "timestamp": "2025-11-26T06:11:15.914Z",
  "model": "gemini-2.5-pro",
  "status": "success",
  "question": "Deque",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Deque (Double-Ended Queue) Visualization</title>\n    <style>\n        body {\n            font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\n            background-color: #f0f2f5;\n            color: #333;\n            display: flex;\n            justify-content: center;\n            align-items: flex-start;\n            padding: 20px;\n            min-height: 100vh;\n            margin: 0;\n        }\n\n        .container {\n            background: #ffffff;\n            padding: 30px;\n            border-radius: 12px;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n            width: 90%;\n            max-width: 800px;\n            text-align: center;\n        }\n\n        h1 {\n            color: #1a73e8;\n            border-bottom: 2px solid #e0e0e0;\n            padding-bottom: 10px;\n            margin-top: 0;\n        }\n        \n        p.description {\n            font-size: 1.1em;\n            color: #555;\n            margin-bottom: 25px;\n            line-height: 1.6;\n        }\n\n        .controls {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\n            gap: 15px;\n            margin-bottom: 30px;\n        }\n\n        .control-group {\n            display: flex;\n            flex-direction: column;\n            gap: 10px;\n        }\n\n        input[type=\"text\"] {\n            padding: 10px;\n            border: 1px solid #ccc;\n            border-radius: 6px;\n            font-size: 1em;\n            width: 100%;\n            box-sizing: border-box;\n        }\n        \n        input[type=\"text\"]:focus {\n            outline: none;\n            border-color: #1a73e8;\n            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);\n        }\n\n        button {\n            padding: 10px 15px;\n            border: none;\n            border-radius: 6px;\n            font-size: 1em;\n            cursor: pointer;\n            transition: background-color 0.2s, transform 0.1s;\n            font-weight: 500;\n        }\n\n        button:active {\n            transform: scale(0.98);\n        }\n        \n        /* Button colors */\n        .btn-add { background-color: #34a853; color: white; }\n        .btn-add:hover { background-color: #2c8f45; }\n        .btn-remove { background-color: #ea4335; color: white; }\n        .btn-remove:hover { background-color: #c5372c; }\n        .btn-peek { background-color: #fbbc05; color: white; }\n        .btn-peek:hover { background-color: #d99f04; }\n        .btn-info { background-color: #4285f4; color: white; }\n        .btn-info:hover { background-color: #3572dc; }\n\n\n        .visualization-area {\n            background-color: #f8f9fa;\n            border: 1px dashed #ccc;\n            border-radius: 8px;\n            padding: 20px;\n            min-height: 100px;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            flex-wrap: wrap;\n            gap: 10px;\n            position: relative;\n            overflow: hidden;\n            margin-top: 20px;\n        }\n        \n        .labels {\n            width: 100%;\n            display: flex;\n            justify-content: space-between;\n            position: absolute;\n            top: 5px;\n            left: 0;\n            padding: 0 25px;\n            font-weight: bold;\n            color: #666;\n            font-size: 0.9em;\n            text-transform: uppercase;\n        }\n\n        .deque-element {\n            background-color: #1a73e8;\n            color: white;\n            padding: 15px 20px;\n            border-radius: 6px;\n            font-weight: bold;\n            font-size: 1.2em;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n            animation: fadeIn 0.5s ease-out;\n        }\n        \n        .empty-message {\n            color: #999;\n            font-style: italic;\n        }\n\n        .info-display {\n            margin-top: 20px;\n            padding: 15px;\n            background-color: #e8f0fe;\n            border: 1px solid #c6dafc;\n            border-radius: 8px;\n            min-height: 24px;\n            font-family: 'Courier New', Courier, monospace;\n            font-weight: bold;\n            font-size: 1.1em;\n            color: #174ea6;\n        }\n\n        @keyframes fadeIn {\n            from { opacity: 0; transform: scale(0.8); }\n            to { opacity: 1; transform: scale(1); }\n        }\n    </style>\n</head>\n<body>\n\n    <div class=\"container\">\n        <h1>Deque (Double-Ended Queue)</h1>\n        <p class=\"description\">\n            A Deque is a data structure where elements can be added or removed from either the front or the rear.\n            This makes it a generalization of both a stack (LIFO) and a queue (FIFO).\n            Try adding and removing elements from both ends to see how it works!\n        </p>\n\n        <div class=\"controls\">\n            <div class=\"control-group\">\n                <input type=\"text\" id=\"elementValue\" placeholder=\"Enter a value\">\n                <button class=\"btn-add\" onclick=\"app.addFront()\">Add to Front</button>\n                <button class=\"btn-add\" onclick=\"app.addBack()\">Add to Back</button>\n            </div>\n            <div class=\"control-group\">\n                <button class=\"btn-remove\" onclick=\"app.removeFront()\">Remove from Front</button>\n                <button class=\"btn-remove\" onclick=\"app.removeBack()\">Remove from Back</button>\n            </div>\n            <div class=\"control-group\">\n                 <button class=\"btn-peek\" onclick=\"app.peekFront()\">Peek Front</button>\n                 <button class=\"btn-peek\" onclick=\"app.peekBack()\">Peek Back</button>\n            </div>\n            <div class=\"control-group\">\n                <button class=\"btn-info\" onclick=\"app.getSize()\">Get Size</button>\n                <button class=\"btn-info\" onclick=\"app.checkEmpty()\">Is Empty?</button>\n            </div>\n        </div>\n\n        <div class=\"visualization-area\" id=\"deque-visual\">\n            <div class=\"labels\">\n                <span>Front</span>\n                <span>Back</span>\n            </div>\n            <div class=\"empty-message\">Deque is empty</div>\n        </div>\n        \n        <div class=\"info-display\" id=\"infoDisplay\">\n            Perform an action to see the result.\n        </div>\n    </div>\n\n    <script>\n        // Deque Class Implementation\n        class Deque {\n            constructor() {\n                // Using an object to store elements allows for efficient\n                // additions/removals at the front by using negative indices.\n                this.items = {};\n                this.headIndex = 0; // Points to the first element\n                this.tailIndex = -1; // Points to the last element\n            }\n\n            // Adds an element to the front of the deque\n            addFront(element) {\n                if (this.isEmpty()) {\n                    this.items[this.headIndex] = element;\n                    this.tailIndex = this.headIndex;\n                } else {\n                    this.headIndex--;\n                    this.items[this.headIndex] = element;\n                }\n            }\n\n            // Adds an element to the back of the deque\n            addBack(element) {\n                if (this.isEmpty()) {\n                     this.addFront(element);\n                } else {\n                    this.tailIndex++;\n                    this.items[this.tailIndex] = element;\n                }\n            }\n\n            // Removes and returns the front element\n            removeFront() {\n                if (this.isEmpty()) {\n                    return undefined;\n                }\n                const result = this.items[this.headIndex];\n                delete this.items[this.headIndex];\n                if (this.headIndex === this.tailIndex) { // Deque becomes empty\n                    this.headIndex = 0;\n                    this.tailIndex = -1;\n                } else {\n                    this.headIndex++;\n                }\n                return result;\n            }\n\n            // Removes and returns the back element\n            removeBack() {\n                if (this.isEmpty()) {\n                    return undefined;\n                }\n                const result = this.items[this.tailIndex];\n                delete this.items[this.tailIndex];\n                 if (this.headIndex === this.tailIndex) { // Deque becomes empty\n                    this.headIndex = 0;\n                    this.tailIndex = -1;\n                } else {\n                    this.tailIndex--;\n                }\n                return result;\n            }\n\n            // Returns the front element without removing it\n            peekFront() {\n                if (this.isEmpty()) {\n                    return undefined;\n                }\n                return this.items[this.headIndex];\n            }\n\n            // Returns the back element without removing it\n            peekBack() {\n                if (this.isEmpty()) {\n                    return undefined;\n                }\n                return this.items[this.tailIndex];\n            }\n            \n            // Returns true if the deque is empty, false otherwise\n            isEmpty() {\n                return this.tailIndex < this.headIndex;\n            }\n\n            // Returns the number of elements in the deque\n            size() {\n                if (this.isEmpty()) {\n                    return 0;\n                }\n                return this.tailIndex - this.headIndex + 1;\n            }\n\n            // Returns an array representation of the deque\n            toArray() {\n                if (this.isEmpty()) {\n                    return [];\n                }\n                const arr = [];\n                for (let i = this.headIndex; i <= this.tailIndex; i++) {\n                    arr.push(this.items[i]);\n                }\n                return arr;\n            }\n        }\n\n        // Application Logic to connect Deque to the UI\n        const app = {\n            deque: new Deque(),\n            elements: {\n                input: document.getElementById('elementValue'),\n                visual: document.getElementById('deque-visual'),\n                info: document.getElementById('infoDisplay')\n            },\n\n            // Renders the current state of the deque in the visualization area\n            render() {\n                this.elements.visual.innerHTML = `\n                    <div class=\"labels\">\n                        <span>Front</span>\n                        <span>Back</span>\n                    </div>`; // Clear previous content but keep labels\n                \n                const dequeArray = this.deque.toArray();\n\n                if (dequeArray.length === 0) {\n                    this.elements.visual.innerHTML += `<div class=\"empty-message\">Deque is empty</div>`;\n                } else {\n                    dequeArray.forEach(item => {\n                        const elementDiv = document.createElement('div');\n                        elementDiv.className = 'deque-element';\n                        elementDiv.textContent = item;\n                        this.elements.visual.appendChild(elementDiv);\n                    });\n                }\n            },\n\n            // Updates the info display panel\n            updateInfo(message) {\n                this.elements.info.textContent = message;\n            },\n            \n            // Gets value from input, clears it, and gives it focus\n            getInputValue() {\n                const value = this.elements.input.value.trim();\n                if (value === '') {\n                    this.updateInfo('Please enter a value to add.');\n                    return null;\n                }\n                this.elements.input.value = '';\n                this.elements.input.focus();\n                return value;\n            },\n\n            addFront() {\n                const value = this.getInputValue();\n                if (value !== null) {\n                    this.deque.addFront(value);\n                    this.render();\n                    this.updateInfo(`Added \"${value}\" to the front.`);\n                }\n            },\n\n            addBack() {\n                const value = this.getInputValue();\n                if (value !== null) {\n                    this.deque.addBack(value);\n                    this.render();\n                    this.updateInfo(`Added \"${value}\" to the back.`);\n                }\n            },\n\n            removeFront() {\n                const removedValue = this.deque.removeFront();\n                this.render();\n                if (removedValue !== undefined) {\n                    this.updateInfo(`Removed \"${removedValue}\" from the front.`);\n                } else {\n                    this.updateInfo('Cannot remove from front: Deque is empty.');\n                }\n            },\n\n            removeBack() {\n                const removedValue = this.deque.removeBack();\n                this.render();\n                if (removedValue !== undefined) {\n                    this.updateInfo(`Removed \"${removedValue}\" from the back.`);\n                } else {\n                    this.updateInfo('Cannot remove from back: Deque is empty.');\n                }\n            },\n\n            peekFront() {\n                const value = this.deque.peekFront();\n                if (value !== undefined) {\n                    this.updateInfo(`Front element is \"${value}\".`);\n                } else {\n                    this.updateInfo('Cannot peek front: Deque is empty.');\n                }\n            },\n\n            peekBack() {\n                const value = this.deque.peekBack();\n                if (value !== undefined) {\n                    this.updateInfo(`Back element is \"${value}\".`);\n                } else {\n                    this.updateInfo('Cannot peek back: Deque is empty.');\n                }\n            },\n            \n            getSize() {\n                const size = this.deque.size();\n                this.updateInfo(`The deque contains ${size} element(s).`);\n            },\n            \n            checkEmpty() {\n                const isEmpty = this.deque.isEmpty();\n                this.updateInfo(`Is the deque empty? ${isEmpty}.`);\n            }\n        };\n        \n        // Add keypress listener to the input field\n        app.elements.input.addEventListener('keypress', function(event) {\n            if (event.key === 'Enter') {\n                // Default action is to add to the back\n                app.addBack();\n            }\n        });\n\n        // Initial render\n        app.render();\n\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Deque"
    }
  ],
  "topic": "Deque",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}