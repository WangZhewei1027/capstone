{
  "id": "39b8ffb1-d1d5-11f0-b49a-6f458b3a25ef",
  "timestamp": "2025-12-05T12:24:55.297Z",
  "type": "html-to-test",
  "htmlModel": "gpt-4o-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>K-Means Clustering Demo</title>\n    <style>\n        canvas {\n            border: 1px solid #000;\n        }\n        #controls {\n            margin-top: 10px;\n        }\n    </style>\n</head>\n<body>\n    <h1>K-Means Clustering Visualization</h1>\n    <canvas id=\"canvas\" width=\"500\" height=\"400\"></canvas>\n    <div id=\"controls\">\n        <button id=\"generateData\">Generate Random Data</button>\n        <button id=\"kMeans\">Run K-Means</button>\n        <label for=\"kInput\">Number of Clusters (k):</label>\n        <input type=\"number\" id=\"kInput\" value=\"3\" min=\"1\" max=\"10\">\n    </div>\n    \n    <script>\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        let points = [];\n        const clusters = [];\n        const kMeansIterations = 10;\n\n        function generateRandomData() {\n            points = [];\n            for(let i = 0; i < 100; i++) {\n                points.push({\n                    x: Math.random() * canvas.width,\n                    y: Math.random() * canvas.height\n                });\n            }\n            drawPoints();\n        }\n\n        function drawPoints() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'lightgray';\n            points.forEach(point => {\n                ctx.beginPath();\n                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\n                ctx.fill();\n            });\n        }\n\n        function kMeans(k) {\n            // Randomly initialize centroids\n            clusters.length = 0; // Clear existing clusters\n            for (let i = 0; i < k; i++) {\n                let centroid = {\n                    x: Math.random() * canvas.width,\n                    y: Math.random() * canvas.height\n                };\n                clusters.push({\n                    centroid,\n                    points: []\n                });\n            }\n\n            for (let iteration = 0; iteration < kMeansIterations; iteration++) {\n                // Clear points in clusters\n                clusters.forEach(cluster => cluster.points = []);\n\n                // Assign points to nearest centroid\n                points.forEach(point => {\n                    const nearestCluster = clusters.reduce((prev, curr) => {\n                        const prevDist = distance(point, prev.centroid);\n                        const currDist = distance(point, curr.centroid);\n                        return (prevDist < currDist) ? prev : curr;\n                    });\n\n                    nearestCluster.points.push(point);\n                });\n\n                // Update centroids\n                clusters.forEach(cluster => {\n                    if (cluster.points.length > 0) {\n                        const newCentroid = calculateCentroid(cluster.points);\n                        cluster.centroid.x = newCentroid.x;\n                        cluster.centroid.y = newCentroid.y;\n                    }\n                });\n            }\n\n            drawClusters();\n        }\n\n        function distance(pointA, pointB) {\n            return Math.sqrt((pointA.x - pointB.x) ** 2 + (pointA.y - pointB.y) ** 2);\n        }\n\n        function calculateCentroid(points) {\n            const sum = points.reduce((acc, point) => {\n                acc.x += point.x;\n                acc.y += point.y;\n                return acc;\n            }, { x: 0, y: 0 });\n            return {\n                x: sum.x / points.length,\n                y: sum.y / points.length\n            };\n        }\n\n        function drawClusters() {\n            // Clear canvas and redraw points\n            drawPoints();\n            ctx.fillStyle = 'red';\n            clusters.forEach(cluster => {\n                ctx.fillStyle = 'blue';\n                cluster.points.forEach(point => {\n                    ctx.beginPath();\n                    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\n                    ctx.fill();\n                });\n                ctx.beginPath();\n                ctx.arc(cluster.centroid.x, cluster.centroid.y, 10, 0, Math.PI * 2);\n                ctx.fillStyle = 'yellow';\n                ctx.fill();\n            });\n        }\n\n        document.getElementById('generateData').addEventListener('click', generateRandomData);\n        document.getElementById('kMeans').addEventListener('click', () => {\n            const k = parseInt(document.getElementById('kInput').value);\n            kMeans(k);\n        });\n\n        // Generate initial random data\n        generateRandomData();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": false,
  "hasTest": true
}