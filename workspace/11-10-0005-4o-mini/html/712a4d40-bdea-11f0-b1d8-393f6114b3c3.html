<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Nearest Neighbors (KNN)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: #f4f4f4;
            padding: 24px;
        }
        h1 {
            margin-bottom: 24px;
        }
        #canvas {
            border: 1px solid #ccc;
            background-color: white;
            position: relative;
            width: 80vw;
            height: 60vh;
            margin-bottom: 24px;
        }
        #controls {
            width: 20vw;
            display: flex;
            flex-direction: column;
            margin-top: 16px;
        }
        .control {
            margin-bottom: 16px;
        }
        #btnClassify {
            padding: 10px;
            background-color: #007BFF;
            color: white;
            border: none;
            cursor: pointer;
        }
        #btnClassify:hover {
            background-color: #0056b3;
        }

    </style>
</head>
<body>
    <h1>Exploring K-Nearest Neighbors (KNN)</h1>
    <div id="canvas"></div>
    <div id="controls">
        <div class="control">
            <label for="kValue">Select K:</label>
            <input type="range" id="kValue" min="1" max="10" value="3" />
            <span id="kDisplay">K = 3</span>
        </div>
        <button id="btnClassify">Classify Point</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const kValueInput = document.getElementById('kValue');
        const kDisplay = document.getElementById('kDisplay');
        const btnClassify = document.getElementById('btnClassify');
        
        let kValue = parseInt(kValueInput.value);
        let points = [];
        let classes = []; // 0 for Class A, 1 for Class B
    
        function updateKDisplay() {
            kDisplay.innerText = `K = ${kValue}`;
        }

        kValueInput.addEventListener('input', (event) => {
            kValue = parseInt(event.target.value);
            updateKDisplay();
        });

        function drawPoints() {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            points.forEach((point, index) => {
                ctx.fillStyle = classes[index] === 0 ? 'blue' : 'red';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const newClass = points.length % 2 === 0 ? 0 : 1; // Alternate classes for testing
            points.push({ x, y });
            classes.push(newClass);
            drawPoints();
        });

        btnClassify.addEventListener('click', () => {
            const newPoint = points[points.length - 1]; // Classify the last added point
            if (points.length < 1) return; // Need at least one point

            let distances = points.map((point, index) => ({
                point,
                class: classes[index],
                distance: Math.hypot(point.x - newPoint.x, point.y - newPoint.y)
            }));
            distances.sort((a, b) => a.distance - b.distance);
            const nearestNeighbors = distances.slice(0, kValue);
            const classCount = { 0: 0, 1: 0 };

            nearestNeighbors.forEach(neighbor => {
                classCount[neighbor.class]++;
            });

            const predictedClass = classCount[0] > classCount[1] ? 0 : 1;
            alert(`Predicted Class: ${predictedClass === 0 ? 'Class A (Blue)' : 'Class B (Red)'}`);

            const ctx = canvas.getContext('2d');
            nearestNeighbors.forEach(neighbor => {
                ctx.beginPath();
                ctx.moveTo(newPoint.x, newPoint.y);
                ctx.lineTo(neighbor.point.x, neighbor.point.y);
                ctx.strokeStyle = 'green';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(neighbor.point.x, neighbor.point.y, 5, 0, 2 * Math.PI);
                ctx.fill();
            });
        });
    </script>
</body>
</html>