<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Deque (Double-Ended Queue) Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 2em;
    background: #f9f9f9;
  }
  h1 {
    text-align: center;
    color: #333;
  }
  .container {
    max-width: 700px;
    margin: 1em auto;
    background: white;
    padding: 1.5em;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgb(0 0 0 / 0.1);
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 1em;
    margin-bottom: 1em;
  }
  .controls > * {
    flex: 1 1 120px;
  }
  input[type="text"] {
    padding: 0.5em;
    font-size: 1em;
    border: 1px solid #bbb;
    border-radius: 4px;
    width: 100%;
    box-sizing: border-box;
  }
  button {
    padding: 0.6em 1em;
    font-size: 1em;
    border: none;
    background-color: #2874f0;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s ease;
    user-select: none;
  }
  button:disabled {
    background-color: #aaa;
    cursor: default;
  }
  button:hover:not(:disabled) {
    background-color: #1a52d8;
  }
  .deque-display {
    margin-top: 1.5em;
    padding: 1em;
    background: #eef5ff;
    border-radius: 6px;
    min-height: 3em;
    font-family: monospace;
    font-size: 1.2rem;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .deque-container {
    display: flex;
    gap: 0.6em;
    flex-wrap: nowrap;
    overflow-x: auto;
    max-width: 100%;
  }
  .deque-item {
    background: #4a90e2;
    color: white;
    padding: 0.3em 0.8em;
    border-radius: 4px;
    user-select: none;
    box-shadow: 0 1px 3px rgb(0 0 0 / 0.2);
    white-space: nowrap;
  }
  .label {
    font-weight: bold;
    margin-bottom: 0.5em;
    text-align:center;
  }
  .help-text {
    font-size: 0.9em;
    color: #666;
    text-align: center;
    margin-top: 1em;
  }
  .arrow {
    font-weight: bold;
    font-size: 1.2em;
    color: #555;
    margin: 0 0.8em;
    user-select: none;
  }
  @media (max-width: 480px) {
    .controls {
      flex-direction: column;
    }
    .controls > * {
      flex: 1 1 auto;
    }
  }
</style>
</head>
<body>
  <h1>Deque (Double-Ended Queue) Visualization</h1>
  <div class="container">
    <div class="controls" aria-label="Deque operations controls">
      <input type="text" id="inputValue" placeholder="Enter value" aria-label="Value to insert" />
      <button id="pushFrontBtn" title="Insert element at front">Push Front</button>
      <button id="pushBackBtn" title="Insert element at back">Push Back</button>
      <button id="popFrontBtn" title="Remove element from front">Pop Front</button>
      <button id="popBackBtn" title="Remove element from back">Pop Back</button>
      <button id="clearBtn" title="Clear the deque">Clear</button>
    </div>

    <div class="label" id="dequeLabel">Deque Contents (Front → Back):</div>
    <div class="deque-display" aria-live="polite" aria-atomic="true" aria-relevant="additions removals" role="list" id="dequeDisplay"></div>

    <div class="help-text">
      Use the controls above to insert or remove elements from either end of the deque. The displayed order is from front to back.
    </div>
  </div>

<script>
(() => {
  // Deque class implemented with native array but efficient for demonstration
  class Deque {
    constructor() {
      this._items = [];
    }
    pushFront(item) {
      this._items.unshift(item);
    }
    pushBack(item) {
      this._items.push(item);
    }
    popFront() {
      return this._items.shift();
    }
    popBack() {
      return this._items.pop();
    }
    clear() {
      this._items = [];
    }
    toArray() {
      return this._items.slice();
    }
    isEmpty() {
      return this._items.length === 0;
    }
  }

  const deque = new Deque();

  // DOM references
  const inputValue = document.getElementById("inputValue");
  const pushFrontBtn = document.getElementById("pushFrontBtn");
  const pushBackBtn = document.getElementById("pushBackBtn");
  const popFrontBtn = document.getElementById("popFrontBtn");
  const popBackBtn = document.getElementById("popBackBtn");
  const clearBtn = document.getElementById("clearBtn");
  const dequeDisplay = document.getElementById("dequeDisplay");

  // Utility: sanitize text for display
  function escapeHtml(text) {
    return text.replace(/[&<>"']/g, (m) => {
      switch(m){
        case '&': return '&amp;';
        case '<': return '&lt;';
        case '>': return '&gt;';
        case '"': return '&quot;';
        case "'": return '&#39;';
        default: return m;
      }
    });
  }

  // Update the visual display of the deque
  function updateDisplay() {
    dequeDisplay.innerHTML = ''; // clear current

    const items = deque.toArray();

    if(items.length === 0){
      dequeDisplay.textContent = '(empty)';
      togglePopButtons(false);
      return;
    }

    togglePopButtons(true);

    // Show front and back arrow labels for clarity
    // Let's build a flex container for the items and arrows at ends

    // Front arrow
    const frontArrow = document.createElement('span');
    frontArrow.className = 'arrow';
    frontArrow.textContent = '← Front';

    // Back arrow
    const backArrow = document.createElement('span');
    backArrow.className = 'arrow';
    backArrow.textContent = 'Back →';

    // Container for items
    const itemsContainer = document.createElement('div');
    itemsContainer.className = 'deque-container';
    items.forEach((item, index) => {
      const div = document.createElement('div');
      div.className = 'deque-item';
      div.textContent = item;
      div.setAttribute('role', 'listitem');
      itemsContainer.appendChild(div);
    });

    dequeDisplay.appendChild(frontArrow);
    dequeDisplay.appendChild(itemsContainer);
    dequeDisplay.appendChild(backArrow);
  }

  // Enable or disable pop buttons depending on emptiness
  function togglePopButtons(enabled) {
    popFrontBtn.disabled = !enabled;
    popBackBtn.disabled = !enabled;
  }

  // Clear input + focus
  function clearInput() {
    inputValue.value = '';
    inputValue.focus();
  }

  // Event listeners
  pushFrontBtn.addEventListener('click', () => {
    const val = inputValue.value.trim();
    if(val === ''){
      alert('Please enter a value to push.');
      inputValue.focus();
      return;
    }
    deque.pushFront(val);
    updateDisplay();
    clearInput();
  });

  pushBackBtn.addEventListener('click', () => {
    const val = inputValue.value.trim();
    if(val === ''){
      alert('Please enter a value to push.');
      inputValue.focus();
      return;
    }
    deque.pushBack(val);
    updateDisplay();
    clearInput();
  });

  popFrontBtn.addEventListener('click', () => {
    if(deque.isEmpty()){
      alert('Deque is empty. Nothing to pop at front.');
      return;
    }
    const popped = deque.popFront();
    alert(`Popped from front: ${popped}`);
    updateDisplay();
  });

  popBackBtn.addEventListener('click', () => {
    if(deque.isEmpty()){
      alert('Deque is empty. Nothing to pop at back.');
      return;
    }
    const popped = deque.popBack();
    alert(`Popped from back: ${popped}`);
    updateDisplay();
  });

  clearBtn.addEventListener('click', () => {
    if(deque.isEmpty()){
      alert('Deque is already empty.');
      return;
    }
    if(confirm('Are you sure you want to clear the deque?')){
      deque.clear();
      updateDisplay();
      clearInput();
    }
  });

  // Enable pressing Enter to pushBack by default
  inputValue.addEventListener('keydown', (e) => {
    if(e.key === 'Enter'){
      e.preventDefault();
      pushBackBtn.click();
    }
  });

  // Initialize display
  updateDisplay();
})();
</script>
</body>
</html>