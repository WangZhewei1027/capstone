<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hash Map Demonstration</title>
<style>
  body {
    font-family: Arial, sans-serif;
    max-width: 700px;
    margin: 2rem auto;
    padding: 0 1rem;
    background: #f0f4f8;
  }
  h1 {
    text-align: center;
    color: #333;
  }
  .section {
    background: #fff;
    border-radius: 8px;
    padding: 1rem 1.5rem 2rem 1.5rem;
    margin: 1rem 0;
    box-shadow: 0 2px 5px rgb(0 0 0 / 0.1);
  }
  label {
    display: block;
    margin: 0.5rem 0 0.25rem 0;
    font-weight: bold;
  }
  input[type="text"] {
    width: 100%;
    padding: 0.4rem 0.5rem;
    font-size: 1rem;
    box-sizing: border-box;
  }
  button {
    margin-top: 0.7rem;
    background: #0078d7;
    color: white;
    border: none;
    padding: 0.5rem 1.2rem;
    font-size: 1rem;
    border-radius: 4px;
    cursor: pointer;
  }
  button:hover {
    background: #005ea2;
  }
  #output {
    white-space: pre-wrap;
    background: #222;
    color: #00ff00;
    padding: 1rem;
    border-radius: 6px;
    font-family: monospace;
    min-height: 120px;
    overflow-x: auto;
    margin-top: 1rem;
  }
  .error {
    color: red;
    font-weight: bold;
  }
  .map-visual {
    margin-top: 1rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }
  .map-item {
    background: #0078d7;
    color: white;
    padding: 0.4rem 0.7rem;
    border-radius: 4px;
    font-size: 0.9rem;
  }
  .map-item .key {
    font-weight: bold;
  }
  .map-item .value {
    font-style: italic;
  }
  small {
    color: #666;
  }
</style>
</head>
<body>
<h1>Hash Map (Hash Table) Demonstration</h1>
<div class="section">
  <p>
    This demo shows a simple <strong>Hash Map</strong> implementation in JavaScript.
    A hash map stores key-value pairs and allows fast insertion, retrieval, and deletion.
  </p>
  <p><small>Note: This is a simplified educational example for demonstration purposes.</small></p>
</div>

<div class="section" id="controls">
  <label for="keyInput">Key:</label>
  <input type="text" id="keyInput" placeholder="Enter a key (string)" />

  <label for="valueInput">Value:</label>
  <input type="text" id="valueInput" placeholder="Enter a value" />

  <button id="addBtn">Add / Update Entry</button>
  <button id="getBtn">Get Value by Key</button>
  <button id="removeBtn">Remove Entry by Key</button>
  <button id="clearBtn" style="background:#d9534f;">Clear Hash Map</button>

  <div id="message" class="error" aria-live="polite"></div>
</div>

<div class="section">
  <h2>Current Hash Map Entries</h2>
  <div class="map-visual" id="mapVisual" aria-live="polite" aria-label="Current hash map entries"></div>
</div>

<div class="section">
  <h2>Operations Output</h2>
  <pre id="output" aria-live="polite" aria-atomic="true">(Operation results will show here)</pre>
</div>

<script>
// Simple hash function (djb2)
function hashString(str, capacity) {
  let hash = 5381;
  for (let i = 0; i < str.length; i++) {
    // charCodeAt returns a number between 0-65535
    hash = ((hash << 5) + hash) + str.charCodeAt(i);
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash) % capacity;
}

class HashMap {
  constructor(initialCapacity = 16) {
    this.capacity = initialCapacity;
    this.size = 0;
    // Initialize buckets, each bucket is an array for separate chaining
    this.buckets = Array.from({ length: this.capacity }, () => []);
  }

  _getBucketIndex(key) {
    return hashString(key, this.capacity);
  }

  put(key, value) {
    const index = this._getBucketIndex(key);
    const bucket = this.buckets[index];
    // Check if key exists already, update it
    for (let i = 0; i < bucket.length; i++) {
      let [k, v] = bucket[i];
      if (k === key) {
        bucket[i][1] = value;
        return;
      }
    }
    // Insert new key-value pair
    bucket.push([key, value]);
    this.size++;
  }

  get(key) {
    const index = this._getBucketIndex(key);
    const bucket = this.buckets[index];
    for (let i = 0; i < bucket.length; i++) {
      let [k, v] = bucket[i];
      if (k === key) {
        return v;
      }
    }
    return undefined; // Not found
  }

  remove(key) {
    const index = this._getBucketIndex(key);
    const bucket = this.buckets[index];
    for (let i = 0; i < bucket.length; i++) {
      if (bucket[i][0] === key) {
        bucket.splice(i, 1);
        this.size--;
        return true;
      }
    }
    return false;
  }

  clear() {
    this.buckets = Array.from({ length: this.capacity }, () => []);
    this.size = 0;
  }

  entries() {
    // Return all key-value pairs as array
    let allEntries = [];
    for (const bucket of this.buckets) {
      allEntries = allEntries.concat(bucket);
    }
    return allEntries;
  }
}

// Instantiate our hash map
const hashMap = new HashMap();

const keyInput = document.getElementById('keyInput');
const valueInput = document.getElementById('valueInput');
const addBtn = document.getElementById('addBtn');
const getBtn = document.getElementById('getBtn');
const removeBtn = document.getElementById('removeBtn');
const clearBtn = document.getElementById('clearBtn');
const message = document.getElementById('message');
const output = document.getElementById('output');
const mapVisual = document.getElementById('mapVisual');

function updateMapVisual() {
  mapVisual.innerHTML = '';
  const entries = hashMap.entries();
  if (entries.length === 0) {
    mapVisual.textContent = '(empty)';
    return;
  }
  for (const [key, value] of entries) {
    const itemDiv = document.createElement('div');
    itemDiv.className = 'map-item';
    itemDiv.title = `Key: ${key}\nValue: ${value}`;
    const keySpan = document.createElement('span');
    keySpan.className = 'key';
    keySpan.textContent = key;
    const sep = document.createTextNode(' â†’ ');
    const valueSpan = document.createElement('span');
    valueSpan.className = 'value';
    valueSpan.textContent = `${value}`;
    itemDiv.appendChild(keySpan);
    itemDiv.appendChild(sep);
    itemDiv.appendChild(valueSpan);
    mapVisual.appendChild(itemDiv);
  }
}

function clearMessage() {
  message.textContent = '';
}

function showMessage(msg, isError = false) {
  message.textContent = msg;
  if (isError) {
    message.classList.add('error');
  } else {
    message.classList.remove('error');
  }
}

// Add/update entry
addBtn.addEventListener('click', () => {
  clearMessage();
  const key = keyInput.value.trim();
  const value = valueInput.value;
  if (key === '') {
    showMessage('Please enter a non-empty key.', true);
    return;
  }
  hashMap.put(key, value);
  output.textContent = `Added/Updated: { "${key}": "${value}" }`;
  updateMapVisual();
});

// Get value by key
getBtn.addEventListener('click', () => {
  clearMessage();
  const key = keyInput.value.trim();
  if (key === '') {
    showMessage('Please enter a key to get its value.', true);
    return;
  }
  const val = hashMap.get(key);
  if (val === undefined) {
    output.textContent = `Key "${key}" not found in the hash map.`;
  } else {
    output.textContent = `Value for key "${key}": "${val}"`;
  }
});

// Remove entry by key
removeBtn.addEventListener('click', () => {
  clearMessage();
  const key = keyInput.value.trim();
  if (key === '') {
    showMessage('Please enter a key to remove.', true);
    return;
  }
  const removed = hashMap.remove(key);
  if (removed) {
    output.textContent = `Removed key "${key}" from the hash map.`;
    updateMapVisual();
  } else {
    output.textContent = `Key "${key}" not found, nothing was removed.`;
  }
});

// Clear entire map
clearBtn.addEventListener('click', () => {
  clearMessage();
  hashMap.clear();
  output.textContent = 'Hash map cleared (all entries removed).';
  updateMapVisual();
});

// Initialize visual
updateMapVisual();
</script>
</body>
</html>