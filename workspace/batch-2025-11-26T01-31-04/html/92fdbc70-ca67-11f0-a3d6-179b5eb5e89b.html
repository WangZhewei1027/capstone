<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Heap (Min/Max) Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  h1, h2 {
    color: #333;
  }
  #controls {
    margin-bottom: 15px;
  }
  input[type=number] {
    width: 100px;
    padding: 6px;
    font-size: 14px;
  }
  button {
    padding: 6px 12px;
    margin-left: 10px;
    font-size: 14px;
    cursor: pointer;
  }
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  #heapType {
    margin-left: 10px;
    font-weight: bold;
  }
  .heap-array {
    margin-top: 10px;
    font-family: monospace;
    white-space: pre-wrap;
    word-wrap: break-word;
    background: #f0f0f0;
    padding: 10px;
    border-radius: 5px;
  }
  #log {
    margin-top: 20px;
    background: #222;
    color: #eee;
    border-radius: 5px;
    max-height: 250px;
    overflow-y: auto;
    padding: 10px;
    font-family: monospace;
    font-size: 13px;
  }
  .highlight {
    color: #e67e22;
    font-weight: bold;
  }
  label {
    font-weight: bold;
  }
  #switchBtn {
    margin-left: 20px;
    font-weight: bold;
  }
  footer {
    margin-top: 40px;
    font-size: 13px;
    color: #666;
    text-align: center;
  }
</style>
</head>
<body>
<h1>Heap (Min/Max) Demo</h1>
<p>This demo shows a binary heap data structure supporting both Min Heap and Max Heap operations. You can insert numbers, extract top (min or max), and see the heap as an array and as a tree visualization.</p>

<div id="controls">
  <label for="numInput">Number:</label>
  <input type="number" id="numInput" />
  <button id="insertBtn">Insert</button>
  <button id="extractBtn">Extract Top</button>
  <button id="clearBtn">Clear</button>
  <button id="switchBtn">Switch to Max Heap</button>
  <span id="heapType">Current: Min Heap</span>
</div>

<h2>Heap Array Representation</h2>
<div id="heapArray" class="heap-array">(empty)</div>

<h2>Heap Tree Visualization</h2>
<svg id="heapSVG" width="100%" height="300" style="border:1px solid #ccc; background:#fafafa;"></svg>

<h2>Operations Log</h2>
<div id="log"></div>

<script>
(() => {
  // Heap class supporting min or max heap
  class Heap {
    constructor(isMinHeap = true) {
      this.data = [];
      this.isMinHeap = isMinHeap;
    }
    compare(a, b) {
      // For min heap: a < b; for max heap: a > b
      return this.isMinHeap ? a < b : a > b;
    }
    insert(value) {
      this.data.push(value);
      this.bubbleUp(this.data.length - 1);
    }
    bubbleUp(index) {
      while(index > 0) {
        let parentIndex = Math.floor((index - 1) / 2);
        if(this.compare(this.data[index], this.data[parentIndex])) {
          this.swap(index, parentIndex);
          index = parentIndex;
        } else break;
      }
    }
    extractTop() {
      if(this.data.length === 0) return null;
      if(this.data.length === 1) return this.data.pop();
      const topValue = this.data[0];
      this.data[0] = this.data.pop();
      this.bubbleDown(0);
      return topValue;
    }
    bubbleDown(index) {
      const length = this.data.length;
      while(true) {
        let left = 2 * index + 1;
        let right = 2 * index + 2;
        let swapIndex = index;

        if(left < length && this.compare(this.data[left], this.data[swapIndex])) {
          swapIndex = left;
        }
        if(right < length && this.compare(this.data[right], this.data[swapIndex])) {
          swapIndex = right;
        }
        if(swapIndex !== index) {
          this.swap(index, swapIndex);
          index = swapIndex;
        } else break;
      }
    }
    swap(i, j) {
      const temp = this.data[i];
      this.data[i] = this.data[j];
      this.data[j] = temp;
    }
    clear() {
      this.data = [];
    }
    size() {
      return this.data.length;
    }
    getTop() {
      return this.data.length > 0 ? this.data[0] : null;
    }
  }

  // DOM Elements
  const numInput = document.getElementById('numInput');
  const insertBtn = document.getElementById('insertBtn');
  const extractBtn = document.getElementById('extractBtn');
  const clearBtn = document.getElementById('clearBtn');
  const switchBtn = document.getElementById('switchBtn');
  const heapTypeSpan = document.getElementById('heapType');
  const heapArrayDiv = document.getElementById('heapArray');
  const logDiv = document.getElementById('log');
  const heapSVG = document.getElementById('heapSVG');

  // Initialize min heap
  let isMinHeap = true;
  const heap = new Heap(isMinHeap);

  function log(msg) {
    const time = new Date().toLocaleTimeString();
    const entry = document.createElement('div');
    entry.textContent = `[${time}] ${msg}`;
    logDiv.prepend(entry);
  }

  function validateInput() {
    // Enable insert only if number entered
    const val = numInput.value.trim();
    insertBtn.disabled = val === '' || isNaN(Number(val));
  }

  function updateHeapArray() {
    if(heap.size() === 0) {
      heapArrayDiv.textContent = '(empty)';
    } else {
      // Show array as [v0, v1, v2, ...]
      heapArrayDiv.textContent = '[ ' + heap.data.join(', ') + ' ]';
    }
  }

  // Visualization parameters
  const nodeRadius = 20;
  const verticalSpacing = 70;
  const horizontalSpacing = 40;

  function clearSVG() {
    while (heapSVG.firstChild) {
      heapSVG.removeChild(heapSVG.firstChild);
    }
  }

  function drawLine(x1, y1, x2, y2) {
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1);
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2);
    line.setAttribute('stroke', '#555');
    line.setAttribute('stroke-width', '2');
    heapSVG.appendChild(line);
  }

  function drawNode(x, y, value) {
    const svgNS = "http://www.w3.org/2000/svg";

    const circle = document.createElementNS(svgNS, 'circle');
    circle.setAttribute('cx', x);
    circle.setAttribute('cy', y);
    circle.setAttribute('r', nodeRadius);
    circle.setAttribute('fill', '#3498db');
    circle.setAttribute('stroke', '#2980b9');
    circle.setAttribute('stroke-width', '2');
    heapSVG.appendChild(circle);

    const text = document.createElementNS(svgNS, 'text');
    text.setAttribute('x', x);
    text.setAttribute('y', y + 5);
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('font-size', '16px');
    text.setAttribute('fill', 'white');
    text.style.userSelect = 'none';
    text.textContent = value;
    heapSVG.appendChild(text);
  }

  // Calculate x position for each node based on index and depth
  // Using a simple approach: positions in levels with spacing
  // Width is dynamically set based on level's max nodes
  function getNodePositions(arr) {
    if(arr.length === 0) return [];
    // Calculate depth levels
    const depth = Math.floor(Math.log2(arr.length)) + 1;
    // Positions array holds {x,y} for each index
    let positions = [];

    // For each node at index i:
    // level = floor(log2(i+1))
    // indexWithinLevel = i - (2^level - 1)
    for(let i = 0; i < arr.length; i++) {
      const level = Math.floor(Math.log2(i+1));
      const maxNodesLevel = Math.pow(2, level);
      const indexInLevel = i - (maxNodesLevel - 1);
      // Calculate width available for this level:
      // total width = heapSVG.clientWidth or 100% assumed 800 here for base
      // For stable visualization, fix width to 800 or dynamically
      const svgWidth = heapSVG.clientWidth || 800;
      const spacing = svgWidth / (maxNodesLevel + 1);
      const x = spacing * (indexInLevel + 1);
      const y = verticalSpacing * (level + 1);
      positions.push({x, y});
    }
    return positions;
  }

  function drawHeapTree() {
    clearSVG();

    if(heap.size() === 0) return;

    const positions = getNodePositions(heap.data);

    // Draw lines first
    for(let i = 0; i < heap.data.length; i++) {
      const leftChildIndex = 2 * i + 1;
      const rightChildIndex = 2 * i + 2;
      const pos = positions[i];
      if(leftChildIndex < heap.data.length) {
        const leftPos = positions[leftChildIndex];
        drawLine(pos.x, pos.y + nodeRadius, leftPos.x, leftPos.y - nodeRadius);
      }
      if(rightChildIndex < heap.data.length) {
        const rightPos = positions[rightChildIndex];
        drawLine(pos.x, pos.y + nodeRadius, rightPos.x, rightPos.y - nodeRadius);
      }
    }

    // Draw nodes on top
    for(let i = 0; i < heap.data.length; i++) {
      drawNode(positions[i].x, positions[i].y, heap.data[i]);
    }
  }

  function updateUI() {
    updateHeapArray();
    drawHeapTree();
    validateInput();
    extractBtn.disabled = heap.size() === 0;
  }

  insertBtn.addEventListener('click', () => {
    const val = Number(numInput.value);
    if(isNaN(val)) return;
    heap.insert(val);
    log(`Inserted ${val}`);
    numInput.value = '';
    updateUI();
  });

  extractBtn.addEventListener('click', () => {
    const top = heap.extractTop();
    if(top !== null) {
      log(`Extracted top value: ${top}`);
    } else {
      log('Heap empty: nothing to extract');
    }
    updateUI();
  });

  clearBtn.addEventListener('click', () => {
    heap.clear();
    log('Heap cleared');
    updateUI();
  });

  switchBtn.addEventListener('click', () => {
    isMinHeap = !isMinHeap;
    heap.isMinHeap = isMinHeap;
    // Rebuild heap to satisfy new heap property:
    // Quick way: extract all data, then reinsert in new heap mode
    const oldData = heap.data.slice();
    heap.clear();
    for(const v of oldData) {
      heap.insert(v);
    }
    heapTypeSpan.textContent = `Current: ${isMinHeap ? 'Min Heap' : 'Max Heap'}`;
    switchBtn.textContent = isMinHeap ? 'Switch to Max Heap' : 'Switch to Min Heap';
    log(`Switched to ${isMinHeap ? 'Min Heap' : 'Max Heap'}`);
    updateUI();
  });

  numInput.addEventListener('input', validateInput);
  validateInput();
  updateUI();

})();
</script>
<footer>Heap Demo by ChatGPT | Min Heap orders smallest to top; Max Heap orders biggest to top</footer>
</body>
</html>