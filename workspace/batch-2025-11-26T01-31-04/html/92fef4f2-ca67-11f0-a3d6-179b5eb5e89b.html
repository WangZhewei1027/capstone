<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Topological Sort Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 2rem;
    background: #f5f5f5;
  }
  h1 {
    text-align: center;
  }
  #graphInput {
    width: 100%;
    height: 150px;
    font-family: monospace;
    font-size: 14px;
  }
  #runBtn {
    display: block;
    margin: 1rem 0;
    padding: 0.5rem 1rem;
    font-size: 16px;
  }
  #output {
    background: white;
    padding: 1rem;
    border-radius: 8px;
    min-height: 100px;
    white-space: pre-wrap;
    font-family: monospace;
    font-size: 16px;
  }
  .error {
    color: red;
  }
  label {
    font-weight: bold;
  }
  .hint {
    background: #e3f2fd;
    border-left: 4px solid #2196f3;
    padding: 0.5rem 1rem;
    margin-bottom: 1rem;
    font-size: 14px;
    line-height: 1.4;
  }
  #graphViz {
    margin-top: 1rem;
    background: white;
    border-radius: 8px;
    padding: 1rem;
  }
  svg {
    width: 100%;
    height: 240px;
  }
</style>
</head>
<body>
<h1>Topological Sort Demo</h1>

<div class="hint">
  Enter a directed graph as adjacency lists in JSON format.<br />
  Example (keys are nodes, values are lists of nodes they point to):<br />
  <code>{"5": ["2", "0"], "4": ["0","1"], "2": ["3"], "3": ["1"], "0": [], "1": []}</code>
</div>

<label for="graphInput">Graph adjacency list (JSON):</label><br />
<textarea id="graphInput" spellcheck="false">{"5": ["2", "0"], "4": ["0","1"], "2": ["3"], "3": ["1"], "0": [], "1": []}</textarea>
<button id="runBtn">Run Topological Sort</button>

<div id="output" aria-live="polite"></div>

<div id="graphViz"></div>

<script>
  // Simple topological sort using DFS; detects cycles.
  function topologicalSort(graph) {
    const visited = new Set();
    const recStack = new Set();
    const order = [];
    let hasCycle = false;

    function dfs(node) {
      if (hasCycle) return;
      if (!graph.hasOwnProperty(node)) {
        // Handle unknown nodes gracefully by adding with empty list
        graph[node] = [];
      }
      if (recStack.has(node)) {
        hasCycle = true;
        return;
      }
      if (visited.has(node)) return;

      recStack.add(node);
      for (const neighbor of graph[node]) {
        dfs(neighbor);
      }
      recStack.delete(node);
      visited.add(node);
      order.push(node);
    }

    for (const node of Object.keys(graph)) {
      if (!visited.has(node)) {
        dfs(node);
      }
    }

    if (hasCycle) {
      return null; // Cycle detected, no topological order
    }
    return order.reverse();
  }

  // Function to create a simple SVG visualization of the graph and topological order
  function visualizeGraph(graph, order) {
    const width = 600;
    const height = 240;
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);

    // Coordinates for nodes in a line done by order
    // If order null (cycle), arrange nodes alphabetically
    const nodes = order ? order : Object.keys(graph).sort();
    const spacing = width / (nodes.length + 1);
    const radius = 20;

    // Map node -> {x,y}
    const coords = {};
    const y = height / 2;

    nodes.forEach((node, i) => {
      coords[node] = { x: spacing * (i + 1), y };
    });

    // Draw edges as arrows
    for (const [from, neighbors] of Object.entries(graph)) {
      const fromCoord = coords[from];
      if (!fromCoord) continue; // If from is unknown, skip

      neighbors.forEach(to => {
        const toCoord = coords[to];
        if (!toCoord) return; // skip unknown nodes

        // Draw line with arrowhead
        const line = document.createElementNS(svgNS, "line");
        line.setAttribute("x1", fromCoord.x);
        line.setAttribute("y1", fromCoord.y);
        line.setAttribute("x2", toCoord.x);
        line.setAttribute("y2", toCoord.y);
        line.setAttribute("stroke", "#444");
        line.setAttribute("stroke-width", "2");
        line.setAttribute("marker-end", "url(#arrowhead)");
        svg.appendChild(line);
      });
    }

    // Define arrowhead marker
    const defs = document.createElementNS(svgNS, "defs");
    const marker = document.createElementNS(svgNS, "marker");
    marker.setAttribute("id", "arrowhead");
    marker.setAttribute("markerWidth", "10");
    marker.setAttribute("markerHeight", "7");
    marker.setAttribute("refX", "10");
    marker.setAttribute("refY", "3.5");
    marker.setAttribute("orient", "auto");
    marker.setAttribute("fill", "#444");

    const polygon = document.createElementNS(svgNS, "polygon");
    polygon.setAttribute("points", "0 0, 10 3.5, 0 7");
    marker.appendChild(polygon);
    defs.appendChild(marker);
    svg.appendChild(defs);

    // Draw nodes as circles + labels
    nodes.forEach((node, i) => {
      const { x, y } = coords[node];

      // Circle backgrounds - highlight order number if exists
      const circle = document.createElementNS(svgNS, "circle");
      circle.setAttribute("cx", x);
      circle.setAttribute("cy", y);
      circle.setAttribute("r", radius);
      circle.setAttribute("fill", "#2196f3");
      circle.setAttribute("stroke", "white");
      circle.setAttribute("stroke-width", "2");
      svg.appendChild(circle);

      // Node label (node name)
      const text = document.createElementNS(svgNS, "text");
      text.setAttribute("x", x);
      text.setAttribute("y", y + 5);
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("font-size", "16");
      text.setAttribute("fill", "white");
      text.style.userSelect = "none";
      text.textContent = node;
      svg.appendChild(text);

      // If we have a topological order, show order number below
      if (order) {
        const ordText = document.createElementNS(svgNS, "text");
        ordText.setAttribute("x", x);
        ordText.setAttribute("y", y + radius + 18);
        ordText.setAttribute("text-anchor", "middle");
        ordText.setAttribute("font-size", "14");
        ordText.setAttribute("fill", "#333");
        ordText.style.userSelect = "none";
        ordText.textContent = i + 1;
        svg.appendChild(ordText);
      }
    });

    return svg;
  }

  document.getElementById("runBtn").addEventListener("click", () => {
    const output = document.getElementById("output");
    const graphViz = document.getElementById("graphViz");
    output.textContent = "";
    graphViz.innerHTML = "";

    let graph;
    try {
      graph = JSON.parse(document.getElementById("graphInput").value.trim());

      if (
        typeof graph !== "object" ||
        graph === null ||
        Array.isArray(graph)
      ) {
        throw new Error("Graph must be a JSON object with adjacency lists.");
      }

      // Validate adjacency lists as arrays of strings or numbers
      for (const [node, neighbors] of Object.entries(graph)) {
        if (!Array.isArray(neighbors)) {
          throw new Error(
            `Neighbors of node '${node}' must be an array.`
          );
        }
        for (const n of neighbors) {
          if (typeof n !== "string" && typeof n !== "number") {
            throw new Error(
              `Neighbor '${n}' of node '${node}' must be a string or number.`
            );
          }
        }
      }
    } catch (e) {
      output.innerHTML = `<span class="error">Invalid JSON or input: ${e.message}</span>`;
      return;
    }

    // Ensure nodes keys and neighbor entries are all strings for consistent keys
    const normalizedGraph = {};
    for (const [node, neighbors] of Object.entries(graph)) {
      const strNode = String(node);
      normalizedGraph[strNode] = neighbors.map((n) => String(n));
    }

    // Call topological sort
    const result = topologicalSort(normalizedGraph);

    if (result === null) {
      output.innerHTML = `<span class="error">Cycle detected! Topological sort is not possible.</span>`;
      // Show graph anyway with alphabetical layout
      const svg = visualizeGraph(normalizedGraph, null);
      graphViz.appendChild(svg);
    } else {
      output.textContent = "Topological order:\n" + result.join(" â†’ ");
      const svg = visualizeGraph(normalizedGraph, result);
      graphViz.appendChild(svg);
    }
  });
</script>

</body>
</html>