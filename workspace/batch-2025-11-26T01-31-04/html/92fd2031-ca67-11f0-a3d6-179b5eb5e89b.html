<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hash Table Demonstration</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    max-width: 700px;
  }
  h1 {
    text-align: center;
  }
  .container {
    margin-top: 20px;
  }
  label {
    display: block;
    margin-top: 10px;
  }
  input[type="text"] {
    width: 60%;
    padding: 8px;
    margin-top: 5px;
  }
  button {
    margin-top: 10px;
    padding: 8px 12px;
    font-size: 1em;
    cursor: pointer;
  }
  #hashTableDisplay {
    margin-top: 30px;
    border-collapse: collapse;
    width: 100%;
  }
  #hashTableDisplay th, #hashTableDisplay td {
    border: 1px solid #ccc;
    padding: 8px;
    text-align: left;
  }
  #hashTableDisplay th {
    background-color: #f2f2f2;
  }
  .linked-list {
    font-family: monospace;
  }
  small {
    color: #666;
  }
  #message {
    margin-top: 20px;
    font-weight: bold;
    color: #d9534f;
  }
  #success {
    color: #5cb85c;
  }
  #legend {
    margin-top: 30px;
    font-size: 0.9em;
    color: #555;
  }
</style>
</head>
<body>
<h1>Hash Table Demonstration</h1>
<p>This example shows a simple hash table using separate chaining to handle collisions. Keys and values are strings.</p>

<div class="container">
  <label for="keyInput">Key:</label>
  <input type="text" id="keyInput" placeholder="Enter key" />

  <label for="valueInput">Value:</label>
  <input type="text" id="valueInput" placeholder="Enter value" />

  <button id="addBtn">Add / Update</button>
  <button id="removeBtn">Remove by Key</button>
  <button id="getBtn">Get Value by Key</button>
  <button id="clearBtn">Clear Table</button>

  <div id="message" aria-live="polite"></div>

  <h2>Hash Table Internal Buckets</h2>
  <table id="hashTableDisplay" aria-label="Hash Table Buckets">
    <thead>
      <tr>
        <th>Bucket Index</th>
        <th>Items (key → value)</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div id="legend">
    <p><strong>Notes:</strong></p>
    <ul>
      <li>The hash function uses the sum of character codes mod the number of buckets.</li>
      <li>Collisions are resolved by linked lists (separate chaining).</li>
      <li>Keys are unique; adding the same key updates its value.</li>
    </ul>
  </div>
</div>

<script>
  // Simple Hash Table implementation using separate chaining (linked lists)
  class HashTable {
    constructor(size = 10) {
      this.size = size;
      this.buckets = Array(size).fill(null).map(() => []);
    }

    // Simple hash function: sum of char codes modulo size
    _hash(key) {
      let hash = 0;
      for (let char of key) {
        hash += char.charCodeAt(0);
      }
      return hash % this.size;
    }

    // Add or update a key-value pair
    set(key, value) {
      const index = this._hash(key);
      const bucket = this.buckets[index];
      // Check if key exists, update
      for (let pair of bucket) {
        if (pair[0] === key) {
          pair[1] = value;
          return false; // false indicates updated existing key
        }
      }
      bucket.push([key, value]);
      return true; // true indicates new key added
    }

    // Get value by key
    get(key) {
      const index = this._hash(key);
      const bucket = this.buckets[index];
      for (let pair of bucket) {
        if (pair[0] === key) {
          return pair[1];
        }
      }
      return undefined;
    }

    // Remove a key-value pair by key
    remove(key) {
      const index = this._hash(key);
      const bucket = this.buckets[index];
      const initialLength = bucket.length;
      this.buckets[index] = bucket.filter(pair => pair[0] !== key);
      return this.buckets[index].length !== initialLength;
    }

    // Clear the table
    clear() {
      this.buckets = Array(this.size).fill(null).map(() => []);
    }
  }

  // Initialize
  const hashTable = new HashTable(10);

  // DOM Elements
  const keyInput = document.getElementById("keyInput");
  const valueInput = document.getElementById("valueInput");
  const addBtn = document.getElementById("addBtn");
  const removeBtn = document.getElementById("removeBtn");
  const getBtn = document.getElementById("getBtn");
  const clearBtn = document.getElementById("clearBtn");
  const messageEl = document.getElementById("message");
  const tableBody = document.querySelector("#hashTableDisplay tbody");

  // Functions to update the display
  function renderTable() {
    tableBody.innerHTML = "";
    hashTable.buckets.forEach((bucket, i) => {
      const tr = document.createElement("tr");
      const indexTd = document.createElement("td");
      indexTd.textContent = i;
      tr.appendChild(indexTd);

      const itemsTd = document.createElement("td");
      if (bucket.length === 0) {
        itemsTd.textContent = "(empty)";
        itemsTd.style.fontStyle = "italic";
        itemsTd.style.color = "#999";
      } else {
        const items = bucket.map(pair => `${pair[0]} → ${pair[1]}`).join("  →  ");
        itemsTd.textContent = items;
        itemsTd.className = "linked-list";
      }
      tr.appendChild(itemsTd);

      tableBody.appendChild(tr);
    });
  }

  function showMessage(text, isError = true) {
    messageEl.textContent = text;
    messageEl.style.color = isError ? "#d9534f" : "#5cb85c";
  }

  // Button event handlers
  addBtn.addEventListener("click", () => {
    const key = keyInput.value.trim();
    const value = valueInput.value.trim();
    if (!key) {
      showMessage("Error: Key cannot be empty.");
      return;
    }
    if (!value) {
      showMessage("Error: Value cannot be empty.");
      return;
    }
    const addedNew = hashTable.set(key, value);
    if (addedNew) {
      showMessage(`Added key "${key}" with value "${value}".`, false);
    } else {
      showMessage(`Updated key "${key}" with new value "${value}".`, false);
    }
    renderTable();
  });

  removeBtn.addEventListener("click", () => {
    const key = keyInput.value.trim();
    if (!key) {
      showMessage("Error: Key cannot be empty.");
      return;
    }
    const removed = hashTable.remove(key);
    if (removed) {
      showMessage(`Removed key "${key}" from the hash table.`, false);
    } else {
      showMessage(`Key "${key}" not found in the hash table.`);
    }
    renderTable();
  });

  getBtn.addEventListener("click", () => {
    const key = keyInput.value.trim();
    if (!key) {
      showMessage("Error: Key cannot be empty.");
      return;
    }
    const value = hashTable.get(key);
    if (value === undefined) {
      showMessage(`Key "${key}" not found in the hash table.`);
    } else {
      showMessage(`Value for key "${key}": "${value}"`, false);
    }
  });

  clearBtn.addEventListener("click", () => {
    hashTable.clear();
    showMessage("Hash table cleared.", false);
    renderTable();
  });

  // Initial render
  renderTable();
</script>
</body>
</html>