<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Binary Search Tree (BST) Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f7f9fc;
    color: #222;
  }
  h1 {
    text-align: center;
  }
  #controls {
    max-width: 600px;
    margin: 0 auto 20px auto;
    background: #ffffff;
    padding: 15px 20px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgb(0 0 0 / 0.1);
  }
  label {
    margin-right: 10px;
  }
  input[type="number"] {
    width: 80px;
    padding: 6px 8px;
    font-size: 1rem;
    margin-right: 10px;
  }
  button {
    padding: 7px 12px;
    font-size: 1rem;
    margin-right: 10px;
    cursor: pointer;
    border: none;
    border-radius: 5px;
    background-color: #0078d7;
    color: white;
    transition: background-color 0.2s ease;
  }
  button:hover:not(:disabled) {
    background-color: #005a9e;
  }
  button:disabled {
    background-color: #999;
    cursor: not-allowed;
  }
  #output {
    max-width: 600px;
    margin: 0 auto 30px auto;
    background: #fff;
    border-radius: 8px;
    padding: 15px 20px;
    box-shadow: 0 2px 8px rgb(0 0 0 / 0.1);
    min-height: 50px;
    white-space: pre-wrap;
    font-family: monospace;
    font-size: 1.1rem;
    color: #333;
  }
  #tree-container {
    max-width: 90vw;
    margin: 20px auto;
    text-align: center;
    overflow-x: auto;
  }
  svg {
    background: #ffffff;
    border: 1px solid #ddd;
    border-radius: 8px;
  }
</style>
</head>
<body>
<h1>Binary Search Tree (BST) Visualizer</h1>
<div id="controls">
  <label for="valueInput">Value:</label>
  <input type="number" id="valueInput" />
  <button id="insertBtn">Insert</button>
  <button id="searchBtn">Search</button>
  <button id="deleteBtn">Delete</button>
  <button id="clearBtn">Clear Tree</button>
</div>
<div id="output" aria-live="polite" aria-atomic="true"></div>
<div id="tree-container" aria-label="Binary search tree visualization"></div>

<script>
(() => {
  // BST Node class
  class Node {
    constructor(value) {
      this.value = value;
      this.left = null;
      this.right = null;
      this.x = 0; // For visualization
      this.y = 0;
    }
  }

  // BST class with insert, search, delete and traversal
  class BST {
    constructor() {
      this.root = null;
    }

    insert(value) {
      if (typeof value !== "number" || isNaN(value)) return false;

      const newNode = new Node(value);
      if (!this.root) {
        this.root = newNode;
        return true;
      }
      let current = this.root;
      while (true) {
        if (value === current.value) {
          // Value already exists, no duplicates in this BST
          return false;
        }
        if (value < current.value) {
          if (!current.left) {
            current.left = newNode;
            return true;
          }
          current = current.left;
        } else {
          if (!current.right) {
            current.right = newNode;
            return true;
          }
          current = current.right;
        }
      }
    }

    search(value) {
      if (!this.root) return null;
      let current = this.root;
      while (current) {
        if (value === current.value) return current;
        if (value < current.value) current = current.left;
        else current = current.right;
      }
      return null;
    }

    delete(value) {
      this.root = this._deleteRec(this.root, value);
    }

    _deleteRec(node, value) {
      if (!node) return null;
      if (value < node.value) {
        node.left = this._deleteRec(node.left, value);
      } else if (value > node.value) {
        node.right = this._deleteRec(node.right, value);
      } else {
        // node.val == value, delete this node
        if (!node.left) return node.right;
        if (!node.right) return node.left;

        // node with two children:
        // get inorder successor (smallest in the right subtree)
        let minLargerNode = this._minValueNode(node.right);
        node.value = minLargerNode.value;
        node.right = this._deleteRec(node.right, minLargerNode.value);
      }
      return node;
    }

    _minValueNode(node) {
      let current = node;
      while (current.left) current = current.left;
      return current;
    }

    // Traversals: in-order, pre-order, post-order
    inorder() {
      const result = [];
      this._inorderRec(this.root, result);
      return result;
    }
    _inorderRec(node, arr) {
      if (!node) return;
      this._inorderRec(node.left, arr);
      arr.push(node.value);
      this._inorderRec(node.right, arr);
    }

    preorder() {
      const result = [];
      this._preorderRec(this.root, result);
      return result;
    }
    _preorderRec(node, arr) {
      if (!node) return;
      arr.push(node.value);
      this._preorderRec(node.left, arr);
      this._preorderRec(node.right, arr);
    }

    postorder() {
      const result = [];
      this._postorderRec(this.root, result);
      return result;
    }
    _postorderRec(node, arr) {
      if (!node) return;
      this._postorderRec(node.left, arr);
      this._postorderRec(node.right, arr);
      arr.push(node.value);
    }

    clear() {
      this.root = null;
    }
  }

  // Visualization logic using SVG
  class BSTVisualizer {
    constructor(container) {
      this.container = container;
      this.nodeRadius = 20;
      this.verticalSpacing = 70;
      this.horizontalSpacing = 40;
      this.svg = null;
    }

    clear() {
      if (this.svg) {
        this.container.removeChild(this.svg);
        this.svg = null;
      }
    }

    render(root) {
      this.clear();
      if (!root) return;

      // Calculate positions first
      this._calculatePositions(root);

      // Calculate SVG width and height based on node positions
      const allNodes = [];
      this._gatherNodes(root, allNodes);

      const xs = allNodes.map(node => node.x);
      const ys = allNodes.map(node => node.y);

      const minX = Math.min(...xs) - this.nodeRadius - 10;
      const maxX = Math.max(...xs) + this.nodeRadius + 10;
      const minY = Math.min(...ys) - this.nodeRadius - 10;
      const maxY = Math.max(...ys) + this.nodeRadius + 10;

      const width = maxX - minX;
      const height = maxY - minY;

      // Create svg element
      const xmlns = "http://www.w3.org/2000/svg";
      this.svg = document.createElementNS(xmlns, "svg");
      this.svg.setAttribute("width", width);
      this.svg.setAttribute("height", height);
      this.svg.setAttribute("viewBox", `${minX} ${minY} ${width} ${height}`);

      // Draw connections (edges) first
      allNodes.forEach(node => {
        if (node.left) {
          this._drawLine(node, node.left);
        }
        if (node.right) {
          this._drawLine(node, node.right);
        }
      });

      // Draw nodes (circles + text)
      allNodes.forEach(node => {
        this._drawNode(node);
      });

      this.container.appendChild(this.svg);
    }

    _drawLine(parent, child) {
      const xmlns = "http://www.w3.org/2000/svg";
      const line = document.createElementNS(xmlns, "line");
      line.setAttribute("x1", parent.x);
      line.setAttribute("y1", parent.y + this.nodeRadius);
      line.setAttribute("x2", child.x);
      line.setAttribute("y2", child.y - this.nodeRadius);
      line.setAttribute("stroke", "#666");
      line.setAttribute("stroke-width", "2");
      this.svg.appendChild(line);
    }

    _drawNode(node) {
      const xmlns = "http://www.w3.org/2000/svg";

      // Circle
      const circle = document.createElementNS(xmlns, "circle");
      circle.setAttribute("cx", node.x);
      circle.setAttribute("cy", node.y);
      circle.setAttribute("r", this.nodeRadius);
      circle.setAttribute("fill", "#1e90ff");
      circle.setAttribute("stroke", "#004a99");
      circle.setAttribute("stroke-width", "2");
      circle.setAttribute("tabindex", "0");
      circle.setAttribute("aria-label", `Node with value ${node.value}`);
      this.svg.appendChild(circle);

      // Text
      const text = document.createElementNS(xmlns, "text");
      text.setAttribute("x", node.x);
      text.setAttribute("y", node.y + 6);
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("font-size", "14");
      text.setAttribute("fill", "white");
      text.style.userSelect = "none";
      text.textContent = node.value;
      this.svg.appendChild(text);
    }

    _calculatePositions(root) {
      // We use a recursive approach assigning x based on in-order traversal position
      let currentX = 0;
      const setPositions = (node, depth = 0) => {
        if (!node) return;
        setPositions(node.left, depth + 1);
        node.x = currentX * this.horizontalSpacing;
        node.y = depth * this.verticalSpacing;
        currentX++;
        setPositions(node.right, depth + 1);
      };
      setPositions(root);
    }

    _gatherNodes(node, arr) {
      if (!node) return;
      arr.push(node);
      this._gatherNodes(node.left, arr);
      this._gatherNodes(node.right, arr);
    }
  }

  // DOM Elements
  const valueInput = document.getElementById("valueInput");
  const insertBtn = document.getElementById("insertBtn");
  const searchBtn = document.getElementById("searchBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const clearBtn = document.getElementById("clearBtn");
  const output = document.getElementById("output");
  const treeContainer = document.getElementById("tree-container");

  // Instances
  const bst = new BST();
  const visualizer = new BSTVisualizer(treeContainer);

  // Helpers
  function printStatus(message, isError = false) {
    output.textContent = message;
    output.style.color = isError ? "crimson" : "#333";
  }

  function validateInput() {
    const val = valueInput.value.trim();
    if (val === "") {
      printStatus("Please enter a value.", true);
      return null;
    }
    const num = Number(val);
    if (isNaN(num)) {
      printStatus("Invalid input. Please enter a valid number.", true);
      return null;
    }
    return num;
  }

  function refreshBSTView() {
    visualizer.render(bst.root);
    // Also display traversals
    const inorder = bst.inorder().join(", ");
    const preorder = bst.preorder().join(", ");
    const postorder = bst.postorder().join(", ");
    output.innerHTML = 
      `In-order traversal: ${inorder}\n` +
      `Pre-order traversal: ${preorder}\n` +
      `Post-order traversal: ${postorder}`;
    output.style.color = "#333";
  }

  // Event Listeners
  insertBtn.addEventListener("click", () => {
    const val = validateInput();
    if (val === null) return;
    const inserted = bst.insert(val);
    if (inserted) {
      printStatus(`Inserted ${val} into the BST.`);
      refreshBSTView();
      valueInput.value = "";
      valueInput.focus();
    } else {
      printStatus(`Value ${val} already exists in the BST (no duplicates).`, true);
    }
  });

  searchBtn.addEventListener("click", () => {
    const val = validateInput();
    if (val === null) return;
    const node = bst.search(val);
    if (node) {
      printStatus(`Value ${val} found in the BST.`);
    } else {
      printStatus(`Value ${val} not found in the BST.`, true);
    }
  });

  deleteBtn.addEventListener("click", () => {
    const val = validateInput();
    if (val === null) return;
    const node = bst.search(val);
    if (!node) {
      printStatus(`Value ${val} not found. Cannot delete.`, true);
      return;
    }
    bst.delete(val);
    printStatus(`Deleted ${val} from the BST.`);
    refreshBSTView();
    valueInput.value = "";
    valueInput.focus();
  });

  clearBtn.addEventListener("click", () => {
    bst.clear();
    visualizer.clear();
    printStatus("BST cleared.");
    valueInput.value = "";
    valueInput.focus();
  });

  // Initial focus
  valueInput.focus();

  // Accessibility improvements: Enter key triggers Insert button
  valueInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      insertBtn.click();
    }
  });
})();
</script>
</body>
</html>