{
  "id": "92fecde1-ca67-11f0-a3d6-179b5eb5e89b",
  "timestamp": "2025-11-26T01:32:12.043Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Floyd-Warshall Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Floyd-Warshall Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f4f7f8;\n    color: #333;\n  }\n  h1 {\n    text-align: center;\n    color: #2c3e50;\n  }\n  #inputArea {\n    max-width: 600px;\n    margin: 0 auto 20px auto;\n    background: #fff;\n    padding: 15px 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 6px #ccc;\n  }\n  label {\n    font-weight: bold;\n  }\n  textarea {\n    width: 100%;\n    height: 120px;\n    font-family: monospace;\n    margin-bottom: 10px;\n    padding: 8px;\n    border-radius: 4px;\n    border: 1px solid #aaa;\n    resize: vertical;\n  }\n  button {\n    background-color: #3498db;\n    border: none;\n    color: white;\n    padding: 10px 18px;\n    font-size: 16px;\n    border-radius: 6px;\n    cursor: pointer;\n    transition: background-color 0.3s;\n    margin-top: 5px;\n  }\n  button:hover {\n    background-color: #2980b9;\n  }\n  #output {\n    max-width: 600px;\n    margin: 20px auto 40px auto;\n    background: #fff;\n    padding: 15px 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 6px #ccc;\n    overflow-x: auto;\n  }\n  table {\n    border-collapse: collapse;\n    width: 100%;\n    max-width: 600px;\n  }\n  th, td {\n    border: 1px solid #bbb;\n    padding: 6px 10px;\n    text-align: center;\n  }\n  th {\n    background-color: #2980b9;\n    color: white;\n  }\n  td.infinity {\n    color: #d35400;\n    font-style: italic;\n  }\n  #stepInfo {\n    max-width: 600px;\n    margin: 0 auto 20px auto;\n    font-size: 16px;\n    color: #2c3e50;\n    font-weight: bold;\n    text-align: center;\n  }\n  #controls {\n    max-width: 600px;\n    margin: 0 auto;\n    display: flex;\n    justify-content: center;\n    gap: 8px;\n  }\n  #graphInputHint {\n    font-size: 12px;\n    color: #666;\n    margin-bottom: 8px;\n  }\n</style>\n</head>\n<body>\n<h1>Floyd-Warshall Algorithm Visualization</h1>\n\n<div id=\"inputArea\">\n  <label for=\"matrixInput\">Input adjacency matrix (use \"INF\" or \"∞\" for infinity):</label>\n  <div id=\"graphInputHint\">\n    Enter a square matrix of weights separated by spaces or commas, with rows separated by newlines.<br />\n    Example (4 vertices):\n    <pre>0 3 INF 7\n8 0 2 INF\n5 INF 0 1\n2 INF INF 0</pre>\n  </div>\n  <textarea id=\"matrixInput\">0 3 INF 7\n8 0 2 INF\n5 INF 0 1\n2 INF INF 0</textarea>\n  <button id=\"startButton\">Start Floyd-Warshall</button>\n</div>\n\n<div id=\"stepInfo\"></div>\n<div id=\"output\"></div>\n<div id=\"controls\" style=\"display:none;\">\n  <button id=\"prevStep\" title=\"Previous Step\">← Previous</button>\n  <button id=\"nextStep\" title=\"Next Step\">Next →</button>\n</div>\n\n<script>\n(() => {\n  const INF_DISPLAY = \"∞\";\n  const INF = Number.POSITIVE_INFINITY;\n\n  // Parse input matrix string into 2D array\n  function parseMatrix(input) {\n    const rows = input.trim().split(/\\n+/);\n    let matrix = rows.map(row => \n      row.trim()\n        .split(/[\\s,]+/)\n        .map(val => {\n          val = val.toLowerCase();\n          if (val === 'inf' || val === '∞' || val === 'infinity') return INF;\n          let num = Number(val);\n          return isNaN(num) ? INF : num;\n        })\n    );\n    // Validate square matrix\n    const n = matrix.length;\n    for(let i=0; i<n; i++) {\n      if(matrix[i].length !== n) {\n        throw new Error('Matrix is not square. Row ' + (i+1) + ' length mismatch.');\n      }\n    }\n    return matrix;\n  }\n\n  // Display matrix as HTML table\n  function matrixToHTML(matrix, highlight = null) {\n    // highlight is an object {k, i, j} to highlight updated cell in step k\n    const n = matrix.length;\n    let html = '<table><thead><tr><th></th>';\n    for(let c=0; c<n; c++) {\n      html += '<th>v' + c + '</th>';\n    }\n    html += '</tr></thead><tbody>';\n    for(let i=0; i<n; i++) {\n      html += '<tr><th>v' + i + '</th>';\n      for(let j=0; j<n; j++) {\n        let val = matrix[i][j];\n        let cellClass = '';\n        if(val === INF) {\n          val = INF_DISPLAY;\n          cellClass = 'infinity';\n        } else {\n          val = val.toString();\n        }\n        // Highlight updated cell if any\n        if(highlight && highlight.i === i && highlight.j === j) {\n          cellClass += ' updated';\n          html += `<td class=\"${cellClass}\" style=\"background-color:#f39c12; font-weight:bold;\">${val}</td>`;\n        } else {\n          html += `<td class=\"${cellClass}\">${val}</td>`;\n        }\n      }\n      html += '</tr>';\n    }\n    html += '</tbody></table>';\n    return html;\n  }\n\n  // Floyd-Warshall algorithm with steps recording\n  // Returns array of steps: each step contains the matrix and info which cell updated\n  function floydWarshallSteps(graph) {\n    const n = graph.length;\n    // Deep copy matrix\n    let dist = graph.map(row => row.slice());\n    const steps = [];\n\n    // Initial step (k = -1)\n    steps.push({\n      k: -1,\n      matrix: dist.map(row => row.slice()),\n      updated: null,\n      info: 'Initial matrix (before any iteration)'\n    });\n\n    for(let k = 0; k < n; k++) {\n      for(let i = 0; i < n; i++) {\n        for(let j = 0; j < n; j++) {\n          let oldDist = dist[i][j];\n          let throughK = dist[i][k] + dist[k][j];\n          if(throughK < dist[i][j]) {\n            dist[i][j] = throughK;\n            steps.push({\n              k,\n              matrix: dist.map(row => row.slice()),\n              updated: {i, j},\n              info: `Updated dist[${i}][${j}] via vertex v${k} (dist[${i}][${k}] + dist[${k}][${j}] = ${dist[i][k]} + ${dist[k][j]} = ${throughK})`\n            });\n          }\n        }\n      }\n      // Also capture an \"end of iteration k\" snapshot if no updates happened inside k\n      if(!steps.some(s => s.k === k && s !== steps[steps.length-1])) {\n        steps.push({\n          k,\n          matrix: dist.map(row => row.slice()),\n          updated: null,\n          info: `End of iteration k=${k}`\n        });\n      }\n    }\n\n    // Final step\n    steps.push({\n      k: n,\n      matrix: dist.map(row => row.slice()),\n      updated: null,\n      info: 'Completed Floyd-Warshall algorithm. Final shortest paths matrix.'\n    });\n\n    return steps;\n  }\n\n  // UI Elements\n  const matrixInput = document.getElementById('matrixInput');\n  const startButton = document.getElementById('startButton');\n  const outputDiv = document.getElementById('output');\n  const stepInfoDiv = document.getElementById('stepInfo');\n  const controlsDiv = document.getElementById('controls');\n  const prevStepBtn = document.getElementById('prevStep');\n  const nextStepBtn = document.getElementById('nextStep');\n\n  let steps = [];\n  let currentStepIndex = 0;\n\n  function renderStep(index) {\n    if(index < 0) index = 0;\n    if(index >= steps.length) index = steps.length - 1;\n    currentStepIndex = index;\n    const step = steps[index];\n    outputDiv.innerHTML = matrixToHTML(step.matrix, step.updated);\n    stepInfoDiv.textContent = `[Step ${index + 1} of ${steps.length}] ${step.info}`;\n    prevStepBtn.disabled = index === 0;\n    nextStepBtn.disabled = index === steps.length -1;\n  }\n\n  startButton.addEventListener('click', () => {\n    try {\n      const graph = parseMatrix(matrixInput.value);\n      steps = floydWarshallSteps(graph);\n      renderStep(0);\n      controlsDiv.style.display = 'flex';\n    } catch (err) {\n      alert('Error: ' + err.message);\n      outputDiv.innerHTML = '';\n      stepInfoDiv.textContent = '';\n      controlsDiv.style.display = 'none';\n    }\n  });\n\n  prevStepBtn.addEventListener('click', () => {\n    if(currentStepIndex > 0) {\n      renderStep(currentStepIndex - 1);\n    }\n  });\n\n  nextStepBtn.addEventListener('click', () => {\n    if(currentStepIndex < steps.length -1) {\n      renderStep(currentStepIndex + 1);\n    }\n  });\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Floyd-Warshall Algorithm"
    }
  ],
  "topic": "Floyd-Warshall Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}