{
  "id": "92fef4f2-ca67-11f0-a3d6-179b5eb5e89b",
  "timestamp": "2025-11-26T01:32:28.098Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Topological Sort Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 2rem;\n    background: #f5f5f5;\n  }\n  h1 {\n    text-align: center;\n  }\n  #graphInput {\n    width: 100%;\n    height: 150px;\n    font-family: monospace;\n    font-size: 14px;\n  }\n  #runBtn {\n    display: block;\n    margin: 1rem 0;\n    padding: 0.5rem 1rem;\n    font-size: 16px;\n  }\n  #output {\n    background: white;\n    padding: 1rem;\n    border-radius: 8px;\n    min-height: 100px;\n    white-space: pre-wrap;\n    font-family: monospace;\n    font-size: 16px;\n  }\n  .error {\n    color: red;\n  }\n  label {\n    font-weight: bold;\n  }\n  .hint {\n    background: #e3f2fd;\n    border-left: 4px solid #2196f3;\n    padding: 0.5rem 1rem;\n    margin-bottom: 1rem;\n    font-size: 14px;\n    line-height: 1.4;\n  }\n  #graphViz {\n    margin-top: 1rem;\n    background: white;\n    border-radius: 8px;\n    padding: 1rem;\n  }\n  svg {\n    width: 100%;\n    height: 240px;\n  }\n</style>\n</head>\n<body>\n<h1>Topological Sort Demo</h1>\n\n<div class=\"hint\">\n  Enter a directed graph as adjacency lists in JSON format.<br />\n  Example (keys are nodes, values are lists of nodes they point to):<br />\n  <code>{\"5\": [\"2\", \"0\"], \"4\": [\"0\",\"1\"], \"2\": [\"3\"], \"3\": [\"1\"], \"0\": [], \"1\": []}</code>\n</div>\n\n<label for=\"graphInput\">Graph adjacency list (JSON):</label><br />\n<textarea id=\"graphInput\" spellcheck=\"false\">{\"5\": [\"2\", \"0\"], \"4\": [\"0\",\"1\"], \"2\": [\"3\"], \"3\": [\"1\"], \"0\": [], \"1\": []}</textarea>\n<button id=\"runBtn\">Run Topological Sort</button>\n\n<div id=\"output\" aria-live=\"polite\"></div>\n\n<div id=\"graphViz\"></div>\n\n<script>\n  // Simple topological sort using DFS; detects cycles.\n  function topologicalSort(graph) {\n    const visited = new Set();\n    const recStack = new Set();\n    const order = [];\n    let hasCycle = false;\n\n    function dfs(node) {\n      if (hasCycle) return;\n      if (!graph.hasOwnProperty(node)) {\n        // Handle unknown nodes gracefully by adding with empty list\n        graph[node] = [];\n      }\n      if (recStack.has(node)) {\n        hasCycle = true;\n        return;\n      }\n      if (visited.has(node)) return;\n\n      recStack.add(node);\n      for (const neighbor of graph[node]) {\n        dfs(neighbor);\n      }\n      recStack.delete(node);\n      visited.add(node);\n      order.push(node);\n    }\n\n    for (const node of Object.keys(graph)) {\n      if (!visited.has(node)) {\n        dfs(node);\n      }\n    }\n\n    if (hasCycle) {\n      return null; // Cycle detected, no topological order\n    }\n    return order.reverse();\n  }\n\n  // Function to create a simple SVG visualization of the graph and topological order\n  function visualizeGraph(graph, order) {\n    const width = 600;\n    const height = 240;\n    const svgNS = \"http://www.w3.org/2000/svg\";\n    const svg = document.createElementNS(svgNS, \"svg\");\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n\n    // Coordinates for nodes in a line done by order\n    // If order null (cycle), arrange nodes alphabetically\n    const nodes = order ? order : Object.keys(graph).sort();\n    const spacing = width / (nodes.length + 1);\n    const radius = 20;\n\n    // Map node -> {x,y}\n    const coords = {};\n    const y = height / 2;\n\n    nodes.forEach((node, i) => {\n      coords[node] = { x: spacing * (i + 1), y };\n    });\n\n    // Draw edges as arrows\n    for (const [from, neighbors] of Object.entries(graph)) {\n      const fromCoord = coords[from];\n      if (!fromCoord) continue; // If from is unknown, skip\n\n      neighbors.forEach(to => {\n        const toCoord = coords[to];\n        if (!toCoord) return; // skip unknown nodes\n\n        // Draw line with arrowhead\n        const line = document.createElementNS(svgNS, \"line\");\n        line.setAttribute(\"x1\", fromCoord.x);\n        line.setAttribute(\"y1\", fromCoord.y);\n        line.setAttribute(\"x2\", toCoord.x);\n        line.setAttribute(\"y2\", toCoord.y);\n        line.setAttribute(\"stroke\", \"#444\");\n        line.setAttribute(\"stroke-width\", \"2\");\n        line.setAttribute(\"marker-end\", \"url(#arrowhead)\");\n        svg.appendChild(line);\n      });\n    }\n\n    // Define arrowhead marker\n    const defs = document.createElementNS(svgNS, \"defs\");\n    const marker = document.createElementNS(svgNS, \"marker\");\n    marker.setAttribute(\"id\", \"arrowhead\");\n    marker.setAttribute(\"markerWidth\", \"10\");\n    marker.setAttribute(\"markerHeight\", \"7\");\n    marker.setAttribute(\"refX\", \"10\");\n    marker.setAttribute(\"refY\", \"3.5\");\n    marker.setAttribute(\"orient\", \"auto\");\n    marker.setAttribute(\"fill\", \"#444\");\n\n    const polygon = document.createElementNS(svgNS, \"polygon\");\n    polygon.setAttribute(\"points\", \"0 0, 10 3.5, 0 7\");\n    marker.appendChild(polygon);\n    defs.appendChild(marker);\n    svg.appendChild(defs);\n\n    // Draw nodes as circles + labels\n    nodes.forEach((node, i) => {\n      const { x, y } = coords[node];\n\n      // Circle backgrounds - highlight order number if exists\n      const circle = document.createElementNS(svgNS, \"circle\");\n      circle.setAttribute(\"cx\", x);\n      circle.setAttribute(\"cy\", y);\n      circle.setAttribute(\"r\", radius);\n      circle.setAttribute(\"fill\", \"#2196f3\");\n      circle.setAttribute(\"stroke\", \"white\");\n      circle.setAttribute(\"stroke-width\", \"2\");\n      svg.appendChild(circle);\n\n      // Node label (node name)\n      const text = document.createElementNS(svgNS, \"text\");\n      text.setAttribute(\"x\", x);\n      text.setAttribute(\"y\", y + 5);\n      text.setAttribute(\"text-anchor\", \"middle\");\n      text.setAttribute(\"font-size\", \"16\");\n      text.setAttribute(\"fill\", \"white\");\n      text.style.userSelect = \"none\";\n      text.textContent = node;\n      svg.appendChild(text);\n\n      // If we have a topological order, show order number below\n      if (order) {\n        const ordText = document.createElementNS(svgNS, \"text\");\n        ordText.setAttribute(\"x\", x);\n        ordText.setAttribute(\"y\", y + radius + 18);\n        ordText.setAttribute(\"text-anchor\", \"middle\");\n        ordText.setAttribute(\"font-size\", \"14\");\n        ordText.setAttribute(\"fill\", \"#333\");\n        ordText.style.userSelect = \"none\";\n        ordText.textContent = i + 1;\n        svg.appendChild(ordText);\n      }\n    });\n\n    return svg;\n  }\n\n  document.getElementById(\"runBtn\").addEventListener(\"click\", () => {\n    const output = document.getElementById(\"output\");\n    const graphViz = document.getElementById(\"graphViz\");\n    output.textContent = \"\";\n    graphViz.innerHTML = \"\";\n\n    let graph;\n    try {\n      graph = JSON.parse(document.getElementById(\"graphInput\").value.trim());\n\n      if (\n        typeof graph !== \"object\" ||\n        graph === null ||\n        Array.isArray(graph)\n      ) {\n        throw new Error(\"Graph must be a JSON object with adjacency lists.\");\n      }\n\n      // Validate adjacency lists as arrays of strings or numbers\n      for (const [node, neighbors] of Object.entries(graph)) {\n        if (!Array.isArray(neighbors)) {\n          throw new Error(\n            `Neighbors of node '${node}' must be an array.`\n          );\n        }\n        for (const n of neighbors) {\n          if (typeof n !== \"string\" && typeof n !== \"number\") {\n            throw new Error(\n              `Neighbor '${n}' of node '${node}' must be a string or number.`\n            );\n          }\n        }\n      }\n    } catch (e) {\n      output.innerHTML = `<span class=\"error\">Invalid JSON or input: ${e.message}</span>`;\n      return;\n    }\n\n    // Ensure nodes keys and neighbor entries are all strings for consistent keys\n    const normalizedGraph = {};\n    for (const [node, neighbors] of Object.entries(graph)) {\n      const strNode = String(node);\n      normalizedGraph[strNode] = neighbors.map((n) => String(n));\n    }\n\n    // Call topological sort\n    const result = topologicalSort(normalizedGraph);\n\n    if (result === null) {\n      output.innerHTML = `<span class=\"error\">Cycle detected! Topological sort is not possible.</span>`;\n      // Show graph anyway with alphabetical layout\n      const svg = visualizeGraph(normalizedGraph, null);\n      graphViz.appendChild(svg);\n    } else {\n      output.textContent = \"Topological order:\\n\" + result.join(\" â†’ \");\n      const svg = visualizeGraph(normalizedGraph, result);\n      graphViz.appendChild(svg);\n    }\n  });\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}