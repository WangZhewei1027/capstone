{
  "id": "92fecde0-ca67-11f0-a3d6-179b5eb5e89b",
  "timestamp": "2025-11-26T01:32:56.549Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Bellman-Ford Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Bellman-Ford Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n    overflow: hidden;\n    background: #f0f3f7;\n  }\n  header {\n    background: #2c3e50;\n    color: white;\n    padding: 1rem;\n    text-align: center;\n    user-select: none;\n  }\n  main {\n    flex: 1;\n    display: flex;\n    overflow: hidden;\n  }\n  #graph-container {\n    flex: 2;\n    background: #fff;\n    border-right: 1px solid #ccc;\n    position: relative;\n  }\n  #controls {\n    flex: 1;\n    padding: 1rem;\n    overflow-y: auto;\n    background: #fafafa;\n  }\n  h2 {\n    margin-top: 0;\n  }\n  label {\n    display: block;\n    margin: 0.8rem 0 0.3rem;\n    font-weight: bold;\n  }\n  input[type=\"number\"],\n  select,\n  button {\n    width: 100%;\n    padding: 0.4rem 0.6rem;\n    font-size: 1rem;\n    box-sizing: border-box;\n  }\n  button {\n    margin-top: 1rem;\n    background: #2980b9;\n    color: white;\n    border: none;\n    cursor: pointer;\n    border-radius: 3px;\n  }\n  button:disabled {\n    background: #ccc;\n    cursor: not-allowed;\n  }\n  #messages {\n    margin-top: 1rem;\n    font-family: monospace;\n    background: #f4f4f4;\n    padding: 0.6rem;\n    height: 150px;\n    overflow-y: auto;\n    border-radius: 3px;\n    border: 1px solid #ccc;\n    white-space: pre-line;\n  }\n  svg {\n    width: 100%;\n    height: 100%;\n  }\n  circle.node {\n    fill: #3498db;\n    stroke: #2980b9;\n    stroke-width: 3px;\n    cursor: pointer;\n    transition: fill 0.3s, stroke 0.3s;\n  }\n  circle.node.source {\n    fill: #e67e22;\n    stroke: #d35400;\n  }\n  circle.node.negative-cycle {\n    fill: red;\n  }\n  text.node-label {\n    pointer-events: none;\n    user-select: none;\n    font-weight: bold;\n    fill: #2c3e50;\n  }\n  text.dist-label {\n    pointer-events: none;\n    font-size: 0.8em;\n    fill: #34495e;\n  }\n  path.edge {\n    fill: none;\n    stroke: #95a5a6;\n    stroke-width: 2px;\n    marker-end: url(#arrowhead);\n    transition: stroke 0.3s;\n  }\n  path.edge.updated {\n    stroke: #e74c3c;\n    stroke-width: 3px;\n  }\n  text.edge-label {\n    font-size: 0.85em;\n    fill: #7f8c8d;\n    user-select: none;\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Bellman-Ford Algorithm Visualization</h1>\n  <small>Create a directed graph, then run Bellman-Ford to find shortest paths and detect negative cycles.</small>\n</header>\n<main>\n  <div id=\"graph-container\">\n    <svg id=\"graph-svg\" viewBox=\"0 0 800 600\" tabindex=\"0\" aria-label=\"Graph Visualization\"></svg>\n  </div>\n  <div id=\"controls\" aria-live=\"polite\" aria-atomic=\"true\">\n\n    <h2>Graph Controls</h2>\n    <label for=\"node-name\">Add Node (Name):</label>\n    <input type=\"text\" id=\"node-name\" maxlength=\"3\" placeholder=\"E.g. A\" aria-describedby=\"nodeNameDesc\" />\n    <small id=\"nodeNameDesc\">Single letter or short name</small>\n    <button id=\"add-node-btn\" aria-label=\"Add Node\">Add Node</button>\n\n    <label for=\"edge-from\">Add Edge - From:</label>\n    <select id=\"edge-from\" aria-label=\"Edge from node\"></select>\n\n    <label for=\"edge-to\">Add Edge - To:</label>\n    <select id=\"edge-to\" aria-label=\"Edge to node\"></select>\n\n    <label for=\"edge-weight\">Edge Weight (integer):</label>\n    <input type=\"number\" id=\"edge-weight\" value=\"1\" step=\"1\" aria-describedby=\"edgeWeightDesc\" />\n    <small id=\"edgeWeightDesc\">Can be negative</small>\n\n    <button id=\"add-edge-btn\" aria-label=\"Add Edge\">Add Edge</button>\n\n    <hr />\n    <h2>Algorithm Settings</h2>\n    <label for=\"source-node\">Select Source Node:</label>\n    <select id=\"source-node\" aria-label=\"Source node for Bellman-Ford\"></select>\n\n    <button id=\"start-btn\" aria-label=\"Run Bellman-Ford Algorithm\">Run Bellman-Ford</button>\n    <button id=\"step-btn\" aria-label=\"Step through algorithm\" disabled>Step</button>\n    <button id=\"reset-btn\" aria-label=\"Reset graph and algorithm\">Reset</button>\n\n    <hr />\n    <h2>Status & Messages</h2>\n    <div id=\"messages\" role=\"log\" aria-live=\"polite\" tabindex=\"0\"></div>\n  </div>\n</main>\n\n<script>\n(() => {\n  // Graph data structures\n  class Node {\n    constructor(name, x, y) {\n      this.name = name;\n      this.x = x;\n      this.y = y;\n      this.dist = Infinity;\n      this.predecessor = null;\n      this.inNegativeCycle = false;\n    }\n  }\n  class Edge {\n    constructor(from, to, weight) {\n      this.from = from;\n      this.to = to;\n      this.weight = weight;\n      this.isUpdated = false;\n    }\n  }\n\n  // Graph and algorithm state\n  const graph = {\n    nodes: [],\n    edges: [],\n  };\n\n  let bellmanFordState = null; // to manage stepwise execution\n\n  // DOM Elements\n  const svg = document.getElementById(\"graph-svg\");\n  const addNodeBtn = document.getElementById(\"add-node-btn\");\n  const addEdgeBtn = document.getElementById(\"add-edge-btn\");\n  const nodeNameInput = document.getElementById(\"node-name\");\n  const edgeFromSelect = document.getElementById(\"edge-from\");\n  const edgeToSelect = document.getElementById(\"edge-to\");\n  const edgeWeightInput = document.getElementById(\"edge-weight\");\n  const sourceNodeSelect = document.getElementById(\"source-node\");\n  const startBtn = document.getElementById(\"start-btn\");\n  const stepBtn = document.getElementById(\"step-btn\");\n  const resetBtn = document.getElementById(\"reset-btn\");\n  const messagesDiv = document.getElementById(\"messages\");\n\n  // Visualization constants\n  const NODE_RADIUS = 22;\n  const width = 800;\n  const height = 600;\n\n  // Helpers\n  function logMessage(msg) {\n    messagesDiv.textContent += msg + \"\\n\";\n    messagesDiv.scrollTop = messagesDiv.scrollHeight;\n  }\n  function clearMessages() {\n    messagesDiv.textContent = \"\";\n  }\n\n  // Add default initial nodes for convenience\n  function addDefaultNodes() {\n    // Example layout roughly circular\n    const defaultNodes = [\"A\", \"B\", \"C\", \"D\", \"E\"];\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const radius = 180;\n    for (let i = 0; i < defaultNodes.length; i++) {\n      const angle = (2 * Math.PI * i) / defaultNodes.length;\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n      addNode(defaultNodes[i], x, y);\n    }\n    refreshAllSelects();\n  }\n\n  // Add a node to the graph\n  function addNode(name, x = Math.random() * (width - 2*NODE_RADIUS) + NODE_RADIUS, y = Math.random() * (height - 2*NODE_RADIUS) + NODE_RADIUS) {\n    name = name.trim();\n    if (!name) {\n      alert(\"Node name cannot be empty.\");\n      return false;\n    }\n    if (graph.nodes.find(n => n.name === name)) {\n      alert(\"Node name must be unique.\");\n      return false;\n    }\n    if (/[^\\w]/.test(name)) {\n      alert(\"Node name must be alphanumeric (letters and digits only).\");\n      return false;\n    }\n    const node = new Node(name, x, y);\n    graph.nodes.push(node);\n    refreshAllSelects();\n    drawGraph();\n    return true;\n  }\n\n  // Add edge to graph\n  function addEdge(fromName, toName, weight) {\n    if (fromName === toName) {\n      alert(\"No loops allowed (edge from and to same node).\");\n      return false;\n    }\n    const fromNode = graph.nodes.find(n => n.name === fromName);\n    const toNode = graph.nodes.find(n => n.name === toName);\n    if (!fromNode || !toNode) {\n      alert(\"Invalid nodes selected.\");\n      return false;\n    }\n    // Check edge duplicates\n    if (graph.edges.find(e => e.from === fromNode && e.to === toNode)) {\n      alert(\"Edge already exists.\");\n      return false;\n    }\n    const edge = new Edge(fromNode, toNode, weight);\n    graph.edges.push(edge);\n    drawGraph();\n    return true;\n  }\n\n  // Clear graph and state\n  function resetGraph() {\n    graph.nodes.length = 0;\n    graph.edges.length = 0;\n    bellmanFordState = null;\n    clearMessages();\n    drawGraph();\n    refreshAllSelects();\n    stepBtn.disabled = true;\n  }\n\n  // Refresh dropdown selects for nodes\n  function refreshAllSelects() {\n    [edgeFromSelect, edgeToSelect, sourceNodeSelect].forEach(select => {\n      while (select.firstChild) {\n        select.removeChild(select.firstChild);\n      }\n    });\n    graph.nodes.forEach(node => {\n      const opt1 = document.createElement(\"option\");\n      opt1.value = node.name;\n      opt1.textContent = node.name;\n\n      const opt2 = opt1.cloneNode(true);\n      const opt3 = opt1.cloneNode(true);\n\n      edgeFromSelect.appendChild(opt1);\n      edgeToSelect.appendChild(opt2);\n      sourceNodeSelect.appendChild(opt3);\n    });\n  }\n\n  // Drawing functions\n  function drawGraph() {\n    // Clear SVG\n    while (svg.firstChild) svg.removeChild(svg.firstChild);\n\n    // Set up arrowhead marker\n    const marker = document.createElementNS(\"http://www.w3.org/2000/svg\", \"marker\");\n    marker.setAttribute(\"id\", \"arrowhead\");\n    marker.setAttribute(\"markerWidth\", \"10\");\n    marker.setAttribute(\"markerHeight\", \"7\");\n    marker.setAttribute(\"refX\", \"22\");\n    marker.setAttribute(\"refY\", \"3.5\");\n    marker.setAttribute(\"orient\", \"auto\");\n    marker.setAttribute(\"fill\", \"#95a5a6\");\n    const markerPath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    markerPath.setAttribute(\"d\", \"M0,0 L10,3.5 L0,7 Z\");\n    marker.appendChild(markerPath);\n    const defs = document.createElementNS(\"http://www.w3.org/2000/svg\", \"defs\");\n    defs.appendChild(marker);\n    svg.appendChild(defs);\n\n    // Draw edges first so nodes are on top\n    graph.edges.forEach(edge => {\n      drawEdge(edge);\n    });\n\n    // Draw nodes\n    graph.nodes.forEach(node => {\n      drawNode(node);\n    });\n  }\n  function drawEdge(edge) {\n    const from = edge.from;\n    const to = edge.to;\n\n    // Calculate line start/end slightly offset from node centers to edges of circles\n    const dx = to.x - from.x;\n    const dy = to.y - from.y;\n    const dist = Math.sqrt(dx*dx + dy*dy);\n    const offsetX = (dx / dist) * NODE_RADIUS;\n    const offsetY = (dy / dist) * NODE_RADIUS;\n\n    const startX = from.x + offsetX;\n    const startY = from.y + offsetY;\n    const endX = to.x - offsetX;\n    const endY = to.y - offsetY;\n\n    // Create path for line with slight curve to improve visual on overlapping edges\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    // For straight arrow:\n    path.setAttribute(\"d\", `M${startX} ${startY} L${endX} ${endY}`);\n    path.setAttribute(\"class\", \"edge\" + (edge.isUpdated ? \" updated\" : \"\"));\n    path.setAttribute(\"marker-end\", \"url(#arrowhead)\");\n    svg.appendChild(path);\n\n    // Edge weight label at midpoint with offset perpendicular to line\n    const labelX = (startX + endX) / 2;\n    const labelY = (startY + endY) / 2;\n    const perpX = -(dy / dist) * 15;\n    const perpY = (dx / dist) * 15;\n\n    const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    text.setAttribute(\"x\", labelX + perpX);\n    text.setAttribute(\"y\", labelY + perpY);\n    text.setAttribute(\"class\", \"edge-label\");\n    text.textContent = edge.weight;\n    svg.appendChild(text);\n  }\n\n  function drawNode(node) {\n    // Circle\n    const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    circle.setAttribute(\"cx\", node.x);\n    circle.setAttribute(\"cy\", node.y);\n    circle.setAttribute(\"r\", NODE_RADIUS);\n    circle.setAttribute(\"class\", \"node\");\n    if (bellmanFordState && bellmanFordState.source && node.name === bellmanFordState.source.name) {\n      circle.classList.add(\"source\");\n    }\n    if (node.inNegativeCycle) {\n      circle.classList.add(\"negative-cycle\");\n    }\n    svg.appendChild(circle);\n\n    // Node name label\n    const nameText = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    nameText.setAttribute(\"x\", node.x);\n    nameText.setAttribute(\"y\", node.y + 5);\n    nameText.setAttribute(\"text-anchor\", \"middle\");\n    nameText.setAttribute(\"class\", \"node-label\");\n    nameText.textContent = node.name;\n    svg.appendChild(nameText);\n\n    // Distance label below node if dist is finite\n    const distText = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    distText.setAttribute(\"x\", node.x);\n    distText.setAttribute(\"y\", node.y + NODE_RADIUS + 18);\n    distText.setAttribute(\"text-anchor\", \"middle\");\n    distText.setAttribute(\"class\", \"dist-label\");\n    distText.textContent = node.dist === Infinity ? \"∞\" : node.dist;\n    svg.appendChild(distText);\n  }\n\n  // Algorithm Implementation & Stepwise Execution\n  function initializeBellmanFord(sourceName) {\n    const source = graph.nodes.find(n => n.name === sourceName);\n    if (!source) {\n      alert(\"Invalid source node.\");\n      return false;\n    }\n    // Initialize distances and predecessors\n    graph.nodes.forEach(n => {\n      n.dist = Infinity;\n      n.predecessor = null;\n      n.inNegativeCycle = false;\n    });\n    graph.edges.forEach(e => e.isUpdated = false);\n\n    source.dist = 0;\n\n    // Bellman-Ford state holds iteration and edge index for step execution\n    bellmanFordState = {\n      source,\n      iteration: 0,\n      edgeIndex: 0,\n      updatedInIteration: false,\n      completed: false,\n      negativeCycleDetected: false,\n      negativeCycleNodes: [],\n    };\n    clearMessages();\n    logMessage(`Starting Bellman-Ford from source node: ${source.name}`);\n    drawGraph();\n    stepBtn.disabled = false;\n    return true;\n  }\n\n  // One step execution: relax one edge\n  function bellmanFordStep() {\n    if (!bellmanFordState || bellmanFordState.completed) return;\n\n    const { iteration, edgeIndex } = bellmanFordState;\n\n    // Reset previous edge highlights\n    graph.edges.forEach(e => e.isUpdated = false);\n\n    const edge = graph.edges[edgeIndex];\n\n    const u = edge.from;\n    const v = edge.to;\n    const w = edge.weight;\n\n    let relaxed = false;\n    if (u.dist !== Infinity && u.dist + w < v.dist) {\n      v.dist = u.dist + w;\n      v.predecessor = u;\n      relaxed = true;\n      bellmanFordState.updatedInIteration = true;\n      edge.isUpdated = true;\n      logMessage(\n        `Iteration ${iteration + 1}, Edge ${u.name}→${v.name} (weight ${w}): updated distance of ${v.name} to ${v.dist}.`\n      );\n    } else {\n      logMessage(\n        `Iteration ${iteration + 1}, Edge ${u.name}→${v.name} (weight ${w}): no update.`\n      );\n    }\n\n    bellmanFordState.edgeIndex++;\n\n    // End of all edges in current iteration?\n    if (bellmanFordState.edgeIndex >= graph.edges.length) {\n      // If no update in this iteration, algorithm completes early\n      if (!bellmanFordState.updatedInIteration) {\n        logMessage(`No updates in iteration ${iteration + 1}. Algorithm converged.`);\n        bellmanFordState.completed = true;\n        stepBtn.disabled = true;\n        detectNegativeCycleAfterRelaxation();\n      } else if (bellmanFordState.iteration + 1 === graph.nodes.length - 1) {\n        // Completed (|V|-1) iterations, check for negative cycles next\n        bellmanFordState.completed = true;\n        stepBtn.disabled = true;\n        logMessage(`Completed ${bellmanFordState.iteration + 1} iterations. Checking for negative cycles...`);\n        detectNegativeCycleAfterRelaxation();\n      } else {\n        // Prepare next iteration\n        bellmanFordState.iteration++;\n        bellmanFordState.edgeIndex = 0;\n        bellmanFordState.updatedInIteration = false;\n        logMessage(`Starting iteration ${bellmanFordState.iteration + 1}...`);\n      }\n    }\n    drawGraph();\n  }\n\n  // After normal relaxation steps, detect negative cycles\n  function detectNegativeCycleAfterRelaxation() {\n    let negativeCycleFound = false;\n    graph.edges.forEach(edge => {\n      const u = edge.from;\n      const v = edge.to;\n      if (u.dist !== Infinity && u.dist + edge.weight < v.dist) {\n        negativeCycleFound = true;\n        v.inNegativeCycle = true;\n        logMessage(`Negative weight cycle detected including edge ${u.name}→${v.name}.`);\n      }\n    });\n    if (!negativeCycleFound) {\n      logMessage(\"No negative weight cycles detected.\");\n    } else {\n      // Propagate markings to all nodes reachable from negative cycle edges\n      propagateNegativeCycleMarks();\n    }\n    drawGraph();\n  }\n\n  // Propagate negative cycle markings for nodes reachable from marked nodes\n  function propagateNegativeCycleMarks() {\n    const queue = graph.nodes.filter(n => n.inNegativeCycle);\n    const visited = new Set(queue);\n\n    while (queue.length) {\n      const node = queue.shift();\n      graph.edges.forEach(e => {\n        if (e.from === node && !visited.has(e.to)) {\n          e.to.inNegativeCycle = true;\n          visited.add(e.to);\n          queue.push(e.to);\n        }\n      });\n    }\n  }\n\n  // UI event handlers\n  addNodeBtn.addEventListener(\"click\", () => {\n    const name = nodeNameInput.value.trim();\n    if (addNode(name)) {\n      nodeNameInput.value = \"\";\n    }\n  });\n\n  addEdgeBtn.addEventListener(\"click\", () => {\n    const from = edgeFromSelect.value;\n    const to = edgeToSelect.value;\n    const weight = parseInt(edgeWeightInput.value, 10);\n    if (isNaN(weight)) {\n      alert(\"Edge weight must be an integer.\");\n      return;\n    }\n    addEdge(from, to, weight);\n  });\n\n  startBtn.addEventListener(\"click\", () => {\n    const source = sourceNodeSelect.value;\n    if (!source) {\n      alert(\"Please select a source node.\");\n      return;\n    }\n    if (graph.nodes.length === 0) {\n      alert(\"Graph must contain nodes.\");\n      return;\n    }\n    if (graph.edges.length === 0) {\n      alert(\"Graph must contain edges.\");\n      return;\n    }\n    if (initializeBellmanFord(source)) {\n      stepBtn.disabled = false;\n    }\n  });\n  stepBtn.addEventListener(\"click\", () => {\n    bellmanFordStep();\n  });\n\n  resetBtn.addEventListener(\"click\", () => {\n    resetGraph();\n  });\n\n  // Drag nodes functionality for interactive layout\n  let draggingNode = null;\n  let offsetX, offsetY;\n\n  svg.addEventListener(\"mousedown\", e => {\n    if (e.target.tagName === \"circle\" && e.target.classList.contains(\"node\")) {\n      const cx = parseFloat(e.target.getAttribute(\"cx\"));\n      const cy = parseFloat(e.target.getAttribute(\"cy\"));\n      offsetX = e.clientX - cx;\n      offsetY = e.clientY - cy;\n      const nodeName = getNodeNameFromCircle(e.target);\n      draggingNode = graph.nodes.find(n => n.name === nodeName);\n      svg.style.cursor = \"grabbing\";\n      e.preventDefault();\n    }\n  });\n  window.addEventListener(\"mousemove\", e => {\n    if (draggingNode) {\n      let newX = e.clientX - offsetX;\n      let newY = e.clientY - offsetY;\n      // Clamp inside SVG bounds\n      newX = Math.min(width - NODE_RADIUS, Math.max(NODE_RADIUS, newX));\n      newY = Math.min(height - NODE_RADIUS, Math.max(NODE_RADIUS, newY));\n      draggingNode.x = newX;\n      draggingNode.y = newY;\n      drawGraph();\n    }\n  });\n  window.addEventListener(\"mouseup\", e => {\n    if (draggingNode) {\n      draggingNode = null;\n      svg.style.cursor = \"default\";\n    }\n  });\n  function getNodeNameFromCircle(circle) {\n    // The node label text follows circle, so just get the next sibling text node\n    const nodes = Array.from(svg.querySelectorAll(\"circle.node\"));\n    const index = nodes.indexOf(circle);\n    if (index === -1) return null;\n    const node = graph.nodes[index];\n    return node ? node.name : null;\n  }\n\n  // Initialize with default nodes\n  addDefaultNodes();\n\n  // For accessibility: announce messages on update\n  const observer = new MutationObserver(() => {\n    messagesDiv.setAttribute(\"aria-live\", \"polite\");\n  });\n  observer.observe(messagesDiv, { childList: true });\n\n  // Initial drawing\n  drawGraph();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Bellman-Ford Algorithm"
    }
  ],
  "topic": "Bellman-Ford Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}