{
  "id": "92fdbc72-ca67-11f0-a3d6-179b5eb5e89b",
  "timestamp": "2025-11-26T01:32:36.946Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Weighted Graph Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    padding: 0;\n    display:flex;\n    flex-direction: column;\n    height: 100vh;\n    overflow: hidden;\n  }\n  header {\n    background: #333;\n    color: white;\n    padding: 1rem;\n    text-align: center;\n  }\n  #graph-container {\n    flex: 1;\n    position: relative;\n    background: #f9f9f9;\n  }\n  svg {\n    width: 100%;\n    height: 100%;\n    display:block;\n  }\n  .node circle {\n    fill: #4a90e2;\n    stroke: #0a3579;\n    stroke-width: 2px;\n    cursor: pointer;\n  }\n  .node text {\n    fill: #fff;\n    font-weight: bold;\n    pointer-events: none;\n    user-select: none;\n  }\n  .edge path {\n    stroke: #777;\n    stroke-width: 2px;\n    fill: none;\n  }\n  .edge text {\n    fill: #333;\n    font-size: 14px;\n    font-weight: bold;\n    user-select: none;\n  }\n  #info {\n    background: #eee;\n    padding: 0.5rem 1rem;\n    font-size: 1rem;\n    height: 3rem;\n  }\n  #controls {\n    background: #222;\n    padding: 0.5rem 1rem;\n    color: white;\n    display: flex;\n    gap: 0.5rem;\n    align-items: center;\n    flex-wrap: wrap;\n  }\n  #controls > * {\n    font-size: 1rem;\n  }\n  button {\n    background: #4a90e2;\n    border: none;\n    color: white;\n    padding: 0.4rem 0.8rem;\n    border-radius: 3px;\n    cursor: pointer;\n  }\n  button:hover {\n    background: #3572c0;\n  }\n  label {\n    user-select:none;\n  }\n  input[type=number] {\n    width: 50px;\n  }\n</style>\n</head>\n<body>\n\n<header>\n  <h1>Weighted Graph Visualization</h1>\n</header>\n\n<div id=\"controls\">\n  <label>\n    Node label: <input type=\"text\" id=\"node-label\" maxlength=\"2\" size=\"2\" />\n  </label>\n  <button id=\"add-node-btn\">Add Node</button>\n  <label>\n    From: \n    <select id=\"edge-from\"></select>\n  </label>\n  <label>\n    To: \n    <select id=\"edge-to\"></select>\n  </label>\n  <label>\n    Weight: <input type=\"number\" id=\"edge-weight\" value=\"1\" min=\"1\" />\n  </label>\n  <button id=\"add-edge-btn\">Add Edge</button>\n  <button id=\"clear-btn\" title=\"Remove all nodes and edges\">Clear Graph</button>\n</div>\n\n<div id=\"graph-container\">\n  <svg id=\"graph-svg\" xmlns=\"http://www.w3.org/2000/svg\"></svg>\n</div>\n<div id=\"info\">\n  Click and drag nodes to move them. Add nodes and edges using the controls above.\n</div>\n\n<script>\n(() => {\n  const svg = document.getElementById('graph-svg');\n  const addNodeBtn = document.getElementById('add-node-btn');\n  const addEdgeBtn = document.getElementById('add-edge-btn');\n  const nodeLabelInput = document.getElementById('node-label');\n  const edgeFromSelect = document.getElementById('edge-from');\n  const edgeToSelect = document.getElementById('edge-to');\n  const edgeWeightInput = document.getElementById('edge-weight');\n  const clearBtn = document.getElementById('clear-btn');\n\n  let nodes = [];\n  let edges = [];\n\n  // Node circle radius\n  const NODE_RADIUS = 20;\n\n  // Track dragged node\n  let draggedNode = null;\n  let dragOffset = {x: 0, y: 0};\n\n  // Add node\n  function addNode(label) {\n    if(!label) return false;\n    label = label.trim();\n    if(nodes.find(n => n.label === label)) {\n      alert('Node label must be unique.');\n      return false;\n    }\n    // Random position inside svg container with some margin\n    const rect = svg.getBoundingClientRect();\n    \n    const margin = NODE_RADIUS + 10;\n    const x = Math.random() * (rect.width - margin*2) + margin;\n    const y = Math.random() * (rect.height - margin*2) + margin;\n    const id = Date.now() + Math.random();\n    nodes.push({id, label, x, y});\n    updateSelectors();\n    render();\n    return true;\n  }\n\n  // Add edge\n  function addEdge(fromLabel, toLabel, weight) {\n    if(!fromLabel || !toLabel) return false;\n    if(fromLabel === toLabel) {\n      alert('Cannot create edge from a node to itself.');\n      return false;\n    }\n    weight = Number(weight);\n    if(weight <= 0 || isNaN(weight)) {\n      alert('Weight must be a positive number.');\n      return false;\n    }\n    // Check nodes exist\n    const fromNode = nodes.find(n => n.label === fromLabel);\n    const toNode = nodes.find(n => n.label === toLabel);\n    if(!fromNode || !toNode) {\n      alert('Both nodes must exist.');\n      return false;\n    }\n    // Prevent duplicate edges (undirected graph, edges same in either direction)\n    if(edges.find(e => \n          ( (e.from === fromNode.id && e.to === toNode.id) ||\n            (e.from === toNode.id && e.to === fromNode.id) )\n        )) {\n      alert('Edge already exists between these nodes.');\n      return false;\n    }\n    edges.push({id: Date.now() + Math.random(), from: fromNode.id, to: toNode.id, weight});\n    render();\n    return true;\n  }\n\n  // Update the node lists in edge selectors\n  function updateSelectors() {\n    [edgeFromSelect, edgeToSelect].forEach(select => {\n      const val = select.value;\n      select.innerHTML = '';\n      nodes.forEach(n => {\n        const option = document.createElement('option');\n        option.value = n.label;\n        option.textContent = n.label;\n        select.appendChild(option);\n      });\n      if(nodes.length > 0) {\n        select.value = val && nodes.find(n => n.label === val) ? val : nodes[0].label;\n      }\n    });\n  }\n\n  // Clear graph\n  function clearGraph() {\n    nodes = [];\n    edges = [];\n    updateSelectors();\n    render();\n  }\n\n  // Render graph\n  function render() {\n    // Clean svg\n    while(svg.lastChild) svg.removeChild(svg.lastChild);\n\n    // Draw edges first\n    edges.forEach(edge => {\n      const fromNode = nodes.find(n => n.id === edge.from);\n      const toNode = nodes.find(n => n.id === edge.to);\n      if(!fromNode || !toNode) return;\n      \n      const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n      path.setAttribute('class', 'edge-path');\n      \n      // Draw a curved line for clarity (quadratic Bezier)\n      const dx = toNode.x - fromNode.x;\n      const dy = toNode.y - fromNode.y;\n      const dist = Math.sqrt(dx*dx + dy*dy);\n      const normX = dx/dist;\n      const normY = dy/dist;\n\n      // Control point for curve (perpendicular midpoint offset)\n      const midX = (fromNode.x + toNode.x)/2;\n      const midY = (fromNode.y + toNode.y)/2;\n      const curveOffset = 30; // pixels\n      const controlX = midX - normY * curveOffset;\n      const controlY = midY + normX * curveOffset;\n\n      // Path string\n      const pathStr = `M${fromNode.x},${fromNode.y} Q${controlX},${controlY} ${toNode.x},${toNode.y}`;\n      path.setAttribute('d', pathStr);\n      path.setAttribute('stroke', '#777');\n      path.setAttribute('stroke-width', '2');\n      path.setAttribute('fill', 'none');\n\n      svg.appendChild(path);\n\n      // Edge weight label position: near control point with offset\n      const txt = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      txt.setAttribute('fill', '#333');\n      txt.setAttribute('font-weight', 'bold');\n      txt.setAttribute('font-size', '14');\n      txt.setAttribute('pointer-events', 'none');\n      // place text slightly offset from control point, small shift to avoid overlap with line\n      txt.setAttribute('x', controlX + 8);\n      txt.setAttribute('y', controlY - 8);\n      txt.textContent = edge.weight;\n\n      svg.appendChild(txt);\n    });\n\n    // Draw nodes on top\n    nodes.forEach(node => {\n      const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      g.classList.add('node');\n      g.setAttribute('data-id', node.id);\n      g.style.cursor = 'pointer';\n\n      const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n      circle.setAttribute('r', NODE_RADIUS);\n      circle.setAttribute('cx', node.x);\n      circle.setAttribute('cy', node.y);\n      circle.setAttribute('fill', '#4a90e2');\n      circle.setAttribute('stroke', '#0a3579');\n      circle.setAttribute('stroke-width', '2');\n      \n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      text.setAttribute('x', node.x);\n      text.setAttribute('y', node.y+5); // vertical centering (approx.)\n      text.setAttribute('text-anchor', 'middle');\n      text.setAttribute('fill', 'white');\n      text.setAttribute('font-weight', 'bold');\n      text.setAttribute('font-size', '16');\n      text.style.userSelect = 'none';\n      text.textContent = node.label;\n\n      g.appendChild(circle);\n      g.appendChild(text);\n\n      svg.appendChild(g);\n\n      // Attach event for dragging\n      g.addEventListener('mousedown', (evt) => {\n        draggedNode = node;\n        const pt = svg.createSVGPoint();\n        pt.x = evt.clientX; pt.y = evt.clientY;\n        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());\n        dragOffset.x = svgP.x - node.x;\n        dragOffset.y = svgP.y - node.y;\n        evt.preventDefault();\n      });\n    });\n  }\n\n  // On mouse move for dragging\n  function onMouseMove(evt) {\n    if(!draggedNode) return;\n    const pt = svg.createSVGPoint();\n    pt.x = evt.clientX; pt.y = evt.clientY;\n    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());\n\n    // Keep inside svg bounds - margin for node radius\n    const margin = NODE_RADIUS + 1;\n    const rect = svg.getBoundingClientRect();\n    let newX = svgP.x - dragOffset.x;\n    let newY = svgP.y - dragOffset.y;\n    newX = Math.min(rect.width - margin, Math.max(margin, newX));\n    newY = Math.min(rect.height - margin, Math.max(margin, newY));\n\n    draggedNode.x = newX;\n    draggedNode.y = newY;\n    render();\n  }\n\n  function onMouseUp(evt) {\n    draggedNode = null;\n  }\n\n  addNodeBtn.addEventListener('click', () => {\n    const label = nodeLabelInput.value.trim();\n    if(label.length === 0) {\n      alert('Please enter a node label.');\n      return;\n    }\n    if(addNode(label)) {\n      nodeLabelInput.value = '';\n      nodeLabelInput.focus();\n    }\n  });\n\n  addEdgeBtn.addEventListener('click', () => {\n    const fromLabel = edgeFromSelect.value;\n    const toLabel = edgeToSelect.value;\n    const weight = edgeWeightInput.value;\n    addEdge(fromLabel, toLabel, weight);\n  });\n\n  clearBtn.addEventListener('click', () => {\n    if(confirm('Are you sure you want to clear the entire graph?')) {\n      clearGraph();\n    }\n  });\n\n  // Drag listeners on svg\n  svg.addEventListener('mousemove', onMouseMove);\n  window.addEventListener('mouseup', onMouseUp);\n\n  // Initialize with sample graph\n  function initSample() {\n    addNode('A');\n    addNode('B');\n    addNode('C');\n    addNode('D');\n    addEdge('A', 'B', 4);\n    addEdge('A', 'C', 2);\n    addEdge('B', 'C', 5);\n    addEdge('B', 'D', 10);\n    addEdge('C', 'D', 3);\n  }\n\n  initSample();\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}