{
  "id": "92fd6e50-ca67-11f0-a3d6-179b5eb5e89b",
  "timestamp": "2025-11-26T01:32:10.303Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Binary Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Binary Tree Visualization & Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  #treeContainer {\n    margin-top: 20px;\n  }\n  svg {\n    border: 1px solid #ccc;\n    background: #f9f9f9;\n    max-width: 100%;\n    height: 500px;\n  }\n  circle.node {\n    fill: #1e90ff;\n    stroke: #333;\n    stroke-width: 2px;\n    cursor: pointer;\n  }\n  text.node-label {\n    fill: white;\n    font-weight: bold;\n    pointer-events: none;\n    user-select: none;\n  }\n  line.link {\n    stroke: #555;\n    stroke-width: 2px;\n  }\n  form label {\n    display: inline-block;\n    width: 60px;\n    font-weight: bold;\n  }\n  form input, form button {\n    margin: 5px 10px 5px 0;\n    padding: 6px;\n    font-size: 14px;\n  }\n  #output {\n    margin-top: 20px;\n    padding: 10px;\n    background: #eef;\n    border: 1px solid #99c;\n    white-space: pre-wrap;\n    font-family: monospace;\n  }\n</style>\n</head>\n<body>\n\n<h1>Binary Tree Visualization & Demo</h1>\n\n<p>\n  This demo lets you insert numbers into a Binary Search Tree (BST) and visualize it.\n  Click a node to see its value in the output box.\n</p>\n\n<form id=\"insertForm\">\n  <label for=\"valueInput\">Value:</label>\n  <input type=\"number\" id=\"valueInput\" step=\"1\" required />\n  <button type=\"submit\">Insert</button>\n  <button type=\"button\" id=\"clearBtn\">Clear Tree</button>\n</form>\n\n<div id=\"treeContainer\">\n  <svg id=\"treeSVG\" width=\"100%\" height=\"500\"></svg>\n</div>\n\n<h2>Output:</h2>\n<div id=\"output\">Insert values to build the Binary Search Tree.</div>\n\n<script>\n  // Binary Tree Node class\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n      this.x = 0; // position for visualization\n      this.y = 0;\n    }\n  }\n\n  // Binary Search Tree class\n  class BST {\n    constructor() {\n      this.root = null;\n    }\n\n    insert(value) {\n      const newNode = new Node(value);\n      if (!this.root) {\n        this.root = newNode;\n        return true;\n      }\n      let current = this.root;\n      while (true) {\n        if (value === current.value) {\n          // Ignore duplicates\n          return false;\n        }\n        if (value < current.value) {\n          if (!current.left) {\n            current.left = newNode;\n            return true;\n          }\n          current = current.left;\n        } else {\n          if (!current.right) {\n            current.right = newNode;\n            return true;\n          }\n          current = current.right;\n        }\n      }\n    }\n\n    // Traverse In-Order (for output)\n    inOrder(node, visit) {\n      if (!node) return;\n      this.inOrder(node.left, visit);\n      visit(node);\n      this.inOrder(node.right, visit);\n    }\n\n    // Level-Order for breadth traversal\n    levelOrder(visit) {\n      const queue = [];\n      if (this.root) queue.push(this.root);\n      while (queue.length) {\n        const node = queue.shift();\n        visit(node);\n        if (node.left) queue.push(node.left);\n        if (node.right) queue.push(node.right);\n      }\n    }\n  }\n\n  // Visualization & interaction\n  (function() {\n    const svg = document.getElementById('treeSVG');\n    const NS = \"http://www.w3.org/2000/svg\";\n    const bst = new BST();\n    const output = document.getElementById('output');\n    const insertForm = document.getElementById('insertForm');\n    const valueInput = document.getElementById('valueInput');\n    const clearBtn = document.getElementById('clearBtn');\n\n    // Calculate x,y positions for nodes using a simple tree layout algorithm\n    function layoutTree(root) {\n      const levels = [];\n      const nodePositions = new Map();\n\n      function traverse(node, depth) {\n        if (!node) return;\n        if (!levels[depth]) levels[depth] = [];\n        levels[depth].push(node);\n        traverse(node.left, depth + 1);\n        traverse(node.right, depth + 1);\n      }\n      traverse(root, 0);\n\n      // Assign x positions by inorder traversal\n      let xPos = 0;\n      function assignXY(node, depth) {\n        if (!node) return;\n        assignXY(node.left, depth + 1);\n        node.x = xPos++;\n        node.y = depth;\n        assignXY(node.right, depth + 1);\n      }\n      assignXY(root, 0);\n    }\n\n    // Render the tree in SVG\n    function renderTree() {\n      while (svg.firstChild) {\n        svg.removeChild(svg.firstChild);\n      }\n      if (!bst.root) return;\n\n      layoutTree(bst.root);\n\n      // Constants for coordinate scaling\n      const NODE_RADIUS = 20;\n      const LEVEL_HEIGHT = 80;\n      const SIBLING_GAP = 50;\n\n      // Get max nodes at any level to determine width scaling\n      let maxLevelWidth = 0;\n      const levelsInfo = [];\n      (function countLevels(node, depth) {\n        if (!node) return;\n        levelsInfo[depth] = (levelsInfo[depth] || 0) + 1;\n        countLevels(node.left, depth + 1);\n        countLevels(node.right, depth + 1);\n      })(bst.root, 0);\n      maxLevelWidth = Math.max(...levelsInfo);\n\n      // Calculate horizontal space per node approx\n      const svgWidth = svg.clientWidth || 800;\n      const svgHeight = LEVEL_HEIGHT * (levelsInfo.length + 1);\n      svg.setAttribute(\"height\", svgHeight);\n\n      // We'll use the assigned inorder x for horizontal position and depth for y\n      // Scale x to width\n      // Since inorder index x may range from 0..(N-1), we map 0 to margin and max x to width-margin\n      const allNodes = [];\n      bst.levelOrder((node) => allNodes.push(node));\n\n      const maxX = allNodes.reduce((max, n) => Math.max(max, n.x), 0);\n      const marginX = NODE_RADIUS + 10;\n\n      function mapX(x) {\n        if (maxX === 0) return svgWidth / 2; // single node\n        return marginX + (x / maxX) * (svgWidth - 2 * marginX);\n      }\n      function mapY(depth) {\n        return NODE_RADIUS + depth * LEVEL_HEIGHT + 10;\n      }\n\n      // Draw links first (lines)\n      allNodes.forEach(node => {\n        if (node.left) {\n          const x1 = mapX(node.x);\n          const y1 = mapY(node.y);\n          const x2 = mapX(node.left.x);\n          const y2 = mapY(node.left.y);\n          const line = document.createElementNS(NS, 'line');\n          line.setAttribute('x1', x1);\n          line.setAttribute('y1', y1);\n          line.setAttribute('x2', x2);\n          line.setAttribute('y2', y2);\n          line.setAttribute('class', 'link');\n          svg.appendChild(line);\n        }\n        if (node.right) {\n          const x1 = mapX(node.x);\n          const y1 = mapY(node.y);\n          const x2 = mapX(node.right.x);\n          const y2 = mapY(node.right.y);\n          const line = document.createElementNS(NS, 'line');\n          line.setAttribute('x1', x1);\n          line.setAttribute('y1', y1);\n          line.setAttribute('x2', x2);\n          line.setAttribute('y2', y2);\n          line.setAttribute('class', 'link');\n          svg.appendChild(line);\n        }\n      });\n\n      // Draw nodes (circles + text)\n      allNodes.forEach(node => {\n        const cx = mapX(node.x);\n        const cy = mapY(node.y);\n\n        const circle = document.createElementNS(NS, 'circle');\n        circle.setAttribute('cx', cx);\n        circle.setAttribute('cy', cy);\n        circle.setAttribute('r', NODE_RADIUS);\n        circle.setAttribute('class', 'node');\n        circle.setAttribute('tabindex', 0);\n        circle.setAttribute('aria-label', 'Node with value ' + node.value);\n        svg.appendChild(circle);\n\n        // Text label\n        const text = document.createElementNS(NS, 'text');\n        text.setAttribute('x', cx);\n        text.setAttribute('y', cy + 5);\n        text.setAttribute('text-anchor', 'middle');\n        text.setAttribute('class', 'node-label');\n        text.textContent = node.value;\n        svg.appendChild(text);\n\n        // Interaction - on click show node info in output\n        circle.addEventListener('click', () => {\n          output.textContent = `Node clicked: ${node.value}`;\n        });\n        // Also allow keyboard Enter or Space keys\n        circle.addEventListener('keydown', (e) => {\n          if (e.key === 'Enter' || e.key === ' ') {\n            e.preventDefault();\n            circle.dispatchEvent(new Event('click'));\n          }\n        });\n      });\n    }\n\n    insertForm.addEventListener('submit', e => {\n      e.preventDefault();\n      const val = parseInt(valueInput.value, 10);\n      if (isNaN(val)) {\n        alert('Please enter a valid number');\n        return;\n      }\n      const inserted = bst.insert(val);\n      if (!inserted) {\n        alert('Value already exists in the tree (no duplicates allowed).');\n      } else {\n        output.textContent = `Inserted value ${val} into the BST.`;\n      }\n      valueInput.value = '';\n      valueInput.focus();\n      renderTree();\n    });\n\n    clearBtn.addEventListener('click', () => {\n      bst.root = null;\n      output.textContent = 'Tree cleared.';\n      renderTree();\n    });\n\n    // Initial message in output\n    output.textContent = 'Insert values to build the Binary Search Tree.';\n\n  })();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Tree"
    }
  ],
  "topic": "Binary Tree",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}