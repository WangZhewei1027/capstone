{
  "id": "92fdbc70-ca67-11f0-a3d6-179b5eb5e89b",
  "timestamp": "2025-11-26T01:32:42.370Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Heap (Min/Max)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Heap (Min/Max) Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  h1, h2 {\n    color: #333;\n  }\n  #controls {\n    margin-bottom: 15px;\n  }\n  input[type=number] {\n    width: 100px;\n    padding: 6px;\n    font-size: 14px;\n  }\n  button {\n    padding: 6px 12px;\n    margin-left: 10px;\n    font-size: 14px;\n    cursor: pointer;\n  }\n  button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n  }\n  #heapType {\n    margin-left: 10px;\n    font-weight: bold;\n  }\n  .heap-array {\n    margin-top: 10px;\n    font-family: monospace;\n    white-space: pre-wrap;\n    word-wrap: break-word;\n    background: #f0f0f0;\n    padding: 10px;\n    border-radius: 5px;\n  }\n  #log {\n    margin-top: 20px;\n    background: #222;\n    color: #eee;\n    border-radius: 5px;\n    max-height: 250px;\n    overflow-y: auto;\n    padding: 10px;\n    font-family: monospace;\n    font-size: 13px;\n  }\n  .highlight {\n    color: #e67e22;\n    font-weight: bold;\n  }\n  label {\n    font-weight: bold;\n  }\n  #switchBtn {\n    margin-left: 20px;\n    font-weight: bold;\n  }\n  footer {\n    margin-top: 40px;\n    font-size: 13px;\n    color: #666;\n    text-align: center;\n  }\n</style>\n</head>\n<body>\n<h1>Heap (Min/Max) Demo</h1>\n<p>This demo shows a binary heap data structure supporting both Min Heap and Max Heap operations. You can insert numbers, extract top (min or max), and see the heap as an array and as a tree visualization.</p>\n\n<div id=\"controls\">\n  <label for=\"numInput\">Number:</label>\n  <input type=\"number\" id=\"numInput\" />\n  <button id=\"insertBtn\">Insert</button>\n  <button id=\"extractBtn\">Extract Top</button>\n  <button id=\"clearBtn\">Clear</button>\n  <button id=\"switchBtn\">Switch to Max Heap</button>\n  <span id=\"heapType\">Current: Min Heap</span>\n</div>\n\n<h2>Heap Array Representation</h2>\n<div id=\"heapArray\" class=\"heap-array\">(empty)</div>\n\n<h2>Heap Tree Visualization</h2>\n<svg id=\"heapSVG\" width=\"100%\" height=\"300\" style=\"border:1px solid #ccc; background:#fafafa;\"></svg>\n\n<h2>Operations Log</h2>\n<div id=\"log\"></div>\n\n<script>\n(() => {\n  // Heap class supporting min or max heap\n  class Heap {\n    constructor(isMinHeap = true) {\n      this.data = [];\n      this.isMinHeap = isMinHeap;\n    }\n    compare(a, b) {\n      // For min heap: a < b; for max heap: a > b\n      return this.isMinHeap ? a < b : a > b;\n    }\n    insert(value) {\n      this.data.push(value);\n      this.bubbleUp(this.data.length - 1);\n    }\n    bubbleUp(index) {\n      while(index > 0) {\n        let parentIndex = Math.floor((index - 1) / 2);\n        if(this.compare(this.data[index], this.data[parentIndex])) {\n          this.swap(index, parentIndex);\n          index = parentIndex;\n        } else break;\n      }\n    }\n    extractTop() {\n      if(this.data.length === 0) return null;\n      if(this.data.length === 1) return this.data.pop();\n      const topValue = this.data[0];\n      this.data[0] = this.data.pop();\n      this.bubbleDown(0);\n      return topValue;\n    }\n    bubbleDown(index) {\n      const length = this.data.length;\n      while(true) {\n        let left = 2 * index + 1;\n        let right = 2 * index + 2;\n        let swapIndex = index;\n\n        if(left < length && this.compare(this.data[left], this.data[swapIndex])) {\n          swapIndex = left;\n        }\n        if(right < length && this.compare(this.data[right], this.data[swapIndex])) {\n          swapIndex = right;\n        }\n        if(swapIndex !== index) {\n          this.swap(index, swapIndex);\n          index = swapIndex;\n        } else break;\n      }\n    }\n    swap(i, j) {\n      const temp = this.data[i];\n      this.data[i] = this.data[j];\n      this.data[j] = temp;\n    }\n    clear() {\n      this.data = [];\n    }\n    size() {\n      return this.data.length;\n    }\n    getTop() {\n      return this.data.length > 0 ? this.data[0] : null;\n    }\n  }\n\n  // DOM Elements\n  const numInput = document.getElementById('numInput');\n  const insertBtn = document.getElementById('insertBtn');\n  const extractBtn = document.getElementById('extractBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const switchBtn = document.getElementById('switchBtn');\n  const heapTypeSpan = document.getElementById('heapType');\n  const heapArrayDiv = document.getElementById('heapArray');\n  const logDiv = document.getElementById('log');\n  const heapSVG = document.getElementById('heapSVG');\n\n  // Initialize min heap\n  let isMinHeap = true;\n  const heap = new Heap(isMinHeap);\n\n  function log(msg) {\n    const time = new Date().toLocaleTimeString();\n    const entry = document.createElement('div');\n    entry.textContent = `[${time}] ${msg}`;\n    logDiv.prepend(entry);\n  }\n\n  function validateInput() {\n    // Enable insert only if number entered\n    const val = numInput.value.trim();\n    insertBtn.disabled = val === '' || isNaN(Number(val));\n  }\n\n  function updateHeapArray() {\n    if(heap.size() === 0) {\n      heapArrayDiv.textContent = '(empty)';\n    } else {\n      // Show array as [v0, v1, v2, ...]\n      heapArrayDiv.textContent = '[ ' + heap.data.join(', ') + ' ]';\n    }\n  }\n\n  // Visualization parameters\n  const nodeRadius = 20;\n  const verticalSpacing = 70;\n  const horizontalSpacing = 40;\n\n  function clearSVG() {\n    while (heapSVG.firstChild) {\n      heapSVG.removeChild(heapSVG.firstChild);\n    }\n  }\n\n  function drawLine(x1, y1, x2, y2) {\n    const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n    line.setAttribute('x1', x1);\n    line.setAttribute('y1', y1);\n    line.setAttribute('x2', x2);\n    line.setAttribute('y2', y2);\n    line.setAttribute('stroke', '#555');\n    line.setAttribute('stroke-width', '2');\n    heapSVG.appendChild(line);\n  }\n\n  function drawNode(x, y, value) {\n    const svgNS = \"http://www.w3.org/2000/svg\";\n\n    const circle = document.createElementNS(svgNS, 'circle');\n    circle.setAttribute('cx', x);\n    circle.setAttribute('cy', y);\n    circle.setAttribute('r', nodeRadius);\n    circle.setAttribute('fill', '#3498db');\n    circle.setAttribute('stroke', '#2980b9');\n    circle.setAttribute('stroke-width', '2');\n    heapSVG.appendChild(circle);\n\n    const text = document.createElementNS(svgNS, 'text');\n    text.setAttribute('x', x);\n    text.setAttribute('y', y + 5);\n    text.setAttribute('text-anchor', 'middle');\n    text.setAttribute('font-size', '16px');\n    text.setAttribute('fill', 'white');\n    text.style.userSelect = 'none';\n    text.textContent = value;\n    heapSVG.appendChild(text);\n  }\n\n  // Calculate x position for each node based on index and depth\n  // Using a simple approach: positions in levels with spacing\n  // Width is dynamically set based on level's max nodes\n  function getNodePositions(arr) {\n    if(arr.length === 0) return [];\n    // Calculate depth levels\n    const depth = Math.floor(Math.log2(arr.length)) + 1;\n    // Positions array holds {x,y} for each index\n    let positions = [];\n\n    // For each node at index i:\n    // level = floor(log2(i+1))\n    // indexWithinLevel = i - (2^level - 1)\n    for(let i = 0; i < arr.length; i++) {\n      const level = Math.floor(Math.log2(i+1));\n      const maxNodesLevel = Math.pow(2, level);\n      const indexInLevel = i - (maxNodesLevel - 1);\n      // Calculate width available for this level:\n      // total width = heapSVG.clientWidth or 100% assumed 800 here for base\n      // For stable visualization, fix width to 800 or dynamically\n      const svgWidth = heapSVG.clientWidth || 800;\n      const spacing = svgWidth / (maxNodesLevel + 1);\n      const x = spacing * (indexInLevel + 1);\n      const y = verticalSpacing * (level + 1);\n      positions.push({x, y});\n    }\n    return positions;\n  }\n\n  function drawHeapTree() {\n    clearSVG();\n\n    if(heap.size() === 0) return;\n\n    const positions = getNodePositions(heap.data);\n\n    // Draw lines first\n    for(let i = 0; i < heap.data.length; i++) {\n      const leftChildIndex = 2 * i + 1;\n      const rightChildIndex = 2 * i + 2;\n      const pos = positions[i];\n      if(leftChildIndex < heap.data.length) {\n        const leftPos = positions[leftChildIndex];\n        drawLine(pos.x, pos.y + nodeRadius, leftPos.x, leftPos.y - nodeRadius);\n      }\n      if(rightChildIndex < heap.data.length) {\n        const rightPos = positions[rightChildIndex];\n        drawLine(pos.x, pos.y + nodeRadius, rightPos.x, rightPos.y - nodeRadius);\n      }\n    }\n\n    // Draw nodes on top\n    for(let i = 0; i < heap.data.length; i++) {\n      drawNode(positions[i].x, positions[i].y, heap.data[i]);\n    }\n  }\n\n  function updateUI() {\n    updateHeapArray();\n    drawHeapTree();\n    validateInput();\n    extractBtn.disabled = heap.size() === 0;\n  }\n\n  insertBtn.addEventListener('click', () => {\n    const val = Number(numInput.value);\n    if(isNaN(val)) return;\n    heap.insert(val);\n    log(`Inserted ${val}`);\n    numInput.value = '';\n    updateUI();\n  });\n\n  extractBtn.addEventListener('click', () => {\n    const top = heap.extractTop();\n    if(top !== null) {\n      log(`Extracted top value: ${top}`);\n    } else {\n      log('Heap empty: nothing to extract');\n    }\n    updateUI();\n  });\n\n  clearBtn.addEventListener('click', () => {\n    heap.clear();\n    log('Heap cleared');\n    updateUI();\n  });\n\n  switchBtn.addEventListener('click', () => {\n    isMinHeap = !isMinHeap;\n    heap.isMinHeap = isMinHeap;\n    // Rebuild heap to satisfy new heap property:\n    // Quick way: extract all data, then reinsert in new heap mode\n    const oldData = heap.data.slice();\n    heap.clear();\n    for(const v of oldData) {\n      heap.insert(v);\n    }\n    heapTypeSpan.textContent = `Current: ${isMinHeap ? 'Min Heap' : 'Max Heap'}`;\n    switchBtn.textContent = isMinHeap ? 'Switch to Max Heap' : 'Switch to Min Heap';\n    log(`Switched to ${isMinHeap ? 'Min Heap' : 'Max Heap'}`);\n    updateUI();\n  });\n\n  numInput.addEventListener('input', validateInput);\n  validateInput();\n  updateUI();\n\n})();\n</script>\n<footer>Heap Demo by ChatGPT | Min Heap orders smallest to top; Max Heap orders biggest to top</footer>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap (Min/Max)"
    }
  ],
  "topic": "Heap (Min/Max)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}