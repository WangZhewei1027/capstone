{
  "id": "92fea6d1-ca67-11f0-a3d6-179b5eb5e89b",
  "timestamp": "2025-11-26T01:32:18.403Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Breadth-First Search (BFS) Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  #graph {\n    display: grid;\n    grid-template-columns: repeat(10, 40px);\n    grid-gap: 5px;\n    margin-bottom: 10px;\n  }\n  .node {\n    width: 40px;\n    height: 40px;\n    background-color: #ddd;\n    border-radius: 6px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-weight: bold;\n    cursor: pointer;\n    user-select: none;\n    position: relative;\n  }\n  .node.wall {\n    background-color: #222;\n    cursor: default;\n  }\n  .node.start {\n    background-color: #4CAF50;\n    color: white;\n  }\n  .node.target {\n    background-color: #f44336;\n    color: white;\n  }\n  .node.visited {\n    background-color: #2196F3;\n    color: white;\n    animation: visitfade 0.5s ease forwards;\n  }\n  .node.path {\n    background-color: #ffeb3b;\n    color: black;\n  }\n  @keyframes visitfade {\n    from { background-color: #90caf9; }\n    to { background-color: #2196F3; }\n  }\n  #controls {\n    margin-bottom: 15px;\n  }\n  button {\n    margin-right: 5px;\n    padding: 6px 12px;\n    font-size: 15px;\n  }\n  #info {\n    margin-top: 10px;\n    font-size: 14px;\n  }\n  small {\n    color: #555;\n  }\n</style>\n</head>\n<body>\n\n<h2>Breadth-First Search (BFS) Visualization</h2>\n<p>\n  Click grid cells to toggle walls. <br />\n  Click <strong>Set Start</strong> then a cell to pick start node (green), <strong>Set Target</strong> then a cell to pick target node (red).<br />\n  Press <strong>Run BFS</strong> to find shortest path.<br />\n  <small>Blue: visited nodes, Yellow: shortest path</small>\n</p>\n\n<div id=\"controls\">\n  <button id=\"setStartBtn\">Set Start</button>\n  <button id=\"setTargetBtn\">Set Target</button>\n  <button id=\"toggleWallBtn\">Toggle Walls</button>\n  <button id=\"runBFSBtn\">Run BFS</button>\n  <button id=\"clearBtn\">Clear</button>\n</div>\n\n<div id=\"graph\" aria-label=\"Grid graph for BFS visualization\" role=\"grid\" tabindex=\"0\"></div>\n\n<div id=\"info\" aria-live=\"polite\"></div>\n\n<script>\n(() => {\n  const rows = 10;\n  const cols = 10;\n  const graphEl = document.getElementById('graph');\n  const infoEl = document.getElementById('info');\n  const setStartBtn = document.getElementById('setStartBtn');\n  const setTargetBtn = document.getElementById('setTargetBtn');\n  const toggleWallBtn = document.getElementById('toggleWallBtn');\n  const runBFSBtn = document.getElementById('runBFSBtn');\n  const clearBtn = document.getElementById('clearBtn');\n\n  let mode = 'toggleWall'; // modes: toggleWall, setStart, setTarget\n  let startNode = null;\n  let targetNode = null;\n  let grid = [];\n  let isRunning = false;\n\n  // Node object constructor\n  function createNode(r, c) {\n    return {\n      row: r,\n      col: c,\n      isWall: false,\n      visited: false,\n      prev: null,\n      element: null,\n    };\n  }\n\n  // Initialize grid and DOM\n  function initGrid() {\n    graphEl.innerHTML = '';\n    grid = [];\n    for(let r=0; r<rows; r++) {\n      const row = [];\n      for(let c=0; c<cols; c++) {\n        const node = createNode(r,c);\n        const div = document.createElement('div');\n        div.classList.add('node');\n        div.setAttribute('role', 'gridcell');\n        div.setAttribute('aria-label', `Node ${r},${c}`);\n        div.tabIndex = 0;\n        div.textContent = '';\n        div.addEventListener('click', () => onNodeClick(node));\n        div.addEventListener('keydown', (e) => {\n          if(e.key === 'Enter' || e.key === ' ') {\n            e.preventDefault();\n            onNodeClick(node);\n          }\n        });\n        graphEl.appendChild(div);\n        node.element = div;\n        row.push(node);\n      }\n      grid.push(row);\n    }\n    startNode = null;\n    targetNode = null;\n    isRunning = false;\n    infoEl.textContent = '';\n  }\n\n  // Handle node click depending on mode\n  function onNodeClick(node) {\n    if(isRunning) return;\n\n    if(mode === 'toggleWall') {\n      if(node === startNode || node === targetNode) return;\n      node.isWall = !node.isWall;\n      node.element.classList.toggle('wall', node.isWall);\n    } else if(mode === 'setStart') {\n      if(node.isWall || node === targetNode) return;\n      if(startNode) startNode.element.classList.remove('start');\n      startNode = node;\n      node.element.classList.add('start');\n      node.isWall = false;\n      node.element.classList.remove('wall');\n      mode = 'toggleWall';\n      highlightCurrentMode();\n    } else if(mode === 'setTarget') {\n      if(node.isWall || node === startNode) return;\n      if(targetNode) targetNode.element.classList.remove('target');\n      targetNode = node;\n      node.element.classList.add('target');\n      node.isWall = false;\n      node.element.classList.remove('wall');\n      mode = 'toggleWall';\n      highlightCurrentMode();\n    }\n  }\n\n  function highlightCurrentMode() {\n    setStartBtn.disabled = (mode === 'setStart');\n    setTargetBtn.disabled = (mode === 'setTarget');\n    toggleWallBtn.disabled = (mode === 'toggleWall');\n  }\n\n  setStartBtn.addEventListener('click', () => {\n    if(isRunning) return;\n    mode = 'setStart';\n    highlightCurrentMode();\n  });\n  setTargetBtn.addEventListener('click', () => {\n    if(isRunning) return;\n    mode = 'setTarget';\n    highlightCurrentMode();\n  });\n  toggleWallBtn.addEventListener('click', () => {\n    if(isRunning) return;\n    mode = 'toggleWall';\n    highlightCurrentMode();\n  });\n  clearBtn.addEventListener('click', () => {\n    if(isRunning) return;\n    initGrid();\n    mode = 'toggleWall';\n    highlightCurrentMode();\n  });\n\n  function neighbors(node) {\n    const deltas = [\n      [-1, 0],\n      [1, 0],\n      [0, -1],\n      [0, 1],\n    ];\n    let result = [];\n    for (const [dr, dc] of deltas) {\n      const nr = node.row + dr;\n      const nc = node.col + dc;\n      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\n        if (!grid[nr][nc].isWall) result.push(grid[nr][nc]);\n      }\n    }\n    return result;\n  }\n\n  async function runBFS() {\n    if(isRunning) return;\n    if(!startNode || !targetNode) {\n      infoEl.textContent = 'Please set both start and target nodes.';\n      return;\n    }\n\n    // Reset previous states\n    for(let r=0; r<rows; r++) {\n      for(let c=0; c<cols; c++) {\n        const node = grid[r][c];\n        node.visited = false;\n        node.prev = null;\n        if(node !== startNode && node !== targetNode && !node.isWall) {\n          node.element.classList.remove('visited', 'path');\n          node.element.textContent = '';\n        }\n      }\n    }\n\n    infoEl.textContent = 'Searching...';\n    isRunning = true;\n\n    let queue = [];\n    startNode.visited = true;\n    queue.push(startNode);\n\n    while(queue.length > 0) {\n      const current = queue.shift();\n\n      // Visualize visiting\n      if(current !== startNode && current !== targetNode) {\n        current.element.classList.add('visited');\n        current.element.textContent = '';\n        await delay(50);\n      }\n\n      if(current === targetNode) {\n        // Reconstruct path\n        let pathNode = targetNode;\n        let length = 0;\n        while(pathNode.prev && pathNode !== startNode) {\n          pathNode = pathNode.prev;\n          if(pathNode !== startNode) {\n            pathNode.element.classList.remove('visited');\n            pathNode.element.classList.add('path');\n            pathNode.element.textContent = '';\n          }\n          length++;\n        }\n        infoEl.textContent = `Target found! Shortest path length: ${length}`;\n        isRunning = false;\n        return;\n      }\n\n      for (const neighbor of neighbors(current)) {\n        if(!neighbor.visited) {\n          neighbor.visited = true;\n          neighbor.prev = current;\n          queue.push(neighbor);\n        }\n      }\n    }\n    infoEl.textContent = 'Target not reachable.';\n    isRunning = false;\n  }\n\n  function delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  runBFSBtn.addEventListener('click', runBFS);\n\n  // Initialize on load\n  initGrid();\n  highlightCurrentMode();\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}