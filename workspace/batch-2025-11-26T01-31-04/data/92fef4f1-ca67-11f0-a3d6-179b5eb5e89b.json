{
  "id": "92fef4f1-ca67-11f0-a3d6-179b5eb5e89b",
  "timestamp": "2025-11-26T01:32:26.581Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Prim's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    background: #f5f7fa;\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n  }\n  header {\n    background: #2a9df4;\n    color: white;\n    padding: 1rem;\n    text-align: center;\n  }\n  #container {\n    flex: 1;\n    display: flex;\n    flex-direction: row;\n    overflow: hidden;\n  }\n  #graph-container {\n    flex: 2;\n    border-right: 1px solid #ddd;\n    position: relative;\n    background: #ffffff;\n  }\n  canvas {\n    display: block;\n    margin: 0 auto;\n    background: #fff;\n  }\n  #controls {\n    flex: 1;\n    padding: 1rem;\n    overflow-y: auto;\n  }\n  h2 {\n    margin-top: 0;\n  }\n  label, button, select, input {\n    font-size: 1rem;\n    margin: 0.5rem 0;\n  }\n  #edgesList {\n    height: 120px;\n    width: 100%;\n    font-family: monospace;\n  }\n  #log {\n    background: #222;\n    color: #eee;\n    font-family: monospace;\n    height: 150px;\n    overflow-y: auto;\n    padding: 0.5rem;\n    white-space: pre-wrap;\n    border-radius: 5px;\n    margin-top: 1rem;\n  }\n  button {\n    cursor: pointer;\n    background-color: #2a9df4;\n    border: none;\n    color: white;\n    padding: 0.5rem 1rem;\n    border-radius: 5px;\n    transition: background-color 0.25s ease;\n  }\n  button:hover:not(:disabled) {\n    background-color: #1682e0;\n  }\n  button:disabled {\n    background-color: #aaa;\n    cursor: default;\n  }\n  small {\n    color: #555;\n  }\n  .step-highlight {\n    fill: #ff9933 !important;\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Prim's Algorithm Visualization</h1>\n  <p>Build Minimum Spanning Tree step-by-step</p>\n</header>\n\n<div id=\"container\">\n  <div id=\"graph-container\">\n    <canvas id=\"graphCanvas\" width=\"700\" height=\"600\"></canvas>\n  </div>\n  <div id=\"controls\">\n    <h2>Graph Input</h2>\n    <p>Enter edges as: <em>node1 node2 weight</em> per line (node names can be letters or numbers)</p>\n    <textarea id=\"edgesList\" placeholder=\"A B 4\nA C 3\nB C 1\nB D 2\nC D 4\nD E 2\nE F 6\nF C 5\"></textarea>\n    <br/>\n    <label for=\"startNode\">Start Node: </label> \n    <input type=\"text\" id=\"startNode\" size=\"3\" value=\"A\" />\n    <br/>\n    <button id=\"loadGraphBtn\">Load Graph</button>\n    <hr/>\n    <h2>Controls</h2>\n    <button id=\"stepBtn\" disabled>Next Step</button>\n    <button id=\"runBtn\" disabled>Run Automatically</button>\n    <button id=\"resetBtn\" disabled>Reset</button>\n    <br/>\n    <br/>\n    <small><b>Legend:</b></small><br/>\n    <svg width=\"200\" height=\"60\" style=\"background:#f9f9f9; border:1px solid #ddd;\">\n      <circle cx=\"20\" cy=\"20\" r=\"12\" fill=\"#4a90e2\"/> <text x=\"40\" y=\"26\" font-size=\"14\" fill=\"#222\">Unvisited Node</text><br/>\n      <circle cx=\"20\" cy=\"45\" r=\"12\" fill=\"#ff9933\"/> <text x=\"40\" y=\"50\" font-size=\"14\" fill=\"#222\">Node in MST</text><br/>\n      <line x1=\"10\" y1=\"70\" x2=\"60\" y2=\"70\" stroke=\"#bbb\" stroke-width=\"4\"/> <text x=\"70\" y=\"74\" font-size=\"14\" fill=\"#222\">Unselected Edge</text><br/>\n      <line x1=\"10\" y1=\"90\" x2=\"60\" y2=\"90\" stroke=\"#ff9933\" stroke-width=\"5\"/> <text x=\"70\" y=\"94\" font-size=\"14\" fill=\"#222\">Selected MST Edge</text>\n    </svg>\n    <h3>Steps Log</h3>\n    <div id=\"log\"></div>\n  </div>\n</div>\n\n<script>\n(() => {\n  /* \n    Prim's Algorithm Visualization Code\n  */\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n\n  const edgesListElem = document.getElementById('edgesList');\n  const startNodeElem = document.getElementById('startNode');\n  const loadGraphBtn = document.getElementById('loadGraphBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const runBtn = document.getElementById('runBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const logElem = document.getElementById('log');\n\n  // Graph structure\n  // nodes: { id: string, x: number, y: number, inMST: bool }\n  // edges: { id, node1, node2, weight, inMST }\n  let nodes = [];\n  let edges = [];\n\n  // Prim's specific state\n  let MSTset = new Set(); // nodes included in MST\n  let candidateEdges = []; // edges on the \"frontier\"\n  let stepQueue = []; // steps to perform\n\n  // For auto-run\n  let autoRunInterval = null;\n\n  // Canvas sizes\n  const WIDTH = canvas.width;\n  const HEIGHT = canvas.height;\n\n  // Node visuals\n  const NODE_RADIUS = 15;\n  const FONT = '14px Arial';\n\n  // Utility: log messages to log area with timestamp\n  function log(msg) {\n    const timestamp = new Date().toLocaleTimeString();\n    logElem.textContent += `[${timestamp}] ${msg}\\n`;\n    logElem.scrollTop = logElem.scrollHeight;\n  }\n\n  // Utility: clear log\n  function clearLog(){\n    logElem.textContent = '';\n  }\n\n  // Parse edges input text, return {nodesSet, edges}\n  function parseInput(text) {\n    const lines = text.split('\\n').map(l => l.trim()).filter(l => l.length>0 && !l.startsWith('#'));\n    const nodesSet = new Set();\n    const edges = [];\n    let edgeId = 0;\n    for (const line of lines) {\n      // format: node1 node2 weight\n      const parts = line.split(/\\s+/);\n      if(parts.length !== 3) continue;\n      const [n1, n2, wStr] = parts;\n      const weight = Number(wStr);\n      if(isNaN(weight) || weight <= 0) continue;\n      nodesSet.add(n1);\n      nodesSet.add(n2);\n      edges.push({id: edgeId++, node1: n1, node2: n2, weight: weight, inMST: false});\n    }\n    return {nodesSet, edges};\n  }\n\n  // Position nodes evenly in a circle for visualization\n  function positionNodes(nodesArr) {\n    let centerX = WIDTH/2;\n    let centerY = HEIGHT/2;\n    let radius = Math.min(WIDTH, HEIGHT)/2 - 60;\n    const count = nodesArr.length;\n    for(let i=0; i<count; i++){\n      const angle = (2 * Math.PI * i) / count - Math.PI/2;\n      nodesArr[i].x = centerX + radius * Math.cos(angle);\n      nodesArr[i].y = centerY + radius * Math.sin(angle);\n    }\n  }\n\n  // Build adjacency list for graph: node => [{node, weight, edgeId}]\n  function buildAdjacencyList(nodesArr, edgesArr) {\n    const adj = {};\n    for(const n of nodesArr) adj[n.id] = [];\n    for(const e of edgesArr) {\n      adj[e.node1].push({node: e.node2, weight: e.weight, edgeId: e.id});\n      adj[e.node2].push({node: e.node1, weight: e.weight, edgeId: e.id});\n    }\n    return adj;\n  }\n\n  // Draw the entire graph and MST state\n  function drawGraph() {\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Draw edges\n    for(const e of edges){\n      const n1 = nodes.find(n => n.id === e.node1);\n      const n2 = nodes.find(n => n.id === e.node2);\n      ctx.beginPath();\n      ctx.moveTo(n1.x, n1.y);\n      ctx.lineTo(n2.x, n2.y);\n      ctx.strokeStyle = e.inMST ? '#ff9933' : '#bbb';\n      ctx.lineWidth = e.inMST ? 5 : 3;\n      ctx.shadowColor = 'transparent';\n      ctx.stroke();\n\n      // Draw weight label midpoint\n      const midX = (n1.x + n2.x) / 2;\n      const midY = (n1.y + n2.y) / 2;\n      ctx.fillStyle = '#222';\n      ctx.font = '12px Arial';\n      ctx.fillText(e.weight, midX + 5, midY - 5);\n    }\n\n    // Draw nodes\n    for(const n of nodes) {\n      ctx.beginPath();\n      ctx.arc(n.x, n.y, NODE_RADIUS, 0, 2 * Math.PI);\n      ctx.fillStyle = n.inMST ? '#ff9933' : '#4a90e2';\n      ctx.shadowColor = 'rgba(0,0,0,0.3)';\n      ctx.shadowBlur = 6;\n      ctx.fill();\n      ctx.shadowBlur = 0;\n\n      ctx.strokeStyle = '#222';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n\n      // Node ID decoration\n      ctx.fillStyle = '#fff';\n      ctx.font = 'bold 14px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(n.id, n.x, n.y);\n    }\n  }\n\n  // Prim's algorithm generator function for step-by-step\n  function* primGenerator(adj, start) {\n    let mstSet = new Set();\n    let edgesSet = new Set(); // edges in MST\n    let edgeCandidates = [];\n\n    mstSet.add(start);\n    log(`Starting Prim's Algorithm at node '${start}'`);\n    // Yield initial state\n    yield {mstNodes: new Set(mstSet), mstEdges: new Set(edgesSet), stepDesc: `Start at node ${start}`};\n\n    // Initialize edge candidates from start node\n    for(const nei of adj[start]){\n      edgeCandidates.push({from: start, to: nei.node, weight: nei.weight, edgeId: nei.edgeId});\n    }\n    // Sort edges by weight ascending\n    edgeCandidates.sort((a,b)=>a.weight-b.weight);\n\n    while(mstSet.size < nodes.length) {\n      // Pick min weight edge with to-node not in mstSet\n      let chosenEdgeIndex = -1;\n      for(let i=0; i<edgeCandidates.length; i++) {\n        if(!mstSet.has(edgeCandidates[i].to)) {\n          chosenEdgeIndex = i;\n          break;\n        }\n      }\n      if(chosenEdgeIndex === -1) {\n        // No connecting edges left - disconnected graph\n        log(\"Graph is disconnected. MST can't include all nodes.\");\n        yield {mstNodes: new Set(mstSet), mstEdges: new Set(edgesSet), stepDesc: \"No connecting edges remain. Algorithm finished early.\"};\n        return;\n      }\n      let chosenEdge = edgeCandidates.splice(chosenEdgeIndex, 1)[0];\n\n      // Add chosen node to MST\n      mstSet.add(chosenEdge.to);\n      edgesSet.add(chosenEdge.edgeId);\n      log(`Add edge (${chosenEdge.from} - ${chosenEdge.to}) with weight ${chosenEdge.weight} to MST.`);\n\n      yield {mstNodes: new Set(mstSet), mstEdges: new Set(edgesSet), stepDesc: `Selected edge (${chosenEdge.from} - ${chosenEdge.to}) weight=${chosenEdge.weight}`};\n\n      // Add new edges to candidate list\n      for(const nei of adj[chosenEdge.to]) {\n        if(!mstSet.has(nei.node)){\n          edgeCandidates.push({from: chosenEdge.to, to: nei.node, weight: nei.weight, edgeId: nei.edgeId});\n        }\n      }\n      // Sort again to keep smallest weights first\n      edgeCandidates.sort((a,b)=>a.weight-b.weight);\n    }\n\n    log(\"Prim's algorithm complete. MST spans all nodes.\");\n    yield {mstNodes: new Set(mstSet), mstEdges: new Set(edgesSet), stepDesc: \"Algorithm complete. MST formed.\"};\n  }\n\n  // Update nodes and edges inMST based on sets\n  function updateMSTStates(mstNodesSet, mstEdgesSet) {\n    for(const n of nodes){\n      n.inMST = mstNodesSet.has(n.id);\n    }\n    for(const e of edges){\n      e.inMST = mstEdgesSet.has(e.id);\n    }\n  }\n\n  // Draw current step's state and show step description\n  function renderStep(state){\n    updateMSTStates(state.mstNodes, state.mstEdges);\n    drawGraph();\n    logElem.textContent += `STEP: ${state.stepDesc}\\n\\n`;\n    logElem.scrollTop = logElem.scrollHeight;\n  }\n\n\n  // Global prim generator & current step\n  let primGen = null;\n\n  // Button handlers\n\n  loadGraphBtn.addEventListener('click', () => {\n    clearLog();\n    let input = edgesListElem.value.trim();\n    if(!input){\n      alert('Please enter edges.');\n      return;\n    }\n    let startNode = startNodeElem.value.trim();\n    if(!startNode){\n      alert('Please enter a start node.');\n      return;\n    }\n    const {nodesSet, edges: parsedEdges} = parseInput(input);\n    if(!nodesSet.has(startNode)) {\n      alert(`Start node '${startNode}' not found in edges.`);\n      return;\n    }\n    // Reset global variables\n    nodes = [...nodesSet].map(id => ({id, x:0, y:0, inMST: false}));\n    edges = parsedEdges;\n    positionNodes(nodes);\n\n    drawGraph();\n\n    const adj = buildAdjacencyList(nodes, edges);\n\n    primGen = primGenerator(adj, startNode);\n\n    stepBtn.disabled = false;\n    runBtn.disabled = false;\n    resetBtn.disabled = false;\n    loadGraphBtn.disabled = true;\n    startNodeElem.disabled = true;\n    edgesListElem.disabled = true;\n\n    clearLog();\n    log(`Graph loaded with ${nodes.length} nodes and ${edges.length} edges.`);\n    log(`Start node set to '${startNode}'.`);\n    log(`Press 'Next Step' to proceed.`);\n  });\n\n  stepBtn.addEventListener('click', () => {\n    const next = primGen.next();\n    if(next.done){\n      stepBtn.disabled = true;\n      runBtn.disabled = true;\n      log('Algorithm finished. No more steps.');\n      return;\n    }\n    renderStep(next.value);\n  });\n\n  runBtn.addEventListener('click', () => {\n    stepBtn.disabled = true;\n    runBtn.disabled = true;\n    resetBtn.disabled = true;\n    loadGraphBtn.disabled = true;\n    startNodeElem.disabled = true;\n    edgesListElem.disabled = true;\n\n    log('Running automatically with 1 sec delay per step...');\n    autoRunInterval = setInterval(() => {\n      const next = primGen.next();\n      if(next.done) {\n        clearInterval(autoRunInterval);\n        autoRunInterval = null;\n        stepBtn.disabled = true;\n        runBtn.disabled = true;\n        resetBtn.disabled = false;\n        loadGraphBtn.disabled = true;\n        startNodeElem.disabled = true;\n        edgesListElem.disabled = true;\n        log('Algorithm finished automatically.');\n        return;\n      }\n      renderStep(next.value);\n    }, 1000);\n  });\n\n  resetBtn.addEventListener('click', () => {\n    if(autoRunInterval){\n      clearInterval(autoRunInterval);\n      autoRunInterval = null;\n    }\n    nodes = [];\n    edges = [];\n    primGen = null;\n    clearLog();\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    stepBtn.disabled = true;\n    runBtn.disabled = true;\n    resetBtn.disabled = true;\n    loadGraphBtn.disabled = false;\n    startNodeElem.disabled = false;\n    edgesListElem.disabled = false;\n  });\n\n  // Initial draw\n  ctx.fillStyle = '#666';\n  ctx.font = '20px Arial';\n  ctx.textAlign = 'center';\n  ctx.fillText('Enter graph edges and press \"Load Graph\"', WIDTH/2, HEIGHT/2);\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}