{
  "id": "92fd2031-ca67-11f0-a3d6-179b5eb5e89b",
  "timestamp": "2025-11-26T01:32:50.288Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Hash Table",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Hash Table Demonstration</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    max-width: 700px;\n  }\n  h1 {\n    text-align: center;\n  }\n  .container {\n    margin-top: 20px;\n  }\n  label {\n    display: block;\n    margin-top: 10px;\n  }\n  input[type=\"text\"] {\n    width: 60%;\n    padding: 8px;\n    margin-top: 5px;\n  }\n  button {\n    margin-top: 10px;\n    padding: 8px 12px;\n    font-size: 1em;\n    cursor: pointer;\n  }\n  #hashTableDisplay {\n    margin-top: 30px;\n    border-collapse: collapse;\n    width: 100%;\n  }\n  #hashTableDisplay th, #hashTableDisplay td {\n    border: 1px solid #ccc;\n    padding: 8px;\n    text-align: left;\n  }\n  #hashTableDisplay th {\n    background-color: #f2f2f2;\n  }\n  .linked-list {\n    font-family: monospace;\n  }\n  small {\n    color: #666;\n  }\n  #message {\n    margin-top: 20px;\n    font-weight: bold;\n    color: #d9534f;\n  }\n  #success {\n    color: #5cb85c;\n  }\n  #legend {\n    margin-top: 30px;\n    font-size: 0.9em;\n    color: #555;\n  }\n</style>\n</head>\n<body>\n<h1>Hash Table Demonstration</h1>\n<p>This example shows a simple hash table using separate chaining to handle collisions. Keys and values are strings.</p>\n\n<div class=\"container\">\n  <label for=\"keyInput\">Key:</label>\n  <input type=\"text\" id=\"keyInput\" placeholder=\"Enter key\" />\n\n  <label for=\"valueInput\">Value:</label>\n  <input type=\"text\" id=\"valueInput\" placeholder=\"Enter value\" />\n\n  <button id=\"addBtn\">Add / Update</button>\n  <button id=\"removeBtn\">Remove by Key</button>\n  <button id=\"getBtn\">Get Value by Key</button>\n  <button id=\"clearBtn\">Clear Table</button>\n\n  <div id=\"message\" aria-live=\"polite\"></div>\n\n  <h2>Hash Table Internal Buckets</h2>\n  <table id=\"hashTableDisplay\" aria-label=\"Hash Table Buckets\">\n    <thead>\n      <tr>\n        <th>Bucket Index</th>\n        <th>Items (key → value)</th>\n      </tr>\n    </thead>\n    <tbody></tbody>\n  </table>\n\n  <div id=\"legend\">\n    <p><strong>Notes:</strong></p>\n    <ul>\n      <li>The hash function uses the sum of character codes mod the number of buckets.</li>\n      <li>Collisions are resolved by linked lists (separate chaining).</li>\n      <li>Keys are unique; adding the same key updates its value.</li>\n    </ul>\n  </div>\n</div>\n\n<script>\n  // Simple Hash Table implementation using separate chaining (linked lists)\n  class HashTable {\n    constructor(size = 10) {\n      this.size = size;\n      this.buckets = Array(size).fill(null).map(() => []);\n    }\n\n    // Simple hash function: sum of char codes modulo size\n    _hash(key) {\n      let hash = 0;\n      for (let char of key) {\n        hash += char.charCodeAt(0);\n      }\n      return hash % this.size;\n    }\n\n    // Add or update a key-value pair\n    set(key, value) {\n      const index = this._hash(key);\n      const bucket = this.buckets[index];\n      // Check if key exists, update\n      for (let pair of bucket) {\n        if (pair[0] === key) {\n          pair[1] = value;\n          return false; // false indicates updated existing key\n        }\n      }\n      bucket.push([key, value]);\n      return true; // true indicates new key added\n    }\n\n    // Get value by key\n    get(key) {\n      const index = this._hash(key);\n      const bucket = this.buckets[index];\n      for (let pair of bucket) {\n        if (pair[0] === key) {\n          return pair[1];\n        }\n      }\n      return undefined;\n    }\n\n    // Remove a key-value pair by key\n    remove(key) {\n      const index = this._hash(key);\n      const bucket = this.buckets[index];\n      const initialLength = bucket.length;\n      this.buckets[index] = bucket.filter(pair => pair[0] !== key);\n      return this.buckets[index].length !== initialLength;\n    }\n\n    // Clear the table\n    clear() {\n      this.buckets = Array(this.size).fill(null).map(() => []);\n    }\n  }\n\n  // Initialize\n  const hashTable = new HashTable(10);\n\n  // DOM Elements\n  const keyInput = document.getElementById(\"keyInput\");\n  const valueInput = document.getElementById(\"valueInput\");\n  const addBtn = document.getElementById(\"addBtn\");\n  const removeBtn = document.getElementById(\"removeBtn\");\n  const getBtn = document.getElementById(\"getBtn\");\n  const clearBtn = document.getElementById(\"clearBtn\");\n  const messageEl = document.getElementById(\"message\");\n  const tableBody = document.querySelector(\"#hashTableDisplay tbody\");\n\n  // Functions to update the display\n  function renderTable() {\n    tableBody.innerHTML = \"\";\n    hashTable.buckets.forEach((bucket, i) => {\n      const tr = document.createElement(\"tr\");\n      const indexTd = document.createElement(\"td\");\n      indexTd.textContent = i;\n      tr.appendChild(indexTd);\n\n      const itemsTd = document.createElement(\"td\");\n      if (bucket.length === 0) {\n        itemsTd.textContent = \"(empty)\";\n        itemsTd.style.fontStyle = \"italic\";\n        itemsTd.style.color = \"#999\";\n      } else {\n        const items = bucket.map(pair => `${pair[0]} → ${pair[1]}`).join(\"  →  \");\n        itemsTd.textContent = items;\n        itemsTd.className = \"linked-list\";\n      }\n      tr.appendChild(itemsTd);\n\n      tableBody.appendChild(tr);\n    });\n  }\n\n  function showMessage(text, isError = true) {\n    messageEl.textContent = text;\n    messageEl.style.color = isError ? \"#d9534f\" : \"#5cb85c\";\n  }\n\n  // Button event handlers\n  addBtn.addEventListener(\"click\", () => {\n    const key = keyInput.value.trim();\n    const value = valueInput.value.trim();\n    if (!key) {\n      showMessage(\"Error: Key cannot be empty.\");\n      return;\n    }\n    if (!value) {\n      showMessage(\"Error: Value cannot be empty.\");\n      return;\n    }\n    const addedNew = hashTable.set(key, value);\n    if (addedNew) {\n      showMessage(`Added key \"${key}\" with value \"${value}\".`, false);\n    } else {\n      showMessage(`Updated key \"${key}\" with new value \"${value}\".`, false);\n    }\n    renderTable();\n  });\n\n  removeBtn.addEventListener(\"click\", () => {\n    const key = keyInput.value.trim();\n    if (!key) {\n      showMessage(\"Error: Key cannot be empty.\");\n      return;\n    }\n    const removed = hashTable.remove(key);\n    if (removed) {\n      showMessage(`Removed key \"${key}\" from the hash table.`, false);\n    } else {\n      showMessage(`Key \"${key}\" not found in the hash table.`);\n    }\n    renderTable();\n  });\n\n  getBtn.addEventListener(\"click\", () => {\n    const key = keyInput.value.trim();\n    if (!key) {\n      showMessage(\"Error: Key cannot be empty.\");\n      return;\n    }\n    const value = hashTable.get(key);\n    if (value === undefined) {\n      showMessage(`Key \"${key}\" not found in the hash table.`);\n    } else {\n      showMessage(`Value for key \"${key}\": \"${value}\"`, false);\n    }\n  });\n\n  clearBtn.addEventListener(\"click\", () => {\n    hashTable.clear();\n    showMessage(\"Hash table cleared.\", false);\n    renderTable();\n  });\n\n  // Initial render\n  renderTable();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Hash Table"
    }
  ],
  "topic": "Hash Table",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}