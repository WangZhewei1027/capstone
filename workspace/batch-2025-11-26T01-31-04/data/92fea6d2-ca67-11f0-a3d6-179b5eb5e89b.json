{
  "id": "92fea6d2-ca67-11f0-a3d6-179b5eb5e89b",
  "timestamp": "2025-11-26T01:33:29.285Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Dijkstra's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    padding: 0;\n    background: #f0f2f5;\n  }\n  header {\n    background-color: #3949ab;\n    color: white;\n    padding: 15px 20px;\n    text-align: center;\n  }\n  #container {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n    padding: 15px;\n  }\n  #graph-canvas {\n    background: white;\n    border: 1px solid #ccc;\n    margin: 10px;\n    flex-grow: 1;\n    max-width: 700px;\n  }\n  #controls {\n    max-width: 300px;\n    background: white;\n    border: 1px solid #ccc;\n    margin: 10px;\n    padding: 15px;\n    border-radius: 5px;\n    height: fit-content;\n  }\n  #controls h2 {\n    margin-top: 0;\n  }\n  label {\n    display: block;\n    margin: 10px 0 5px 0;\n    font-weight: 600;\n  }\n  select, button {\n    width: 100%;\n    padding: 8px 10px;\n    font-size: 16px;\n    margin-bottom: 12px;\n    border-radius: 3px;\n    border: 1px solid #aaa;\n  }\n  button:disabled {\n    background-color: #ccc;\n  }\n  #log {\n    height: 220px;\n    overflow-y: auto;\n    background: #222;\n    color: #eee;\n    font-family: monospace;\n    font-size: 14px;\n    padding: 10px;\n    border-radius: 4px;\n    border: 1px solid #444;\n  }\n  #legend {\n    margin-top: 15px;\n    font-size: 14px;\n  }\n  #legend div {\n    margin-bottom: 6px;\n  }\n  .legend-color {\n    display: inline-block;\n    width: 14px;\n    height: 14px;\n    vertical-align: middle;\n    margin-right: 6px;\n    border: 1px solid #999;\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Dijkstra's Algorithm Visualization</h1>\n  <p>Click \"Next Step\" to advance the algorithm step-by-step.</p>\n</header>\n<div id=\"container\">\n  <canvas id=\"graph-canvas\" width=\"700\" height=\"500\"></canvas>\n  <div id=\"controls\">\n    <h2>Settings & Controls</h2>\n    <label for=\"start-node\">Select Start Node:</label>\n    <select id=\"start-node\"></select>\n    <label for=\"end-node\">Select End Node (optional):</label>\n    <select id=\"end-node\">\n      <option value=\"\">None (Find all shortest distances)</option>\n    </select>\n    <button id=\"reset-btn\">Reset Graph</button>\n    <button id=\"next-step-btn\" disabled>Next Step</button>\n    <button id=\"auto-run-btn\" disabled>Auto Run</button>\n    <button id=\"stop-auto-btn\" style=\"display:none;\">Stop Auto Run</button>\n    <div id=\"legend\">\n      <div><span class=\"legend-color\" style=\"background:#3949ab;\"></span> Untouched node</div>\n      <div><span class=\"legend-color\" style=\"background:#ffa726;\"></span> Visited node (current)</div>\n      <div><span class=\"legend-color\" style=\"background:#66bb6a;\"></span> Finalized node (shortest distance found)</div>\n      <div><span class=\"legend-color\" style=\"background:#e53935;\"></span> Node on shortest path (if end node selected)</div>\n      <div><span class=\"legend-color\" style=\"background:#ccc;\"></span> Edge</div>\n      <div><span class=\"legend-color\" style=\"background:#fbc02d;\"></span> Current edge being relaxed</div>\n    </div>\n    <h3>Log:</h3>\n    <div id=\"log\"></div>\n  </div>\n</div>\n<script>\n(() => {\n  // Graph data structure: array of nodes, each with x,y coords and edges: {to, weight}\n  // We'll create a fixed sample graph for demo\n  const nodes = [\n    { id: 0, label: \"A\", x: 100, y: 100, edges: [ {to:1, weight:4}, {to:2, weight:1} ] },\n    { id: 1, label: \"B\", x: 300, y: 80, edges: [ {to:3, weight:1} ] },\n    { id: 2, label: \"C\", x: 150, y: 250, edges: [ {to:1, weight:2}, {to:3, weight:5}, {to:4, weight:8} ] },\n    { id: 3, label: \"D\", x: 450, y: 200, edges: [ {to:4, weight:3} ] },\n    { id: 4, label: \"E\", x: 600, y: 120, edges: [ ] },\n  ];\n\n  // Build adjacency map for quick access and undirected graph\n  // For visualization and Dijkstra, we'll treat as directed edges as given.\n  // But our demo graph will simulate a directed graph (typical for Dijkstra)\n  // We'll add reverse edges for undirected demo for simpler understanding\n  // but for this demo let's keep edges directed as defined.\n\n  // Globals\n  const canvas = document.getElementById(\"graph-canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const startSelect = document.getElementById(\"start-node\");\n  const endSelect = document.getElementById(\"end-node\");\n  const resetBtn = document.getElementById(\"reset-btn\");\n  const nextStepBtn = document.getElementById(\"next-step-btn\");\n  const autoRunBtn = document.getElementById(\"auto-run-btn\");\n  const stopAutoBtn = document.getElementById(\"stop-auto-btn\");\n  const logDiv = document.getElementById(\"log\");\n\n  // Algorithm state\n  let distances = [];\n  let previous = [];\n  let visited = new Set();\n  let pq = null; // Priority queue (min-heap)\n  let stepIterator = null;\n  let currentNode = null;\n  let currentEdgeIndex = null;\n  let autoRunInterval = null;\n\n  // Colors\n  const COLORS = {\n    nodeDefault: \"#3949ab\",\n    nodeVisited: \"#ffa726\",\n    nodeFinalized: \"#66bb6a\",\n    nodePath: \"#e53935\",\n    edgeDefault: \"#ccc\",\n    edgeRelaxing: \"#fbc02d\",\n    text: \"#222\",\n    bg: \"#f0f2f5\",\n    logBg: \"#222\",\n    logText: \"#eee\"\n  };\n\n  // Initialize selection options\n  function populateNodeOptions() {\n    startSelect.innerHTML = \"\";\n    endSelect.innerHTML = '<option value=\"\">None (Find all shortest distances)</option>';\n\n    nodes.forEach(n => {\n      const opt1 = document.createElement(\"option\");\n      opt1.value = n.id;\n      opt1.textContent = n.label;\n      startSelect.appendChild(opt1);\n\n      const opt2 = document.createElement(\"option\");\n      opt2.value = n.id;\n      opt2.textContent = n.label;\n      endSelect.appendChild(opt2);\n    });\n\n    startSelect.selectedIndex = 0;\n    endSelect.selectedIndex = 0;\n  }\n\n  // Priority Queue class (min-heap) for Dijkstra\n  class PriorityQueue {\n    constructor() {\n      this.heap = [];\n    }\n    push(item, priority) {\n      this.heap.push({item, priority});\n      this._bubbleUp(this.heap.length - 1);\n    }\n    pop() {\n      if(this.heap.length === 0) return null;\n      const top = this.heap[0];\n      const end = this.heap.pop();\n      if(this.heap.length > 0) {\n        this.heap[0] = end;\n        this._sinkDown(0);\n      }\n      return top.item;\n    }\n    _bubbleUp(n) {\n      const element = this.heap[n];\n      while(n > 0){\n        const parentN = Math.floor((n+1)/2)-1;\n        const parent = this.heap[parentN];\n        if(element.priority >= parent.priority) break;\n        this.heap[parentN] = element;\n        this.heap[n] = parent;\n        n = parentN;\n      }\n    }\n    _sinkDown(n) {\n      const length = this.heap.length;\n      const element = this.heap[n];\n      while(true){\n        let leftN = 2 * (n+1) - 1;\n        let rightN = leftN + 1;\n        let swap = null;\n        if(leftN < length){\n          const left = this.heap[leftN];\n          if(left.priority < element.priority) swap = leftN;\n        }\n        if(rightN < length){\n          const right = this.heap[rightN];\n          if(\n            (swap === null && right.priority < element.priority) ||\n            (swap !== null && right.priority < this.heap[swap].priority)\n          ) swap = rightN;\n        }\n        if(swap === null) break;\n        this.heap[n] = this.heap[swap];\n        this.heap[swap] = element;\n        n = swap;\n      }\n    }\n    size() {\n      return this.heap.length;\n    }\n  }\n\n  // Draw functions\n  function clearCanvas() {\n    ctx.fillStyle = COLORS.bg;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n  }\n\n  function drawArrow(fromX, fromY, toX, toY, color = COLORS.edgeDefault, width = 2) {\n    const headlen = 10; // length of head in pixels\n    const dx = toX - fromX;\n    const dy = toY - fromY;\n    const angle = Math.atan2(dy, dx);\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    ctx.lineWidth = width;\n\n    // Line\n    ctx.beginPath();\n    ctx.moveTo(fromX, fromY);\n    ctx.lineTo(toX, toY);\n    ctx.stroke();\n\n    // Arrowhead\n    ctx.beginPath();\n    ctx.moveTo(toX, toY);\n    ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));\n    ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function drawGraph(highlight = {}) {\n    // highlight example: {currentNode: id, finalized: Set, visited: Set, pathNodes:Set, relaxingEdge: {from,to}}\n\n    clearCanvas();\n\n    // Draw edges first\n    nodes.forEach(node => {\n      node.edges.forEach((edge, i) => {\n        let color = COLORS.edgeDefault;\n        if(highlight.relaxingEdge && highlight.relaxingEdge.from === node.id && highlight.relaxingEdge.to === edge.to) {\n          color = COLORS.edgeRelaxing;\n        }\n        drawArrow(node.x, node.y, nodes[edge.to].x, nodes[edge.to].y, color);\n        // Draw edge weight label near the middle\n        const midX = (node.x + nodes[edge.to].x) / 2;\n        const midY = (node.y + nodes[edge.to].y) / 2;\n        ctx.fillStyle = COLORS.text;\n        ctx.font = \"14px Arial\";\n        ctx.shadowColor = \"white\";\n        ctx.shadowBlur = 2;\n        ctx.fillText(edge.weight.toString(), midX + 5, midY + 5);\n        ctx.shadowBlur = 0;\n      });\n    });\n\n    // Draw nodes on top\n    nodes.forEach(node => {\n      let fillStyle = COLORS.nodeDefault;\n      if(highlight.pathNodes && highlight.pathNodes.has(node.id)) fillStyle = COLORS.nodePath;\n      else if(highlight.finalized && highlight.finalized.has(node.id)) fillStyle = COLORS.nodeFinalized;\n      else if(highlight.currentNode === node.id) fillStyle = COLORS.nodeVisited;\n\n      // Outer circle\n      ctx.beginPath();\n      ctx.fillStyle = fillStyle;\n      ctx.strokeStyle = \"#333\";\n      ctx.lineWidth = 2;\n      ctx.shadowColor = \"rgba(0,0,0,0.2)\";\n      ctx.shadowBlur = 6;\n      ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.shadowBlur = 0;\n      ctx.stroke();\n\n      // Node label (letter)\n      ctx.fillStyle = \"white\";\n      ctx.font = \"bold 20px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(node.label, node.x, node.y);\n\n      // Distance label below node\n      let distText = distances[node.id] === Infinity ? \"∞\" : distances[node.id].toString();\n      ctx.font = \"14px Arial\";\n      ctx.fillStyle = \"#333\";\n      ctx.textBaseline = \"top\";\n      ctx.fillText(`Dist: ${distText}`, node.x, node.y + 25);\n    });\n  }\n\n  // Logging helper\n  function log(message) {\n    const time = new Date().toLocaleTimeString();\n    logDiv.innerHTML += `[${time}] ${message}<br>`;\n    logDiv.scrollTop = logDiv.scrollHeight;\n  }\n\n  // Reset everything for new run\n  function reset() {\n    distances = new Array(nodes.length).fill(Infinity);\n    previous = new Array(nodes.length).fill(null);\n    visited = new Set();\n    pq = new PriorityQueue();\n    stepIterator = null;\n    currentNode = null;\n    currentEdgeIndex = null;\n    stopAutoRun();\n\n    nextStepBtn.disabled = false;\n    autoRunBtn.disabled = false;\n    stopAutoBtn.style.display = \"none\";\n\n    distances[startSelect.value] = 0;\n    pq.push(startSelect.value, 0);\n\n    logDiv.innerHTML = \"\";\n    log(`Starting Dijkstra's algorithm from node ${nodes[startSelect.value].label}.`);\n    drawGraph();\n    updateControls();\n  }\n\n  // Update controls (disable/enable based on state)\n  function updateControls() {\n    // When algorithm finishes, disable next and auto-run buttons\n    if(stepIterator && stepIterator.done) {\n      nextStepBtn.disabled = true;\n      autoRunBtn.disabled = true;\n      stopAutoBtn.style.display = \"none\";\n      log(\"Algorithm completed.\");\n    }\n  }\n\n  // Retrieve shortest path if end node selected and finalized\n  function getShortestPath(endId) {\n    let path = [];\n    let current = parseInt(endId);\n    if(distances[current] === Infinity) return null;\n    while(current !== null) {\n      path.push(current);\n      current = previous[current];\n    }\n    return path.reverse();\n  }\n\n  // Generator function for stepping through Dijkstra\n  function* dijkstraStep(startId) {\n    // Initialize\n    const finalized = new Set();\n    const localVisited = new Set();\n    const localDistances = distances.slice();\n    const localPrev = previous.slice();\n    const localPQ = new PriorityQueue();\n    localPQ.push(parseInt(startId), 0);\n\n    while(localPQ.size() > 0) {\n      // Pop the node with smallest tentative distance\n      const u = localPQ.pop();\n      if(finalized.has(u)) {\n        // Already finalized\n        continue;\n      }\n      currentNode = u;\n      log(`Visiting node ${nodes[u].label} with current shortest distance ${localDistances[u]}.`);\n      yield {currentNode:u, finalized: new Set(finalized), relaxingEdge: null};\n\n      finalized.add(u);\n\n      // Visit each neighbor\n      for (let i = 0; i < nodes[u].edges.length; i++) {\n        const edge = nodes[u].edges[i];\n        let from = u, to = edge.to;\n        if(finalized.has(to)) {\n          // Nothing to do for finalized nodes\n          continue;\n        }\n        currentEdgeIndex = i;\n        log(`Relaxing edge from ${nodes[from].label} to ${nodes[to].label} with weight ${edge.weight}.`);\n        yield {currentNode: u, finalized: new Set(finalized), relaxingEdge: {from, to}};\n\n        if(localDistances[u] + edge.weight < localDistances[to]) {\n          const oldDist = localDistances[to];\n          localDistances[to] = localDistances[u] + edge.weight;\n          localPrev[to] = u;\n          localPQ.push(to, localDistances[to]);\n          log(`Updated distance of node ${nodes[to].label} from ${oldDist === Infinity ? \"∞\" : oldDist} to ${localDistances[to]}.`);\n          distances[to] = localDistances[to];\n          previous[to] = u;\n        } else {\n          log(`No update for node ${nodes[to].label}, current distance ${localDistances[to]} is better.`);\n        }\n        yield {currentNode: u, finalized: new Set(finalized), relaxingEdge: {from, to}};\n      }\n    }\n    // Mark algorithm done, no current node\n    currentNode = null;\n    log(\"All nodes finalized.\");\n    yield {finalized: new Set(finalized), done:true};\n  }\n\n  // Perform one step in the algorithm\n  function nextStep() {\n    if(!stepIterator) {\n      stepIterator = dijkstraStep(startSelect.value);\n    }\n    const {value, done} = stepIterator.next();\n    if(done) {\n      stepIterator.done = true;\n      highlightResults();\n      updateControls();\n      return;\n    }\n    // Draw graph with highlighting\n    drawGraph({\n      currentNode: value.currentNode,\n      finalized: value.finalized,\n      relaxingEdge: value.relaxingEdge,\n      pathNodes: null\n    });\n    updateControls();\n  }\n\n  // When algorithm finishes, highlight shortest path if end node given\n  function highlightResults() {\n    const endId = endSelect.value;\n    if(!endId) {\n      // Just highlight finalized set\n      drawGraph({\n        finalized: new Set(nodes.map(n=>n.id)),\n        pathNodes: null\n      });\n      log(\"Shortest paths from start node to all reachable nodes displayed.\");\n      return;\n    }\n    const path = getShortestPath(endId);\n    if(!path) {\n      log(`Node ${nodes[endId].label} is not reachable from start node.`);\n      drawGraph({finalized: new Set(nodes.map(n=>n.id)), pathNodes: null});\n      return;\n    }\n    // Highlight finalized and path nodes\n    const pathSet = new Set(path);\n    drawGraph({\n      finalized: new Set(nodes.map(n=>n.id)),\n      pathNodes: pathSet\n    });\n    log(`Shortest path to node ${nodes[endId].label}: ${path.map(i=>nodes[i].label).join(\" → \")}`);\n  }\n\n  function startAutoRun() {\n    if(autoRunInterval) return;\n    nextStepBtn.disabled = true;\n    autoRunBtn.style.display = \"none\";\n    stopAutoBtn.style.display = \"inline-block\";\n    autoRunInterval = setInterval(() => {\n      if(!stepIterator) stepIterator = dijkstraStep(startSelect.value);\n      const {done} = stepIterator.next();\n      if(done) {\n        stepIterator.done = true;\n        highlightResults();\n        stopAutoRun();\n        updateControls();\n      } else {\n        const state = stepIterator.next().value;\n        drawGraph({\n          currentNode: state.currentNode,\n          finalized: state.finalized,\n          relaxingEdge: state.relaxingEdge\n        });\n      }\n    }, 900);\n  }\n\n  function stopAutoRun() {\n    if(autoRunInterval) {\n      clearInterval(autoRunInterval);\n      autoRunInterval = null;\n      nextStepBtn.disabled = false;\n      autoRunBtn.style.display = \"inline-block\";\n      stopAutoBtn.style.display = \"none\";\n    }\n  }\n\n  // Event listeners\n  resetBtn.addEventListener(\"click\", () => {\n    distances.fill(Infinity);\n    previous.fill(null);\n    visited.clear();\n    stepIterator = null;\n    currentNode = null;\n    currentEdgeIndex = null;\n    nextStepBtn.disabled = false;\n    autoRunBtn.disabled = false;\n    stopAutoRun();\n    logDiv.innerHTML = \"\";\n    distances[startSelect.value] = 0;\n    pq = new PriorityQueue();\n    pq.push(parseInt(startSelect.value), 0);\n    drawGraph();\n    log(`Graph reset. Start node is ${nodes[startSelect.value].label}.`);\n    updateControls();\n  });\n\n  nextStepBtn.addEventListener(\"click\", () => {\n    if(!stepIterator) {\n      distances = new Array(nodes.length).fill(Infinity);\n      previous = new Array(nodes.length).fill(null);\n      distances[startSelect.value] = 0;\n      stepIterator = dijkstraStep(startSelect.value);\n    }\n    const {value, done} = stepIterator.next();\n    if(done) {\n      stepIterator.done = true;\n      highlightResults();\n      updateControls();\n      return;\n    }\n    drawGraph({\n      currentNode: value.currentNode,\n      finalized: value.finalized,\n      relaxingEdge: value.relaxingEdge,\n      pathNodes: null\n    });\n    updateControls();\n  });\n\n  autoRunBtn.addEventListener(\"click\", () => {\n    if(!stepIterator) {\n      distances = new Array(nodes.length).fill(Infinity);\n      previous = new Array(nodes.length).fill(null);\n      distances[startSelect.value] = 0;\n      stepIterator = dijkstraStep(startSelect.value);\n    }\n    startAutoRun();\n  });\n\n  stopAutoBtn.addEventListener(\"click\", () => {\n    stopAutoRun();\n  });\n\n  startSelect.addEventListener(\"change\", () => {\n    resetBtn.click();\n  });\n\n  endSelect.addEventListener(\"change\", () => {\n    // Just redraw on end node change\n    if(stepIterator && stepIterator.done) {\n      highlightResults();\n    }\n  });\n\n  // Initialize on load\n  function init() {\n    populateNodeOptions();\n    distances = new Array(nodes.length).fill(Infinity);\n    previous = new Array(nodes.length).fill(null);\n    distances[startSelect.value] = 0;\n    drawGraph();\n    log(`Select a start node and click \"Reset Graph\" to begin.`);\n  }\n\n  init();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}