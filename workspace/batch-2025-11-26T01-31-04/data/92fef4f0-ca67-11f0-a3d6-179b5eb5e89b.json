{
  "id": "92fef4f0-ca67-11f0-a3d6-179b5eb5e89b",
  "timestamp": "2025-11-26T01:32:53.852Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Kruskal's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    margin: 0;\n    overflow: hidden;\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n  }\n  header {\n    background: #003366;\n    color: white;\n    padding: 0.75rem 1rem;\n    text-align: center;\n  }\n  #container {\n    display: flex;\n    flex: 1;\n    overflow: hidden;\n  }\n  #canvas-container {\n    flex: 2;\n    background: #f4f7f9;\n    position: relative;\n  }\n  canvas {\n    display: block;\n    margin: 0 auto;\n    background: white;\n    box-shadow: 0 0 10px rgb(0 0 0 / 0.1);\n  }\n  #controls {\n    flex: 1;\n    background: #e8eff7;\n    border-left: 1px solid #ccc;\n    padding: 1rem;\n    box-sizing: border-box;\n    overflow-y: auto;\n  }\n  h2 {\n    margin-top: 0;\n  }\n  label, button {\n    display: block;\n    margin-top: 0.8rem;\n  }\n  input[type=\"number\"], textarea {\n    width: 100%;\n    font-size: 1rem;\n    padding: 0.4rem;\n    box-sizing: border-box;\n    margin-top: 0.2rem;\n    font-family: monospace;\n  }\n  textarea {\n    resize: vertical;\n    height: 130px;\n  }\n  button {\n    font-size: 1.1rem;\n    background-color: #003366;\n    color: white;\n    border: none;\n    padding: 0.6rem;\n    cursor: pointer;\n    border-radius: 3px;\n    transition: background-color 0.3s;\n  }\n  button:hover:not(:disabled) {\n    background-color: #0054b3;\n  }\n  button:disabled {\n    background-color: #999;\n    cursor: not-allowed;\n  }\n  #log {\n    background: white;\n    margin-top: 1rem;\n    height: 150px;\n    overflow-y: auto;\n    padding: 0.5rem;\n    border: 1px solid #ccc;\n    font-size: 0.9rem;\n    font-family: monospace;\n    white-space: pre-wrap;\n  }\n  #legend {\n    margin-top: 1rem;\n    font-size: 0.9rem;\n  }\n  .color-box {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    vertical-align: middle;\n    margin-right: 5px;\n    border-radius: 3px;\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Kruskal's Algorithm Visualization</h1>\n  <p>Minimum Spanning Tree (MST) finder using Kruskal’s Algorithm</p>\n</header>\n<div id=\"container\">\n  <div id=\"canvas-container\">\n    <canvas id=\"graphCanvas\" width=\"700\" height=\"600\" aria-label=\"Graph visualization\"></canvas>\n  </div>\n  <div id=\"controls\">\n    <h2>Input Graph</h2>\n    <label for=\"numVertices\">Number of vertices (max 20):</label>\n    <input type=\"number\" id=\"numVertices\" min=\"2\" max=\"20\" value=\"7\" />\n    \n    <label for=\"edgesInput\">Edges (format: u v weight):</label>\n    <textarea id=\"edgesInput\" aria-describedby=\"edgeFormatHelp\">0 1 7\n0 3 5\n1 2 8\n1 3 9\n1 4 7\n2 4 5\n3 4 15\n3 5 6\n4 5 8\n4 6 9\n5 6 11</textarea>\n    <div id=\"edgeFormatHelp\" style=\"font-size:0.85rem; color:#555;\">\n      One edge per line. Vertices are numbered from 0 to n-1.\n    </div>\n\n    <button id=\"generateRandom\">Generate Random Graph</button>\n    <button id=\"startBtn\">Start Kruskal's Algorithm</button>\n    <button id=\"stepBtn\" disabled>Next Step</button>\n    <button id=\"resetBtn\" disabled>Reset</button>\n\n    <h2>Legend</h2>\n    <div id=\"legend\">\n      <div><span class=\"color-box\" style=\"background-color:#666;\">&nbsp;</span>Unselected Edge</div>\n      <div><span class=\"color-box\" style=\"background-color:#3a86ff;\">&nbsp;</span>Edge Currently Considered</div>\n      <div><span class=\"color-box\" style=\"background-color:#06d6a0;\">&nbsp;</span>Edge Added to MST</div>\n      <div><span class=\"color-box\" style=\"background-color:#ef476f;\">&nbsp;</span>Edge Skipped (creates cycle)</div>\n      <div><span class=\"color-box\" style=\"background-color:#ffd166;\">&nbsp;</span>Vertices connected by MST edges</div>\n    </div>\n\n    <h2>Log</h2>\n    <div id=\"log\" aria-live=\"polite\"></div>\n  </div>\n</div>\n\n<script>\n/**\n * Kruskal's Algorithm Visualization\n * \n * Graph representation:\n * - Vertices 0 to n-1, placed evenly around a circle\n * - Edges with weights, drawn as lines between vertices\n * \n * Visual states for edges:\n * - Normal: gray\n * - Current considered edge: blue\n * - Added to MST: green\n * - Skipped (cycle): red\n * \n * Vertices included in MST edges are highlighted yellow.\n * \n * Controls:\n * - Input number of vertices and edges manually\n * - Generate random graph button\n * - Start algorithm\n * - Next step (step through sorting edges and union-find decisions)\n * - Reset\n */\n\n(() => {\n  // Canvas setup\n  const canvas = document.getElementById(\"graphCanvas\");\n  const ctx = canvas.getContext(\"2d\");\n\n  // UI Elements\n  const numVerticesInput = document.getElementById(\"numVertices\");\n  const edgesInput = document.getElementById(\"edgesInput\");\n  const generateRandomBtn = document.getElementById(\"generateRandom\");\n  const startBtn = document.getElementById(\"startBtn\");\n  const stepBtn = document.getElementById(\"stepBtn\");\n  const resetBtn = document.getElementById(\"resetBtn\");\n  const logDiv = document.getElementById(\"log\");\n\n  // Constants for drawing\n  const WIDTH = canvas.width;\n  const HEIGHT = canvas.height;\n  const RADIUS = Math.min(WIDTH, HEIGHT) / 2 - 60;\n  const VERTEX_RADIUS = 20;\n\n  // Colors\n  const COLOR_EDGE_NORMAL = \"#666666\";\n  const COLOR_EDGE_CURRENT = \"#3a86ff\";\n  const COLOR_EDGE_MST = \"#06d6a0\";\n  const COLOR_EDGE_SKIPPED = \"#ef476f\";\n  const COLOR_VERTEX_MST = \"#ffd166\";\n  const COLOR_VERTEX_NORMAL = \"#888\";\n  const COLOR_VERTEX_LABEL = \"#111\";\n\n  // State variables\n  let vertices = []; // {x, y}\n  let edges = []; // {u, v, weight, state} - state: normal, current, mst, skipped\n  let numVertices = 0;\n\n  // Kruskal's algorithm state\n  let sortedEdges = [];\n  let edgeIndex = 0;\n  let unionFind = null;\n  let mstEdges = [];\n  let isRunning = false;\n\n  function log(msg) {\n    logDiv.textContent += msg + \"\\n\";\n    logDiv.scrollTop = logDiv.scrollHeight;\n  }\n\n  // Union-Find (Disjoint Set) Data Structure\n  class UnionFind {\n    constructor(n) {\n      this.parent = new Array(n);\n      this.rank = new Array(n);\n      for (let i = 0; i < n; i++) {\n        this.parent[i] = i;\n        this.rank[i] = 0;\n      }\n    }\n    find(x) {\n      if (this.parent[x] !== x) {\n        this.parent[x] = this.find(this.parent[x]);\n      }\n      return this.parent[x];\n    }\n    union(a, b) {\n      let rootA = this.find(a);\n      let rootB = this.find(b);\n      if (rootA === rootB) return false;\n      if (this.rank[rootA] < this.rank[rootB]) {\n        this.parent[rootA] = rootB;\n      } else if (this.rank[rootB] < this.rank[rootA]) {\n        this.parent[rootB] = rootA;\n      } else {\n        this.parent[rootB] = rootA;\n        this.rank[rootA]++;\n      }\n      return true;\n    }\n    connected(a, b) {\n      return this.find(a) === this.find(b);\n    }\n  }\n\n  // Calculate vertex positions in circle layout\n  function calculateVerticesPositions(n) {\n    // Center of canvas\n    const cx = WIDTH / 2;\n    const cy = HEIGHT / 2;\n    const positions = [];\n    for (let i = 0; i < n; i++) {\n      const angle = (2 * Math.PI * i) / n - Math.PI / 2;\n      const x = cx + RADIUS * Math.cos(angle);\n      const y = cy + RADIUS * Math.sin(angle);\n      positions.push({ x, y });\n    }\n    return positions;\n  }\n\n  // Draw single vertex\n  function drawVertex(i, includedInMST) {\n    const v = vertices[i];\n    ctx.beginPath();\n    ctx.fillStyle = includedInMST ? COLOR_VERTEX_MST : COLOR_VERTEX_NORMAL;\n    ctx.strokeStyle = \"#222\";\n    ctx.lineWidth = 2;\n    ctx.arc(v.x, v.y, VERTEX_RADIUS, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.fillStyle = COLOR_VERTEX_LABEL;\n    ctx.font = \"bold 16px monospace\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(i, v.x, v.y);\n  }\n\n  // Draw single edge\n  function drawEdge(edge) {\n    const { u, v, weight, state } = edge;\n    const A = vertices[u];\n    const B = vertices[v];\n\n    // Choose color\n    let color = COLOR_EDGE_NORMAL;\n    switch (state) {\n      case \"current\":\n        color = COLOR_EDGE_CURRENT;\n        break;\n      case \"mst\":\n        color = COLOR_EDGE_MST;\n        break;\n      case \"skipped\":\n        color = COLOR_EDGE_SKIPPED;\n        break;\n    }\n\n    ctx.strokeStyle = color;\n    ctx.lineWidth = state === \"current\" ? 4 : (state === \"mst\" ? 5 : 2);\n    \n    // Draw edge line\n    ctx.beginPath();\n    ctx.moveTo(A.x, A.y);\n    ctx.lineTo(B.x, B.y);\n    ctx.stroke();\n\n    // Draw weight label\n    const midX = (A.x + B.x) / 2;\n    const midY = (A.y + B.y) / 2;\n    ctx.fillStyle = \"#222\";\n    ctx.font = \"14px monospace\";\n    // Offset slightly perpendicular to line for clarity\n    const dx = B.x - A.x;\n    const dy = B.y - A.y;\n    const len = Math.sqrt(dx * dx + dy * dy);\n    const offsetX = (-dy / len) * 12;\n    const offsetY = (dx / len) * 12;\n    ctx.fillText(weight, midX + offsetX, midY + offsetY);\n  }\n\n  // Draw entire graph\n  function drawGraph() {\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // Determine which vertices are in MST\n    let vertexInMST = new Array(numVertices).fill(false);\n    for (const e of edges) {\n      if (e.state === \"mst\") {\n        vertexInMST[e.u] = true;\n        vertexInMST[e.v] = true;\n      }\n    }\n    \n    // Draw edges first (underneath vertices)\n    for (const edge of edges) {\n      drawEdge(edge);\n    }\n    // Draw vertices on top\n    for (let i = 0; i < numVertices; i++) {\n      drawVertex(i, vertexInMST[i]);\n    }\n  }\n\n  // Parse edges input and validate\n  function parseEdges(text, n) {\n    const lines = text.trim().split(\"\\n\");\n    const parsedEdges = [];\n    for (let lineNum = 0; lineNum < lines.length; lineNum++) {\n      let line = lines[lineNum].trim();\n      if (!line) continue;\n      const parts = line.split(/\\s+/);\n      if (parts.length !== 3) {\n        throw new Error(`Invalid edge format at line ${lineNum + 1}. Expected 3 values.`);\n      }\n      let [u, v, w] = parts;\n      u = Number(u);\n      v = Number(v);\n      w = Number(w);\n      if (\n        !Number.isInteger(u) || !Number.isInteger(v) ||\n        u < 0 || v < 0 || u >= n || v >= n ||\n        isNaN(w) || w <= 0\n      ) {\n        throw new Error(`Invalid edge values at line ${lineNum + 1}. Vertex indices must be integers [0, ${n - 1}] and weight positive number.`);\n      }\n      // Disallow self loops\n      if (u === v) {\n        throw new Error(`Self loop edge at line ${lineNum + 1} is not allowed.`);\n      }\n      parsedEdges.push({ u, v, weight: w, state: \"normal\" });\n    }\n    // Optional: Remove duplicate edges (u,v) and (v,u)\n    let seen = new Set();\n    let filteredEdges = [];\n    for (const e of parsedEdges) {\n      const key = e.u < e.v ? e.u + \",\" + e.v : e.v + \",\" + e.u;\n      if (!seen.has(key)) {\n        seen.add(key);\n        filteredEdges.push(e);\n      } else {\n        // Duplicate ignored\n      }\n    }\n    return filteredEdges;\n  }\n\n  // Generate random connected graph\n  function generateRandomGraph(n) {\n    // Create a connected graph first (spanning tree)\n    let generatedEdges = [];\n    for (let i = 1; i < n; i++) {\n      const connectTo = Math.floor(Math.random() * i); // connect i to some vertex less than i\n      const weight = Math.floor(Math.random() * 20) + 1;\n      generatedEdges.push({ u: i, v: connectTo, weight, state: \"normal\" });\n    }\n    // Add some random extra edges\n    let extraEdgesCount = Math.min(n * 2, 30);\n    let edgeSet = new Set();\n    for (const e of generatedEdges) {\n      const key = e.u < e.v ? `${e.u},${e.v}` : `${e.v},${e.u}`;\n      edgeSet.add(key);\n    }\n    while (extraEdgesCount > 0) {\n      const u = Math.floor(Math.random() * n);\n      let v = Math.floor(Math.random() * n);\n      if (v === u) continue;\n      const a = u < v ? u : v;\n      const b = u < v ? v : u;\n      const key = `${a},${b}`;\n      if (edgeSet.has(key)) continue;\n      const weight = Math.floor(Math.random() * 20) + 1;\n      generatedEdges.push({ u: a, v: b, weight, state: \"normal\" });\n      edgeSet.add(key);\n      extraEdgesCount--;\n    }\n    return generatedEdges;\n  }\n\n  // Reset states\n  function resetState() {\n    isRunning = false;\n    edgeIndex = 0;\n    mstEdges = [];\n    unionFind = null;\n    for (const e of edges) {\n      e.state = \"normal\";\n    }\n    logDiv.textContent = \"\";\n    stepBtn.disabled = true;\n    resetBtn.disabled = true;\n    startBtn.disabled = false;\n    drawGraph();\n  }\n\n  // Start algorithm\n  function startAlgorithm() {\n    // Sort edges by weight ascending\n    sortedEdges = edges.slice().sort((a, b) => a.weight - b.weight);\n    edgeIndex = 0;\n    unionFind = new UnionFind(numVertices);\n    isRunning = true;\n    stepBtn.disabled = false;\n    resetBtn.disabled = false;\n    startBtn.disabled = true;\n    logDiv.textContent = \"\";\n    log(\"Starting Kruskal's Algorithm:\");\n    for (const e of edges) e.state = \"normal\";\n    drawGraph();\n  }\n\n  // Perform one step of Kruskal\n  function stepAlgorithm() {\n    // Clear previous current highlight\n    for (const e of edges) {\n      if (e.state === \"current\") e.state = \"normal\";\n    }\n\n    if (edgeIndex >= sortedEdges.length) {\n      log(\"All edges processed. MST complete.\");\n      stepBtn.disabled = true;\n      isRunning = false;\n      drawGraph();\n      return;\n    }\n\n    const edge = sortedEdges[edgeIndex];\n    // Find the corresponding edge in edges array by u,v and weight\n    // Because edges are objects, they match — but safer to find.\n    const realEdge = edges.find(\n      e => ( (e.u === edge.u && e.v === edge.v) || (e.u === edge.v && e.v === edge.u) ) && e.weight === edge.weight\n    );\n    if (!realEdge) throw new Error(\"Edge mismatch in algorithm step.\");\n\n    realEdge.state = \"current\";\n    drawGraph();\n\n    log(`Considering edge (${realEdge.u}, ${realEdge.v}) with weight ${realEdge.weight}`);\n    // Check if adding it forms cycle\n    if (unionFind.connected(realEdge.u, realEdge.v)) {\n      realEdge.state = \"skipped\";\n      log(`Edge creates a cycle. Skipping it.`);\n    } else {\n      unionFind.union(realEdge.u, realEdge.v);\n      realEdge.state = \"mst\";\n      mstEdges.push(realEdge);\n      log(`Edge added to MST.`);\n    }\n\n    edgeIndex++;\n\n    // If MST completed (n-1 edges), disable next step\n    if (mstEdges.length === numVertices - 1) {\n      log(\"Minimum Spanning Tree completed.\");\n      stepBtn.disabled = true;\n      isRunning = false;\n    }\n    drawGraph();\n  }\n\n  // Load graph from inputs\n  function loadGraphFromInput() {\n    const n = Number(numVerticesInput.value);\n    if (!Number.isInteger(n) || n < 2 || n > 20) {\n      alert(\"Number of vertices must be an integer between 2 and 20.\");\n      return false;\n    }\n    let parsedEdges;\n    try {\n      parsedEdges = parseEdges(edgesInput.value, n);\n    } catch (err) {\n      alert(\"Error parsing edges:\\n\" + err.message);\n      return false;\n    }\n    if (parsedEdges.length === 0) {\n      alert(\"No valid edges parsed from input.\");\n      return false;\n    }\n    // Save state\n    numVertices = n;\n    vertices = calculateVerticesPositions(numVertices);\n    edges = parsedEdges;\n    resetState();\n    return true;\n  }\n\n  // Initialize Random graph\n  function initializeRandomGraph() {\n    const n = Number(numVerticesInput.value);\n    if (!Number.isInteger(n) || n < 2 || n > 20) {\n      alert(\"Number of vertices must be an integer between 2 and 20.\");\n      return;\n    }\n    const randomEdges = generateRandomGraph(n);\n    edgesInput.value = randomEdges\n      .map(e => `${e.u} ${e.v} ${e.weight}`)\n      .join(\"\\n\");\n    if (loadGraphFromInput()) {\n      log(\"Random graph generated and loaded.\");\n    }\n  }\n\n  // Initial setup\n  function init() {\n    if (loadGraphFromInput()) {\n      log(\"Graph loaded. Ready to start.\");\n    }\n  }\n\n  // Event listeners\n  startBtn.addEventListener(\"click\", () => {\n    if (isRunning) return;\n    if (loadGraphFromInput()) {\n      startAlgorithm();\n    }\n  });\n\n  stepBtn.addEventListener(\"click\", () => {\n    if (!isRunning) return;\n    stepAlgorithm();\n  });\n\n  resetBtn.addEventListener(\"click\", () => {\n    resetState();\n    log(\"Algorithm reset.\");\n  });\n\n  generateRandomBtn.addEventListener(\"click\", () => {\n    initializeRandomGraph();\n  });\n\n  numVerticesInput.addEventListener(\"change\", () => {\n    // Reload graph with new size but keep edges text intact\n    if (loadGraphFromInput()) {\n      log(\"Graph reloaded after changing number of vertices.\");\n    }\n  });\n\n  edgesInput.addEventListener(\"input\", () => {\n    // Just clear logs and reset state when edges input changes to avoid confusion\n    resetState();\n    log(\"Graph changed. Please start the algorithm.\");\n  });\n\n  // On load\n  window.onload = () => {\n    vertices = calculateVerticesPositions(numVerticesInput.value);\n    if (loadGraphFromInput()) {\n      log(\"Ready. Configure the graph and start the algorithm.\");\n    }\n    drawGraph();\n  };\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}