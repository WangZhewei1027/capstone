{
  "id": "92fd9560-ca67-11f0-a3d6-179b5eb5e89b",
  "timestamp": "2025-11-26T01:32:56.949Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Binary Search Tree (BST) Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f7f9fc;\n    color: #222;\n  }\n  h1 {\n    text-align: center;\n  }\n  #controls {\n    max-width: 600px;\n    margin: 0 auto 20px auto;\n    background: #ffffff;\n    padding: 15px 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 8px rgb(0 0 0 / 0.1);\n  }\n  label {\n    margin-right: 10px;\n  }\n  input[type=\"number\"] {\n    width: 80px;\n    padding: 6px 8px;\n    font-size: 1rem;\n    margin-right: 10px;\n  }\n  button {\n    padding: 7px 12px;\n    font-size: 1rem;\n    margin-right: 10px;\n    cursor: pointer;\n    border: none;\n    border-radius: 5px;\n    background-color: #0078d7;\n    color: white;\n    transition: background-color 0.2s ease;\n  }\n  button:hover:not(:disabled) {\n    background-color: #005a9e;\n  }\n  button:disabled {\n    background-color: #999;\n    cursor: not-allowed;\n  }\n  #output {\n    max-width: 600px;\n    margin: 0 auto 30px auto;\n    background: #fff;\n    border-radius: 8px;\n    padding: 15px 20px;\n    box-shadow: 0 2px 8px rgb(0 0 0 / 0.1);\n    min-height: 50px;\n    white-space: pre-wrap;\n    font-family: monospace;\n    font-size: 1.1rem;\n    color: #333;\n  }\n  #tree-container {\n    max-width: 90vw;\n    margin: 20px auto;\n    text-align: center;\n    overflow-x: auto;\n  }\n  svg {\n    background: #ffffff;\n    border: 1px solid #ddd;\n    border-radius: 8px;\n  }\n</style>\n</head>\n<body>\n<h1>Binary Search Tree (BST) Visualizer</h1>\n<div id=\"controls\">\n  <label for=\"valueInput\">Value:</label>\n  <input type=\"number\" id=\"valueInput\" />\n  <button id=\"insertBtn\">Insert</button>\n  <button id=\"searchBtn\">Search</button>\n  <button id=\"deleteBtn\">Delete</button>\n  <button id=\"clearBtn\">Clear Tree</button>\n</div>\n<div id=\"output\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n<div id=\"tree-container\" aria-label=\"Binary search tree visualization\"></div>\n\n<script>\n(() => {\n  // BST Node class\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n      this.x = 0; // For visualization\n      this.y = 0;\n    }\n  }\n\n  // BST class with insert, search, delete and traversal\n  class BST {\n    constructor() {\n      this.root = null;\n    }\n\n    insert(value) {\n      if (typeof value !== \"number\" || isNaN(value)) return false;\n\n      const newNode = new Node(value);\n      if (!this.root) {\n        this.root = newNode;\n        return true;\n      }\n      let current = this.root;\n      while (true) {\n        if (value === current.value) {\n          // Value already exists, no duplicates in this BST\n          return false;\n        }\n        if (value < current.value) {\n          if (!current.left) {\n            current.left = newNode;\n            return true;\n          }\n          current = current.left;\n        } else {\n          if (!current.right) {\n            current.right = newNode;\n            return true;\n          }\n          current = current.right;\n        }\n      }\n    }\n\n    search(value) {\n      if (!this.root) return null;\n      let current = this.root;\n      while (current) {\n        if (value === current.value) return current;\n        if (value < current.value) current = current.left;\n        else current = current.right;\n      }\n      return null;\n    }\n\n    delete(value) {\n      this.root = this._deleteRec(this.root, value);\n    }\n\n    _deleteRec(node, value) {\n      if (!node) return null;\n      if (value < node.value) {\n        node.left = this._deleteRec(node.left, value);\n      } else if (value > node.value) {\n        node.right = this._deleteRec(node.right, value);\n      } else {\n        // node.val == value, delete this node\n        if (!node.left) return node.right;\n        if (!node.right) return node.left;\n\n        // node with two children:\n        // get inorder successor (smallest in the right subtree)\n        let minLargerNode = this._minValueNode(node.right);\n        node.value = minLargerNode.value;\n        node.right = this._deleteRec(node.right, minLargerNode.value);\n      }\n      return node;\n    }\n\n    _minValueNode(node) {\n      let current = node;\n      while (current.left) current = current.left;\n      return current;\n    }\n\n    // Traversals: in-order, pre-order, post-order\n    inorder() {\n      const result = [];\n      this._inorderRec(this.root, result);\n      return result;\n    }\n    _inorderRec(node, arr) {\n      if (!node) return;\n      this._inorderRec(node.left, arr);\n      arr.push(node.value);\n      this._inorderRec(node.right, arr);\n    }\n\n    preorder() {\n      const result = [];\n      this._preorderRec(this.root, result);\n      return result;\n    }\n    _preorderRec(node, arr) {\n      if (!node) return;\n      arr.push(node.value);\n      this._preorderRec(node.left, arr);\n      this._preorderRec(node.right, arr);\n    }\n\n    postorder() {\n      const result = [];\n      this._postorderRec(this.root, result);\n      return result;\n    }\n    _postorderRec(node, arr) {\n      if (!node) return;\n      this._postorderRec(node.left, arr);\n      this._postorderRec(node.right, arr);\n      arr.push(node.value);\n    }\n\n    clear() {\n      this.root = null;\n    }\n  }\n\n  // Visualization logic using SVG\n  class BSTVisualizer {\n    constructor(container) {\n      this.container = container;\n      this.nodeRadius = 20;\n      this.verticalSpacing = 70;\n      this.horizontalSpacing = 40;\n      this.svg = null;\n    }\n\n    clear() {\n      if (this.svg) {\n        this.container.removeChild(this.svg);\n        this.svg = null;\n      }\n    }\n\n    render(root) {\n      this.clear();\n      if (!root) return;\n\n      // Calculate positions first\n      this._calculatePositions(root);\n\n      // Calculate SVG width and height based on node positions\n      const allNodes = [];\n      this._gatherNodes(root, allNodes);\n\n      const xs = allNodes.map(node => node.x);\n      const ys = allNodes.map(node => node.y);\n\n      const minX = Math.min(...xs) - this.nodeRadius - 10;\n      const maxX = Math.max(...xs) + this.nodeRadius + 10;\n      const minY = Math.min(...ys) - this.nodeRadius - 10;\n      const maxY = Math.max(...ys) + this.nodeRadius + 10;\n\n      const width = maxX - minX;\n      const height = maxY - minY;\n\n      // Create svg element\n      const xmlns = \"http://www.w3.org/2000/svg\";\n      this.svg = document.createElementNS(xmlns, \"svg\");\n      this.svg.setAttribute(\"width\", width);\n      this.svg.setAttribute(\"height\", height);\n      this.svg.setAttribute(\"viewBox\", `${minX} ${minY} ${width} ${height}`);\n\n      // Draw connections (edges) first\n      allNodes.forEach(node => {\n        if (node.left) {\n          this._drawLine(node, node.left);\n        }\n        if (node.right) {\n          this._drawLine(node, node.right);\n        }\n      });\n\n      // Draw nodes (circles + text)\n      allNodes.forEach(node => {\n        this._drawNode(node);\n      });\n\n      this.container.appendChild(this.svg);\n    }\n\n    _drawLine(parent, child) {\n      const xmlns = \"http://www.w3.org/2000/svg\";\n      const line = document.createElementNS(xmlns, \"line\");\n      line.setAttribute(\"x1\", parent.x);\n      line.setAttribute(\"y1\", parent.y + this.nodeRadius);\n      line.setAttribute(\"x2\", child.x);\n      line.setAttribute(\"y2\", child.y - this.nodeRadius);\n      line.setAttribute(\"stroke\", \"#666\");\n      line.setAttribute(\"stroke-width\", \"2\");\n      this.svg.appendChild(line);\n    }\n\n    _drawNode(node) {\n      const xmlns = \"http://www.w3.org/2000/svg\";\n\n      // Circle\n      const circle = document.createElementNS(xmlns, \"circle\");\n      circle.setAttribute(\"cx\", node.x);\n      circle.setAttribute(\"cy\", node.y);\n      circle.setAttribute(\"r\", this.nodeRadius);\n      circle.setAttribute(\"fill\", \"#1e90ff\");\n      circle.setAttribute(\"stroke\", \"#004a99\");\n      circle.setAttribute(\"stroke-width\", \"2\");\n      circle.setAttribute(\"tabindex\", \"0\");\n      circle.setAttribute(\"aria-label\", `Node with value ${node.value}`);\n      this.svg.appendChild(circle);\n\n      // Text\n      const text = document.createElementNS(xmlns, \"text\");\n      text.setAttribute(\"x\", node.x);\n      text.setAttribute(\"y\", node.y + 6);\n      text.setAttribute(\"text-anchor\", \"middle\");\n      text.setAttribute(\"font-size\", \"14\");\n      text.setAttribute(\"fill\", \"white\");\n      text.style.userSelect = \"none\";\n      text.textContent = node.value;\n      this.svg.appendChild(text);\n    }\n\n    _calculatePositions(root) {\n      // We use a recursive approach assigning x based on in-order traversal position\n      let currentX = 0;\n      const setPositions = (node, depth = 0) => {\n        if (!node) return;\n        setPositions(node.left, depth + 1);\n        node.x = currentX * this.horizontalSpacing;\n        node.y = depth * this.verticalSpacing;\n        currentX++;\n        setPositions(node.right, depth + 1);\n      };\n      setPositions(root);\n    }\n\n    _gatherNodes(node, arr) {\n      if (!node) return;\n      arr.push(node);\n      this._gatherNodes(node.left, arr);\n      this._gatherNodes(node.right, arr);\n    }\n  }\n\n  // DOM Elements\n  const valueInput = document.getElementById(\"valueInput\");\n  const insertBtn = document.getElementById(\"insertBtn\");\n  const searchBtn = document.getElementById(\"searchBtn\");\n  const deleteBtn = document.getElementById(\"deleteBtn\");\n  const clearBtn = document.getElementById(\"clearBtn\");\n  const output = document.getElementById(\"output\");\n  const treeContainer = document.getElementById(\"tree-container\");\n\n  // Instances\n  const bst = new BST();\n  const visualizer = new BSTVisualizer(treeContainer);\n\n  // Helpers\n  function printStatus(message, isError = false) {\n    output.textContent = message;\n    output.style.color = isError ? \"crimson\" : \"#333\";\n  }\n\n  function validateInput() {\n    const val = valueInput.value.trim();\n    if (val === \"\") {\n      printStatus(\"Please enter a value.\", true);\n      return null;\n    }\n    const num = Number(val);\n    if (isNaN(num)) {\n      printStatus(\"Invalid input. Please enter a valid number.\", true);\n      return null;\n    }\n    return num;\n  }\n\n  function refreshBSTView() {\n    visualizer.render(bst.root);\n    // Also display traversals\n    const inorder = bst.inorder().join(\", \");\n    const preorder = bst.preorder().join(\", \");\n    const postorder = bst.postorder().join(\", \");\n    output.innerHTML = \n      `In-order traversal: ${inorder}\\n` +\n      `Pre-order traversal: ${preorder}\\n` +\n      `Post-order traversal: ${postorder}`;\n    output.style.color = \"#333\";\n  }\n\n  // Event Listeners\n  insertBtn.addEventListener(\"click\", () => {\n    const val = validateInput();\n    if (val === null) return;\n    const inserted = bst.insert(val);\n    if (inserted) {\n      printStatus(`Inserted ${val} into the BST.`);\n      refreshBSTView();\n      valueInput.value = \"\";\n      valueInput.focus();\n    } else {\n      printStatus(`Value ${val} already exists in the BST (no duplicates).`, true);\n    }\n  });\n\n  searchBtn.addEventListener(\"click\", () => {\n    const val = validateInput();\n    if (val === null) return;\n    const node = bst.search(val);\n    if (node) {\n      printStatus(`Value ${val} found in the BST.`);\n    } else {\n      printStatus(`Value ${val} not found in the BST.`, true);\n    }\n  });\n\n  deleteBtn.addEventListener(\"click\", () => {\n    const val = validateInput();\n    if (val === null) return;\n    const node = bst.search(val);\n    if (!node) {\n      printStatus(`Value ${val} not found. Cannot delete.`, true);\n      return;\n    }\n    bst.delete(val);\n    printStatus(`Deleted ${val} from the BST.`);\n    refreshBSTView();\n    valueInput.value = \"\";\n    valueInput.focus();\n  });\n\n  clearBtn.addEventListener(\"click\", () => {\n    bst.clear();\n    visualizer.clear();\n    printStatus(\"BST cleared.\");\n    valueInput.value = \"\";\n    valueInput.focus();\n  });\n\n  // Initial focus\n  valueInput.focus();\n\n  // Accessibility improvements: Enter key triggers Insert button\n  valueInput.addEventListener(\"keydown\", (e) => {\n    if (e.key === \"Enter\") {\n      insertBtn.click();\n    }\n  });\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}