{
  "id": "92fdbc71-ca67-11f0-a3d6-179b5eb5e89b",
  "timestamp": "2025-11-26T01:32:47.348Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Graph Demo: Directed and Undirected</title>\n<style>\n  body {\n    font-family: sans-serif;\n    margin: 0;\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n  }\n  #controls {\n    padding: 10px;\n    background: #eee;\n    display: flex;\n    align-items: center;\n    gap: 10px;\n  }\n  #canvas-container {\n    flex: 1;\n    background: #fff;\n    position: relative;\n  }\n  canvas {\n    display: block;\n    background: #fafafa;\n    margin: 0 auto;\n  }\n  button {\n    cursor: pointer;\n  }\n  #instructions {\n    font-size: 14px;\n    background: #f9f9f9;\n    border-top: 1px solid #ccc;\n    padding: 8px 12px;\n  }\n</style>\n</head>\n<body>\n  <div id=\"controls\">\n    <label>\n      <input type=\"radio\" name=\"graphType\" value=\"undirected\" checked />\n      Undirected\n    </label>\n    <label>\n      <input type=\"radio\" name=\"graphType\" value=\"directed\" />\n      Directed\n    </label>\n    <button id=\"addNodeBtn\">Add Node</button>\n    <button id=\"clearBtn\">Clear Graph</button>\n    <span style=\"margin-left:auto; font-size: 14px; color:#555;\">\n      Click to add nodes. Drag from one node to another to add edge.\n    </span>\n  </div>\n  <div id=\"canvas-container\">\n    <canvas id=\"graphCanvas\" width=\"800\" height=\"600\"></canvas>\n  </div>\n  <div id=\"instructions\">\n    <strong>Instructions:</strong> \n    <ul style=\"margin:4px 0 0 20px; padding:0; font-size:13px;\">\n      <li>Select directed or undirected graph.</li>\n      <li>Click \"Add Node\" then click on canvas to place node.</li>\n      <li>Drag from one node to another to create an edge.</li>\n      <li>Edges show arrowheads if directed.</li>\n      <li>Clear graph to start over.</li>\n    </ul>\n  </div>\n<script>\n(() => {\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n  const addNodeBtn = document.getElementById('addNodeBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const graphTypeRadios = document.querySelectorAll('input[name=\"graphType\"]');\n\n  // Graph data\n  let nodes = [];\n  let edges = []; // edges: {from: nodeId, to: nodeId}\n  let nodeIdCounter = 0;\n\n  // State\n  let graphType = 'undirected';\n  let addingNode = false;\n  let draggingEdge = null; // {fromNode, currentX, currentY}\n  let dragStartNode = null;\n  const nodeRadius = 20;\n\n  // Track mouse position & interaction\n  let mouseX = 0;\n  let mouseY = 0;\n\n  // Utility: distance squared between points\n  function distSq(x1, y1, x2, y2) {\n    return (x1 - x2) ** 2 + (y1 - y2) ** 2;\n  }\n\n  // Find node by position (circle hit test)\n  function findNodeAt(x, y) {\n    for(let node of nodes) {\n      if (distSq(node.x, node.y, x, y) <= nodeRadius*nodeRadius) {\n        return node;\n      }\n    }\n    return null;\n  }\n\n  // Draw arrowhead helper on edge line\n  function drawArrowhead(ctx, fromX, fromY, toX, toY, radius = 10) {\n    const angle = Math.atan2(toY - fromY, toX - fromX);\n    ctx.beginPath();\n    ctx.moveTo(toX, toY);\n    ctx.lineTo(\n      toX - radius * Math.cos(angle - Math.PI / 6),\n      toY - radius * Math.sin(angle - Math.PI / 6)\n    );\n    ctx.lineTo(\n      toX - radius * Math.cos(angle + Math.PI / 6),\n      toY - radius * Math.sin(angle + Math.PI / 6)\n    );\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Draw graph\n  function draw() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw edges\n    edges.forEach(edge => {\n      const fromNode = nodes.find(n => n.id === edge.from);\n      const toNode = nodes.find(n => n.id === edge.to);\n      if (!fromNode || !toNode) return;\n\n      // Calculate line start/end to avoid node overlap (offset by radius)\n      const dx = toNode.x - fromNode.x;\n      const dy = toNode.y - fromNode.y;\n      const dist = Math.sqrt(dx*dx + dy*dy);\n      if(dist === 0) return; // same node, skip drawing\n\n      const offsetX = (dx / dist) * nodeRadius;\n      const offsetY = (dy / dist) * nodeRadius;\n\n      const startX = fromNode.x + offsetX;\n      const startY = fromNode.y + offsetY;\n      const endX = toNode.x - offsetX;\n      const endY = toNode.y - offsetY;\n\n      ctx.strokeStyle = '#333';\n      ctx.fillStyle = '#333';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(startX, startY);\n      ctx.lineTo(endX, endY);\n      ctx.stroke();\n\n      if(graphType === 'directed') {\n        drawArrowhead(ctx, startX, startY, endX, endY, 10);\n      }\n    });\n\n    // If dragging new edge, draw temporary line\n    if(draggingEdge) {\n      const fromNode = draggingEdge.fromNode;\n      const dx = mouseX - fromNode.x;\n      const dy = mouseY - fromNode.y;\n      const dist = Math.sqrt(dx*dx + dy*dy);\n      const offsetX = (dx / dist) * nodeRadius;\n      const offsetY = (dy / dist) * nodeRadius;\n      ctx.strokeStyle = '#666';\n      ctx.fillStyle = '#666';\n      ctx.lineWidth = 2;\n      ctx.setLineDash([5,5]);\n      ctx.beginPath();\n      ctx.moveTo(fromNode.x + offsetX, fromNode.y + offsetY);\n      ctx.lineTo(mouseX, mouseY);\n      ctx.stroke();\n      ctx.setLineDash([]);\n      if(graphType === 'directed') {\n        drawArrowhead(ctx, fromNode.x + offsetX, fromNode.y + offsetY, mouseX, mouseY, 10);\n      }\n    }\n\n    // Draw nodes\n    nodes.forEach(node => {\n      ctx.beginPath();\n      ctx.fillStyle = '#1E90FF';\n      ctx.strokeStyle = '#005fbb';\n      ctx.lineWidth = 3;\n      ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n\n      // Draw node ID number\n      ctx.fillStyle = '#fff';\n      ctx.font = 'bold 14px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(node.id, node.x, node.y);\n    });\n  }\n\n  // Add node handler\n  function onCanvasClick(e) {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    if(addingNode) {\n      // Place new node\n      nodes.push({\n        id: ++nodeIdCounter,\n        x: x,\n        y: y\n      });\n      addingNode = false;\n      addNodeBtn.disabled = false;\n      draw();\n    }\n  }\n\n  // Mouse down: check if on node to start dragging edge\n  function onMouseDown(e) {\n    if(addingNode) return; // disable dragging while adding node\n    const rect = canvas.getBoundingClientRect();\n    mouseX = e.clientX - rect.left;\n    mouseY = e.clientY - rect.top;\n\n    const node = findNodeAt(mouseX, mouseY);\n    if(node) {\n      dragStartNode = node;\n      draggingEdge = { fromNode: node };\n      canvas.style.cursor = 'crosshair';\n    }\n  }\n\n  // Mouse move: update dragging edge line or cursor\n  function onMouseMove(e) {\n    const rect = canvas.getBoundingClientRect();\n    mouseX = e.clientX - rect.left;\n    mouseY = e.clientY - rect.top;\n\n    if(draggingEdge) {\n      draw();\n    } else {\n      // Hover effect: pointer if on node\n      const node = findNodeAt(mouseX, mouseY);\n      canvas.style.cursor = node ? 'pointer' : (addingNode ? 'crosshair' : 'default');\n    }\n  }\n\n  // Mouse up: finalize edge if released over another node\n  function onMouseUp(e) {\n    if(draggingEdge) {\n      const rect = canvas.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n      const targetNode = findNodeAt(x, y);\n      if(targetNode && targetNode.id !== dragStartNode.id) {\n        // Add edge (avoid duplicates)\n        const edgeExists = edges.some(edge => {\n          if(graphType === 'undirected') {\n            return (edge.from === dragStartNode.id && edge.to === targetNode.id) ||\n                   (edge.to === dragStartNode.id && edge.from === targetNode.id);\n          } else {\n            return edge.from === dragStartNode.id && edge.to === targetNode.id;\n          }\n        });\n        if(!edgeExists) {\n          edges.push({\n            from: dragStartNode.id,\n            to: targetNode.id\n          });\n        }\n      }\n      draggingEdge = null;\n      dragStartNode = null;\n      canvas.style.cursor = 'default';\n      draw();\n    }\n  }\n\n  // Clear graph\n  function clearGraph() {\n    nodes = [];\n    edges = [];\n    nodeIdCounter = 0;\n    draw();\n  }\n\n  // Event handlers for buttons and radios\n  addNodeBtn.onclick = () => {\n    addingNode = true;\n    addNodeBtn.disabled = true;\n    canvas.style.cursor = 'crosshair';\n  };\n\n  clearBtn.onclick = () => {\n    clearGraph();\n  };\n\n  graphTypeRadios.forEach(radio => {\n    radio.addEventListener('change', e => {\n      graphType = e.target.value;\n      draw();\n    });\n  });\n\n  // Canvas event listeners\n  canvas.addEventListener('click', onCanvasClick);\n  canvas.addEventListener('mousedown', onMouseDown);\n  canvas.addEventListener('mousemove', onMouseMove);\n  canvas.addEventListener('mouseup', onMouseUp);\n  canvas.addEventListener('mouseleave', () => {\n    if(draggingEdge) {\n      draggingEdge = null;\n      dragStartNode = null;\n      canvas.style.cursor = 'default';\n      draw();\n    }\n  });\n\n  // Initial draw\n  draw();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}