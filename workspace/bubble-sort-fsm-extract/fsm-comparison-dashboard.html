<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FSM Comparison Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
      }

      .dashboard {
        max-width: 1600px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        color: white;
        margin-bottom: 30px;
      }

      .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .header p {
        font-size: 1.2em;
        opacity: 0.9;
      }

      .fsm-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .fsm-card {
        background: white;
        border-radius: 15px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        padding: 20px;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }

      .fsm-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 12px 35px rgba(0, 0, 0, 0.15);
      }

      .ideal-fsm {
        border-left: 6px solid #4caf50;
        background: linear-gradient(145deg, #ffffff 0%, #f0f8f0 100%);
      }

      .extracted-fsm {
        border-left: 6px solid #2196f3;
        background: linear-gradient(145deg, #ffffff 0%, #f0f6ff 100%);
      }

      .ideal-fsm .fsm-title {
        color: #2e7d32;
      }

      .extracted-fsm .fsm-title {
        color: #1565c0;
      }

      .fsm-title {
        font-size: 1.3em;
        font-weight: bold;
        color: #333;
        margin-bottom: 10px;
        border-bottom: 2px solid #e0e0e0;
        padding-bottom: 8px;
      }

      .fsm-meta {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-bottom: 15px;
        font-size: 0.9em;
      }

      .meta-item {
        display: flex;
        justify-content: space-between;
        padding: 5px 0;
      }

      .meta-label {
        font-weight: bold;
        color: #666;
      }

      .meta-value {
        color: #333;
      }

      .fsm-graph {
        width: 100%;
        height: 400px;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        background: #fafafa;
      }

      .comparison-panel {
        background: white;
        border-radius: 15px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        padding: 25px;
        margin-top: 30px;
      }

      .comparison-title {
        font-size: 1.5em;
        color: #333;
        margin-bottom: 20px;
        text-align: center;
      }

      .comparison-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
      }

      .comparison-item {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        border-left: 4px solid #007bff;
      }

      .comparison-item h4 {
        margin: 0 0 10px 0;
        color: #333;
      }

      .comparison-stats {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
        text-align: center;
      }

      .stat-box {
        background: white;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #e0e0e0;
      }

      .stat-number {
        font-size: 2em;
        font-weight: bold;
        color: #007bff;
      }

      .stat-label {
        font-size: 0.9em;
        color: #666;
        margin-top: 5px;
      }

      .controls {
        text-align: center;
        margin-bottom: 20px;
      }

      .btn {
        background: #007bff;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 25px;
        cursor: pointer;
        margin: 0 10px;
        font-size: 1em;
        transition: background 0.3s ease;
      }

      .btn:hover {
        background: #0056b3;
      }

      .success-message {
        background: #d4edda;
        color: #155724;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        border: 1px solid #c3e6cb;
      }

      .error-message {
        background: #f8d7da;
        color: #721c24;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        border: 1px solid #f5c6cb;
      }

      /* D3 Graph Styles */
      .node {
        cursor: pointer;
        stroke-width: 2px;
      }

      .node-idle {
        fill: #4caf50;
        stroke: #2e7d32;
      }
      .node-atomic {
        fill: #2196f3;
        stroke: #1565c0;
      }
      .node-composite {
        fill: #ff9800;
        stroke: #ef6c00;
      }
      .node-error {
        fill: #f44336;
        stroke: #c62828;
      }

      .node-label {
        font-family: Arial, sans-serif;
        font-size: 10px;
        font-weight: bold;
        text-anchor: middle;
        dominant-baseline: central;
        fill: white;
        pointer-events: none;
      }

      .link {
        stroke: #666;
        stroke-width: 1.5px;
        fill: none;
        marker-end: url(#arrowhead);
      }

      .link-label {
        font-family: Arial, sans-serif;
        font-size: 8px;
        fill: #333;
        text-anchor: middle;
      }

      .tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        pointer-events: none;
        font-size: 12px;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.2s;
      }

      @media (max-width: 768px) {
        .fsm-grid {
          grid-template-columns: 1fr;
        }

        .comparison-grid {
          grid-template-columns: 1fr;
        }

        .comparison-stats {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="dashboard">
      <div class="header">
        <h1>üîÑ FSM Comparison Dashboard</h1>
        <p>Compare and Visualize Multiple Finite State Machines</p>
      </div>

      <div class="controls">
        <button class="btn" onclick="loadAllFSMs()">üîÑ Load All FSMs</button>
        <button class="btn" onclick="resetAllViews()">
          üéØ Reset All Views
        </button>
        <button class="btn" onclick="exportAllGraphs()">
          üíæ Export All Graphs
        </button>
        <button class="btn" onclick="refreshFSMList()">
          üîç Scan FSM Folder
        </button>
      </div>

      <div
        id="loadingIndicator"
        style="display: none; text-align: center; color: white; margin: 10px 0"
      >
        <p>üîç Scanning /fsm folder for extracted FSM files...</p>
      </div>

      <div id="messageArea"></div>

      <div id="fsmGrid" class="fsm-grid">
        <!-- FSM cards will be dynamically populated -->
      </div>

      <div class="comparison-panel">
        <div class="comparison-title">üìä Comparative Analysis</div>
        <div id="comparisonContent">
          <!-- Comparison data will be populated here -->
        </div>
      </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
      class FSMComparisonDashboard {
        constructor() {
          this.fsms = new Map();
          this.visualizers = new Map();
          this.tooltip = d3.select("#tooltip");
          this.fsmDefinitions = [];

          this.initializeIdealFSM();
          this.scanAndLoadExtractedFSMs();
        }

        initializeIdealFSM() {
          // Add the ideal FSM as the reference
          this.fsmDefinitions = [
            {
              id: "ideal",
              title: "üìã Ideal FSM (Reference)",
              description: "Binary Search Tree - Educational Template",
              isIdeal: true,
              data: {
                meta: {
                  concept: "BubbleSort",
                  topic: "Simple Bubble Sort Demonstration",
                  educational_goal:
                    "Show how bubble sort compares and swaps adjacent elements",
                  expected_interactions: ["input_array", "start_sort", "reset"],
                },
                states: [
                  {
                    id: "S0_Idle",
                    label: "Idle",
                    type: "idle",
                    entry_actions: ["showInputField()", "enableControls()"],
                    exit_actions: [],
                  },
                  {
                    id: "S1_ArrayReady",
                    label: "ArrayReady",
                    type: "atomic",
                    entry_actions: ["renderArray()", "enableSortButton()"],
                    exit_actions: [],
                  },
                  {
                    id: "S2_Comparing",
                    label: "Comparing",
                    type: "atomic",
                    entry_actions: ["highlightPair()", "showComparison()"],
                    exit_actions: ["removeHighlight()"],
                  },
                  {
                    id: "S3_Swapping",
                    label: "Swapping",
                    type: "atomic",
                    entry_actions: ["animateSwap()", "updateArray()"],
                    exit_actions: [],
                  },
                  {
                    id: "S4_PassComplete",
                    label: "PassComplete",
                    type: "atomic",
                    entry_actions: ["markSorted()", "checkIfDone()"],
                    exit_actions: [],
                  },
                  {
                    id: "S5_SortComplete",
                    label: "SortComplete",
                    type: "atomic",
                    entry_actions: ["showSuccess()", "enableReset()"],
                    exit_actions: [],
                  },
                ],
                events: [
                  {
                    id: "arrayInputEntered",
                    event_type: "user_input",
                    description: "User enters array values",
                  },
                  {
                    id: "startButtonClicked",
                    event_type: "user_action",
                    description: "User clicks start sorting",
                  },
                  {
                    id: "resetButtonClicked",
                    event_type: "user_action",
                    description: "User clicks reset",
                  },
                  {
                    id: "comparisonDone",
                    event_type: "system_event",
                    description: "Comparison of two elements complete",
                  },
                  {
                    id: "swapDone",
                    event_type: "system_event",
                    description: "Element swap animation complete",
                  },
                  {
                    id: "passFinished",
                    event_type: "system_event",
                    description: "One pass through array complete",
                  },
                  {
                    id: "sortingFinished",
                    event_type: "system_event",
                    description: "All elements are sorted",
                  },
                ],
                transitions: [
                  {
                    from: "S0_Idle",
                    to: "S1_ArrayReady",
                    event: "arrayInputEntered",
                    guard: "validInput",
                    actions: ["parseArray()", "visualizeArray()"],
                    expected_observables: ["visual:arrayDisplayed"],
                    timeout: 1000,
                  },
                  {
                    from: "S1_ArrayReady",
                    to: "S2_Comparing",
                    event: "startButtonClicked",
                    guard: "arrayNotEmpty",
                    actions: ["startBubbleSort()", "selectFirstPair()"],
                    expected_observables: ["visual:sortingStarted"],
                    timeout: 500,
                  },
                  {
                    from: "S2_Comparing",
                    to: "S3_Swapping",
                    event: "comparisonDone",
                    guard: "needsSwap",
                    actions: ["swapElements()"],
                    expected_observables: ["visual:elementsSwapped"],
                    timeout: 1000,
                  },
                  {
                    from: "S2_Comparing",
                    to: "S2_Comparing",
                    event: "comparisonDone",
                    guard: "noSwapNeeded",
                    actions: ["moveToNextPair()"],
                    expected_observables: ["visual:nextComparison"],
                    timeout: 500,
                  },
                  {
                    from: "S3_Swapping",
                    to: "S2_Comparing",
                    event: "swapDone",
                    guard: "moreComparisons",
                    actions: ["moveToNextPair()"],
                    expected_observables: ["visual:nextComparison"],
                    timeout: 500,
                  },
                  {
                    from: "S2_Comparing",
                    to: "S4_PassComplete",
                    event: "passFinished",
                    guard: "passEnded",
                    actions: ["completeBubblePass()"],
                    expected_observables: ["visual:passCompleted"],
                    timeout: 800,
                  },
                  {
                    from: "S3_Swapping",
                    to: "S4_PassComplete",
                    event: "passFinished",
                    guard: "passEnded",
                    actions: ["completeBubblePass()"],
                    expected_observables: ["visual:passCompleted"],
                    timeout: 800,
                  },
                  {
                    from: "S4_PassComplete",
                    to: "S2_Comparing",
                    event: "passFinished",
                    guard: "morePassesNeeded",
                    actions: ["startNextPass()"],
                    expected_observables: ["visual:nextPassStarted"],
                    timeout: 1000,
                  },
                  {
                    from: "S4_PassComplete",
                    to: "S5_SortComplete",
                    event: "sortingFinished",
                    guard: "allSorted",
                    actions: ["celebrateCompletion()"],
                    expected_observables: ["visual:sortCompleted"],
                    timeout: 2000,
                  },
                  {
                    from: "S5_SortComplete",
                    to: "S0_Idle",
                    event: "resetButtonClicked",
                    guard: "true",
                    actions: ["clearVisualization()", "resetState()"],
                    expected_observables: ["visual:reset"],
                    timeout: 500,
                  },
                  {
                    from: "S1_ArrayReady",
                    to: "S0_Idle",
                    event: "resetButtonClicked",
                    guard: "true",
                    actions: ["clearArray()", "resetControls()"],
                    expected_observables: ["visual:reset"],
                    timeout: 500,
                  },
                ],
                components: [
                  "array_input",
                  "start_button",
                  "reset_button",
                  "array_visualization",
                ],
              },
            },
          ];
        }

        async scanAndLoadExtractedFSMs() {
          const loadingIndicator = document.getElementById("loadingIndicator");
          const messageArea = document.getElementById("messageArea");
          loadingIndicator.style.display = "block";

          try {
            // Try to load the overall analysis report first to get the list of analyzed files
            const overallReportResponse = await fetch(
              "./fsm/overall_analysis_report.json"
            );

            if (overallReportResponse.ok) {
              const overallReport = await overallReportResponse.json();
              await this.loadFSMsFromReport(overallReport);
              messageArea.innerHTML = `<div class="success-message">‚úÖ Loaded ${
                this.fsmDefinitions.length - 1
              } extracted FSMs from analysis report</div>`;
            } else {
              // Fallback: try to load from known folders
              await this.loadFSMsFromKnownFolders();
              messageArea.innerHTML = `<div class="success-message">‚úÖ Loaded ${
                this.fsmDefinitions.length - 1
              } FSMs using fallback method</div>`;
            }
          } catch (error) {
            console.log("Using fallback method to load FSMs:", error);
            await this.loadFSMsFromKnownFolders();
            messageArea.innerHTML = `<div class="error-message">‚ö†Ô∏è Used fallback loading method. Some FSMs may be missing.</div>`;
          } finally {
            loadingIndicator.style.display = "none";
          }
        }

        async loadFSMsFromReport(overallReport) {
          console.log("üìä Loading FSMs from overall analysis report...");

          const successfulFiles =
            overallReport.file_details?.filter(
              (f) => f.status === "analyzed" && f.states > 0
            ) || [];

          console.log(`Found ${successfulFiles.length} analyzed FSMs`);

          for (const fileDetail of successfulFiles) {
            try {
              const htmlFileName = fileDetail.file.replace(".html", "");
              const fsmPath = `./fsm/${htmlFileName}/extracted_fsm.json`;
              const analysisPath = `./fsm/${htmlFileName}/analysis_report.json`;

              // Load the extracted FSM
              const fsmResponse = await fetch(fsmPath);
              if (!fsmResponse.ok) continue;

              const extractedFSM = await fsmResponse.json();

              // Try to load analysis report for additional metadata
              let analysisReport = null;
              try {
                const analysisResponse = await fetch(analysisPath);
                if (analysisResponse.ok) {
                  analysisReport = await analysisResponse.json();
                }
              } catch (e) {
                console.log(`No analysis report for ${htmlFileName}`);
              }

              // Create FSM definition
              const fsmDef = {
                id: htmlFileName,
                title: `ü§ñ Extracted FSM - ${htmlFileName.substring(0, 12)}...`,
                description: `Auto-extracted from ${fileDetail.file} (${fileDetail.states} states, ${fileDetail.transitions} transitions)`,
                isExtracted: true,
                htmlFile: fileDetail.file,
                data: extractedFSM,
                analysis: analysisReport,
                stats: {
                  states: fileDetail.states,
                  transitions: fileDetail.transitions,
                  components: fileDetail.components,
                  state_coverage: fileDetail.state_coverage,
                  transition_coverage: fileDetail.transition_coverage,
                },
              };

              this.fsmDefinitions.push(fsmDef);
              console.log(`‚úÖ Loaded FSM: ${htmlFileName}`);
            } catch (error) {
              console.error(
                `‚ùå Failed to load FSM for ${fileDetail.file}:`,
                error
              );
            }
          }
        }

        async loadFSMsFromKnownFolders() {
          console.log("üìÅ Loading FSMs from known folders...");

          // Known extracted FSM folders based on the attached data
          const knownFolders = [
            "5d7c31e0-bf4e-11f0-9d64-ab1079f525e7",
            "5d8dd330-bf50-11f0-9278-a57cfa0a44e5",
            "9e580470-bf51-11f0-8ac4-79272b6a78b2",
            "fad12780-bf52-11f0-bc20-193729720a40",
          ];

          for (const folderId of knownFolders) {
            try {
              const fsmPath = `./fsm/${folderId}/extracted_fsm.json`;
              const analysisPath = `./fsm/${folderId}/analysis_report.json`;

              const fsmResponse = await fetch(fsmPath);
              if (!fsmResponse.ok) continue;

              const extractedFSM = await fsmResponse.json();

              // Try to load analysis report
              let analysisReport = null;
              try {
                const analysisResponse = await fetch(analysisPath);
                if (analysisResponse.ok) {
                  analysisReport = await analysisResponse.json();
                }
              } catch (e) {
                console.log(`No analysis report for ${folderId}`);
              }

              const fsmDef = {
                id: folderId,
                title: `ü§ñ Extracted FSM - ${folderId.substring(0, 8)}...`,
                description: `Auto-extracted FSM (${
                  extractedFSM.states?.length || 0
                } states, ${
                  extractedFSM.transitions?.length || 0
                } transitions)`,
                isExtracted: true,
                data: extractedFSM,
                analysis: analysisReport,
              };

              this.fsmDefinitions.push(fsmDef);
              console.log(`‚úÖ Loaded FSM: ${folderId}`);
            } catch (error) {
              console.error(`‚ùå Failed to load FSM ${folderId}:`, error);
            }
          }
        }

        createFSMCard(fsmDef) {
          const meta = fsmDef.data.meta || {};
          const stats = this.calculateStats(fsmDef.data);

          // Special handling for ideal vs extracted FSMs
          const cardClass = fsmDef.isIdeal
            ? "fsm-card ideal-fsm"
            : "fsm-card extracted-fsm";
          const titleIcon = fsmDef.isIdeal ? "üìã" : "ü§ñ";

          // Add coverage information if available
          let coverageInfo = "";
          if (
            fsmDef.stats &&
            (fsmDef.stats.state_coverage || fsmDef.stats.transition_coverage)
          ) {
            coverageInfo = `
                    <div class="meta-item">
                      <span class="meta-label">State Coverage:</span>
                      <span class="meta-value">${(
                        (fsmDef.stats.state_coverage || 0) * 100
                      ).toFixed(1)}%</span>
                    </div>
                    <div class="meta-item">
                      <span class="meta-label">Transition Coverage:</span>
                      <span class="meta-value">${(
                        (fsmDef.stats.transition_coverage || 0) * 100
                      ).toFixed(1)}%</span>
                    </div>
                  `;
          }

          // Add extraction timestamp if available
          let timestampInfo = "";
          if (meta.timestamp) {
            const date = new Date(meta.timestamp);
            timestampInfo = `
                    <div class="meta-item">
                      <span class="meta-label">Extracted:</span>
                      <span class="meta-value">${date.toLocaleDateString()} ${date.toLocaleTimeString()}</span>
                    </div>
                  `;
          }

          return `
                          <div class="${cardClass}" id="card-${fsmDef.id}">
                              <div class="fsm-title">${titleIcon} ${
            fsmDef.title
          }</div>
                              <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">${
                                fsmDef.description
                              }</p>

                              <div class="fsm-meta">
                                  <div class="meta-item">
                                      <span class="meta-label">Concept:</span>
                                      <span class="meta-value">${
                                        meta.concept || "N/A"
                                      }</span>
                                  </div>
                                  <div class="meta-item">
                                      <span class="meta-label">Method:</span>
                                      <span class="meta-value">${
                                        meta.extraction_method || "Manual"
                                      }</span>
                                  </div>
                                  <div class="meta-item">
                                      <span class="meta-label">States:</span>
                                      <span class="meta-value">${
                                        stats.states
                                      }</span>
                                  </div>
                                  <div class="meta-item">
                                      <span class="meta-label">Events:</span>
                                      <span class="meta-value">${
                                        stats.events
                                      }</span>
                                  </div>
                                  <div class="meta-item">
                                      <span class="meta-label">Transitions:</span>
                                      <span class="meta-value">${
                                        stats.transitions
                                      }</span>
                                  </div>
                                  <div class="meta-item">
                                      <span class="meta-label">Components:</span>
                                      <span class="meta-value">${
                                        stats.components
                                      }</span>
                                  </div>
                                  ${coverageInfo}
                                  ${timestampInfo}
                              </div>

                              <svg class="fsm-graph" id="graph-${
                                fsmDef.id
                              }"></svg>
                          </div>
                      `;
        }

        calculateStats(fsm) {
          return {
            states: fsm.states?.length || 0,
            events: fsm.events?.length || 0,
            transitions: fsm.transitions?.length || 0,
            components: fsm.components ? fsm.components.length : 0,
          };
        }

        visualizeFSM(fsmId, fsm) {
          const svg = d3.select(`#graph-${fsmId}`);
          const width = 480;
          const height = 400;

          svg.selectAll("*").remove();

          // Add arrow marker
          svg
            .append("defs")
            .append("marker")
            .attr("id", `arrowhead-${fsmId}`)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 20)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .style("fill", "#666");

          const container = svg.append("g");

          // Prepare data
          const nodes =
            fsm.states?.map((state) => ({
              id: state.id,
              label: state.label || state.id,
              type: state.type || "atomic",
              ...state,
            })) || [];

          const links =
            fsm.transitions?.map((transition) => ({
              source: transition.from,
              target: transition.to,
              event: transition.event,
              ...transition,
            })) || [];

          // Create force simulation
          const simulation = d3
            .forceSimulation(nodes)
            .force(
              "link",
              d3
                .forceLink(links)
                .id((d) => d.id)
                .distance(80)
            )
            .force("charge", d3.forceManyBody().strength(-200))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide(25));

          // Create links
          const link = container
            .selectAll(".link")
            .data(links)
            .join("path")
            .attr("class", "link")
            .attr("marker-end", `url(#arrowhead-${fsmId})`);

          // Create link labels
          const linkLabel = container
            .selectAll(".link-label")
            .data(links)
            .join("text")
            .attr("class", "link-label")
            .text((d) =>
              d.event
                ? d.event
                    .replace("UserClick", "C:")
                    .replace("UserFill", "F:")
                    .replace("Fill", "")
                : "T"
            );

          // Create nodes
          const node = container
            .selectAll(".node")
            .data(nodes)
            .join("circle")
            .attr("class", (d) => `node node-${d.type}`)
            .attr("r", 20)
            .on("mouseover", (event, d) => this.showTooltip(event, d))
            .on("mouseout", () => this.hideTooltip());

          // Create node labels
          const nodeLabel = container
            .selectAll(".node-label")
            .data(nodes)
            .join("text")
            .attr("class", "node-label")
            .text((d) =>
              d.label.length > 8 ? d.label.substring(0, 8) + "..." : d.label
            );

          // Update positions on simulation tick
          simulation.on("tick", () => {
            link.attr("d", (d) => {
              const dx = d.target.x - d.source.x;
              const dy = d.target.y - d.source.y;
              const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
              return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
            });

            linkLabel
              .attr("x", (d) => (d.source.x + d.target.x) / 2)
              .attr("y", (d) => (d.source.y + d.target.y) / 2);

            node
              .attr("cx", (d) => Math.max(20, Math.min(width - 20, d.x)))
              .attr("cy", (d) => Math.max(20, Math.min(height - 20, d.y)));

            nodeLabel
              .attr("x", (d) => Math.max(20, Math.min(width - 20, d.x)))
              .attr("y", (d) => Math.max(20, Math.min(height - 20, d.y)));
          });

          this.visualizers.set(fsmId, { svg, simulation });
        }

        showTooltip(event, state) {
          this.tooltip
            .style("opacity", 1)
            .html(
              `
                              <strong>${state.label}</strong><br>
                              Type: ${state.type}<br>
                              ID: ${state.id}<br>
                              Entry: ${
                                (state.entry_actions || []).length
                              } actions<br>
                              Exit: ${(state.exit_actions || []).length} actions
                          `
            )
            .style("left", event.pageX + 10 + "px")
            .style("top", event.pageY - 10 + "px");
        }

        hideTooltip() {
          this.tooltip.style("opacity", 0);
        }

        generateComparison() {
          const allStats = this.fsmDefinitions.map((fsm) => ({
            name: fsm.title,
            ...this.calculateStats(fsm.data),
          }));

          const totalStats = allStats.reduce(
            (acc, stats) => ({
              states: acc.states + stats.states,
              events: acc.events + stats.events,
              transitions: acc.transitions + stats.transitions,
              components: acc.components + stats.components,
            }),
            { states: 0, events: 0, transitions: 0, components: 0 }
          );

          return `
                          <div class="comparison-stats">
                              <div class="stat-box">
                                  <div class="stat-number">${
                                    totalStats.states
                                  }</div>
                                  <div class="stat-label">Total States</div>
                              </div>
                              <div class="stat-box">
                                  <div class="stat-number">${
                                    totalStats.transitions
                                  }</div>
                                  <div class="stat-label">Total Transitions</div>
                              </div>
                              <div class="stat-box">
                                  <div class="stat-number">${
                                    totalStats.events
                                  }</div>
                                  <div class="stat-label">Total Events</div>
                              </div>
                          </div>

                          <div class="comparison-grid" style="margin-top: 20px;">
                              ${allStats
                                .map(
                                  (stats) => `
                                  <div class="comparison-item">
                                      <h4>${stats.name}</h4>
                                      <p><strong>States:</strong> ${stats.states}</p>
                                      <p><strong>Events:</strong> ${stats.events}</p>
                                      <p><strong>Transitions:</strong> ${stats.transitions}</p>
                                      <p><strong>Components:</strong> ${stats.components}</p>
                                  </div>
                              `
                                )
                                .join("")}
                          </div>
                      `;
        }

        render() {
          const fsmGrid = document.getElementById("fsmGrid");
          const comparisonContent =
            document.getElementById("comparisonContent");

          // Render FSM cards
          fsmGrid.innerHTML = this.fsmDefinitions
            .map((fsm) => this.createFSMCard(fsm))
            .join("");

          // Render comparison
          comparisonContent.innerHTML = this.generateComparison();

          // Initialize visualizations
          this.fsmDefinitions.forEach((fsmDef) => {
            this.fsms.set(fsmDef.id, fsmDef.data);
            setTimeout(() => {
              this.visualizeFSM(fsmDef.id, fsmDef.data);
            }, 100);
          });
        }
      }

      // Global functions
      function loadAllFSMs() {
        if (window.dashboard) {
          window.dashboard.render();
        }
      }

      function refreshFSMList() {
        if (window.dashboard) {
          const messageArea = document.getElementById("messageArea");
          messageArea.innerHTML = `<div class="success-message">üîÑ Refreshing FSM list...</div>`;

          // Clear current extracted FSMs but keep ideal FSM
          window.dashboard.fsmDefinitions =
            window.dashboard.fsmDefinitions.filter((fsm) => fsm.isIdeal);

          // Re-scan for extracted FSMs
          window.dashboard.scanAndLoadExtractedFSMs().then(() => {
            window.dashboard.render();
          });
        }
      }

      function resetAllViews() {
        if (window.dashboard) {
          window.dashboard.fsmDefinitions.forEach((fsmDef) => {
            const visualizer = window.dashboard.visualizers.get(fsmDef.id);
            if (visualizer && visualizer.simulation) {
              visualizer.simulation.alpha(1).restart();
            }
          });
        }
      }

      function exportAllGraphs() {
        window.dashboard.fsmDefinitions.forEach((fsmDef) => {
          const svg = document.querySelector(`#graph-${fsmDef.id}`);
          const serializer = new XMLSerializer();
          const svgString = serializer.serializeToString(svg);

          const blob = new Blob([svgString], { type: "image/svg+xml" });
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = `fsm-${fsmDef.id}-${Date.now()}.svg`;
          a.click();

          URL.revokeObjectURL(url);
        });
      }

      // Initialize dashboard when DOM loads
      document.addEventListener("DOMContentLoaded", () => {
        window.dashboard = new FSMComparisonDashboard();
        window.dashboard.render();
      });
    </script>
  </body>
</html>
