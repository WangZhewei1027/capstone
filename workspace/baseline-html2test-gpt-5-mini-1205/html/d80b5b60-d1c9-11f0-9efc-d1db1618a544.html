<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Dijkstra's Algorithm Interactive Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:0}
  body{display:flex;flex-direction:column;height:100vh;gap:8px;background:#f5f7fb;color:#111;margin:0;padding:12px;}
  header{display:flex;align-items:center;gap:12px}
  h1{font-size:18px;margin:0}
  #app{display:flex;flex:1;gap:12px;min-height:0}
  #canvasPane{flex:1; background:white;border:1px solid #d8dbe0;border-radius:8px;position:relative;overflow:hidden}
  svg{width:100%;height:100%;display:block}
  .controls{width:360px;display:flex;flex-direction:column;gap:8px}
  .panel{background:white;border:1px solid #d8dbe0;border-radius:8px;padding:12px;overflow:auto;max-height:60vh}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button{background:#1f6feb;color:white;border:0;padding:8px 10px;border-radius:6px;cursor:pointer}
  button.secondary{background:#e6eefc;color:#1f2a44}
  button.warn{background:#ff6b6b}
  .modeBtn{background:#eaf1ff;color:#1f2a44;border:1px solid #d0e0ff}
  select,input[type=number]{padding:6px;border-radius:6px;border:1px solid #cfd8e3}
  .small{font-size:13px;padding:6px 8px}
  .instructions{font-size:13px;color:#445;line-height:1.2}
  #log{font-family:monospace;font-size:12px;height:150px;overflow:auto;background:#0f1720;color:#e6fffa;padding:8px;border-radius:6px}
  .nodeCircle{stroke:#1f2a44;stroke-width:1.5px;cursor:pointer}
  .edgeLine{stroke:#9aa6b2;stroke-width:2px;cursor:default}
  .edgeWeight{fill:#1f2a44;font-size:12px;user-select:none}
  .nodeLabel{fill:white;font-weight:600;pointer-events:none;font-size:12px}
  .distLabel{font-family:monospace;font-size:11px;fill:#072044;pointer-events:none}
  .visited{fill:#94d4a4}
  .current{fill:#ffd47a}
  .frontier{fill:#9ec5ff}
  .unvisited{fill:#d1d9e6}
  .arrow{fill:#9aa6b2}
  .smallMuted{font-size:12px;color:#556}
  table{width:100%;border-collapse:collapse}
  th,td{padding:6px;border-bottom:1px solid #eef2f7;text-align:left;font-size:13px}
  #pqList{font-family:monospace;font-size:13px;background:#fff;padding:8px;border-radius:6px;border:1px solid #e6eefc;height:100px;overflow:auto}
  .kbd{background:#f1f5f9;border-radius:4px;padding:2px 6px;font-size:12px;border:1px solid #e2e8f0}
  footer{font-size:12px;color:#466;padding-top:4px}
</style>
</head>
<body>
<header>
  <h1>Dijkstra's Algorithm — Interactive Demo</h1>
  <div class="smallMuted">Create a graph, pick a start node, and step through the algorithm.</div>
</header>

<div id="app">
  <div id="canvasPane">
    <svg id="svg"></svg>
  </div>

  <div class="controls">
    <div class="panel">
      <div class="row">
        <button id="modeAddNode" class="modeBtn">Add Node</button>
        <button id="modeAddEdge" class="modeBtn">Add Edge</button>
        <button id="modeDrag" class="modeBtn">Move</button>
        <button id="modeDelete" class="modeBtn">Delete</button>
      </div>
      <div class="row" style="margin-top:8px">
        <label class="smallMuted">Start:</label>
        <select id="startSelect"></select>
        <label class="smallMuted">Target (optional):</label>
        <select id="targetSelect">
          <option value="">None</option>
        </select>
      </div>

      <div style="border-top:1px dashed #eef2f7;margin-top:8px;padding-top:8px">
        <div class="row">
          <button id="stepBtn">Step</button>
          <button id="runBtn">Auto</button>
          <button id="pauseBtn" class="secondary">Pause</button>
          <button id="resetBtn" class="secondary">Reset</button>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="clearBtn" class="warn">Clear Graph</button>
          <button id="exampleBtn" class="secondary">Load Example Graph</button>
        </div>
      </div>

      <div style="border-top:1px dashed #eef2f7;margin-top:8px;padding-top:8px">
        <div class="smallMuted">Edge creation: click source then target and enter non-negative weight.</div>
        <div class="smallMuted">You can drag nodes to reposition them. When ready, choose a start and run.</div>
        <div style="margin-top:8px" class="row">
          <label class="smallMuted">Auto delay (ms):</label>
          <input id="delayInput" type="number" value="700" min="50" style="width:80px"/>
        </div>
      </div>
    </div>

    <div class="panel">
      <div style="font-weight:600">Algorithm State</div>
      <div class="row" style="margin-top:8px">
        <div style="flex:1">
          <div class="smallMuted">Distances and predecessors</div>
          <table id="stateTable">
            <thead><tr><th>Node</th><th>Dist</th><th>Prev</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div style="margin-top:8px">
        <div class="smallMuted">Priority Queue (min by dist)</div>
        <div id="pqList"></div>
      </div>

      <div style="margin-top:8px">
        <div class="smallMuted">Console / Log</div>
        <div id="log"></div>
      </div>
    </div>
  </div>
</div>

<footer>Click "Add Node" then click canvas to add nodes. Use "Add Edge" then click source and target to create edges with weights. Dijkstra requires non-negative weights.</footer>

<script>
(() => {
  // Utilities
  const svg = document.getElementById('svg');
  const NS = "http://www.w3.org/2000/svg";
  const addNodeBtn = document.getElementById('modeAddNode');
  const addEdgeBtn = document.getElementById('modeAddEdge');
  const moveBtn = document.getElementById('modeDrag');
  const delBtn = document.getElementById('modeDelete');
  const stepBtn = document.getElementById('stepBtn');
  const runBtn = document.getElementById('runBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const clearBtn = document.getElementById('clearBtn');
  const exampleBtn = document.getElementById('exampleBtn');
  const startSelect = document.getElementById('startSelect');
  const targetSelect = document.getElementById('targetSelect');
  const stateTableBody = document.querySelector('#stateTable tbody');
  const pqList = document.getElementById('pqList');
  const logEl = document.getElementById('log');
  const delayInput = document.getElementById('delayInput');

  let mode = 'move'; // addNode, addEdge, move, delete
  const setMode = m => {
    mode = m;
    [addNodeBtn, addEdgeBtn, moveBtn, delBtn].forEach(b => b.classList.remove('modeBtnActive'));
    if(m==='addNode') addNodeBtn.classList.add('modeBtnActive');
    if(m==='addEdge') addEdgeBtn.classList.add('modeBtnActive');
    if(m==='move') moveBtn.classList.add('modeBtnActive');
    if(m==='delete') delBtn.classList.add('modeBtnActive');
  };
  setMode('move');

  addNodeBtn.onclick = ()=>setMode('addNode');
  addEdgeBtn.onclick = ()=>setMode('addEdge');
  moveBtn.onclick = ()=>setMode('move');
  delBtn.onclick = ()=>setMode('delete');

  // Graph data
  let nodes = []; // {id,x,y,label}
  let edges = []; // {id,from,to,weight}
  let nextNodeId = 1, nextEdgeId = 1;

  // SVG groups
  const defs = document.createElementNS(NS,'defs');
  svg.appendChild(defs);
  // arrow marker
  const marker = document.createElementNS(NS,'marker');
  marker.setAttribute('id','arrow');
  marker.setAttribute('viewBox','0 0 10 10');
  marker.setAttribute('markerWidth','6');
  marker.setAttribute('markerHeight','6');
  marker.setAttribute('refX','10');
  marker.setAttribute('refY','5');
  marker.setAttribute('orient','auto-start-reverse');
  const path = document.createElementNS(NS,'path');
  path.setAttribute('d','M 0 0 L 10 5 L 0 10 z');
  path.setAttribute('fill','#9aa6b2');
  marker.appendChild(path);
  defs.appendChild(marker);

  const edgeLayer = document.createElementNS(NS,'g'); svg.appendChild(edgeLayer);
  const nodeLayer = document.createElementNS(NS,'g'); svg.appendChild(nodeLayer);
  const uiLayer = document.createElementNS(NS,'g'); svg.appendChild(uiLayer); // for overlays if needed

  // Rendering helpers
  function clearSVG() {
    while(edgeLayer.firstChild) edgeLayer.removeChild(edgeLayer.firstChild);
    while(nodeLayer.firstChild) nodeLayer.removeChild(nodeLayer.firstChild);
  }

  function render() {
    clearSVG();
    // edges
    for(const e of edges){
      const n1 = nodes.find(n=>n.id===e.from);
      const n2 = nodes.find(n=>n.id===e.to);
      if(!n1||!n2) continue;
      // line
      const g = document.createElementNS(NS,'g');
      const line = document.createElementNS(NS,'line');
      line.setAttribute('x1',n1.x); line.setAttribute('y1',n1.y);
      line.setAttribute('x2',n2.x); line.setAttribute('y2',n2.y);
      line.setAttribute('class','edgeLine');
      line.setAttribute('marker-end','url(#arrow)');
      g.appendChild(line);
      // weight label: midpoint + small offset
      const mx = (n1.x+n2.x)/2, my = (n1.y+n2.y)/2;
      const text = document.createElementNS(NS,'text');
      text.setAttribute('x', mx + 8);
      text.setAttribute('y', my - 6);
      text.setAttribute('class','edgeWeight');
      text.textContent = e.weight;
      g.appendChild(text);
      edgeLayer.appendChild(g);
      // clickable edge for deletion
      line.dataset.edgeId = e.id;
      line.addEventListener('click', ev => {
        ev.stopPropagation();
        if(mode==='delete'){
          if(confirm('Delete this edge?')) {
            edges = edges.filter(x=>x.id!==e.id);
            log(`Edge ${e.id} deleted`);
            render();
            updateSelectors();
            resetAlgorithmState();
          }
        }
      });
    }

    // nodes
    for(const n of nodes){
      const g = document.createElementNS(NS,'g');
      g.setAttribute('transform', `translate(${n.x},${n.y})`);
      // circle
      const circle = document.createElementNS(NS,'circle');
      circle.setAttribute('r', 22);
      circle.setAttribute('class','nodeCircle unvisited');
      circle.setAttribute('fill','#d1d9e6');
      circle.dataset.nodeId = n.id;
      g.appendChild(circle);
      // label (node id)
      const label = document.createElementNS(NS,'text');
      label.setAttribute('class','nodeLabel');
      label.setAttribute('text-anchor','middle');
      label.setAttribute('dy','6');
      label.textContent = n.label;
      g.appendChild(label);
      // distance display (small circle or text)
      const dlabel = document.createElementNS(NS,'text');
      dlabel.setAttribute('class','distLabel');
      dlabel.setAttribute('text-anchor','middle');
      dlabel.setAttribute('dy','-30');
      dlabel.textContent = ''; // filled by algorithm state
      dlabel.dataset.nodeId = n.id;
      g.appendChild(dlabel);

      // interactions
      g.addEventListener('mousedown', ev => {
        ev.stopPropagation();
        const id = n.id;
        if(mode==='move'){
          startDrag(n, g, ev);
        } else if(mode==='addEdge'){
          handleEdgeClick(n);
        } else if(mode==='addNode'){
          // noop because adding node is on canvas click
        } else if(mode==='delete'){
          if(confirm('Delete node and its edges?')) {
            nodes = nodes.filter(x=>x.id!==id);
            edges = edges.filter(e=>e.from!==id && e.to!==id);
            log(`Node ${id} deleted`);
            render();
            updateSelectors();
            resetAlgorithmState();
          }
        }
      });

      nodeLayer.appendChild(g);
    }
    updateStateLabels(); // distances and classes updated
  }

  // Dragging
  let dragState = null;
  function startDrag(node, gEl, ev) {
    const start = {x: ev.clientX, y: ev.clientY, nodeX: node.x, nodeY: node.y};
    dragState = start;
    function onMove(e){
      const dx = e.clientX - start.x;
      const dy = e.clientY - start.y;
      node.x = start.nodeX + dx;
      node.y = start.nodeY + dy;
      gEl.setAttribute('transform', `translate(${node.x},${node.y})`);
      render(); // re-render edges positions
    }
    function onUp(){ window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); dragState = null; }
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  }

  // Canvas interactions
  svg.addEventListener('click', ev => {
    const rect = svg.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    if(mode==='addNode'){
      addNodeAt(x,y);
    }
  });

  function addNodeAt(x,y,label){
    const id = nextNodeId++;
    const node = {id, x, y, label: label || String(id)};
    nodes.push(node);
    log(`Node ${node.label} added`);
    render();
    updateSelectors();
    resetAlgorithmState();
  }

  // Edge creation sequencing
  let pendingEdgeSource = null;
  function handleEdgeClick(node){
    if(!pendingEdgeSource){
      pendingEdgeSource = node;
      log(`Selected source node ${node.label}. Now click target node.`);
      // visually indicate maybe
    } else if(pendingEdgeSource.id === node.id){
      pendingEdgeSource = null;
      log('Cancelled edge creation (same node).');
    } else {
      const w = prompt(`Enter weight for edge ${pendingEdgeSource.label} → ${node.label} (non-negative):`, "1");
      pendingEdgeSource = pendingEdgeSource; // keep for clarity
      if(w===null){ pendingEdgeSource=null; return; }
      const weight = Number(w);
      if(isNaN(weight) || weight < 0){ alert('Weight must be a non-negative number'); pendingEdgeSource = null; return; }
      const edge = {id: nextEdgeId++, from: pendingEdgeSource.id, to: node.id, weight};
      edges.push(edge);
      log(`Edge ${edge.id} added: ${getNodeLabel(edge.from)} → ${getNodeLabel(edge.to)} (w=${edge.weight})`);
      pendingEdgeSource = null;
      render();
      updateSelectors();
      resetAlgorithmState();
    }
  }

  // Helpers
  function getNodeLabel(id){ const n = nodes.find(x=>x.id===id); return n ? n.label : id; }
  function log(msg){ const t = new Date().toLocaleTimeString(); logEl.textContent += `[${t}] ${msg}\n`; logEl.scrollTop = logEl.scrollHeight; }
  function updateSelectors(){
    startSelect.innerHTML = '';
    targetSelect.innerHTML = '<option value="">None</option>';
    for(const n of nodes){
      const opt = document.createElement('option'); opt.value = n.id; opt.textContent = n.label; startSelect.appendChild(opt);
      const opt2 = document.createElement('option'); opt2.value = n.id; opt2.textContent = n.label; targetSelect.appendChild(opt2);
    }
  }

  // Algorithm state
  let distances = {}; // id -> number (Infinity for unknown)
  let prev = {}; // id -> predecessor id or null
  let visited = new Set();
  let pq = []; // array of {node,dist}
  let currentNode = null;
  let running = false;
  let autoTimer = null;
  let generator = null;

  function resetAlgorithmState(){
    distances = {};
    prev = {};
    visited = new Set();
    pq = [];
    currentNode = null;
    running = false;
    generator = null;
    updateStateLabels();
    render();
    updatePQDisplay();
  }

  resetAlgorithmState();

  // Dijkstra as generator producing steps
  function* dijkstraGen(startId, targetId=null){
    // initialization
    const INF = Infinity;
    const allIds = nodes.map(n=>n.id);
    for(const id of allIds){ distances[id] = INF; prev[id] = null; }
    distances[startId] = 0;
    pq = [{node:startId, dist:0}];
    yield {type:'init', start:startId};
    while(pq.length>0){
      // extract min (pop smallest)
      pq.sort((a,b)=>a.dist - b.dist);
      const u = pq.shift();
      const uId = u.node;
      if(visited.has(uId)) {
        yield {type:'skip', node:uId, dist:u.dist};
        continue;
      }
      currentNode = uId;
      if(distances[uId] !== u.dist){
        // stale entry, skip
        yield {type:'stale', node:uId, dist:u.dist};
      }
      // mark visited
      visited.add(uId);
      yield {type:'visit', node:uId, dist:distances[uId]};
      if(targetId && uId === targetId){
        yield {type:'foundTarget', node:uId};
        return {distances, prev};
      }
      // relax neighbors (edges from u)
      const outgoing = edges.filter(e=>e.from===uId);
      for(const e of outgoing){
        const v = e.to;
        const alt = distances[uId] + e.weight;
        yield {type:'considerEdge', from:uId, to:v, edge:e, alt};
        if(alt < distances[v]){
          distances[v] = alt;
          prev[v] = uId;
          pq.push({node:v, dist:alt});
          yield {type:'relax', from:uId, to:v, newDist:alt};
        } else {
          yield {type:'noRelax', from:uId, to:v, keptDist:distances[v]};
        }
      }
    }
    yield {type:'done'};
    return {distances, prev};
  }

  // UI actions for algorithm
  stepBtn.onclick = ()=> {
    const startId = Number(startSelect.value);
    if(!startId){ alert('Select a start node'); return; }
    if(!generator){ generator = dijkstraGen(startId, targetSelect.value ? Number(targetSelect.value) : null); }
    const res = generator.next();
    processStepResult(res);
  };

  runBtn.onclick = ()=> {
    const startId = Number(startSelect.value);
    if(!startId){ alert('Select a start node'); return; }
    if(!generator) generator = dijkstraGen(startId, targetSelect.value ? Number(targetSelect.value) : null);
    if(running) return;
    running = true;
    autoStep();
  };

  function autoStep(){
    if(!running) return;
    const res = generator.next();
    processStepResult(res);
    if(res.done){ running=false; return; }
    const delay = Math.max(50, Number(delayInput.value) || 700);
    autoTimer = setTimeout(autoStep, delay);
  }

  pauseBtn.onclick = ()=> {
    running = false;
    if(autoTimer) { clearTimeout(autoTimer); autoTimer = null; }
  };

  resetBtn.onclick = ()=> {
    running = false;
    if(autoTimer){ clearTimeout(autoTimer); autoTimer=null; }
    generator = null;
    resetAlgorithmState();
    log('Algorithm reset to initial state');
  };

  clearBtn.onclick = ()=> {
    if(!confirm('Clear entire graph?')) return;
    nodes = []; edges = []; nextNodeId = 1; nextEdgeId = 1;
    render(); updateSelectors(); resetAlgorithmState(); log('Graph cleared');
  };

  exampleBtn.onclick = ()=> {
    // build a sample graph
    nodes = [];
    edges = [];
    nextNodeId = 1; nextEdgeId = 1;
    addNodeAt(120,120); addNodeAt(300,70); addNodeAt(500,120); addNodeAt(200,260); addNodeAt(420,250);
    // ensure labels are consistent
    nodes.forEach((n, i) => n.label = String(n.id));
    edges.push({id: nextEdgeId++, from:1, to:2, weight:7});
    edges.push({id: nextEdgeId++, from:1, to:4, weight:9});
    edges.push({id: nextEdgeId++, from:1, to:3, weight:14});
    edges.push({id: nextEdgeId++, from:2, to:3, weight:10});
    edges.push({id: nextEdgeId++, from:2, to:4, weight:15});
    edges.push({id: nextEdgeId++, from:3, to:5, weight:9});
    edges.push({id: nextEdgeId++, from:4, to:5, weight:11});
    // add reverse edges to make undirected (optional)
    edges.push({id: nextEdgeId++, from:2, to:1, weight:7});
    edges.push({id: nextEdgeId++, from:4, to:1, weight:9});
    edges.push({id: nextEdgeId++, from:3, to:1, weight:14});
    edges.push({id: nextEdgeId++, from:3, to:2, weight:10});
    edges.push({id: nextEdgeId++, from:4, to:2, weight:15});
    edges.push({id: nextEdgeId++, from:5, to:3, weight:9});
    edges.push({id: nextEdgeId++, from:5, to:4, weight:11});
    render(); updateSelectors(); resetAlgorithmState();
    log('Example graph loaded');
  };

  // process generator step
  function processStepResult(res){
    if(res.done){
      updateStateLabels();
      updatePQDisplay();
      render();
      log('Algorithm finished');
      generator = null;
      running = false;
      return;
    }
    const evt = res.value;
    switch(evt.type){
      case 'init':
        log(`Initialized with start node ${getNodeLabel(evt.start)}`);
        break;
      case 'visit':
        log(`Visiting node ${getNodeLabel(evt.node)} (dist=${evt.dist === Infinity ? '∞' : evt.dist})`);
        break;
      case 'skip':
        log(`Skipping visited node ${getNodeLabel(evt.node)} (stale)`);
        break;
      case 'stale':
        log(`Stale pq entry for ${getNodeLabel(evt.node)} (dist=${evt.dist})`);
        break;
      case 'considerEdge':
        log(`Considering edge ${getNodeLabel(evt.from)} → ${getNodeLabel(evt.to)} (w=${evt.edge.weight}), alt=${evt.alt}`);
        break;
      case 'relax':
        log(`Relax: updated ${getNodeLabel(evt.to)} dist=${evt.newDist} via ${getNodeLabel(evt.from)}`);
        break;
      case 'noRelax':
        // optional: log nothing or concise message
        break;
      case 'foundTarget':
        log(`Target ${getNodeLabel(evt.node)} reached`);
        break;
      case 'done':
        log('No more reachable nodes.');
        break;
    }
    updateStateLabels();
    updatePQDisplay();
    highlightNodes();
    render();
  }

  function highlightNodes(){
    // update node circle classes based on distances/visited/current/pq
    for(const g of Array.from(nodeLayer.children)){
      const circle = g.querySelector('circle');
      const nodeId = Number(circle.dataset.nodeId);
      if(visited.has(nodeId)){
        circle.classList.remove('unvisited','frontier','current'); circle.classList.add('visited');
        circle.setAttribute('fill','#94d4a4');
      } else if(currentNode === nodeId){
        circle.classList.remove('unvisited','frontier','visited'); circle.classList.add('current');
        circle.setAttribute('fill','#ffd47a');
      } else if(pq.some(x=>x.node===nodeId)){
        circle.classList.remove('unvisited','visited','current'); circle.classList.add('frontier');
        circle.setAttribute('fill','#9ec5ff');
      } else {
        circle.classList.remove('visited','frontier','current'); circle.classList.add('unvisited');
        circle.setAttribute('fill','#d1d9e6');
      }
    }
  }

  function updateStateLabels(){
    // distances in table and node labels
    stateTableBody.innerHTML = '';
    for(const n of nodes){
      const tr = document.createElement('tr');
      const tdNode = document.createElement('td'); tdNode.textContent = n.label;
      const tdDist = document.createElement('td'); tdDist.textContent = distances[n.id]===Infinity || distances[n.id]===undefined ? '∞' : distances[n.id];
      const tdPrev = document.createElement('td'); tdPrev.textContent = prev[n.id] ? getNodeLabel(prev[n.id]) : '-';
      tr.appendChild(tdNode); tr.appendChild(tdDist); tr.appendChild(tdPrev);
      stateTableBody.appendChild(tr);

      // update node's small dist label text
      const nodeGroup = Array.from(nodeLayer.children).find(g => {
        const c = g.querySelector('circle');
        return c && Number(c.dataset.nodeId) === n.id;
      });
      if(nodeGroup){
        const dlabel = nodeGroup.querySelector('text.distLabel') || nodeGroup.querySelector('text:nth-child(3)');
        if(dlabel){
          dlabel.textContent = distances[n.id]===Infinity || distances[n.id]===undefined ? '' : distances[n.id];
        }
      }
    }
  }

  function updatePQDisplay(){
    const arr = Array.from(pq).sort((a,b)=>a.dist-b.dist);
    pqList.innerHTML = arr.map(e=>`${getNodeLabel(e.node)}:${e.dist}`).join('  ↦  ');
  }

  // initial sample graph to show something helpful
  exampleBtn.click();

  // small keyboard shortcuts
  window.addEventListener('keydown', ev=>{
    if(ev.key === '1') setMode('addNode');
    if(ev.key === '2') setMode('addEdge');
    if(ev.key === '3') setMode('move');
    if(ev.key === '4') setMode('delete');
    if(ev.key === ' ') { ev.preventDefault(); stepBtn.click(); }
  });

  // expose reset on window for debugging
  window.demo = {nodes, edges, render, addNodeAt};

})();
</script>
</body>
</html>