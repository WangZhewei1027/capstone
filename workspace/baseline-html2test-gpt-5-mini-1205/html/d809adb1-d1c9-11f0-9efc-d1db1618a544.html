<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Interactive Hash Map (Separate Chaining) Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#3b82f6;
      --muted:#94a3b8;
      --card:#0b1226;
      --success:#16a34a;
      --danger:#ef4444;
      --glass: rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#041526 0%, #071428 60%);color:#e6eef8}
    .app{
      max-width:1100px;margin:28px auto;padding:20px;border-radius:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: 0 10px 30px rgba(2,6,23,0.6);
      min-height:600px;
    }
    header{display:flex;align-items:center;gap:16px;margin-bottom:18px}
    .logo{
      width:56px;height:56px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#7c3aed);
      display:flex;align-items:center;justify-content:center;font-weight:700;color:#021026;font-size:20px;
      box-shadow: 0 8px 20px rgba(59,130,246,0.12), inset 0 -6px 30px rgba(255,255,255,0.02);
    }
    h1{font-size:20px;margin:0}
    p.lead{margin:0;color:var(--muted);font-size:13px}
    .main{display:flex;gap:20px;margin-top:18px}
    .controls{
      width:320px;padding:16px;border-radius:12px;background:var(--panel);box-shadow:inset 0 1px 0 rgba(255,255,255,0.02);
    }
    .controls h2{margin:0 0 10px 0;font-size:14px}
    label{display:block;font-size:13px;color:var(--muted);margin-top:12px}
    input[type="text"], input[type="number"]{
      width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);
      margin-top:8px;background:transparent;color:inherit;
    }
    .row{display:flex;gap:8px;margin-top:10px}
    button{
      padding:10px 12px;border-radius:8px;border:0;background:var(--accent);color:#021026;font-weight:600;cursor:pointer;
      box-shadow:0 6px 18px rgba(59,130,246,0.12);
    }
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);box-shadow:none}
    .small{font-size:13px;padding:8px 10px}
    .switch{display:flex;align-items:center;gap:8px;margin-top:12px}
    .stats{
      margin-top:14px;padding:12px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      color:var(--muted);font-size:13px;
    }
    .visual{
      flex:1;padding:16px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));
      min-height:520px;display:flex;flex-direction:column;gap:12px;
    }
    .controls .hint{font-size:12px;color:var(--muted);margin-top:6px}
    .buckets{
      display:flex;gap:10px;flex-wrap:wrap;padding:8px;border-radius:10px;background:var(--card);flex:1;overflow:auto;
    }
    .bucket{
      width:120px;min-height:80px;padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.02);position:relative;transition:transform 200ms, box-shadow 200ms;
    }
    .bucket.highlight{box-shadow:0 8px 30px rgba(59,130,246,0.12);transform:translateY(-6px);border-color:rgba(59,130,246,0.2)}
    .bucket .idx{position:absolute;top:6px;right:8px;font-size:11px;color:var(--muted)}
    .bucket .empty{color:var(--muted);font-size:13px;margin-top:6px}
    .entry{
      margin-top:8px;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);display:flex;gap:8px;align-items:center;
      border:1px solid rgba(255,255,255,0.02);font-size:13px;word-break:break-word;
    }
    .key{font-weight:700;color:#e6eef8}
    .val{color:var(--muted);font-size:12px}
    .chip{background:rgba(255,255,255,0.02);padding:4px 8px;border-radius:6px;font-size:12px}
    .log{margin-top:10px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px;max-height:110px;overflow:auto;color:var(--muted)}
    .controls .footer{margin-top:12px;text-align:center;color:var(--muted);font-size:12px}
    .action-row{display:flex;gap:8px;margin-top:10px}
    .btn-danger{background:var(--danger);color:white}
    .btn-success{background:var(--success)}
    .loader{height:8px;background:rgba(255,255,255,0.03);border-radius:6px;margin-top:8px;overflow:hidden}
    .loader > i{display:block;height:100%;background:linear-gradient(90deg,transparent,rgba(59,130,246,0.35),transparent);width:40%;animation:move 1.2s linear infinite}
    @keyframes move{from{margin-left:-40%}to{margin-left:100%}}
    footer{margin-top:14px;color:var(--muted);font-size:13px;text-align:center}
    .controls .muted{font-size:12px;color:var(--muted);margin-top:6px}
    .entry .buttons{margin-left:auto;display:flex;gap:6px}
    .tiny{font-size:11px;padding:6px 8px}
    .highlightInsert{animation:flash 900ms ease}
    @keyframes flash{
      0%{box-shadow:0 0 0 rgba(59,130,246,0.0)}
      30%{box-shadow:0 10px 30px rgba(59,130,246,0.14)}
      100%{box-shadow:none}
    }
    .muted-border{border:1px dashed rgba(255,255,255,0.02);padding:10px;border-radius:8px;margin-top:10px}
    .note{font-size:13px;color:var(--muted);margin-top:6px}
    .footer small{color:var(--muted)}
    .controls .toggle{cursor:pointer;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);display:inline-block;margin-left:6px}
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Hash Map Demo">
    <header>
      <div class="logo">HM</div>
      <div>
        <h1>Hash Map — Interactive Demo (Separate Chaining)</h1>
        <p class="lead">Visualize how keys are hashed into buckets, see collisions, resizing and operations (put/get/remove).</p>
      </div>
    </header>

    <div class="main">
      <aside class="controls" aria-label="Controls">
        <h2>Operations</h2>

        <label for="keyInput">Key (string or number)</label>
        <input id="keyInput" type="text" placeholder='e.g. "name" or 42' />

        <label for="valInput">Value (any text)</label>
        <input id="valInput" type="text" placeholder='e.g. "Alice"' />

        <div class="row action-row">
          <button id="putBtn">Put</button>
          <button class="ghost" id="getBtn">Get</button>
          <button class="ghost" id="removeBtn">Remove</button>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="randomBtn" class="small ghost">Insert 10 Random</button>
          <button id="clearBtn" class="small ghost">Clear</button>
        </div>

        <div class="switch">
          <input id="autoResize" type="checkbox" checked />
          <label for="autoResize" style="margin:0;font-size:13px;color:var(--muted)">Auto-resize (grow at load factor)</label>
        </div>

        <div class="muted">
          <div style="margin-top:10px">
            <label for="capInput">Initial capacity</label>
            <input id="capInput" type="number" min="2" max="1024" value="8" />
          </div>
          <div style="margin-top:8px">
            <label for="lfInput">Load factor (grow threshold)</label>
            <input id="lfInput" type="number" step="0.01" min="0.1" max="0.95" value="0.75" />
          </div>
          <div style="margin-top:10px">
            <button id="resetBtn" class="small">Reset map (recreate)</button>
          </div>
        </div>

        <div class="stats" aria-live="polite">
          <div><strong>Capacity:</strong> <span id="cap">-</span></div>
          <div><strong>Size:</strong> <span id="size">-</span></div>
          <div><strong>Load factor:</strong> <span id="lf">-</span></div>
          <div style="margin-top:6px;">
            <strong>Max chain length:</strong> <span id="maxChain">-</span>
            <span style="float:right;color:var(--muted)">Avg chain: <span id="avgChain">-</span></span>
          </div>
          <div style="margin-top:8px;">
            <div class="loader" title="Simulated activity bar"><i></i></div>
          </div>
        </div>

        <div class="log" id="log" aria-live="polite" role="log"></div>

        <div class="footer">
          <small>Separate chaining with arrays used to handle collisions. Keys are converted to strings for hashing.</small>
        </div>
      </aside>

      <section class="visual" aria-label="Visualization">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <div style="font-size:14px;color:var(--muted)"><strong>Buckets</strong> — click an entry to get/remove it</div>
          <div class="note">Buckets show index and chained entries (head → tail)</div>
        </div>

        <div class="buckets" id="buckets" role="region" aria-label="Hash buckets"></div>

        <div style="display:flex;gap:12px;align-items:center">
          <div class="muted-border" style="flex:1">
            <div style="display:flex;align-items:center;gap:8px">
              <div style="font-weight:700">Entries (keys → value)</div>
              <div style="margin-left:auto;color:var(--muted)">Order: bucket then chain</div>
            </div>
            <div id="entriesList" style="margin-top:8px;color:var(--muted);font-size:13px"></div>
          </div>

          <div style="width:260px">
            <div style="font-weight:700">Notes</div>
            <div style="color:var(--muted);font-size:13px;margin-top:6px">
              - Hash maps map keys to bucket indexes using a hash function. Collisions occur when different keys map to the same index; separate chaining stores them in a list.<br>
              - When size / capacity > load factor, map typically grows (rehash) to keep operations near O(1).
            </div>
          </div>
        </div>

        <footer>
          <small>Demonstration (not production-ready). Keys are stringified; keep keys simple for predictable results.</small>
        </footer>
      </section>
    </div>
  </div>

  <script>
    // === HashMap implementation (Separate chaining) ===
    class HashMap {
      constructor({capacity = 8, loadFactor = 0.75, autoResize = true} = {}) {
        this._capacity = this._nextPowerOfTwo(Math.max(2, capacity));
        this._loadFactor = Math.max(0.1, Math.min(0.95, loadFactor));
        this._buckets = Array.from({length: this._capacity}, () => []);
        this._size = 0;
        this._autoResize = !!autoResize;
      }

      // Very fast string/number hash (djb2-like)
      _hashKey(key) {
        if (typeof key === 'number' && Number.isInteger(key)) {
          // mix up bits
          let h = key | 0;
          h = h ^ (h >>> 16);
          return h >>> 0;
        }
        // stringify otherwise
        const s = typeof key === 'string' ? key : JSON.stringify(key);
        // djb2
        let h = 5381;
        for (let i = 0; i < s.length; i++) {
          h = ((h << 5) + h) + s.charCodeAt(i); // h*33 + c
        }
        return (h >>> 0);
      }

      _indexForHash(hash) {
        return hash & (this._capacity - 1); // capacity is power of two
      }

      put(key, value) {
        const hash = this._hashKey(key);
        const idx = this._indexForHash(hash);
        const chain = this._buckets[idx];
        for (let i = 0; i < chain.length; i++) {
          if (this._equals(chain[i].key, key)) {
            chain[i].value = value;
            return { updated: true, index: idx, position: i };
          }
        }
        chain.push({key, value, hash});
        this._size++;
        if (this._autoResize && this.loadFactor() > this._loadFactor) {
          this._resize(this._capacity * 2);
        }
        return { added: true, index: idx, position: chain.length - 1 };
      }

      get(key) {
        const hash = this._hashKey(key);
        const idx = this._indexForHash(hash);
        const chain = this._buckets[idx];
        for (const e of chain) {
          if (this._equals(e.key, key)) return e.value;
        }
        return undefined;
      }

      has(key) {
        return this.get(key) !== undefined;
      }

      remove(key) {
        const hash = this._hashKey(key);
        const idx = this._indexForHash(hash);
        const chain = this._buckets[idx];
        for (let i = 0; i < chain.length; i++) {
          if (this._equals(chain[i].key, key)) {
            const removed = chain.splice(i,1)[0];
            this._size--;
            // optional shrink - keep it conservative
            if (this._autoResize && this._capacity > 8 && this._size < this._capacity / 4) {
              this._resize(Math.max(8, Math.floor(this._capacity / 2)));
            }
            return removed.value;
          }
        }
        return undefined;
      }

      clear() {
        this._buckets = Array.from({length: this._capacity}, () => []);
        this._size = 0;
      }

      entries() {
        const out = [];
        for (const chain of this._buckets) {
          for (const e of chain) out.push([e.key, e.value]);
        }
        return out;
      }

      keys() { return this.entries().map(e => e[0]); }
      values() { return this.entries().map(e => e[1]); }

      size() { return this._size; }
      capacity() { return this._capacity; }

      loadFactor() { return this._size / this._capacity; }

      _equals(a,b) {
        return typeof a === 'number' && typeof b === 'number' ? a === b : JSON.stringify(a) === JSON.stringify(b);
      }

      _resize(newCap) {
        newCap = this._nextPowerOfTwo(Math.max(2, Math.floor(newCap)));
        const old = this._buckets;
        this._capacity = newCap;
        this._buckets = Array.from({length: this._capacity}, () => []);
        this._size = 0;
        for (const chain of old) {
          for (const e of chain) {
            // reinsert
            const idx = this._indexForHash(e.hash);
            this._buckets[idx].push({key: e.key, value: e.value, hash: e.hash});
            this._size++;
          }
        }
      }

      _nextPowerOfTwo(n) {
        return 1 << Math.ceil(Math.log2(n));
      }

      bucketInfo() {
        return this._buckets.map(chain => ({
          length: chain.length,
          items: chain.map(e => ({key:e.key,value:e.value}))
        }));
      }
    }

    // === UI wiring ===
    const keyInput = document.getElementById('keyInput');
    const valInput = document.getElementById('valInput');
    const putBtn = document.getElementById('putBtn');
    const getBtn = document.getElementById('getBtn');
    const removeBtn = document.getElementById('removeBtn');
    const randomBtn = document.getElementById('randomBtn');
    const clearBtn = document.getElementById('clearBtn');
    const bucketsEl = document.getElementById('buckets');
    const sizeEl = document.getElementById('size');
    const capEl = document.getElementById('cap');
    const lfEl = document.getElementById('lf');
    const maxChainEl = document.getElementById('maxChain');
    const avgChainEl = document.getElementById('avgChain');
    const logEl = document.getElementById('log');
    const entriesList = document.getElementById('entriesList');
    const autoResizeCheckbox = document.getElementById('autoResize');
    const capInput = document.getElementById('capInput');
    const lfInput = document.getElementById('lfInput');
    const resetBtn = document.getElementById('resetBtn');

    let map = new HashMap({capacity: Number(capInput.value) || 8, loadFactor: Number(lfInput.value) || 0.75, autoResize:true});
    function log(msg, kind = 'info') {
      const time = new Date().toLocaleTimeString();
      const el = document.createElement('div');
      el.innerHTML = `<strong>[${time}]</strong> ${escapeHtml(String(msg))}`;
      el.style.marginBottom = '6px';
      if (kind === 'error') el.style.color = 'var(--danger)';
      logEl.prepend(el);
      // limit lines
      while (logEl.children.length > 200) logEl.removeChild(logEl.lastChild);
    }

    function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    function render() {
      bucketsEl.innerHTML = '';
      const info = map.bucketInfo();
      info.forEach((b, idx) => {
        const be = document.createElement('div');
        be.className = 'bucket';
        be.setAttribute('data-idx', idx);
        be.innerHTML = `<div class="idx">#${idx}</div>`;
        if (b.items.length === 0) {
          const empty = document.createElement('div');
          empty.className = 'empty';
          empty.textContent = '(empty)';
          be.appendChild(empty);
        } else {
          for (let i = 0; i < b.items.length; i++) {
            const entry = b.items[i];
            const div = document.createElement('div');
            div.className = 'entry';
            div.innerHTML = `<div style="display:flex;flex-direction:column;"><span class="key">${escapeHtml(String(entry.key))}</span><span class="val">${escapeHtml(String(entry.value))}</span></div>`;
            const btns = document.createElement('div');
            btns.className = 'buttons';
            const getBtn = document.createElement('button');
            getBtn.className = 'tiny ghost';
            getBtn.textContent = 'Get';
            getBtn.onclick = (ev) => {
              ev.stopPropagation();
              const v = map.get(entry.key);
              log(`get(${JSON.stringify(entry.key)}) => ${JSON.stringify(v)}`);
              flashBucket(idx);
            };
            const rmBtn = document.createElement('button');
            rmBtn.className = 'tiny btn-danger';
            rmBtn.textContent = 'Remove';
            rmBtn.onclick = (ev) => {
              ev.stopPropagation();
              const removed = map.remove(entry.key);
              log(`remove(${JSON.stringify(entry.key)}) => ${JSON.stringify(removed)}`);
              render();
            };
            btns.appendChild(getBtn);
            btns.appendChild(rmBtn);
            div.appendChild(btns);
            be.appendChild(div);
          }
        }
        bucketsEl.appendChild(be);
      });

      // stats
      capEl.textContent = map.capacity();
      sizeEl.textContent = map.size();
      lfEl.textContent = map.loadFactor().toFixed(3);
      const lens = info.map(b => b.length);
      const maxLen = Math.max(...lens, 0);
      const avg = (lens.reduce((a,c)=>a+c,0) / lens.length).toFixed(2);
      maxChainEl.textContent = maxLen;
      avgChainEl.textContent = avg;

      // entries list
      const ent = map.entries();
      if (ent.length === 0) {
        entriesList.textContent = '(no entries)';
      } else {
        entriesList.innerHTML = ent.map(([k,v]) => `<div style="margin-bottom:6px;"><span class="chip">${escapeHtml(String(k))}</span> → <span style="color:var(--muted)">${escapeHtml(String(v))}</span></div>`).join('');
      }
    }

    function flashBucket(idx) {
      const sel = bucketsEl.querySelector(`.bucket[data-idx="${idx}"]`);
      if (!sel) return;
      sel.classList.add('highlight');
      setTimeout(()=>sel.classList.remove('highlight'), 700);
    }

    // Operators
    putBtn.onclick = () => {
      const kRaw = keyInput.value.trim();
      const vRaw = valInput.value;
      if (kRaw === '') { log('Please provide a key.', 'error'); return; }
      const key = parseKeyInput(kRaw);
      const res = map.put(key, vRaw);
      if (res.added) {
        log(`put(${JSON.stringify(key)}, ${JSON.stringify(vRaw)}) — added in bucket ${res.index}`);
        render();
        animateInsert(res.index);
      } else if (res.updated) {
        log(`put(${JSON.stringify(key)}, ${JSON.stringify(vRaw)}) — updated at bucket ${res.index}`);
        render();
        flashBucket(res.index);
      }
    };

    getBtn.onclick = () => {
      const kRaw = keyInput.value.trim();
      if (kRaw === '') { log('Please provide a key to get.', 'error'); return; }
      const key = parseKeyInput(kRaw);
      const v = map.get(key);
      log(`get(${JSON.stringify(key)}) => ${JSON.stringify(v)}`);
      // highlight bucket
      const idx = map._indexForHash(map._hashKey(key));
      flashBucket(idx);
    };

    removeBtn.onclick = () => {
      const kRaw = keyInput.value.trim();
      if (kRaw === '') { log('Please provide a key to remove.', 'error'); return; }
      const key = parseKeyInput(kRaw);
      const v = map.remove(key);
      log(`remove(${JSON.stringify(key)}) => ${JSON.stringify(v)}`);
      render();
    };

    randomBtn.onclick = () => {
      for (let i = 0; i < 10; i++) {
        const k = randomKey();
        const v = randomValue();
        const res = map.put(k, v);
        log(`put(${JSON.stringify(k)}, ${JSON.stringify(v)})`);
        if (res.added) animateInsert(res.index, 80 * i);
      }
      setTimeout(render, 250);
    };

    clearBtn.onclick = () => {
      map.clear();
      log('clear() — map emptied');
      render();
    };

    autoResizeCheckbox.onchange = () => {
      map._autoResize = autoResizeCheckbox.checked;
      log('autoResize = ' + map._autoResize);
    };

    capInput.onchange = () => {
      // do nothing until reset
    };
    lfInput.onchange = () => {
      // do nothing until reset
    };

    resetBtn.onclick = () => {
      const cap = Number(capInput.value) || 8;
      const lf = Number(lfInput.value) || 0.75;
      map = new HashMap({capacity: cap, loadFactor: lf, autoResize: autoResizeCheckbox.checked});
      log(`Reset map: capacity=${map.capacity()} loadFactor=${map._loadFactor}`);
      render();
    };

    function animateInsert(idx, delay=0) {
      setTimeout(() => {
        const sel = bucketsEl.querySelector(`.bucket[data-idx="${idx}"]`);
        if (!sel) return;
        sel.classList.add('highlightInsert');
        sel.classList.add('highlight');
        setTimeout(()=>{ sel.classList.remove('highlightInsert'); sel.classList.remove('highlight'); }, 900);
      }, delay);
    }

    function parseKeyInput(raw) {
      // try number first
      if (!isNaN(raw) && raw !== '') {
        // interpret as number if looks like one
        if (/^-?\d+$/.test(raw)) return Number(raw);
      }
      // strip surrounding quotes if present
      if ((raw.startsWith('"') && raw.endsWith('"')) || (raw.startsWith("'") && raw.endsWith("'"))) {
        return raw.substring(1, raw.length-1);
      }
      // otherwise use raw string
      return raw;
    }

    function randomKey() {
      const t = Math.random();
      if (t < 0.4) return Math.floor(Math.random() * 50); // numeric keys cause clustered hashing sometimes
      const words = ['apple','bob','cat','delta','echo','foo','bar','baz','alice','name','id','key'];
      return words[Math.floor(Math.random()*words.length)] + Math.floor(Math.random()*20);
    }
    function randomValue() {
      const samples = ['Alice','Bob','42','hello','world','true','{obj}','[1,2,3]','value','xyz'];
      return samples[Math.floor(Math.random()*samples.length)];
    }

    // initial render
    render();
    log('HashMap demo ready. Try inserting keys and observe collisions and resizing.');

    // allow bucket clicking to highlight
    bucketsEl.addEventListener('click',(ev)=>{
      const b = ev.target.closest('.bucket');
      if (!b) return;
      const idx = Number(b.getAttribute('data-idx'));
      flashBucket(idx);
      log(`bucket ${idx} selected`);
    });

    // keyboard shortcuts
    document.addEventListener('keydown',(e)=>{
      if (e.key === 'Enter') {
        if (document.activeElement === keyInput || document.activeElement === valInput) {
          putBtn.click();
        }
      }
    });

    // Expose map for debugging in console (optional)
    window.demoMap = map;
  </script>
</body>
</html>