<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>DFS Visualizer — Recursive & Iterative</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{
      --cell-size:24px;
      --gap:2px;
      --bg:#111;
      --panel:#0f1720;
      --text:#cbd5e1;
      --muted:#94a3b8;
      --accent:#60a5fa;
      --start:#16a34a;
      --goal:#ef4444;
      --wall:#0f1720;
      --visited:#06b6d4;
      --frontier:#8b5cf6;
      --path:#f59e0b;
    }
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{
      margin:0;
      min-height:100vh;
      background:linear-gradient(180deg,#071025 0%, #071a2b 100%);
      color:var(--text);
      display:flex;
      gap:18px;
      padding:20px;
      align-items:flex-start;
      font-size:13px;
    }
    .container{
      display:flex;
      gap:18px;
      width:100%;
    }
    .left{
      display:flex;
      flex-direction:column;
      gap:12px;
      min-width:520px;
    }
    .controls{
      background:linear-gradient(180deg,rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      padding:12px;
      border-radius:8px;
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
    }
    .controls label{color:var(--muted); font-size:12px}
    input[type=number]{width:64px;padding:6px;border-radius:6px;border:none;background:rgba(255,255,255,0.03);color:var(--text)}
    select, button{
      padding:8px 10px;border-radius:8px;border:none;background:var(--panel);color:var(--text);cursor:pointer;
      box-shadow:inset 0 -1px rgba(255,255,255,0.02);
    }
    button.primary{background:linear-gradient(90deg,#2563eb,#60a5fa)}
    button.danger{background:linear-gradient(90deg,#ef4444,#fb7185)}
    button:disabled{opacity:0.45;cursor:not-allowed}
    .grid-wrap{
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      padding:12px;border-radius:8px;
      display:flex; gap:12px;
    }
    .grid{
      display:grid;
      gap:var(--gap);
      padding:8px;
      background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);
      border-radius:8px;
      user-select:none;
    }
    .cell{
      width:var(--cell-size);
      height:var(--cell-size);
      background:rgba(255,255,255,0.02);
      border-radius:4px;
      display:flex;align-items:center;justify-content:center;
      cursor:pointer;
      transition:background 160ms, transform 80ms;
      box-shadow: inset 0 -1px rgba(255,255,255,0.02);
    }
    .cell:hover{transform:translateY(-2px)}
    .cell.wall{background:var(--wall); box-shadow:none}
    .cell.start{background:linear-gradient(90deg, rgba(22,163,74,0.95), rgba(34,197,94,0.9))}
    .cell.goal{background:linear-gradient(90deg, rgba(239,68,68,0.95), rgba(251,113,133,0.9))}
    .cell.visited{background:linear-gradient(90deg, rgba(6,182,212,0.95), rgba(59,130,246,0.85))}
    .cell.frontier{background:linear-gradient(90deg, rgba(139,92,246,0.95), rgba(99,102,241,0.85))}
    .cell.path{background:linear-gradient(90deg, rgba(245,158,11,0.95), rgba(250,204,21,0.85))}
    .legend{display:flex;gap:8px;flex-wrap:wrap}
    .legend .item{display:flex;align-items:center;gap:8px;color:var(--muted)}
    .swatch{width:18px;height:18px;border-radius:4px;box-shadow:inset 0 -1px rgba(255,255,255,0.02)}
    .panel{
      width:360px;
      background:linear-gradient(180deg,rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      padding:12px;border-radius:8px;height:640px;overflow:auto;
    }
    .panel h3{margin:6px 0 10px 0;font-size:14px;color:var(--text)}
    .panel .section{margin-bottom:12px}
    .info{font-size:12px;color:var(--muted);line-height:1.4}
    .stack-list, .vis-order{background:rgba(255,255,255,0.01);border-radius:6px;padding:8px;min-height:80px;max-height:220px;overflow:auto;font-family:monospace;font-size:12px}
    .stack-frame{padding:6px;border-radius:6px;margin-bottom:6px;background:rgba(255,255,255,0.01);display:flex;justify-content:space-between;align-items:center}
    .small{font-size:12px;color:var(--muted)}
    .controls-row{display:flex;gap:8px;align-items:center}
    .muted{color:var(--muted)}
    .footer{margin-top:10px;font-size:12px;color:var(--muted)}
    .hint{font-size:12px;color:var(--muted);margin-top:8px}
    .btn-ghost{background:transparent;border:1px dashed rgba(255,255,255,0.03)}
    .top-controls{display:flex;gap:8px;align-items:center}
    .radio-row{display:flex;gap:8px;align-items:center}
    .toggle{display:inline-block;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);cursor:pointer}
    .muted-2{color:#9aa6b2}
  </style>
</head>
<body>
  <div class="container">
    <div class="left">
      <div class="controls">
        <div class="top-controls">
          <label>Rows<input id="rows" type="number" min="5" max="40" value="20"></label>
          <label>Cols<input id="cols" type="number" min="5" max="40" value="30"></label>
          <button id="regen">Generate Grid</button>
        </div>
        <div class="controls-row">
          <button id="run-rec" class="primary">Run Recursive DFS</button>
          <button id="run-itr" class="primary">Run Iterative DFS</button>
          <button id="step" class="btn-ghost">Next Step</button>
          <button id="play" class="btn-ghost">Play</button>
          <button id="reset" class="">Reset</button>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
          <label style="margin-right:8px" class="muted-2">Speed</label>
          <input id="speed" type="range" min="10" max="1000" value="180">
          <span id="speed-val" class="small">180ms</span>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
          <label class="small">Neighbor order</label>
          <select id="order">
            <option value="udlr">Up, Down, Left, Right</option>
            <option value="uldr">Up, Left, Down, Right</option>
            <option value="rdlu">Right, Down, Left, Up</option>
            <option value="random">Random</option>
          </select>
          <label class="small" title="If checked, only set visited but don't draw final path automatically">
            <input type="checkbox" id="no-path"> No auto path
          </label>
        </div>
      </div>

      <div class="grid-wrap">
        <div style="display:flex;flex-direction:column;gap:8px">
          <div class="hint">Click a cell to toggle wall. Shift+Click to set Start. Ctrl+Click to set Goal. Start and Goal default to corners.</div>
          <div id="grid" class="grid" style="--cell-size:24px;"></div>
          <div class="legend" style="margin-top:6px">
            <div class="item"><div class="swatch" style="background:var(--start)"></div><div class="small">Start</div></div>
            <div class="item"><div class="swatch" style="background:var(--goal)"></div><div class="small">Goal</div></div>
            <div class="item"><div class="swatch" style="background:var(--wall)"></div><div class="small">Wall</div></div>
            <div class="item"><div class="swatch" style="background:var(--visited)"></div><div class="small">Visited</div></div>
            <div class="item"><div class="swatch" style="background:var(--frontier)"></div><div class="small">Frontier / Stack</div></div>
            <div class="item"><div class="swatch" style="background:var(--path)"></div><div class="small">Final path</div></div>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>DFS Visualizer — Execution Details</h3>
      <div class="section">
        <div class="info">
          This demo visualizes Depth-First Search (DFS) on a 2D grid. You can choose recursive or iterative implementations. The "frontier" is shown as the stack contents. The demo supports step-by-step execution (use "Next") and autoplay.
        </div>
      </div>

      <div class="section">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Call Stack / Stack</strong></div>
          <div class="small muted">Shows active recursive calls (rec) or stack elements (itr)</div>
        </div>
        <div id="stack" class="stack-list"></div>
      </div>

      <div class="section">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Visited Order</strong></div>
          <div class="small muted">Most recent at top</div>
        </div>
        <div id="vis" class="vis-order"></div>
      </div>

      <div class="section">
        <div class="small muted">Controls:</div>
        <ul class="info">
          <li>Toggle walls by clicking cells.</li>
          <li>Shift+Click to set start; Ctrl/Cmd+Click to set goal.</li>
          <li>Use "Next" to advance one step. Use "Play" to run continuously.</li>
        </ul>
      </div>

      <div class="footer">Implementation notes: DFS explores depth-first using a stack (LIFO). Recursive DFS implicitly uses the call stack and will backtrack when dead-ends are reached.</div>
    </div>
  </div>

<script>
(function(){
  // Config / State
  const gridEl = document.getElementById('grid');
  const rowsInput = document.getElementById('rows');
  const colsInput = document.getElementById('cols');
  const regenBtn = document.getElementById('regen');
  const runRecBtn = document.getElementById('run-rec');
  const runItrBtn = document.getElementById('run-itr');
  const resetBtn = document.getElementById('reset');
  const stepBtn = document.getElementById('step');
  const playBtn = document.getElementById('play');
  const speedInput = document.getElementById('speed');
  const speedVal = document.getElementById('speed-val');
  const orderSelect = document.getElementById('order');
  const stackEl = document.getElementById('stack');
  const visEl = document.getElementById('vis');
  const noPathCheck = document.getElementById('no-path');

  let rows = parseInt(rowsInput.value,10);
  let cols = parseInt(colsInput.value,10);
  let cellSize = 24;
  let grid = []; // 2d array of cells
  let start = {r:0,c:0};
  let goal = {r:rows-1,c:cols-1};
  let running = false;
  let paused = false;
  let autoPlay = false;
  let speed = parseInt(speedInput.value,10);
  let parent = {}; // for path reconstruct
  let visitedOrder = [];
  let stepResolve = null;

  // Utilities
  function idx(r,c){ return r + ',' + c; }
  function valid(r,c){ return r>=0 && r<rows && c>=0 && c<cols; }
  function setCellClass(r,c,cls,removeOther=true){
    const el = grid[r][c].el;
    if(removeOther){
      el.className = 'cell';
      if(grid[r][c].wall) el.classList.add('wall');
    }
    el.classList.remove('start','goal','visited','frontier','path');
    if(cls) el.classList.add(cls);
    if(idx(r,c) === idx(start.r,start.c)) el.classList.add('start');
    if(idx(r,c) === idx(goal.r,goal.c)) el.classList.add('goal');
  }

  function sleep(ms){
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // Step control: await next if paused/stepping
  async function waitStep(){
    if(!autoPlay){
      paused = true;
      stepBtn.disabled = false;
      return new Promise(resolve => { stepResolve = resolve; });
    } else {
      await sleep(speed);
    }
  }

  // UI update: stack and visited lists
  function renderStack(frames){
    stackEl.innerHTML = '';
    if(!frames || frames.length===0){
      stackEl.innerHTML = '<div class="small muted">Stack empty</div>';
      return;
    }
    frames.slice().reverse().forEach(f=>{
      const d = document.createElement('div');
      d.className = 'stack-frame';
      d.innerHTML = `<div>(${f.r},${f.c})</div><div class="small muted">${f.tag||''}</div>`;
      stackEl.appendChild(d);
    });
  }
  function renderVisited(list){
    visEl.innerHTML = '';
    if(list.length===0){visEl.innerHTML = '<div class="small muted">No nodes visited</div>'; return;}
    list.slice().reverse().forEach(p=>{
      const d = document.createElement('div');
      d.className = 'stack-frame';
      d.style.background='transparent';
      d.innerHTML = `<div style="width:100%">${p}</div>`;
      visEl.appendChild(d);
    });
  }

  // Build grid DOM
  function buildGrid(){
    rows = parseInt(rowsInput.value,10);
    cols = parseInt(colsInput.value,10);
    gridEl.style.setProperty('--cell-size', cellSize+'px');
    gridEl.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
    gridEl.innerHTML = '';
    grid = [];
    for(let r=0;r<rows;r++){
      grid[r] = [];
      for(let c=0;c<cols;c++){
        const el = document.createElement('div');
        el.className = 'cell';
        el.dataset.r = r;
        el.dataset.c = c;
        el.title = `${r},${c}`;
        gridEl.appendChild(el);
        grid[r][c] = {r,c,el,wall:false};
        // Click handlers
        el.addEventListener('click', (ev)=>{
          if(running) return;
          if(ev.shiftKey){
            start = {r,c};
            updateAllCellClasses();
          } else if(ev.ctrlKey || ev.metaKey){
            goal = {r,c};
            updateAllCellClasses();
          } else {
            grid[r][c].wall = !grid[r][c].wall;
            setCellClass(r,c, grid[r][c].wall ? 'wall' : null, true);
          }
        });
      }
    }
    // default start & goal
    start = {r:0,c:0};
    goal = {r:rows-1,c:cols-1};
    updateAllCellClasses();
  }

  function updateAllCellClasses(){
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const cell = grid[r][c];
        if(cell.wall) setCellClass(r,c,'wall',true);
        else setCellClass(r,c,null,true);
      }
    }
    setCellClass(start.r,start.c,'start',false);
    setCellClass(goal.r,goal.c,'goal',false);
  }

  // Neighbor ordering
  function getNeighbors(r,c){
    const choice = orderSelect.value;
    let dirs;
    if(choice === 'random'){
      dirs = [[-1,0],[1,0],[0,-1],[0,1]].sort(()=>Math.random()-0.5);
    } else {
      // map string to a sequence
      const mapping = { u:[-1,0], d:[1,0], l:[0,-1], r:[0,1] };
      dirs = [];
      for(const ch of choice){
        if(mapping[ch]) dirs.push(mapping[ch]);
      }
    }
    const result = [];
    for(const d of dirs){
      const nr = r + d[0], nc = c + d[1];
      if(valid(nr,nc) && !grid[nr][nc].wall) result.push({r:nr,c:nc});
    }
    return result;
  }

  // Iterative DFS
  async function runIterative(){
    running = true;
    disableControls(true);
    clearVisited();
    parent = {};
    visitedOrder = [];
    renderVisited(visitedOrder);
    const stack = [{r:start.r,c:start.c}];
    const inStackSet = new Set([idx(start.r,start.c)]);
    renderStack(stack.map(s=>({...s, tag:'stack'})));
    setCellClass(start.r,start.c,'frontier',false);
    while(stack.length>0){
      // show stack
      renderStack(stack.map(s=>({...s, tag:'stack'})));
      // Wait for step/autoplay
      if(!autoPlay){
        stepBtn.disabled = false;
        await waitStep();
        // resolved by clicking Next or toggling Play; after resolving, disable step until next pause
        stepBtn.disabled = true;
      } else {
        await sleep(speed);
      }

      const cur = stack.pop();
      inStackSet.delete(idx(cur.r,cur.c));
      // mark popped as frontier->visited
      setCellClass(cur.r,cur.c,null,true);
      setCellClass(cur.r,cur.c,'visited',false);
      visitedOrder.push(idx(cur.r,cur.c));
      renderVisited(visitedOrder);
      if(idx(cur.r,cur.c) === idx(goal.r,goal.c)){
        // found
        await revealPath(cur);
        break;
      }
      // get neighbors
      const neighbors = getNeighbors(cur.r,cur.c);
      // Push neighbors in order (so that first neighbor will be popped last if we want desired order)
      for(const nb of neighbors){
        const key = idx(nb.r,nb.c);
        if(parent[key] || key === idx(start.r,start.c) || grid[nb.r][nb.c].visited) continue;
        // Avoid pushing duplicates
        if(!inStackSet.has(key) && !grid[nb.r][nb.c].visited){
          parent[key] = idx(cur.r,cur.c);
          stack.push(nb);
          inStackSet.add(key);
          setCellClass(nb.r,nb.c,'frontier',false);
        }
      }
      // mark visited flag in grid for iteration
      grid[cur.r][cur.c].visited = true;
      // small UI update for stack
      renderStack(stack.map(s=>({...s, tag:'stack'})));
    }
    running = false;
    disableControls(false);
  }

  // Recursive DFS with manual callStack display and ability to step
  async function runRecursive(){
    running = true;
    disableControls(true);
    clearVisited();
    parent = {};
    visitedOrder = [];
    renderVisited(visitedOrder);
    const callStack = [];
    let found = false;

    async function dfs(r,c){
      callStack.push({r,c,tag:'rec'});
      renderStack(callStack);
      // step/wait
      if(!autoPlay){
        stepBtn.disabled = false;
        await waitStep();
        stepBtn.disabled = true;
      } else {
        await sleep(speed);
      }

      // if already visited or wall or found, pop and return
      if(found || grid[r][c].visited || grid[r][c].wall){
        callStack.pop();
        renderStack(callStack);
        return;
      }
      // Mark frontier/entry
      setCellClass(r,c,'frontier',false);
      await sleep(10);
      grid[r][c].visited = true;
      setCellClass(r,c,'visited',false);
      visitedOrder.push(idx(r,c));
      renderVisited(visitedOrder);

      if(idx(r,c) === idx(goal.r,goal.c)){
        found = true;
        callStack.pop();
        renderStack(callStack);
        await revealPath({r,c});
        return;
      }
      // neighbors
      const neighbors = getNeighbors(r,c);
      for(const nb of neighbors){
        const key = idx(nb.r,nb.c);
        if(found) break;
        if(grid[nb.r][nb.c].visited) continue;
        parent[key] = idx(r,c);
        await dfs(nb.r,nb.c);
      }
      // backtracking visualization: show popped frame
      const popped = callStack.pop();
      renderStack(callStack);
      // small pause to visualize backtrack
      if(!autoPlay){
        stepBtn.disabled = false;
        await waitStep();
        stepBtn.disabled = true;
      } else {
        await sleep(speed/3);
      }
      return;
    }

    // Entry
    await dfs(start.r,start.c);
    running = false;
    disableControls(false);
  }

  // Reveal path by following parent map from node to start
  async function revealPath(end){
    if(noPathCheck.checked) return;
    // reconstruct
    let curKey = idx(end.r,end.c);
    const path = [];
    while(curKey){
      path.push(curKey);
      if(curKey === idx(start.r,start.c)) break;
      curKey = parent[curKey];
    }
    // animate path
    for(let i=path.length-1;i>=0;i--){
      const [r,c] = path[i].split(',').map(n=>parseInt(n,10));
      setCellClass(r,c,'path',false);
      await sleep(Math.max(20, speed/5));
    }
  }

  // Helpers
  function clearVisited(){
    visitedOrder = [];
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        grid[r][c].visited = false;
        // clear classes except walls
        setCellClass(r,c, grid[r][c].wall ? 'wall' : null, true);
      }
    }
    setCellClass(start.r,start.c,'start',false);
    setCellClass(goal.r,goal.c,'goal',false);
    renderVisited([]);
    renderStack([]);
  }

  function disableControls(dis){
    runRecBtn.disabled = dis;
    runItrBtn.disabled = dis;
    regenBtn.disabled = dis;
    rowsInput.disabled = dis;
    colsInput.disabled = dis;
    orderSelect.disabled = dis;
    noPathCheck.disabled = dis;
    resetBtn.disabled = false;
    // step/play behavior handled elsewhere
  }

  // Step/Play button logic
  stepBtn.addEventListener('click', ()=>{
    if(stepResolve){
      stepResolve();
      stepResolve = null;
    }
  });
  playBtn.addEventListener('click', ()=>{
    autoPlay = !autoPlay;
    playBtn.textContent = autoPlay ? 'Pause' : 'Play';
    if(autoPlay && stepResolve){
      // resolve paused wait so execution continues
      stepResolve();
      stepResolve = null;
    }
  });

  // Event bindings
  regenBtn.addEventListener('click', ()=>{if(running) return; buildGrid();});
  resetBtn.addEventListener('click', ()=>{
    if(running) return;
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) grid[r][c].wall = false;
    clearVisited();
    updateAllCellClasses();
  });

  runItrBtn.addEventListener('click', async ()=>{
    if(running) return;
    autoPlay = false; playBtn.textContent = 'Play';
    await runIterative();
  });

  runRecBtn.addEventListener('click', async ()=>{
    if(running) return;
    autoPlay = false; playBtn.textContent = 'Play';
    await runRecursive();
  });

  speedInput.addEventListener('input', ()=>{
    speed = parseInt(speedInput.value,10);
    speedVal.textContent = speed + 'ms';
  });

  // Build initial grid
  buildGrid();

  // Keyboard shortcuts for convenience
  window.addEventListener('keydown', (ev)=>{
    if(ev.key === ' '){
      ev.preventDefault();
      if(running){
        // toggle pause/play
        autoPlay = !autoPlay;
        playBtn.textContent = autoPlay ? 'Pause' : 'Play';
        if(autoPlay && stepResolve){
          stepResolve();
          stepResolve = null;
        }
      }
    }
  });

  // initialize
  speedVal.textContent = speed + 'ms';
})();
</script>
</body>
</html>