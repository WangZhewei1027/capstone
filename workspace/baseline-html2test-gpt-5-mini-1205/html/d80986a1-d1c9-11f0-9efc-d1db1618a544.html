<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Deque (Double-Ended Queue) ‚Äî Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f1724;
      --card: #0b1220;
      --muted: #94a3b8;
      --accent: #7dd3fc;
      --accent-2: #60a5fa;
      --good: #86efac;
      --bad: #fca5a5;
      --node-bg: linear-gradient(180deg,#071129,#0b2540);
      --glass: rgba(255,255,255,0.03);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html,body { height:100%; margin:0; background: linear-gradient(180deg,#071025,#021124); color:#e6eef8; }
    .wrap { max-width:1100px; margin:28px auto; padding:20px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); box-shadow: 0 8px 30px rgba(2,6,23,0.6); }
    header { display:flex; gap:16px; align-items:center; margin-bottom:16px; }
    header h1 { font-size:20px; margin:0; letter-spacing:-0.2px; }
    header p { margin:0; color:var(--muted); font-size:13px; }
    .controls { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:14px; }
    .card { background:var(--card); padding:12px; border-radius:10px; min-width:0; }
    .row { display:flex; gap:8px; align-items:center; }
    input[type="text"] { padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit; min-width:120px; }
    select { padding:8px 10px; border-radius:8px; background:transparent; color:inherit; border:1px solid rgba(255,255,255,0.04); }
    button { background:linear-gradient(180deg,var(--accent),var(--accent-2)); color:#002233; border:0; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600; }
    button.secondary { background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--muted); font-weight:600; }
    button.warn { background:linear-gradient(180deg,#ffb4b4,#ff7b7b); color:#380000; }
    .visual { margin-top:18px; display:flex; gap:18px; align-items:flex-start; }
    .panel { flex:1; background:var(--glass); padding:14px; border-radius:10px; min-height:180px; }
    .deque-area { display:flex; gap:10px; align-items:center; justify-content:flex-start; padding:12px; overflow:auto; min-height:80px; }
    .node {
      display:flex; align-items:center; justify-content:center; min-width:56px; height:56px;
      border-radius:8px; background:var(--node-bg); border:1px solid rgba(255,255,255,0.04);
      box-shadow: inset 0 -6px 18px rgba(2,6,23,0.3);
      font-weight:700; color:#dff7ff; position:relative;
      transition:transform 220ms ease, opacity 200ms ease;
    }
    .node .sub { position:absolute; bottom:-14px; left:0; right:0; text-align:center; font-size:11px; color:var(--muted); }
    .node.head { outline:3px solid rgba(125,211,252,0.12); }
    .node.tail { outline:3px solid rgba(96,165,250,0.12); }
    .arrow { font-size:20px; opacity:0.7; color:var(--muted); }
    .log { max-height:220px; overflow:auto; font-size:13px; color:var(--muted); padding:6px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); }
    .meta { display:flex; gap:10px; margin-top:10px; align-items:center; flex-wrap:wrap; }
    .badge { padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.02); color:var(--muted); font-size:13px; }
    .small { font-size:13px; color:var(--muted); }
    .code { background:rgba(0,0,0,0.2); padding:8px; border-radius:8px; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; font-size:12px; color:#dbeafe; }
    footer { margin-top:14px; color:var(--muted); font-size:13px; display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap; }
    .note { color:var(--muted); font-size:13px; }
    .muted-2 { color:#9fb0c6; }
    .center { text-align:center; }
    /* small animations */
    .node.removed { transform:translateY(-20px) scale(0.9); opacity:0; }
    .node.added { transform:translateY(-6px); box-shadow: 0 10px 30px rgba(2,6,23,0.6); }
    @media (max-width:720px) {
      .visual { flex-direction:column; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Deque ‚Äî double-ended queue</h1>
        <p>Interactive demo: add/remove at both ends, peek, rotate, and compare array vs linked list implementations.</p>
      </div>
      <div style="margin-left:auto" class="small muted-2">Operations: pushFront, pushBack, popFront, popBack ‚Äî often O(1)</div>
    </header>

    <div class="controls">
      <div class="card row">
        <input id="valueInput" type="text" placeholder="value (string or number)" />
        <button id="pushFrontBtn" title="Add to front">Push Front</button>
        <button id="pushBackBtn" title="Add to back">Push Back</button>
      </div>

      <div class="card row">
        <button id="popFrontBtn" class="secondary">Pop Front</button>
        <button id="popBackBtn" class="secondary">Pop Back</button>
        <button id="peekFrontBtn" class="secondary">Peek Front</button>
        <button id="peekBackBtn" class="secondary">Peek Back</button>
      </div>

      <div class="card row">
        <select id="implSelect" title="Choose implementation">
          <option value="linked">Doubly-linked list (O(1) ends)</option>
          <option value="array">Simple Array (uses push/pop/shift/unshift)</option>
        </select>
        <button id="clearBtn" class="warn">Clear</button>
      </div>

      <div class="card row">
        <input id="countInput" type="text" placeholder="count (e.g. 5)" style="min-width:84px" />
        <button id="fillBtn" class="secondary">Fill Random</button>
        <button id="pushManyFrontBtn" class="secondary">Push Many Front</button>
        <button id="pushManyBackBtn" class="secondary">Push Many Back</button>
      </div>
    </div>

    <div class="visual">
      <div class="panel" style="flex:2">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
          <div class="small">Representation (<span id="implLabel">Doubly-linked list</span>)</div>
          <div class="meta">
            <div class="badge">Size: <span id="sizeBadge">0</span></div>
            <div class="badge">Empty: <span id="emptyBadge">true</span></div>
            <div class="badge">Last op: <span id="lastOp">‚Äî</span></div>
          </div>
        </div>

        <div class="deque-area" id="dequeArea" style="margin-top:12px; min-height:120px; background:linear-gradient(90deg, rgba(255,255,255,0.01), transparent); border-radius:8px;"></div>

        <div style="margin-top:10px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <button id="rotateLeftBtn" class="secondary">Rotate Left</button>
          <button id="rotateRightBtn" class="secondary">Rotate Right</button>
          <button id="demoSeqBtn" class="secondary">Run Sample Sequence</button>
          <button id="exportBtn" class="secondary">Export Array Snapshot</button>
        </div>
      </div>

      <div class="panel" style="flex:1">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
          <div class="small">Log / Info</div>
          <div class="small muted-2">Click items to remove that value (front->back order)</div>
        </div>

        <div class="log" id="log"></div>

        <div style="margin-top:12px;">
          <div class="small" style="margin-bottom:8px">Implementation details</div>
          <div class="code" id="implInfo">
            Doubly-linked list: push/pop at either end are O(1). Simple array uses shift/unshift which are O(n).
          </div>
        </div>
      </div>
    </div>

    <footer>
      <div class="note">Try switching implementations to observe behavior. Clicking an element removes the first matching value (for demonstration).</div>
      <div class="note">This demo shows the abstract Deque concept ‚Äî commonly used in BFS, sliding window, job scheduling, etc.</div>
    </footer>
  </div>

  <script>
    // Deque interfaces: two implementations (Linked list and simple Array)
    // Both implement: pushFront(v), pushBack(v), popFront(), popBack(), peekFront(), peekBack(), size(), isEmpty(), toArray(), clear(), rotateLeft(), rotateRight()

    // Doubly-linked list deque (O(1) at ends)
    class LinkedNode {
      constructor(value) { this.value = value; this.next = null; this.prev = null; }
    }
    class LinkedDeque {
      constructor() { this.head = null; this.tail = null; this._size = 0; }
      pushFront(v) {
        const n = new LinkedNode(v);
        if (!this.head) { this.head = this.tail = n; }
        else { n.next = this.head; this.head.prev = n; this.head = n; }
        this._size++; return this;
      }
      pushBack(v) {
        const n = new LinkedNode(v);
        if (!this.tail) { this.head = this.tail = n; }
        else { n.prev = this.tail; this.tail.next = n; this.tail = n; }
        this._size++; return this;
      }
      popFront() {
        if (!this.head) return undefined;
        const v = this.head.value;
        this.head = this.head.next;
        if (this.head) this.head.prev = null; else this.tail = null;
        this._size--; return v;
      }
      popBack() {
        if (!this.tail) return undefined;
        const v = this.tail.value;
        this.tail = this.tail.prev;
        if (this.tail) this.tail.next = null; else this.head = null;
        this._size--; return v;
      }
      peekFront() { return this.head ? this.head.value : undefined; }
      peekBack() { return this.tail ? this.tail.value : undefined; }
      size() { return this._size; }
      isEmpty() { return this._size === 0; }
      clear() { this.head = this.tail = null; this._size = 0; return this; }
      toArray() {
        const out = [];
        let cur = this.head;
        while (cur) { out.push(cur.value); cur = cur.next; }
        return out;
      }
      // rotate left: front -> back
      rotateLeft() {
        if (this._size <= 1) return this;
        const v = this.popFront();
        this.pushBack(v);
        return this;
      }
      rotateRight() {
        if (this._size <= 1) return this;
        const v = this.popBack();
        this.pushFront(v);
        return this;
      }
    }

    // Simple array-backed deque (uses shift/unshift)
    class ArrayDeque {
      constructor() { this.arr = []; }
      pushFront(v) { this.arr.unshift(v); return this; }
      pushBack(v) { this.arr.push(v); return this; }
      popFront() { return this.arr.shift(); }
      popBack() { return this.arr.pop(); }
      peekFront() { return this.arr.length ? this.arr[0] : undefined; }
      peekBack() { return this.arr.length ? this.arr[this.arr.length-1] : undefined; }
      size() { return this.arr.length; }
      isEmpty() { return this.arr.length === 0; }
      clear() { this.arr = []; return this; }
      toArray() { return this.arr.slice(); }
      rotateLeft() { if (this.arr.length > 1) this.arr.push(this.arr.shift()); return this; }
      rotateRight() { if (this.arr.length > 1) this.arr.unshift(this.arr.pop()); return this; }
    }

    // Small helper to animate DOM nodes
    const dequeArea = document.getElementById('dequeArea');
    const logEl = document.getElementById('log');
    const sizeBadge = document.getElementById('sizeBadge');
    const emptyBadge = document.getElementById('emptyBadge');
    const lastOp = document.getElementById('lastOp');
    const implInfo = document.getElementById('implInfo');
    const implLabel = document.getElementById('implLabel');

    let implType = 'linked';
    let deque = new LinkedDeque();

    // UI elements
    const valueInput = document.getElementById('valueInput');
    const pushFrontBtn = document.getElementById('pushFrontBtn');
    const pushBackBtn = document.getElementById('pushBackBtn');
    const popFrontBtn = document.getElementById('popFrontBtn');
    const popBackBtn = document.getElementById('popBackBtn');
    const peekFrontBtn = document.getElementById('peekFrontBtn');
    const peekBackBtn = document.getElementById('peekBackBtn');
    const clearBtn = document.getElementById('clearBtn');
    const fillBtn = document.getElementById('fillBtn');
    const countInput = document.getElementById('countInput');
    const pushManyFrontBtn = document.getElementById('pushManyFrontBtn');
    const pushManyBackBtn = document.getElementById('pushManyBackBtn');
    const implSelect = document.getElementById('implSelect');
    const rotateLeftBtn = document.getElementById('rotateLeftBtn');
    const rotateRightBtn = document.getElementById('rotateRightBtn');
    const demoSeqBtn = document.getElementById('demoSeqBtn');
    const exportBtn = document.getElementById('exportBtn');

    // update UI rendering
    function render() {
      const arr = deque.toArray();
      dequeArea.innerHTML = '';
      if (arr.length === 0) {
        const hint = document.createElement('div');
        hint.className = 'small muted-2 center';
        hint.style.padding = '20px';
        hint.innerText = 'Deque is empty ‚Äî add items from either end.';
        dequeArea.appendChild(hint);
      } else {
        arr.forEach((v, i) => {
          const n = document.createElement('div');
          n.className = 'node';
          const text = String(v);
          n.textContent = text;
          if (i === 0) { n.classList.add('head'); const sub = document.createElement('div'); sub.className='sub'; sub.textContent='front'; n.appendChild(sub); }
          if (i === arr.length-1) { n.classList.add('tail'); const sub2 = document.createElement('div'); sub2.className='sub'; sub2.textContent='back'; n.appendChild(sub2); }
          // click handler removes first occurrence of this value (demo purpose)
          n.title = 'Click to remove this specific element (first matching)';
          n.addEventListener('click', (e) => {
            removeValueOnce(v);
          });
          dequeArea.appendChild(n);
          if (i < arr.length - 1) {
            const arrow = document.createElement('div');
            arrow.className = 'arrow';
            arrow.innerHTML = '&#8594;'; // ‚Üí
            dequeArea.appendChild(arrow);
          }
        });
      }
      sizeBadge.textContent = deque.size();
      emptyBadge.textContent = deque.isEmpty();
    }

    function log(msg, type='info') {
      const time = new Date().toLocaleTimeString();
      const item = document.createElement('div');
      item.innerHTML = `<span style="color:#9fb0c6">[${time}]</span> ${msg}`;
      logEl.prepend(item);
    }

    function applyImplChoice() {
      implType = implSelect.value;
      if (implType === 'linked') {
        implLabel.textContent = 'Doubly-linked list';
        implInfo.textContent = 'Doubly-linked list: push/pop at either end are O(1) (no element shifting). Good for heavy front/back operations.';
        // convert current array snapshot into new implementation
        const snapshot = deque.toArray();
        deque = new LinkedDeque();
        snapshot.forEach(v => deque.pushBack(v));
      } else {
        implLabel.textContent = 'Simple Array';
        implInfo.textContent = 'Simple array: uses push/pop/shift/unshift. push/pop at back are O(1), but shift/unshift (front) are O(n) due to element movement.';
        const snapshot = deque.toArray();
        deque = new ArrayDeque();
        snapshot.forEach(v => deque.pushBack(v));
      }
      log(`Switched implementation to: ${implLabel.textContent}`);
      render();
    }

    // UI operation functions
    function pushFront(value) {
      if (value === '') return;
      deque.pushFront(value);
      lastOp.textContent = `pushFront(${value})`;
      renderTransientAdd('front');
      log(`pushFront(${JSON.stringify(value)})`);
    }
    function pushBack(value) {
      if (value === '') return;
      deque.pushBack(value);
      lastOp.textContent = `pushBack(${value})`;
      renderTransientAdd('back');
      log(`pushBack(${JSON.stringify(value)})`);
    }
    function popFront() {
      const v = deque.popFront();
      lastOp.textContent = `popFront() -> ${String(v)}`;
      log(`popFront() -> ${JSON.stringify(v)}`);
      renderTransientRemove();
    }
    function popBack() {
      const v = deque.popBack();
      lastOp.textContent = `popBack() -> ${String(v)}`;
      log(`popBack() -> ${JSON.stringify(v)}`);
      renderTransientRemove();
    }
    function peekFront() {
      const v = deque.peekFront();
      lastOp.textContent = `peekFront() -> ${String(v)}`;
      log(`peekFront() -> ${JSON.stringify(v)}`);
      flashPeek('front');
    }
    function peekBack() {
      const v = deque.peekBack();
      lastOp.textContent = `peekBack() -> ${String(v)}`;
      log(`peekBack() -> ${JSON.stringify(v)}`);
      flashPeek('back');
    }

    function removeValueOnce(val) {
      // remove first matching value from front to back (demonstration)
      const arr = deque.toArray();
      const idx = arr.findIndex(x => x === val);
      if (idx === -1) return;
      if (idx === 0) { popFront(); return; }
      if (idx === arr.length - 1) { popBack(); return; }
      // for array impl, remove directly; for linked, we can rebuild
      if (implType === 'array') {
        // access internal array (unsafe, for demo) by using toArray, rebuild
        const newArr = arr.slice(0, idx).concat(arr.slice(idx+1));
        deque.clear();
        newArr.forEach(v => deque.pushBack(v));
        log(`Removed value ${JSON.stringify(val)} at index ${idx}`);
        renderTransientRemove();
      } else {
        // linked: rebuild without the item
        const newDeque = new LinkedDeque();
        let removed = false;
        for (const item of arr) {
          if (!removed && item === val) { removed = true; continue; }
          newDeque.pushBack(item);
        }
        deque = newDeque;
        log(`Removed value ${JSON.stringify(val)} (first match)`);
        renderTransientRemove();
      }
    }

    // transient UI helpers: animate last added/removed
    function renderTransientAdd(position) {
      render();
      // animate last node
      const nodes = dequeArea.querySelectorAll('.node');
      if (!nodes.length) return;
      const node = position === 'front' ? nodes[0] : nodes[nodes.length-1];
      node.classList.add('added');
      setTimeout(() => node.classList.remove('added'), 500);
    }
    function renderTransientRemove() {
      // Visual removal: mark one of the nodes as removed briefly
      const nodes = dequeArea.querySelectorAll('.node');
      if (!nodes.length) { render(); return; }
      // pick removed index by comparing sizes (we don't have previous size easily); just render and show removal animation on first/last if pop occurred
      render(); // ensure up-to-date
    }
    function flashPeek(which) {
      render();
      const nodes = dequeArea.querySelectorAll('.node');
      if (!nodes.length) return;
      const node = which === 'front' ? nodes[0] : nodes[nodes.length-1];
      // temporary highlight
      node.style.transition = 'transform 120ms ease';
      node.style.transform = 'scale(1.06)';
      setTimeout(() => node.style.transform = '', 220);
    }

    // helpers: random generator and push many
    function randomValue() {
      const pool = ['A','B','C','D','E','X','Y','Z','üçé','üçä','7','42','node','task'];
      return pool[Math.floor(Math.random()*pool.length)] + Math.floor(Math.random()*100);
    }
    function fillRandom() {
      const cnt = parseInt(countInput.value) || 5;
      for (let i=0;i<cnt;i++) { deque.pushBack(randomValue()); }
      lastOp.textContent = `fillRandom(${cnt})`;
      log(`Filled with ${cnt} random values`);
      render();
    }

    function pushMany(side) {
      const cnt = parseInt(countInput.value) || 5;
      const vals = [];
      for (let i=0;i<cnt;i++) vals.push(randomValue());
      if (side === 'front') {
        for (const v of vals) deque.pushFront(v);
        log(`Pushed ${cnt} values to front`);
      } else {
        for (const v of vals) deque.pushBack(v);
        log(`Pushed ${cnt} values to back`);
      }
      lastOp.textContent = `pushMany(${side}, ${cnt})`;
      render();
    }

    function rotateLeft() {
      deque.rotateLeft();
      lastOp.textContent = 'rotateLeft()';
      log('rotateLeft() ‚Äî front moved to back');
      render();
    }
    function rotateRight() {
      deque.rotateRight();
      lastOp.textContent = 'rotateRight()';
      log('rotateRight() ‚Äî back moved to front');
      render();
    }

    // sample sequence to demonstrate typical deque usage
    async function demoSequence() {
      // run some operations with slight delays
      const seq = [
        () => { pushBack('job1'); },
        () => { pushBack('job2'); },
        () => { pushFront('urgent'); },
        () => { popBack(); },
        () => { pushBack('job3'); },
        () => { rotateRight(); },
        () => { pushFront('very-urgent'); },
        () => { popFront(); },
      ];
      for (const step of seq) {
        step();
        await new Promise(r => setTimeout(r, 420));
      }
      log('Sample sequence completed');
    }

    function exportSnapshot() {
      const arr = deque.toArray();
      const txt = JSON.stringify(arr);
      navigator.clipboard?.writeText(txt).then(() => {
        log(`Snapshot copied to clipboard: ${txt}`);
      }).catch(() => {
        log(`Snapshot: ${txt}`);
      });
      alert('Array snapshot: ' + txt);
    }

    // attach event listeners
    pushFrontBtn.addEventListener('click', () => { pushFront(valueInput.value.trim()); valueInput.value=''; render(); });
    pushBackBtn.addEventListener('click', () => { pushBack(valueInput.value.trim()); valueInput.value=''; render(); });
    popFrontBtn.addEventListener('click', () => { popFront(); render(); });
    popBackBtn.addEventListener('click', () => { popBack(); render(); });
    peekFrontBtn.addEventListener('click', () => { peekFront(); });
    peekBackBtn.addEventListener('click', () => { peekBack(); });
    clearBtn.addEventListener('click', () => { deque.clear(); log('clear()'); render(); lastOp.textContent = 'clear()'; });
    fillBtn.addEventListener('click', () => { fillRandom(); render(); });
    pushManyFrontBtn.addEventListener('click', () => { pushMany('front'); render(); });
    pushManyBackBtn.addEventListener('click', () => { pushMany('back'); render(); });
    implSelect.addEventListener('change', () => { applyImplChoice(); });
    rotateLeftBtn.addEventListener('click', () => { rotateLeft(); });
    rotateRightBtn.addEventListener('click', () => { rotateRight(); });
    demoSeqBtn.addEventListener('click', () => { demoSequence(); });
    exportBtn.addEventListener('click', () => { exportSnapshot(); });

    // keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        // enter to pushBack quickly
        if (document.activeElement === valueInput) {
          pushBack(valueInput.value.trim());
          valueInput.value = '';
          render();
        }
      }
    });

    // initial render
    render();
    log('Demo ready ‚Äî choose an implementation and try operations.');

    // small demonstration: prefill with a few items
    deque.pushBack('start1');
    deque.pushBack('start2');
    render();
  </script>
</body>
</html>