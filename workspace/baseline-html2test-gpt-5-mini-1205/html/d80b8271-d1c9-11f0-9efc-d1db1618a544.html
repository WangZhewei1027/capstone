<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Kruskal's Algorithm — Interactive Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#f7f9fc;
    --panel:#ffffff;
    --accent:#2b6cb0;
    --muted:#718096;
    --good:#2f855a;
    --bad:#e53e3e;
    --check:#d69e2e;
  }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{background:var(--bg);display:flex;flex-direction:column;}
  header{padding:14px 20px;background:linear-gradient(90deg,#ffffff88, #f0f6ff);border-bottom:1px solid #e6eef8;}
  h1{margin:0;font-weight:600;font-size:18px;color:#0b3a66;}
  p.lead{margin:6px 0 0;color:var(--muted);font-size:13px;}
  .container{flex:1;display:flex;gap:12px;padding:12px;max-height:calc(100% - 86px);}
  .canvas-wrap{flex:1;background:linear-gradient(180deg,#ffffff,#f7fbff);border-radius:10px;padding:12px;box-shadow:0 4px 14px rgba(39,74,122,0.06);display:flex;flex-direction:column;min-width:0;}
  .canvas-top{display:flex;gap:10px;align-items:center;margin-bottom:8px;}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
  button, input[type=number], select{font:inherit;padding:8px 10px;border-radius:8px;border:1px solid #dbe7f5;background:var(--panel);color:#0b3a66;cursor:pointer;}
  button:hover{filter:brightness(.98)}
  button.primary{background:linear-gradient(180deg,var(--accent),#236199);color:white;border:none;box-shadow:0 6px 18px rgba(36,97,166,0.12);}
  button.warn{background:linear-gradient(180deg,var(--check),#c48a1b);color:white;border:none;}
  .small{padding:6px 8px;font-size:13px;border-radius:7px;}
  .side{width:340px;min-width:260px;background:var(--panel);border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(38,70,120,0.06);overflow:auto;}
  .panel-title{font-weight:600;color:#0b3a66;margin:0 0 8px 0;}
  .info{font-size:13px;color:var(--muted);margin-bottom:8px;}
  canvas{background:transparent;border-radius:8px;flex:1;display:block;}
  .footer-row{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
  .edge-list{font-size:13px;border-radius:8px;padding:8px;background:#f6fbff;border:1px dashed #e6f0fb;max-height:220px;overflow:auto;}
  .edge-row{display:flex;justify-content:space-between;padding:6px;border-radius:6px;margin-bottom:6px;}
  .edge-row.consider{background:#fff9e6;border:1px solid #ffe8a8;}
  .edge-row.accept{background:#e9f7ee;border:1px solid #c7efd0;}
  .edge-row.reject{background:#fff1f1;border:1px solid #f8d6d6;}
  .badge{font-weight:700;padding:4px 8px;border-radius:999px;font-size:12px;}
  .small-muted{font-size:12px;color:var(--muted)}
  label{font-size:13px;color:var(--muted);margin-right:6px}
  .mode-toggle{display:inline-flex;border-radius:8px;overflow:hidden;border:1px solid #e2ecfb}
  .mode-toggle button{border-radius:0;padding:8px 10px;background:transparent;border:none;}
  .mode-toggle button.active{background:#e9f4ff;color:var(--accent);font-weight:600}
  .legend{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
  .legend .item{display:flex;gap:6px;align-items:center;font-size:13px;color:var(--muted)}
  .swatch{width:16px;height:12px;border-radius:3px;border:1px solid #bbb}
  .status-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .mst-info{font-weight:700;color:var(--good);font-size:14px}
  .uf-table{font-size:13px;line-height:1.6;background:#fbfdff;padding:8px;border-radius:8px;border:1px solid #e7f2ff}
  .hint{font-size:12px;color:var(--muted);margin-top:8px}
  .weight{font-weight:700;color:#0b3a66}
  .small-input{width:72px}
  @media (max-width:900px){
    .container{flex-direction:column;padding:12px;}
    .side{width:100%}
  }
</style>
</head>
<body>
<header>
  <h1>Kruskal's Algorithm — Interactive Demo</h1>
  <p class="lead">Build or randomize a weighted undirected graph, then step through Kruskal’s algorithm to form a Minimum Spanning Tree (MST). Colors show components and accepted/rejected edges.</p>
</header>

<div class="container">
  <div class="canvas-wrap">
    <div class="canvas-top">
      <div class="controls">
        <button id="add-node" class="small">Add Node</button>
        <button id="add-edge" class="small">Add Edge</button>
        <button id="auto-edge" class="small">Auto-Edge Mode</button>
        <button id="random-graph" class="small">Random Graph</button>
        <label class="small-muted">Nodes:
          <input id="rand-n" type="number" class="small-input" min="2" max="30" value="8">
        </label>
        <label class="small-muted">Density:
          <select id="rand-d">
            <option value="0.3">Sparse (30%)</option>
            <option value="0.5" selected>Medium (50%)</option>
            <option value="0.8">Dense (80%)</option>
          </select>
        </label>
      </div>

      <div style="flex:1"></div>

      <div class="controls">
        <label class="small-muted">Speed:
          <input id="speed" type="range" min="100" max="2000" step="100" value="800" />
        </label>
        <button id="step" class="primary small">Step</button>
        <button id="run" class="primary small">Play</button>
        <button id="reset" class="small">Reset</button>
      </div>
    </div>

    <canvas id="canvas" width="900" height="560"></canvas>

    <div class="footer-row">
      <div class="small-muted">Mode: <span id="mode-label">Idle — Use controls above</span></div>
      <div class="small-muted">Click nodes to drag. When in "Add Edge" click one node then another to add an edge.</div>
      <div style="flex:1"></div>
      <div class="small-muted">Total MST Weight: <span id="mst-total" class="weight">0</span></div>
    </div>
  </div>

  <aside class="side">
    <h3 class="panel-title">Edges (sorted)</h3>
    <div class="info">Kruskal examines edges in ascending weight. Click an edge row to highlight it on the canvas.</div>
    <div id="edge-list" class="edge-list"></div>

    <div style="height:12px"></div>

    <h4 class="panel-title">Union-Find (Disjoint Set)</h4>
    <div class="info">Current representative (root) for each node and component colors after unions.</div>
    <div id="uf" class="uf-table"></div>

    <div style="height:12px"></div>

    <h4 class="panel-title">Legend & Status</h4>
    <div class="legend">
      <div class="item"><div class="swatch" style="background:#dbeeff;border:1px solid #9fc6ff"></div><div class="small-muted">Unprocessed Edge</div></div>
      <div class="item"><div class="swatch" style="background:#fff8e1;border:1px solid #ffd58a"></div><div class="small-muted">Considering</div></div>
      <div class="item"><div class="swatch" style="background:#e6fbf0;border:1px solid #bfeed2"></div><div class="small-muted">Accepted (MST)</div></div>
      <div class="item"><div class="swatch" style="background:#fff0f0;border:1px solid #f4c5c5"></div><div class="small-muted">Rejected</div></div>
    </div>

    <div style="height:12px"></div>

    <div class="status-row">
      <div class="mst-info">MST edges: <span id="mst-count">0</span></div>
      <div class="small-muted"> | Edges total: <span id="edge-count">0</span></div>
      <div style="flex:1"></div>
      <button id="explain" class="small warn">Help / Explanation</button>
    </div>

    <div class="hint" id="hint">
      Tip: Add nodes and edges manually or generate a random graph. Use "Step" to walk Kruskal's decisions one edge at a time.
    </div>

  </aside>
</div>

<!-- Help Dialog -->
<div id="help" style="display:none;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:720px;max-width:94%;background:white;border-radius:10px;padding:18px;box-shadow:0 18px 50px rgba(30,60,110,0.25);z-index:200">
  <h3 style="margin:0 0 10px 0">Kruskal's Algorithm — Quick Explanation</h3>
  <div style="font-size:13px;color:#425a70">
    <p style="margin:0 0 8px 0">Kruskal's algorithm finds a Minimum Spanning Tree (MST) of a weighted undirected graph by:</p>
    <ol style="margin:0 0 8px 20px;line-height:1.5">
      <li>Sorting all edges by increasing weight.</li>
      <li>Iterating edges from smallest to largest and adding an edge if it connects two different components (to avoid cycles).</li>
      <li>Using a disjoint-set (union-find) structure to quickly check whether two vertices are already connected and to union their components when an edge is accepted.</li>
    </ol>
    <p style="margin:0 0 8px 0">Stop when you have n-1 edges for n nodes. The resulting set of edges is a minimum-weight spanning tree when the graph is connected.</p>
  </div>
  <div style="text-align:right;margin-top:12px">
    <button id="close-help" class="small primary">Close</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let W = canvas.width, H = canvas.height;

  // Graph data
  let nodes = []; // {id,label,x,y,color}
  let edges = []; // {id,u,v,w,status,color,highlight}
  let nextNodeId = 0;
  let nextEdgeId = 0;

  // modes: 'idle','add-node','add-edge','auto-edge'
  let mode = 'idle';
  let addEdgeFirst = null;
  let dragging = null;
  let dragOffset = {x:0,y:0};

  // Kruskal state
  let sortedEdges = []; // indices into edges
  let pointer = 0;
  let uf = null;
  let mst = []; // edge ids accepted
  let running = false;
  let timer = null;

  // UI elements
  const modeLabel = document.getElementById('mode-label');
  const addNodeBtn = document.getElementById('add-node');
  const addEdgeBtn = document.getElementById('add-edge');
  const autoEdgeBtn = document.getElementById('auto-edge');
  const randomBtn = document.getElementById('random-graph');
  const randN = document.getElementById('rand-n');
  const randD = document.getElementById('rand-d');
  const stepBtn = document.getElementById('step');
  const runBtn = document.getElementById('run');
  const resetBtn = document.getElementById('reset');
  const edgeListEl = document.getElementById('edge-list');
  const ufEl = document.getElementById('uf');
  const mstTotalEl = document.getElementById('mst-total');
  const mstCountEl = document.getElementById('mst-count');
  const edgeCountEl = document.getElementById('edge-count');
  const speedEl = document.getElementById('speed');
  const explainBtn = document.getElementById('explain');
  const helpDialog = document.getElementById('help');
  const closeHelp = document.getElementById('close-help');

  // Utilities
  function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }

  // Colors for components
  function palette(i){
    const cs = [
      '#f97316','#06b6d4','#7c3aed','#ef4444','#10b981','#f59e0b','#0ea5e9','#6366f1','#db2777','#84cc16'
    ];
    return cs[i % cs.length];
  }

  // Union-Find
  class UnionFind {
    constructor(n){
      this.parent = new Array(n);
      this.rank = new Array(n).fill(0);
      for(let i=0;i<n;i++) this.parent[i]=i;
    }
    find(a){
      if(this.parent[a] !== a) this.parent[a] = this.find(this.parent[a]);
      return this.parent[a];
    }
    union(a,b){
      a = this.find(a); b = this.find(b);
      if(a===b) return false;
      if(this.rank[a] < this.rank[b]) [a,b]=[b,a];
      this.parent[b]=a;
      if(this.rank[a]===this.rank[b]) this.rank[a]++;
      return true;
    }
  }

  // Graph operations
  function addNodeAt(x,y){
    const n = { id: nextNodeId++, label: String.fromCharCode(65 + (nextNodeId-1) % 26), x, y, color: palette(nodes.length) };
    nodes.push(n);
    rebuildState();
    draw();
    return n;
  }

  function addEdgeBetween(uId,vId,w=null){
    if(uId === vId) return null;
    // avoid duplicate undirected edge
    for(let e of edges){
      if((e.u===uId && e.v===vId) || (e.u===vId && e.v===uId)) return null;
    }
    if(w==null) w = rand(1,20);
    const e = { id: nextEdgeId++, u: uId, v: vId, w: w, status: 'unprocessed', color:'#bcd9ff' };
    edges.push(e);
    rebuildState();
    draw();
    return e;
  }

  function rebuildState(){
    // reset Kruskal state (you must press Reset to start over)
    sortedEdges = edges.slice().sort((a,b)=>a.w-b.w).map(e=>e.id);
    pointer = 0;
    uf = new UnionFind(nodes.length);
    mst = [];
    for(let e of edges){ e.status='unprocessed'; e.color='#bcd9ff'; }
    updateUI();
  }

  function resetAlgorithm(){
    if(timer) { clearInterval(timer); timer=null; running=false; runBtn.textContent='Play'; }
    sortedEdges = edges.slice().sort((a,b)=>a.w-b.w).map(e=>e.id);
    pointer = 0;
    uf = new UnionFind(nodes.length);
    mst = [];
    for(let e of edges){ e.status='unprocessed'; e.color='#bcd9ff'; }
    updateUI();
    draw();
  }

  // Find edge object by id
  function edgeById(id){ return edges.find(e=>e.id===id); }
  function nodeById(id){ return nodes.find(n=>n.id===id); }

  // Kruskal step
  function kruskalStep(){
    if(pointer >= sortedEdges.length){
      running=false;
      if(timer){ clearInterval(timer); timer=null; runBtn.textContent='Play'; }
      modeLabel.textContent = 'Finished — all edges processed';
      return;
    }
    // mark previous 'considering' (if any) as left as is (they should have been accepted/rejected)
    // Consider next edge
    const eid = sortedEdges[pointer];
    const edge = edgeById(eid);
    if(!edge){
      pointer++;
      return;
    }
    // mark as considering
    edge.status = 'considering';
    updateUI();
    draw();
    // small delay for visualization when auto; for step we do instantly
    // Check ends
    const uIndex = nodes.findIndex(n=>n.id===edge.u);
    const vIndex = nodes.findIndex(n=>n.id===edge.v);
    if(uIndex===-1 || vIndex===-1){
      edge.status = 'reject'; // invalid
      pointer++;
      updateUI();
      draw();
      return;
    }
    if(uf.find(uIndex) !== uf.find(vIndex)){
      // accept
      uf.union(uIndex, vIndex);
      edge.status = 'accept';
      mst.push(edge.id);
      edge.color = '#86e0a7';
    } else {
      edge.status = 'reject';
      edge.color = '#f6b0b0';
    }
    pointer++;
    updateUI();
    draw();

    // If MST complete (n-1 edges), we can stop early
    if(mst.length >= Math.max(0, nodes.length-1)){
      running=false;
      if(timer){ clearInterval(timer); timer=null; runBtn.textContent='Play'; }
      modeLabel.textContent = 'MST complete — n-1 edges selected';
    }
  }

  function runAuto(){
    if(running){
      running=false;
      if(timer){ clearInterval(timer); timer=null; }
      runBtn.textContent='Play';
      modeLabel.textContent='Paused';
      return;
    }
    if(pointer >= sortedEdges.length || mst.length >= Math.max(0, nodes.length-1)){
      resetAlgorithm();
    }
    running=true;
    runBtn.textContent='Pause';
    modeLabel.textContent='Running Kruskal...';
    timer = setInterval(()=>{
      kruskalStep();
      if(!running || pointer>=sortedEdges.length || mst.length >= Math.max(0, nodes.length-1)){
        running=false;
        if(timer){ clearInterval(timer); timer=null; }
        runBtn.textContent='Play';
      }
    }, Number(speedEl.value));
  }

  // UI update
  function updateUI(){
    // edge list sorted display
    edgeListEl.innerHTML = '';
    const sorted = edges.slice().sort((a,b)=>a.w-b.w);
    edgeCountEl.textContent = edges.length;
    for(let e of sorted){
      const div = document.createElement('div');
      div.className = 'edge-row';
      if(e.status==='considering') div.classList.add('consider');
      if(e.status==='accept') div.classList.add('accept');
      if(e.status==='reject') div.classList.add('reject');
      div.style.cursor = 'pointer';
      const u = nodeById(e.u), v = nodeById(e.v);
      const left = document.createElement('div');
      left.textContent = `${u ? u.label : '?'} — ${v ? v.label : '?'} (id:${e.id})`;
      left.style.color = '#244e7a';
      const right = document.createElement('div');
      right.innerHTML = `<span class="small-muted">w=</span><span class="weight">${e.w}</span>`;
      div.appendChild(left);
      div.appendChild(right);
      div.addEventListener('click', ()=>{
        // center/highlight this edge briefly
        for(let ed of edges) ed.highlight = false;
        e.highlight = true;
        draw();
        setTimeout(()=>{ e.highlight = false; draw(); }, 900);
      });
      edgeListEl.appendChild(div);
    }

    // UF display
    // Build mapping from index to parent and color by representative
    const nodeIndex = (id) => nodes.findIndex(n=>n.id===id);
    let content = '<div style="display:flex;gap:8px;flex-wrap:wrap">';
    if(nodes.length===0) content += '<div style="color:var(--muted)">No nodes</div>';
    else {
      // assign colors by rep
      let repColor = {};
      let repList = [];
      for(let i=0;i<nodes.length;i++){
        const r = uf.find ? uf.find(i) : i;
        if(!(r in repColor)){
          repColor[r] = palette(repList.length);
          repList.push(r);
        }
      }
      for(let i=0;i<nodes.length;i++){
        const n = nodes[i];
        const r = uf.find ? uf.find(i) : i;
        content += `<div style="border-radius:8px;padding:6px;background:#fbfdff;border:1px solid #e7f2ff;min-width:86px">
          <div style="font-size:13px;font-weight:700;color:#16324a">${n.label} (idx ${i})</div>
          <div style="font-size:12px;color:var(--muted)">rep: <span style="color:${repColor[r]};font-weight:700">${nodes[r] ? nodes[r].label+'('+r+')' : r}</span></div>
        </div>`;
      }
    }
    content += '</div>';
    ufEl.innerHTML = content;

    // MST info
    mstCountEl.textContent = mst.length;
    let total = 0;
    for(let id of mst){
      const e = edges.find(x=>x.id===id);
      if(e) total += e.w;
    }
    mstTotalEl.textContent = total;
  }

  // Drawing
  function draw(){
    ctx.clearRect(0,0,W,H);
    // draw edges
    for(let e of edges){
      const nu = nodeById(e.u);
      const nv = nodeById(e.v);
      if(!nu || !nv) continue;
      const hx = e.highlight ? 6 : 0;
      // edge line
      ctx.beginPath();
      ctx.moveTo(nu.x, nu.y);
      ctx.lineTo(nv.x, nv.y);
      ctx.lineWidth = e.highlight ? 5 : 3;
      let stroke = '#cfe9ff';
      if(e.status==='unprocessed') stroke = '#bcd9ff';
      else if(e.status==='considering') stroke = '#ffd389';
      else if(e.status==='accept') stroke = '#86e0a7';
      else if(e.status==='reject') stroke = '#f6b0b0';
      ctx.strokeStyle = stroke;
      ctx.lineCap = 'round';
      ctx.stroke();

      // weight circle: compute midpoint
      const mx = (nu.x + nv.x)/2;
      const my = (nu.y + nv.y)/2;
      ctx.beginPath();
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#c9e2ff';
      ctx.lineWidth = 1;
      ctx.roundRect ? ctx.roundRect(mx-18,my-12,36,24,6) : null;
      // fallback rounded rect
      roundRect(ctx, mx-18,my-12,36,24,6);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#0b3a66';
      ctx.font = '12px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(e.w), mx, my);

      // If considering, draw dashed highlight near middle
      if(e.status==='considering'){
        ctx.beginPath();
        ctx.strokeStyle = '#ffbe5a';
        ctx.setLineDash([6,4]);
        ctx.moveTo(nu.x, nu.y);
        ctx.lineTo(nv.x, nv.y);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // draw nodes
    for(let i=0;i<nodes.length;i++){
      const n = nodes[i];
      // fill color by representative
      let fill = n.color;
      if(uf){
        const r = uf.find(i);
        const idx = r % 10;
        fill = palette(idx);
      }
      // outer ring
      ctx.beginPath();
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = '#dbeafe';
      ctx.lineWidth = 3;
      ctx.arc(n.x, n.y, 20, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // inner circle
      ctx.beginPath();
      ctx.arc(n.x, n.y, 14, 0, Math.PI*2);
      ctx.fillStyle = fill;
      ctx.fill();

      // label
      ctx.fillStyle = '#06223a';
      ctx.font = 'bold 13px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(n.label, n.x, n.y);
    }
  }

  // small helper for rounded rect (if ctx.roundRect is not available)
  function roundRect(ctx, x, y, w, h, r){
    if(w<2*r) r=w/2;
    if(h<2*r) r=h/2;
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  // Event handlers
  canvas.addEventListener('mousedown', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    // check nodes first
    for(let i=nodes.length-1;i>=0;i--){
      const n = nodes[i];
      if(Math.hypot(n.x-x,n.y-y) <= 22){
        if(mode === 'add-edge'){
          if(addEdgeFirst == null){
            addEdgeFirst = n.id;
            modeLabel.textContent = `Add edge: selected ${n.label}. Click another node.`;
            return;
          } else {
            if(addEdgeFirst === n.id){
              modeLabel.textContent = 'Cannot create self-edge. Choose another node.';
              addEdgeFirst = null;
              return;
            }
            // prompt for weight
            const w = Number(prompt(`Weight for edge ${nodeById(addEdgeFirst).label} — ${n.label}:`, String(rand(1,20))));
            if(!isNaN(w) && w !== null){
              addEdgeBetween(addEdgeFirst, n.id, Math.max(0, Math.floor(w)));
            }
            addEdgeFirst = null;
            modeLabel.textContent = 'Add Edge mode — click nodes to add edges';
            return;
          }
        } else if(mode === 'auto-edge'){
          // Connect to nearest or create random weight edge from this node to another newly created?
          // We'll in auto-edge mode create a random edge from this node to another node chosen randomly
          if(nodes.length < 2){
            modeLabel.textContent = 'Need at least 2 nodes for edges.';
            return;
          }
          // pick random other node
          let other = n;
          while(other.id === n.id) other = nodes[rand(0,nodes.length-1)];
          addEdgeBetween(n.id, other.id, rand(1,20));
          return;
        } else {
          // start dragging
          dragging = n;
          dragOffset.x = x - n.x;
          dragOffset.y = y - n.y;
          return;
        }
      }
    }
    // If not on node
    if(mode === 'add-node'){
      addNodeAt(x,y);
    } else {
      // clicking empty space cancels addEdge selection
      addEdgeFirst = null;
    }
  });

  canvas.addEventListener('mousemove', (e)=>{
    if(!dragging) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    dragging.x = Math.max(24, Math.min(W-24, x - dragOffset.x));
    dragging.y = Math.max(24, Math.min(H-24, y - dragOffset.y));
    draw();
  });

  canvas.addEventListener('mouseup', (e)=>{
    dragging = null;
  });

  window.addEventListener('resize', ()=>{
    // keep canvas size stable relative to container
    const rect = canvas.getBoundingClientRect();
    W = canvas.width = rect.width;
    H = canvas.height = rect.height;
    draw();
  });

  // Buttons
  addNodeBtn.addEventListener('click', ()=>{
    mode = (mode === 'add-node') ? 'idle' : 'add-node';
    modeLabel.textContent = mode === 'add-node' ? 'Add Node mode — click canvas to add nodes' : 'Idle';
    addNodeBtn.classList.toggle('active', mode==='add-node');
    addEdgeBtn.classList.remove('active');
    autoEdgeBtn.classList.remove('active');
    if(mode!=='add-edge') addEdgeFirst = null;
  });

  addEdgeBtn.addEventListener('click', ()=>{
    mode = (mode === 'add-edge') ? 'idle' : 'add-edge';
    modeLabel.textContent = mode === 'add-edge' ? 'Add Edge mode — click two nodes to add an edge' : 'Idle';
    addEdgeBtn.classList.toggle('active', mode==='add-edge');
    addNodeBtn.classList.remove('active');
    autoEdgeBtn.classList.remove('active');
    addEdgeFirst = null;
  });

  autoEdgeBtn.addEventListener('click', ()=>{
    mode = (mode === 'auto-edge') ? 'idle' : 'auto-edge';
    modeLabel.textContent = mode === 'auto-edge' ? 'Auto-Edge mode — click a node to auto-add an edge to another node' : 'Idle';
    autoEdgeBtn.classList.toggle('active', mode==='auto-edge');
    addNodeBtn.classList.remove('active');
    addEdgeBtn.classList.remove('active');
    addEdgeFirst = null;
  });

  randomBtn.addEventListener('click', ()=>{
    // generate nodes in circle
    const n = Math.max(2, Math.min(30, Number(randN.value) || 8));
    const density = Number(randD.value);
    nodes = [];
    edges = [];
    nextNodeId = 0; nextEdgeId = 0;
    const cx = W/2, cy = H/2;
    const r = Math.min(W,H) / 2.6;
    for(let i=0;i<n;i++){
      const ang = (i/n) * Math.PI*2;
      const x = cx + Math.cos(ang) * (r * (0.6 + Math.random()*0.4));
      const y = cy + Math.sin(ang) * (r * (0.6 + Math.random()*0.4));
      addNodeAt(x,y);
    }
    // create edges randomly according to density
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        if(Math.random() < density){
          addEdgeBetween(nodes[i].id, nodes[j].id, rand(1,20));
        }
      }
    }
    rebuildState();
    draw();
  });

  stepBtn.addEventListener('click', ()=>{
    if(nodes.length === 0){ modeLabel.textContent = 'No nodes present'; return; }
    if(!uf || sortedEdges.length===0) rebuildState();
    running=false;
    if(timer){ clearInterval(timer); timer=null; runBtn.textContent='Play'; }
    kruskalStep();
  });

  runBtn.addEventListener('click', ()=>{
    if(!uf || sortedEdges.length===0) rebuildState();
    runAuto();
  });

  resetBtn.addEventListener('click', ()=>{
    resetAlgorithm();
    modeLabel.textContent = 'Algorithm reset';
  });

  explainBtn.addEventListener('click', ()=>{
    helpDialog.style.display='block';
  });
  closeHelp.addEventListener('click', ()=> helpDialog.style.display='none');

  // Edge list click highlight (delegated by updateUI using event listeners created there)

  // init sample graph
  function initSample(){
    nodes = []; edges = []; nextNodeId=0; nextEdgeId=0;
    const cols = 3;
    const rows = 3;
    const margin = 60;
    const nx = 3, ny = 3;
    for(let i=0;i<9;i++){
      const row = Math.floor(i/3), col = i%3;
      const x = 100 + col*250 + (Math.random()-0.5)*30;
      const y = 80 + row*150 + (Math.random()-0.5)*30;
      addNodeAt(x,y);
    }
    // connect some edges
    const all = nodes.map(n=>n.id);
    const pairs = [
      [0,1],[1,2],[0,3],[1,4],[2,5],[3,4],[4,5],[3,6],[4,7],[5,8],[6,7],[7,8]
    ];
    for(let p of pairs){
      addEdgeBetween(nodes[p[0]].id, nodes[p[1]].id, rand(1,20));
    }
    rebuildState();
    draw();
  }

  // initial
  initSample();

  // keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key === ' ') { e.preventDefault(); runBtn.click(); }
    if(e.key === 'Enter') { stepBtn.click(); }
    if(e.key === 'r' && e.ctrlKey) { randomBtn.click(); }
  });

  // small polyfill for roundRect if needed
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      roundRect(this,x,y,w,h,r);
    };
  }

  // Initial UI update
  rebuildState();
  draw();

})();
</script>
</body>
</html>