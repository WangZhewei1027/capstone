<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hash Table (Separate Chaining) — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#4fd1c5;
      --muted:#9aa8b3;
      --success:#16a34a;
      --danger:#ef4444;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    body{
      background: linear-gradient(180deg,#071028 0%, #061425 60%);
      color:#e6eef6;
      padding:20px;
      box-sizing:border-box;
    }
    .container{
      max-width:1100px;margin:0 auto;
    }
    header{display:flex;align-items:center;gap:16px;margin-bottom:18px}
    header h1{font-size:20px;margin:0}
    header p{margin:0;color:var(--muted);font-size:13px}
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;padding:16px;margin-bottom:18px;box-shadow:0 6px 24px rgba(2,6,23,0.6);
      border: 1px solid rgba(255,255,255,0.03);
    }
    .controls{
      display:flex;flex-wrap:wrap;gap:12px;align-items:center;
    }
    .controls .group{display:flex;gap:8px;align-items:center}
    input[type="text"], input[type="number"], select{
      background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:inherit;
      min-width:120px;
    }
    button{
      background:var(--accent);border:0;padding:8px 12px;border-radius:8px;color:#042027;font-weight:600;cursor:pointer;
      box-shadow:0 4px 10px rgba(79,209,197,0.12);
    }
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    .muted{color:var(--muted);font-size:13px}
    .visual{
      margin-top:14px;padding:12px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:8px;
      overflow:auto;
    }
    .buckets{
      display:flex;gap:10px;padding:10px;
    }
    .bucket{
      min-width:130px;background:var(--glass);border-radius:10px;padding:10px;border:1px solid rgba(255,255,255,0.03);
      display:flex;flex-direction:column;gap:8px;align-items:center;
    }
    .bindex{font-size:12px;color:var(--muted);background:rgba(255,255,255,0.02);padding:4px 6px;border-radius:6px}
    .chain{
      display:flex;flex-direction:column;gap:6px;width:100%;align-items:center;min-height:36px;
    }
    .node{
      background:#071a1a;padding:6px 8px;border-radius:8px;color:#c9fff7;border:1px solid rgba(79,209,197,0.08);
      width:92%;display:flex;justify-content:space-between;font-size:13px;
    }
    .node .k{font-weight:700;color:#bff3ee}
    .node .v{color:var(--muted);font-weight:600}
    .node.highlight{box-shadow:0 6px 18px rgba(79,209,197,0.12);transform:translateY(-4px);transition:transform 220ms}
    .node.found{background:linear-gradient(90deg,#153a2f,#0c3e32);border-color:rgba(22,163,74,0.6)}
    .node.del{opacity:0.45;text-decoration:line-through}
    .status{
      display:flex;gap:12px;flex-wrap:wrap;margin-top:12px;
    }
    .status .item{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;min-width:120px;text-align:center;border:1px solid rgba(255,255,255,0.03)}
    .status .item .num{font-weight:700;font-size:16px}
    .log{margin-top:12px;background:rgba(0,0,0,0.15);padding:8px;border-radius:8px;height:110px;overflow:auto;font-family:monospace;font-size:13px}
    small.hint{color:var(--muted);display:block;margin-top:6px}
    .controls-wrap{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap}
    .leftcol{flex:1;min-width:320px}
    .rightcol{width:360px}
    footer{margin-top:10px;color:var(--muted);font-size:13px}
    .legend{display:flex;gap:8px;align-items:center;margin-top:8px}
    .legend .chip{width:12px;height:12px;border-radius:3px}
    .chip.find{background:linear-gradient(90deg,#153a2f,#0c3e32)}
    .chip.coll{background:#3b82f6}
    @media (max-width:880px){
      .buckets{flex-wrap:wrap}
      .rightcol{width:100%}
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Hash Table — Separate Chaining (Interactive)</h1>
        <p>Explore basic hash table operations (insert/get/delete), collisions, load factor, and automatic resizing.</p>
      </div>
    </header>

    <div class="card controls-wrap">
      <div class="leftcol">
        <div class="controls">
          <div class="group">
            <label class="muted">Key</label>
            <input id="keyInput" type="text" placeholder="e.g. apple" />
            <label class="muted">Value</label>
            <input id="valInput" type="text" placeholder="e.g. 42" />
            <button id="insertBtn">Insert</button>
            <button id="searchBtn" class="ghost">Search</button>
            <button id="deleteBtn" class="ghost">Delete</button>
          </div>
        </div>
        <small class="hint">Keys are strings. Hash function used: djb2 (demonstration). Collisions are handled with separate chaining (linked lists).</small>

        <div class="controls" style="margin-top:12px;">
          <div class="group">
            <label class="muted">Table size</label>
            <input id="sizeInput" type="number" min="2" value="8" />
            <button id="resizeBtn" class="ghost">Resize Table</button>
          </div>
          <div class="group">
            <label class="muted">Auto-resize?</label>
            <input id="autoResize" type="checkbox" checked />
            <label class="muted">Threshold</label>
            <input id="threshold" type="number" min="0.1" max="1" step="0.05" value="0.75" />
          </div>
          <div class="group">
            <button id="randomBtn" class="ghost">Insert Random (10)</button>
            <button id="clearBtn" class="ghost">Clear</button>
          </div>
        </div>
      </div>

      <div class="rightcol">
        <div class="status">
          <div class="item"><div class="muted">Buckets</div><div id="bucketsCount" class="num">0</div></div>
          <div class="item"><div class="muted">Elements</div><div id="elemsCount" class="num">0</div></div>
          <div class="item"><div class="muted">Collisions</div><div id="collisionsCount" class="num">0</div></div>
          <div class="item"><div class="muted">Load factor</div><div id="loadFactor" class="num">0</div></div>
        </div>

        <div class="legend">
          <div class="chip find"></div><div class="muted">Found</div>
          <div class="chip coll"></div><div class="muted">Collision (bucket occupied)</div>
        </div>

        <div class="log" id="log"></div>
      </div>
    </div>

    <div class="card visual">
      <div id="visualArea">
        <div class="buckets" id="buckets"></div>
      </div>
    </div>

    <footer>
      Tip: Try inserting keys that collide (like "a", "k", "u" in small table), then resize the table to see rehashing.
    </footer>
  </div>

<script>
/*
  Hash Table demo (Separate Chaining)
  - djb2 hash function for strings
  - buckets are arrays (simulate linked lists)
  - tracks collisions, supports auto-resize
  - visualization with DOM updates and simple highlights
*/

// -------- HashTable class ----------
class HashTable {
  constructor(capacity = 8, onChange = ()=>{}) {
    this.capacity = Math.max(2, Math.floor(capacity));
    this.buckets = Array.from({length: this.capacity}, ()=> []);
    this._size = 0;
    this.collisions = 0; // count of insert collisions (inserting into non-empty bucket)
    this.onChange = onChange;
  }

  // djb2 hashing algorithm for strings -> non-negative integer
  hash(key){
    const str = String(key);
    let hash = 5381;
    for(let i=0;i<str.length;i++){
      hash = ((hash << 5) + hash) + str.charCodeAt(i); // hash * 33 + c
      hash = hash | 0; // ensure 32-bit
    }
    return Math.abs(hash);
  }

  indexFor(key){
    return this.hash(key) % this.capacity;
  }

  // Insert key -> value (if key exists, overwrite)
  put(key, value){
    const idx = this.indexFor(key);
    const bucket = this.buckets[idx];

    // check if key exists, overwrite
    for(let node of bucket){
      if(node.key === key){
        node.value = value;
        this.onChange({type:'update', key, value, index: idx});
        return {action:'update', index: idx};
      }
    }

    // new insertion
    if(bucket.length > 0){
      this.collisions += 1;
      // we still append to chain
    }
    bucket.push({key, value});
    this._size += 1;
    this.onChange({type:'insert', key, value, index: idx, collided: bucket.length>1});
    return {action:'insert', index: idx, collided: bucket.length>1};
  }

  // Get value (returns {found, value, index})
  get(key){
    const idx = this.indexFor(key);
    const bucket = this.buckets[idx];
    for(let node of bucket){
      if(node.key === key) return {found:true, value:node.value, index: idx};
    }
    return {found:false, index: idx};
  }

  // Remove key (returns true if removed)
  remove(key){
    const idx = this.indexFor(key);
    const bucket = this.buckets[idx];
    for(let i=0;i<bucket.length;i++){
      if(bucket[i].key === key){
        const removed = bucket.splice(i,1)[0];
        this._size -= 1;
        this.onChange({type:'remove', key, index: idx});
        return {removed:true, value: removed.value, index: idx};
      }
    }
    return {removed:false, index: idx};
  }

  keys(){
    const arr = [];
    for(const bucket of this.buckets){
      for(const node of bucket) arr.push(node.key);
    }
    return arr;
  }

  size(){ return this._size; }
  bucketsCount(){ return this.capacity; }
  loadFactor(){ return this.capacity===0 ? 0 : (this._size / this.capacity); }

  clear(){
    this.buckets = Array.from({length: this.capacity}, ()=> []);
    this._size = 0;
    this.collisions = 0;
    this.onChange({type:'clear'});
  }

  // Resize and rehash into newCapacity
  rehash(newCapacity){
    newCapacity = Math.max(2, Math.floor(newCapacity));
    const oldBuckets = this.buckets;
    this.capacity = newCapacity;
    this.buckets = Array.from({length: this.capacity}, ()=> []);
    this._size = 0;
    this.collisions = 0;
    // re-insert all entries (will recompute collisions)
    for(const bucket of oldBuckets){
      for(const node of bucket){
        this.put(node.key, node.value);
      }
    }
    this.onChange({type:'rehash', newCapacity});
  }
}

// -------- UI and wiring ----------
const bucketsEl = document.getElementById('buckets');
const keyInput = document.getElementById('keyInput');
const valInput = document.getElementById('valInput');
const insertBtn = document.getElementById('insertBtn');
const searchBtn = document.getElementById('searchBtn');
const deleteBtn = document.getElementById('deleteBtn');
const sizeInput = document.getElementById('sizeInput');
const resizeBtn = document.getElementById('resizeBtn');
const randomBtn = document.getElementById('randomBtn');
const clearBtn = document.getElementById('clearBtn');
const autoResize = document.getElementById('autoResize');
const threshold = document.getElementById('threshold');

const bucketsCountEl = document.getElementById('bucketsCount');
const elemsCountEl = document.getElementById('elemsCount');
const collisionsCountEl = document.getElementById('collisionsCount');
const loadFactorEl = document.getElementById('loadFactor');
const logEl = document.getElementById('log');

let ht = new HashTable(parseInt(sizeInput.value), handleChange);
render();

// Helper: log messages
function log(msg, type='info'){
  const time = new Date().toLocaleTimeString();
  const line = document.createElement('div');
  line.textContent = `[${time}] ${msg}`;
  line.style.color = (type==='error' ? 'var(--danger)' : (type==='success'? 'var(--success)' : 'inherit'));
  logEl.prepend(line);
}

// Render buckets to DOM
function render(highlight=null){
  bucketsEl.innerHTML = '';
  for(let i=0;i<ht.capacity;i++){
    const bucketDiv = document.createElement('div');
    bucketDiv.className = 'bucket';
    const idx = document.createElement('div');
    idx.className = 'bindex';
    idx.textContent = `#${i}`;
    bucketDiv.appendChild(idx);

    const chain = document.createElement('div');
    chain.className = 'chain';

    const bucket = ht.buckets[i];
    if(bucket.length === 0){
      const empty = document.createElement('div');
      empty.className = 'node';
      empty.style.justifyContent = 'center';
      empty.style.opacity = 0.45;
      empty.textContent = '(empty)';
      chain.appendChild(empty);
    } else {
      for(const node of bucket){
        const nd = document.createElement('div');
        nd.className = 'node';
        nd.innerHTML = `<span class="k">${escapeHtml(node.key)}</span><span class="v">${escapeHtml(String(node.value))}</span>`;
        chain.appendChild(nd);
      }
    }

    bucketDiv.appendChild(chain);
    bucketsEl.appendChild(bucketDiv);
  }

  updateStats();

  // if highlight instructed set styles
  if(highlight){
    // highlight bucket index by adding a top border color, and optionally highlight nodes
    const bucketEl = bucketsEl.children[highlight.index];
    if(bucketEl){
      bucketEl.style.transition = 'box-shadow 300ms';
      bucketEl.style.boxShadow = '0 10px 40px rgba(79,209,197,0.06)';
      setTimeout(()=> bucketEl.style.boxShadow = '', 900);
      if(highlight.keyFound){
        // find the node and add found class
        const nodes = bucketEl.querySelectorAll('.node');
        for(const n of nodes){
          if(n.querySelector('.k') && n.querySelector('.k').textContent === highlight.key){
            n.classList.add('found','highlight');
            setTimeout(()=> n.classList.remove('highlight'), 900);
            break;
          }
        }
      } else if(highlight.showCollision){
        // make first node show collided by briefly highlighting
        const first = bucketEl.querySelector('.node');
        if(first){
          first.classList.add('highlight');
          setTimeout(()=> first.classList.remove('highlight'), 900);
        }
      } else if(highlight.removed){
        // find removed node — we can't show it (it was removed), but flash bucket
        bucketEl.style.opacity = 0.9;
        setTimeout(()=> bucketEl.style.opacity = 1, 900);
      }
    }
  }
}

// Escape until safe HTML injection for keys/values
function escapeHtml(s){
  return s.replace(/[&<>"']/g, (m)=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

function updateStats(){
  bucketsCountEl.textContent = ht.bucketsCount();
  elemsCountEl.textContent = ht.size();
  collisionsCountEl.textContent = ht.collisions;
  loadFactorEl.textContent = (ht.loadFactor()).toFixed(3);
}

// Handle HashTable events (called from class via onChange)
function handleChange(evt){
  // evt: {type, ...}
  switch(evt.type){
    case 'insert':
      log(`Inserted key "${evt.key}" at bucket ${evt.index}` + (evt.collided ? ' (collision occurred)':''), 'success');
      render({index: evt.index, showCollision: evt.collided});
      maybeAutoResize();
      break;
    case 'update':
      log(`Updated key "${evt.key}" at bucket ${evt.index}`, 'info');
      render({index: evt.index, keyFound: true});
      break;
    case 'remove':
      log(`Removed key "${evt.key}" from bucket ${evt.index}`, 'info');
      render({index: evt.index, removed: true});
      break;
    case 'rehash':
      log(`Table rehashed to new capacity: ${evt.newCapacity}`, 'info');
      render();
      break;
    case 'clear':
      log(`Table cleared`, 'info');
      render();
      break;
  }
}

// Auto resize if enabled and loadFactor > threshold
function maybeAutoResize(){
  if(!autoResize.checked) return;
  const th = parseFloat(threshold.value) || 0.75;
  if(ht.loadFactor() > th){
    // double capacity
    const newCap = ht.capacity * 2;
    log(`Load factor ${ht.loadFactor().toFixed(3)} > ${th}. Auto-resizing to ${newCap}...`);
    // small delay to show message before heavy rehash
    setTimeout(()=> ht.rehash(newCap), 250);
  }
}

// Button handlers
insertBtn.addEventListener('click', ()=>{
  const key = keyInput.value.trim();
  const val = valInput.value;
  if(key === ''){
    log('Please enter a non-empty key', 'error'); return;
  }
  ht.put(key, val);
  keyInput.focus();
});

searchBtn.addEventListener('click', ()=>{
  const key = keyInput.value.trim();
  if(key === ''){
    log('Please enter a key to search', 'error'); return;
  }
  const res = ht.get(key);
  if(res.found){
    log(`Found key "${key}" in bucket ${res.index} -> value: ${res.value}`, 'success');
    render({index: res.index, keyFound: true, key});
  } else {
    log(`Key "${key}" not found (would be in bucket ${res.index})`, 'error');
    render({index: res.index});
  }
});

deleteBtn.addEventListener('click', ()=>{
  const key = keyInput.value.trim();
  if(key === ''){
    log('Please enter a key to delete', 'error'); return;
  }
  const res = ht.remove(key);
  if(res.removed){
    log(`Removed key "${key}" (bucket ${res.index})`, 'success');
    render({index: res.index, removed:true});
  } else {
    log(`Key "${key}" not found (nothing removed)`, 'error');
    render({index: res.index});
  }
});

resizeBtn.addEventListener('click', ()=>{
  const newSize = parseInt(sizeInput.value) || ht.capacity;
  if(newSize < 2){ log('Size must be at least 2', 'error'); return; }
  ht.rehash(newSize);
});

randomBtn.addEventListener('click', ()=>{
  const words = ["apple","banana","cherry","date","egg","fig","grape","kiwi","lemon","mango","nectarine",
                 "olive","papaya","quince","rasp","straw","tango","umbrella","violet","walnut","xray","yarn","zebra"];
  // insert 10 random key-value pairs (could collide)
  for(let i=0;i<10;i++){
    const k = words[Math.floor(Math.random()*words.length)] + (Math.random() < 0.5 ? '' : '_' + Math.floor(Math.random()*100));
    const v = Math.floor(Math.random()*999);
    ht.put(k, v);
  }
  render();
});

clearBtn.addEventListener('click', ()=>{
  ht.clear();
});

// allow Enter key to insert
[keyInput, valInput].forEach(el=>el.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter'){
    insertBtn.click();
  }
}));

// Initialize with a few keys to illustrate collisions in small table
(function seedDemo(){
  ht.put('a', 1);
  ht.put('k', 2);
  ht.put('u', 3);
  ht.put('apple', 'fruit');
  ht.put('banana', 'fruit');
  render();
  log('Demo seeded with a few keys. Try searching for "a", "k", "u" or resizing the table.', 'info');
})();

// Expose some debug utilities to console
window._ht = ht;
window._render = render;
window._log = log;

</script>
</body>
</html>