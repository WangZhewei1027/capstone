<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Two Pointers — Interactive Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#2dd4bf;
      --muted:#98a8b9;
      --panel:#071025;
      --box:#0b1b2a;
      --white:#e6eef6;
    }
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#051025 0%, #071227 50%, #081624 100%);color:var(--white)}
    header{padding:18px 28px;border-bottom:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;gap:18px}
    h1{font-size:18px;margin:0}
    .container{display:grid;grid-template-columns:360px 1fr;gap:18px;padding:20px;max-width:1200px;margin:18px auto}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03)}
    .left{height:calc(100vh - 140px);overflow:auto;padding-bottom:30px}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    input[type=text],textarea,select{width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:rgba(255,255,255,0.02);color:var(--white);outline:none}
    .controls{display:flex;gap:8px;margin-top:10px}
    button{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);color:var(--white);padding:8px 10px;border-radius:8px;cursor:pointer}
    button.primary{background:linear-gradient(90deg,var(--accent),#60a5fa);color:#001219;border:none}
    .small{padding:6px 8px;font-size:13px}
    .algo-list{display:flex;flex-direction:column;gap:6px}
    .algo-item{display:flex;align-items:center;gap:10px;padding:8px;border-radius:8px;cursor:pointer}
    .algo-item input{transform:scale(1.1)}
    .visual{padding:16px;min-height:320px;display:flex;flex-direction:column;gap:14px}
    .array-row{position:relative;padding:14px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));display:flex;gap:10px;align-items:flex-end;overflow:auto}
    .cell{min-width:48px;height:48px;border-radius:8px;background:var(--box);display:flex;align-items:center;justify-content:center;color:var(--white);font-weight:600;border:1px solid rgba(255,255,255,0.03);position:relative}
    .cell.small{min-width:36px;height:36px;font-weight:600}
    .pointer{position:absolute;top:-28px;font-size:12px;padding:4px 8px;border-radius:6px;color:#001219;background:var(--accent);transform:translateX(-50%);white-space:nowrap}
    .pointer.r{background:#60a5fa;color:#001219}
    .cell.marked{outline:3px solid rgba(45,212,191,0.12)}
    .cell.found{outline:3px solid rgba(96,165,250,0.18)}
    .description{padding:12px;border-radius:10px;background:rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}
    pre{background:rgba(0,0,0,0.18);padding:10px;border-radius:8px;overflow:auto;font-size:12px;color:#e6f7f3}
    .statusbar{display:flex;justify-content:space-between;gap:12px;align-items:center;margin-top:10px;font-size:13px;color:var(--muted)}
    .footer{margin-top:12px;color:var(--muted);font-size:12px}
    .result{font-weight:700;color:var(--white)}
    .log{max-height:160px;overflow:auto;margin-top:10px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.01);font-size:13px}
    .speed{display:flex;align-items:center;gap:8px}
    @media (max-width:880px){
      .container{grid-template-columns:1fr;padding:12px}
      .left{height:auto}
    }
  </style>
</head>
<body>
  <header>
    <h1>Two Pointers — Interactive Visualizer</h1>
    <div style="margin-left:auto;color:var(--muted);font-size:13px">Learn pointer movement patterns used to solve array/string problems efficiently</div>
  </header>

  <div class="container">
    <div class="panel left">
      <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
        <div>
          <label>Choose algorithm</label>
          <select id="algoSelect">
            <option value="pairSum">Pair Sum (sorted) — find two numbers that add to target</option>
            <option value="removeDuplicates">Remove Duplicates (sorted) — in-place</option>
            <option value="reverseString">Reverse String — swap with two pointers</option>
            <option value="maxContainer">Container With Most Water — max area</option>
            <option value="partitionParity">Partition by Parity — evens left, odds right</option>
          </select>
        </div>
        <div style="width:160px">
          <label>Animation speed</label>
          <div class="speed"><input id="speed" type="range" min="50" max="1500" value="500"><span id="speedLabel" style="width:56px;text-align:right;color:var(--muted);font-size:13px">500 ms</span></div>
        </div>
      </div>

      <div style="margin-top:12px">
        <label id="inputLabel">Input array (numbers separated by commas)</label>
        <input id="inputArray" type="text" value="1,2,3,4,5,6,7,8,9">
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="randomBtn" class="small">Random</button>
          <button id="sortBtn" class="small">Sort</button>
          <button id="parseBtn" class="small primary">Run & Build Steps</button>
        </div>
      </div>

      <div id="targetArea" style="margin-top:12px;display:block">
        <label>Target value (for Pair Sum)</label>
        <input id="targetInput" type="text" value="10">
      </div>

      <div style="margin-top:12px">
        <label>Controls</label>
        <div class="controls">
          <button id="playBtn" class="small primary">Play</button>
          <button id="pauseBtn" class="small">Pause</button>
          <button id="stepBack" class="small">Step ◀</button>
          <button id="stepForward" class="small">Step ▶</button>
          <button id="resetBtn" class="small">Reset</button>
        </div>
      </div>

      <div style="margin-top:12px">
        <label>Quick presets</label>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button class="small" data-preset="1,2,3,4,5,6,7">1..7</button>
          <button class="small" data-preset="2,3,4,5,9,11">2,3,4,5,9,11</button>
          <button class="small" data-preset="5,4,3,2,1">5,4,3,2,1</button>
          <button class="small" data-preset="20,18,17,6,5,4,2">20,18,17,6,5,4,2</button>
          <button class="small" data-preset="1,1,2,2,3,3,4">1,1,2,2,3,3,4</button>
        </div>
      </div>

      <div style="margin-top:14px">
        <label>Description</label>
        <div class="description" id="algoDesc">
          Two pointers is a technique where you maintain two indices (pointers) that move through a data structure to satisfy some condition. It is commonly used on sorted arrays or when you need to operate from both ends. Choose an algorithm and press "Run & Build Steps" to see pointer movements.
        </div>
      </div>

      <div style="margin-top:14px">
        <label>Complexity</label>
        <div class="description" id="algoComplexity">
          Time: O(n) typical for two-pointer passes. Space: O(1) extra (in-place), unless algorithm requires extra output.
        </div>
      </div>

      <div style="margin-top:14px">
        <label>Code (pseudo/JS)</label>
        <pre id="codeBlock">
// Code preview will appear here for the selected algorithm
        </pre>
      </div>

    </div>

    <div class="panel visual">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
        <div style="font-weight:700">Visualization</div>
        <div style="display:flex;gap:8px;align-items:center">
          <div class="statusbar" style="gap:8px">
            <div>Step: <span id="stepIdx">0</span>/<span id="stepMax">0</span></div>
            <div>Ops: <span id="opsCount">0</span></div>
            <div>Result: <span class="result" id="resultText">—</span></div>
          </div>
        </div>
      </div>

      <div class="array-row" id="arrayRow" style="min-height:96px">
        <!-- cells injected here -->
      </div>

      <div id="annotation" class="description">Build steps to begin.</div>

      <div id="log" class="log" style="display:none"></div>

      <div style="margin-top:auto">
        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between">
          <div style="font-size:13px;color:var(--muted)">Use Step buttons or Play to animate. You can edit the input and rebuild steps anytime.</div>
          <div style="font-size:12px;color:var(--muted)"><em>Two Pointers</em> — small, simple demos — educational use</div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // Utilities
  const qs = s => document.querySelector(s);
  const qsa = s => Array.from(document.querySelectorAll(s));

  // Elements
  const algoSelect = qs('#algoSelect');
  const inputArray = qs('#inputArray');
  const parseBtn = qs('#parseBtn');
  const arrayRow = qs('#arrayRow');
  const annotation = qs('#annotation');
  const codeBlock = qs('#codeBlock');
  const speed = qs('#speed');
  const speedLabel = qs('#speedLabel');
  const playBtn = qs('#playBtn');
  const pauseBtn = qs('#pauseBtn');
  const stepForward = qs('#stepForward');
  const stepBack = qs('#stepBack');
  const resetBtn = qs('#resetBtn');
  const stepIdxEl = qs('#stepIdx');
  const stepMaxEl = qs('#stepMax');
  const opsCountEl = qs('#opsCount');
  const resultText = qs('#resultText');
  const randomBtn = qs('#randomBtn');
  const sortBtn = qs('#sortBtn');
  const targetArea = qs('#targetArea');
  const targetInput = qs('#targetInput');
  const algoDesc = qs('#algoDesc');
  const algoComplexity = qs('#algoComplexity');
  const logEl = qs('#log');
  const presets = qsa('[data-preset]');

  // State
  let steps = []; // each step: {arr, left, right, i, j, desc, marked:[], found:boolean, result}
  let currentStep = -1;
  let timer = null;
  let playInterval = 500;
  let ops = 0;

  // Algorithms definitions
  const algorithms = {
    pairSum: {
      name: 'Pair Sum (sorted)',
      short: 'Find two numbers that add to target using left/right pointer',
      complexity: 'Time: O(n). Space: O(1). Requires sorted array (or sort first).',
      code:
`// Sorted array two-pointer pair sum (target)
let l = 0, r = arr.length-1;
while (l < r) {
  const s = arr[l] + arr[r];
  if (s === target) return [l, r];
  if (s < target) l++;
  else r--;
}
return null;`,
      build: (inputArr, opts) => {
        const arr = inputArr.slice();
        const target = opts.target;
        let l = 0, r = arr.length - 1;
        const out = [];
        let found = false;
        let opsLocal = 0;
        out.push(snapshot(arr, l, r, `Start (target=${target})`));
        while (l < r) {
          opsLocal++;
          const s = arr[l] + arr[r];
          out.push(snapshot(arr, l, r, `Compare arr[${l}] + arr[${r}] = ${arr[l]} + ${arr[r]} = ${s}`));
          if (s === target) {
            out.push(snapshot(arr, l, r, `Found! Indices ${l} and ${r}`, {found:true, result:[l,r]}));
            found = true;
            break;
          }
          if (s < target) {
            l++;
            out.push(snapshot(arr, l, r, `Sum < target => move left pointer right to ${l}`));
          } else {
            r--;
            out.push(snapshot(arr, l, r, `Sum > target => move right pointer left to ${r}`));
          }
        }
        if (!found) {
          out.push(snapshot(arr, l, r, `No pair found`));
        }
        return {steps:out, ops:opsLocal, result: found ? out.find(s=>s.found).result : null};
      },
    },

    removeDuplicates: {
      name: 'Remove Duplicates (sorted)',
      short: 'In-place remove duplicates from sorted array. Return new length',
      complexity: 'Time: O(n). Space: O(1). Modifies array in place.',
      code:
`// Remove duplicates from sorted array in-place
let i = 0; // slow pointer
for (let j = 1; j < arr.length; j++) {
  if (arr[j] !== arr[i]) {
    i++;
    arr[i] = arr[j];
  }
}
return i + 1;`,
      build: (inputArr) => {
        const arr = inputArr.slice();
        const out = [];
        if (arr.length === 0) {
          out.push(snapshot(arr, -1, -1, 'Empty array'));
          return {steps:out, ops:0, result:0};
        }
        let i = 0;
        out.push(snapshot(arr, i, 1, `Start: i=0 (position of last unique)`));
        let opsLocal = 0;
        for (let j = 1; j < arr.length; j++) {
          opsLocal++;
          out.push(snapshot(arr, i, j, `Compare arr[${j}]=${arr[j]} with arr[${i}]=${arr[i]}`));
          if (arr[j] !== arr[i]) {
            i++;
            arr[i] = arr[j];
            out.push(snapshot(arr.slice(), i, j, `Unique found, copy arr[${j}] to arr[${i}]`, {marked:[i]}));
          } else {
            out.push(snapshot(arr.slice(), i, j, `Duplicate — skip`));
          }
        }
        out.push(snapshot(arr.slice(), i, arr.length-1, `Done. New length = ${i+1}`, {result:i+1}));
        return {steps:out, ops:opsLocal, result:i+1};
      }
    },

    reverseString: {
      name: 'Reverse String',
      short: 'Swap characters with two pointers from both ends',
      complexity: 'Time: O(n/2). Space: O(1) if using char array.',
      code:
`let l = 0, r = s.length - 1;
while (l < r) {
  // swap s[l] and s[r]
  const tmp = s[l];
  s[l] = s[r];
  s[r] = tmp;
  l++; r--;
}
return s;`,
      build: (inputStr) => {
        // inputStr is an array of characters or a string
        const arr = Array.from(inputStr.join ? inputStr : String(inputStr));
        const out = [];
        let l = 0, r = arr.length - 1;
        out.push(snapshot(arr.slice(), l, r, `Start`));
        let opsLocal = 0;
        while (l < r) {
          opsLocal++;
          out.push(snapshot(arr.slice(), l, r, `Swap arr[${l}]='${arr[l]}' and arr[${r}]='${arr[r]}'`));
          const tmp = arr[l];
          arr[l] = arr[r];
          arr[r] = tmp;
          out.push(snapshot(arr.slice(), l, r, `After swap`, {marked:[l,r]}));
          l++; r--;
        }
        out.push(snapshot(arr.slice(), l, r, `Done. Result: "${arr.join('')}"`, {result:arr.join('')}));
        return {steps:out, ops:opsLocal, result:arr.join('')};
      }
    },

    maxContainer: {
      name: 'Container With Most Water',
      short: 'Keep left and right pointers; compute area and move smaller height pointer',
      complexity: 'Time: O(n). Space: O(1).',
      code:
`let l = 0, r = height.length - 1;
let maxArea = 0;
while (l < r) {
  const area = Math.min(height[l], height[r]) * (r - l);
  maxArea = Math.max(maxArea, area);
  if (height[l] < height[r]) l++; else r--;
}
return maxArea;`,
      build: (inputArr) => {
        const arr = inputArr.slice();
        const out = [];
        let l = 0, r = arr.length - 1;
        let maxArea = 0, best = null;
        out.push(snapshot(arr.slice(), l, r, `Start`));
        let opsLocal = 0;
        while (l < r) {
          opsLocal++;
          const hL = arr[l], hR = arr[r];
          const area = Math.min(hL, hR) * (r - l);
          out.push(snapshot(arr.slice(), l, r, `Compute area = min(${hL},${hR}) * (${r}-${l}) = ${area}`));
          if (area > maxArea) {
            maxArea = area;
            best = [l, r, area];
            out.push(snapshot(arr.slice(), l, r, `New max area ${area} at (${l},${r})`, {marked:[l,r], result:area}));
          }
          if (hL < hR) {
            l++;
            out.push(snapshot(arr.slice(), l, r, `Move left pointer to ${l} (height ${hL} < ${hR})`));
          } else {
            r--;
            out.push(snapshot(arr.slice(), l, r, `Move right pointer to ${r} (height ${hR} <= ${hL})`));
          }
        }
        out.push(snapshot(arr.slice(), l, r, `Done. Max area = ${maxArea}`, {result:maxArea}));
        return {steps:out, ops:opsLocal, result:maxArea};
      }
    },

    partitionParity: {
      name: 'Partition by Parity',
      short: 'Place even numbers left and odd right using two pointers',
      complexity: 'Time: O(n). Space: O(1).',
      code:
`let l = 0, r = arr.length - 1;
while (l < r) {
  while (l < r && arr[l] % 2 === 0) l++;
  while (l < r && arr[r] % 2 !== 0) r--;
  if (l < r) swap(arr, l, r), l++, r--;
}
return arr;`,
      build: (inputArr) => {
        const arr = inputArr.slice();
        const out = [];
        let l = 0, r = arr.length - 1;
        out.push(snapshot(arr.slice(), l, r, 'Start'));
        let opsLocal = 0;
        while (l < r) {
          opsLocal++;
          if (arr[l] % 2 === 0) {
            out.push(snapshot(arr.slice(), l, r, `arr[${l}]=${arr[l]} is even -> advance left`));
            l++; continue;
          }
          if (arr[r] % 2 !== 0) {
            out.push(snapshot(arr.slice(), l, r, `arr[${r}]=${arr[r]} is odd -> move right`));
            r--; continue;
          }
          // now arr[l] is odd, arr[r] is even => swap
          out.push(snapshot(arr.slice(), l, r, `Swap odd arr[${l}]=${arr[l]} with even arr[${r}]=${arr[r]}`));
          const tmp = arr[l]; arr[l] = arr[r]; arr[r] = tmp;
          out.push(snapshot(arr.slice(), l, r, `After swap`, {marked:[l,r]}));
          l++; r--;
        }
        out.push(snapshot(arr.slice(), l, r, `Done. Partitioned array`, {result:arr.slice()}));
        return {steps:out, ops:opsLocal, result:arr.slice()};
      }
    }
  };

  function snapshot(arr, left=-1, right=-1, desc='', opts={}) {
    return {
      arr: Array.isArray(arr) ? arr.slice() : JSON.parse(JSON.stringify(arr)),
      left: left,
      right: right,
      desc: desc || '',
      marked: opts.marked || [],
      found: !!opts.found,
      result: opts.result !== undefined ? opts.result : null
    };
  }

  // UI helpers
  function renderArrayStep(step) {
    arrayRow.innerHTML = '';
    if (!step) return;
    const arr = step.arr;
    // adapt cell size for long arrays
    const cellClass = arr.length > 14 ? 'cell small' : 'cell';
    arr.forEach((v,i) => {
      const c = document.createElement('div');
      c.className = cellClass;
      c.textContent = String(v);
      if (step.marked && step.marked.includes(i)) c.classList.add('marked');
      if (step.found && (i===step.left || i===step.right)) c.classList.add('found');
      arrayRow.appendChild(c);
    });
    // pointers as absolute positioned elements above the corresponding cell
    placePointer('L', step.left, 'pointer l');
    placePointer('R', step.right, 'pointer r');
    // description
    annotation.textContent = step.desc || '';
    // result text
    if (step.result !== null && step.result !== undefined) {
      resultText.textContent = formatResult(step.result);
    } else {
      resultText.textContent = '—';
    }
  }

  function formatResult(r) {
    if (Array.isArray(r)) return '['+r.join(', ')+']';
    if (typeof r === 'object') return JSON.stringify(r);
    return String(r);
  }

  function placePointer(label, index, classes) {
    // remove existing with that label
    const existing = arrayRow.querySelector(`.pointer.${label}`);
    if (existing) existing.remove();
    if (index < 0 || index >= arrayRow.children.length) return;
    const cell = arrayRow.children[index];
    const p = document.createElement('div');
    p.className = `pointer ${classes} ${label.toLowerCase()}`;
    p.textContent = label;
    // position above cell by translating relative to arrayRow
    // compute left offset
    const cellRect = cell.getBoundingClientRect();
    const rowRect = arrayRow.getBoundingClientRect();
    const left = cellRect.left - rowRect.left + cellRect.width/2;
    p.style.left = left + 'px';
    arrayRow.appendChild(p);
  }

  function updateStatus() {
    stepIdxEl.textContent = Math.max(0, currentStep+1);
    stepMaxEl.textContent = steps.length;
    opsCountEl.textContent = ops;
  }

  function play() {
    if (!steps.length) return;
    stopTimer();
    timer = setInterval(() => {
      if (currentStep < steps.length-1) {
        currentStep++;
        renderArrayStep(steps[currentStep]);
        updateStatus();
      } else {
        stopTimer();
      }
    }, playInterval);
  }
  function stopTimer() {
    if (timer) { clearInterval(timer); timer = null; }
  }

  function step(offset) {
    if (!steps.length) return;
    currentStep = Math.max(0, Math.min(steps.length-1, currentStep + offset));
    renderArrayStep(steps[currentStep]);
    updateStatus();
  }

  function reset() {
    stopTimer();
    currentStep = -1;
    renderArrayStep(null);
    stepIdxEl.textContent = 0;
    resultText.textContent = '—';
    annotation.textContent = 'Build steps to begin.';
    ops = 0;
    opsCountEl.textContent = 0;
    logEl.style.display = 'none';
    logEl.innerHTML = '';
    stepMaxEl.textContent = 0;
  }

  // Parsing helpers
  function parseArrayInput() {
    const s = inputArray.value.trim();
    if (algoSelect.value === 'reverseString') {
      // take raw string (not comma separated)
      // if input contains commas and looks like arr, treat as comma separated values
      if (s.includes(',') && !s.trim().startsWith('"')) {
        // join tokens with comma? For reverse string better to treat full string ignoring commas
        // We'll fallback to raw string (commas included)
        return s;
      } else {
        return s;
      }
    }
    // parse numbers by comma or spaces
    if (!s) return [];
    // allow bracket style: [1,2,3]
    let cleaned = s.replace(/[\[\]]/g, '');
    // split by comma or whitespace
    const tokens = cleaned.split(/[\s,]+/).filter(Boolean);
    const nums = tokens.map(t => {
      const n = Number(t);
      return Number.isNaN(n) ? t : n;
    });
    return nums;
  }

  // Build steps
  function buildSteps() {
    reset();
    const algoKey = algoSelect.value;
    const algo = algorithms[algoKey];
    if (!algo) return;
    // Update description and code
    algoDesc.textContent = algo.short;
    algoComplexity.textContent = algo.complexity;
    codeBlock.textContent = algo.code;

    let parsed = parseArrayInput();
    // For algorithms that require array of numbers, ensure it's an array
    if (algoKey === 'pairSum' || algoKey === 'removeDuplicates' || algoKey === 'maxContainer' || algoKey === 'partitionParity') {
      if (!Array.isArray(parsed)) {
        annotation.textContent = 'Please provide numeric array (comma separated).';
        return;
      }
      // ensure numeric typing
      const notNums = parsed.filter(x => typeof x !== 'number');
      if (notNums.length > 0) {
        annotation.textContent = 'Array must contain numbers for this algorithm.';
        return;
      }
    }

    // For pairSum we expect sorted array: auto-sort but inform user
    if (algoKey === 'pairSum' || algoKey === 'removeDuplicates') {
      // make numeric array sorted
      const arrNumbers = parsed.slice().sort((a,b)=>a-b);
      parsed = arrNumbers;
      inputArray.value = parsed.join(',');
      annotation.textContent = '(Array sorted automatically for this demo)';
    }

    // For reverseString, treat parsed as raw string
    let buildInput = parsed;
    if (algoKey === 'reverseString') {
      // if input is array of tokens, join them with spaces ONLY if user entered tokens
      if (Array.isArray(parsed)) {
        // join elements with comma if user entered commas; but better to use the raw input string
        buildInput = inputArray.value;
      } else {
        buildInput = inputArray.value;
      }
    }

    const opts = {};
    if (algoKey === 'pairSum') {
      const t = Number(targetInput.value);
      if (Number.isNaN(t)) { annotation.textContent = 'Target must be a number.'; return; }
      opts.target = t;
    }

    const res = algo.build(buildInput, opts);
    steps = res.steps || [];
    ops = res.ops || 0;
    // append final step if none
    if (steps.length === 0) {
      steps.push(snapshot(Array.isArray(parsed) ? parsed : Array.from(String(parsed)), -1, -1, 'No steps generated'));
    }
    currentStep = 0;
    renderArrayStep(steps[0]);
    stepMaxEl.textContent = steps.length;
    stepIdxEl.textContent = 1;
    opsCountEl.textContent = ops;
    resultText.textContent = res.result !== undefined && res.result !== null ? formatResult(res.result) : '—';
    // Fill log with all step descriptions
    logEl.style.display = 'block';
    logEl.innerHTML = steps.map((s,i)=>`<div style="padding:6px;border-bottom:1px solid rgba(255,255,255,0.02)"><strong>Step ${i+1}</strong>: ${escapeHtml(s.desc)}</div>`).join('');
  }

  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // Event listeners
  parseBtn.addEventListener('click', buildSteps);
  playBtn.addEventListener('click', () => {
    playInterval = Number(speed.value);
    play();
  });
  pauseBtn.addEventListener('click', stopTimer);
  stepForward.addEventListener('click', () => { stopTimer(); step(1); });
  stepBack.addEventListener('click', () => { stopTimer(); step(-1); });
  resetBtn.addEventListener('click', reset);
  speed.addEventListener('input', () => {
    speedLabel.textContent = speed.value + ' ms';
  });

  randomBtn.addEventListener('click', () => {
    const n = 8;
    const arr = Array.from({length:n},()=>Math.floor(Math.random()*20));
    inputArray.value = arr.join(',');
  });

  sortBtn.addEventListener('click', () => {
    const parsed = parseArrayInput();
    if (!Array.isArray(parsed)) return;
    inputArray.value = parsed.slice().sort((a,b)=>a-b).join(',');
  });

  algoSelect.addEventListener('change', () => {
    const key = algoSelect.value;
    // show/hide target area
    targetArea.style.display = (key === 'pairSum') ? 'block' : 'none';
    // update code and descriptions immediately
    const algo = algorithms[key];
    algoDesc.textContent = algo.short;
    algoComplexity.textContent = algo.complexity;
    codeBlock.textContent = algo.code;
    reset();
  });

  presets.forEach(btn => btn.addEventListener('click', () => {
    inputArray.value = btn.dataset.preset;
  }));

  // Init
  algoSelect.dispatchEvent(new Event('change'));
  reset();

  // Provide keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (e.key === ' ') { e.preventDefault(); if (timer) stopTimer(); else play(); }
    if (e.key === 'ArrowRight') { stepForward.click(); }
    if (e.key === 'ArrowLeft') { stepBack.click(); }
  });

  // Expose for debugging (optional)
  window._twopointers = {
    buildSteps: buildSteps,
    stepsRef: () => steps
  };
})();
</script>
</body>
</html>