<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Radix Sort Visualizer (LSD) — Interactive Demo</title>
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --muted:#9aa6c1;
      --accent:#60a5fa;
      --accent2:#7c3aed;
      --card:#071024;
      --good:#10b981;
      --danger:#ef4444;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    body{background:linear-gradient(180deg,var(--bg),#051022);color:#e6eef8;padding:18px;}
    .container{max-width:1100px;margin:0 auto;}
    header{display:flex;align-items:center;gap:16px;margin-bottom:14px;}
    h1{font-size:20px;margin:0;color:#eaf2ff;}
    p.lead{margin:0;color:var(--muted);font-size:13px;}
    .controls{display:flex;gap:12px;flex-wrap:wrap;margin:12px 0 18px;}
    .card{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);padding:12px;border-radius:10px;}
    .card.small{padding:8px;font-size:13px;}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px;}
    input[type="text"], textarea, select, input[type="number"]{
      background:transparent;border:1px solid rgba(255,255,255,0.04);color:#e6eef8;padding:8px;border-radius:6px;min-width:120px;
    }
    textarea{min-height:56px;min-width:260px;}
    button{background:linear-gradient(180deg,var(--accent),#2b6cb0);border:0;color:white;padding:8px 12px;border-radius:8px;cursor:pointer;}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#cfe5ff;}
    .flex{display:flex;gap:10px;align-items:center;}
    .visual{display:flex;gap:14px;align-items:flex-start;}
    .left{flex:1;}
    .array-wrap{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);min-height:180px;}
    .array{display:flex;align-items:end;gap:8px;padding:10px;min-height:110px;overflow:auto;}
    .item{
      width:48px;background:linear-gradient(180deg,#2b6cb0,#1e3a8a);color:white;border-radius:6px;display:flex;justify-content:center;align-items:flex-end;padding:6px 4px 6px 4px;box-sizing:border-box;
      position:relative;transition:transform 250ms ease;
      box-shadow:0 6px 18px rgba(12,24,46,0.4), inset 0 -6px 12px rgba(255,255,255,0.03);
    }
    .item.small{width:36px;padding:4px;font-size:12px;}
    .item .label{position:absolute;top:6px;left:6px;font-size:11px;color:rgba(255,255,255,0.9);}
    .buckets{display:flex;gap:8px;flex-wrap:wrap;padding:10px;}
    .bucket{min-width:80px;background:linear-gradient(180deg,#071633,#031029);border-radius:8px;padding:8px;border:1px solid rgba(255,255,255,0.03);color:var(--muted);min-height:80px;}
    .bucket h4{margin:0 0 6px 0;font-size:13px;color:#a8d2ff;}
    .bucket .slot{display:flex;flex-direction:column;gap:6px;min-height:36px;}
    .bucket .slot .item{background:#3b82f6;}
    .controls-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;}
    .state{margin-top:10px;color:var(--muted);font-size:13px;}
    .footer{margin-top:18px;font-size:13px;color:var(--muted);}
    .muted{color:var(--muted);}
    .small-note{font-size:12px;color:var(--muted);margin-top:6px;}
    .status{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:8px;}
    .pill{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;font-size:13px;color:var(--muted);border:1px solid rgba(255,255,255,0.02);}
    .danger{color:var(--danger);border-color:rgba(239,68,68,0.12);background:rgba(239,68,68,0.04);}
    .good{color:var(--good);border-color:rgba(16,185,129,0.08);background:rgba(16,185,129,0.03);}
    .explain{margin-top:12px;padding:12px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.02);color:var(--muted);line-height:1.45;font-size:13px;}
    .controls-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
    footer small{color:var(--muted);}
    /* simple animations */
    .moving{transform:scale(1.05) translateY(-8px);box-shadow:0 12px 24px rgba(12,24,46,0.6);}
    .highlight{outline:2px solid rgba(255,255,255,0.06);box-shadow:0 6px 18px rgba(12,24,46,0.6);}
    @media (max-width:720px){
      .array{overflow-x:auto;}
      .bucket{min-width:70px;}
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Radix Sort Visualizer (LSD)</h1>
        <p class="lead">Least Significant Digit Radix Sort for integers — interactive step-through and animation.</p>
      </div>
    </header>

    <div class="controls card">
      <div class="controls-grid">
        <div>
          <label>Input array (comma or space separated integers)</label>
          <textarea id="inputArray" placeholder="e.g. 170, 45, 75, 90, 802, 24, 2, 66">170,45,75,90,802,24,2,66</textarea>
          <div style="margin-top:8px;">
            <button id="fromText" class="secondary">Load</button>
            <button id="randomize" class="secondary">Randomize</button>
          </div>
        </div>

        <div>
          <label>Random generation</label>
          <div style="display:flex;gap:8px;align-items:center;">
            <input type="number" id="size" min="1" max="60" value="8" />
            <input type="number" id="maxVal" min="1" max="5000" value="900" />
            <select id="radix">
              <option value="2">Base 2 (binary)</option>
              <option value="4">Base 4</option>
              <option value="8">Base 8</option>
              <option value="10" selected>Base 10</option>
              <option value="16">Base 16 (hex)</option>
              <option value="32">Base 32</option>
            </select>
          </div>
          <div class="small-note">Choose base (radix). Higher base reduces passes but increases bucket count per pass.</div>
        </div>

        <div>
          <label>Sorting / Playback</label>
          <div class="controls-row">
            <button id="start">Start</button>
            <button id="stepBtn" class="secondary">Step</button>
            <button id="pauseBtn" class="secondary">Pause</button>
            <button id="resetBtn" class="secondary">Reset</button>
          </div>

          <div style="margin-top:8px;">
            <label style="font-size:12px;margin-bottom:6px;color:var(--muted);">Speed (ms per step)</label>
            <input type="range" id="speed" min="50" max="1500" value="350" />
            <div class="small-note">Faster = lower ms. Use Step to move one action at a time.</div>
          </div>
        </div>

        <div>
          <label>Options</label>
          <div style="display:flex;flex-direction:column;gap:8px;">
            <label style="font-size:13px"><input type="checkbox" id="ascending" checked /> Ascending</label>
            <label style="font-size:13px"><input type="checkbox" id="allowNeg" /> Support negatives (offset)</label>
            <label style="font-size:13px"><input type="checkbox" id="showValues" checked /> Show numeric values on bars</label>
          </div>
          <div class="small-note">When "Support negatives" is enabled, a constant offset is applied so radix sort can run (animated values will be restored at the end).</div>
        </div>
      </div>
    </div>

    <div class="visual" style="margin-top:14px;">
      <div class="left">
        <div class="array-wrap card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
            <div style="font-weight:600;color:#dff1ff;">Array</div>
            <div class="status">
              <div class="pill" id="passPill">Pass: 0</div>
              <div class="pill" id="actionPill">Action: 0 / 0</div>
              <div class="pill" id="infoPill">Radix: 10</div>
            </div>
          </div>
          <div id="mainArray" class="array" aria-live="polite" role="list"></div>
          <div id="newMainHidden" style="display:none"></div>
        </div>

        <div class="explain">
          <strong>How LSD Radix Sort works (brief):</strong>
          <div style="margin-top:6px;">
            - Radix sort processes digits from least significant (rightmost) to most significant (leftmost).<br>
            - At each pass elements are distributed into buckets based on the current digit, preserving relative order (stable). After distributing all elements, buckets are concatenated to form the new array for the next pass.<br>
            - Complexity: O(d * (n + b)) where d is number of digits (passes), b is base. For fixed-width integers this is linear O(n).
          </div>
        </div>
      </div>

      <div style="width:360px">
        <div class="card" style="padding:10px;margin-bottom:10px;">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <strong style="color:#dff1ff">Buckets</strong>
            <div class="muted" id="bucketInfo">Buckets: 10</div>
          </div>
          <div id="buckets" class="buckets" style="margin-top:10px;"></div>
        </div>

        <div class="card small" style="margin-bottom:10px;">
          <div style="font-weight:600;color:#dff1ff;margin-bottom:6px;">Status</div>
          <div id="log" class="muted" style="font-size:13px;min-height:66px"></div>
        </div>

        <div class="card small">
          <div style="font-weight:600;color:#dff1ff;margin-bottom:6px;">Complexity & Notes</div>
          <div class="muted" style="font-size:13px;">
            - Time: O(d*(n+b)) (d = digits), Space: O(n+b) for buckets.<br>
            - Stable, non-comparative. Best when digits (d) small relative to n.<br>
            - This demo uses LSD and works on integers. Non-negative expected; negative values can be handled by adding a constant offset (option enabled above).
          </div>
        </div>
      </div>
    </div>

    <footer style="margin-top:16px;">
      <small class="muted">Interactive visualization for educational purposes. You can change radix, array, and step through each low-level bucket move to see how Radix Sort rearranges elements.</small>
    </footer>
  </div>

  <script>
    // Radix Sort Visualizer (LSD) - JavaScript
    (() => {
      // DOM elements
      const inputArray = document.getElementById('inputArray');
      const fromTextBtn = document.getElementById('fromText');
      const randomizeBtn = document.getElementById('randomize');
      const sizeInput = document.getElementById('size');
      const maxValInput = document.getElementById('maxVal');
      const radixSelect = document.getElementById('radix');
      const startBtn = document.getElementById('start');
      const stepBtn = document.getElementById('stepBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const resetBtn = document.getElementById('resetBtn');
      const speedInput = document.getElementById('speed');
      const mainArrayDiv = document.getElementById('mainArray');
      const bucketsDiv = document.getElementById('buckets');
      const passPill = document.getElementById('passPill');
      const actionPill = document.getElementById('actionPill');
      const bucketInfo = document.getElementById('bucketInfo');
      const infoPill = document.getElementById('infoPill');
      const logDiv = document.getElementById('log');
      const ascendingCheckbox = document.getElementById('ascending');
      const allowNegCheckbox = document.getElementById('allowNeg');
      const showValuesCheckbox = document.getElementById('showValues');

      // State
      let items = []; // items: {id, value, displayValue}
      let originalItems = [];
      let actions = []; // precomputed action list
      let actionIndex = 0;
      let timer = null;
      let isRunning = false;
      let base = parseInt(radixSelect.value,10);
      let ascending = ascendingCheckbox.checked;
      let allowNegatives = allowNegCheckbox.checked;
      let stepMs = parseInt(speedInput.value,10);

      // Helpers
      function log(msg){
        const p = document.createElement('div');
        p.textContent = msg;
        logDiv.prepend(p);
        // limit lines
        while(logDiv.children.length > 200) logDiv.removeChild(logDiv.lastChild);
      }

      function parseInput(text){
        const tokens = text.split(/[\s,]+/).filter(Boolean);
        const nums = tokens.map(t => {
          if (/^0x[0-9a-f]+$/i.test(t)) return parseInt(t,16);
          return Number(t);
        }).filter(n => !Number.isNaN(n));
        return nums;
      }

      function buildItemsFromNumbers(nums){
        return nums.map((v,i)=>({
          id: 'i'+(i+1)+'_'+Math.random().toString(36).slice(2,7),
          value: Math.trunc(v)
        }));
      }

      function renderMainArray(container, arr){
        container.innerHTML = '';
        const showV = showValuesCheckbox.checked;
        const maxVal = Math.max(...arr.map(it=>Math.abs(it.value)), 1);
        const minWidth = 36;
        for(let it of arr){
          const div = document.createElement('div');
          div.className = 'item';
          if (arr.length > 16) div.classList.add('small');
          div.dataset.id = it.id;
          const h = Math.max(12, Math.round((Math.abs(it.value) / maxVal) * 80) + 18);
          div.style.height = h + 'px';
          // background color for negative values (if offset used then displayed value may look different)
          if (it.value < 0) {
            div.style.background = 'linear-gradient(180deg,#ef4444,#991b1b)';
          }
          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = it.id;
          div.appendChild(label);
          if (showV) {
            const vspan = document.createElement('div');
            vspan.style.fontSize = '13px';
            vspan.style.color = '#fff';
            vspan.textContent = String(it.displayValue ?? it.value);
            div.appendChild(vspan);
          }
          container.appendChild(div);
        }
      }

      function createBucketsDOM(b){
        bucketsDiv.innerHTML = '';
        bucketInfo.textContent = `Buckets: ${b}`;
        for(let i=0;i<b;i++){
          const box = document.createElement('div');
          box.className = 'bucket';
          box.dataset.bucket = i;
          const h = document.createElement('h4');
          h.textContent = String(i);
          box.appendChild(h);
          const slot = document.createElement('div');
          slot.className = 'slot';
          box.appendChild(slot);
          bucketsDiv.appendChild(box);
        }
      }

      // Action types:
      // {type:'move', pass, digit, id, value, displayValue}
      // {type:'collect', pass, bucketIndex, id, value, displayValue, targetIndex}
      // We'll precompute actions for all passes (LSD)
      function generateActionsFor(itemsIn, base, ascending){
        // We operate on copies of item objects (but preserve id)
        const items = itemsIn.map(it => ({id: it.id, value: it.value, displayValue: it.displayValue}));
        const n = items.length;
        const actions = [];
        if (n===0) return {actions, passes:0, final: items.slice()};
        const maxVal = Math.max(...items.map(it=>Math.abs(it.value)));
        // number of passes: minimal d such that base^d > maxVal
        let passes = 0;
        if (maxVal === 0) passes = 1;
        else {
          let p = 1;
          while (Math.pow(base, p) <= maxVal) p++;
          passes = p;
        }
        let working = items.slice();
        const powCache = [];
        for(let d=0; d<passes; d++){
          const powb = Math.pow(base, d);
          powCache[d] = powb;
        }
        for(let d=0; d<passes; d++){
          // distribute
          const buckets = Array.from({length: base}, ()=>[]);
          for(let i=0;i<working.length;i++){
            const it = working[i];
            const digit = Math.floor(Math.abs(it.value) / powCache[d]) % base;
            actions.push({type:'move', pass:d, digit, id:it.id, value:it.value, displayValue:it.displayValue});
            buckets[digit].push(it);
          }
          // collect
          const bucketOrder = ascending ? [...Array(base).keys()] : [...Array(base).keys()].reverse();
          let targetIdx = 0;
          for(const bIdx of bucketOrder){
            for(const it of buckets[bIdx]){
              actions.push({type:'collect', pass:d, bucketIndex:bIdx, id:it.id, value:it.value, displayValue:it.displayValue, targetIndex:targetIdx});
              targetIdx++;
            }
          }
          // update working for next pass
          const newWorking = [];
          for(const bIdx of bucketOrder){
            for(const it of buckets[bIdx]) newWorking.push(it);
          }
          working = newWorking;
        }
        return {actions, passes, final: working};
      }

      // Build actions given current items, base, and ascending option, and negative handling via offset
      function buildAllActions(){
        actions = [];
        actionIndex = 0;
        passPill.textContent = 'Pass: 0';
        actionPill.textContent = 'Action: 0 / 0';
        logDiv.innerHTML = '';

        // original items copy
        originalItems = items.map(it => ({...it}));

        // handle negative offset if enabled
        let offset = 0;
        if (allowNegatives){
          const minV = Math.min(...items.map(it => it.value));
          if (minV < 0) offset = Math.abs(minV);
          if (offset !== 0){
            for(let it of items){
              it.displayValue = it.value; // store original for display
              it.value = it.value + offset;
            }
            log(`Negative offset applied: +${offset} to all values for sorting (will be restored).`);
          } else {
            // still set displayValue to show original
            for(let it of items){
              it.displayValue = it.value;
            }
          }
        } else {
          // just set displayValue equal to value
          for(let it of items){
            it.displayValue = it.value;
          }
        }

        const generated = generateActionsFor(items, base, ascending);
        actions = generated.actions;
        const totalActions = actions.length;
        actionPill.textContent = `Action: 0 / ${totalActions}`;
        passPill.textContent = 'Pass: 0';
        infoPill.textContent = `Radix: ${base}  |  Passes: ${generated.passes}`;
        createBucketsDOM(base);

        log(`Prepared ${totalActions} low-level actions over ${generated.passes} pass(es).`);
        // store offset to restore after full run
        actions._offset = offset;
        actions._passes = generated.passes;
        actions._n = items.length;
      }

      // Render helpers for DOM items mapping
      function findMainElementById(id){
        return mainArrayDiv.querySelector(`[data-id="${id}"]`);
      }
      function findBucketSlot(bucketIndex){
        const box = bucketsDiv.querySelector(`.bucket[data-bucket="${bucketIndex}"]`);
        if (!box) return null;
        return box.querySelector('.slot');
      }

      // Execute a single action
      // We maintain per-pass collection container newMainDiv for collecting phase
      let currentPass = -1;
      let collectedThisPass = 0;
      let movesThisPass = 0;
      let newMainDiv = null;

      function doAction(a){
        if (!a) return;
        // update status
        actionPill.textContent = `Action: ${actionIndex+1} / ${actions.length}`;
        passPill.textContent = `Pass: ${a.pass + 1} / ${actions._passes}`;
        // if new pass begins, reset counts and clear buckets DOM
        if (a.pass !== currentPass){
          currentPass = a.pass;
          collectedThisPass = 0;
          movesThisPass = 0;
          // clear buckets
          for(let i=0;i<base;i++){
            const slot = findBucketSlot(i);
            if (slot) slot.innerHTML = '';
          }
          // create a fresh newMain div to collect this pass's items
          newMainDiv = document.createElement('div');
          newMainDiv.style.display = 'flex';
          newMainDiv.style.alignItems = 'end';
          newMainDiv.style.gap = '8px';
          newMainDiv.style.padding = '10px';
          newMainDiv.className = 'temp-new-main';
        }

        if (a.type === 'move'){
          movesThisPass++;
          // find the DOM element in main array and move a clone into bucket
          const elem = findMainElementById(a.id);
          if (!elem){
            // maybe it's already moved; skip
            return;
          }
          // visually mark moving
          elem.classList.add('moving');
          // create a cloned element for bucket (so we can keep placeholder if needed)
          const cloned = elem.cloneNode(true);
          cloned.classList.remove('moving');
          // show displayValue (in case displayValue differs from internal value)
          if (cloned.querySelector('div:nth-child(2)')){
            cloned.querySelector('div:nth-child(2)').textContent = String(a.displayValue ?? a.value);
          }
          // append cloned to bucket slot
          const slot = findBucketSlot(a.digit);
          if (slot){
            setTimeout(()=> {
              slot.appendChild(cloned);
            }, 80);
          }
          // hide original from main area (so it visually disappears)
          elem.style.visibility = 'hidden';
          log(`[pass ${a.pass}] MOVE id=${a.id} val=${a.displayValue ?? a.value} -> bucket ${a.digit}`);
        } else if (a.type === 'collect'){
          collectedThisPass++;
          // find the bucket slot and remove the first matching element with that id
          const slot = findBucketSlot(a.bucketIndex);
          if (slot){
            const child = Array.from(slot.children).find(ch => ch.dataset.id === a.id);
            if (child){
              slot.removeChild(child);
              // append the child to newMainDiv
              newMainDiv.appendChild(child);
              child.style.visibility = 'visible';
              child.classList.remove('moving');
              child.classList.add('highlight');
              // ensure displayed numeric value is correct (might be offset)
              const vspan = child.querySelector('div:nth-child(2)');
              if (vspan) vspan.textContent = String(a.displayValue ?? a.value);
              // quick remove highlight
              setTimeout(()=> child.classList.remove('highlight'), 350);
            } else {
              // not found - create a fresh element representing it
              const div = document.createElement('div');
              div.className = 'item';
              if (actions._n > 16) div.classList.add('small');
              div.dataset.id = a.id;
              const h = Math.max(12, Math.round((Math.abs(a.value) / 1) * 18) + 18);
              div.style.height = h + 'px';
              const label = document.createElement('div');
              label.className = 'label';
              label.textContent = a.id;
              div.appendChild(label);
              const vspan = document.createElement('div');
              vspan.textContent = String(a.displayValue ?? a.value);
              div.appendChild(vspan);
              newMainDiv.appendChild(div);
            }
          }
          log(`[pass ${a.pass}] COLLECT id=${a.id} val=${a.displayValue ?? a.value} from bucket ${a.bucketIndex} into new array`);
          // If we've collected all for this pass, finalize main array DOM
          if (collectedThisPass === actions._n){
            // replace mainArrayDiv contents with newMainDiv's children (in order)
            // Build a new array representation from newMainDiv children
            const newChildren = Array.from(newMainDiv.children).map(ch => {
              // ensure style classes corrected
              ch.classList.remove('moving','highlight');
              return ch;
            });
            // replace: clear mainArrayDiv and append in order
            mainArrayDiv.innerHTML = '';
            for(const ch of newChildren){
              mainArrayDiv.appendChild(ch);
            }
            // reset newMainDiv
            newMainDiv = null;
            log(`Completed pass ${a.pass}. Array updated for next pass.`);
          }
        }
      }

      function step(){
        if (actionIndex >= actions.length) {
          log('All actions completed.');
          finalizeSort();
          return;
        }
        const a = actions[actionIndex];
        doAction(a);
        actionIndex++;
        actionPill.textContent = `Action: ${actionIndex} / ${actions.length}`;
        if (actionIndex >= actions.length){
          log('All actions completed.');
          finalizeSort();
        }
      }

      function run(){
        if (isRunning) return;
        isRunning = true;
        pauseBtn.textContent = 'Pause';
        timer = setInterval(()=>{
          if (actionIndex >= actions.length){
            clearInterval(timer);
            isRunning = false;
            finalizeSort();
            return;
          }
          step();
        }, stepMs);
      }

      function pause(){
        if (timer) clearInterval(timer);
        isRunning = false;
        pauseBtn.textContent = 'Resume';
      }

      function reset(){
        if (timer) clearInterval(timer);
        isRunning = false;
        actionIndex = 0;
        currentPass = -1;
        newMainDiv = null;
        collectedThisPass = 0;
        movesThisPass = 0;
        // restore items to originalItems values and displayValue, and render
        if (originalItems && originalItems.length){
          items = originalItems.map(it => ({...it}));
        }
        // If offsets were applied earlier, ensure we restore displayValue to original
        for(let it of items){
          it.displayValue = it.value;
        }
        renderMainArray(mainArrayDiv, items);
        createBucketsDOM(base);
        passPill.textContent = 'Pass: 0';
        actionPill.textContent = `Action: 0 / 0`;
        log('Reset to initial array.');
      }

      function finalizeSort(){
        // restore offset if needed
        const offset = actions._offset || 0;
        if (offset){
          // subtract offset from displayValue (we had kept displayValue original before offset)
          // To ensure the final displayed numbers are original, we will fetch the DOM items and update their displayed text
          // But we also need to update items array values
          // After final pass, the DOM order equals sorted order of shifted values. We'll map them back.
          const children = Array.from(mainArrayDiv.children);
          for(const ch of children){
            const id = ch.dataset.id;
            // find in originalItems by id to get original value
            const orig = originalItems.find(it => it.id === id);
            if (orig){
              const newV = orig.value; // original pre-offset value
              // replace display text
              const vspan = ch.querySelector('div:nth-child(2)');
              if (vspan) vspan.textContent = String(newV);
              // update items array
              const itemObj = items.find(it => it.id === id);
              if (itemObj) {
                itemObj.value = newV;
                itemObj.displayValue = newV;
              }
            }
          }
          log('Offset reversed; original negative values restored in display.');
        } else {
          // ensure displayValue is accurate final values
          const children = Array.from(mainArrayDiv.children);
          for(const ch of children){
            const id = ch.dataset.id;
            const it = items.find(x => x.id === id) || originalItems.find(x => x.id === id);
            if (it){
              const vspan = ch.querySelector('div:nth-child(2)');
              if (vspan) vspan.textContent = String(it.displayValue ?? it.value);
            }
          }
        }
        passPill.textContent = `Pass: ${actions._passes}`;
        actionPill.textContent = `Action: ${actions.length} / ${actions.length}`;
        isRunning = false;
        if (timer) clearInterval(timer);
        log('Sorting finished.');
      }

      // Event wiring
      fromTextBtn.addEventListener('click', ()=>{
        const nums = parseInput(inputArray.value);
        items = buildItemsFromNumbers(nums);
        // set displayValue equal to value as baseline
        for(const it of items) it.displayValue = it.value;
        renderMainArray(mainArrayDiv, items);
        log('Loaded array from text input.');
      });

      randomizeBtn.addEventListener('click', ()=>{
        const n = Math.max(1, Math.min(60, parseInt(sizeInput.value) || 8));
        const maxV = Math.max(1, parseInt(maxValInput.value) || 100);
        const nums = [];
        for(let i=0;i<n;i++){
          const r = Math.floor(Math.random() * (maxV+1));
          // allow negative sometimes if option checked
          if (allowNegCheckbox.checked && Math.random() < 0.25){
            nums.push(r - Math.floor(maxV/2));
          } else nums.push(r);
        }
        inputArray.value = nums.join(', ');
        items = buildItemsFromNumbers(nums);
        for(const it of items) it.displayValue = it.value;
        renderMainArray(mainArrayDiv, items);
        log('Random array generated.');
      });

      radixSelect.addEventListener('change', ()=>{
        base = parseInt(radixSelect.value,10);
        infoPill.textContent = `Radix: ${base}`;
        createBucketsDOM(base);
      });

      startBtn.addEventListener('click', ()=>{
        // prepare items from input if not already loaded
        const nums = parseInput(inputArray.value);
        items = buildItemsFromNumbers(nums);
        for(const it of items) it.displayValue = it.value;
        base = parseInt(radixSelect.value,10);
        ascending = ascendingCheckbox.checked;
        allowNegatives = allowNegCheckbox.checked;
        stepMs = parseInt(speedInput.value,10);
        renderMainArray(mainArrayDiv, items);
        buildAllActions();
        // start running
        if (actions.length > 0){
          run();
        } else {
          log('Nothing to sort (empty array).');
        }
      });

      stepBtn.addEventListener('click', ()=>{
        // If not prepared, prepare actions first
        if (!actions || actions.length === 0 || actionIndex === 0){
          // reload items from input
          const nums = parseInput(inputArray.value);
          items = buildItemsFromNumbers(nums);
          for(const it of items) it.displayValue = it.value;
          renderMainArray(mainArrayDiv, items);
          base = parseInt(radixSelect.value,10);
          ascending = ascendingCheckbox.checked;
          allowNegatives = allowNegCheckbox.checked;
          buildAllActions();
        }
        pause(); // ensure paused
        step();
      });

      pauseBtn.addEventListener('click', ()=>{
        if (isRunning){
          pause();
        } else {
          // resume
          if (actionIndex >= actions.length){
            log('Nothing to resume, already finished.');
            return;
          }
          stepMs = parseInt(speedInput.value,10);
          run();
        }
      });

      resetBtn.addEventListener('click', ()=>{
        reset();
      });

      speedInput.addEventListener('input', ()=>{
        stepMs = parseInt(speedInput.value,10);
        if (isRunning){
          pause();
          run();
        }
      });

      ascendingCheckbox.addEventListener('change', ()=>{
        ascending = ascendingCheckbox.checked;
      });

      allowNegCheckbox.addEventListener('change', ()=>{
        allowNegatives = allowNegCheckbox.checked;
      });

      showValuesCheckbox.addEventListener('change', ()=>{
        // rerender main array to show/hide numbers
        renderMainArray(mainArrayDiv, items);
      });

      // initial render
      (function init(){
        const nums = parseInput(inputArray.value);
        items = buildItemsFromNumbers(nums);
        for(const it of items) it.displayValue = it.value;
        renderMainArray(mainArrayDiv, items);
        base = parseInt(radixSelect.value,10);
        createBucketsDOM(base);
        infoPill.textContent = `Radix: ${base}`;
      })();

      // keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.key === ' '){
          e.preventDefault();
          if (isRunning) pause(); else run();
        } else if (e.key === 'ArrowRight'){
          e.preventDefault();
          step();
        } else if (e.key === 'Escape'){
          pause();
        }
      });

    })();
  </script>
</body>
</html>