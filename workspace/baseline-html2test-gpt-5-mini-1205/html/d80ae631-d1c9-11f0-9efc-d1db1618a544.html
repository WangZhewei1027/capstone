<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Heap Sort Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#2dd4bf;
      --muted:#94a3b8;
      --bar:#60a5fa;
      --swap:#fb7185;
      --compare:#fbbf24;
      --sorted:#34d399;
    }
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:linear-gradient(180deg,#071023 0%,#07101a 100%); color:#e6eef6}
    .wrap{max-width:1200px;margin:18px auto;padding:18px;}
    header{display:flex;align-items:center;gap:18px;margin-bottom:18px}
    header h1{font-size:20px;margin:0}
    .controls{display:flex;flex-wrap:wrap;gap:12px;background:rgba(255,255,255,0.02);padding:12px;border-radius:10px}
    .control-row{display:flex;gap:12px;align-items:center}
    label{font-size:13px;color:var(--muted)}
    input[type="range"]{width:160px}
    button{background:linear-gradient(180deg,#0ea5a4,#057a7a);border:0;color:white;padding:8px 12px;border-radius:8px;cursor:pointer}
    button.secondary{background:#1f2937}
    button:disabled{opacity:0.45;cursor:not-allowed}
    .status{display:flex;gap:12px;align-items:center;margin-left:auto}
    .panel{display:flex;gap:12px;margin-top:18px}
    .left{flex:2;background:var(--panel);padding:12px;border-radius:10px;min-height:320px}
    .right{flex:1;background:var(--panel);padding:12px;border-radius:10px;display:flex;flex-direction:column;gap:12px}
    .array{position:relative;height:340px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:6px;padding:10px;display:flex;align-items:flex-end;gap:6px;overflow:hidden}
    .bar{flex:1 1 auto;background:linear-gradient(180deg,var(--bar),#2563eb);border-radius:4px;display:flex;align-items:end;justify-content:center;color:rgba(255,255,255,0.9);font-size:11px;box-shadow:0 2px 4px rgba(2,6,23,0.6)}
    .bar.small{font-size:10px}
    .bar .idx{font-size:10px;color:rgba(255,255,255,0.65);margin-bottom:4px}
    .info{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;color:var(--muted);font-size:13px}
    .counters{display:flex;gap:8px}
    .pill{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;min-width:94px;text-align:center}
    .pseudocode{background:#031022;padding:10px;border-radius:8px;overflow:auto;color:#cfe9ff;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;font-size:13px}
    .line{padding:4px 6px;border-left:3px solid transparent}
    .line.active{background:linear-gradient(90deg, rgba(255,255,255,0.02), transparent);border-left-color:var(--accent)}
    .legend{display:flex;gap:8px;flex-wrap:wrap}
    .legend .key{display:flex;gap:6px;align-items:center;font-size:13px;color:var(--muted)}
    .swatch{width:14px;height:14px;border-radius:4px}
    footer{margin-top:14px;color:var(--muted);font-size:13px}
    @media (max-width:900px){
      .panel{flex-direction:column}
      .array{height:260px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Heap Sort Visualizer</h1>
      <div style="color:var(--muted);font-size:13px">Visual, step-through, and animated demonstration of Heap Sort (in-place)</div>
      <div class="status">
        <div class="pill" id="compCount">Comparisons: 0</div>
        <div class="pill" id="swapCount">Swaps: 0</div>
      </div>
    </header>

    <div class="controls">
      <div class="control-row">
        <label>Array Size
          <input id="sizeRange" type="range" min="6" max="60" value="24">
        </label>
        <span id="sizeVal" style="min-width:28px;color:var(--muted)">24</span>
      </div>

      <div class="control-row">
        <label>Speed
          <input id="speedRange" type="range" min="1" max="100" value="50">
        </label>
        <span id="speedVal" style="min-width:36px;color:var(--muted)">50</span>
      </div>

      <div class="control-row">
        <label>Order
          <select id="orderSelect" style="padding:6px;border-radius:6px;background:#071027;color:#e6eef6;border:1px solid rgba(255,255,255,0.03)">
            <option value="asc">Ascending</option>
            <option value="desc">Descending</option>
          </select>
        </label>
      </div>

      <div class="control-row">
        <button id="generateBtn" title="Create new random array">Generate</button>
        <button id="startBtn" style="background:linear-gradient(180deg,#0ea5a4,#057a7a)">Start</button>
        <button id="pauseBtn" class="secondary" disabled>Pause</button>
        <button id="stepBtn" class="secondary">Step</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>

      <div class="control-row" style="margin-left:auto">
        <div class="legend">
          <div class="key"><div class="swatch" style="background:var(--compare)"></div> compare</div>
          <div class="key"><div class="swatch" style="background:var(--swap)"></div> swap</div>
          <div class="key"><div class="swatch" style="background:var(--sorted)"></div> sorted</div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="left">
        <div class="array" id="arrayContainer" aria-live="polite" aria-label="Array visualization"></div>
      </div>

      <div class="right">
        <div class="info">
          <strong>Current Action</strong>
          <div id="actionText" style="margin-top:6px;color:#dbeafe">Idle</div>
        </div>

        <div class="pseudocode" id="pseudocode">
          <div class="line" id="line1">function heapSort(arr):</div>
          <div class="line" id="line2">&nbsp;&nbsp; n = arr.length</div>
          <div class="line" id="line3">&nbsp;&nbsp; // Build heap</div>
          <div class="line" id="line4">&nbsp;&nbsp; for i = floor(n/2)-1 downto 0: heapify(arr, n, i)</div>
          <div class="line" id="line5">&nbsp;&nbsp; // Extract elements</div>
          <div class="line" id="line6">&nbsp;&nbsp; for end = n-1 downto 1:</div>
          <div class="line" id="line7">&nbsp;&nbsp;&nbsp;&nbsp; swap(arr[0], arr[end])</div>
          <div class="line" id="line8">&nbsp;&nbsp;&nbsp;&nbsp; heapify(arr, end, 0)</div>
          <hr style="border:none;border-top:1px dashed rgba(255,255,255,0.03);margin:6px 0">
          <div class="line" id="line9">function heapify(arr, n, i):</div>
          <div class="line" id="line10">&nbsp;&nbsp; largest = i</div>
          <div class="line" id="line11">&nbsp;&nbsp; left = 2*i + 1</div>
          <div class="line" id="line12">&nbsp;&nbsp; right = 2*i + 2</div>
          <div class="line" id="line13">&nbsp;&nbsp; if left &lt; n and arr[left] &gt; arr[largest]: largest = left</div>
          <div class="line" id="line14">&nbsp;&nbsp; if right &lt; n and arr[right] &gt; arr[largest]: largest = right</div>
          <div class="line" id="line15">&nbsp;&nbsp; if largest != i:</div>
          <div class="line" id="line16">&nbsp;&nbsp;&nbsp;&nbsp; swap(arr[i], arr[largest])</div>
          <div class="line" id="line17">&nbsp;&nbsp;&nbsp;&nbsp; heapify(arr, n, largest)</div>
        </div>

        <div class="info">
          <div class="counters">
            <div style="flex:1">
              <div style="font-size:13px;color:var(--muted)">Comparisons</div>
              <div id="comparisons" style="font-size:16px">0</div>
            </div>
            <div style="flex:1">
              <div style="font-size:13px;color:var(--muted)">Swaps</div>
              <div id="swaps" style="font-size:16px">0</div>
            </div>
          </div>
        </div>

        <div class="info" style="font-size:13px">
          Tips:
          <ul style="margin:6px 0 0 18px; padding:0; color:var(--muted)">
            <li>Heap sort first builds a heap (max-heap here) then repeatedly extracts the top into the sorted region.</li>
            <li>Use Step to go one action at a time; Pause to freeze the animation; Reset to restore the original array.</li>
          </ul>
        </div>
      </div>
    </div>

    <footer>
      Implementation notes: In-place heap sort; this demo highlights comparisons, swaps, and the sorted tail.
    </footer>
  </div>

  <script>
    // Heap Sort Visualizer
    (() => {
      // Elements
      const arrayContainer = document.getElementById('arrayContainer');
      const sizeRange = document.getElementById('sizeRange');
      const sizeVal = document.getElementById('sizeVal');
      const speedRange = document.getElementById('speedRange');
      const speedVal = document.getElementById('speedVal');
      const generateBtn = document.getElementById('generateBtn');
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const stepBtn = document.getElementById('stepBtn');
      const resetBtn = document.getElementById('resetBtn');
      const orderSelect = document.getElementById('orderSelect');
      const actionText = document.getElementById('actionText');
      const comparisonsEl = document.getElementById('comparisons');
      const swapsEl = document.getElementById('swaps');
      const compCount = document.getElementById('compCount');
      const swapCount = document.getElementById('swapCount');
      const pseudoLines = Array.from(document.querySelectorAll('.pseudocode .line'));

      // State
      let array = [];
      let original = [];
      let bars = [];
      let actions = []; // recorded actions to animate
      let actionIndex = 0;
      let running = false;
      let paused = false;
      let comps = 0;
      let swaps = 0;
      let animationTimer = null;

      // Helpers
      function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }
      function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

      function createRandomArray(n){
        const arr = [];
        for(let i=0;i<n;i++) arr.push(randInt(12,320));
        return arr;
      }

      function renderArray(arr, highlight = {}) {
        arrayContainer.innerHTML = '';
        bars = [];
        const n = arr.length;
        for(let i=0;i<n;i++){
          const bar = document.createElement('div');
          bar.className = 'bar' + (n>40?' small':'');
          bar.style.height = (arr[i]) + 'px';
          bar.dataset.index = i;
          bar.title = String(arr[i]);
          // label bottom index
          const idx = document.createElement('div');
          idx.className = 'idx';
          idx.textContent = i;
          const val = document.createElement('div');
          val.textContent = arr[i];
          val.style.padding = '4px 0 6px';
          bar.appendChild(val);
          bar.appendChild(idx);
          // set default color
          bar.style.background = 'linear-gradient(180deg,var(--bar),#2563eb)';
          arrayContainer.appendChild(bar);
          bars.push(bar);
        }
        // apply some highlights if provided
        if(highlight.compare) highlight.compare.forEach(i => colorBar(i, 'var(--compare)'));
        if(highlight.swap) highlight.swap.forEach(i => colorBar(i, 'var(--swap)'));
        if(highlight.sorted) highlight.sorted.forEach(i => colorBar(i, 'var(--sorted)'));
      }

      function colorBar(i, color){
        if(bars[i]) bars[i].style.background = color;
      }

      function swapVisual(i,j,arr){
        // swap heights and titles and text
        if(!bars[i] || !bars[j]) return;
        const hi = bars[i].style.height;
        const hj = bars[j].style.height;
        bars[i].style.height = hj;
        bars[j].style.height = hi;
        const ti = bars[i].querySelector('div:nth-child(1)');
        const tj = bars[j].querySelector('div:nth-child(1)');
        const vi = ti.textContent, vj = tj.textContent;
        ti.textContent = vj;
        tj.textContent = vi;
        bars[i].title = bars[i].querySelector('div:nth-child(1)').textContent;
        bars[j].title = bars[j].querySelector('div:nth-child(1)').textContent;
        // also update data-index display (the label should remain the index)
      }

      function resetHighlights(){
        bars.forEach(bar => bar.style.background = 'linear-gradient(180deg,var(--bar),#2563eb)');
      }

      // Action recording and heap sort implementation that records small atomic actions:
      // actions: {type:'compare', i,j}, {type:'swap', i,j}, {type:'markSorted', index}, {type:'action', text}, {type:'range', n}
      function recordHeapSort(arrSrc, ascending=true){
        const arr = arrSrc.slice();
        const n = arr.length;
        const comp = (a,b)=> a > b; // choose relation for max-heap
        const wantMax = ascending; // for ascending, build max-heap; for descending, build min-heap by inverting compare
        const compareFn = (a,b) => wantMax ? a > b : a < b;

        actions = [];
        comps = 0; swaps = 0;

        function recHeapify(nLocal, i){
          actions.push({type:'action', text:`heapify(n=${nLocal}, i=${i})`});
          let largest = i;
          for(;;){
            let left = 2*i + 1;
            let right = 2*i + 2;
            let candidate = largest;
            if(left < nLocal){
              actions.push({type:'compare', i:left, j:largest});
              comps++;
              if(compareFn(arr[left], arr[candidate])) candidate = left;
            }
            if(right < nLocal){
              actions.push({type:'compare', i:right, j:candidate});
              comps++;
              if(compareFn(arr[right], arr[candidate])) candidate = right;
            }
            if(candidate !== i){
              actions.push({type:'swap', i:i, j:candidate});
              swaps++;
              // do swap in arr to reflect future comparisons
              [arr[i], arr[candidate]] = [arr[candidate], arr[i]];
              i = candidate; // continue sifting down
              // continue loop with new i
            } else {
              break;
            }
          }
        }

        // Build heap
        actions.push({type:'action', text:'Build heap'});
        for(let i = Math.floor(n/2)-1; i>=0; i--){
          actions.push({type:'action', text:`build: heapify index ${i}`});
          recHeapify(n, i);
        }

        // Extract elements
        actions.push({type:'action', text:'Extract elements / sort'});
        for(let end = n-1; end > 0; end--){
          actions.push({type:'swap', i:0, j:end});
          swaps++;
          [arr[0], arr[end]] = [arr[end], arr[0]];
          actions.push({type:'markSorted', index:end});
          // heapify reduced heap
          // heapify on prefix of size end
          // implement iterative heapify that records compares & swaps relative to the reduced heap
          let i = 0;
          while(true){
            let left = 2*i + 1;
            let right = 2*i + 2;
            let candidate = i;
            if(left < end){
              actions.push({type:'compare', i:left, j:candidate});
              comps++;
              if(compareFn(arr[left], arr[candidate])) candidate = left;
            }
            if(right < end){
              actions.push({type:'compare', i:right, j:candidate});
              comps++;
              if(compareFn(arr[right], arr[candidate])) candidate = right;
            }
            if(candidate !== i){
              actions.push({type:'swap', i:i, j:candidate});
              swaps++;
              [arr[i], arr[candidate]] = [arr[candidate], arr[i]];
              i = candidate;
            } else break;
          }
        }
        actions.push({type:'markSorted', index:0});
        // record totals
        actions.push({type:'done'});
        return actions;
      }

      // Animation / execution engine
      function getDelay(){
        const speed = parseInt(speedRange.value,10);
        // map 1..100 to delay 450..10 ms (higher speed -> lower delay)
        return Math.max(8, Math.floor(500 - speed*4.8));
      }

      function updateCounters(){
        comparisonsEl.textContent = comps;
        swapsEl.textContent = swaps;
        compCount.textContent = 'Comparisons: ' + comps;
        swapCount.textContent = 'Swaps: ' + swaps;
      }

      function highlightPseudoFor(action){
        // clear
        pseudoLines.forEach(l => l.classList.remove('active'));
        // map action types to lines roughly
        if(!action) return;
        switch(action.type){
          case 'action':
            if(action.text && action.text.startsWith('Build')) document.getElementById('line3').classList.add('active');
            if(action.text && action.text.startsWith('Extract')) document.getElementById('line5').classList.add('active');
            break;
          case 'compare':
            document.getElementById('line13').classList.add('active');
            document.getElementById('line14').classList.add('active');
            break;
          case 'swap':
            document.getElementById('line7').classList.add('active');
            document.getElementById('line16').classList.add('active');
            break;
          case 'markSorted':
            document.getElementById('line7').classList.add('active');
            break;
          case 'done':
            pseudoLines.forEach(l => l.classList.add('active'));
            break;
          default:
            break;
        }
      }

      function renderAction(a){
        resetHighlights();
        if(!a) return;
        switch(a.type){
          case 'action':
            actionText.textContent = a.text;
            break;
          case 'compare':
            actionText.textContent = `Compare index ${a.i} and ${a.j}`;
            if(bars[a.i]) bars[a.i].style.background = 'var(--compare)';
            if(bars[a.j]) bars[a.j].style.background = 'var(--compare)';
            break;
          case 'swap':
            actionText.textContent = `Swap index ${a.i} and ${a.j}`;
            if(bars[a.i]) bars[a.i].style.background = 'var(--swap)';
            if(bars[a.j]) bars[a.j].style.background = 'var(--swap)';
            swapVisual(a.i, a.j, array);
            break;
          case 'markSorted':
            actionText.textContent = `Mark sorted index ${a.index}`;
            if(bars[a.index]) bars[a.index].style.background = 'var(--sorted)';
            break;
          case 'done':
            actionText.textContent = `Done`;
            break;
        }
        updateCounters();
        highlightPseudoFor(a);
      }

      function executeNextAction(){
        if(actionIndex >= actions.length){
          running = false;
          paused = false;
          startBtn.disabled = false;
          pauseBtn.disabled = true;
          stepBtn.disabled = true;
          return;
        }
        const a = actions[actionIndex++];
        // When we perform a compare or swap the underlying model array must be updated as necessary.
        // Our recorded actions already updated a temporary arr during recording; during replay we perform visual swaps for swaps only.
        renderAction(a);
        // Schedule next
        if(a.type === 'done'){
          running = false;
          paused = false;
          startBtn.disabled = false;
          pauseBtn.disabled = true;
          stepBtn.disabled = true;
          return;
        }
        if(!paused){
          animationTimer = setTimeout(() => {
            executeNextAction();
          }, getDelay());
        }
      }

      // Controls behavior
      function generateNew(){
        const n = parseInt(sizeRange.value,10);
        array = createRandomArray(n);
        original = array.slice();
        renderArray(array);
        comps = 0; swaps = 0;
        updateCounters();
        actionText.textContent = 'Idle';
        actionIndex = 0;
        actions = [];
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        stepBtn.disabled = false;
        resetBtn.disabled = false;
      }

      function prepareActions(){
        actions = recordHeapSort(array, orderSelect.value === 'asc');
        // Reset to original visualization array (we want to animate from original)
        array = original.slice();
        renderArray(array);
        actionIndex = 0;
        comps = 0; swaps = 0;
        updateCounters();
      }

      // Event listeners
      sizeRange.addEventListener('input', () => {
        sizeVal.textContent = sizeRange.value;
      });

      speedRange.addEventListener('input', () => {
        speedVal.textContent = speedRange.value;
      });

      generateBtn.addEventListener('click', () => {
        generateNew();
      });

      startBtn.addEventListener('click', () => {
        // compute actions and start animating
        prepareActions();
        running = true;
        paused = false;
        startBtn.disabled = true;
        pauseBtn.disabled = false;
        stepBtn.disabled = false;
        executeNextAction();
      });

      pauseBtn.addEventListener('click', () => {
        if(!running) return;
        if(!paused){
          paused = true;
          pauseBtn.textContent = 'Resume';
          if(animationTimer) clearTimeout(animationTimer);
        } else {
          paused = false;
          pauseBtn.textContent = 'Pause';
          // continue
          executeNextAction();
        }
      });

      stepBtn.addEventListener('click', () => {
        if(!running){
          // if not started, prepare actions but do not set running true
          prepareActions();
          running = true;
        }
        if(paused){
          // perform one action
          if(actionIndex < actions.length){
            const a = actions[actionIndex++];
            renderAction(a);
            if(a.type === 'done'){
              running = false;
              paused = false;
              startBtn.disabled = false;
              pauseBtn.disabled = true;
              stepBtn.disabled = true;
            }
          }
        } else {
          // Pause and step: pause current animation then step one
          paused = true;
          pauseBtn.textContent = 'Resume';
          if(animationTimer) clearTimeout(animationTimer);
          if(actionIndex < actions.length){
            const a = actions[actionIndex++];
            renderAction(a);
            if(a.type === 'done'){
              running = false;
              paused = false;
              startBtn.disabled = false;
              pauseBtn.disabled = true;
              stepBtn.disabled = true;
            }
          }
        }
      });

      resetBtn.addEventListener('click', () => {
        // Stop animation and restore original array
        if(animationTimer) clearTimeout(animationTimer);
        running = false;
        paused = false;
        actionIndex = 0;
        actions = [];
        array = original.slice();
        renderArray(array);
        comps = 0; swaps = 0;
        updateCounters();
        actionText.textContent = 'Idle';
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        pauseBtn.textContent = 'Pause';
        stepBtn.disabled = false;
      });

      // initial
      sizeVal.textContent = sizeRange.value;
      speedVal.textContent = speedRange.value;
      generateNew();

    })();
  </script>
</body>
</html>