<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Selection Sort Visualizer</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --muted:#94a3b8;
    --accent:#3b82f6;
    --good:#10b981;
    --bad:#ef4444;
    --card:#0b1220;
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,system-ui,Arial,sans-serif;background:linear-gradient(180deg,#071021 0%, #07142a 100%);color:#e6eef8}
  .app{max-width:1100px;margin:22px auto;padding:20px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.7);}
  header{display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:14px}
  h1{font-size:20px;margin:0}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .controls > *{background:var(--panel);border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:8px;color:var(--muted);font-size:13px}
  .btn{cursor:pointer;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:9px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);color:#e6eef8}
  .btn:active{transform:translateY(1px)}
  .btn.primary{background:linear-gradient(90deg,var(--accent),#2563eb);box-shadow:0 6px 20px rgba(59,130,246,0.15)}
  .btn.warn{background:linear-gradient(90deg,var(--bad),#dc2626)}
  .toolbar{display:flex;gap:10px;align-items:center}
  .slider{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:8px;background:#0b1220}
  input[type=range]{accent-color:var(--accent)}
  .main{display:flex;gap:20px}
  .visual{flex:2;padding:14px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:10px;min-height:260px;display:flex;flex-direction:column;align-items:stretch}
  .bars{flex:1;display:flex;align-items:flex-end;gap:6px;padding:8px 6px 10px;min-height:180px}
  .bar{flex:1 1 0;height:60px;background:#0b1220;border-radius:6px;display:flex;align-items:flex-end;justify-content:center;color:#e6eef8;font-weight:600;transition:height 300ms cubic-bezier(.22,.9,.22,1), transform 180ms}
  .bar .value{transform:translateY(-6px);font-size:12px;color:#e6eef8}
  .bar.default{background:linear-gradient(180deg,#0b1220,#071022)}
  .bar.i{background:linear-gradient(180deg,#60a5fa,#3b82f6);box-shadow:0 8px 20px rgba(59,130,246,0.15)}
  .bar.j{background:linear-gradient(180deg,#fb923c,#f97316);box-shadow:0 8px 20px rgba(249,115,22,0.12)}
  .bar.min{background:linear-gradient(180deg,#34d399,#10b981);box-shadow:0 8px 20px rgba(16,185,129,0.12)}
  .bar.swap{background:linear-gradient(180deg,#fb7185,#ef4444);box-shadow:0 8px 20px rgba(239,68,68,0.12);transform:translateY(-6px)}
  .info{display:flex;gap:12px;align-items:center;margin-top:10px}
  .badge{background:#071426;padding:8px 10px;border-radius:8px;font-size:13px;color:var(--muted)}
  .panel{flex:1;padding:14px;background:#071226;border-radius:10px;min-height:260px;color:var(--muted);font-size:14px}
  .panel h3{margin:0 0 10px 0;color:#e6eef8;font-size:15px}
  pre{margin:0;background:transparent;padding:8px;border-radius:6px;color:var(--muted);font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,monospace;font-size:13px}
  .code-line{padding:4px;border-radius:6px}
  .code-line.active{background:linear-gradient(90deg, rgba(96,165,250,0.07), transparent);color:#e6eef8}
  .small{font-size:12px;color:var(--muted)}
  footer{margin-top:12px;color:#8ea0bd;font-size:13px}
  @media (max-width:900px){.main{flex-direction:column}.visual,.panel{min-height:220px}}
</style>
</head>
<body>
<div class="app" role="main" aria-label="Selection Sort Visualizer">
  <header>
    <div>
      <h1>Selection Sort â€” Visualizer</h1>
      <div class="small">See how selection sort finds the minimum and swaps it into place.</div>
    </div>
    <div class="controls">
      <div class="toolbar">
        <button id="btnNew" class="btn primary" title="Generate new random array">New Array</button>
        <button id="btnShuffle" class="btn" title="Shuffle current array">Shuffle</button>
        <button id="btnPlay" class="btn" title="Play">Play</button>
        <button id="btnPause" class="btn" title="Pause" disabled>Pause</button>
        <button id="btnStep" class="btn" title="Step">Step</button>
        <button id="btnReset" class="btn" title="Reset">Reset</button>
      </div>
      <div class="slider">
        <label class="small">Size</label>
        <input id="size" type="range" min="5" max="60" value="18">
        <span id="sizeVal" class="small">18</span>
      </div>
      <div class="slider">
        <label class="small">Speed</label>
        <input id="speed" type="range" min="50" max="1200" value="220">
        <span id="speedVal" class="small">220ms</span>
      </div>
    </div>
  </header>

  <div class="main">
    <div class="visual" aria-live="polite">
      <div class="bars" id="bars" role="img" aria-label="Array bars"></div>
      <div class="info">
        <div class="badge">Comparisons: <strong id="cmp">0</strong></div>
        <div class="badge">Swaps: <strong id="swp">0</strong></div>
        <div class="badge">i: <strong id="iidx">-</strong></div>
        <div class="badge">min: <strong id="minidx">-</strong></div>
        <div class="badge">j: <strong id="jidx">-</strong></div>
      </div>
    </div>

    <div class="panel" aria-label="Pseudocode and status">
      <h3>Pseudocode (Selection Sort)</h3>
      <pre id="pseudocode">
<div id="code0" class="code-line">for i from 0 to n-2:</div>
<div id="code1" class="code-line">  min = i</div>
<div id="code2" class="code-line">  for j from i+1 to n-1:</div>
<div id="code3" class="code-line">    if array[j] < array[min]:</div>
<div id="code4" class="code-line">      min = j</div>
<div id="code5" class="code-line">  if min != i:</div>
<div id="code6" class="code-line">    swap array[i] and array[min]</div>
      </pre>

      <h3 style="margin-top:12px">Explanation</h3>
      <div class="small">Selection sort repeatedly selects the smallest remaining element and swaps it into its correct position. It's easy to understand but not optimal for large arrays (O(n^2) time).</div>
    </div>
  </div>

  <footer>
    Controls: Play/Pause to run automatically. Step to perform a single comparison/action. You can change array size or speed anytime; generating a new array resets counters.
  </footer>
</div>

<script>
(function(){
  // DOM
  const barsEl = document.getElementById('bars');
  const btnNew = document.getElementById('btnNew');
  const btnShuffle = document.getElementById('btnShuffle');
  const btnPlay = document.getElementById('btnPlay');
  const btnPause = document.getElementById('btnPause');
  const btnStep = document.getElementById('btnStep');
  const btnReset = document.getElementById('btnReset');
  const sizeInput = document.getElementById('size');
  const sizeVal = document.getElementById('sizeVal');
  const speedInput = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const cmpEl = document.getElementById('cmp');
  const swpEl = document.getElementById('swp');
  const iidxEl = document.getElementById('iidx');
  const minidxEl = document.getElementById('minidx');
  const jidxEl = document.getElementById('jidx');
  const codeLines = Array.from({length:7}).map((_,i)=>document.getElementById('code'+i));

  // State
  let arr = [];
  let bars = [];
  let comparisons = 0, swaps = 0;
  let running = false;
  let waitingResolvers = [];
  let stepRequested = false;
  let speed = parseInt(speedInput.value,10);
  let allowControls = true;
  let snapshotArr = null;

  function randInt(min,max){return Math.floor(Math.random()*(max-min+1))+min}
  function generateArray(n){
    const a = [];
    for(let i=0;i<n;i++) a.push(randInt(5,100));
    return a;
  }

  function renderArray(a){
    barsEl.innerHTML = '';
    bars = [];
    const max = Math.max(...a,100);
    a.forEach((v, idx)=>{
      const bar = document.createElement('div');
      bar.className = 'bar default';
      bar.style.height = (v/max*100) + '%';
      bar.setAttribute('data-index', idx);
      bar.setAttribute('data-value', v);
      const lbl = document.createElement('div');
      lbl.className = 'value';
      lbl.textContent = v;
      bar.appendChild(lbl);
      barsEl.appendChild(bar);
      bars.push(bar);
    });
  }

  function updateBadges(i,min,j){
    cmpEl.textContent = comparisons;
    swpEl.textContent = swaps;
    iidxEl.textContent = (i==null?'-':i);
    minidxEl.textContent = (min==null?'-':min);
    jidxEl.textContent = (j==null?'-':j);
  }

  function clearHighlights(){
    bars.forEach(b=>{
      b.className = 'bar default';
    });
    codeLines.forEach(l=>l.classList.remove('active'));
  }

  function highlight(indices){
    // indices: {i, j, min, swap}
    bars.forEach((b,idx)=>{
      b.className = 'bar default';
      if(indices){
        if(indices.swap && (idx===indices.swap[0] || idx===indices.swap[1])){
          b.classList.add('swap');
        } else if(indices.i!=null && idx===indices.i){
          b.classList.add('i');
        } else if(indices.j!=null && idx===indices.j){
          b.classList.add('j');
        } else if(indices.min!=null && idx===indices.min){
          b.classList.add('min');
        }
      }
    });
  }

  function updatePseudocode(line){
    codeLines.forEach((l,idx)=>l.classList.toggle('active', idx===line));
  }

  // Control mechanism: wait for play or step or timeout
  function waitForControl(){
    return new Promise(resolve=>{
      if(running){
        setTimeout(resolve, speed);
      } else if(stepRequested){
        stepRequested = false;
        resolve();
      } else {
        waitingResolvers.push(resolve);
      }
    });
  }

  function resumeAll(){
    // Called when switching to running: resolve all waiting so algorithm continues.
    while(waitingResolvers.length) {
      const r = waitingResolvers.shift();
      r();
    }
  }

  function cancelWaiting(){
    // Resolve any pending to avoid deadlocks (used on reset/new array)
    while(waitingResolvers.length) {
      const r = waitingResolvers.shift();
      r();
    }
    stepRequested = false;
  }

  // Selection sort with visualization and control points
  async function selectionSortVisual(a){
    comparisons = 0; swaps = 0;
    updateBadges(null,null,null);
    snapshotArr = a.slice(); // for reset
    const n = a.length;
    for(let i=0;i<n-1;i++){
      updatePseudocode(0);
      let min = i;
      updatePseudocode(1);
      updateBadges(i,min,null);
      highlight({i,min});
      await waitForControl();

      for(let j=i+1;j<n;j++){
        updatePseudocode(2);
        updateBadges(i,min,j);
        highlight({i,j,min});
        // comparison
        updatePseudocode(3);
        comparisons++;
        updateBadges(i,min,j);
        await waitForControl();

        if(a[j] < a[min]){
          min = j;
          updatePseudocode(4);
          updateBadges(i,min,j);
          highlight({i,j,min});
          await waitForControl();
        }
      }

      updatePseudocode(5);
      await waitForControl();

      if(min !== i){
        updatePseudocode(6);
        // visually swap: mark swap and animate
        updateBadges(i,min,null);
        highlight({swap:[i,min]});
        await waitForControl();
        // perform swap in array and DOM
        swaps++;
        // swap values
        const tmp = a[i]; a[i]=a[min]; a[min]=tmp;
        // swap bars heights and data-values with smooth transition
        const bi = bars[i], bm = bars[min];
        // swap heights and labels
        const hi = bi.style.height, hm = bm.style.height;
        bi.style.height = hm; bm.style.height = hi;
        const vi = bi.querySelector('.value').textContent;
        const vm = bm.querySelector('.value').textContent;
        bi.querySelector('.value').textContent = vm;
        bm.querySelector('.value').textContent = vi;
        // also update data-value attrs
        bi.setAttribute('data-value', a[i]);
        bm.setAttribute('data-value', a[min]);
        updateBadges(i,min,null);
        await waitForControl();
      }

      // finalize position i
      clearHighlights();
      updateBadges(i,null,null);
      await waitForControl();
    }
    // done
    clearHighlights();
    updateBadges('-', '-', '-');
    updatePseudocode(-1);
  }

  // Controls wiring
  function setPlay(on){
    running = !!on;
    btnPlay.disabled = running;
    btnPause.disabled = !running;
    if(running) resumeAll();
  }

  btnPlay.addEventListener('click', ()=>{
    setPlay(true);
  });
  btnPause.addEventListener('click', ()=>{
    setPlay(false);
  });
  btnStep.addEventListener('click', ()=>{
    // If algorithm running paused and there is a waiting resolver, resolve one.
    if(waitingResolvers.length>0){
      const r = waitingResolvers.shift();
      r();
    } else {
      stepRequested = true;
    }
    setPlay(false);
  });

  btnNew.addEventListener('click', ()=>{
    cancelWaiting();
    setPlay(false);
    initArray(+sizeInput.value);
    resetCounts();
  });

  btnShuffle.addEventListener('click', ()=>{
    cancelWaiting();
    setPlay(false);
    shuffleArray();
    resetCounts();
  });

  btnReset.addEventListener('click', ()=>{
    cancelWaiting();
    setPlay(false);
    resetToSnapshot();
  });

  sizeInput.addEventListener('input', (e)=>{
    sizeVal.textContent = e.target.value;
  });
  sizeInput.addEventListener('change', (e)=>{
    cancelWaiting();
    setPlay(false);
    initArray(+e.target.value);
    resetCounts();
  });

  speedInput.addEventListener('input', (e)=>{
    speed = parseInt(e.target.value,10);
    speedVal.textContent = speed + 'ms';
  });

  function resetCounts(){
    comparisons = 0; swaps = 0;
    cmpEl.textContent = 0; swpEl.textContent = 0;
    iidxEl.textContent = '-'; jidxEl.textContent = '-'; minidxEl.textContent='-';
  }

  function initArray(n){
    arr = generateArray(n);
    renderArray(arr);
    clearHighlights();
    resetCounts();
    snapshotArr = arr.slice();
    // start algorithm in background
    startSort();
  }

  function shuffleArray(){
    // Fisher-Yates
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    renderArray(arr);
    snapshotArr = arr.slice();
  }

  function resetToSnapshot(){
    if(!snapshotArr) return;
    arr = snapshotArr.slice();
    renderArray(arr);
    resetCounts();
  }

  // Start the sort algorithm in background, but ensure only one instance
  let sortTask = null;
  function startSort(){
    if(sortTask) return;
    sortTask = (async ()=>{
      try{
        await selectionSortVisual(arr);
      }catch(e){
        // ignore
      } finally {
        sortTask = null;
        setPlay(false);
      }
    })();
  }

  // Initialize
  function init(){
    sizeVal.textContent = sizeInput.value;
    speedVal.textContent = speedInput.value + 'ms';
    speed = parseInt(speedInput.value,10);
    initArray(+sizeInput.value);

    // Start paused by default
    setPlay(false);

    // when page visible, ensure resumeAll if running
    document.addEventListener('visibilitychange', ()=>{
      if(!document.hidden && running) resumeAll();
    });

    // Auto start in paused state so users can step
    setTimeout(()=>{ /* nothing */ }, 0);
  }

  init();
})();
</script>
</body>
</html>