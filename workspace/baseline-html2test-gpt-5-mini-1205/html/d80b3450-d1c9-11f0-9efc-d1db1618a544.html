<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Binary Search Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --muted:#94a3b8;
      --accent:#60a5fa;
      --success:#34d399;
      --danger:#fb7185;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{
      margin:0;height:100%;background:linear-gradient(180deg,#071029 0%, #071a2a 100%);font-family:Inter, Roboto, Arial, sans-serif;color:#e6eef8;
    }
    .container{
      max-width:1100px;margin:28px auto;padding:20px;
    }
    h1{margin:0 0 12px 0;font-size:24px}
    .grid{
      display:grid;grid-template-columns:1fr 420px;gap:18px;
    }
    .card{
      background:var(--card);border-radius:10px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6);
    }
    .controls{display:flex;flex-direction:column;gap:10px}
    label{font-size:13px;color:var(--muted);display:flex;justify-content:space-between;align-items:center}
    .row{display:flex;gap:10px;align-items:center}
    input[type="number"], input[type="text"]{
      background:var(--glass);border:1px solid rgba(255,255,255,0.04);color:inherit;padding:8px;border-radius:6px;
      min-width:0;
    }
    button{
      background:linear-gradient(180deg,var(--accent),#2b7bdc);border:none;padding:8px 12px;border-radius:8px;color:#02203b;cursor:pointer;font-weight:600;
      box-shadow:0 4px 10px rgba(59,130,246,0.18);
    }
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);box-shadow:none}
    .small{font-size:13px;padding:6px 8px;border-radius:6px}
    .array{
      display:flex;gap:8px;flex-wrap:wrap;padding:12px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);min-height:88px;align-items:center;
    }
    .cell{
      width:48px;height:56px;border-radius:8px;background:rgba(255,255,255,0.03);display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:14px;
      border:1px solid rgba(255,255,255,0.03);position:relative;cursor:pointer;transition:transform 160ms ease, box-shadow 160ms;
      user-select:none;
    }
    .cell:hover{transform:translateY(-4px);box-shadow:0 8px 18px rgba(3,6,23,0.6)}
    .idx{font-size:11px;color:var(--muted);position:absolute;left:6px;top:6px}
    .val{font-weight:700}
    .range{background:linear-gradient(90deg, rgba(96,165,250,0.08), transparent);border-color:rgba(96,165,250,0.12)}
    .leftptr{box-shadow:0 6px 18px rgba(96,165,250,0.08);border:2px solid rgba(96,165,250,0.22)}
    .rightptr{box-shadow:0 6px 18px rgba(96,165,250,0.08);border:2px solid rgba(96,165,250,0.22)}
    .mid{background:linear-gradient(90deg, rgba(16,185,129,0.09), transparent);border:2px solid rgba(16,185,129,0.12);box-shadow:0 10px 30px rgba(16,185,129,0.04)}
    .found{background:linear-gradient(90deg, rgba(52,211,153,0.12), transparent);border:2px solid rgba(52,211,153,0.14)}
    .notfound{background:linear-gradient(90deg, rgba(251,113,133,0.08), transparent);border:2px solid rgba(251,113,133,0.12)}
    .controls-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .pseudocode{font-family:monospace;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:12px;border-radius:8px;color:var(--muted);font-size:13px}
    .line{padding:6px;border-radius:6px}
    .line.active{background:rgba(96,165,250,0.09);color:#e6f2ff}
    .status{font-size:13px;color:var(--muted);padding-top:8px}
    .legend{display:flex;gap:8px;flex-wrap:wrap}
    .legend .item{display:flex;gap:6px;align-items:center;font-size:13px;color:var(--muted)}
    .swatch{width:14px;height:14px;border-radius:4px;box-shadow:0 4px 10px rgba(2,6,23,0.6)}
    .sw-range{background:linear-gradient(90deg, rgba(96,165,250,0.16), transparent)}
    .sw-left{background:rgba(96,165,250,0.32)}
    .sw-mid{background:rgba(16,185,129,0.34)}
    .sw-found{background:rgba(52,211,153,0.34)}
    .info{margin-top:10px;color:var(--muted);font-size:13px}
    .controls .muted{color:var(--muted);font-size:13px}
    .stack{
      margin-top:10px;display:flex;flex-direction:column;gap:8px;
    }
    .frame{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;font-family:monospace;color:var(--muted);display:flex;justify-content:space-between}
    .playbtn{background:linear-gradient(90deg,#34d399,#10b981);color:#012018}
  </style>
</head>
<body>
  <div class="container">
    <h1>Binary Search Visualizer</h1>
    <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:8px">
      <div style="color:var(--muted);font-size:13px;max-width:720px">
        Binary Search finds the position of a target value within a sorted array by repeatedly dividing the search interval in half. Use the controls to build an array, pick a target, and step through the algorithm. Click any array cell to set the search target quickly.
      </div>
    </div>

    <div class="grid">
      <!-- Left: Visualization and controls -->
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
          <div style="font-weight:700">Array & Visualization</div>
          <div style="display:flex;gap:8px;align-items:center">
            <div style="color:var(--muted);font-size:13px">Mode</div>
            <select id="modeSelect" style="background:var(--glass);border-radius:6px;padding:6px;color:inherit;border:1px solid rgba(255,255,255,0.03)">
              <option value="iterative">Iterative</option>
              <option value="recursive">Recursive (visualized stack)</option>
            </select>
          </div>
        </div>

        <div style="margin-top:12px" class="controls">
          <div class="row" style="gap:10px">
            <label style="flex:1">
              <span>Array size</span>
              <span style="display:flex;gap:8px;align-items:center">
                <input id="sizeInput" type="number" min="3" max="60" value="15" style="width:68px" />
                <button id="genBtn" class="small">Generate</button>
              </span>
            </label>
            <label style="flex:1">
              <span>Min & Max values</span>
              <span style="display:flex;gap:6px">
                <input id="minVal" type="number" value="1" style="width:68px" />
                <input id="maxVal" type="number" value="99" style="width:68px" />
              </span>
            </label>
          </div>

          <div class="row">
            <label style="flex:1">
              <span>Target value</span>
              <input id="targetInput" type="text" placeholder="Enter number or click a cell" />
            </label>
            <div style="display:flex;gap:8px;align-items:center">
              <button id="setTargetBtn" class="small ghost">Set Target</button>
              <button id="randomTargetBtn" class="small">Random Target</button>
            </div>
          </div>

          <div style="margin-top:6px" class="controls-row">
            <button id="stepBtn" class="small">Step</button>
            <button id="playBtn" class="small playbtn">Play</button>
            <button id="resetBtn" class="small ghost">Reset</button>
            <button id="fastBtn" class="small">Fast Run</button>
            <div style="margin-left:auto;display:flex;gap:6px;align-items:center">
              <div style="color:var(--muted);font-size:13px">Speed</div>
              <input id="speed" type="range" min="100" max="1600" value="700" />
            </div>
          </div>

        </div>

        <div style="margin-top:12px" class="array" id="arrayContainer" title="Click an element to set target">
          <!-- cells inserted here -->
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px">
          <div class="legend">
            <div class="item"><div class="swatch sw-range"></div><div class="muted">Active search range</div></div>
            <div class="item"><div class="swatch sw-left"></div><div class="muted">Left / Right pointers</div></div>
            <div class="item"><div class="swatch sw-mid"></div><div class="muted">Mid</div></div>
            <div class="item"><div class="swatch sw-found"></div><div class="muted">Found</div></div>
          </div>
          <div style="text-align:right">
            <div style="font-size:13px;color:var(--muted)">Comparisons: <span id="compCount">0</span></div>
            <div style="font-size:13px;color:var(--muted)">Steps: <span id="stepCount">0</span></div>
          </div>
        </div>

        <div class="status" id="message" style="margin-top:10px">Status: waiting to start</div>

        <div id="stackArea" style="display:none;margin-top:12px">
          <div style="font-weight:700;margin-bottom:8px">Recursion stack (top first)</div>
          <div class="stack" id="stackFrames"></div>
        </div>
      </div>

      <!-- Right: Pseudocode & info -->
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Pseudocode & Explanation</div>
          <div style="font-size:13px;color:var(--muted)">Click cells to set target</div>
        </div>

        <div style="margin-top:12px">
          <div class="pseudocode" id="pseudocode">
            <!-- code lines -->
          </div>
        </div>

        <div style="margin-top:12px" class="info">
          <div style="font-weight:700;margin-bottom:6px">How to use</div>
          <ul style="margin:0 0 0 18px;color:var(--muted);font-size:13px">
            <li>Generate a sorted array and set a target (input or click a cell).</li>
            <li>Use Step to advance one algorithm action; Play to auto-step at the selected speed.</li>
            <li>Observe left, right and mid pointers and the active search range.</li>
            <li>Switch to recursive mode for a stack-based view of recursive calls.</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

<script>
/*
  Binary Search Visualizer
  - Generates a sorted array (unique or with duplicates depending on spacing)
  - Allows setting a target by input or clicking a cell
  - Step-by-step iterative or recursive visual simulation with an optional auto-play
  - Highlights pseudocode line corresponding to the current step
*/

// ---- Utility ----
function $(id){ return document.getElementById(id); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

// ---- State ----
let arr = [];
let left = 0, right = -1, mid = -1;
let target = null;
let mode = 'iterative';
let running = false;
let autoTimer = null;
let compCount = 0, stepCount = 0;
let state = 'idle'; // 'idle','calc_mid','compare','found','notfound','done'
let speed = 700;

// For recursive visualization, maintain a simulated call stack frames: {l,r,status,mid}
let stack = [];
let recursiveActive = false;

// DOM
const arrayContainer = $('arrayContainer');
const sizeInput = $('sizeInput');
const genBtn = $('genBtn');
const minValInput = $('minVal');
const maxValInput = $('maxVal');
const targetInput = $('targetInput');
const setTargetBtn = $('setTargetBtn');
const randomTargetBtn = $('randomTargetBtn');
const stepBtn = $('stepBtn');
const playBtn = $('playBtn');
const resetBtn = $('resetBtn');
const fastBtn = $('fastBtn');
const speedInput = $('speed');
const compCountEl = $('compCount');
const stepCountEl = $('stepCount');
const messageEl = $('message');
const modeSelect = $('modeSelect');
const pseudocodeEl = $('pseudocode');
const stackArea = $('stackArea');
const stackFrames = $('stackFrames');

// Pseudocode lines for iterative and recursive modes
const pseudoIter = [
  'left = 0; right = n - 1',
  'while left <= right:',
  '  mid = floor((left + right) / 2)',
  '  if A[mid] == target:',
  '    return mid  // found',
  '  else if A[mid] < target:',
  '    left = mid + 1',
  '  else:',
  '    right = mid - 1',
  'return -1  // not found'
];

const pseudoRec = [
  'function binarySearchRec(A, left, right, target):',
  '  if left > right:',
  '    return -1  // base case: not found',
  '  mid = floor((left + right) / 2)',
  '  if A[mid] == target:',
  '    return mid  // found',
  '  else if A[mid] < target:',
  '    return binarySearchRec(A, mid+1, right, target)',
  '  else:',
  '    return binarySearchRec(A, left, mid-1, target)'
];

// Render pseudocode
function renderPseudocode(){
  pseudocodeEl.innerHTML = '';
  const lines = mode === 'iterative' ? pseudoIter : pseudoRec;
  lines.forEach((t,i) => {
    const div = document.createElement('div');
    div.className = 'line';
    div.dataset.line = i;
    div.textContent = t;
    pseudocodeEl.appendChild(div);
  });
}

// Render array
function renderArray(){
  arrayContainer.innerHTML = '';
  arr.forEach((v,i) => {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.index = i;
    const idx = document.createElement('div');
    idx.className = 'idx';
    idx.textContent = i;
    const val = document.createElement('div');
    val.className = 'val';
    val.textContent = v;
    cell.appendChild(idx);
    cell.appendChild(val);
    // Click to set target
    cell.addEventListener('click', () => {
      setTarget(arr[i]);
    });
    arrayContainer.appendChild(cell);
  });
  updateHighlights();
}

// Update highlights for left/right/mid/active range
function updateHighlights(foundIndex = null){
  const cells = arrayContainer.querySelectorAll('.cell');
  cells.forEach(c => {
    c.classList.remove('range','leftptr','rightptr','mid','found','notfound');
    const i = parseInt(c.dataset.index,10);
    if (state === 'done' && foundIndex !== null && i === foundIndex){
      c.classList.add('found');
    } else if (state === 'notfound' && (left>right)) {
      // show entire attempted range as not found highlight
      // mark none specifically; optional to flash
    } else {
      if (left <= right && i >= left && i <= right) c.classList.add('range');
      if (i === left && left <= right) c.classList.add('leftptr');
      if (i === right && left <= right) c.classList.add('rightptr');
      if (i === mid && mid >= left && mid <= right) c.classList.add('mid');
    }
  });
}

// Generate sorted array
function generateArray(){
  const n = clamp(parseInt(sizeInput.value,10) || 10, 3, 60);
  const minV = parseInt(minValInput.value,10) || 0;
  const maxV = parseInt(maxValInput.value,10);
  const mx = Math.max(maxV, minV + Math.floor(n*1.2));
  const range = Math.max(1, mx - minV + 1);
  // Generate increasing sequence with some spacing
  const res = [];
  let cur = minV;
  for (let i=0;i<n;i++){
    // spacing ensures sorted unique-ish but can allow duplicates if range small
    const remaining = n - i - 1;
    const maxStep = Math.max(1, Math.floor(range / n));
    const step = randInt(0, maxStep+2);
    cur += step;
    res.push(cur);
    cur += 1; // ensure growth
  }
  arr = res;
  resetSimulation();
}

// Set target
function setTarget(val){
  if (typeof val === 'string') {
    const parsed = parseInt(val,10);
    if (!Number.isFinite(parsed)) {
      target = null;
      targetInput.value = '';
      showMessage('Invalid target value', true);
      return;
    } else {
      target = parsed;
      targetInput.value = String(target);
    }
  } else {
    target = val;
    targetInput.value = String(val);
  }
  showMessage('Target set to ' + target);
}

// Reset simulation
function resetSimulation(){
  // initial pointers
  left = 0; right = arr.length - 1; mid = -1;
  compCount = 0; stepCount = 0; state = 'idle';
  stack = [];
  running = false;
  clearAuto();
  compCountEl.textContent = compCount;
  stepCountEl.textContent = stepCount;
  renderArray();
  renderPseudocode();
  highlightLine(null);
  stackArea.style.display = (mode === 'recursive') ? 'block' : 'none';
  stackFrames.innerHTML = '';
  showMessage('Array generated. Set a target to start.');
}

// Show message
function showMessage(msg, isError=false){
  messageEl.textContent = 'Status: ' + msg;
  messageEl.style.color = isError ? 'var(--danger)' : '#e6eef8';
}

// Highlight pseudocode line index
function highlightLine(i){
  const lines = pseudocodeEl.querySelectorAll('.line');
  lines.forEach((ln,idx)=> {
    ln.classList.toggle('active', idx === i);
  });
}

// Step function for iterative mode (state machine)
function stepIterative(){
  if (state === 'idle') {
    // initialize
    left = 0; right = arr.length - 1; mid = -1;
    state = 'calc_mid';
    showMessage(`Searching for ${target} between [${left},${right}]`);
    highlightLine(0); // left = 0; right = n - 1
    stepCount++;
    stepCountEl.textContent = stepCount;
    updateHighlights();
    return;
  }
  if (state === 'calc_mid') {
    if (left > right) {
      state = 'notfound';
      highlightLine(8);
      showMessage('Target not found (empty interval)');
      updateHighlights();
      return;
    }
    mid = Math.floor((left + right) / 2);
    state = 'compare';
    highlightLine(2); // mid calculation
    stepCount++;
    stepCountEl.textContent = stepCount;
    updateHighlights();
    showMessage(`Calculated mid = ${mid} (A[mid]=${arr[mid]})`);
    return;
  }
  if (state === 'compare') {
    compCount++;
    compCountEl.textContent = compCount;
    highlightLine(3); // if A[mid] == target
    stepCount++;
    stepCountEl.textContent = stepCount;
    const midVal = arr[mid];
    showMessage(`Compare target ${target} with A[mid] = ${midVal}`);
    if (midVal === target){
      state = 'found';
      highlightLine(4);
      showMessage(`Found target at index ${mid}`);
      updateHighlights(mid);
      state = 'done';
      running = false;
      clearAuto();
      return;
    } else if (midVal < target){
      highlightLine(5);
      // move left
      left = mid + 1;
      state = 'calc_mid';
      showMessage(`A[mid] < target → move left to ${left}`);
      updateHighlights();
      return;
    } else {
      highlightLine(7);
      right = mid - 1;
      state = 'calc_mid';
      showMessage(`A[mid] > target → move right to ${right}`);
      updateHighlights();
      return;
    }
  }
  if (state === 'notfound' || state === 'done') {
    running = false;
    clearAuto();
    showMessage(state === 'done' ? 'Search finished (found)' : 'Search finished (not found)');
  }
}

// Step function for recursive mode: we simulate recursion step-by-step by expanding/contracting stack
function stepRecursive(){
  // Initialize recursion if idle
  if (state === 'idle') {
    stack = [];
    stack.push({l:0, r:arr.length-1, status:'enter', mid:null});
    state = 'running';
    renderStack();
    highlightLine(0);
    stepCount++; stepCountEl.textContent = stepCount;
    showMessage(`Start recursion with [0, ${arr.length-1}]`);
    return;
  }

  if (stack.length === 0) {
    // finished without finding
    state = 'notfound'; showMessage('Target not found'); highlightLine(1);
    running = false; clearAuto();
    return;
  }

  // operate on top frame
  const frame = stack[stack.length - 1];
  // status sequence: enter -> check_base -> compute_mid -> compare -> decided (pop or push next)
  if (frame.status === 'enter') {
    frame.status = 'check_base';
    renderStack();
    highlightLine(1); // if left > right: base case
    stepCount++; stepCountEl.textContent = stepCount;
    if (frame.l > frame.r) {
      // base case, return -1 from this frame (pop)
      frame.status = 'return_notfound';
      showMessage(`Frame [${frame.l},${frame.r}] base case: left > right`);
      return;
    } else {
      showMessage(`Frame [${frame.l},${frame.r}] proceeding`);
      return;
    }
  } else if (frame.status === 'check_base' && frame.l <= frame.r) {
    // compute mid
    frame.mid = Math.floor((frame.l + frame.r) / 2);
    frame.status = 'compare';
    renderStack();
    highlightLine(2);
    stepCount++; stepCountEl.textContent = stepCount;
    showMessage(`Frame [${frame.l},${frame.r}] mid = ${frame.mid} (A[mid]=${arr[frame.mid]})`);
    return;
  } else if (frame.status === 'compare') {
    // compare
    compCount++; compCountEl.textContent = compCount;
    stepCount++; stepCountEl.textContent = stepCount;
    const mVal = arr[frame.mid];
    highlightLine(3);
    if (mVal === target) {
      // found: we want to clear stack and show found
      showMessage(`Found target at index ${frame.mid}`);
      // mark found and finish
      state = 'done';
      renderArray();
      updateHighlights(frame.mid);
      highlightLine(4);
      running = false; clearAuto();
      // clear stack and show result
      stack = [];
      renderStack();
      return;
    } else if (mVal < target) {
      // search right half
      frame.status = 'go_right';
      highlightLine(5);
      showMessage(`A[mid] < target → recurse into [${frame.mid+1}, ${frame.r}]`);
      // push new frame
      stack.push({l: frame.mid+1, r: frame.r, status:'enter', mid:null});
      renderStack();
      return;
    } else {
      frame.status = 'go_left';
      highlightLine(7);
      showMessage(`A[mid] > target → recurse into [${frame.l}, ${frame.mid-1}]`);
      stack.push({l: frame.l, r: frame.mid-1, status:'enter', mid:null});
      renderStack();
      return;
    }
  } else if (frame.status === 'return_notfound') {
    // this frame returns -1: pop it
    stack.pop();
    renderStack();
    stepCount++; stepCountEl.textContent = stepCount;
    showMessage(`Returning from frame (not found)`);
    highlightLine(1);
    return;
  } else {
    // any other status remove or continue
    stack.pop();
    renderStack();
    return;
  }
}

// Global step
function step(){
  if (mode === 'iterative') {
    stepIterative();
  } else {
    stepRecursive();
  }
  updateHighlights();
  renderStack();
}

// Auto-play
function clearAuto(){
  if (autoTimer) {
    clearInterval(autoTimer); autoTimer = null;
    playBtn.textContent = 'Play';
  }
}
function play(){
  if (running) { running = false; clearAuto(); return; }
  running = true;
  playBtn.textContent = 'Pause';
  clearAuto();
  autoTimer = setInterval(() => {
    // If done, stop
    if (state === 'done' || state === 'notfound') {
      running = false;
      clearAuto();
      return;
    }
    // If target not set, pause
    if (target === null || target === '') {
      showMessage('Set a target first', true);
      running = false; clearAuto(); return;
    }
    step();
  }, speed);
}

// Fast run: run to completion quickly (no step UI)
function fastRun(){
  if (target === null || target === '') {
    showMessage('Set a target first', true);
    return;
  }
  if (mode === 'iterative') {
    // simple while loop simulation updating visuals only at the end
    left = 0; right = arr.length -1; mid = -1;
    compCount = 0; stepCount = 0;
    while (left <= right) {
      mid = Math.floor((left + right)/2);
      compCount++;
      if (arr[mid] === target) {
        showMessage('Found target at index ' + mid);
        state = 'done';
        updateHighlights(mid);
        compCountEl.textContent = compCount;
        stepCountEl.textContent = stepCount;
        return;
      } else if (arr[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    state = 'notfound';
    showMessage('Not found');
    updateHighlights();
    compCountEl.textContent = compCount;
    stepCountEl.textContent = stepCount;
  } else {
    // For recursion, perform normal recursion and animate result at end
    const recSearch = (A,l,r) => {
      if (l>r) return -1;
      const m = Math.floor((l+r)/2);
      if (A[m] === target) return m;
      if (A[m] < target) return recSearch(A,m+1,r);
      return recSearch(A,l,m-1);
    };
    const result = recSearch(arr,0,arr.length-1);
    if (result >= 0) {
      showMessage('Found target at index ' + result);
      state = 'done';
      updateHighlights(result);
    } else {
      showMessage('Not found');
      state = 'notfound';
      updateHighlights();
    }
  }
}

// Render recursion stack
function renderStack(){
  if (mode !== 'recursive') return;
  stackArea.style.display = 'block';
  stackFrames.innerHTML = '';
  // show top first (last frame is top)
  for (let i = stack.length - 1; i >= 0; i--){
    const f = stack[i];
    const div = document.createElement('div');
    div.className = 'frame';
    div.innerHTML = `<div>[${f.l}, ${f.r}]</div><div style="color:var(--muted)">${f.mid===null?'mid: -': 'mid: '+f.mid}</div>`;
    stackFrames.appendChild(div);
  }
  if (stack.length === 0 && state !== 'idle'){
    const div = document.createElement('div');
    div.className = 'frame';
    div.textContent = 'Empty stack';
    stackFrames.appendChild(div);
  }
}

// UI bindings
genBtn.addEventListener('click', () => {
  generateArray();
});
setTargetBtn.addEventListener('click', () => {
  setTarget(targetInput.value);
});
randomTargetBtn.addEventListener('click', () => {
  // pick random value between min and max (may or may not exist)
  const minV = parseInt(minValInput.value,10) || 0;
  const maxV = parseInt(maxValInput.value,10) || (minV+30);
  const v = randInt(minV, maxV);
  setTarget(v);
});
stepBtn.addEventListener('click', () => {
  if (target === null || target === '') {
    showMessage('Set a target first', true);
    return;
  }
  step();
});
playBtn.addEventListener('click', () => {
  if (target === null || target === '') {
    showMessage('Set a target first', true);
    return;
  }
  play();
});
resetBtn.addEventListener('click', () => {
  resetSimulation();
});
fastBtn.addEventListener('click', () => {
  fastRun();
});
speedInput.addEventListener('input', () => {
  speed = parseInt(speedInput.value,10);
  if (autoTimer){
    // restart with new speed
    clearAuto();
    play();
  }
});
modeSelect.addEventListener('change', () => {
  mode = modeSelect.value;
  resetSimulation();
});

// Allow Enter key in target input to set
targetInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    setTarget(targetInput.value);
  }
});

// Initialize default
generateArray();
renderPseudocode();
updateHighlights();
showMessage('Ready. Generate array and set a target. Click Step to begin.');

// Keep highlights updated if window resizes or content changes
window.addEventListener('resize', updateHighlights);
</script>

</body>
</html>