<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Interactive Knapsack Problem (0/1) — Dynamic Programming Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 18px; color:#111; background: #fafafa; }
  h1 { margin: 0 0 8px; font-size: 20px; }
  .container { display: grid; grid-template-columns: 360px 1fr; gap: 18px; align-items: start; }
  .panel { background: #fff; border: 1px solid #e2e6ea; padding: 12px; border-radius: 8px; box-shadow: 0 1px 2px rgba(16,24,40,0.03); }
  label { display:block; font-size: 13px; margin-top: 8px; color:#333; }
  input[type=number] { width: 100%; padding: 6px 8px; margin-top:6px; box-sizing:border-box; }
  button { padding: 8px 10px; border-radius: 6px; border: 1px solid #cbd5e1; background: linear-gradient(#fff,#f8fafc); cursor: pointer; margin-right:6px; }
  button.primary { background: linear-gradient(#2563eb,#1d4ed8); color: #fff; border: none; }
  button.warn { background: linear-gradient(#f97316,#ea580c); color:#fff; border:none; }
  .items-list { margin-top: 8px; font-size: 14px; }
  ul { padding-left: 18px; margin: 6px 0; }
  .grid-wrap { overflow: auto; max-height: 640px; border-radius: 6px; border: 1px solid #eef2f7; background:#fff; padding: 8px; }
  table.dp { border-collapse: collapse; font-size: 12px; }
  table.dp td, table.dp th { border: 1px solid #e6eef6; padding: 6px 8px; text-align:center; min-width: 52px; vertical-align: middle; }
  table.dp th { background:#f1f5f9; font-weight:600; position: sticky; top:0; z-index:1; }
  .cell-value { font-weight:700; font-size:13px; display:block; }
  .cell-sub { font-size:11px; color:#475569; }
  .taken { background: linear-gradient(135deg,#bbf7d0,#86efac); }
  .trace { outline: 3px solid rgba(99,102,241,0.18); }
  .controls { margin-top: 10px; }
  .explain { font-size: 13px; color:#284; margin-top: 8px; background:#fefce8; padding:8px; border-radius:6px; border:1px solid #fef3c7; }
  .small { font-size: 12px; color:#475569; }
  .row-header { background:#eef2ff; font-weight:700; min-width: 72px; position: sticky; left:0; z-index:2; }
  .legend { display:flex; gap:8px; margin-top:8px; align-items:center; }
  .legend span { display:inline-block; padding:6px 8px; border-radius:6px; font-size:12px; }
  .legend .l-taken { background: linear-gradient(135deg,#bbf7d0,#86efac); border:1px solid #c7f0d0;}
  .legend .l-trace { outline:3px solid rgba(99,102,241,0.18); background:#fff;}
  footer { margin-top:12px; color:#64748b; font-size:12px; }
  .flex { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .item-row { display:flex; gap:8px; align-items:center; margin-top:6px; }
  .item-row input { width: 100px; }
  .note { color:#475569; font-size:13px; margin-top:10px; }
</style>
</head>
<body>
  <h1>Knapsack Problem — Interactive 0/1 Dynamic Programming Demo</h1>
  <div class="container">
    <div class="panel">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <strong>Controls & Items</strong>
        <small class="small">0/1 knapsack (items indivisible)</small>
      </div>

      <label>Capacity (W) — max 200 recommended</label>
      <input id="capacity" type="number" value="20" min="1" max="500">

      <div class="item-row">
        <label style="flex:1;">Add Item — weight</label>
        <input id="newWeight" type="number" value="6" min="1" style="width:80px;">
        <label style="width:40px;text-align:center;">value</label>
        <input id="newValue" type="number" value="30" min="0" style="width:80px;">
        <button id="addItemBtn">Add</button>
      </div>

      <div class="controls">
        <button id="solveBtn" class="primary">Solve (DP)</button>
        <button id="stepBtn">Step-by-step</button>
        <button id="stopBtn" style="display:none;">Stop</button>
        <button id="randomBtn">Random Items</button>
        <button id="clearBtn" class="warn">Clear Items</button>
      </div>

      <div class="items-list panel" style="margin-top:10px;">
        <strong>Items (index: weight, value)</strong>
        <div id="itemsDiv" class="small"></div>
        <div style="margin-top:8px;">
          <button id="removeLastBtn">Remove Last</button>
          <button id="autoFillBtn">Fill Example (classic)</button>
        </div>
      </div>

      <div class="explain">
        How it works: We build a DP table dp[i][w] = best value using first i items with capacity w.
        Reconstruction follows: if dp[i][w] != dp[i-1][w] then item i was taken.
      </div>

      <div class="note">
        Try different capacities and item sets. Use Step-by-step to watch rows being computed.
      </div>

      <div style="margin-top:10px;">
        <div class="legend">
          <span class="l-taken">Taken in optimal solution</span>
          <span class="l-trace">Trace path (reconstruction)</span>
        </div>
      </div>
    </div>

    <div class="panel">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <strong>DP Table & Results</strong>
        <div class="small">Columns: capacity 0..W</div>
      </div>

      <div id="results" class="small" style="margin-top:8px;"></div>
      <div class="grid-wrap" id="gridWrap" style="margin-top:8px;">
        <div id="tableContainer"></div>
      </div>

      <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
        <button id="showTakenBtn">Show Selected Items</button>
        <button id="highlightTraceBtn">Highlight Reconstruction Path</button>
        <button id="clearHighlightsBtn">Clear Highlights</button>
      </div>

      <div id="fracDiv" class="small" style="margin-top:10px;"></div>
      <footer>
        Note: This demo calculates 0/1 knapsack optimally. For fractional knapsack (continuous items), greedy by value/weight works.
      </footer>
    </div>
  </div>

<script>
(function(){
  // State
  let items = []; // each {w,v}
  let capacityEl = document.getElementById('capacity');
  let itemsDiv = document.getElementById('itemsDiv');
  let tableContainer = document.getElementById('tableContainer');
  let results = document.getElementById('results');
  let fracDiv = document.getElementById('fracDiv');

  // DP structures
  let dp = null; // 2D array
  let n = 0;
  let W = 0;
  let running = false;
  let stepMode = false;
  let stepTimer = null;

  // Helpers
  function renderItems(){
    if(items.length === 0){ itemsDiv.innerHTML = "<em>No items</em>"; return; }
    let out = '<ul>';
    for(let i=0;i<items.length;i++){
      out += `<li>i=${i+1}: weight=${items[i].w}, value=${items[i].v}</li>`;
    }
    out += '</ul>';
    itemsDiv.innerHTML = out;
  }

  function clampCapacityVal(){
    let val = parseInt(capacityEl.value) || 0;
    if(val < 1) val = 1;
    if(val > 500) val = 500;
    capacityEl.value = val;
    return val;
  }

  function buildEmptyDP(n, W){
    // creates (n+1) x (W+1) zeroed
    let a = new Array(n+1);
    for(let i=0;i<=n;i++){
      a[i] = new Array(W+1).fill(0);
    }
    return a;
  }

  function colorForValue(val){
    // return background color based on magnitude (simple)
    if(val === 0) return '#fff';
    let t = Math.min(1, val/200); // scale
    let r = Math.round(240 - 80*t);
    let g = Math.round(250 - 160*(1-t));
    let b = Math.round(255 - 30*t);
    return `rgb(${r},${g},${b})`;
  }

  function renderTable(dpTable){
    // build HTML table for dp array
    if(!dpTable) { tableContainer.innerHTML = '<div class="small">No DP computed yet.</div>'; return; }
    let rows = dpTable.length - 1;
    let cols = dpTable[0].length - 1;
    let html = '<table class="dp" id="dpTable">';
    // header row
    html += '<tr><th class="row-header">i \\ w</th>';
    for(let w=0; w<=cols; w++){
      html += `<th>${w}</th>`;
    }
    html += '</tr>';
    for(let i=0;i<=rows;i++){
      html += `<tr>`;
      if(i===0){
        html += `<th class="row-header">i=0</th>`;
      } else {
        html += `<th class="row-header">i=${i} (w=${items[i-1].w}, v=${items[i-1].v})</th>`;
      }
      for(let w=0; w<=cols; w++){
        let val = dpTable[i][w];
        let bg = colorForValue(val);
        html += `<td id="cell-${i}-${w}" style="background:${bg}"><span class="cell-value">${val}</span>`;
        if(i>0){
          html += `<span class="cell-sub">(${i-1},${w})</span>`;
        } else {
          html += `<span class="cell-sub">base</span>`;
        }
        html += `</td>`;
      }
      html += `</tr>`;
    }
    html += '</table>';
    tableContainer.innerHTML = html;
  }

  function computeDPFull(){
    n = items.length;
    W = clampCapacityVal();
    // size guard
    if(W > 300){
      if(!confirm("Capacity > 300 may create a large table and be slow. Continue?")) return;
    }
    dp = buildEmptyDP(n, W);

    // Standard 0/1 knapsack DP
    for(let i=1;i<=n;i++){
      let wi = items[i-1].w;
      let vi = items[i-1].v;
      for(let w=0; w<=W; w++){
        if(wi <= w){
          let take = dp[i-1][w-wi] + vi;
          let notake = dp[i-1][w];
          dp[i][w] = Math.max(take, notake);
        } else {
          dp[i][w] = dp[i-1][w];
        }
      }
    }
    renderTable(dp);
    displayResult();
    computeFractionalGreedy();
  }

  function computeFractionalGreedy(){
    // For comparison: fractional knapsack (continuous) greedy
    let Wcap = clampCapacityVal();
    let arr = items.map((it, idx) => ({idx: idx+1, w:it.w, v:it.v, r: it.v/it.w}));
    arr.sort((a,b)=>b.r - a.r);
    let remaining = Wcap;
    let value = 0;
    let taken = [];
    for(let it of arr){
      if(remaining === 0) break;
      if(it.w <= remaining){
        taken.push({idx: it.idx, w: it.w, v: it.v, frac:1});
        value += it.v;
        remaining -= it.w;
      } else {
        let frac = remaining / it.w;
        taken.push({idx: it.idx, w: it.w, v: it.v, frac: frac});
        value += it.v * frac;
        remaining = 0;
        break;
      }
    }
    // render summary
    let s = `<strong>Fractional (greedy) optimum:</strong> value ≈ ${value.toFixed(2)}; items: `;
    s += taken.map(t => `#${t.idx}${t.frac<1?('('+ (t.frac*100|0) +'% )'):''}`).join(', ');
    fracDiv.innerHTML = s;
  }

  function displayResult(){
    if(!dp) return;
    let best = dp[n][W];
    results.innerHTML = `<strong>Optimal value:</strong> ${best} for capacity W=${W}. Items count: ${n}.`;
  }

  function reconstructSelected(){
    if(!dp) return [];
    let sel = new Array(n).fill(false);
    let i = n;
    let w = W;
    let path = [];
    while(i > 0){
      if(dp[i][w] !== dp[i-1][w]){
        // taken
        sel[i-1] = true;
        path.push({i:i, w:w, taken:true});
        w -= items[i-1].w;
        i -= 1;
      } else {
        path.push({i:i, w:w, taken:false});
        i -= 1;
      }
    }
    return {selected: sel, path: path};
  }

  function showSelectedOnTable(){
    clearHighlights();
    if(!dp){
      alert("Compute DP first (Solve).");
      return;
    }
    let res = reconstructSelected();
    const sel = res.selected;
    // mark cells where item included: those dp[i][w] equal dp[i-1][w-wi] + vi and chosen in backtrace.
    let i = n; let w = W;
    while(i > 0){
      let cell = document.getElementById(`cell-${i}-${w}`);
      if(!cell){ i--; continue; }
      if(sel[i-1]){
        // color this cell as taken
        cell.classList.add('taken');
        // step back to w - wi
        w -= items[i-1].w;
      }
      i--;
    }
    // highlight those item rows in the header perhaps: we'll also show list
    let chosen = sel.map((v,idx)=> v ? `#${idx+1}` : null).filter(Boolean);
    let best = dp[n][W];
    results.innerHTML = `<strong>Optimal value:</strong> ${best} (selected items: ${chosen.join(', ') || 'none'})`;
  }

  function highlightTrace(){
    // highlight the exact reconstruction path cells (i,w) visited when reconstructing
    clearHighlights();
    if(!dp){ alert("Compute DP first."); return; }
    let i = n;
    let w = W;
    let visited = [];
    while(i > 0){
      visited.push({i:i, w:w});
      if(dp[i][w] !== dp[i-1][w]){
        w -= items[i-1].w;
        i -= 1;
      } else {
        i -= 1;
      }
    }
    visited.push({i:0, w:w});
    for(const p of visited){
      let cell = document.getElementById(`cell-${p.i}-${p.w}`);
      if(cell) cell.classList.add('trace');
    }
    results.innerHTML = `<strong>Trace length:</strong> ${visited.length}. Reconstructing from (i=${n}, w=${W}) to base.`;
  }

  function clearHighlights(){
    let cells = tableContainer.querySelectorAll('td');
    cells.forEach(c => { c.classList.remove('taken'); c.classList.remove('trace'); });
    displayResult();
  }

  // Step-by-step animation: fill DP row by row and update table progressively
  function computeDPWithSteps(){
    if(running) return;
    stepMode = true;
    n = items.length;
    W = clampCapacityVal();
    if(n === 0){ alert("Add some items first."); return; }
    dp = buildEmptyDP(n, W);
    renderTable(dp);
    let i = 1;
    running = true;
    document.getElementById('solveBtn').disabled = true;
    document.getElementById('stepBtn').style.display = 'none';
    document.getElementById('stopBtn').style.display = 'inline-block';
    stepTimer = setInterval(()=>{
      if(i>n || !running){
        clearInterval(stepTimer);
        running = false;
        stepMode = false;
        document.getElementById('solveBtn').disabled = false;
        document.getElementById('stepBtn').style.display = 'inline-block';
        document.getElementById('stopBtn').style.display = 'none';
        renderTable(dp);
        displayResult();
        computeFractionalGreedy();
        return;
      }
      // compute row i
      let wi = items[i-1].w, vi = items[i-1].v;
      for(let w=0; w<=W; w++){
        if(wi <= w){
          let take = dp[i-1][w-wi] + vi;
          let notake = dp[i-1][w];
          dp[i][w] = Math.max(take, notake);
        } else {
          dp[i][w] = dp[i-1][w];
        }
      }
      // update only row i in DOM
      updateRowInDOM(i);
      i++;
    }, 350);
  }

  function updateRowInDOM(i){
    // Ensure table exists, else render
    let tbl = document.getElementById('dpTable');
    if(!tbl){ renderTable(dp); return; }
    for(let w=0; w<=W; w++){
      let cell = document.getElementById(`cell-${i}-${w}`);
      if(cell){
        let val = dp[i][w];
        cell.querySelector('.cell-value').textContent = val;
        cell.style.background = colorForValue(val);
      }
    }
    // small message:
    results.innerHTML = `Computing row i=${i}...`;
  }

  // UI event bindings
  document.getElementById('addItemBtn').addEventListener('click', ()=>{
    let w = parseInt(document.getElementById('newWeight').value) || 0;
    let v = parseInt(document.getElementById('newValue').value) || 0;
    if(w <= 0){ alert("Weight must be positive integer."); return; }
    items.push({w:w, v:v});
    renderItems();
  });

  document.getElementById('removeLastBtn').addEventListener('click', ()=>{
    if(items.length === 0) return;
    items.pop();
    renderItems();
  });

  document.getElementById('clearBtn').addEventListener('click', ()=>{
    if(!confirm("Clear all items?")) return;
    items = [];
    renderItems();
    dp = null;
    tableContainer.innerHTML = '';
    results.innerHTML = '';
    fracDiv.innerHTML = '';
  });

  document.getElementById('randomBtn').addEventListener('click', ()=>{
    let count = Math.max(4, Math.min(18, Math.round(Math.random()*12 + 4)));
    items = [];
    for(let i=0;i<count;i++){
      let w = Math.max(1, Math.round(Math.random()*12));
      let v = Math.max(1, Math.round(Math.random()*35));
      items.push({w:w, v:v});
    }
    renderItems();
  });

  document.getElementById('autoFillBtn').addEventListener('click', ()=>{
    // classic example
    items = [
      {w: 12, v:4},
      {w: 2, v:2},
      {w: 1, v:1},
      {w: 1, v:2},
      {w: 4, v:10}
    ];
    capacityEl.value = 15;
    renderItems();
  });

  document.getElementById('solveBtn').addEventListener('click', ()=>{
    if(items.length === 0){ alert("Add items first."); return; }
    computeDPFull();
  });

  document.getElementById('stepBtn').addEventListener('click', ()=>{
    if(items.length === 0){ alert("Add items first."); return; }
    computeDPWithSteps();
  });

  document.getElementById('stopBtn').addEventListener('click', ()=>{
    running = false;
    stepMode = false;
    clearInterval(stepTimer);
    document.getElementById('solveBtn').disabled = false;
    document.getElementById('stepBtn').style.display = 'inline-block';
    document.getElementById('stopBtn').style.display = 'none';
    if(dp) { renderTable(dp); displayResult(); computeFractionalGreedy(); }
  });

  document.getElementById('showTakenBtn').addEventListener('click', showSelectedOnTable);
  document.getElementById('highlightTraceBtn').addEventListener('click', highlightTrace);
  document.getElementById('clearHighlightsBtn').addEventListener('click', clearHighlights);

  // Initialize with a small example
  items = [
    {w:6, v:30},
    {w:3, v:14},
    {w:4, v:16},
    {w:2, v:9}
  ];
  renderItems();
  // computeDPFull();

  // Make table responsive to capacity changes: if dp exists and capacity changed, clear dp
  capacityEl.addEventListener('change', ()=>{
    dp = null;
    tableContainer.innerHTML = '';
    results.innerHTML = '';
    fracDiv.innerHTML = '';
  });

  // keyboard convenience: Enter in newValue adds item
  document.getElementById('newValue').addEventListener('keydown', (e)=>{
    if(e.key === 'Enter') document.getElementById('addItemBtn').click();
  });

})();
</script>
</body>
</html>