<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Adjacency Matrix Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #4fd1c5;
      --muted: #9aa7b2;
      --edge: rgba(255,255,255,0.15);
    }
    html,body { height:100%; margin:0; font-family: Inter, Roboto, Arial, sans-serif; background: linear-gradient(180deg,#061022 0%, #081426 100%); color:#e6eef6; }
    .app {
      display:flex;
      gap:12px;
      padding:16px;
      box-sizing:border-box;
      height:100vh;
    }
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      border-radius:10px;
      padding:12px;
      box-sizing:border-box;
      box-shadow: 0 8px 30px rgba(2,6,23,0.6);
    }
    .left {
      flex:1.3;
      display:flex;
      flex-direction:column;
      min-width:400px;
    }
    .right {
      flex:1;
      min-width:360px;
      max-width:540px;
      overflow:auto;
    }
    .controls {
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    button, input[type="number"], select, textarea {
      background: rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
    }
    button:hover { transform: translateY(-1px); cursor:pointer; color:white; border-color: rgba(255,255,255,0.12); }
    .status {
      margin-left:auto;
      font-size:13px;
      color:var(--muted);
    }
    #canvasWrap {
      flex:1;
      border-radius:8px;
      overflow:hidden;
      position:relative;
      border: 1px dashed rgba(255,255,255,0.03);
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.008));
    }
    svg {
      display:block;
      width:100%;
      height:100%;
      cursor:crosshair;
      user-select:none;
      -webkit-user-select:none;
      -moz-user-select:none;
    }
    .node {
      fill: linear-gradient(180deg, #1f6, #08a);
    }
    #matrixWrap {
      max-height: calc(100vh - 120px);
      overflow:auto;
      padding:8px;
    }
    table.matrix {
      border-collapse:collapse;
      font-family: monospace;
      font-size:13px;
      width:100%;
      table-layout:fixed;
    }
    table.matrix th, table.matrix td {
      border:1px solid rgba(255,255,255,0.03);
      padding:6px;
      text-align:center;
      min-width:30px;
      max-width:60px;
      overflow:hidden;
      white-space:nowrap;
      color:var(--muted);
      background: rgba(255,255,255,0.01);
    }
    table.matrix th {
      background: rgba(255,255,255,0.02);
      color:#dfeff2;
      font-weight:600;
      position:sticky;
      top:0;
      z-index:2;
    }
    table.matrix tr.header th:first-child { position:sticky; left:0; z-index:3; }
    table.matrix td.cell-hover, table.matrix th.col-hover {
      background: rgba(79,209,197,0.08);
      color:#a9fff6;
    }
    .edge-line {
      stroke: rgba(255,255,255,0.14);
      stroke-width:2;
      fill:none;
      stroke-linecap:round;
    }
    .edge-arrow {
      stroke: rgba(255,255,255,0.14);
      stroke-width:1.6;
      fill: rgba(255,255,255,0.14);
    }
    .node-circle {
      fill: linear-gradient(180deg,#0ea5a4,#2563eb);
    }
    .node-bg {
      fill: rgba(255,255,255,0.03);
      stroke: rgba(255,255,255,0.06);
    }
    .node-label {
      pointer-events:none;
      font-size:12px;
      fill:#e6f7fa;
      text-anchor:middle;
      dominant-baseline:middle;
      font-weight:600;
    }
    .mini {
      font-size:12px;
      color:var(--muted);
    }
    .footer {
      display:flex;
      gap:8px;
      align-items:center;
      margin-top:10px;
    }
    .hint {
      font-size:12px;
      color:var(--muted);
    }
    textarea.importBox { width:100%; height:60px; background:transparent; color:#dbefff; border:1px dashed rgba(255,255,255,0.04); padding:8px; border-radius:6px; }
    .bad { color:#ff9b9b; }
    .good { color:#9df0d9; }
    .small { font-size:12px; color:var(--muted); }
    .legend { display:flex; gap:10px; align-items:center; font-size:13px; color:var(--muted); }
    .legend .item { display:flex; gap:6px; align-items:center; }
    .swatch { width:18px; height:10px; border-radius:3px; background:linear-gradient(90deg,#4fd1c5,#38bdf8); border:1px solid rgba(255,255,255,0.04); }
    .controls .group { display:flex; gap:6px; align-items:center; }
    .linklike { color:#8fdbd3; text-decoration:underline; background:transparent; border:none; padding:0; cursor:pointer; font-size:13px; }
    .matrix-controls { display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }
    .note { font-size:13px; color:var(--muted); }
    .topbar { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    .nodeCount { font-weight:700; color:#dff6f2; }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel left">
      <div class="topbar controls">
        <div class="group">
          <button id="addNodeBtn">Add node</button>
          <button id="randomBtn">Random graph</button>
          <button id="clearBtn">Clear</button>
        </div>

        <div class="group">
          <label class="mini">Mode:</label>
          <select id="mode">
            <option value="add">Add edges (click nodes)</option>
            <option value="remove">Remove edges (click nodes)</option>
          </select>
        </div>

        <div class="group">
          <label class="mini">Directed</label>
          <input type="checkbox" id="directed" />
        </div>

        <div class="group">
          <label class="mini">Weighted</label>
          <input type="checkbox" id="weighted" />
          <input id="weightInput" type="number" value="1" style="width:68px;" step="any" />
        </div>

        <div class="status">
          Nodes: <span class="nodeCount" id="nodeCount">0</span>
        </div>
      </div>

      <div id="canvasWrap">
        <svg id="svgCanvas" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet"></svg>
      </div>

      <div class="footer">
        <div class="hint">Instructions: Add nodes, then click two nodes to add/remove an edge. Drag nodes to reposition. Click matrix cells to edit values.</div>
        <div style="margin-left:auto;" class="legend">
          <div class="item"><div class="swatch"></div> Edge</div>
        </div>
      </div>
    </div>

    <div class="panel right">
      <div class="matrix-controls">
        <div class="group">
          <button id="exportBtn">Export JSON</button>
          <button id="importBtn">Import JSON</button>
        </div>
        <div class="group">
          <button id="transposeBtn">Transpose</button>
          <button id="complementBtn">Complement</button>
        </div>
        <div style="margin-left:auto" class="small">Click a row or column header to highlight.</div>
      </div>

      <div id="matrixWrap"></div>

      <div style="margin-top:10px;">
        <div class="note">Adjacency matrix: A[i][j] indicates an edge from node i to node j. For undirected graphs, matrix is symmetric.</div>
        <div style="margin-top:8px;">
          <textarea id="ioArea" class="importBox" placeholder="Exported graph JSON will appear here; you can paste JSON here to import."></textarea>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function(){
      // Basic graph model
      let nodes = []; // {id,label,x,y}
      let matrix = []; // NxN numbers (0 or weight)
      let svg = document.getElementById('svgCanvas');
      let addNodeBtn = document.getElementById('addNodeBtn');
      let randomBtn = document.getElementById('randomBtn');
      let clearBtn = document.getElementById('clearBtn');
      let directedChk = document.getElementById('directed');
      let weightedChk = document.getElementById('weighted');
      let weightInput = document.getElementById('weightInput');
      let modeSelect = document.getElementById('mode');
      let matrixWrap = document.getElementById('matrixWrap');
      let nodeCountEl = document.getElementById('nodeCount');
      let exportBtn = document.getElementById('exportBtn');
      let importBtn = document.getElementById('importBtn');
      let ioArea = document.getElementById('ioArea');
      let transposeBtn = document.getElementById('transposeBtn');
      let complementBtn = document.getElementById('complementBtn');

      let state = {
        lastClickedNode: null,
        dragging: null,
        dragOffset: {x:0,y:0},
      };

      // Utilities
      function uid() { return Math.random().toString(36).slice(2,9); }
      function updateNodeCount() { nodeCountEl.textContent = nodes.length; }

      // Canvas size defaults (viewBox)
      const viewW = 800, viewH = 600;

      // Create new node at random location
      function addNodeAt(x,y,label) {
        let id = uid();
        let idx = nodes.length;
        let newNode = { id, label: label || ('v' + (idx)), x: x===undefined? (100 + Math.random()*(viewW-200)) : x, y: y===undefined? (100 + Math.random()*(viewH-200)) : y };
        nodes.push(newNode);
        // expand matrix
        for (let i=0;i<matrix.length;i++) matrix[i].push(0);
        matrix.push(Array(nodes.length).fill(0));
        refresh();
      }

      function removeAll() {
        nodes = [];
        matrix = [];
        state.lastClickedNode = null;
        refresh();
      }

      function randomGraph(n=6, p=0.25) {
        removeAll();
        for (let i=0;i<n;i++) addNodeAt(undefined,undefined,'v'+i);
        for (let i=0;i<n;i++){
          for (let j=0;j<n;j++){
            if (i===j) continue;
            if (Math.random()<p) {
              matrix[i][j] = weightedChk.checked ? Number(weightInput.value || 1) : 1;
              if (!directedChk.checked) matrix[j][i] = matrix[i][j];
            }
          }
        }
        refresh();
      }

      // Edge toggle from i->j
      function toggleEdge(i,j,make) {
        if (i<0||j<0||i>=nodes.length||j>=nodes.length) return;
        if (i===j) return; // ignore self-loops for simplicity
        let w = weightedChk.checked ? Number(weightInput.value || 1) : 1;
        if (make===true) {
          matrix[i][j] = w;
          if (!directedChk.checked) matrix[j][i] = w;
        } else if (make===false) {
          matrix[i][j] = 0;
          if (!directedChk.checked) matrix[j][i] = 0;
        } else {
          // toggle
          if (matrix[i][j]) {
            matrix[i][j] = 0;
            if (!directedChk.checked) matrix[j][i] = 0;
          } else {
            matrix[i][j] = w;
            if (!directedChk.checked) matrix[j][i] = w;
          }
        }
        refresh();
      }

      // Rendering
      function refresh() {
        updateNodeCount();
        renderSVG();
        renderMatrix();
      }

      function renderSVG() {
        // Clear
        while (svg.firstChild) svg.removeChild(svg.firstChild);

        // Draw edges first
        let N = nodes.length;
        for (let i=0;i<N;i++){
          for (let j=0;j<N;j++){
            if (matrix[i][j] && (directedChk.checked || i<=j || matrix[j][i]===0 || i!==j)) {
              // for undirected graphs we will draw once (i<j)
              if (!directedChk.checked && j<i) continue;
              drawEdge(nodes[i], nodes[j], matrix[i][j], directedChk.checked);
            }
          }
        }

        // Draw nodes
        nodes.forEach((n, idx)=>{
          let g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('data-idx', idx);
          g.setAttribute('class','node-g');
          // background circle
          let bg = document.createElementNS('http://www.w3.org/2000/svg','circle');
          bg.setAttribute('cx', n.x);
          bg.setAttribute('cy', n.y);
          bg.setAttribute('r', 22);
          bg.setAttribute('class', 'node-bg');
          bg.setAttribute('stroke-width','1.2');
          bg.setAttribute('fill','rgba(255,255,255,0.02)');
          g.appendChild(bg);

          // main circle
          let c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('cx', n.x);
          c.setAttribute('cy', n.y);
          c.setAttribute('r', 14);
          c.setAttribute('fill','url(#nodeGrad)');
          c.setAttribute('class','node-circle');
          c.setAttribute('stroke','rgba(255,255,255,0.06)');
          c.setAttribute('stroke-width','1.6');
          g.appendChild(c);

          // label
          let t = document.createElementNS('http://www.w3.org/2000/svg','text');
          t.setAttribute('x', n.x);
          t.setAttribute('y', n.y);
          t.setAttribute('class','node-label');
          t.textContent = n.label;
          g.appendChild(t);

          // interactions
          g.addEventListener('mousedown', onNodeMouseDown);
          g.addEventListener('mouseup', onNodeMouseUp);
          g.addEventListener('mouseleave', onNodeMouseLeave);
          g.addEventListener('click', onNodeClick);

          svg.appendChild(g);
        });

        // Add defs for gradient/arrow marker
        let defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
        let grad = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
        grad.setAttribute('id','nodeGrad');
        grad.setAttribute('x1','0%'); grad.setAttribute('x2','100%');
        grad.setAttribute('y1','0%'); grad.setAttribute('y2','100%');
        let stop1 = document.createElementNS('http://www.w3.org/2000/svg','stop'); stop1.setAttribute('offset','0%'); stop1.setAttribute('stop-color','#20c997'); stop1.setAttribute('stop-opacity','1');
        let stop2 = document.createElementNS('http://www.w3.org/2000/svg','stop'); stop2.setAttribute('offset','100%'); stop2.setAttribute('stop-color','#3b82f6'); stop2.setAttribute('stop-opacity','1');
        grad.appendChild(stop1); grad.appendChild(stop2);
        defs.appendChild(grad);

        // arrow marker for directed edges
        let marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
        marker.setAttribute('id','arrow');
        marker.setAttribute('markerWidth','8');
        marker.setAttribute('markerHeight','8');
        marker.setAttribute('refX','8');
        marker.setAttribute('refY','3');
        marker.setAttribute('orient','auto');
        let path = document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d','M0,0 L6,3 L0,6 z');
        path.setAttribute('fill','rgba(255,255,255,0.14)');
        marker.appendChild(path);
        defs.appendChild(marker);

        svg.insertBefore(defs, svg.firstChild);
      }

      function drawEdge(a,b,w,directed){
        // Draw a curved line slightly if nodes overlap or to make arrows clearer
        let x1=a.x, y1=a.y, x2=b.x, y2=b.y;
        let dx = x2-x1, dy = y2-y1, dist = Math.hypot(dx,dy);
        if (dist < 1) return;
        let normX = dx/dist, normY = dy/dist;
        // offset ends to avoid overlapping the node circles
        let r = 16;
        let sx = x1 + normX * r;
        let sy = y1 + normY * r;
        let ex = x2 - normX * r;
        let ey = y2 - normY * r;

        // curve offset
        let midx = (sx+ex)/2, midy = (sy+ey)/2;
        // perpendicular
        let px = -normY, py = normX;
        // curvature amount based on distance
        let curvature = Math.min(120, Math.max(8, dist*0.18));
        // for undirected and i>j, we avoid drawing twice, but here we rely on caller
        // create path
        let path = document.createElementNS('http://www.w3.org/2000/svg','path');
        // if nodes are almost aligned, draw straight
        let useCurve = true;
        if (Math.abs(dx) < 1 && Math.abs(dy) < 1) useCurve=false;
        let qx = midx + px*curvature;
        let qy = midy + py*curvature;
        let d = `M ${sx} ${sy} Q ${qx} ${qy} ${ex} ${ey}`;
        path.setAttribute('d', d);
        path.setAttribute('class','edge-line');
        path.setAttribute('stroke-width', Math.max(1, Math.min(3, Math.log(1+Math.abs(w))*1.6)));
        path.setAttribute('fill','none');
        if (directed) path.setAttribute('marker-end','url(#arrow)');
        svg.appendChild(path);

        // display weight label near midpoint
        if (weightedChk.checked) {
          let label = document.createElementNS('http://www.w3.org/2000/svg','text');
          label.setAttribute('x', qx);
          label.setAttribute('y', qy);
          label.setAttribute('class','node-label');
          label.setAttribute('font-size','11');
          label.setAttribute('fill','#cfeff0');
          label.textContent = w;
          svg.appendChild(label);
        }
      }

      // Interactions
      function onNodeClick(evt) {
        evt.stopPropagation();
        let g = evt.currentTarget;
        let idx = Number(g.getAttribute('data-idx'));
        let mode = modeSelect.value;
        if (mode === 'add') {
          if (state.lastClickedNode === null) {
            state.lastClickedNode = idx;
            highlightNodeHeader(idx);
          } else {
            let i = state.lastClickedNode, j = idx;
            // add edge i->j (or undirected)
            toggleEdge(i,j);
            state.lastClickedNode = null;
            clearHeaderHighlight();
          }
        } else {
          // remove mode: clicking two nodes will remove edge
          if (state.lastClickedNode === null) {
            state.lastClickedNode = idx;
            highlightNodeHeader(idx);
          } else {
            let i = state.lastClickedNode, j = idx;
            toggleEdge(i,j,false);
            state.lastClickedNode = null;
            clearHeaderHighlight();
          }
        }
      }

      function onNodeMouseDown(evt) {
        evt.stopPropagation();
        let g = evt.currentTarget;
        let idx = Number(g.getAttribute('data-idx'));
        state.dragging = idx;
        // compute offset
        let pt = getMousePos(evt);
        state.dragOffset.x = nodes[idx].x - pt.x;
        state.dragOffset.y = nodes[idx].y - pt.y;

        window.addEventListener('mousemove', onWindowMouseMove);
        window.addEventListener('mouseup', onWindowMouseUp);
      }
      function onNodeMouseUp(evt) {
        // prevent click being fired twice
      }
      function onNodeMouseLeave(evt) {
        // noop
      }

      function onWindowMouseMove(evt) {
        if (state.dragging === null) return;
        let idx = state.dragging;
        let pt = getMousePos(evt);
        nodes[idx].x = Math.max(20, Math.min(viewW-20, pt.x + state.dragOffset.x));
        nodes[idx].y = Math.max(20, Math.min(viewH-20, pt.y + state.dragOffset.y));
        refresh();
      }
      function onWindowMouseUp(evt) {
        state.dragging = null;
        window.removeEventListener('mousemove', onWindowMouseMove);
        window.removeEventListener('mouseup', onWindowMouseUp);
      }

      function getMousePos(evt) {
        // map client coordinates to SVG viewBox coords
        let pt = svg.createSVGPoint();
        pt.x = evt.clientX;
        pt.y = evt.clientY;
        let ctm = svg.getScreenCTM().inverse();
        let svgP = pt.matrixTransform(ctm);
        return { x: svgP.x, y: svgP.y };
      }

      // Matrix rendering
      function renderMatrix() {
        matrixWrap.innerHTML = '';
        let n = nodes.length;
        if (n === 0) {
          matrixWrap.innerHTML = '<div class="small" style="color:var(--muted)">No nodes yet â€” add nodes to build a graph.</div>';
          return;
        }
        let table = document.createElement('table');
        table.className = 'matrix';
        // header row
        let thead = document.createElement('thead');
        let htr = document.createElement('tr'); htr.className='header';
        let corner = document.createElement('th'); corner.textContent = ''; htr.appendChild(corner);
        for (let j=0;j<n;j++){
          let th = document.createElement('th');
          th.textContent = nodes[j].label;
          th.dataset.col = j;
          th.addEventListener('mouseenter', ()=>{ highlightColumn(j); });
          th.addEventListener('mouseleave', ()=>{ clearHeaderHighlight(); });
          th.addEventListener('click', ()=>{ selectColumn(j); });
          htr.appendChild(th);
        }
        thead.appendChild(htr);
        table.appendChild(thead);

        let tbody = document.createElement('tbody');
        for (let i=0;i<n;i++){
          let tr = document.createElement('tr');
          // row header
          let rh = document.createElement('th');
          rh.textContent = nodes[i].label;
          rh.dataset.row = i;
          rh.addEventListener('mouseenter', ()=>{ highlightRow(i); });
          rh.addEventListener('mouseleave', ()=>{ clearHeaderHighlight(); });
          rh.addEventListener('click', ()=>{ selectRow(i); });
          tr.appendChild(rh);
          for (let j=0;j<n;j++){
            let td = document.createElement('td');
            td.className = 'matrix-cell';
            td.dataset.i = i; td.dataset.j = j;
            td.textContent = matrix[i][j] ? matrix[i][j] : 0;
            td.addEventListener('click', onMatrixCellClick);
            td.addEventListener('dblclick', onMatrixCellDoubleClick);
            td.addEventListener('mouseenter', ()=>{ td.classList.add('cell-hover'); highlightSVGCell(i,j); });
            td.addEventListener('mouseleave', ()=>{ td.classList.remove('cell-hover'); clearSVGHighlight(); });
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }
        table.appendChild(tbody);
        matrixWrap.appendChild(table);
      }

      function onMatrixCellClick(evt){
        evt.stopPropagation();
        let td = evt.currentTarget;
        let i = Number(td.dataset.i), j = Number(td.dataset.j);
        if (weightedChk.checked) {
          // open small prompt to set value
          let cur = matrix[i][j] || 0;
          let val = prompt('Enter weight (0 to remove edge):', String(cur));
          if (val === null) return;
          let num = Number(val);
          if (isNaN(num)) { alert('Invalid number'); return; }
          matrix[i][j] = num;
          if (!directedChk.checked) matrix[j][i] = num;
        } else {
          // toggle
          matrix[i][j] = matrix[i][j] ? 0 : 1;
          if (!directedChk.checked) matrix[j][i] = matrix[i][j];
        }
        refresh();
      }

      function onMatrixCellDoubleClick(evt){
        // same as click for now
      }

      // Highlight helpers
      function highlightRow(i) {
        let table = matrixWrap.querySelector('table');
        if (!table) return;
        table.querySelectorAll('tr').forEach((tr, idx)=>{
          if (idx>0) {
            let th = tr.querySelector('th');
            if (Number(th.dataset.row) === i) th.classList.add('col-hover');
          }
        });
        // highlight svg node
        highlightSVGNode(i);
      }
      function highlightColumn(j) {
        let table = matrixWrap.querySelector('table');
        if (!table) return;
        let ths = table.querySelectorAll('thead th');
        ths.forEach((th, idx)=>{
          if (idx-1 === j) th.classList.add('col-hover');
        });
        highlightSVGNode(j);
      }
      function highlightNodeHeader(idx) {
        // visually mark that node is selected as first click
        let table = matrixWrap.querySelector('table');
        if (!table) return;
        // add a faint highlight on header
        let rowTh = table.querySelector('tbody tr:nth-child(' + (idx+1) + ') th');
        if (rowTh) rowTh.style.background = 'rgba(79,209,197,0.12)';
      }
      function clearHeaderHighlight(){
        let table = matrixWrap.querySelector('table');
        if (!table) return;
        table.querySelectorAll('th').forEach(th=> th.style.background = '');
        clearSVGHighlight();
      }
      function selectRow(i) {
        // select row as source for adding edges
        state.lastClickedNode = i;
        alert('Selected node ' + nodes[i].label + ' as source. Click another node to create/remove edge.');
      }
      function selectColumn(j) {
        state.lastClickedNode = j;
        alert('Selected node ' + nodes[j].label + ' as source. Click another node to create/remove edge.');
      }

      function highlightSVGNode(idx){
        // Change node circle stroke or background
        let gs = svg.querySelectorAll('g.node-g');
        gs.forEach(g=>{
          let id = Number(g.getAttribute('data-idx'));
          let circ = g.querySelector('circle');
          if (id === idx) {
            circ.setAttribute('stroke','rgba(79,209,197,0.95)');
            circ.setAttribute('stroke-width','2.6');
          } else {
            circ.setAttribute('stroke','rgba(255,255,255,0.06)');
            circ.setAttribute('stroke-width','1.6');
          }
        });
      }

      function highlightSVGCell(i,j) {
        // highlight nodes i and j
        highlightSVGNode(i);
        // maybe draw a temporary line
      }

      function clearSVGHighlight(){
        let gs = svg.querySelectorAll('g.node-g');
        gs.forEach(g=>{
          let circ = g.querySelector('circle');
          circ.setAttribute('stroke','rgba(255,255,255,0.06)');
          circ.setAttribute('stroke-width','1.6');
        });
      }

      // IO
      function exportJSON() {
        let data = { nodes: nodes.map(n=>({id:n.id,label:n.label,x:n.x,y:n.y})), matrix, directed: directedChk.checked, weighted: weightedChk.checked };
        let str = JSON.stringify(data, null, 2);
        ioArea.value = str;
        alert('Graph exported to the text area below. You can copy it.');
      }

      function importJSON() {
        try {
          let text = ioArea.value.trim();
          if (!text) { alert('Paste JSON into the textarea first.'); return; }
          let data = JSON.parse(text);
          if (!Array.isArray(data.nodes) || !Array.isArray(data.matrix)) { alert('Invalid format. Expecting {nodes: [...], matrix: [...]}'); return; }
          nodes = data.nodes.map(n=>({ id: n.id || uid(), label: n.label || 'v', x: (n.x||100), y:(n.y||100) }));
          matrix = data.matrix.map(row=>row.slice());
          directedChk.checked = !!data.directed;
          weightedChk.checked = !!data.weighted;
          refresh();
          alert('Imported graph with ' + nodes.length + ' nodes.');
        } catch (e) {
          alert('Error parsing JSON: ' + e.message);
        }
      }

      // Transformations
      function transposeMatrix() {
        let n = nodes.length;
        let m2 = Array(n).fill(0).map(()=>Array(n).fill(0));
        for (let i=0;i<n;i++) for (let j=0;j<n;j++) m2[j][i] = matrix[i][j];
        matrix = m2;
        // swap directed? Keep directed flag same; transpose just flips directions.
        refresh();
      }
      function complementMatrix() {
        let n = nodes.length;
        for (let i=0;i<n;i++){
          for (let j=0;j<n;j++){
            if (i===j) continue;
            matrix[i][j] = matrix[i][j] ? 0 : (weightedChk.checked ? Number(weightInput.value || 1) : 1);
          }
        }
        refresh();
      }

      // Event bindings
      addNodeBtn.addEventListener('click', ()=>{ addNodeAt(); });
      randomBtn.addEventListener('click', ()=>{ let n = parseInt(prompt('Number of nodes?', '6')||'6'); let p = parseFloat(prompt('Edge probability (0-1)', '0.25')||'0.25'); if (isNaN(n)||isNaN(p)) return; randomGraph(n,p); });
      clearBtn.addEventListener('click', ()=>{ if (confirm('Clear the graph?')) removeAll(); });
      exportBtn.addEventListener('click', exportJSON);
      importBtn.addEventListener('click', importJSON);
      transposeBtn.addEventListener('click', ()=>{ transposeMatrix(); });
      complementBtn.addEventListener('click', ()=>{ if (confirm('Replace edges with their complements (i.e. non-edges become edges)?')) complementMatrix(); });

      // Clicking empty canvas resets lastClickedNode
      svg.addEventListener('click', function(evt){
        state.lastClickedNode = null;
        clearHeaderHighlight();
      });

      // Resize handling: keep viewBox fixed so coordinates consistent
      svg.setAttribute('viewBox', `0 0 ${viewW} ${viewH}`);

      // Seed with a sample graph
      (function seed(){
        addNodeAt(120,120,'A');
        addNodeAt(340,100,'B');
        addNodeAt(560,160,'C');
        addNodeAt(200,360,'D');
        addNodeAt(480,360,'E');
        matrix = [
          [0,1,0,0,1],
          [0,0,1,0,0],
          [0,0,0,1,0],
          [0,0,0,0,1],
          [0,0,0,0,0]
        ];
        refresh();
      })();

      // Allow dropping JSON file
      window.addEventListener('dragover', e=>e.preventDefault());
      window.addEventListener('drop', e=>{ e.preventDefault(); let f = e.dataTransfer.files && e.dataTransfer.files[0]; if (f) { let reader = new FileReader(); reader.onload = ()=>{ ioArea.value = reader.result; importJSON(); }; reader.readAsText(f); } });

      // Keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'a' && e.ctrlKey) { e.preventDefault(); addNodeAt(); }
        if (e.key === 'e' && e.ctrlKey) { e.preventDefault(); exportJSON(); }
      });

      // Initial render done in seed
    })();
  </script>
</body>
</html>