<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Merge Sort Visualization</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724; --panel:#0b1220; --accent:#38bdf8; --muted:#94a3b8; --success:#34d399;
      --danger:#fb7185; --bar:#60a5fa;
    }
    html,body{height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial; background:linear-gradient(180deg,#071024 0%, #071430 100%); color:#e6eef8;}
    .app{max-width:1100px; margin:24px auto; padding:18px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; box-shadow:0 6px 30px rgba(2,6,23,0.6);}
    h1{margin:0 0 8px 0; font-size:20px; color:var(--accent);}
    .top{display:flex; gap:16px; align-items:center; flex-wrap:wrap;}
    .controls{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    button{background:#081026; border:1px solid rgba(255,255,255,0.06); color:var(--muted); padding:8px 12px; border-radius:8px; cursor:pointer;}
    button.primary{background:linear-gradient(90deg,var(--accent),#7dd3fc); color:#022; border:none;}
    button.danger{background:linear-gradient(90deg,var(--danger),#fb8fa3); color:#2d0211; border:none;}
    button:disabled{opacity:0.45; cursor:default;}
    .slider{display:flex; gap:8px; align-items:center;}
    input[type=range]{accent-color:var(--accent);}
    .main{display:flex; gap:16px; margin-top:16px;}
    .visual{flex:2; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02)); padding:12px; border-radius:10px; min-height:320px; display:flex; flex-direction:column;}
    .bars{display:flex; align-items:flex-end; gap:4px; height:260px; padding:12px; border-radius:8px; background:linear-gradient(180deg, rgba(6,10,20,0.6), rgba(6,10,30,0.4));}
    .bar{flex:1; background:var(--bar); border-radius:4px 4px 0 0; position:relative; transition:height 200ms ease, transform 150ms ease; display:flex; align-items:end; justify-content:center; color:rgba(3,7,18,0.9); font-size:11px; font-weight:600;}
    .bar .val{padding-bottom:6px; color:rgba(255,255,255,0.95); text-shadow:0 1px 0 rgba(0,0,0,0.2);}
    .bar.compare{background:linear-gradient(180deg,var(--accent),#1e6ea4); transform:scaleY(1.02); box-shadow:0 6px 22px rgba(56,189,248,0.08);}
    .bar.source{background:linear-gradient(180deg,var(--success),#0ea5a0);}
    .bar.target{background:linear-gradient(180deg,var(--danger),#ef4444);}
    .info{flex:1; padding:12px; border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02)); min-width:300px; max-height:520px; overflow:auto;}
    .row{display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px;}
    .stats{display:flex; gap:12px; flex-wrap:wrap;}
    .stat{background:rgba(255,255,255,0.02); padding:8px 10px; border-radius:8px; font-weight:600; color:var(--muted); }
    .legend{display:flex; gap:8px; margin-top:8px; flex-wrap:wrap;}
    .legend .item{display:flex; gap:6px; align-items:center; font-size:13px; color:var(--muted);}
    .swatch{width:18px; height:14px; border-radius:4px;}
    pre{background:rgba(2,6,23,0.6); padding:10px; border-radius:8px; color:#dbeafe; overflow:auto; font-size:13px;}
    .pseudocode{margin-top:12px;}
    .code-line{padding:4px 6px; border-radius:6px;}
    .code-line.active{background:linear-gradient(90deg, rgba(56,189,248,0.12), rgba(32,197,220,0.04)); color:var(--accent); font-weight:700;}
    footer{margin-top:12px; color:var(--muted); font-size:13px;}
    @media (max-width:900px){ .main{flex-direction:column;} .visual{order:2} .info{order:1}}
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Merge Sort Visualizer">
    <div class="top">
      <div>
        <h1>Merge Sort â€” Interactive Visualization</h1>
        <div style="color:var(--muted);font-size:13px;margin-top:6px;">
          Watch how Merge Sort splits the array, compares elements, and merges subarrays back into sorted order.
        </div>
      </div>
      <div style="flex:1"></div>
      <div class="controls" aria-hidden="false">
        <label style="color:var(--muted);font-size:13px;">Size:
          <input id="sizeRange" type="range" min="6" max="80" value="30" style="vertical-align:middle;margin-left:8px;">
        </label>
        <label style="color:var(--muted);font-size:13px;">Speed:
          <input id="speedRange" type="range" min="1" max="1000" value="300" style="vertical-align:middle;margin-left:8px;">
        </label>
        <button id="newBtn">New Array</button>
        <button id="shuffleBtn">Shuffle</button>
        <button id="startBtn" class="primary">Start</button>
        <button id="pauseBtn" disabled>Pause</button>
        <button id="stepBtn">Step</button>
        <button id="stopBtn" class="danger" disabled>Reset</button>
      </div>
    </div>

    <div class="main">
      <div class="visual" aria-live="polite">
        <div class="bars" id="bars" aria-hidden="false"></div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px;">
          <div style="color:var(--muted);font-size:13px;">Array visualization (bars represent values). Values shown on bars.</div>
          <div style="color:var(--muted);font-size:13px;">Speed controls the delay between animation steps (lower = faster)</div>
        </div>
      </div>

      <div class="info">
        <div class="row">
          <div class="stats">
            <div class="stat">Comparisons: <span id="cmpCount">0</span></div>
            <div class="stat">Writes: <span id="writeCount">0</span></div>
            <div class="stat">Array Size: <span id="arrSize">30</span></div>
          </div>
        </div>

        <div class="legend">
          <div class="item"><div class="swatch" style="background:linear-gradient(180deg,var(--accent),#1e6ea4)"></div> Comparing</div>
          <div class="item"><div class="swatch" style="background:linear-gradient(180deg,var(--success),#0ea5a0)"></div> Source element</div>
          <div class="item"><div class="swatch" style="background:linear-gradient(180deg,var(--danger),#ef4444)"></div> Target position write</div>
          <div class="item"><div class="swatch" style="background:linear-gradient(180deg,var(--bar),#3b82f6)"></div> Idle</div>
        </div>

        <div class="pseudocode">
          <div style="font-weight:700;color:var(--muted);margin-bottom:8px;">Pseudocode (highlights active phase)</div>
          <pre id="pseudocode" aria-hidden="false" style="height:220px;">
<span class="code-line" data-line="1">function mergeSort(arr, l, r):</span>
<span class="code-line" data-line="2">  if r - l &lt;= 1: return</span>
<span class="code-line" data-line="3">  mid = (l + r) // 2</span>
<span class="code-line" data-line="4">  mergeSort(arr, l, mid)            // split left</span>
<span class="code-line" data-line="5">  mergeSort(arr, mid, r)            // split right</span>
<span class="code-line" data-line="6">  // merge two sorted halves</span>
<span class="code-line" data-line="7">  i = l; j = mid; k = l</span>
<span class="code-line" data-line="8">  while i &lt; mid and j &lt; r:</span>
<span class="code-line" data-line="9">    if arr[i] &lt;= arr[j]: tmp[k++] = arr[i++]   // pick left</span>
<span class="code-line" data-line="10">    else: tmp[k++] = arr[j++]                 // pick right</span>
<span class="code-line" data-line="11">  while i &lt; mid: tmp[k++] = arr[i++]</span>
<span class="code-line" data-line="12">  while j &lt; r: tmp[k++] = arr[j++]</span>
<span class="code-line" data-line="13">  copy tmp[l:r] back to arr[l:r]</span>
          </pre>
        </div>

        <footer>
          Complexity: O(n log n) time, O(n) extra space. Stable sort. Use Merge Sort to reliably sort large data sets in predictable time.
        </footer>
      </div>
    </div>
  </div>

  <script>
    // Merge Sort Visualizer
    (function(){
      const barsContainer = document.getElementById('bars');
      const newBtn = document.getElementById('newBtn');
      const shuffleBtn = document.getElementById('shuffleBtn');
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const stepBtn = document.getElementById('stepBtn');
      const stopBtn = document.getElementById('stopBtn');
      const sizeRange = document.getElementById('sizeRange');
      const speedRange = document.getElementById('speedRange');
      const cmpCountEl = document.getElementById('cmpCount');
      const writeCountEl = document.getElementById('writeCount');
      const arrSizeEl = document.getElementById('arrSize');
      const pseudocode = document.getElementById('pseudocode');

      let array = [];
      let bars = [];
      let actions = []; // recorded actions for animation
      let cmpCount = 0, writeCount = 0;
      let playing = false;
      let paused = false;
      let actionIndex = 0;
      let delay = Number(speedRange.value); // ms between actions
      let currentSize = Number(sizeRange.value);

      // Helper: create random array
      function createArray(n){
        array = [];
        for(let i=0;i<n;i++) array.push(Math.floor(Math.random()*100)+5);
        return array;
      }

      // Render bars
      function renderArray(){
        barsContainer.innerHTML = '';
        bars = [];
        const max = Math.max(...array);
        const n = array.length;
        for(let i=0;i<n;i++){
          const b = document.createElement('div');
          b.className = 'bar';
          b.style.height = (array[i]/max*100) + '%';
          b.dataset.index = i;
          const val = document.createElement('div');
          val.className = 'val';
          val.textContent = array[i];
          b.appendChild(val);
          barsContainer.appendChild(b);
          bars.push(b);
        }
        arrSizeEl.textContent = n;
      }

      // Utilities to mark lines in pseudocode
      function highlightLine(line){
        const lines = pseudocode.querySelectorAll('.code-line');
        lines.forEach(l=>l.classList.toggle('active', Number(l.dataset.line) === line));
      }

      // Record actions by running instrumented merge sort
      function recordMergeSort(arr){
        actions = [];
        cmpCount = 0; writeCount = 0;
        const tmp = new Array(arr.length);
        function ms(l,r){
          if(r - l <= 1){
            actions.push({type:'idleRange', l, r});
            return;
          }
          const mid = Math.floor((l + r)/2);
          actions.push({type:'split', l, mid, r});
          ms(l,mid);
          ms(mid,r);
          actions.push({type:'mergeStart', l, mid, r});
          let i=l, j=mid, k=l;
          while(i<mid && j<r){
            actions.push({type:'compare', i, j});
            if(arr[i] <= arr[j]){
              actions.push({type:'take', from:i, to:k, value:arr[i]});
              tmp[k++] = arr[i++];
            } else {
              actions.push({type:'take', from:j, to:k, value:arr[j]});
              tmp[k++] = arr[j++];
            }
          }
          while(i<mid){
            actions.push({type:'take', from:i, to:k, value:arr[i]});
            tmp[k++] = arr[i++];
          }
          while(j<r){
            actions.push({type:'take', from:j, to:k, value:arr[j]});
            tmp[k++] = arr[j++];
          }
          // copy back
          for(let t=l; t<r; t++){
            actions.push({type:'writeBack', index:t, value:tmp[t]});
            arr[t] = tmp[t];
          }
          actions.push({type:'mergeEnd', l, mid, r});
        }
        // Use a copy to avoid modifying original until animation plays writes back
        ms(0, arr.length);
        // final done
        actions.push({type:'done'});
      }

      // Animation engine
      function resetCounts(){
        cmpCount=0; writeCount=0;
        cmpCountEl.textContent = '0';
        writeCountEl.textContent = '0';
      }

      function enableControls(enabled){
        newBtn.disabled = !enabled;
        shuffleBtn.disabled = !enabled;
        sizeRange.disabled = !enabled;
        startBtn.disabled = !enabled;
      }

      function play(){
        if(playing) return;
        playing = true;
        paused = false;
        pauseBtn.disabled = false;
        stopBtn.disabled = false;
        newBtn.disabled = true;
        shuffleBtn.disabled = true;
        sizeRange.disabled = true;
        startBtn.disabled = true;
        stepBtn.disabled = true;
        runActions();
      }

      function pause(){
        paused = true;
        pauseBtn.disabled = true;
        startBtn.disabled = false;
        stepBtn.disabled = false;
      }
      function resume(){
        if(!playing) play();
        paused = false;
        pauseBtn.disabled = false;
        startBtn.disabled = true;
        stepBtn.disabled = true;
        runActions();
      }

      function stop(){
        playing = false;
        paused = false;
        actionIndex = 0;
        actions = [];
        resetCounts();
        renderArray();
        highlightLine(null);
        pauseBtn.disabled = true;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        newBtn.disabled = false;
        shuffleBtn.disabled = false;
        sizeRange.disabled = false;
        stepBtn.disabled = false;
      }

      function stepOnce(){
        if(actionIndex >= actions.length) return;
        executeAction(actions[actionIndex++]);
      }

      async function runActions(){
        while(playing && actionIndex < actions.length){
          if(paused) break;
          const act = actions[actionIndex++];
          executeAction(act);
          // when 'compare' or similar we might want different delays
          await sleep(delay);
        }
        if(actionIndex >= actions.length){
          playing = false;
          pauseBtn.disabled = true;
          stopBtn.disabled = true;
          startBtn.disabled = true;
          stepBtn.disabled = true;
          highlightLine(13);
        }
      }

      function sleep(ms){
        return new Promise(res => setTimeout(res, ms));
      }

      // Execute and animate a single recorded action
      function executeAction(action){
        clearAllHighlights();
        switch(action.type){
          case 'idleRange':
            highlightRange(action.l, action.r, 'idle');
            highlightLine(2);
            break;
          case 'split':
            highlightRange(action.l, action.mid, 'source');
            highlightRange(action.mid, action.r, 'target');
            highlightLine(4);
            break;
          case 'mergeStart':
            highlightRange(action.l, action.r, 'merging');
            highlightLine(6);
            break;
          case 'compare':
            cmpCount++;
            cmpCountEl.textContent = cmpCount;
            markBar(action.i, 'compare');
            markBar(action.j, 'compare');
            highlightLine(8);
            break;
          case 'take':
            // show source highlighted and target index highlighted
            markBar(action.from, 'source');
            markBar(action.to, 'target');
            // visually move by updating height and text (but don't commit final array until writeBack)
            // We'll reflect immediately to keep animation intuitive
            setBarValue(action.to, action.value);
            writeCount++;
            writeCountEl.textContent = writeCount;
            highlightLine(action.from < action.to ? 9 : 10);
            break;
          case 'writeBack':
            // commit final write (already shown by take step, but ensure correct)
            setBarValue(action.index, action.value);
            markBar(action.index, 'target');
            writeCount++;
            writeCountEl.textContent = writeCount;
            highlightLine(13);
            break;
          case 'mergeEnd':
            // mark merged range as sorted (use source color)
            highlightRange(action.l, action.r, 'merged');
            highlightLine(13);
            break;
          case 'done':
            for(let i=0;i<bars.length;i++){
              markBar(i, 'source');
            }
            highlightLine(13);
            break;
        }
      }

      // Visual helpers
      function setBarValue(idx, val){
        if(!bars[idx]) return;
        const max = Math.max(...array, val);
        array[idx] = val; // keep local array in sync
        bars[idx].style.height = (val / Math.max(...array) * 100) + '%';
        bars[idx].querySelector('.val').textContent = val;
      }

      function markBar(i, cls){
        if(!bars[i]) return;
        bars[i].classList.add(cls === 'compare' ? 'compare' : cls === 'source' ? 'source' : cls === 'target' ? 'target' : '');
      }

      function highlightRange(l, r, kind){
        for(let i=l;i<r;i++){
          if(!bars[i]) continue;
          if(kind === 'source') { bars[i].classList.add('source'); }
          else if(kind === 'target') { bars[i].classList.add('target'); }
          else if(kind === 'merged'){ bars[i].classList.add('source'); }
          else if(kind === 'merging'){ bars[i].classList.add('compare'); }
          else { /* idle */ }
        }
      }

      function clearAllHighlights(){
        bars.forEach(b => { b.classList.remove('compare','source','target'); });
        highlightLine(null);
      }

      // Event wiring
      newBtn.addEventListener('click', ()=>{
        currentSize = Number(sizeRange.value);
        array = createArray(currentSize);
        resetCounts();
        renderArray();
      });

      shuffleBtn.addEventListener('click', ()=>{
        // Fisher-Yates shuffle
        for(let i=array.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        resetCounts();
        renderArray();
      });

      startBtn.addEventListener('click', ()=>{
        // prepare actions
        resetCounts();
        // Use a copy for recording algorithm steps
        const copy = array.slice();
        recordMergeSort(copy);
        actionIndex = 0;
        play();
      });

      pauseBtn.addEventListener('click', ()=>{
        if(!playing) return;
        if(!paused) {
          pause();
        } else {
          resume();
        }
      });

      stepBtn.addEventListener('click', ()=>{
        if(!playing){
          // prepare if first step
          resetCounts();
          const copy = array.slice();
          recordMergeSort(copy);
          playing = true;
          paused = true;
          pauseBtn.disabled = false;
          stopBtn.disabled = false;
        }
        if(actionIndex < actions.length){
          stepOnce();
        }
      });

      stopBtn.addEventListener('click', ()=>{
        stop();
      });

      sizeRange.addEventListener('input', ()=>{
        currentSize = Number(sizeRange.value);
        arrSizeEl.textContent = currentSize;
      });

      speedRange.addEventListener('input', ()=>{
        delay = Number(speedRange.value);
      });

      // initialize
      currentSize = Number(sizeRange.value);
      array = createArray(currentSize);
      renderArray();

      // Accessibility: allow keyboard space to start/stop
      document.addEventListener('keydown', (e)=>{
        if(e.code === 'Space'){
          e.preventDefault();
          if(!playing) startBtn.click();
          else if(!paused) pauseBtn.click();
          else resume();
        }
      });

      // small improvement: when window resized recompute heights for accurate scale
      window.addEventListener('resize', ()=>{
        // re-render heights to reflect max scaling
        const max = Math.max(...array);
        bars.forEach((b, i) => {
          b.style.height = (array[i]/max*100) + '%';
        });
      });
    })();
  </script>
</body>
</html>