<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Breadth-First Search (BFS) Visualization</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --cell-size: 28px;
      --gap: 2px;
      --bg: #111827;
      --panel: #0f1724;
      --accent: #60a5fa;
      --visited: #93c5fd;
      --frontier: #fb923c;
      --wall: #111827;
      --path: #34d399;
      --start: #a78bfa;
      --end: #f472b6;
      --text: #e6edf3;
    }
    body{
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #071129 0%, #041026 100%);
      color: var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app{
      max-width: 1100px;
      margin: 24px auto;
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: 18px;
      padding: 18px;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 10px;
      padding: 14px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }
    .left{
      padding: 18px;
    }
    .controls{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-bottom:12px;
    }
    button, select, input[type="number"], input[type="range"]{
      background: transparent;
      border: 1px solid rgba(255,255,255,0.06);
      color:var(--text);
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
    }
    button.primary{
      background: linear-gradient(90deg, #2563eb, #60a5fa);
      color: white;
      border: none;
      box-shadow: 0 6px 18px rgba(37,99,235,0.16);
    }
    .grid-wrap{
      display:flex;
      gap:12px;
      align-items:flex-start;
    }
    .grid{
      display:grid;
      grid-template-columns: repeat(var(--cols), var(--cell-size));
      grid-auto-rows: var(--cell-size);
      gap: var(--gap);
      background: #041024;
      padding: 12px;
      border-radius: 10px;
    }
    .cell{
      width: var(--cell-size);
      height: var(--cell-size);
      border-radius: 6px;
      background: #07203a;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      color:rgba(255,255,255,0.85);
      user-select:none;
      cursor:pointer;
      transition: background 120ms, transform 80ms;
    }
    .cell.wall{ background: var(--wall); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02); }
    .cell.visited{ background: var(--visited); color:#062c4a; }
    .cell.frontier{ background: var(--frontier); color:#2b0f00; }
    .cell.path{ background: var(--path); color:#052515; }
    .cell.start{ background: var(--start); color:#0b0720; font-weight:700; }
    .cell.end{ background: var(--end); color:#2b0624; font-weight:700; }
    .cell.curr{ outline: 2px solid rgba(255,255,255,0.08); transform: scale(1.05); }
    .legend{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .legend .item{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:13px;
      color:rgba(255,255,255,0.8);
    }
    .swatch{
      width:18px;height:18px;border-radius:4px;border:1px solid rgba(255,255,255,0.04);
    }
    .stats{
      margin-top:12px;
      font-size:13px;
      line-height:1.5;
    }
    .right{
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .section{
      background: rgba(255,255,255,0.02);
      padding:12px;
      border-radius:8px;
      border: 1px solid rgba(255,255,255,0.02);
    }
    label{ display:block; font-size:12px; color:rgba(255,255,255,0.8); margin-bottom:6px; }
    .queue-list{
      max-height:180px; overflow:auto;
      background: rgba(0,0,0,0.15);
      padding:8px; border-radius:6px;
      font-family: monospace;
      font-size:13px;
    }
    .small{
      font-size:12px;
      color:rgba(255,255,255,0.75);
    }
    .footer{
      font-size:12px; color:rgba(255,255,255,0.6); margin-top:8px;
    }
    @media (max-width:980px){
      .app{ grid-template-columns: 1fr; padding:12px; }
      .grid-wrap{ flex-direction:column; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel left">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:10px;">
        <div>
          <h2 style="margin:0 0 3px 0; font-size:18px;">BFS Visualizer</h2>
          <div class="small">Breadth-First Search on a grid (4-neighbors)</div>
        </div>
        <div style="text-align:right;">
          <div class="small">Unweighted shortest path</div>
        </div>
      </div>

      <div class="controls">
        <button id="mode-draw" class="primary">Draw Walls</button>
        <button id="mode-start">Set Start</button>
        <button id="mode-end">Set End</button>
        <button id="clear-walls">Clear Walls</button>
        <button id="randomize">Randomize</button>
        <button id="reset-bfs">Reset BFS</button>
      </div>

      <div class="controls" style="margin-bottom:14px;">
        <button id="run" class="primary">Run</button>
        <button id="step">Step</button>
        <button id="pause">Pause</button>
        <label style="display:flex;align-items:center;gap:8px;">
          Speed
          <input id="speed" type="range" min="50" max="1200" step="10" value="220" />
        </label>
        <label style="display:flex;align-items:center;gap:6px;">
          Rows
          <input id="rows" type="number" min="6" max="40" value="16" style="width:66px;" />
        </label>
        <label style="display:flex;align-items:center;gap:6px;">
          Cols
          <input id="cols" type="number" min="6" max="60" value="28" style="width:66px;" />
        </label>
        <button id="resize">Resize Grid</button>
      </div>

      <div class="grid-wrap">
        <div>
          <div id="grid" class="grid" style="--cols:28;"></div>
          <div class="legend">
            <div class="item"><div class="swatch" style="background:var(--start)"></div> Start</div>
            <div class="item"><div class="swatch" style="background:var(--end)"></div> End</div>
            <div class="item"><div class="swatch" style="background:var(--wall)"></div> Wall</div>
            <div class="item"><div class="swatch" style="background:var(--visited)"></div> Visited</div>
            <div class="item"><div class="swatch" style="background:var(--frontier)"></div> Frontier (Queue)</div>
            <div class="item"><div class="swatch" style="background:var(--path)"></div> Final Path</div>
          </div>
          <div class="stats">
            <div>Mode: <span id="mode-label">Draw Walls</span></div>
            <div>Start: <span id="start-pos"></span> &nbsp; End: <span id="end-pos"></span></div>
            <div>Visited nodes: <span id="visited-count">0</span></div>
            <div>Path length: <span id="path-length">-</span></div>
          </div>
        </div>
      </div>
    </div>

    <div class="panel right">
      <div class="section">
        <h3 style="margin:0 0 8px 0;">Queue (front → back)</h3>
        <div id="queue" class="queue-list">[ empty ]</div>
      </div>

      <div class="section">
        <h3 style="margin:0 0 8px 0;">Instructions</h3>
        <div class="small">
          - Click cells to toggle walls in "Draw Walls" mode.<br>
          - Click "Set Start" or "Set End" then click a cell to place them.<br>
          - Run will animate BFS; Step advances one state.<br>
          - Pause to stop the animation; Reset BFS clears visited and path but keeps walls.<br>
          - Resize changes the grid size (resets everything).
        </div>
      </div>

      <div class="section">
        <h3 style="margin:0 0 8px 0;">Controls Help</h3>
        <div class="small">BFS explores neighbors level-by-level, guaranteeing the shortest path on an unweighted grid. The frontier shows the queue contents; visited are marked as explored. Once the end is found, the shortest path is reconstructed using parent pointers.</div>
      </div>

      <div class="footer">Made for demonstration • Click cells to interact</div>
    </div>
  </div>

<script>
(() => {
  // Config & state
  let rows = parseInt(document.getElementById('rows').value,10) || 16;
  let cols = parseInt(document.getElementById('cols').value,10) || 28;
  const gridEl = document.getElementById('grid');
  const modeLabel = document.getElementById('mode-label');
  const startPosEl = document.getElementById('start-pos');
  const endPosEl = document.getElementById('end-pos');
  const visitedCountEl = document.getElementById('visited-count');
  const pathLengthEl = document.getElementById('path-length');
  const queueEl = document.getElementById('queue');
  const speedEl = document.getElementById('speed');

  let mode = 'draw'; // draw | start | end
  let isRunning = false;
  let animationTimer = null;
  let animDelay = Number(speedEl.value);

  // Grid data: array of cells row-major
  let cells = [];
  let start = {r:0,c:0};
  let end = {r: rows-1, c: cols-1};

  // BFS state
  let bfsGenerator = null;
  let currentQueue = [];
  let visitedCount = 0;
  let found = false;

  // Initialize
  function createGrid(r, c){
    rows = r; cols = c;
    gridEl.style.setProperty('--cols', cols);
    gridEl.innerHTML = '';
    cells = new Array(rows*cols);
    for(let i=0;i<rows;i++){
      for(let j=0;j<cols;j++){
        const idx = i*cols + j;
        const el = document.createElement('div');
        el.className = 'cell';
        el.dataset.r = i;
        el.dataset.c = j;
        el.title = `(${i},${j})`;
        el.addEventListener('click', onCellClick);
        el.addEventListener('mousedown', onCellDown);
        cells[idx] = {
          r:i, c:j, el,
          wall:false, visited:false, inQueue:false, parent:null, dist: Infinity
        };
        gridEl.appendChild(el);
      }
    }
    // default start end
    start = {r:0,c:0};
    end = {r: rows-1, c: cols-1};
    resetBFSState(true);
    render();
  }

  function idx(r,c){ return r*cols + c; }

  function onCellClick(e){
    const r = Number(this.dataset.r), c = Number(this.dataset.c);
    const cell = cells[idx(r,c)];
    if(mode === 'draw'){
      // toggle wall but don't allow start/end to be wall
      if((r===start.r && c===start.c) || (r===end.r && c===end.c)) return;
      cell.wall = !cell.wall;
      renderCell(cell);
    } else if(mode === 'start'){
      // move start (can't place on wall or on end)
      if(cell.wall) return;
      if(r===end.r && c===end.c) return;
      start = {r,c};
      resetBFSState(true);
      render();
    } else if(mode === 'end'){
      if(cell.wall) return;
      if(r===start.r && c===start.c) return;
      end = {r,c};
      resetBFSState(true);
      render();
    }
  }

  let mouseDown = false;
  function onCellDown(e){
    // support drag drawing walls
    mouseDown = true;
    function moveHandler(ev){
      ev.preventDefault();
      const el = document.elementFromPoint(ev.clientX, ev.clientY);
      if(!el || !el.classList || !el.classList.contains('cell')) return;
      const r = Number(el.dataset.r), c = Number(el.dataset.c);
      const cell = cells[idx(r,c)];
      if(mode !== 'draw') return;
      if((r===start.r && c===start.c) || (r===end.r && c===end.c)) return;
      cell.wall = true;
      renderCell(cell);
    }
    function upHandler(){ mouseDown=false; window.removeEventListener('mousemove', moveHandler); window.removeEventListener('mouseup', upHandler); }
    window.addEventListener('mousemove', moveHandler);
    window.addEventListener('mouseup', upHandler);
  }

  document.body.addEventListener('mouseup', ()=>mouseDown=false);

  // Controls
  document.getElementById('mode-draw').addEventListener('click', ()=>{
    mode = 'draw'; updateModeUI();
  });
  document.getElementById('mode-start').addEventListener('click', ()=>{
    mode = 'start'; updateModeUI();
  });
  document.getElementById('mode-end').addEventListener('click', ()=>{
    mode = 'end'; updateModeUI();
  });
  document.getElementById('clear-walls').addEventListener('click', ()=>{
    for(const cell of cells){ cell.wall = false; }
    resetBFSState(true);
    render();
  });
  document.getElementById('randomize').addEventListener('click', ()=>{
    for(const cell of cells){
      cell.wall = (Math.random() < 0.26);
    }
    // ensure start/end not wall
    cells[idx(start.r,start.c)].wall = false;
    cells[idx(end.r,end.c)].wall = false;
    resetBFSState(true);
    render();
  });
  document.getElementById('reset-bfs').addEventListener('click', ()=>{
    resetBFSState(false);
    render();
  });
  document.getElementById('run').addEventListener('click', ()=>{
    if(isRunning) return;
    if(!bfsGenerator) bfsGenerator = bfs();
    isRunning = true;
    animDelay = Number(speedEl.value);
    runAnimation();
  });
  document.getElementById('pause').addEventListener('click', ()=>{
    stopAnimation();
  });
  document.getElementById('step').addEventListener('click', ()=>{
    if(!bfsGenerator) bfsGenerator = bfs();
    stepOnce();
  });
  speedEl.addEventListener('input', ()=>{ animDelay = Number(speedEl.value); });
  document.getElementById('resize').addEventListener('click', ()=>{
    const r = Math.max(6, Math.min(40, parseInt(document.getElementById('rows').value,10) || 16));
    const c = Math.max(6, Math.min(60, parseInt(document.getElementById('cols').value,10) || 28));
    createGrid(r,c);
  });

  function updateModeUI(){
    modeLabel.textContent = mode === 'draw' ? 'Draw Walls' : mode === 'start' ? 'Set Start' : 'Set End';
    // highlight button
    document.getElementById('mode-draw').classList.toggle('primary', mode==='draw');
    document.getElementById('mode-start').classList.toggle('primary', mode==='start');
    document.getElementById('mode-end').classList.toggle('primary', mode==='end');
  }

  // Rendering
  function render(){
    for(const cell of cells) renderCell(cell);
    updateInfo();
  }
  function renderCell(cell){
    const el = cell.el;
    el.className = 'cell';
    if(cell.wall) el.classList.add('wall');
    if(cell.visited) el.classList.add('visited');
    if(cell.inQueue) el.classList.add('frontier');
    if(cell.isPath) el.classList.add('path');
    if(cell.r === start.r && cell.c === start.c) el.classList.add('start');
    if(cell.r === end.r && cell.c === end.c) el.classList.add('end');
    if(cell.curr) el.classList.add('curr');
    // show distance optionally: display small number if visited and not start/end/path
    if(cell.dist !== Infinity && (cell.visited || cell.isPath) && !(cell.r===start.r && cell.c===start.c) && !(cell.r===end.r && cell.c===end.c)){
      el.textContent = cell.dist;
    } else {
      el.textContent = '';
    }
  }
  function updateInfo(){
    startPosEl.textContent = `(${start.r},${start.c})`;
    endPosEl.textContent = `(${end.r},${end.c})`;
    visitedCountEl.textContent = visitedCount;
    pathLengthEl.textContent = found ? calculatePathLength() : '-';
    renderQueue();
  }
  function renderQueue(){
    if(currentQueue.length === 0){
      queueEl.textContent = '[ empty ]';
    } else {
      queueEl.innerHTML = currentQueue.map(n=>`(${n.r},${n.c})`).join(' ← ');
    }
  }

  // BFS generator for step-by-step
  function* bfs(){
    // reset properties but keep walls and start/end
    for(const c of cells){
      c.visited = false; c.inQueue = false; c.parent = null; c.dist = Infinity;
      c.isPath = false; c.curr = false;
    }
    visitedCount = 0;
    found = false;
    currentQueue = [];
    // If start or end on wall -> abort
    if(cells[idx(start.r,start.c)].wall || cells[idx(end.r,end.c)].wall){
      updateInfo();
      return;
    }
    // init
    const sIdx = idx(start.r,start.c);
    cells[sIdx].visited = true;
    cells[sIdx].dist = 0;
    currentQueue.push({r:start.r,c:start.c});
    cells[sIdx].inQueue = true;
    yield; // initial state

    while(currentQueue.length){
      // pop front
      const cur = currentQueue.shift();
      const curCell = cells[idx(cur.r,cur.c)];
      curCell.inQueue = false;
      // mark as current
      curCell.curr = true;
      yield;
      // check goal
      if(cur.r === end.r && cur.c === end.c){
        found = true;
        // reconstruct path
        let p = curCell;
        while(p){
          p.isPath = true;
          p = p.parent ? cells[idx(p.parent.r,p.parent.c)] : null;
        }
        curCell.curr = false;
        yield;
        return;
      }
      // explore neighbors (4 directions)
      const deltas = [[-1,0],[1,0],[0,-1],[0,1]];
      for(const d of deltas){
        const nr = cur.r + d[0], nc = cur.c + d[1];
        if(nr<0 || nr>=rows || nc<0 || nc>=cols) continue;
        const nb = cells[idx(nr,nc)];
        if(nb.wall || nb.visited) continue;
        nb.visited = true;
        nb.parent = {r:cur.r,c:cur.c};
        nb.dist = curCell.dist + 1;
        nb.inQueue = true;
        visitedCount++;
        currentQueue.push({r:nr,c:nc});
        yield;
      }
      curCell.curr = false;
      yield;
    }
    // finished with no path
    yield;
  }

  function stepOnce(){
    if(!bfsGenerator) bfsGenerator = bfs();
    const res = bfsGenerator.next();
    render();
    if(res.done){
      bfsGenerator = null;
      stopAnimation();
    }
  }

  function runAnimation(){
    if(!bfsGenerator) bfsGenerator = bfs();
    function tick(){
      const res = bfsGenerator.next();
      render();
      if(res.done){
        bfsGenerator = null;
        stopAnimation();
        return;
      }
      animationTimer = setTimeout(()=>{ if(isRunning) requestAnimationFrame(tick); }, animDelay);
    }
    isRunning = true;
    requestAnimationFrame(tick);
  }

  function stopAnimation(){
    isRunning = false;
    if(animationTimer) { clearTimeout(animationTimer); animationTimer = null; }
  }

  function resetBFSState(fullReset){
    stopAnimation();
    bfsGenerator = null;
    currentQueue = [];
    visitedCount = 0;
    found = false;
    for(const c of cells){
      c.visited = false; c.inQueue = false; c.parent = null; c.dist = Infinity;
      c.isPath = false; c.curr = false;
      if(fullReset){
        c.wall = c.wall || false; // keep as-is, but fullReset may also be used when resizing; in resize we recreate grid
      }
    }
    updateInfo();
  }

  function calculatePathLength(){
    // count cells with isPath true minus 1
    const pathCells = cells.filter(c=>c.isPath).length;
    return Math.max(0, pathCells-1);
  }

  // initial grid
  createGrid(rows, cols);
  updateModeUI();

  // Helpful: allow keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key === ' ') { // space to step
      e.preventDefault();
      document.getElementById('step').click();
    } else if(e.key === 'r'){ document.getElementById('run').click();}
    else if(e.key === 'p'){ document.getElementById('pause').click();}
    else if(e.key === '1'){ document.getElementById('mode-draw').click();}
    else if(e.key === '2'){ document.getElementById('mode-start').click();}
    else if(e.key === '3'){ document.getElementById('mode-end').click();}
  });

  // Small convenience: ensure start/end labels show on create
  render();
})();
</script>
</body>
</html>