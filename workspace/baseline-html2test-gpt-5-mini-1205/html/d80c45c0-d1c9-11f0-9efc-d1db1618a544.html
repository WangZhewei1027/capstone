<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Recursion Explorer — Interactive Demos</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --muted:#9aa4b2; --accent:#7dd3fc;
      --panel:#071023; --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    body{
      background: linear-gradient(180deg,#071023 0%, #071022 50%, #041024 100%);
      color:#e6eef6; padding:18px; box-sizing:border-box;
    }
    header{display:flex;gap:18px;align-items:center;margin-bottom:18px;}
    h1{font-size:20px;margin:0;}
    p.lead{margin:0;color:var(--muted);font-size:13px;}
    .container{display:grid;grid-template-columns:360px 1fr 420px;gap:18px;align-items:start;}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:10px;padding:14px;box-shadow: 0 6px 18px rgba(2,6,23,0.6);}
    .controls .row{display:flex;gap:8px;align-items:center;margin-bottom:8px;}
    label{font-size:13px;color:var(--muted);min-width:80px;}
    select,input[type=number]{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:6px;color:inherit;}
    button{background:linear-gradient(180deg,#1f6feb,#0d5acc);border:none;color:white;padding:8px 12px;border-radius:8px;cursor:pointer;}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);}
    .small{font-size:13px;padding:6px 8px;border-radius:6px;}
    .stack{max-height:420px;overflow:auto;padding:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:8px;border:1px solid rgba(255,255,255,0.02);}
    ul.stack-list{list-style:none;padding:6px;margin:0;}
    ul.stack-list li{padding:8px;border-radius:8px;margin-bottom:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);display:flex;justify-content:space-between;align-items:center;border:1px solid rgba(255,255,255,0.02);}
    ul.stack-list li .meta{color:var(--muted);font-size:12px}
    pre.code{background:#041526;color:#cdebf8;padding:10px;border-radius:8px;overflow:auto;font-size:13px;margin:0;border:1px solid rgba(125,211,252,0.06);}
    .visual{height:520px;display:flex;flex-direction:column;gap:12px;}
    #canvasWrap{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:10px;padding:10px;display:flex;align-items:stretch;justify-content:stretch;overflow:auto;}
    canvas{width:100%;height:100%;border-radius:8px;background:linear-gradient(180deg, rgba(7,16,35,0.8), rgba(2,6,23,0.9));display:block;}
    .footer{font-size:12px;color:var(--muted);margin-top:8px;}
    .status-row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;}
    .badge{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;font-size:13px;border:1px solid rgba(255,255,255,0.02);}
    .tree{overflow:auto;padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border:1px solid rgba(255,255,255,0.02);max-height:520px;}
    .node{display:inline-block;padding:6px 8px;margin:6px;border-radius:8px;background:#062234;border:1px solid rgba(125,211,252,0.06);font-size:13px}
    .tree ul{list-style:none;padding-left:18px;margin:6px 0;}
    .controls .hint{color:var(--muted);font-size:12px}
    .top-row{display:flex;gap:8px;align-items:center;margin-bottom:12px;}
    .speed{width:160px;}
    .footer small{color:var(--muted)}
    .code-title{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Recursion Explorer</h1>
      <p class="lead">Interactive demonstrations of recursion: call stack visualization, Fibonacci recursion tree (with memoization option), and a recursive fractal tree.</p>
    </div>
  </header>

  <div class="container">
    <!-- Left: Controls and Stack -->
    <div class="panel controls">
      <div class="top-row">
        <label for="demoSelect">Demo</label>
        <select id="demoSelect">
          <option value="factorial">Factorial (call stack)</option>
          <option value="fibonacci">Fibonacci (recursion tree)</option>
          <option value="fractal">Fractal Tree (canvas)</option>
        </select>
      </div>

      <div class="row">
        <label id="paramLabel">n</label>
        <input id="inputN" type="number" value="6" min="0" max="12" />
        <div style="flex:1"></div>
      </div>

      <div class="row" id="memoRow" style="display:none;">
        <label>Memoize</label>
        <input id="memoCheckbox" type="checkbox" />
        <span class="hint" style="margin-left:8px;color:var(--muted)">Turn on for Fibonacci to avoid repeated calls</span>
      </div>

      <div class="row">
        <label>Mode</label>
        <select id="modeSelect">
          <option value="auto">Auto (animate)</option>
          <option value="step">Step-by-step</option>
        </select>
        <label style="margin-left:8px">Speed</label>
        <input id="speedRange" class="speed" type="range" min="50" max="1200" value="250" />
      </div>

      <div class="row" style="margin-top:6px;">
        <button id="runBtn">Run</button>
        <button id="stepBtn" class="small ghost">Step</button>
        <button id="resetBtn" class="small ghost">Reset</button>
        <div style="flex:1"></div>
      </div>

      <div class="row" style="margin-top:6px;">
        <label>Events</label>
        <div class="status-row">
          <div class="badge" id="callCount">Calls: 0</div>
          <div class="badge" id="maxDepth">Max depth: 0</div>
          <div class="badge" id="resultBadge">Result: —</div>
        </div>
      </div>

      <hr style="border:none;height:1px;background:rgba(255,255,255,0.02);margin:12px 0">

      <div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <strong>Call Stack</strong>
          <span class="hint">push = function call started, pop = returned</span>
        </div>
        <div class="stack">
          <ul id="stackList" class="stack-list"></ul>
        </div>
      </div>

      <div class="footer" style="margin-top:12px">
        <small>Tip: Try small n for Fibonacci (<=7) to see the full tree. Use memoization to compare performance.</small>
      </div>
    </div>

    <!-- Middle: Visual / Code -->
    <div class="panel visual" id="visualPanel">
      <div class="code-title">
        <strong id="demoTitle">Factorial (call stack)</strong>
        <span class="hint" id="demoHint">Shows how recursive calls are pushed and popped on the call stack.</span>
      </div>

      <div style="display:flex;gap:12px;">
        <div style="flex:1">
          <pre class="code" id="codeBlock">
// Recursive factorial (instrumented for visualization)
async function factorial(n) {
  pushFrame('factorial', {n});
  if (n <= 1) {
    popFrame(1);
    return 1;
  }
  const sub = await factorial(n - 1); // recursive call
  const res = n * sub;
  popFrame(res);
  return res;
}
          </pre>
        </div>
        <div style="width:220px;">
          <div style="margin-bottom:8px"><strong>Live stack preview</strong></div>
          <div id="miniStack" class="stack" style="max-height:200px">
            <ul id="miniList" class="stack-list"></ul>
          </div>
        </div>
      </div>

      <div id="canvasWrap" style="margin-top:12px;">
        <!-- Canvas or tree area will be inserted here by JS -->
        <canvas id="mainCanvas"></canvas>
        <div id="treeArea" class="tree" style="display:none;"></div>
      </div>

    </div>

    <!-- Right: Explanation & Fibonacci / Fractal controls -->
    <div class="panel" id="rightPanel">
      <div id="explain">
        <h3 style="margin-top:0">What's happening?</h3>
        <p class="lead" style="font-size:13px;color:var(--muted)">
          Recursion is when a function calls itself to solve smaller instances of the same problem.
          Each active call becomes a "frame" on the call stack. When a call finishes, it returns and its frame is popped.
        </p>

        <h4>Demo notes</h4>
        <ul style="color:var(--muted);font-size:13px">
          <li><strong>Factorial:</strong> linear recursion with depth equal to n.</li>
          <li><strong>Fibonacci:</strong> naive recursion creates a tree of calls — many repeated subcalls.</li>
          <li><strong>Memoization:</strong> caches results to avoid repeated work.</li>
          <li><strong>Fractal tree:</strong> recursion used for drawing branching structures — each branch spawns two smaller branches.</li>
        </ul>

        <h4 style="margin-top:12px">Try these</h4>
        <ul style="color:var(--muted);font-size:13px">
          <li>Switch to step mode and step through factorial to watch the stack grow and shrink.</li>
          <li>Observe call count changes for Fibonacci with/without memoization.</li>
          <li>Draw a fractal tree and increase depth to see recursion depth effect.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    // ---- Utilities & Scheduler ----
    const qs = sel => document.querySelector(sel);
    const el = id => document.getElementById(id);

    const state = {
      calls:0, maxDepth:0, stack:[], framesById:{}, running:false,
      config:{mode:'auto', speed:250, memo:false}
    };

    class Scheduler {
      constructor(){
        this._resolveNext = null;
        this.auto = true;
        this.delay = 250;
      }
      setMode(mode){
        this.auto = (mode === 'auto');
      }
      setDelay(ms){ this.delay = ms; }
      nextStep(){
        if(this._resolveNext) { this._resolveNext(); this._resolveNext = null; }
      }
      async wait(){
        if(this.auto) {
          await new Promise(r => setTimeout(r, this.delay));
          return;
        }
        await new Promise(r => this._resolveNext = r);
      }
    }
    const scheduler = new Scheduler();

    // ---- DOM helpers for stack visualization ----
    const stackList = el('stackList');
    const miniList = el('miniList');
    const callCountBadge = el('callCount');
    const maxDepthBadge = el('maxDepth');
    const resultBadge = el('resultBadge');
    const demoTitle = el('demoTitle');
    const demoHint = el('demoHint');
    const codeBlock = el('codeBlock');
    const treeArea = el('treeArea');
    const canvas = el('mainCanvas');

    function pushFrameToDOM(frame){
      const li = document.createElement('li');
      li.id = frame.id;
      li.innerHTML = `<div><strong>${frame.fn}</strong>(${formatArgs(frame.args)})<div class="meta">status: running</div></div><div class="meta">depth ${frame.depth}</div>`;
      stackList.prepend(li);

      const mini = li.cloneNode(true);
      mini.id = frame.id + '_mini';
      miniList.prepend(mini);
    }
    function popFrameInDOM(frame){
      const li = document.getElementById(frame.id);
      if(li){
        const meta = li.querySelector('.meta');
        if(meta) meta.textContent = 'returned: ' + JSON.stringify(frame.ret);
        li.style.opacity = '0.65';
      }
      const mini = document.getElementById(frame.id + '_mini');
      if(mini){
        const m = mini.querySelector('.meta');
        if(m) m.textContent = 'returned: ' + JSON.stringify(frame.ret);
        mini.style.opacity = '0.65';
      }
      // remove after a short delay so user can observe
      setTimeout(()=>{
        if(li && li.parentNode) li.parentNode.removeChild(li);
        if(mini && mini.parentNode) mini.parentNode.removeChild(mini);
      }, 600);
    }
    function formatArgs(obj){
      if(obj && 'n' in obj) return obj.n;
      return JSON.stringify(obj);
    }

    // ---- Instrumentation primitives ----
    let frameCounter = 0;
    function pushFrame(fn, args){
      const id = 'f' + (++frameCounter);
      const depth = state.stack.length + 1;
      const frame = {id, fn, args, ret:undefined, depth};
      state.stack.push(frame);
      state.calls++;
      state.maxDepth = Math.max(state.maxDepth, depth);
      state.framesById[id] = frame;
      pushFrameToDOM(frame);
      updateBadges();
      return frame;
    }

    function popFrame(ret){
      const frame = state.stack.pop();
      if(!frame) return;
      frame.ret = ret;
      popFrameInDOM(frame);
      updateBadges();
      return frame;
    }

    function updateBadges(){
      callCountBadge.textContent = 'Calls: ' + state.calls;
      maxDepthBadge.textContent = 'Max depth: ' + state.maxDepth;
      if(state.lastResult !== undefined) resultBadge.textContent = 'Result: ' + state.lastResult;
    }

    function resetState(){
      state.calls = 0; state.maxDepth = 0; state.stack = []; state.framesById = {}; state.lastResult = undefined;
      frameCounter = 0; state.running = false;
      stackList.innerHTML = ''; miniList.innerHTML = '';
      callCountBadge.textContent = 'Calls: 0'; maxDepthBadge.textContent = 'Max depth: 0'; resultBadge.textContent = 'Result: —';
    }

    // ---- Recursive Demos (async to allow stepping) ----
    async function factorialDemo(n){
      // instrumented factorial
      async function factorial(n){
        const frame = pushFrame('factorial', {n});
        await scheduler.wait();
        if(n <= 1){
          popFrame(1);
          await scheduler.wait();
          return 1;
        }
        const sub = await factorial(n - 1);
        const res = n * sub;
        popFrame(res);
        await scheduler.wait();
        return res;
      }
      const res = await factorial(n);
      state.lastResult = res;
      updateBadges();
      return res;
    }

    // Fibonacci with optional memoization + visual tree (DOM)
    async function fibonacciDemo(n, memoize){
      // for the tree visualization we'll build a nested DOM structure,
      // and also instrument calls for stack.
      treeArea.innerHTML = '';
      treeArea.style.display = 'block';
      canvas.style.display = 'none';

      const memo = new Map();
      let nodeId = 0;

      async function fibNode(n, parentEl){
        const nodeEl = document.createElement('div');
        nodeEl.className = 'node';
        const nid = 'node' + (++nodeId);
        nodeEl.id = nid;
        nodeEl.textContent = `fib(${n}) …`;
        const wrapper = document.createElement('div');
        wrapper.appendChild(nodeEl);
        const childrenUl = document.createElement('ul');
        wrapper.appendChild(childrenUl);
        if(parentEl) parentEl.appendChild(wrapper);
        // push frame
        const frame = pushFrame('fib', {n});
        await scheduler.wait();

        if(memoize && memo.has(n)){
          const val = memo.get(n);
          nodeEl.textContent = `fib(${n}) = ${val} (cached)`;
          popFrame(val);
          await scheduler.wait();
          return val;
        }

        if(n <= 1){
          nodeEl.textContent = `fib(${n}) = ${n}`;
          popFrame(n);
          await scheduler.wait();
          if(memoize) memo.set(n, n);
          return n;
        }

        // recursive left
        const leftLi = document.createElement('li');
        childrenUl.appendChild(leftLi);
        const a = await fibNode(n-1, leftLi);

        // recursive right
        const rightLi = document.createElement('li');
        childrenUl.appendChild(rightLi);
        const b = await fibNode(n-2, rightLi);

        const res = a + b;
        nodeEl.textContent = `fib(${n}) = ${res}`;
        if(memoize) memo.set(n, res);
        popFrame(res);
        await scheduler.wait();
        return res;
      }

      const rootUl = document.createElement('ul');
      treeArea.appendChild(rootUl);
      const rootLi = document.createElement('li');
      rootUl.appendChild(rootLi);

      const result = await fibNode(n, rootLi);
      state.lastResult = result;
      updateBadges();
      return result;
    }

    // Fractal tree drawing (non-instrumented recursion, uses canvas)
    function drawFractalTree(depth){
      treeArea.style.display = 'none';
      canvas.style.display = 'block';
      const c = canvas;
      // ensure correct pixel size
      const rect = c.getBoundingClientRect();
      c.width = Math.floor(rect.width * devicePixelRatio);
      c.height = Math.floor(rect.height * devicePixelRatio);
      const ctx = c.getContext('2d');
      ctx.scale(devicePixelRatio, devicePixelRatio);
      ctx.clearRect(0,0,rect.width,rect.height);
      ctx.strokeStyle = '#7dd3fc';
      ctx.lineWidth = 1.5;
      const startX = rect.width / 2;
      const startY = rect.height - 20;

      function branch(x,y,len,angle,depthLeft){
        ctx.save();
        ctx.translate(x,y);
        ctx.rotate(angle);
        // draw line up
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(0,-len);
        ctx.stroke();
        ctx.translate(0,-len);

        if(depthLeft <= 0){
          // tip
          ctx.restore();
          return;
        }
        const newLen = len * (0.66 - depthLeft*0.004);
        const spread = 0.5; // radians
        branch(0,0,newLen, -spread, depthLeft - 1);
        branch(0,0,newLen, spread, depthLeft - 1);
        ctx.restore();
      }

      branch(startX, startY, Math.max(40, rect.height/6), 0, depth);
    }

    // ---- UI wiring ----
    const demoSelect = el('demoSelect');
    const inputN = el('inputN');
    const runBtn = el('runBtn');
    const stepBtn = el('stepBtn');
    const resetBtn = el('resetBtn');
    const modeSelect = el('modeSelect');
    const speedRange = el('speedRange');
    const memoCheckbox = el('memoCheckbox');
    const memoRow = el('memoRow');

    function updateUIForDemo(){
      const demo = demoSelect.value;
      resetState();
      treeArea.style.display = 'none';
      canvas.style.display = 'block';
      canvas.getContext('2d').clearRect(0,0,canvas.width,canvas.height);

      if(demo === 'factorial'){
        demoTitle.textContent = 'Factorial (call stack)';
        demoHint.textContent = 'Shows how recursive calls are pushed to the stack and popped when returning.';
        codeBlock.textContent = `// Recursive factorial (instrumented)
async function factorial(n){
  pushFrame('factorial',{n});
  await scheduler.wait();
  if(n <= 1){
    popFrame(1);
    await scheduler.wait();
    return 1;
  }
  const sub = await factorial(n-1);
  const res = n * sub;
  popFrame(res);
  await scheduler.wait();
  return res;
}`;
        inputN.min = 0; inputN.max = 50; inputN.value = 8;
        memoRow.style.display = 'none';
        canvas.style.display = 'none';
        treeArea.style.display = 'none';
      } else if(demo === 'fibonacci'){
        demoTitle.textContent = 'Fibonacci (recursion tree)';
        demoHint.textContent = 'Builds a tree of recursive calls. Watch how many repeated calls occur without memoization.';
        codeBlock.textContent = `// Naive Fibonacci (instrumented)
async function fib(n){
  pushFrame('fib',{n});
  await scheduler.wait();
  if(n <= 1){
    popFrame(n);
    await scheduler.wait();
    return n;
  }
  const a = await fib(n-1);
  const b = await fib(n-2);
  const r = a + b;
  popFrame(r);
  await scheduler.wait();
  return r;
}`;
        inputN.min = 0; inputN.max = 12; inputN.value = 6;
        memoRow.style.display = 'block';
        canvas.style.display = 'none';
        treeArea.style.display = 'block';
      } else if(demo === 'fractal'){
        demoTitle.textContent = 'Fractal Tree (drawing recursion)';
        demoHint.textContent = 'Each branch recursively draws two smaller branches.';
        codeBlock.textContent = `// Recursively draw branching tree (non-async)
function drawBranch(x,y,len,angle,depth){
  // draw line then two smaller branches until depth==0
}`;
        inputN.min = 1; inputN.max = 12; inputN.value = 8;
        memoRow.style.display = 'none';
        treeArea.style.display = 'none';
        canvas.style.display = 'block';
      }
    }

    demoSelect.addEventListener('change', updateUIForDemo);
    modeSelect.addEventListener('change', (e)=>{
      state.config.mode = e.target.value;
      scheduler.setMode(e.target.value);
      stepBtn.disabled = (e.target.value !== 'step');
    });
    speedRange.addEventListener('input', ()=>{ state.config.speed = parseInt(speedRange.value,10); scheduler.setDelay(state.config.speed); });

    stepBtn.addEventListener('click', ()=>{
      // allow next step in scheduler
      scheduler.nextStep();
    });

    resetBtn.addEventListener('click', ()=>{
      resetState();
    });

    runBtn.addEventListener('click', async ()=>{
      if(state.running) return;
      resetState();
      state.running = true;
      scheduler.setMode(modeSelect.value);
      scheduler.setDelay(parseInt(speedRange.value,10));
      const demo = demoSelect.value;
      const n = Math.max(0, Math.min(50, parseInt(inputN.value || 0,10)));
      try {
        if(demo === 'factorial'){
          treeArea.style.display = 'none';
          canvas.style.display = 'none';
          // run factorial demo
          const res = await factorialDemo(n);
          state.lastResult = res;
          updateBadges();
        } else if(demo === 'fibonacci'){
          const memoize = memoCheckbox.checked;
          // run fibonacci demo
          const res = await fibonacciDemo(n, memoize);
          state.lastResult = res;
          updateBadges();
        } else if(demo === 'fractal'){
          // draw fractal tree (non-async)
          treeArea.style.display = 'none';
          canvas.style.display = 'block';
          drawFractalTree(n);
          // set result to depth for display
          state.lastResult = 'drawn (depth ' + n + ')';
          updateBadges();
        }
      } catch (err){
        console.error(err);
      } finally {
        state.running = false;
      }
    });

    // initialize
    (function init(){
      updateUIForDemo();
      scheduler.setMode(modeSelect.value);
      scheduler.setDelay(parseInt(speedRange.value,10));
      stepBtn.disabled = (modeSelect.value !== 'step');
      // resize canvas on window resize
      function fitCanvas(){
        if(canvas.style.display === 'none') return;
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.floor(rect.width * devicePixelRatio);
        canvas.height = Math.floor(rect.height * devicePixelRatio);
      }
      window.addEventListener('resize', fitCanvas);
      fitCanvas();
    })();

    // Prevent accidental large runs for naive Fibonacci: cap input if memo off
    inputN.addEventListener('input', ()=>{
      if(demoSelect.value === 'fibonacci' && !memoCheckbox.checked){
        const v = parseInt(inputN.value||0,10);
        if(v > 9){ inputN.value = 9; } // naive fib >9 grows quickly in calls
      }
    });

    // Toggle memoization hint
    memoCheckbox.addEventListener('change', ()=>{
      if(!memoCheckbox.checked){
        // warn if n too large (>9)
        if(parseInt(inputN.value||0,10) > 9) inputN.value = 9;
      }
    });

    // small helper: allow pressing space to step in step mode
    window.addEventListener('keydown', (e)=>{
      if(e.code === 'Space' && modeSelect.value === 'step'){
        e.preventDefault();
        scheduler.nextStep();
      }
    });

  </script>
</body>
</html>