<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Binary Tree Visualizer (BST)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#4f46e5;
      --muted:#94a3b8;
      --node:#e6eef8;
      --node-fill:#0b2140;
      --good:#16a34a;
      --bad:#ef4444;
      --highlight:#f59e0b;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{background:linear-gradient(180deg,#071025 0%, #0b1220 100%); color:var(--node); display:flex; flex-direction:column; align-items:center;}
    .container{width:100%; max-width:1100px; padding:18px; box-sizing:border-box;}
    header{display:flex; align-items:center; gap:16px; margin-bottom:12px;}
    h1{font-size:20px; margin:0; color:var(--node);}
    .controls{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .panel{background:linear-gradient(180deg,#071426 0%, #081426 100%); padding:12px; border-radius:10px; box-shadow: 0 6px 18px rgba(2,6,23,0.6); color:var(--node); display:flex; gap:12px; align-items:center;}
    input[type="number"], input[type="text"]{background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--node); padding:8px 10px; border-radius:8px; width:100px;}
    button{background:linear-gradient(180deg,var(--accent),#3b82f6); border:none; color:white; padding:8px 12px; border-radius:8px; cursor:pointer;}
    button.secondary{background:transparent; border:1px solid rgba(255,255,255,0.06);}
    button.warn{background:linear-gradient(180deg,#ef4444,#c026d3);}
    .small{padding:6px 10px; font-size:13px;}
    .svg-wrap{background:linear-gradient(180deg,#071426AA,#081426AA); border-radius:12px; padding:12px; margin-top:12px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); }
    #canvas{width:100%; height:520px; background:transparent;}
    .info{margin-top:10px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
    .stat{background:rgba(255,255,255,0.02); padding:8px 10px; border-radius:10px; color:var(--muted); font-size:13px;}
    .legend{display:flex; gap:8px; align-items:center;}
    .swatch{width:12px;height:12px;border-radius:3px; display:inline-block;}
    .note{font-size:13px; color:var(--muted); max-width:720px; line-height:1.4; margin-top:8px;}
    .node-label{font-weight:600; font-size:12px; fill:var(--node);}
    .btn-row{display:flex; gap:6px; flex-wrap:wrap;}
    footer{margin-top:18px; color:var(--muted); font-size:13px;}
    @media (max-width:720px){ header{flex-direction:column; align-items:flex-start} .panel{flex-wrap:wrap}}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Binary Tree Visualizer (Binary Search Tree)</h1>
        <div class="note">This demo builds a Binary Search Tree (BST). Insert unique numbers to create the tree. Use the controls to insert, delete, search, generate random trees, and play step-by-step traversals (inorder, preorder, postorder, level-order). Click nodes to inspect.</div>
      </div>
      <div style="margin-left:auto"></div>
    </header>

    <div class="panel controls" style="justify-content:space-between;">
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <input id="valueInput" type="number" placeholder="Value" />
        <button id="insertBtn">Insert</button>
        <button class="secondary" id="deleteBtn">Delete</button>
        <button class="secondary" id="searchBtn">Search</button>
        <button id="clearBtn" class="small">Clear</button>
        <button id="randomBtn" class="small">Random Tree</button>
      </div>

      <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <div class="btn-row">
          <button id="inorderBtn" class="small">Inorder</button>
          <button id="preorderBtn" class="small">Preorder</button>
          <button id="postorderBtn" class="small">Postorder</button>
          <button id="levelBtn" class="small">Level-order</button>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="playBtn" class="small">Play</button>
          <button id="stepBtn" class="small secondary">Step</button>
          <label style="font-size:13px;color:var(--muted);">Speed</label>
          <input id="speed" type="range" min="100" max="1200" value="450" />
        </div>
      </div>
    </div>

    <div class="svg-wrap">
      <svg id="canvas" viewBox="0 0 1200 520" preserveAspectRatio="xMidYMid meet">
        <!-- Edges and nodes are drawn here -->
      </svg>
    </div>

    <div class="info">
      <div class="stat">Nodes: <span id="nodeCount">0</span></div>
      <div class="stat">Height: <span id="height">0</span></div>
      <div class="stat">Root: <span id="rootVal">—</span></div>
      <div class="stat">Status: <span id="status" style="color:var(--muted)">Idle</span></div>
      <div style="margin-left:auto" class="legend">
        <div class="swatch" style="background:var(--node-fill); border:1px solid rgba(255,255,255,0.06)"></div><div style="color:var(--muted); font-size:13px">Node</div>
        <div class="swatch" style="background:var(--highlight)"></div><div style="color:var(--muted); font-size:13px">Visited / Highlight</div>
        <div class="swatch" style="background:var(--good)"></div><div style="color:var(--muted); font-size:13px">Found</div>
        <div class="swatch" style="background:var(--bad)"></div><div style="color:var(--muted); font-size:13px">Deleted</div>
      </div>
    </div>

    <footer>
      Tip: Try inserting ascending numbers to see an unbalanced tree, or insert random numbers to get a more balanced tree. Delete nodes with two children to observe successor replacement.
    </footer>
  </div>

  <script>
  // Simple BST with visualization in SVG. Single-file demo.

  // Utilities
  const $ = (id) => document.getElementById(id);
  const svg = $('canvas');
  const WIDTH = 1200, HEIGHT = 520;
  svg.setAttribute('viewBox', `0 0 ${WIDTH} ${HEIGHT}`);

  // Tree Node class
  let uniqueId = 1;
  class Node {
    constructor(val){
      this.val = val;
      this.left = null;
      this.right = null;
      this.id = uniqueId++;
      // layout
      this.x = 0; this.y = 0;
    }
  }

  // BST root
  let root = null;

  // Visualization / state
  let nodesFlat = []; // flat list for easy access
  let animTimer = null;
  let currentSequence = [];
  let playIndex = 0;
  let isPlaying = false;
  const state = {
    highlight: null
  };

  // DOM elements
  const nodeCountEl = $('nodeCount');
  const heightEl = $('height');
  const rootValEl = $('rootVal');
  const statusEl = $('status');
  const speedEl = $('speed');

  function updateStats(){
    nodeCountEl.textContent = countNodes(root);
    heightEl.textContent = getHeight(root);
    rootValEl.textContent = root ? root.val : '—';
  }

  // BST operations
  function insertValue(val){
    if (root === null) { root = new Node(val); return root; }
    let cur = root;
    while(true){
      if (val === cur.val) return null; // duplicates not allowed
      if (val < cur.val){
        if (!cur.left){ cur.left = new Node(val); return cur.left; }
        cur = cur.left;
      } else {
        if (!cur.right){ cur.right = new Node(val); return cur.right; }
        cur = cur.right;
      }
    }
  }

  function searchValue(val){
    let cur = root;
    const path = [];
    while(cur){
      path.push(cur);
      if (val === cur.val) return {found:cur, path};
      cur = val < cur.val ? cur.left : cur.right;
    }
    return {found:null, path};
  }

  function deleteValue(val){
    let deleted = {node:null};
    root = deleteRec(root, val, deleted);
    return deleted.node;
  }

  function deleteRec(node, val, deleted){
    if (!node) return null;
    if (val < node.val) node.left = deleteRec(node.left, val, deleted);
    else if (val > node.val) node.right = deleteRec(node.right, val, deleted);
    else {
      // found
      deleted.node = node;
      if (!node.left && !node.right) return null;
      if (!node.left) return node.right;
      if (!node.right) return node.left;
      // two children: replace with inorder successor (min in right subtree)
      const succ = minNode(node.right);
      node.val = succ.val;
      // remove successor node from right subtree
      node.right = deleteRec(node.right, succ.val, deleted);
    }
    return node;
  }

  function minNode(node){ while(node.left) node = node.left; return node; }

  // Traversals
  function inorder(n, arr){ if(!n) return; inorder(n.left,arr); arr.push(n); inorder(n.right,arr); }
  function preorder(n, arr){ if(!n) return; arr.push(n); preorder(n.left,arr); preorder(n.right,arr); }
  function postorder(n, arr){ if(!n) return; postorder(n.left,arr); postorder(n.right,arr); arr.push(n); }
  function levelOrder(n,arr){ if(!n) return; const q=[n]; while(q.length){ const t=q.shift(); arr.push(t); if(t.left) q.push(t.left); if(t.right) q.push(t.right); } }

  // Utility traversals
  function countNodes(n){ if(!n) return 0; return 1 + countNodes(n.left) + countNodes(n.right); }
  function getHeight(n){ if(!n) return 0; return 1 + Math.max(getHeight(n.left), getHeight(n.right)); }

  // Layout: assign x via inorder index, y by depth. We'll compute inorder positions
  function computeLayout(){
    nodesFlat = [];
    let index = 0;
    function dfs(n, depth){
      if(!n) return;
      dfs(n.left, depth + 1);
      // horizontal spacing
      const margin = 60;
      const span = WIDTH - 2*margin;
      const totalLeaves = Math.max(1, countNodes(root));
      // Use inorder index to place evenly
      n.x = margin + (index / Math.max(1, totalLeaves-1 || 1)) * span;
      n.y = 60 + depth * 85;
      index++;
      nodesFlat.push(n);
      dfs(n.right, depth + 1);
    }
    index = 0;
    if (root) dfs(root, 0);
    // If only one node, center it
    if (nodesFlat.length === 1){ nodesFlat[0].x = WIDTH/2; nodesFlat[0].y = 80; }
  }

  // Rendering
  function render(){
    computeLayout();
    svg.innerHTML = ''; // clear
    // draw edges first
    if (root) drawEdgesSVG(root);
    // draw nodes
    if (nodesFlat.length) {
      for (const n of nodesFlat){
        drawNodeSVG(n);
      }
    }
    attachNodeClickHandlers();
    updateStats();
  }

  function drawEdgesSVG(node){
    if (!node) return;
    if (node.left){
      drawLine(node.x, node.y, node.left.x, node.left.y);
      drawEdgesSVG(node.left);
    }
    if (node.right){
      drawLine(node.x, node.y, node.right.x, node.right.y);
      drawEdgesSVG(node.right);
    }
  }

  function drawLine(x1,y1,x2,y2){
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1 + 18); // start under node circle
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2 - 18); // end above node circle
    line.setAttribute('stroke', 'rgba(255,255,255,0.08)');
    line.setAttribute('stroke-width', 2);
    svg.appendChild(line);
  }

  function drawNodeSVG(n){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('data-id', n.id);
    g.setAttribute('transform', `translate(${n.x},${n.y})`);
    // circle
    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('r', 20);
    circle.setAttribute('cx', 0);
    circle.setAttribute('cy', 0);
    circle.setAttribute('fill', 'var(--node-fill)');
    circle.setAttribute('stroke', 'rgba(255,255,255,0.06)');
    circle.setAttribute('stroke-width', 2);
    circle.classList.add('node-circle');
    // label
    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('x', 0);
    text.setAttribute('y', 6);
    text.setAttribute('text-anchor','middle');
    text.setAttribute('class','node-label');
    text.textContent = String(n.val);
    // add tooltip (title)
    const title = document.createElementNS('http://www.w3.org/2000/svg','title');
    title.textContent = 'Click to inspect: ' + n.val;
    g.appendChild(circle);
    g.appendChild(text);
    g.appendChild(title);
    svg.appendChild(g);
  }

  function attachNodeClickHandlers(){
    const groups = svg.querySelectorAll('g[data-id]');
    groups.forEach(g=>{
      g.style.cursor = 'pointer';
      g.onclick = (ev)=>{
        const id = +g.getAttribute('data-id');
        const node = nodesFlat.find(n=>n.id===id);
        if(!node) return;
        flashNode(node, 'inspect');
        showNodeInfo(node);
        ev.stopPropagation();
      };
    });
    // clicking background clears inspection
    svg.onclick = (ev)=>{ clearStatus(); };
  }

  function showNodeInfo(node){
    statusEl.textContent = `Node ${node.val} (id ${node.id}) — left: ${node.left?node.left.val:'—'}, right: ${node.right?node.right.val:'—'}`;
  }

  function clearStatus(){
    statusEl.textContent = 'Idle';
  }

  // Animations & highlights
  function highlightNode(node, color){
    const g = svg.querySelector(`g[data-id="${node.id}"]`);
    if(!g) return;
    const circle = g.querySelector('circle');
    circle.setAttribute('fill', color);
  }

  function resetNodeColor(node){
    const g = svg.querySelector(`g[data-id="${node.id}"]`);
    if(!g) return;
    const circle = g.querySelector('circle');
    circle.setAttribute('fill', 'var(--node-fill)');
  }

  function flashNode(node, type){
    // short highlight animation for click or found
    const color = type === 'found' ? 'var(--good)' : type === 'delete' ? 'var(--bad)' : 'var(--highlight)';
    highlightNode(node, color);
    setTimeout(()=>{ resetNodeColor(node); }, 700);
  }

  function playSequence(sequence, onDone){
    stopPlayback();
    currentSequence = sequence.slice();
    playIndex = 0;
    isPlaying = true;
    $('playBtn').textContent = 'Stop';
    statusEl.textContent = 'Playing traversal...';
    const step = ()=>{
      if (!isPlaying) return;
      if (playIndex >= currentSequence.length){
        stopPlayback();
        if (onDone) onDone();
        return;
      }
      const n = currentSequence[playIndex];
      highlightOne(n);
      playIndex++;
      animTimer = setTimeout(step, +speedEl.value);
    };
    step();
  }

  function stopPlayback(){
    isPlaying = false;
    if (animTimer) clearTimeout(animTimer);
    animTimer = null;
    $('playBtn').textContent = 'Play';
    statusEl.textContent = 'Idle';
    // reset colors
    nodesFlat.forEach(n=>resetNodeColor(n));
  }

  function highlightOne(node){
    // brief highlight and keep it highlighted (to show sequence) then dim slightly
    const g = svg.querySelector(`g[data-id="${node.id}"]`);
    if(!g) return;
    const circle = g.querySelector('circle');
    circle.setAttribute('fill', 'var(--highlight)');
    // fade to muted highlight
    setTimeout(()=>{ circle.setAttribute('fill', 'rgba(245,158,11,0.36)'); }, Math.max(200, +speedEl.value - 200));
  }

  // Buttons & interactions
  $('insertBtn').onclick = ()=>{
    const val = Number($('valueInput').value);
    if (!Number.isFinite(val)) { alert('Enter a number to insert.'); return; }
    const res = insertValue(val);
    if (!res) { alert('Value already exists in tree (duplicates not allowed).'); return;}
    render();
    flashNode(res, 'insert');
    clearInput();
  };

  $('deleteBtn').onclick = ()=>{
    const val = Number($('valueInput').value);
    if (!Number.isFinite(val)) { alert('Enter a number to delete.'); return; }
    const found = searchValue(val);
    if (!found.found){ alert('Value not found.'); return; }
    const del = deleteValue(val);
    render();
    if (del) flashNode(del, 'delete');
    clearInput();
  };

  $('searchBtn').onclick = ()=>{
    const val = Number($('valueInput').value);
    if (!Number.isFinite(val)) { alert('Enter a number to search.'); return; }
    const res = searchValue(val);
    // render path highlighting
    render();
    // highlight path stepwise
    let i=0;
    function step(){
      if (i>0){ resetNodeColor(res.path[i-1]); }
      if (i >= res.path.length){ 
        if (res.found){ flashNode(res.found, 'found'); statusEl.textContent = `Found ${val}.`; }
        else statusEl.textContent = `Not found: ${val}.`;
        return;
      }
      highlightNode(res.path[i], 'rgba(59,130,246,0.9)'); // blue path
      i++;
      setTimeout(step, 300);
    }
    step();
    clearInput();
  };

  $('clearBtn').onclick = ()=>{
    root = null;
    nodesFlat = [];
    render();
    clearStatus();
  };

  $('randomBtn').onclick = ()=>{
    const n = Math.max(1, Math.min(30, Math.round(prompt('How many nodes? (1-30)', '9') || 9)));
    // generate unique random values
    const vals = new Set();
    while(vals.size < n){
      vals.add(Math.floor(Math.random()*100));
    }
    root = null;
    for (const v of vals) insertValue(v);
    render();
    statusEl.textContent = `Random tree with ${n} nodes created.`;
  };

  $('inorderBtn').onclick = ()=>{ runTraversal('inorder'); };
  $('preorderBtn').onclick = ()=>{ runTraversal('preorder'); };
  $('postorderBtn').onclick = ()=>{ runTraversal('postorder'); };
  $('levelBtn').onclick = ()=>{ runTraversal('level'); };

  function runTraversal(kind){
    if (!root) { alert('Tree is empty'); return; }
    stopPlayback();
    const arr = [];
    if (kind === 'inorder') inorder(root, arr);
    else if (kind === 'preorder') preorder(root, arr);
    else if (kind === 'postorder') postorder(root, arr);
    else if (kind === 'level') levelOrder(root, arr);
    currentSequence = arr;
    playIndex = 0;
    // show list in status
    statusEl.textContent = `${kind} → ${arr.map(n=>n.val).join(', ')}`;
    // highlight first item briefly
    nodesFlat.forEach(n=>resetNodeColor(n));
    if (arr.length) highlightNode(arr[0], 'var(--highlight)');
  }

  $('playBtn').onclick = ()=>{
    if (isPlaying){ stopPlayback(); return; }
    if (!currentSequence.length){ alert('Start a traversal (Inorder/Preorder/Postorder/Level-order) first to play it.'); return; }
    playSequence(currentSequence, ()=>{ statusEl.textContent = 'Traversal complete.'; });
  };

  $('stepBtn').onclick = ()=>{
    if (!currentSequence.length){ alert('Start a traversal first.'); return; }
    if (playIndex >= currentSequence.length) { playIndex = 0; nodesFlat.forEach(n=>resetNodeColor(n)); }
    const n = currentSequence[playIndex++];
    highlightOne(n);
    statusEl.textContent = `Step: ${n.val} (${playIndex}/${currentSequence.length})`;
    if (playIndex >= currentSequence.length) statusEl.textContent = 'Traversal finished.';
  };

  function clearInput(){ $('valueInput').value = ''; }

  // Click on empty SVG clears selection
  svg.onclick = (ev)=>{ /* handled above */ };

  // Initialize sample tree
  function initSample(){
    root = null;
    [50, 30, 70, 20, 40, 60, 80].forEach(v=>insertValue(v));
    render();
    statusEl.textContent = 'Sample tree loaded.';
  }

  // start
  initSample();

  // expose functions for debug
  window._bst = { root, insertValue, deleteValue, searchValue, render };
  </script>
</body>
</html>