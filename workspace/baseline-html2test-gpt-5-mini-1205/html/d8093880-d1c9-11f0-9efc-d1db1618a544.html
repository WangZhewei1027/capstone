<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Linked List Visualizer (Singly Linked List)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#2dd4bf;
      --muted:#9aa6b2;
      --card:#071029;
      --danger:#ff6b6b;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{
      height:100%;
      margin:0;
      font-family: Inter, Roboto, "Segoe UI", Arial, sans-serif;
      background: linear-gradient(180deg,#071023 0%, #08112b 60%, #071029 100%);
      color:#e6eef3;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app{
      max-width:1100px;
      margin:28px auto;
      padding:20px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      box-shadow: 0 6px 30px rgba(0,0,0,0.6);
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:18px;
      align-items:start;
    }

    .panel{
      background:var(--panel);
      border-radius:10px;
      padding:14px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    }

    h1{
      margin:0 0 8px 0;
      font-size:20px;
      color:var(--accent);
    }
    p.lead{
      margin:0 0 14px 0;
      color:var(--muted);
      font-size:13px;
    }

    .controls{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .row{
      display:flex;
      gap:8px;
      align-items:center;
    }
    input[type="text"], input[type="number"]{
      flex:1;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      background:var(--card);
      color:inherit;
      outline:none;
      font-size:14px;
    }
    button{
      background:linear-gradient(180deg,var(--accent), #06b89f);
      color:#042027;
      border:none;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      box-shadow: 0 4px 14px rgba(45,212,191,0.12);
    }
    button.ghost{
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--muted);
      box-shadow:none;
    }
    .small{
      padding:6px 8px;
      font-size:13px;
    }
    .danger{
      background:linear-gradient(180deg,#ff7b7b,#ff6b6b);
      color:#3b0000;
    }

    .meta{
      font-size:13px;
      color:var(--muted);
      margin-top:10px;
    }

    /* Canvas area */
    .canvasWrap{
      min-height:320px;
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .svgContainer{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      border-radius:10px;
      padding:16px;
      overflow:auto;
      border:1px solid rgba(255,255,255,0.03);
    }
    svg{
      width:100%;
      height:160px;
      display:block;
    }

    .info{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      margin-top:6px;
    }
    .badge{
      background:var(--glass);
      padding:6px 10px;
      border-radius:999px;
      color:var(--muted);
      font-size:13px;
    }

    /* Node styles for fallback (not SVG) */
    .node{
      display:inline-flex;
      align-items:center;
      gap:12px;
      padding:8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      margin-right:12px;
    }

    /* Legend */
    .legend{
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .legend .key{
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .swatch{
      width:18px;height:18px;border-radius:6px;
      display:inline-block;
    }
    .swatch.node{ background:#0ea5a4; }
    .swatch.ptr{ background:transparent; border:2px solid rgba(255,255,255,0.06); box-sizing:border-box; }
    .swatch.highlight{ background:#ffd166; }

    /* Highlight animations */
    .node-rect{
      transition: fill 260ms ease, stroke 260ms ease;
    }
    .node-text{
      transition: fill 260ms ease;
    }
    .highlight{
      fill:#ffd166 !important;
      stroke:#ffb84d !important;
    }
    .found{
      fill:#7afcff !important;
      stroke:#06b6d4 !important;
    }

    footer{
      font-size:12px;
      color:var(--muted);
      margin-top:20px;
      text-align:center;
    }

    @media (max-width:880px){
      .app{ grid-template-columns: 1fr; padding:12px; margin:12px; }
      .svgContainer{ height:220px; }
    }
  </style>
</head>
<body>
  <div class="app" role="main">
    <div class="panel" aria-labelledby="title">
      <h1 id="title">Singly Linked List — Visual Explorer</h1>
      <p class="lead">Interactive demonstration of a singly linked list. Create nodes, insert, remove, search, reverse, and step through traversals to see how pointers move.</p>

      <div class="controls" aria-hidden="false">
        <div class="row">
          <input id="valInput" type="text" placeholder="Node value (text or number)" />
          <button id="pushBtn" class="small" title="Append to tail">Push</button>
          <button id="unshiftBtn" class="small" title="Insert at head">Unshift</button>
        </div>

        <div class="row">
          <input id="indexInput" type="number" placeholder="Index (0-based)" min="0" />
          <button id="insertAtBtn" class="small" title="Insert at index">Insert at</button>
          <button id="removeAtBtn" class="small ghost" title="Remove node at index">Remove at</button>
        </div>

        <div class="row">
          <input id="searchInput" type="text" placeholder="Search value" />
          <button id="findBtn" class="small ghost" title="Find first occurrence">Find</button>
          <button id="removeBtn" class="small danger" title="Remove first matching value">Remove</button>
        </div>

        <div class="row">
          <button id="reverseBtn" class="small">Reverse</button>
          <button id="clearBtn" class="small ghost">Clear</button>
          <button id="randomBtn" class="small">Randomize</button>
        </div>

        <div class="meta">
          Tip: Use "Find" to animate traversal. "Insert at" highlights the point of insertion. "Reverse" reverses pointers; watch the head move.
        </div>

        <div style="height:8px"></div>

        <div class="legend">
          <div class="key"><span class="swatch node"></span> Node</div>
          <div class="key"><span class="swatch ptr"></span> Pointer / Arrow</div>
          <div class="key"><span class="swatch highlight"></span> Current / Highlight</div>
        </div>
      </div>
    </div>

    <div class="panel canvasWrap" aria-live="polite">
      <div class="svgContainer" id="svgWrapper">
        <!-- SVG will be injected here -->
      </div>

      <div class="info">
        <div>
          <span class="badge" id="sizeBadge">Size: 0</span>
          <span class="badge" id="headBadge">Head: null</span>
        </div>
        <div>
          <button id="stepTraversal" class="small ghost">Step-through Traversal</button>
          <button id="exportBtn" class="small ghost">Export (array)</button>
        </div>
      </div>

      <div id="log" style="margin-top:8px; color:var(--muted); font-size:13px; min-height:18px;">Ready.</div>
    </div>
  </div>

  <footer>
    Implementation: Singly linked list in JavaScript with SVG visualization — nodes are boxes, arrows are SVG markers. Interact to learn pointer behavior.
  </footer>

  <script>
    // Singly Linked List implementation + visualizer
    (function(){
      // Utility: small delay for animations
      const wait = ms => new Promise(res => setTimeout(res, ms));

      // Node class (internal)
      class Node {
        constructor(value){
          this.value = value;
          this.next = null;
        }
      }

      // Singly linked list with common operations
      class LinkedList {
        constructor(){
          this.head = null;
          this.length = 0;
        }

        push(value){
          const node = new Node(value);
          if (!this.head){
            this.head = node;
          } else {
            let cur = this.head;
            while (cur.next) cur = cur.next;
            cur.next = node;
          }
          this.length++;
          return node;
        }

        unshift(value){
          const node = new Node(value);
          node.next = this.head;
          this.head = node;
          this.length++;
          return node;
        }

        insertAt(index, value){
          if (index < 0 || index > this.length) return null;
          if (index === 0) return this.unshift(value);
          const node = new Node(value);
          let cur = this.head;
          let prev = null;
          let i = 0;
          while (i < index){
            prev = cur;
            cur = cur.next;
            i++;
          }
          prev.next = node;
          node.next = cur;
          this.length++;
          return node;
        }

        removeAt(index){
          if (index < 0 || index >= this.length || !this.head) return null;
          let cur = this.head;
          if (index === 0){
            this.head = cur.next;
            this.length--;
            return cur;
          }
          let prev = null;
          let i = 0;
          while (i < index){
            prev = cur;
            cur = cur.next;
            i++;
          }
          prev.next = cur.next;
          this.length--;
          return cur;
        }

        remove(value){
          if (!this.head) return null;
          let cur = this.head;
          if (cur.value === value){
            this.head = cur.next;
            this.length--;
            return cur;
          }
          let prev = null;
          while (cur && cur.value !== value){
            prev = cur;
            cur = cur.next;
          }
          if (!cur) return null;
          prev.next = cur.next;
          this.length--;
          return cur;
        }

        findIndex(value){
          let cur = this.head;
          let i = 0;
          while (cur){
            if (cur.value === value) return i;
            cur = cur.next;
            i++;
          }
          return -1;
        }

        toArray(){
          const res = [];
          let cur = this.head;
          while (cur){
            res.push(cur.value);
            cur = cur.next;
          }
          return res;
        }

        reverse(){
          let prev = null;
          let cur = this.head;
          while (cur){
            let next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = next;
          }
          this.head = prev;
        }

        clear(){
          this.head = null;
          this.length = 0;
        }
      }

      // Visualizer: renders an SVG representation of the list
      class LinkedListVisualizer {
        constructor(list, container){
          this.list = list;
          this.container = container; // element to place an SVG
          // config
          this.nodeWidth = 90;
          this.nodeHeight = 42;
          this.hGap = 28;
          this.vPadding = 16;
          this.animating = false;
          this.svg = null;
          this.markerId = 'arrow';
          this._createSVG();
        }

        _createSVG(){
          // Clear container
          this.container.innerHTML = '';
          const svgNS = 'http://www.w3.org/2000/svg';
          const svg = document.createElementNS(svgNS, 'svg');
          svg.setAttribute('viewBox', '0 0 100 100');
          svg.setAttribute('preserveAspectRatio', 'xMinYMid meet');
          svg.style.width = '100%';
          svg.style.height = '160px';
          // defs for arrow marker
          const defs = document.createElementNS(svgNS, 'defs');
          const marker = document.createElementNS(svgNS, 'marker');
          marker.setAttribute('id', this.markerId);
          marker.setAttribute('markerWidth','8');
          marker.setAttribute('markerHeight','8');
          marker.setAttribute('refX','6');
          marker.setAttribute('refY','3');
          marker.setAttribute('orient','auto');
          const path = document.createElementNS(svgNS, 'path');
          path.setAttribute('d','M0,0 L6,3 L0,6 z');
          path.setAttribute('fill','#7ea6a5');
          marker.appendChild(path);
          defs.appendChild(marker);
          svg.appendChild(defs);
          this.container.appendChild(svg);
          this.svg = svg;
        }

        // Render nodes based on current list; optional highlight map {index:class}
        render(highlightIndex = -1, foundIndex = -1){
          if (!this.svg) this._createSVG();
          const svg = this.svg;
          const svgNS = 'http://www.w3.org/2000/svg';
          // remove all children except defs
          const defs = svg.querySelector('defs');
          svg.innerHTML = '';
          if (defs) svg.appendChild(defs);

          // Compute needed width
          const arr = this.list.toArray();
          const n = arr.length;
          if (n === 0){
            // Empty placeholder
            svg.setAttribute('viewBox','0 0 100 100');
            const txt = document.createElementNS(svgNS,'text');
            txt.setAttribute('x','50%');
            txt.setAttribute('y','50%');
            txt.setAttribute('text-anchor','middle');
            txt.setAttribute('fill','#9aa6b2');
            txt.setAttribute('font-size','12');
            txt.textContent = '(empty list)';
            svg.appendChild(txt);
            return;
          }
          const totalNodeW = this.nodeWidth * n + this.hGap * (n - 1);
          const width = Math.max(totalNodeW + 40, 320);
          const height = 140;
          svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
          // layout nodes horizontally
          const startX = 20;
          const y = height / 2 - this.nodeHeight / 2;

          // Draw arrows and nodes
          for (let i=0;i<n;i++){
            const x = startX + i * (this.nodeWidth + this.hGap);

            // Node group
            const g = document.createElementNS(svgNS,'g');
            g.setAttribute('data-index', i);

            // Rect (node body)
            const rect = document.createElementNS(svgNS,'rect');
            rect.setAttribute('x', x);
            rect.setAttribute('y', y);
            rect.setAttribute('rx', 8);
            rect.setAttribute('ry', 8);
            rect.setAttribute('width', this.nodeWidth);
            rect.setAttribute('height', this.nodeHeight);
            rect.setAttribute('fill', '#0ea5a4');
            rect.setAttribute('stroke', 'rgba(255,255,255,0.06)');
            rect.setAttribute('class', 'node-rect');
            rect.setAttribute('id', `rect-${i}`);
            g.appendChild(rect);

            // Text (value)
            const text = document.createElementNS(svgNS,'text');
            text.setAttribute('x', x + this.nodeWidth/2);
            text.setAttribute('y', y + this.nodeHeight/2 + 5);
            text.setAttribute('text-anchor','middle');
            text.setAttribute('fill','#042027');
            text.setAttribute('font-size','14');
            text.setAttribute('font-weight','600');
            text.setAttribute('class','node-text');
            text.textContent = String(arr[i]);
            g.appendChild(text);

            svg.appendChild(g);

            // Draw arrow to next (if not last)
            if (i < n - 1){
              const arrowStartX = x + this.nodeWidth;
              const arrowStartY = y + this.nodeHeight/2;
              const arrowEndX = x + this.nodeWidth + this.hGap;
              const arrowEndY = arrowStartY;

              const line = document.createElementNS(svgNS,'line');
              line.setAttribute('x1', arrowStartX + 2);
              line.setAttribute('y1', arrowStartY);
              line.setAttribute('x2', arrowEndX - 6);
              line.setAttribute('y2', arrowEndY);
              line.setAttribute('stroke', 'rgba(255,255,255,0.06)');
              line.setAttribute('stroke-width', 2);
              line.setAttribute('marker-end', `url(#${this.markerId})`);
              svg.appendChild(line);
            }

            // If highlightIndex or foundIndex, apply classes
            if (i === highlightIndex){
              rect.setAttribute('fill','#ffd166');
              rect.setAttribute('stroke','#ffb84d');
              text.setAttribute('fill','#051019');
            } else if (i === foundIndex){
              rect.setAttribute('fill','#7afcff');
              rect.setAttribute('stroke','#06b6d4');
              text.setAttribute('fill','#002427');
            }
          }

          // Draw Head label arrow
          const headX = startX - 10;
          const headY = y + this.nodeHeight / 2;
          const headText = document.createElementNS(svgNS,'text');
          headText.setAttribute('x', 8);
          headText.setAttribute('y', headY + 5);
          headText.setAttribute('fill','#9aa6b2');
          headText.setAttribute('font-size','12');
          headText.textContent = 'head';
          svg.appendChild(headText);

          const headLine = document.createElementNS(svgNS,'line');
          headLine.setAttribute('x1', 24);
          headLine.setAttribute('y1', headY);
          headLine.setAttribute('x2', startX);
          headLine.setAttribute('y2', headY);
          headLine.setAttribute('stroke', 'rgba(255,255,255,0.06)');
          headLine.setAttribute('stroke-width', 2);
          headLine.setAttribute('marker-end', `url(#${this.markerId})`);
          svg.appendChild(headLine);
        }

        // Animate traversal: sequentially highlight nodes (awaitable)
        async animateTraversal(targetIndex = -1, onStep = null, delay = 600){
          if (this.animating) return;
          this.animating = true;
          const n = this.list.length;
          for (let i=0;i<n;i++){
            // render with highlight at i
            this.render(i, -1);
            if (typeof onStep === 'function') onStep(i);
            await wait(delay);
            // If targetIndex reached, highlight as found and break
            if (i === targetIndex){
              this.render(-1, i);
              await wait(delay);
              break;
            }
          }
          this.animating = false;
        }
      }

      // Application wiring
      const list = new LinkedList();
      const wrapper = document.getElementById('svgWrapper');
      const viz = new LinkedListVisualizer(list, wrapper);

      // UI elements
      const valInput = document.getElementById('valInput');
      const indexInput = document.getElementById('indexInput');
      const searchInput = document.getElementById('searchInput');
      const pushBtn = document.getElementById('pushBtn');
      const unshiftBtn = document.getElementById('unshiftBtn');
      const insertAtBtn = document.getElementById('insertAtBtn');
      const removeAtBtn = document.getElementById('removeAtBtn');
      const findBtn = document.getElementById('findBtn');
      const removeBtn = document.getElementById('removeBtn');
      const reverseBtn = document.getElementById('reverseBtn');
      const clearBtn = document.getElementById('clearBtn');
      const randomBtn = document.getElementById('randomBtn');
      const sizeBadge = document.getElementById('sizeBadge');
      const headBadge = document.getElementById('headBadge');
      const logEl = document.getElementById('log');
      const stepTraversal = document.getElementById('stepTraversal');
      const exportBtn = document.getElementById('exportBtn');

      // Helpers to update UI
      function updateBadges(){
        sizeBadge.textContent = 'Size: ' + list.length;
        headBadge.textContent = 'Head: ' + (list.head ? String(list.head.value) : 'null');
      }
      function log(msg){
        logEl.textContent = msg;
      }
      function normalizeInputValue(el){
        // null or trimmed
        return el.value === '' ? null : el.value;
      }
      // Render current list
      function renderNow(){
        viz.render();
        updateBadges();
      }

      // Event handlers
      pushBtn.addEventListener('click', async ()=>{
        const v = normalizeInputValue(valInput);
        if (v === null){ log('Enter a value to push.'); return; }
        list.push(v);
        log('Pushed "'+v+'".');
        renderNow();
      });

      unshiftBtn.addEventListener('click', async ()=>{
        const v = normalizeInputValue(valInput);
        if (v === null){ log('Enter a value to unshift.'); return; }
        list.unshift(v);
        log('Inserted "'+v+'" at head.');
        renderNow();
      });

      insertAtBtn.addEventListener('click', async ()=>{
        const v = normalizeInputValue(valInput);
        const idx = parseInt(indexInput.value, 10);
        if (v === null){ log('Enter a value to insert.'); return; }
        if (isNaN(idx)){ log('Enter a valid index.'); return; }
        if (idx < 0 || idx > list.length){ log('Index out of bounds.'); return; }
        // Animate traversal to index (we highlight node before insertion)
        if (idx === 0){
          list.unshift(v);
          log(`Inserted "${v}" at index 0 (head).`);
          renderNow();
          return;
        }
        // animate to index-1 (the previous node where we will insert after)
        await viz.animateTraversal(idx-1, (i)=> log(`Traversing: at index ${i}`), 450);
        list.insertAt(idx, v);
        log(`Inserted "${v}" at index ${idx}.`);
        renderNow();
      });

      removeAtBtn.addEventListener('click', async ()=>{
        const idx = parseInt(indexInput.value, 10);
        if (isNaN(idx)){ log('Enter a valid index to remove.'); return; }
        if (idx < 0 || idx >= list.length){ log('Index out of bounds.'); return; }
        // animate traversal to the node at index
        await viz.animateTraversal(idx, (i)=> log(`Traversing: at index ${i}`), 450);
        const removed = list.removeAt(idx);
        log(`Removed node at index ${idx} (value="${removed ? removed.value : 'null'}").`);
        renderNow();
      });

      findBtn.addEventListener('click', async ()=>{
        const v = normalizeInputValue(searchInput);
        if (v === null){ log('Enter a value to find.'); return; }
        // find index
        const idx = list.findIndex(v);
        if (idx === -1){
          // animate full traversal to show not found
          await viz.animateTraversal(-1, (i)=> log(`Traversing: at index ${i}`), 350);
          log(`Value "${v}" not found.`);
          renderNow();
          return;
        }
        await viz.animateTraversal(idx, (i)=> log(`Traversing: at index ${i}`), 400);
        log(`Found "${v}" at index ${idx}.`);
        // final render shows found highlight
        viz.render(-1, idx);
      });

      removeBtn.addEventListener('click', async ()=>{
        const v = normalizeInputValue(searchInput);
        if (v === null){ log('Enter a value to remove.'); return; }
        const idx = list.findIndex(v);
        if (idx === -1){
          await viz.animateTraversal(-1, (i)=> log(`Traversing: at index ${i}`), 350);
          log(`Value "${v}" not found; nothing removed.`);
          renderNow();
          return;
        }
        await viz.animateTraversal(idx, (i)=> log(`Traversing: at index ${i}`), 380);
        const removed = list.remove(v);
        log(`Removed first occurrence of "${v}" (index ${idx}).`);
        renderNow();
      });

      reverseBtn.addEventListener('click', async ()=>{
        if (list.length <= 1){ log('List too small to reverse.'); return; }
        // Show an animated sequence: traverse and then reverse
        log('Reversing list...');
        // Quick highlight sweep
        await viz.animateTraversal(-1, (i)=> log(`Scanning: at index ${i}`), 160);
        list.reverse();
        renderNow();
        log('List reversed.');
      });

      clearBtn.addEventListener('click', ()=>{
        list.clear();
        renderNow();
        log('Cleared list.');
      });

      randomBtn.addEventListener('click', ()=>{
        list.clear();
        const sample = ['A','B','C','D','E','1','2','3','X','Y','Z'];
        const n = Math.floor(Math.random()*5)+3;
        for (let i=0;i<n;i++){
          const v = sample[Math.floor(Math.random()*sample.length)];
          list.push(v);
        }
        renderNow();
        log('Generated random list.');
      });

      stepTraversal.addEventListener('click', async ()=>{
        if (list.length === 0){ log('List is empty.'); return; }
        log('Step-through traversal: click "Next" in the prompt.');
        // We'll step using a simple confirm prompt (keeps it single-file & simple)
        // But avoid blocking UI; instead simulate step-by-step with window.confirm
        // Provide instructions
        let cur = list.head;
        let i = 0;
        while (cur){
          const proceed = confirm(`Step ${i}: node value = "${cur.value}". Click OK to advance, Cancel to stop.`);
          if (!proceed) { log('Traversal stopped by user.'); renderNow(); return; }
          // highlight current
          viz.render(i, -1);
          await wait(200);
          cur = cur.next;
          i++;
        }
        log('Reached end of list.');
        viz.render();
      });

      exportBtn.addEventListener('click', ()=>{
        const arr = list.toArray();
        const text = JSON.stringify(arr);
        // attempt clipboard write
        if (navigator.clipboard && navigator.clipboard.writeText){
          navigator.clipboard.writeText(text).then(()=> {
            log('Exported array to clipboard: ' + text);
          }).catch(()=> {
            log('Export: ' + text);
          });
        } else {
          log('Export: ' + text);
        }
      });

      // Initialize with a sample list
      (function seed(){
        const seeds = ['10','20','30','40'];
        seeds.forEach(v => list.push(v));
        renderNow();
        log('Sample list created. Try operations above.');
      })();

      // Keep rendering on window resize for responsiveness
      window.addEventListener('resize', ()=> renderNow());

      // Expose for debugging (optional)
      window._linkedListDemo = { list, viz };
    })();
  </script>
</body>
</html>