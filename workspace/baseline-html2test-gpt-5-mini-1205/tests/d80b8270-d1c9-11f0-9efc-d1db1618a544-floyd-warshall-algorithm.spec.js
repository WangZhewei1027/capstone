import { test, expect } from '@playwright/test';

const APP_URL = 'http://127.0.0.1:5500/workspace/baseline-html2test-gpt-5-mini-1205/html/d80b8270-d1c9-11f0-9efc-d1db1618a544.html';

test.describe('Floyd–Warshall Visualizer - d80b8270-d1c9-11f0-9efc-d1db1618a544', () => {
  // Hold console and page errors per test for assertions
  let consoleErrors;
  let pageErrors;

  test.beforeEach(async ({ page }) => {
    consoleErrors = [];
    pageErrors = [];

    // Capture console messages (only record error-level for assertions)
    page.on('console', (msg) => {
      if (msg.type() === 'error') {
        consoleErrors.push({
          text: msg.text(),
          location: msg.location ? msg.location() : null
        });
      }
    });

    // Capture uncaught exceptions
    page.on('pageerror', (err) => {
      pageErrors.push(String(err && err.message ? err.message : err));
    });

    // Navigate to the app
    await page.goto(APP_URL, { waitUntil: 'load' });
    // Wait a short moment for the app's initial scripts (random graph & snapshots) to settle
    await page.waitForTimeout(300);
  });

  test.afterEach(async () => {
    // After each test ensure that no unexpected runtime errors were emitted
    expect(pageErrors, 'No uncaught page errors should occur').toHaveLength(0);
    expect(consoleErrors, 'No console.error messages should be logged').toHaveLength(0);
  });

  test.describe('Initial page load and default state', () => {
    test('loads page and renders initial UI elements', async ({ page }) => {
      // Verify title
      await expect(page).toHaveTitle(/Floyd–Warshall Algorithm Visualizer|Floyd–Warshall Visualizer/);

      // Key UI controls exist
      await expect(page.locator('#addNodeBtn')).toBeVisible();
      await expect(page.locator('#runBtn')).toBeVisible();
      await expect(page.locator('#svg')).toBeVisible();

      // There should be some nodes generated by the initial randomGraph call
      const nodeCountText = await page.locator('#nodeCount').textContent();
      const nodeCountNum = Number(nodeCountText);
      expect(nodeCountNum).toBeGreaterThanOrEqual(1);

      // SVG should contain at least one node with class "node"
      const svgNodeCount = await page.locator('svg g.node').count();
      expect(svgNodeCount).toBeGreaterThanOrEqual(1);

      // Snapshot information should be present and snapshot total should be >= 0
      const snapTotal = await page.locator('#snapTotal').textContent();
      expect(Number(snapTotal)).toBeGreaterThanOrEqual(0);

      // Distance and next tables present
      await expect(page.locator('#distTableWrap table')).toBeVisible();
      await expect(page.locator('#nextTableWrap table')).toBeVisible();
    });
  });

  test.describe('Node and edge interactions', () => {
    test('can add a node via Add Node mode and updates node count', async ({ page }) => {
      // Capture initial count
      const before = Number(await page.locator('#nodeCount').textContent());

      // Activate Add Node and click near the center of SVG
      await page.click('#addNodeBtn');
      const svg = page.locator('#svg');
      const box = await svg.boundingBox();
      expect(box).toBeTruthy();
      // Click at center
      await page.mouse.click(box.x + box.width / 2, box.y + box.height / 2);
      await page.waitForTimeout(150);

      const after = Number(await page.locator('#nodeCount').textContent());
      expect(after).toBeGreaterThan(before);
    });

    test('can create an edge by clicking two nodes and dialog is handled', async ({ page }) => {
      // Ensure at least two nodes exist
      const nodes = page.locator('svg g.node');
      const count = await nodes.count();
      if (count < 2) {
        // Add nodes to reach 2
        await page.click('#addNodeBtn');
        const svg = page.locator('#svg');
        const box = await svg.boundingBox();
        await page.mouse.click(box.x + 40, box.y + 40);
        await page.waitForTimeout(50);
        await page.click('#addNodeBtn');
        await page.mouse.click(box.x + 80, box.y + 80);
        await page.waitForTimeout(50);
      }

      // Prepare to accept the prompt for weight
      page.on('dialog', async (dialog) => {
        // Accept weight "7" to create an edge
        await dialog.accept('7');
      });

      // Click first node (select), then second node to create edge
      await nodes.nth(0).click();
      await nodes.nth(1).click();
      // Small wait for edge to be added and DOM updated
      await page.waitForTimeout(200);

      // There should be at least one edge path element
      const edgePaths = page.locator('svg path.edge');
      const edgeCount = await edgePaths.count();
      expect(edgeCount).toBeGreaterThanOrEqual(1);

      // The label with weight "7" should appear somewhere in the edgeLabel texts
      const labels = page.locator('svg text.edgeLabel');
      const texts = await labels.allTextContents();
      expect(texts.some(t => t.trim() === '7')).toBeTruthy();
    });

    test('editing an edge weight via clicking edge triggers dialog and updates label', async ({ page }) => {
      // Ensure there is at least one edge to edit; if not, create one quickly
      let edgePaths = page.locator('svg path.edge');
      if ((await edgePaths.count()) === 0) {
        // create edge between two nodes
        const nodes = page.locator('svg g.node');
        const n = await nodes.count();
        if (n < 2) {
          // add two nodes
          await page.click('#addNodeBtn');
          const svg = page.locator('#svg');
          const box = await svg.boundingBox();
          await page.mouse.click(box.x + 30, box.y + 30);
          await page.waitForTimeout(30);
          await page.click('#addNodeBtn');
          await page.mouse.click(box.x + 80, box.y + 30);
          await page.waitForTimeout(30);
        }
        // add an edge via dialog
        page.on('dialog', async (dialog) => { await dialog.accept('2'); });
        await page.locator('svg g.node').nth(0).click();
        await page.locator('svg g.node').nth(1).click();
        await page.waitForTimeout(200);
        edgePaths = page.locator('svg path.edge');
      }

      // Edit first edge: when clicked, prompt appears, supply new weight "5"
      page.once('dialog', async (dialog) => {
        await dialog.accept('5');
      });
      await edgePaths.first().click({ force: true });
      await page.waitForTimeout(200);

      // Verify at least one label now has '5'
      const labels = page.locator('svg text.edgeLabel');
      const texts = await labels.allTextContents();
      expect(texts.some(t => t.trim() === '5')).toBeTruthy();
    });

    test('directed checkbox toggles and adding edge when undirected creates reverse edge', async ({ page }) => {
      // Clear graph to start deterministically
      await page.click('#clearBtn');
      await page.waitForTimeout(50);
      // Add two nodes
      await page.click('#addNodeBtn');
      const svg = page.locator('#svg');
      const box = await svg.boundingBox();
      await page.mouse.click(box.x + 40, box.y + 40);
      await page.waitForTimeout(30);
      await page.click('#addNodeBtn');
      await page.mouse.click(box.x + 100, box.y + 40);
      await page.waitForTimeout(100);

      // Uncheck directed to make graph undirected
      const directedCheckbox = page.locator('#directed');
      const isChecked = await directedCheckbox.isChecked();
      if (isChecked) await directedCheckbox.click();

      // Add an undirected edge between first and second node; accept weight '8'
      page.once('dialog', async (dialog) => await dialog.accept('8'));
      const nodes = page.locator('svg g.node');
      await nodes.nth(0).click();
      await nodes.nth(1).click();
      await page.waitForTimeout(150);

      // There should be at least 2 edge path elements (one in each direction)
      const edgePaths = page.locator('svg path.edge');
      const edgeCount = await edgePaths.count();
      expect(edgeCount).toBeGreaterThanOrEqual(2);

      // Re-check directed back to original state for other tests (defensive)
      if (!isChecked) await directedCheckbox.click();
    });
  });

  test.describe('Algorithm controls and snapshots', () => {
    test('run button computes snapshots and snapshots UI updates', async ({ page }) => {
      // Click run to compute snapshots
      await page.click('#runBtn');
      await page.waitForTimeout(200);

      // Snapshot total should be at least 0
      const total = Number(await page.locator('#snapTotal').textContent());
      expect(total).toBeGreaterThanOrEqual(0);

      // Snapshot index should be 0 after rendering
      const idx = Number(await page.locator('#snapIndex').textContent());
      expect(idx).toBe(0);

      // Snapshot info should contain text
      const info = (await page.locator('#snapshotInfo').textContent()).trim();
      expect(info.length).toBeGreaterThanOrEqual(0);
    });

    test('step forward and step back update snapshot index and matrix highlights', async ({ page }) => {
      // Ensure snapshots exist
      await page.click('#runBtn');
      await page.waitForTimeout(200);

      const total = Number(await page.locator('#snapTotal').textContent());
      if (total < 2) {
        // Not enough snapshots to test stepping; just assert we have some
        expect(total).toBeGreaterThanOrEqual(0);
        return;
      }

      const before = Number(await page.locator('#snapIndex').textContent());
      // Step forward
      await page.click('#stepForwardBtn');
      await page.waitForTimeout(100);
      const afterForward = Number(await page.locator('#snapIndex').textContent());
      expect(afterForward).toBeGreaterThanOrEqual(before);

      // Step back
      await page.click('#stepBackBtn');
      await page.waitForTimeout(100);
      const afterBack = Number(await page.locator('#snapIndex').textContent());
      // afterBack should be <= afterForward
      expect(afterBack).toBeGreaterThanOrEqual(0);
    });

    test('play and pause controls toggle and advance snapshots', async ({ page }) => {
      // Ensure snapshots exist
      await page.click('#runBtn');
      await page.waitForTimeout(100);

      // Set speed to minimum to progress faster
      const speed = page.locator('#speed');
      await speed.fill('200');

      // Click play
      await page.click('#playBtn');
      // Immediately play button disabled and pause enabled
      await expect(page.locator('#playBtn')).toBeDisabled();
      await expect(page.locator('#pauseBtn')).toBeEnabled();

      // Let it run briefly then pause
      await page.waitForTimeout(400);
      await page.click('#pauseBtn');
      await page.waitForTimeout(50);

      // After pause, play should be enabled again
      await expect(page.locator('#playBtn')).toBeEnabled();
      await expect(page.locator('#pauseBtn')).toBeDisabled();

      // Snapshot index should be some number >= 0
      const idx = Number(await page.locator('#snapIndex').textContent());
      expect(idx).toBeGreaterThanOrEqual(0);
    });

    test('show path displays a path summary or indicates no path', async ({ page }) => {
      // Ensure we have at least two nodes
      const nodes = page.locator('svg g.node');
      const count = await nodes.count();
      if (count < 2) {
        // add two nodes
        await page.click('#addNodeBtn');
        const svg = page.locator('#svg');
        const box = await svg.boundingBox();
        await page.mouse.click(box.x + 30, box.y + 30);
        await page.waitForTimeout(30);
        await page.click('#addNodeBtn');
        await page.mouse.click(box.x + 70, box.y + 30);
        await page.waitForTimeout(50);
      }

      // Run to ensure snapshots exist
      await page.click('#runBtn');
      await page.waitForTimeout(100);

      // Select from/to options (choose first and second options if present)
      const fromSelect = page.locator('#fromSelect');
      const toSelect = page.locator('#toSelect');
      const fromOptions = await fromSelect.locator('option').count();
      const toOptions = await toSelect.locator('option').count();
      if (fromOptions < 2 || toOptions < 2) {
        // Not enough options to meaningfully test; still click show path to validate no crash
        await page.click('#showPathBtn');
        const pd = await page.locator('#pathDisplay').textContent();
        expect(pd).toBeTruthy();
        return;
      }

      // Choose first and second options
      await fromSelect.selectOption({ index: 0 });
      await toSelect.selectOption({ index: 1 });
      await page.click('#showPathBtn');
      await page.waitForTimeout(100);

      const pathText = (await page.locator('#pathDisplay').textContent()).trim();
      // Should either show "Path:" or indicate "No path"
      expect(pathText.length).toBeGreaterThan(0);
      expect(pathText.includes('Path:') || pathText.includes('No path') || pathText.includes('No snapshot')).toBeTruthy();
    });
  });

  test.describe('Edge cases, clearing, and accessibility checks', () => {
    test('clear button resets graph and UI to empty state', async ({ page }) => {
      // Click clear
      await page.click('#clearBtn');
      await page.waitForTimeout(100);

      // Node count should be 0
      const nodeCount = Number(await page.locator('#nodeCount').textContent());
      expect(nodeCount).toBe(0);

      // Snapshot total should be 0 and tables cleared
      const snapTotal = Number(await page.locator('#snapTotal').textContent());
      expect(snapTotal).toBe(0);
      await expect(page.locator('#distTableWrap')).toBeEmpty();
      await expect(page.locator('#nextTableWrap')).toBeEmpty();
    });

    test('reset positions does not throw and updates node transforms when nodes exist', async ({ page }) => {
      // Ensure some nodes exist by generating a small random graph
      await page.click('#randomBtn');
      await page.waitForTimeout(150);
      const nodeCount = await page.locator('svg g.node').count();
      if (nodeCount === 0) {
        // add one node to meaningfully test resetPositions
        await page.click('#addNodeBtn');
        const svg = page.locator('#svg');
        const box = await svg.boundingBox();
        await page.mouse.click(box.x + 60, box.y + 60);
        await page.waitForTimeout(50);
      }

      // Click reset positions and ensure no errors occur (monitored by pageErrors/consoleErrors)
      await page.click('#resetPositions');
      await page.waitForTimeout(100);

      // Verify nodes have transform attributes (i.e., were repositioned/drawn)
      const transforms = await page.locator('svg g.node').first().getAttribute('transform');
      expect(transforms).toBeTruthy();
      expect(transforms).toMatch(/translate\(/);
    });

    test('accessibility: key interactive elements are focusable', async ({ page }) => {
      // Check that main buttons are in the document and can be focused
      const controls = ['#addNodeBtn', '#runBtn', '#playBtn', '#pauseBtn', '#clearBtn', '#randomBtn'];
      for (const sel of controls) {
        const el = page.locator(sel);
        await expect(el).toBeVisible();
        await el.focus();
        // focused element should be the expected one
        const activeId = await page.evaluate(() => document.activeElement && document.activeElement.id);
        // activeId might be empty for some elements but ensure no exception thrown and element exists
        const exists = await el.count();
        expect(exists).toBeGreaterThan(0);
      }
    });
  });
});