{
  "id": "d80c93e1-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:02.632Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Linear Regression",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Interactive Linear Regression Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root { --bg: #111827; --panel: #0f1724; --accent: #60a5fa; --muted: #9ca3af; --text: #e6eef8; }\n    html,body { height:100%; margin:0; font-family: Inter, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; background: linear-gradient(180deg,#071129 0%, #071228 55%, #061126 100%); color:var(--text); }\n    .container { display:flex; gap:18px; padding:18px; box-sizing:border-box; height:100%; }\n    .left { width:320px; min-width:280px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; padding:14px; box-shadow: 0 6px 20px rgba(2,6,23,0.6); overflow:auto; }\n    .right { flex:1; display:flex; flex-direction:column; gap:12px; }\n    h1 { font-size:18px; margin:4px 0 10px 0; color:var(--text); }\n    p.lead { margin:6px 0 14px 0; color:var(--muted); font-size:13px; line-height:1.35; }\n    .control-group { margin-bottom:12px; }\n    label { display:block; font-size:13px; color:var(--muted); margin-bottom:6px; }\n    input[type=\"range\"] { width:100%; }\n    .row { display:flex; gap:8px; align-items:center; }\n    button { background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--text); padding:8px 10px; border-radius:8px; cursor:pointer; font-size:13px; }\n    button.primary { background:linear-gradient(90deg,var(--accent),#7dd3fc20); border:1px solid rgba(96,165,250,0.18); }\n    .small { font-size:12px; color:var(--muted); }\n    .stats { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:6px; }\n    .stat { background:rgba(255,255,255,0.02); padding:8px; border-radius:8px; font-size:13px; }\n    canvas { background:linear-gradient(180deg,#071735 0%, #05203a 100%); border-radius:12px; box-shadow: 0 8px 30px rgba(2,6,23,0.55); display:block; }\n    .legend { display:flex; gap:10px; align-items:center; margin-top:8px; color:var(--muted); font-size:13px; }\n    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }\n    .dot.points { background:#34d399; box-shadow:0 0 10px rgba(52,211,153,0.15); }\n    .dot.line { width:30px; height:3px; border-radius:3px; background:#60a5fa; display:inline-block; vertical-align:middle; box-shadow:0 0 10px rgba(96,165,250,0.12); }\n    .muted { color:var(--muted); font-size:13px; }\n    .hint { font-size:12px; color:var(--muted); margin-top:8px; }\n    .small-grid { display:flex; gap:6px; flex-wrap:wrap; }\n    .chip { background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:8px; font-size:13px; border:1px solid rgba(255,255,255,0.03); }\n    .footer { margin-top:8px; font-size:12px; color:var(--muted); }\n    input[type=\"number\"] { width:100%; padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); background:transparent; color:var(--text); }\n    .btn-row { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }\n    .toggle { display:inline-flex; gap:6px; align-items:center; font-size:13px; color:var(--muted); }\n    .linklike { text-decoration:underline; cursor:pointer; color:var(--accent); }\n    .credits { font-size:12px; color:var(--muted); margin-top:10px; }\n    @media (max-width:900px) {\n      .container { flex-direction:column; padding:12px; }\n      .left { width:100%; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"left\">\n      <h1>Linear Regression — Interactive Demo</h1>\n      <p class=\"lead\">Add points by clicking the plot. Drag to move them. Fit a line using the closed‑form solution (least squares) or gradient descent, visualize residuals and watch the loss.</p>\n\n      <div class=\"control-group\">\n        <label>Data: generate random points</label>\n        <div class=\"row\" style=\"gap:8px;\">\n          <input id=\"numPoints\" type=\"range\" min=\"3\" max=\"80\" value=\"25\" />\n          <div class=\"chip small\" id=\"numPointsVal\">25</div>\n        </div>\n        <div class=\"row\" style=\"margin-top:8px;\">\n          <div style=\"flex:1\">\n            <label class=\"small\">True slope</label>\n            <input id=\"trueSlope\" type=\"range\" min=\"-3\" max=\"3\" step=\"0.1\" value=\"0.8\" />\n          </div>\n          <div style=\"width:90px; display:flex; align-items:center;\">\n            <div class=\"chip\" id=\"trueSlopeVal\">0.8</div>\n          </div>\n        </div>\n\n        <div class=\"row\" style=\"margin-top:8px;\">\n          <div style=\"flex:1\">\n            <label class=\"small\">True intercept</label>\n            <input id=\"trueIntercept\" type=\"range\" min=\"-40\" max=\"40\" step=\"1\" value=\"10\" />\n          </div>\n          <div style=\"width:90px; display:flex; align-items:center;\">\n            <div class=\"chip\" id=\"trueInterceptVal\">10</div>\n          </div>\n        </div>\n\n        <div class=\"row\" style=\"margin-top:8px;\">\n          <div style=\"flex:1\">\n            <label class=\"small\">Noise (std dev)</label>\n            <input id=\"noise\" type=\"range\" min=\"0\" max=\"30\" step=\"0.5\" value=\"8\" />\n          </div>\n          <div style=\"width:90px; display:flex; align-items:center;\">\n            <div class=\"chip\" id=\"noiseVal\">8</div>\n          </div>\n        </div>\n\n        <div class=\"btn-row\" style=\"margin-top:10px;\">\n          <button id=\"randBtn\" class=\"primary\">Generate Random Data</button>\n          <button id=\"clearBtn\">Clear Points</button>\n          <button id=\"undoBtn\">Undo</button>\n        </div>\n      </div>\n\n      <div class=\"control-group\">\n        <label>Fitting</label>\n        <div class=\"btn-row\">\n          <button id=\"fitClosed\">Fit (Closed form)</button>\n          <button id=\"fitGD\">Fit (Gradient Descent)</button>\n          <button id=\"startStopGD\">Start GD</button>\n          <button id=\"stepGD\">Step GD</button>\n        </div>\n\n        <div style=\"margin-top:10px;\">\n          <label class=\"small\">Gradient descent settings</label>\n          <div class=\"row\">\n            <div style=\"flex:1\">\n              <input id=\"lr\" type=\"range\" min=\"0.0005\" max=\"0.5\" step=\"0.0005\" value=\"0.02\" />\n            </div>\n            <div style=\"width:100px;\">\n              <div class=\"chip\" id=\"lrVal\">0.020</div>\n            </div>\n          </div>\n\n          <div style=\"margin-top:8px;\" class=\"row\">\n            <div style=\"flex:1\">\n              <label class=\"small\">Epochs per \"fit GD\" run</label>\n              <input id=\"epochs\" type=\"range\" min=\"1\" max=\"1000\" step=\"1\" value=\"200\" />\n            </div>\n            <div style=\"width:80px;\">\n              <div class=\"chip\" id=\"epochsVal\">200</div>\n            </div>\n          </div>\n        </div>\n\n        <div style=\"margin-top:10px;\" class=\"row\">\n          <label class=\"toggle\"><input id=\"showResiduals\" type=\"checkbox\" checked /> <span style=\"margin-left:6px;\">Show residual lines</span></label>\n        </div>\n      </div>\n\n      <div class=\"control-group\">\n        <label>Statistics</label>\n        <div class=\"stats\">\n          <div class=\"stat\"><div class=\"small muted\">Slope (m)</div><div id=\"statSlope\">—</div></div>\n          <div class=\"stat\"><div class=\"small muted\">Intercept (b)</div><div id=\"statIntercept\">—</div></div>\n          <div class=\"stat\"><div class=\"small muted\">MSE</div><div id=\"statMSE\">—</div></div>\n          <div class=\"stat\"><div class=\"small muted\">R²</div><div id=\"statR2\">—</div></div>\n        </div>\n      </div>\n\n      <div class=\"footer\">\n        <div class=\"muted\">How to use:</div>\n        <ol style=\"padding-left:18px; margin:6px 0 0 0; color:var(--muted); font-size:13px;\">\n          <li>Click the plot to add points. Drag points to modify them.</li>\n          <li>Use \"Generate Random Data\" to make a noisy linear dataset.</li>\n          <li>\"Fit (Closed form)\" computes the exact least-squares line.</li>\n          <li>\"Fit (Gradient Descent)\" runs iterative fitting; start/stop to animate.</li>\n        </ol>\n        <div class=\"credits\">Built-in demo — no external libraries.</div>\n      </div>\n    </div>\n\n    <div class=\"right\">\n      <canvas id=\"plot\" width=\"900\" height=\"520\"></canvas>\n      <div style=\"display:flex; gap:12px; align-items:center; justify-content:space-between;\">\n        <div class=\"legend\">\n          <span class=\"dot points\"></span><span class=\"muted\">Points</span>\n          <span style=\"width:16px\"></span>\n          <span class=\"dot line\"></span><span class=\"muted\">Fitted line</span>\n        </div>\n        <div class=\"muted\">Click points to add, drag to move. Zoom/pan not supported.</div>\n      </div>\n      <canvas id=\"loss\" width=\"900\" height=\"150\"></canvas>\n    </div>\n  </div>\n\n  <script>\n    // Data and model\n    const plot = document.getElementById('plot');\n    const lossCanvas = document.getElementById('loss');\n    const ctx = plot.getContext('2d');\n    const lctx = lossCanvas.getContext('2d');\n\n    let points = []; // {x,y} in data coords\n    let history = []; // for undo\n    let m = 0, b = 0; // model: y = m*x + b\n    let lossHistory = [];\n    let gdRunning = false;\n    let gdAnimationId = null;\n    let gdIteration = 0;\n\n    // Data coordinate window\n    const dataXMin = 0, dataXMax = 100;\n    const dataYMin = -60, dataYMax = 140;\n\n    // UI elements\n    const numPoints = document.getElementById('numPoints');\n    const numPointsVal = document.getElementById('numPointsVal');\n    const trueSlope = document.getElementById('trueSlope');\n    const trueSlopeVal = document.getElementById('trueSlopeVal');\n    const trueIntercept = document.getElementById('trueIntercept');\n    const trueInterceptVal = document.getElementById('trueInterceptVal');\n    const noise = document.getElementById('noise');\n    const noiseVal = document.getElementById('noiseVal');\n    const randBtn = document.getElementById('randBtn');\n    const clearBtn = document.getElementById('clearBtn');\n    const undoBtn = document.getElementById('undoBtn');\n    const fitClosed = document.getElementById('fitClosed');\n    const fitGD = document.getElementById('fitGD');\n    const startStopGD = document.getElementById('startStopGD');\n    const stepGD = document.getElementById('stepGD');\n    const lr = document.getElementById('lr');\n    const lrVal = document.getElementById('lrVal');\n    const epochs = document.getElementById('epochs');\n    const epochsVal = document.getElementById('epochsVal');\n    const showResiduals = document.getElementById('showResiduals');\n\n    const statSlope = document.getElementById('statSlope');\n    const statIntercept = document.getElementById('statIntercept');\n    const statMSE = document.getElementById('statMSE');\n    const statR2 = document.getElementById('statR2');\n\n    // Helpers: data<->canvas transforms\n    function xToCanvas(x) {\n      const pad = 40;\n      const w = plot.width - pad*2;\n      return pad + ((x - dataXMin) / (dataXMax - dataXMin)) * w;\n    }\n    function yToCanvas(y) {\n      const pad = 40;\n      const h = plot.height - pad*2;\n      // y increases downwards on canvas, but data y increases upwards\n      return pad + (1 - (y - dataYMin) / (dataYMax - dataYMin)) * h;\n    }\n    function canvasToData(cx, cy) {\n      const pad = 40;\n      const w = plot.width - pad*2;\n      const h = plot.height - pad*2;\n      const x = dataXMin + ((cx - pad) / w) * (dataXMax - dataXMin);\n      const y = dataYMin + (1 - ((cy - pad) / h)) * (dataYMax - dataYMin);\n      return {x,y};\n    }\n\n    // Drawing\n    function clearPlot() {\n      ctx.clearRect(0,0,plot.width,plot.height);\n      // background gradient (already CSS) - we still draw axes grid\n      // draw grid lines\n      ctx.save();\n      ctx.globalAlpha = 0.15;\n      ctx.strokeStyle = '#8ab4ff';\n      ctx.lineWidth = 1;\n      // vertical ticks at 0,20,40,60,80,100\n      for (let gx = 0; gx <= 100; gx += 20) {\n        const cx = xToCanvas(gx);\n        ctx.beginPath();\n        ctx.moveTo(cx, 20);\n        ctx.lineTo(cx, plot.height - 20);\n        ctx.stroke();\n      }\n      // horizontal ticks at -40,-20,0,20,40,60,80,100,120\n      for (let gy = -40; gy <= 120; gy += 20) {\n        const cy = yToCanvas(gy);\n        ctx.beginPath();\n        ctx.moveTo(20, cy);\n        ctx.lineTo(plot.width - 20, cy);\n        ctx.stroke();\n      }\n      ctx.restore();\n\n      // axes labels\n      ctx.fillStyle = '#cbd5e1';\n      ctx.font = '12px system-ui, Arial';\n      ctx.textAlign = 'center';\n      for (let gx = 0; gx <= 100; gx += 20) {\n        const cx = xToCanvas(gx);\n        ctx.fillText(gx.toString(), cx, plot.height - 18);\n      }\n      ctx.textAlign = 'right';\n      for (let gy = -40; gy <= 120; gy += 20) {\n        const cy = yToCanvas(gy);\n        ctx.fillText(gy.toString(), 36, cy + 4);\n      }\n    }\n\n    function drawPointsAndLine() {\n      clearPlot();\n\n      // Draw residuals first if enabled\n      if (showResiduals.checked && points.length >= 1) {\n        ctx.strokeStyle = 'rgba(255,255,255,0.12)';\n        ctx.lineWidth = 1.6;\n        for (const p of points) {\n          const xC = xToCanvas(p.x), yC = yToCanvas(p.y);\n          const predY = m * p.x + b;\n          const yPC = yToCanvas(predY);\n          ctx.beginPath();\n          ctx.moveTo(xC, yC);\n          ctx.lineTo(xC, yPC);\n          ctx.stroke();\n        }\n      }\n\n      // Draw line (fitted)\n      if (points.length >= 2) {\n        const xA = dataXMin, xB = dataXMax;\n        const yA = m * xA + b;\n        const yB = m * xB + b;\n        const cAx = xToCanvas(xA), cAy = yToCanvas(yA);\n        const cBx = xToCanvas(xB), cBy = yToCanvas(yB);\n        ctx.strokeStyle = '#60a5fa';\n        ctx.lineWidth = 2.6;\n        ctx.beginPath();\n        ctx.moveTo(cAx, cAy);\n        ctx.lineTo(cBx, cBy);\n        ctx.stroke();\n      }\n\n      // Draw points\n      for (const p of points) {\n        const x = xToCanvas(p.x);\n        const y = yToCanvas(p.y);\n        ctx.beginPath();\n        ctx.fillStyle = '#10b981';\n        ctx.strokeStyle = 'rgba(255,255,255,0.12)';\n        ctx.lineWidth = 1;\n        ctx.arc(x, y, 6, 0, Math.PI*2);\n        ctx.fill();\n        ctx.stroke();\n      }\n    }\n\n    // Compute stats\n    function computeClosedForm() {\n      const n = points.length;\n      if (n < 2) return null;\n      const xs = points.map(p=>p.x);\n      const ys = points.map(p=>p.y);\n      const meanX = xs.reduce((a,b)=>a+b,0)/n;\n      const meanY = ys.reduce((a,b)=>a+b,0)/n;\n      let num = 0, den = 0;\n      for (let i=0;i<n;i++){\n        num += (xs[i]-meanX)*(ys[i]-meanY);\n        den += (xs[i]-meanX)*(xs[i]-meanX);\n      }\n      const mm = den === 0 ? 0 : num/den;\n      const bb = meanY - mm*meanX;\n      return {m:mm,b:bb};\n    }\n\n    function computeMSE(m_, b_) {\n      if (points.length === 0) return Infinity;\n      let sse = 0;\n      for (const p of points) {\n        const e = p.y - (m_ * p.x + b_);\n        sse += e*e;\n      }\n      return sse / points.length;\n    }\n\n    function computeR2(m_, b_) {\n      if (points.length === 0) return NaN;\n      const ys = points.map(p=>p.y);\n      const meanY = ys.reduce((a,b)=>a+b,0)/ys.length;\n      let sst = 0, sse = 0;\n      for (const p of points) {\n        sst += (p.y - meanY)**2;\n        sse += (p.y - (m_*p.x + b_))**2;\n      }\n      return 1 - (sse / sst || 1);\n    }\n\n    // Fit closed form\n    function fitClosedForm() {\n      const res = computeClosedForm();\n      if (!res) return;\n      m = res.m;\n      b = res.b;\n      lossHistory = [];\n      updateStats();\n      drawPointsAndLine();\n      drawLoss();\n    }\n\n    // Gradient descent functions\n    function gdStep(lrate) {\n      const n = points.length;\n      if (n === 0) return;\n      // compute gradients\n      let dM = 0, dB = 0;\n      for (const p of points) {\n        const pred = m * p.x + b;\n        const err = pred - p.y; // derivative of mse wrt pred is 2*(pred - y)/n but we can absorb 2 into lr\n        dM += err * p.x;\n        dB += err;\n      }\n      // average gradients, multiply by 2/n to match MSE gradient (we'll use that scale)\n      dM = (2/n) * dM;\n      dB = (2/n) * dB;\n      m = m - lrate * dM;\n      b = b - lrate * dB;\n      const mse = computeMSE(m,b);\n      lossHistory.push(mse);\n      gdIteration++;\n    }\n\n    function fitGD(epochsCount, lrate, animate=false) {\n      if (points.length === 0) return;\n      // If no initialization yet, start near closed form for faster convergence\n      const cf = computeClosedForm();\n      if (cf) { m = cf.m; b = cf.b; }\n      if (!animate) {\n        for (let e=0;e<epochsCount;e++) gdStep(lrate);\n        updateStats();\n        drawPointsAndLine();\n        drawLoss();\n      } else {\n        // animated: spawn iterative loop handled by startStopGD\n        gdRunning = true;\n        startStopGD.innerText = \"Stop GD\";\n        // ensure we have loss history and iteration\n        for (let i=0;i<epochsCount;i++) {\n          if (!gdRunning) break;\n          gdStep(lrate);\n        }\n        updateStats();\n        drawPointsAndLine();\n        drawLoss();\n      }\n    }\n\n    // Draw loss curve\n    function drawLoss() {\n      lctx.clearRect(0,0,lossCanvas.width,lossCanvas.height);\n      lctx.fillStyle = '#0b1220';\n      lctx.fillRect(0,0,lossCanvas.width,lossCanvas.height);\n      if (lossHistory.length === 0) {\n        lctx.fillStyle = '#93c5fd';\n        lctx.font = '12px system-ui';\n        lctx.fillText('No loss history yet (run gradient descent or press \"Fit (Gradient Descent)\")', 12, 24);\n        return;\n      }\n      const pad = 30;\n      // axes\n      lctx.strokeStyle = 'rgba(255,255,255,0.06)';\n      lctx.lineWidth = 1;\n      lctx.beginPath();\n      lctx.moveTo(pad, pad);\n      lctx.lineTo(pad, lossCanvas.height - pad);\n      lctx.lineTo(lossCanvas.width - pad, lossCanvas.height - pad);\n      lctx.stroke();\n\n      const maxLoss = Math.max(...lossHistory);\n      const minLoss = Math.min(...lossHistory);\n      const range = Math.max(1e-8, maxLoss - minLoss);\n      const w = lossCanvas.width - pad*2;\n      const h = lossCanvas.height - pad*2;\n\n      // draw curve\n      lctx.beginPath();\n      lctx.strokeStyle = '#60a5fa';\n      lctx.lineWidth = 2;\n      for (let i=0;i<lossHistory.length;i++){\n        const x = pad + (i / (lossHistory.length-1 || 1)) * w;\n        const y = pad + (1 - (lossHistory[i] - minLoss)/range) * h;\n        if (i===0) lctx.moveTo(x,y); else lctx.lineTo(x,y);\n      }\n      lctx.stroke();\n\n      lctx.fillStyle = '#9ca3af';\n      lctx.font = '12px system-ui';\n      lctx.textAlign = 'left';\n      lctx.fillText('Loss (MSE) over iterations', pad, 14);\n\n      // latest value\n      lctx.textAlign = 'right';\n      lctx.fillStyle = '#c7d2fe';\n      lctx.fillText('Latest: ' + (lossHistory[lossHistory.length-1]).toFixed(3), lossCanvas.width - pad, 14);\n    }\n\n    // Update stats UI\n    function updateStats() {\n      if (points.length < 1) {\n        statSlope.innerText = '—';\n        statIntercept.innerText = '—';\n        statMSE.innerText = '—';\n        statR2.innerText = '—';\n        return;\n      }\n      statSlope.innerText = m.toFixed(4);\n      statIntercept.innerText = b.toFixed(4);\n      const mse = computeMSE(m,b);\n      statMSE.innerText = mse.toFixed(4);\n      const r2 = computeR2(m,b);\n      statR2.innerText = (isFinite(r2) ? r2.toFixed(4) : '—');\n    }\n\n    // UI wiring\n    numPoints.addEventListener('input', ()=>{ numPointsVal.innerText = numPoints.value; });\n    trueSlope.addEventListener('input', ()=>{ trueSlopeVal.innerText = trueSlope.value; });\n    trueIntercept.addEventListener('input', ()=>{ trueInterceptVal.innerText = trueIntercept.value; });\n    noise.addEventListener('input', ()=>{ noiseVal.innerText = noise.value; });\n    lr.addEventListener('input', ()=>{ lrVal.innerText = Number(lr.value).toFixed(3); });\n    epochs.addEventListener('input', ()=>{ epochsVal.innerText = epochs.value; });\n\n    randBtn.addEventListener('click', ()=>{\n      history.push(JSON.stringify(points));\n      generateRandomData(Number(numPoints.value), Number(trueSlope.value), Number(trueIntercept.value), Number(noise.value));\n      lossHistory = [];\n      updateStats();\n      drawPointsAndLine();\n      drawLoss();\n    });\n\n    clearBtn.addEventListener('click', ()=>{\n      history.push(JSON.stringify(points));\n      points = [];\n      lossHistory = [];\n      updateStats();\n      drawPointsAndLine();\n      drawLoss();\n    });\n\n    undoBtn.addEventListener('click', ()=>{\n      if (history.length === 0) return;\n      const prev = history.pop();\n      points = JSON.parse(prev);\n      lossHistory = [];\n      updateStats();\n      drawPointsAndLine();\n      drawLoss();\n    });\n\n    fitClosed.addEventListener('click', ()=>{\n      if (points.length < 2) return;\n      history.push(JSON.stringify(points));\n      fitClosedForm();\n    });\n\n    fitGD.addEventListener('click', ()=>{\n      if (points.length < 1) return;\n      history.push(JSON.stringify(points));\n      const ep = Number(epochs.value);\n      const lrate = Number(lr.value);\n      // If too many epochs, run in short chunks to keep UI responsive\n      if (ep > 1000) {\n        fitGD(ep, lrate, false);\n      } else {\n        fitGD(ep, lrate, false);\n      }\n    });\n\n    startStopGD.addEventListener('click', ()=>{\n      if (gdRunning) {\n        gdRunning = false;\n        startStopGD.innerText = \"Start GD\";\n        if (gdAnimationId) cancelAnimationFrame(gdAnimationId);\n      } else {\n        if (points.length < 1) return;\n        gdRunning = true;\n        startStopGD.innerText = \"Stop GD\";\n        // initialize near closed form for better start\n        const cf = computeClosedForm();\n        if (cf) { m = cf.m; b = cf.b; }\n        animateGD();\n      }\n    });\n\n    stepGD.addEventListener('click', ()=>{\n      if (points.length < 1) return;\n      history.push(JSON.stringify(points));\n      gdRunning = false;\n      startStopGD.innerText = \"Start GD\";\n      const lrate = Number(lr.value);\n      gdStep(lrate);\n      updateStats();\n      drawPointsAndLine();\n      drawLoss();\n    });\n\n    function animateGD() {\n      if (!gdRunning) return;\n      // perform a small number of steps per frame to speed things up slightly\n      const stepsPerFrame = 3;\n      const lrate = Number(lr.value);\n      for (let i=0;i<stepsPerFrame;i++){\n        gdStep(lrate);\n      }\n      updateStats();\n      drawPointsAndLine();\n      drawLoss();\n      gdAnimationId = requestAnimationFrame(animateGD);\n    }\n\n    // Generate synthetic data\n    function generateRandomData(n, slope, intercept, noiseStd) {\n      points = [];\n      for (let i=0;i<n;i++){\n        const x = Math.random() * (dataXMax - dataXMin) + dataXMin;\n        const ideal = slope * x + intercept;\n        const y = ideal + gaussianRandom()*noiseStd;\n        points.push({x,y});\n      }\n      // shuffle a bit\n      points.sort(()=>Math.random()-0.5);\n    }\n\n    // Gaussian random using Box-Muller\n    function gaussianRandom() {\n      let u = 0, v = 0;\n      while(u === 0) u = Math.random();\n      while(v === 0) v = Math.random();\n      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n    }\n\n    // Mouse interactions: add, drag points\n    let draggingIndex = -1;\n    let dragOffset = {dx:0, dy:0};\n\n    plot.addEventListener('mousedown', (e)=>{\n      const rect = plot.getBoundingClientRect();\n      const cx = e.clientX - rect.left;\n      const cy = e.clientY - rect.top;\n      // check if clicking near an existing point\n      let foundIndex = -1;\n      for (let i=0;i<points.length;i++){\n        const px = xToCanvas(points[i].x), py = yToCanvas(points[i].y);\n        const dx = px - cx, dy = py - cy;\n        if (Math.sqrt(dx*dx + dy*dy) < 10) { foundIndex = i; break; }\n      }\n      if (foundIndex >= 0) {\n        // start dragging\n        draggingIndex = foundIndex;\n        dragOffset.dx = xToCanvas(points[foundIndex].x) - cx;\n        dragOffset.dy = yToCanvas(points[foundIndex].y) - cy;\n      } else {\n        // add new point\n        history.push(JSON.stringify(points));\n        const d = canvasToData(cx, cy);\n        points.push({x:d.x, y:d.y});\n        updateStats();\n        drawPointsAndLine();\n        drawLoss();\n      }\n    });\n\n    window.addEventListener('mousemove', (e)=>{\n      if (draggingIndex === -1) return;\n      const rect = plot.getBoundingClientRect();\n      const cx = e.clientX - rect.left + dragOffset.dx;\n      const cy = e.clientY - rect.top + dragOffset.dy;\n      const d = canvasToData(cx, cy);\n      points[draggingIndex].x = Math.min(dataXMax, Math.max(dataXMin, d.x));\n      points[draggingIndex].y = Math.min(dataYMax, Math.max(dataYMin, d.y));\n      updateStats();\n      drawPointsAndLine();\n      drawLoss();\n    });\n\n    window.addEventListener('mouseup', ()=>{ draggingIndex = -1; });\n\n    // Initial render\n    generateRandomData(25, Number(trueSlope.value), Number(trueIntercept.value), Number(noise.value));\n    fitClosedForm(); // initialize line\n    drawPointsAndLine();\n    drawLoss();\n    updateStats();\n\n    // Keyboard shortcuts\n    window.addEventListener('keydown', (e)=>{\n      if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {\n        if (history.length) {\n          const prev = history.pop();\n          points = JSON.parse(prev);\n          updateStats();\n          drawPointsAndLine();\n          drawLoss();\n        }\n      }\n    });\n\n    // Resize handling for crispness on high-DPI screens\n    function resizeCanvases() {\n      [plot, lossCanvas].forEach(c => {\n        const ratio = window.devicePixelRatio || 1;\n        const styleW = parseInt(getComputedStyle(c).width, 10) || c.width;\n        const styleH = parseInt(getComputedStyle(c).height, 10) || c.height;\n        c.width = Math.max(300, Math.floor(styleW * ratio));\n        c.height = Math.max(150, Math.floor(styleH * ratio));\n        const ctx2 = c.getContext('2d');\n        ctx2.setTransform(ratio,0,0,ratio,0,0);\n      });\n      drawPointsAndLine();\n      drawLoss();\n    }\n    // initial size set to CSS pixel sizes\n    plot.style.width = '100%';\n    plot.style.height = '520px';\n    lossCanvas.style.width = '100%';\n    lossCanvas.style.height = '150px';\n    window.addEventListener('resize', resizeCanvases);\n    resizeCanvases();\n\n    // Small precaution: stop GD when leaving page\n    window.addEventListener('beforeunload', ()=>{ gdRunning = false; });\n\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Linear Regression"
    }
  ],
  "topic": "Linear Regression",
  "hasFSM": false,
  "hasTest": true
}