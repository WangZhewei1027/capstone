{
  "id": "d80b5b60-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:21.858Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<title>Dijkstra's Algorithm Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<style>\n  :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;margin:0}\n  body{display:flex;flex-direction:column;height:100vh;gap:8px;background:#f5f7fb;color:#111;margin:0;padding:12px;}\n  header{display:flex;align-items:center;gap:12px}\n  h1{font-size:18px;margin:0}\n  #app{display:flex;flex:1;gap:12px;min-height:0}\n  #canvasPane{flex:1; background:white;border:1px solid #d8dbe0;border-radius:8px;position:relative;overflow:hidden}\n  svg{width:100%;height:100%;display:block}\n  .controls{width:360px;display:flex;flex-direction:column;gap:8px}\n  .panel{background:white;border:1px solid #d8dbe0;border-radius:8px;padding:12px;overflow:auto;max-height:60vh}\n  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n  button{background:#1f6feb;color:white;border:0;padding:8px 10px;border-radius:6px;cursor:pointer}\n  button.secondary{background:#e6eefc;color:#1f2a44}\n  button.warn{background:#ff6b6b}\n  .modeBtn{background:#eaf1ff;color:#1f2a44;border:1px solid #d0e0ff}\n  select,input[type=number]{padding:6px;border-radius:6px;border:1px solid #cfd8e3}\n  .small{font-size:13px;padding:6px 8px}\n  .instructions{font-size:13px;color:#445;line-height:1.2}\n  #log{font-family:monospace;font-size:12px;height:150px;overflow:auto;background:#0f1720;color:#e6fffa;padding:8px;border-radius:6px}\n  .nodeCircle{stroke:#1f2a44;stroke-width:1.5px;cursor:pointer}\n  .edgeLine{stroke:#9aa6b2;stroke-width:2px;cursor:default}\n  .edgeWeight{fill:#1f2a44;font-size:12px;user-select:none}\n  .nodeLabel{fill:white;font-weight:600;pointer-events:none;font-size:12px}\n  .distLabel{font-family:monospace;font-size:11px;fill:#072044;pointer-events:none}\n  .visited{fill:#94d4a4}\n  .current{fill:#ffd47a}\n  .frontier{fill:#9ec5ff}\n  .unvisited{fill:#d1d9e6}\n  .arrow{fill:#9aa6b2}\n  .smallMuted{font-size:12px;color:#556}\n  table{width:100%;border-collapse:collapse}\n  th,td{padding:6px;border-bottom:1px solid #eef2f7;text-align:left;font-size:13px}\n  #pqList{font-family:monospace;font-size:13px;background:#fff;padding:8px;border-radius:6px;border:1px solid #e6eefc;height:100px;overflow:auto}\n  .kbd{background:#f1f5f9;border-radius:4px;padding:2px 6px;font-size:12px;border:1px solid #e2e8f0}\n  footer{font-size:12px;color:#466;padding-top:4px}\n</style>\n</head>\n<body>\n<header>\n  <h1>Dijkstra's Algorithm — Interactive Demo</h1>\n  <div class=\"smallMuted\">Create a graph, pick a start node, and step through the algorithm.</div>\n</header>\n\n<div id=\"app\">\n  <div id=\"canvasPane\">\n    <svg id=\"svg\"></svg>\n  </div>\n\n  <div class=\"controls\">\n    <div class=\"panel\">\n      <div class=\"row\">\n        <button id=\"modeAddNode\" class=\"modeBtn\">Add Node</button>\n        <button id=\"modeAddEdge\" class=\"modeBtn\">Add Edge</button>\n        <button id=\"modeDrag\" class=\"modeBtn\">Move</button>\n        <button id=\"modeDelete\" class=\"modeBtn\">Delete</button>\n      </div>\n      <div class=\"row\" style=\"margin-top:8px\">\n        <label class=\"smallMuted\">Start:</label>\n        <select id=\"startSelect\"></select>\n        <label class=\"smallMuted\">Target (optional):</label>\n        <select id=\"targetSelect\">\n          <option value=\"\">None</option>\n        </select>\n      </div>\n\n      <div style=\"border-top:1px dashed #eef2f7;margin-top:8px;padding-top:8px\">\n        <div class=\"row\">\n          <button id=\"stepBtn\">Step</button>\n          <button id=\"runBtn\">Auto</button>\n          <button id=\"pauseBtn\" class=\"secondary\">Pause</button>\n          <button id=\"resetBtn\" class=\"secondary\">Reset</button>\n        </div>\n        <div class=\"row\" style=\"margin-top:8px\">\n          <button id=\"clearBtn\" class=\"warn\">Clear Graph</button>\n          <button id=\"exampleBtn\" class=\"secondary\">Load Example Graph</button>\n        </div>\n      </div>\n\n      <div style=\"border-top:1px dashed #eef2f7;margin-top:8px;padding-top:8px\">\n        <div class=\"smallMuted\">Edge creation: click source then target and enter non-negative weight.</div>\n        <div class=\"smallMuted\">You can drag nodes to reposition them. When ready, choose a start and run.</div>\n        <div style=\"margin-top:8px\" class=\"row\">\n          <label class=\"smallMuted\">Auto delay (ms):</label>\n          <input id=\"delayInput\" type=\"number\" value=\"700\" min=\"50\" style=\"width:80px\"/>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div style=\"font-weight:600\">Algorithm State</div>\n      <div class=\"row\" style=\"margin-top:8px\">\n        <div style=\"flex:1\">\n          <div class=\"smallMuted\">Distances and predecessors</div>\n          <table id=\"stateTable\">\n            <thead><tr><th>Node</th><th>Dist</th><th>Prev</th></tr></thead>\n            <tbody></tbody>\n          </table>\n        </div>\n      </div>\n\n      <div style=\"margin-top:8px\">\n        <div class=\"smallMuted\">Priority Queue (min by dist)</div>\n        <div id=\"pqList\"></div>\n      </div>\n\n      <div style=\"margin-top:8px\">\n        <div class=\"smallMuted\">Console / Log</div>\n        <div id=\"log\"></div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<footer>Click \"Add Node\" then click canvas to add nodes. Use \"Add Edge\" then click source and target to create edges with weights. Dijkstra requires non-negative weights.</footer>\n\n<script>\n(() => {\n  // Utilities\n  const svg = document.getElementById('svg');\n  const NS = \"http://www.w3.org/2000/svg\";\n  const addNodeBtn = document.getElementById('modeAddNode');\n  const addEdgeBtn = document.getElementById('modeAddEdge');\n  const moveBtn = document.getElementById('modeDrag');\n  const delBtn = document.getElementById('modeDelete');\n  const stepBtn = document.getElementById('stepBtn');\n  const runBtn = document.getElementById('runBtn');\n  const pauseBtn = document.getElementById('pauseBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const exampleBtn = document.getElementById('exampleBtn');\n  const startSelect = document.getElementById('startSelect');\n  const targetSelect = document.getElementById('targetSelect');\n  const stateTableBody = document.querySelector('#stateTable tbody');\n  const pqList = document.getElementById('pqList');\n  const logEl = document.getElementById('log');\n  const delayInput = document.getElementById('delayInput');\n\n  let mode = 'move'; // addNode, addEdge, move, delete\n  const setMode = m => {\n    mode = m;\n    [addNodeBtn, addEdgeBtn, moveBtn, delBtn].forEach(b => b.classList.remove('modeBtnActive'));\n    if(m==='addNode') addNodeBtn.classList.add('modeBtnActive');\n    if(m==='addEdge') addEdgeBtn.classList.add('modeBtnActive');\n    if(m==='move') moveBtn.classList.add('modeBtnActive');\n    if(m==='delete') delBtn.classList.add('modeBtnActive');\n  };\n  setMode('move');\n\n  addNodeBtn.onclick = ()=>setMode('addNode');\n  addEdgeBtn.onclick = ()=>setMode('addEdge');\n  moveBtn.onclick = ()=>setMode('move');\n  delBtn.onclick = ()=>setMode('delete');\n\n  // Graph data\n  let nodes = []; // {id,x,y,label}\n  let edges = []; // {id,from,to,weight}\n  let nextNodeId = 1, nextEdgeId = 1;\n\n  // SVG groups\n  const defs = document.createElementNS(NS,'defs');\n  svg.appendChild(defs);\n  // arrow marker\n  const marker = document.createElementNS(NS,'marker');\n  marker.setAttribute('id','arrow');\n  marker.setAttribute('viewBox','0 0 10 10');\n  marker.setAttribute('markerWidth','6');\n  marker.setAttribute('markerHeight','6');\n  marker.setAttribute('refX','10');\n  marker.setAttribute('refY','5');\n  marker.setAttribute('orient','auto-start-reverse');\n  const path = document.createElementNS(NS,'path');\n  path.setAttribute('d','M 0 0 L 10 5 L 0 10 z');\n  path.setAttribute('fill','#9aa6b2');\n  marker.appendChild(path);\n  defs.appendChild(marker);\n\n  const edgeLayer = document.createElementNS(NS,'g'); svg.appendChild(edgeLayer);\n  const nodeLayer = document.createElementNS(NS,'g'); svg.appendChild(nodeLayer);\n  const uiLayer = document.createElementNS(NS,'g'); svg.appendChild(uiLayer); // for overlays if needed\n\n  // Rendering helpers\n  function clearSVG() {\n    while(edgeLayer.firstChild) edgeLayer.removeChild(edgeLayer.firstChild);\n    while(nodeLayer.firstChild) nodeLayer.removeChild(nodeLayer.firstChild);\n  }\n\n  function render() {\n    clearSVG();\n    // edges\n    for(const e of edges){\n      const n1 = nodes.find(n=>n.id===e.from);\n      const n2 = nodes.find(n=>n.id===e.to);\n      if(!n1||!n2) continue;\n      // line\n      const g = document.createElementNS(NS,'g');\n      const line = document.createElementNS(NS,'line');\n      line.setAttribute('x1',n1.x); line.setAttribute('y1',n1.y);\n      line.setAttribute('x2',n2.x); line.setAttribute('y2',n2.y);\n      line.setAttribute('class','edgeLine');\n      line.setAttribute('marker-end','url(#arrow)');\n      g.appendChild(line);\n      // weight label: midpoint + small offset\n      const mx = (n1.x+n2.x)/2, my = (n1.y+n2.y)/2;\n      const text = document.createElementNS(NS,'text');\n      text.setAttribute('x', mx + 8);\n      text.setAttribute('y', my - 6);\n      text.setAttribute('class','edgeWeight');\n      text.textContent = e.weight;\n      g.appendChild(text);\n      edgeLayer.appendChild(g);\n      // clickable edge for deletion\n      line.dataset.edgeId = e.id;\n      line.addEventListener('click', ev => {\n        ev.stopPropagation();\n        if(mode==='delete'){\n          if(confirm('Delete this edge?')) {\n            edges = edges.filter(x=>x.id!==e.id);\n            log(`Edge ${e.id} deleted`);\n            render();\n            updateSelectors();\n            resetAlgorithmState();\n          }\n        }\n      });\n    }\n\n    // nodes\n    for(const n of nodes){\n      const g = document.createElementNS(NS,'g');\n      g.setAttribute('transform', `translate(${n.x},${n.y})`);\n      // circle\n      const circle = document.createElementNS(NS,'circle');\n      circle.setAttribute('r', 22);\n      circle.setAttribute('class','nodeCircle unvisited');\n      circle.setAttribute('fill','#d1d9e6');\n      circle.dataset.nodeId = n.id;\n      g.appendChild(circle);\n      // label (node id)\n      const label = document.createElementNS(NS,'text');\n      label.setAttribute('class','nodeLabel');\n      label.setAttribute('text-anchor','middle');\n      label.setAttribute('dy','6');\n      label.textContent = n.label;\n      g.appendChild(label);\n      // distance display (small circle or text)\n      const dlabel = document.createElementNS(NS,'text');\n      dlabel.setAttribute('class','distLabel');\n      dlabel.setAttribute('text-anchor','middle');\n      dlabel.setAttribute('dy','-30');\n      dlabel.textContent = ''; // filled by algorithm state\n      dlabel.dataset.nodeId = n.id;\n      g.appendChild(dlabel);\n\n      // interactions\n      g.addEventListener('mousedown', ev => {\n        ev.stopPropagation();\n        const id = n.id;\n        if(mode==='move'){\n          startDrag(n, g, ev);\n        } else if(mode==='addEdge'){\n          handleEdgeClick(n);\n        } else if(mode==='addNode'){\n          // noop because adding node is on canvas click\n        } else if(mode==='delete'){\n          if(confirm('Delete node and its edges?')) {\n            nodes = nodes.filter(x=>x.id!==id);\n            edges = edges.filter(e=>e.from!==id && e.to!==id);\n            log(`Node ${id} deleted`);\n            render();\n            updateSelectors();\n            resetAlgorithmState();\n          }\n        }\n      });\n\n      nodeLayer.appendChild(g);\n    }\n    updateStateLabels(); // distances and classes updated\n  }\n\n  // Dragging\n  let dragState = null;\n  function startDrag(node, gEl, ev) {\n    const start = {x: ev.clientX, y: ev.clientY, nodeX: node.x, nodeY: node.y};\n    dragState = start;\n    function onMove(e){\n      const dx = e.clientX - start.x;\n      const dy = e.clientY - start.y;\n      node.x = start.nodeX + dx;\n      node.y = start.nodeY + dy;\n      gEl.setAttribute('transform', `translate(${node.x},${node.y})`);\n      render(); // re-render edges positions\n    }\n    function onUp(){ window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); dragState = null; }\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  // Canvas interactions\n  svg.addEventListener('click', ev => {\n    const rect = svg.getBoundingClientRect();\n    const x = ev.clientX - rect.left;\n    const y = ev.clientY - rect.top;\n    if(mode==='addNode'){\n      addNodeAt(x,y);\n    }\n  });\n\n  function addNodeAt(x,y,label){\n    const id = nextNodeId++;\n    const node = {id, x, y, label: label || String(id)};\n    nodes.push(node);\n    log(`Node ${node.label} added`);\n    render();\n    updateSelectors();\n    resetAlgorithmState();\n  }\n\n  // Edge creation sequencing\n  let pendingEdgeSource = null;\n  function handleEdgeClick(node){\n    if(!pendingEdgeSource){\n      pendingEdgeSource = node;\n      log(`Selected source node ${node.label}. Now click target node.`);\n      // visually indicate maybe\n    } else if(pendingEdgeSource.id === node.id){\n      pendingEdgeSource = null;\n      log('Cancelled edge creation (same node).');\n    } else {\n      const w = prompt(`Enter weight for edge ${pendingEdgeSource.label} → ${node.label} (non-negative):`, \"1\");\n      pendingEdgeSource = pendingEdgeSource; // keep for clarity\n      if(w===null){ pendingEdgeSource=null; return; }\n      const weight = Number(w);\n      if(isNaN(weight) || weight < 0){ alert('Weight must be a non-negative number'); pendingEdgeSource = null; return; }\n      const edge = {id: nextEdgeId++, from: pendingEdgeSource.id, to: node.id, weight};\n      edges.push(edge);\n      log(`Edge ${edge.id} added: ${getNodeLabel(edge.from)} → ${getNodeLabel(edge.to)} (w=${edge.weight})`);\n      pendingEdgeSource = null;\n      render();\n      updateSelectors();\n      resetAlgorithmState();\n    }\n  }\n\n  // Helpers\n  function getNodeLabel(id){ const n = nodes.find(x=>x.id===id); return n ? n.label : id; }\n  function log(msg){ const t = new Date().toLocaleTimeString(); logEl.textContent += `[${t}] ${msg}\\n`; logEl.scrollTop = logEl.scrollHeight; }\n  function updateSelectors(){\n    startSelect.innerHTML = '';\n    targetSelect.innerHTML = '<option value=\"\">None</option>';\n    for(const n of nodes){\n      const opt = document.createElement('option'); opt.value = n.id; opt.textContent = n.label; startSelect.appendChild(opt);\n      const opt2 = document.createElement('option'); opt2.value = n.id; opt2.textContent = n.label; targetSelect.appendChild(opt2);\n    }\n  }\n\n  // Algorithm state\n  let distances = {}; // id -> number (Infinity for unknown)\n  let prev = {}; // id -> predecessor id or null\n  let visited = new Set();\n  let pq = []; // array of {node,dist}\n  let currentNode = null;\n  let running = false;\n  let autoTimer = null;\n  let generator = null;\n\n  function resetAlgorithmState(){\n    distances = {};\n    prev = {};\n    visited = new Set();\n    pq = [];\n    currentNode = null;\n    running = false;\n    generator = null;\n    updateStateLabels();\n    render();\n    updatePQDisplay();\n  }\n\n  resetAlgorithmState();\n\n  // Dijkstra as generator producing steps\n  function* dijkstraGen(startId, targetId=null){\n    // initialization\n    const INF = Infinity;\n    const allIds = nodes.map(n=>n.id);\n    for(const id of allIds){ distances[id] = INF; prev[id] = null; }\n    distances[startId] = 0;\n    pq = [{node:startId, dist:0}];\n    yield {type:'init', start:startId};\n    while(pq.length>0){\n      // extract min (pop smallest)\n      pq.sort((a,b)=>a.dist - b.dist);\n      const u = pq.shift();\n      const uId = u.node;\n      if(visited.has(uId)) {\n        yield {type:'skip', node:uId, dist:u.dist};\n        continue;\n      }\n      currentNode = uId;\n      if(distances[uId] !== u.dist){\n        // stale entry, skip\n        yield {type:'stale', node:uId, dist:u.dist};\n      }\n      // mark visited\n      visited.add(uId);\n      yield {type:'visit', node:uId, dist:distances[uId]};\n      if(targetId && uId === targetId){\n        yield {type:'foundTarget', node:uId};\n        return {distances, prev};\n      }\n      // relax neighbors (edges from u)\n      const outgoing = edges.filter(e=>e.from===uId);\n      for(const e of outgoing){\n        const v = e.to;\n        const alt = distances[uId] + e.weight;\n        yield {type:'considerEdge', from:uId, to:v, edge:e, alt};\n        if(alt < distances[v]){\n          distances[v] = alt;\n          prev[v] = uId;\n          pq.push({node:v, dist:alt});\n          yield {type:'relax', from:uId, to:v, newDist:alt};\n        } else {\n          yield {type:'noRelax', from:uId, to:v, keptDist:distances[v]};\n        }\n      }\n    }\n    yield {type:'done'};\n    return {distances, prev};\n  }\n\n  // UI actions for algorithm\n  stepBtn.onclick = ()=> {\n    const startId = Number(startSelect.value);\n    if(!startId){ alert('Select a start node'); return; }\n    if(!generator){ generator = dijkstraGen(startId, targetSelect.value ? Number(targetSelect.value) : null); }\n    const res = generator.next();\n    processStepResult(res);\n  };\n\n  runBtn.onclick = ()=> {\n    const startId = Number(startSelect.value);\n    if(!startId){ alert('Select a start node'); return; }\n    if(!generator) generator = dijkstraGen(startId, targetSelect.value ? Number(targetSelect.value) : null);\n    if(running) return;\n    running = true;\n    autoStep();\n  };\n\n  function autoStep(){\n    if(!running) return;\n    const res = generator.next();\n    processStepResult(res);\n    if(res.done){ running=false; return; }\n    const delay = Math.max(50, Number(delayInput.value) || 700);\n    autoTimer = setTimeout(autoStep, delay);\n  }\n\n  pauseBtn.onclick = ()=> {\n    running = false;\n    if(autoTimer) { clearTimeout(autoTimer); autoTimer = null; }\n  };\n\n  resetBtn.onclick = ()=> {\n    running = false;\n    if(autoTimer){ clearTimeout(autoTimer); autoTimer=null; }\n    generator = null;\n    resetAlgorithmState();\n    log('Algorithm reset to initial state');\n  };\n\n  clearBtn.onclick = ()=> {\n    if(!confirm('Clear entire graph?')) return;\n    nodes = []; edges = []; nextNodeId = 1; nextEdgeId = 1;\n    render(); updateSelectors(); resetAlgorithmState(); log('Graph cleared');\n  };\n\n  exampleBtn.onclick = ()=> {\n    // build a sample graph\n    nodes = [];\n    edges = [];\n    nextNodeId = 1; nextEdgeId = 1;\n    addNodeAt(120,120); addNodeAt(300,70); addNodeAt(500,120); addNodeAt(200,260); addNodeAt(420,250);\n    // ensure labels are consistent\n    nodes.forEach((n, i) => n.label = String(n.id));\n    edges.push({id: nextEdgeId++, from:1, to:2, weight:7});\n    edges.push({id: nextEdgeId++, from:1, to:4, weight:9});\n    edges.push({id: nextEdgeId++, from:1, to:3, weight:14});\n    edges.push({id: nextEdgeId++, from:2, to:3, weight:10});\n    edges.push({id: nextEdgeId++, from:2, to:4, weight:15});\n    edges.push({id: nextEdgeId++, from:3, to:5, weight:9});\n    edges.push({id: nextEdgeId++, from:4, to:5, weight:11});\n    // add reverse edges to make undirected (optional)\n    edges.push({id: nextEdgeId++, from:2, to:1, weight:7});\n    edges.push({id: nextEdgeId++, from:4, to:1, weight:9});\n    edges.push({id: nextEdgeId++, from:3, to:1, weight:14});\n    edges.push({id: nextEdgeId++, from:3, to:2, weight:10});\n    edges.push({id: nextEdgeId++, from:4, to:2, weight:15});\n    edges.push({id: nextEdgeId++, from:5, to:3, weight:9});\n    edges.push({id: nextEdgeId++, from:5, to:4, weight:11});\n    render(); updateSelectors(); resetAlgorithmState();\n    log('Example graph loaded');\n  };\n\n  // process generator step\n  function processStepResult(res){\n    if(res.done){\n      updateStateLabels();\n      updatePQDisplay();\n      render();\n      log('Algorithm finished');\n      generator = null;\n      running = false;\n      return;\n    }\n    const evt = res.value;\n    switch(evt.type){\n      case 'init':\n        log(`Initialized with start node ${getNodeLabel(evt.start)}`);\n        break;\n      case 'visit':\n        log(`Visiting node ${getNodeLabel(evt.node)} (dist=${evt.dist === Infinity ? '∞' : evt.dist})`);\n        break;\n      case 'skip':\n        log(`Skipping visited node ${getNodeLabel(evt.node)} (stale)`);\n        break;\n      case 'stale':\n        log(`Stale pq entry for ${getNodeLabel(evt.node)} (dist=${evt.dist})`);\n        break;\n      case 'considerEdge':\n        log(`Considering edge ${getNodeLabel(evt.from)} → ${getNodeLabel(evt.to)} (w=${evt.edge.weight}), alt=${evt.alt}`);\n        break;\n      case 'relax':\n        log(`Relax: updated ${getNodeLabel(evt.to)} dist=${evt.newDist} via ${getNodeLabel(evt.from)}`);\n        break;\n      case 'noRelax':\n        // optional: log nothing or concise message\n        break;\n      case 'foundTarget':\n        log(`Target ${getNodeLabel(evt.node)} reached`);\n        break;\n      case 'done':\n        log('No more reachable nodes.');\n        break;\n    }\n    updateStateLabels();\n    updatePQDisplay();\n    highlightNodes();\n    render();\n  }\n\n  function highlightNodes(){\n    // update node circle classes based on distances/visited/current/pq\n    for(const g of Array.from(nodeLayer.children)){\n      const circle = g.querySelector('circle');\n      const nodeId = Number(circle.dataset.nodeId);\n      if(visited.has(nodeId)){\n        circle.classList.remove('unvisited','frontier','current'); circle.classList.add('visited');\n        circle.setAttribute('fill','#94d4a4');\n      } else if(currentNode === nodeId){\n        circle.classList.remove('unvisited','frontier','visited'); circle.classList.add('current');\n        circle.setAttribute('fill','#ffd47a');\n      } else if(pq.some(x=>x.node===nodeId)){\n        circle.classList.remove('unvisited','visited','current'); circle.classList.add('frontier');\n        circle.setAttribute('fill','#9ec5ff');\n      } else {\n        circle.classList.remove('visited','frontier','current'); circle.classList.add('unvisited');\n        circle.setAttribute('fill','#d1d9e6');\n      }\n    }\n  }\n\n  function updateStateLabels(){\n    // distances in table and node labels\n    stateTableBody.innerHTML = '';\n    for(const n of nodes){\n      const tr = document.createElement('tr');\n      const tdNode = document.createElement('td'); tdNode.textContent = n.label;\n      const tdDist = document.createElement('td'); tdDist.textContent = distances[n.id]===Infinity || distances[n.id]===undefined ? '∞' : distances[n.id];\n      const tdPrev = document.createElement('td'); tdPrev.textContent = prev[n.id] ? getNodeLabel(prev[n.id]) : '-';\n      tr.appendChild(tdNode); tr.appendChild(tdDist); tr.appendChild(tdPrev);\n      stateTableBody.appendChild(tr);\n\n      // update node's small dist label text\n      const nodeGroup = Array.from(nodeLayer.children).find(g => {\n        const c = g.querySelector('circle');\n        return c && Number(c.dataset.nodeId) === n.id;\n      });\n      if(nodeGroup){\n        const dlabel = nodeGroup.querySelector('text.distLabel') || nodeGroup.querySelector('text:nth-child(3)');\n        if(dlabel){\n          dlabel.textContent = distances[n.id]===Infinity || distances[n.id]===undefined ? '' : distances[n.id];\n        }\n      }\n    }\n  }\n\n  function updatePQDisplay(){\n    const arr = Array.from(pq).sort((a,b)=>a.dist-b.dist);\n    pqList.innerHTML = arr.map(e=>`${getNodeLabel(e.node)}:${e.dist}`).join('  ↦  ');\n  }\n\n  // initial sample graph to show something helpful\n  exampleBtn.click();\n\n  // small keyboard shortcuts\n  window.addEventListener('keydown', ev=>{\n    if(ev.key === '1') setMode('addNode');\n    if(ev.key === '2') setMode('addEdge');\n    if(ev.key === '3') setMode('move');\n    if(ev.key === '4') setMode('delete');\n    if(ev.key === ' ') { ev.preventDefault(); stepBtn.click(); }\n  });\n\n  // expose reset on window for debugging\n  window.demo = {nodes, edges, render, addNodeAt};\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}