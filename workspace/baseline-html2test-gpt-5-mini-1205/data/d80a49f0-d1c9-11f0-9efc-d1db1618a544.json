{
  "id": "d80a49f0-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:01.719Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Graph Explorer — Directed / Undirected</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    :root{--bg:#f7f9fc;--panel:#ffffff;--accent:#0b76ef;--muted:#666;}\n    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:#111;}\n    .app{display:flex;height:100vh;gap:12px;padding:12px;box-sizing:border-box;}\n    .canvas-wrap{flex:1;background:linear-gradient(180deg, #fff, #fbfdff);border:1px solid #e2e8f0;border-radius:8px;position:relative;overflow:hidden;}\n    header{display:flex;align-items:center;gap:12px;padding:12px;border-bottom:1px solid #eef2f7;background:var(--panel);}\n    .toolbar{display:flex;gap:8px;flex-wrap:wrap;padding:8px;}\n    button,input,select{font-size:13px;padding:8px;border-radius:6px;border:1px solid #d1dbe8;background:#fff;cursor:pointer;}\n    button.primary{background:var(--accent);color:#fff;border-color:transparent;}\n    button.ghost{background:transparent;border:1px dashed #cbd5e1;}\n    .controls{width:360px;display:flex;flex-direction:column;gap:12px;}\n    .panel{background:var(--panel);border-radius:8px;padding:12px;border:1px solid #e6eef8;box-shadow:0 1px 2px rgba(16,24,40,0.02);}\n    label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px;}\n    .row{display:flex;gap:8px;align-items:center;}\n    .small{font-size:12px;padding:6px;}\n    .muted{color:var(--muted);font-size:13px;}\n    .info{font-size:13px;color:#0f1724;}\n    #svgCanvas{width:100%;height:calc(100% - 60px);cursor:crosshair;}\n    .footer{position:absolute;left:12px;bottom:12px;background:rgba(255,255,255,0.9);padding:8px;border-radius:8px;border:1px solid #eef2f7;font-size:13px;}\n    .list{max-height:220px;overflow:auto;padding:6px;background:#fbfdff;border-radius:6px;border:1px dashed #eef6ff;}\n    table{border-collapse:collapse;width:100%;font-size:13px;}\n    table td,table th{border:1px solid #e6eef8;padding:6px;text-align:center;}\n    .selected{outline:3px solid rgba(11,118,239,0.12);box-shadow:0 2px 6px rgba(11,118,239,0.08);}\n    a.link{color:var(--accent);text-decoration:none;}\n    .small-muted{font-size:12px;color:#94a3b8;}\n    textarea{width:100%;height:120px;font-family:monospace;}\n    .flex-col{display:flex;flex-direction:column;gap:8px;}\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"canvas-wrap panel\" style=\"display:flex;flex-direction:column;\">\n      <header style=\"display:flex;justify-content:space-between;align-items:center;\">\n        <div style=\"display:flex;gap:12px;align-items:center;\">\n          <strong>Graph Explorer</strong>\n          <span class=\"small-muted\">Create, switch Directed/Undirected, inspect adjacency</span>\n        </div>\n        <div style=\"display:flex;gap:8px;align-items:center;\">\n          <label class=\"small-muted\" style=\"margin:0 8px 0 0;\">Mode:</label>\n          <select id=\"modeSelect\">\n            <option value=\"addNode\">Add Node (click)</option>\n            <option value=\"addEdge\">Add Edge (click source → target)</option>\n            <option value=\"select\">Select / Drag</option>\n          </select>\n          <button id=\"clearBtn\" class=\"ghost\">Clear</button>\n        </div>\n      </header>\n\n      <svg id=\"svgCanvas\" viewBox=\"0 0 1200 800\" xmlns=\"http://www.w3.org/2000/svg\">\n        <defs>\n          <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"10\" refY=\"5\" orient=\"auto\">\n            <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#0b76ef\" />\n          </marker>\n          <marker id=\"arrow-dark\" markerWidth=\"10\" markerHeight=\"10\" refX=\"10\" refY=\"5\" orient=\"auto\">\n            <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#0b76ef\" />\n          </marker>\n          <marker id=\"arrow-muted\" markerWidth=\"10\" markerHeight=\"10\" refX=\"10\" refY=\"5\" orient=\"auto\">\n            <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#94a3b8\" />\n          </marker>\n        </defs>\n        <g id=\"edgesLayer\"></g>\n        <g id=\"nodesLayer\"></g>\n        <g id=\"labelsLayer\"></g>\n      </svg>\n\n      <div class=\"footer\">\n        <span id=\"status\">Click canvas to add nodes. Mode: Add Node</span>\n      </div>\n    </div>\n\n    <div class=\"controls\">\n      <div class=\"panel\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n          <strong>Graph Settings</strong>\n          <div class=\"small-muted\">Directed?</div>\n        </div>\n        <div style=\"display:flex;gap:8px;margin-top:8px;align-items:center;\">\n          <label><input type=\"checkbox\" id=\"directedToggle\" checked> Directed</label>\n          <label style=\"margin-left:8px;\"><input type=\"checkbox\" id=\"weightedToggle\"> Weighted</label>\n          <label style=\"margin-left:8px;\"><input type=\"checkbox\" id=\"showIdsToggle\" checked> Show IDs</label>\n        </div>\n        <div style=\"display:flex;gap:8px;margin-top:10px;\">\n          <button id=\"randomGraph\" class=\"small\">Random Graph</button>\n          <button id=\"exportBtn\" class=\"small\">Export JSON</button>\n          <button id=\"importBtn\" class=\"small\">Import JSON</button>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <strong>Edit / Actions</strong>\n        <div style=\"display:flex;flex-direction:column;gap:8px;margin-top:8px;\">\n          <div style=\"display:flex;gap:8px;\">\n            <button id=\"deleteSelected\" class=\"small\">Delete Selected</button>\n            <button id=\"autoLayout\" class=\"small\">Auto Layout</button>\n            <button id=\"toggleMode\" class=\"small\">Toggle Mode</button>\n          </div>\n          <div>\n            <label class=\"muted\">Path algorithms</label>\n            <div style=\"display:flex;gap:8px;margin-top:6px;\">\n              <select id=\"startSelect\"></select>\n              <select id=\"endSelect\"></select>\n            </div>\n            <div style=\"display:flex;gap:8px;margin-top:8px;\">\n              <button id=\"bfsBtn\" class=\"small\">BFS</button>\n              <button id=\"dfsBtn\" class=\"small\">DFS</button>\n              <button id=\"dijkstraBtn\" class=\"small\">Dijkstra</button>\n            </div>\n            <div id=\"pathInfo\" class=\"small-muted\" style=\"margin-top:8px;\">No path highlighted</div>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"panel flex-col\">\n        <strong>Adjacency List</strong>\n        <div id=\"adjList\" class=\"list\"></div>\n        <strong style=\"margin-top:8px;\">Adjacency Matrix</strong>\n        <div id=\"adjMatrix\" class=\"list\" style=\"overflow:auto;\"></div>\n      </div>\n\n      <div class=\"panel\">\n        <strong>Import / Export</strong>\n        <textarea id=\"jsonArea\" placeholder='Paste JSON here for import or hit Export to generate'></textarea>\n        <div style=\"display:flex;gap:8px;margin-top:8px;\">\n          <button id=\"doImport\" class=\"small\">Import</button>\n          <button id=\"doExport\" class=\"small\">Export (to textarea)</button>\n        </div>\n        <div style=\"margin-top:8px;\" class=\"small-muted\">\n          Format: {nodes:[{id,x,y}], edges:[{id,source,target,weight,directed}]}\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Graph Explorer: Directed / Undirected example\n    (function(){\n      // State\n      let nodes = []; // {id,x,y}\n      let edges = []; // {id,source,target,weight,directed}\n      let nodeIdSeq = 1;\n      let edgeIdSeq = 1;\n      const R = 22; // node radius\n      const svg = document.getElementById('svgCanvas');\n      const nodesLayer = document.getElementById('nodesLayer');\n      const edgesLayer = document.getElementById('edgesLayer');\n      const labelsLayer = document.getElementById('labelsLayer');\n\n      // UI refs\n      const modeSelect = document.getElementById('modeSelect');\n      const status = document.getElementById('status');\n      const directedToggle = document.getElementById('directedToggle');\n      const weightedToggle = document.getElementById('weightedToggle');\n      const showIdsToggle = document.getElementById('showIdsToggle');\n      const clearBtn = document.getElementById('clearBtn');\n      const randomBtn = document.getElementById('randomGraph');\n      const deleteSelectedBtn = document.getElementById('deleteSelected');\n      const autoLayoutBtn = document.getElementById('autoLayout');\n      const toggleModeBtn = document.getElementById('toggleMode');\n\n      const startSelect = document.getElementById('startSelect');\n      const endSelect = document.getElementById('endSelect');\n      const bfsBtn = document.getElementById('bfsBtn');\n      const dfsBtn = document.getElementById('dfsBtn');\n      const dijkstraBtn = document.getElementById('dijkstraBtn');\n      const pathInfo = document.getElementById('pathInfo');\n\n      const adjListDiv = document.getElementById('adjList');\n      const adjMatrixDiv = document.getElementById('adjMatrix');\n\n      const exportBtn = document.getElementById('exportBtn');\n      const importBtn = document.getElementById('importBtn');\n      const jsonArea = document.getElementById('jsonArea');\n      const doExport = document.getElementById('doExport');\n      const doImport = document.getElementById('doImport');\n\n      // Interaction\n      let mode = modeSelect.value; // addNode, addEdge, select\n      let selectedNodeId = null;\n      let selectedEdgeId = null;\n      let dragging = null;\n      let addingEdgeFrom = null;\n\n      function setStatus(text){\n        status.textContent = text;\n      }\n\n      modeSelect.addEventListener('change', ()=>{ mode = modeSelect.value; setStatus('Mode: '+modeLabel()); clearSelections(); });\n      toggleModeBtn.addEventListener('click', ()=>{\n        const next = (mode === 'addNode') ? 'addEdge' : (mode === 'addEdge' ? 'select' : 'addNode');\n        mode = next;\n        modeSelect.value = next;\n        setStatus('Mode: '+modeLabel());\n        clearSelections();\n      });\n\n      directedToggle.addEventListener('change', ()=>{\n        render();\n      });\n      weightedToggle.addEventListener('change', ()=> render());\n      showIdsToggle.addEventListener('change', ()=> render());\n\n      clearBtn.addEventListener('click', ()=> { nodes=[]; edges=[]; nodeIdSeq=1; edgeIdSeq=1; render(); });\n      randomBtn.addEventListener('click', createRandomGraph);\n      deleteSelectedBtn.addEventListener('click', deleteSelected);\n      autoLayoutBtn.addEventListener('click', autoLayout);\n\n      exportBtn.addEventListener('click', ()=> {\n        jsonArea.value = JSON.stringify({nodes,edges}, null, 2);\n        setStatus('Exported JSON to text area');\n      });\n      doExport.addEventListener('click', ()=> {\n        jsonArea.value = JSON.stringify({nodes,edges}, null, 2);\n        setStatus('Exported JSON to text area');\n      });\n      importBtn.addEventListener('click', ()=> {\n        const v = prompt('Paste JSON to import (nodes, edges):', jsonArea.value || '');\n        if(!v) return;\n        try{\n          const obj = JSON.parse(v);\n          importGraph(obj);\n          setStatus('Imported graph');\n        }catch(e){ alert('Invalid JSON'); }\n      });\n      doImport.addEventListener('click', ()=> {\n        const v = jsonArea.value.trim();\n        if(!v) { alert('Paste JSON into textarea first'); return; }\n        try{\n          const obj = JSON.parse(v);\n          importGraph(obj);\n          setStatus('Imported graph');\n        }catch(e){ alert('Invalid JSON'); }\n      });\n\n      // Path algorithm buttons\n      bfsBtn.addEventListener('click', ()=> runSearch('bfs'));\n      dfsBtn.addEventListener('click', ()=> runSearch('dfs'));\n      dijkstraBtn.addEventListener('click', ()=> runSearch('dijkstra'));\n\n      // Helpers\n      function modeLabel(){ return mode === 'addNode' ? 'Add Node' : mode === 'addEdge' ? 'Add Edge' : 'Select / Drag'; }\n\n      function importGraph(obj){\n        if(!obj.nodes || !obj.edges) { alert('Object must contain nodes and edges arrays'); return; }\n        nodes = obj.nodes.map(n=>({id:n.id,x:n.x,y:n.y}));\n        edges = obj.edges.map(e=>({id:e.id,source:e.source,target:e.target,weight:e.weight||1,directed:!!e.directed}));\n        nodeIdSeq = nodes.reduce((m,n)=>Math.max(m,n.id),0)+1;\n        edgeIdSeq = edges.reduce((m,e)=>Math.max(m,e.id),0)+1;\n        render();\n      }\n\n      function createRandomGraph(){\n        nodes=[]; edges=[];// generate random nodes and edges\n        const n = Math.floor(Math.random()*6)+5;\n        const w = 1000, h = 600;\n        for(let i=0;i<n;i++){\n          nodes.push({id:nodeIdSeq++, x:100+Math.random()*(w-200), y:60+Math.random()*(h-120)});\n        }\n        const m = Math.floor(n*1.5);\n        const directed = directedToggle.checked;\n        for(let i=0;i<m;i++){\n          const a = nodes[Math.floor(Math.random()*nodes.length)];\n          const b = nodes[Math.floor(Math.random()*nodes.length)];\n          if(!a || !b || a.id===b.id) continue;\n          const wgt = weightedToggle.checked ? Math.floor(Math.random()*9)+1 : 1;\n          edges.push({id:edgeIdSeq++, source:a.id, target:b.id, weight:wgt, directed:directed});\n          if(!directed){\n            // possibility to add symmetric duplicate? keep single\n          }\n        }\n        render();\n      }\n\n      function addNode(x,y){\n        nodes.push({id:nodeIdSeq++, x, y});\n        render();\n      }\n\n      function addEdge(srcId, tgtId, weight, directed){\n        // prevent duplicate same direction\n        const exists = edges.find(e=>e.source===srcId && e.target===tgtId && e.directed===directed);\n        if(exists) return;\n        edges.push({id:edgeIdSeq++, source:srcId, target:tgtId, weight:weight||1, directed:directed});\n        render();\n      }\n\n      function deleteSelected(){\n        if(selectedNodeId!=null){\n          // remove node and incident edges\n          nodes = nodes.filter(n=>n.id!==selectedNodeId);\n          edges = edges.filter(e=>e.source!==selectedNodeId && e.target!==selectedNodeId);\n          selectedNodeId = null;\n        }else if(selectedEdgeId!=null){\n          edges = edges.filter(e=>e.id!==selectedEdgeId);\n          selectedEdgeId = null;\n        }else{\n          alert('Select a node or edge first (mode: Select / Drag).');\n        }\n        render();\n      }\n\n      function clearSelections(){\n        addingEdgeFrom = null;\n        selectedNodeId = null;\n        selectedEdgeId = null;\n        render();\n      }\n\n      // Render\n      function render(){\n        // clear\n        while(nodesLayer.firstChild) nodesLayer.removeChild(nodesLayer.firstChild);\n        while(edgesLayer.firstChild) edgesLayer.removeChild(edgesLayer.firstChild);\n        while(labelsLayer.firstChild) labelsLayer.removeChild(labelsLayer.firstChild);\n\n        // Draw edges\n        edges.forEach(e=>{\n          const s = nodes.find(n=>n.id===e.source);\n          const t = nodes.find(n=>n.id===e.target);\n          if(!s || !t) return;\n          const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n          const dx = t.x - s.x, dy = t.y - s.y;\n          const len = Math.hypot(dx,dy) || 1;\n          const ux = dx/len, uy = dy/len;\n          const offset = R;\n          const x1 = s.x + ux*offset, y1 = s.y + uy*offset;\n          const x2 = t.x - ux*offset, y2 = t.y - uy*offset;\n          line.setAttribute('x1',x1);\n          line.setAttribute('y1',y1);\n          line.setAttribute('x2',x2);\n          line.setAttribute('y2',y2);\n          line.setAttribute('stroke', (e.id===selectedEdgeId)?'#0b76ef':'#94a3b8');\n          line.setAttribute('stroke-width', (e.id===selectedEdgeId)?4:2);\n          if(e.directed && directedToggle.checked){\n            line.setAttribute('marker-end','url(#arrow)');\n          } else {\n            line.removeAttribute('marker-end');\n          }\n          line.style.cursor = 'pointer';\n          line.addEventListener('click', (ev)=>{ ev.stopPropagation(); selectedEdgeId = e.id; selectedNodeId=null; setStatus('Selected edge '+e.id); render(); });\n          edgesLayer.appendChild(line);\n\n          // weight label\n          if(weightedToggle.checked){\n            const tx = (x1+x2)/2, ty = (y1+y2)/2;\n            const txt = document.createElementNS('http://www.w3.org/2000/svg','text');\n            txt.setAttribute('x', tx);\n            txt.setAttribute('y', ty-6);\n            txt.setAttribute('fill', '#0b76ef');\n            txt.setAttribute('font-size','12');\n            txt.setAttribute('text-anchor','middle');\n            txt.textContent = e.weight;\n            labelsLayer.appendChild(txt);\n          }\n        });\n\n        // Draw nodes\n        nodes.forEach(n=>{\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('transform',`translate(${n.x},${n.y})`);\n          // circle\n          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          c.setAttribute('r', R);\n          c.setAttribute('cx', 0);\n          c.setAttribute('cy', 0);\n          c.setAttribute('fill', (n.id===selectedNodeId)?'#eaf4ff':'#fff');\n          c.setAttribute('stroke', (n.id===selectedNodeId)?'#0b76ef':'#94a3b8');\n          c.setAttribute('stroke-width', (n.id===selectedNodeId)?3:2);\n          c.style.cursor = 'grab';\n          g.appendChild(c);\n\n          // label: id or small dot\n          if(showIdsToggle.checked){\n            const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n            t.setAttribute('x',0);\n            t.setAttribute('y',4);\n            t.setAttribute('text-anchor','middle');\n            t.setAttribute('font-size','14');\n            t.setAttribute('fill','#0b1220');\n            t.textContent = n.id;\n            g.appendChild(t);\n          }\n\n          // event handlers\n          g.addEventListener('mousedown', (ev)=>{\n            ev.stopPropagation();\n            if(mode === 'addEdge'){\n              if(!addingEdgeFrom){\n                addingEdgeFrom = n.id;\n                selectedNodeId = n.id;\n                setStatus('Edge: click target node');\n              } else {\n                const src = addingEdgeFrom;\n                const tgt = n.id;\n                let w = weightedToggle.checked ? Number(prompt('Edge weight (number)', '1')) : 1;\n                if(isNaN(w) || w===null) w = 1;\n                addEdge(src,tgt,w, directedToggle.checked);\n                addingEdgeFrom = null;\n                setStatus('Edge added');\n              }\n              render();\n            } else {\n              // select / drag\n              selectedNodeId = n.id;\n              selectedEdgeId = null;\n              dragging = {id: n.id, offsetX: ev.offsetX - n.x, offsetY: ev.offsetY - n.y};\n              setStatus('Dragging node '+n.id);\n              render();\n            }\n          });\n          g.addEventListener('mouseup', (ev)=>{ ev.stopPropagation(); dragging=null; setStatus(''); });\n          g.addEventListener('click', (ev)=>{ ev.stopPropagation(); if(mode==='select'){ selectedNodeId=n.id; selectedEdgeId=null; render(); } });\n\n          nodesLayer.appendChild(g);\n        });\n\n        // update selects and adjacency displays\n        updateNodeSelects();\n        updateAdjDisplays();\n      }\n\n      // SVG interaction: click to add node, move dragging\n      svg.addEventListener('click', function(ev){\n        const pt = svg.createSVGPoint();\n        pt.x = ev.clientX; pt.y = ev.clientY;\n        const ctm = svg.getScreenCTM();\n        if(ctm) {\n          const inv = ctm.inverse();\n          const loc = pt.matrixTransform(inv);\n          if(mode === 'addNode'){\n            addNode(loc.x, loc.y);\n            setStatus('Added node');\n          } else if(mode === 'addEdge'){\n            // click on empty space cancels edge add\n            addingEdgeFrom = null;\n            setStatus('Edge creation cancelled');\n          } else {\n            // select deselect\n            selectedNodeId = null; selectedEdgeId = null; render();\n          }\n        }\n      });\n\n      // Track mousemove for dragging\n      svg.addEventListener('mousemove', function(ev){\n        if(!dragging) return;\n        const pt = svg.createSVGPoint();\n        pt.x = ev.clientX; pt.y = ev.clientY;\n        const ctm = svg.getScreenCTM();\n        if(!ctm) return;\n        const inv = ctm.inverse();\n        const loc = pt.matrixTransform(inv);\n        const n = nodes.find(x=>x.id===dragging.id);\n        if(n){\n          n.x = loc.x - dragging.offsetX;\n          n.y = loc.y - dragging.offsetY;\n          render();\n        }\n      });\n\n      // Utility: update selects for path algorithms\n      function updateNodeSelects(){\n        const oldStart = startSelect.value;\n        while(startSelect.firstChild) startSelect.removeChild(startSelect.firstChild);\n        while(endSelect.firstChild) endSelect.removeChild(endSelect.firstChild);\n        nodes.forEach(n=>{\n          const o1 = document.createElement('option'); o1.value=n.id; o1.textContent=n.id;\n          const o2 = document.createElement('option'); o2.value=n.id; o2.textContent=n.id;\n          startSelect.appendChild(o1); endSelect.appendChild(o2);\n        });\n        if(oldStart) startSelect.value = oldStart;\n      }\n\n      // Adjacency displays\n      function updateAdjDisplays(){\n        // Build adjacency list\n        const directed = directedToggle.checked;\n        const map = {};\n        nodes.forEach(n=>map[n.id]=[]);\n        edges.forEach(e=>{\n          if(!map[e.source]) map[e.source]=[];\n          map[e.source].push({to:e.target, w:e.weight, directed:e.directed});\n          if(!e.directed && !directed){\n            // treat as undirected (also add reverse)\n            if(!map[e.target]) map[e.target]=[];\n            map[e.target].push({to:e.source, w:e.weight, directed:false});\n          }\n        });\n        // Render list\n        adjListDiv.innerHTML = '';\n        for(const nid of nodes.map(n=>n.id)){\n          const arr = map[nid] || [];\n          const item = document.createElement('div');\n          item.innerHTML = `<strong>${nid}</strong>: ` + (arr.length ? arr.map(a=> a.w? `${a.to}(w=${a.w})` : `${a.to}`).join(', ') : '—');\n          adjListDiv.appendChild(item);\n        }\n\n        // Matrix\n        const ids = nodes.map(n=>n.id);\n        const n = ids.length;\n        const table = document.createElement('table');\n        const head = document.createElement('tr');\n        head.appendChild(document.createElement('th')); // empty top-left\n        ids.forEach(id=>{ const th = document.createElement('th'); th.textContent = id; head.appendChild(th); });\n        table.appendChild(head);\n        for(let i=0;i<n;i++){\n          const tr = document.createElement('tr');\n          const th = document.createElement('th'); th.textContent = ids[i]; tr.appendChild(th);\n          for(let j=0;j<n;j++){\n            const td = document.createElement('td');\n            const e = edges.find(ed=>ed.source===ids[i] && ed.target===ids[j]);\n            if(e){\n              td.textContent = weightedToggle.checked ? e.weight : '1';\n            } else {\n              if(!directed){\n                // check reverse\n                const rev = edges.find(ed=>ed.source===ids[j] && ed.target===ids[i]);\n                if(rev) td.textContent = weightedToggle.checked ? rev.weight : '1';\n                else td.textContent = '0';\n              } else {\n                td.textContent = '0';\n              }\n            }\n            tr.appendChild(td);\n          }\n          table.appendChild(tr);\n        }\n        adjMatrixDiv.innerHTML = '';\n        adjMatrixDiv.appendChild(table);\n      }\n\n      // Path finding: BFS, DFS, Dijkstra\n      function buildAdjacencyWeighted(){\n        const adj = {};\n        nodes.forEach(n=>adj[n.id]=[]);\n        edges.forEach(e=>{\n          if(!adj[e.source]) adj[e.source]=[];\n          adj[e.source].push({to:e.target, w:e.weight});\n          if(!e.directed && !directedToggle.checked){\n            if(!adj[e.target]) adj[e.target]=[];\n            adj[e.target].push({to:e.source, w:e.weight});\n          }\n        });\n        return adj;\n      }\n\n      function runSearch(type){\n        const s = Number(startSelect.value);\n        const t = Number(endSelect.value);\n        if(isNaN(s) || isNaN(t)){ alert('Select start and end nodes'); return; }\n        const adj = buildAdjacencyWeighted();\n        if(type === 'bfs'){\n          const prev = bfs(adj, s, t);\n          highlightPath(prev, s, t);\n        } else if(type === 'dfs'){\n          const prev = dfs(adj, s, t);\n          highlightPath(prev, s, t);\n        } else if(type === 'dijkstra'){\n          const res = dijkstra(adj, s);\n          const {dist, prev} = res;\n          highlightPath(prev, s, t, dist[t]);\n        }\n      }\n\n      function bfs(adj, s, t){\n        const q = [s];\n        const seen = new Set([s]);\n        const prev = {};\n        while(q.length){\n          const u = q.shift();\n          if(u===t) break;\n          for(const nb of (adj[u]||[])){\n            if(!seen.has(nb.to)){\n              seen.add(nb.to);\n              prev[nb.to]=u;\n              q.push(nb.to);\n            }\n          }\n        }\n        return prev;\n      }\n\n      function dfs(adj, s, t){\n        const visited = new Set();\n        const prev = {};\n        let found=false;\n        function go(u){\n          if(found) return;\n          visited.add(u);\n          if(u===t){ found=true; return; }\n          for(const nb of (adj[u]||[])){\n            if(!visited.has(nb.to)){\n              prev[nb.to]=u;\n              go(nb.to);\n              if(found) return;\n            }\n          }\n        }\n        go(s);\n        return prev;\n      }\n\n      function dijkstra(adj, s){\n        const Q = new Set(Object.keys(adj).map(k=>Number(k)));\n        const INF = Infinity;\n        const dist = {};\n        const prev = {};\n        for(const u of Q) dist[u]=INF;\n        dist[s]=0;\n        while(Q.size){\n          let u = null; let best = INF;\n          for(const v of Q) if(dist[v] < best){ best = dist[v]; u = v; }\n          if(u===null) break;\n          Q.delete(u);\n          for(const nb of (adj[u]||[])){\n            const alt = dist[u] + (nb.w||1);\n            if(alt < dist[nb.to]){\n              dist[nb.to] = alt;\n              prev[nb.to] = u;\n            }\n          }\n        }\n        return {dist, prev};\n      }\n\n      function highlightPath(prev, s, t, cost){\n        // reconstruct\n        const path = [];\n        let cur = t;\n        while(cur!==undefined && cur!==s){\n          path.unshift(cur);\n          cur = prev[cur];\n        }\n        if(cur===s) path.unshift(s);\n        if(path.length===0 || path[0]!==s){\n          pathInfo.textContent = 'No path found';\n          // clear any highlights\n          selectedEdgeId = null;\n          selectedNodeId = null;\n          render();\n          return;\n        }\n        // highlight nodes and edges along path\n        selectedNodeId = null;\n        selectedEdgeId = null;\n        // For edges highlight, mark edges in given sequence\n        // choose the edges that match sequence\n        const pathEdges = [];\n        for(let i=0;i<path.length-1;i++){\n          const a = path[i], b = path[i+1];\n          // find matching edge\n          const e = edges.find(ed => ed.source===a && ed.target===b) ||\n                    edges.find(ed => (!ed.directed || !directedToggle.checked) && ed.source===b && ed.target===a);\n          if(e) pathEdges.push(e.id);\n        }\n        // highlight all path edges by setting selectedEdgeId to first and then drawing others thicker via temporary class\n        // For simplicity mark first as selected and flash others by increasing stroke width in DOM\n        selectedEdgeId = pathEdges.length?pathEdges[0]:null;\n        render();\n        // additionally make other edges thicker\n        setTimeout(()=> {\n          // iterate over edge lines\n          const lines = edgesLayer.querySelectorAll('line');\n          lines.forEach(line=>{\n            line.setAttribute('stroke-width', '2');\n          });\n          // highlight path edges\n          pathEdges.forEach(pid=>{\n            const idx = edges.findIndex(e=>e.id===pid);\n            if(idx>=0){\n              const l = edgesLayer.children[idx];\n              if(l) l.setAttribute('stroke-width','5');\n              if(l) l.setAttribute('stroke','#ff7a00');\n            }\n          });\n        }, 10);\n\n        if(cost!==undefined){\n          pathInfo.textContent = `Path: ${path.join(' → ')} (cost=${cost})`;\n        } else {\n          pathInfo.textContent = `Path: ${path.join(' → ')}`;\n        }\n      }\n\n      // Auto layout: simple force-ish / radial\n      function autoLayout(){\n        if(nodes.length===0) return;\n        // place nodes around a circle\n        const cx = 600, cy = 400;\n        const r = Math.min(500, Math.max(200, nodes.length*30));\n        nodes.forEach((n,i)=>{\n          const ang = (i / nodes.length) * Math.PI*2;\n          n.x = cx + Math.cos(ang)*r;\n          n.y = cy + Math.sin(ang)*r;\n        });\n        render();\n      }\n\n      // Initialize with small sample\n      (function initSample(){\n        nodes = [\n          {id:1,x:200,y:120},{id:2,x:420,y:100},{id:3,x:380,y:260},\n          {id:4,x:620,y:200},{id:5,x:860,y:140}\n        ];\n        edges = [\n          {id:1,source:1,target:2,weight:1,directed:true},\n          {id:2,source:2,target:3,weight:1,directed:true},\n          {id:3,source:3,target:1,weight:1,directed:true},\n          {id:4,source:2,target:4,weight:1,directed:true},\n          {id:5,source:4,target:5,weight:1,directed:true}\n        ];\n        nodeIdSeq = 6; edgeIdSeq = 6;\n        render();\n        setStatus('Sample graph loaded. Try dragging nodes or switch mode.');\n      })();\n\n      // Keyboard: Delete to delete selected\n      window.addEventListener('keydown', (ev)=>{\n        if(ev.key === 'Delete' || ev.key === 'Backspace') deleteSelected();\n      });\n\n      // Prevent text selection while dragging\n      svg.addEventListener('mousedown', (ev)=> ev.preventDefault());\n      svg.addEventListener('mouseup', ()=> dragging=null);\n\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": false,
  "hasTest": true
}