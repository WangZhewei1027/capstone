{
  "id": "d80a22e1-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:37.109Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Red-Black Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Red-Black Tree Visualizer</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<style>\n  :root { --bg: #f7f7fb; --panel: #ffffff; --accent: #1f6feb; --muted: #666; }\n  body { margin:0; font-family: Inter, Roboto, system-ui, -apple-system, \"Segoe UI\", Arial; background: var(--bg); color:#111; }\n  header { padding:12px 18px; display:flex; gap:12px; align-items:center; background:linear-gradient(180deg,#fff,#f3f6ff); border-bottom:1px solid #e6e9f2; }\n  header h1 { margin:0; font-size:16px; }\n  main { display:flex; gap:16px; padding:16px; }\n  .left { width: 360px; }\n  .panel { background:var(--panel); border-radius:10px; padding:12px; box-shadow:0 6px 20px rgba(20,30,60,0.06); }\n  .controls { display:flex; gap:8px; margin-bottom:8px; flex-wrap:wrap; }\n  input[type=\"number\"], input[type=\"text\"] { padding:8px 10px; border-radius:8px; border:1px solid #dbe3f1; width:120px; }\n  button { background:var(--accent); color:white; border:0; padding:8px 10px; border-radius:8px; cursor:pointer; box-shadow:0 4px 12px rgba(31,111,235,0.12); }\n  button.secondary { background:#fff; color:#233; border:1px solid #e2e6f0; box-shadow:none; }\n  button.danger { background:#ff5c5c; box-shadow:none; }\n  label { display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px; }\n  .stat { font-size:13px; color:#334; margin-top:8px; }\n  .log { height:160px; overflow:auto; font-family:monospace; background:#071126; color:#dff7ff; padding:8px; border-radius:8px; margin-top:8px; font-size:12px; }\n  .svg-wrap { flex:1; min-height:520px; background:linear-gradient(180deg,#f8fbff,#fcfdff); border-radius:12px; padding:12px; border:1px solid #eef2ff; display:flex; align-items:flex-start; justify-content:center; }\n  svg { width:100%; height:620px; }\n  .legend { display:flex; gap:12px; margin-top:8px; align-items:center; color:var(--muted); font-size:13px; }\n  .legend .item { display:flex; gap:6px; align-items:center; }\n  .dot { width:18px; height:18px; border-radius:50%; display:inline-block; border:1px solid rgba(0,0,0,0.2); }\n  .dot.red { background:crimson; }\n  .dot.black { background:#111; }\n  .hint { margin-top:8px; font-size:13px; color:#334; }\n  .footer { margin-top:10px; font-size:12px; color:var(--muted); }\n  /* SVG node styles transition */\n  .node-group { transition: transform 450ms cubic-bezier(.2,.9,.2,1); }\n  line.edge { stroke:#203a8a; stroke-width:2; stroke-linecap:round; transition: x1 450ms linear, y1 450ms linear, x2 450ms linear, y2 450ms linear, opacity 450ms linear; }\n  .node-circle { transition: r 250ms ease, fill 250ms ease, stroke 200ms ease; stroke-width:2; }\n  text { font-size:12px; font-weight:600; fill:#fff; pointer-events:none; text-anchor:middle; dominant-baseline:central; }\n  .small { font-size:11px; color:var(--muted); }\n  .valid-ok { color:green; font-weight:600; }\n  .valid-bad { color:#c0392b; font-weight:700; }\n  .controls-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; }\n  .slider-row { display:flex; gap:8px; align-items:center; margin-top:6px; }\n  input[type=\"range\"] { width:160px; }\n</style>\n</head>\n<body>\n<header>\n  <h1>Red-Black Tree Visualizer</h1>\n  <div style=\"color:var(--muted); font-size:13px;\">Insert / Delete / Search with animated rotations & fixups</div>\n</header>\n\n<main>\n  <div class=\"left\">\n    <div class=\"panel\">\n      <div class=\"controls\">\n        <input id=\"valueInput\" type=\"number\" placeholder=\"Key (integer)\" />\n        <button id=\"insertBtn\">Insert</button>\n        <button id=\"deleteBtn\" class=\"danger\">Delete</button>\n        <button id=\"searchBtn\" class=\"secondary\">Search</button>\n      </div>\n\n      <div class=\"controls\">\n        <button id=\"randomBtn\" class=\"secondary\">Insert Random (10)</button>\n        <button id=\"clearBtn\" class=\"secondary\">Clear</button>\n        <button id=\"exampleBtn\" class=\"secondary\">Load Example</button>\n      </div>\n\n      <div class=\"slider-row\">\n        <label class=\"small\">Animation: <span id=\"animVal\">450</span>ms</label>\n        <input id=\"animRange\" type=\"range\" min=\"0\" max=\"1200\" value=\"450\">\n      </div>\n\n      <div class=\"stat\">\n        <div>Nodes: <span id=\"count\">0</span> â€¢ Height: <span id=\"height\">0</span></div>\n        <div style=\"margin-top:6px;\">Validation:\n          <span id=\"validRoot\" class=\"small\"></span>,\n          <span id=\"validRed\" class=\"small\"></span>,\n          <span id=\"validBlackHeight\" class=\"small\"></span>\n        </div>\n      </div>\n\n      <div class=\"legend\">\n        <div class=\"item\"><span class=\"dot red\"></span> Red node</div>\n        <div class=\"item\"><span class=\"dot black\"></span> Black node</div>\n        <div class=\"item\" style=\"margin-left:8px\"><span class=\"small\">NIL leaves are implicit (not drawn)</span></div>\n      </div>\n\n      <div style=\"margin-top:8px;\" class=\"hint\">\n        Tip: Insert integers. Deleting follows CLRS algorithm and keeps balancing. Use \"Load Example\" for a preset tree.\n      </div>\n\n      <div class=\"log\" id=\"log\"></div>\n      <div class=\"footer\">This demo implements standard red-black insertion and deletion (CLRS-style) with a sentinel NIL node.</div>\n    </div>\n  </div>\n\n  <div class=\"svg-wrap\">\n    <svg id=\"svgCanvas\" viewBox=\"0 0 1200 620\" preserveAspectRatio=\"xMidYMin meet\"></svg>\n  </div>\n</main>\n\n<script>\n/*\n  Red-Black Tree Visualizer\n  - Implements RB tree operations: insert, delete, search\n  - Visualization in SVG with basic animations (CSS transitions)\n  - Sentinel NIL node implementation\n  - Validation checks and log messages\n*/\n\n// Utilities\nconst logEl = document.getElementById('log');\nfunction log(...args) {\n  const line = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');\n  const time = new Date().toLocaleTimeString();\n  logEl.textContent = time + '  ' + line + '\\\\n' + logEl.textContent;\n}\n\n// Colors\nconst RED = 'R', BLACK = 'B';\n\n// Node class with sentinel support\nclass RBNode {\n  constructor(key = null, color = BLACK) {\n    this.key = key;\n    this.color = color;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n    // visualization fields\n    this.x = 0; this.y = 0;\n    this._id = RBNode._nextId++;\n  }\n}\nRBNode._nextId = 1;\n\n// Tree class\nclass RBTree {\n  constructor() {\n    this.NIL = new RBNode(null, BLACK);\n    // NIL's children/parent point to itself for safety\n    this.NIL.left = this.NIL.right = this.NIL.parent = this.NIL;\n    this.root = this.NIL;\n    this.size = 0;\n  }\n\n  leftRotate(x) {\n    const y = x.right;\n    x.right = y.left;\n    if (y.left !== this.NIL) y.left.parent = x;\n    y.parent = x.parent;\n    if (x.parent === this.NIL) {\n      this.root = y;\n    } else if (x === x.parent.left) {\n      x.parent.left = y;\n    } else {\n      x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n    log(`LeftRotate(${x.key})`);\n  }\n\n  rightRotate(y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== this.NIL) x.right.parent = y;\n    x.parent = y.parent;\n    if (y.parent === this.NIL) {\n      this.root = x;\n    } else if (y === y.parent.right) {\n      y.parent.right = x;\n    } else {\n      y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    log(`RightRotate(${y.key})`);\n  }\n\n  insert(key) {\n    // Prevent duplicates for clarity\n    if (this.findNode(key) !== this.NIL) {\n      log(`Insert skipped: key ${key} already present`);\n      return false;\n    }\n    let z = new RBNode(key, RED);\n    z.left = this.NIL; z.right = this.NIL;\n    let y = this.NIL;\n    let x = this.root;\n    while (x !== this.NIL) {\n      y = x;\n      if (z.key < x.key) x = x.left;\n      else x = x.right;\n    }\n    z.parent = y;\n    if (y === this.NIL) this.root = z;\n    else if (z.key < y.key) y.left = z;\n    else y.right = z;\n    this.size++;\n    log(`Insert: ${key}`);\n    this.insertFixup(z);\n    return true;\n  }\n\n  insertFixup(z) {\n    while (z.parent.color === RED) {\n      if (z.parent === z.parent.parent.left) {\n        let y = z.parent.parent.right;\n        if (y.color === RED) {\n          // Case 1\n          z.parent.color = BLACK;\n          y.color = BLACK;\n          z.parent.parent.color = RED;\n          z = z.parent.parent;\n          log('InsertFixup: recolor (case 1)');\n        } else {\n          if (z === z.parent.right) {\n            // Case 2\n            z = z.parent;\n            this.leftRotate(z);\n            log('InsertFixup: rotate left (case 2)');\n          }\n          // Case 3\n          z.parent.color = BLACK;\n          z.parent.parent.color = RED;\n          this.rightRotate(z.parent.parent);\n          log('InsertFixup: rotate right (case 3)');\n        }\n      } else {\n        // mirror\n        let y = z.parent.parent.left;\n        if (y.color === RED) {\n          z.parent.color = BLACK;\n          y.color = BLACK;\n          z.parent.parent.color = RED;\n          z = z.parent.parent;\n          log('InsertFixup: recolor (mirror case 1)');\n        } else {\n          if (z === z.parent.left) {\n            z = z.parent;\n            this.rightRotate(z);\n            log('InsertFixup: rotate right (mirror case 2)');\n          }\n          z.parent.color = BLACK;\n          z.parent.parent.color = RED;\n          this.leftRotate(z.parent.parent);\n          log('InsertFixup: rotate left (mirror case 3)');\n        }\n      }\n    }\n    this.root.color = BLACK;\n    log('Insert done; root set to BLACK');\n  }\n\n  transplant(u, v) {\n    if (u.parent === this.NIL) this.root = v;\n    else if (u === u.parent.left) u.parent.left = v;\n    else u.parent.right = v;\n    v.parent = u.parent;\n  }\n\n  minimum(x) {\n    while (x.left !== this.NIL) x = x.left;\n    return x;\n  }\n\n  delete(key) {\n    let z = this.findNode(key);\n    if (z === this.NIL) {\n      log(`Delete: key ${key} not found`);\n      return false;\n    }\n    log(`Delete: ${key}`);\n    let y = z;\n    let yOriginalColor = y.color;\n    let x;\n    if (z.left === this.NIL) {\n      x = z.right;\n      this.transplant(z, z.right);\n    } else if (z.right === this.NIL) {\n      x = z.left;\n      this.transplant(z, z.left);\n    } else {\n      y = this.minimum(z.right);\n      yOriginalColor = y.color;\n      x = y.right;\n      if (y.parent === z) {\n        x.parent = y;\n      } else {\n        this.transplant(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.transplant(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n      y.color = z.color;\n    }\n    this.size--;\n    if (yOriginalColor === BLACK) {\n      this.deleteFixup(x);\n    }\n    return true;\n  }\n\n  deleteFixup(x) {\n    while (x !== this.root && x.color === BLACK) {\n      if (x === x.parent.left) {\n        let w = x.parent.right;\n        if (w.color === RED) {\n          w.color = BLACK;\n          x.parent.color = RED;\n          this.leftRotate(x.parent);\n          w = x.parent.right;\n          log('DeleteFixup: case 1 (left) - rotate');\n        }\n        if (w.left.color === BLACK && w.right.color === BLACK) {\n          w.color = RED;\n          x = x.parent;\n          log('DeleteFixup: case 2 (left) - recolor');\n        } else {\n          if (w.right.color === BLACK) {\n            w.left.color = BLACK;\n            w.color = RED;\n            this.rightRotate(w);\n            w = x.parent.right;\n            log('DeleteFixup: case 3 (left) - rotate');\n          }\n          w.color = x.parent.color;\n          x.parent.color = BLACK;\n          w.right.color = BLACK;\n          this.leftRotate(x.parent);\n          x = this.root;\n          log('DeleteFixup: case 4 (left) - rotate final');\n        }\n      } else {\n        let w = x.parent.left;\n        if (w.color === RED) {\n          w.color = BLACK;\n          x.parent.color = RED;\n          this.rightRotate(x.parent);\n          w = x.parent.left;\n          log('DeleteFixup: case 1 (right) - rotate');\n        }\n        if (w.right.color === BLACK && w.left.color === BLACK) {\n          w.color = RED;\n          x = x.parent;\n          log('DeleteFixup: case 2 (right) - recolor');\n        } else {\n          if (w.left.color === BLACK) {\n            w.right.color = BLACK;\n            w.color = RED;\n            this.leftRotate(w);\n            w = x.parent.left;\n            log('DeleteFixup: case 3 (right) - rotate');\n          }\n          w.color = x.parent.color;\n          x.parent.color = BLACK;\n          w.left.color = BLACK;\n          this.rightRotate(x.parent);\n          x = this.root;\n          log('DeleteFixup: case 4 (right) - rotate final');\n        }\n      }\n    }\n    x.color = BLACK;\n    log('Delete done; ensured BLACK at node');\n  }\n\n  findNode(key) {\n    let x = this.root;\n    while (x !== this.NIL) {\n      if (key === x.key) return x;\n      x = key < x.key ? x.left : x.right;\n    }\n    return this.NIL;\n  }\n\n  // utility for stats & validation\n  inOrder(node=this.root, fn=(n)=>{}) {\n    if (node === this.NIL) return;\n    this.inOrder(node.left, fn);\n    fn(node);\n    this.inOrder(node.right, fn);\n  }\n\n  height(node=this.root) {\n    if (node === this.NIL) return 0;\n    return 1 + Math.max(this.height(node.left), this.height(node.right));\n  }\n\n  validate() {\n    const results = { rootBlack: false, redProperty: true, blackHeightConsistent: true, blackHeights: [] };\n    results.rootBlack = (this.root === this.NIL) ? true : (this.root.color === BLACK);\n    // red property: red nodes have black children\n    this.inOrder(this.root, (n) => {\n      if (n.color === RED) {\n        if (n.left.color !== BLACK || n.right.color !== BLACK) results.redProperty = false;\n      }\n    });\n    // black-height: all root-to-leaf paths contain same number of black nodes\n    const counts = new Set();\n    const traverse = (node, count) => {\n      if (node.color === BLACK) count++;\n      if (node === this.NIL) {\n        counts.add(count);\n        return;\n      }\n      traverse(node.left, count);\n      traverse(node.right, count);\n    };\n    traverse(this.root, 0);\n    if (counts.size !== 1) results.blackHeightConsistent = false;\n    results.blackHeights = [...counts];\n    return results;\n  }\n}\n\n// Visualization\nconst svg = document.getElementById('svgCanvas');\nconst tree = new RBTree();\nlet animDuration = 450;\n\n// mapping from node id to SVG group\nconst groups = new Map();\nconst edges = new Map();\n\nfunction clearSVG() {\n  while (svg.firstChild) svg.removeChild(svg.firstChild);\n  groups.clear(); edges.clear();\n}\n\nfunction createNodeGroup(n) {\n  const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n  g.classList.add('node-group');\n  g.setAttribute('data-id', n._id);\n  const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n  circle.classList.add('node-circle');\n  circle.setAttribute('r', 18);\n  circle.setAttribute('stroke', n.color === RED ? '#b30000' : '#222');\n  circle.setAttribute('fill', n.color === RED ? 'crimson' : '#111');\n  const txt = document.createElementNS('http://www.w3.org/2000/svg','text');\n  txt.textContent = n.key;\n  g.appendChild(circle);\n  g.appendChild(txt);\n  svg.appendChild(g);\n  groups.set(n._id, {g, circle, txt});\n  // set transitions duration\n  g.style.transitionDuration = animDuration + 'ms';\n  let s = svg.style;\n  return g;\n}\n\nfunction createEdge(id) {\n  const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n  line.classList.add('edge');\n  line.setAttribute('stroke', '#3d5fd7');\n  line.setAttribute('opacity', '0.85');\n  line.setAttribute('x1', 0); line.setAttribute('y1',0); line.setAttribute('x2',0); line.setAttribute('y2',0);\n  svg.insertBefore(line, svg.firstChild); // edges under nodes\n  edges.set(id, line);\n  line.style.transitionDuration = animDuration + 'ms';\n  return line;\n}\n\nfunction updateVisualization() {\n  // compute layout: inorder index gives x, depth gives y\n  const depthMap = new Map();\n  const positions = new Map();\n  let index = 0;\n  const assign = (node, depth) => {\n    if (node === tree.NIL) return;\n    assign(node.left, depth+1);\n    positions.set(node._id, {index: index++, depth});\n    assign(node.right, depth+1);\n  };\n  assign(tree.root, 0);\n  const total = Math.max(1, index);\n  const width = 1100;\n  const leftMargin = 40;\n  const rightMargin = 40;\n  const usable = width - leftMargin - rightMargin;\n  const hSpacing = usable / Math.max(1, (total));\n  const vSpacing = 80;\n\n  // ensure SVG groups and edges exist for each node\n  const existingNodes = new Set(groups.keys());\n  tree.inOrder(tree.root, (n) => {\n    if (!groups.has(n._id)) createNodeGroup(n);\n    existingNodes.delete(n._id);\n  });\n  // remove old groups (shouldn't happen often)\n  for (let rem of existingNodes) {\n    const obj = groups.get(rem);\n    if (obj) {\n      svg.removeChild(obj.g);\n      groups.delete(rem);\n    }\n  }\n\n  // create edges for parent-child pairs\n  const edgeKeys = new Set(edges.keys());\n  tree.inOrder(tree.root, (n) => {\n    if (n.left !== tree.NIL) {\n      const key = `${n._id}-L`;\n      if (!edges.has(key)) createEdge(key);\n      edgeKeys.delete(key);\n    }\n    if (n.right !== tree.NIL) {\n      const key = `${n._id}-R`;\n      if (!edges.has(key)) createEdge(key);\n      edgeKeys.delete(key);\n    }\n  });\n  // remove unused edges\n  for (let rem of edgeKeys) {\n    const line = edges.get(rem);\n    if (line) svg.removeChild(line);\n    edges.delete(rem);\n  }\n\n  // set positions\n  tree.inOrder(tree.root, (n) => {\n    const pos = positions.get(n._id);\n    if (!pos) return;\n    const x = leftMargin + (pos.index + 0.5) * hSpacing;\n    const y = 40 + pos.depth * vSpacing;\n    n.x = x; n.y = y;\n    // node group transform\n    const obj = groups.get(n._id);\n    if (obj) {\n      obj.g.style.transitionDuration = animDuration + 'ms';\n      obj.g.setAttribute('transform', `translate(${x},${y})`);\n      const circle = obj.circle;\n      circle.setAttribute('r', 18);\n      circle.setAttribute('fill', n.color === RED ? 'crimson' : '#111');\n      circle.setAttribute('stroke', n.color === RED ? '#b30000' : '#111');\n      obj.txt.textContent = n.key;\n    }\n    // edges\n    if (n.left !== tree.NIL) {\n      const key = `${n._id}-L`;\n      const line = edges.get(key);\n      if (line) {\n        line.style.transitionDuration = animDuration + 'ms';\n        line.setAttribute('x1', x);\n        line.setAttribute('y1', y+16);\n        line.setAttribute('x2', n.left.x || x-40);\n        line.setAttribute('y2', n.left.y || y+80);\n        line.setAttribute('opacity', 1);\n      }\n    }\n    if (n.right !== tree.NIL) {\n      const key = `${n._id}-R`;\n      const line = edges.get(key);\n      if (line) {\n        line.style.transitionDuration = animDuration + 'ms';\n        line.setAttribute('x1', x);\n        line.setAttribute('y1', y+16);\n        line.setAttribute('x2', n.right.x || x+40);\n        line.setAttribute('y2', n.right.y || y+80);\n        line.setAttribute('opacity', 1);\n      }\n    }\n  });\n\n  // Update stats\n  document.getElementById('count').textContent = tree.size;\n  document.getElementById('height').textContent = tree.height();\n  const v = tree.validate();\n  document.getElementById('validRoot').innerHTML = 'Root black: <span class=\"'+(v.rootBlack? 'valid-ok':'valid-bad')+'\">' + (v.rootBlack? 'OK' : 'NO') + '</span>';\n  document.getElementById('validRed').innerHTML = 'Red rule: <span class=\"'+(v.redProperty? 'valid-ok':'valid-bad')+'\">' + (v.redProperty? 'OK':'VIOLATION') + '</span>';\n  document.getElementById('validBlackHeight').innerHTML = 'Black-height: <span class=\"'+(v.blackHeightConsistent? 'valid-ok':'valid-bad')+'\">' + (v.blackHeightConsistent? 'OK':'INCONSISTENT') + '</span>';\n}\n\n// UI wiring\nconst valueInput = document.getElementById('valueInput');\ndocument.getElementById('insertBtn').addEventListener('click', () => {\n  const val = parseInt(valueInput.value);\n  if (isNaN(val)) { alert('Enter an integer key to insert'); return; }\n  tree.insert(val);\n  updateVisualization();\n});\ndocument.getElementById('deleteBtn').addEventListener('click', () => {\n  const val = parseInt(valueInput.value);\n  if (isNaN(val)) { alert('Enter integer key to delete'); return; }\n  tree.delete(val);\n  updateVisualization();\n});\ndocument.getElementById('searchBtn').addEventListener('click', () => {\n  const val = parseInt(valueInput.value);\n  if (isNaN(val)) { alert('Enter integer key to search'); return; }\n  const n = tree.findNode(val);\n  if (n === tree.NIL) {\n    log(`Search: ${val} not found`);\n    flashNotFound();\n  } else {\n    log(`Search: found ${val}`);\n    flashNode(n);\n  }\n});\n\ndocument.getElementById('randomBtn').addEventListener('click', () => {\n  for (let i=0;i<10;i++) {\n    const r = Math.floor(Math.random()*200) - 50;\n    tree.insert(r);\n  }\n  updateVisualization();\n});\n\ndocument.getElementById('clearBtn').addEventListener('click', () => {\n  // reinitialize tree\n  for (let g of groups.values()) {\n    try { svg.removeChild(g.g); } catch(e){}\n  }\n  for (let e of edges.values()) {\n    try { svg.removeChild(e); } catch(e){}\n  }\n  groups.clear(); edges.clear();\n  tree.root = tree.NIL;\n  tree.size = 0;\n  log('Cleared tree');\n  updateVisualization();\n});\n\ndocument.getElementById('exampleBtn').addEventListener('click', () => {\n  const keys = [41, 38, 31, 12, 19, 8, 70, 50, 60, 85, 90, 95, 5, 15];\n  for (let k of keys) tree.insert(k);\n  updateVisualization();\n});\n\ndocument.getElementById('animRange').addEventListener('input', (e) => {\n  animDuration = parseInt(e.target.value);\n  document.getElementById('animVal').textContent = animDuration;\n  // apply duration to existing nodes/edges\n  for (let obj of groups.values()) obj.g.style.transitionDuration = animDuration + 'ms';\n  for (let l of edges.values()) l.style.transitionDuration = animDuration + 'ms';\n});\n\n// small visual helpers\nfunction flashNode(n) {\n  if (n === tree.NIL) return;\n  const obj = groups.get(n._id);\n  if (!obj) return;\n  const orig = obj.circle.getAttribute('stroke');\n  obj.circle.setAttribute('stroke', '#ffd54f');\n  setTimeout(()=> {\n    obj.circle.setAttribute('stroke', n.color === RED ? '#b30000' : '#111');\n  }, 800);\n}\nfunction flashNotFound() {\n  const prev = svg.style.background;\n  svg.style.transition = 'background 200ms';\n  svg.style.background = '#ffecec';\n  setTimeout(()=> svg.style.background = prev, 700);\n}\n\n// initial empty viz\nupdateVisualization();\nlog('Red-Black Tree visualizer ready.');\n\n// Keyboard shortcuts\nwindow.addEventListener('keydown', (e) => {\n  if (e.key === 'Enter') { document.getElementById('insertBtn').click(); }\n});\n\n// expose tree for debugging in console\nwindow._rbtree = tree;\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Red-Black Tree"
    }
  ],
  "topic": "Red-Black Tree",
  "hasFSM": false,
  "hasTest": true
}