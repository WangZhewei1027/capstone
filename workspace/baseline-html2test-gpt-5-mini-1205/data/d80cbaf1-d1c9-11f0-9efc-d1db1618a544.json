{
  "id": "d80cbaf1-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:54.663Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>K-Means Clustering Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 0; display: flex; height: 100vh; }\n  #left { width: 360px; padding: 16px; border-right: 1px solid #ddd; box-sizing: border-box; overflow:auto; background:#fafafa; }\n  h1 { margin: 0 0 12px 0; font-size: 20px; }\n  label { display:block; margin-top:10px; font-size:13px; color:#333; }\n  input[type=range] { width:100%; }\n  .row { display:flex; gap:8px; align-items:center; margin-top:8px; }\n  button { padding:8px 10px; border-radius:6px; border:1px solid #bbb; background:white; cursor:pointer; }\n  button.primary { background:#0069ff; color:white; border-color:#0059dd; }\n  select, input[type=number] { padding:6px; border-radius:6px; border:1px solid #bbb; }\n  #canvasWrap { flex:1; display:flex; align-items:stretch; justify-content:center; background:#fff; }\n  canvas { width:100%; height:100%; display:block; }\n  .small { font-size:12px; color:#444 }\n  .info { margin-top:10px; font-size:13px; color:#222; background:#fff; padding:8px; border-radius:6px; border:1px solid #eee; }\n  .muted { color:#666; font-size:12px; }\n  .controls-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; }\n  footer { margin-top:12px; font-size:12px; color:#666; }\n  .toggle { display:flex; gap:8px; align-items:center; margin-top:8px; }\n  .kbd { background:#f3f3f3; padding:2px 6px; border-radius:4px; border:1px solid #e6e6e6; font-family:monospace; font-size:12px; }\n</style>\n</head>\n<body>\n  <div id=\"left\">\n    <h1>K-Means Clustering — Interactive Demo</h1>\n    <div class=\"muted\">Explore clustering by generating points, choosing K and initialization, then run step-by-step or animate.</div>\n\n    <label>K (number of clusters): <span id=\"kVal\">3</span></label>\n    <input id=\"kRange\" type=\"range\" min=\"1\" max=\"12\" value=\"3\">\n\n    <label>Points: <span id=\"nVal\">150</span></label>\n    <input id=\"nRange\" type=\"range\" min=\"5\" max=\"800\" value=\"150\">\n\n    <label>Initialization method</label>\n    <select id=\"initMethod\">\n      <option value=\"random\">Random (uniform)</option>\n      <option value=\"kmeans++\">K-Means++</option>\n      <option value=\"manual\">Manual (place centroids)</option>\n    </select>\n\n    <div class=\"row\">\n      <button id=\"generateBtn\">Generate Points</button>\n      <button id=\"clearBtn\">Clear Points</button>\n    </div>\n\n    <div style=\"height:8px\"></div>\n\n    <div class=\"row\">\n      <button id=\"initBtn\">Initialize Centroids</button>\n      <button id=\"resetBtn\">Reset Clustering</button>\n    </div>\n\n    <div style=\"height:8px\"></div>\n\n    <div class=\"row\">\n      <button id=\"startBtn\" class=\"primary\">Start</button>\n      <button id=\"stepBtn\">Step</button>\n      <button id=\"stopBtn\">Pause</button>\n    </div>\n\n    <label>Animation speed</label>\n    <div class=\"controls-grid\">\n      <button id=\"speedSlow\">Slow</button>\n      <button id=\"speedNormal\" class=\"primary\">Normal</button>\n      <button id=\"speedFast\">Fast</button>\n      <button id=\"speedInstant\">Instant</button>\n    </div>\n\n    <div class=\"toggle\">\n      <input type=\"checkbox\" id=\"dragToggle\" checked>\n      <label for=\"dragToggle\" class=\"small\">Enable dragging (points & centroids)</label>\n    </div>\n\n    <div class=\"info\" id=\"stats\">\n      <div>Iteration: <strong id=\"iter\">0</strong></div>\n      <div>Assigned clusters: <strong id=\"assigned\">0</strong> / <span id=\"totalPoints\">0</span></div>\n      <div>Inertia (sum of squared distances): <strong id=\"inertia\">—</strong></div>\n      <div>Converged: <strong id=\"converged\">No</strong></div>\n    </div>\n\n    <label>Tips</label>\n    <div class=\"muted\">\n      - Click canvas to add points.<br>\n      - If \"Manual\" init selected: click on canvas to place centroids (K times).<br>\n      - Drag points/centroids to experiment.<br>\n      - Use Step to see assignment & update alternately.\n    </div>\n\n    <footer>\n      Built-in demo — K-Means with K-Means++ initialization and manual placement. No external libraries.\n    </footer>\n  </div>\n\n  <div id=\"canvasWrap\">\n    <canvas id=\"c\"></canvas>\n  </div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('c');\n  const ctx = canvas.getContext('2d');\n  let DPR = window.devicePixelRatio || 1;\n\n  function resizeCanvas() {\n    const rect = canvas.getBoundingClientRect();\n    DPR = window.devicePixelRatio || 1;\n    canvas.width = Math.max(600, rect.width * DPR);\n    canvas.height = Math.max(400, rect.height * DPR);\n    ctx.setTransform(DPR,0,0,DPR,0,0);\n    draw();\n  }\n  window.addEventListener('resize', resizeCanvas);\n\n  // UI elements\n  const kRange = document.getElementById('kRange');\n  const kVal = document.getElementById('kVal');\n  const nRange = document.getElementById('nRange');\n  const nVal = document.getElementById('nVal');\n  const generateBtn = document.getElementById('generateBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const initBtn = document.getElementById('initBtn');\n  const startBtn = document.getElementById('startBtn');\n  const stopBtn = document.getElementById('stopBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const initMethod = document.getElementById('initMethod');\n  const iterEl = document.getElementById('iter');\n  const assignedEl = document.getElementById('assigned');\n  const totalPointsEl = document.getElementById('totalPoints');\n  const inertiaEl = document.getElementById('inertia');\n  const convergedEl = document.getElementById('converged');\n  const dragToggle = document.getElementById('dragToggle');\n\n  const speedSlow = document.getElementById('speedSlow');\n  const speedNormal = document.getElementById('speedNormal');\n  const speedFast = document.getElementById('speedFast');\n  const speedInstant = document.getElementById('speedInstant');\n\n  kVal.textContent = kRange.value;\n  nVal.textContent = nRange.value;\n\n  kRange.addEventListener('input', ()=>{ kVal.textContent = kRange.value; });\n  nRange.addEventListener('input', ()=>{ nVal.textContent = nRange.value; });\n\n  // Colors\n  const COLORS = [\n    '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b',\n    '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#a6cee3', '#b2df8a'\n  ];\n\n  // Data\n  let points = []; // {x,y,cluster}\n  let centroids = []; // {x,y}\n  let k = parseInt(kRange.value);\n  let iteration = 0;\n  let assignedCount = 0;\n  let inertia = 0;\n  let converged = false;\n\n  // Running state\n  let running = false;\n  let animationTimer = null;\n  let stepPhase = 'assign'; // 'assign' or 'update'\n  let speed = 600; // ms per phase; instant => 0\n\n  // Dragging\n  let dragging = null; // {type:'point'|'centroid', idx, offsetX, offsetY}\n  let dragEnabled = dragToggle.checked;\n\n  dragToggle.addEventListener('change', ()=> { dragEnabled = dragToggle.checked; });\n\n  // Utility\n  function rand(min, max){ return Math.random()*(max-min)+min; }\n  function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }\n  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }\n\n  // Generate points in clusters for nicer visuals\n  function generatePoints(n) {\n    points = [];\n    const W = canvas.clientWidth, H = canvas.clientHeight;\n    // Create a few random blob centers\n    const blobs = [];\n    const blobCount = Math.max(2, Math.round(Math.sqrt(n)/2));\n    for (let i=0;i<blobCount;i++){\n      blobs.push({x:rand(40, W-40), y:rand(40,H-40), r:rand(30, Math.max(40, Math.min(120, W/8)))});\n    }\n    for (let i=0;i<n;i++){\n      const b = blobs[Math.floor(Math.random()*blobs.length)];\n      // gaussian like around blob center\n      const angle = Math.random()*Math.PI*2;\n      const rad = Math.abs((Math.random()*1.2 + Math.random()*0.3))*b.r;\n      const x = clamp(b.x + Math.cos(angle)*rad, 10, W-10);\n      const y = clamp(b.y + Math.sin(angle)*rad, 10, H-10);\n      points.push({x,y,cluster: -1});\n    }\n    totalPointsEl.textContent = points.length;\n    iteration = 0;\n    assignedCount = 0;\n    inertia = 0;\n    converged = false;\n    updateStats();\n  }\n\n  function clearPoints() {\n    points = [];\n    centroids = [];\n    iteration = 0;\n    assignedCount = 0;\n    inertia = 0;\n    converged = false;\n    totalPointsEl.textContent = 0;\n    updateStats();\n    draw();\n  }\n\n  // K-Means initialization\n  function initCentroids(method) {\n    k = Math.max(1, Math.min(points.length || 1, parseInt(kRange.value)));\n    centroids = [];\n    if (method === 'random') {\n      // uniform random within canvas\n      const W = canvas.clientWidth, H = canvas.clientHeight;\n      for (let i=0;i<k;i++){\n        centroids.push({x: rand(20, W-20), y: rand(20, H-20)});\n      }\n    } else if (method === 'kmeans++') {\n      if (points.length === 0) {\n        initCentroids('random');\n        return;\n      }\n      // Choose first centroid uniformly from points\n      const pts = points;\n      const first = pts[Math.floor(Math.random()*pts.length)];\n      centroids.push({x:first.x, y:first.y});\n      // choose remaining with probability proportional to D^2\n      while (centroids.length < k) {\n        // compute distances squared to nearest chosen centroid\n        const d2 = pts.map(p => {\n          let d = Infinity;\n          for (const c of centroids){\n            const dx = p.x - c.x, dy = p.y - c.y;\n            const val = dx*dx + dy*dy;\n            if (val < d) d = val;\n          }\n          return d;\n        });\n        const sum = d2.reduce((a,b)=>a+b,0);\n        if (sum === 0) {\n          // all points identical — just pick random points\n          while (centroids.length < k) {\n            const p = pts[Math.floor(Math.random()*pts.length)];\n            centroids.push({x:p.x, y:p.y});\n          }\n          break;\n        }\n        // roulette selection\n        let r = Math.random()*sum;\n        let idx = 0;\n        while (r > d2[idx]) { r -= d2[idx]; idx++; }\n        const p = pts[idx];\n        centroids.push({x:p.x, y:p.y});\n      }\n    } else if (method === 'manual') {\n      // user will place centroids by clicking; nothing to add here\n      // Show instruction in stats\n      // keep centroids empty\n    }\n    iteration = 0;\n    assignedCount = 0;\n    inertia = 0;\n    converged = false;\n    updateStats();\n    draw();\n  }\n\n  // Assign points to nearest centroid\n  function assignClusters() {\n    if (centroids.length === 0) return;\n    assignedCount = 0;\n    inertia = 0;\n    for (let i=0;i<points.length;i++){\n      let best = -1;\n      let bestD = Infinity;\n      for (let j=0;j<centroids.length;j++){\n        const d = dist2(points[i], centroids[j]);\n        if (d < bestD) { bestD = d; best = j; }\n      }\n      if (points[i].cluster !== best) points[i].cluster = best;\n      if (points[i].cluster >= 0) assignedCount++;\n      inertia += bestD;\n    }\n    updateStats();\n  }\n\n  // Update centroids positions as means of assigned points\n  function updateCentroids() {\n    if (centroids.length === 0) return;\n    iteration++;\n    const sums = centroids.map(()=>({x:0,y:0,n:0}));\n    for (const p of points){\n      if (p.cluster >= 0) {\n        sums[p.cluster].x += p.x;\n        sums[p.cluster].y += p.y;\n        sums[p.cluster].n += 1;\n      }\n    }\n    let moved = false;\n    for (let j=0;j<centroids.length;j++){\n      const s = sums[j];\n      if (s.n === 0) {\n        // empty cluster: reinitialize centroid to random point\n        if (points.length>0) {\n          const rp = points[Math.floor(Math.random()*points.length)];\n          if (centroids[j].x !== rp.x || centroids[j].y !== rp.y) moved = true;\n          centroids[j].x = rp.x;\n          centroids[j].y = rp.y;\n        }\n      } else {\n        const nx = s.x / s.n;\n        const ny = s.y / s.n;\n        if (Math.hypot(nx-centroids[j].x, ny-centroids[j].y) > 1e-6) moved = true;\n        centroids[j].x = nx; centroids[j].y = ny;\n      }\n    }\n    converged = !moved;\n    updateStats();\n  }\n\n  function step() {\n    if (centroids.length === 0) return;\n    if (stepPhase === 'assign'){\n      assignClusters();\n      stepPhase = 'update';\n    } else {\n      updateCentroids();\n      stepPhase = 'assign';\n    }\n    draw();\n  }\n\n  function start() {\n    if (centroids.length === 0) {\n      alert('Initialize centroids first (Init Centroids). For manual init choose Manual and click to place K centroids.');\n      return;\n    }\n    running = true;\n    stopBtn.disabled = false;\n    startBtn.disabled = true;\n    stepBtn.disabled = true;\n    initBtn.disabled = true;\n    initMethod.disabled = true;\n    animate();\n  }\n\n  function stop() {\n    running = false;\n    clearInterval(animationTimer);\n    animationTimer = null;\n    stopBtn.disabled = true;\n    startBtn.disabled = false;\n    stepBtn.disabled = false;\n    initBtn.disabled = false;\n    initMethod.disabled = false;\n  }\n\n  function animate() {\n    if (speed === 0) {\n      // instant: run until convergence\n      while (!converged) {\n        if (stepPhase === 'assign') assignClusters();\n        else updateCentroids();\n        if (stepPhase === 'update') stepPhase = 'assign'; // ensure alternation\n        if (centroids.length === 0) break;\n      }\n      draw();\n      stop();\n      return;\n    }\n    // else run with interval\n    if (animationTimer) clearInterval(animationTimer);\n    animationTimer = setInterval(() => {\n      if (!running) return;\n      if (converged) { stop(); return; }\n      step();\n    }, speed);\n  }\n\n  function resetClustering() {\n    // remove cluster labels but keep points & centroids\n    for (const p of points) p.cluster = -1;\n    iteration = 0;\n    assignedCount = 0;\n    inertia = 0;\n    converged = false;\n    stepPhase = 'assign';\n    updateStats();\n    draw();\n  }\n\n  function updateStats() {\n    iterEl.textContent = iteration;\n    assignedEl.textContent = assignedCount;\n    inertiaEl.textContent = isFinite(inertia) ? inertia.toFixed(1) : '—';\n    convergedEl.textContent = converged ? 'Yes' : 'No';\n  }\n\n  // Drawing\n  function draw() {\n    const W = canvas.clientWidth, H = canvas.clientHeight;\n    ctx.clearRect(0,0,W,H);\n    ctx.fillStyle = '#ffffff';\n    ctx.fillRect(0,0,W,H);\n\n    // optionally draw Voronoi? (skip for speed)\n    // Draw points\n    for (let i=0;i<points.length;i++){\n      const p = points[i];\n      const cidx = (p.cluster >= 0 && p.cluster < COLORS.length) ? p.cluster : -1;\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, 4, 0, Math.PI*2);\n      ctx.fillStyle = cidx>=0 ? COLORS[cidx] : '#999999';\n      ctx.fill();\n      ctx.strokeStyle = 'rgba(0,0,0,0.07)';\n      ctx.lineWidth = 1;\n      ctx.stroke();\n    }\n\n    // Draw centroids\n    for (let j=0;j<centroids.length;j++){\n      const c = centroids[j];\n      const color = COLORS[j % COLORS.length];\n      // halo\n      ctx.beginPath();\n      ctx.arc(c.x, c.y, 12, 0, Math.PI*2);\n      ctx.fillStyle = hexToRgba(color, 0.12);\n      ctx.fill();\n      // cross\n      ctx.strokeStyle = color;\n      ctx.lineWidth = 2.4;\n      ctx.beginPath();\n      ctx.moveTo(c.x-10, c.y-10);\n      ctx.lineTo(c.x+10, c.y+10);\n      ctx.moveTo(c.x-10, c.y+10);\n      ctx.lineTo(c.x+10, c.y-10);\n      ctx.stroke();\n      // index label\n      ctx.fillStyle = '#111';\n      ctx.font = '12px system-ui, Arial';\n      ctx.fillText('C'+(j+1), c.x+12, c.y-12);\n    }\n\n    // draw iteration overlay\n    ctx.fillStyle = 'rgba(255,255,255,0.6)';\n    ctx.fillRect(8,8,150,56);\n    ctx.fillStyle = '#222';\n    ctx.font = '12px system-ui, Arial';\n    ctx.fillText(`K = ${centroids.length}`, 14, 26);\n    ctx.fillText(`Iter = ${iteration}`, 14, 44);\n    ctx.fillText(`Inertia = ${inertiaEl.textContent}`, 80, 44);\n  }\n\n  function hexToRgba(hex, alpha) {\n    const h = hex.replace('#','');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    return `rgba(${r},${g},${b},${alpha})`;\n  }\n\n  // Event handlers for canvas interactions: add points, manual centroid placement, dragging\n  function canvasToLocal(e){\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left);\n    const y = (e.clientY - rect.top);\n    return {x, y};\n  }\n\n  canvas.addEventListener('dblclick', (e)=>{\n    // double-click to clear selection? We'll add a point\n    const p = canvasToLocal(e);\n    points.push({x:p.x, y:p.y, cluster:-1});\n    totalPointsEl.textContent = points.length;\n    draw();\n  });\n\n  canvas.addEventListener('click', (e)=>{\n    const pos = canvasToLocal(e);\n    const method = initMethod.value;\n    // If manual init selected AND we haven't placed K centroids yet, place centroid\n    if (method === 'manual' && centroids.length < parseInt(kRange.value)) {\n      centroids.push({x:pos.x, y:pos.y});\n      updateStats();\n      draw();\n      return;\n    }\n    // Otherwise add a point\n    points.push({x:pos.x, y:pos.y, cluster:-1});\n    totalPointsEl.textContent = points.length;\n    draw();\n  });\n\n  // Dragging points and centroids\n  canvas.addEventListener('mousedown', (e)=>{\n    if (!dragEnabled) return;\n    const pos = canvasToLocal(e);\n    // check centroids first (higher priority)\n    for (let j=0;j<centroids.length;j++){\n      const c = centroids[j];\n      if (Math.hypot(pos.x - c.x, pos.y - c.y) < 14) {\n        dragging = {type:'centroid', idx:j, offsetX: pos.x - c.x, offsetY: pos.y - c.y};\n        return;\n      }\n    }\n    // check points\n    for (let i=points.length-1;i>=0;i--){\n      const p = points[i];\n      if (Math.hypot(pos.x - p.x, pos.y - p.y) < 8) {\n        dragging = {type:'point', idx:i, offsetX: pos.x - p.x, offsetY: pos.y - p.y};\n        return;\n      }\n    }\n  });\n  window.addEventListener('mousemove', (e)=>{\n    if (!dragging) return;\n    const pos = canvasToLocal(e);\n    if (dragging.type === 'centroid') {\n      const c = centroids[dragging.idx];\n      c.x = clamp(pos.x - dragging.offsetX, 6, canvas.clientWidth-6);\n      c.y = clamp(pos.y - dragging.offsetY, 6, canvas.clientHeight-6);\n      // when centroids move manually, we should recompute assignment for clarity\n      assignClusters();\n    } else if (dragging.type === 'point') {\n      const p = points[dragging.idx];\n      p.x = clamp(pos.x - dragging.offsetX, 6, canvas.clientWidth-6);\n      p.y = clamp(pos.y - dragging.offsetY, 6, canvas.clientHeight-6);\n      assignClusters();\n    }\n    draw();\n  });\n  window.addEventListener('mouseup', ()=>{ dragging = null; });\n\n  // Buttons\n  generateBtn.addEventListener('click', ()=>{\n    const n = parseInt(nRange.value);\n    generatePoints(n);\n    draw();\n  });\n  clearBtn.addEventListener('click', ()=> {\n    if (!confirm('Clear all points and centroids?')) return;\n    clearPoints();\n  });\n  initBtn.addEventListener('click', ()=>{\n    const method = initMethod.value;\n    // Ensure k not greater than number of points (if method uses points)\n    if (method === 'kmeans++' && points.length === 0) {\n      alert('No points: generate or add points first or use Random init.');\n      return;\n    }\n    k = parseInt(kRange.value);\n    if (method !== 'manual' && k > (points.length || k)) {\n      // If there are zero points, random init may still work\n    }\n    initCentroids(method);\n    stepPhase = 'assign';\n    draw();\n  });\n  startBtn.addEventListener('click', start);\n  stopBtn.addEventListener('click', stop);\n  stepBtn.addEventListener('click', ()=>{ step(); });\n  resetBtn.addEventListener('click', ()=>{ resetClustering(); draw(); });\n\n  // Speeds\n  speedSlow.addEventListener('click', ()=> { speed = 1200; setSpeedButton(speedSlow); });\n  speedNormal.addEventListener('click', ()=> { speed = 600; setSpeedButton(speedNormal); });\n  speedFast.addEventListener('click', ()=> { speed = 200; setSpeedButton(speedFast); });\n  speedInstant.addEventListener('click', ()=> { speed = 0; setSpeedButton(speedInstant); });\n  function setSpeedButton(btn){\n    [speedSlow, speedNormal, speedFast, speedInstant].forEach(b=>b.classList.remove('primary'));\n    btn.classList.add('primary');\n    if (running) animate();\n  }\n\n  // Initialization on load\n  resizeCanvas();\n  generatePoints(parseInt(nRange.value));\n  draw();\n  updateStats();\n\n  // Keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if (e.key === ' ') { // space toggles start/pause\n      e.preventDefault();\n      if (running) stop(); else start();\n    } else if (e.key === 's') {\n      step();\n    }\n  });\n\n  // Prevent selection/drag interfering with canvas drag\n  canvas.addEventListener('dragstart', (e)=> e.preventDefault());\n\n  // Convenience: If K reduced while centroids exist, trim\n  kRange.addEventListener('change', ()=>{\n    const newK = parseInt(kRange.value);\n    if (centroids.length > newK) centroids = centroids.slice(0,newK);\n    draw();\n  });\n\n  // If points added/removed while running, adjust behaviour\n  // Not necessary, but ensure totalPoints updated\n  // update total points whenever points array mutated (we update in all places)\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": false,
  "hasTest": true
}