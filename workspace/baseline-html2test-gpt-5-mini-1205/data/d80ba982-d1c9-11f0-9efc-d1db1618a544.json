{
  "id": "d80ba982-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:36.951Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Knapsack Problem",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Interactive Knapsack Problem (0/1) — Dynamic Programming Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 18px; color:#111; background: #fafafa; }\n  h1 { margin: 0 0 8px; font-size: 20px; }\n  .container { display: grid; grid-template-columns: 360px 1fr; gap: 18px; align-items: start; }\n  .panel { background: #fff; border: 1px solid #e2e6ea; padding: 12px; border-radius: 8px; box-shadow: 0 1px 2px rgba(16,24,40,0.03); }\n  label { display:block; font-size: 13px; margin-top: 8px; color:#333; }\n  input[type=number] { width: 100%; padding: 6px 8px; margin-top:6px; box-sizing:border-box; }\n  button { padding: 8px 10px; border-radius: 6px; border: 1px solid #cbd5e1; background: linear-gradient(#fff,#f8fafc); cursor: pointer; margin-right:6px; }\n  button.primary { background: linear-gradient(#2563eb,#1d4ed8); color: #fff; border: none; }\n  button.warn { background: linear-gradient(#f97316,#ea580c); color:#fff; border:none; }\n  .items-list { margin-top: 8px; font-size: 14px; }\n  ul { padding-left: 18px; margin: 6px 0; }\n  .grid-wrap { overflow: auto; max-height: 640px; border-radius: 6px; border: 1px solid #eef2f7; background:#fff; padding: 8px; }\n  table.dp { border-collapse: collapse; font-size: 12px; }\n  table.dp td, table.dp th { border: 1px solid #e6eef6; padding: 6px 8px; text-align:center; min-width: 52px; vertical-align: middle; }\n  table.dp th { background:#f1f5f9; font-weight:600; position: sticky; top:0; z-index:1; }\n  .cell-value { font-weight:700; font-size:13px; display:block; }\n  .cell-sub { font-size:11px; color:#475569; }\n  .taken { background: linear-gradient(135deg,#bbf7d0,#86efac); }\n  .trace { outline: 3px solid rgba(99,102,241,0.18); }\n  .controls { margin-top: 10px; }\n  .explain { font-size: 13px; color:#284; margin-top: 8px; background:#fefce8; padding:8px; border-radius:6px; border:1px solid #fef3c7; }\n  .small { font-size: 12px; color:#475569; }\n  .row-header { background:#eef2ff; font-weight:700; min-width: 72px; position: sticky; left:0; z-index:2; }\n  .legend { display:flex; gap:8px; margin-top:8px; align-items:center; }\n  .legend span { display:inline-block; padding:6px 8px; border-radius:6px; font-size:12px; }\n  .legend .l-taken { background: linear-gradient(135deg,#bbf7d0,#86efac); border:1px solid #c7f0d0;}\n  .legend .l-trace { outline:3px solid rgba(99,102,241,0.18); background:#fff;}\n  footer { margin-top:12px; color:#64748b; font-size:12px; }\n  .flex { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }\n  .item-row { display:flex; gap:8px; align-items:center; margin-top:6px; }\n  .item-row input { width: 100px; }\n  .note { color:#475569; font-size:13px; margin-top:10px; }\n</style>\n</head>\n<body>\n  <h1>Knapsack Problem — Interactive 0/1 Dynamic Programming Demo</h1>\n  <div class=\"container\">\n    <div class=\"panel\">\n      <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n        <strong>Controls & Items</strong>\n        <small class=\"small\">0/1 knapsack (items indivisible)</small>\n      </div>\n\n      <label>Capacity (W) — max 200 recommended</label>\n      <input id=\"capacity\" type=\"number\" value=\"20\" min=\"1\" max=\"500\">\n\n      <div class=\"item-row\">\n        <label style=\"flex:1;\">Add Item — weight</label>\n        <input id=\"newWeight\" type=\"number\" value=\"6\" min=\"1\" style=\"width:80px;\">\n        <label style=\"width:40px;text-align:center;\">value</label>\n        <input id=\"newValue\" type=\"number\" value=\"30\" min=\"0\" style=\"width:80px;\">\n        <button id=\"addItemBtn\">Add</button>\n      </div>\n\n      <div class=\"controls\">\n        <button id=\"solveBtn\" class=\"primary\">Solve (DP)</button>\n        <button id=\"stepBtn\">Step-by-step</button>\n        <button id=\"stopBtn\" style=\"display:none;\">Stop</button>\n        <button id=\"randomBtn\">Random Items</button>\n        <button id=\"clearBtn\" class=\"warn\">Clear Items</button>\n      </div>\n\n      <div class=\"items-list panel\" style=\"margin-top:10px;\">\n        <strong>Items (index: weight, value)</strong>\n        <div id=\"itemsDiv\" class=\"small\"></div>\n        <div style=\"margin-top:8px;\">\n          <button id=\"removeLastBtn\">Remove Last</button>\n          <button id=\"autoFillBtn\">Fill Example (classic)</button>\n        </div>\n      </div>\n\n      <div class=\"explain\">\n        How it works: We build a DP table dp[i][w] = best value using first i items with capacity w.\n        Reconstruction follows: if dp[i][w] != dp[i-1][w] then item i was taken.\n      </div>\n\n      <div class=\"note\">\n        Try different capacities and item sets. Use Step-by-step to watch rows being computed.\n      </div>\n\n      <div style=\"margin-top:10px;\">\n        <div class=\"legend\">\n          <span class=\"l-taken\">Taken in optimal solution</span>\n          <span class=\"l-trace\">Trace path (reconstruction)</span>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n        <strong>DP Table & Results</strong>\n        <div class=\"small\">Columns: capacity 0..W</div>\n      </div>\n\n      <div id=\"results\" class=\"small\" style=\"margin-top:8px;\"></div>\n      <div class=\"grid-wrap\" id=\"gridWrap\" style=\"margin-top:8px;\">\n        <div id=\"tableContainer\"></div>\n      </div>\n\n      <div style=\"margin-top:10px; display:flex; gap:8px; align-items:center;\">\n        <button id=\"showTakenBtn\">Show Selected Items</button>\n        <button id=\"highlightTraceBtn\">Highlight Reconstruction Path</button>\n        <button id=\"clearHighlightsBtn\">Clear Highlights</button>\n      </div>\n\n      <div id=\"fracDiv\" class=\"small\" style=\"margin-top:10px;\"></div>\n      <footer>\n        Note: This demo calculates 0/1 knapsack optimally. For fractional knapsack (continuous items), greedy by value/weight works.\n      </footer>\n    </div>\n  </div>\n\n<script>\n(function(){\n  // State\n  let items = []; // each {w,v}\n  let capacityEl = document.getElementById('capacity');\n  let itemsDiv = document.getElementById('itemsDiv');\n  let tableContainer = document.getElementById('tableContainer');\n  let results = document.getElementById('results');\n  let fracDiv = document.getElementById('fracDiv');\n\n  // DP structures\n  let dp = null; // 2D array\n  let n = 0;\n  let W = 0;\n  let running = false;\n  let stepMode = false;\n  let stepTimer = null;\n\n  // Helpers\n  function renderItems(){\n    if(items.length === 0){ itemsDiv.innerHTML = \"<em>No items</em>\"; return; }\n    let out = '<ul>';\n    for(let i=0;i<items.length;i++){\n      out += `<li>i=${i+1}: weight=${items[i].w}, value=${items[i].v}</li>`;\n    }\n    out += '</ul>';\n    itemsDiv.innerHTML = out;\n  }\n\n  function clampCapacityVal(){\n    let val = parseInt(capacityEl.value) || 0;\n    if(val < 1) val = 1;\n    if(val > 500) val = 500;\n    capacityEl.value = val;\n    return val;\n  }\n\n  function buildEmptyDP(n, W){\n    // creates (n+1) x (W+1) zeroed\n    let a = new Array(n+1);\n    for(let i=0;i<=n;i++){\n      a[i] = new Array(W+1).fill(0);\n    }\n    return a;\n  }\n\n  function colorForValue(val){\n    // return background color based on magnitude (simple)\n    if(val === 0) return '#fff';\n    let t = Math.min(1, val/200); // scale\n    let r = Math.round(240 - 80*t);\n    let g = Math.round(250 - 160*(1-t));\n    let b = Math.round(255 - 30*t);\n    return `rgb(${r},${g},${b})`;\n  }\n\n  function renderTable(dpTable){\n    // build HTML table for dp array\n    if(!dpTable) { tableContainer.innerHTML = '<div class=\"small\">No DP computed yet.</div>'; return; }\n    let rows = dpTable.length - 1;\n    let cols = dpTable[0].length - 1;\n    let html = '<table class=\"dp\" id=\"dpTable\">';\n    // header row\n    html += '<tr><th class=\"row-header\">i \\\\ w</th>';\n    for(let w=0; w<=cols; w++){\n      html += `<th>${w}</th>`;\n    }\n    html += '</tr>';\n    for(let i=0;i<=rows;i++){\n      html += `<tr>`;\n      if(i===0){\n        html += `<th class=\"row-header\">i=0</th>`;\n      } else {\n        html += `<th class=\"row-header\">i=${i} (w=${items[i-1].w}, v=${items[i-1].v})</th>`;\n      }\n      for(let w=0; w<=cols; w++){\n        let val = dpTable[i][w];\n        let bg = colorForValue(val);\n        html += `<td id=\"cell-${i}-${w}\" style=\"background:${bg}\"><span class=\"cell-value\">${val}</span>`;\n        if(i>0){\n          html += `<span class=\"cell-sub\">(${i-1},${w})</span>`;\n        } else {\n          html += `<span class=\"cell-sub\">base</span>`;\n        }\n        html += `</td>`;\n      }\n      html += `</tr>`;\n    }\n    html += '</table>';\n    tableContainer.innerHTML = html;\n  }\n\n  function computeDPFull(){\n    n = items.length;\n    W = clampCapacityVal();\n    // size guard\n    if(W > 300){\n      if(!confirm(\"Capacity > 300 may create a large table and be slow. Continue?\")) return;\n    }\n    dp = buildEmptyDP(n, W);\n\n    // Standard 0/1 knapsack DP\n    for(let i=1;i<=n;i++){\n      let wi = items[i-1].w;\n      let vi = items[i-1].v;\n      for(let w=0; w<=W; w++){\n        if(wi <= w){\n          let take = dp[i-1][w-wi] + vi;\n          let notake = dp[i-1][w];\n          dp[i][w] = Math.max(take, notake);\n        } else {\n          dp[i][w] = dp[i-1][w];\n        }\n      }\n    }\n    renderTable(dp);\n    displayResult();\n    computeFractionalGreedy();\n  }\n\n  function computeFractionalGreedy(){\n    // For comparison: fractional knapsack (continuous) greedy\n    let Wcap = clampCapacityVal();\n    let arr = items.map((it, idx) => ({idx: idx+1, w:it.w, v:it.v, r: it.v/it.w}));\n    arr.sort((a,b)=>b.r - a.r);\n    let remaining = Wcap;\n    let value = 0;\n    let taken = [];\n    for(let it of arr){\n      if(remaining === 0) break;\n      if(it.w <= remaining){\n        taken.push({idx: it.idx, w: it.w, v: it.v, frac:1});\n        value += it.v;\n        remaining -= it.w;\n      } else {\n        let frac = remaining / it.w;\n        taken.push({idx: it.idx, w: it.w, v: it.v, frac: frac});\n        value += it.v * frac;\n        remaining = 0;\n        break;\n      }\n    }\n    // render summary\n    let s = `<strong>Fractional (greedy) optimum:</strong> value ≈ ${value.toFixed(2)}; items: `;\n    s += taken.map(t => `#${t.idx}${t.frac<1?('('+ (t.frac*100|0) +'% )'):''}`).join(', ');\n    fracDiv.innerHTML = s;\n  }\n\n  function displayResult(){\n    if(!dp) return;\n    let best = dp[n][W];\n    results.innerHTML = `<strong>Optimal value:</strong> ${best} for capacity W=${W}. Items count: ${n}.`;\n  }\n\n  function reconstructSelected(){\n    if(!dp) return [];\n    let sel = new Array(n).fill(false);\n    let i = n;\n    let w = W;\n    let path = [];\n    while(i > 0){\n      if(dp[i][w] !== dp[i-1][w]){\n        // taken\n        sel[i-1] = true;\n        path.push({i:i, w:w, taken:true});\n        w -= items[i-1].w;\n        i -= 1;\n      } else {\n        path.push({i:i, w:w, taken:false});\n        i -= 1;\n      }\n    }\n    return {selected: sel, path: path};\n  }\n\n  function showSelectedOnTable(){\n    clearHighlights();\n    if(!dp){\n      alert(\"Compute DP first (Solve).\");\n      return;\n    }\n    let res = reconstructSelected();\n    const sel = res.selected;\n    // mark cells where item included: those dp[i][w] equal dp[i-1][w-wi] + vi and chosen in backtrace.\n    let i = n; let w = W;\n    while(i > 0){\n      let cell = document.getElementById(`cell-${i}-${w}`);\n      if(!cell){ i--; continue; }\n      if(sel[i-1]){\n        // color this cell as taken\n        cell.classList.add('taken');\n        // step back to w - wi\n        w -= items[i-1].w;\n      }\n      i--;\n    }\n    // highlight those item rows in the header perhaps: we'll also show list\n    let chosen = sel.map((v,idx)=> v ? `#${idx+1}` : null).filter(Boolean);\n    let best = dp[n][W];\n    results.innerHTML = `<strong>Optimal value:</strong> ${best} (selected items: ${chosen.join(', ') || 'none'})`;\n  }\n\n  function highlightTrace(){\n    // highlight the exact reconstruction path cells (i,w) visited when reconstructing\n    clearHighlights();\n    if(!dp){ alert(\"Compute DP first.\"); return; }\n    let i = n;\n    let w = W;\n    let visited = [];\n    while(i > 0){\n      visited.push({i:i, w:w});\n      if(dp[i][w] !== dp[i-1][w]){\n        w -= items[i-1].w;\n        i -= 1;\n      } else {\n        i -= 1;\n      }\n    }\n    visited.push({i:0, w:w});\n    for(const p of visited){\n      let cell = document.getElementById(`cell-${p.i}-${p.w}`);\n      if(cell) cell.classList.add('trace');\n    }\n    results.innerHTML = `<strong>Trace length:</strong> ${visited.length}. Reconstructing from (i=${n}, w=${W}) to base.`;\n  }\n\n  function clearHighlights(){\n    let cells = tableContainer.querySelectorAll('td');\n    cells.forEach(c => { c.classList.remove('taken'); c.classList.remove('trace'); });\n    displayResult();\n  }\n\n  // Step-by-step animation: fill DP row by row and update table progressively\n  function computeDPWithSteps(){\n    if(running) return;\n    stepMode = true;\n    n = items.length;\n    W = clampCapacityVal();\n    if(n === 0){ alert(\"Add some items first.\"); return; }\n    dp = buildEmptyDP(n, W);\n    renderTable(dp);\n    let i = 1;\n    running = true;\n    document.getElementById('solveBtn').disabled = true;\n    document.getElementById('stepBtn').style.display = 'none';\n    document.getElementById('stopBtn').style.display = 'inline-block';\n    stepTimer = setInterval(()=>{\n      if(i>n || !running){\n        clearInterval(stepTimer);\n        running = false;\n        stepMode = false;\n        document.getElementById('solveBtn').disabled = false;\n        document.getElementById('stepBtn').style.display = 'inline-block';\n        document.getElementById('stopBtn').style.display = 'none';\n        renderTable(dp);\n        displayResult();\n        computeFractionalGreedy();\n        return;\n      }\n      // compute row i\n      let wi = items[i-1].w, vi = items[i-1].v;\n      for(let w=0; w<=W; w++){\n        if(wi <= w){\n          let take = dp[i-1][w-wi] + vi;\n          let notake = dp[i-1][w];\n          dp[i][w] = Math.max(take, notake);\n        } else {\n          dp[i][w] = dp[i-1][w];\n        }\n      }\n      // update only row i in DOM\n      updateRowInDOM(i);\n      i++;\n    }, 350);\n  }\n\n  function updateRowInDOM(i){\n    // Ensure table exists, else render\n    let tbl = document.getElementById('dpTable');\n    if(!tbl){ renderTable(dp); return; }\n    for(let w=0; w<=W; w++){\n      let cell = document.getElementById(`cell-${i}-${w}`);\n      if(cell){\n        let val = dp[i][w];\n        cell.querySelector('.cell-value').textContent = val;\n        cell.style.background = colorForValue(val);\n      }\n    }\n    // small message:\n    results.innerHTML = `Computing row i=${i}...`;\n  }\n\n  // UI event bindings\n  document.getElementById('addItemBtn').addEventListener('click', ()=>{\n    let w = parseInt(document.getElementById('newWeight').value) || 0;\n    let v = parseInt(document.getElementById('newValue').value) || 0;\n    if(w <= 0){ alert(\"Weight must be positive integer.\"); return; }\n    items.push({w:w, v:v});\n    renderItems();\n  });\n\n  document.getElementById('removeLastBtn').addEventListener('click', ()=>{\n    if(items.length === 0) return;\n    items.pop();\n    renderItems();\n  });\n\n  document.getElementById('clearBtn').addEventListener('click', ()=>{\n    if(!confirm(\"Clear all items?\")) return;\n    items = [];\n    renderItems();\n    dp = null;\n    tableContainer.innerHTML = '';\n    results.innerHTML = '';\n    fracDiv.innerHTML = '';\n  });\n\n  document.getElementById('randomBtn').addEventListener('click', ()=>{\n    let count = Math.max(4, Math.min(18, Math.round(Math.random()*12 + 4)));\n    items = [];\n    for(let i=0;i<count;i++){\n      let w = Math.max(1, Math.round(Math.random()*12));\n      let v = Math.max(1, Math.round(Math.random()*35));\n      items.push({w:w, v:v});\n    }\n    renderItems();\n  });\n\n  document.getElementById('autoFillBtn').addEventListener('click', ()=>{\n    // classic example\n    items = [\n      {w: 12, v:4},\n      {w: 2, v:2},\n      {w: 1, v:1},\n      {w: 1, v:2},\n      {w: 4, v:10}\n    ];\n    capacityEl.value = 15;\n    renderItems();\n  });\n\n  document.getElementById('solveBtn').addEventListener('click', ()=>{\n    if(items.length === 0){ alert(\"Add items first.\"); return; }\n    computeDPFull();\n  });\n\n  document.getElementById('stepBtn').addEventListener('click', ()=>{\n    if(items.length === 0){ alert(\"Add items first.\"); return; }\n    computeDPWithSteps();\n  });\n\n  document.getElementById('stopBtn').addEventListener('click', ()=>{\n    running = false;\n    stepMode = false;\n    clearInterval(stepTimer);\n    document.getElementById('solveBtn').disabled = false;\n    document.getElementById('stepBtn').style.display = 'inline-block';\n    document.getElementById('stopBtn').style.display = 'none';\n    if(dp) { renderTable(dp); displayResult(); computeFractionalGreedy(); }\n  });\n\n  document.getElementById('showTakenBtn').addEventListener('click', showSelectedOnTable);\n  document.getElementById('highlightTraceBtn').addEventListener('click', highlightTrace);\n  document.getElementById('clearHighlightsBtn').addEventListener('click', clearHighlights);\n\n  // Initialize with a small example\n  items = [\n    {w:6, v:30},\n    {w:3, v:14},\n    {w:4, v:16},\n    {w:2, v:9}\n  ];\n  renderItems();\n  // computeDPFull();\n\n  // Make table responsive to capacity changes: if dp exists and capacity changed, clear dp\n  capacityEl.addEventListener('change', ()=>{\n    dp = null;\n    tableContainer.innerHTML = '';\n    results.innerHTML = '';\n    fracDiv.innerHTML = '';\n  });\n\n  // keyboard convenience: Enter in newValue adds item\n  document.getElementById('newValue').addEventListener('keydown', (e)=>{\n    if(e.key === 'Enter') document.getElementById('addItemBtn').click();\n  });\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Knapsack Problem"
    }
  ],
  "topic": "Knapsack Problem",
  "hasFSM": false,
  "hasTest": true
}