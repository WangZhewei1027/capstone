{
  "id": "d80b0d40-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:28.670Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Counting Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Counting Sort Visualization</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, Helvetica, Arial; margin: 16px; color:#111;}\n  h1 { margin: 0 0 8px 0; font-size: 20px; }\n  .top { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:12px;}\n  .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }\n  input[type=\"text\"] { width:260px; padding:6px; border-radius:6px; border:1px solid #ccc;}\n  button { padding:8px 10px; border-radius:6px; border:1px solid #888; background:#f4f4f4; cursor:pointer;}\n  button:active { transform:translateY(1px); }\n  label { font-size:13px; color:#333; }\n  .panel { border:1px solid #e0e0e0; padding:12px; border-radius:8px; background:#fafafa; margin-bottom:12px;}\n  .viz { display:flex; gap:20px; align-items:flex-end; min-height:160px; padding:8px 4px;}\n  .array { display:flex; gap:6px; align-items:flex-end; }\n  .bar { width:28px; height:40px; background:#b3d4fc; display:flex; align-items:flex-end; justify-content:center; border-radius:6px 6px 0 0; box-shadow: inset 0 -3px rgba(0,0,0,0.05); position:relative; transition: transform 300ms ease, background 200ms; }\n  .bar.hidden { background:transparent; box-shadow:none; }\n  .bar .lbl { font-size:12px; padding:4px; color:#042a4f; }\n  .bar.small { width:22px; font-size:11px; }\n  .bar.highlight { background:#ffda7b; transform:translateY(-8px); }\n  .bar.target { background:#9be7b7; transform:translateY(-8px); }\n  .counts { display:flex; gap:6px; align-items:flex-end; padding:6px; background:#fff; border-radius:6px; border:1px solid #eee; }\n  .countBox { width:48px; min-height:42px; background:#fff; border-radius:6px; border:1px solid #ddd; text-align:center; padding:6px; box-sizing:border-box; transition: transform 200ms, background 200ms, border-color 200ms; }\n  .countBox .idx { font-size:11px; color:#666; }\n  .countBox .ct { font-weight:700; font-size:16px; color:#0b3b2f; }\n  .countBox.active { background:#fff7e6; border-color:#ffcf66; transform:translateY(-6px); }\n  .countBox.cum { background:#eaf6ff; border-color:#88c0ff; transform:translateY(-6px); }\n  .output { display:flex; gap:6px; align-items:flex-end; padding:6px; }\n  .desc { margin-top:6px; font-size:13px; color:#222; }\n  .status { margin-left:8px; font-size:13px; color:#444; }\n  .small { font-size:13px; color:#555; }\n  .controls-row { display:flex; gap:8px; align-items:center; margin-top:8px;}\n  .slider { width:160px; }\n  .footer { font-size:13px; color:#444; margin-top:10px; }\n  .warning { color:#8a2300; font-weight:600; }\n  .flexcol { display:flex; flex-direction:column; gap:8px; }\n  .muted { color:#666; font-size:13px; }\n  @media (max-width:720px){ .bar { width:22px; } .countBox{ width:40px; } }\n</style>\n</head>\n<body>\n  <h1>Counting Sort — Interactive Visualization</h1>\n  <div class=\"top\">\n    <div class=\"panel\">\n      <div class=\"controls\">\n        <label>Array (comma-separated):</label>\n        <input id=\"inputArray\" type=\"text\" value=\"4, 2, -1, 3, 2, 0, -1\">\n        <button id=\"loadBtn\">Load</button>\n        <button id=\"randBtn\">Random</button>\n        <label class=\"small\">Size:\n          <input id=\"randSize\" type=\"number\" min=\"1\" max=\"60\" value=\"10\" style=\"width:60px; margin-left:6px;\">\n        </label>\n        <label class=\"small\">Min:\n          <input id=\"randMin\" type=\"number\" value=\"-5\" style=\"width:60px; margin-left:6px;\">\n        </label>\n        <label class=\"small\">Max:\n          <input id=\"randMax\" type=\"number\" value=\"8\" style=\"width:60px; margin-left:6px;\">\n        </label>\n      </div>\n      <div class=\"controls-row\">\n        <button id=\"startBtn\">Start</button>\n        <button id=\"pauseBtn\" disabled>Pause</button>\n        <button id=\"stepBtn\">Step</button>\n        <button id=\"resetBtn\">Reset</button>\n        <label class=\"small\">Speed:\n          <input id=\"speed\" class=\"slider\" type=\"range\" min=\"50\" max=\"1200\" value=\"300\">\n        </label>\n        <span class=\"status\" id=\"status\">Idle</span>\n      </div>\n      <div class=\"muted\">Note: Counting Sort works best when range (max-min+1) is reasonably small. Visualization limits range to 70 for clarity.</div>\n    </div>\n\n    <div style=\"min-width:320px; flex:1;\">\n      <div class=\"panel flexcol\">\n        <div><strong>Current Phase:</strong> <span id=\"phase\">Not started</span></div>\n        <div id=\"message\" class=\"muted\">Load or generate an array, then press Start.</div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"panel\">\n    <div style=\"display:flex; gap:18px; align-items:flex-start; flex-wrap:wrap;\">\n      <div style=\"flex:1; min-width:220px;\">\n        <div><strong>Input Array</strong></div>\n        <div class=\"viz\" id=\"inputViz\"></div>\n      </div>\n\n      <div style=\"flex:1; min-width:240px;\">\n        <div><strong>Counts Array (Indexes shown are actual values)</strong></div>\n        <div style=\"overflow:auto; padding-top:8px;\">\n          <div id=\"countsViz\" class=\"counts\"></div>\n        </div>\n      </div>\n\n      <div style=\"flex:1; min-width:220px;\">\n        <div><strong>Output Array</strong></div>\n        <div id=\"outputViz\" class=\"viz\"></div>\n      </div>\n    </div>\n\n    <div class=\"desc\" id=\"explain\">Explanation: Counting sort tallies how often each distinct value appears, computes cumulative counts, and then places each element into the correct output position (processing input from right to left to keep the sort stable).</div>\n  </div>\n\n  <div class=\"footer\">This demo supports negative values by offsetting counts using the minimum value. Range limited to 70 for visualization clarity.</div>\n\n<script>\n/*\n  Counting Sort Visualization\n  - Uses a generator to yield atomic actions so the UI can step/animate.\n  - Supports negative numbers by offsetting by min value.\n  - Limits the range to avoid too-large visualizations.\n*/\n\n// DOM refs\nconst inputEl = document.getElementById('inputArray');\nconst loadBtn = document.getElementById('loadBtn');\nconst randBtn = document.getElementById('randBtn');\nconst randSize = document.getElementById('randSize');\nconst randMin = document.getElementById('randMin');\nconst randMax = document.getElementById('randMax');\nconst startBtn = document.getElementById('startBtn');\nconst pauseBtn = document.getElementById('pauseBtn');\nconst stepBtn = document.getElementById('stepBtn');\nconst resetBtn = document.getElementById('resetBtn');\nconst speedEl = document.getElementById('speed');\nconst statusEl = document.getElementById('status');\nconst phaseEl = document.getElementById('phase');\nconst messageEl = document.getElementById('message');\n\nconst inputViz = document.getElementById('inputViz');\nconst countsViz = document.getElementById('countsViz');\nconst outputViz = document.getElementById('outputViz');\nconst explainEl = document.getElementById('explain');\n\nlet arr = [];\nlet minVal = 0, maxVal = 0, range = 0;\nlet counts = [];\nlet output = [];\nlet gen = null;\nlet playing = false;\nlet timer = null;\nlet lastAction = null;\nconst RANGE_LIMIT = 70; // visualization limit\n\n// Utility: parse user array input\nfunction parseInput(s) {\n  if (!s.trim()) return [];\n  const parts = s.split(',').map(x=>x.trim()).filter(x=>x!=='');\n  const nums = parts.map(x=> {\n    const n = Number(x);\n    if (Number.isNaN(n)) throw new Error('Invalid number: ' + x);\n    return Math.trunc(n);\n  });\n  return nums;\n}\n\n// Create random array\nfunction makeRandom(size, mn, mx) {\n  const res = [];\n  for (let i=0;i<size;i++){\n    res.push(Math.floor(Math.random()*(mx-mn+1))+mn);\n  }\n  return res;\n}\n\n// UI render helpers\nfunction clearElement(el) { el.innerHTML = ''; }\n\nfunction renderInput() {\n  clearElement(inputViz);\n  if (!arr.length) {\n    inputViz.textContent = '(empty)';\n    return;\n  }\n  const maxAbs = Math.max(...arr.map(x=>Math.abs(x)), 1);\n  for (let i=0;i<arr.length;i++){\n    const v = arr[i];\n    const bar = document.createElement('div');\n    bar.className = 'bar';\n    bar.style.height = (40 + Math.round((Math.abs(v)/maxAbs)*120)) + 'px';\n    bar.dataset.index = i;\n    bar.dataset.value = v;\n    const lbl = document.createElement('div');\n    lbl.className = 'lbl';\n    lbl.textContent = v;\n    bar.appendChild(lbl);\n    inputViz.appendChild(bar);\n  }\n}\n\nfunction renderCounts() {\n  clearElement(countsViz);\n  countsViz.style.minWidth = (range * 54) + 'px';\n  for (let i=0;i<range;i++){\n    const cv = document.createElement('div');\n    cv.className = 'countBox';\n    cv.dataset.idx = i;\n    const idx = document.createElement('div');\n    idx.className = 'idx';\n    idx.textContent = (i+minVal); // actual value label\n    const ct = document.createElement('div');\n    ct.className = 'ct';\n    ct.textContent = counts[i] ?? 0;\n    cv.appendChild(idx);\n    cv.appendChild(ct);\n    countsViz.appendChild(cv);\n  }\n}\n\nfunction renderOutput() {\n  clearElement(outputViz);\n  if (!output.length) {\n    outputViz.textContent = '(empty)';\n    return;\n  }\n  const maxAbs = Math.max(...arr.map(x=>Math.abs(x)), 1);\n  for (let i=0;i<output.length;i++){\n    const v = output[i];\n    const bar = document.createElement('div');\n    bar.className = 'bar';\n    if (v === null || v === undefined) {\n      bar.classList.add('hidden');\n      bar.style.height = '38px';\n      bar.innerHTML = '<div class=\"lbl\"></div>';\n    } else {\n      bar.style.height = (40 + Math.round((Math.abs(v)/maxAbs)*120)) + 'px';\n      const lbl = document.createElement('div');\n      lbl.className = 'lbl';\n      lbl.textContent = v;\n      bar.appendChild(lbl);\n    }\n    outputViz.appendChild(bar);\n  }\n}\n\n// Update a single count box value and highlight classes\nfunction updateCountBox(i, highlightClass) {\n  const node = countsViz.querySelector(`.countBox[data-idx=\"${i}\"]`);\n  if (!node) return;\n  node.querySelector('.ct').textContent = counts[i];\n  node.classList.remove('active','cum');\n  if (highlightClass) node.classList.add(highlightClass);\n}\n\n// Highlight input bar at index i\nfunction highlightInput(i, cls) {\n  Array.from(inputViz.children).forEach(el=> el.classList.remove('highlight','target'));\n  if (i==null) return;\n  const node = inputViz.querySelector(`.bar[data-index=\"${i}\"]`);\n  if (node) node.classList.add(cls);\n}\n\n// Highlight output slot at index j\nfunction highlightOutput(j, cls) {\n  Array.from(outputViz.children).forEach(el=> el.classList.remove('highlight','target'));\n  if (j==null) return;\n  const node = outputViz.children[j];\n  if (node) node.classList.add(cls);\n}\n\n// Set value in output at pos\nfunction setOutputAt(pos, val) {\n  output[pos] = val;\n  const node = outputViz.children[pos];\n  if (node) {\n    node.classList.remove('hidden');\n    node.innerHTML = '';\n    const lbl = document.createElement('div');\n    lbl.className = 'lbl';\n    lbl.textContent = val;\n    node.appendChild(lbl);\n    // set height proportional (approx)\n    const maxAbs = Math.max(...arr.map(x=>Math.abs(x)), 1);\n    node.style.height = (40 + Math.round((Math.abs(val)/maxAbs)*120)) + 'px';\n  }\n}\n\n// Main generator performing counting sort and yielding steps\nfunction* countingSortGenerator(a) {\n  // prepare\n  const n = a.length;\n  if (n===0) {\n    yield {type:'done', msg:'Empty array'};\n    return;\n  }\n  minVal = Math.min(...a);\n  maxVal = Math.max(...a);\n  range = maxVal - minVal + 1;\n  if (range > RANGE_LIMIT) {\n    yield {type:'error', msg:`Range too large for visualization (${range} > ${RANGE_LIMIT}).`};\n    return;\n  }\n\n  counts = new Array(range).fill(0);\n  output = new Array(n).fill(null);\n\n  // initial render state\n  yield {type:'init', counts:counts.slice(), min:minVal, max:maxVal, range, output:output.slice()};\n\n  // Counting phase\n  for (let i=0;i<n;i++){\n    const val = a[i];\n    const idx = val - minVal;\n    yield {type:'counting:visit', i, val, idx, counts:counts.slice()};\n    counts[idx] += 1;\n    yield {type:'counting:update', i, val, idx, counts:counts.slice()};\n  }\n\n  // Prefix sum (cumulative)\n  yield {type:'prefix:start', counts:counts.slice()};\n  for (let k=0;k<range;k++){\n    const before = counts[k];\n    if (k>0) counts[k] += counts[k-1];\n    // yield cumulative update for each index\n    yield {type:'prefix:update', k, before, after:counts[k], counts:counts.slice()};\n  }\n\n  // Placing phase (right-to-left for stability)\n  for (let i = n-1; i>=0; i--){\n    const val = a[i];\n    const idx = val - minVal;\n    const pos = counts[idx] - 1;\n    yield {type:'placing:select', i, val, idx, pos, counts:counts.slice(), output:output.slice()};\n    // place\n    output[pos] = val;\n    yield {type:'placing:placed', i, val, idx, pos, counts:counts.slice(), output:output.slice()};\n    counts[idx] -= 1;\n    yield {type:'placing:countdec', i, val, idx, pos, counts:counts.slice(), output:output.slice()};\n  }\n\n  yield {type:'done', counts:counts.slice(), output:output.slice()};\n}\n\n// Driver to process one yielded action\nfunction processAction(action) {\n  lastAction = action;\n  phaseEl.textContent = action.type;\n  statusEl.textContent = '';\n  if (action.type === 'error') {\n    messageEl.innerHTML = '<span class=\"warning\">'+action.msg+'</span>';\n    stopPlaying();\n    return;\n  }\n  messageEl.textContent = '';\n\n  switch(action.type) {\n    case 'init':\n      renderInput();\n      renderCounts();\n      renderOutput();\n      explainEl.textContent = `Counting sort will operate on values from ${action.min} to ${action.max} (range ${action.range}). First we count occurrences, then compute cumulative counts, then place elements to output array (from right to left for stability).`;\n      break;\n\n    case 'counting:visit':\n      phaseEl.textContent = 'Counting: scanning input';\n      highlightInput(action.i, 'highlight');\n      updateCountsDisplay(action.counts);\n      messageEl.textContent = `Visiting input[${action.i}] = ${action.val} — increment count for value ${action.val}.`;\n      break;\n\n    case 'counting:update':\n      updateCountsDisplay(action.counts);\n      highlightInput(action.i, 'highlight');\n      // also highlight the specific count box briefly\n      highlightCountBox(action.idx, 'active');\n      break;\n\n    case 'prefix:start':\n      phaseEl.textContent = 'Prefix Sum: cumulative counts';\n      messageEl.textContent = 'Compute cumulative counts (prefix sums) so each count indicates the end index for that value in the output.';\n      updateCountsDisplay(action.counts);\n      break;\n\n    case 'prefix:update':\n      phaseEl.textContent = 'Prefix Sum: computing';\n      // mark current box as cumulative\n      updateCountsDisplay(action.counts);\n      highlightCountBox(action.k, 'cum');\n      messageEl.textContent = `Index ${action.k + minVal}: before=${action.before}, after=${action.after}.`;\n      break;\n\n    case 'placing:select':\n      phaseEl.textContent = 'Placing: selecting element';\n      // highlight the input element and target position\n      highlightInput(action.i, 'highlight');\n      highlightOutput(action.pos, 'target');\n      updateCountsDisplay(action.counts);\n      messageEl.textContent = `Select input[${action.i}] = ${action.val}. Place at output[${action.pos}].`;\n      break;\n\n    case 'placing:placed':\n      phaseEl.textContent = 'Placing: placed';\n      // show placed value\n      setOutputAt(action.pos, action.val);\n      highlightInput(action.i, 'highlight');\n      highlightOutput(action.pos, 'target');\n      messageEl.textContent = `Placed ${action.val} at output[${action.pos}].`;\n      break;\n\n    case 'placing:countdec':\n      phaseEl.textContent = 'Placing: decrementing count';\n      updateCountsDisplay(action.counts);\n      highlightCountBox(action.idx, 'active');\n      highlightInput(action.i, null);\n      highlightOutput(action.pos, null);\n      break;\n\n    case 'done':\n      phaseEl.textContent = 'Done';\n      updateCountsDisplay(action.counts || counts);\n      renderOutput();\n      highlightInput(null);\n      highlightCountBox(null);\n      highlightOutput(null);\n      messageEl.textContent = 'Sorting complete.';\n      explainEl.textContent = 'Result: output array is sorted. Counting sort was stable because we processed inputs right-to-left when placing.';\n      stopPlaying();\n      break;\n  }\n}\n\n// Helpers to update visual counts (refresh all boxes)\nfunction updateCountsDisplay(arrCounts) {\n  for (let i=0;i<range;i++){\n    counts[i] = arrCounts[i];\n    updateCountBox(i, null);\n  }\n}\n\n// Highlight a specific count box index, clearing others\nfunction highlightCountBox(i, cls) {\n  Array.from(countsViz.children).forEach(el=> el.classList.remove('active','cum'));\n  if (i == null) return;\n  const node = countsViz.querySelector(`.countBox[data-idx=\"${i}\"]`);\n  if (node) node.classList.add(cls);\n}\n\n// Play / step logic\nfunction startPlaying() {\n  if (!gen) {\n    messageEl.textContent = 'No process to run. Load an array and press Start.';\n    return;\n  }\n  if (playing) return;\n  playing = true;\n  startBtn.disabled = true;\n  pauseBtn.disabled = false;\n  stepBtn.disabled = true;\n  statusEl.textContent = 'Playing';\n  advanceAuto();\n}\n\nfunction stopPlaying() {\n  playing = false;\n  startBtn.disabled = false;\n  pauseBtn.disabled = true;\n  stepBtn.disabled = false;\n  statusEl.textContent = 'Paused';\n  if (timer) { clearTimeout(timer); timer = null; }\n}\n\nfunction pausePlaying() {\n  playing = false;\n  startBtn.disabled = false;\n  pauseBtn.disabled = true;\n  stepBtn.disabled = false;\n  statusEl.textContent = 'Paused';\n  if (timer) { clearTimeout(timer); timer = null; }\n}\n\nfunction advanceAuto() {\n  const delay = Number(speedEl.value);\n  const stepOnce = () => {\n    const next = gen.next();\n    if (next.done) {\n      // generator ended\n      playing = false;\n      startBtn.disabled = false;\n      pauseBtn.disabled = true;\n      stepBtn.disabled = false;\n      statusEl.textContent = 'Finished';\n      return;\n    }\n    processAction(next.value);\n    if (playing) {\n      timer = setTimeout(stepOnce, delay);\n    }\n  };\n  stepOnce();\n}\n\n// Single step\nfunction stepOnce() {\n  if (!gen) {\n    messageEl.textContent = 'No process loaded. Load an array and press Start.';\n    return;\n  }\n  // if currently auto-playing, ignore step\n  if (playing) return;\n  const next = gen.next();\n  if (next.done) {\n    statusEl.textContent = 'Finished';\n    return;\n  }\n  processAction(next.value);\n}\n\n// Initialize process generator from current arr\nfunction prepareGenerator() {\n  gen = countingSortGenerator(arr.slice());\n  // advance to init to set up visuals\n  const init = gen.next();\n  if (!init.done) processAction(init.value);\n}\n\n// Event handlers\nloadBtn.addEventListener('click', ()=>{\n  try {\n    const parsed = parseInput(inputEl.value);\n    if (parsed.length > 200) { messageEl.textContent = 'Array too large (max 200)'; return; }\n    arr = parsed.slice();\n    // enforce reasonable visualization constraints\n    minVal = Math.min(...arr);\n    maxVal = Math.max(...arr);\n    if (maxVal - minVal + 1 > RANGE_LIMIT) {\n      messageEl.innerHTML = `<span class=\"warning\">Range too large (${maxVal - minVal + 1}). Choose values closer together for visualization.</span>`;\n    }\n    prepareGenerator();\n    statusEl.textContent = 'Ready';\n    phaseEl.textContent = 'Initialized';\n  } catch (e) {\n    messageEl.textContent = 'Error: ' + e.message;\n  }\n});\n\nrandBtn.addEventListener('click', ()=>{\n  const s = Number(randSize.value) || 10;\n  const mn = Number(randMin.value) || 0;\n  const mx = Number(randMax.value) || 10;\n  if (mx < mn) { messageEl.textContent = 'Max must be >= Min'; return; }\n  arr = makeRandom(Math.max(1, Math.min(60, Math.trunc(s))), mn, mx);\n  inputEl.value = arr.join(', ');\n  prepareGenerator();\n  statusEl.textContent = 'Ready';\n  phaseEl.textContent = 'Initialized';\n  messageEl.textContent = `Random array of ${arr.length} values generated.`;\n});\n\nstartBtn.addEventListener('click', ()=>{\n  if (!gen) {\n    // try to parse input automatically\n    try {\n      arr = parseInput(inputEl.value);\n      prepareGenerator();\n    } catch (e) {\n      messageEl.textContent = 'Error: ' + e.message;\n      return;\n    }\n  }\n  startPlaying();\n});\n\npauseBtn.addEventListener('click', ()=> {\n  pausePlaying();\n});\n\nstepBtn.addEventListener('click', ()=> {\n  // if no gen, prepare\n  if (!gen) {\n    try {\n      arr = parseInput(inputEl.value);\n      prepareGenerator();\n    } catch (e) {\n      messageEl.textContent = 'Error: ' + e.message;\n      return;\n    }\n  }\n  stepOnce();\n});\n\nresetBtn.addEventListener('click', ()=> {\n  if (timer) { clearTimeout(timer); timer = null; }\n  gen = null;\n  playing = false;\n  startBtn.disabled = false;\n  pauseBtn.disabled = true;\n  stepBtn.disabled = false;\n  statusEl.textContent = 'Idle';\n  phaseEl.textContent = 'Not started';\n  messageEl.textContent = '';\n  minVal = maxVal = range = 0;\n  counts = [];\n  output = [];\n  renderInput();\n  clearElement(countsViz);\n  clearElement(outputViz);\n  explainEl.textContent = 'Explanation: Counting sort tallies how often each distinct value appears, computes cumulative counts, and then places each element into the correct output position (processing input from right to left to keep the sort stable).';\n});\n\n// initialize with default sample\n(function init() {\n  try {\n    arr = parseInput(inputEl.value);\n  } catch(e) { arr = []; }\n  prepareGenerator();\n  statusEl.textContent = 'Ready';\n})();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Counting Sort"
    }
  ],
  "topic": "Counting Sort",
  "hasFSM": false,
  "hasTest": true
}