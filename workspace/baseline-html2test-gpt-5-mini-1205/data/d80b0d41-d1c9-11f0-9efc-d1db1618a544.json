{
  "id": "d80b0d41-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:06.175Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Radix Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Radix Sort Visualizer (LSD) — Interactive Demo</title>\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --muted:#9aa6c1;\n      --accent:#60a5fa;\n      --accent2:#7c3aed;\n      --card:#071024;\n      --good:#10b981;\n      --danger:#ef4444;\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;}\n    body{background:linear-gradient(180deg,var(--bg),#051022);color:#e6eef8;padding:18px;}\n    .container{max-width:1100px;margin:0 auto;}\n    header{display:flex;align-items:center;gap:16px;margin-bottom:14px;}\n    h1{font-size:20px;margin:0;color:#eaf2ff;}\n    p.lead{margin:0;color:var(--muted);font-size:13px;}\n    .controls{display:flex;gap:12px;flex-wrap:wrap;margin:12px 0 18px;}\n    .card{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);padding:12px;border-radius:10px;}\n    .card.small{padding:8px;font-size:13px;}\n    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px;}\n    input[type=\"text\"], textarea, select, input[type=\"number\"]{\n      background:transparent;border:1px solid rgba(255,255,255,0.04);color:#e6eef8;padding:8px;border-radius:6px;min-width:120px;\n    }\n    textarea{min-height:56px;min-width:260px;}\n    button{background:linear-gradient(180deg,var(--accent),#2b6cb0);border:0;color:white;padding:8px 12px;border-radius:8px;cursor:pointer;}\n    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#cfe5ff;}\n    .flex{display:flex;gap:10px;align-items:center;}\n    .visual{display:flex;gap:14px;align-items:flex-start;}\n    .left{flex:1;}\n    .array-wrap{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);min-height:180px;}\n    .array{display:flex;align-items:end;gap:8px;padding:10px;min-height:110px;overflow:auto;}\n    .item{\n      width:48px;background:linear-gradient(180deg,#2b6cb0,#1e3a8a);color:white;border-radius:6px;display:flex;justify-content:center;align-items:flex-end;padding:6px 4px 6px 4px;box-sizing:border-box;\n      position:relative;transition:transform 250ms ease;\n      box-shadow:0 6px 18px rgba(12,24,46,0.4), inset 0 -6px 12px rgba(255,255,255,0.03);\n    }\n    .item.small{width:36px;padding:4px;font-size:12px;}\n    .item .label{position:absolute;top:6px;left:6px;font-size:11px;color:rgba(255,255,255,0.9);}\n    .buckets{display:flex;gap:8px;flex-wrap:wrap;padding:10px;}\n    .bucket{min-width:80px;background:linear-gradient(180deg,#071633,#031029);border-radius:8px;padding:8px;border:1px solid rgba(255,255,255,0.03);color:var(--muted);min-height:80px;}\n    .bucket h4{margin:0 0 6px 0;font-size:13px;color:#a8d2ff;}\n    .bucket .slot{display:flex;flex-direction:column;gap:6px;min-height:36px;}\n    .bucket .slot .item{background:#3b82f6;}\n    .controls-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;}\n    .state{margin-top:10px;color:var(--muted);font-size:13px;}\n    .footer{margin-top:18px;font-size:13px;color:var(--muted);}\n    .muted{color:var(--muted);}\n    .small-note{font-size:12px;color:var(--muted);margin-top:6px;}\n    .status{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:8px;}\n    .pill{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;font-size:13px;color:var(--muted);border:1px solid rgba(255,255,255,0.02);}\n    .danger{color:var(--danger);border-color:rgba(239,68,68,0.12);background:rgba(239,68,68,0.04);}\n    .good{color:var(--good);border-color:rgba(16,185,129,0.08);background:rgba(16,185,129,0.03);}\n    .explain{margin-top:12px;padding:12px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.02);color:var(--muted);line-height:1.45;font-size:13px;}\n    .controls-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}\n    footer small{color:var(--muted);}\n    /* simple animations */\n    .moving{transform:scale(1.05) translateY(-8px);box-shadow:0 12px 24px rgba(12,24,46,0.6);}\n    .highlight{outline:2px solid rgba(255,255,255,0.06);box-shadow:0 6px 18px rgba(12,24,46,0.6);}\n    @media (max-width:720px){\n      .array{overflow-x:auto;}\n      .bucket{min-width:70px;}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <header>\n      <div>\n        <h1>Radix Sort Visualizer (LSD)</h1>\n        <p class=\"lead\">Least Significant Digit Radix Sort for integers — interactive step-through and animation.</p>\n      </div>\n    </header>\n\n    <div class=\"controls card\">\n      <div class=\"controls-grid\">\n        <div>\n          <label>Input array (comma or space separated integers)</label>\n          <textarea id=\"inputArray\" placeholder=\"e.g. 170, 45, 75, 90, 802, 24, 2, 66\">170,45,75,90,802,24,2,66</textarea>\n          <div style=\"margin-top:8px;\">\n            <button id=\"fromText\" class=\"secondary\">Load</button>\n            <button id=\"randomize\" class=\"secondary\">Randomize</button>\n          </div>\n        </div>\n\n        <div>\n          <label>Random generation</label>\n          <div style=\"display:flex;gap:8px;align-items:center;\">\n            <input type=\"number\" id=\"size\" min=\"1\" max=\"60\" value=\"8\" />\n            <input type=\"number\" id=\"maxVal\" min=\"1\" max=\"5000\" value=\"900\" />\n            <select id=\"radix\">\n              <option value=\"2\">Base 2 (binary)</option>\n              <option value=\"4\">Base 4</option>\n              <option value=\"8\">Base 8</option>\n              <option value=\"10\" selected>Base 10</option>\n              <option value=\"16\">Base 16 (hex)</option>\n              <option value=\"32\">Base 32</option>\n            </select>\n          </div>\n          <div class=\"small-note\">Choose base (radix). Higher base reduces passes but increases bucket count per pass.</div>\n        </div>\n\n        <div>\n          <label>Sorting / Playback</label>\n          <div class=\"controls-row\">\n            <button id=\"start\">Start</button>\n            <button id=\"stepBtn\" class=\"secondary\">Step</button>\n            <button id=\"pauseBtn\" class=\"secondary\">Pause</button>\n            <button id=\"resetBtn\" class=\"secondary\">Reset</button>\n          </div>\n\n          <div style=\"margin-top:8px;\">\n            <label style=\"font-size:12px;margin-bottom:6px;color:var(--muted);\">Speed (ms per step)</label>\n            <input type=\"range\" id=\"speed\" min=\"50\" max=\"1500\" value=\"350\" />\n            <div class=\"small-note\">Faster = lower ms. Use Step to move one action at a time.</div>\n          </div>\n        </div>\n\n        <div>\n          <label>Options</label>\n          <div style=\"display:flex;flex-direction:column;gap:8px;\">\n            <label style=\"font-size:13px\"><input type=\"checkbox\" id=\"ascending\" checked /> Ascending</label>\n            <label style=\"font-size:13px\"><input type=\"checkbox\" id=\"allowNeg\" /> Support negatives (offset)</label>\n            <label style=\"font-size:13px\"><input type=\"checkbox\" id=\"showValues\" checked /> Show numeric values on bars</label>\n          </div>\n          <div class=\"small-note\">When \"Support negatives\" is enabled, a constant offset is applied so radix sort can run (animated values will be restored at the end).</div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"visual\" style=\"margin-top:14px;\">\n      <div class=\"left\">\n        <div class=\"array-wrap card\">\n          <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;\">\n            <div style=\"font-weight:600;color:#dff1ff;\">Array</div>\n            <div class=\"status\">\n              <div class=\"pill\" id=\"passPill\">Pass: 0</div>\n              <div class=\"pill\" id=\"actionPill\">Action: 0 / 0</div>\n              <div class=\"pill\" id=\"infoPill\">Radix: 10</div>\n            </div>\n          </div>\n          <div id=\"mainArray\" class=\"array\" aria-live=\"polite\" role=\"list\"></div>\n          <div id=\"newMainHidden\" style=\"display:none\"></div>\n        </div>\n\n        <div class=\"explain\">\n          <strong>How LSD Radix Sort works (brief):</strong>\n          <div style=\"margin-top:6px;\">\n            - Radix sort processes digits from least significant (rightmost) to most significant (leftmost).<br>\n            - At each pass elements are distributed into buckets based on the current digit, preserving relative order (stable). After distributing all elements, buckets are concatenated to form the new array for the next pass.<br>\n            - Complexity: O(d * (n + b)) where d is number of digits (passes), b is base. For fixed-width integers this is linear O(n).\n          </div>\n        </div>\n      </div>\n\n      <div style=\"width:360px\">\n        <div class=\"card\" style=\"padding:10px;margin-bottom:10px;\">\n          <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n            <strong style=\"color:#dff1ff\">Buckets</strong>\n            <div class=\"muted\" id=\"bucketInfo\">Buckets: 10</div>\n          </div>\n          <div id=\"buckets\" class=\"buckets\" style=\"margin-top:10px;\"></div>\n        </div>\n\n        <div class=\"card small\" style=\"margin-bottom:10px;\">\n          <div style=\"font-weight:600;color:#dff1ff;margin-bottom:6px;\">Status</div>\n          <div id=\"log\" class=\"muted\" style=\"font-size:13px;min-height:66px\"></div>\n        </div>\n\n        <div class=\"card small\">\n          <div style=\"font-weight:600;color:#dff1ff;margin-bottom:6px;\">Complexity & Notes</div>\n          <div class=\"muted\" style=\"font-size:13px;\">\n            - Time: O(d*(n+b)) (d = digits), Space: O(n+b) for buckets.<br>\n            - Stable, non-comparative. Best when digits (d) small relative to n.<br>\n            - This demo uses LSD and works on integers. Non-negative expected; negative values can be handled by adding a constant offset (option enabled above).\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <footer style=\"margin-top:16px;\">\n      <small class=\"muted\">Interactive visualization for educational purposes. You can change radix, array, and step through each low-level bucket move to see how Radix Sort rearranges elements.</small>\n    </footer>\n  </div>\n\n  <script>\n    // Radix Sort Visualizer (LSD) - JavaScript\n    (() => {\n      // DOM elements\n      const inputArray = document.getElementById('inputArray');\n      const fromTextBtn = document.getElementById('fromText');\n      const randomizeBtn = document.getElementById('randomize');\n      const sizeInput = document.getElementById('size');\n      const maxValInput = document.getElementById('maxVal');\n      const radixSelect = document.getElementById('radix');\n      const startBtn = document.getElementById('start');\n      const stepBtn = document.getElementById('stepBtn');\n      const pauseBtn = document.getElementById('pauseBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const speedInput = document.getElementById('speed');\n      const mainArrayDiv = document.getElementById('mainArray');\n      const bucketsDiv = document.getElementById('buckets');\n      const passPill = document.getElementById('passPill');\n      const actionPill = document.getElementById('actionPill');\n      const bucketInfo = document.getElementById('bucketInfo');\n      const infoPill = document.getElementById('infoPill');\n      const logDiv = document.getElementById('log');\n      const ascendingCheckbox = document.getElementById('ascending');\n      const allowNegCheckbox = document.getElementById('allowNeg');\n      const showValuesCheckbox = document.getElementById('showValues');\n\n      // State\n      let items = []; // items: {id, value, displayValue}\n      let originalItems = [];\n      let actions = []; // precomputed action list\n      let actionIndex = 0;\n      let timer = null;\n      let isRunning = false;\n      let base = parseInt(radixSelect.value,10);\n      let ascending = ascendingCheckbox.checked;\n      let allowNegatives = allowNegCheckbox.checked;\n      let stepMs = parseInt(speedInput.value,10);\n\n      // Helpers\n      function log(msg){\n        const p = document.createElement('div');\n        p.textContent = msg;\n        logDiv.prepend(p);\n        // limit lines\n        while(logDiv.children.length > 200) logDiv.removeChild(logDiv.lastChild);\n      }\n\n      function parseInput(text){\n        const tokens = text.split(/[\\s,]+/).filter(Boolean);\n        const nums = tokens.map(t => {\n          if (/^0x[0-9a-f]+$/i.test(t)) return parseInt(t,16);\n          return Number(t);\n        }).filter(n => !Number.isNaN(n));\n        return nums;\n      }\n\n      function buildItemsFromNumbers(nums){\n        return nums.map((v,i)=>({\n          id: 'i'+(i+1)+'_'+Math.random().toString(36).slice(2,7),\n          value: Math.trunc(v)\n        }));\n      }\n\n      function renderMainArray(container, arr){\n        container.innerHTML = '';\n        const showV = showValuesCheckbox.checked;\n        const maxVal = Math.max(...arr.map(it=>Math.abs(it.value)), 1);\n        const minWidth = 36;\n        for(let it of arr){\n          const div = document.createElement('div');\n          div.className = 'item';\n          if (arr.length > 16) div.classList.add('small');\n          div.dataset.id = it.id;\n          const h = Math.max(12, Math.round((Math.abs(it.value) / maxVal) * 80) + 18);\n          div.style.height = h + 'px';\n          // background color for negative values (if offset used then displayed value may look different)\n          if (it.value < 0) {\n            div.style.background = 'linear-gradient(180deg,#ef4444,#991b1b)';\n          }\n          const label = document.createElement('div');\n          label.className = 'label';\n          label.textContent = it.id;\n          div.appendChild(label);\n          if (showV) {\n            const vspan = document.createElement('div');\n            vspan.style.fontSize = '13px';\n            vspan.style.color = '#fff';\n            vspan.textContent = String(it.displayValue ?? it.value);\n            div.appendChild(vspan);\n          }\n          container.appendChild(div);\n        }\n      }\n\n      function createBucketsDOM(b){\n        bucketsDiv.innerHTML = '';\n        bucketInfo.textContent = `Buckets: ${b}`;\n        for(let i=0;i<b;i++){\n          const box = document.createElement('div');\n          box.className = 'bucket';\n          box.dataset.bucket = i;\n          const h = document.createElement('h4');\n          h.textContent = String(i);\n          box.appendChild(h);\n          const slot = document.createElement('div');\n          slot.className = 'slot';\n          box.appendChild(slot);\n          bucketsDiv.appendChild(box);\n        }\n      }\n\n      // Action types:\n      // {type:'move', pass, digit, id, value, displayValue}\n      // {type:'collect', pass, bucketIndex, id, value, displayValue, targetIndex}\n      // We'll precompute actions for all passes (LSD)\n      function generateActionsFor(itemsIn, base, ascending){\n        // We operate on copies of item objects (but preserve id)\n        const items = itemsIn.map(it => ({id: it.id, value: it.value, displayValue: it.displayValue}));\n        const n = items.length;\n        const actions = [];\n        if (n===0) return {actions, passes:0, final: items.slice()};\n        const maxVal = Math.max(...items.map(it=>Math.abs(it.value)));\n        // number of passes: minimal d such that base^d > maxVal\n        let passes = 0;\n        if (maxVal === 0) passes = 1;\n        else {\n          let p = 1;\n          while (Math.pow(base, p) <= maxVal) p++;\n          passes = p;\n        }\n        let working = items.slice();\n        const powCache = [];\n        for(let d=0; d<passes; d++){\n          const powb = Math.pow(base, d);\n          powCache[d] = powb;\n        }\n        for(let d=0; d<passes; d++){\n          // distribute\n          const buckets = Array.from({length: base}, ()=>[]);\n          for(let i=0;i<working.length;i++){\n            const it = working[i];\n            const digit = Math.floor(Math.abs(it.value) / powCache[d]) % base;\n            actions.push({type:'move', pass:d, digit, id:it.id, value:it.value, displayValue:it.displayValue});\n            buckets[digit].push(it);\n          }\n          // collect\n          const bucketOrder = ascending ? [...Array(base).keys()] : [...Array(base).keys()].reverse();\n          let targetIdx = 0;\n          for(const bIdx of bucketOrder){\n            for(const it of buckets[bIdx]){\n              actions.push({type:'collect', pass:d, bucketIndex:bIdx, id:it.id, value:it.value, displayValue:it.displayValue, targetIndex:targetIdx});\n              targetIdx++;\n            }\n          }\n          // update working for next pass\n          const newWorking = [];\n          for(const bIdx of bucketOrder){\n            for(const it of buckets[bIdx]) newWorking.push(it);\n          }\n          working = newWorking;\n        }\n        return {actions, passes, final: working};\n      }\n\n      // Build actions given current items, base, and ascending option, and negative handling via offset\n      function buildAllActions(){\n        actions = [];\n        actionIndex = 0;\n        passPill.textContent = 'Pass: 0';\n        actionPill.textContent = 'Action: 0 / 0';\n        logDiv.innerHTML = '';\n\n        // original items copy\n        originalItems = items.map(it => ({...it}));\n\n        // handle negative offset if enabled\n        let offset = 0;\n        if (allowNegatives){\n          const minV = Math.min(...items.map(it => it.value));\n          if (minV < 0) offset = Math.abs(minV);\n          if (offset !== 0){\n            for(let it of items){\n              it.displayValue = it.value; // store original for display\n              it.value = it.value + offset;\n            }\n            log(`Negative offset applied: +${offset} to all values for sorting (will be restored).`);\n          } else {\n            // still set displayValue to show original\n            for(let it of items){\n              it.displayValue = it.value;\n            }\n          }\n        } else {\n          // just set displayValue equal to value\n          for(let it of items){\n            it.displayValue = it.value;\n          }\n        }\n\n        const generated = generateActionsFor(items, base, ascending);\n        actions = generated.actions;\n        const totalActions = actions.length;\n        actionPill.textContent = `Action: 0 / ${totalActions}`;\n        passPill.textContent = 'Pass: 0';\n        infoPill.textContent = `Radix: ${base}  |  Passes: ${generated.passes}`;\n        createBucketsDOM(base);\n\n        log(`Prepared ${totalActions} low-level actions over ${generated.passes} pass(es).`);\n        // store offset to restore after full run\n        actions._offset = offset;\n        actions._passes = generated.passes;\n        actions._n = items.length;\n      }\n\n      // Render helpers for DOM items mapping\n      function findMainElementById(id){\n        return mainArrayDiv.querySelector(`[data-id=\"${id}\"]`);\n      }\n      function findBucketSlot(bucketIndex){\n        const box = bucketsDiv.querySelector(`.bucket[data-bucket=\"${bucketIndex}\"]`);\n        if (!box) return null;\n        return box.querySelector('.slot');\n      }\n\n      // Execute a single action\n      // We maintain per-pass collection container newMainDiv for collecting phase\n      let currentPass = -1;\n      let collectedThisPass = 0;\n      let movesThisPass = 0;\n      let newMainDiv = null;\n\n      function doAction(a){\n        if (!a) return;\n        // update status\n        actionPill.textContent = `Action: ${actionIndex+1} / ${actions.length}`;\n        passPill.textContent = `Pass: ${a.pass + 1} / ${actions._passes}`;\n        // if new pass begins, reset counts and clear buckets DOM\n        if (a.pass !== currentPass){\n          currentPass = a.pass;\n          collectedThisPass = 0;\n          movesThisPass = 0;\n          // clear buckets\n          for(let i=0;i<base;i++){\n            const slot = findBucketSlot(i);\n            if (slot) slot.innerHTML = '';\n          }\n          // create a fresh newMain div to collect this pass's items\n          newMainDiv = document.createElement('div');\n          newMainDiv.style.display = 'flex';\n          newMainDiv.style.alignItems = 'end';\n          newMainDiv.style.gap = '8px';\n          newMainDiv.style.padding = '10px';\n          newMainDiv.className = 'temp-new-main';\n        }\n\n        if (a.type === 'move'){\n          movesThisPass++;\n          // find the DOM element in main array and move a clone into bucket\n          const elem = findMainElementById(a.id);\n          if (!elem){\n            // maybe it's already moved; skip\n            return;\n          }\n          // visually mark moving\n          elem.classList.add('moving');\n          // create a cloned element for bucket (so we can keep placeholder if needed)\n          const cloned = elem.cloneNode(true);\n          cloned.classList.remove('moving');\n          // show displayValue (in case displayValue differs from internal value)\n          if (cloned.querySelector('div:nth-child(2)')){\n            cloned.querySelector('div:nth-child(2)').textContent = String(a.displayValue ?? a.value);\n          }\n          // append cloned to bucket slot\n          const slot = findBucketSlot(a.digit);\n          if (slot){\n            setTimeout(()=> {\n              slot.appendChild(cloned);\n            }, 80);\n          }\n          // hide original from main area (so it visually disappears)\n          elem.style.visibility = 'hidden';\n          log(`[pass ${a.pass}] MOVE id=${a.id} val=${a.displayValue ?? a.value} -> bucket ${a.digit}`);\n        } else if (a.type === 'collect'){\n          collectedThisPass++;\n          // find the bucket slot and remove the first matching element with that id\n          const slot = findBucketSlot(a.bucketIndex);\n          if (slot){\n            const child = Array.from(slot.children).find(ch => ch.dataset.id === a.id);\n            if (child){\n              slot.removeChild(child);\n              // append the child to newMainDiv\n              newMainDiv.appendChild(child);\n              child.style.visibility = 'visible';\n              child.classList.remove('moving');\n              child.classList.add('highlight');\n              // ensure displayed numeric value is correct (might be offset)\n              const vspan = child.querySelector('div:nth-child(2)');\n              if (vspan) vspan.textContent = String(a.displayValue ?? a.value);\n              // quick remove highlight\n              setTimeout(()=> child.classList.remove('highlight'), 350);\n            } else {\n              // not found - create a fresh element representing it\n              const div = document.createElement('div');\n              div.className = 'item';\n              if (actions._n > 16) div.classList.add('small');\n              div.dataset.id = a.id;\n              const h = Math.max(12, Math.round((Math.abs(a.value) / 1) * 18) + 18);\n              div.style.height = h + 'px';\n              const label = document.createElement('div');\n              label.className = 'label';\n              label.textContent = a.id;\n              div.appendChild(label);\n              const vspan = document.createElement('div');\n              vspan.textContent = String(a.displayValue ?? a.value);\n              div.appendChild(vspan);\n              newMainDiv.appendChild(div);\n            }\n          }\n          log(`[pass ${a.pass}] COLLECT id=${a.id} val=${a.displayValue ?? a.value} from bucket ${a.bucketIndex} into new array`);\n          // If we've collected all for this pass, finalize main array DOM\n          if (collectedThisPass === actions._n){\n            // replace mainArrayDiv contents with newMainDiv's children (in order)\n            // Build a new array representation from newMainDiv children\n            const newChildren = Array.from(newMainDiv.children).map(ch => {\n              // ensure style classes corrected\n              ch.classList.remove('moving','highlight');\n              return ch;\n            });\n            // replace: clear mainArrayDiv and append in order\n            mainArrayDiv.innerHTML = '';\n            for(const ch of newChildren){\n              mainArrayDiv.appendChild(ch);\n            }\n            // reset newMainDiv\n            newMainDiv = null;\n            log(`Completed pass ${a.pass}. Array updated for next pass.`);\n          }\n        }\n      }\n\n      function step(){\n        if (actionIndex >= actions.length) {\n          log('All actions completed.');\n          finalizeSort();\n          return;\n        }\n        const a = actions[actionIndex];\n        doAction(a);\n        actionIndex++;\n        actionPill.textContent = `Action: ${actionIndex} / ${actions.length}`;\n        if (actionIndex >= actions.length){\n          log('All actions completed.');\n          finalizeSort();\n        }\n      }\n\n      function run(){\n        if (isRunning) return;\n        isRunning = true;\n        pauseBtn.textContent = 'Pause';\n        timer = setInterval(()=>{\n          if (actionIndex >= actions.length){\n            clearInterval(timer);\n            isRunning = false;\n            finalizeSort();\n            return;\n          }\n          step();\n        }, stepMs);\n      }\n\n      function pause(){\n        if (timer) clearInterval(timer);\n        isRunning = false;\n        pauseBtn.textContent = 'Resume';\n      }\n\n      function reset(){\n        if (timer) clearInterval(timer);\n        isRunning = false;\n        actionIndex = 0;\n        currentPass = -1;\n        newMainDiv = null;\n        collectedThisPass = 0;\n        movesThisPass = 0;\n        // restore items to originalItems values and displayValue, and render\n        if (originalItems && originalItems.length){\n          items = originalItems.map(it => ({...it}));\n        }\n        // If offsets were applied earlier, ensure we restore displayValue to original\n        for(let it of items){\n          it.displayValue = it.value;\n        }\n        renderMainArray(mainArrayDiv, items);\n        createBucketsDOM(base);\n        passPill.textContent = 'Pass: 0';\n        actionPill.textContent = `Action: 0 / 0`;\n        log('Reset to initial array.');\n      }\n\n      function finalizeSort(){\n        // restore offset if needed\n        const offset = actions._offset || 0;\n        if (offset){\n          // subtract offset from displayValue (we had kept displayValue original before offset)\n          // To ensure the final displayed numbers are original, we will fetch the DOM items and update their displayed text\n          // But we also need to update items array values\n          // After final pass, the DOM order equals sorted order of shifted values. We'll map them back.\n          const children = Array.from(mainArrayDiv.children);\n          for(const ch of children){\n            const id = ch.dataset.id;\n            // find in originalItems by id to get original value\n            const orig = originalItems.find(it => it.id === id);\n            if (orig){\n              const newV = orig.value; // original pre-offset value\n              // replace display text\n              const vspan = ch.querySelector('div:nth-child(2)');\n              if (vspan) vspan.textContent = String(newV);\n              // update items array\n              const itemObj = items.find(it => it.id === id);\n              if (itemObj) {\n                itemObj.value = newV;\n                itemObj.displayValue = newV;\n              }\n            }\n          }\n          log('Offset reversed; original negative values restored in display.');\n        } else {\n          // ensure displayValue is accurate final values\n          const children = Array.from(mainArrayDiv.children);\n          for(const ch of children){\n            const id = ch.dataset.id;\n            const it = items.find(x => x.id === id) || originalItems.find(x => x.id === id);\n            if (it){\n              const vspan = ch.querySelector('div:nth-child(2)');\n              if (vspan) vspan.textContent = String(it.displayValue ?? it.value);\n            }\n          }\n        }\n        passPill.textContent = `Pass: ${actions._passes}`;\n        actionPill.textContent = `Action: ${actions.length} / ${actions.length}`;\n        isRunning = false;\n        if (timer) clearInterval(timer);\n        log('Sorting finished.');\n      }\n\n      // Event wiring\n      fromTextBtn.addEventListener('click', ()=>{\n        const nums = parseInput(inputArray.value);\n        items = buildItemsFromNumbers(nums);\n        // set displayValue equal to value as baseline\n        for(const it of items) it.displayValue = it.value;\n        renderMainArray(mainArrayDiv, items);\n        log('Loaded array from text input.');\n      });\n\n      randomizeBtn.addEventListener('click', ()=>{\n        const n = Math.max(1, Math.min(60, parseInt(sizeInput.value) || 8));\n        const maxV = Math.max(1, parseInt(maxValInput.value) || 100);\n        const nums = [];\n        for(let i=0;i<n;i++){\n          const r = Math.floor(Math.random() * (maxV+1));\n          // allow negative sometimes if option checked\n          if (allowNegCheckbox.checked && Math.random() < 0.25){\n            nums.push(r - Math.floor(maxV/2));\n          } else nums.push(r);\n        }\n        inputArray.value = nums.join(', ');\n        items = buildItemsFromNumbers(nums);\n        for(const it of items) it.displayValue = it.value;\n        renderMainArray(mainArrayDiv, items);\n        log('Random array generated.');\n      });\n\n      radixSelect.addEventListener('change', ()=>{\n        base = parseInt(radixSelect.value,10);\n        infoPill.textContent = `Radix: ${base}`;\n        createBucketsDOM(base);\n      });\n\n      startBtn.addEventListener('click', ()=>{\n        // prepare items from input if not already loaded\n        const nums = parseInput(inputArray.value);\n        items = buildItemsFromNumbers(nums);\n        for(const it of items) it.displayValue = it.value;\n        base = parseInt(radixSelect.value,10);\n        ascending = ascendingCheckbox.checked;\n        allowNegatives = allowNegCheckbox.checked;\n        stepMs = parseInt(speedInput.value,10);\n        renderMainArray(mainArrayDiv, items);\n        buildAllActions();\n        // start running\n        if (actions.length > 0){\n          run();\n        } else {\n          log('Nothing to sort (empty array).');\n        }\n      });\n\n      stepBtn.addEventListener('click', ()=>{\n        // If not prepared, prepare actions first\n        if (!actions || actions.length === 0 || actionIndex === 0){\n          // reload items from input\n          const nums = parseInput(inputArray.value);\n          items = buildItemsFromNumbers(nums);\n          for(const it of items) it.displayValue = it.value;\n          renderMainArray(mainArrayDiv, items);\n          base = parseInt(radixSelect.value,10);\n          ascending = ascendingCheckbox.checked;\n          allowNegatives = allowNegCheckbox.checked;\n          buildAllActions();\n        }\n        pause(); // ensure paused\n        step();\n      });\n\n      pauseBtn.addEventListener('click', ()=>{\n        if (isRunning){\n          pause();\n        } else {\n          // resume\n          if (actionIndex >= actions.length){\n            log('Nothing to resume, already finished.');\n            return;\n          }\n          stepMs = parseInt(speedInput.value,10);\n          run();\n        }\n      });\n\n      resetBtn.addEventListener('click', ()=>{\n        reset();\n      });\n\n      speedInput.addEventListener('input', ()=>{\n        stepMs = parseInt(speedInput.value,10);\n        if (isRunning){\n          pause();\n          run();\n        }\n      });\n\n      ascendingCheckbox.addEventListener('change', ()=>{\n        ascending = ascendingCheckbox.checked;\n      });\n\n      allowNegCheckbox.addEventListener('change', ()=>{\n        allowNegatives = allowNegCheckbox.checked;\n      });\n\n      showValuesCheckbox.addEventListener('change', ()=>{\n        // rerender main array to show/hide numbers\n        renderMainArray(mainArrayDiv, items);\n      });\n\n      // initial render\n      (function init(){\n        const nums = parseInput(inputArray.value);\n        items = buildItemsFromNumbers(nums);\n        for(const it of items) it.displayValue = it.value;\n        renderMainArray(mainArrayDiv, items);\n        base = parseInt(radixSelect.value,10);\n        createBucketsDOM(base);\n        infoPill.textContent = `Radix: ${base}`;\n      })();\n\n      // keyboard shortcuts\n      document.addEventListener('keydown', (e) => {\n        if (e.key === ' '){\n          e.preventDefault();\n          if (isRunning) pause(); else run();\n        } else if (e.key === 'ArrowRight'){\n          e.preventDefault();\n          step();\n        } else if (e.key === 'Escape'){\n          pause();\n        }\n      });\n\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Radix Sort"
    }
  ],
  "topic": "Radix Sort",
  "hasFSM": false,
  "hasTest": true
}