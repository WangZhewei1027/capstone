{
  "id": "d809adb0-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:43.490Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Hash Table",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Hash Table (Separate Chaining) — Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --card:#0b1220;\n      --accent:#4fd1c5;\n      --muted:#9aa8b3;\n      --success:#16a34a;\n      --danger:#ef4444;\n      --glass: rgba(255,255,255,0.03);\n    }\n    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;}\n    body{\n      background: linear-gradient(180deg,#071028 0%, #061425 60%);\n      color:#e6eef6;\n      padding:20px;\n      box-sizing:border-box;\n    }\n    .container{\n      max-width:1100px;margin:0 auto;\n    }\n    header{display:flex;align-items:center;gap:16px;margin-bottom:18px}\n    header h1{font-size:20px;margin:0}\n    header p{margin:0;color:var(--muted);font-size:13px}\n    .card{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;padding:16px;margin-bottom:18px;box-shadow:0 6px 24px rgba(2,6,23,0.6);\n      border: 1px solid rgba(255,255,255,0.03);\n    }\n    .controls{\n      display:flex;flex-wrap:wrap;gap:12px;align-items:center;\n    }\n    .controls .group{display:flex;gap:8px;align-items:center}\n    input[type=\"text\"], input[type=\"number\"], select{\n      background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:inherit;\n      min-width:120px;\n    }\n    button{\n      background:var(--accent);border:0;padding:8px 12px;border-radius:8px;color:#042027;font-weight:600;cursor:pointer;\n      box-shadow:0 4px 10px rgba(79,209,197,0.12);\n    }\n    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}\n    .muted{color:var(--muted);font-size:13px}\n    .visual{\n      margin-top:14px;padding:12px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:8px;\n      overflow:auto;\n    }\n    .buckets{\n      display:flex;gap:10px;padding:10px;\n    }\n    .bucket{\n      min-width:130px;background:var(--glass);border-radius:10px;padding:10px;border:1px solid rgba(255,255,255,0.03);\n      display:flex;flex-direction:column;gap:8px;align-items:center;\n    }\n    .bindex{font-size:12px;color:var(--muted);background:rgba(255,255,255,0.02);padding:4px 6px;border-radius:6px}\n    .chain{\n      display:flex;flex-direction:column;gap:6px;width:100%;align-items:center;min-height:36px;\n    }\n    .node{\n      background:#071a1a;padding:6px 8px;border-radius:8px;color:#c9fff7;border:1px solid rgba(79,209,197,0.08);\n      width:92%;display:flex;justify-content:space-between;font-size:13px;\n    }\n    .node .k{font-weight:700;color:#bff3ee}\n    .node .v{color:var(--muted);font-weight:600}\n    .node.highlight{box-shadow:0 6px 18px rgba(79,209,197,0.12);transform:translateY(-4px);transition:transform 220ms}\n    .node.found{background:linear-gradient(90deg,#153a2f,#0c3e32);border-color:rgba(22,163,74,0.6)}\n    .node.del{opacity:0.45;text-decoration:line-through}\n    .status{\n      display:flex;gap:12px;flex-wrap:wrap;margin-top:12px;\n    }\n    .status .item{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;min-width:120px;text-align:center;border:1px solid rgba(255,255,255,0.03)}\n    .status .item .num{font-weight:700;font-size:16px}\n    .log{margin-top:12px;background:rgba(0,0,0,0.15);padding:8px;border-radius:8px;height:110px;overflow:auto;font-family:monospace;font-size:13px}\n    small.hint{color:var(--muted);display:block;margin-top:6px}\n    .controls-wrap{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap}\n    .leftcol{flex:1;min-width:320px}\n    .rightcol{width:360px}\n    footer{margin-top:10px;color:var(--muted);font-size:13px}\n    .legend{display:flex;gap:8px;align-items:center;margin-top:8px}\n    .legend .chip{width:12px;height:12px;border-radius:3px}\n    .chip.find{background:linear-gradient(90deg,#153a2f,#0c3e32)}\n    .chip.coll{background:#3b82f6}\n    @media (max-width:880px){\n      .buckets{flex-wrap:wrap}\n      .rightcol{width:100%}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <header>\n      <div>\n        <h1>Hash Table — Separate Chaining (Interactive)</h1>\n        <p>Explore basic hash table operations (insert/get/delete), collisions, load factor, and automatic resizing.</p>\n      </div>\n    </header>\n\n    <div class=\"card controls-wrap\">\n      <div class=\"leftcol\">\n        <div class=\"controls\">\n          <div class=\"group\">\n            <label class=\"muted\">Key</label>\n            <input id=\"keyInput\" type=\"text\" placeholder=\"e.g. apple\" />\n            <label class=\"muted\">Value</label>\n            <input id=\"valInput\" type=\"text\" placeholder=\"e.g. 42\" />\n            <button id=\"insertBtn\">Insert</button>\n            <button id=\"searchBtn\" class=\"ghost\">Search</button>\n            <button id=\"deleteBtn\" class=\"ghost\">Delete</button>\n          </div>\n        </div>\n        <small class=\"hint\">Keys are strings. Hash function used: djb2 (demonstration). Collisions are handled with separate chaining (linked lists).</small>\n\n        <div class=\"controls\" style=\"margin-top:12px;\">\n          <div class=\"group\">\n            <label class=\"muted\">Table size</label>\n            <input id=\"sizeInput\" type=\"number\" min=\"2\" value=\"8\" />\n            <button id=\"resizeBtn\" class=\"ghost\">Resize Table</button>\n          </div>\n          <div class=\"group\">\n            <label class=\"muted\">Auto-resize?</label>\n            <input id=\"autoResize\" type=\"checkbox\" checked />\n            <label class=\"muted\">Threshold</label>\n            <input id=\"threshold\" type=\"number\" min=\"0.1\" max=\"1\" step=\"0.05\" value=\"0.75\" />\n          </div>\n          <div class=\"group\">\n            <button id=\"randomBtn\" class=\"ghost\">Insert Random (10)</button>\n            <button id=\"clearBtn\" class=\"ghost\">Clear</button>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"rightcol\">\n        <div class=\"status\">\n          <div class=\"item\"><div class=\"muted\">Buckets</div><div id=\"bucketsCount\" class=\"num\">0</div></div>\n          <div class=\"item\"><div class=\"muted\">Elements</div><div id=\"elemsCount\" class=\"num\">0</div></div>\n          <div class=\"item\"><div class=\"muted\">Collisions</div><div id=\"collisionsCount\" class=\"num\">0</div></div>\n          <div class=\"item\"><div class=\"muted\">Load factor</div><div id=\"loadFactor\" class=\"num\">0</div></div>\n        </div>\n\n        <div class=\"legend\">\n          <div class=\"chip find\"></div><div class=\"muted\">Found</div>\n          <div class=\"chip coll\"></div><div class=\"muted\">Collision (bucket occupied)</div>\n        </div>\n\n        <div class=\"log\" id=\"log\"></div>\n      </div>\n    </div>\n\n    <div class=\"card visual\">\n      <div id=\"visualArea\">\n        <div class=\"buckets\" id=\"buckets\"></div>\n      </div>\n    </div>\n\n    <footer>\n      Tip: Try inserting keys that collide (like \"a\", \"k\", \"u\" in small table), then resize the table to see rehashing.\n    </footer>\n  </div>\n\n<script>\n/*\n  Hash Table demo (Separate Chaining)\n  - djb2 hash function for strings\n  - buckets are arrays (simulate linked lists)\n  - tracks collisions, supports auto-resize\n  - visualization with DOM updates and simple highlights\n*/\n\n// -------- HashTable class ----------\nclass HashTable {\n  constructor(capacity = 8, onChange = ()=>{}) {\n    this.capacity = Math.max(2, Math.floor(capacity));\n    this.buckets = Array.from({length: this.capacity}, ()=> []);\n    this._size = 0;\n    this.collisions = 0; // count of insert collisions (inserting into non-empty bucket)\n    this.onChange = onChange;\n  }\n\n  // djb2 hashing algorithm for strings -> non-negative integer\n  hash(key){\n    const str = String(key);\n    let hash = 5381;\n    for(let i=0;i<str.length;i++){\n      hash = ((hash << 5) + hash) + str.charCodeAt(i); // hash * 33 + c\n      hash = hash | 0; // ensure 32-bit\n    }\n    return Math.abs(hash);\n  }\n\n  indexFor(key){\n    return this.hash(key) % this.capacity;\n  }\n\n  // Insert key -> value (if key exists, overwrite)\n  put(key, value){\n    const idx = this.indexFor(key);\n    const bucket = this.buckets[idx];\n\n    // check if key exists, overwrite\n    for(let node of bucket){\n      if(node.key === key){\n        node.value = value;\n        this.onChange({type:'update', key, value, index: idx});\n        return {action:'update', index: idx};\n      }\n    }\n\n    // new insertion\n    if(bucket.length > 0){\n      this.collisions += 1;\n      // we still append to chain\n    }\n    bucket.push({key, value});\n    this._size += 1;\n    this.onChange({type:'insert', key, value, index: idx, collided: bucket.length>1});\n    return {action:'insert', index: idx, collided: bucket.length>1};\n  }\n\n  // Get value (returns {found, value, index})\n  get(key){\n    const idx = this.indexFor(key);\n    const bucket = this.buckets[idx];\n    for(let node of bucket){\n      if(node.key === key) return {found:true, value:node.value, index: idx};\n    }\n    return {found:false, index: idx};\n  }\n\n  // Remove key (returns true if removed)\n  remove(key){\n    const idx = this.indexFor(key);\n    const bucket = this.buckets[idx];\n    for(let i=0;i<bucket.length;i++){\n      if(bucket[i].key === key){\n        const removed = bucket.splice(i,1)[0];\n        this._size -= 1;\n        this.onChange({type:'remove', key, index: idx});\n        return {removed:true, value: removed.value, index: idx};\n      }\n    }\n    return {removed:false, index: idx};\n  }\n\n  keys(){\n    const arr = [];\n    for(const bucket of this.buckets){\n      for(const node of bucket) arr.push(node.key);\n    }\n    return arr;\n  }\n\n  size(){ return this._size; }\n  bucketsCount(){ return this.capacity; }\n  loadFactor(){ return this.capacity===0 ? 0 : (this._size / this.capacity); }\n\n  clear(){\n    this.buckets = Array.from({length: this.capacity}, ()=> []);\n    this._size = 0;\n    this.collisions = 0;\n    this.onChange({type:'clear'});\n  }\n\n  // Resize and rehash into newCapacity\n  rehash(newCapacity){\n    newCapacity = Math.max(2, Math.floor(newCapacity));\n    const oldBuckets = this.buckets;\n    this.capacity = newCapacity;\n    this.buckets = Array.from({length: this.capacity}, ()=> []);\n    this._size = 0;\n    this.collisions = 0;\n    // re-insert all entries (will recompute collisions)\n    for(const bucket of oldBuckets){\n      for(const node of bucket){\n        this.put(node.key, node.value);\n      }\n    }\n    this.onChange({type:'rehash', newCapacity});\n  }\n}\n\n// -------- UI and wiring ----------\nconst bucketsEl = document.getElementById('buckets');\nconst keyInput = document.getElementById('keyInput');\nconst valInput = document.getElementById('valInput');\nconst insertBtn = document.getElementById('insertBtn');\nconst searchBtn = document.getElementById('searchBtn');\nconst deleteBtn = document.getElementById('deleteBtn');\nconst sizeInput = document.getElementById('sizeInput');\nconst resizeBtn = document.getElementById('resizeBtn');\nconst randomBtn = document.getElementById('randomBtn');\nconst clearBtn = document.getElementById('clearBtn');\nconst autoResize = document.getElementById('autoResize');\nconst threshold = document.getElementById('threshold');\n\nconst bucketsCountEl = document.getElementById('bucketsCount');\nconst elemsCountEl = document.getElementById('elemsCount');\nconst collisionsCountEl = document.getElementById('collisionsCount');\nconst loadFactorEl = document.getElementById('loadFactor');\nconst logEl = document.getElementById('log');\n\nlet ht = new HashTable(parseInt(sizeInput.value), handleChange);\nrender();\n\n// Helper: log messages\nfunction log(msg, type='info'){\n  const time = new Date().toLocaleTimeString();\n  const line = document.createElement('div');\n  line.textContent = `[${time}] ${msg}`;\n  line.style.color = (type==='error' ? 'var(--danger)' : (type==='success'? 'var(--success)' : 'inherit'));\n  logEl.prepend(line);\n}\n\n// Render buckets to DOM\nfunction render(highlight=null){\n  bucketsEl.innerHTML = '';\n  for(let i=0;i<ht.capacity;i++){\n    const bucketDiv = document.createElement('div');\n    bucketDiv.className = 'bucket';\n    const idx = document.createElement('div');\n    idx.className = 'bindex';\n    idx.textContent = `#${i}`;\n    bucketDiv.appendChild(idx);\n\n    const chain = document.createElement('div');\n    chain.className = 'chain';\n\n    const bucket = ht.buckets[i];\n    if(bucket.length === 0){\n      const empty = document.createElement('div');\n      empty.className = 'node';\n      empty.style.justifyContent = 'center';\n      empty.style.opacity = 0.45;\n      empty.textContent = '(empty)';\n      chain.appendChild(empty);\n    } else {\n      for(const node of bucket){\n        const nd = document.createElement('div');\n        nd.className = 'node';\n        nd.innerHTML = `<span class=\"k\">${escapeHtml(node.key)}</span><span class=\"v\">${escapeHtml(String(node.value))}</span>`;\n        chain.appendChild(nd);\n      }\n    }\n\n    bucketDiv.appendChild(chain);\n    bucketsEl.appendChild(bucketDiv);\n  }\n\n  updateStats();\n\n  // if highlight instructed set styles\n  if(highlight){\n    // highlight bucket index by adding a top border color, and optionally highlight nodes\n    const bucketEl = bucketsEl.children[highlight.index];\n    if(bucketEl){\n      bucketEl.style.transition = 'box-shadow 300ms';\n      bucketEl.style.boxShadow = '0 10px 40px rgba(79,209,197,0.06)';\n      setTimeout(()=> bucketEl.style.boxShadow = '', 900);\n      if(highlight.keyFound){\n        // find the node and add found class\n        const nodes = bucketEl.querySelectorAll('.node');\n        for(const n of nodes){\n          if(n.querySelector('.k') && n.querySelector('.k').textContent === highlight.key){\n            n.classList.add('found','highlight');\n            setTimeout(()=> n.classList.remove('highlight'), 900);\n            break;\n          }\n        }\n      } else if(highlight.showCollision){\n        // make first node show collided by briefly highlighting\n        const first = bucketEl.querySelector('.node');\n        if(first){\n          first.classList.add('highlight');\n          setTimeout(()=> first.classList.remove('highlight'), 900);\n        }\n      } else if(highlight.removed){\n        // find removed node — we can't show it (it was removed), but flash bucket\n        bucketEl.style.opacity = 0.9;\n        setTimeout(()=> bucketEl.style.opacity = 1, 900);\n      }\n    }\n  }\n}\n\n// Escape until safe HTML injection for keys/values\nfunction escapeHtml(s){\n  return s.replace(/[&<>\"']/g, (m)=> ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[m]));\n}\n\nfunction updateStats(){\n  bucketsCountEl.textContent = ht.bucketsCount();\n  elemsCountEl.textContent = ht.size();\n  collisionsCountEl.textContent = ht.collisions;\n  loadFactorEl.textContent = (ht.loadFactor()).toFixed(3);\n}\n\n// Handle HashTable events (called from class via onChange)\nfunction handleChange(evt){\n  // evt: {type, ...}\n  switch(evt.type){\n    case 'insert':\n      log(`Inserted key \"${evt.key}\" at bucket ${evt.index}` + (evt.collided ? ' (collision occurred)':''), 'success');\n      render({index: evt.index, showCollision: evt.collided});\n      maybeAutoResize();\n      break;\n    case 'update':\n      log(`Updated key \"${evt.key}\" at bucket ${evt.index}`, 'info');\n      render({index: evt.index, keyFound: true});\n      break;\n    case 'remove':\n      log(`Removed key \"${evt.key}\" from bucket ${evt.index}`, 'info');\n      render({index: evt.index, removed: true});\n      break;\n    case 'rehash':\n      log(`Table rehashed to new capacity: ${evt.newCapacity}`, 'info');\n      render();\n      break;\n    case 'clear':\n      log(`Table cleared`, 'info');\n      render();\n      break;\n  }\n}\n\n// Auto resize if enabled and loadFactor > threshold\nfunction maybeAutoResize(){\n  if(!autoResize.checked) return;\n  const th = parseFloat(threshold.value) || 0.75;\n  if(ht.loadFactor() > th){\n    // double capacity\n    const newCap = ht.capacity * 2;\n    log(`Load factor ${ht.loadFactor().toFixed(3)} > ${th}. Auto-resizing to ${newCap}...`);\n    // small delay to show message before heavy rehash\n    setTimeout(()=> ht.rehash(newCap), 250);\n  }\n}\n\n// Button handlers\ninsertBtn.addEventListener('click', ()=>{\n  const key = keyInput.value.trim();\n  const val = valInput.value;\n  if(key === ''){\n    log('Please enter a non-empty key', 'error'); return;\n  }\n  ht.put(key, val);\n  keyInput.focus();\n});\n\nsearchBtn.addEventListener('click', ()=>{\n  const key = keyInput.value.trim();\n  if(key === ''){\n    log('Please enter a key to search', 'error'); return;\n  }\n  const res = ht.get(key);\n  if(res.found){\n    log(`Found key \"${key}\" in bucket ${res.index} -> value: ${res.value}`, 'success');\n    render({index: res.index, keyFound: true, key});\n  } else {\n    log(`Key \"${key}\" not found (would be in bucket ${res.index})`, 'error');\n    render({index: res.index});\n  }\n});\n\ndeleteBtn.addEventListener('click', ()=>{\n  const key = keyInput.value.trim();\n  if(key === ''){\n    log('Please enter a key to delete', 'error'); return;\n  }\n  const res = ht.remove(key);\n  if(res.removed){\n    log(`Removed key \"${key}\" (bucket ${res.index})`, 'success');\n    render({index: res.index, removed:true});\n  } else {\n    log(`Key \"${key}\" not found (nothing removed)`, 'error');\n    render({index: res.index});\n  }\n});\n\nresizeBtn.addEventListener('click', ()=>{\n  const newSize = parseInt(sizeInput.value) || ht.capacity;\n  if(newSize < 2){ log('Size must be at least 2', 'error'); return; }\n  ht.rehash(newSize);\n});\n\nrandomBtn.addEventListener('click', ()=>{\n  const words = [\"apple\",\"banana\",\"cherry\",\"date\",\"egg\",\"fig\",\"grape\",\"kiwi\",\"lemon\",\"mango\",\"nectarine\",\n                 \"olive\",\"papaya\",\"quince\",\"rasp\",\"straw\",\"tango\",\"umbrella\",\"violet\",\"walnut\",\"xray\",\"yarn\",\"zebra\"];\n  // insert 10 random key-value pairs (could collide)\n  for(let i=0;i<10;i++){\n    const k = words[Math.floor(Math.random()*words.length)] + (Math.random() < 0.5 ? '' : '_' + Math.floor(Math.random()*100));\n    const v = Math.floor(Math.random()*999);\n    ht.put(k, v);\n  }\n  render();\n});\n\nclearBtn.addEventListener('click', ()=>{\n  ht.clear();\n});\n\n// allow Enter key to insert\n[keyInput, valInput].forEach(el=>el.addEventListener('keydown', (e)=>{\n  if(e.key === 'Enter'){\n    insertBtn.click();\n  }\n}));\n\n// Initialize with a few keys to illustrate collisions in small table\n(function seedDemo(){\n  ht.put('a', 1);\n  ht.put('k', 2);\n  ht.put('u', 3);\n  ht.put('apple', 'fruit');\n  ht.put('banana', 'fruit');\n  render();\n  log('Demo seeded with a few keys. Try searching for \"a\", \"k\", \"u\" or resizing the table.', 'info');\n})();\n\n// Expose some debug utilities to console\nwindow._ht = ht;\nwindow._render = render;\nwindow._log = log;\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Hash Table"
    }
  ],
  "topic": "Hash Table",
  "hasFSM": false,
  "hasTest": true
}