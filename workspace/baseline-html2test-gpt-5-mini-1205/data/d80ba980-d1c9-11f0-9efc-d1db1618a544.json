{
  "id": "d80ba980-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:05.437Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>Topological Sort Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<style>\n  body { font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial; margin: 0; padding: 0; display: flex; height: 100vh; }\n  #left { width: 340px; border-right: 1px solid #ddd; padding: 12px; box-sizing: border-box; background: #fafafa; overflow:auto; }\n  #left h2 { margin: 6px 0 8px; font-size: 18px; }\n  #controls { display: flex; flex-wrap: wrap; gap:6px; margin-bottom:10px; }\n  button { padding:6px 8px; font-size: 13px; }\n  .mode { display:flex; gap:6px; margin:8px 0; align-items:center; }\n  .info { font-size:13px; color:#333; margin:8px 0; }\n  #adj, #indeg, #log { font-family: monospace; font-size:13px; background:#fff; padding:8px; border:1px solid #eee; max-height:160px; overflow:auto; }\n  label { font-size:13px; }\n  #canvasWrap { flex:1; position:relative; background: linear-gradient(180deg,#fff,#f7fbff); }\n  svg { width:100%; height:100%; display:block; }\n  .node { cursor: pointer; }\n  .node circle { fill:#4da6ff; stroke:#0a5aa1; stroke-width:1.5px; }\n  .node text { fill:white; font-weight:700; pointer-events:none; }\n  .edge { stroke:#444; stroke-width:2px; fill:none; marker-end: url(#arrow); }\n  .edge.cycle { stroke: #e03e3e; }\n  .node.removed circle { fill:#bfbfbf; stroke:#8c8c8c; }\n  .node.highlight circle { fill:#28a745; stroke:#19692b; }\n  .node.cycle circle { fill:#e03e3e; stroke:#7a1212; }\n  .badge { display:inline-block; background:#eee; padding:3px 6px; border-radius:10px; font-size:12px; margin-left:6px; }\n  #status { font-size:13px; margin-top:8px; }\n  .small { font-size:12px; color:#555; }\n  .control-group { margin-bottom:10px; }\n  input[type=number] { width:60px; padding:4px; }\n  footer { font-size:12px; color:#666; margin-top:10px; }\n</style>\n</head>\n<body>\n  <div id=\"left\">\n    <h2>Topological Sort Demo</h2>\n    <div class=\"info\">\n      Build a directed acyclic graph (DAG) or create cycles. Try Kahn's algorithm and DFS-based topological sort. Click the canvas to add nodes, drag nodes to move, add edges by selecting \"Add Edge\" and clicking source then target.\n    </div>\n\n    <div class=\"control-group\">\n      <div id=\"controls\">\n        <button id=\"addNodeBtn\">Add Node</button>\n        <button id=\"addEdgeBtn\">Add Edge</button>\n        <button id=\"deleteBtn\">Delete Mode</button>\n        <button id=\"dragBtn\">Drag Mode</button>\n      </div>\n      <div class=\"small\">Modes: Add Node (click canvas) • Add Edge (click source then target) • Delete (click node/edge) • Drag (move nodes)</div>\n    </div>\n\n    <div class=\"control-group\">\n      <button id=\"randomDAG\">Random DAG</button>\n      <button id=\"randomGraph\">Random Graph (may have cycles)</button>\n      <button id=\"clearBtn\">Clear</button>\n      <button id=\"resetPositions\">Reset Positions</button>\n    </div>\n\n    <div class=\"control-group\">\n      <button id=\"runKahn\">Run Kahn's Algorithm</button>\n      <button id=\"runDFS\">Run DFS TopoSort</button>\n      <button id=\"stepKahn\">Step Kahn</button>\n      <button id=\"stopAnimation\">Stop</button>\n    </div>\n\n    <div id=\"status\" class=\"small\">Mode: <span id=\"modeLabel\">Drag</span></div>\n\n    <h3 style=\"margin-top:10px;\">Graph Info</h3>\n    <div style=\"display:flex;gap:8px;\">\n      <div style=\"flex:1\">\n        <div class=\"small\">Adjacency list</div>\n        <pre id=\"adj\">[]</pre>\n      </div>\n      <div style=\"width:110px\">\n        <div class=\"small\">In-degrees</div>\n        <pre id=\"indeg\">[]</pre>\n      </div>\n    </div>\n\n    <h3>Log / Messages</h3>\n    <div id=\"log\">Ready.</div>\n\n    <footer>\n      Implementation: Kahn (BFS in-degree) and DFS (post-order). Detects cycles. SVG-only visualization, no external libraries.\n    </footer>\n  </div>\n\n  <div id=\"canvasWrap\">\n    <svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\">\n      <defs>\n        <marker id=\"arrow\" viewBox=\"0 0 10 10\" refX=\"9\" refY=\"5\" markerWidth=\"6\" markerHeight=\"6\" orient=\"auto-start-reverse\">\n          <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#444\"></path>\n        </marker>\n        <marker id=\"arrow-red\" viewBox=\"0 0 10 10\" refX=\"9\" refY=\"5\" markerWidth=\"6\" markerHeight=\"6\" orient=\"auto-start-reverse\">\n          <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#e03e3e\"></path>\n        </marker>\n      </defs>\n      <g id=\"edges\"></g>\n      <g id=\"nodes\"></g>\n    </svg>\n  </div>\n\n<script>\n// Data model\nlet nodes = []; // {id,label,x,y}\nlet edges = []; // {id, from, to}\nlet nextNodeId = 0;\nlet nextEdgeId = 0;\n\n// Modes: 'drag','addNode','addEdge','delete'\nlet mode = 'drag';\nlet svg = document.getElementById('svg');\nlet nodesG = document.getElementById('nodes');\nlet edgesG = document.getElementById('edges');\nlet modeLabel = document.getElementById('modeLabel');\nlet adjPre = document.getElementById('adj');\nlet indegPre = document.getElementById('indeg');\nlet logEl = document.getElementById('log');\n\nfunction log(msg) {\n  logEl.textContent = msg;\n}\n\n// Utilities\nfunction createNodeAt(x,y) {\n  const id = nextNodeId++;\n  const label = String.fromCharCode(65 + (id % 26)) + (Math.floor(id/26) || '');\n  nodes.push({id, label, x, y});\n  render();\n  updateInfo();\n}\n\nfunction createEdge(fromId,toId) {\n  // prevent duplicate same directed edge\n  if (edges.some(e => e.from===fromId && e.to===toId)) {\n    log('Edge already exists.');\n    return;\n  }\n  // prevent self-loop?\n  // allow self-loop but it will create cycle.\n  edges.push({id: nextEdgeId++, from: fromId, to: toId});\n  render();\n  updateInfo();\n}\n\nfunction deleteNode(id) {\n  nodes = nodes.filter(n => n.id !== id);\n  edges = edges.filter(e => e.from !== id && e.to !== id);\n  render();\n  updateInfo();\n}\n\nfunction deleteEdge(id) {\n  edges = edges.filter(e => e.id !== id);\n  render();\n  updateInfo();\n}\n\nfunction clearGraph() {\n  nodes = []; edges = []; nextNodeId = 0; nextEdgeId = 0;\n  render(); updateInfo();\n}\n\n// Generate random DAG\nfunction randomDAG(nodeCount=6, density=0.25) {\n  clearGraph();\n  for (let i=0;i<nodeCount;i++){\n    const x = 80 + Math.random() * (svg.clientWidth-200);\n    const y = 60 + Math.random() * (svg.clientHeight-140);\n    createNodeAt(x,y);\n  }\n  // impose a random topological order by node index\n  for (let i=0;i<nodes.length;i++){\n    for (let j=i+1;j<nodes.length;j++){\n      if (Math.random() < density) createEdge(nodes[i].id, nodes[j].id);\n    }\n  }\n  log('Random DAG generated.');\n}\n\n// Random graph (may have cycles)\nfunction randomGraph(nodeCount=7, density=0.3) {\n  clearGraph();\n  for (let i=0;i<nodeCount;i++){\n    const x = 80 + Math.random() * (svg.clientWidth-200);\n    const y = 60 + Math.random() * (svg.clientHeight-140);\n    createNodeAt(x,y);\n  }\n  for (let i=0;i<nodes.length;i++){\n    for (let j=0;j<nodes.length;j++){\n      if (i===j) continue;\n      if (Math.random() < density) createEdge(nodes[i].id, nodes[j].id);\n    }\n  }\n  log('Random graph generated (cycles possible).');\n}\n\n// Rendering\nfunction render() {\n  // clear\n  edgesG.innerHTML = '';\n  nodesG.innerHTML = '';\n\n  // draw edges\n  edges.forEach(e => {\n    const from = nodes.find(n => n.id === e.from);\n    const to = nodes.find(n => n.id === e.to);\n    if (!from || !to) return;\n    const line = document.createElementNS('http://www.w3.org/2000/svg','path');\n    line.setAttribute('class','edge');\n    line.setAttribute('data-edge-id', e.id);\n    line.addEventListener('click', (ev)=> {\n      ev.stopPropagation();\n      if (mode === 'delete') {\n        deleteEdge(e.id);\n        log('Deleted edge.');\n      }\n    });\n    edgesG.appendChild(line);\n    updateEdgePath(line, from, to);\n  });\n\n  // draw nodes\n  nodes.forEach(n => {\n    const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n    g.setAttribute('class','node');\n    g.setAttribute('data-node-id', n.id);\n    g.setAttribute('transform', `translate(${n.x},${n.y})`);\n    // circle\n    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');\n    c.setAttribute('r', 22);\n    g.appendChild(c);\n    // text\n    const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n    t.setAttribute('x',0);\n    t.setAttribute('y',6);\n    t.setAttribute('text-anchor','middle');\n    t.textContent = n.label;\n    g.appendChild(t);\n\n    // degree badge\n    const badge = document.createElementNS('http://www.w3.org/2000/svg','text');\n    badge.setAttribute('x',18);\n    badge.setAttribute('y',22);\n    badge.setAttribute('text-anchor','end');\n    badge.setAttribute('fill','#222');\n    badge.setAttribute('font-size','10');\n    badge.setAttribute('pointer-events','none');\n    badge.textContent = '';\n    g.appendChild(badge);\n\n    nodesG.appendChild(g);\n\n    // events\n    g.addEventListener('mousedown', nodeMouseDown);\n    g.addEventListener('mouseup', nodeMouseUp);\n    g.addEventListener('click', (ev)=>{\n      ev.stopPropagation();\n      const nid = n.id;\n      if (mode === 'addEdge') {\n        handleAddEdgeClick(nid);\n      } else if (mode === 'delete') {\n        deleteNode(nid);\n        log('Deleted node ' + n.label);\n      }\n    });\n  });\n\n  // Attach arrow markers depending on edge classes are handled via class; simpler to use same marker\n\n  updateInfo();\n}\n\n// update path coordinates, draw a bezier/straight line with arrow\nfunction updateEdgePath(pathEl, from, to) {\n  const dx = to.x - from.x;\n  const dy = to.y - from.y;\n  const dist = Math.hypot(dx,dy);\n  if (dist < 1) return;\n  // compute start and end offset to circle radius (22)\n  const r = 22;\n  const ux = dx / dist;\n  const uy = dy / dist;\n  const sx = from.x + ux * r;\n  const sy = from.y + uy * r;\n  const tx = to.x - ux * r;\n  const ty = to.y - uy * r;\n  // control points for slight curve\n  const mx = (sx + tx)/2 - uy * Math.min(60, dist/2);\n  const my = (sy + ty)/2 + ux * Math.min(60, dist/2);\n  pathEl.setAttribute('d', `M ${sx} ${sy} Q ${mx} ${my} ${tx} ${ty}`);\n  pathEl.setAttribute('marker-end', 'url(#arrow)');\n}\n\n// Interaction: dragging\nlet dragState = {dragging:false, id:null, ox:0, oy:0, startX:0, startY:0};\n\nfunction nodeMouseDown(ev) {\n  if (mode !== 'drag') return;\n  ev.preventDefault();\n  const g = ev.currentTarget;\n  const id = parseInt(g.getAttribute('data-node-id'));\n  dragState.dragging = true;\n  dragState.id = id;\n  dragState.ox = ev.clientX;\n  dragState.oy = ev.clientY;\n  const n = nodes.find(x => x.id === id);\n  dragState.startX = n.x;\n  dragState.startY = n.y;\n  window.addEventListener('mousemove', windowMouseMove);\n  window.addEventListener('mouseup', windowMouseUp);\n}\nfunction nodeMouseUp(ev) {\n  // required for compatibility; actual end handled by windowMouseUp\n}\nfunction windowMouseMove(ev) {\n  if (!dragState.dragging) return;\n  const dx = ev.clientX - dragState.ox;\n  const dy = ev.clientY - dragState.oy;\n  const n = nodes.find(x => x.id === dragState.id);\n  n.x = dragState.startX + dx;\n  n.y = dragState.startY + dy;\n  render();\n}\nfunction windowMouseUp(ev) {\n  if (dragState.dragging) {\n    dragState.dragging = false;\n    dragState.id = null;\n    window.removeEventListener('mousemove', windowMouseMove);\n    window.removeEventListener('mouseup', windowMouseUp);\n  }\n}\n\n// Canvas click for adding node\nsvg.addEventListener('click', (ev)=>{\n  if (mode !== 'addNode') return;\n  // compute SVG coordinates\n  const pt = svg.createSVGPoint();\n  pt.x = ev.clientX; pt.y = ev.clientY;\n  const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());\n  createNodeAt(svgP.x, svgP.y);\n  log('Added node.');\n});\n\n// Add edge via selecting source then target\nlet edgePending = null;\nfunction handleAddEdgeClick(nodeId) {\n  if (edgePending == null) {\n    edgePending = nodeId;\n    highlightNode(nodeId, 'highlight');\n    log('Selected source node. Click target node to complete edge.');\n  } else {\n    if (edgePending === nodeId) {\n      log('Self-loop will be created.');\n    }\n    createEdge(edgePending, nodeId);\n    unhighlightAll();\n    edgePending = null;\n    log('Edge created.');\n  }\n}\nfunction highlightNode(nodeId, cls) {\n  // add class\n  const g = nodesG.querySelector(`[data-node-id=\"${nodeId}\"]`);\n  if (g) g.classList.add(cls);\n}\nfunction unhighlightAll() {\n  Array.from(nodesG.children).forEach(g => g.classList.remove('highlight','removed','cycle'));\n  Array.from(edgesG.children).forEach(e => e.classList.remove('cycle'));\n}\n\n// Delete mode: also allow clicking edges (handled earlier)\n\n// Update info displays\nfunction buildAdjacency() {\n  const adj = {};\n  nodes.forEach(n => adj[n.id] = []);\n  edges.forEach(e => {\n    if (adj[e.from]) adj[e.from].push(e.to);\n  });\n  return adj;\n}\nfunction computeInDegrees() {\n  const indeg = {};\n  nodes.forEach(n => indeg[n.id] = 0);\n  edges.forEach(e => {\n    if (indeg.hasOwnProperty(e.to)) indeg[e.to]++;\n  });\n  return indeg;\n}\nfunction updateInfo() {\n  const adj = buildAdjacency();\n  // adjacency list display using labels\n  function labelOf(id){ const n = nodes.find(x=>x.id===id); return n? n.label : '?'; }\n  const entries = nodes.map(n => `${n.label}: [${(adj[n.id]||[]).map(labelOf).join(', ')}]`);\n  adjPre.textContent = entries.join('\\n');\n\n  const indeg = computeInDegrees();\n  const indegEntries = nodes.map(n => `${n.label}: ${indeg[n.id] || 0}`);\n  indegPre.textContent = indegEntries.join('\\n');\n\n  // update badges on nodes (in-degree)\n  Array.from(nodesG.children).forEach(g => {\n    const nid = parseInt(g.getAttribute('data-node-id'));\n    const badge = g.querySelectorAll('text')[1];\n    if (badge) badge.textContent = indeg[nid] !== undefined ? indeg[nid] : '';\n  });\n\n  // update edge paths (positions might change)\n  Array.from(edgesG.children).forEach(pathEl => {\n    const eid = parseInt(pathEl.getAttribute('data-edge-id'));\n    const e = edges.find(x=>x.id===eid);\n    if (e) {\n      const from = nodes.find(n => n.id === e.from);\n      const to = nodes.find(n => n.id === e.to);\n      if (from && to) updateEdgePath(pathEl, from, to);\n    }\n  });\n}\n\n// UI controls\ndocument.getElementById('addNodeBtn').addEventListener('click', ()=> setMode('addNode'));\ndocument.getElementById('addEdgeBtn').addEventListener('click', ()=> setMode('addEdge'));\ndocument.getElementById('deleteBtn').addEventListener('click', ()=> setMode('delete'));\ndocument.getElementById('dragBtn').addEventListener('click', ()=> setMode('drag'));\n\ndocument.getElementById('randomDAG').addEventListener('click', ()=> randomDAG(6, 0.3));\ndocument.getElementById('randomGraph').addEventListener('click', ()=> randomGraph(7, 0.28));\ndocument.getElementById('clearBtn').addEventListener('click', ()=> { clearGraph(); log('Cleared graph.'); });\ndocument.getElementById('resetPositions').addEventListener('click', ()=> {\n  // spread nodes evenly\n  const w = svg.clientWidth, h = svg.clientHeight;\n  const cols = Math.ceil(Math.sqrt(nodes.length));\n  nodes.forEach((n,i)=>{\n    const col = i % cols;\n    const row = Math.floor(i/cols);\n    n.x = 80 + col * Math.min(160, (w-160)/cols);\n    n.y = 80 + row * 100;\n  });\n  render();\n  log('Reset positions.');\n});\n\nfunction setMode(m) {\n  mode = m;\n  modeLabel.textContent = m.charAt(0).toUpperCase() + m.slice(1);\n  edgePending = null;\n  unhighlightAll();\n}\n\n// Algorithm implementations\n\n// Kahn's algorithm (animated)\nlet animationHandle = null;\nlet animationPaused = false;\n\nfunction runKahnStepwise(auto=true, stepDelay=700) {\n  const adj = buildAdjacency();\n  const indeg = computeInDegrees();\n  const q = [];\n  nodes.forEach(n => { if ((indeg[n.id]||0) === 0) q.push(n.id); });\n  const order = [];\n  const visited = new Set();\n  let step = 0;\n\n  function markNodeAsRemoved(id) {\n    const g = nodesG.querySelector(`[data-node-id=\"${id}\"]`);\n    if (g) {\n      g.classList.add('removed');\n      g.classList.remove('highlight','cycle');\n    }\n  }\n  function markNodeHighlight(id) {\n    const g = nodesG.querySelector(`[data-node-id=\"${id}\"]`);\n    if (g) g.classList.add('highlight');\n  }\n\n  function stepFn() {\n    if (animationPaused) return;\n    // update indeg display\n    updateInfo();\n    if (q.length === 0) {\n      // finished or cycle\n      if (order.length === nodes.length) {\n        log('Kahn finished. Topological order: ' + order.map(idToLabel).join(' → '));\n        // highlight order sequentially\n        animateOrder(order);\n      } else {\n        // cycle detected\n        // find nodes not in order\n        const remaining = nodes.filter(n => !order.includes(n.id)).map(n=>n.id);\n        remaining.forEach(id => {\n          const g = nodesG.querySelector(`[data-node-id=\"${id}\"]`);\n          if (g) g.classList.add('cycle');\n        });\n        // mark cycle edges red\n        Array.from(edgesG.children).forEach(pathEl => {\n          const eid = parseInt(pathEl.getAttribute('data-edge-id'));\n          const e = edges.find(x=>x.id===eid);\n          if (e && remaining.includes(e.from) && remaining.includes(e.to)) pathEl.classList.add('cycle');\n        });\n        log('Cycle detected. No topological order exists. Highlighted nodes/edges might be part of cycle.');\n      }\n      animationHandle = null;\n      return;\n    }\n    const cur = q.shift();\n    step++;\n    markNodeHighlight(cur);\n    setTimeout(()=> {\n      // remove node\n      markNodeAsRemoved(cur);\n      order.push(cur);\n      // reduce indegree of neighbors\n      (adj[cur]||[]).forEach(nb => {\n        indeg[nb]--;\n        if (indeg[nb] === 0) q.push(nb);\n      });\n      // continue\n      animationHandle = setTimeout(stepFn, auto ? stepDelay : 0);\n    }, 250);\n  }\n  // start\n  animationPaused = false;\n  stepFn();\n  return {stop: ()=> {animationPaused = true; if (animationHandle) clearTimeout(animationHandle); animationHandle = null;}};\n}\n\nfunction animateOrder(order) {\n  // briefly highlight each in order green\n  let i = 0;\n  const interval = setInterval(()=>{\n    if (i >= order.length) {\n      clearInterval(interval);\n      log('Final order: ' + order.map(idToLabel).join(' → '));\n      return;\n    }\n    unhighlightAll();\n    const id = order[i++];\n    const g = nodesG.querySelector(`[data-node-id=\"${id}\"]`);\n    if (g) g.classList.add('highlight');\n  }, 600);\n}\n\n// DFS based topo sort\nfunction runDFS() {\n  unhighlightAll();\n  const adj = buildAdjacency();\n  const color = {}; // 0 white, 1 gray, 2 black\n  const order = [];\n  let hasCycle = false;\n  const cycleNodes = new Set();\n\n  function dfs(u, ancStack) {\n    color[u] = 1;\n    ancStack.push(u);\n    // highlight current\n    const g = nodesG.querySelector(`[data-node-id=\"${u}\"]`);\n    if (g) g.classList.add('highlight');\n    for (const v of (adj[u]||[])) {\n      if (color[v] === 0) {\n        if (dfs(v, ancStack)) return true;\n      } else if (color[v] === 1) {\n        // back edge -> cycle\n        hasCycle = true;\n        // mark cycle nodes (from v to end of ancStack)\n        const idx = ancStack.indexOf(v);\n        if (idx >= 0) {\n          for (let k = idx; k < ancStack.length; k++) cycleNodes.add(ancStack[k]);\n        }\n        cycleNodes.add(v);\n        return true;\n      }\n    }\n    ancStack.pop();\n    color[u] = 2;\n    order.push(u);\n    return false;\n  }\n\n  nodes.forEach(n => color[n.id] = 0);\n  for (const n of nodes) {\n    if (color[n.id] === 0) {\n      const stop = dfs(n.id, []);\n      if (stop) break;\n    }\n  }\n  if (hasCycle) {\n    // highlight cycle\n    cycleNodes.forEach(id => {\n      const g = nodesG.querySelector(`[data-node-id=\"${id}\"]`);\n      if (g) g.classList.add('cycle');\n    });\n    // highlight cycle edges\n    Array.from(edgesG.children).forEach(pathEl => {\n      const eid = parseInt(pathEl.getAttribute('data-edge-id'));\n      const e = edges.find(x=>x.id===eid);\n      if (e && cycleNodes.has(e.from) && cycleNodes.has(e.to)) pathEl.classList.add('cycle');\n    });\n    log('Cycle detected by DFS. Nodes in red may belong to a cycle.');\n  } else {\n    order.reverse();\n    log('DFS topo sort produced order: ' + order.map(idToLabel).join(' → '));\n    animateOrder(order);\n  }\n}\n\n// helpers\nfunction idToLabel(id) {\n  const n = nodes.find(x=>x.id===id);\n  return n? n.label : '?';\n}\n\n// Buttons for running algorithms\ndocument.getElementById('runKahn').addEventListener('click', ()=> {\n  unhighlightAll();\n  if (animationHandle) { clearTimeout(animationHandle); animationHandle = null; }\n  runKahnStepwise(true, 700);\n});\ndocument.getElementById('stepKahn').addEventListener('click', ()=> {\n  unhighlightAll();\n  if (animationHandle) { clearTimeout(animationHandle); animationHandle = null; }\n  // step-by-step non-auto: perform single step at a time\n  // Implement small manual stepper using closure\n  const adj = buildAdjacency();\n  const indeg = computeInDegrees();\n  const q = [];\n  nodes.forEach(n => { if ((indeg[n.id]||0) === 0) q.push(n.id); });\n  const order = [];\n  function singleStep() {\n    updateInfo();\n    if (q.length === 0) {\n      if (order.length === nodes.length) {\n        log('Kahn finished. Topological order: ' + order.map(idToLabel).join(' → '));\n      } else {\n        const remaining = nodes.filter(n => !order.includes(n.id)).map(n=>n.id);\n        remaining.forEach(id => {\n          const g = nodesG.querySelector(`[data-node-id=\"${id}\"]`);\n          if (g) g.classList.add('cycle');\n        });\n        Array.from(edgesG.children).forEach(pathEl => {\n          const eid = parseInt(pathEl.getAttribute('data-edge-id'));\n          const e = edges.find(x=>x.id===eid);\n          if (e && remaining.includes(e.from) && remaining.includes(e.to)) pathEl.classList.add('cycle');\n        });\n        log('Cycle detected. No more steps.');\n      }\n      return;\n    }\n    const cur = q.shift();\n    const g = nodesG.querySelector(`[data-node-id=\"${cur}\"]`);\n    if (g) {\n      g.classList.add('highlight');\n      setTimeout(()=> {\n        g.classList.remove('highlight');\n        g.classList.add('removed');\n      }, 250);\n    }\n    order.push(cur);\n    (adj[cur]||[]).forEach(nb => {\n      indeg[nb]--;\n      if (indeg[nb] === 0) q.push(nb);\n    });\n    log('Removed ' + idToLabel(cur) + '.');\n    updateInfo();\n    // store stepper for next manual step by reassigning stepper state closure variables\n    // To implement manual stepping, we reuse this closure by setting global \"manualKahn\" to this function bound to current state\n    manualKahn = singleStep;\n  }\n  // initialize manualKahn\n  window.manualKahn = null;\n  // run an initial step so user can press Step again\n  singleStep();\n});\ndocument.getElementById('runDFS').addEventListener('click', ()=> {\n  if (animationHandle) { clearTimeout(animationHandle); animationHandle = null; }\n  unhighlightAll();\n  runDFS();\n});\ndocument.getElementById('stopAnimation').addEventListener('click', ()=> {\n  if (animationHandle) { clearTimeout(animationHandle); animationHandle = null; }\n  animationPaused = true;\n  unhighlightAll();\n  updateInfo();\n  log('Stopped animations.');\n});\n\n// allow pressing space or Enter to step manual Kahn\nwindow.addEventListener('keydown', (ev)=> {\n  if ((ev.key === ' ' || ev.key === 'Enter') && typeof window.manualKahn === 'function') {\n    ev.preventDefault();\n    window.manualKahn();\n  }\n});\n\n// initial demo graph\n(function initDemo(){\n  // place some nodes and edges\n  clearGraph();\n  const w = Math.max(svg.clientWidth, 600);\n  const h = Math.max(svg.clientHeight, 400);\n  const coords = [\n    [120,120],[320,80],[520,140],[220,260],[460,260],[720,180]\n  ];\n  for (let i=0;i<coords.length;i++){\n    createNodeAt(coords[i][0], coords[i][1]);\n  }\n  // edges that form a DAG\n  createEdge(0,1);\n  createEdge(0,3);\n  createEdge(1,2);\n  createEdge(1,4);\n  createEdge(3,4);\n  createEdge(2,5);\n  createEdge(4,5);\n  setMode('drag');\n  log('Demo DAG loaded. Try Kahn or DFS.');\n})();\n\n// Make edges clickable/selectable: clicking empty space should clear edgePending\nsvg.addEventListener('click', ()=> {\n  if (mode === 'addEdge') {\n    // clicking on empty space cancels selection\n    if (edgePending != null) {\n      edgePending = null;\n      unhighlightAll();\n      log('Cancelled edge creation.');\n    }\n  }\n});\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": false,
  "hasTest": true
}