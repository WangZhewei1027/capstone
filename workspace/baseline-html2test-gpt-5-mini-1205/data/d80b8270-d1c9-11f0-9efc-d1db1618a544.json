{
  "id": "d80b8270-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:19.877Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Floyd-Warshall Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Floyd–Warshall Algorithm Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 0; display: flex; height: 100vh; }\n    #left { width: 48%; border-right: 1px solid #ddd; padding: 12px; box-sizing: border-box; overflow: auto; }\n    #right { flex: 1; padding: 12px; box-sizing: border-box; overflow: auto; }\n    h1 { margin: 0 0 8px 0; font-size: 20px; }\n    .controls { display:flex; gap:8px; flex-wrap:wrap; margin-bottom: 8px; }\n    button, select, input[type=\"range\"] { padding:6px 8px; font-size:14px; }\n    #canvasWrap { border:1px solid #ccc; height:480px; background:#fafafa; position:relative; }\n    svg { width:100%; height:100%; display:block; }\n    .node { cursor: pointer; }\n    .node circle { fill:#1e90ff; stroke:#0b61c6; stroke-width:2px; }\n    .node text { fill:white; font-weight:700; pointer-events:none; font-size:12px; }\n    .edge { stroke:#333; stroke-width:2px; fill:none; }\n    .edgeLabel { font-size:12px; fill:#111; background:rgba(255,255,255,.8); }\n    .selected circle { fill:#ff9800; stroke:#c76b00; }\n    .hover circle { stroke:#22a; stroke-width:3px; }\n    .arrowhead { fill:#333; }\n    .highlightEdge { stroke:#e91e63; stroke-width:3px; }\n    .updatedEdge { stroke:#4caf50; stroke-width:4px; }\n    .tableWrap { display:flex; gap:12px; margin-top:12px; flex-wrap:wrap; }\n    table { border-collapse: collapse; font-size:13px; }\n    th, td { border:1px solid #ddd; padding:6px 8px; text-align:center; min-width:36px; }\n    th { background:#f5f5f5; font-weight:600; }\n    .inf { color:#999; }\n    .cell-highlight { background: #fff3cd; }\n    .cell-updated { background: #d4edda; }\n    #snapshotInfo { margin-top:8px; }\n    .legend { margin-top:10px; font-size:13px; color:#444; }\n    .small { font-size:13px; color:#666; }\n    label { font-size:13px; }\n    .footer { margin-top:12px; color:#666; font-size:13px; }\n    #speed { width:120px; }\n  </style>\n</head>\n<body>\n  <div id=\"left\">\n    <h1>Floyd–Warshall Visualizer</h1>\n    <div class=\"controls\">\n      <button id=\"addNodeBtn\">Add Node</button>\n      <button id=\"clearBtn\">Clear</button>\n      <button id=\"randomBtn\">Random Graph</button>\n      <label><input type=\"checkbox\" id=\"directed\" checked> Directed</label>\n      <label style=\"margin-left:8px;\">Nodes: <span id=\"nodeCount\">0</span></label>\n    </div>\n\n    <div id=\"canvasWrap\">\n      <svg id=\"svg\"></svg>\n    </div>\n\n    <div style=\"margin-top:12px;\">\n      <div class=\"controls\">\n        <button id=\"runBtn\">Compute (all)</button>\n        <button id=\"stepBackBtn\">◀ Step Back</button>\n        <button id=\"stepForwardBtn\">Step ▶</button>\n        <button id=\"playBtn\">Play</button>\n        <button id=\"pauseBtn\" disabled>Pause</button>\n        <label>Speed <input id=\"speed\" type=\"range\" min=\"200\" max=\"2000\" step=\"100\" value=\"800\"></label>\n        <button id=\"resetPositions\">Reset Positions</button>\n      </div>\n\n      <div class=\"controls small\">\n        <label>Current snapshot: <span id=\"snapIndex\">0</span>/<span id=\"snapTotal\">0</span></label>\n        <label id=\"snapshotInfo\"></label>\n        <label id=\"negCycle\" style=\"color:#b71c1c;\"></label>\n      </div>\n\n      <div class=\"tableWrap\">\n        <div>\n          <div class=\"small\">Distance matrix (D)</div>\n          <div id=\"distTableWrap\"></div>\n        </div>\n        <div>\n          <div class=\"small\">Next matrix (next)</div>\n          <div id=\"nextTableWrap\"></div>\n        </div>\n        <div style=\"min-width:220px;\">\n          <div class=\"small\">Path between nodes</div>\n          <select id=\"fromSelect\"></select>\n          <select id=\"toSelect\"></select>\n          <button id=\"showPathBtn\">Show Path</button>\n          <div class=\"small\" id=\"pathDisplay\"></div>\n          <div class=\"legend\">\n            Click a node once to select (for adding edge), click second to create edge.<br>\n            Drag nodes to reposition. Click an edge to edit weight.\n          </div>\n        </div>\n      </div>\n      <div class=\"footer\">\n        Implementation notes: this visualizer computes Floyd–Warshall snapshots at each (k,i,j) comparison and records matrix updates and path reconstruction (next matrix). Negative cycle detection shown if any diagonal becomes negative.\n      </div>\n    </div>\n  </div>\n\n  <div id=\"right\">\n    <h1>How it works</h1>\n    <p class=\"small\">Floyd–Warshall finds shortest paths between all pairs of nodes. It maintains:\n    - D[i][j]: current shortest distance from i to j\n    - next[i][j]: the next vertex after i on the shortest path to j (used to reconstruct path)</p>\n\n    <p class=\"small\">Algorithm (conceptual):\n    for k from 0..n-1:\n      for i from 0..n-1:\n        for j from 0..n-1:\n          if D[i][k] + D[k][j] < D[i][j]:\n            D[i][j] = D[i][k] + D[k][j]\n            next[i][j] = next[i][k]</p>\n\n    <p class=\"small\">Use the controls on the left to build a graph, run the algorithm step-by-step, watch the matrices and paths update.</p>\n\n    <h2 style=\"margin-top:8px;\">Tips</h2>\n    <ul class=\"small\">\n      <li>Start by creating a few nodes (Add Node) or generating a random graph.</li>\n      <li>To add an edge, click a node (it becomes selected), then click another node and enter a weight. For undirected graphs the edge will be added both ways.</li>\n      <li>To edit an edge, click the edge's line and enter a new weight (or leave blank to delete).</li>\n      <li>Select two nodes and press Show Path to highlight the current shortest path according to the displayed snapshot.</li>\n    </ul>\n  </div>\n\n  <script>\n(function(){\n  // Basic graph model\n  let nodes = []; // {id, x, y}\n  let edges = []; // {from,to,weight, id}\n  let directed = true;\n  let nodeIdCounter = 0;\n\n  // UI elements\n  const svg = document.getElementById('svg');\n  const addNodeBtn = document.getElementById('addNodeBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const nodeCountSpan = document.getElementById('nodeCount');\n  const directedCheckbox = document.getElementById('directed');\n  const runBtn = document.getElementById('runBtn');\n  const stepForwardBtn = document.getElementById('stepForwardBtn');\n  const stepBackBtn = document.getElementById('stepBackBtn');\n  const playBtn = document.getElementById('playBtn');\n  const pauseBtn = document.getElementById('pauseBtn');\n  const speedInput = document.getElementById('speed');\n  const snapIndexSpan = document.getElementById('snapIndex');\n  const snapTotalSpan = document.getElementById('snapTotal');\n  const distTableWrap = document.getElementById('distTableWrap');\n  const nextTableWrap = document.getElementById('nextTableWrap');\n  const fromSelect = document.getElementById('fromSelect');\n  const toSelect = document.getElementById('toSelect');\n  const showPathBtn = document.getElementById('showPathBtn');\n  const pathDisplay = document.getElementById('pathDisplay');\n  const snapshotInfo = document.getElementById('snapshotInfo');\n  const snapTotalLabel = snapTotalSpan;\n  const negCycleLabel = document.getElementById('negCycle');\n  const resetPositionsBtn = document.getElementById('resetPositions');\n\n  let selectedNode = null;\n  let hoverNode = null;\n  let dragNode = null;\n  let dragOffset = {x:0,y:0};\n\n  // Matrices and snapshots\n  let snapshots = []; // each snapshot: {D, next, k,i,j, updated: {i,j,old,new}, negCycle}\n  let currentSnapIndex = 0;\n  let playing = false;\n  let playTimer = null;\n\n  // SVG elements maps\n  const edgeGroup = document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\");\n  const nodeGroup = document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\");\n  svg.appendChild(edgeGroup);\n  svg.appendChild(nodeGroup);\n\n  // Arrow marker\n  const defs = document.createElementNS(\"http://www.w3.org/2000/svg\",\"defs\");\n  svg.appendChild(defs);\n  const marker = document.createElementNS(\"http://www.w3.org/2000/svg\",\"marker\");\n  marker.setAttribute(\"id\",\"arrow\");\n  marker.setAttribute(\"markerWidth\",\"10\");\n  marker.setAttribute(\"markerHeight\",\"10\");\n  marker.setAttribute(\"refX\",\"10\");\n  marker.setAttribute(\"refY\",\"5\");\n  marker.setAttribute(\"orient\",\"auto\");\n  marker.setAttribute(\"markerUnits\",\"strokeWidth\");\n  const arrowPath = document.createElementNS(\"http://www.w3.org/2000/svg\",\"path\");\n  arrowPath.setAttribute(\"d\",\"M0,0 L10,5 L0,10 z\");\n  arrowPath.setAttribute(\"class\",\"arrowhead\");\n  marker.appendChild(arrowPath);\n  defs.appendChild(marker);\n\n  function updateNodeCount(){ nodeCountSpan.textContent = nodes.length; }\n\n  // Add node centered at random position or specified\n  function addNode(x,y){\n    const rect = svg.getBoundingClientRect();\n    const px = (x==null) ? (50 + Math.random() * (rect.width-100)) : x;\n    const py = (y==null) ? (50 + Math.random() * (rect.height-100)) : y;\n    const node = { id: nodeIdCounter++, x: px, y: py };\n    nodes.push(node);\n    draw();\n    updateNodeCount();\n    updateSelects();\n  }\n\n  function clearGraph(){\n    nodes = [];\n    edges = [];\n    nodeIdCounter = 0;\n    snapshots = [];\n    currentSnapIndex = 0;\n    playing = false;\n    if (playTimer) { clearInterval(playTimer); playTimer = null; }\n    draw();\n    updateNodeCount();\n    updateSelects();\n    renderMatricesEmpty();\n    updateSnapshotInfo();\n  }\n\n  function randomGraph(n=5, density=0.4, minW=-3, maxW=10){\n    clearGraph();\n    for(let i=0;i<n;i++) addNode();\n    for(let i=0;i<n;i++){\n      for(let j=0;j<n;j++){\n        if (i===j) continue;\n        if (Math.random() < density){\n          const w = Math.floor(minW + Math.random()*(maxW-minW+1));\n          addEdge(nodes[i].id, nodes[j].id, w);\n        }\n      }\n    }\n    draw();\n  }\n\n  function addEdge(fromId, toId, weight){\n    // Remove existing if present\n    const existing = edges.find(e => e.from===fromId && e.to===toId);\n    if(existing){ existing.weight = weight; draw(); return existing; }\n    const e = { id: 'e' + Math.random().toString(36).slice(2,9), from: fromId, to: toId, weight: Number(weight) };\n    edges.push(e);\n    if(!directed && fromId !== toId){\n      // also add reverse\n      const existing2 = edges.find(x => x.from===toId && x.to===fromId);\n      if(!existing2) edges.push({ id: 'e' + Math.random().toString(36).slice(2,9), from: toId, to: fromId, weight: Number(weight) });\n    }\n    draw();\n    return e;\n  }\n\n  function removeEdge(edgeId){\n    edges = edges.filter(e => e.id !== edgeId);\n    draw();\n  }\n\n  function findNodeById(id){ return nodes.find(n => n.id === id); }\n  function findEdgeById(id){ return edges.find(e => e.id === id); }\n\n  // Drawing functions\n  function draw(){\n    // Clear\n    while(edgeGroup.firstChild) edgeGroup.removeChild(edgeGroup.firstChild);\n    while(nodeGroup.firstChild) nodeGroup.removeChild(nodeGroup.firstChild);\n\n    // Draw edges\n    edges.forEach(e => {\n      const n1 = findNodeById(e.from);\n      const n2 = findNodeById(e.to);\n      if(!n1 || !n2) return;\n      const line = document.createElementNS(\"http://www.w3.org/2000/svg\",\"path\");\n      line.setAttribute(\"class\",\"edge\");\n      line.setAttribute(\"data-edgeid\", e.id);\n      const dx = n2.x - n1.x, dy = n2.y - n1.y;\n      const dist = Math.sqrt(dx*dx + dy*dy);\n      // offset so lines don't touch circles\n      const r = 18;\n      const ux = dx / dist, uy = dy / dist;\n      const startX = n1.x + ux * r;\n      const startY = n1.y + uy * r;\n      const endX = n2.x - ux * r;\n      const endY = n2.y - uy * r;\n\n      const midX = (startX + endX)/2 + (-uy)*10; // slight offset for visibility\n      const midY = (startY + endY)/2 + (ux)*10;\n      const d = `M ${startX} ${startY} Q ${midX} ${midY} ${endX} ${endY}`;\n      line.setAttribute(\"d\", d);\n      if (directed) line.setAttribute(\"marker-end\", \"url(#arrow)\");\n      edgeGroup.appendChild(line);\n\n      // label\n      const label = document.createElementNS(\"http://www.w3.org/2000/svg\",\"text\");\n      label.setAttribute(\"class\",\"edgeLabel\");\n      // place approx at mid of path\n      label.setAttribute(\"x\", (startX + endX)/2 + (-uy)*8);\n      label.setAttribute(\"y\", (startY + endY)/2 + (ux)*8 + 4);\n      label.setAttribute(\"text-anchor\",\"middle\");\n      label.textContent = String(e.weight);\n      edgeGroup.appendChild(label);\n\n      // click to edit\n      line.addEventListener('click', (ev) => {\n        ev.stopPropagation();\n        const val = prompt(\"Enter weight (empty to delete):\", String(e.weight));\n        if(val === null) return;\n        if(val.trim() === \"\") { removeEdge(e.id); computeAndSnapshotIfNeeded(); return; }\n        const num = Number(val);\n        if(Number.isFinite(num)){\n          e.weight = num;\n          draw();\n          computeAndSnapshotIfNeeded();\n        } else alert(\"Invalid number\");\n      });\n\n    });\n\n    // Draw nodes\n    nodes.forEach(n => {\n      const g = document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\");\n      g.setAttribute(\"class\",\"node\");\n      g.setAttribute(\"data-nodeid\", n.id);\n      g.setAttribute(\"transform\", `translate(${n.x},${n.y})`);\n      const circle = document.createElementNS(\"http://www.w3.org/2000/svg\",\"circle\");\n      circle.setAttribute(\"r\", 18);\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\",\"text\");\n      text.setAttribute(\"y\", 5);\n      text.setAttribute(\"text-anchor\",\"middle\");\n      text.textContent = String(n.id);\n      g.appendChild(circle); g.appendChild(text);\n      nodeGroup.appendChild(g);\n\n      // Events\n      g.addEventListener('mousedown', (ev) => {\n        ev.stopPropagation();\n        dragNode = n;\n        const rect = svg.getBoundingClientRect();\n        dragOffset.x = ev.clientX - rect.left - n.x;\n        dragOffset.y = ev.clientY - rect.top - n.y;\n      });\n      g.addEventListener('click', (ev) => {\n        ev.stopPropagation();\n        if(selectedNode == null){\n          selectedNode = n;\n          updateSelectionVisual();\n        } else if(selectedNode.id === n.id){\n          selectedNode = null;\n          updateSelectionVisual();\n        } else {\n          // create edge from selectedNode to n\n          const w = prompt(`Weight from ${selectedNode.id} → ${n.id}:`, \"1\");\n          if(w!==null && w.trim()!==\"\"){\n            const num = Number(w);\n            if(Number.isFinite(num)){\n              addEdge(selectedNode.id, n.id, num);\n              computeAndSnapshotIfNeeded();\n            } else alert(\"Invalid number\");\n          }\n          selectedNode = null;\n          updateSelectionVisual();\n        }\n      });\n      g.addEventListener('mouseenter', ()=>{ hoverNode = n; updateHoverVisual(); });\n      g.addEventListener('mouseleave', ()=>{ hoverNode = null; updateHoverVisual(); });\n    });\n\n    updateSelectionVisual();\n    updateHoverVisual();\n  }\n\n  // Visual updates\n  function updateSelectionVisual(){\n    Array.from(nodeGroup.children).forEach(g => {\n      const id = Number(g.getAttribute('data-nodeid'));\n      g.classList.toggle('selected', selectedNode && selectedNode.id === id);\n    });\n  }\n  function updateHoverVisual(){\n    Array.from(nodeGroup.children).forEach(g => {\n      const id = Number(g.getAttribute('data-nodeid'));\n      g.classList.toggle('hover', hoverNode && hoverNode.id === id);\n    });\n  }\n\n  // Dragging\n  window.addEventListener('mousemove', (ev) => {\n    if(!dragNode) return;\n    const rect = svg.getBoundingClientRect();\n    dragNode.x = Math.max(20, Math.min(rect.width-20, ev.clientX - rect.left - dragOffset.x));\n    dragNode.y = Math.max(20, Math.min(rect.height-20, ev.clientY - rect.top - dragOffset.y));\n    draw();\n  });\n  window.addEventListener('mouseup', ()=> { dragNode = null; });\n\n  // Canvas click to add node when Add Node selected\n  addNodeBtn.addEventListener('click', ()=>{\n    svg.style.cursor = 'crosshair';\n    const onClick = (ev) => {\n      const rect = svg.getBoundingClientRect();\n      addNode(ev.clientX - rect.left, ev.clientY - rect.top);\n      svg.style.cursor = '';\n      svg.removeEventListener('click', onClick);\n    };\n    svg.addEventListener('click', onClick);\n  });\n\n  clearBtn.addEventListener('click', clearGraph);\n  randomBtn.addEventListener('click', ()=> randomGraph(6, 0.5));\n\n  directedCheckbox.addEventListener('change', ()=>{\n    directed = directedCheckbox.checked;\n    draw();\n  });\n\n  resetPositionsBtn.addEventListener('click', ()=>{\n    // reposition in grid\n    const w = svg.getBoundingClientRect().width, h = svg.getBoundingClientRect().height;\n    const cols = Math.ceil(Math.sqrt(nodes.length));\n    nodes.forEach((n,i) => {\n      const cx = (i % cols) / (cols) * (w-100) + 50;\n      const cy = Math.floor(i/cols) / (cols) * (h-100) + 50;\n      n.x = cx; n.y = cy;\n    });\n    draw();\n  });\n\n  // Matrices helpers\n  function initMatrices(){\n    const idxMap = nodes.map(n=>n.id);\n    const n = nodes.length;\n    const D = Array.from({length:n}, ()=>Array(n).fill(Infinity));\n    const next = Array.from({length:n}, ()=>Array(n).fill(null));\n    for(let i=0;i<n;i++){ D[i][i]=0; next[i][i]=nodes[i].id; }\n    // add edges\n    edges.forEach(e=>{\n      const i = indexOfNodeId(e.from);\n      const j = indexOfNodeId(e.to);\n      if(i>=0 && j>=0){\n        D[i][j] = Number(e.weight);\n        next[i][j] = nodes[i].id === nodes[j].id ? nodes[i].id : nodes[j].id;\n      }\n    });\n    return {D, next};\n  }\n\n  function indexOfNodeId(id){\n    return nodes.findIndex(n => n.id === id);\n  }\n\n  function deepCopyMatrix(mat){\n    return mat.map(row => row.map(v => (v===Infinity?Infinity:(v===null?null: (typeof v==='number'?v:v)))));\n  }\n\n  // Compute snapshots of Floyd-Warshall\n  function computeSnapshots(){\n    snapshots = [];\n    if(nodes.length===0){ updateSnapshotInfo(); return; }\n    const n = nodes.length;\n    const {D: D0, next: next0} = initMatrices();\n    // snapshot initial\n    snapshots.push({\n      D: deepCopyMatrix(D0),\n      next: deepCopyMatrix(next0),\n      k: null, i:null, j:null, updated: null, negCycle: false,\n      info: 'initial'\n    });\n    // algorithm\n    const D = deepCopyMatrix(D0);\n    const next = deepCopyMatrix(next0);\n    let negativeDetectedAt = null;\n    for(let k=0;k<n;k++){\n      for(let i=0;i<n;i++){\n        for(let j=0;j<n;j++){\n          const Dik = D[i][k], Dkj = D[k][j], Dij = D[i][j];\n          const sum = (Dik===Infinity || Dkj===Infinity) ? Infinity : Dik + Dkj;\n          let updated = null;\n          if(sum < Dij){\n            updated = {i, j, old: Dij, ne: sum, via: k};\n            D[i][j] = sum;\n            // next[i][j] = next[i][k]\n            next[i][j] = next[i][k];\n          }\n          const neg = D.some((row,ii) => row[ii] < 0);\n          snapshots.push({\n            D: deepCopyMatrix(D),\n            next: deepCopyMatrix(next),\n            k, i, j, updated, negCycle: neg,\n            info: updated ? `Updated D[${i}][${j}] via ${k}` : (sum===Infinity ? `Checked D[${i}][${j}] via ${k}` : `No change for D[${i}][${j}] via ${k}`)\n          });\n          if(neg && negativeDetectedAt==null) negativeDetectedAt = snapshots.length-1;\n        }\n      }\n    }\n    if(negativeDetectedAt!=null){\n      snapshots[negativeDetectedAt].info += ' — negative cycle detected';\n    }\n    currentSnapIndex = 0;\n    updateSnapshotInfo();\n  }\n\n  function computeAndSnapshotIfNeeded(){\n    // If snapshots exist, we should recompute\n    if(nodes.length>0) computeSnapshots();\n    renderSnapshot(0);\n  }\n\n  // Rendering matrices\n  function renderMatricesEmpty(){\n    distTableWrap.innerHTML = '';\n    nextTableWrap.innerHTML = '';\n    snapIndexSpan.textContent = '0';\n    snapTotalSpan.textContent = '0';\n    pathDisplay.textContent = '';\n  }\n\n  function renderSnapshot(index){\n    if(snapshots.length===0){ renderMatricesEmpty(); return; }\n    currentSnapIndex = Math.max(0, Math.min(index, snapshots.length-1));\n    const snap = snapshots[currentSnapIndex];\n    const D = snap.D;\n    const next = snap.next;\n    const n = nodes.length;\n    // build tables\n    const createTable = (matrix, isNext) => {\n      const table = document.createElement('table');\n      const thead = document.createElement('thead');\n      const headerRow = document.createElement('tr');\n      headerRow.appendChild(document.createElement('th'));\n      for(let j=0;j<n;j++){\n        const th = document.createElement('th'); th.textContent = String(nodes[j].id); headerRow.appendChild(th);\n      }\n      thead.appendChild(headerRow);\n      table.appendChild(thead);\n      const tbody = document.createElement('tbody');\n      for(let i=0;i<n;i++){\n        const tr = document.createElement('tr');\n        const th = document.createElement('th'); th.textContent = String(nodes[i].id); tr.appendChild(th);\n        for(let j=0;j<n;j++){\n          const td = document.createElement('td');\n          const val = matrix[i][j];\n          if(val===Infinity) { td.textContent = '∞'; td.classList.add('inf'); }\n          else if(val===null) { td.textContent = '-'; td.classList.add('inf'); }\n          else td.textContent = String(val);\n          // highlight current k,i,j\n          if(snap.k !== null && snap.k !== undefined){\n            if(i === snap.i && j === snap.j) td.classList.add('cell-highlight');\n            if(snap.updated && snap.updated.i === i && snap.updated.j === j) td.classList.add('cell-updated');\n          }\n          tr.appendChild(td);\n        }\n        tbody.appendChild(tr);\n      }\n      table.appendChild(tbody);\n      return table;\n    };\n\n    distTableWrap.innerHTML = '';\n    nextTableWrap.innerHTML = '';\n    distTableWrap.appendChild(createTable(D, false));\n    nextTableWrap.appendChild(createTable(next, true));\n\n    snapIndexSpan.textContent = String(currentSnapIndex);\n    snapTotalSpan.textContent = String(snapshots.length-1);\n    snapshotInfo.textContent = snap.info || '';\n    negCycleLabel.textContent = snap.negCycle ? \"Negative cycle detected (diagonal < 0).\" : \"\";\n\n    // highlight edges along the selected pair path if shown\n    draw(); // redraw to clear previous highlights\n    // mark updated edge if any\n    if(snap.updated){\n      const ui = snap.updated.i, uj = snap.updated.j;\n      const fromId = nodes[ui].id, toId = nodes[uj].id;\n      highlightEdgeBetween(fromId, toId, 'updatedEdge');\n    }\n\n    // highlight currently considered k,i,j nodes\n    if(snap.k !== null && snap.k !== undefined){\n      const ids = [snap.k, snap.i, snap.j].map(x => nodes[x] ? nodes[x].id : null);\n      highlightNodesById(ids);\n    }\n  }\n\n  function highlightEdgeBetween(fromId, toId, cls){\n    Array.from(edgeGroup.children).forEach(el=>{\n      if(el.getAttribute('data-edgeid')){\n        const edge = findEdgeById(el.getAttribute('data-edgeid'));\n        if(edge && edge.from===fromId && edge.to===toId){\n          el.classList.add(cls);\n        }\n      }\n    });\n  }\n\n  function highlightNodesById(ids){\n    Array.from(nodeGroup.children).forEach(g=>{\n      const id = Number(g.getAttribute('data-nodeid'));\n      g.classList.toggle('cell-highlight', ids.includes(id));\n    });\n  }\n\n  // Snapshot navigation\n  stepForwardBtn.addEventListener('click', ()=>{\n    if(snapshots.length === 0) return;\n    if(currentSnapIndex < snapshots.length-1){\n      currentSnapIndex++;\n      renderSnapshot(currentSnapIndex);\n    }\n  });\n  stepBackBtn.addEventListener('click', ()=>{\n    if(snapshots.length === 0) return;\n    if(currentSnapIndex > 0){\n      currentSnapIndex--;\n      renderSnapshot(currentSnapIndex);\n    }\n  });\n\n  playBtn.addEventListener('click', ()=>{\n    if(snapshots.length === 0) return;\n    playing = true;\n    playBtn.disabled = true; pauseBtn.disabled = false;\n    const speed = Number(speedInput.value);\n    playTimer = setInterval(()=>{\n      if(currentSnapIndex < snapshots.length-1){\n        currentSnapIndex++;\n        renderSnapshot(currentSnapIndex);\n      } else {\n        clearInterval(playTimer); playTimer = null; playing = false; playBtn.disabled = false; pauseBtn.disabled = true;\n      }\n    }, speed);\n  });\n  pauseBtn.addEventListener('click', ()=>{\n    if(playTimer) clearInterval(playTimer);\n    playTimer = null; playing = false; playBtn.disabled = false; pauseBtn.disabled = true;\n  });\n\n  runBtn.addEventListener('click', ()=>{\n    computeSnapshots();\n    renderSnapshot(0);\n  });\n\n  // update selects\n  function updateSelects(){\n    fromSelect.innerHTML = '';\n    toSelect.innerHTML = '';\n    nodes.forEach(n => {\n      const o1 = document.createElement('option'); o1.value = String(n.id); o1.textContent = String(n.id);\n      const o2 = o1.cloneNode(true);\n      fromSelect.appendChild(o1);\n      toSelect.appendChild(o2);\n    });\n  }\n\n  showPathBtn.addEventListener('click', ()=>{\n    if(nodes.length===0) return;\n    const fromId = Number(fromSelect.value);\n    const toId = Number(toSelect.value);\n    const snap = snapshots[currentSnapIndex];\n    if(!snap){ pathDisplay.textContent = 'No snapshot available'; return; }\n    const idxFrom = indexOfNodeId(fromId);\n    const idxTo = indexOfNodeId(toId);\n    if(idxFrom < 0 || idxTo < 0) { pathDisplay.textContent = 'Invalid nodes'; return; }\n    const path = reconstructPathFromSnapshot(idxFrom, idxTo, snap.next);\n    if(!path){ pathDisplay.textContent = 'No path (∞)'; } else {\n      pathDisplay.textContent = 'Path: ' + path.map(i=>nodes[i].id).join(' → ') + ' (cost: ' + (snap.D[idxFrom][idxTo]===Infinity ? '∞' : snap.D[idxFrom][idxTo]) + ')';\n      // highlight edges along path\n      draw();\n      for(let p=0;p<path.length-1;p++){\n        const a = nodes[path[p]].id, b = nodes[path[p+1]].id;\n        highlightEdgeBetween(a,b,'highlightEdge');\n      }\n    }\n  });\n\n  function reconstructPathFromSnapshot(i,j,next){\n    if(next[i][j] === null) return null;\n    const path = [i];\n    while(i !== j){\n      const nid = next[i][j];\n      if(nid === null) return null;\n      const ni = indexOfNodeId(nid);\n      if(ni === -1) return null;\n      if(path.includes(ni)){ // cycle detected -> break\n        path.push(ni); break;\n      }\n      path.push(ni);\n      i = ni;\n      if(path.length > nodes.length + 5) break;\n    }\n    return path;\n  }\n\n  // When nodes/edges change, recompute if snapshots already existed\n  function computeAndSnapshotIfNeeded(){\n    if(snapshots.length > 0) {\n      computeSnapshots();\n      renderSnapshot(0);\n    } else {\n      draw();\n      renderMatricesEmpty();\n    }\n  }\n\n  // Initialize\n  clearGraph();\n  randomGraph(5, 0.45);\n\n  // Clicking on blank SVG deselects\n  svg.addEventListener('click', (ev) => {\n    selectedNode = null;\n    updateSelectionVisual();\n  });\n\n  // Edge clicks to edit are handled in draw()\n\n  // Prevent text selection on double-click drag\n  document.addEventListener('dragstart', (e)=> e.preventDefault());\n\n  // Initial render\n  computeSnapshots();\n  renderSnapshot(0);\n\n  // Expose for console debugging (optional)\n  window._fw = { nodes, edges, snapshots, computeSnapshots, renderSnapshot, addNode, addEdge };\n\n})();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Floyd-Warshall Algorithm"
    }
  ],
  "topic": "Floyd-Warshall Algorithm",
  "hasFSM": false,
  "hasTest": true
}