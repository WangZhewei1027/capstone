{
  "id": "d80c45c0-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:56.829Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Recursion",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Recursion Explorer — Interactive Demos</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724; --card:#0b1220; --muted:#9aa4b2; --accent:#7dd3fc;\n      --panel:#071023; --glass: rgba(255,255,255,0.03);\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;}\n    body{\n      background: linear-gradient(180deg,#071023 0%, #071022 50%, #041024 100%);\n      color:#e6eef6; padding:18px; box-sizing:border-box;\n    }\n    header{display:flex;gap:18px;align-items:center;margin-bottom:18px;}\n    h1{font-size:20px;margin:0;}\n    p.lead{margin:0;color:var(--muted);font-size:13px;}\n    .container{display:grid;grid-template-columns:360px 1fr 420px;gap:18px;align-items:start;}\n    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:10px;padding:14px;box-shadow: 0 6px 18px rgba(2,6,23,0.6);}\n    .controls .row{display:flex;gap:8px;align-items:center;margin-bottom:8px;}\n    label{font-size:13px;color:var(--muted);min-width:80px;}\n    select,input[type=number]{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:6px;color:inherit;}\n    button{background:linear-gradient(180deg,#1f6feb,#0d5acc);border:none;color:white;padding:8px 12px;border-radius:8px;cursor:pointer;}\n    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);}\n    .small{font-size:13px;padding:6px 8px;border-radius:6px;}\n    .stack{max-height:420px;overflow:auto;padding:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:8px;border:1px solid rgba(255,255,255,0.02);}\n    ul.stack-list{list-style:none;padding:6px;margin:0;}\n    ul.stack-list li{padding:8px;border-radius:8px;margin-bottom:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);display:flex;justify-content:space-between;align-items:center;border:1px solid rgba(255,255,255,0.02);}\n    ul.stack-list li .meta{color:var(--muted);font-size:12px}\n    pre.code{background:#041526;color:#cdebf8;padding:10px;border-radius:8px;overflow:auto;font-size:13px;margin:0;border:1px solid rgba(125,211,252,0.06);}\n    .visual{height:520px;display:flex;flex-direction:column;gap:12px;}\n    #canvasWrap{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:10px;padding:10px;display:flex;align-items:stretch;justify-content:stretch;overflow:auto;}\n    canvas{width:100%;height:100%;border-radius:8px;background:linear-gradient(180deg, rgba(7,16,35,0.8), rgba(2,6,23,0.9));display:block;}\n    .footer{font-size:12px;color:var(--muted);margin-top:8px;}\n    .status-row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;}\n    .badge{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;font-size:13px;border:1px solid rgba(255,255,255,0.02);}\n    .tree{overflow:auto;padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border:1px solid rgba(255,255,255,0.02);max-height:520px;}\n    .node{display:inline-block;padding:6px 8px;margin:6px;border-radius:8px;background:#062234;border:1px solid rgba(125,211,252,0.06);font-size:13px}\n    .tree ul{list-style:none;padding-left:18px;margin:6px 0;}\n    .controls .hint{color:var(--muted);font-size:12px}\n    .top-row{display:flex;gap:8px;align-items:center;margin-bottom:12px;}\n    .speed{width:160px;}\n    .footer small{color:var(--muted)}\n    .code-title{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}\n  </style>\n</head>\n<body>\n  <header>\n    <div>\n      <h1>Recursion Explorer</h1>\n      <p class=\"lead\">Interactive demonstrations of recursion: call stack visualization, Fibonacci recursion tree (with memoization option), and a recursive fractal tree.</p>\n    </div>\n  </header>\n\n  <div class=\"container\">\n    <!-- Left: Controls and Stack -->\n    <div class=\"panel controls\">\n      <div class=\"top-row\">\n        <label for=\"demoSelect\">Demo</label>\n        <select id=\"demoSelect\">\n          <option value=\"factorial\">Factorial (call stack)</option>\n          <option value=\"fibonacci\">Fibonacci (recursion tree)</option>\n          <option value=\"fractal\">Fractal Tree (canvas)</option>\n        </select>\n      </div>\n\n      <div class=\"row\">\n        <label id=\"paramLabel\">n</label>\n        <input id=\"inputN\" type=\"number\" value=\"6\" min=\"0\" max=\"12\" />\n        <div style=\"flex:1\"></div>\n      </div>\n\n      <div class=\"row\" id=\"memoRow\" style=\"display:none;\">\n        <label>Memoize</label>\n        <input id=\"memoCheckbox\" type=\"checkbox\" />\n        <span class=\"hint\" style=\"margin-left:8px;color:var(--muted)\">Turn on for Fibonacci to avoid repeated calls</span>\n      </div>\n\n      <div class=\"row\">\n        <label>Mode</label>\n        <select id=\"modeSelect\">\n          <option value=\"auto\">Auto (animate)</option>\n          <option value=\"step\">Step-by-step</option>\n        </select>\n        <label style=\"margin-left:8px\">Speed</label>\n        <input id=\"speedRange\" class=\"speed\" type=\"range\" min=\"50\" max=\"1200\" value=\"250\" />\n      </div>\n\n      <div class=\"row\" style=\"margin-top:6px;\">\n        <button id=\"runBtn\">Run</button>\n        <button id=\"stepBtn\" class=\"small ghost\">Step</button>\n        <button id=\"resetBtn\" class=\"small ghost\">Reset</button>\n        <div style=\"flex:1\"></div>\n      </div>\n\n      <div class=\"row\" style=\"margin-top:6px;\">\n        <label>Events</label>\n        <div class=\"status-row\">\n          <div class=\"badge\" id=\"callCount\">Calls: 0</div>\n          <div class=\"badge\" id=\"maxDepth\">Max depth: 0</div>\n          <div class=\"badge\" id=\"resultBadge\">Result: —</div>\n        </div>\n      </div>\n\n      <hr style=\"border:none;height:1px;background:rgba(255,255,255,0.02);margin:12px 0\">\n\n      <div>\n        <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px\">\n          <strong>Call Stack</strong>\n          <span class=\"hint\">push = function call started, pop = returned</span>\n        </div>\n        <div class=\"stack\">\n          <ul id=\"stackList\" class=\"stack-list\"></ul>\n        </div>\n      </div>\n\n      <div class=\"footer\" style=\"margin-top:12px\">\n        <small>Tip: Try small n for Fibonacci (<=7) to see the full tree. Use memoization to compare performance.</small>\n      </div>\n    </div>\n\n    <!-- Middle: Visual / Code -->\n    <div class=\"panel visual\" id=\"visualPanel\">\n      <div class=\"code-title\">\n        <strong id=\"demoTitle\">Factorial (call stack)</strong>\n        <span class=\"hint\" id=\"demoHint\">Shows how recursive calls are pushed and popped on the call stack.</span>\n      </div>\n\n      <div style=\"display:flex;gap:12px;\">\n        <div style=\"flex:1\">\n          <pre class=\"code\" id=\"codeBlock\">\n// Recursive factorial (instrumented for visualization)\nasync function factorial(n) {\n  pushFrame('factorial', {n});\n  if (n <= 1) {\n    popFrame(1);\n    return 1;\n  }\n  const sub = await factorial(n - 1); // recursive call\n  const res = n * sub;\n  popFrame(res);\n  return res;\n}\n          </pre>\n        </div>\n        <div style=\"width:220px;\">\n          <div style=\"margin-bottom:8px\"><strong>Live stack preview</strong></div>\n          <div id=\"miniStack\" class=\"stack\" style=\"max-height:200px\">\n            <ul id=\"miniList\" class=\"stack-list\"></ul>\n          </div>\n        </div>\n      </div>\n\n      <div id=\"canvasWrap\" style=\"margin-top:12px;\">\n        <!-- Canvas or tree area will be inserted here by JS -->\n        <canvas id=\"mainCanvas\"></canvas>\n        <div id=\"treeArea\" class=\"tree\" style=\"display:none;\"></div>\n      </div>\n\n    </div>\n\n    <!-- Right: Explanation & Fibonacci / Fractal controls -->\n    <div class=\"panel\" id=\"rightPanel\">\n      <div id=\"explain\">\n        <h3 style=\"margin-top:0\">What's happening?</h3>\n        <p class=\"lead\" style=\"font-size:13px;color:var(--muted)\">\n          Recursion is when a function calls itself to solve smaller instances of the same problem.\n          Each active call becomes a \"frame\" on the call stack. When a call finishes, it returns and its frame is popped.\n        </p>\n\n        <h4>Demo notes</h4>\n        <ul style=\"color:var(--muted);font-size:13px\">\n          <li><strong>Factorial:</strong> linear recursion with depth equal to n.</li>\n          <li><strong>Fibonacci:</strong> naive recursion creates a tree of calls — many repeated subcalls.</li>\n          <li><strong>Memoization:</strong> caches results to avoid repeated work.</li>\n          <li><strong>Fractal tree:</strong> recursion used for drawing branching structures — each branch spawns two smaller branches.</li>\n        </ul>\n\n        <h4 style=\"margin-top:12px\">Try these</h4>\n        <ul style=\"color:var(--muted);font-size:13px\">\n          <li>Switch to step mode and step through factorial to watch the stack grow and shrink.</li>\n          <li>Observe call count changes for Fibonacci with/without memoization.</li>\n          <li>Draw a fractal tree and increase depth to see recursion depth effect.</li>\n        </ul>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // ---- Utilities & Scheduler ----\n    const qs = sel => document.querySelector(sel);\n    const el = id => document.getElementById(id);\n\n    const state = {\n      calls:0, maxDepth:0, stack:[], framesById:{}, running:false,\n      config:{mode:'auto', speed:250, memo:false}\n    };\n\n    class Scheduler {\n      constructor(){\n        this._resolveNext = null;\n        this.auto = true;\n        this.delay = 250;\n      }\n      setMode(mode){\n        this.auto = (mode === 'auto');\n      }\n      setDelay(ms){ this.delay = ms; }\n      nextStep(){\n        if(this._resolveNext) { this._resolveNext(); this._resolveNext = null; }\n      }\n      async wait(){\n        if(this.auto) {\n          await new Promise(r => setTimeout(r, this.delay));\n          return;\n        }\n        await new Promise(r => this._resolveNext = r);\n      }\n    }\n    const scheduler = new Scheduler();\n\n    // ---- DOM helpers for stack visualization ----\n    const stackList = el('stackList');\n    const miniList = el('miniList');\n    const callCountBadge = el('callCount');\n    const maxDepthBadge = el('maxDepth');\n    const resultBadge = el('resultBadge');\n    const demoTitle = el('demoTitle');\n    const demoHint = el('demoHint');\n    const codeBlock = el('codeBlock');\n    const treeArea = el('treeArea');\n    const canvas = el('mainCanvas');\n\n    function pushFrameToDOM(frame){\n      const li = document.createElement('li');\n      li.id = frame.id;\n      li.innerHTML = `<div><strong>${frame.fn}</strong>(${formatArgs(frame.args)})<div class=\"meta\">status: running</div></div><div class=\"meta\">depth ${frame.depth}</div>`;\n      stackList.prepend(li);\n\n      const mini = li.cloneNode(true);\n      mini.id = frame.id + '_mini';\n      miniList.prepend(mini);\n    }\n    function popFrameInDOM(frame){\n      const li = document.getElementById(frame.id);\n      if(li){\n        const meta = li.querySelector('.meta');\n        if(meta) meta.textContent = 'returned: ' + JSON.stringify(frame.ret);\n        li.style.opacity = '0.65';\n      }\n      const mini = document.getElementById(frame.id + '_mini');\n      if(mini){\n        const m = mini.querySelector('.meta');\n        if(m) m.textContent = 'returned: ' + JSON.stringify(frame.ret);\n        mini.style.opacity = '0.65';\n      }\n      // remove after a short delay so user can observe\n      setTimeout(()=>{\n        if(li && li.parentNode) li.parentNode.removeChild(li);\n        if(mini && mini.parentNode) mini.parentNode.removeChild(mini);\n      }, 600);\n    }\n    function formatArgs(obj){\n      if(obj && 'n' in obj) return obj.n;\n      return JSON.stringify(obj);\n    }\n\n    // ---- Instrumentation primitives ----\n    let frameCounter = 0;\n    function pushFrame(fn, args){\n      const id = 'f' + (++frameCounter);\n      const depth = state.stack.length + 1;\n      const frame = {id, fn, args, ret:undefined, depth};\n      state.stack.push(frame);\n      state.calls++;\n      state.maxDepth = Math.max(state.maxDepth, depth);\n      state.framesById[id] = frame;\n      pushFrameToDOM(frame);\n      updateBadges();\n      return frame;\n    }\n\n    function popFrame(ret){\n      const frame = state.stack.pop();\n      if(!frame) return;\n      frame.ret = ret;\n      popFrameInDOM(frame);\n      updateBadges();\n      return frame;\n    }\n\n    function updateBadges(){\n      callCountBadge.textContent = 'Calls: ' + state.calls;\n      maxDepthBadge.textContent = 'Max depth: ' + state.maxDepth;\n      if(state.lastResult !== undefined) resultBadge.textContent = 'Result: ' + state.lastResult;\n    }\n\n    function resetState(){\n      state.calls = 0; state.maxDepth = 0; state.stack = []; state.framesById = {}; state.lastResult = undefined;\n      frameCounter = 0; state.running = false;\n      stackList.innerHTML = ''; miniList.innerHTML = '';\n      callCountBadge.textContent = 'Calls: 0'; maxDepthBadge.textContent = 'Max depth: 0'; resultBadge.textContent = 'Result: —';\n    }\n\n    // ---- Recursive Demos (async to allow stepping) ----\n    async function factorialDemo(n){\n      // instrumented factorial\n      async function factorial(n){\n        const frame = pushFrame('factorial', {n});\n        await scheduler.wait();\n        if(n <= 1){\n          popFrame(1);\n          await scheduler.wait();\n          return 1;\n        }\n        const sub = await factorial(n - 1);\n        const res = n * sub;\n        popFrame(res);\n        await scheduler.wait();\n        return res;\n      }\n      const res = await factorial(n);\n      state.lastResult = res;\n      updateBadges();\n      return res;\n    }\n\n    // Fibonacci with optional memoization + visual tree (DOM)\n    async function fibonacciDemo(n, memoize){\n      // for the tree visualization we'll build a nested DOM structure,\n      // and also instrument calls for stack.\n      treeArea.innerHTML = '';\n      treeArea.style.display = 'block';\n      canvas.style.display = 'none';\n\n      const memo = new Map();\n      let nodeId = 0;\n\n      async function fibNode(n, parentEl){\n        const nodeEl = document.createElement('div');\n        nodeEl.className = 'node';\n        const nid = 'node' + (++nodeId);\n        nodeEl.id = nid;\n        nodeEl.textContent = `fib(${n}) …`;\n        const wrapper = document.createElement('div');\n        wrapper.appendChild(nodeEl);\n        const childrenUl = document.createElement('ul');\n        wrapper.appendChild(childrenUl);\n        if(parentEl) parentEl.appendChild(wrapper);\n        // push frame\n        const frame = pushFrame('fib', {n});\n        await scheduler.wait();\n\n        if(memoize && memo.has(n)){\n          const val = memo.get(n);\n          nodeEl.textContent = `fib(${n}) = ${val} (cached)`;\n          popFrame(val);\n          await scheduler.wait();\n          return val;\n        }\n\n        if(n <= 1){\n          nodeEl.textContent = `fib(${n}) = ${n}`;\n          popFrame(n);\n          await scheduler.wait();\n          if(memoize) memo.set(n, n);\n          return n;\n        }\n\n        // recursive left\n        const leftLi = document.createElement('li');\n        childrenUl.appendChild(leftLi);\n        const a = await fibNode(n-1, leftLi);\n\n        // recursive right\n        const rightLi = document.createElement('li');\n        childrenUl.appendChild(rightLi);\n        const b = await fibNode(n-2, rightLi);\n\n        const res = a + b;\n        nodeEl.textContent = `fib(${n}) = ${res}`;\n        if(memoize) memo.set(n, res);\n        popFrame(res);\n        await scheduler.wait();\n        return res;\n      }\n\n      const rootUl = document.createElement('ul');\n      treeArea.appendChild(rootUl);\n      const rootLi = document.createElement('li');\n      rootUl.appendChild(rootLi);\n\n      const result = await fibNode(n, rootLi);\n      state.lastResult = result;\n      updateBadges();\n      return result;\n    }\n\n    // Fractal tree drawing (non-instrumented recursion, uses canvas)\n    function drawFractalTree(depth){\n      treeArea.style.display = 'none';\n      canvas.style.display = 'block';\n      const c = canvas;\n      // ensure correct pixel size\n      const rect = c.getBoundingClientRect();\n      c.width = Math.floor(rect.width * devicePixelRatio);\n      c.height = Math.floor(rect.height * devicePixelRatio);\n      const ctx = c.getContext('2d');\n      ctx.scale(devicePixelRatio, devicePixelRatio);\n      ctx.clearRect(0,0,rect.width,rect.height);\n      ctx.strokeStyle = '#7dd3fc';\n      ctx.lineWidth = 1.5;\n      const startX = rect.width / 2;\n      const startY = rect.height - 20;\n\n      function branch(x,y,len,angle,depthLeft){\n        ctx.save();\n        ctx.translate(x,y);\n        ctx.rotate(angle);\n        // draw line up\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.lineTo(0,-len);\n        ctx.stroke();\n        ctx.translate(0,-len);\n\n        if(depthLeft <= 0){\n          // tip\n          ctx.restore();\n          return;\n        }\n        const newLen = len * (0.66 - depthLeft*0.004);\n        const spread = 0.5; // radians\n        branch(0,0,newLen, -spread, depthLeft - 1);\n        branch(0,0,newLen, spread, depthLeft - 1);\n        ctx.restore();\n      }\n\n      branch(startX, startY, Math.max(40, rect.height/6), 0, depth);\n    }\n\n    // ---- UI wiring ----\n    const demoSelect = el('demoSelect');\n    const inputN = el('inputN');\n    const runBtn = el('runBtn');\n    const stepBtn = el('stepBtn');\n    const resetBtn = el('resetBtn');\n    const modeSelect = el('modeSelect');\n    const speedRange = el('speedRange');\n    const memoCheckbox = el('memoCheckbox');\n    const memoRow = el('memoRow');\n\n    function updateUIForDemo(){\n      const demo = demoSelect.value;\n      resetState();\n      treeArea.style.display = 'none';\n      canvas.style.display = 'block';\n      canvas.getContext('2d').clearRect(0,0,canvas.width,canvas.height);\n\n      if(demo === 'factorial'){\n        demoTitle.textContent = 'Factorial (call stack)';\n        demoHint.textContent = 'Shows how recursive calls are pushed to the stack and popped when returning.';\n        codeBlock.textContent = `// Recursive factorial (instrumented)\nasync function factorial(n){\n  pushFrame('factorial',{n});\n  await scheduler.wait();\n  if(n <= 1){\n    popFrame(1);\n    await scheduler.wait();\n    return 1;\n  }\n  const sub = await factorial(n-1);\n  const res = n * sub;\n  popFrame(res);\n  await scheduler.wait();\n  return res;\n}`;\n        inputN.min = 0; inputN.max = 50; inputN.value = 8;\n        memoRow.style.display = 'none';\n        canvas.style.display = 'none';\n        treeArea.style.display = 'none';\n      } else if(demo === 'fibonacci'){\n        demoTitle.textContent = 'Fibonacci (recursion tree)';\n        demoHint.textContent = 'Builds a tree of recursive calls. Watch how many repeated calls occur without memoization.';\n        codeBlock.textContent = `// Naive Fibonacci (instrumented)\nasync function fib(n){\n  pushFrame('fib',{n});\n  await scheduler.wait();\n  if(n <= 1){\n    popFrame(n);\n    await scheduler.wait();\n    return n;\n  }\n  const a = await fib(n-1);\n  const b = await fib(n-2);\n  const r = a + b;\n  popFrame(r);\n  await scheduler.wait();\n  return r;\n}`;\n        inputN.min = 0; inputN.max = 12; inputN.value = 6;\n        memoRow.style.display = 'block';\n        canvas.style.display = 'none';\n        treeArea.style.display = 'block';\n      } else if(demo === 'fractal'){\n        demoTitle.textContent = 'Fractal Tree (drawing recursion)';\n        demoHint.textContent = 'Each branch recursively draws two smaller branches.';\n        codeBlock.textContent = `// Recursively draw branching tree (non-async)\nfunction drawBranch(x,y,len,angle,depth){\n  // draw line then two smaller branches until depth==0\n}`;\n        inputN.min = 1; inputN.max = 12; inputN.value = 8;\n        memoRow.style.display = 'none';\n        treeArea.style.display = 'none';\n        canvas.style.display = 'block';\n      }\n    }\n\n    demoSelect.addEventListener('change', updateUIForDemo);\n    modeSelect.addEventListener('change', (e)=>{\n      state.config.mode = e.target.value;\n      scheduler.setMode(e.target.value);\n      stepBtn.disabled = (e.target.value !== 'step');\n    });\n    speedRange.addEventListener('input', ()=>{ state.config.speed = parseInt(speedRange.value,10); scheduler.setDelay(state.config.speed); });\n\n    stepBtn.addEventListener('click', ()=>{\n      // allow next step in scheduler\n      scheduler.nextStep();\n    });\n\n    resetBtn.addEventListener('click', ()=>{\n      resetState();\n    });\n\n    runBtn.addEventListener('click', async ()=>{\n      if(state.running) return;\n      resetState();\n      state.running = true;\n      scheduler.setMode(modeSelect.value);\n      scheduler.setDelay(parseInt(speedRange.value,10));\n      const demo = demoSelect.value;\n      const n = Math.max(0, Math.min(50, parseInt(inputN.value || 0,10)));\n      try {\n        if(demo === 'factorial'){\n          treeArea.style.display = 'none';\n          canvas.style.display = 'none';\n          // run factorial demo\n          const res = await factorialDemo(n);\n          state.lastResult = res;\n          updateBadges();\n        } else if(demo === 'fibonacci'){\n          const memoize = memoCheckbox.checked;\n          // run fibonacci demo\n          const res = await fibonacciDemo(n, memoize);\n          state.lastResult = res;\n          updateBadges();\n        } else if(demo === 'fractal'){\n          // draw fractal tree (non-async)\n          treeArea.style.display = 'none';\n          canvas.style.display = 'block';\n          drawFractalTree(n);\n          // set result to depth for display\n          state.lastResult = 'drawn (depth ' + n + ')';\n          updateBadges();\n        }\n      } catch (err){\n        console.error(err);\n      } finally {\n        state.running = false;\n      }\n    });\n\n    // initialize\n    (function init(){\n      updateUIForDemo();\n      scheduler.setMode(modeSelect.value);\n      scheduler.setDelay(parseInt(speedRange.value,10));\n      stepBtn.disabled = (modeSelect.value !== 'step');\n      // resize canvas on window resize\n      function fitCanvas(){\n        if(canvas.style.display === 'none') return;\n        const rect = canvas.getBoundingClientRect();\n        canvas.width = Math.floor(rect.width * devicePixelRatio);\n        canvas.height = Math.floor(rect.height * devicePixelRatio);\n      }\n      window.addEventListener('resize', fitCanvas);\n      fitCanvas();\n    })();\n\n    // Prevent accidental large runs for naive Fibonacci: cap input if memo off\n    inputN.addEventListener('input', ()=>{\n      if(demoSelect.value === 'fibonacci' && !memoCheckbox.checked){\n        const v = parseInt(inputN.value||0,10);\n        if(v > 9){ inputN.value = 9; } // naive fib >9 grows quickly in calls\n      }\n    });\n\n    // Toggle memoization hint\n    memoCheckbox.addEventListener('change', ()=>{\n      if(!memoCheckbox.checked){\n        // warn if n too large (>9)\n        if(parseInt(inputN.value||0,10) > 9) inputN.value = 9;\n      }\n    });\n\n    // small helper: allow pressing space to step in step mode\n    window.addEventListener('keydown', (e)=>{\n      if(e.code === 'Space' && modeSelect.value === 'step'){\n        e.preventDefault();\n        scheduler.nextStep();\n      }\n    });\n\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Recursion"
    }
  ],
  "topic": "Recursion",
  "hasFSM": false,
  "hasTest": true
}