{
  "id": "d80ba981-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:50.445Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Fibonacci Sequence",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<title>Fibonacci Sequence Explorer</title>\n<style>\n  :root{\n    --bg:#0f1724;\n    --card:#0b1220;\n    --muted:#9aa4b2;\n    --accent:#6ee7b7;\n    --accent2:#60a5fa;\n    --glass: rgba(255,255,255,0.03);\n    color-scheme: dark;\n  }\n  body{\n    margin:0;\n    font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    background: linear-gradient(180deg, #071024 0%, #081226 50%, #081323 100%);\n    color:#e6eef6;\n    -webkit-font-smoothing:antialiased;\n    -moz-osx-font-smoothing:grayscale;\n    padding:24px;\n  }\n  header{ margin-bottom:18px; display:flex; align-items:flex-start; gap:16px; }\n  h1{ margin:0; font-size:20px; letter-spacing:-0.2px; }\n  p.lead{ margin:4px 0 0; color:var(--muted); font-size:13px; max-width:58ch; }\n  main{ display:grid; grid-template-columns: 360px 1fr; gap:18px; align-items:start; }\n  .card{\n    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n    border:1px solid rgba(255,255,255,0.03);\n    padding:14px;\n    border-radius:12px;\n    box-shadow: 0 6px 30px rgba(2,6,23,0.6);\n  }\n  label{ display:block; font-size:13px; margin-bottom:6px; color:var(--muted); }\n  .form-row{ margin-bottom:12px; }\n  input[type=\"number\"], select, input[type=\"text\"]{\n    width:100%;\n    padding:8px 10px;\n    background:var(--glass);\n    border:1px solid rgba(255,255,255,0.03);\n    border-radius:8px;\n    color:inherit;\n    outline:none;\n    box-sizing:border-box;\n    font-size:13px;\n  }\n  button{\n    background:linear-gradient(90deg,var(--accent), var(--accent2));\n    border:0;\n    color:#042027;\n    padding:9px 12px;\n    border-radius:10px;\n    cursor:pointer;\n    font-weight:600;\n  }\n  .muted{ color:var(--muted); font-size:13px; }\n  .row{ display:flex; gap:8px; align-items:center; }\n  .controls{ display:flex; gap:8px; margin-top:6px; }\n  .small{ font-size:12px; padding:7px 8px; border-radius:8px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); color:var(--muted); }\n  .output{ white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:13px; color:#dcefff; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005)); padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.02); max-height:360px; overflow:auto; }\n  .canvas-wrap{ background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005)); padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.02); }\n  footer{ margin-top:12px; color:var(--muted); font-size:12px; }\n  .meta{ font-size:13px; color:var(--muted); margin-top:8px; }\n  .badge{ background:rgba(255,255,255,0.02); color:var(--muted); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.02); font-size:13px; }\n  a{ color:var(--accent2); text-decoration:none; }\n  @media (max-width:940px){\n    main{ grid-template-columns: 1fr; }\n  }\n</style>\n</head>\n<body>\n<header>\n  <div>\n    <h1>Fibonacci Sequence Explorer</h1>\n    <p class=\"lead\">Generate Fibonacci numbers, compare algorithms, visualize growth (log scale) and watch the ratios converge to the golden ratio φ ≈ 1.6180339887.</p>\n  </div>\n</header>\n\n<main>\n  <section class=\"card\">\n    <div class=\"form-row\">\n      <label for=\"count\">How many Fibonacci numbers to compute?</label>\n      <input id=\"count\" type=\"number\" min=\"1\" max=\"10000\" value=\"30\" />\n      <div class=\"muted\" style=\"margin-top:6px;\">Tip: naive recursion is slow—limited to n ≤ 40 for safety. Fast doubling can compute very large indices using BigInt.</div>\n    </div>\n\n    <div class=\"form-row\">\n      <label for=\"method\">Algorithm</label>\n      <select id=\"method\">\n        <option value=\"iterative\">Iterative (loop)</option>\n        <option value=\"recursive\">Naive recursive (slow)</option>\n        <option value=\"memo\">Recursive with memoization</option>\n        <option value=\"fastdoubling\" selected>Fast doubling (recommended)</option>\n        <option value=\"matrix\">Matrix exponentiation</option>\n      </select>\n    </div>\n\n    <div class=\"form-row\">\n      <label for=\"limitDigits\">If numbers grow large, optionally display only the last N digits (0 = full)</label>\n      <input id=\"limitDigits\" type=\"number\" min=\"0\" max=\"100000\" value=\"0\" />\n    </div>\n\n    <div class=\"row controls\">\n      <button id=\"computeBtn\">Compute</button>\n      <button id=\"copyBtn\" class=\"small\">Copy sequence</button>\n      <button id=\"clearBtn\" class=\"small\">Clear</button>\n    </div>\n\n    <div class=\"meta\">\n      <div style=\"display:flex; gap:8px; margin-top:10px;\">\n        <div class=\"badge\" id=\"timeBadge\">Time: --</div>\n        <div class=\"badge\" id=\"algoBadge\">Algorithm: fastdoubling</div>\n      </div>\n      <div class=\"muted\" style=\"margin-top:8px;\">Notes: All integer computations use BigInt to preserve exactness. Ratios are shown as floating approximations.</div>\n    </div>\n  </section>\n\n  <section style=\"display:flex;flex-direction:column; gap:12px;\">\n    <div class=\"card\">\n      <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n        <strong>Output</strong>\n        <div class=\"muted\">Count: <span id=\"outCount\">0</span></div>\n      </div>\n      <div id=\"output\" class=\"output\" aria-live=\"polite\">Press \"Compute\" to begin.</div>\n    </div>\n\n    <div class=\"card\">\n      <div style=\"display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;\">\n        <strong>Charts</strong>\n        <div class=\"muted\">Visualization: log10(Fn) bar heights and ratio F(n+1)/F(n)</div>\n      </div>\n      <div class=\"canvas-wrap\">\n        <canvas id=\"chart\" width=\"1000\" height=\"300\" style=\"width:100%; height:240px; display:block;\"></canvas>\n      </div>\n      <div style=\"display:flex; gap:8px; margin-top:8px;\">\n        <button id=\"downloadPNG\" class=\"small\">Download PNG</button>\n        <button id=\"toggleLog\" class=\"small\">Toggle Y-scale: Log</button>\n        <div style=\"flex:1\"></div>\n        <div class=\"muted\" id=\"phiBadge\">φ ≈ 1.6180339887</div>\n      </div>\n    </div>\n\n    <footer class=\"muted\">This page demonstrates Fibonacci generation methods, performance, and convergence to the golden ratio. Works offline — single file.</footer>\n  </section>\n</main>\n\n<script>\n/*\n  Fibonacci Explorer\n  - Multiple algorithms:\n    iterative, naive recursive, memoized, fast doubling, matrix\n  - Uses BigInt for exact integers\n  - Visualizes log10(Fn) bars and ratio line\n  - Limits naive recursion for safety\n*/\n\nconst elements = {\n  count: document.getElementById('count'),\n  method: document.getElementById('method'),\n  computeBtn: document.getElementById('computeBtn'),\n  output: document.getElementById('output'),\n  outCount: document.getElementById('outCount'),\n  timeBadge: document.getElementById('timeBadge'),\n  algoBadge: document.getElementById('algoBadge'),\n  copyBtn: document.getElementById('copyBtn'),\n  clearBtn: document.getElementById('clearBtn'),\n  limitDigits: document.getElementById('limitDigits'),\n  chart: document.getElementById('chart'),\n  downloadPNG: document.getElementById('downloadPNG'),\n  toggleLog: document.getElementById('toggleLog'),\n  phiBadge: document.getElementById('phiBadge')\n};\n\nconst ctx = elements.chart.getContext('2d');\nlet useLog = true;\n\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst SQRT5 = Math.sqrt(5);\n\nfunction formatBigInt(bi, limitDigits){\n  if(limitDigits && limitDigits > 0){\n    // last N digits: use string and take last part\n    const s = bi.toString();\n    if(s.length > limitDigits){\n      return '…' + s.slice(-limitDigits);\n    }\n    return s;\n  } else {\n    return bi.toString();\n  }\n}\n\n// Algorithms\nfunction fibIterative(n){\n  // returns array of BigInt from F1..Fn\n  const res = [];\n  if(n <= 0) return res;\n  let a = 0n, b = 1n;\n  for(let i=1;i<=n;i++){\n    res.push(b);\n    const nxt = a + b;\n    a = b; b = nxt;\n  }\n  return res;\n}\n\nfunction fibNaive(n){\n  // compute F(n) naive recursion (1-indexed)\n  function f(k){\n    if(k <= 0) return 0n;\n    if(k === 1) return 1n;\n    return f(k-1) + f(k-2);\n  }\n  const arr = [];\n  for(let i=1;i<=n;i++) arr.push(f(i));\n  return arr;\n}\n\nfunction fibMemo(n){\n  const memo = {0:0n, 1:1n};\n  function f(k){\n    if(k in memo) return memo[k];\n    memo[k] = f(k-1) + f(k-2);\n    return memo[k];\n  }\n  const arr = [];\n  for(let i=1;i<=n;i++) arr.push(f(i));\n  return arr;\n}\n\nfunction fibMatrix(n){\n  // Uses 2x2 matrix exponentiation with BigInt\n  function mul(A,B){\n    return [\n      [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],\n      [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]\n    ];\n  }\n  function powMatrix(M, k){\n    let res = [[1n,0n],[0n,1n]];\n    let base = M;\n    while(k > 0){\n      if(k & 1) res = mul(res, base);\n      base = mul(base, base);\n      k >>= 1;\n    }\n    return res;\n  }\n  const arr = [];\n  for(let i=1;i<=n;i++){\n    const M = [[1n,1n],[1n,0n]];\n    const P = powMatrix(M, i-1); // P * [F1;F0] gives [Fi;F{i-1}] where F1=1 F0=0\n    arr.push(P[0][0]); // Fi\n  }\n  return arr;\n}\n\nfunction fibFastDoublingSingle(k){\n  // returns [F(k), F(k+1)] as BigInt using fast doubling\n  function fd(n){\n    if(n === 0) return [0n, 1n];\n    const [a,b] = fd(Math.floor(n/2));\n    const c = a * ( (b<<1n) - a );\n    const d = a*a + b*b;\n    if(n % 2 === 0) return [c, d];\n    else return [d, c + d];\n  }\n  return fd(k);\n}\n\nfunction fibFastDoubling(n){\n  const arr = [];\n  for(let i=1;i<=n;i++){\n    arr.push(fibFastDoublingSingle(i)[0]);\n  }\n  return arr;\n}\n\n// Helpers for approximate double value (for ratio when BigInt too big)\nfunction approxFibDouble(n){\n  // Use Binet's formula approximation as double\n  // Fn ≈ phi^n / sqrt(5) for n >= 1 (more accurate for larger n)\n  return Math.exp(n * Math.log(PHI) - Math.log(SQRT5));\n}\n\nfunction computeSequence(n, method){\n  if(n <= 0) return [];\n  switch(method){\n    case 'iterative': return fibIterative(n);\n    case 'recursive':\n      if(n > 40) throw new Error('Naive recursion limited to n ≤ 40 to avoid freezing the page.');\n      return fibNaive(n);\n    case 'memo': return fibMemo(n);\n    case 'matrix': return fibMatrix(n);\n    case 'fastdoubling': return fibFastDoubling(n);\n    default: return fibIterative(n);\n  }\n}\n\nfunction timeIt(fn){\n  const t0 = performance.now();\n  const res = fn();\n  const t1 = performance.now();\n  return {res, time: t1 - t0};\n}\n\nfunction drawChart(valuesBigInt){\n  const canvas = elements.chart;\n  const ctx = canvas.getContext('2d');\n  const W = canvas.width = Math.floor(canvas.clientWidth * devicePixelRatio);\n  const H = canvas.height = Math.floor(canvas.clientHeight * devicePixelRatio);\n  ctx.clearRect(0,0,W,H);\n  ctx.save();\n  ctx.scale(devicePixelRatio, devicePixelRatio);\n\n  const padding = {l:44, r:16, t:12, b:36};\n  const cw = canvas.clientWidth;\n  const ch = canvas.clientHeight;\n\n  const n = valuesBigInt.length;\n  if(n === 0){\n    ctx.fillStyle = '#9aa4b2';\n    ctx.font = '13px ui-sans-serif';\n    ctx.fillText('No data to plot', padding.l, ch/2);\n    ctx.restore();\n    return;\n  }\n\n  // compute heights: use log10(Fn) so we can plot regardless of magnitude\n  const logs = valuesBigInt.map((v, i)=>{\n    if(v === 0n) return 0;\n    // if small enough to convert safely:\n    const s = v.toString();\n    if(s.length <= 15){\n      return Math.log10(Number(v));\n    } else {\n      // approximate log10 via length and leading digits\n      // log10(v) ≈ (len-1) + log10(leading)\n      const len = s.length;\n      const lead = Number(s.slice(0,15)) / Math.pow(10, 15 - 1);\n      return Math.log10(lead) + (len - 1);\n    }\n  });\n\n  const minLog = Math.min(...logs);\n  const maxLog = Math.max(...logs);\n\n  // For ratio plot: compute ratio approximations\n  const ratios = [];\n  for(let i=0;i<n-1;i++){\n    const a = valuesBigInt[i];\n    const b = valuesBigInt[i+1];\n    let r;\n    // if both small enough:\n    if(a.toString().length <= 15 && b.toString().length <= 15){\n      r = Number(b) / Number(a);\n    } else {\n      // ratio ≈ phi for large indices; or use exponents: ratio ≈ 10^(log10(b)-log10(a))\n      const logA = logs[i];\n      const logB = logs[i+1];\n      r = Math.pow(10, logB - logA);\n    }\n    ratios.push(r);\n  }\n\n  const maxRatio = Math.max(...ratios, PHI);\n  const minRatio = Math.min(...ratios, PHI);\n\n  // draw axes\n  ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n  ctx.lineWidth = 1;\n  ctx.beginPath();\n  ctx.moveTo(padding.l, padding.t);\n  ctx.lineTo(padding.l, ch - padding.b);\n  ctx.lineTo(cw - padding.r, ch - padding.b);\n  ctx.stroke();\n\n  // bars for logs\n  const plotW = cw - padding.l - padding.r;\n  const barGap = Math.min(4, Math.max(1, Math.floor(plotW / n / 6)));\n  const barW = Math.max(2, (plotW / n) - barGap);\n\n  // compute y scale for logs\n  const logRange = (maxLog - minLog) || 1;\n  function yFromLog(L){\n    // map maxLog -> padding.t, minLog -> ch - padding.b\n    const t = padding.t + ( (maxLog - L) / logRange ) * (ch - padding.t - padding.b);\n    return t;\n  }\n\n  // draw bars\n  for(let i=0;i<n;i++){\n    const x = padding.l + i * (barW + barGap);\n    const y = yFromLog(logs[i]);\n    const h = (ch - padding.b) - y;\n    const grd = ctx.createLinearGradient(x, y, x, y+h);\n    grd.addColorStop(0, 'rgba(110,231,183,0.9)');\n    grd.addColorStop(1, 'rgba(96,165,250,0.85)');\n    ctx.fillStyle = grd;\n    ctx.fillRect(x, y, barW, h);\n  }\n\n  // draw ratio line\n  ctx.beginPath();\n  for(let i=0;i<ratios.length;i++){\n    const r = ratios[i];\n    // map ratio to y on right half scale\n    const y = padding.t + ( (maxRatio - r) / (maxRatio - minRatio || 1) ) * (ch - padding.t - padding.b);\n    const x = padding.l + (i + 0.5) * (barW + barGap);\n    if(i === 0) ctx.moveTo(x, y);\n    else ctx.lineTo(x, y);\n  }\n  ctx.strokeStyle = 'rgba(255,205,86,0.95)';\n  ctx.lineWidth = 2;\n  ctx.stroke();\n\n  // draw golden ratio horizontal line\n  const phiY = padding.t + ( (maxRatio - PHI) / (maxRatio - minRatio || 1) ) * (ch - padding.t - padding.b);\n  ctx.beginPath();\n  ctx.setLineDash([6,4]);\n  ctx.moveTo(padding.l, phiY);\n  ctx.lineTo(cw - padding.r, phiY);\n  ctx.strokeStyle = 'rgba(255,255,255,0.12)';\n  ctx.lineWidth = 1;\n  ctx.stroke();\n  ctx.setLineDash([]);\n\n  // labels\n  ctx.fillStyle = 'rgba(255,255,255,0.75)';\n  ctx.font = '12px ui-sans-serif';\n  ctx.fillText('log10(Fn)', 8, padding.t + 12);\n  ctx.fillText('ratio F(n+1)/F(n)', cw - padding.r - 140, padding.t + 12);\n\n  // y-axis ticks for log scale\n  ctx.fillStyle = 'rgba(255,255,255,0.6)';\n  ctx.font = '11px ui-sans-serif';\n  const ticks = 4;\n  for(let i=0;i<=ticks;i++){\n    const L = minLog + ( (ticks - i) / ticks ) * (maxLog - minLog);\n    const y = yFromLog(L);\n    ctx.fillText(L.toFixed(1), 6, y + 4);\n    ctx.beginPath();\n    ctx.moveTo(padding.l - 4, y);\n    ctx.lineTo(padding.l, y);\n    ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n    ctx.stroke();\n  }\n\n  // x-axis labels (every so often)\n  ctx.fillStyle = 'rgba(255,255,255,0.6)';\n  ctx.font = '11px ui-sans-serif';\n  const step = Math.ceil(n / 10);\n  for(let i=0;i<n;i+=step){\n    const x = padding.l + (i) * (barW + barGap);\n    ctx.fillText(String(i+1), x, ch - padding.b + 14);\n  }\n\n  ctx.restore();\n}\n\n// Event handlers\nelements.computeBtn.addEventListener('click', ()=> {\n  const n = Math.floor(Number(elements.count.value)) || 0;\n  const method = elements.method.value;\n  const limitDigits = Math.floor(Number(elements.limitDigits.value)) || 0;\n  elements.algoBadge.textContent = `Algorithm: ${method}`;\n  elements.timeBadge.textContent = 'Time: computing…';\n  elements.output.textContent = 'Computing… please wait.';\n\n  try{\n    const {res, time} = timeIt(()=> computeSequence(n, method));\n    // res is array of BigInt\n    elements.timeBadge.textContent = `Time: ${time.toFixed(2)} ms`;\n    elements.outCount.textContent = String(res.length);\n    const lines = res.map((v, idx)=>{\n      return `${idx+1}: ${formatBigInt(v, limitDigits)}`;\n    });\n    elements.output.textContent = lines.join('\\n');\n    drawChart(res);\n  } catch(err){\n    elements.timeBadge.textContent = 'Time: error';\n    elements.output.textContent = 'Error: ' + err.message;\n    ctx.clearRect(0,0, elements.chart.width, elements.chart.height);\n  }\n});\n\nelements.copyBtn.addEventListener('click', async ()=>{\n  const text = elements.output.textContent;\n  try{\n    await navigator.clipboard.writeText(text);\n    elements.copyBtn.textContent = 'Copied!';\n    setTimeout(()=> elements.copyBtn.textContent = 'Copy sequence', 1200);\n  } catch(e){\n    elements.copyBtn.textContent = 'Copy failed';\n    setTimeout(()=> elements.copyBtn.textContent = 'Copy sequence', 1200);\n  }\n});\n\nelements.clearBtn.addEventListener('click', ()=>{\n  elements.output.textContent = '';\n  elements.outCount.textContent = '0';\n  elements.timeBadge.textContent = 'Time: --';\n  ctx.clearRect(0,0, elements.chart.width, elements.chart.height);\n});\n\nelements.downloadPNG.addEventListener('click', ()=>{\n  const link = document.createElement('a');\n  link.href = elements.chart.toDataURL('image/png');\n  link.download = 'fibonacci_chart.png';\n  link.click();\n});\n\nelements.toggleLog.addEventListener('click', ()=>{\n  useLog = !useLog;\n  elements.toggleLog.textContent = useLog ? 'Toggle Y-scale: Log' : 'Toggle Y-scale: Linear';\n  // we don't support linear in this simplified viewer; redraw with same data\n  // re-trigger compute to redraw chart\n  elements.computeBtn.click();\n});\n\n// Initialize with default example\nwindow.addEventListener('load', ()=>{\n  elements.computeBtn.click();\n});\n\n// Extra: compute and display ratio convergence for larger n when user hovers phiBadge\nelements.phiBadge.addEventListener('mouseenter', ()=>{\n  // compute ratios for n = 5..25 quickly using fast doubling and show approximate closeness\n  const ns = [5,8,10,12,15,20,30,50];\n  const rows = ns.map(k=>{\n    const fk = fibFastDoublingSingle(k)[0];\n    const fk1 = fibFastDoublingSingle(k+1)[0];\n    let ratio;\n    if(fk.toString().length <= 15 && fk1.toString().length <= 15){\n      ratio = (Number(fk1) / Number(fk)).toFixed(12);\n    } else {\n      const logA = Math.log10(Number(approxFibDouble(k)));\n      const logB = Math.log10(Number(approxFibDouble(k+1)));\n      ratio = Math.pow(10, logB - logA).toFixed(12);\n    }\n    const diff = (Math.abs(Number(ratio) - PHI)).toExponential(3);\n    return `n=${k}: ratio=${ratio}, diff from φ ≈ ${diff}`;\n  });\n  elements.phiBadge.textContent = rows.join(' | ');\n});\nelements.phiBadge.addEventListener('mouseleave', ()=>{\n  elements.phiBadge.textContent = `φ ≈ ${PHI.toFixed(10)}`;\n});\n\n\n// Accessibility: allow Enter key on count to compute\nelements.count.addEventListener('keydown', (e)=>{\n  if(e.key === 'Enter') elements.computeBtn.click();\n});\nelements.method.addEventListener('change', ()=> {\n  elements.algoBadge.textContent = `Algorithm: ${elements.method.value}`;\n});\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Fibonacci Sequence"
    }
  ],
  "topic": "Fibonacci Sequence",
  "hasFSM": false,
  "hasTest": true
}