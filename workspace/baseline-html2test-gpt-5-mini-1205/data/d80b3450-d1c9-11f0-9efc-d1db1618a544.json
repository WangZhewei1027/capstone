{
  "id": "d80b3450-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:14.630Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Binary Search",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Binary Search Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --card:#0b1220;\n      --muted:#94a3b8;\n      --accent:#60a5fa;\n      --success:#34d399;\n      --danger:#fb7185;\n      --glass: rgba(255,255,255,0.03);\n    }\n    html,body{\n      margin:0;height:100%;background:linear-gradient(180deg,#071029 0%, #071a2a 100%);font-family:Inter, Roboto, Arial, sans-serif;color:#e6eef8;\n    }\n    .container{\n      max-width:1100px;margin:28px auto;padding:20px;\n    }\n    h1{margin:0 0 12px 0;font-size:24px}\n    .grid{\n      display:grid;grid-template-columns:1fr 420px;gap:18px;\n    }\n    .card{\n      background:var(--card);border-radius:10px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6);\n    }\n    .controls{display:flex;flex-direction:column;gap:10px}\n    label{font-size:13px;color:var(--muted);display:flex;justify-content:space-between;align-items:center}\n    .row{display:flex;gap:10px;align-items:center}\n    input[type=\"number\"], input[type=\"text\"]{\n      background:var(--glass);border:1px solid rgba(255,255,255,0.04);color:inherit;padding:8px;border-radius:6px;\n      min-width:0;\n    }\n    button{\n      background:linear-gradient(180deg,var(--accent),#2b7bdc);border:none;padding:8px 12px;border-radius:8px;color:#02203b;cursor:pointer;font-weight:600;\n      box-shadow:0 4px 10px rgba(59,130,246,0.18);\n    }\n    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);box-shadow:none}\n    .small{font-size:13px;padding:6px 8px;border-radius:6px}\n    .array{\n      display:flex;gap:8px;flex-wrap:wrap;padding:12px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);min-height:88px;align-items:center;\n    }\n    .cell{\n      width:48px;height:56px;border-radius:8px;background:rgba(255,255,255,0.03);display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:14px;\n      border:1px solid rgba(255,255,255,0.03);position:relative;cursor:pointer;transition:transform 160ms ease, box-shadow 160ms;\n      user-select:none;\n    }\n    .cell:hover{transform:translateY(-4px);box-shadow:0 8px 18px rgba(3,6,23,0.6)}\n    .idx{font-size:11px;color:var(--muted);position:absolute;left:6px;top:6px}\n    .val{font-weight:700}\n    .range{background:linear-gradient(90deg, rgba(96,165,250,0.08), transparent);border-color:rgba(96,165,250,0.12)}\n    .leftptr{box-shadow:0 6px 18px rgba(96,165,250,0.08);border:2px solid rgba(96,165,250,0.22)}\n    .rightptr{box-shadow:0 6px 18px rgba(96,165,250,0.08);border:2px solid rgba(96,165,250,0.22)}\n    .mid{background:linear-gradient(90deg, rgba(16,185,129,0.09), transparent);border:2px solid rgba(16,185,129,0.12);box-shadow:0 10px 30px rgba(16,185,129,0.04)}\n    .found{background:linear-gradient(90deg, rgba(52,211,153,0.12), transparent);border:2px solid rgba(52,211,153,0.14)}\n    .notfound{background:linear-gradient(90deg, rgba(251,113,133,0.08), transparent);border:2px solid rgba(251,113,133,0.12)}\n    .controls-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n    .pseudocode{font-family:monospace;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:12px;border-radius:8px;color:var(--muted);font-size:13px}\n    .line{padding:6px;border-radius:6px}\n    .line.active{background:rgba(96,165,250,0.09);color:#e6f2ff}\n    .status{font-size:13px;color:var(--muted);padding-top:8px}\n    .legend{display:flex;gap:8px;flex-wrap:wrap}\n    .legend .item{display:flex;gap:6px;align-items:center;font-size:13px;color:var(--muted)}\n    .swatch{width:14px;height:14px;border-radius:4px;box-shadow:0 4px 10px rgba(2,6,23,0.6)}\n    .sw-range{background:linear-gradient(90deg, rgba(96,165,250,0.16), transparent)}\n    .sw-left{background:rgba(96,165,250,0.32)}\n    .sw-mid{background:rgba(16,185,129,0.34)}\n    .sw-found{background:rgba(52,211,153,0.34)}\n    .info{margin-top:10px;color:var(--muted);font-size:13px}\n    .controls .muted{color:var(--muted);font-size:13px}\n    .stack{\n      margin-top:10px;display:flex;flex-direction:column;gap:8px;\n    }\n    .frame{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;font-family:monospace;color:var(--muted);display:flex;justify-content:space-between}\n    .playbtn{background:linear-gradient(90deg,#34d399,#10b981);color:#012018}\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <h1>Binary Search Visualizer</h1>\n    <div style=\"display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:8px\">\n      <div style=\"color:var(--muted);font-size:13px;max-width:720px\">\n        Binary Search finds the position of a target value within a sorted array by repeatedly dividing the search interval in half. Use the controls to build an array, pick a target, and step through the algorithm. Click any array cell to set the search target quickly.\n      </div>\n    </div>\n\n    <div class=\"grid\">\n      <!-- Left: Visualization and controls -->\n      <div class=\"card\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;gap:12px\">\n          <div style=\"font-weight:700\">Array & Visualization</div>\n          <div style=\"display:flex;gap:8px;align-items:center\">\n            <div style=\"color:var(--muted);font-size:13px\">Mode</div>\n            <select id=\"modeSelect\" style=\"background:var(--glass);border-radius:6px;padding:6px;color:inherit;border:1px solid rgba(255,255,255,0.03)\">\n              <option value=\"iterative\">Iterative</option>\n              <option value=\"recursive\">Recursive (visualized stack)</option>\n            </select>\n          </div>\n        </div>\n\n        <div style=\"margin-top:12px\" class=\"controls\">\n          <div class=\"row\" style=\"gap:10px\">\n            <label style=\"flex:1\">\n              <span>Array size</span>\n              <span style=\"display:flex;gap:8px;align-items:center\">\n                <input id=\"sizeInput\" type=\"number\" min=\"3\" max=\"60\" value=\"15\" style=\"width:68px\" />\n                <button id=\"genBtn\" class=\"small\">Generate</button>\n              </span>\n            </label>\n            <label style=\"flex:1\">\n              <span>Min & Max values</span>\n              <span style=\"display:flex;gap:6px\">\n                <input id=\"minVal\" type=\"number\" value=\"1\" style=\"width:68px\" />\n                <input id=\"maxVal\" type=\"number\" value=\"99\" style=\"width:68px\" />\n              </span>\n            </label>\n          </div>\n\n          <div class=\"row\">\n            <label style=\"flex:1\">\n              <span>Target value</span>\n              <input id=\"targetInput\" type=\"text\" placeholder=\"Enter number or click a cell\" />\n            </label>\n            <div style=\"display:flex;gap:8px;align-items:center\">\n              <button id=\"setTargetBtn\" class=\"small ghost\">Set Target</button>\n              <button id=\"randomTargetBtn\" class=\"small\">Random Target</button>\n            </div>\n          </div>\n\n          <div style=\"margin-top:6px\" class=\"controls-row\">\n            <button id=\"stepBtn\" class=\"small\">Step</button>\n            <button id=\"playBtn\" class=\"small playbtn\">Play</button>\n            <button id=\"resetBtn\" class=\"small ghost\">Reset</button>\n            <button id=\"fastBtn\" class=\"small\">Fast Run</button>\n            <div style=\"margin-left:auto;display:flex;gap:6px;align-items:center\">\n              <div style=\"color:var(--muted);font-size:13px\">Speed</div>\n              <input id=\"speed\" type=\"range\" min=\"100\" max=\"1600\" value=\"700\" />\n            </div>\n          </div>\n\n        </div>\n\n        <div style=\"margin-top:12px\" class=\"array\" id=\"arrayContainer\" title=\"Click an element to set target\">\n          <!-- cells inserted here -->\n        </div>\n\n        <div style=\"display:flex;justify-content:space-between;align-items:center;margin-top:12px\">\n          <div class=\"legend\">\n            <div class=\"item\"><div class=\"swatch sw-range\"></div><div class=\"muted\">Active search range</div></div>\n            <div class=\"item\"><div class=\"swatch sw-left\"></div><div class=\"muted\">Left / Right pointers</div></div>\n            <div class=\"item\"><div class=\"swatch sw-mid\"></div><div class=\"muted\">Mid</div></div>\n            <div class=\"item\"><div class=\"swatch sw-found\"></div><div class=\"muted\">Found</div></div>\n          </div>\n          <div style=\"text-align:right\">\n            <div style=\"font-size:13px;color:var(--muted)\">Comparisons: <span id=\"compCount\">0</span></div>\n            <div style=\"font-size:13px;color:var(--muted)\">Steps: <span id=\"stepCount\">0</span></div>\n          </div>\n        </div>\n\n        <div class=\"status\" id=\"message\" style=\"margin-top:10px\">Status: waiting to start</div>\n\n        <div id=\"stackArea\" style=\"display:none;margin-top:12px\">\n          <div style=\"font-weight:700;margin-bottom:8px\">Recursion stack (top first)</div>\n          <div class=\"stack\" id=\"stackFrames\"></div>\n        </div>\n      </div>\n\n      <!-- Right: Pseudocode & info -->\n      <div class=\"card\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center\">\n          <div style=\"font-weight:700\">Pseudocode & Explanation</div>\n          <div style=\"font-size:13px;color:var(--muted)\">Click cells to set target</div>\n        </div>\n\n        <div style=\"margin-top:12px\">\n          <div class=\"pseudocode\" id=\"pseudocode\">\n            <!-- code lines -->\n          </div>\n        </div>\n\n        <div style=\"margin-top:12px\" class=\"info\">\n          <div style=\"font-weight:700;margin-bottom:6px\">How to use</div>\n          <ul style=\"margin:0 0 0 18px;color:var(--muted);font-size:13px\">\n            <li>Generate a sorted array and set a target (input or click a cell).</li>\n            <li>Use Step to advance one algorithm action; Play to auto-step at the selected speed.</li>\n            <li>Observe left, right and mid pointers and the active search range.</li>\n            <li>Switch to recursive mode for a stack-based view of recursive calls.</li>\n          </ul>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<script>\n/*\n  Binary Search Visualizer\n  - Generates a sorted array (unique or with duplicates depending on spacing)\n  - Allows setting a target by input or clicking a cell\n  - Step-by-step iterative or recursive visual simulation with an optional auto-play\n  - Highlights pseudocode line corresponding to the current step\n*/\n\n// ---- Utility ----\nfunction $(id){ return document.getElementById(id); }\nfunction clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }\nfunction randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }\n\n// ---- State ----\nlet arr = [];\nlet left = 0, right = -1, mid = -1;\nlet target = null;\nlet mode = 'iterative';\nlet running = false;\nlet autoTimer = null;\nlet compCount = 0, stepCount = 0;\nlet state = 'idle'; // 'idle','calc_mid','compare','found','notfound','done'\nlet speed = 700;\n\n// For recursive visualization, maintain a simulated call stack frames: {l,r,status,mid}\nlet stack = [];\nlet recursiveActive = false;\n\n// DOM\nconst arrayContainer = $('arrayContainer');\nconst sizeInput = $('sizeInput');\nconst genBtn = $('genBtn');\nconst minValInput = $('minVal');\nconst maxValInput = $('maxVal');\nconst targetInput = $('targetInput');\nconst setTargetBtn = $('setTargetBtn');\nconst randomTargetBtn = $('randomTargetBtn');\nconst stepBtn = $('stepBtn');\nconst playBtn = $('playBtn');\nconst resetBtn = $('resetBtn');\nconst fastBtn = $('fastBtn');\nconst speedInput = $('speed');\nconst compCountEl = $('compCount');\nconst stepCountEl = $('stepCount');\nconst messageEl = $('message');\nconst modeSelect = $('modeSelect');\nconst pseudocodeEl = $('pseudocode');\nconst stackArea = $('stackArea');\nconst stackFrames = $('stackFrames');\n\n// Pseudocode lines for iterative and recursive modes\nconst pseudoIter = [\n  'left = 0; right = n - 1',\n  'while left <= right:',\n  '  mid = floor((left + right) / 2)',\n  '  if A[mid] == target:',\n  '    return mid  // found',\n  '  else if A[mid] < target:',\n  '    left = mid + 1',\n  '  else:',\n  '    right = mid - 1',\n  'return -1  // not found'\n];\n\nconst pseudoRec = [\n  'function binarySearchRec(A, left, right, target):',\n  '  if left > right:',\n  '    return -1  // base case: not found',\n  '  mid = floor((left + right) / 2)',\n  '  if A[mid] == target:',\n  '    return mid  // found',\n  '  else if A[mid] < target:',\n  '    return binarySearchRec(A, mid+1, right, target)',\n  '  else:',\n  '    return binarySearchRec(A, left, mid-1, target)'\n];\n\n// Render pseudocode\nfunction renderPseudocode(){\n  pseudocodeEl.innerHTML = '';\n  const lines = mode === 'iterative' ? pseudoIter : pseudoRec;\n  lines.forEach((t,i) => {\n    const div = document.createElement('div');\n    div.className = 'line';\n    div.dataset.line = i;\n    div.textContent = t;\n    pseudocodeEl.appendChild(div);\n  });\n}\n\n// Render array\nfunction renderArray(){\n  arrayContainer.innerHTML = '';\n  arr.forEach((v,i) => {\n    const cell = document.createElement('div');\n    cell.className = 'cell';\n    cell.dataset.index = i;\n    const idx = document.createElement('div');\n    idx.className = 'idx';\n    idx.textContent = i;\n    const val = document.createElement('div');\n    val.className = 'val';\n    val.textContent = v;\n    cell.appendChild(idx);\n    cell.appendChild(val);\n    // Click to set target\n    cell.addEventListener('click', () => {\n      setTarget(arr[i]);\n    });\n    arrayContainer.appendChild(cell);\n  });\n  updateHighlights();\n}\n\n// Update highlights for left/right/mid/active range\nfunction updateHighlights(foundIndex = null){\n  const cells = arrayContainer.querySelectorAll('.cell');\n  cells.forEach(c => {\n    c.classList.remove('range','leftptr','rightptr','mid','found','notfound');\n    const i = parseInt(c.dataset.index,10);\n    if (state === 'done' && foundIndex !== null && i === foundIndex){\n      c.classList.add('found');\n    } else if (state === 'notfound' && (left>right)) {\n      // show entire attempted range as not found highlight\n      // mark none specifically; optional to flash\n    } else {\n      if (left <= right && i >= left && i <= right) c.classList.add('range');\n      if (i === left && left <= right) c.classList.add('leftptr');\n      if (i === right && left <= right) c.classList.add('rightptr');\n      if (i === mid && mid >= left && mid <= right) c.classList.add('mid');\n    }\n  });\n}\n\n// Generate sorted array\nfunction generateArray(){\n  const n = clamp(parseInt(sizeInput.value,10) || 10, 3, 60);\n  const minV = parseInt(minValInput.value,10) || 0;\n  const maxV = parseInt(maxValInput.value,10);\n  const mx = Math.max(maxV, minV + Math.floor(n*1.2));\n  const range = Math.max(1, mx - minV + 1);\n  // Generate increasing sequence with some spacing\n  const res = [];\n  let cur = minV;\n  for (let i=0;i<n;i++){\n    // spacing ensures sorted unique-ish but can allow duplicates if range small\n    const remaining = n - i - 1;\n    const maxStep = Math.max(1, Math.floor(range / n));\n    const step = randInt(0, maxStep+2);\n    cur += step;\n    res.push(cur);\n    cur += 1; // ensure growth\n  }\n  arr = res;\n  resetSimulation();\n}\n\n// Set target\nfunction setTarget(val){\n  if (typeof val === 'string') {\n    const parsed = parseInt(val,10);\n    if (!Number.isFinite(parsed)) {\n      target = null;\n      targetInput.value = '';\n      showMessage('Invalid target value', true);\n      return;\n    } else {\n      target = parsed;\n      targetInput.value = String(target);\n    }\n  } else {\n    target = val;\n    targetInput.value = String(val);\n  }\n  showMessage('Target set to ' + target);\n}\n\n// Reset simulation\nfunction resetSimulation(){\n  // initial pointers\n  left = 0; right = arr.length - 1; mid = -1;\n  compCount = 0; stepCount = 0; state = 'idle';\n  stack = [];\n  running = false;\n  clearAuto();\n  compCountEl.textContent = compCount;\n  stepCountEl.textContent = stepCount;\n  renderArray();\n  renderPseudocode();\n  highlightLine(null);\n  stackArea.style.display = (mode === 'recursive') ? 'block' : 'none';\n  stackFrames.innerHTML = '';\n  showMessage('Array generated. Set a target to start.');\n}\n\n// Show message\nfunction showMessage(msg, isError=false){\n  messageEl.textContent = 'Status: ' + msg;\n  messageEl.style.color = isError ? 'var(--danger)' : '#e6eef8';\n}\n\n// Highlight pseudocode line index\nfunction highlightLine(i){\n  const lines = pseudocodeEl.querySelectorAll('.line');\n  lines.forEach((ln,idx)=> {\n    ln.classList.toggle('active', idx === i);\n  });\n}\n\n// Step function for iterative mode (state machine)\nfunction stepIterative(){\n  if (state === 'idle') {\n    // initialize\n    left = 0; right = arr.length - 1; mid = -1;\n    state = 'calc_mid';\n    showMessage(`Searching for ${target} between [${left},${right}]`);\n    highlightLine(0); // left = 0; right = n - 1\n    stepCount++;\n    stepCountEl.textContent = stepCount;\n    updateHighlights();\n    return;\n  }\n  if (state === 'calc_mid') {\n    if (left > right) {\n      state = 'notfound';\n      highlightLine(8);\n      showMessage('Target not found (empty interval)');\n      updateHighlights();\n      return;\n    }\n    mid = Math.floor((left + right) / 2);\n    state = 'compare';\n    highlightLine(2); // mid calculation\n    stepCount++;\n    stepCountEl.textContent = stepCount;\n    updateHighlights();\n    showMessage(`Calculated mid = ${mid} (A[mid]=${arr[mid]})`);\n    return;\n  }\n  if (state === 'compare') {\n    compCount++;\n    compCountEl.textContent = compCount;\n    highlightLine(3); // if A[mid] == target\n    stepCount++;\n    stepCountEl.textContent = stepCount;\n    const midVal = arr[mid];\n    showMessage(`Compare target ${target} with A[mid] = ${midVal}`);\n    if (midVal === target){\n      state = 'found';\n      highlightLine(4);\n      showMessage(`Found target at index ${mid}`);\n      updateHighlights(mid);\n      state = 'done';\n      running = false;\n      clearAuto();\n      return;\n    } else if (midVal < target){\n      highlightLine(5);\n      // move left\n      left = mid + 1;\n      state = 'calc_mid';\n      showMessage(`A[mid] < target → move left to ${left}`);\n      updateHighlights();\n      return;\n    } else {\n      highlightLine(7);\n      right = mid - 1;\n      state = 'calc_mid';\n      showMessage(`A[mid] > target → move right to ${right}`);\n      updateHighlights();\n      return;\n    }\n  }\n  if (state === 'notfound' || state === 'done') {\n    running = false;\n    clearAuto();\n    showMessage(state === 'done' ? 'Search finished (found)' : 'Search finished (not found)');\n  }\n}\n\n// Step function for recursive mode: we simulate recursion step-by-step by expanding/contracting stack\nfunction stepRecursive(){\n  // Initialize recursion if idle\n  if (state === 'idle') {\n    stack = [];\n    stack.push({l:0, r:arr.length-1, status:'enter', mid:null});\n    state = 'running';\n    renderStack();\n    highlightLine(0);\n    stepCount++; stepCountEl.textContent = stepCount;\n    showMessage(`Start recursion with [0, ${arr.length-1}]`);\n    return;\n  }\n\n  if (stack.length === 0) {\n    // finished without finding\n    state = 'notfound'; showMessage('Target not found'); highlightLine(1);\n    running = false; clearAuto();\n    return;\n  }\n\n  // operate on top frame\n  const frame = stack[stack.length - 1];\n  // status sequence: enter -> check_base -> compute_mid -> compare -> decided (pop or push next)\n  if (frame.status === 'enter') {\n    frame.status = 'check_base';\n    renderStack();\n    highlightLine(1); // if left > right: base case\n    stepCount++; stepCountEl.textContent = stepCount;\n    if (frame.l > frame.r) {\n      // base case, return -1 from this frame (pop)\n      frame.status = 'return_notfound';\n      showMessage(`Frame [${frame.l},${frame.r}] base case: left > right`);\n      return;\n    } else {\n      showMessage(`Frame [${frame.l},${frame.r}] proceeding`);\n      return;\n    }\n  } else if (frame.status === 'check_base' && frame.l <= frame.r) {\n    // compute mid\n    frame.mid = Math.floor((frame.l + frame.r) / 2);\n    frame.status = 'compare';\n    renderStack();\n    highlightLine(2);\n    stepCount++; stepCountEl.textContent = stepCount;\n    showMessage(`Frame [${frame.l},${frame.r}] mid = ${frame.mid} (A[mid]=${arr[frame.mid]})`);\n    return;\n  } else if (frame.status === 'compare') {\n    // compare\n    compCount++; compCountEl.textContent = compCount;\n    stepCount++; stepCountEl.textContent = stepCount;\n    const mVal = arr[frame.mid];\n    highlightLine(3);\n    if (mVal === target) {\n      // found: we want to clear stack and show found\n      showMessage(`Found target at index ${frame.mid}`);\n      // mark found and finish\n      state = 'done';\n      renderArray();\n      updateHighlights(frame.mid);\n      highlightLine(4);\n      running = false; clearAuto();\n      // clear stack and show result\n      stack = [];\n      renderStack();\n      return;\n    } else if (mVal < target) {\n      // search right half\n      frame.status = 'go_right';\n      highlightLine(5);\n      showMessage(`A[mid] < target → recurse into [${frame.mid+1}, ${frame.r}]`);\n      // push new frame\n      stack.push({l: frame.mid+1, r: frame.r, status:'enter', mid:null});\n      renderStack();\n      return;\n    } else {\n      frame.status = 'go_left';\n      highlightLine(7);\n      showMessage(`A[mid] > target → recurse into [${frame.l}, ${frame.mid-1}]`);\n      stack.push({l: frame.l, r: frame.mid-1, status:'enter', mid:null});\n      renderStack();\n      return;\n    }\n  } else if (frame.status === 'return_notfound') {\n    // this frame returns -1: pop it\n    stack.pop();\n    renderStack();\n    stepCount++; stepCountEl.textContent = stepCount;\n    showMessage(`Returning from frame (not found)`);\n    highlightLine(1);\n    return;\n  } else {\n    // any other status remove or continue\n    stack.pop();\n    renderStack();\n    return;\n  }\n}\n\n// Global step\nfunction step(){\n  if (mode === 'iterative') {\n    stepIterative();\n  } else {\n    stepRecursive();\n  }\n  updateHighlights();\n  renderStack();\n}\n\n// Auto-play\nfunction clearAuto(){\n  if (autoTimer) {\n    clearInterval(autoTimer); autoTimer = null;\n    playBtn.textContent = 'Play';\n  }\n}\nfunction play(){\n  if (running) { running = false; clearAuto(); return; }\n  running = true;\n  playBtn.textContent = 'Pause';\n  clearAuto();\n  autoTimer = setInterval(() => {\n    // If done, stop\n    if (state === 'done' || state === 'notfound') {\n      running = false;\n      clearAuto();\n      return;\n    }\n    // If target not set, pause\n    if (target === null || target === '') {\n      showMessage('Set a target first', true);\n      running = false; clearAuto(); return;\n    }\n    step();\n  }, speed);\n}\n\n// Fast run: run to completion quickly (no step UI)\nfunction fastRun(){\n  if (target === null || target === '') {\n    showMessage('Set a target first', true);\n    return;\n  }\n  if (mode === 'iterative') {\n    // simple while loop simulation updating visuals only at the end\n    left = 0; right = arr.length -1; mid = -1;\n    compCount = 0; stepCount = 0;\n    while (left <= right) {\n      mid = Math.floor((left + right)/2);\n      compCount++;\n      if (arr[mid] === target) {\n        showMessage('Found target at index ' + mid);\n        state = 'done';\n        updateHighlights(mid);\n        compCountEl.textContent = compCount;\n        stepCountEl.textContent = stepCount;\n        return;\n      } else if (arr[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    state = 'notfound';\n    showMessage('Not found');\n    updateHighlights();\n    compCountEl.textContent = compCount;\n    stepCountEl.textContent = stepCount;\n  } else {\n    // For recursion, perform normal recursion and animate result at end\n    const recSearch = (A,l,r) => {\n      if (l>r) return -1;\n      const m = Math.floor((l+r)/2);\n      if (A[m] === target) return m;\n      if (A[m] < target) return recSearch(A,m+1,r);\n      return recSearch(A,l,m-1);\n    };\n    const result = recSearch(arr,0,arr.length-1);\n    if (result >= 0) {\n      showMessage('Found target at index ' + result);\n      state = 'done';\n      updateHighlights(result);\n    } else {\n      showMessage('Not found');\n      state = 'notfound';\n      updateHighlights();\n    }\n  }\n}\n\n// Render recursion stack\nfunction renderStack(){\n  if (mode !== 'recursive') return;\n  stackArea.style.display = 'block';\n  stackFrames.innerHTML = '';\n  // show top first (last frame is top)\n  for (let i = stack.length - 1; i >= 0; i--){\n    const f = stack[i];\n    const div = document.createElement('div');\n    div.className = 'frame';\n    div.innerHTML = `<div>[${f.l}, ${f.r}]</div><div style=\"color:var(--muted)\">${f.mid===null?'mid: -': 'mid: '+f.mid}</div>`;\n    stackFrames.appendChild(div);\n  }\n  if (stack.length === 0 && state !== 'idle'){\n    const div = document.createElement('div');\n    div.className = 'frame';\n    div.textContent = 'Empty stack';\n    stackFrames.appendChild(div);\n  }\n}\n\n// UI bindings\ngenBtn.addEventListener('click', () => {\n  generateArray();\n});\nsetTargetBtn.addEventListener('click', () => {\n  setTarget(targetInput.value);\n});\nrandomTargetBtn.addEventListener('click', () => {\n  // pick random value between min and max (may or may not exist)\n  const minV = parseInt(minValInput.value,10) || 0;\n  const maxV = parseInt(maxValInput.value,10) || (minV+30);\n  const v = randInt(minV, maxV);\n  setTarget(v);\n});\nstepBtn.addEventListener('click', () => {\n  if (target === null || target === '') {\n    showMessage('Set a target first', true);\n    return;\n  }\n  step();\n});\nplayBtn.addEventListener('click', () => {\n  if (target === null || target === '') {\n    showMessage('Set a target first', true);\n    return;\n  }\n  play();\n});\nresetBtn.addEventListener('click', () => {\n  resetSimulation();\n});\nfastBtn.addEventListener('click', () => {\n  fastRun();\n});\nspeedInput.addEventListener('input', () => {\n  speed = parseInt(speedInput.value,10);\n  if (autoTimer){\n    // restart with new speed\n    clearAuto();\n    play();\n  }\n});\nmodeSelect.addEventListener('change', () => {\n  mode = modeSelect.value;\n  resetSimulation();\n});\n\n// Allow Enter key in target input to set\ntargetInput.addEventListener('keypress', (e) => {\n  if (e.key === 'Enter') {\n    setTarget(targetInput.value);\n  }\n});\n\n// Initialize default\ngenerateArray();\nrenderPseudocode();\nupdateHighlights();\nshowMessage('Ready. Generate array and set a target. Click Step to begin.');\n\n// Keep highlights updated if window resizes or content changes\nwindow.addEventListener('resize', updateHighlights);\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search"
    }
  ],
  "topic": "Binary Search",
  "hasFSM": false,
  "hasTest": true
}