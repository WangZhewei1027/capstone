{
  "id": "d80b8271-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:32.098Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>Kruskal's Algorithm — Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<style>\n  :root{\n    --bg:#f7f9fc;\n    --panel:#ffffff;\n    --accent:#2b6cb0;\n    --muted:#718096;\n    --good:#2f855a;\n    --bad:#e53e3e;\n    --check:#d69e2e;\n  }\n  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n  body{background:var(--bg);display:flex;flex-direction:column;}\n  header{padding:14px 20px;background:linear-gradient(90deg,#ffffff88, #f0f6ff);border-bottom:1px solid #e6eef8;}\n  h1{margin:0;font-weight:600;font-size:18px;color:#0b3a66;}\n  p.lead{margin:6px 0 0;color:var(--muted);font-size:13px;}\n  .container{flex:1;display:flex;gap:12px;padding:12px;max-height:calc(100% - 86px);}\n  .canvas-wrap{flex:1;background:linear-gradient(180deg,#ffffff,#f7fbff);border-radius:10px;padding:12px;box-shadow:0 4px 14px rgba(39,74,122,0.06);display:flex;flex-direction:column;min-width:0;}\n  .canvas-top{display:flex;gap:10px;align-items:center;margin-bottom:8px;}\n  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}\n  button, input[type=number], select{font:inherit;padding:8px 10px;border-radius:8px;border:1px solid #dbe7f5;background:var(--panel);color:#0b3a66;cursor:pointer;}\n  button:hover{filter:brightness(.98)}\n  button.primary{background:linear-gradient(180deg,var(--accent),#236199);color:white;border:none;box-shadow:0 6px 18px rgba(36,97,166,0.12);}\n  button.warn{background:linear-gradient(180deg,var(--check),#c48a1b);color:white;border:none;}\n  .small{padding:6px 8px;font-size:13px;border-radius:7px;}\n  .side{width:340px;min-width:260px;background:var(--panel);border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(38,70,120,0.06);overflow:auto;}\n  .panel-title{font-weight:600;color:#0b3a66;margin:0 0 8px 0;}\n  .info{font-size:13px;color:var(--muted);margin-bottom:8px;}\n  canvas{background:transparent;border-radius:8px;flex:1;display:block;}\n  .footer-row{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}\n  .edge-list{font-size:13px;border-radius:8px;padding:8px;background:#f6fbff;border:1px dashed #e6f0fb;max-height:220px;overflow:auto;}\n  .edge-row{display:flex;justify-content:space-between;padding:6px;border-radius:6px;margin-bottom:6px;}\n  .edge-row.consider{background:#fff9e6;border:1px solid #ffe8a8;}\n  .edge-row.accept{background:#e9f7ee;border:1px solid #c7efd0;}\n  .edge-row.reject{background:#fff1f1;border:1px solid #f8d6d6;}\n  .badge{font-weight:700;padding:4px 8px;border-radius:999px;font-size:12px;}\n  .small-muted{font-size:12px;color:var(--muted)}\n  label{font-size:13px;color:var(--muted);margin-right:6px}\n  .mode-toggle{display:inline-flex;border-radius:8px;overflow:hidden;border:1px solid #e2ecfb}\n  .mode-toggle button{border-radius:0;padding:8px 10px;background:transparent;border:none;}\n  .mode-toggle button.active{background:#e9f4ff;color:var(--accent);font-weight:600}\n  .legend{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}\n  .legend .item{display:flex;gap:6px;align-items:center;font-size:13px;color:var(--muted)}\n  .swatch{width:16px;height:12px;border-radius:3px;border:1px solid #bbb}\n  .status-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n  .mst-info{font-weight:700;color:var(--good);font-size:14px}\n  .uf-table{font-size:13px;line-height:1.6;background:#fbfdff;padding:8px;border-radius:8px;border:1px solid #e7f2ff}\n  .hint{font-size:12px;color:var(--muted);margin-top:8px}\n  .weight{font-weight:700;color:#0b3a66}\n  .small-input{width:72px}\n  @media (max-width:900px){\n    .container{flex-direction:column;padding:12px;}\n    .side{width:100%}\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Kruskal's Algorithm — Interactive Demo</h1>\n  <p class=\"lead\">Build or randomize a weighted undirected graph, then step through Kruskal’s algorithm to form a Minimum Spanning Tree (MST). Colors show components and accepted/rejected edges.</p>\n</header>\n\n<div class=\"container\">\n  <div class=\"canvas-wrap\">\n    <div class=\"canvas-top\">\n      <div class=\"controls\">\n        <button id=\"add-node\" class=\"small\">Add Node</button>\n        <button id=\"add-edge\" class=\"small\">Add Edge</button>\n        <button id=\"auto-edge\" class=\"small\">Auto-Edge Mode</button>\n        <button id=\"random-graph\" class=\"small\">Random Graph</button>\n        <label class=\"small-muted\">Nodes:\n          <input id=\"rand-n\" type=\"number\" class=\"small-input\" min=\"2\" max=\"30\" value=\"8\">\n        </label>\n        <label class=\"small-muted\">Density:\n          <select id=\"rand-d\">\n            <option value=\"0.3\">Sparse (30%)</option>\n            <option value=\"0.5\" selected>Medium (50%)</option>\n            <option value=\"0.8\">Dense (80%)</option>\n          </select>\n        </label>\n      </div>\n\n      <div style=\"flex:1\"></div>\n\n      <div class=\"controls\">\n        <label class=\"small-muted\">Speed:\n          <input id=\"speed\" type=\"range\" min=\"100\" max=\"2000\" step=\"100\" value=\"800\" />\n        </label>\n        <button id=\"step\" class=\"primary small\">Step</button>\n        <button id=\"run\" class=\"primary small\">Play</button>\n        <button id=\"reset\" class=\"small\">Reset</button>\n      </div>\n    </div>\n\n    <canvas id=\"canvas\" width=\"900\" height=\"560\"></canvas>\n\n    <div class=\"footer-row\">\n      <div class=\"small-muted\">Mode: <span id=\"mode-label\">Idle — Use controls above</span></div>\n      <div class=\"small-muted\">Click nodes to drag. When in \"Add Edge\" click one node then another to add an edge.</div>\n      <div style=\"flex:1\"></div>\n      <div class=\"small-muted\">Total MST Weight: <span id=\"mst-total\" class=\"weight\">0</span></div>\n    </div>\n  </div>\n\n  <aside class=\"side\">\n    <h3 class=\"panel-title\">Edges (sorted)</h3>\n    <div class=\"info\">Kruskal examines edges in ascending weight. Click an edge row to highlight it on the canvas.</div>\n    <div id=\"edge-list\" class=\"edge-list\"></div>\n\n    <div style=\"height:12px\"></div>\n\n    <h4 class=\"panel-title\">Union-Find (Disjoint Set)</h4>\n    <div class=\"info\">Current representative (root) for each node and component colors after unions.</div>\n    <div id=\"uf\" class=\"uf-table\"></div>\n\n    <div style=\"height:12px\"></div>\n\n    <h4 class=\"panel-title\">Legend & Status</h4>\n    <div class=\"legend\">\n      <div class=\"item\"><div class=\"swatch\" style=\"background:#dbeeff;border:1px solid #9fc6ff\"></div><div class=\"small-muted\">Unprocessed Edge</div></div>\n      <div class=\"item\"><div class=\"swatch\" style=\"background:#fff8e1;border:1px solid #ffd58a\"></div><div class=\"small-muted\">Considering</div></div>\n      <div class=\"item\"><div class=\"swatch\" style=\"background:#e6fbf0;border:1px solid #bfeed2\"></div><div class=\"small-muted\">Accepted (MST)</div></div>\n      <div class=\"item\"><div class=\"swatch\" style=\"background:#fff0f0;border:1px solid #f4c5c5\"></div><div class=\"small-muted\">Rejected</div></div>\n    </div>\n\n    <div style=\"height:12px\"></div>\n\n    <div class=\"status-row\">\n      <div class=\"mst-info\">MST edges: <span id=\"mst-count\">0</span></div>\n      <div class=\"small-muted\"> | Edges total: <span id=\"edge-count\">0</span></div>\n      <div style=\"flex:1\"></div>\n      <button id=\"explain\" class=\"small warn\">Help / Explanation</button>\n    </div>\n\n    <div class=\"hint\" id=\"hint\">\n      Tip: Add nodes and edges manually or generate a random graph. Use \"Step\" to walk Kruskal's decisions one edge at a time.\n    </div>\n\n  </aside>\n</div>\n\n<!-- Help Dialog -->\n<div id=\"help\" style=\"display:none;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:720px;max-width:94%;background:white;border-radius:10px;padding:18px;box-shadow:0 18px 50px rgba(30,60,110,0.25);z-index:200\">\n  <h3 style=\"margin:0 0 10px 0\">Kruskal's Algorithm — Quick Explanation</h3>\n  <div style=\"font-size:13px;color:#425a70\">\n    <p style=\"margin:0 0 8px 0\">Kruskal's algorithm finds a Minimum Spanning Tree (MST) of a weighted undirected graph by:</p>\n    <ol style=\"margin:0 0 8px 20px;line-height:1.5\">\n      <li>Sorting all edges by increasing weight.</li>\n      <li>Iterating edges from smallest to largest and adding an edge if it connects two different components (to avoid cycles).</li>\n      <li>Using a disjoint-set (union-find) structure to quickly check whether two vertices are already connected and to union their components when an edge is accepted.</li>\n    </ol>\n    <p style=\"margin:0 0 8px 0\">Stop when you have n-1 edges for n nodes. The resulting set of edges is a minimum-weight spanning tree when the graph is connected.</p>\n  </div>\n  <div style=\"text-align:right;margin-top:12px\">\n    <button id=\"close-help\" class=\"small primary\">Close</button>\n  </div>\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  let W = canvas.width, H = canvas.height;\n\n  // Graph data\n  let nodes = []; // {id,label,x,y,color}\n  let edges = []; // {id,u,v,w,status,color,highlight}\n  let nextNodeId = 0;\n  let nextEdgeId = 0;\n\n  // modes: 'idle','add-node','add-edge','auto-edge'\n  let mode = 'idle';\n  let addEdgeFirst = null;\n  let dragging = null;\n  let dragOffset = {x:0,y:0};\n\n  // Kruskal state\n  let sortedEdges = []; // indices into edges\n  let pointer = 0;\n  let uf = null;\n  let mst = []; // edge ids accepted\n  let running = false;\n  let timer = null;\n\n  // UI elements\n  const modeLabel = document.getElementById('mode-label');\n  const addNodeBtn = document.getElementById('add-node');\n  const addEdgeBtn = document.getElementById('add-edge');\n  const autoEdgeBtn = document.getElementById('auto-edge');\n  const randomBtn = document.getElementById('random-graph');\n  const randN = document.getElementById('rand-n');\n  const randD = document.getElementById('rand-d');\n  const stepBtn = document.getElementById('step');\n  const runBtn = document.getElementById('run');\n  const resetBtn = document.getElementById('reset');\n  const edgeListEl = document.getElementById('edge-list');\n  const ufEl = document.getElementById('uf');\n  const mstTotalEl = document.getElementById('mst-total');\n  const mstCountEl = document.getElementById('mst-count');\n  const edgeCountEl = document.getElementById('edge-count');\n  const speedEl = document.getElementById('speed');\n  const explainBtn = document.getElementById('explain');\n  const helpDialog = document.getElementById('help');\n  const closeHelp = document.getElementById('close-help');\n\n  // Utilities\n  function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }\n  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }\n\n  // Colors for components\n  function palette(i){\n    const cs = [\n      '#f97316','#06b6d4','#7c3aed','#ef4444','#10b981','#f59e0b','#0ea5e9','#6366f1','#db2777','#84cc16'\n    ];\n    return cs[i % cs.length];\n  }\n\n  // Union-Find\n  class UnionFind {\n    constructor(n){\n      this.parent = new Array(n);\n      this.rank = new Array(n).fill(0);\n      for(let i=0;i<n;i++) this.parent[i]=i;\n    }\n    find(a){\n      if(this.parent[a] !== a) this.parent[a] = this.find(this.parent[a]);\n      return this.parent[a];\n    }\n    union(a,b){\n      a = this.find(a); b = this.find(b);\n      if(a===b) return false;\n      if(this.rank[a] < this.rank[b]) [a,b]=[b,a];\n      this.parent[b]=a;\n      if(this.rank[a]===this.rank[b]) this.rank[a]++;\n      return true;\n    }\n  }\n\n  // Graph operations\n  function addNodeAt(x,y){\n    const n = { id: nextNodeId++, label: String.fromCharCode(65 + (nextNodeId-1) % 26), x, y, color: palette(nodes.length) };\n    nodes.push(n);\n    rebuildState();\n    draw();\n    return n;\n  }\n\n  function addEdgeBetween(uId,vId,w=null){\n    if(uId === vId) return null;\n    // avoid duplicate undirected edge\n    for(let e of edges){\n      if((e.u===uId && e.v===vId) || (e.u===vId && e.v===uId)) return null;\n    }\n    if(w==null) w = rand(1,20);\n    const e = { id: nextEdgeId++, u: uId, v: vId, w: w, status: 'unprocessed', color:'#bcd9ff' };\n    edges.push(e);\n    rebuildState();\n    draw();\n    return e;\n  }\n\n  function rebuildState(){\n    // reset Kruskal state (you must press Reset to start over)\n    sortedEdges = edges.slice().sort((a,b)=>a.w-b.w).map(e=>e.id);\n    pointer = 0;\n    uf = new UnionFind(nodes.length);\n    mst = [];\n    for(let e of edges){ e.status='unprocessed'; e.color='#bcd9ff'; }\n    updateUI();\n  }\n\n  function resetAlgorithm(){\n    if(timer) { clearInterval(timer); timer=null; running=false; runBtn.textContent='Play'; }\n    sortedEdges = edges.slice().sort((a,b)=>a.w-b.w).map(e=>e.id);\n    pointer = 0;\n    uf = new UnionFind(nodes.length);\n    mst = [];\n    for(let e of edges){ e.status='unprocessed'; e.color='#bcd9ff'; }\n    updateUI();\n    draw();\n  }\n\n  // Find edge object by id\n  function edgeById(id){ return edges.find(e=>e.id===id); }\n  function nodeById(id){ return nodes.find(n=>n.id===id); }\n\n  // Kruskal step\n  function kruskalStep(){\n    if(pointer >= sortedEdges.length){\n      running=false;\n      if(timer){ clearInterval(timer); timer=null; runBtn.textContent='Play'; }\n      modeLabel.textContent = 'Finished — all edges processed';\n      return;\n    }\n    // mark previous 'considering' (if any) as left as is (they should have been accepted/rejected)\n    // Consider next edge\n    const eid = sortedEdges[pointer];\n    const edge = edgeById(eid);\n    if(!edge){\n      pointer++;\n      return;\n    }\n    // mark as considering\n    edge.status = 'considering';\n    updateUI();\n    draw();\n    // small delay for visualization when auto; for step we do instantly\n    // Check ends\n    const uIndex = nodes.findIndex(n=>n.id===edge.u);\n    const vIndex = nodes.findIndex(n=>n.id===edge.v);\n    if(uIndex===-1 || vIndex===-1){\n      edge.status = 'reject'; // invalid\n      pointer++;\n      updateUI();\n      draw();\n      return;\n    }\n    if(uf.find(uIndex) !== uf.find(vIndex)){\n      // accept\n      uf.union(uIndex, vIndex);\n      edge.status = 'accept';\n      mst.push(edge.id);\n      edge.color = '#86e0a7';\n    } else {\n      edge.status = 'reject';\n      edge.color = '#f6b0b0';\n    }\n    pointer++;\n    updateUI();\n    draw();\n\n    // If MST complete (n-1 edges), we can stop early\n    if(mst.length >= Math.max(0, nodes.length-1)){\n      running=false;\n      if(timer){ clearInterval(timer); timer=null; runBtn.textContent='Play'; }\n      modeLabel.textContent = 'MST complete — n-1 edges selected';\n    }\n  }\n\n  function runAuto(){\n    if(running){\n      running=false;\n      if(timer){ clearInterval(timer); timer=null; }\n      runBtn.textContent='Play';\n      modeLabel.textContent='Paused';\n      return;\n    }\n    if(pointer >= sortedEdges.length || mst.length >= Math.max(0, nodes.length-1)){\n      resetAlgorithm();\n    }\n    running=true;\n    runBtn.textContent='Pause';\n    modeLabel.textContent='Running Kruskal...';\n    timer = setInterval(()=>{\n      kruskalStep();\n      if(!running || pointer>=sortedEdges.length || mst.length >= Math.max(0, nodes.length-1)){\n        running=false;\n        if(timer){ clearInterval(timer); timer=null; }\n        runBtn.textContent='Play';\n      }\n    }, Number(speedEl.value));\n  }\n\n  // UI update\n  function updateUI(){\n    // edge list sorted display\n    edgeListEl.innerHTML = '';\n    const sorted = edges.slice().sort((a,b)=>a.w-b.w);\n    edgeCountEl.textContent = edges.length;\n    for(let e of sorted){\n      const div = document.createElement('div');\n      div.className = 'edge-row';\n      if(e.status==='considering') div.classList.add('consider');\n      if(e.status==='accept') div.classList.add('accept');\n      if(e.status==='reject') div.classList.add('reject');\n      div.style.cursor = 'pointer';\n      const u = nodeById(e.u), v = nodeById(e.v);\n      const left = document.createElement('div');\n      left.textContent = `${u ? u.label : '?'} — ${v ? v.label : '?'} (id:${e.id})`;\n      left.style.color = '#244e7a';\n      const right = document.createElement('div');\n      right.innerHTML = `<span class=\"small-muted\">w=</span><span class=\"weight\">${e.w}</span>`;\n      div.appendChild(left);\n      div.appendChild(right);\n      div.addEventListener('click', ()=>{\n        // center/highlight this edge briefly\n        for(let ed of edges) ed.highlight = false;\n        e.highlight = true;\n        draw();\n        setTimeout(()=>{ e.highlight = false; draw(); }, 900);\n      });\n      edgeListEl.appendChild(div);\n    }\n\n    // UF display\n    // Build mapping from index to parent and color by representative\n    const nodeIndex = (id) => nodes.findIndex(n=>n.id===id);\n    let content = '<div style=\"display:flex;gap:8px;flex-wrap:wrap\">';\n    if(nodes.length===0) content += '<div style=\"color:var(--muted)\">No nodes</div>';\n    else {\n      // assign colors by rep\n      let repColor = {};\n      let repList = [];\n      for(let i=0;i<nodes.length;i++){\n        const r = uf.find ? uf.find(i) : i;\n        if(!(r in repColor)){\n          repColor[r] = palette(repList.length);\n          repList.push(r);\n        }\n      }\n      for(let i=0;i<nodes.length;i++){\n        const n = nodes[i];\n        const r = uf.find ? uf.find(i) : i;\n        content += `<div style=\"border-radius:8px;padding:6px;background:#fbfdff;border:1px solid #e7f2ff;min-width:86px\">\n          <div style=\"font-size:13px;font-weight:700;color:#16324a\">${n.label} (idx ${i})</div>\n          <div style=\"font-size:12px;color:var(--muted)\">rep: <span style=\"color:${repColor[r]};font-weight:700\">${nodes[r] ? nodes[r].label+'('+r+')' : r}</span></div>\n        </div>`;\n      }\n    }\n    content += '</div>';\n    ufEl.innerHTML = content;\n\n    // MST info\n    mstCountEl.textContent = mst.length;\n    let total = 0;\n    for(let id of mst){\n      const e = edges.find(x=>x.id===id);\n      if(e) total += e.w;\n    }\n    mstTotalEl.textContent = total;\n  }\n\n  // Drawing\n  function draw(){\n    ctx.clearRect(0,0,W,H);\n    // draw edges\n    for(let e of edges){\n      const nu = nodeById(e.u);\n      const nv = nodeById(e.v);\n      if(!nu || !nv) continue;\n      const hx = e.highlight ? 6 : 0;\n      // edge line\n      ctx.beginPath();\n      ctx.moveTo(nu.x, nu.y);\n      ctx.lineTo(nv.x, nv.y);\n      ctx.lineWidth = e.highlight ? 5 : 3;\n      let stroke = '#cfe9ff';\n      if(e.status==='unprocessed') stroke = '#bcd9ff';\n      else if(e.status==='considering') stroke = '#ffd389';\n      else if(e.status==='accept') stroke = '#86e0a7';\n      else if(e.status==='reject') stroke = '#f6b0b0';\n      ctx.strokeStyle = stroke;\n      ctx.lineCap = 'round';\n      ctx.stroke();\n\n      // weight circle: compute midpoint\n      const mx = (nu.x + nv.x)/2;\n      const my = (nu.y + nv.y)/2;\n      ctx.beginPath();\n      ctx.fillStyle = '#ffffff';\n      ctx.strokeStyle = '#c9e2ff';\n      ctx.lineWidth = 1;\n      ctx.roundRect ? ctx.roundRect(mx-18,my-12,36,24,6) : null;\n      // fallback rounded rect\n      roundRect(ctx, mx-18,my-12,36,24,6);\n      ctx.fill();\n      ctx.stroke();\n\n      ctx.fillStyle = '#0b3a66';\n      ctx.font = '12px system-ui, sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(e.w), mx, my);\n\n      // If considering, draw dashed highlight near middle\n      if(e.status==='considering'){\n        ctx.beginPath();\n        ctx.strokeStyle = '#ffbe5a';\n        ctx.setLineDash([6,4]);\n        ctx.moveTo(nu.x, nu.y);\n        ctx.lineTo(nv.x, nv.y);\n        ctx.stroke();\n        ctx.setLineDash([]);\n      }\n    }\n\n    // draw nodes\n    for(let i=0;i<nodes.length;i++){\n      const n = nodes[i];\n      // fill color by representative\n      let fill = n.color;\n      if(uf){\n        const r = uf.find(i);\n        const idx = r % 10;\n        fill = palette(idx);\n      }\n      // outer ring\n      ctx.beginPath();\n      ctx.fillStyle = '#fff';\n      ctx.strokeStyle = '#dbeafe';\n      ctx.lineWidth = 3;\n      ctx.arc(n.x, n.y, 20, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n\n      // inner circle\n      ctx.beginPath();\n      ctx.arc(n.x, n.y, 14, 0, Math.PI*2);\n      ctx.fillStyle = fill;\n      ctx.fill();\n\n      // label\n      ctx.fillStyle = '#06223a';\n      ctx.font = 'bold 13px system-ui, sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(n.label, n.x, n.y);\n    }\n  }\n\n  // small helper for rounded rect (if ctx.roundRect is not available)\n  function roundRect(ctx, x, y, w, h, r){\n    if(w<2*r) r=w/2;\n    if(h<2*r) r=h/2;\n    ctx.beginPath();\n    ctx.moveTo(x+r, y);\n    ctx.arcTo(x+w, y, x+w, y+h, r);\n    ctx.arcTo(x+w, y+h, x, y+h, r);\n    ctx.arcTo(x, y+h, x, y, r);\n    ctx.arcTo(x, y, x+w, y, r);\n    ctx.closePath();\n  }\n\n  // Event handlers\n  canvas.addEventListener('mousedown', (e)=>{\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    // check nodes first\n    for(let i=nodes.length-1;i>=0;i--){\n      const n = nodes[i];\n      if(Math.hypot(n.x-x,n.y-y) <= 22){\n        if(mode === 'add-edge'){\n          if(addEdgeFirst == null){\n            addEdgeFirst = n.id;\n            modeLabel.textContent = `Add edge: selected ${n.label}. Click another node.`;\n            return;\n          } else {\n            if(addEdgeFirst === n.id){\n              modeLabel.textContent = 'Cannot create self-edge. Choose another node.';\n              addEdgeFirst = null;\n              return;\n            }\n            // prompt for weight\n            const w = Number(prompt(`Weight for edge ${nodeById(addEdgeFirst).label} — ${n.label}:`, String(rand(1,20))));\n            if(!isNaN(w) && w !== null){\n              addEdgeBetween(addEdgeFirst, n.id, Math.max(0, Math.floor(w)));\n            }\n            addEdgeFirst = null;\n            modeLabel.textContent = 'Add Edge mode — click nodes to add edges';\n            return;\n          }\n        } else if(mode === 'auto-edge'){\n          // Connect to nearest or create random weight edge from this node to another newly created?\n          // We'll in auto-edge mode create a random edge from this node to another node chosen randomly\n          if(nodes.length < 2){\n            modeLabel.textContent = 'Need at least 2 nodes for edges.';\n            return;\n          }\n          // pick random other node\n          let other = n;\n          while(other.id === n.id) other = nodes[rand(0,nodes.length-1)];\n          addEdgeBetween(n.id, other.id, rand(1,20));\n          return;\n        } else {\n          // start dragging\n          dragging = n;\n          dragOffset.x = x - n.x;\n          dragOffset.y = y - n.y;\n          return;\n        }\n      }\n    }\n    // If not on node\n    if(mode === 'add-node'){\n      addNodeAt(x,y);\n    } else {\n      // clicking empty space cancels addEdge selection\n      addEdgeFirst = null;\n    }\n  });\n\n  canvas.addEventListener('mousemove', (e)=>{\n    if(!dragging) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    dragging.x = Math.max(24, Math.min(W-24, x - dragOffset.x));\n    dragging.y = Math.max(24, Math.min(H-24, y - dragOffset.y));\n    draw();\n  });\n\n  canvas.addEventListener('mouseup', (e)=>{\n    dragging = null;\n  });\n\n  window.addEventListener('resize', ()=>{\n    // keep canvas size stable relative to container\n    const rect = canvas.getBoundingClientRect();\n    W = canvas.width = rect.width;\n    H = canvas.height = rect.height;\n    draw();\n  });\n\n  // Buttons\n  addNodeBtn.addEventListener('click', ()=>{\n    mode = (mode === 'add-node') ? 'idle' : 'add-node';\n    modeLabel.textContent = mode === 'add-node' ? 'Add Node mode — click canvas to add nodes' : 'Idle';\n    addNodeBtn.classList.toggle('active', mode==='add-node');\n    addEdgeBtn.classList.remove('active');\n    autoEdgeBtn.classList.remove('active');\n    if(mode!=='add-edge') addEdgeFirst = null;\n  });\n\n  addEdgeBtn.addEventListener('click', ()=>{\n    mode = (mode === 'add-edge') ? 'idle' : 'add-edge';\n    modeLabel.textContent = mode === 'add-edge' ? 'Add Edge mode — click two nodes to add an edge' : 'Idle';\n    addEdgeBtn.classList.toggle('active', mode==='add-edge');\n    addNodeBtn.classList.remove('active');\n    autoEdgeBtn.classList.remove('active');\n    addEdgeFirst = null;\n  });\n\n  autoEdgeBtn.addEventListener('click', ()=>{\n    mode = (mode === 'auto-edge') ? 'idle' : 'auto-edge';\n    modeLabel.textContent = mode === 'auto-edge' ? 'Auto-Edge mode — click a node to auto-add an edge to another node' : 'Idle';\n    autoEdgeBtn.classList.toggle('active', mode==='auto-edge');\n    addNodeBtn.classList.remove('active');\n    addEdgeBtn.classList.remove('active');\n    addEdgeFirst = null;\n  });\n\n  randomBtn.addEventListener('click', ()=>{\n    // generate nodes in circle\n    const n = Math.max(2, Math.min(30, Number(randN.value) || 8));\n    const density = Number(randD.value);\n    nodes = [];\n    edges = [];\n    nextNodeId = 0; nextEdgeId = 0;\n    const cx = W/2, cy = H/2;\n    const r = Math.min(W,H) / 2.6;\n    for(let i=0;i<n;i++){\n      const ang = (i/n) * Math.PI*2;\n      const x = cx + Math.cos(ang) * (r * (0.6 + Math.random()*0.4));\n      const y = cy + Math.sin(ang) * (r * (0.6 + Math.random()*0.4));\n      addNodeAt(x,y);\n    }\n    // create edges randomly according to density\n    for(let i=0;i<n;i++){\n      for(let j=i+1;j<n;j++){\n        if(Math.random() < density){\n          addEdgeBetween(nodes[i].id, nodes[j].id, rand(1,20));\n        }\n      }\n    }\n    rebuildState();\n    draw();\n  });\n\n  stepBtn.addEventListener('click', ()=>{\n    if(nodes.length === 0){ modeLabel.textContent = 'No nodes present'; return; }\n    if(!uf || sortedEdges.length===0) rebuildState();\n    running=false;\n    if(timer){ clearInterval(timer); timer=null; runBtn.textContent='Play'; }\n    kruskalStep();\n  });\n\n  runBtn.addEventListener('click', ()=>{\n    if(!uf || sortedEdges.length===0) rebuildState();\n    runAuto();\n  });\n\n  resetBtn.addEventListener('click', ()=>{\n    resetAlgorithm();\n    modeLabel.textContent = 'Algorithm reset';\n  });\n\n  explainBtn.addEventListener('click', ()=>{\n    helpDialog.style.display='block';\n  });\n  closeHelp.addEventListener('click', ()=> helpDialog.style.display='none');\n\n  // Edge list click highlight (delegated by updateUI using event listeners created there)\n\n  // init sample graph\n  function initSample(){\n    nodes = []; edges = []; nextNodeId=0; nextEdgeId=0;\n    const cols = 3;\n    const rows = 3;\n    const margin = 60;\n    const nx = 3, ny = 3;\n    for(let i=0;i<9;i++){\n      const row = Math.floor(i/3), col = i%3;\n      const x = 100 + col*250 + (Math.random()-0.5)*30;\n      const y = 80 + row*150 + (Math.random()-0.5)*30;\n      addNodeAt(x,y);\n    }\n    // connect some edges\n    const all = nodes.map(n=>n.id);\n    const pairs = [\n      [0,1],[1,2],[0,3],[1,4],[2,5],[3,4],[4,5],[3,6],[4,7],[5,8],[6,7],[7,8]\n    ];\n    for(let p of pairs){\n      addEdgeBetween(nodes[p[0]].id, nodes[p[1]].id, rand(1,20));\n    }\n    rebuildState();\n    draw();\n  }\n\n  // initial\n  initSample();\n\n  // keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === ' ') { e.preventDefault(); runBtn.click(); }\n    if(e.key === 'Enter') { stepBtn.click(); }\n    if(e.key === 'r' && e.ctrlKey) { randomBtn.click(); }\n  });\n\n  // small polyfill for roundRect if needed\n  if(!CanvasRenderingContext2D.prototype.roundRect){\n    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){\n      roundRect(this,x,y,w,h,r);\n    };\n  }\n\n  // Initial UI update\n  rebuildState();\n  draw();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}