{
  "id": "d80c93e0-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:23.450Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Two Pointers",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Two Pointers — Interactive Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    :root{\n      --bg:#0f1724;\n      --card:#0b1220;\n      --accent:#2dd4bf;\n      --muted:#98a8b9;\n      --panel:#071025;\n      --box:#0b1b2a;\n      --white:#e6eef6;\n    }\n    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    html,body{height:100%;margin:0;background:linear-gradient(180deg,#051025 0%, #071227 50%, #081624 100%);color:var(--white)}\n    header{padding:18px 28px;border-bottom:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;gap:18px}\n    h1{font-size:18px;margin:0}\n    .container{display:grid;grid-template-columns:360px 1fr;gap:18px;padding:20px;max-width:1200px;margin:18px auto}\n    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03)}\n    .left{height:calc(100vh - 140px);overflow:auto;padding-bottom:30px}\n    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}\n    input[type=text],textarea,select{width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:rgba(255,255,255,0.02);color:var(--white);outline:none}\n    .controls{display:flex;gap:8px;margin-top:10px}\n    button{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);color:var(--white);padding:8px 10px;border-radius:8px;cursor:pointer}\n    button.primary{background:linear-gradient(90deg,var(--accent),#60a5fa);color:#001219;border:none}\n    .small{padding:6px 8px;font-size:13px}\n    .algo-list{display:flex;flex-direction:column;gap:6px}\n    .algo-item{display:flex;align-items:center;gap:10px;padding:8px;border-radius:8px;cursor:pointer}\n    .algo-item input{transform:scale(1.1)}\n    .visual{padding:16px;min-height:320px;display:flex;flex-direction:column;gap:14px}\n    .array-row{position:relative;padding:14px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));display:flex;gap:10px;align-items:flex-end;overflow:auto}\n    .cell{min-width:48px;height:48px;border-radius:8px;background:var(--box);display:flex;align-items:center;justify-content:center;color:var(--white);font-weight:600;border:1px solid rgba(255,255,255,0.03);position:relative}\n    .cell.small{min-width:36px;height:36px;font-weight:600}\n    .pointer{position:absolute;top:-28px;font-size:12px;padding:4px 8px;border-radius:6px;color:#001219;background:var(--accent);transform:translateX(-50%);white-space:nowrap}\n    .pointer.r{background:#60a5fa;color:#001219}\n    .cell.marked{outline:3px solid rgba(45,212,191,0.12)}\n    .cell.found{outline:3px solid rgba(96,165,250,0.18)}\n    .description{padding:12px;border-radius:10px;background:rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}\n    pre{background:rgba(0,0,0,0.18);padding:10px;border-radius:8px;overflow:auto;font-size:12px;color:#e6f7f3}\n    .statusbar{display:flex;justify-content:space-between;gap:12px;align-items:center;margin-top:10px;font-size:13px;color:var(--muted)}\n    .footer{margin-top:12px;color:var(--muted);font-size:12px}\n    .result{font-weight:700;color:var(--white)}\n    .log{max-height:160px;overflow:auto;margin-top:10px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.01);font-size:13px}\n    .speed{display:flex;align-items:center;gap:8px}\n    @media (max-width:880px){\n      .container{grid-template-columns:1fr;padding:12px}\n      .left{height:auto}\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Two Pointers — Interactive Visualizer</h1>\n    <div style=\"margin-left:auto;color:var(--muted);font-size:13px\">Learn pointer movement patterns used to solve array/string problems efficiently</div>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"panel left\">\n      <div style=\"display:flex;gap:8px;align-items:center;justify-content:space-between\">\n        <div>\n          <label>Choose algorithm</label>\n          <select id=\"algoSelect\">\n            <option value=\"pairSum\">Pair Sum (sorted) — find two numbers that add to target</option>\n            <option value=\"removeDuplicates\">Remove Duplicates (sorted) — in-place</option>\n            <option value=\"reverseString\">Reverse String — swap with two pointers</option>\n            <option value=\"maxContainer\">Container With Most Water — max area</option>\n            <option value=\"partitionParity\">Partition by Parity — evens left, odds right</option>\n          </select>\n        </div>\n        <div style=\"width:160px\">\n          <label>Animation speed</label>\n          <div class=\"speed\"><input id=\"speed\" type=\"range\" min=\"50\" max=\"1500\" value=\"500\"><span id=\"speedLabel\" style=\"width:56px;text-align:right;color:var(--muted);font-size:13px\">500 ms</span></div>\n        </div>\n      </div>\n\n      <div style=\"margin-top:12px\">\n        <label id=\"inputLabel\">Input array (numbers separated by commas)</label>\n        <input id=\"inputArray\" type=\"text\" value=\"1,2,3,4,5,6,7,8,9\">\n        <div style=\"display:flex;gap:8px;margin-top:8px\">\n          <button id=\"randomBtn\" class=\"small\">Random</button>\n          <button id=\"sortBtn\" class=\"small\">Sort</button>\n          <button id=\"parseBtn\" class=\"small primary\">Run & Build Steps</button>\n        </div>\n      </div>\n\n      <div id=\"targetArea\" style=\"margin-top:12px;display:block\">\n        <label>Target value (for Pair Sum)</label>\n        <input id=\"targetInput\" type=\"text\" value=\"10\">\n      </div>\n\n      <div style=\"margin-top:12px\">\n        <label>Controls</label>\n        <div class=\"controls\">\n          <button id=\"playBtn\" class=\"small primary\">Play</button>\n          <button id=\"pauseBtn\" class=\"small\">Pause</button>\n          <button id=\"stepBack\" class=\"small\">Step ◀</button>\n          <button id=\"stepForward\" class=\"small\">Step ▶</button>\n          <button id=\"resetBtn\" class=\"small\">Reset</button>\n        </div>\n      </div>\n\n      <div style=\"margin-top:12px\">\n        <label>Quick presets</label>\n        <div style=\"display:flex;gap:8px;flex-wrap:wrap\">\n          <button class=\"small\" data-preset=\"1,2,3,4,5,6,7\">1..7</button>\n          <button class=\"small\" data-preset=\"2,3,4,5,9,11\">2,3,4,5,9,11</button>\n          <button class=\"small\" data-preset=\"5,4,3,2,1\">5,4,3,2,1</button>\n          <button class=\"small\" data-preset=\"20,18,17,6,5,4,2\">20,18,17,6,5,4,2</button>\n          <button class=\"small\" data-preset=\"1,1,2,2,3,3,4\">1,1,2,2,3,3,4</button>\n        </div>\n      </div>\n\n      <div style=\"margin-top:14px\">\n        <label>Description</label>\n        <div class=\"description\" id=\"algoDesc\">\n          Two pointers is a technique where you maintain two indices (pointers) that move through a data structure to satisfy some condition. It is commonly used on sorted arrays or when you need to operate from both ends. Choose an algorithm and press \"Run & Build Steps\" to see pointer movements.\n        </div>\n      </div>\n\n      <div style=\"margin-top:14px\">\n        <label>Complexity</label>\n        <div class=\"description\" id=\"algoComplexity\">\n          Time: O(n) typical for two-pointer passes. Space: O(1) extra (in-place), unless algorithm requires extra output.\n        </div>\n      </div>\n\n      <div style=\"margin-top:14px\">\n        <label>Code (pseudo/JS)</label>\n        <pre id=\"codeBlock\">\n// Code preview will appear here for the selected algorithm\n        </pre>\n      </div>\n\n    </div>\n\n    <div class=\"panel visual\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center;gap:12px\">\n        <div style=\"font-weight:700\">Visualization</div>\n        <div style=\"display:flex;gap:8px;align-items:center\">\n          <div class=\"statusbar\" style=\"gap:8px\">\n            <div>Step: <span id=\"stepIdx\">0</span>/<span id=\"stepMax\">0</span></div>\n            <div>Ops: <span id=\"opsCount\">0</span></div>\n            <div>Result: <span class=\"result\" id=\"resultText\">—</span></div>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"array-row\" id=\"arrayRow\" style=\"min-height:96px\">\n        <!-- cells injected here -->\n      </div>\n\n      <div id=\"annotation\" class=\"description\">Build steps to begin.</div>\n\n      <div id=\"log\" class=\"log\" style=\"display:none\"></div>\n\n      <div style=\"margin-top:auto\">\n        <div style=\"display:flex;gap:12px;align-items:center;justify-content:space-between\">\n          <div style=\"font-size:13px;color:var(--muted)\">Use Step buttons or Play to animate. You can edit the input and rebuild steps anytime.</div>\n          <div style=\"font-size:12px;color:var(--muted)\"><em>Two Pointers</em> — small, simple demos — educational use</div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<script>\n(() => {\n  // Utilities\n  const qs = s => document.querySelector(s);\n  const qsa = s => Array.from(document.querySelectorAll(s));\n\n  // Elements\n  const algoSelect = qs('#algoSelect');\n  const inputArray = qs('#inputArray');\n  const parseBtn = qs('#parseBtn');\n  const arrayRow = qs('#arrayRow');\n  const annotation = qs('#annotation');\n  const codeBlock = qs('#codeBlock');\n  const speed = qs('#speed');\n  const speedLabel = qs('#speedLabel');\n  const playBtn = qs('#playBtn');\n  const pauseBtn = qs('#pauseBtn');\n  const stepForward = qs('#stepForward');\n  const stepBack = qs('#stepBack');\n  const resetBtn = qs('#resetBtn');\n  const stepIdxEl = qs('#stepIdx');\n  const stepMaxEl = qs('#stepMax');\n  const opsCountEl = qs('#opsCount');\n  const resultText = qs('#resultText');\n  const randomBtn = qs('#randomBtn');\n  const sortBtn = qs('#sortBtn');\n  const targetArea = qs('#targetArea');\n  const targetInput = qs('#targetInput');\n  const algoDesc = qs('#algoDesc');\n  const algoComplexity = qs('#algoComplexity');\n  const logEl = qs('#log');\n  const presets = qsa('[data-preset]');\n\n  // State\n  let steps = []; // each step: {arr, left, right, i, j, desc, marked:[], found:boolean, result}\n  let currentStep = -1;\n  let timer = null;\n  let playInterval = 500;\n  let ops = 0;\n\n  // Algorithms definitions\n  const algorithms = {\n    pairSum: {\n      name: 'Pair Sum (sorted)',\n      short: 'Find two numbers that add to target using left/right pointer',\n      complexity: 'Time: O(n). Space: O(1). Requires sorted array (or sort first).',\n      code:\n`// Sorted array two-pointer pair sum (target)\nlet l = 0, r = arr.length-1;\nwhile (l < r) {\n  const s = arr[l] + arr[r];\n  if (s === target) return [l, r];\n  if (s < target) l++;\n  else r--;\n}\nreturn null;`,\n      build: (inputArr, opts) => {\n        const arr = inputArr.slice();\n        const target = opts.target;\n        let l = 0, r = arr.length - 1;\n        const out = [];\n        let found = false;\n        let opsLocal = 0;\n        out.push(snapshot(arr, l, r, `Start (target=${target})`));\n        while (l < r) {\n          opsLocal++;\n          const s = arr[l] + arr[r];\n          out.push(snapshot(arr, l, r, `Compare arr[${l}] + arr[${r}] = ${arr[l]} + ${arr[r]} = ${s}`));\n          if (s === target) {\n            out.push(snapshot(arr, l, r, `Found! Indices ${l} and ${r}`, {found:true, result:[l,r]}));\n            found = true;\n            break;\n          }\n          if (s < target) {\n            l++;\n            out.push(snapshot(arr, l, r, `Sum < target => move left pointer right to ${l}`));\n          } else {\n            r--;\n            out.push(snapshot(arr, l, r, `Sum > target => move right pointer left to ${r}`));\n          }\n        }\n        if (!found) {\n          out.push(snapshot(arr, l, r, `No pair found`));\n        }\n        return {steps:out, ops:opsLocal, result: found ? out.find(s=>s.found).result : null};\n      },\n    },\n\n    removeDuplicates: {\n      name: 'Remove Duplicates (sorted)',\n      short: 'In-place remove duplicates from sorted array. Return new length',\n      complexity: 'Time: O(n). Space: O(1). Modifies array in place.',\n      code:\n`// Remove duplicates from sorted array in-place\nlet i = 0; // slow pointer\nfor (let j = 1; j < arr.length; j++) {\n  if (arr[j] !== arr[i]) {\n    i++;\n    arr[i] = arr[j];\n  }\n}\nreturn i + 1;`,\n      build: (inputArr) => {\n        const arr = inputArr.slice();\n        const out = [];\n        if (arr.length === 0) {\n          out.push(snapshot(arr, -1, -1, 'Empty array'));\n          return {steps:out, ops:0, result:0};\n        }\n        let i = 0;\n        out.push(snapshot(arr, i, 1, `Start: i=0 (position of last unique)`));\n        let opsLocal = 0;\n        for (let j = 1; j < arr.length; j++) {\n          opsLocal++;\n          out.push(snapshot(arr, i, j, `Compare arr[${j}]=${arr[j]} with arr[${i}]=${arr[i]}`));\n          if (arr[j] !== arr[i]) {\n            i++;\n            arr[i] = arr[j];\n            out.push(snapshot(arr.slice(), i, j, `Unique found, copy arr[${j}] to arr[${i}]`, {marked:[i]}));\n          } else {\n            out.push(snapshot(arr.slice(), i, j, `Duplicate — skip`));\n          }\n        }\n        out.push(snapshot(arr.slice(), i, arr.length-1, `Done. New length = ${i+1}`, {result:i+1}));\n        return {steps:out, ops:opsLocal, result:i+1};\n      }\n    },\n\n    reverseString: {\n      name: 'Reverse String',\n      short: 'Swap characters with two pointers from both ends',\n      complexity: 'Time: O(n/2). Space: O(1) if using char array.',\n      code:\n`let l = 0, r = s.length - 1;\nwhile (l < r) {\n  // swap s[l] and s[r]\n  const tmp = s[l];\n  s[l] = s[r];\n  s[r] = tmp;\n  l++; r--;\n}\nreturn s;`,\n      build: (inputStr) => {\n        // inputStr is an array of characters or a string\n        const arr = Array.from(inputStr.join ? inputStr : String(inputStr));\n        const out = [];\n        let l = 0, r = arr.length - 1;\n        out.push(snapshot(arr.slice(), l, r, `Start`));\n        let opsLocal = 0;\n        while (l < r) {\n          opsLocal++;\n          out.push(snapshot(arr.slice(), l, r, `Swap arr[${l}]='${arr[l]}' and arr[${r}]='${arr[r]}'`));\n          const tmp = arr[l];\n          arr[l] = arr[r];\n          arr[r] = tmp;\n          out.push(snapshot(arr.slice(), l, r, `After swap`, {marked:[l,r]}));\n          l++; r--;\n        }\n        out.push(snapshot(arr.slice(), l, r, `Done. Result: \"${arr.join('')}\"`, {result:arr.join('')}));\n        return {steps:out, ops:opsLocal, result:arr.join('')};\n      }\n    },\n\n    maxContainer: {\n      name: 'Container With Most Water',\n      short: 'Keep left and right pointers; compute area and move smaller height pointer',\n      complexity: 'Time: O(n). Space: O(1).',\n      code:\n`let l = 0, r = height.length - 1;\nlet maxArea = 0;\nwhile (l < r) {\n  const area = Math.min(height[l], height[r]) * (r - l);\n  maxArea = Math.max(maxArea, area);\n  if (height[l] < height[r]) l++; else r--;\n}\nreturn maxArea;`,\n      build: (inputArr) => {\n        const arr = inputArr.slice();\n        const out = [];\n        let l = 0, r = arr.length - 1;\n        let maxArea = 0, best = null;\n        out.push(snapshot(arr.slice(), l, r, `Start`));\n        let opsLocal = 0;\n        while (l < r) {\n          opsLocal++;\n          const hL = arr[l], hR = arr[r];\n          const area = Math.min(hL, hR) * (r - l);\n          out.push(snapshot(arr.slice(), l, r, `Compute area = min(${hL},${hR}) * (${r}-${l}) = ${area}`));\n          if (area > maxArea) {\n            maxArea = area;\n            best = [l, r, area];\n            out.push(snapshot(arr.slice(), l, r, `New max area ${area} at (${l},${r})`, {marked:[l,r], result:area}));\n          }\n          if (hL < hR) {\n            l++;\n            out.push(snapshot(arr.slice(), l, r, `Move left pointer to ${l} (height ${hL} < ${hR})`));\n          } else {\n            r--;\n            out.push(snapshot(arr.slice(), l, r, `Move right pointer to ${r} (height ${hR} <= ${hL})`));\n          }\n        }\n        out.push(snapshot(arr.slice(), l, r, `Done. Max area = ${maxArea}`, {result:maxArea}));\n        return {steps:out, ops:opsLocal, result:maxArea};\n      }\n    },\n\n    partitionParity: {\n      name: 'Partition by Parity',\n      short: 'Place even numbers left and odd right using two pointers',\n      complexity: 'Time: O(n). Space: O(1).',\n      code:\n`let l = 0, r = arr.length - 1;\nwhile (l < r) {\n  while (l < r && arr[l] % 2 === 0) l++;\n  while (l < r && arr[r] % 2 !== 0) r--;\n  if (l < r) swap(arr, l, r), l++, r--;\n}\nreturn arr;`,\n      build: (inputArr) => {\n        const arr = inputArr.slice();\n        const out = [];\n        let l = 0, r = arr.length - 1;\n        out.push(snapshot(arr.slice(), l, r, 'Start'));\n        let opsLocal = 0;\n        while (l < r) {\n          opsLocal++;\n          if (arr[l] % 2 === 0) {\n            out.push(snapshot(arr.slice(), l, r, `arr[${l}]=${arr[l]} is even -> advance left`));\n            l++; continue;\n          }\n          if (arr[r] % 2 !== 0) {\n            out.push(snapshot(arr.slice(), l, r, `arr[${r}]=${arr[r]} is odd -> move right`));\n            r--; continue;\n          }\n          // now arr[l] is odd, arr[r] is even => swap\n          out.push(snapshot(arr.slice(), l, r, `Swap odd arr[${l}]=${arr[l]} with even arr[${r}]=${arr[r]}`));\n          const tmp = arr[l]; arr[l] = arr[r]; arr[r] = tmp;\n          out.push(snapshot(arr.slice(), l, r, `After swap`, {marked:[l,r]}));\n          l++; r--;\n        }\n        out.push(snapshot(arr.slice(), l, r, `Done. Partitioned array`, {result:arr.slice()}));\n        return {steps:out, ops:opsLocal, result:arr.slice()};\n      }\n    }\n  };\n\n  function snapshot(arr, left=-1, right=-1, desc='', opts={}) {\n    return {\n      arr: Array.isArray(arr) ? arr.slice() : JSON.parse(JSON.stringify(arr)),\n      left: left,\n      right: right,\n      desc: desc || '',\n      marked: opts.marked || [],\n      found: !!opts.found,\n      result: opts.result !== undefined ? opts.result : null\n    };\n  }\n\n  // UI helpers\n  function renderArrayStep(step) {\n    arrayRow.innerHTML = '';\n    if (!step) return;\n    const arr = step.arr;\n    // adapt cell size for long arrays\n    const cellClass = arr.length > 14 ? 'cell small' : 'cell';\n    arr.forEach((v,i) => {\n      const c = document.createElement('div');\n      c.className = cellClass;\n      c.textContent = String(v);\n      if (step.marked && step.marked.includes(i)) c.classList.add('marked');\n      if (step.found && (i===step.left || i===step.right)) c.classList.add('found');\n      arrayRow.appendChild(c);\n    });\n    // pointers as absolute positioned elements above the corresponding cell\n    placePointer('L', step.left, 'pointer l');\n    placePointer('R', step.right, 'pointer r');\n    // description\n    annotation.textContent = step.desc || '';\n    // result text\n    if (step.result !== null && step.result !== undefined) {\n      resultText.textContent = formatResult(step.result);\n    } else {\n      resultText.textContent = '—';\n    }\n  }\n\n  function formatResult(r) {\n    if (Array.isArray(r)) return '['+r.join(', ')+']';\n    if (typeof r === 'object') return JSON.stringify(r);\n    return String(r);\n  }\n\n  function placePointer(label, index, classes) {\n    // remove existing with that label\n    const existing = arrayRow.querySelector(`.pointer.${label}`);\n    if (existing) existing.remove();\n    if (index < 0 || index >= arrayRow.children.length) return;\n    const cell = arrayRow.children[index];\n    const p = document.createElement('div');\n    p.className = `pointer ${classes} ${label.toLowerCase()}`;\n    p.textContent = label;\n    // position above cell by translating relative to arrayRow\n    // compute left offset\n    const cellRect = cell.getBoundingClientRect();\n    const rowRect = arrayRow.getBoundingClientRect();\n    const left = cellRect.left - rowRect.left + cellRect.width/2;\n    p.style.left = left + 'px';\n    arrayRow.appendChild(p);\n  }\n\n  function updateStatus() {\n    stepIdxEl.textContent = Math.max(0, currentStep+1);\n    stepMaxEl.textContent = steps.length;\n    opsCountEl.textContent = ops;\n  }\n\n  function play() {\n    if (!steps.length) return;\n    stopTimer();\n    timer = setInterval(() => {\n      if (currentStep < steps.length-1) {\n        currentStep++;\n        renderArrayStep(steps[currentStep]);\n        updateStatus();\n      } else {\n        stopTimer();\n      }\n    }, playInterval);\n  }\n  function stopTimer() {\n    if (timer) { clearInterval(timer); timer = null; }\n  }\n\n  function step(offset) {\n    if (!steps.length) return;\n    currentStep = Math.max(0, Math.min(steps.length-1, currentStep + offset));\n    renderArrayStep(steps[currentStep]);\n    updateStatus();\n  }\n\n  function reset() {\n    stopTimer();\n    currentStep = -1;\n    renderArrayStep(null);\n    stepIdxEl.textContent = 0;\n    resultText.textContent = '—';\n    annotation.textContent = 'Build steps to begin.';\n    ops = 0;\n    opsCountEl.textContent = 0;\n    logEl.style.display = 'none';\n    logEl.innerHTML = '';\n    stepMaxEl.textContent = 0;\n  }\n\n  // Parsing helpers\n  function parseArrayInput() {\n    const s = inputArray.value.trim();\n    if (algoSelect.value === 'reverseString') {\n      // take raw string (not comma separated)\n      // if input contains commas and looks like arr, treat as comma separated values\n      if (s.includes(',') && !s.trim().startsWith('\"')) {\n        // join tokens with comma? For reverse string better to treat full string ignoring commas\n        // We'll fallback to raw string (commas included)\n        return s;\n      } else {\n        return s;\n      }\n    }\n    // parse numbers by comma or spaces\n    if (!s) return [];\n    // allow bracket style: [1,2,3]\n    let cleaned = s.replace(/[\\[\\]]/g, '');\n    // split by comma or whitespace\n    const tokens = cleaned.split(/[\\s,]+/).filter(Boolean);\n    const nums = tokens.map(t => {\n      const n = Number(t);\n      return Number.isNaN(n) ? t : n;\n    });\n    return nums;\n  }\n\n  // Build steps\n  function buildSteps() {\n    reset();\n    const algoKey = algoSelect.value;\n    const algo = algorithms[algoKey];\n    if (!algo) return;\n    // Update description and code\n    algoDesc.textContent = algo.short;\n    algoComplexity.textContent = algo.complexity;\n    codeBlock.textContent = algo.code;\n\n    let parsed = parseArrayInput();\n    // For algorithms that require array of numbers, ensure it's an array\n    if (algoKey === 'pairSum' || algoKey === 'removeDuplicates' || algoKey === 'maxContainer' || algoKey === 'partitionParity') {\n      if (!Array.isArray(parsed)) {\n        annotation.textContent = 'Please provide numeric array (comma separated).';\n        return;\n      }\n      // ensure numeric typing\n      const notNums = parsed.filter(x => typeof x !== 'number');\n      if (notNums.length > 0) {\n        annotation.textContent = 'Array must contain numbers for this algorithm.';\n        return;\n      }\n    }\n\n    // For pairSum we expect sorted array: auto-sort but inform user\n    if (algoKey === 'pairSum' || algoKey === 'removeDuplicates') {\n      // make numeric array sorted\n      const arrNumbers = parsed.slice().sort((a,b)=>a-b);\n      parsed = arrNumbers;\n      inputArray.value = parsed.join(',');\n      annotation.textContent = '(Array sorted automatically for this demo)';\n    }\n\n    // For reverseString, treat parsed as raw string\n    let buildInput = parsed;\n    if (algoKey === 'reverseString') {\n      // if input is array of tokens, join them with spaces ONLY if user entered tokens\n      if (Array.isArray(parsed)) {\n        // join elements with comma if user entered commas; but better to use the raw input string\n        buildInput = inputArray.value;\n      } else {\n        buildInput = inputArray.value;\n      }\n    }\n\n    const opts = {};\n    if (algoKey === 'pairSum') {\n      const t = Number(targetInput.value);\n      if (Number.isNaN(t)) { annotation.textContent = 'Target must be a number.'; return; }\n      opts.target = t;\n    }\n\n    const res = algo.build(buildInput, opts);\n    steps = res.steps || [];\n    ops = res.ops || 0;\n    // append final step if none\n    if (steps.length === 0) {\n      steps.push(snapshot(Array.isArray(parsed) ? parsed : Array.from(String(parsed)), -1, -1, 'No steps generated'));\n    }\n    currentStep = 0;\n    renderArrayStep(steps[0]);\n    stepMaxEl.textContent = steps.length;\n    stepIdxEl.textContent = 1;\n    opsCountEl.textContent = ops;\n    resultText.textContent = res.result !== undefined && res.result !== null ? formatResult(res.result) : '—';\n    // Fill log with all step descriptions\n    logEl.style.display = 'block';\n    logEl.innerHTML = steps.map((s,i)=>`<div style=\"padding:6px;border-bottom:1px solid rgba(255,255,255,0.02)\"><strong>Step ${i+1}</strong>: ${escapeHtml(s.desc)}</div>`).join('');\n  }\n\n  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }\n\n  // Event listeners\n  parseBtn.addEventListener('click', buildSteps);\n  playBtn.addEventListener('click', () => {\n    playInterval = Number(speed.value);\n    play();\n  });\n  pauseBtn.addEventListener('click', stopTimer);\n  stepForward.addEventListener('click', () => { stopTimer(); step(1); });\n  stepBack.addEventListener('click', () => { stopTimer(); step(-1); });\n  resetBtn.addEventListener('click', reset);\n  speed.addEventListener('input', () => {\n    speedLabel.textContent = speed.value + ' ms';\n  });\n\n  randomBtn.addEventListener('click', () => {\n    const n = 8;\n    const arr = Array.from({length:n},()=>Math.floor(Math.random()*20));\n    inputArray.value = arr.join(',');\n  });\n\n  sortBtn.addEventListener('click', () => {\n    const parsed = parseArrayInput();\n    if (!Array.isArray(parsed)) return;\n    inputArray.value = parsed.slice().sort((a,b)=>a-b).join(',');\n  });\n\n  algoSelect.addEventListener('change', () => {\n    const key = algoSelect.value;\n    // show/hide target area\n    targetArea.style.display = (key === 'pairSum') ? 'block' : 'none';\n    // update code and descriptions immediately\n    const algo = algorithms[key];\n    algoDesc.textContent = algo.short;\n    algoComplexity.textContent = algo.complexity;\n    codeBlock.textContent = algo.code;\n    reset();\n  });\n\n  presets.forEach(btn => btn.addEventListener('click', () => {\n    inputArray.value = btn.dataset.preset;\n  }));\n\n  // Init\n  algoSelect.dispatchEvent(new Event('change'));\n  reset();\n\n  // Provide keyboard shortcuts\n  document.addEventListener('keydown', (e) => {\n    if (e.key === ' ') { e.preventDefault(); if (timer) stopTimer(); else play(); }\n    if (e.key === 'ArrowRight') { stepForward.click(); }\n    if (e.key === 'ArrowLeft') { stepBack.click(); }\n  });\n\n  // Expose for debugging (optional)\n  window._twopointers = {\n    buildSteps: buildSteps,\n    stepsRef: () => steps\n  };\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Two Pointers"
    }
  ],
  "topic": "Two Pointers",
  "hasFSM": false,
  "hasTest": true
}