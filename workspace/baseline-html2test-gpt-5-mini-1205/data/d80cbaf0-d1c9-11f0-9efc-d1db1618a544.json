{
  "id": "d80cbaf0-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:42.431Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "K-Nearest Neighbors (KNN)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>K-Nearest Neighbors (KNN) Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    :root{\n      --bg:#fafafa;\n      --panel:#ffffff;\n      --muted:#666;\n      --accent:#246;\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,\"Helvetica Neue\",Arial; background:var(--bg); color:#111;}\n    .app{display:flex;gap:18px;padding:18px;box-sizing:border-box;height:100%;}\n    .left{width:380px;min-width:300px;background:var(--panel);border-radius:10px;padding:16px;box-shadow:0 6px 20px rgba(20,30,50,0.08);overflow:auto;}\n    .right{flex:1;display:flex;flex-direction:column;gap:12px;}\n    h1{margin:6px 0 12px;font-size:18px;}\n    p{margin:8px 0;color:var(--muted);font-size:13px;line-height:1.45;}\n    .controls{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px;}\n    .control-row{display:flex;gap:8px;align-items:center;margin-bottom:8px;}\n    label{font-size:13px;color:#333;}\n    input[type=\"range\"]{width:100%;}\n    select,input[type=\"number\"]{width:100%;padding:6px;border-radius:6px;border:1px solid #ddd;background:#fff;}\n    button{padding:8px 10px;border-radius:8px;border:1px solid #d0d7e3;background:white;cursor:pointer;}\n    .btn-primary{background:linear-gradient(180deg,#2d6cdf,#1d47b3);color:#fff;border:none;}\n    .small{font-size:12px;padding:6px 8px;}\n    .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px;}\n    .legend-item{display:flex;gap:6px;align-items:center;font-size:13px;}\n    .swatch{width:14px;height:14px;border-radius:4px;}\n    canvas{background:#fff;border-radius:10px;border:1px solid rgba(20,30,50,0.06);box-shadow:0 6px 20px rgba(20,30,50,0.04);display:block;}\n    .footer{font-size:12px;color:var(--muted);margin-top:10px;}\n    .meta{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}\n    .mode-pill{padding:6px 8px;border-radius:8px;border:1px solid #eee;background:#fff;cursor:pointer;}\n    .mode-pill.active{background:#1d47b3;color:#fff;border:none;}\n    .info-box{background:#f4f8ff;border-radius:8px;padding:8px;border:1px solid #e6eefc;font-size:13px;margin-top:10px;}\n    .neighbors-list{font-size:13px;color:#222;margin-top:8px;max-height:120px;overflow:auto;}\n    .neighbors-row{display:flex;justify-content:space-between;padding:4px 6px;border-bottom:1px dashed #f0f0f0;}\n    .muted{color:var(--muted);font-size:13px;}\n    .flex{display:flex;gap:8px;align-items:center;}\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"left\">\n      <h1>K-Nearest Neighbors (KNN) — Interactive Demo</h1>\n      <p>\n        KNN is a simple, non-parametric classifier that labels a query point based on the labels of its nearest neighbors in the feature space.\n        Use the controls to change K, distance metric, weighting, and interactively add points or classify a new point by clicking the canvas.\n      </p>\n\n      <div class=\"controls\">\n        <div>\n          <label for=\"kRange\">K (neighbors): <span id=\"kLabel\">3</span></label>\n          <input id=\"kRange\" type=\"range\" min=\"1\" max=\"25\" value=\"3\">\n        </div>\n        <div>\n          <label for=\"metric\">Distance metric</label>\n          <select id=\"metric\">\n            <option value=\"euclidean\">Euclidean (L2)</option>\n            <option value=\"manhattan\">Manhattan (L1)</option>\n            <option value=\"chebyshev\">Chebyshev (L∞)</option>\n          </select>\n        </div>\n      </div>\n\n      <div class=\"control-row\">\n        <label style=\"min-width:120px\">Weighted voting</label>\n        <input id=\"weighted\" type=\"checkbox\">\n        <span class=\"muted\">If checked, closer neighbors count more (weight = 1 / (distance + ε)).</span>\n      </div>\n\n      <div class=\"control-row\">\n        <label style=\"min-width:120px\">Mode</label>\n        <div class=\"meta\">\n          <div id=\"modeAdd\" class=\"mode-pill active\">Add Points</div>\n          <div id=\"modeQuery\" class=\"mode-pill\">Query (classify)</div>\n        </div>\n      </div>\n\n      <div style=\"margin-top:6px;\">\n        <label>Choose class color to add:</label>\n        <div class=\"legend\" id=\"classLegend\"></div>\n      </div>\n\n      <div style=\"margin-top:10px;\" class=\"flex\">\n        <button id=\"btnRandom\" class=\"small\">Generate Random Clusters</button>\n        <button id=\"btnClear\" class=\"small\">Clear Points</button>\n        <button id=\"btnBoundary\" class=\"small\">Toggle Decision Boundary</button>\n        <button id=\"btnReset\" class=\"small\">Reset Default</button>\n      </div>\n\n      <div class=\"info-box\">\n        <strong>How to use</strong>\n        <ul style=\"margin:6px 0 0 18px;padding:0;color:var(--muted)\">\n          <li>Switch to \"Add Points\", choose a color/class and click canvas to place labeled points.</li>\n          <li>Switch to \"Query\" and click the canvas to classify that point. K nearest neighbors will be highlighted.</li>\n          <li>Toggle \"Decision Boundary\" to color the whole canvas by predicted class (grid approximation).</li>\n        </ul>\n      </div>\n\n      <div style=\"margin-top:10px;\">\n        <label>Grid resolution (for boundary): <span id=\"resLabel\">6</span> px</label>\n        <input id=\"resolution\" type=\"range\" min=\"3\" max=\"18\" value=\"6\">\n      </div>\n\n      <div class=\"neighbors-list\" id=\"neighborsList\"></div>\n\n      <div class=\"footer\">\n        Short formulas:\n        <div class=\"muted\" style=\"margin-top:6px\">\n          Euclidean: d(a,b)=sqrt(sum((ai-bi)^2)). Manhattan: sum(|ai-bi|). Weighted vote: sum(wi * 1[label_i == c]) with wi=1/(d+ε).\n        </div>\n      </div>\n    </div>\n\n    <div class=\"right\">\n      <canvas id=\"canvas\" width=\"820\" height=\"620\"></canvas>\n      <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n        <div class=\"muted\" id=\"status\">Mode: Add Points. Click to add points.</div>\n        <div style=\"display:flex;gap:10px;align-items:center;\">\n          <div class=\"muted\">Selected Class:</div>\n          <div id=\"selectedClassBox\" style=\"display:flex;align-items:center;gap:8px\"></div>\n          <div style=\"width:12px;height:12px;border-radius:3px;background:#fff;border:1px solid #eee\"></div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // KNN Interactive Demo\n    (function(){\n      // Utility & configuration\n      const colors = [\n        '#e53935','#1e88e5','#43a047','#fb8c00','#8e24aa','#00acc1','#6d4c41'\n      ];\n      const maxClasses = Math.min(colors.length, 6);\n      let classesCount = 3;\n      let selectedClass = 0;\n\n      // Data: array of {x:0..1, y:0..1, label:int}\n      let points = [];\n      let query = null;\n      let showBoundary = false;\n\n      // Controls\n      const canvas = document.getElementById('canvas');\n      const ctx = canvas.getContext('2d');\n      let canvasRect = canvas.getBoundingClientRect();\n\n      const kRange = document.getElementById('kRange');\n      const kLabel = document.getElementById('kLabel');\n      const metricSelect = document.getElementById('metric');\n      const weightedCheckbox = document.getElementById('weighted');\n      const modeAdd = document.getElementById('modeAdd');\n      const modeQuery = document.getElementById('modeQuery');\n      const btnRandom = document.getElementById('btnRandom');\n      const btnClear = document.getElementById('btnClear');\n      const btnBoundary = document.getElementById('btnBoundary');\n      const btnReset = document.getElementById('btnReset');\n      const resolution = document.getElementById('resolution');\n      const resLabel = document.getElementById('resLabel');\n      const neighborsList = document.getElementById('neighborsList');\n      const status = document.getElementById('status');\n      const classLegend = document.getElementById('classLegend');\n      const selectedClassBox = document.getElementById('selectedClassBox');\n\n      // State\n      let mode = 'add'; // 'add' | 'query'\n\n      // Initialize UI\n      function createLegend(){\n        classLegend.innerHTML = '';\n        for(let i=0;i<classesCount;i++){\n          const div = document.createElement('div');\n          div.className = 'legend-item';\n          div.dataset.cls = i;\n          div.innerHTML = `<div class=\"swatch\" style=\"background:${colors[i]}\"></div><div style=\"font-size:13px\">Class ${i+1}</div>`;\n          div.addEventListener('click', ()=> {\n            selectedClass = i;\n            updateSelectedClassUI();\n          });\n          classLegend.appendChild(div);\n        }\n        updateSelectedClassUI();\n      }\n\n      function updateSelectedClassUI(){\n        selectedClassBox.innerHTML = '';\n        const sw = document.createElement('div');\n        sw.style.width = '18px';\n        sw.style.height = '18px';\n        sw.style.borderRadius = '4px';\n        sw.style.background = colors[selectedClass];\n        sw.style.border = '1px solid rgba(0,0,0,0.06)';\n        selectedClassBox.appendChild(sw);\n      }\n\n      // Helpers: coordinate transforms\n      function toCanvasCoord(p){\n        return {x: p.x * canvas.width, y: (1 - p.y) * canvas.height};\n      }\n      function toNormalized(x,y){\n        const rect = canvas.getBoundingClientRect();\n        const cx = x - rect.left;\n        const cy = y - rect.top;\n        return {x: Math.max(0, Math.min(1, cx / rect.width)), y: Math.max(0, Math.min(1, 1 - cy / rect.height))};\n      }\n\n      // Distance metrics\n      function distance(a,b,metric='euclidean'){\n        const dx = a.x - b.x;\n        const dy = a.y - b.y;\n        if(metric === 'euclidean') return Math.hypot(dx,dy);\n        if(metric === 'manhattan') return Math.abs(dx) + Math.abs(dy);\n        if(metric === 'chebyshev') return Math.max(Math.abs(dx), Math.abs(dy));\n        return Math.hypot(dx,dy);\n      }\n\n      // KNN classifier\n      function classifyPoint(pt, K, metric, weighted){\n        if(points.length === 0) return {label: null, neighbors: []};\n        const dists = points.map((p,i)=>({i, label:p.label, dist: distance(pt,p,metric), p} ));\n        dists.sort((a,b)=>a.dist - b.dist);\n        const neighbors = dists.slice(0, Math.min(K, dists.length));\n        // If zero distance to a sample, return that label immediately\n        if(neighbors.length>0 && neighbors[0].dist === 0){\n          return {label: neighbors[0].label, neighbors};\n        }\n        const votes = {};\n        for(const n of neighbors){\n          const w = weighted ? 1 / (n.dist + 1e-9) : 1;\n          votes[n.label] = (votes[n.label] || 0) + w;\n        }\n        // pick label with max vote; break ties by closer average distance\n        let bestLabel = null;\n        let bestScore = -Infinity;\n        for(const lab in votes){\n          if(votes[lab] > bestScore){\n            bestScore = votes[lab];\n            bestLabel = Number(lab);\n          }\n        }\n        return {label: bestLabel, neighbors, votes};\n      }\n\n      // Drawing\n      function draw(){\n        // Clear\n        ctx.clearRect(0,0,canvas.width,canvas.height);\n        ctx.save();\n        // Optionally draw decision boundary\n        if(showBoundary && points.length>0){\n          const step = Number(resolution.value);\n          for(let x=0;x<canvas.width;x+=step){\n            for(let y=0;y<canvas.height;y+=step){\n              const nx = x / canvas.width;\n              const ny = 1 - y / canvas.height;\n              const res = classifyPoint({x:nx,y:ny}, Number(kRange.value), metricSelect.value, weightedCheckbox.checked);\n              if(res.label === null) continue;\n              ctx.fillStyle = hexToRgba(colors[res.label], 0.12);\n              ctx.fillRect(x,y,step,step);\n            }\n          }\n        }\n        // Draw grid lightly\n        ctx.strokeStyle = 'rgba(0,0,0,0.03)';\n        ctx.beginPath();\n        for(let x=0;x<=canvas.width;x+=40){ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);}\n        for(let y=0;y<=canvas.height;y+=40){ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);}\n        ctx.stroke();\n\n        // Draw points\n        for(const p of points){\n          const c = toCanvasCoord(p);\n          drawPoint(c.x,c.y, colors[p.label], 8, true);\n        }\n\n        // If query present, classify and draw neighbors\n        if(query){\n          const K = Number(kRange.value);\n          const res = classifyPoint(query, K, metricSelect.value, weightedCheckbox.checked);\n          // highlight neighbors\n          for(const nb of res.neighbors){\n            const cp = toCanvasCoord(nb.p);\n            ctx.beginPath();\n            ctx.lineWidth = 2.2;\n            ctx.strokeStyle = hexToRgba(colors[nb.label], 0.95);\n            ctx.fillStyle = 'rgba(255,255,255,0.0)';\n            ctx.arc(cp.x, cp.y, 16, 0, Math.PI*2);\n            ctx.stroke();\n            // connect line\n            const cq = toCanvasCoord(query);\n            ctx.beginPath();\n            ctx.lineWidth = 1.0;\n            ctx.strokeStyle = hexToRgba(colors[nb.label], 0.25);\n            ctx.moveTo(cp.x, cp.y);\n            ctx.lineTo(cq.x, cq.y);\n            ctx.stroke();\n          }\n          // draw query\n          const qc = toCanvasCoord(query);\n          drawTriangle(qc.x, qc.y, res.label !== null ? colors[res.label] : '#999', 14);\n          // show classification summary\n          renderNeighborList(res);\n        } else {\n          neighborsList.innerHTML = '<div class=\"muted\">No query selected. Switch to \"Query\" mode and click the canvas to classify a point.</div>';\n        }\n\n        ctx.restore();\n      }\n\n      function drawPoint(x,y,color,r, stroke){\n        ctx.beginPath();\n        ctx.fillStyle = color;\n        ctx.arc(x,y,r,0,Math.PI*2);\n        ctx.fill();\n        if(stroke){\n          ctx.lineWidth = 1.2;\n          ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n          ctx.stroke();\n        }\n      }\n\n      function drawTriangle(x,y,color,size){\n        ctx.save();\n        ctx.translate(x,y);\n        ctx.rotate(0);\n        ctx.beginPath();\n        ctx.fillStyle = color;\n        ctx.moveTo(0, -size);\n        ctx.lineTo(size * 0.86, size * 0.5);\n        ctx.lineTo(-size * 0.86, size * 0.5);\n        ctx.closePath();\n        ctx.fill();\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = 'rgba(0,0,0,0.08)';\n        ctx.stroke();\n        ctx.restore();\n      }\n\n      function hexToRgba(hex, alpha){\n        const h = hex.replace('#','');\n        const bigint = parseInt(h,16);\n        const r = (bigint >> 16) & 255;\n        const g = (bigint >> 8) & 255;\n        const b = bigint & 255;\n        return `rgba(${r},${g},${b},${alpha})`;\n      }\n\n      // Render neighbor list details\n      function renderNeighborList(res){\n        if(!res || res.neighbors.length===0){\n          neighborsList.innerHTML = '<div class=\"muted\">No neighbors to display.</div>'; return;\n        }\n        let html = `<div style=\"padding:6px 0;font-weight:600\">Predicted: <span style=\"color:${colors[res.label]}\">Class ${res.label+1}</span></div>`;\n        html += `<div class=\"muted\" style=\"padding-bottom:6px\">Neighbors (closest first):</div>`;\n        html += '<div>';\n        res.neighbors.forEach((n, idx)=>{\n          const dist = (n.dist).toFixed(4);\n          html += `<div class=\"neighbors-row\"><div style=\"display:flex;gap:8px;align-items:center\">\n            <div style=\"width:10px;height:10px;border-radius:3px;background:${colors[n.label]};\"></div>\n            <div>Point #${n.i+1} (Class ${n.label+1})</div></div><div class=\"muted\">${dist}</div></div>`;\n        });\n        html += '</div>';\n        neighborsList.innerHTML = html;\n      }\n\n      // Interactions\n      canvas.addEventListener('click', (ev)=>{\n        const p = toNormalized(ev.clientX, ev.clientY);\n        if(mode === 'add'){\n          points.push({x:p.x, y:p.y, label: selectedClass});\n          query = null;\n          draw();\n        } else {\n          query = {x:p.x, y:p.y};\n          draw();\n        }\n      });\n\n      // UI events\n      kRange.addEventListener('input', ()=>{ kLabel.textContent = kRange.value; draw(); });\n      metricSelect.addEventListener('change', draw);\n      weightedCheckbox.addEventListener('change', draw);\n      resolution.addEventListener('input', ()=>{ resLabel.textContent = resolution.value; if(showBoundary) draw(); });\n\n      modeAdd.addEventListener('click', ()=>{ mode='add'; modeAdd.classList.add('active'); modeQuery.classList.remove('active'); status.textContent = 'Mode: Add Points. Click canvas to add labeled points.'; });\n      modeQuery.addEventListener('click', ()=>{ mode='query'; modeQuery.classList.add('active'); modeAdd.classList.remove('active'); status.textContent = 'Mode: Query. Click canvas to classify a point.'; });\n\n      btnRandom.addEventListener('click', ()=>{ generateRandomClusters(); draw(); });\n      btnClear.addEventListener('click', ()=>{ points=[]; query=null; draw(); });\n      btnBoundary.addEventListener('click', ()=>{ showBoundary = !showBoundary; btnBoundary.textContent = showBoundary ? 'Hide Decision Boundary' : 'Toggle Decision Boundary'; draw(); });\n      btnReset.addEventListener('click', ()=>{ resetDemo(); draw(); });\n\n      // Initialization helpers\n      function generateRandomClusters(){\n        points = [];\n        // place 'classesCount' clusters\n        for(let c=0;c<classesCount;c++){\n          const cx = 0.15 + Math.random()*0.7;\n          const cy = 0.15 + Math.random()*0.7;\n          const n = 15 + Math.floor(Math.random()*10);\n          const spread = 0.04 + Math.random()*0.08;\n          for(let i=0;i<n;i++){\n            points.push({\n              x: Math.min(0.98, Math.max(0.02, cx + randn()*spread)),\n              y: Math.min(0.98, Math.max(0.02, cy + randn()*spread)),\n              label: c\n            });\n          }\n        }\n        query = null;\n      }\n\n      function randn(){\n        // Box-Muller\n        let u=0,v=0;\n        while(u===0) u=Math.random();\n        while(v===0) v=Math.random();\n        return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);\n      }\n\n      function resetDemo(){\n        points = [];\n        selectedClass = 0;\n        classesCount = 3;\n        createLegend();\n        kRange.value = 3; kLabel.textContent = 3;\n        metricSelect.value = 'euclidean';\n        weightedCheckbox.checked = false;\n        resolution.value = 6; resLabel.textContent = 6;\n        showBoundary = false;\n        btnBoundary.textContent = 'Toggle Decision Boundary';\n        mode='add'; modeAdd.classList.add('active'); modeQuery.classList.remove('active');\n        status.textContent = 'Mode: Add Points. Click canvas to add labeled points.';\n        generateRandomClusters();\n      }\n\n      // Resize handling\n      function resizeCanvas(){\n        // keep canvas pixel ratio sharp\n        const dpr = window.devicePixelRatio || 1;\n        const width = canvas.clientWidth || 820;\n        const height = canvas.clientHeight || 620;\n        canvas.width = Math.floor(width * dpr);\n        canvas.height = Math.floor(height * dpr);\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n        ctx.setTransform(dpr,0,0,dpr,0,0);\n        canvasRect = canvas.getBoundingClientRect();\n        draw();\n      }\n\n      window.addEventListener('resize', ()=>{\n        // small debounce\n        setTimeout(()=>{ resizeCanvas(); }, 60);\n      });\n\n      // Setup default state\n      (function init(){\n        // create classes UI (start with 3)\n        createLegend();\n        // set some default canvas size\n        canvas.style.width = '100%';\n        canvas.style.height = '620px';\n        // initial dataset\n        generateRandomClusters();\n        // initial draw after sizing\n        // ensure canvas has layout\n        setTimeout(()=>{ resizeCanvas(); }, 20);\n      })();\n\n      // Make it easy to change number of classes: keyboard 2..6\n      window.addEventListener('keydown', (e)=>{\n        if(e.key >= '2' && e.key <= String(maxClasses)){\n          classesCount = Number(e.key);\n          selectedClass = Math.min(selectedClass, classesCount-1);\n          createLegend();\n          draw();\n        }\n      });\n\n      // Prevent context menu on right-click for canvas (optional)\n      canvas.addEventListener('contextmenu', (e)=> e.preventDefault());\n\n      // Expose some for debugging\n      window._knnDemo = {points, classifyPoint, draw};\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Nearest Neighbors (KNN)"
    }
  ],
  "topic": "K-Nearest Neighbors (KNN)",
  "hasFSM": false,
  "hasTest": true
}