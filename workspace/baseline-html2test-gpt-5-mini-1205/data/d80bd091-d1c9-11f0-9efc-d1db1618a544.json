{
  "id": "d80bd091-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:20.034Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Huffman Coding",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>Huffman Coding Interactive Demonstration</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 18px; color: #111; }\n  h1 { margin-top: 0; }\n  .container { display: grid; grid-template-columns: 1fr 420px; gap: 18px; align-items: start; }\n  .panel { border: 1px solid #ddd; padding: 12px; border-radius: 8px; background: #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.03); }\n  textarea { width: 100%; min-height: 80px; font-family: monospace; font-size: 13px; padding: 8px; box-sizing: border-box; }\n  input[type=\"text\"] { width: 100%; padding: 6px 8px; box-sizing: border-box; }\n  button { padding: 8px 10px; margin: 4px 2px 0 0; }\n  .small { font-size: 13px; color: #444; }\n  table { width: 100%; border-collapse: collapse; margin-top: 8px; }\n  th, td { text-align: left; padding: 6px 8px; border-bottom: 1px solid #eee; font-size: 13px; }\n  th { background: #fafafa; position: sticky; top: 0; }\n  .freq { font-weight: 600; }\n  .controls { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px; }\n  .queue { font-family: monospace; font-size: 14px; }\n  .svg-wrap { overflow: auto; border: 1px solid #eee; padding: 6px; border-radius: 6px; background: #fff; }\n  svg { width: 100%; height: 280px; }\n  .node { cursor: default; }\n  .node circle { fill: #f7fbff; stroke: #1e88e5; stroke-width: 1.5px; }\n  .node text { font-size: 12px; text-anchor: middle; pointer-events: none; }\n  .internal circle { fill: #fff7e6; stroke: #ff8a00; }\n  .highlight circle { stroke-width: 3px; transform-origin: center; }\n  .help { font-size: 13px; color: #333; margin-bottom: 8px; }\n  .metrics { font-size: 14px; margin-top: 8px; }\n  .codecell { font-family: monospace; background: #f6f9ff; padding: 6px; border-radius: 4px; display:block; }\n  .bit-output { word-break: break-all; font-family: monospace; background: #f3f3f3; padding: 8px; border-radius: 4px; }\n  .stat { display:flex; gap:12px; flex-wrap:wrap; margin-top:8px; }\n  .stat div { background:#fafafa; padding:6px 8px; border-radius:6px; border:1px solid #eee; font-size:13px; }\n  .footer { margin-top: 16px; font-size:13px; color:#555; }\n  .muted { color: #666; font-size: 13px; }\n  .legend { display:flex; gap:10px; align-items:center; margin-top:8px; }\n  .legend span { display:inline-flex; gap:6px; align-items:center; font-size:13px; }\n  .color-swatch { width:12px; height:12px; border-radius:2px; display:inline-block; border:1px solid #ccc; }\n  .left-col { min-width: 0; }\n  .right-col { position: sticky; top: 12px; align-self: start; }\n  .node-label { font-size: 11px; fill: #333; }\n</style>\n</head>\n<body>\n<h1>Huffman Coding — Interactive Demonstration</h1>\n<div class=\"help panel\">\n  <strong>What is Huffman Coding?</strong>\n  <p class=\"small\">Huffman coding is a variable-length, prefix-free encoding for symbols based on their frequencies. More frequent symbols get shorter codes. This demo lets you type text or provide symbol frequencies, then builds the Huffman tree step-by-step, shows codes, encodes and decodes bitstrings, and compares sizes.</p>\n  <div class=\"legend\">\n    <span><span class=\"color-swatch\" style=\"background:#e3f2fd;border-color:#1e88e5\"></span> Leaf node (symbol)</span>\n    <span><span class=\"color-swatch\" style=\"background:#fff6e5;border-color:#ff8a00\"></span> Internal node</span>\n  </div>\n</div>\n\n<div class=\"container\">\n  <div class=\"panel left-col\">\n    <div>\n      <label><strong>Input text (or type symbols separated by spaces)</strong></label>\n      <textarea id=\"inputText\" placeholder=\"Type a sample text here...\">this is an example for huffman encoding</textarea>\n      <div style=\"display:flex; gap:8px; margin-top:8px;\">\n        <button id=\"analyzeBtn\">Analyze Frequencies & Build Steps</button>\n        <button id=\"autoPlayBtn\">Auto-play</button>\n        <button id=\"resetBtn\">Reset</button>\n      </div>\n    </div>\n\n    <div class=\"controls\" style=\"margin-top:12px;\">\n      <label style=\"display:flex; gap:8px; align-items:center;\"><input id=\"ignoreSpaces\" type=\"checkbox\" checked/> Ignore spaces</label>\n      <label style=\"display:flex; gap:8px; align-items:center;\"><input id=\"showStepCodes\" type=\"checkbox\" checked/> Show interim codes</label>\n      <label style=\"display:flex; gap:8px; align-items:center;\"><input id=\"useUtf8\" type=\"checkbox\" checked/> Use 8-bit per symbol baseline</label>\n      <label style=\"display:flex; gap:8px; align-items:center;\"><input id=\"showEdges\" type=\"checkbox\" checked/> Show tree edges</label>\n    </div>\n\n    <div style=\"display:flex; gap:12px; margin-top:12px;\">\n      <div style=\"flex:1\">\n        <strong>Frequency Table</strong>\n        <div id=\"freqArea\" class=\"panel\" style=\"padding:8px; margin-top:8px;\"></div>\n      </div>\n      <div style=\"width:220px;\">\n        <strong>Final Codes</strong>\n        <div id=\"codesArea\" class=\"panel\" style=\"padding:8px; margin-top:8px;\"></div>\n      </div>\n    </div>\n\n    <div style=\"margin-top:12px;\">\n      <strong>Step-by-step Priority Queue & Tree Construction</strong>\n      <div style=\"display:flex; gap:8px; align-items:center; margin-top:8px;\">\n        <button id=\"stepBackBtn\">‹ Prev</button>\n        <button id=\"stepNextBtn\">Next ›</button>\n        <button id=\"fastForwardBtn\">Finish</button>\n        <div style=\"margin-left:auto;\" class=\"muted\">Step <span id=\"stepNum\">0</span> / <span id=\"stepTotal\">0</span></div>\n      </div>\n      <div id=\"queueArea\" class=\"panel queue\" style=\"margin-top:8px; min-height:54px;\"></div>\n      <div class=\"svg-wrap\" style=\"margin-top:10px;\">\n        <svg id=\"treeSvg\" viewBox=\"0 0 1000 300\" preserveAspectRatio=\"xMinYMin meet\"></svg>\n      </div>\n    </div>\n\n    <div style=\"margin-top:12px;\">\n      <strong>Encode & Decode</strong>\n      <div style=\"display:flex; gap:8px; margin-top:8px;\">\n        <button id=\"encodeBtn\">Encode Input</button>\n        <button id=\"decodeBtn\">Decode Bits</button>\n        <button id=\"copyBitsBtn\">Copy Bits</button>\n      </div>\n      <div style=\"margin-top:8px;\">\n        <label>Bit string (editable)</label>\n        <textarea id=\"bitString\" placeholder=\"Encoded bit string will appear here...\" style=\"min-height:60px\"></textarea>\n        <div style=\"display:flex; gap:8px; margin-top:6px;\">\n          <div class=\"stat\">\n            <div>Original size: <span id=\"origSize\">-</span></div>\n            <div>Huffman size: <span id=\"huffSize\">-</span></div>\n            <div>Compression: <span id=\"ratio\">-</span></div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"footer\">\n      Tip: If you want to encode arbitrary bytes, paste them into the input field. By default the demo treats each character as one symbol (8-bit baseline). Use \"Ignore spaces\" to collapse spaces.\n    </div>\n  </div>\n\n  <div class=\"panel right-col\">\n    <strong>Explanation & Metrics</strong>\n    <div class=\"muted\" style=\"margin-top:8px;\">\n      This interactive shows how Huffman coding merges the two least frequent nodes repeatedly to form a binary tree. Each leaf is a symbol; paths left=0 right=1 (convention) define the codewords. The resulting encoding is prefix-free and optimal (minimum average code length) for the given symbol frequencies.\n    </div>\n\n    <div style=\"margin-top:12px;\">\n      <strong>Steps</strong>\n      <ol id=\"stepsList\" style=\"padding-left:18px; margin-top:8px; max-height:240px; overflow:auto;\"></ol>\n    </div>\n\n    <div style=\"margin-top:12px;\">\n      <strong>Selected Node Details</strong>\n      <div id=\"nodeDetails\" style=\"margin-top:8px; font-size:13px;\" class=\"muted\">Click a node in the tree to see details.</div>\n    </div>\n\n    <div style=\"margin-top:12px;\">\n      <strong>Options</strong>\n      <div style=\"margin-top:6px;\" class=\"small\">\n        <label><input type=\"checkbox\" id=\"leftBitZero\" checked/> Left branch = 0 (else 1)</label><br/>\n        <label><input type=\"checkbox\" id=\"showInterimSizes\" checked/> Show interim sizes during building</label>\n      </div>\n    </div>\n  </div>\n</div>\n\n<script>\n/*\n  Huffman Coding Interactive Demo\n  - Build frequency table from input\n  - Step-by-step merge of lowest-frequency nodes\n  - Visualize tree (SVG)\n  - Show codes, encode, decode, compare sizes\n*/\n\n(function(){\n  // Utilities\n  const $ = id => document.getElementById(id);\n\n  // DOM elements\n  const inputText = $('inputText');\n  const analyzeBtn = $('analyzeBtn');\n  const freqArea = $('freqArea');\n  const codesArea = $('codesArea');\n  const queueArea = $('queueArea');\n  const treeSvg = $('treeSvg');\n  const stepBackBtn = $('stepBackBtn');\n  const stepNextBtn = $('stepNextBtn');\n  const fastForwardBtn = $('fastForwardBtn');\n  const stepNumSpan = $('stepNum');\n  const stepTotalSpan = $('stepTotal');\n  const stepsList = $('stepsList');\n  const autoPlayBtn = $('autoPlayBtn');\n  const bitString = $('bitString');\n  const encodeBtn = $('encodeBtn');\n  const decodeBtn = $('decodeBtn');\n  const copyBitsBtn = $('copyBitsBtn');\n  const origSizeSpan = $('origSize');\n  const huffSizeSpan = $('huffSize');\n  const ratioSpan = $('ratio');\n  const nodeDetails = $('nodeDetails');\n  const resetBtn = $('resetBtn');\n\n  // Options\n  const ignoreSpaces = $('ignoreSpaces');\n  const showStepCodes = $('showStepCodes');\n  const useUtf8 = $('useUtf8');\n  const showEdges = $('showEdges');\n  const leftBitZero = $('leftBitZero');\n  const showInterimSizes = $('showInterimSizes');\n\n  // State\n  let frequencies = {}; // symbol -> count\n  let nodes = []; // initial leaf nodes\n  let steps = []; // each step holds queue snapshot and merged node\n  let currentStep = 0;\n  let autoPlaying = false;\n  let finalRoot = null;\n  let finalCodes = {}; // symbol -> code string\n  let treeNodesById = {}; // id -> node object for visualization\n  let stepTimer = null;\n\n  function resetState(){\n    frequencies = {};\n    nodes = [];\n    steps = [];\n    currentStep = 0;\n    finalRoot = null;\n    finalCodes = {};\n    treeNodesById = {};\n    clearInterval(stepTimer);\n    autoPlaying = false;\n    autoPlayBtn.textContent = 'Auto-play';\n    stepNumSpan.textContent = '0';\n    stepTotalSpan.textContent = '0';\n    queueArea.innerHTML = '';\n    treeSvg.innerHTML = '';\n    freqArea.innerHTML = '';\n    codesArea.innerHTML = '';\n    stepsList.innerHTML = '';\n    nodeDetails.innerHTML = 'Click a node in the tree to see details.';\n    bitString.value = '';\n    origSizeSpan.textContent = '-';\n    huffSizeSpan.textContent = '-';\n    ratioSpan.textContent = '-';\n  }\n\n  function analyzeInput(){\n    resetState();\n    const txt = inputText.value;\n    if(txt.length === 0) {\n      alert('Please type some text to analyze.');\n      return;\n    }\n    // Build frequencies\n    frequencies = {};\n    for(let ch of txt){\n      if(ignoreSpaces.checked && ch === ' ') continue;\n      frequencies[ch] = (frequencies[ch] || 0) + 1;\n    }\n    // If nothing remains (all spaces), include space\n    if(Object.keys(frequencies).length === 0){\n      frequencies[' '] = txt.length;\n    }\n\n    // Build leaf nodes\n    let idCounter = 0;\n    nodes = Object.keys(frequencies).map(sym => ({\n      id: 'n' + (idCounter++),\n      sym,\n      weight: frequencies[sym],\n      left: null,\n      right: null,\n      isLeaf: true\n    }));\n\n    // Display frequency table\n    renderFrequencyTable();\n\n    // Build steps (simulate merges)\n    buildSteps();\n\n    // Render initial tree (leaves only)\n    renderStep(0);\n\n    // Compute final codes (on finish)\n    computeFinalCodes();\n    renderCodes();\n    updateSizeMetrics();\n\n    // Populate steps list summaries\n    renderStepsList();\n  }\n\n  function renderFrequencyTable(){\n    const pairs = Object.entries(frequencies).sort((a,b)=>b[1]-a[1]||a[0].localeCompare(b[0]));\n    let html = '<table><thead><tr><th>Symbol</th><th>Frequency</th></tr></thead><tbody>';\n    for(const [sym, cnt] of pairs){\n      const label = sym === ' ' ? '␣ (space)' : escapeHtml(sym);\n      html += `<tr><td class=\"freq\">${label}</td><td>${cnt}</td></tr>`;\n    }\n    html += '</tbody></table>';\n    freqArea.innerHTML = html;\n  }\n\n  function buildSteps(){\n    // Build a working priority queue as array, deterministic sort: by weight asc, then by isLeaf? then by symbol (or id)\n    let pq = nodes.map(n => ({...n})); // clone\n    // assign stable order via id sequencing if needed\n    let stepIndex = 0;\n    steps = [];\n    // Save initial queue snapshot\n    steps.push({ step: stepIndex++, pq: snapshotQueue(pq), merged: null });\n\n    while(pq.length > 1){\n      // sort\n      pq.sort((a,b)=>{\n        if(a.weight !== b.weight) return a.weight - b.weight;\n        // deterministic tie-break: prefer leaf with lexicographic symbol, internal nodes by id\n        const ak = a.isLeaf ? ('0'+a.sym) : ('1'+a.id);\n        const bk = b.isLeaf ? ('0'+b.sym) : ('1'+b.id);\n        return ak < bk ? -1 : (ak > bk ? 1 : 0);\n      });\n\n      // take two smallest\n      const left = pq.shift();\n      const right = pq.shift();\n      // merge node\n      const merged = {\n        id: 'm' + stepIndex + '_' + Math.random().toString(36).slice(2,6),\n        sym: null,\n        weight: left.weight + right.weight,\n        left,\n        right,\n        isLeaf: false\n      };\n      pq.push(merged);\n      steps.push({ step: stepIndex++, pq: snapshotQueue(pq), merged });\n    }\n\n    // Save final root\n    finalRoot = pq[0] || null;\n    // Save final full tree nodes by traversing\n    treeNodesById = {};\n    if(finalRoot) traverseAssignIds(finalRoot);\n    stepTotalSpan.textContent = steps.length - 1;\n  }\n\n  function snapshotQueue(pq){\n    // Return compact snapshot for display: shallow clones with minimal info\n    return pq.map(n => ({\n      id: n.id,\n      isLeaf: !!n.isLeaf,\n      sym: n.sym,\n      weight: n.weight,\n      leftId: n.left && n.left.id,\n      rightId: n.right && n.right.id\n    }));\n  }\n\n  function traverseAssignIds(node){\n    treeNodesById[node.id] = node;\n    if(node.left) traverseAssignIds(node.left);\n    if(node.right) traverseAssignIds(node.right);\n  }\n\n  function computeFinalCodes(){\n    finalCodes = {};\n    if(!finalRoot) return;\n    const leftZero = leftBitZero.checked;\n    function dfs(n, prefix){\n      if(n.isLeaf){\n        finalCodes[n.sym] = prefix || '0'; // single symbol edge case -> give it 0\n      } else {\n        // Left = 0, right = 1 (or reverse based on option)\n        if(n.left) dfs(n.left, prefix + (leftZero ? '0' : '1'));\n        if(n.right) dfs(n.right, prefix + (leftZero ? '1' : '0'));\n      }\n    }\n    dfs(finalRoot, '');\n  }\n\n  function renderCodes(){\n    const pairs = Object.entries(finalCodes).sort((a,b)=>a[0].localeCompare(b[0]));\n    let html = '<table><thead><tr><th>Symbol</th><th>Code</th><th>Len</th></tr></thead><tbody>';\n    for(const [sym, code] of pairs){\n      const label = sym === ' ' ? '␣ (space)' : escapeHtml(sym);\n      html += `<tr><td class=\"freq\">${label}</td><td class=\"codecell\">${code}</td><td>${code.length}</td></tr>`;\n    }\n    html += '</tbody></table>';\n    codesArea.innerHTML = html;\n  }\n\n  function updateSizeMetrics(){\n    const leftZero = leftBitZero.checked;\n    const totSymbols = Object.values(frequencies).reduce((a,b)=>a+b,0);\n    const baselineBitsPerSymbol = useUtf8.checked ? 8 : 1; // rough default\n    const origBits = totSymbols * baselineBitsPerSymbol;\n    let huffBits = 0;\n    for(const sym in frequencies){\n      const count = frequencies[sym];\n      const codeLen = (finalCodes[sym] || '').length || 0;\n      huffBits += count * codeLen;\n    }\n    origSizeSpan.textContent = origBits + ' bits';\n    huffSizeSpan.textContent = huffBits + ' bits';\n    ratioSpan.textContent = origBits > 0 ? ( (100 * (origBits - huffBits)/origBits).toFixed(1) + '% saved' ) : '-';\n  }\n\n  function renderStepsList(){\n    stepsList.innerHTML = '';\n    for(let i=0;i<steps.length;i++){\n      const s = steps[i];\n      const li = document.createElement('li');\n      li.textContent = i === 0 ? `Initial queue (${s.pq.length} nodes)` : `Merged node: weight ${s.merged ? s.merged.weight : ''}  — queue size ${s.pq.length}`;\n      li.style.cursor = 'pointer';\n      li.style.padding = '4px 0';\n      li.onclick = () => {\n        renderStep(i);\n      };\n      stepsList.appendChild(li);\n    }\n  }\n\n  function renderStep(idx){\n    if(idx < 0) idx = 0;\n    if(idx >= steps.length) idx = steps.length - 1;\n    currentStep = idx;\n    stepNumSpan.textContent = idx;\n    // Render queue\n    const snapshot = steps[idx].pq;\n    queueArea.innerHTML = snapshot.map(q=>{\n      const sym = q.isLeaf ? (q.sym === ' ' ? '␣' : escapeHtml(q.sym)) : '(int)';\n      return `<div style=\"display:inline-block; margin-right:8px; padding:6px 8px; border-radius:6px; background:#fff; border:1px solid #eee;\">\n        <div style=\"font-weight:700\">${sym}</div>\n        <div style=\"font-size:12px;color:#666\">${q.weight}</div>\n      </div>`;\n    }).join('');\n\n    // Render tree: from partial nodes available at this step\n    // Need to reconstruct full nodes that are present in pq: these refer to leftId/rightId in snapshots\n    const nodesMap = {};\n    // Build from final tree but only include nodes reachable from ids present in snapshot\n    for(const q of snapshot){\n      // For each id, if exists in treeNodesById, clone that subtree for display\n      const original = treeNodesById[q.id] || findNodeInInitial(q.id);\n      if(original) nodesMap[q.id] = cloneSubtree(original);\n    }\n    // If there are multiple roots (nodes in pq), create a virtual root joining them for layout (not used in code)\n    // We'll display each node as independent trees side-by-side; for simplicity, create a temporary super-root with children = pq nodes\n    const superRoot = { id: 'super', isLeaf: false, left: null, right: null };\n    // For layout convenience, transform multiple children to a binary chain: chain them to the right\n    // Build chain: first = nodesMap[pq[0].id], then right = rest chained\n    if(snapshot.length > 0){\n      let chain = cloneSubtree(nodesMap[snapshot[0].id] || { id:'empty', isLeaf:true, sym:'?', weight:0 });\n      for(let i=1;i<snapshot.length;i++){\n        const next = cloneSubtree(nodesMap[snapshot[i].id] || { id:'empty'+i, isLeaf:true, sym:'?', weight:0 });\n        chain = { id: 'chain' + i + '_' + Math.random().toString(36).slice(2,5), isLeaf:false, left: chain, right: next, weight: (chain.weight || 0) + (next.weight || 0) };\n      }\n      superRoot.left = chain;\n      superRoot.right = null; // single child chain, visualization handles chaining\n    } else {\n      superRoot.left = null;\n    }\n\n    // For visualization we want a single root. If only one element in pq and it's fully built tree, show it\n    const vizRoot = snapshot.length === 1 ? (treeNodesById[snapshot[0].id] || cloneSubtree(nodesMap[snapshot[0].id])) : superRoot.left;\n\n    // Build a small internal registry for nodes displayed\n    const vizNodes = {};\n    if(vizRoot) {\n      traverseAssignTemp(vizRoot, vizNodes);\n    }\n\n    drawTree(vizRoot, idx);\n\n    // Update steps list highlight\n    const lis = stepsList.querySelectorAll('li');\n    lis.forEach((li, i) => li.style.fontWeight = i === idx ? '700' : 'normal');\n  }\n\n  function traverseAssignTemp(node, map){\n    if(!node) return;\n    map[node.id] = node;\n    if(node.left) traverseAssignTemp(node.left, map);\n    if(node.right) traverseAssignTemp(node.right, map);\n  }\n\n  function drawTree(root, stepIdx){\n    treeSvg.innerHTML = '';\n    if(!root){\n      // Nothing to show\n      const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n      t.setAttribute('x','10');\n      t.setAttribute('y','20');\n      t.setAttribute('fill','#666');\n      t.textContent = 'No tree to display yet.';\n      treeSvg.appendChild(t);\n      return;\n    }\n\n    // Compute positions: assign x positions to leaves evenly\n    const leaves = [];\n    function collectLeaves(n, depth){\n      if(!n) return;\n      if(n.isLeaf || (!n.left && !n.right)) {\n        leaves.push(n);\n      } else {\n        collectLeaves(n.left, depth+1);\n        collectLeaves(n.right, depth+1);\n      }\n    }\n    collectLeaves(root, 0);\n    const leafCount = Math.max(1, leaves.length);\n    const width = 960;\n    const height = 260;\n    const marginX = 20;\n    const marginY = 20;\n    const xSpacing = (width - marginX*2) / (leafCount);\n    // assign x to leaves in order of left-to-right traversal\n    let idx = 0;\n    function assignX(n, depth){\n      if(!n) return;\n      if(n.isLeaf || (!n.left && !n.right)){\n        n._x = marginX + idx * xSpacing + xSpacing/2;\n        n._y = marginY + depth * 40;\n        idx++;\n      } else {\n        assignX(n.left, depth+1);\n        assignX(n.right, depth+1);\n        // internal node x is middle of children\n        const lx = n.left ? n.left._x : null;\n        const rx = n.right ? n.right._x : null;\n        n._x = ( (lx || 0) + (rx || lx || 0) ) / ( (rx ? 1 : 0) + 1 );\n        n._y = marginY + depth * 40;\n      }\n    }\n    assignX(root, 0);\n\n    // Expand viewBox to fit\n    treeSvg.setAttribute('viewBox','0 0 ' + width + ' ' + height);\n\n    // Draw edges first\n    function drawEdges(n){\n      if(!n) return;\n      if(n.left){\n        if(showEdges.checked) {\n          const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n          line.setAttribute('x1', n._x);\n          line.setAttribute('y1', n._y + 14);\n          line.setAttribute('x2', n.left._x);\n          line.setAttribute('y2', n.left._y - 14);\n          line.setAttribute('stroke','#bbb');\n          line.setAttribute('stroke-width','1.2');\n          treeSvg.appendChild(line);\n          // bit label on edge\n          const txt = document.createElementNS('http://www.w3.org/2000/svg','text');\n          txt.setAttribute('x', (n._x + n.left._x)/2 );\n          txt.setAttribute('y', (n._y + n.left._y)/2 - 4 );\n          txt.setAttribute('fill','#555');\n          txt.setAttribute('class','node-label');\n          txt.textContent = leftBitZero.checked ? '0' : '1';\n          treeSvg.appendChild(txt);\n        }\n        drawEdges(n.left);\n      }\n      if(n.right){\n        if(showEdges.checked) {\n          const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n          line.setAttribute('x1', n._x);\n          line.setAttribute('y1', n._y + 14);\n          line.setAttribute('x2', n.right._x);\n          line.setAttribute('y2', n.right._y - 14);\n          line.setAttribute('stroke','#bbb');\n          line.setAttribute('stroke-width','1.2');\n          treeSvg.appendChild(line);\n          // bit label on edge\n          const txt = document.createElementNS('http://www.w3.org/2000/svg','text');\n          txt.setAttribute('x', (n._x + n.right._x)/2 );\n          txt.setAttribute('y', (n._y + n.right._y)/2 - 4 );\n          txt.setAttribute('fill','#555');\n          txt.setAttribute('class','node-label');\n          txt.textContent = leftBitZero.checked ? '1' : '0';\n          treeSvg.appendChild(txt);\n        }\n        drawEdges(n.right);\n      }\n    }\n    drawEdges(root);\n\n    // Draw nodes\n    function drawNode(n){\n      // group\n      const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      g.setAttribute('transform', `translate(${n._x},${n._y})`);\n      g.setAttribute('class', 'node ' + (n.isLeaf ? 'leaf' : 'internal'));\n      g.setAttribute('data-id', n.id);\n      // circle\n      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n      circle.setAttribute('r', 14);\n      circle.setAttribute('cx', 0);\n      circle.setAttribute('cy', 0);\n      circle.setAttribute('fill', n.isLeaf ? '#eaf5ff' : '#fff6e5');\n      circle.setAttribute('stroke', n.isLeaf ? '#1e88e5' : '#ff8a00');\n      circle.setAttribute('stroke-width', '1.6');\n      g.appendChild(circle);\n      // weight text\n      const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n      t.setAttribute('y', 4);\n      t.setAttribute('fill', '#111');\n      t.setAttribute('font-size', '11');\n      t.textContent = n.weight != null ? n.weight : '';\n      g.appendChild(t);\n\n      // symbol label for leaf below circle\n      if(n.isLeaf){\n        const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');\n        lbl.setAttribute('y', 30);\n        lbl.setAttribute('fill', '#222');\n        lbl.setAttribute('font-size', '12');\n        lbl.setAttribute('text-anchor','middle');\n        lbl.textContent = n.sym === ' ' ? '␣' : n.sym;\n        g.appendChild(lbl);\n      }\n\n      // make clickable\n      g.style.cursor = 'pointer';\n      g.addEventListener('click', (ev)=>{\n        ev.stopPropagation();\n        showNodeDetails(n);\n        // highlight node\n        Array.from(treeSvg.querySelectorAll('.node circle')).forEach(c => c.setAttribute('stroke-width', '1.6'));\n        circle.setAttribute('stroke-width','3');\n      });\n\n      treeSvg.appendChild(g);\n\n      if(n.left) drawNode(n.left);\n      if(n.right) drawNode(n.right);\n    }\n    drawNode(root);\n  }\n\n  function showNodeDetails(n){\n    let html = `<div><strong>Node ID:</strong> ${n.id}</div>`;\n    html += `<div><strong>Weight:</strong> ${n.weight || 0}</div>`;\n    if(n.isLeaf){\n      html += `<div><strong>Symbol:</strong> ${n.sym === ' ' ? '␣ (space)' : escapeHtml(n.sym)}</div>`;\n      const code = finalCodes[n.sym] || computeCodeForNode(n);\n      html += `<div><strong>Final code:</strong> <span class=\"codecell\">${code}</span></div>`;\n    } else {\n      html += `<div><strong>Internal node</strong></div>`;\n      html += `<div><em>Children:</em></div>`;\n      html += `<div style=\"margin-left:10px\">Left: ${n.left ? (n.left.isLeaf ? (n.left.sym === ' ' ? '␣' : escapeHtml(n.left.sym)) : '(internal)') : '—'}</div>`;\n      html += `<div style=\"margin-left:10px\">Right: ${n.right ? (n.right.isLeaf ? (n.right.sym === ' ' ? '␣' : escapeHtml(n.right.sym)) : '(internal)') : '—'}</div>`;\n    }\n    nodeDetails.innerHTML = html;\n  }\n\n  function computeCodeForNode(targetNode){\n    // If finalRoot exists, walk to find path to target\n    if(!finalRoot) return '';\n    let found = null;\n    function dfs(n, prefix){\n      if(!n || found) return;\n      if(n === targetNode || (n.isLeaf && targetNode.isLeaf && n.sym === targetNode.sym && n.weight === targetNode.weight)){\n        found = prefix;\n        return;\n      }\n      dfs(n.left, prefix + (leftBitZero.checked ? '0' : '1'));\n      dfs(n.right, prefix + (leftBitZero.checked ? '1' : '0'));\n    }\n    dfs(finalRoot, '');\n    return found || '';\n  }\n\n  // Step control\n  stepNextBtn.addEventListener('click', ()=>{\n    if(steps.length === 0) return;\n    renderStep(Math.min(currentStep + 1, steps.length - 1));\n  });\n  stepBackBtn.addEventListener('click', ()=>{\n    if(steps.length === 0) return;\n    renderStep(Math.max(currentStep - 1, 0));\n  });\n  fastForwardBtn.addEventListener('click', ()=>{\n    if(steps.length === 0) return;\n    renderStep(steps.length - 1);\n  });\n\n  analyzeBtn.addEventListener('click', analyzeInput);\n\n  // Auto-play\n  autoPlayBtn.addEventListener('click', ()=>{\n    if(autoPlaying){\n      autoPlaying = false;\n      clearInterval(stepTimer);\n      autoPlayBtn.textContent = 'Auto-play';\n      return;\n    }\n    if(steps.length === 0){\n      analyzeInput();\n    }\n    autoPlaying = true;\n    autoPlayBtn.textContent = 'Stop';\n    renderStep(0);\n    stepTimer = setInterval(()=>{\n      if(currentStep >= steps.length - 1){\n        clearInterval(stepTimer);\n        autoPlaying = false;\n        autoPlayBtn.textContent = 'Auto-play';\n        return;\n      }\n      renderStep(currentStep + 1);\n    }, 700);\n  });\n\n  // Encode input using final codes\n  encodeBtn.addEventListener('click', ()=>{\n    if(Object.keys(finalCodes).length === 0){\n      alert('No codes available. Click \"Analyze\" first.');\n      return;\n    }\n    const txt = inputText.value;\n    let bits = '';\n    for(let ch of txt){\n      if(ignoreSpaces.checked && ch === ' ') continue;\n      const c = finalCodes[ch];\n      if(!c){\n        alert('No code for symbol: ' + JSON.stringify(ch));\n        return;\n      }\n      bits += c;\n    }\n    bitString.value = bits;\n    updateSizeMetrics();\n  });\n\n  // Decode bitstring\n  decodeBtn.addEventListener('click', ()=>{\n    if(!finalRoot) { alert('Tree not built. Analyze first.'); return; }\n    const bits = bitString.value.trim();\n    if(bits.length === 0){ alert('Enter a bit string to decode.'); return; }\n    let out = '';\n    let node = finalRoot;\n    const leftZero = leftBitZero.checked;\n    for(let i=0;i<bits.length;i++){\n      const b = bits[i];\n      if(b !== '0' && b !== '1') continue;\n      if(b === (leftZero ? '0' : '1')) node = node.left;\n      else node = node.right;\n      if(!node) { alert('Decoding error at bit index ' + i + '. Path invalid.'); return; }\n      if(node.isLeaf){\n        out += node.sym;\n        node = finalRoot;\n      }\n    }\n    // If ended in non-root and not at leaf, that's an incomplete code; still show what we have\n    if(node !== finalRoot && !node.isLeaf){\n      alert('Bit string ended on a non-leaf node. It may be truncated.');\n    }\n    inputText.value = out;\n    analyzeInput();\n  });\n\n  copyBitsBtn.addEventListener('click', ()=>{\n    const txt = bitString.value;\n    if(navigator.clipboard){\n      navigator.clipboard.writeText(txt).then(()=>alert('Copied bits to clipboard.'));\n    } else {\n      // fallback\n      prompt('Copy bits:', txt);\n    }\n  });\n\n  resetBtn.addEventListener('click', ()=>{\n    inputText.value = '';\n    resetState();\n  });\n\n  // Helpers\n  function escapeHtml(s){\n    return (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');\n  }\n\n  function findNodeInInitial(id){\n    // search initial nodes array\n    for(const n of nodes){\n      if(n.id === id) return n;\n    }\n    return null;\n  }\n\n  function cloneSubtree(n){\n    if(!n) return null;\n    return {\n      id: n.id,\n      isLeaf: !!n.isLeaf,\n      sym: n.sym,\n      weight: n.weight,\n      left: cloneSubtree(n.left),\n      right: cloneSubtree(n.right)\n    };\n  }\n\n  // Initialize with default analysis\n  analyzeInput();\n\n  // End of IIFE\n})();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Huffman Coding"
    }
  ],
  "topic": "Huffman Coding",
  "hasFSM": false,
  "hasTest": true
}