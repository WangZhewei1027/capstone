{
  "id": "d80b3452-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:17.229Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Breadth-First Search (BFS) Visualization</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --cell-size: 28px;\n      --gap: 2px;\n      --bg: #111827;\n      --panel: #0f1724;\n      --accent: #60a5fa;\n      --visited: #93c5fd;\n      --frontier: #fb923c;\n      --wall: #111827;\n      --path: #34d399;\n      --start: #a78bfa;\n      --end: #f472b6;\n      --text: #e6edf3;\n    }\n    body{\n      margin:0;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background: linear-gradient(180deg, #071129 0%, #041026 100%);\n      color: var(--text);\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .app{\n      max-width: 1100px;\n      margin: 24px auto;\n      display: grid;\n      grid-template-columns: 1fr 360px;\n      gap: 18px;\n      padding: 18px;\n    }\n    .panel{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.04);\n      border-radius: 10px;\n      padding: 14px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n    }\n    .left{\n      padding: 18px;\n    }\n    .controls{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n      margin-bottom:12px;\n    }\n    button, select, input[type=\"number\"], input[type=\"range\"]{\n      background: transparent;\n      border: 1px solid rgba(255,255,255,0.06);\n      color:var(--text);\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      font-size:13px;\n    }\n    button.primary{\n      background: linear-gradient(90deg, #2563eb, #60a5fa);\n      color: white;\n      border: none;\n      box-shadow: 0 6px 18px rgba(37,99,235,0.16);\n    }\n    .grid-wrap{\n      display:flex;\n      gap:12px;\n      align-items:flex-start;\n    }\n    .grid{\n      display:grid;\n      grid-template-columns: repeat(var(--cols), var(--cell-size));\n      grid-auto-rows: var(--cell-size);\n      gap: var(--gap);\n      background: #041024;\n      padding: 12px;\n      border-radius: 10px;\n    }\n    .cell{\n      width: var(--cell-size);\n      height: var(--cell-size);\n      border-radius: 6px;\n      background: #07203a;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-size:11px;\n      color:rgba(255,255,255,0.85);\n      user-select:none;\n      cursor:pointer;\n      transition: background 120ms, transform 80ms;\n    }\n    .cell.wall{ background: var(--wall); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02); }\n    .cell.visited{ background: var(--visited); color:#062c4a; }\n    .cell.frontier{ background: var(--frontier); color:#2b0f00; }\n    .cell.path{ background: var(--path); color:#052515; }\n    .cell.start{ background: var(--start); color:#0b0720; font-weight:700; }\n    .cell.end{ background: var(--end); color:#2b0624; font-weight:700; }\n    .cell.curr{ outline: 2px solid rgba(255,255,255,0.08); transform: scale(1.05); }\n    .legend{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n      margin-top:10px;\n    }\n    .legend .item{\n      display:flex;\n      align-items:center;\n      gap:8px;\n      font-size:13px;\n      color:rgba(255,255,255,0.8);\n    }\n    .swatch{\n      width:18px;height:18px;border-radius:4px;border:1px solid rgba(255,255,255,0.04);\n    }\n    .stats{\n      margin-top:12px;\n      font-size:13px;\n      line-height:1.5;\n    }\n    .right{\n      padding:16px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .section{\n      background: rgba(255,255,255,0.02);\n      padding:12px;\n      border-radius:8px;\n      border: 1px solid rgba(255,255,255,0.02);\n    }\n    label{ display:block; font-size:12px; color:rgba(255,255,255,0.8); margin-bottom:6px; }\n    .queue-list{\n      max-height:180px; overflow:auto;\n      background: rgba(0,0,0,0.15);\n      padding:8px; border-radius:6px;\n      font-family: monospace;\n      font-size:13px;\n    }\n    .small{\n      font-size:12px;\n      color:rgba(255,255,255,0.75);\n    }\n    .footer{\n      font-size:12px; color:rgba(255,255,255,0.6); margin-top:8px;\n    }\n    @media (max-width:980px){\n      .app{ grid-template-columns: 1fr; padding:12px; }\n      .grid-wrap{ flex-direction:column; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"panel left\">\n      <div style=\"display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:10px;\">\n        <div>\n          <h2 style=\"margin:0 0 3px 0; font-size:18px;\">BFS Visualizer</h2>\n          <div class=\"small\">Breadth-First Search on a grid (4-neighbors)</div>\n        </div>\n        <div style=\"text-align:right;\">\n          <div class=\"small\">Unweighted shortest path</div>\n        </div>\n      </div>\n\n      <div class=\"controls\">\n        <button id=\"mode-draw\" class=\"primary\">Draw Walls</button>\n        <button id=\"mode-start\">Set Start</button>\n        <button id=\"mode-end\">Set End</button>\n        <button id=\"clear-walls\">Clear Walls</button>\n        <button id=\"randomize\">Randomize</button>\n        <button id=\"reset-bfs\">Reset BFS</button>\n      </div>\n\n      <div class=\"controls\" style=\"margin-bottom:14px;\">\n        <button id=\"run\" class=\"primary\">Run</button>\n        <button id=\"step\">Step</button>\n        <button id=\"pause\">Pause</button>\n        <label style=\"display:flex;align-items:center;gap:8px;\">\n          Speed\n          <input id=\"speed\" type=\"range\" min=\"50\" max=\"1200\" step=\"10\" value=\"220\" />\n        </label>\n        <label style=\"display:flex;align-items:center;gap:6px;\">\n          Rows\n          <input id=\"rows\" type=\"number\" min=\"6\" max=\"40\" value=\"16\" style=\"width:66px;\" />\n        </label>\n        <label style=\"display:flex;align-items:center;gap:6px;\">\n          Cols\n          <input id=\"cols\" type=\"number\" min=\"6\" max=\"60\" value=\"28\" style=\"width:66px;\" />\n        </label>\n        <button id=\"resize\">Resize Grid</button>\n      </div>\n\n      <div class=\"grid-wrap\">\n        <div>\n          <div id=\"grid\" class=\"grid\" style=\"--cols:28;\"></div>\n          <div class=\"legend\">\n            <div class=\"item\"><div class=\"swatch\" style=\"background:var(--start)\"></div> Start</div>\n            <div class=\"item\"><div class=\"swatch\" style=\"background:var(--end)\"></div> End</div>\n            <div class=\"item\"><div class=\"swatch\" style=\"background:var(--wall)\"></div> Wall</div>\n            <div class=\"item\"><div class=\"swatch\" style=\"background:var(--visited)\"></div> Visited</div>\n            <div class=\"item\"><div class=\"swatch\" style=\"background:var(--frontier)\"></div> Frontier (Queue)</div>\n            <div class=\"item\"><div class=\"swatch\" style=\"background:var(--path)\"></div> Final Path</div>\n          </div>\n          <div class=\"stats\">\n            <div>Mode: <span id=\"mode-label\">Draw Walls</span></div>\n            <div>Start: <span id=\"start-pos\"></span> &nbsp; End: <span id=\"end-pos\"></span></div>\n            <div>Visited nodes: <span id=\"visited-count\">0</span></div>\n            <div>Path length: <span id=\"path-length\">-</span></div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel right\">\n      <div class=\"section\">\n        <h3 style=\"margin:0 0 8px 0;\">Queue (front → back)</h3>\n        <div id=\"queue\" class=\"queue-list\">[ empty ]</div>\n      </div>\n\n      <div class=\"section\">\n        <h3 style=\"margin:0 0 8px 0;\">Instructions</h3>\n        <div class=\"small\">\n          - Click cells to toggle walls in \"Draw Walls\" mode.<br>\n          - Click \"Set Start\" or \"Set End\" then click a cell to place them.<br>\n          - Run will animate BFS; Step advances one state.<br>\n          - Pause to stop the animation; Reset BFS clears visited and path but keeps walls.<br>\n          - Resize changes the grid size (resets everything).\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <h3 style=\"margin:0 0 8px 0;\">Controls Help</h3>\n        <div class=\"small\">BFS explores neighbors level-by-level, guaranteeing the shortest path on an unweighted grid. The frontier shows the queue contents; visited are marked as explored. Once the end is found, the shortest path is reconstructed using parent pointers.</div>\n      </div>\n\n      <div class=\"footer\">Made for demonstration • Click cells to interact</div>\n    </div>\n  </div>\n\n<script>\n(() => {\n  // Config & state\n  let rows = parseInt(document.getElementById('rows').value,10) || 16;\n  let cols = parseInt(document.getElementById('cols').value,10) || 28;\n  const gridEl = document.getElementById('grid');\n  const modeLabel = document.getElementById('mode-label');\n  const startPosEl = document.getElementById('start-pos');\n  const endPosEl = document.getElementById('end-pos');\n  const visitedCountEl = document.getElementById('visited-count');\n  const pathLengthEl = document.getElementById('path-length');\n  const queueEl = document.getElementById('queue');\n  const speedEl = document.getElementById('speed');\n\n  let mode = 'draw'; // draw | start | end\n  let isRunning = false;\n  let animationTimer = null;\n  let animDelay = Number(speedEl.value);\n\n  // Grid data: array of cells row-major\n  let cells = [];\n  let start = {r:0,c:0};\n  let end = {r: rows-1, c: cols-1};\n\n  // BFS state\n  let bfsGenerator = null;\n  let currentQueue = [];\n  let visitedCount = 0;\n  let found = false;\n\n  // Initialize\n  function createGrid(r, c){\n    rows = r; cols = c;\n    gridEl.style.setProperty('--cols', cols);\n    gridEl.innerHTML = '';\n    cells = new Array(rows*cols);\n    for(let i=0;i<rows;i++){\n      for(let j=0;j<cols;j++){\n        const idx = i*cols + j;\n        const el = document.createElement('div');\n        el.className = 'cell';\n        el.dataset.r = i;\n        el.dataset.c = j;\n        el.title = `(${i},${j})`;\n        el.addEventListener('click', onCellClick);\n        el.addEventListener('mousedown', onCellDown);\n        cells[idx] = {\n          r:i, c:j, el,\n          wall:false, visited:false, inQueue:false, parent:null, dist: Infinity\n        };\n        gridEl.appendChild(el);\n      }\n    }\n    // default start end\n    start = {r:0,c:0};\n    end = {r: rows-1, c: cols-1};\n    resetBFSState(true);\n    render();\n  }\n\n  function idx(r,c){ return r*cols + c; }\n\n  function onCellClick(e){\n    const r = Number(this.dataset.r), c = Number(this.dataset.c);\n    const cell = cells[idx(r,c)];\n    if(mode === 'draw'){\n      // toggle wall but don't allow start/end to be wall\n      if((r===start.r && c===start.c) || (r===end.r && c===end.c)) return;\n      cell.wall = !cell.wall;\n      renderCell(cell);\n    } else if(mode === 'start'){\n      // move start (can't place on wall or on end)\n      if(cell.wall) return;\n      if(r===end.r && c===end.c) return;\n      start = {r,c};\n      resetBFSState(true);\n      render();\n    } else if(mode === 'end'){\n      if(cell.wall) return;\n      if(r===start.r && c===start.c) return;\n      end = {r,c};\n      resetBFSState(true);\n      render();\n    }\n  }\n\n  let mouseDown = false;\n  function onCellDown(e){\n    // support drag drawing walls\n    mouseDown = true;\n    function moveHandler(ev){\n      ev.preventDefault();\n      const el = document.elementFromPoint(ev.clientX, ev.clientY);\n      if(!el || !el.classList || !el.classList.contains('cell')) return;\n      const r = Number(el.dataset.r), c = Number(el.dataset.c);\n      const cell = cells[idx(r,c)];\n      if(mode !== 'draw') return;\n      if((r===start.r && c===start.c) || (r===end.r && c===end.c)) return;\n      cell.wall = true;\n      renderCell(cell);\n    }\n    function upHandler(){ mouseDown=false; window.removeEventListener('mousemove', moveHandler); window.removeEventListener('mouseup', upHandler); }\n    window.addEventListener('mousemove', moveHandler);\n    window.addEventListener('mouseup', upHandler);\n  }\n\n  document.body.addEventListener('mouseup', ()=>mouseDown=false);\n\n  // Controls\n  document.getElementById('mode-draw').addEventListener('click', ()=>{\n    mode = 'draw'; updateModeUI();\n  });\n  document.getElementById('mode-start').addEventListener('click', ()=>{\n    mode = 'start'; updateModeUI();\n  });\n  document.getElementById('mode-end').addEventListener('click', ()=>{\n    mode = 'end'; updateModeUI();\n  });\n  document.getElementById('clear-walls').addEventListener('click', ()=>{\n    for(const cell of cells){ cell.wall = false; }\n    resetBFSState(true);\n    render();\n  });\n  document.getElementById('randomize').addEventListener('click', ()=>{\n    for(const cell of cells){\n      cell.wall = (Math.random() < 0.26);\n    }\n    // ensure start/end not wall\n    cells[idx(start.r,start.c)].wall = false;\n    cells[idx(end.r,end.c)].wall = false;\n    resetBFSState(true);\n    render();\n  });\n  document.getElementById('reset-bfs').addEventListener('click', ()=>{\n    resetBFSState(false);\n    render();\n  });\n  document.getElementById('run').addEventListener('click', ()=>{\n    if(isRunning) return;\n    if(!bfsGenerator) bfsGenerator = bfs();\n    isRunning = true;\n    animDelay = Number(speedEl.value);\n    runAnimation();\n  });\n  document.getElementById('pause').addEventListener('click', ()=>{\n    stopAnimation();\n  });\n  document.getElementById('step').addEventListener('click', ()=>{\n    if(!bfsGenerator) bfsGenerator = bfs();\n    stepOnce();\n  });\n  speedEl.addEventListener('input', ()=>{ animDelay = Number(speedEl.value); });\n  document.getElementById('resize').addEventListener('click', ()=>{\n    const r = Math.max(6, Math.min(40, parseInt(document.getElementById('rows').value,10) || 16));\n    const c = Math.max(6, Math.min(60, parseInt(document.getElementById('cols').value,10) || 28));\n    createGrid(r,c);\n  });\n\n  function updateModeUI(){\n    modeLabel.textContent = mode === 'draw' ? 'Draw Walls' : mode === 'start' ? 'Set Start' : 'Set End';\n    // highlight button\n    document.getElementById('mode-draw').classList.toggle('primary', mode==='draw');\n    document.getElementById('mode-start').classList.toggle('primary', mode==='start');\n    document.getElementById('mode-end').classList.toggle('primary', mode==='end');\n  }\n\n  // Rendering\n  function render(){\n    for(const cell of cells) renderCell(cell);\n    updateInfo();\n  }\n  function renderCell(cell){\n    const el = cell.el;\n    el.className = 'cell';\n    if(cell.wall) el.classList.add('wall');\n    if(cell.visited) el.classList.add('visited');\n    if(cell.inQueue) el.classList.add('frontier');\n    if(cell.isPath) el.classList.add('path');\n    if(cell.r === start.r && cell.c === start.c) el.classList.add('start');\n    if(cell.r === end.r && cell.c === end.c) el.classList.add('end');\n    if(cell.curr) el.classList.add('curr');\n    // show distance optionally: display small number if visited and not start/end/path\n    if(cell.dist !== Infinity && (cell.visited || cell.isPath) && !(cell.r===start.r && cell.c===start.c) && !(cell.r===end.r && cell.c===end.c)){\n      el.textContent = cell.dist;\n    } else {\n      el.textContent = '';\n    }\n  }\n  function updateInfo(){\n    startPosEl.textContent = `(${start.r},${start.c})`;\n    endPosEl.textContent = `(${end.r},${end.c})`;\n    visitedCountEl.textContent = visitedCount;\n    pathLengthEl.textContent = found ? calculatePathLength() : '-';\n    renderQueue();\n  }\n  function renderQueue(){\n    if(currentQueue.length === 0){\n      queueEl.textContent = '[ empty ]';\n    } else {\n      queueEl.innerHTML = currentQueue.map(n=>`(${n.r},${n.c})`).join(' ← ');\n    }\n  }\n\n  // BFS generator for step-by-step\n  function* bfs(){\n    // reset properties but keep walls and start/end\n    for(const c of cells){\n      c.visited = false; c.inQueue = false; c.parent = null; c.dist = Infinity;\n      c.isPath = false; c.curr = false;\n    }\n    visitedCount = 0;\n    found = false;\n    currentQueue = [];\n    // If start or end on wall -> abort\n    if(cells[idx(start.r,start.c)].wall || cells[idx(end.r,end.c)].wall){\n      updateInfo();\n      return;\n    }\n    // init\n    const sIdx = idx(start.r,start.c);\n    cells[sIdx].visited = true;\n    cells[sIdx].dist = 0;\n    currentQueue.push({r:start.r,c:start.c});\n    cells[sIdx].inQueue = true;\n    yield; // initial state\n\n    while(currentQueue.length){\n      // pop front\n      const cur = currentQueue.shift();\n      const curCell = cells[idx(cur.r,cur.c)];\n      curCell.inQueue = false;\n      // mark as current\n      curCell.curr = true;\n      yield;\n      // check goal\n      if(cur.r === end.r && cur.c === end.c){\n        found = true;\n        // reconstruct path\n        let p = curCell;\n        while(p){\n          p.isPath = true;\n          p = p.parent ? cells[idx(p.parent.r,p.parent.c)] : null;\n        }\n        curCell.curr = false;\n        yield;\n        return;\n      }\n      // explore neighbors (4 directions)\n      const deltas = [[-1,0],[1,0],[0,-1],[0,1]];\n      for(const d of deltas){\n        const nr = cur.r + d[0], nc = cur.c + d[1];\n        if(nr<0 || nr>=rows || nc<0 || nc>=cols) continue;\n        const nb = cells[idx(nr,nc)];\n        if(nb.wall || nb.visited) continue;\n        nb.visited = true;\n        nb.parent = {r:cur.r,c:cur.c};\n        nb.dist = curCell.dist + 1;\n        nb.inQueue = true;\n        visitedCount++;\n        currentQueue.push({r:nr,c:nc});\n        yield;\n      }\n      curCell.curr = false;\n      yield;\n    }\n    // finished with no path\n    yield;\n  }\n\n  function stepOnce(){\n    if(!bfsGenerator) bfsGenerator = bfs();\n    const res = bfsGenerator.next();\n    render();\n    if(res.done){\n      bfsGenerator = null;\n      stopAnimation();\n    }\n  }\n\n  function runAnimation(){\n    if(!bfsGenerator) bfsGenerator = bfs();\n    function tick(){\n      const res = bfsGenerator.next();\n      render();\n      if(res.done){\n        bfsGenerator = null;\n        stopAnimation();\n        return;\n      }\n      animationTimer = setTimeout(()=>{ if(isRunning) requestAnimationFrame(tick); }, animDelay);\n    }\n    isRunning = true;\n    requestAnimationFrame(tick);\n  }\n\n  function stopAnimation(){\n    isRunning = false;\n    if(animationTimer) { clearTimeout(animationTimer); animationTimer = null; }\n  }\n\n  function resetBFSState(fullReset){\n    stopAnimation();\n    bfsGenerator = null;\n    currentQueue = [];\n    visitedCount = 0;\n    found = false;\n    for(const c of cells){\n      c.visited = false; c.inQueue = false; c.parent = null; c.dist = Infinity;\n      c.isPath = false; c.curr = false;\n      if(fullReset){\n        c.wall = c.wall || false; // keep as-is, but fullReset may also be used when resizing; in resize we recreate grid\n      }\n    }\n    updateInfo();\n  }\n\n  function calculatePathLength(){\n    // count cells with isPath true minus 1\n    const pathCells = cells.filter(c=>c.isPath).length;\n    return Math.max(0, pathCells-1);\n  }\n\n  // initial grid\n  createGrid(rows, cols);\n  updateModeUI();\n\n  // Helpful: allow keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === ' ') { // space to step\n      e.preventDefault();\n      document.getElementById('step').click();\n    } else if(e.key === 'r'){ document.getElementById('run').click();}\n    else if(e.key === 'p'){ document.getElementById('pause').click();}\n    else if(e.key === '1'){ document.getElementById('mode-draw').click();}\n    else if(e.key === '2'){ document.getElementById('mode-start').click();}\n    else if(e.key === '3'){ document.getElementById('mode-end').click();}\n  });\n\n  // Small convenience: ensure start/end labels show on create\n  render();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": false,
  "hasTest": true
}