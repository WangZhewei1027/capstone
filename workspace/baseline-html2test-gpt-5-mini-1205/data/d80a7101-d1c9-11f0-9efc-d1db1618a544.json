{
  "id": "d80a7101-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:14.309Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency List",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Adjacency List Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root { --bg:#0f1724; --panel:#0b1220; --accent:#06b6d4; --muted:#94a3b8; --card:#0b1320; color-scheme: dark; }\n    html,body { height:100%; margin:0; font-family:Inter,Segoe UI,Helvetica,Arial,sans-serif; background:linear-gradient(180deg,#071028 0%, #081226 100%); }\n    header { padding:14px 18px; display:flex; gap:12px; align-items:center; color: #e6eef7; }\n    h1 { font-size:16px; margin:0; font-weight:600; letter-spacing:0.2px; }\n    .container { display:grid; grid-template-columns: 1fr 340px; gap:12px; padding:12px; height:calc(100% - 64px); box-sizing:border-box; }\n    .canvas-card { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:10px; padding:10px; display:flex; flex-direction:column; }\n    .toolbar { display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }\n    .toolbar label { color:var(--muted); font-size:13px; display:flex; gap:6px; align-items:center; }\n    .toolbar input[type=\"number\"] { width:68px; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:transparent; color:#e6eef7; }\n    .toolbar button { background:linear-gradient(180deg,#0b6a77,#06404a); color:white; border:none; padding:8px 10px; border-radius:8px; cursor:pointer; font-size:13px; }\n    .toolbar .muted-btn { background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--muted); }\n    .toolbar .danger { background:linear-gradient(180deg,#7f1d1d,#4c0d0d); }\n    .svg-area { flex:1; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); overflow:hidden; position:relative; }\n    svg { width:100%; height:100%; display:block; touch-action:none; }\n    .side { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:10px; padding:12px; color:#e6eef7; overflow:auto; }\n    .panel-title { font-weight:600; margin:0 0 8px 0; font-size:14px; color:#dff8ff; }\n    pre { margin:6px 0; padding:8px; background:rgba(255,255,255,0.02); border-radius:6px; overflow:auto; max-height:34vh; color:#d2f2f6; font-size:13px; }\n    .list { font-size:13px; color:var(--muted); }\n    .small { font-size:12px; color:var(--muted); }\n    .controls-row { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }\n    .badge { background:rgba(255,255,255,0.03); padding:6px 8px; border-radius:7px; font-size:13px; color:#dff8ff; }\n    .node { cursor:pointer; }\n    .node circle { fill:#0ea5a8; stroke:#052f31; stroke-width:2px; }\n    .node text { fill:#021f21; font-weight:700; pointer-events:none; font-size:12px; }\n    .edge { stroke:#94a3b8; stroke-width:2; opacity:0.9; }\n    .edge-weight { fill:#dceff0; font-size:12px; pointer-events:none; }\n    .selected circle { stroke:#ffdf6e; stroke-width:3px; }\n    .highlight circle { fill:#ffd166; stroke:#bb6b0d; }\n    .highlight-edge { stroke:#ffd166; stroke-width:3; }\n    .muted-text { color:var(--muted); font-size:13px; }\n    .footer-small { font-size:12px; color:var(--muted); margin-top:6px; }\n    .row { display:flex; gap:8px; align-items:center; }\n    input[type=\"checkbox\"] { width:16px; height:16px; }\n    .linklike { color:var(--accent); cursor:pointer; text-decoration:underline; font-size:13px; }\n    .center { display:flex; align-items:center; justify-content:center; gap:8px; }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Adjacency List — Interactive Demo</h1>\n    <div style=\"margin-left:auto\" class=\"small\">Click empty space to add node. Click node then another to add edge. Toggle Directed/Weighted. Use Remove Mode to delete.</div>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"canvas-card\">\n      <div class=\"toolbar\">\n        <label><input id=\"directed\" type=\"checkbox\"> Directed</label>\n        <label><input id=\"weighted\" type=\"checkbox\"> Weighted</label>\n        <label>Weight:<input id=\"weight\" type=\"number\" value=\"1\" min=\"0\" step=\"1\"></label>\n        <button id=\"undo\" class=\"muted-btn\">Undo</button>\n        <button id=\"clear\" class=\"muted-btn\">Clear</button>\n        <button id=\"random\" class=\"muted-btn\">Random</button>\n        <button id=\"removeMode\" class=\"danger\">Remove Mode: OFF</button>\n        <div style=\"flex:1\"></div>\n        <div class=\"small muted-text\">Selected: <span id=\"selectedCount\">0</span></div>\n      </div>\n      <div class=\"svg-area\">\n        <svg id=\"svg\"></svg>\n      </div>\n      <div class=\"footer-small\">Tip: drag nodes to reposition. Use BFS/DFS buttons in the right panel to traverse the graph using the adjacency list.</div>\n    </div>\n\n    <div class=\"side\">\n      <div>\n        <div class=\"panel-title\">Adjacency List</div>\n        <div class=\"list\" id=\"adjHuman\">No nodes yet.</div>\n        <pre id=\"adjCode\">{}</pre>\n      </div>\n\n      <div style=\"margin-top:12px\">\n        <div class=\"panel-title\">Other Views & Tools</div>\n        <div class=\"small muted-text\">Adjacency matrix (rows = from):</div>\n        <pre id=\"matrix\">[]</pre>\n\n        <div style=\"margin-top:8px\" class=\"row\">\n          <label class=\"small\">Traversal:</label>\n          <select id=\"startSelect\"></select>\n          <button id=\"bfs\" class=\"muted-btn\">BFS</button>\n          <button id=\"dfs\" class=\"muted-btn\">DFS</button>\n        </div>\n\n        <div class=\"controls-row\">\n          <button id=\"export\" class=\"muted-btn\">Export JSON</button>\n          <button id=\"import\" class=\"muted-btn\">Import JSON</button>\n        </div>\n\n        <div style=\"margin-top:8px\" class=\"center\">\n          <div class=\"badge\">Nodes: <span id=\"nodeCount\">0</span></div>\n          <div class=\"badge\">Edges: <span id=\"edgeCount\">0</span></div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<script>\n(function(){\n  // Simple interactive graph editor demonstrating adjacency list representation.\n  // Graph model\n  let nodes = []; // {id, x, y}\n  let edges = []; // {id, source, target, weight}\n  let nextNodeId = 0, nextEdgeId = 0;\n  let selectedNode = null;\n  let removeMode = false;\n  let undoStack = [];\n\n  // DOM\n  const svg = document.getElementById('svg');\n  const directedBox = document.getElementById('directed');\n  const weightedBox = document.getElementById('weighted');\n  const weightInput = document.getElementById('weight');\n  const removeBtn = document.getElementById('removeMode');\n  const adjHuman = document.getElementById('adjHuman');\n  const adjCode = document.getElementById('adjCode');\n  const matrixPre = document.getElementById('matrix');\n  const startSelect = document.getElementById('startSelect');\n  const bfsBtn = document.getElementById('bfs');\n  const dfsBtn = document.getElementById('dfs');\n  const nodeCount = document.getElementById('nodeCount');\n  const edgeCount = document.getElementById('edgeCount');\n  const selectedCount = document.getElementById('selectedCount');\n  const undoBtn = document.getElementById('undo');\n  const clearBtn = document.getElementById('clear');\n  const randomBtn = document.getElementById('random');\n  const exportBtn = document.getElementById('export');\n  const importBtn = document.getElementById('import');\n\n  // SVG elements group\n  const defs = makeSVG('defs'); svg.appendChild(defs);\n  const marker = makeSVG('marker'); marker.setAttribute('id','arrow'); marker.setAttribute('markerWidth','10');\n  marker.setAttribute('markerHeight','10'); marker.setAttribute('refX','10'); marker.setAttribute('refY','3'); marker.setAttribute('orient','auto');\n  const arrowPath = makeSVG('path'); arrowPath.setAttribute('d','M0,0 L0,6 L6,3 z'); arrowPath.setAttribute('fill','#94a3b8');\n  marker.appendChild(arrowPath); defs.appendChild(marker);\n  const edgesGroup = makeSVG('g'); svg.appendChild(edgesGroup);\n  const weightsGroup = makeSVG('g'); svg.appendChild(weightsGroup);\n  const nodesGroup = makeSVG('g'); svg.appendChild(nodesGroup);\n\n  // Basic helpers\n  function makeSVG(tag){ return document.createElementNS('http://www.w3.org/2000/svg', tag); }\n\n  function addNode(x,y){\n    const id = String(nextNodeId++);\n    const node = {id, x, y};\n    nodes.push(node);\n    saveUndo();\n    render();\n    return node;\n  }\n  function addEdge(s,t,w = null){\n    // prevent duplicate for undirected graphs (store once or both? We store one edge object.)\n    const id = String(nextEdgeId++);\n    const edge = {id, source: s, target: t, weight: w};\n    edges.push(edge);\n    saveUndo();\n    render();\n    return edge;\n  }\n  function removeNodeById(id){\n    nodes = nodes.filter(n=>n.id!==id);\n    edges = edges.filter(e=>e.source!==id && e.target!==id);\n    saveUndo();\n    render();\n  }\n  function removeEdgeById(id){\n    edges = edges.filter(e=>e.id!==id);\n    saveUndo();\n    render();\n  }\n\n  // Rendering\n  function render(){\n    // clear groups\n    while(edgesGroup.firstChild) edgesGroup.removeChild(edgesGroup.firstChild);\n    while(weightsGroup.firstChild) weightsGroup.removeChild(weightsGroup.firstChild);\n    while(nodesGroup.firstChild) nodesGroup.removeChild(nodesGroup.firstChild);\n\n    // draw edges\n    edges.forEach(e=>{\n      const s = nodes.find(n=>n.id===e.source);\n      const t = nodes.find(n=>n.id===e.target);\n      if(!s || !t) return;\n      const line = makeSVG('line');\n      line.setAttribute('x1', s.x); line.setAttribute('y1', s.y);\n      line.setAttribute('x2', t.x); line.setAttribute('y2', t.y);\n      line.setAttribute('class', 'edge');\n      line.dataset.id = e.id;\n\n      // arrow for directed\n      if(directedBox.checked){\n        line.setAttribute('marker-end','url(#arrow)');\n      } else {\n        line.removeAttribute('marker-end');\n      }\n\n      // click for deletion when in remove mode\n      line.addEventListener('click', (ev)=>{\n        ev.stopPropagation();\n        if(removeMode){\n          removeEdgeById(e.id);\n        }\n      });\n\n      edgesGroup.appendChild(line);\n\n      // weight label\n      if(weightedBox.checked){\n        const mx = (s.x + t.x)/2;\n        const my = (s.y + t.y)/2;\n        const wt = makeSVG('text');\n        wt.setAttribute('x', mx); wt.setAttribute('y', my - 6);\n        wt.setAttribute('class','edge-weight');\n        wt.setAttribute('text-anchor','middle');\n        wt.textContent = e.weight != null ? e.weight : '1';\n        weightsGroup.appendChild(wt);\n      }\n    });\n\n    // draw nodes\n    nodes.forEach(n=>{\n      const g = makeSVG('g');\n      g.setAttribute('transform', `translate(${n.x},${n.y})`);\n      g.classList.add('node');\n      g.dataset.id = n.id;\n\n      const circle = makeSVG('circle'); circle.setAttribute('r','18');\n      g.appendChild(circle);\n\n      const label = makeSVG('text'); label.setAttribute('text-anchor','middle'); label.setAttribute('dy','4');\n      label.textContent = n.id;\n      g.appendChild(label);\n\n      // selection visual\n      if(selectedNode && selectedNode.id === n.id){\n        g.classList.add('selected');\n      }\n\n      // interactions\n      g.addEventListener('mousedown', (ev)=>{\n        ev.stopPropagation();\n        if(removeMode){\n          removeNodeById(n.id);\n          return;\n        }\n        // if we have a currently selected node, and it's different -> create edge\n        if(selectedNode && selectedNode.id !== n.id){\n          // add directed or undirected edge per setting\n          const w = weightedBox.checked ? parseFloat(weightInput.value || '1') : null;\n          addEdge(selectedNode.id, n.id, w);\n          // for undirected graphs we will also add a reverse representation in adjacency list (not duplicate)\n          // keep the edge object single; adjacency list builder will handle undirected by adding both links\n          selectedNode = null;\n        } else {\n          // toggle select\n          selectedNode = selectedNode && selectedNode.id === n.id ? null : n;\n        }\n        selectedCount.textContent = selectedNode ? 1 : 0;\n        render();\n      });\n\n      // drag\n      let dragging = false, sx=0, sy=0;\n      g.addEventListener('pointerdown', (ev)=>{\n        ev.preventDefault();\n        dragging = true;\n        sx = ev.clientX; sy = ev.clientY;\n        g.setPointerCapture(ev.pointerId);\n      });\n      window.addEventListener('pointermove', (ev)=>{\n        if(!dragging) return;\n        const dx = ev.clientX - sx, dy = ev.clientY - sy;\n        sx = ev.clientX; sy = ev.clientY;\n        n.x += dx; n.y += dy;\n        render();\n      });\n      window.addEventListener('pointerup', (ev)=>{\n        if(dragging){\n          dragging = false;\n          saveUndo();\n        }\n      });\n\n      nodesGroup.appendChild(g);\n    });\n\n    updatePanels();\n  }\n\n  function updatePanels(){\n    // Build adjacency list\n    const adj = {}; // map id -> array of {to, weight}\n    nodes.forEach(n=> adj[n.id]=[]);\n    edges.forEach(e=>{\n      if(!(e.source in adj) || !(e.target in adj)) return;\n      adj[e.source].push({to: e.target, weight: e.weight});\n      // For undirected graphs, also add reverse link for adjacency view\n      if(!directedBox.checked){\n        adj[e.target].push({to: e.source, weight: e.weight});\n      }\n    });\n\n    // Human readable\n    if(nodes.length === 0){\n      adjHuman.textContent = 'No nodes yet.';\n    } else {\n      adjHuman.innerHTML = '';\n      nodes.forEach(n=>{\n        const row = document.createElement('div');\n        row.innerHTML = `<strong>${n.id}</strong>: ` + (adj[n.id].length ? adj[n.id].map(o=> weightedBox.checked ? `${o.to}(${o.weight})` : `${o.to}`).join(', ') : '—');\n        row.style.marginBottom = '6px';\n        adjHuman.appendChild(row);\n      });\n    }\n\n    // Code (JS object)\n    const codeObj = {};\n    Object.keys(adj).forEach(k=>{\n      codeObj[k] = adj[k].map(o => weightedBox.checked ? {to:o.to,weight:o.weight} : o.to);\n    });\n    adjCode.textContent = JSON.stringify(codeObj, null, 2);\n\n    // Adjacency matrix\n    const ids = nodes.map(n=>n.id);\n    const matrix = ids.map(i=> ids.map(j=> {\n      // for simplicity: 1 if edge present from i->j (or for undirected symmetrical)\n      const present = edges.some(e=>{\n        if(directedBox.checked){\n          return e.source===i && e.target===j;\n        } else {\n          return (e.source===i && e.target===j) || (e.source===j && e.target===i);\n        }\n      });\n      return present ? 1 : 0;\n    }));\n    matrixPre.textContent = JSON.stringify(matrix);\n\n    // startSelect options\n    startSelect.innerHTML = '';\n    const optNone = document.createElement('option'); optNone.value=''; optNone.textContent='Choose node';\n    startSelect.appendChild(optNone);\n    nodes.forEach(n=>{\n      const o = document.createElement('option'); o.value = n.id; o.textContent = n.id;\n      startSelect.appendChild(o);\n    });\n\n    nodeCount.textContent = nodes.length;\n    edgeCount.textContent = edges.length;\n  }\n\n  // Utilities\n  function saveUndo(){\n    // shallow copy minimal state\n    undoStack.push({\n      nodes: JSON.parse(JSON.stringify(nodes)),\n      edges: JSON.parse(JSON.stringify(edges)),\n      nextNodeId, nextEdgeId\n    });\n    if(undoStack.length > 40) undoStack.shift();\n  }\n  undoBtn.addEventListener('click', ()=>{\n    const s = undoStack.pop();\n    if(!s) return;\n    nodes = s.nodes; edges = s.edges; nextNodeId = s.nextNodeId; nextEdgeId = s.nextEdgeId;\n    selectedNode = null;\n    render();\n  });\n\n  // Canvas interactions\n  svg.addEventListener('click', (ev)=>{\n    // click empty space => add node (unless removeMode)\n    const rect = svg.getBoundingClientRect();\n    const x = ev.clientX - rect.left;\n    const y = ev.clientY - rect.top;\n    if(removeMode) return;\n    addNode(x,y);\n  });\n\n  // toggle remove mode\n  removeBtn.addEventListener('click', ()=>{\n    removeMode = !removeMode;\n    removeBtn.textContent = `Remove Mode: ${removeMode ? 'ON' : 'OFF'}`;\n    if(removeMode) removeBtn.style.opacity = 0.9; else removeBtn.style.opacity = 1.0;\n  });\n\n  // clear\n  clearBtn.addEventListener('click', ()=>{\n    if(!confirm('Clear all nodes and edges?')) return;\n    saveUndo();\n    nodes = []; edges = []; nextNodeId = 0; nextEdgeId = 0; selectedNode = null;\n    render();\n  });\n\n  // random graph\n  randomBtn.addEventListener('click', ()=>{\n    const n = parseInt(prompt('Number of nodes (3-12)?', '6')||'6',10);\n    if(isNaN(n) || n<1) return;\n    saveUndo();\n    nodes = []; edges = []; nextNodeId=0; nextEdgeId=0;\n    for(let i=0;i<n;i++){\n      addNode(60 + Math.random()*(svg.clientWidth-120), 60 + Math.random()*(svg.clientHeight-120));\n    }\n    // add random edges\n    const maxE = Math.min(n*(n-1), n*3);\n    const m = Math.floor(Math.random()*maxE/2) + Math.floor(n/2);\n    for(let k=0;k<m;k++){\n      const i = nodes[Math.floor(Math.random()*nodes.length)];\n      const j = nodes[Math.floor(Math.random()*nodes.length)];\n      if(i && j && i.id !== j.id){\n        const w = weightedBox.checked ? Math.floor(Math.random()*10)+1 : null;\n        addEdge(i.id, j.id, w);\n      }\n    }\n    render();\n  });\n\n  // Export/Import\n  exportBtn.addEventListener('click', ()=>{\n    const data = {nodes, edges, directed: directedBox.checked, weighted: weightedBox.checked};\n    const txt = JSON.stringify(data, null, 2);\n    navigator.clipboard?.writeText(txt).then(()=> alert('Graph JSON copied to clipboard.'), ()=> alert('Copy failed. Here is the JSON:\\n\\n' + txt));\n  });\n  importBtn.addEventListener('click', ()=>{\n    const txt = prompt('Paste graph JSON (nodes, edges).');\n    if(!txt) return;\n    try{\n      const data = JSON.parse(txt);\n      if(data.nodes && data.edges){\n        saveUndo();\n        nodes = data.nodes;\n        edges = data.edges;\n        nextNodeId = Math.max(0, ...nodes.map(n=>parseInt(n.id,10) || 0)) + 1;\n        nextEdgeId = Math.max(0, ...edges.map(e=>parseInt(e.id,10) || 0)) + 1;\n        directedBox.checked = !!data.directed;\n        weightedBox.checked = !!data.weighted;\n        render();\n      } else alert('Invalid format.');\n    } catch(err){ alert('Invalid JSON'); }\n  });\n\n  // Traversals using adjacency list\n  function buildAdjMap(){\n    // returns Map id -> array of neighbors (with optional weights)\n    const map = new Map();\n    nodes.forEach(n=> map.set(n.id, []));\n    edges.forEach(e=>{\n      if(!map.has(e.source) || !map.has(e.target)) return;\n      map.get(e.source).push({to:e.target, weight: e.weight});\n      if(!directedBox.checked){\n        map.get(e.target).push({to:e.source, weight: e.weight});\n      }\n    });\n    return map;\n  }\n\n  function animateSequence(seq){\n    // seq is array of node ids in visit order\n    let idx = 0;\n    const interval = setInterval(()=>{\n      // clear highlights\n      nodesGroup.querySelectorAll('g').forEach(g=> g.classList.remove('highlight'));\n      edgesGroup.querySelectorAll('line').forEach(l=> l.classList.remove('highlight-edge'));\n      if(idx >= seq.length){\n        clearInterval(interval);\n        return;\n      }\n      const id = seq[idx];\n      const g = nodesGroup.querySelector(`g[data-id='${id}']`);\n      if(g) g.classList.add('highlight');\n      // highlight edge from previous to current\n      if(idx>0){\n        const prev = seq[idx-1];\n        const line = edgesGroup.querySelectorAll('line');\n        for(const l of line){\n          const e = edges.find(x=>x.id===l.dataset.id);\n          if(!e) continue;\n          if(e.source===prev && e.target===id){\n            l.classList.add('highlight-edge');\n            break;\n          }\n          if(!directedBox.checked && ((e.source===id && e.target===prev) || (e.source===prev && e.target===id))){\n            l.classList.add('highlight-edge');\n            break;\n          }\n        }\n      }\n      idx++;\n    }, 700);\n  }\n\n  bfsBtn.addEventListener('click', ()=>{\n    const start = startSelect.value;\n    if(!start) { alert('Choose start node'); return; }\n    const adj = buildAdjMap();\n    const q = [start];\n    const visited = new Set([start]);\n    const order = [];\n    while(q.length){\n      const u = q.shift();\n      order.push(u);\n      for(const nb of adj.get(u) || []){\n        if(!visited.has(nb.to)){\n          visited.add(nb.to);\n          q.push(nb.to);\n        }\n      }\n    }\n    animateSequence(order);\n  });\n\n  dfsBtn.addEventListener('click', ()=>{\n    const start = startSelect.value;\n    if(!start) { alert('Choose start node'); return; }\n    const adj = buildAdjMap();\n    const visited = new Set();\n    const order = [];\n    function dfs(u){\n      visited.add(u);\n      order.push(u);\n      for(const nb of adj.get(u) || []){\n        if(!visited.has(nb.to)) dfs(nb.to);\n      }\n    }\n    dfs(start);\n    animateSequence(order);\n  });\n\n  // initial render\n  render();\n\n  // small UX: allow edge clicking to delete in remove mode - already set\n  // keyboard: delete selected\n  window.addEventListener('keydown', (ev)=>{\n    if(ev.key === 'Delete' && selectedNode){\n      removeNodeById(selectedNode.id);\n      selectedNode = null; selectedCount.textContent='0';\n    }\n  });\n\n  // responsiveness: maintain svg size\n  function resizeSvg(){ svg.setAttribute('viewBox', `0 0 ${svg.clientWidth} ${svg.clientHeight}`); }\n  window.addEventListener('resize', resizeSvg);\n  resizeSvg();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency List"
    }
  ],
  "topic": "Adjacency List",
  "hasFSM": false,
  "hasTest": true
}