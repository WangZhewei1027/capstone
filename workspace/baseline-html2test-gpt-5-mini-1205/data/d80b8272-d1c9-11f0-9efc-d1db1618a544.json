{
  "id": "d80b8272-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:17.956Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\"/>\n  <title>Prim's Algorithm — Interactive Demonstration</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n  <style>\n    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, \"Helvetica Neue\", Arial; margin: 0; display: flex; height: 100vh; }\n    #left { width: 420px; border-right: 1px solid #ddd; padding: 12px; box-sizing: border-box; overflow: auto; background: #fafafa; }\n    #canvasWrap { flex: 1; position: relative; background: #fff; }\n    svg { width: 100%; height: 100%; display: block; }\n    h1 { font-size: 18px; margin: 6px 0 12px; }\n    .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px; }\n    .controls button, .controls input[type=\"number\"], select { padding: 6px; font-size: 13px; }\n    .wide { grid-column: span 2; }\n    .section { margin-bottom: 12px; }\n    label { display:block; font-size: 13px; margin-bottom: 6px; color: #333; }\n    .small { font-size: 13px; color: #444; }\n    table { width: 100%; border-collapse: collapse; font-size: 13px; }\n    th, td { border: 1px solid #eee; padding: 6px; text-align: center; }\n    th { background: #fafafa; }\n    .legend { display:flex; gap:8px; flex-wrap:wrap; font-size:12px; margin-top:8px; }\n    .legend span { display:inline-flex; align-items:center; gap:6px; padding:4px 6px; border-radius:4px; background:#fff; border:1px solid #eee; }\n    .colorbox { width:16px; height:12px; display:inline-block; border-radius:2px; }\n    .note { font-size:12px; color:#666; margin-top:8px; }\n    .mode-buttons { display:flex; gap:6px; margin-top:6px; }\n    button.active { outline: 2px solid #227; color: #227; }\n    .bottom-row { display:flex; gap:8px; align-items:center; margin-top:8px; }\n    #status { font-size:13px; color:#333; margin-left:8px; }\n    footer { position: absolute; right:8px; bottom:8px; font-size: 12px; color:#666; }\n  </style>\n</head>\n<body>\n  <div id=\"left\">\n    <h1>Prim's Algorithm — Interactive Demo</h1>\n\n    <div class=\"section\">\n      <label>Graph generation</label>\n      <div class=\"controls\">\n        <input id=\"nodeCount\" type=\"number\" min=\"2\" max=\"20\" value=\"8\" title=\"Number of nodes\">\n        <input id=\"density\" type=\"number\" min=\"10\" max=\"100\" value=\"40\" title=\"Edge density (%)\">\n        <input id=\"maxWeight\" type=\"number\" min=\"1\" max=\"50\" value=\"20\" title=\"Max edge weight\">\n        <button id=\"genGraph\" class=\"wide\">Generate Random Graph</button>\n      </div>\n      <div class=\"note\">Generates a (connected) random undirected weighted graph. You can also add nodes/edges manually.</div>\n    </div>\n\n    <div class=\"section\">\n      <label>Editing</label>\n      <div class=\"mode-buttons\">\n        <button id=\"modeSelect\" class=\"active\">Pointer</button>\n        <button id=\"modeAddNode\">Add Node</button>\n        <button id=\"modeAddEdge\">Add Edge</button>\n        <button id=\"modeDelete\">Delete</button>\n      </div>\n      <div class=\"note\">Add Node: click canvas to place. Add Edge: click source then target; you'll be prompted for weight. Delete: click node/edge to remove.</div>\n    </div>\n\n    <div class=\"section\">\n      <label>Prim Controls</label>\n      <div class=\"controls\">\n        <select id=\"startVertex\"></select>\n        <button id=\"initPrim\">Init Prim</button>\n        <button id=\"stepBack\">Step ◀</button>\n        <button id=\"stepForward\">Step ▶</button>\n        <button id=\"play\">Play ▶</button>\n        <button id=\"reset\">Reset</button>\n        <input id=\"speed\" type=\"range\" min=\"150\" max=\"1500\" value=\"600\">\n        <div class=\"small\">Speed (ms per step)</div>\n      </div>\n      <div class=\"bottom-row\">\n        <div class=\"small\">Total MST weight: <strong id=\"mstWeight\">0</strong></div>\n        <div id=\"status\"></div>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <label>State (per-vertex)</label>\n      <table>\n        <thead><tr><th>Node</th><th>Key</th><th>Parent</th><th>In MST</th></tr></thead>\n        <tbody id=\"stateTable\"></tbody>\n      </table>\n    </div>\n\n    <div class=\"section\">\n      <label>Legend</label>\n      <div class=\"legend\">\n        <span><span class=\"colorbox\" style=\"background:#e0e0e0;border:1px solid #ccc;\"></span> Idle edge</span>\n        <span><span class=\"colorbox\" style=\"background:#ffb74d;\"></span> Candidate/relaxed</span>\n        <span><span class=\"colorbox\" style=\"background:#4fc3f7;\"></span> Extracted vertex</span>\n        <span><span class=\"colorbox\" style=\"background:#81c784;\"></span> Edge in MST</span>\n        <span><span class=\"colorbox\" style=\"background:#f06292;\"></span> Highlighted (selected)</span>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <label>Tips</label>\n      <div class=\"small\">\n        - Press \"Init Prim\" to prepare snapshots. Then use Step ◀ / ▶ or Play. <br>\n        - Each snapshot corresponds to either extracting the next minimum vertex, or updating a neighbor's key/parent. <br>\n        - The table shows current key and parent values. When a vertex becomes part of the MST its connecting edge is colored green.\n      </div>\n    </div>\n\n    <footer>Click canvas nodes to drag. Double-click a node to set as start vertex.</footer>\n  </div>\n\n  <div id=\"canvasWrap\">\n    <svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\"></svg>\n  </div>\n\n<script>\n/*\nPrim's Algorithm Interactive Demo\nSingle-file HTML + JS visualization.\n\nFeatures:\n- Generate connected random weighted graph with n nodes.\n- Manual edit: add nodes, add edges, delete objects, drag nodes.\n- Initialize Prim from chosen start vertex: builds snapshots (one per extraction or neighbor relaxation).\n- Step forward/back through snapshots; Play/Pause at adjustable speed.\n- Visualize keys, parents, inMST, PQ state, highlighted edges/nodes.\n*/\n\n(() => {\n  const svg = document.getElementById('svg');\n  const width = () => svg.clientWidth;\n  const height = () => svg.clientHeight;\n\n  // Controls\n  const nodeCountInput = document.getElementById('nodeCount');\n  const densityInput = document.getElementById('density');\n  const maxWeightInput = document.getElementById('maxWeight');\n  const genGraphBtn = document.getElementById('genGraph');\n\n  const modeSelectBtn = document.getElementById('modeSelect');\n  const modeAddNodeBtn = document.getElementById('modeAddNode');\n  const modeAddEdgeBtn = document.getElementById('modeAddEdge');\n  const modeDeleteBtn = document.getElementById('modeDelete');\n\n  const startVertexSelect = document.getElementById('startVertex');\n  const initPrimBtn = document.getElementById('initPrim');\n  const stepBackBtn = document.getElementById('stepBack');\n  const stepForwardBtn = document.getElementById('stepForward');\n  const playBtn = document.getElementById('play');\n  const resetBtn = document.getElementById('reset');\n  const speedInput = document.getElementById('speed');\n\n  const stateTable = document.getElementById('stateTable');\n  const mstWeightEl = document.getElementById('mstWeight');\n  const statusEl = document.getElementById('status');\n\n  // Graph data\n  let nodes = []; // {id,x,y}\n  let edges = []; // {id,u,v,w}\n  let nextNodeId = 0;\n  let nextEdgeId = 0;\n\n  // Editing state\n  let mode = 'select'; // select, addNode, addEdge, delete\n  let dragging = null;\n  let addEdgeSource = null;\n\n  // Visualization state per snapshot\n  let snapshots = []; // array of {key:[], parent:[], inMST:[], lastExtracted: int or -1, lastRelaxed: {u,v} or null}\n  let currentSnapshotIndex = 0;\n  let playing = false;\n  let playTimer = null;\n\n  function setMode(m) {\n    mode = m;\n    [modeSelectBtn, modeAddNodeBtn, modeAddEdgeBtn, modeDeleteBtn].forEach(b => b.classList.remove('active'));\n    if (m === 'select') modeSelectBtn.classList.add('active');\n    if (m === 'addNode') modeAddNodeBtn.classList.add('active');\n    if (m === 'addEdge') modeAddEdgeBtn.classList.add('active');\n    if (m === 'delete') modeDeleteBtn.classList.add('active');\n    addEdgeSource = null;\n  }\n\n  // Utility\n  function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n  function distance(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }\n  function ensureConnectedGraph(n, densityPercent, maxW) {\n    nodes = [];\n    edges = [];\n    nextNodeId = 0; nextEdgeId = 0;\n    // place nodes randomly\n    for (let i=0;i<n;i++) {\n      const padding = 40;\n      const p = { id: nextNodeId++, x: rand(padding, width()-padding), y: rand(padding, height()-padding) };\n      nodes.push(p);\n    }\n    // first, generate a random spanning tree to ensure connectivity\n    const connected = new Set([0]);\n    const remaining = new Set([...Array(n).keys()].slice(1));\n    while (remaining.size) {\n      const r = Array.from(remaining)[rand(0, remaining.size-1)];\n      const c = Array.from(connected)[rand(0, connected.size-1)];\n      addEdgeInternal(nodes[r].id, nodes[c].id, rand(1, maxW));\n      remaining.delete(r);\n      connected.add(r);\n    }\n    // then add random extra edges based on density\n    for (let i=0;i<n;i++){\n      for (let j=i+1;j<n;j++){\n        if (Math.random()*100 < densityPercent) {\n          // avoid duplicate edge (we may already have from spanning tree)\n          if (!edgeBetween(nodes[i].id, nodes[j].id)) {\n            addEdgeInternal(nodes[i].id, nodes[j].id, rand(1, maxW));\n          }\n        }\n      }\n    }\n  }\n\n  function addNodeAt(x,y) {\n    const p = {id: nextNodeId++, x, y};\n    nodes.push(p);\n    render();\n    populateStartSelect();\n  }\n  function addEdgeInternal(uId, vId, w) {\n    if (uId === vId) return null;\n    if (edgeBetween(uId, vId)) return null;\n    const e = {id: nextEdgeId++, u: uId, v: vId, w};\n    edges.push(e);\n    render();\n    return e;\n  }\n  function edgeBetween(a,b) {\n    return edges.find(e => (e.u===a && e.v===b) || (e.u===b && e.v===a));\n  }\n  function removeNode(nodeId) {\n    nodes = nodes.filter(n => n.id !== nodeId);\n    edges = edges.filter(e => e.u !== nodeId && e.v !== nodeId);\n    render();\n    populateStartSelect();\n  }\n  function removeEdge(edgeId) {\n    edges = edges.filter(e => e.id !== edgeId);\n    render();\n  }\n\n  // SVG elements dictionaries for easy update\n  const nodeEls = new Map(); // id -> g element\n  const edgeEls = new Map(); // id -> {line,text,group}\n\n  function clearSvg() {\n    while (svg.lastChild) svg.removeChild(svg.lastChild);\n    nodeEls.clear();\n    edgeEls.clear();\n  }\n\n  function render() {\n    clearSvg();\n    // draw edges first\n    edges.forEach(e => {\n      const u = nodes.find(n => n.id === e.u);\n      const v = nodes.find(n => n.id === e.v);\n      const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      g.setAttribute('data-edge-id', e.id);\n      const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n      line.setAttribute('x1', u.x); line.setAttribute('y1', u.y);\n      line.setAttribute('x2', v.x); line.setAttribute('y2', v.y);\n      line.setAttribute('stroke', '#ddd'); line.setAttribute('stroke-width', '3'); line.setAttribute('stroke-linecap', 'round');\n      // weight label\n      const midx = (u.x+v.x)/2; const midy = (u.y+v.y)/2;\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      text.setAttribute('x', midx); text.setAttribute('y', midy - 6);\n      text.setAttribute('text-anchor', 'middle'); text.setAttribute('font-size', '12');\n      text.setAttribute('fill', '#333'); text.textContent = e.w;\n      // add to svg\n      g.appendChild(line); g.appendChild(text);\n      svg.appendChild(g);\n      edgeEls.set(e.id, {g, line, text});\n      // pointer events\n      g.addEventListener('click', (ev) => {\n        ev.stopPropagation();\n        if (mode === 'delete') {\n          removeEdge(e.id);\n        } else if (mode === 'select') {\n          // select edge visually briefly\n          highlightTemporaryEdge(e.id);\n        }\n      });\n    });\n\n    // draw nodes\n    nodes.forEach(n => {\n      const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      g.setAttribute('data-node-id', n.id);\n      const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n      circle.setAttribute('cx', n.x); circle.setAttribute('cy', n.y); circle.setAttribute('r', 18);\n      circle.setAttribute('fill', '#fff'); circle.setAttribute('stroke', '#777'); circle.setAttribute('stroke-width', '2');\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      text.setAttribute('x', n.x); text.setAttribute('y', n.y + 5);\n      text.setAttribute('text-anchor', 'middle'); text.setAttribute('font-size', '12'); text.setAttribute('fill', '#111');\n      text.textContent = String(n.id);\n      g.appendChild(circle); g.appendChild(text);\n      svg.appendChild(g);\n      nodeEls.set(n.id, {g, circle, text});\n      // events\n      let offset = null;\n      g.addEventListener('mousedown', (ev) => {\n        ev.stopPropagation();\n        if (mode === 'addNode') return;\n        if (mode === 'addEdge') {\n          if (addEdgeSource == null) {\n            addEdgeSource = n.id;\n            statusEl.textContent = 'Selected source ' + n.id + '. Now click target node.';\n          } else {\n            const target = n.id;\n            if (addEdgeSource !== target) {\n              const weight = prompt('Edge weight (positive integer):', '5');\n              const w = Math.max(1, parseInt(weight)||1);\n              addEdgeInternal(addEdgeSource, target, w);\n            }\n            addEdgeSource = null;\n            statusEl.textContent = '';\n          }\n          return;\n        }\n        if (mode === 'delete') {\n          removeNode(n.id);\n          return;\n        }\n        // select/drag\n        dragging = n;\n        offset = { dx: ev.clientX - n.x, dy: ev.clientY - n.y };\n      });\n      g.addEventListener('dblclick', (ev) => {\n        ev.stopPropagation();\n        // set as start vertex quickly\n        populateStartSelect();\n        startVertexSelect.value = n.id;\n      });\n      window.addEventListener('mousemove', (ev) => {\n        if (!dragging || dragging.id !== n.id) return;\n        const newx = Math.max(20, Math.min(width()-20, ev.clientX - offset.dx));\n        const newy = Math.max(20, Math.min(height()-20, ev.clientY - offset.dy));\n        dragging.x = newx; dragging.y = newy;\n        // update visuals\n        updatePositions();\n      });\n      window.addEventListener('mouseup', () => { dragging = null; });\n    });\n\n    updatePositions();\n    refreshVisualFromSnapshot();\n  }\n\n  function updatePositions() {\n    // update edge positions and node positions\n    edges.forEach(e => {\n      const u = nodes.find(n => n.id === e.u);\n      const v = nodes.find(n => n.id === e.v);\n      const entry = edgeEls.get(e.id);\n      if (!entry) return;\n      entry.line.setAttribute('x1', u.x); entry.line.setAttribute('y1', u.y);\n      entry.line.setAttribute('x2', v.x); entry.line.setAttribute('y2', v.y);\n      const midx = (u.x+v.x)/2; const midy = (u.y+v.y)/2;\n      entry.text.setAttribute('x', midx); entry.text.setAttribute('y', midy - 6);\n    });\n\n    nodes.forEach(n => {\n      const entry = nodeEls.get(n.id);\n      if (!entry) return;\n      entry.circle.setAttribute('cx', n.x); entry.circle.setAttribute('cy', n.y);\n      entry.text.setAttribute('x', n.x); entry.text.setAttribute('y', n.y + 5);\n    });\n  }\n\n  // Snapshot helpers\n  function buildAdjList() {\n    const adj = new Map(); // id -> [{to,w}]\n    nodes.forEach(n => adj.set(n.id, []));\n    edges.forEach(e => {\n      adj.get(e.u).push({to: e.v, w: e.w});\n      adj.get(e.v).push({to: e.u, w: e.w});\n    });\n    return adj;\n  }\n\n  function initializePrimSnapshots(startId) {\n    snapshots = [];\n    currentSnapshotIndex = 0;\n    playing = false; clearPlayTimer();\n    const n = nodes.length;\n    if (n === 0) return;\n    const ids = nodes.map(x => x.id);\n    const idToIndex = new Map(ids.map((id,i) => [id,i]));\n    const INF = 1e9;\n    let key = Array(n).fill(INF);\n    let parent = Array(n).fill(-1);\n    let inMST = Array(n).fill(false);\n    // map nodeId -> index for arrays\n    const idAt = (idx) => ids[idx]; // index -> nodeId\n    const idxOf = (id) => idToIndex.get(id);\n\n    key[idxOf(startId)] = 0;\n    snapshots.push(snapshotCopy(key, parent, inMST, -1, null));\n    const adj = buildAdjList();\n\n    for (let iter=0; iter<n; iter++) {\n      // find min key among not inMST\n      let minKey = INF+1, uIndex = -1;\n      for (let i=0;i<n;i++){\n        if (!inMST[i] && key[i] < minKey) {\n          minKey = key[i]; uIndex = i;\n        }\n      }\n      if (uIndex === -1) break; // disconnected\n      inMST[uIndex] = true;\n      const uId = idAt(uIndex);\n      snapshots.push(snapshotCopy(key,parent,inMST,uId,null));\n\n      // relax neighbors\n      const neighbors = adj.get(uId) || [];\n      for (const nb of neighbors) {\n        const vIndex = idxOf(nb.to);\n        if (!inMST[vIndex] && nb.w < key[vIndex]) {\n          key[vIndex] = nb.w;\n          parent[vIndex] = uId;\n          snapshots.push(snapshotCopy(key,parent,inMST,-1,{u:uId,v:nb.to}));\n        }\n      }\n    }\n    // finished\n    statusEl.textContent = `Snapshots created: ${snapshots.length}.`;\n    currentSnapshotIndex = 0;\n    refreshVisualFromSnapshot();\n  }\n\n  function snapshotCopy(key, parent, inMST, lastExtracted, lastRelaxed) {\n    return {\n      key: key.slice(),\n      parent: parent.slice(),\n      inMST: inMST.slice(),\n      lastExtracted: lastExtracted === undefined ? -1 : lastExtracted,\n      lastRelaxed: lastRelaxed ? {u:lastRelaxed.u, v:lastRelaxed.v} : null\n    };\n  }\n\n  function refreshVisualFromSnapshot() {\n    // default styles\n    edgeEls.forEach((entry, id) => {\n      entry.line.setAttribute('stroke', '#ddd');\n      entry.line.setAttribute('stroke-width', '3');\n      entry.text.setAttribute('fill', '#333');\n      entry.g.setAttribute('opacity', '1');\n    });\n    nodeEls.forEach((entry, id) => {\n      entry.circle.setAttribute('fill', '#fff');\n      entry.circle.setAttribute('stroke', '#777');\n      entry.circle.setAttribute('stroke-width', '2');\n    });\n\n    if (snapshots.length === 0) {\n      // nothing to show, maybe show default\n      populateStateTable(null);\n      mstWeightEl.textContent = '0';\n      return;\n    }\n    const snap = snapshots[currentSnapshotIndex];\n    // map snapshot arrays back to node ids\n    const ids = nodes.map(n => n.id);\n    const idToIndex = new Map(ids.map((id,i)=>[id,i]));\n    // mark inMST edges\n    for (const nid of ids) {\n      const i = idToIndex.get(nid);\n      if (snap.inMST[i] && snap.parent[i] !== -1) {\n        const pid = snap.parent[i];\n        const e = edgeBetween(nid, pid);\n        if (e) {\n          const entry = edgeEls.get(e.id);\n          if (entry) entry.line.setAttribute('stroke', '#81c784');\n        }\n      }\n    }\n    // highlight last relaxed edge (candidate)\n    if (snap.lastRelaxed) {\n      const e = edgeBetween(snap.lastRelaxed.u, snap.lastRelaxed.v);\n      if (e) {\n        const entry = edgeEls.get(e.id);\n        if (entry) {\n          entry.line.setAttribute('stroke', '#ffb74d');\n          entry.line.setAttribute('stroke-width', '5');\n        }\n      }\n    }\n    // extracted vertex\n    if (snap.lastExtracted !== -1) {\n      const nid = snap.lastExtracted;\n      const entry = nodeEls.get(nid);\n      if (entry) {\n        entry.circle.setAttribute('fill', '#4fc3f7');\n        entry.circle.setAttribute('stroke', '#0b6');\n        entry.circle.setAttribute('stroke-width', '2');\n      }\n    }\n    // also mark nodes already in MST\n    for (let i=0;i<ids.length;i++){\n      if (snap.inMST[i]) {\n        const nid = ids[i];\n        const entry = nodeEls.get(nid);\n        if (entry) {\n          entry.circle.setAttribute('fill', '#e8f5e9');\n          entry.circle.setAttribute('stroke', '#388e3c');\n          entry.circle.setAttribute('stroke-width', '2');\n        }\n      }\n    }\n\n    // show candidate parent edges for nodes that have parent but not yet in MST\n    for (let i=0;i<ids.length;i++){\n      const pid = snap.parent[i];\n      if (pid !== -1 && !snap.inMST[i]) {\n        const nid = ids[i];\n        const e = edgeBetween(nid, pid);\n        if (e) {\n          const entry = edgeEls.get(e.id);\n          if (entry) entry.line.setAttribute('stroke', '#ffb74d');\n        }\n      }\n    }\n\n    populateStateTable(snap);\n    // total MST weight so far\n    let total = 0;\n    for (let i=0;i<ids.length;i++){\n      if (snap.inMST[i]) total += snap.key[i];\n    }\n    mstWeightEl.textContent = String(total);\n  }\n\n  function populateStateTable(snap) {\n    stateTable.innerHTML = '';\n    const ids = nodes.map(n => n.id);\n    const idToIndex = new Map(ids.map((id,i)=>[id,i]));\n    // header already present\n    for (const id of ids) {\n      const tr = document.createElement('tr');\n      const tdId = document.createElement('td'); tdId.textContent = id;\n      const tdKey = document.createElement('td');\n      const tdParent = document.createElement('td');\n      const tdIn = document.createElement('td');\n      if (!snap) {\n        tdKey.textContent = '-'; tdParent.textContent = '-'; tdIn.textContent = '-';\n      } else {\n        const i = idToIndex.get(id);\n        tdKey.textContent = (snap.key[i] >= 1e9 ? '∞' : snap.key[i]);\n        tdParent.textContent = (snap.parent[i] === -1 ? '-' : snap.parent[i]);\n        tdIn.textContent = snap.inMST[i] ? 'Yes' : 'No';\n      }\n      tr.appendChild(tdId); tr.appendChild(tdKey); tr.appendChild(tdParent); tr.appendChild(tdIn);\n      stateTable.appendChild(tr);\n    }\n  }\n\n  // Step controls\n  function stepForward() {\n    if (snapshots.length === 0) return;\n    if (currentSnapshotIndex < snapshots.length - 1) {\n      currentSnapshotIndex++;\n      refreshVisualFromSnapshot();\n    }\n    if (currentSnapshotIndex === snapshots.length - 1) {\n      // finished\n      clearPlayTimer();\n      playing = false;\n      playBtn.textContent = 'Play ▶';\n    }\n  }\n  function stepBack() {\n    if (snapshots.length === 0) return;\n    if (currentSnapshotIndex > 0) {\n      currentSnapshotIndex--;\n      refreshVisualFromSnapshot();\n    }\n    clearPlayTimer();\n    playing = false;\n    playBtn.textContent = 'Play ▶';\n  }\n  function playPause() {\n    if (snapshots.length === 0) return;\n    if (playing) {\n      clearPlayTimer();\n      playing = false;\n      playBtn.textContent = 'Play ▶';\n    } else {\n      playing = true;\n      playBtn.textContent = 'Pause ❚❚';\n      scheduleNextPlay();\n    }\n  }\n  function scheduleNextPlay() {\n    clearPlayTimer();\n    if (!playing) return;\n    const interval = parseInt(speedInput.value) || 600;\n    playTimer = setTimeout(() => {\n      stepForward();\n      if (currentSnapshotIndex < snapshots.length - 1) scheduleNextPlay();\n      else { playing = false; playBtn.textContent = 'Play ▶'; }\n    }, interval);\n  }\n  function clearPlayTimer() { if (playTimer) { clearTimeout(playTimer); playTimer = null; } }\n\n  // highlight temporary edge (for user feedback)\n  function highlightTemporaryEdge(eid) {\n    const entry = edgeEls.get(eid);\n    if (!entry) return;\n    const original = entry.line.getAttribute('stroke');\n    entry.line.setAttribute('stroke', '#f06292');\n    entry.line.setAttribute('stroke-width', '5');\n    setTimeout(() => {\n      if (entry) {\n        entry.line.setAttribute('stroke', original || '#ddd');\n        entry.line.setAttribute('stroke-width', '3');\n      }\n    }, 600);\n  }\n\n  // UI wiring\n  genGraphBtn.addEventListener('click', () => {\n    const n = Math.max(2, Math.min(20, parseInt(nodeCountInput.value) || 8));\n    const d = Math.max(0, Math.min(100, parseInt(densityInput.value) || 40));\n    const mw = Math.max(1, parseInt(maxWeightInput.value) || 20);\n    ensureConnectedGraph(n, d, mw);\n    render();\n    populateStartSelect();\n    snapshots = []; currentSnapshotIndex = 0; clearPlayTimer(); playing=false; playBtn.textContent='Play ▶';\n    statusEl.textContent = 'Random graph generated.';\n  });\n\n  // editing modes\n  modeSelectBtn.addEventListener('click', () => setMode('select'));\n  modeAddNodeBtn.addEventListener('click', () => setMode('addNode'));\n  modeAddEdgeBtn.addEventListener('click', () => setMode('addEdge'));\n  modeDeleteBtn.addEventListener('click', () => setMode('delete'));\n\n  svg.addEventListener('click', (ev) => {\n    const rect = svg.getBoundingClientRect();\n    const x = ev.clientX - rect.left;\n    const y = ev.clientY - rect.top;\n    if (mode === 'addNode') {\n      addNodeAt(x, y);\n    } else {\n      addEdgeSource = null;\n      statusEl.textContent = '';\n    }\n  });\n\n  function populateStartSelect() {\n    startVertexSelect.innerHTML = '';\n    nodes.forEach(n => {\n      const opt = document.createElement('option');\n      opt.value = n.id; opt.textContent = n.id;\n      startVertexSelect.appendChild(opt);\n    });\n  }\n\n  initPrimBtn.addEventListener('click', () => {\n    if (nodes.length === 0) { alert('Graph is empty. Generate or add nodes first.'); return; }\n    const startId = parseInt(startVertexSelect.value);\n    initializePrimSnapshots(startId);\n  });\n\n  stepForwardBtn.addEventListener('click', () => { stepForward(); });\n  stepBackBtn.addEventListener('click', () => { stepBack(); });\n\n  playBtn.addEventListener('click', () => { playPause(); });\n\n  resetBtn.addEventListener('click', () => {\n    snapshots = []; currentSnapshotIndex = 0; clearPlayTimer(); playing=false; playBtn.textContent='Play ▶';\n    // clear any algorithm highlights by re-render\n    refreshVisualFromSnapshot();\n    statusEl.textContent = 'Reset algorithm state.';\n    mstWeightEl.textContent = '0';\n    populateStateTable(null);\n  });\n\n  // allow deleting edges by clicking line: already wired in render\n\n  // initialization\n  function init() {\n    // initial random graph\n    ensureConnectedGraph(8, 40, 20);\n    render();\n    populateStartSelect();\n    // set width/height reactive\n    window.addEventListener('resize', () => {\n      // reposition nodes to stay within new bounds\n      nodes.forEach(n => {\n        n.x = Math.min(n.x, width()-20);\n        n.y = Math.min(n.y, height()-20);\n      });\n      updatePositions();\n    });\n    // keyboard shortcuts\n    window.addEventListener('keydown', (ev) => {\n      if (ev.key === ' ') { ev.preventDefault(); playPause(); }\n      if (ev.key === 'ArrowRight') stepForward();\n      if (ev.key === 'ArrowLeft') stepBack();\n    });\n  }\n\n  init();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}