{
  "id": "d80c6cd1-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:49.720Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Sliding Window",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Sliding Window Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#60a5fa;\n      --muted:#94a3b8;\n      --good:#fbbf24;\n      --win:#38bdf8;\n      --left:#fb7185;\n      --right:#34d399;\n      --card:#071226;\n      color-scheme: dark;\n    }\n    html,body { height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial; background:linear-gradient(180deg,#021024 0%, #041025 60%); color:#e6eef8;}\n    .wrap { max-width:1100px; margin:24px auto; padding:20px; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); box-shadow: 0 8px 30px rgba(2,6,23,0.6); }\n    h1 { margin:0 0 8px; font-size:20px; color:var(--accent); }\n    p.lead { margin:0 0 18px; color:var(--muted); font-size:13px; }\n    .controls { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:12px;}\n    select,input,button { background:var(--panel); color:#dbeafe; border:1px solid rgba(255,255,255,0.04); padding:8px 10px; border-radius:8px; font-size:13px; }\n    button { cursor:pointer; }\n    button.primary { background:linear-gradient(90deg,var(--accent),#3b82f6); border:none; color:#03203a; font-weight:600; }\n    .grid { display:grid; grid-template-columns: 1fr 360px; gap:16px; align-items:start; }\n    .card { background:var(--card); padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); }\n    .vis { min-height:160px; display:flex; gap:8px; align-items:center; padding:12px; flex-wrap:wrap; }\n    .cell { width:48px; height:48px; display:flex; align-items:center; justify-content:center; border-radius:8px; background:rgba(255,255,255,0.02); color:#cfe8ff; font-weight:600; position:relative; }\n    .cell.small { width:36px; height:36px; font-size:13px; }\n    .cell .idx { position:absolute; bottom:-18px; font-size:11px; color:var(--muted); left:0; right:0; text-align:center; }\n    .cell.left { box-shadow:0 0 0 3px rgba(251,113,133,0.12) inset, 0 6px 18px rgba(11,17,30,0.6); border:1px solid rgba(251,113,133,0.2); }\n    .cell.right { box-shadow:0 0 0 3px rgba(52,211,153,0.12) inset; border:1px solid rgba(52,211,153,0.16); }\n    .cell.window { background:linear-gradient(180deg, rgba(56,189,248,0.15), rgba(56,189,248,0.06)); border:1px solid rgba(56,189,248,0.18); box-shadow:0 6px 18px rgba(3,7,18,0.55); }\n    .cell.best { background:linear-gradient(180deg, rgba(251,191,36,0.14), rgba(251,191,36,0.06)); border:1px solid rgba(251,191,36,0.2); box-shadow:0 6px 18px rgba(7,4,0,0.45); }\n    .legend { display:flex; gap:8px; margin-top:8px; font-size:13px; color:var(--muted); flex-wrap:wrap; }\n    .legend .l { display:flex; gap:6px; align-items:center; }\n    .swatch { width:14px;height:12px;border-radius:3px; display:inline-block; }\n    .sw-win { background:linear-gradient(90deg,var(--win),#60a5fa); }\n    .sw-left { background:var(--left); }\n    .sw-right { background:var(--right); }\n    .stats { margin-top:12px; display:flex; gap:10px; flex-wrap:wrap; }\n    .stat { background:rgba(255,255,255,0.02); padding:8px 10px; border-radius:8px; font-size:13px; color:var(--muted); }\n    .params { display:flex; gap:8px; align-items:center; margin-bottom:10px; flex-wrap:wrap; }\n    textarea.input { width:100%; min-height:64px; font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size:13px; padding:8px; border-radius:8px; background:var(--panel); color:#dbeafe; }\n    .rightcol { position:relative; display:flex; flex-direction:column; gap:12px; }\n    .log { font-family:ui-monospace, Menlo, monospace; font-size:13px; color:#dbeafe; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:8px; border-radius:8px; max-height:300px; overflow:auto; border:1px solid rgba(255,255,255,0.02); }\n    .controls .big { padding:10px 12px; font-weight:700; }\n    .row { display:flex; gap:8px; align-items:center; }\n    .hint { color:var(--muted); font-size:13px; margin-top:10px; }\n    footer { margin-top:14px; color:var(--muted); font-size:13px; text-align:center; }\n    .small { font-size:12px; color:var(--muted); }\n    input[type=range] { -webkit-appearance:none; width:120px; height:6px; background:linear-gradient(90deg,#0b1220,#0b1220); border-radius:6px; }\n    input[type=range]::-webkit-slider-thumb { -webkit-appearance:none; width:14px; height:14px; border-radius:50%; background:var(--accent); box-shadow:0 2px 6px rgba(59,130,246,0.4); }\n    pre { margin:0; white-space:pre-wrap; word-break:break-word; }\n  </style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <h1>Sliding Window Visualizer</h1>\n    <p class=\"lead\">Interactive demonstration of the sliding window technique. Pick a scenario, provide input, and step through how left/right pointers and the window evolve.</p>\n\n    <div class=\"controls\">\n      <label>\n        Algorithm:\n        <select id=\"algo\">\n          <option value=\"fixed\">Max Sum Subarray (fixed-size window)</option>\n          <option value=\"atmost\">Longest Subarray with Sum ≤ S (variable window)</option>\n          <option value=\"unique\">Longest Substring Without Repeating Characters</option>\n        </select>\n      </label>\n\n      <label id=\"param-k\" style=\"display:flex;align-items:center;\">\n        k:\n        <input id=\"k\" type=\"number\" value=\"3\" min=\"1\" style=\"width:70px; margin-left:6px;\">\n      </label>\n\n      <label id=\"param-s\" style=\"display:none;align-items:center;\">\n        S:\n        <input id=\"s\" type=\"number\" value=\"8\" style=\"width:80px; margin-left:6px;\">\n      </label>\n\n      <button id=\"reset\" class=\"primary\">Reset</button>\n      <button id=\"randomize\">Randomize Input</button>\n\n      <div style=\"margin-left:auto; display:flex; gap:8px; align-items:center;\">\n        <button id=\"back\">⟵ Back</button>\n        <button id=\"step\" class=\"big\">Step</button>\n        <button id=\"play\">Play ▶</button>\n        <button id=\"pause\">Pause ⏸</button>\n        <label class=\"small\">Speed<input id=\"speed\" type=\"range\" min=\"100\" max=\"2000\" step=\"100\" value=\"700\"></label>\n      </div>\n    </div>\n\n    <div class=\"grid\">\n      <div>\n        <div class=\"card\">\n          <div class=\"params\">\n            <div style=\"flex:1\">\n              <label class=\"small\">Array (comma separated integers)</label>\n              <textarea id=\"arrayInput\" class=\"input\">2,1,5,1,3,2</textarea>\n            </div>\n            <div id=\"stringBox\" style=\"flex:1; display:none\">\n              <label class=\"small\">String</label>\n              <textarea id=\"stringInput\" class=\"input\">abcabcbb</textarea>\n            </div>\n          </div>\n\n          <div class=\"vis card\" id=\"vis\"></div>\n\n          <div class=\"legend\">\n            <div class=\"l\"><span class=\"swatch sw-win\"></span> current window</div>\n            <div class=\"l\"><span class=\"swatch sw-left\"></span> left pointer</div>\n            <div class=\"l\"><span class=\"swatch sw-right\"></span> right pointer</div>\n            <div class=\"l\"><span class=\"swatch\" style=\"background:var(--good);\"></span> best window</div>\n          </div>\n\n          <div class=\"stats\" id=\"stats\">\n            <div class=\"stat\" id=\"stat-info\">State: idle</div>\n            <div class=\"stat\" id=\"stat-sum\" style=\"display:none\">Sum: -</div>\n            <div class=\"stat\" id=\"stat-max\">Best: -</div>\n          </div>\n\n          <div class=\"hint\">\n            Use Step to advance one micro-step. Play will animate steps. Back rewinds through history.\n          </div>\n        </div>\n\n        <div style=\"margin-top:12px;\" class=\"card\">\n          <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n            <div><strong>Pseudocode (high level)</strong></div>\n            <div class=\"small\" id=\"pc-title\"></div>\n          </div>\n          <pre id=\"pseudocode\" style=\"margin-top:8px;font-size:13px; color:var(--muted)\"></pre>\n        </div>\n      </div>\n\n      <div class=\"rightcol\">\n        <div class=\"card\">\n          <div style=\"display:flex; gap:8px; align-items:center;\">\n            <strong>Execution Log</strong>\n            <div class=\"small\" style=\"margin-left:auto;\" id=\"stepCount\">Step: 0</div>\n          </div>\n          <div class=\"log\" id=\"log\"></div>\n        </div>\n\n        <div class=\"card small\">\n          <div style=\"margin-bottom:8px;\"><strong>Controls</strong></div>\n          <div>Reset: restart with current inputs. Randomize: fill array/string randomly. Edit inputs then Reset to use them.</div>\n          <div style=\"margin-top:8px;\"><strong>Examples:</strong> fixed: max sum for k; atmost: longest subarray with sum ≤ S; unique: longest substring without repeat.</div>\n        </div>\n      </div>\n    </div>\n\n    <footer>Built to illustrate the sliding window pattern — fixed and variable window examples, and string variant.</footer>\n  </div>\n\n  <script>\n    // Basic utility\n    const $ = id => document.getElementById(id);\n\n    // UI elements\n    const algoSel = $('algo');\n    const arrInput = $('arrayInput');\n    const strInput = $('stringInput');\n    const vis = $('vis');\n    const statInfo = $('stat-info');\n    const statSum = $('stat-sum');\n    const statMax = $('stat-max');\n    const logEl = $('log');\n    const stepBtn = $('step');\n    const playBtn = $('play');\n    const pauseBtn = $('pause');\n    const backBtn = $('back');\n    const resetBtn = $('reset');\n    const randomBtn = $('randomize');\n    const kInput = $('k');\n    const sInput = $('s');\n    const paramK = $('param-k');\n    const paramS = $('param-s');\n    const stringBox = $('stringBox');\n    const pcTitle = $('pc-title');\n    const pseudocode = $('pseudocode');\n    const stepCount = $('stepCount');\n    const speedR = $('speed');\n\n    // State\n    let generator = null;\n    let history = [];\n    let historyIndex = -1;\n    let playing = false;\n    let timer = null;\n    let stepNumber = 0;\n\n    // Helpers to parse inputs\n    function parseArrayInput() {\n      const raw = arrInput.value.trim();\n      if (!raw) return [];\n      return raw.split(',').map(s => parseInt(s.trim(),10)).filter(n => !Number.isNaN(n));\n    }\n    function parseStringInput() {\n      return strInput.value || \"\";\n    }\n\n    // Render functions\n    function renderState(state) {\n      // state object contains:\n      // type: 'array' or 'string'\n      // arr or str\n      // left, right (indices)\n      // windowLeft, windowRight (if exists)\n      // currentSum, currentLen, bestLen, bestLeft, bestRight, bestSum, message\n      // map maybe for string\n      vis.innerHTML = '';\n      logEl.scrollTop = logEl.scrollHeight;\n\n      if (!state) return;\n      if (state.type === 'array') {\n        const arr = state.arr || [];\n        arr.forEach((v,i) => {\n          const c = document.createElement('div');\n          c.className = 'cell' + (arr.length>12?' small':'');\n          c.textContent = String(v);\n          const idx = document.createElement('div');\n          idx.className = 'idx';\n          idx.textContent = i;\n          c.appendChild(idx);\n\n          if (state.bestLeft !== undefined && i>=state.bestLeft && i<=state.bestRight && state.bestLen>0) {\n            c.classList.add('best');\n          }\n          if (state.windowLeft !== undefined && i>=state.windowLeft && i<=state.windowRight) {\n            c.classList.add('window');\n          }\n          if (state.left === i) c.classList.add('left');\n          if (state.right === i) c.classList.add('right');\n\n          vis.appendChild(c);\n        });\n      } else {\n        // string\n        const s = state.str || \"\";\n        for (let i=0;i<s.length;i++){\n          const c = document.createElement('div');\n          c.className = 'cell' + (s.length>12?' small':'');\n          c.textContent = s[i];\n          const idx = document.createElement('div');\n          idx.className = 'idx';\n          idx.textContent = i;\n          c.appendChild(idx);\n\n          if (state.bestLeft !== undefined && i>=state.bestLeft && i<=state.bestRight && state.bestLen>0) {\n            c.classList.add('best');\n          }\n          if (state.windowLeft !== undefined && i>=state.windowLeft && i<=state.windowRight) {\n            c.classList.add('window');\n          }\n          if (state.left === i) c.classList.add('left');\n          if (state.right === i) c.classList.add('right');\n\n          vis.appendChild(c);\n        }\n      }\n\n      // Stats panel\n      statInfo.textContent = state.message || 'running';\n      if (state.currentSum !== undefined) {\n        statSum.style.display = 'inline-block';\n        statSum.textContent = 'Sum: ' + state.currentSum;\n      } else {\n        statSum.style.display = 'none';\n      }\n      if (state.bestLen !== undefined) {\n        // show best appropriately per algorithm\n        if (state.type==='array' && state.mode==='fixed') {\n          statMax.textContent = 'Max sum: ' + (state.bestSum === -Infinity ? '-' : state.bestSum) + (state.bestLeft!==undefined ? ' (indices '+state.bestLeft+'..'+state.bestRight+')' : '');\n        } else if (state.mode==='atmost') {\n          statMax.textContent = 'Best length: ' + (state.bestLen||0) + (state.bestLeft!==undefined ? ' (indices '+state.bestLeft+'..'+state.bestRight+')' : '');\n        } else if (state.mode==='unique') {\n          statMax.textContent = 'Best length: ' + (state.bestLen||0) + (state.bestLeft!==undefined ? ' (indices '+state.bestLeft+'..'+state.bestRight+')' : '');\n        } else {\n          statMax.textContent = 'Best: ' + JSON.stringify(state.bestLen);\n        }\n      }\n\n      // Update log and step count\n      stepCount.textContent = 'Step: ' + stepNumber;\n      if (state.logEntry) {\n        const entry = document.createElement('div');\n        entry.style.padding = '6px 4px';\n        entry.style.borderBottom = '1px dashed rgba(255,255,255,0.02)';\n        entry.innerHTML = `<div style=\"color:var(--muted);font-size:12px;\">${new Date().toLocaleTimeString()}</div><div>${state.logEntry}</div>`;\n        logEl.appendChild(entry);\n        logEl.scrollTop = logEl.scrollHeight;\n      }\n    }\n\n    // Generators for algorithms; each yields states at micro-steps.\n\n    // 1) Fixed-size sliding window: max sum of size k\n    function* genFixed(arr,k) {\n      const n = arr.length;\n      const stateBase = { type:'array', arr:arr.slice(), mode:'fixed' };\n      if (k<=0 || k>n) {\n        yield { ...stateBase, message: 'Invalid k - window size', logEntry: 'Invalid k; must be between 1 and n.' };\n        return;\n      }\n      let sum = 0;\n      for (let i=0;i<k;i++) sum += arr[i];\n      let bestSum = sum;\n      let bestL = 0, bestR = k-1;\n      let l = 0, r = k-1;\n      stepNumber++;\n      yield { ...stateBase, windowLeft: l, windowRight: r, left:l, right:r, currentSum: sum, bestSum, bestLeft:bestL, bestRight:bestR, bestLen:k, message: `Initial window [${l}..${r}] sum=${sum}`, logEntry: `Initial window [${l}..${r}] sum=${sum}` };\n\n      for (let i=k;i<n;i++) {\n        // slide: remove arr[i-k], add arr[i]\n        const removed = arr[i-k];\n        const added = arr[i];\n        sum = sum - removed + added;\n        l = i-k+1;\n        r = i;\n        stepNumber++;\n        yield { ...stateBase, windowLeft: l, windowRight: r, left:l, right:r, currentSum: sum, bestSum, bestLeft:bestL, bestRight:bestR, bestLen:k, message: `Slide window to [${l}..${r}] (removed ${removed}, added ${added}) sum=${sum}`, logEntry: `Slide to [${l}..${r}]: -${removed} +${added} => sum=${sum}` };\n\n        if (sum > bestSum) {\n          bestSum = sum;\n          bestL = l;\n          bestR = r;\n          stepNumber++;\n          yield { ...stateBase, windowLeft: l, windowRight: r, left:l, right:r, currentSum: sum, bestSum, bestLeft:bestL, bestRight:bestR, bestLen:k, message: `New best sum ${bestSum} at [${bestL}..${bestR}]`, logEntry: `New best sum ${bestSum} at [${bestL}..${bestR}]` };\n        }\n      }\n\n      stepNumber++;\n      yield { ...stateBase, windowLeft: l, windowRight: r, left:l, right:r, currentSum: sum, bestSum, bestLeft:bestL, bestRight:bestR, bestLen:k, message: `Done. Max sum ${bestSum} at [${bestL}..${bestR}]`, logEntry: `Done. Max sum ${bestSum} at [${bestL}..${bestR}]` };\n    }\n\n    // 2) Variable-size sliding window: longest subarray with sum <= S\n    function* genAtMost(arr,S) {\n      const n = arr.length;\n      const stateBase = { type:'array', arr:arr.slice(), mode:'atmost' };\n      let l = 0, sum = 0, bestLen = 0, bestL=-1,bestR=-1;\n      for (let r=0;r<n;r++) {\n        sum += arr[r];\n        stepNumber++;\n        yield { ...stateBase, left:l, right:r, windowLeft:l, windowRight:r, currentSum: sum, bestLen, bestLeft:bestL,bestRight:bestR, message: `Expanded right to ${r}, sum=${sum}`, logEntry: `Add arr[${r}]=${arr[r]}; sum=${sum}` };\n\n        while (sum > S && l<=r) {\n          const removed = arr[l];\n          sum -= removed;\n          l++;\n          stepNumber++;\n          yield { ...stateBase, left:l, right:r, windowLeft:l, windowRight:r, currentSum: sum, bestLen, bestLeft:bestL,bestRight:bestR, message: `Shrank left to ${l}, removed ${removed}, sum=${sum}`, logEntry: `sum>${S}, removed arr[${l-1}]=${removed}, sum=${sum}` };\n        }\n        // now sum <= S\n        const len = r - l + 1;\n        if (len > bestLen) {\n          bestLen = len; bestL = l; bestR = r;\n          stepNumber++;\n          yield { ...stateBase, left:l, right:r, windowLeft:l, windowRight:r, currentSum: sum, bestLen, bestLeft:bestL,bestRight:bestR, message: `New best length ${bestLen} at [${bestL}..${bestR}]`, logEntry: `New best length ${bestLen} (indices ${bestL}..${bestR})` };\n        }\n      }\n      stepNumber++;\n      yield { ...stateBase, left:l, right: n-1, windowLeft:l, windowRight:n-1, currentSum: sum, bestLen, bestLeft:bestL,bestRight:bestR, message: `Done. Best length ${bestLen} at [${bestL}..${bestR}]`, logEntry: `Done. Best length ${bestLen}` };\n    }\n\n    // 3) Longest substring without repeating characters (string)\n    function* genUnique(s) {\n      const n = s.length;\n      const stateBase = { type:'string', str:s, mode:'unique' };\n      let last = new Map();\n      let l = 0, bestL=-1, bestR=-1, bestLen=0;\n      for (let r=0;r<n;r++) {\n        const ch = s[r];\n        stepNumber++;\n        yield { ...stateBase, left:l, right:r, windowLeft:l, windowRight:r, bestLen, bestLeft:bestL,bestRight:bestR, message: `Inspecting '${ch}' at ${r}`, logEntry: `Inspect ${ch} at ${r}` };\n\n        if (last.has(ch) && last.get(ch) >= l) {\n          const prev = last.get(ch);\n          stepNumber++;\n          yield { ...stateBase, left:l, right:r, windowLeft:l, windowRight:r, bestLen, bestLeft:bestL,bestRight:bestR, message: `Duplicate '${ch}' seen at ${prev}, move left to ${prev+1}`, logEntry: `Duplicate ${ch} seen at ${prev}, shift left to ${prev+1}` };\n          l = prev + 1;\n        }\n        last.set(ch, r);\n        const len = r - l + 1;\n        if (len > bestLen) {\n          bestLen = len; bestL = l; bestR = r;\n          stepNumber++;\n          yield { ...stateBase, left:l, right:r, windowLeft:l, windowRight:r, bestLen, bestLeft:bestL,bestRight:bestR, message: `New best substring length ${bestLen} at [${bestL}..${bestR}]`, logEntry: `New best len ${bestLen} \"${s.slice(bestL,bestR+1)}\"` };\n        }\n      }\n      stepNumber++;\n      yield { ...stateBase, left:l, right:n-1, windowLeft:l, windowRight:n-1, bestLen, bestLeft:bestL,bestRight:bestR, message: `Done. Best length ${bestLen} substring \"${s.slice(bestL,bestR+1)}\"`, logEntry: `Done. Best length ${bestLen}` };\n    }\n\n    // Control functions\n    function resetExecution() {\n      stopPlaying();\n      history = [];\n      historyIndex = -1;\n      stepNumber = 0;\n      logEl.innerHTML = '';\n      prepareGenerator();\n      // take first step automatically to show initial state\n      stepOnce();\n    }\n\n    function prepareGenerator() {\n      const algo = algoSel.value;\n      if (algo === 'fixed') {\n        const arr = parseArrayInput();\n        const k = parseInt(kInput.value,10) || 0;\n        generator = genFixed(arr,k);\n        pcTitle.textContent = 'fixed-size window';\n        pseudocode.textContent = `// Max sum of subarray of size k\\nsum = sum(arr[0..k-1])\\nbest = sum\\nfor i = k..n-1:\\n  sum += arr[i] - arr[i-k]\\n  update best if needed`;\n        stringBox.style.display = 'none';\n        document.querySelector('#stringBox').style.display='none';\n      } else if (algo === 'atmost') {\n        const arr = parseArrayInput();\n        const S = parseInt(sInput.value,10) || 0;\n        generator = genAtMost(arr,S);\n        pcTitle.textContent = 'variable-size window';\n        pseudocode.textContent = `// Longest subarray with sum ≤ S\\nl = 0; sum = 0; best = 0\\nfor r in 0..n-1:\\n  sum += arr[r]\\n  while sum > S:\\n    sum -= arr[l]\\n    l++\\n  best = max(best, r-l+1)`;\n        stringBox.style.display = 'none';\n      } else {\n        const s = parseStringInput();\n        generator = genUnique(s);\n        pcTitle.textContent = 'string sliding window';\n        pseudocode.textContent = `// Longest substring without repeating chars\\nl = 0; last = {}\\nfor r in 0..n-1:\\n  if last[s[r]] ≥ l: l = last[s[r]]+1\\n  last[s[r]] = r\\n  best = max(best, r-l+1)`;\n        stringBox.style.display = '';\n      }\n    }\n\n    function stepOnce() {\n      if (!generator) {\n        prepareGenerator();\n      }\n      const res = generator.next();\n      if (res.done) {\n        // nothing more\n        playing = false;\n        stopPlaying();\n        return;\n      }\n      const state = res.value;\n      history.push(state);\n      historyIndex = history.length - 1;\n      renderState(state);\n    }\n\n    function stepBack() {\n      if (historyIndex > 0) {\n        historyIndex--;\n        const state = history[historyIndex];\n        renderState({ ...state, logEntry: null }); // don't duplicate log\n      }\n    }\n\n    function play() {\n      if (playing) return;\n      playing = true;\n      const speed = parseInt(speedR.value,10) || 700;\n      timer = setInterval(() => {\n        const beforeLen = history.length;\n        const res = generator.next();\n        if (res.done) {\n          // final state may have been yielded previously; stop\n          stopPlaying();\n          return;\n        }\n        const state = res.value;\n        history.push(state);\n        historyIndex = history.length - 1;\n        renderState(state);\n      }, speed);\n    }\n\n    function stopPlaying() {\n      playing = false;\n      if (timer) {\n        clearInterval(timer);\n        timer = null;\n      }\n    }\n\n    // Toggle visible inputs based on algorithm\n    function updateUIForAlgo() {\n      const algo = algoSel.value;\n      if (algo === 'fixed') {\n        paramK.style.display = '';\n        paramS.style.display = 'none';\n        arrInput.style.display = '';\n        stringBox.style.display = 'none';\n      } else if (algo === 'atmost') {\n        paramK.style.display = 'none';\n        paramS.style.display = '';\n        arrInput.style.display = '';\n        stringBox.style.display = 'none';\n      } else {\n        paramK.style.display = 'none';\n        paramS.style.display = 'none';\n        arrInput.style.display = 'none';\n        stringBox.style.display = '';\n      }\n    }\n\n    // Randomize helpers\n    function randomArray(n=8, min=0, max=9) {\n      const a = [];\n      for (let i=0;i<n;i++) a.push(Math.floor(Math.random()*(max-min+1))+min);\n      return a;\n    }\n    function randomString(n=10) {\n      const chars = 'abcdefghijklmnopqrstuvwxyz';\n      let s = '';\n      for (let i=0;i<n;i++) s += chars[Math.floor(Math.random()*chars.length)];\n      return s;\n    }\n\n    // Event bindings\n    algoSel.addEventListener('change', () => {\n      updateUIForAlgo();\n      resetExecution();\n    });\n    resetBtn.addEventListener('click', () => {\n      resetExecution();\n    });\n    randomBtn.addEventListener('click', () => {\n      const algo = algoSel.value;\n      if (algo === 'unique') {\n        strInput.value = randomString(10);\n      } else {\n        const arr = randomArray(10,0,9);\n        arrInput.value = arr.join(', ');\n        if (algo==='fixed') {\n          kInput.value = Math.max(1, Math.min(4, arr.length));\n        } else {\n          sInput.value = Math.floor(arr.reduce((a,b)=>a+b,0)/2);\n        }\n      }\n      resetExecution();\n    });\n\n    stepBtn.addEventListener('click', () => {\n      stopPlaying();\n      stepOnce();\n    });\n    backBtn.addEventListener('click', () => {\n      stopPlaying();\n      stepBack();\n    });\n    playBtn.addEventListener('click', () => {\n      if (!generator) prepareGenerator();\n      // some steps may remain in history; resume generator from current\n      playing = true;\n      play();\n    });\n    pauseBtn.addEventListener('click', () => {\n      stopPlaying();\n    });\n    speedR.addEventListener('change', () => {\n      if (playing) {\n        stopPlaying();\n        play();\n      }\n    });\n\n    // Initial setup\n    updateUIForAlgo();\n    prepareGenerator();\n    // start with initial step to show the starting state\n    stepOnce();\n\n    // Keyboard shortcuts for convenience\n    document.addEventListener('keydown', (e) => {\n      if (e.key === ' ') { e.preventDefault(); if (playing) { stopPlaying(); } else { play(); } }\n      if (e.key === 'ArrowRight') { stepOnce(); }\n      if (e.key === 'ArrowLeft') { stepBack(); }\n    });\n\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Sliding Window"
    }
  ],
  "topic": "Sliding Window",
  "hasFSM": false,
  "hasTest": true
}