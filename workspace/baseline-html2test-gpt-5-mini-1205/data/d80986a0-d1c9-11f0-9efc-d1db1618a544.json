{
  "id": "d80986a0-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:38.366Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Queue",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Queue Demonstration</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#06b6d4;\n      --muted:#94a3b8;\n      --card:#0f1724;\n      --good:#0ea5a4;\n      --bad:#f97316;\n      --glass: rgba(255,255,255,0.02);\n    }\n    *{box-sizing:border-box;font-family:Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;}\n    body{\n      margin:0;\n      min-height:100vh;\n      background:\n        radial-gradient(1000px 400px at 10% 10%, rgba(6,182,212,0.06), transparent 10%),\n        radial-gradient(800px 300px at 90% 90%, rgba(99,102,241,0.04), transparent 10%),\n        var(--bg);\n      color:#e6eef6;\n      padding:28px;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    header{display:flex;align-items:center;gap:16px;margin-bottom:18px}\n    h1{font-size:20px;margin:0}\n    p.lead{margin:0;color:var(--muted);font-size:13px}\n    .layout{display:grid;grid-template-columns:360px 1fr;gap:20px;align-items:start}\n    .card{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);\n      padding:14px;border-radius:10px;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.6);\n    }\n    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}\n    input[type=\"text\"], input[type=\"number\"], select{\n      width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);\n      background:transparent;color:inherit;font-size:14px;\n    }\n    .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}\n    button{\n      background:linear-gradient(180deg,var(--accent),#028289);border:none;padding:8px 12px;border-radius:8px;color:#052024;font-weight:600;\n      cursor:pointer;font-size:13px;\n    }\n    button.secondary{\n      background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600;\n    }\n    button.ghost{background:transparent;border:1px dashed rgba(255,255,255,0.04);color:var(--muted)}\n    .small{padding:6px 8px;font-size:13px;border-radius:7px}\n    .visual{\n      display:flex;flex-direction:column;gap:12px;\n    }\n    .queue-row{\n      display:flex;gap:8px;align-items:center;flex-wrap:wrap;\n      min-height:86px;padding:12px;border-radius:10px;background:var(--glass);border:1px solid rgba(255,255,255,0.02)\n    }\n    .slot{\n      height:64px;min-width:64px;display:flex;align-items:center;justify-content:center;\n      border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);position:relative;color:var(--muted);font-weight:700;\n      transition:transform 260ms ease, box-shadow 220ms ease, background 220ms;\n      user-select:none;\n    }\n    .slot.value{color:#031421;background:linear-gradient(180deg,#9beef5,#06b6d4);box-shadow:0 6px 18px rgba(6,182,212,0.12)}\n    .slot.empty{opacity:0.6}\n    .idx{\n      position:absolute;left:6px;bottom:6px;font-size:11px;color:rgba(2,6,23,0.6);\n      background:rgba(255,255,255,0.6);padding:2px 6px;border-radius:6px;font-weight:700;\n    }\n    .marker{\n      position:absolute;top:-18px;font-size:12px;padding:4px 6px;border-radius:6px;background:rgba(255,255,255,0.06);\n      color:var(--muted);font-weight:700;\n    }\n    .marker.head{left:8px}\n    .marker.tail{right:8px}\n    .info{\n      display:flex;gap:12px;flex-wrap:wrap;align-items:center;font-size:13px;color:var(--muted);\n    }\n    .badge{\n      background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);\n      color:var(--muted);\n    }\n    .log{\n      max-height:180px;overflow:auto;margin-top:10px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02);\n      color:var(--muted);font-size:13px;\n    }\n    .log p{margin:6px 0}\n    .status{font-size:13px;margin-top:8px}\n    .status .ok{color:var(--good);font-weight:700}\n    .status .err{color:var(--bad);font-weight:700}\n    footer{margin-top:18px;color:var(--muted);font-size:13px}\n    .row{display:flex;gap:8px;align-items:center}\n    .flex{flex:1}\n    .hint{font-size:12px;color:var(--muted);margin-top:6px}\n    /* small screen */\n    @media (max-width:880px){\n      .layout{grid-template-columns:1fr;gap:12px}\n      header{flex-direction:column;align-items:flex-start;gap:6px}\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <div>\n      <h1>Queue — interactive demo</h1>\n      <p class=\"lead\">Explore queue operations visually (enqueue, dequeue, peek, size, clear). Toggle array / circular buffer modes.</p>\n    </div>\n  </header>\n\n  <div class=\"layout\">\n    <!-- Controls -->\n    <div class=\"card\">\n      <label for=\"mode\">Implementation mode</label>\n      <select id=\"mode\">\n        <option value=\"array\">Simple Array-based (unbounded)</option>\n        <option value=\"circular\">Fixed-size Circular Buffer</option>\n      </select>\n\n      <div style=\"display:flex;gap:8px;margin-top:10px\">\n        <div style=\"flex:1\">\n          <label for=\"capacity\">Capacity (for circular):</label>\n          <input id=\"capacity\" type=\"number\" min=\"1\" value=\"8\"/>\n        </div>\n        <div style=\"width:96px\">\n          <label>&nbsp;</label>\n          <button id=\"applyCap\" class=\"small secondary\">Apply</button>\n        </div>\n      </div>\n\n      <hr style=\"border:0;border-top:1px solid rgba(255,255,255,0.03);margin:12px 0\" />\n\n      <label for=\"value\">Value to enqueue</label>\n      <input id=\"value\" type=\"text\" placeholder=\"text or number\" />\n\n      <div class=\"controls\" style=\"margin-top:8px\">\n        <button id=\"enqueue\">Enqueue</button>\n        <button id=\"dequeue\" class=\"secondary\">Dequeue</button>\n        <button id=\"peek\" class=\"ghost\">Peek</button>\n        <button id=\"clear\" class=\"secondary\">Clear</button>\n      </div>\n\n      <div style=\"margin-top:10px\">\n        <label for=\"bulk\">Bulk / random</label>\n        <div style=\"display:flex;gap:8px\">\n          <input id=\"bulk\" type=\"number\" min=\"1\" max=\"20\" value=\"5\" />\n          <button id=\"random\" class=\"small\">Enqueue Random</button>\n        </div>\n        <div class=\"hint\">Generate N random numbers and enqueue them. Useful to see wrap-around with circular mode.</div>\n      </div>\n\n      <hr style=\"border:0;border-top:1px solid rgba(255,255,255,0.03);margin:12px 0\" />\n\n      <div class=\"info\">\n        <div class=\"badge\">Size: <span id=\"size\">0</span></div>\n        <div class=\"badge\">Empty: <span id=\"empty\">true</span></div>\n        <div class=\"badge\">Front: <span id=\"frontVal\">—</span></div>\n        <div class=\"badge\">Rear: <span id=\"rearVal\">—</span></div>\n      </div>\n\n      <div class=\"status\" id=\"status\"></div>\n\n      <div class=\"log\" id=\"log\" aria-live=\"polite\"></div>\n    </div>\n\n    <!-- Visualization -->\n    <div class=\"card visual\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center\">\n        <div style=\"font-weight:700\">Queue Visualization</div>\n        <div class=\"hint\">Click slots to highlight / inspect (in circular mode indexes shown).</div>\n      </div>\n\n      <div class=\"queue-row\" id=\"queueRow\" aria-hidden=\"false\"></div>\n\n      <div style=\"display:flex;justify-content:space-between;align-items:center;margin-top:6px\">\n        <div class=\"hint\">Representation: blue boxes are occupied slots</div>\n        <div style=\"display:flex;gap:8px;align-items:center\">\n          <button id=\"stepEnq\" class=\"small\">Step Enqueue</button>\n          <button id=\"stepDeq\" class=\"small secondary\">Step Dequeue</button>\n        </div>\n      </div>\n\n      <footer>\n        Implementation notes:\n        <ul style=\"margin:6px 0 0 18px;color:var(--muted)\">\n          <li>Array mode uses JavaScript array push/shift (unbounded).</li>\n          <li>Circular mode uses a fixed-size backing array with head/tail indices to demonstrate wrap-around.</li>\n        </ul>\n      </footer>\n    </div>\n  </div>\n\n<script>\n/*\n  Queue demo script\n  - Supports two modes:\n    1. Array-based (unbounded): enqueue -> push, dequeue -> shift\n    2. Circular buffer (fixed-size): backing array, head/tail indices, size tracking\n  - Visualizes the internal slots and shows head/tail markers for circular mode\n  - Logs operations and shows front/rear values\n*/\n\n(() => {\n  // DOM references\n  const modeSelect = document.getElementById('mode');\n  const capacityInput = document.getElementById('capacity');\n  const applyCapBtn = document.getElementById('applyCap');\n  const valueInput = document.getElementById('value');\n  const enqueueBtn = document.getElementById('enqueue');\n  const dequeueBtn = document.getElementById('dequeue');\n  const peekBtn = document.getElementById('peek');\n  const clearBtn = document.getElementById('clear');\n  const randomBtn = document.getElementById('random');\n  const bulkInput = document.getElementById('bulk');\n  const queueRow = document.getElementById('queueRow');\n  const sizeEl = document.getElementById('size');\n  const emptyEl = document.getElementById('empty');\n  const frontValEl = document.getElementById('frontVal');\n  const rearValEl = document.getElementById('rearVal');\n  const logEl = document.getElementById('log');\n  const statusEl = document.getElementById('status');\n  const stepEnqBtn = document.getElementById('stepEnq');\n  const stepDeqBtn = document.getElementById('stepDeq');\n\n  // Utility: append log\n  function log(text, level = 'info') {\n    const p = document.createElement('p');\n    p.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;\n    if (level === 'err') p.style.color = 'var(--bad)';\n    logEl.prepend(p);\n  }\n\n  // Queue implementations\n  class ArrayQueue {\n    constructor(){\n      this.arr = [];\n    }\n    enqueue(v){\n      this.arr.push(v);\n    }\n    dequeue(){\n      return this.arr.length ? this.arr.shift() : undefined;\n    }\n    peek(){\n      return this.arr.length ? this.arr[0] : undefined;\n    }\n    size(){ return this.arr.length; }\n    isEmpty(){ return this.arr.length===0; }\n    clear(){ this.arr = []; }\n    getState(){ return { backing: Array.from(this.arr) }; }\n  }\n\n  class CircularQueue {\n    constructor(capacity = 8){\n      if (!Number.isInteger(capacity) || capacity <= 0) capacity = 8;\n      this.capacity = capacity;\n      this.arr = new Array(capacity).fill(undefined);\n      this.head = 0; // points to current front\n      this.tail = 0; // points to next insertion position\n      this.count = 0;\n    }\n    enqueue(v){\n      if (this.count === this.capacity) throw new Error('Queue full');\n      this.arr[this.tail] = v;\n      this.tail = (this.tail + 1) % this.capacity;\n      this.count++;\n    }\n    dequeue(){\n      if (this.count === 0) return undefined;\n      const val = this.arr[this.head];\n      this.arr[this.head] = undefined;\n      this.head = (this.head + 1) % this.capacity;\n      this.count--;\n      return val;\n    }\n    peek(){\n      return this.count === 0 ? undefined : this.arr[this.head];\n    }\n    size(){ return this.count; }\n    isEmpty(){ return this.count === 0; }\n    clear(){\n      this.arr = new Array(this.capacity).fill(undefined);\n      this.head = this.tail = this.count = 0;\n    }\n    getState(){\n      return {\n        backing: Array.from(this.arr),\n        head: this.head,\n        tail: this.tail,\n        capacity: this.capacity,\n        count: this.count\n      };\n    }\n    setCapacity(n){\n      if (!Number.isInteger(n) || n <= 0) return;\n      // When changing capacity, we'll attempt to preserve elements in logical order.\n      const elems = [];\n      while (this.count) elems.push(this.dequeue());\n      this.capacity = n;\n      this.arr = new Array(n).fill(undefined);\n      this.head = this.tail = this.count = 0;\n      for (const e of elems){\n        if (this.count < this.capacity) this.enqueue(e);\n        else break;\n      }\n    }\n  }\n\n  // App state\n  let queue = new ArrayQueue();\n  let mode = modeSelect.value; // 'array' or 'circular'\n  let circularCapacity = Math.max(1, parseInt(capacityInput.value || \"8\", 10));\n\n  function createQueueInstance() {\n    if (mode === 'array') return new ArrayQueue();\n    const q = new CircularQueue(circularCapacity);\n    return q;\n  }\n\n  // Initialize\n  function resetQueue() {\n    queue = createQueueInstance();\n    updateAll();\n    log(`Initialized ${mode === 'array' ? 'Array-based' : `Circular (cap=${circularCapacity})`} queue.`);\n  }\n  resetQueue();\n\n  // UI update functions\n  function updateAll() {\n    const state = queue.getState();\n    renderQueue(state);\n    updateInfo(state);\n  }\n\n  function renderQueue(state) {\n    // Clear\n    queueRow.innerHTML = '';\n\n    if (mode === 'array') {\n      const backing = state.backing;\n      if (backing.length === 0) {\n        const hint = document.createElement('div');\n        hint.textContent = 'Queue is empty';\n        hint.className = 'hint';\n        queueRow.appendChild(hint);\n        return;\n      }\n      // Show each element as a slot (no fixed capacity)\n      backing.forEach((v, idx) => {\n        const slot = document.createElement('div');\n        slot.className = 'slot value';\n        slot.textContent = String(v);\n        const idxBox = document.createElement('div');\n        idxBox.className = 'idx';\n        idxBox.textContent = idx;\n        slot.appendChild(idxBox);\n        // head marker on first, tail marker on last\n        if (idx === 0) {\n          const mk = document.createElement('div'); mk.className='marker head'; mk.textContent='HEAD';\n          slot.appendChild(mk);\n        }\n        if (idx === backing.length - 1) {\n          const mk = document.createElement('div'); mk.className='marker tail'; mk.textContent='TAIL';\n          slot.appendChild(mk);\n        }\n        queueRow.appendChild(slot);\n      });\n    } else {\n      // Circular: show fixed number of slots\n      const backing = state.backing;\n      const cap = backing.length;\n      for (let i = 0; i < cap; i++) {\n        const v = backing[i];\n        const slot = document.createElement('div');\n        slot.className = 'slot ' + (v===undefined ? 'empty' : 'value');\n        slot.textContent = v===undefined ? '' : String(v);\n        const idxBox = document.createElement('div'); idxBox.className = 'idx'; idxBox.textContent = i;\n        slot.appendChild(idxBox);\n        // Markers for head/tail — tail is next insertion position; to show last element we compute last index\n        if (state.head !== undefined && i === state.head && state.count>0) {\n          const mk = document.createElement('div'); mk.className='marker head'; mk.textContent='HEAD';\n          slot.appendChild(mk);\n        }\n        // TAIL marker: place at (tail-1) if count>0 or at tail with 'TAIL (insert)' when empty?\n        if (state.count>0 && i === ((state.tail - 1 + cap) % cap)) {\n          const mk = document.createElement('div'); mk.className='marker tail'; mk.textContent='TAIL';\n          slot.appendChild(mk);\n        } else if (state.count===0 && i===state.tail) {\n          const mk = document.createElement('div'); mk.className='marker tail'; mk.textContent='TAIL (insert)';\n          slot.appendChild(mk);\n        }\n        // Click to inspect\n        slot.addEventListener('click', () => {\n          statusEl.innerHTML = `Slot ${i}: ${v===undefined ? '<span class=\"err\">empty</span>' : `<span class=\"ok\">${escapeHtml(String(v))}</span>`} (head=${state.head}, tail=${state.tail}, count=${state.count})`;\n        });\n        queueRow.appendChild(slot);\n      }\n    }\n  }\n\n  function updateInfo(state) {\n    const s = queue.size();\n    sizeEl.textContent = s;\n    emptyEl.textContent = queue.isEmpty();\n    const front = queue.peek();\n    frontValEl.textContent = front === undefined ? '—' : String(front);\n    // rear value: depends on implementation\n    let rear = undefined;\n    if (mode === 'array') {\n      const b = state.backing;\n      rear = b.length ? b[b.length-1] : undefined;\n    } else {\n      // circular: the last element index is (tail-1+cap)%cap when count>0\n      if (state.count > 0) {\n        const idx = (state.tail - 1 + state.capacity) % state.capacity;\n        rear = state.backing[idx];\n      } else {\n        rear = undefined;\n      }\n    }\n    rearValEl.textContent = rear === undefined ? '—' : String(rear);\n  }\n\n  // Escape HTML helper\n  function escapeHtml(s) {\n    return s.replace(/[&<>\"']/g, (m) => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[m]));\n  }\n\n  // Operation handlers\n  enqueueBtn.addEventListener('click', () => {\n    const raw = valueInput.value.trim();\n    if (raw === '') {\n      statusEl.innerHTML = '<span class=\"err\">Enter a value to enqueue.</span>';\n      return;\n    }\n    try {\n      queue.enqueue(raw);\n      updateAll();\n      log(`Enqueued: ${raw}`);\n      statusEl.innerHTML = `<span class=\"ok\">Enqueued “${escapeHtml(raw)}”</span>`;\n      valueInput.value = '';\n    } catch (err) {\n      statusEl.innerHTML = `<span class=\"err\">${escapeHtml(err.message)}</span>`;\n      log(`Failed enqueue: ${err.message}`, 'err');\n    }\n  });\n\n  dequeueBtn.addEventListener('click', () => {\n    try {\n      const val = queue.dequeue();\n      if (val === undefined) {\n        statusEl.innerHTML = '<span class=\"err\">Queue is empty — cannot dequeue.</span>';\n        log('Dequeue attempted on empty queue', 'err');\n      } else {\n        updateAll();\n        statusEl.innerHTML = `<span class=\"ok\">Dequeued “${escapeHtml(String(val))}”</span>`;\n        log(`Dequeued: ${String(val)}`);\n      }\n    } catch (err) {\n      statusEl.innerHTML = `<span class=\"err\">${escapeHtml(err.message)}</span>`;\n      log(`Dequeue error: ${err.message}`, 'err');\n    }\n  });\n\n  peekBtn.addEventListener('click', () => {\n    const val = queue.peek();\n    if (val === undefined) {\n      statusEl.innerHTML = '<span class=\"err\">Queue is empty.</span>';\n      log('Peek: queue empty');\n    } else {\n      statusEl.innerHTML = `<span class=\"ok\">Front value: “${escapeHtml(String(val))}”</span>`;\n      log(`Peek: ${String(val)}`);\n    }\n  });\n\n  clearBtn.addEventListener('click', () => {\n    queue.clear();\n    updateAll();\n    statusEl.innerHTML = '<span class=\"ok\">Queue cleared.</span>';\n    log('Cleared queue');\n  });\n\n  randomBtn.addEventListener('click', () => {\n    const n = Math.max(1, Math.min(50, parseInt(bulkInput.value || '5', 10)));\n    let added = 0;\n    for (let i = 0; i < n; i++) {\n      const v = Math.floor(Math.random() * 99) + 1;\n      try {\n        queue.enqueue(v);\n        added++;\n      } catch (err) {\n        log(`Stopped after ${added} enqueues: ${err.message}`, 'err');\n        statusEl.innerHTML = `<span class=\"err\">Stopped: ${escapeHtml(err.message)}</span>`;\n        break;\n      }\n    }\n    updateAll();\n    log(`Enqueued ${added} random value(s)`);\n    statusEl.innerHTML = `<span class=\"ok\">Enqueued ${added} random value(s)</span>`;\n  });\n\n  // Mode switch and capacity handling\n  modeSelect.addEventListener('change', (e) => {\n    mode = e.target.value;\n    // show/hide capacity input styling not necessary but we can update behavior\n    resetQueue();\n  });\n\n  applyCapBtn.addEventListener('click', () => {\n    const n = Math.max(1, parseInt(capacityInput.value || '8', 10));\n    circularCapacity = n;\n    if (mode === 'circular') {\n      // adjust current queue if circular\n      if (queue instanceof CircularQueue) queue.setCapacity(n);\n      else queue = createQueueInstance();\n    }\n    resetQueue();\n  });\n\n  // Step buttons: small demo step operations for learning\n  stepEnqBtn.addEventListener('click', () => {\n    // Ask for a value via prompt quickly to step\n    const val = prompt('Value to enqueue (step):', String(Math.floor(Math.random()*100)));\n    if (val === null) return;\n    try {\n      queue.enqueue(val);\n      updateAll();\n      log(`(step) Enqueued ${val}`);\n    } catch (err) {\n      statusEl.innerHTML = `<span class=\"err\">${escapeHtml(err.message)}</span>`;\n      log(`(step) enqueue error: ${err.message}`, 'err');\n    }\n  });\n\n  stepDeqBtn.addEventListener('click', () => {\n    try {\n      const v = queue.dequeue();\n      if (v === undefined) {\n        statusEl.innerHTML = '<span class=\"err\">Queue empty (step).</span>';\n        log('(step) dequeue attempted on empty queue', 'err');\n      } else {\n        updateAll();\n        log(`(step) Dequeued ${v}`);\n      }\n    } catch (err) {\n      statusEl.innerHTML = `<span class=\"err\">${escapeHtml(err.message)}</span>`;\n      log(`(step) dequeue error: ${err.message}`, 'err');\n    }\n  });\n\n  // Keyboard shortcuts for convenience: Enter to enqueue\n  valueInput.addEventListener('keydown', (ev) => {\n    if (ev.key === 'Enter') {\n      enqueueBtn.click();\n    }\n  });\n\n  // Initialize UI\n  updateAll();\n  log('Ready.');\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Queue"
    }
  ],
  "topic": "Queue",
  "hasFSM": false,
  "hasTest": true
}