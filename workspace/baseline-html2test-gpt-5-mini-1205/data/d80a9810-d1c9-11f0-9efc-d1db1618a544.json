{
  "id": "d80a9810-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:06.054Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Priority Queue",
  "answer": {
    "role": "assistant",
    "content": "<!doctype html>\n<title>Priority Queue Demo — Binary Heap vs Naive Array</title>\n<meta charset=\"utf-8\">\n<style>\n  body { font-family: system-ui, -apple-system, Roboto, \"Helvetica Neue\", Arial; margin: 18px; color:#111; background:#f7f9fc;}\n  h1 { margin:0 0 6px 0; font-size:20px;}\n  .container { display:flex; gap:18px; align-items:flex-start; }\n  .panel { background:white; padding:12px; border-radius:8px; box-shadow:0 2px 8px rgba(20,30,40,0.06); width:520px; }\n  label { display:block; margin:8px 0 4px; font-size:13px; color:#333;}\n  input[type=\"text\"], input[type=\"number\"] { width:140px; padding:6px 8px; border-radius:6px; border:1px solid #d7dbe8; }\n  button { padding:8px 10px; margin-right:6px; border-radius:6px; border:1px solid #c9d1e6; background:linear-gradient(#fff,#f3f6fb); cursor:pointer; }\n  button:active { transform:translateY(1px); }\n  .controls { margin-bottom:10px; }\n  .small { font-size:13px; color:#445; }\n  .log { background:#071025; color:#cfe9ff; padding:8px; border-radius:6px; height:120px; overflow:auto; font-family:monospace; font-size:12px; }\n  .heap-vis { margin-top:8px; }\n  .node { display:inline-block; min-width:48px; height:36px; border-radius:6px; margin:6px; background:#eef6ff; border:1px solid #cfe1ff; text-align:center; line-height:36px; font-weight:600; color:#123; }\n  .node.highlight { background:#ffeac8; border-color:#ffd39a; }\n  .array-row { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }\n  .meta { font-size:13px; color:#445; margin-top:8px; }\n  .tabs { display:flex; gap:6px; margin-bottom:8px; }\n  .tab { padding:6px 8px; border-radius:6px; cursor:pointer; background:#eef3ff; border:1px solid #d7e0ff; }\n  .tab.active { background:#cfe4ff; font-weight:700; }\n  .bench { margin-top:8px; }\n  .footer { margin-top:12px; font-size:13px; color:#445; }\n  .tree { display:flex; flex-wrap:wrap; justify-content:center; gap:6px; }\n  .level { width:100%; display:flex; justify-content:center; gap:6px; }\n  .info { background:#fff9e6; border:1px solid #ffecb8; padding:8px; border-radius:6px; color:#6a4b00; margin-top:8px; }\n</style>\n\n<div style=\"max-width:1140px;margin:auto;\">\n  <h1>Priority Queue Demo — Binary Heap vs Naive Array</h1>\n  <div class=\"small\">Interactive demo shows a min-priority queue (smaller priority = higher priority). Tie-breaker: insertion order (stable).</div>\n\n  <div style=\"height:12px;\"></div>\n\n  <div class=\"container\">\n    <div class=\"panel\" id=\"heapPanel\">\n      <div style=\"display:flex;align-items:center;justify-content:space-between;\">\n        <div>\n          <strong>Binary Heap (array-backed min-heap)</strong>\n          <div class=\"small\">Typical operations: O(log n) insert/pop, O(1) peek.</div>\n        </div>\n        <div style=\"text-align:right\">\n          <div class=\"small\" id=\"heapMeta\">size: 0</div>\n        </div>\n      </div>\n\n      <div class=\"controls\">\n        <label>Insert item</label>\n        <input id=\"hValue\" type=\"text\" placeholder=\"value (string)\" />\n        <input id=\"hPriority\" type=\"number\" placeholder=\"priority (number)\" />\n        <button id=\"hInsert\">Insert</button>\n        <button id=\"hInsertRand\">Insert random</button>\n        <button id=\"hPop\">Pop (extractMin)</button>\n        <button id=\"hPeek\">Peek</button>\n        <label style=\"display:inline-block;margin-left:10px;\"><input id=\"hAnimate\" type=\"checkbox\" checked /> Animate</label>\n      </div>\n\n      <div class=\"heap-vis\">\n        <div class=\"small\">Heap as array (index: value:priority)</div>\n        <div id=\"heapArray\" class=\"array-row\"></div>\n        <div class=\"small\" style=\"margin-top:8px;\">Heap tree view</div>\n        <div id=\"heapTree\" class=\"tree\"></div>\n      </div>\n\n      <div class=\"meta\">\n        Comparison: <strong>Binary Heap</strong> uses array representing a complete binary tree; parent at i, children at 2i+1,2i+2.\n      </div>\n\n      <div class=\"log\" id=\"heapLog\"></div>\n    </div>\n\n    <div class=\"panel\" id=\"arrPanel\">\n      <div style=\"display:flex;align-items:center;justify-content:space-between;\">\n        <div>\n          <strong>Naive Array-based Priority Queue</strong>\n          <div class=\"small\">Insert: O(1). Pop: O(n) scan to find best.</div>\n        </div>\n        <div style=\"text-align:right\">\n          <div class=\"small\" id=\"arrMeta\">size: 0</div>\n        </div>\n      </div>\n\n      <div class=\"controls\">\n        <label>Insert item</label>\n        <input id=\"aValue\" type=\"text\" placeholder=\"value (string)\" />\n        <input id=\"aPriority\" type=\"number\" placeholder=\"priority (number)\" />\n        <button id=\"aInsert\">Insert</button>\n        <button id=\"aInsertRand\">Insert random</button>\n        <button id=\"aPop\">Pop (extractMin)</button>\n        <button id=\"aPeek\">Peek</button>\n      </div>\n\n      <div class=\"heap-vis\">\n        <div class=\"small\">Underlying array order (insertion order shown)</div>\n        <div id=\"arrArray\" class=\"array-row\"></div>\n      </div>\n\n      <div class=\"meta\">Use this to compare simplicity vs performance.</div>\n\n      <div class=\"log\" id=\"arrLog\"></div>\n\n      <div class=\"bench\">\n        <label>Benchmark</label><br/>\n        <input id=\"benchN\" type=\"number\" value=\"50000\" style=\"width:120px;\" /> items\n        <button id=\"benchRun\">Run benchmark (both)</button>\n        <div class=\"small\" id=\"benchResult\"></div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"panel\" style=\"margin-top:12px;\">\n    <strong>Notes & Complexity</strong>\n    <ul>\n      <li>Binary heap (implemented here): insert O(log n), extract-min O(log n), peek O(1). Space O(n).</li>\n      <li>Array-based naive: insert O(1), extract-min O(n) (scan). Useful when pops are rare.</li>\n      <li>We use a stable tie-breaker (insertion counter) so items with equal priority preserve FIFO order.</li>\n    </ul>\n    <div class=\"info\">\n      Example uses: Dijkstra's shortest path, A* search, scheduling tasks, event simulation, median-of-stream (with two heaps).\n    </div>\n  </div>\n</div>\n\n<script>\n/*\n  Priority Queue implementations and interactive UI.\n\n  BinaryHeapPriorityQueue:\n    - min-heap by priority\n    - stable tie-breaker using insertion index\n    - supports insert(value, priority), peek(), pop(), size(), clear()\n*/\n\nclass BinaryHeapPriorityQueue {\n  constructor() {\n    this._arr = []; // elements: {value, priority, idx}\n    this._counter = 0; // for stability tie-breaker\n  }\n\n  size() { return this._arr.length; }\n  isEmpty() { return this._arr.length === 0; }\n\n  peek() {\n    return this.isEmpty() ? null : this._arr[0];\n  }\n\n  insert(value, priority) {\n    const node = { value, priority: Number(priority), idx: this._counter++ };\n    this._arr.push(node);\n    this._bubbleUp(this._arr.length - 1);\n    return node;\n  }\n\n  pop() {\n    if (this.isEmpty()) return null;\n    const root = this._arr[0];\n    const last = this._arr.pop();\n    if (!this.isEmpty()) {\n      this._arr[0] = last;\n      this._bubbleDown(0);\n    }\n    return root;\n  }\n\n  clear() {\n    this._arr = [];\n    this._counter = 0;\n  }\n\n  // comparator: smaller priority is higher; tie-breaker by insertion idx\n  _less(i, j) {\n    const a = this._arr[i], b = this._arr[j];\n    if (a.priority !== b.priority) return a.priority < b.priority;\n    return a.idx < b.idx;\n  }\n\n  _swap(i, j) {\n    const t = this._arr[i];\n    this._arr[i] = this._arr[j];\n    this._arr[j] = t;\n  }\n\n  _bubbleUp(pos) {\n    while (pos > 0) {\n      const parent = Math.floor((pos - 1) / 2);\n      if (this._less(pos, parent)) {\n        this._swap(pos, parent);\n        pos = parent;\n      } else break;\n    }\n  }\n\n  _bubbleDown(pos) {\n    const n = this._arr.length;\n    while (true) {\n      const l = 2 * pos + 1;\n      const r = 2 * pos + 2;\n      let smallest = pos;\n      if (l < n && this._less(l, smallest)) smallest = l;\n      if (r < n && this._less(r, smallest)) smallest = r;\n      if (smallest === pos) break;\n      this._swap(pos, smallest);\n      pos = smallest;\n    }\n  }\n\n  // expose internal array (read-only)\n  internalArray() { return this._arr.slice(); }\n}\n\n/* Naive array-based priority queue */\nclass ArrayPriorityQueue {\n  constructor() {\n    this._arr = []; // elements: {value, priority, idx}\n    this._counter = 0;\n  }\n\n  size() { return this._arr.length; }\n  isEmpty() { return this._arr.length === 0; }\n\n  insert(value, priority) {\n    const node = { value, priority: Number(priority), idx: this._counter++ };\n    this._arr.push(node);\n    return node;\n  }\n\n  peek() {\n    if (this.isEmpty()) return null;\n    // find min by priority then idx\n    let best = 0;\n    for (let i = 1; i < this._arr.length; i++) {\n      if (this._arr[i].priority < this._arr[best].priority ||\n         (this._arr[i].priority === this._arr[best].priority && this._arr[i].idx < this._arr[best].idx)) {\n        best = i;\n      }\n    }\n    return this._arr[best];\n  }\n\n  pop() {\n    if (this.isEmpty()) return null;\n    let best = 0;\n    for (let i = 1; i < this._arr.length; i++) {\n      if (this._arr[i].priority < this._arr[best].priority ||\n         (this._arr[i].priority === this._arr[best].priority && this._arr[i].idx < this._arr[best].idx)) {\n        best = i;\n      }\n    }\n    const [node] = this._arr.splice(best, 1);\n    return node;\n  }\n\n  clear() { this._arr = []; this._counter = 0; }\n  internalArray() { return this._arr.slice(); }\n}\n\n/* UI wiring and visualization */\n\nconst heapPQ = new BinaryHeapPriorityQueue();\nconst arrPQ = new ArrayPriorityQueue();\n\nconst heapArrayEl = document.getElementById('heapArray');\nconst heapTreeEl = document.getElementById('heapTree');\nconst heapLog = document.getElementById('heapLog');\nconst heapMeta = document.getElementById('heapMeta');\n\nconst arrArrayEl = document.getElementById('arrArray');\nconst arrLog = document.getElementById('arrLog');\nconst arrMeta = document.getElementById('arrMeta');\n\nfunction renderHeap(animateHighlights = []) {\n  const arr = heapPQ.internalArray();\n  heapArrayEl.innerHTML = \"\";\n  arr.forEach((node, i) => {\n    const div = document.createElement('div');\n    div.className = 'node' + (animateHighlights.includes(i) ? ' highlight' : '');\n    div.textContent = `${i}: ${node.value}:${node.priority}`;\n    heapArrayEl.appendChild(div);\n  });\n  renderHeapTree(arr, animateHighlights);\n  heapMeta.textContent = `size: ${arr.length}`;\n}\n\nfunction renderHeapTree(arr, highlights = []) {\n  heapTreeEl.innerHTML = \"\";\n  if (arr.length === 0) return;\n  // compute levels\n  let levelStart = 0;\n  let levelSize = 1;\n  while (levelStart < arr.length) {\n    const level = document.createElement('div');\n    level.className = 'level';\n    for (let i = levelStart; i < Math.min(arr.length, levelStart + levelSize); i++) {\n      const n = document.createElement('div');\n      n.className = 'node' + (highlights.includes(i) ? ' highlight' : '');\n      n.style.minWidth = (80 / Math.max(1, levelSize)) + 'px';\n      n.textContent = `${arr[i].value}:${arr[i].priority}`;\n      level.appendChild(n);\n    }\n    heapTreeEl.appendChild(level);\n    levelStart += levelSize;\n    levelSize *= 2;\n  }\n}\n\nfunction log(el, ...texts) {\n  const t = texts.join(' ');\n  const now = new Date().toLocaleTimeString();\n  el.innerText = `[${now}] ${t}\\n` + el.innerText;\n}\n\n/* animate bubble up/down to show swaps (for binary heap) */\nfunction delay(ms) { return new Promise(res => setTimeout(res, ms)); }\n\nasync function animatedInsert(value, priority) {\n  const animate = document.getElementById('hAnimate').checked;\n  // We'll perform insert while capturing swaps: to animate we re-implement bubbleUp exposing indices\n  const node = { value, priority: Number(priority), idx: heapPQ._counter++ };\n  heapPQ._arr.push(node);\n  let pos = heapPQ._arr.length - 1;\n  if (!animate) {\n    heapPQ._bubbleUp(pos);\n    renderHeap();\n    log(heapLog, `Inserted ${value}:${priority}`);\n    return;\n  }\n  // animation: step-by-step swaps\n  while (pos > 0) {\n    const parent = Math.floor((pos - 1) / 2);\n    if (heapPQ._less(pos, parent)) {\n      heapPQ._swap(pos, parent);\n      renderHeap([pos, parent]);\n      await delay(260);\n      pos = parent;\n    } else break;\n  }\n  renderHeap();\n  log(heapLog, `Inserted ${value}:${priority} (animated)`);\n}\n\nasync function animatedPop() {\n  if (heapPQ.isEmpty()) { log(heapLog, 'Pop: empty'); return; }\n  const animate = document.getElementById('hAnimate').checked;\n  const root = heapPQ._arr[0];\n  if (!animate) {\n    const r = heapPQ.pop();\n    renderHeap();\n    log(heapLog, `Popped ${r.value}:${r.priority}`);\n    return;\n  }\n  // animation: swap root with last, pop, then bubble down with steps\n  const lastIndex = heapPQ._arr.length - 1;\n  heapPQ._swap(0, lastIndex);\n  renderHeap([0, lastIndex]);\n  await delay(260);\n  const popped = heapPQ._arr.pop();\n  renderHeap([0]); await delay(260);\n\n  let pos = 0;\n  const n = heapPQ._arr.length;\n  while (true) {\n    const l = 2 * pos + 1, r = 2 * pos + 2;\n    let smallest = pos;\n    if (l < n && heapPQ._less(l, smallest)) smallest = l;\n    if (r < n && heapPQ._less(r, smallest)) smallest = r;\n    if (smallest === pos) break;\n    heapPQ._swap(pos, smallest);\n    renderHeap([pos, smallest]);\n    await delay(260);\n    pos = smallest;\n  }\n  renderHeap();\n  log(heapLog, `Popped ${popped.value}:${popped.priority} (animated)`);\n}\n\n/* Wire up controls */\n\ndocument.getElementById('hInsert').addEventListener('click', async () => {\n  const v = document.getElementById('hValue').value || randomValue();\n  const p = document.getElementById('hPriority').value;\n  if (p === '') { alert('Enter priority (number)'); return; }\n  await animatedInsert(v, Number(p));\n});\n\ndocument.getElementById('hInsertRand').addEventListener('click', async () => {\n  const v = randomValue();\n  const p = Math.floor(Math.random() * 100);\n  await animatedInsert(v, p);\n});\n\ndocument.getElementById('hPop').addEventListener('click', async () => {\n  await animatedPop();\n});\n\ndocument.getElementById('hPeek').addEventListener('click', () => {\n  const p = heapPQ.peek();\n  if (!p) { log(heapLog, 'Peek: empty'); }\n  else log(heapLog, `Peek -> ${p.value}:${p.priority}`);\n});\n\n/* array controls */\ndocument.getElementById('aInsert').addEventListener('click', () => {\n  const v = document.getElementById('aValue').value || randomValue();\n  const p = document.getElementById('aPriority').value;\n  if (p === '') { alert('Enter priority (number)'); return; }\n  const n = arrPQ.insert(v, Number(p));\n  renderArray();\n  log(arrLog, `Inserted ${n.value}:${n.priority}`);\n});\n\ndocument.getElementById('aInsertRand').addEventListener('click', () => {\n  const v = randomValue();\n  const p = Math.floor(Math.random() * 100);\n  const n = arrPQ.insert(v, p);\n  renderArray();\n  log(arrLog, `Inserted ${n.value}:${n.priority}`);\n});\n\ndocument.getElementById('aPop').addEventListener('click', () => {\n  const r = arrPQ.pop();\n  if (!r) log(arrLog, 'Pop: empty');\n  else {\n    renderArray();\n    log(arrLog, `Popped ${r.value}:${r.priority}`);\n  }\n});\n\ndocument.getElementById('aPeek').addEventListener('click', () => {\n  const p = arrPQ.peek();\n  if (!p) log(arrLog, 'Peek: empty');\n  else log(arrLog, `Peek -> ${p.value}:${p.priority}`);\n});\n\n/* benchmark: insert N random, then pop N, measure time for both implementations */\ndocument.getElementById('benchRun').addEventListener('click', async () => {\n  const n = Number(document.getElementById('benchN').value) || 10000;\n  document.getElementById('benchResult').innerText = 'Running benchmark...';\n  await delay(20);\n\n  // prepare random data to ensure equal inputs\n  const data = [];\n  for (let i = 0; i < n; i++) data.push({ v: 'x'+i, p: Math.floor(Math.random()*10000) });\n\n  // Binary heap benchmark\n  heapPQ.clear(); renderHeap();\n  await delay(20);\n  const t0 = performance.now();\n  for (let i=0;i<n;i++) heapPQ.insert(data[i].v, data[i].p);\n  for (let i=0;i<n;i++) heapPQ.pop();\n  const t1 = performance.now();\n\n  // Array PQ benchmark\n  arrPQ.clear(); renderArray();\n  const t2 = performance.now();\n  for (let i=0;i<n;i++) arrPQ.insert(data[i].v, data[i].p);\n  for (let i=0;i<n;i++) arrPQ.pop();\n  const t3 = performance.now();\n\n  const heapTime = (t1 - t0).toFixed(2);\n  const arrTime = (t3 - t2).toFixed(2);\n  document.getElementById('benchResult').innerText =\n    `n=${n} → BinaryHeap: ${heapTime}ms | NaiveArray: ${arrTime}ms`;\n  log(heapLog, `Benchmark n=${n}, heap ${heapTime}ms`);\n  log(arrLog, `Benchmark n=${n}, array ${arrTime}ms`);\n});\n\n/* helper renders */\nfunction renderArray() {\n  const arr = arrPQ.internalArray();\n  arrArrayEl.innerHTML = '';\n  arr.forEach((node, i) => {\n    const div = document.createElement('div');\n    div.className = 'node';\n    div.textContent = `${i}: ${node.value}:${node.priority}`;\n    arrArrayEl.appendChild(div);\n  });\n  arrMeta.textContent = `size: ${arr.length}`;\n}\n\n/* misc */\nfunction randomValue() {\n  return Math.random().toString(36).slice(2,7);\n}\n\n/* Initialize with some items for demo */\n(async function seedDemo() {\n  const initial = [\n    ['taskA', 25],\n    ['taskB', 5],\n    ['taskC', 40],\n    ['taskD', 5], // same priority as B to show stability\n    ['taskE', 12]\n  ];\n  for (const [v,p] of initial) {\n    heapPQ.insert(v,p);\n    arrPQ.insert(v,p);\n  }\n  renderHeap();\n  renderArray();\n  log(heapLog, 'Seeded demo heap with sample items.');\n  log(arrLog, 'Seeded demo array with sample items.');\n})();\n</script>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Priority Queue"
    }
  ],
  "topic": "Priority Queue",
  "hasFSM": false,
  "hasTest": true
}