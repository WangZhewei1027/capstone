{
  "id": "d80b3451-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:40.992Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Depth-First Search (DFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>DFS Visualizer — Recursive & Iterative</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    :root{\n      --cell-size:24px;\n      --gap:2px;\n      --bg:#111;\n      --panel:#0f1720;\n      --text:#cbd5e1;\n      --muted:#94a3b8;\n      --accent:#60a5fa;\n      --start:#16a34a;\n      --goal:#ef4444;\n      --wall:#0f1720;\n      --visited:#06b6d4;\n      --frontier:#8b5cf6;\n      --path:#f59e0b;\n    }\n    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial}\n    body{\n      margin:0;\n      min-height:100vh;\n      background:linear-gradient(180deg,#071025 0%, #071a2b 100%);\n      color:var(--text);\n      display:flex;\n      gap:18px;\n      padding:20px;\n      align-items:flex-start;\n      font-size:13px;\n    }\n    .container{\n      display:flex;\n      gap:18px;\n      width:100%;\n    }\n    .left{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      min-width:520px;\n    }\n    .controls{\n      background:linear-gradient(180deg,rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      padding:12px;\n      border-radius:8px;\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n      align-items:center;\n    }\n    .controls label{color:var(--muted); font-size:12px}\n    input[type=number]{width:64px;padding:6px;border-radius:6px;border:none;background:rgba(255,255,255,0.03);color:var(--text)}\n    select, button{\n      padding:8px 10px;border-radius:8px;border:none;background:var(--panel);color:var(--text);cursor:pointer;\n      box-shadow:inset 0 -1px rgba(255,255,255,0.02);\n    }\n    button.primary{background:linear-gradient(90deg,#2563eb,#60a5fa)}\n    button.danger{background:linear-gradient(90deg,#ef4444,#fb7185)}\n    button:disabled{opacity:0.45;cursor:not-allowed}\n    .grid-wrap{\n      background:rgba(255,255,255,0.02);\n      border:1px solid rgba(255,255,255,0.03);\n      padding:12px;border-radius:8px;\n      display:flex; gap:12px;\n    }\n    .grid{\n      display:grid;\n      gap:var(--gap);\n      padding:8px;\n      background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);\n      border-radius:8px;\n      user-select:none;\n    }\n    .cell{\n      width:var(--cell-size);\n      height:var(--cell-size);\n      background:rgba(255,255,255,0.02);\n      border-radius:4px;\n      display:flex;align-items:center;justify-content:center;\n      cursor:pointer;\n      transition:background 160ms, transform 80ms;\n      box-shadow: inset 0 -1px rgba(255,255,255,0.02);\n    }\n    .cell:hover{transform:translateY(-2px)}\n    .cell.wall{background:var(--wall); box-shadow:none}\n    .cell.start{background:linear-gradient(90deg, rgba(22,163,74,0.95), rgba(34,197,94,0.9))}\n    .cell.goal{background:linear-gradient(90deg, rgba(239,68,68,0.95), rgba(251,113,133,0.9))}\n    .cell.visited{background:linear-gradient(90deg, rgba(6,182,212,0.95), rgba(59,130,246,0.85))}\n    .cell.frontier{background:linear-gradient(90deg, rgba(139,92,246,0.95), rgba(99,102,241,0.85))}\n    .cell.path{background:linear-gradient(90deg, rgba(245,158,11,0.95), rgba(250,204,21,0.85))}\n    .legend{display:flex;gap:8px;flex-wrap:wrap}\n    .legend .item{display:flex;align-items:center;gap:8px;color:var(--muted)}\n    .swatch{width:18px;height:18px;border-radius:4px;box-shadow:inset 0 -1px rgba(255,255,255,0.02)}\n    .panel{\n      width:360px;\n      background:linear-gradient(180deg,rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);\n      padding:12px;border-radius:8px;height:640px;overflow:auto;\n    }\n    .panel h3{margin:6px 0 10px 0;font-size:14px;color:var(--text)}\n    .panel .section{margin-bottom:12px}\n    .info{font-size:12px;color:var(--muted);line-height:1.4}\n    .stack-list, .vis-order{background:rgba(255,255,255,0.01);border-radius:6px;padding:8px;min-height:80px;max-height:220px;overflow:auto;font-family:monospace;font-size:12px}\n    .stack-frame{padding:6px;border-radius:6px;margin-bottom:6px;background:rgba(255,255,255,0.01);display:flex;justify-content:space-between;align-items:center}\n    .small{font-size:12px;color:var(--muted)}\n    .controls-row{display:flex;gap:8px;align-items:center}\n    .muted{color:var(--muted)}\n    .footer{margin-top:10px;font-size:12px;color:var(--muted)}\n    .hint{font-size:12px;color:var(--muted);margin-top:8px}\n    .btn-ghost{background:transparent;border:1px dashed rgba(255,255,255,0.03)}\n    .top-controls{display:flex;gap:8px;align-items:center}\n    .radio-row{display:flex;gap:8px;align-items:center}\n    .toggle{display:inline-block;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);cursor:pointer}\n    .muted-2{color:#9aa6b2}\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"left\">\n      <div class=\"controls\">\n        <div class=\"top-controls\">\n          <label>Rows<input id=\"rows\" type=\"number\" min=\"5\" max=\"40\" value=\"20\"></label>\n          <label>Cols<input id=\"cols\" type=\"number\" min=\"5\" max=\"40\" value=\"30\"></label>\n          <button id=\"regen\">Generate Grid</button>\n        </div>\n        <div class=\"controls-row\">\n          <button id=\"run-rec\" class=\"primary\">Run Recursive DFS</button>\n          <button id=\"run-itr\" class=\"primary\">Run Iterative DFS</button>\n          <button id=\"step\" class=\"btn-ghost\">Next Step</button>\n          <button id=\"play\" class=\"btn-ghost\">Play</button>\n          <button id=\"reset\" class=\"\">Reset</button>\n        </div>\n        <div style=\"display:flex;gap:8px;align-items:center;\">\n          <label style=\"margin-right:8px\" class=\"muted-2\">Speed</label>\n          <input id=\"speed\" type=\"range\" min=\"10\" max=\"1000\" value=\"180\">\n          <span id=\"speed-val\" class=\"small\">180ms</span>\n        </div>\n        <div style=\"display:flex;gap:8px;align-items:center;\">\n          <label class=\"small\">Neighbor order</label>\n          <select id=\"order\">\n            <option value=\"udlr\">Up, Down, Left, Right</option>\n            <option value=\"uldr\">Up, Left, Down, Right</option>\n            <option value=\"rdlu\">Right, Down, Left, Up</option>\n            <option value=\"random\">Random</option>\n          </select>\n          <label class=\"small\" title=\"If checked, only set visited but don't draw final path automatically\">\n            <input type=\"checkbox\" id=\"no-path\"> No auto path\n          </label>\n        </div>\n      </div>\n\n      <div class=\"grid-wrap\">\n        <div style=\"display:flex;flex-direction:column;gap:8px\">\n          <div class=\"hint\">Click a cell to toggle wall. Shift+Click to set Start. Ctrl+Click to set Goal. Start and Goal default to corners.</div>\n          <div id=\"grid\" class=\"grid\" style=\"--cell-size:24px;\"></div>\n          <div class=\"legend\" style=\"margin-top:6px\">\n            <div class=\"item\"><div class=\"swatch\" style=\"background:var(--start)\"></div><div class=\"small\">Start</div></div>\n            <div class=\"item\"><div class=\"swatch\" style=\"background:var(--goal)\"></div><div class=\"small\">Goal</div></div>\n            <div class=\"item\"><div class=\"swatch\" style=\"background:var(--wall)\"></div><div class=\"small\">Wall</div></div>\n            <div class=\"item\"><div class=\"swatch\" style=\"background:var(--visited)\"></div><div class=\"small\">Visited</div></div>\n            <div class=\"item\"><div class=\"swatch\" style=\"background:var(--frontier)\"></div><div class=\"small\">Frontier / Stack</div></div>\n            <div class=\"item\"><div class=\"swatch\" style=\"background:var(--path)\"></div><div class=\"small\">Final path</div></div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <h3>DFS Visualizer — Execution Details</h3>\n      <div class=\"section\">\n        <div class=\"info\">\n          This demo visualizes Depth-First Search (DFS) on a 2D grid. You can choose recursive or iterative implementations. The \"frontier\" is shown as the stack contents. The demo supports step-by-step execution (use \"Next\") and autoplay.\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center\">\n          <div><strong>Call Stack / Stack</strong></div>\n          <div class=\"small muted\">Shows active recursive calls (rec) or stack elements (itr)</div>\n        </div>\n        <div id=\"stack\" class=\"stack-list\"></div>\n      </div>\n\n      <div class=\"section\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center\">\n          <div><strong>Visited Order</strong></div>\n          <div class=\"small muted\">Most recent at top</div>\n        </div>\n        <div id=\"vis\" class=\"vis-order\"></div>\n      </div>\n\n      <div class=\"section\">\n        <div class=\"small muted\">Controls:</div>\n        <ul class=\"info\">\n          <li>Toggle walls by clicking cells.</li>\n          <li>Shift+Click to set start; Ctrl/Cmd+Click to set goal.</li>\n          <li>Use \"Next\" to advance one step. Use \"Play\" to run continuously.</li>\n        </ul>\n      </div>\n\n      <div class=\"footer\">Implementation notes: DFS explores depth-first using a stack (LIFO). Recursive DFS implicitly uses the call stack and will backtrack when dead-ends are reached.</div>\n    </div>\n  </div>\n\n<script>\n(function(){\n  // Config / State\n  const gridEl = document.getElementById('grid');\n  const rowsInput = document.getElementById('rows');\n  const colsInput = document.getElementById('cols');\n  const regenBtn = document.getElementById('regen');\n  const runRecBtn = document.getElementById('run-rec');\n  const runItrBtn = document.getElementById('run-itr');\n  const resetBtn = document.getElementById('reset');\n  const stepBtn = document.getElementById('step');\n  const playBtn = document.getElementById('play');\n  const speedInput = document.getElementById('speed');\n  const speedVal = document.getElementById('speed-val');\n  const orderSelect = document.getElementById('order');\n  const stackEl = document.getElementById('stack');\n  const visEl = document.getElementById('vis');\n  const noPathCheck = document.getElementById('no-path');\n\n  let rows = parseInt(rowsInput.value,10);\n  let cols = parseInt(colsInput.value,10);\n  let cellSize = 24;\n  let grid = []; // 2d array of cells\n  let start = {r:0,c:0};\n  let goal = {r:rows-1,c:cols-1};\n  let running = false;\n  let paused = false;\n  let autoPlay = false;\n  let speed = parseInt(speedInput.value,10);\n  let parent = {}; // for path reconstruct\n  let visitedOrder = [];\n  let stepResolve = null;\n\n  // Utilities\n  function idx(r,c){ return r + ',' + c; }\n  function valid(r,c){ return r>=0 && r<rows && c>=0 && c<cols; }\n  function setCellClass(r,c,cls,removeOther=true){\n    const el = grid[r][c].el;\n    if(removeOther){\n      el.className = 'cell';\n      if(grid[r][c].wall) el.classList.add('wall');\n    }\n    el.classList.remove('start','goal','visited','frontier','path');\n    if(cls) el.classList.add(cls);\n    if(idx(r,c) === idx(start.r,start.c)) el.classList.add('start');\n    if(idx(r,c) === idx(goal.r,goal.c)) el.classList.add('goal');\n  }\n\n  function sleep(ms){\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Step control: await next if paused/stepping\n  async function waitStep(){\n    if(!autoPlay){\n      paused = true;\n      stepBtn.disabled = false;\n      return new Promise(resolve => { stepResolve = resolve; });\n    } else {\n      await sleep(speed);\n    }\n  }\n\n  // UI update: stack and visited lists\n  function renderStack(frames){\n    stackEl.innerHTML = '';\n    if(!frames || frames.length===0){\n      stackEl.innerHTML = '<div class=\"small muted\">Stack empty</div>';\n      return;\n    }\n    frames.slice().reverse().forEach(f=>{\n      const d = document.createElement('div');\n      d.className = 'stack-frame';\n      d.innerHTML = `<div>(${f.r},${f.c})</div><div class=\"small muted\">${f.tag||''}</div>`;\n      stackEl.appendChild(d);\n    });\n  }\n  function renderVisited(list){\n    visEl.innerHTML = '';\n    if(list.length===0){visEl.innerHTML = '<div class=\"small muted\">No nodes visited</div>'; return;}\n    list.slice().reverse().forEach(p=>{\n      const d = document.createElement('div');\n      d.className = 'stack-frame';\n      d.style.background='transparent';\n      d.innerHTML = `<div style=\"width:100%\">${p}</div>`;\n      visEl.appendChild(d);\n    });\n  }\n\n  // Build grid DOM\n  function buildGrid(){\n    rows = parseInt(rowsInput.value,10);\n    cols = parseInt(colsInput.value,10);\n    gridEl.style.setProperty('--cell-size', cellSize+'px');\n    gridEl.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;\n    gridEl.innerHTML = '';\n    grid = [];\n    for(let r=0;r<rows;r++){\n      grid[r] = [];\n      for(let c=0;c<cols;c++){\n        const el = document.createElement('div');\n        el.className = 'cell';\n        el.dataset.r = r;\n        el.dataset.c = c;\n        el.title = `${r},${c}`;\n        gridEl.appendChild(el);\n        grid[r][c] = {r,c,el,wall:false};\n        // Click handlers\n        el.addEventListener('click', (ev)=>{\n          if(running) return;\n          if(ev.shiftKey){\n            start = {r,c};\n            updateAllCellClasses();\n          } else if(ev.ctrlKey || ev.metaKey){\n            goal = {r,c};\n            updateAllCellClasses();\n          } else {\n            grid[r][c].wall = !grid[r][c].wall;\n            setCellClass(r,c, grid[r][c].wall ? 'wall' : null, true);\n          }\n        });\n      }\n    }\n    // default start & goal\n    start = {r:0,c:0};\n    goal = {r:rows-1,c:cols-1};\n    updateAllCellClasses();\n  }\n\n  function updateAllCellClasses(){\n    for(let r=0;r<rows;r++){\n      for(let c=0;c<cols;c++){\n        const cell = grid[r][c];\n        if(cell.wall) setCellClass(r,c,'wall',true);\n        else setCellClass(r,c,null,true);\n      }\n    }\n    setCellClass(start.r,start.c,'start',false);\n    setCellClass(goal.r,goal.c,'goal',false);\n  }\n\n  // Neighbor ordering\n  function getNeighbors(r,c){\n    const choice = orderSelect.value;\n    let dirs;\n    if(choice === 'random'){\n      dirs = [[-1,0],[1,0],[0,-1],[0,1]].sort(()=>Math.random()-0.5);\n    } else {\n      // map string to a sequence\n      const mapping = { u:[-1,0], d:[1,0], l:[0,-1], r:[0,1] };\n      dirs = [];\n      for(const ch of choice){\n        if(mapping[ch]) dirs.push(mapping[ch]);\n      }\n    }\n    const result = [];\n    for(const d of dirs){\n      const nr = r + d[0], nc = c + d[1];\n      if(valid(nr,nc) && !grid[nr][nc].wall) result.push({r:nr,c:nc});\n    }\n    return result;\n  }\n\n  // Iterative DFS\n  async function runIterative(){\n    running = true;\n    disableControls(true);\n    clearVisited();\n    parent = {};\n    visitedOrder = [];\n    renderVisited(visitedOrder);\n    const stack = [{r:start.r,c:start.c}];\n    const inStackSet = new Set([idx(start.r,start.c)]);\n    renderStack(stack.map(s=>({...s, tag:'stack'})));\n    setCellClass(start.r,start.c,'frontier',false);\n    while(stack.length>0){\n      // show stack\n      renderStack(stack.map(s=>({...s, tag:'stack'})));\n      // Wait for step/autoplay\n      if(!autoPlay){\n        stepBtn.disabled = false;\n        await waitStep();\n        // resolved by clicking Next or toggling Play; after resolving, disable step until next pause\n        stepBtn.disabled = true;\n      } else {\n        await sleep(speed);\n      }\n\n      const cur = stack.pop();\n      inStackSet.delete(idx(cur.r,cur.c));\n      // mark popped as frontier->visited\n      setCellClass(cur.r,cur.c,null,true);\n      setCellClass(cur.r,cur.c,'visited',false);\n      visitedOrder.push(idx(cur.r,cur.c));\n      renderVisited(visitedOrder);\n      if(idx(cur.r,cur.c) === idx(goal.r,goal.c)){\n        // found\n        await revealPath(cur);\n        break;\n      }\n      // get neighbors\n      const neighbors = getNeighbors(cur.r,cur.c);\n      // Push neighbors in order (so that first neighbor will be popped last if we want desired order)\n      for(const nb of neighbors){\n        const key = idx(nb.r,nb.c);\n        if(parent[key] || key === idx(start.r,start.c) || grid[nb.r][nb.c].visited) continue;\n        // Avoid pushing duplicates\n        if(!inStackSet.has(key) && !grid[nb.r][nb.c].visited){\n          parent[key] = idx(cur.r,cur.c);\n          stack.push(nb);\n          inStackSet.add(key);\n          setCellClass(nb.r,nb.c,'frontier',false);\n        }\n      }\n      // mark visited flag in grid for iteration\n      grid[cur.r][cur.c].visited = true;\n      // small UI update for stack\n      renderStack(stack.map(s=>({...s, tag:'stack'})));\n    }\n    running = false;\n    disableControls(false);\n  }\n\n  // Recursive DFS with manual callStack display and ability to step\n  async function runRecursive(){\n    running = true;\n    disableControls(true);\n    clearVisited();\n    parent = {};\n    visitedOrder = [];\n    renderVisited(visitedOrder);\n    const callStack = [];\n    let found = false;\n\n    async function dfs(r,c){\n      callStack.push({r,c,tag:'rec'});\n      renderStack(callStack);\n      // step/wait\n      if(!autoPlay){\n        stepBtn.disabled = false;\n        await waitStep();\n        stepBtn.disabled = true;\n      } else {\n        await sleep(speed);\n      }\n\n      // if already visited or wall or found, pop and return\n      if(found || grid[r][c].visited || grid[r][c].wall){\n        callStack.pop();\n        renderStack(callStack);\n        return;\n      }\n      // Mark frontier/entry\n      setCellClass(r,c,'frontier',false);\n      await sleep(10);\n      grid[r][c].visited = true;\n      setCellClass(r,c,'visited',false);\n      visitedOrder.push(idx(r,c));\n      renderVisited(visitedOrder);\n\n      if(idx(r,c) === idx(goal.r,goal.c)){\n        found = true;\n        callStack.pop();\n        renderStack(callStack);\n        await revealPath({r,c});\n        return;\n      }\n      // neighbors\n      const neighbors = getNeighbors(r,c);\n      for(const nb of neighbors){\n        const key = idx(nb.r,nb.c);\n        if(found) break;\n        if(grid[nb.r][nb.c].visited) continue;\n        parent[key] = idx(r,c);\n        await dfs(nb.r,nb.c);\n      }\n      // backtracking visualization: show popped frame\n      const popped = callStack.pop();\n      renderStack(callStack);\n      // small pause to visualize backtrack\n      if(!autoPlay){\n        stepBtn.disabled = false;\n        await waitStep();\n        stepBtn.disabled = true;\n      } else {\n        await sleep(speed/3);\n      }\n      return;\n    }\n\n    // Entry\n    await dfs(start.r,start.c);\n    running = false;\n    disableControls(false);\n  }\n\n  // Reveal path by following parent map from node to start\n  async function revealPath(end){\n    if(noPathCheck.checked) return;\n    // reconstruct\n    let curKey = idx(end.r,end.c);\n    const path = [];\n    while(curKey){\n      path.push(curKey);\n      if(curKey === idx(start.r,start.c)) break;\n      curKey = parent[curKey];\n    }\n    // animate path\n    for(let i=path.length-1;i>=0;i--){\n      const [r,c] = path[i].split(',').map(n=>parseInt(n,10));\n      setCellClass(r,c,'path',false);\n      await sleep(Math.max(20, speed/5));\n    }\n  }\n\n  // Helpers\n  function clearVisited(){\n    visitedOrder = [];\n    for(let r=0;r<rows;r++){\n      for(let c=0;c<cols;c++){\n        grid[r][c].visited = false;\n        // clear classes except walls\n        setCellClass(r,c, grid[r][c].wall ? 'wall' : null, true);\n      }\n    }\n    setCellClass(start.r,start.c,'start',false);\n    setCellClass(goal.r,goal.c,'goal',false);\n    renderVisited([]);\n    renderStack([]);\n  }\n\n  function disableControls(dis){\n    runRecBtn.disabled = dis;\n    runItrBtn.disabled = dis;\n    regenBtn.disabled = dis;\n    rowsInput.disabled = dis;\n    colsInput.disabled = dis;\n    orderSelect.disabled = dis;\n    noPathCheck.disabled = dis;\n    resetBtn.disabled = false;\n    // step/play behavior handled elsewhere\n  }\n\n  // Step/Play button logic\n  stepBtn.addEventListener('click', ()=>{\n    if(stepResolve){\n      stepResolve();\n      stepResolve = null;\n    }\n  });\n  playBtn.addEventListener('click', ()=>{\n    autoPlay = !autoPlay;\n    playBtn.textContent = autoPlay ? 'Pause' : 'Play';\n    if(autoPlay && stepResolve){\n      // resolve paused wait so execution continues\n      stepResolve();\n      stepResolve = null;\n    }\n  });\n\n  // Event bindings\n  regenBtn.addEventListener('click', ()=>{if(running) return; buildGrid();});\n  resetBtn.addEventListener('click', ()=>{\n    if(running) return;\n    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) grid[r][c].wall = false;\n    clearVisited();\n    updateAllCellClasses();\n  });\n\n  runItrBtn.addEventListener('click', async ()=>{\n    if(running) return;\n    autoPlay = false; playBtn.textContent = 'Play';\n    await runIterative();\n  });\n\n  runRecBtn.addEventListener('click', async ()=>{\n    if(running) return;\n    autoPlay = false; playBtn.textContent = 'Play';\n    await runRecursive();\n  });\n\n  speedInput.addEventListener('input', ()=>{\n    speed = parseInt(speedInput.value,10);\n    speedVal.textContent = speed + 'ms';\n  });\n\n  // Build initial grid\n  buildGrid();\n\n  // Keyboard shortcuts for convenience\n  window.addEventListener('keydown', (ev)=>{\n    if(ev.key === ' '){\n      ev.preventDefault();\n      if(running){\n        // toggle pause/play\n        autoPlay = !autoPlay;\n        playBtn.textContent = autoPlay ? 'Pause' : 'Play';\n        if(autoPlay && stepResolve){\n          stepResolve();\n          stepResolve = null;\n        }\n      }\n    }\n  });\n\n  // initialize\n  speedVal.textContent = speed + 'ms';\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Depth-First Search (DFS)"
    }
  ],
  "topic": "Depth-First Search (DFS)",
  "hasFSM": false,
  "hasTest": true
}