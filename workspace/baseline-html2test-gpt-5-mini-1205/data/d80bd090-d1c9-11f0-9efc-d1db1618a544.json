{
  "id": "d80bd090-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:26.023Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Longest Common Subsequence",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Longest Common Subsequence (LCS) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 18px; color: #111; }\n    h1 { margin: 0 0 8px 0; font-size: 20px; }\n    p.lead { margin: 6px 0 14px 0; color: #333; max-width: 900px; }\n    .controls { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:12px; }\n    label { font-size: 13px; }\n    input[type=\"text\"] { padding:6px 8px; font-size:14px; width:260px; }\n    button { padding:8px 12px; font-size:14px; cursor:pointer; }\n    .small { font-size:13px; color:#555; }\n    .container { display:flex; gap:18px; align-items:flex-start; flex-wrap:wrap; }\n    .panel { background:#fff; border:1px solid #ddd; padding:12px; border-radius:6px; box-shadow: 0 1px 0 rgba(0,0,0,0.02); }\n    .panel.wide { min-width:420px; max-width:100%; }\n    table.dp { border-collapse:collapse; margin-top:12px; }\n    table.dp th, table.dp td { border:1px solid #e1e6ea; padding:6px 8px; text-align:center; min-width:32px; position:relative; background: #fafcff; }\n    table.dp th { background:#f4f8ff; font-weight:600; color:#0b3b6f; }\n    td.empty { background:#f9f9f9; color:#999; }\n    td.match { background: linear-gradient(180deg,#e6fff4,#e0fff2); }\n    td.highlight { box-shadow: inset 0 0 0 3px rgba(255,236,179,0.6); } /* path highlight */\n    .arrow { font-size:12px; position:absolute; bottom:2px; right:4px; color:#666; }\n    .status { margin-top:8px; font-size:13px; color:#333; }\n    .result { margin-top:12px; }\n    .sequences { max-height:160px; overflow:auto; padding:8px; background:#fcfcff; border:1px dashed #eee; border-radius:4px; }\n    .meta { margin-top:8px; font-size:13px; color:#444; }\n    .footer { margin-top:14px; font-size:13px; color:#444; max-width:680px; }\n    .toggle { display:flex; gap:8px; align-items:center; }\n    input[type=number] { width:70px; padding:6px; }\n    .note { font-size:12px; color:#666; margin-top:6px; }\n    .sequence-picked { font-weight:700; color:#0b3b6f; }\n  </style>\n</head>\n<body>\n  <h1>Longest Common Subsequence (LCS) Visualizer</h1>\n  <p class=\"lead\">Enter two strings below. This tool builds the DP table for LCS and lets you visualize how the table is filled, then reconstructs the subsequence(s). You can animate the filling, step through, and list multiple LCS up to a limit.</p>\n\n  <div class=\"controls\">\n    <label>String A: <input id=\"strA\" type=\"text\" value=\"ABCBDAB\" /></label>\n    <label>String B: <input id=\"strB\" type=\"text\" value=\"BDCABA\" /></label>\n    <button id=\"computeBtn\">Compute</button>\n    <label class=\"toggle\"><input id=\"animateChk\" type=\"checkbox\" checked /> Animate</label>\n    <label>Speed(ms): <input id=\"speed\" type=\"number\" value=\"60\" min=\"10\" /></label>\n    <button id=\"stepBtn\" disabled>Step</button>\n    <button id=\"pauseBtn\" disabled>Pause</button>\n  </div>\n\n  <div class=\"container\">\n    <div class=\"panel wide\" id=\"panelLeft\">\n      <div class=\"small\">DP Table (rows: A prefix, columns: B prefix). Top-left is 0x0 base.</div>\n      <div id=\"tableWrapper\"></div>\n      <div class=\"status\" id=\"status\">Ready.</div>\n    </div>\n\n    <div class=\"panel\" style=\"min-width:300px;\">\n      <div><strong>Results</strong></div>\n      <div class=\"result\" id=\"resultArea\">\n        <div class=\"meta\">Length: <span id=\"lcsLen\">-</span></div>\n        <div class=\"meta\">One LCS: <span id=\"oneLcs\" class=\"sequence-picked\">-</span></div>\n        <div class=\"meta\">All LCS (limited):</div>\n        <div class=\"sequences\" id=\"allLcs\">-</div>\n        <div class=\"note\">Algorithm complexity: O(n*m) time and O(n*m) space for the DP table. Backtracking to enumerate multiple LCS can be exponential in worst case.</div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Utility\n    const $ = id => document.getElementById(id);\n\n    // Elements\n    const strAInput = $('strA'), strBInput = $('strB');\n    const computeBtn = $('computeBtn'), animateChk = $('animateChk'), speedInput = $('speed');\n    const tableWrapper = $('tableWrapper'), status = $('status');\n    const lcsLenSpan = $('lcsLen'), oneLcsSpan = $('oneLcs'), allLcsDiv = $('allLcs');\n    const stepBtn = $('stepBtn'), pauseBtn = $('pauseBtn');\n\n    // State\n    let A = '', B = '';\n    let n=0, m=0;\n    let dp = [];      // dp matrix (n+1 x m+1)\n    let dirs = [];    // directions storing arrows info for backtracking\n    let cells = [];   // references to table td elements\n    let animating = false, paused = false;\n    let stepMode = false;\n    let maxEnumerate = 200; // limit for enumerating all LCS strings\n\n    // Arrow characters\n    const ARROW_UP = '↑', ARROW_LEFT = '←', ARROW_DIAG = '↖';\n\n    // Create DP table DOM\n    function createTable() {\n      tableWrapper.innerHTML = '';\n      const table = document.createElement('table');\n      table.className = 'dp';\n      const thead = document.createElement('thead');\n      const tbody = document.createElement('tbody');\n\n      // top row header: empty cell + B chars\n      const topRow = document.createElement('tr');\n      const thEmpty = document.createElement('th'); thEmpty.textContent = ''; topRow.appendChild(thEmpty);\n      const thZero = document.createElement('th'); thZero.textContent = ''; topRow.appendChild(thZero);\n      for (let j=0;j<m;j++){\n        const th = document.createElement('th'); th.textContent = B[j]; topRow.appendChild(th);\n      }\n      thead.appendChild(topRow);\n\n      // rows: first header row for A (empty) + zeros row\n      table.appendChild(thead);\n\n      // Row 0 (0th row of dp) with leading header blank + zero cells for j=0..m\n      const row0 = document.createElement('tr');\n      const row0Header = document.createElement('th'); row0Header.textContent = ''; row0.appendChild(row0Header);\n      for (let j=0;j<=m;j++){\n        const td = document.createElement('td'); td.className='empty'; td.textContent = '0';\n        row0.appendChild(td);\n      }\n      tbody.appendChild(row0);\n\n      // subsequent rows: header cell with A[i-1], then dp cells\n      cells = []; // 2D array for easy access [i][j]\n      cells.push(Array.from(row0.querySelectorAll('td'))); // row 0 cells (j from 0..m)\n\n      for (let i=1;i<=n;i++){\n        const tr = document.createElement('tr');\n        const th = document.createElement('th'); th.textContent = A[i-1]; tr.appendChild(th);\n        const cellRow = [];\n        for (let j=0;j<=m;j++){\n          const td = document.createElement('td');\n          td.textContent = '0';\n          // include an arrow container\n          const arrow = document.createElement('div'); arrow.className='arrow'; td.appendChild(arrow);\n          tr.appendChild(td);\n          cellRow.push(td);\n        }\n        tbody.appendChild(tr);\n        cells.push(cellRow);\n      }\n\n      table.appendChild(tbody);\n      tableWrapper.appendChild(table);\n    }\n\n    // Initialize dp & dirs\n    function initDP() {\n      dp = Array.from({length:n+1}, () => Array(m+1).fill(0));\n      dirs = Array.from({length:n+1}, () => Array.from({length:m+1}, () => ({ up:false, left:false, diag:false })));\n    }\n\n    // Sleep promise for animation\n    function sleep(ms) {\n      return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    // Update table cell content and arrow\n    function updateCell(i,j,val,dirObj, highlight=false, match=false) {\n      // cells is indexed by [i][j] where i from 0..n, j from 0..m\n      const td = cells[i][j];\n      td.classList.toggle('highlight', !!highlight);\n      td.classList.toggle('match', !!match);\n      // set number (first child text node). Some td have arrow div appended.\n      // We place the number as the first text node.\n      td.childNodes[0] && (td.childNodes[0].textContent = String(val));\n      // update arrow\n      const arrowDiv = td.querySelector('.arrow');\n      if (arrowDiv) {\n        let s = '';\n        if (dirObj.diag) s += ARROW_DIAG;\n        if (dirObj.up) s += (s? ' ':'') + ARROW_UP;\n        if (dirObj.left) s += (s? ' ':'') + ARROW_LEFT;\n        arrowDiv.textContent = s;\n      }\n    }\n\n    // Main compute (with optional animation)\n    async function compute(animate=true) {\n      A = strAInput.value || '';\n      B = strBInput.value || '';\n      n = A.length; m = B.length;\n      initDP();\n      createTable();\n      // initialize row0 and col0 visuals\n      for (let j=0;j<=m;j++) updateCell(0,j,0, {up:false,left:false,diag:false});\n      for (let i=1;i<=n;i++) updateCell(i,0,0, {up:false,left:false,diag:false});\n\n      status.textContent = 'Filling DP table...';\n      animating = animate;\n      paused = false;\n      stepMode = false;\n      stepBtn.disabled = true;\n      pauseBtn.disabled = !animate ? true : false;\n\n      const delay = Math.max(1, Number(speedInput.value) || 60);\n\n      // Fill dp row by row\n      for (let i=1;i<=n;i++){\n        for (let j=1;j<=m;j++){\n          // handle pausing\n          if (animate) {\n            // wait while paused\n            while (paused) {\n              await sleep(50);\n            }\n            // if step mode: wait for a single step\n            if (stepMode) {\n              stepBtn.disabled = false;\n              pauseBtn.disabled = true;\n              // wait until user clicks step\n              await new Promise(res => {\n                const onStep = () => { stepBtn.removeEventListener('click', onStep); res(); };\n                stepBtn.addEventListener('click', onStep);\n              });\n              stepBtn.disabled = true;\n              pauseBtn.disabled = false;\n            } else {\n              await sleep(delay);\n            }\n          }\n\n          if (A[i-1] === B[j-1]) {\n            dp[i][j] = dp[i-1][j-1] + 1;\n            dirs[i][j] = { diag:true, up:false, left:false };\n            updateCell(i,j,dp[i][j], dirs[i][j], true, true);\n          } else {\n            if (dp[i-1][j] > dp[i][j-1]) {\n              dp[i][j] = dp[i-1][j];\n              dirs[i][j] = { diag:false, up:true, left:false };\n            } else if (dp[i-1][j] < dp[i][j-1]) {\n              dp[i][j] = dp[i][j-1];\n              dirs[i][j] = { diag:false, up:false, left:true };\n            } else {\n              dp[i][j] = dp[i-1][j]; // equal\n              dirs[i][j] = { diag:false, up:true, left:true };\n            }\n            updateCell(i,j,dp[i][j], dirs[i][j], false, false);\n          }\n        }\n      }\n\n      animating = false;\n      paused = false;\n      stepMode = false;\n      stepBtn.disabled = true;\n      pauseBtn.disabled = true;\n\n      status.textContent = 'Table complete. Backtracking to get LCS...';\n      // Display results\n      displayResults();\n    }\n\n    // Backtrack to get one LCS string (simple greedy path)\n    function getOneLCS() {\n      let i=n, j=m;\n      const seq = [];\n      // we'll follow preference: diag if match; else choose up if dp[i-1][j] >= dp[i][j-1], else left\n      while (i>0 && j>0) {\n        if (A[i-1] === B[j-1]) {\n          seq.push(A[i-1]);\n          // mark match cells\n          cells[i][j].classList.add('highlight');\n          i--; j--;\n        } else {\n          if (dp[i-1][j] >= dp[i][j-1]) {\n            // go up\n            i--;\n          } else {\n            j--;\n          }\n        }\n      }\n      return seq.reverse().join('');\n    }\n\n    // Backtrack to enumerate all LCS sequences (with memoization and limit)\n    function allLCS(limit = maxEnumerate) {\n      const memo = new Map(); // key: i,j -> set of strings (array)\n      function key(i,j){ return i+','+j; }\n\n      function helper(i,j) {\n        const k = key(i,j);\n        if (memo.has(k)) return memo.get(k);\n        const res = new Set();\n        if (i===0 || j===0) {\n          res.add('');\n          memo.set(k,res); return res;\n        }\n        if (A[i-1] === B[j-1]) {\n          const prev = helper(i-1,j-1);\n          for (const s of prev) {\n            // prepend A[i-1] (but since prev strings are from left->right, append)\n            res.add(s + A[i-1]);\n            if (res.size >= limit) break;\n          }\n        } else {\n          if (dp[i-1][j] >= dp[i][j-1]) {\n            for (const s of helper(i-1,j)) {\n              res.add(s);\n              if (res.size >= limit) break;\n            }\n          }\n          if (res.size < limit && dp[i][j-1] >= dp[i-1][j]) {\n            for (const s of helper(i,j-1)) {\n              res.add(s);\n              if (res.size >= limit) break;\n            }\n          }\n        }\n        // For correctness, the strings created by match-case are built L->R (since we appended as we go bottom-up),\n        // but when returning to top-level they are in correct order.\n        // However helper returns strings built from prefixes ending at i,j; for performance we are okay.\n        memo.set(k,res);\n        return res;\n      }\n\n      const setRes = helper(n,m);\n      // The set contains strings built left-to-right but possibly duplicates; ensure unique and cut limit\n      const arr = Array.from(setRes).slice(0, limit);\n      // They might be built from bottom-up appending; ensure they are of length dp[n][m]\n      return arr.map(s => s);\n    }\n\n    // Highlight a chosen LCS sequence's match positions in the table\n    function highlightSequence(seq) {\n      // Clear previous highlights\n      for (let i=0;i<=n;i++) for (let j=0;j<=m;j++) cells[i][j].classList.remove('highlight');\n\n      let i=1, j=1;\n      let k=0;\n      // We want to mark positions where characters of seq were matched. We'll scan A and B to find matches in DP consistent with seq.\n      // We'll iterate through table: move to find next char of seq by advancing i/j such that match occurs at dp value decreasing as appropriate.\n      i = n; j = m;\n      // For better marking, we'll backtrack following the specific sequence: start from end and find matches backward.\n      const positions = [];\n      let si = seq.length -1;\n      while (i>0 && j>0 && si>=0) {\n        if (A[i-1] === B[j-1] && A[i-1] === seq[si]) {\n          positions.push([i,j]);\n          i--; j--; si--;\n        } else {\n          // move in direction of greater dp\n          if (dp[i-1][j] >= dp[i][j-1]) i--; else j--;\n        }\n      }\n      // mark positions\n      for (const [ii,jj] of positions) cells[ii][jj].classList.add('highlight');\n    }\n\n    // Display final results\n    function displayResults() {\n      lcsLenSpan.textContent = String(dp[n][m]);\n      // Clear highlights first\n      for (let i=0;i<=n;i++) for (let j=0;j<=m;j++) cells[i][j].classList.remove('highlight');\n\n      // Find one LCS\n      const one = getOneLCS();\n      oneLcsSpan.textContent = one || '(empty)';\n\n      // Enumerate all (up to limit)\n      status.textContent = 'Enumerating LCS (limited)...';\n      // We do enumeration asynchronously so UI doesn't block for long sequences\n      setTimeout(() => {\n        const arr = allLCS(maxEnumerate);\n        // arr contains strings built from left to right. Some might be in reversed order in our builder depending on implementation;\n        // ensure they are of correct length and no duplicates.\n        const uniq = Array.from(new Set(arr)).filter(s => s.length === dp[n][m]);\n        allLcsDiv.innerHTML = '';\n        if (uniq.length === 0) {\n          allLcsDiv.textContent = '(none / empty)';\n        } else {\n          for (let i=0;i<uniq.length;i++) {\n            const d = document.createElement('div');\n            d.style.padding = '4px 0';\n            d.style.borderBottom = (i<uniq.length-1)? '1px dashed #eee' : 'none';\n            d.innerHTML = `<span class=\"small\">${i+1}.</span> <span class=\"sequence-picked\">${uniq[i]||'(empty)'}</span>`;\n            // clicking a sequence highlights its matches in table\n            d.style.cursor = 'pointer';\n            d.title = 'Click to highlight this sequence on the DP table';\n            d.addEventListener('click', ()=> highlightSequence(uniq[i]));\n            allLcsDiv.appendChild(d);\n          }\n          if (uniq.length >= maxEnumerate) {\n            const note = document.createElement('div'); note.className='note'; note.textContent = `Displayed first ${maxEnumerate} unique LCS sequences (limit).`;\n            allLcsDiv.appendChild(note);\n          }\n        }\n        status.textContent = 'Done. Click any sequence to highlight its matches in the table.';\n      }, 10);\n    }\n\n    // Wire buttons\n    computeBtn.addEventListener('click', async () => {\n      // reset statuses\n      status.textContent = 'Preparing...';\n      // Cancel any existing highlights / animation state\n      paused = false;\n      stepMode = false;\n      stepBtn.disabled = true;\n      pauseBtn.disabled = true;\n      try {\n        await compute(animateChk.checked);\n      } catch (e) {\n        console.error(e);\n        status.textContent = 'Error: ' + e.message;\n      }\n    });\n\n    // Pause button\n    pauseBtn.addEventListener('click', () => {\n      if (!animating) return;\n      paused = !paused;\n      pauseBtn.textContent = paused ? 'Resume' : 'Pause';\n      status.textContent = paused ? 'Paused.' : 'Animating...';\n      // If paused, enable step button to allow stepping\n      stepBtn.disabled = !paused;\n      stepMode = false;\n    });\n\n    // Step button toggles step-mode: if clicked it's handled in compute loop\n    stepBtn.addEventListener('click', () => {\n      // step action is handled during compute via event listener in compute's step promise\n      // (button enabled only when paused).\n    });\n\n    // Keyboard shortcut: Enter in input triggers compute\n    [strAInput, strBInput].forEach(inp => {\n      inp.addEventListener('keydown', (e) => { if (e.key === 'Enter') computeBtn.click(); });\n    });\n\n    // Initial compute on load\n    window.addEventListener('load', () => {\n      computeBtn.click();\n    });\n\n    // Small improvements: recompute on string change after small delay?\n    // Not necessary here; user can press compute.\n\n    // Explanatory note in the console for advanced users\n    console.log('LCS Visualizer ready. Edit the strings and press Compute. Click sequences to highlight matches in DP table.');\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Longest Common Subsequence"
    }
  ],
  "topic": "Longest Common Subsequence",
  "hasFSM": false,
  "hasTest": true
}