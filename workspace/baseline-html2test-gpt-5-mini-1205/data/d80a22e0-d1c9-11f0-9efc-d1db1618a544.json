{
  "id": "d80a22e0-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:04:54.423Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Binary Search Tree (BST) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#60a5fa;\n      --muted:#94a3b8;\n      --card:#0b1726;\n      --good:#34d399;\n      --bad:#fb7185;\n      --text:#e6eef8;\n    }\n    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;}\n    body{background: linear-gradient(180deg,#071226 0%, #07182a 100%); color:var(--text); display:flex; align-items:flex-start; justify-content:center; padding:24px;}\n    .container{width:1100px; max-width:98vw; background: linear-gradient(180deg,#071422 0%, #071428 100%); border-radius:12px; box-shadow:0 10px 30px rgba(2,6,23,0.7); padding:18px; display:grid; grid-template-columns: 340px 1fr; gap:16px;}\n    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:10px; padding:14px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);}\n    .controls{display:flex;flex-direction:column;gap:12px;}\n    .controls h2{margin:0 0 6px 0;font-size:18px;color:var(--accent);}\n    .row{display:flex;gap:8px;align-items:center;}\n    input[type=\"number\"], input[type=\"text\"], select{\n      background:transparent;border:1px solid rgba(255,255,255,0.06); color:var(--text); padding:8px 10px; border-radius:8px; outline:none; font-size:14px; width:100%;\n    }\n    button{background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.06); color:var(--text); padding:8px 10px; border-radius:8px; cursor:pointer;}\n    button.primary{background:linear-gradient(180deg,var(--accent), #2b6fbf); color:#041024; font-weight:600;}\n    button.small{padding:6px 8px;font-size:13px;}\n    .muted{color:var(--muted); font-size:13px;}\n    .svgwrap{background:linear-gradient(180deg,#05202e 0%, #02121a 100%); border-radius:10px; padding:12px; height:680px; overflow:auto;}\n    svg{width:100%; min-height:640px;}\n    .node{cursor:pointer; transition:transform 120ms ease;}\n    .node circle{fill:rgba(255,255,255,0.06); stroke:rgba(255,255,255,0.08); stroke-width:1.2;}\n    .node text{fill:var(--text); font-size:13px; font-weight:600; dominant-baseline:middle; text-anchor:middle;}\n    .node.highlight circle{fill:var(--accent); stroke:#062c4f;}\n    .node.found circle{fill:var(--good); stroke:#053b2a;}\n    .node.del circle{fill:var(--bad); stroke:#4b0f17;}\n    .edge{stroke:rgba(255,255,255,0.06); stroke-width:1.2;}\n    .edge.highlight{stroke:var(--accent); stroke-width:2;}\n    .info{font-size:13px;color:var(--muted); display:flex; gap:8px; flex-wrap:wrap;}\n    .traversal{display:flex; gap:6px; flex-wrap:wrap; max-height:120px; overflow:auto; padding:8px; background:rgba(255,255,255,0.02); border-radius:8px;}\n    .chip{background:rgba(255,255,255,0.03); padding:6px 8px; border-radius:6px; color:var(--text); font-weight:600;}\n    .footer{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-top:6px;}\n    .smallmuted{font-size:12px;color:var(--muted);}\n    .legend{display:flex;gap:8px;align-items:center;}\n    .legend .box{width:14px;height:14px;border-radius:4px;}\n    .legend .h {background:var(--accent);} .legend .f{background:var(--good);} .legend .d{background:var(--bad);}\n    .message{padding:8px;border-radius:8px;background:rgba(255,255,255,0.02); color:var(--muted); font-size:13px;}\n    footer.note{font-size:12px;color:var(--muted); margin-top:8px;}\n    a.link{color:var(--accent); text-decoration:none;}\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"panel controls\">\n      <h2>Binary Search Tree (BST)</h2>\n      <div class=\"muted\">Insert, search, delete, and visualize the BST. Values are numeric. Duplicates are ignored.</div>\n\n      <div style=\"height:8px;\"></div>\n\n      <div class=\"row\">\n        <input id=\"valueInput\" type=\"number\" placeholder=\"Value (e.g. 42)\" />\n        <button id=\"insertBtn\" class=\"primary small\">Insert</button>\n      </div>\n\n      <div class=\"row\">\n        <button id=\"searchBtn\" class=\"small\">Search</button>\n        <button id=\"deleteBtn\" class=\"small\">Delete</button>\n        <button id=\"clearBtn\" class=\"small\">Clear</button>\n      </div>\n\n      <div class=\"row\" style=\"align-items:center;\">\n        <label class=\"smallmuted\" style=\"width:80px;\">Speed</label>\n        <input id=\"speedRange\" type=\"range\" min=\"50\" max=\"1000\" value=\"300\" />\n        <div class=\"smallmuted\" id=\"speedVal\">300 ms</div>\n      </div>\n\n      <div style=\"height:6px;\"></div>\n\n      <div>\n        <label class=\"smallmuted\">Traversal</label>\n        <div class=\"row\" style=\"margin-top:6px;\">\n          <button id=\"inorderBtn\" class=\"small\">In-order</button>\n          <button id=\"preorderBtn\" class=\"small\">Pre-order</button>\n          <button id=\"postorderBtn\" class=\"small\">Post-order</button>\n          <button id=\"levelBtn\" class=\"small\">Level-order</button>\n        </div>\n      </div>\n\n      <div style=\"height:8px;\"></div>\n\n      <div>\n        <label class=\"smallmuted\">Utilities</label>\n        <div style=\"display:flex;gap:8px;margin-top:6px;flex-wrap:wrap;\">\n          <button id=\"randomBtn\" class=\"small\">Random Tree</button>\n          <button id=\"balanceBtn\" class=\"small\">Build Balanced</button>\n          <button id=\"infoBtn\" class=\"small\">Info</button>\n        </div>\n      </div>\n\n      <div style=\"height:12px;\"></div>\n\n      <div class=\"panel\" style=\"padding:10px;background:transparent;border:1px dashed rgba(255,255,255,0.02);\">\n        <div class=\"muted\">Traversals (animated):</div>\n        <div id=\"travOutput\" class=\"traversal\" aria-live=\"polite\"></div>\n      </div>\n\n      <div style=\"height:8px;\"></div>\n\n      <div class=\"message\" id=\"message\">Click nodes to highlight. Use controls to modify the tree.</div>\n\n      <div class=\"footer\">\n        <div class=\"legend\">\n          <div style=\"display:flex;flex-direction:column;gap:6px;\">\n            <div style=\"display:flex;gap:6px;align-items:center;\"><div class=\"box h\"></div><span class=\"smallmuted\">Visited</span></div>\n            <div style=\"display:flex;gap:6px;align-items:center;\"><div class=\"box f\"></div><span class=\"smallmuted\">Found</span></div>\n            <div style=\"display:flex;gap:6px;align-items:center;\"><div class=\"box d\"></div><span class=\"smallmuted\">Deleting</span></div>\n          </div>\n        </div>\n        <div>\n          <div class=\"smallmuted\">Nodes: <span id=\"nodeCount\">0</span></div>\n          <div class=\"smallmuted\">Height: <span id=\"nodeHeight\">0</span></div>\n        </div>\n      </div>\n\n      <footer class=\"note\">Tip: Insert numbers and then use traversals to see ordered sequences. Delete demonstrates BST removal cases (leaf, one child, two children).</footer>\n    </div>\n\n    <div class=\"panel svgwrap\" aria-live=\"polite\">\n      <svg id=\"svgCanvas\" viewBox=\"0 0 1200 700\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n    </div>\n  </div>\n\n<script>\n/*\n  BST Visualizer\n  - Insert, Search, Delete\n  - Traversals (animated)\n  - SVG visualization with auto-layout (in-order x assignment)\n*/\n\n// --- Data structures ---\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass BST {\n  constructor() {\n    this.root = null;\n    this._size = 0;\n  }\n\n  size() { return this._size; }\n\n  insert(val) {\n    if (this.root === null) {\n      this.root = new Node(val);\n      this._size++;\n      return true;\n    }\n    let cur = this.root;\n    while (true) {\n      if (val === cur.val) return false; // ignore duplicates\n      if (val < cur.val) {\n        if (!cur.left) { cur.left = new Node(val); this._size++; return true; }\n        cur = cur.left;\n      } else {\n        if (!cur.right) { cur.right = new Node(val); this._size++; return true; }\n        cur = cur.right;\n      }\n    }\n  }\n\n  find(val) {\n    let cur = this.root;\n    while (cur) {\n      if (val === cur.val) return cur;\n      cur = val < cur.val ? cur.left : cur.right;\n    }\n    return null;\n  }\n\n  minNode(node=this.root) {\n    if (!node) return null;\n    while (node.left) node = node.left;\n    return node;\n  }\n\n  delete(val) {\n    let deleted = false;\n    const remove = (node, val) => {\n      if (!node) return null;\n      if (val < node.val) {\n        node.left = remove(node.left, val);\n        return node;\n      } else if (val > node.val) {\n        node.right = remove(node.right, val);\n        return node;\n      } else {\n        deleted = true;\n        // node with only one child or no child\n        if (!node.left) return node.right;\n        if (!node.right) return node.left;\n        // node with two children: get inorder successor (min in right subtree)\n        let succ = this.minNode(node.right);\n        node.val = succ.val;\n        // delete successor\n        node.right = remove(node.right, succ.val);\n        return node;\n      }\n    };\n    this.root = remove(this.root, val);\n    if (deleted) this._size--;\n    return deleted;\n  }\n\n  // Traversals returning array of values and optionally nodes visited order\n  inorderVisit(node=this.root, arr=[]) {\n    if (!node) return arr;\n    this.inorderVisit(node.left, arr);\n    arr.push(node.val);\n    this.inorderVisit(node.right, arr);\n    return arr;\n  }\n  preorderVisit(node=this.root, arr=[]) {\n    if (!node) return arr;\n    arr.push(node.val);\n    this.preorderVisit(node.left, arr);\n    this.preorderVisit(node.right, arr);\n    return arr;\n  }\n  postorderVisit(node=this.root, arr=[]) {\n    if (!node) return arr;\n    this.postorderVisit(node.left, arr);\n    this.postorderVisit(node.right, arr);\n    arr.push(node.val);\n    return arr;\n  }\n  levelOrderVisit() {\n    let res=[]; if (!this.root) return res;\n    let q=[this.root];\n    while(q.length){\n      let n=q.shift();\n      res.push(n.val);\n      if(n.left) q.push(n.left);\n      if(n.right) q.push(n.right);\n    }\n    return res;\n  }\n\n  height(node=this.root) {\n    if (!node) return 0;\n    return 1 + Math.max(this.height(node.left), this.height(node.right));\n  }\n\n  // For visualization: produce nodes with positions using in-order x assignment\n  layout(spacingX=80, spacingY=80) {\n    // Traverse to assign x based on in-order index and y based on depth\n    let positions = new Map(); // node -> {x,y}\n    let index = 0;\n    function dfs(node, depth) {\n      if(!node) return;\n      dfs(node.left, depth+1);\n      positions.set(node, {x: index*spacingX, y: depth*spacingY});\n      index++;\n      dfs(node.right, depth+1);\n    }\n    dfs(this.root, 0);\n    return positions;\n  }\n\n  // Collect nodes with parent pointers for edges\n  nodesWithParents() {\n    let list=[];\n    function dfs(node, parent=null){\n      if(!node) return;\n      list.push({node,parent});\n      dfs(node.left, node);\n      dfs(node.right, node);\n    }\n    dfs(this.root, null);\n    return list;\n  }\n}\n\n// --- Visualization & UI ---\nconst svg = document.getElementById('svgCanvas');\nconst valueInput = document.getElementById('valueInput');\nconst insertBtn = document.getElementById('insertBtn');\nconst searchBtn = document.getElementById('searchBtn');\nconst deleteBtn = document.getElementById('deleteBtn');\nconst clearBtn = document.getElementById('clearBtn');\nconst inorderBtn = document.getElementById('inorderBtn');\nconst preorderBtn = document.getElementById('preorderBtn');\nconst postorderBtn = document.getElementById('postorderBtn');\nconst levelBtn = document.getElementById('levelBtn');\nconst travOutput = document.getElementById('travOutput');\nconst message = document.getElementById('message');\nconst nodeCount = document.getElementById('nodeCount');\nconst nodeHeight = document.getElementById('nodeHeight');\nconst speedRange = document.getElementById('speedRange');\nconst speedVal = document.getElementById('speedVal');\nconst randomBtn = document.getElementById('randomBtn');\nconst balanceBtn = document.getElementById('balanceBtn');\nconst infoBtn = document.getElementById('infoBtn');\n\nlet bst = new BST();\nlet animSpeed = parseInt(speedRange.value); // ms per step\n\nspeedRange.addEventListener('input', ()=>{ animSpeed = parseInt(speedRange.value); speedVal.textContent = animSpeed + ' ms'; });\n\n// helpers to clear svg\nfunction clearSVG() {\n  while (svg.firstChild) svg.removeChild(svg.firstChild);\n}\n\n// render tree\nfunction renderTree(highlights = {}) {\n  // highlights: {visited:Set(vals), found:Set(vals), deleting:Set(vals), pathEdges:Set([{p,c}])}\n  const spacingX = Math.max(60, 900 / Math.max(1, bst.size())); // adapt spacing to width\n  const spacingY = 90;\n  clearSVG();\n  if (!bst.root) {\n    // empty state\n    const txt = document.createElementNS('http://www.w3.org/2000/svg','text');\n    txt.setAttribute('x', 600);\n    txt.setAttribute('y', 320);\n    txt.setAttribute('fill','rgba(255,255,255,0.06)');\n    txt.setAttribute('font-size', '18');\n    txt.setAttribute('text-anchor','middle');\n    txt.textContent = 'Empty BST — insert nodes to begin';\n    svg.appendChild(txt);\n    updateStats();\n    return;\n  }\n\n  const positions = bst.layout(spacingX, spacingY);\n  // compute bounding box offset to center\n  let xs = Array.from(positions.values()).map(p=>p.x);\n  if(xs.length===0) return;\n  let minx = Math.min(...xs);\n  let maxx = Math.max(...xs);\n  let treeWidth = Math.max(600, (maxx - minx) + spacingX);\n  // shift to center in 1200 width viewBox\n  let offsetX = (1200 - treeWidth) / 2 - minx + spacingX/2;\n\n  // draw edges first\n  const nodes = bst.nodesWithParents();\n  for (let {node,parent} of nodes) {\n    if (!parent) continue;\n    const pPos = positions.get(parent);\n    const cPos = positions.get(node);\n    const x1 = pPos.x + offsetX;\n    const y1 = pPos.y + 60;\n    const x2 = cPos.x + offsetX;\n    const y2 = cPos.y + 60;\n    const edge = document.createElementNS('http://www.w3.org/2000/svg','line');\n    edge.setAttribute('x1', x1); edge.setAttribute('y1', y1);\n    edge.setAttribute('x2', x2); edge.setAttribute('y2', y2);\n    edge.setAttribute('class','edge');\n    // highlight if part of pathEdges\n    if (highlights.pathEdges) {\n      for (let pe of highlights.pathEdges) {\n        if (pe.p === parent.val && pe.c === node.val) {\n          edge.classList.add('highlight');\n        }\n      }\n    }\n    svg.appendChild(edge);\n  }\n\n  // draw nodes\n  for (let {node,parent} of nodes) {\n    const pos = positions.get(node);\n    const cx = pos.x + offsetX;\n    const cy = pos.y + 60;\n    const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n    g.setAttribute('transform', `translate(${cx},${cy})`);\n    g.setAttribute('class','node');\n    g.dataset.val = node.val;\n    const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');\n    circ.setAttribute('r', 20);\n    g.appendChild(circ);\n    const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n    t.textContent = node.val;\n    g.appendChild(t);\n\n    // apply highlight classes\n    if (highlights.visited && highlights.visited.has(node.val)) g.classList.add('highlight');\n    if (highlights.found && highlights.found.has(node.val)) g.classList.add('found');\n    if (highlights.deleting && highlights.deleting.has(node.val)) g.classList.add('del');\n\n    // click handler: show info and highlight path from root to this node\n    g.addEventListener('click', (e) => {\n      e.stopPropagation();\n      // compute path\n      const path = pathToValue(node.val);\n      const edges = [];\n      for (let i=0;i<path.length-1;i++){ edges.push({p:path[i], c:path[i+1]}); }\n      renderTree({visited: new Set(path), pathEdges: edges});\n      message.textContent = 'Path to ' + node.val + ': ' + path.join(' → ');\n    });\n\n    svg.appendChild(g);\n  }\n\n  updateStats();\n}\n\n// returns array of vals from root to val if found (includes val). If not found returns the visited path until null.\nfunction pathToValue(val) {\n  let cur = bst.root;\n  const path = [];\n  while (cur) {\n    path.push(cur.val);\n    if (val === cur.val) return path;\n    cur = val < cur.val ? cur.left : cur.right;\n  }\n  return path;\n}\n\nfunction updateStats() {\n  nodeCount.textContent = bst.size();\n  nodeHeight.textContent = bst.height();\n}\n\n// --- Animation and operations ---\n\nfunction sleep(ms){ return new Promise(resolve=>setTimeout(resolve, ms)); }\n\nasync function animateSearch(val) {\n  if (!bst.root) { message.textContent = 'Tree is empty.'; renderTree(); return; }\n  let cur = bst.root;\n  const visited = new Set();\n  const edges = [];\n  while (cur) {\n    visited.add(cur.val);\n    renderTree({visited, pathEdges: edges});\n    message.textContent = 'Visiting ' + cur.val;\n    await sleep(animSpeed);\n    if (val === cur.val) {\n      renderTree({found: new Set([cur.val]), visited, pathEdges: edges});\n      message.textContent = 'Found ' + val;\n      return true;\n    }\n    // record edge to next\n    const next = val < cur.val ? cur.left : cur.right;\n    if (next) edges.push({p: cur.val, c: next.val});\n    cur = next;\n  }\n  renderTree({visited});\n  message.textContent = String(val) + ' not found in the tree.';\n  return false;\n}\n\nasync function animateInsert(val) {\n  if (bst.find(val)) { message.textContent = 'Value already exists (duplicates ignored).'; renderTree(); return; }\n  if (!bst.root) {\n    bst.insert(val);\n    renderTree();\n    message.textContent = 'Inserted ' + val + ' as root.';\n    return;\n  }\n  let cur = bst.root;\n  const visited = new Set();\n  const edges = [];\n  while (cur) {\n    visited.add(cur.val);\n    renderTree({visited, pathEdges: edges});\n    message.textContent = 'Comparing with ' + cur.val;\n    await sleep(animSpeed);\n    if (val < cur.val) {\n      if (!cur.left) {\n        // insert here\n        cur.left = new Node(val);\n        bst._size++;\n        edges.push({p:cur.val, c:val});\n        renderTree({found:new Set([val]), visited, pathEdges: edges});\n        message.textContent = 'Inserted ' + val + ' as left child of ' + cur.val;\n        return;\n      } else {\n        edges.push({p:cur.val, c:cur.left.val});\n        cur = cur.left;\n      }\n    } else {\n      if (!cur.right) {\n        cur.right = new Node(val);\n        bst._size++;\n        edges.push({p:cur.val, c:val});\n        renderTree({found:new Set([val]), visited, pathEdges: edges});\n        message.textContent = 'Inserted ' + val + ' as right child of ' + cur.val;\n        return;\n      } else {\n        edges.push({p:cur.val, c:cur.right.val});\n        cur = cur.right;\n      }\n    }\n  }\n}\n\nasync function animateDelete(val) {\n  if (!bst.root) { message.textContent = 'Tree is empty.'; renderTree(); return; }\n  // show path to value\n  let cur = bst.root;\n  const visited = new Set();\n  const edges = [];\n  let found = false;\n  while (cur) {\n    visited.add(cur.val);\n    renderTree({visited, pathEdges: edges});\n    message.textContent = 'Visiting ' + cur.val;\n    await sleep(animSpeed);\n    if (val === cur.val) { found = true; break; }\n    const next = val < cur.val ? cur.left : cur.right;\n    if (next) edges.push({p: cur.val, c: next.val});\n    cur = next;\n  }\n  if (!found) {\n    message.textContent = val + ' not found. Nothing to delete.';\n    renderTree({visited});\n    return;\n  }\n  // highlight node to delete\n  renderTree({deleting:new Set([val]), visited, pathEdges: edges});\n  message.textContent = 'Deleting ' + val + '...';\n  await sleep(animSpeed+60);\n  // perform deletion in data structure (non-animated internal restructure)\n  const deleted = bst.delete(val);\n  if (deleted) {\n    renderTree();\n    message.textContent = 'Deleted ' + val + '.';\n  } else {\n    renderTree();\n    message.textContent = 'Deletion failed?';\n  }\n}\n\n// Traversal animation: highlight nodes in order\nasync function animateTraversal(list) {\n  travOutput.innerHTML = '';\n  for (let v of list) {\n    const chip = document.createElement('div');\n    chip.className = 'chip';\n    chip.textContent = v;\n    travOutput.appendChild(chip);\n    // highlight in tree\n    renderTree({found: new Set([v])});\n    await sleep(animSpeed);\n  }\n  renderTree();\n  message.textContent = 'Traversal complete: ' + list.join(', ');\n}\n\n// --- UI event bindings ---\ninsertBtn.addEventListener('click', async () => {\n  const v = parseInt(valueInput.value);\n  if (Number.isNaN(v)) { message.textContent = 'Enter a numeric value to insert.'; return; }\n  insertBtn.disabled = true;\n  await animateInsert(v);\n  insertBtn.disabled = false;\n  updateStats();\n});\n\nsearchBtn.addEventListener('click', async () => {\n  const v = parseInt(valueInput.value);\n  if (Number.isNaN(v)) { message.textContent = 'Enter numeric value to search.'; return; }\n  searchBtn.disabled = true;\n  await animateSearch(v);\n  searchBtn.disabled = false;\n});\n\ndeleteBtn.addEventListener('click', async () => {\n  const v = parseInt(valueInput.value);\n  if (Number.isNaN(v)) { message.textContent = 'Enter numeric value to delete.'; return; }\n  deleteBtn.disabled = true;\n  await animateDelete(v);\n  deleteBtn.disabled = false;\n  updateStats();\n});\n\nclearBtn.addEventListener('click', () => {\n  bst = new BST();\n  renderTree();\n  message.textContent = 'Cleared tree.';\n});\n\ninorderBtn.addEventListener('click', async () => {\n  inorderBtn.disabled = true;\n  const list = bst.inorderVisit();\n  await animateTraversal(list);\n  inorderBtn.disabled = false;\n});\n\npreorderBtn.addEventListener('click', async () => {\n  preorderBtn.disabled = true;\n  const list = bst.preorderVisit();\n  await animateTraversal(list);\n  preorderBtn.disabled = false;\n});\n\npostorderBtn.addEventListener('click', async () => {\n  postorderBtn.disabled = true;\n  const list = bst.postorderVisit();\n  await animateTraversal(list);\n  postorderBtn.disabled = false;\n});\n\nlevelBtn.addEventListener('click', async () => {\n  levelBtn.disabled = true;\n  const list = bst.levelOrderVisit();\n  await animateTraversal(list);\n  levelBtn.disabled = false;\n});\n\nrandomBtn.addEventListener('click', () => {\n  // build a random tree with 8-14 nodes\n  bst = new BST();\n  const count = 8 + Math.floor(Math.random() * 7);\n  const vals = new Set();\n  while (vals.size < count) {\n    vals.add(Math.floor(Math.random()*100));\n  }\n  for (let v of vals) bst.insert(v);\n  renderTree();\n  message.textContent = 'Random tree with ' + bst.size() + ' nodes.';\n});\n\nbalanceBtn.addEventListener('click', () => {\n  // build balanced tree from sorted list\n  let vals = [];\n  // allow user to type a comma-separated list?\n  const raw = valueInput.value.trim();\n  if (raw.includes(',')) {\n    vals = raw.split(',').map(s=>parseInt(s.trim())).filter(n=>!Number.isNaN(n));\n  }\n  if (vals.length === 0) {\n    // if no list, use a random small set\n    const count = 9;\n    let s = new Set();\n    while (s.size < count) s.add(Math.floor(Math.random()*100));\n    vals = Array.from(s);\n  }\n  vals = Array.from(new Set(vals)).sort((a,b)=>a-b);\n  bst = new BST();\n  function buildBalanced(arr) {\n    if (!arr.length) return null;\n    const mid = Math.floor(arr.length/2);\n    const node = new Node(arr[mid]);\n    node.left = buildBalanced(arr.slice(0,mid));\n    node.right = buildBalanced(arr.slice(mid+1));\n    return node;\n  }\n  bst.root = buildBalanced(vals);\n  bst._size = vals.length;\n  renderTree();\n  message.textContent = 'Built balanced tree from ' + vals.length + ' values.';\n});\n\ninfoBtn.addEventListener('click', () => {\n  alert('BST operations:\\n- Insert: add value maintaining left<node<right\\n- Search: follow left/right until found or null\\n- Delete: three cases: leaf, one child, two children (replace with inorder successor)\\n- Traversals: inorder gives sorted order.');\n});\n\n// initial render\nrenderTree();\n\n// keyboard Enter to insert\nvalueInput.addEventListener('keydown', (e) => {\n  if (e.key === 'Enter') insertBtn.click();\n});\n\n// click background to reset highlights\nsvg.addEventListener('click', (e) => {\n  renderTree();\n  message.textContent = 'Canvas clicked. Highlights cleared.';\n});\n\n// initial sample\n(function seedSample(){\n  const sample = [50, 30, 70, 20, 40, 60, 80];\n  for (let v of sample) bst.insert(v);\n  renderTree();\n  message.textContent = 'Sample BST loaded (balanced-ish).';\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": false,
  "hasTest": true
}