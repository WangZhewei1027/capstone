{
  "id": "d80a7100-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:18.137Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency Matrix",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Adjacency Matrix Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f1724;\n      --card: #0b1220;\n      --accent: #4fd1c5;\n      --muted: #9aa7b2;\n      --edge: rgba(255,255,255,0.15);\n    }\n    html,body { height:100%; margin:0; font-family: Inter, Roboto, Arial, sans-serif; background: linear-gradient(180deg,#061022 0%, #081426 100%); color:#e6eef6; }\n    .app {\n      display:flex;\n      gap:12px;\n      padding:16px;\n      box-sizing:border-box;\n      height:100vh;\n    }\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.04);\n      border-radius:10px;\n      padding:12px;\n      box-sizing:border-box;\n      box-shadow: 0 8px 30px rgba(2,6,23,0.6);\n    }\n    .left {\n      flex:1.3;\n      display:flex;\n      flex-direction:column;\n      min-width:400px;\n    }\n    .right {\n      flex:1;\n      min-width:360px;\n      max-width:540px;\n      overflow:auto;\n    }\n    .controls {\n      display:flex;\n      gap:8px;\n      align-items:center;\n      flex-wrap:wrap;\n      margin-bottom:10px;\n    }\n    button, input[type=\"number\"], select, textarea {\n      background: rgba(255,255,255,0.03);\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--muted);\n      padding:8px 10px;\n      border-radius:8px;\n      font-size:13px;\n    }\n    button:hover { transform: translateY(-1px); cursor:pointer; color:white; border-color: rgba(255,255,255,0.12); }\n    .status {\n      margin-left:auto;\n      font-size:13px;\n      color:var(--muted);\n    }\n    #canvasWrap {\n      flex:1;\n      border-radius:8px;\n      overflow:hidden;\n      position:relative;\n      border: 1px dashed rgba(255,255,255,0.03);\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.008));\n    }\n    svg {\n      display:block;\n      width:100%;\n      height:100%;\n      cursor:crosshair;\n      user-select:none;\n      -webkit-user-select:none;\n      -moz-user-select:none;\n    }\n    .node {\n      fill: linear-gradient(180deg, #1f6, #08a);\n    }\n    #matrixWrap {\n      max-height: calc(100vh - 120px);\n      overflow:auto;\n      padding:8px;\n    }\n    table.matrix {\n      border-collapse:collapse;\n      font-family: monospace;\n      font-size:13px;\n      width:100%;\n      table-layout:fixed;\n    }\n    table.matrix th, table.matrix td {\n      border:1px solid rgba(255,255,255,0.03);\n      padding:6px;\n      text-align:center;\n      min-width:30px;\n      max-width:60px;\n      overflow:hidden;\n      white-space:nowrap;\n      color:var(--muted);\n      background: rgba(255,255,255,0.01);\n    }\n    table.matrix th {\n      background: rgba(255,255,255,0.02);\n      color:#dfeff2;\n      font-weight:600;\n      position:sticky;\n      top:0;\n      z-index:2;\n    }\n    table.matrix tr.header th:first-child { position:sticky; left:0; z-index:3; }\n    table.matrix td.cell-hover, table.matrix th.col-hover {\n      background: rgba(79,209,197,0.08);\n      color:#a9fff6;\n    }\n    .edge-line {\n      stroke: rgba(255,255,255,0.14);\n      stroke-width:2;\n      fill:none;\n      stroke-linecap:round;\n    }\n    .edge-arrow {\n      stroke: rgba(255,255,255,0.14);\n      stroke-width:1.6;\n      fill: rgba(255,255,255,0.14);\n    }\n    .node-circle {\n      fill: linear-gradient(180deg,#0ea5a4,#2563eb);\n    }\n    .node-bg {\n      fill: rgba(255,255,255,0.03);\n      stroke: rgba(255,255,255,0.06);\n    }\n    .node-label {\n      pointer-events:none;\n      font-size:12px;\n      fill:#e6f7fa;\n      text-anchor:middle;\n      dominant-baseline:middle;\n      font-weight:600;\n    }\n    .mini {\n      font-size:12px;\n      color:var(--muted);\n    }\n    .footer {\n      display:flex;\n      gap:8px;\n      align-items:center;\n      margin-top:10px;\n    }\n    .hint {\n      font-size:12px;\n      color:var(--muted);\n    }\n    textarea.importBox { width:100%; height:60px; background:transparent; color:#dbefff; border:1px dashed rgba(255,255,255,0.04); padding:8px; border-radius:6px; }\n    .bad { color:#ff9b9b; }\n    .good { color:#9df0d9; }\n    .small { font-size:12px; color:var(--muted); }\n    .legend { display:flex; gap:10px; align-items:center; font-size:13px; color:var(--muted); }\n    .legend .item { display:flex; gap:6px; align-items:center; }\n    .swatch { width:18px; height:10px; border-radius:3px; background:linear-gradient(90deg,#4fd1c5,#38bdf8); border:1px solid rgba(255,255,255,0.04); }\n    .controls .group { display:flex; gap:6px; align-items:center; }\n    .linklike { color:#8fdbd3; text-decoration:underline; background:transparent; border:none; padding:0; cursor:pointer; font-size:13px; }\n    .matrix-controls { display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }\n    .note { font-size:13px; color:var(--muted); }\n    .topbar { display:flex; gap:8px; align-items:center; margin-bottom:8px; }\n    .nodeCount { font-weight:700; color:#dff6f2; }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"panel left\">\n      <div class=\"topbar controls\">\n        <div class=\"group\">\n          <button id=\"addNodeBtn\">Add node</button>\n          <button id=\"randomBtn\">Random graph</button>\n          <button id=\"clearBtn\">Clear</button>\n        </div>\n\n        <div class=\"group\">\n          <label class=\"mini\">Mode:</label>\n          <select id=\"mode\">\n            <option value=\"add\">Add edges (click nodes)</option>\n            <option value=\"remove\">Remove edges (click nodes)</option>\n          </select>\n        </div>\n\n        <div class=\"group\">\n          <label class=\"mini\">Directed</label>\n          <input type=\"checkbox\" id=\"directed\" />\n        </div>\n\n        <div class=\"group\">\n          <label class=\"mini\">Weighted</label>\n          <input type=\"checkbox\" id=\"weighted\" />\n          <input id=\"weightInput\" type=\"number\" value=\"1\" style=\"width:68px;\" step=\"any\" />\n        </div>\n\n        <div class=\"status\">\n          Nodes: <span class=\"nodeCount\" id=\"nodeCount\">0</span>\n        </div>\n      </div>\n\n      <div id=\"canvasWrap\">\n        <svg id=\"svgCanvas\" viewBox=\"0 0 800 600\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n      </div>\n\n      <div class=\"footer\">\n        <div class=\"hint\">Instructions: Add nodes, then click two nodes to add/remove an edge. Drag nodes to reposition. Click matrix cells to edit values.</div>\n        <div style=\"margin-left:auto;\" class=\"legend\">\n          <div class=\"item\"><div class=\"swatch\"></div> Edge</div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel right\">\n      <div class=\"matrix-controls\">\n        <div class=\"group\">\n          <button id=\"exportBtn\">Export JSON</button>\n          <button id=\"importBtn\">Import JSON</button>\n        </div>\n        <div class=\"group\">\n          <button id=\"transposeBtn\">Transpose</button>\n          <button id=\"complementBtn\">Complement</button>\n        </div>\n        <div style=\"margin-left:auto\" class=\"small\">Click a row or column header to highlight.</div>\n      </div>\n\n      <div id=\"matrixWrap\"></div>\n\n      <div style=\"margin-top:10px;\">\n        <div class=\"note\">Adjacency matrix: A[i][j] indicates an edge from node i to node j. For undirected graphs, matrix is symmetric.</div>\n        <div style=\"margin-top:8px;\">\n          <textarea id=\"ioArea\" class=\"importBox\" placeholder=\"Exported graph JSON will appear here; you can paste JSON here to import.\"></textarea>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    (function(){\n      // Basic graph model\n      let nodes = []; // {id,label,x,y}\n      let matrix = []; // NxN numbers (0 or weight)\n      let svg = document.getElementById('svgCanvas');\n      let addNodeBtn = document.getElementById('addNodeBtn');\n      let randomBtn = document.getElementById('randomBtn');\n      let clearBtn = document.getElementById('clearBtn');\n      let directedChk = document.getElementById('directed');\n      let weightedChk = document.getElementById('weighted');\n      let weightInput = document.getElementById('weightInput');\n      let modeSelect = document.getElementById('mode');\n      let matrixWrap = document.getElementById('matrixWrap');\n      let nodeCountEl = document.getElementById('nodeCount');\n      let exportBtn = document.getElementById('exportBtn');\n      let importBtn = document.getElementById('importBtn');\n      let ioArea = document.getElementById('ioArea');\n      let transposeBtn = document.getElementById('transposeBtn');\n      let complementBtn = document.getElementById('complementBtn');\n\n      let state = {\n        lastClickedNode: null,\n        dragging: null,\n        dragOffset: {x:0,y:0},\n      };\n\n      // Utilities\n      function uid() { return Math.random().toString(36).slice(2,9); }\n      function updateNodeCount() { nodeCountEl.textContent = nodes.length; }\n\n      // Canvas size defaults (viewBox)\n      const viewW = 800, viewH = 600;\n\n      // Create new node at random location\n      function addNodeAt(x,y,label) {\n        let id = uid();\n        let idx = nodes.length;\n        let newNode = { id, label: label || ('v' + (idx)), x: x===undefined? (100 + Math.random()*(viewW-200)) : x, y: y===undefined? (100 + Math.random()*(viewH-200)) : y };\n        nodes.push(newNode);\n        // expand matrix\n        for (let i=0;i<matrix.length;i++) matrix[i].push(0);\n        matrix.push(Array(nodes.length).fill(0));\n        refresh();\n      }\n\n      function removeAll() {\n        nodes = [];\n        matrix = [];\n        state.lastClickedNode = null;\n        refresh();\n      }\n\n      function randomGraph(n=6, p=0.25) {\n        removeAll();\n        for (let i=0;i<n;i++) addNodeAt(undefined,undefined,'v'+i);\n        for (let i=0;i<n;i++){\n          for (let j=0;j<n;j++){\n            if (i===j) continue;\n            if (Math.random()<p) {\n              matrix[i][j] = weightedChk.checked ? Number(weightInput.value || 1) : 1;\n              if (!directedChk.checked) matrix[j][i] = matrix[i][j];\n            }\n          }\n        }\n        refresh();\n      }\n\n      // Edge toggle from i->j\n      function toggleEdge(i,j,make) {\n        if (i<0||j<0||i>=nodes.length||j>=nodes.length) return;\n        if (i===j) return; // ignore self-loops for simplicity\n        let w = weightedChk.checked ? Number(weightInput.value || 1) : 1;\n        if (make===true) {\n          matrix[i][j] = w;\n          if (!directedChk.checked) matrix[j][i] = w;\n        } else if (make===false) {\n          matrix[i][j] = 0;\n          if (!directedChk.checked) matrix[j][i] = 0;\n        } else {\n          // toggle\n          if (matrix[i][j]) {\n            matrix[i][j] = 0;\n            if (!directedChk.checked) matrix[j][i] = 0;\n          } else {\n            matrix[i][j] = w;\n            if (!directedChk.checked) matrix[j][i] = w;\n          }\n        }\n        refresh();\n      }\n\n      // Rendering\n      function refresh() {\n        updateNodeCount();\n        renderSVG();\n        renderMatrix();\n      }\n\n      function renderSVG() {\n        // Clear\n        while (svg.firstChild) svg.removeChild(svg.firstChild);\n\n        // Draw edges first\n        let N = nodes.length;\n        for (let i=0;i<N;i++){\n          for (let j=0;j<N;j++){\n            if (matrix[i][j] && (directedChk.checked || i<=j || matrix[j][i]===0 || i!==j)) {\n              // for undirected graphs we will draw once (i<j)\n              if (!directedChk.checked && j<i) continue;\n              drawEdge(nodes[i], nodes[j], matrix[i][j], directedChk.checked);\n            }\n          }\n        }\n\n        // Draw nodes\n        nodes.forEach((n, idx)=>{\n          let g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('data-idx', idx);\n          g.setAttribute('class','node-g');\n          // background circle\n          let bg = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          bg.setAttribute('cx', n.x);\n          bg.setAttribute('cy', n.y);\n          bg.setAttribute('r', 22);\n          bg.setAttribute('class', 'node-bg');\n          bg.setAttribute('stroke-width','1.2');\n          bg.setAttribute('fill','rgba(255,255,255,0.02)');\n          g.appendChild(bg);\n\n          // main circle\n          let c = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          c.setAttribute('cx', n.x);\n          c.setAttribute('cy', n.y);\n          c.setAttribute('r', 14);\n          c.setAttribute('fill','url(#nodeGrad)');\n          c.setAttribute('class','node-circle');\n          c.setAttribute('stroke','rgba(255,255,255,0.06)');\n          c.setAttribute('stroke-width','1.6');\n          g.appendChild(c);\n\n          // label\n          let t = document.createElementNS('http://www.w3.org/2000/svg','text');\n          t.setAttribute('x', n.x);\n          t.setAttribute('y', n.y);\n          t.setAttribute('class','node-label');\n          t.textContent = n.label;\n          g.appendChild(t);\n\n          // interactions\n          g.addEventListener('mousedown', onNodeMouseDown);\n          g.addEventListener('mouseup', onNodeMouseUp);\n          g.addEventListener('mouseleave', onNodeMouseLeave);\n          g.addEventListener('click', onNodeClick);\n\n          svg.appendChild(g);\n        });\n\n        // Add defs for gradient/arrow marker\n        let defs = document.createElementNS('http://www.w3.org/2000/svg','defs');\n        let grad = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');\n        grad.setAttribute('id','nodeGrad');\n        grad.setAttribute('x1','0%'); grad.setAttribute('x2','100%');\n        grad.setAttribute('y1','0%'); grad.setAttribute('y2','100%');\n        let stop1 = document.createElementNS('http://www.w3.org/2000/svg','stop'); stop1.setAttribute('offset','0%'); stop1.setAttribute('stop-color','#20c997'); stop1.setAttribute('stop-opacity','1');\n        let stop2 = document.createElementNS('http://www.w3.org/2000/svg','stop'); stop2.setAttribute('offset','100%'); stop2.setAttribute('stop-color','#3b82f6'); stop2.setAttribute('stop-opacity','1');\n        grad.appendChild(stop1); grad.appendChild(stop2);\n        defs.appendChild(grad);\n\n        // arrow marker for directed edges\n        let marker = document.createElementNS('http://www.w3.org/2000/svg','marker');\n        marker.setAttribute('id','arrow');\n        marker.setAttribute('markerWidth','8');\n        marker.setAttribute('markerHeight','8');\n        marker.setAttribute('refX','8');\n        marker.setAttribute('refY','3');\n        marker.setAttribute('orient','auto');\n        let path = document.createElementNS('http://www.w3.org/2000/svg','path');\n        path.setAttribute('d','M0,0 L6,3 L0,6 z');\n        path.setAttribute('fill','rgba(255,255,255,0.14)');\n        marker.appendChild(path);\n        defs.appendChild(marker);\n\n        svg.insertBefore(defs, svg.firstChild);\n      }\n\n      function drawEdge(a,b,w,directed){\n        // Draw a curved line slightly if nodes overlap or to make arrows clearer\n        let x1=a.x, y1=a.y, x2=b.x, y2=b.y;\n        let dx = x2-x1, dy = y2-y1, dist = Math.hypot(dx,dy);\n        if (dist < 1) return;\n        let normX = dx/dist, normY = dy/dist;\n        // offset ends to avoid overlapping the node circles\n        let r = 16;\n        let sx = x1 + normX * r;\n        let sy = y1 + normY * r;\n        let ex = x2 - normX * r;\n        let ey = y2 - normY * r;\n\n        // curve offset\n        let midx = (sx+ex)/2, midy = (sy+ey)/2;\n        // perpendicular\n        let px = -normY, py = normX;\n        // curvature amount based on distance\n        let curvature = Math.min(120, Math.max(8, dist*0.18));\n        // for undirected and i>j, we avoid drawing twice, but here we rely on caller\n        // create path\n        let path = document.createElementNS('http://www.w3.org/2000/svg','path');\n        // if nodes are almost aligned, draw straight\n        let useCurve = true;\n        if (Math.abs(dx) < 1 && Math.abs(dy) < 1) useCurve=false;\n        let qx = midx + px*curvature;\n        let qy = midy + py*curvature;\n        let d = `M ${sx} ${sy} Q ${qx} ${qy} ${ex} ${ey}`;\n        path.setAttribute('d', d);\n        path.setAttribute('class','edge-line');\n        path.setAttribute('stroke-width', Math.max(1, Math.min(3, Math.log(1+Math.abs(w))*1.6)));\n        path.setAttribute('fill','none');\n        if (directed) path.setAttribute('marker-end','url(#arrow)');\n        svg.appendChild(path);\n\n        // display weight label near midpoint\n        if (weightedChk.checked) {\n          let label = document.createElementNS('http://www.w3.org/2000/svg','text');\n          label.setAttribute('x', qx);\n          label.setAttribute('y', qy);\n          label.setAttribute('class','node-label');\n          label.setAttribute('font-size','11');\n          label.setAttribute('fill','#cfeff0');\n          label.textContent = w;\n          svg.appendChild(label);\n        }\n      }\n\n      // Interactions\n      function onNodeClick(evt) {\n        evt.stopPropagation();\n        let g = evt.currentTarget;\n        let idx = Number(g.getAttribute('data-idx'));\n        let mode = modeSelect.value;\n        if (mode === 'add') {\n          if (state.lastClickedNode === null) {\n            state.lastClickedNode = idx;\n            highlightNodeHeader(idx);\n          } else {\n            let i = state.lastClickedNode, j = idx;\n            // add edge i->j (or undirected)\n            toggleEdge(i,j);\n            state.lastClickedNode = null;\n            clearHeaderHighlight();\n          }\n        } else {\n          // remove mode: clicking two nodes will remove edge\n          if (state.lastClickedNode === null) {\n            state.lastClickedNode = idx;\n            highlightNodeHeader(idx);\n          } else {\n            let i = state.lastClickedNode, j = idx;\n            toggleEdge(i,j,false);\n            state.lastClickedNode = null;\n            clearHeaderHighlight();\n          }\n        }\n      }\n\n      function onNodeMouseDown(evt) {\n        evt.stopPropagation();\n        let g = evt.currentTarget;\n        let idx = Number(g.getAttribute('data-idx'));\n        state.dragging = idx;\n        // compute offset\n        let pt = getMousePos(evt);\n        state.dragOffset.x = nodes[idx].x - pt.x;\n        state.dragOffset.y = nodes[idx].y - pt.y;\n\n        window.addEventListener('mousemove', onWindowMouseMove);\n        window.addEventListener('mouseup', onWindowMouseUp);\n      }\n      function onNodeMouseUp(evt) {\n        // prevent click being fired twice\n      }\n      function onNodeMouseLeave(evt) {\n        // noop\n      }\n\n      function onWindowMouseMove(evt) {\n        if (state.dragging === null) return;\n        let idx = state.dragging;\n        let pt = getMousePos(evt);\n        nodes[idx].x = Math.max(20, Math.min(viewW-20, pt.x + state.dragOffset.x));\n        nodes[idx].y = Math.max(20, Math.min(viewH-20, pt.y + state.dragOffset.y));\n        refresh();\n      }\n      function onWindowMouseUp(evt) {\n        state.dragging = null;\n        window.removeEventListener('mousemove', onWindowMouseMove);\n        window.removeEventListener('mouseup', onWindowMouseUp);\n      }\n\n      function getMousePos(evt) {\n        // map client coordinates to SVG viewBox coords\n        let pt = svg.createSVGPoint();\n        pt.x = evt.clientX;\n        pt.y = evt.clientY;\n        let ctm = svg.getScreenCTM().inverse();\n        let svgP = pt.matrixTransform(ctm);\n        return { x: svgP.x, y: svgP.y };\n      }\n\n      // Matrix rendering\n      function renderMatrix() {\n        matrixWrap.innerHTML = '';\n        let n = nodes.length;\n        if (n === 0) {\n          matrixWrap.innerHTML = '<div class=\"small\" style=\"color:var(--muted)\">No nodes yet â€” add nodes to build a graph.</div>';\n          return;\n        }\n        let table = document.createElement('table');\n        table.className = 'matrix';\n        // header row\n        let thead = document.createElement('thead');\n        let htr = document.createElement('tr'); htr.className='header';\n        let corner = document.createElement('th'); corner.textContent = ''; htr.appendChild(corner);\n        for (let j=0;j<n;j++){\n          let th = document.createElement('th');\n          th.textContent = nodes[j].label;\n          th.dataset.col = j;\n          th.addEventListener('mouseenter', ()=>{ highlightColumn(j); });\n          th.addEventListener('mouseleave', ()=>{ clearHeaderHighlight(); });\n          th.addEventListener('click', ()=>{ selectColumn(j); });\n          htr.appendChild(th);\n        }\n        thead.appendChild(htr);\n        table.appendChild(thead);\n\n        let tbody = document.createElement('tbody');\n        for (let i=0;i<n;i++){\n          let tr = document.createElement('tr');\n          // row header\n          let rh = document.createElement('th');\n          rh.textContent = nodes[i].label;\n          rh.dataset.row = i;\n          rh.addEventListener('mouseenter', ()=>{ highlightRow(i); });\n          rh.addEventListener('mouseleave', ()=>{ clearHeaderHighlight(); });\n          rh.addEventListener('click', ()=>{ selectRow(i); });\n          tr.appendChild(rh);\n          for (let j=0;j<n;j++){\n            let td = document.createElement('td');\n            td.className = 'matrix-cell';\n            td.dataset.i = i; td.dataset.j = j;\n            td.textContent = matrix[i][j] ? matrix[i][j] : 0;\n            td.addEventListener('click', onMatrixCellClick);\n            td.addEventListener('dblclick', onMatrixCellDoubleClick);\n            td.addEventListener('mouseenter', ()=>{ td.classList.add('cell-hover'); highlightSVGCell(i,j); });\n            td.addEventListener('mouseleave', ()=>{ td.classList.remove('cell-hover'); clearSVGHighlight(); });\n            tr.appendChild(td);\n          }\n          tbody.appendChild(tr);\n        }\n        table.appendChild(tbody);\n        matrixWrap.appendChild(table);\n      }\n\n      function onMatrixCellClick(evt){\n        evt.stopPropagation();\n        let td = evt.currentTarget;\n        let i = Number(td.dataset.i), j = Number(td.dataset.j);\n        if (weightedChk.checked) {\n          // open small prompt to set value\n          let cur = matrix[i][j] || 0;\n          let val = prompt('Enter weight (0 to remove edge):', String(cur));\n          if (val === null) return;\n          let num = Number(val);\n          if (isNaN(num)) { alert('Invalid number'); return; }\n          matrix[i][j] = num;\n          if (!directedChk.checked) matrix[j][i] = num;\n        } else {\n          // toggle\n          matrix[i][j] = matrix[i][j] ? 0 : 1;\n          if (!directedChk.checked) matrix[j][i] = matrix[i][j];\n        }\n        refresh();\n      }\n\n      function onMatrixCellDoubleClick(evt){\n        // same as click for now\n      }\n\n      // Highlight helpers\n      function highlightRow(i) {\n        let table = matrixWrap.querySelector('table');\n        if (!table) return;\n        table.querySelectorAll('tr').forEach((tr, idx)=>{\n          if (idx>0) {\n            let th = tr.querySelector('th');\n            if (Number(th.dataset.row) === i) th.classList.add('col-hover');\n          }\n        });\n        // highlight svg node\n        highlightSVGNode(i);\n      }\n      function highlightColumn(j) {\n        let table = matrixWrap.querySelector('table');\n        if (!table) return;\n        let ths = table.querySelectorAll('thead th');\n        ths.forEach((th, idx)=>{\n          if (idx-1 === j) th.classList.add('col-hover');\n        });\n        highlightSVGNode(j);\n      }\n      function highlightNodeHeader(idx) {\n        // visually mark that node is selected as first click\n        let table = matrixWrap.querySelector('table');\n        if (!table) return;\n        // add a faint highlight on header\n        let rowTh = table.querySelector('tbody tr:nth-child(' + (idx+1) + ') th');\n        if (rowTh) rowTh.style.background = 'rgba(79,209,197,0.12)';\n      }\n      function clearHeaderHighlight(){\n        let table = matrixWrap.querySelector('table');\n        if (!table) return;\n        table.querySelectorAll('th').forEach(th=> th.style.background = '');\n        clearSVGHighlight();\n      }\n      function selectRow(i) {\n        // select row as source for adding edges\n        state.lastClickedNode = i;\n        alert('Selected node ' + nodes[i].label + ' as source. Click another node to create/remove edge.');\n      }\n      function selectColumn(j) {\n        state.lastClickedNode = j;\n        alert('Selected node ' + nodes[j].label + ' as source. Click another node to create/remove edge.');\n      }\n\n      function highlightSVGNode(idx){\n        // Change node circle stroke or background\n        let gs = svg.querySelectorAll('g.node-g');\n        gs.forEach(g=>{\n          let id = Number(g.getAttribute('data-idx'));\n          let circ = g.querySelector('circle');\n          if (id === idx) {\n            circ.setAttribute('stroke','rgba(79,209,197,0.95)');\n            circ.setAttribute('stroke-width','2.6');\n          } else {\n            circ.setAttribute('stroke','rgba(255,255,255,0.06)');\n            circ.setAttribute('stroke-width','1.6');\n          }\n        });\n      }\n\n      function highlightSVGCell(i,j) {\n        // highlight nodes i and j\n        highlightSVGNode(i);\n        // maybe draw a temporary line\n      }\n\n      function clearSVGHighlight(){\n        let gs = svg.querySelectorAll('g.node-g');\n        gs.forEach(g=>{\n          let circ = g.querySelector('circle');\n          circ.setAttribute('stroke','rgba(255,255,255,0.06)');\n          circ.setAttribute('stroke-width','1.6');\n        });\n      }\n\n      // IO\n      function exportJSON() {\n        let data = { nodes: nodes.map(n=>({id:n.id,label:n.label,x:n.x,y:n.y})), matrix, directed: directedChk.checked, weighted: weightedChk.checked };\n        let str = JSON.stringify(data, null, 2);\n        ioArea.value = str;\n        alert('Graph exported to the text area below. You can copy it.');\n      }\n\n      function importJSON() {\n        try {\n          let text = ioArea.value.trim();\n          if (!text) { alert('Paste JSON into the textarea first.'); return; }\n          let data = JSON.parse(text);\n          if (!Array.isArray(data.nodes) || !Array.isArray(data.matrix)) { alert('Invalid format. Expecting {nodes: [...], matrix: [...]}'); return; }\n          nodes = data.nodes.map(n=>({ id: n.id || uid(), label: n.label || 'v', x: (n.x||100), y:(n.y||100) }));\n          matrix = data.matrix.map(row=>row.slice());\n          directedChk.checked = !!data.directed;\n          weightedChk.checked = !!data.weighted;\n          refresh();\n          alert('Imported graph with ' + nodes.length + ' nodes.');\n        } catch (e) {\n          alert('Error parsing JSON: ' + e.message);\n        }\n      }\n\n      // Transformations\n      function transposeMatrix() {\n        let n = nodes.length;\n        let m2 = Array(n).fill(0).map(()=>Array(n).fill(0));\n        for (let i=0;i<n;i++) for (let j=0;j<n;j++) m2[j][i] = matrix[i][j];\n        matrix = m2;\n        // swap directed? Keep directed flag same; transpose just flips directions.\n        refresh();\n      }\n      function complementMatrix() {\n        let n = nodes.length;\n        for (let i=0;i<n;i++){\n          for (let j=0;j<n;j++){\n            if (i===j) continue;\n            matrix[i][j] = matrix[i][j] ? 0 : (weightedChk.checked ? Number(weightInput.value || 1) : 1);\n          }\n        }\n        refresh();\n      }\n\n      // Event bindings\n      addNodeBtn.addEventListener('click', ()=>{ addNodeAt(); });\n      randomBtn.addEventListener('click', ()=>{ let n = parseInt(prompt('Number of nodes?', '6')||'6'); let p = parseFloat(prompt('Edge probability (0-1)', '0.25')||'0.25'); if (isNaN(n)||isNaN(p)) return; randomGraph(n,p); });\n      clearBtn.addEventListener('click', ()=>{ if (confirm('Clear the graph?')) removeAll(); });\n      exportBtn.addEventListener('click', exportJSON);\n      importBtn.addEventListener('click', importJSON);\n      transposeBtn.addEventListener('click', ()=>{ transposeMatrix(); });\n      complementBtn.addEventListener('click', ()=>{ if (confirm('Replace edges with their complements (i.e. non-edges become edges)?')) complementMatrix(); });\n\n      // Clicking empty canvas resets lastClickedNode\n      svg.addEventListener('click', function(evt){\n        state.lastClickedNode = null;\n        clearHeaderHighlight();\n      });\n\n      // Resize handling: keep viewBox fixed so coordinates consistent\n      svg.setAttribute('viewBox', `0 0 ${viewW} ${viewH}`);\n\n      // Seed with a sample graph\n      (function seed(){\n        addNodeAt(120,120,'A');\n        addNodeAt(340,100,'B');\n        addNodeAt(560,160,'C');\n        addNodeAt(200,360,'D');\n        addNodeAt(480,360,'E');\n        matrix = [\n          [0,1,0,0,1],\n          [0,0,1,0,0],\n          [0,0,0,1,0],\n          [0,0,0,0,1],\n          [0,0,0,0,0]\n        ];\n        refresh();\n      })();\n\n      // Allow dropping JSON file\n      window.addEventListener('dragover', e=>e.preventDefault());\n      window.addEventListener('drop', e=>{ e.preventDefault(); let f = e.dataTransfer.files && e.dataTransfer.files[0]; if (f) { let reader = new FileReader(); reader.onload = ()=>{ ioArea.value = reader.result; importJSON(); }; reader.readAsText(f); } });\n\n      // Keyboard shortcuts\n      window.addEventListener('keydown', (e)=>{\n        if (e.key === 'a' && e.ctrlKey) { e.preventDefault(); addNodeAt(); }\n        if (e.key === 'e' && e.ctrlKey) { e.preventDefault(); exportJSON(); }\n      });\n\n      // Initial render done in seed\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency Matrix"
    }
  ],
  "topic": "Adjacency Matrix",
  "hasFSM": false,
  "hasTest": true
}