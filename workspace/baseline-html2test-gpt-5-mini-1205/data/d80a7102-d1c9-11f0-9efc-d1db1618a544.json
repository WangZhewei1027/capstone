{
  "id": "d80a7102-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:05.464Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Union-Find (Disjoint Set)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<title>Union-Find (Disjoint Set) Interactive Demo</title>\n<style>\n  :root { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; color: #111; }\n  body { margin: 0; padding: 16px; background: #fafafa; }\n  h1 { margin: 0 0 8px 0; font-size: 20px; }\n  .container { display:flex; gap:16px; }\n  .left { width: 640px; }\n  .right { flex: 1; min-width: 280px; }\n  .card { background: white; border-radius: 8px; padding: 12px; box-shadow: 0 1px 4px rgba(0,0,0,0.08); margin-bottom: 12px; }\n  .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }\n  button { padding:6px 10px; border-radius:6px; border:1px solid #ddd; background:#fff; cursor:pointer; }\n  button.primary { background: linear-gradient(#0ea5a4, #038f8b); color:white; border:none; }\n  button.warn { background: linear-gradient(#f97316,#ef6b00); color:white; border:none; }\n  label { font-size:13px; display:flex; gap:6px; align-items:center; }\n  input[type=number] { width:72px; padding:6px; border-radius:6px; border:1px solid #ddd; }\n  small { color:#555; }\n  #svgCanvas { width:100%; height:420px; border-radius:6px; background: linear-gradient(180deg,#ffffff,#f7f9fb); display:block; }\n  .arrays { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }\n  table { border-collapse:collapse; width:100%; }\n  th, td { text-align:center; padding:6px 8px; border-bottom:1px solid #eee; font-size:13px; }\n  th { background:#fafafa; font-weight:600; }\n  .nodeBox { fill: #fff; stroke: #2b6cb0; stroke-width:2; rx:10; }\n  .nodeLabel { font-size:12px; pointer-events:none; }\n  .nodeSmall { font-size:11px; fill:#444; }\n  .arrow { stroke:#666; stroke-width:2; marker-end: url(#arrowhead); fill:none; }\n  .arrow.highlight { stroke:#f97316; stroke-width:3; }\n  .arrow.compressed { stroke:#059669; stroke-width:3; stroke-dasharray:4 3; }\n  .nodeSelected { stroke:#ff0066; stroke-width:3; }\n  .log { max-height:220px; overflow:auto; font-size:13px; background:#fbfbfb; padding:8px; border-radius:6px; border:1px solid #eee; }\n  .footer { font-size:13px; color:#444; }\n  .badge { display:inline-block; background:#eef2ff; color:#2b6cb0; padding:2px 8px; border-radius:999px; font-size:12px; margin-left:8px; }\n  .muted { color:#666; font-size:13px; }\n</style>\n</head>\n<body>\n  <h1>Union-Find (Disjoint Set) â€” Interactive Demo</h1>\n  <div class=\"muted\">Visualize sets, unions, finds, path compression and union by rank. Click nodes to select them for operations.</div>\n\n  <div class=\"container\" style=\"margin-top:12px;\">\n    <div class=\"left\">\n      <div class=\"card\">\n        <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n          <div><strong>Universe Visualization</strong> <span class=\"badge\" id=\"componentsCount\">0 components</span></div>\n          <div class=\"muted\">Click nodes to select one or two</div>\n        </div>\n        <svg id=\"svgCanvas\" viewBox=\"0 0 1200 600\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n      </div>\n\n      <div class=\"card\">\n        <div style=\"display:flex; gap:8px; align-items:center; margin-bottom:8px;\">\n          <div class=\"controls\">\n            <label>Size:\n              <input type=\"number\" id=\"initN\" min=\"1\" value=\"10\">\n            </label>\n            <button id=\"initBtn\" class=\"primary\">Initialize</button>\n            <button id=\"resetBtn\">Reset</button>\n            <button id=\"randomUnionBtn\">Random Unions</button>\n            <button id=\"autoUnionBtn\">Auto-connect to form k sets</button>\n          </div>\n        </div>\n\n        <div style=\"display:flex; gap:12px; align-items:center; margin-bottom:8px;\">\n          <label><input type=\"checkbox\" id=\"byRank\" checked> Union by rank</label>\n          <label><input type=\"checkbox\" id=\"pathCompress\" checked> Path compression on Find</label>\n          <label><input type=\"checkbox\" id=\"animate\" checked> Animate changes</label>\n          <label style=\"margin-left:8px;\">Step duration\n            <input type=\"number\" id=\"stepMs\" min=\"10\" value=\"600\" style=\"width:80px;\">\n            ms\n          </label>\n        </div>\n\n        <div style=\"display:flex; gap:8px; margin-bottom:6px; align-items:center;\">\n          <button id=\"unionBtn\">Union selected (2)</button>\n          <button id=\"findBtn\">Find selected (1)</button>\n          <button id=\"clearSelectionBtn\">Clear selection</button>\n          <button id=\"randomSelectBtn\">Select random</button>\n        </div>\n\n        <div style=\"display:flex; gap:12px; margin-top:8px;\">\n          <div style=\"flex:1;\">\n            <small>Parent array (parent[i] = parent's index)</small>\n            <div id=\"parentTable\" class=\"arrays\"></div>\n          </div>\n          <div style=\"width:140px;\">\n            <small>Rank array</small>\n            <div id=\"rankTable\" class=\"arrays\" style=\"margin-top:6px;\"></div>\n          </div>\n        </div>\n      </div>\n\n    </div>\n\n    <div class=\"right\">\n      <div class=\"card\">\n        <strong>Controls & Info</strong>\n        <div style=\"margin-top:8px; display:flex; gap:8px; align-items:center;\">\n          <label style=\"display:flex; gap:6px; align-items:center;\">Node A:\n            <input type=\"number\" id=\"nodeA\" min=\"0\" value=\"0\" style=\"width:70px;\">\n          </label>\n          <label style=\"display:flex; gap:6px; align-items:center;\">Node B:\n            <input type=\"number\" id=\"nodeB\" min=\"0\" value=\"1\" style=\"width:70px;\">\n          </label>\n          <button id=\"unionManual\">Union A,B</button>\n          <button id=\"findManual\">Find A</button>\n        </div>\n\n        <div style=\"margin-top:10px;\">\n          <small>Quick actions</small>\n          <div style=\"display:flex; gap:8px; margin-top:6px;\">\n            <button id=\"connectLine\">Connect in line</button>\n            <button id=\"connectPairs\">Connect pairs</button>\n            <button id=\"shuffleBtn\">Shuffle & Randomize</button>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"card\">\n        <strong>Log</strong>\n        <div id=\"log\" class=\"log\" aria-live=\"polite\"></div>\n      </div>\n\n      <div class=\"card\">\n        <strong>How to use</strong>\n        <ol style=\"padding-left:18px; margin:8px 0 0 0;\">\n          <li>Initialize a universe size (default 10).</li>\n          <li>Click nodes in visualization to select them (1 or 2). Use Union or Find.</li>\n          <li>Toggle \"Union by rank\" or \"Path compression\" to see different strategies.</li>\n          <li>Watch the arrays and arrows update. Path compression will rewire pointers to the root.</li>\n        </ol>\n      </div>\n    </div>\n  </div>\n\n<script>\n/* Union-Find interactive demo\n   - parent[]: parent pointers (root points to itself)\n   - rank[]: rank heuristic\n   - visual: nodes arranged horizontally; arrows point to parent\n   - supports find with animation and optional path compression\n   - supports union with optional union by rank\n*/\n\n(() => {\n  // DOM elements\n  const svg = document.getElementById('svgCanvas');\n  const initN = document.getElementById('initN');\n  const initBtn = document.getElementById('initBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const randomUnionBtn = document.getElementById('randomUnionBtn');\n  const autoUnionBtn = document.getElementById('autoUnionBtn');\n  const byRankBox = document.getElementById('byRank');\n  const pathCompressBox = document.getElementById('pathCompress');\n  const animateBox = document.getElementById('animate');\n  const stepMsBox = document.getElementById('stepMs');\n  const unionBtn = document.getElementById('unionBtn');\n  const findBtn = document.getElementById('findBtn');\n  const clearSelectionBtn = document.getElementById('clearSelectionBtn');\n  const randomSelectBtn = document.getElementById('randomSelectBtn');\n  const parentTable = document.getElementById('parentTable');\n  const rankTable = document.getElementById('rankTable');\n  const logBox = document.getElementById('log');\n  const componentsCount = document.getElementById('componentsCount');\n  const nodeAinput = document.getElementById('nodeA');\n  const nodeBinput = document.getElementById('nodeB');\n  const unionManual = document.getElementById('unionManual');\n  const findManual = document.getElementById('findManual');\n  const connectLine = document.getElementById('connectLine');\n  const connectPairs = document.getElementById('connectPairs');\n  const shuffleBtn = document.getElementById('shuffleBtn');\n  const randomSelect = document.getElementById('randomSelectBtn');\n\n  // state\n  let n = 10;\n  let parent = [];\n  let rankArr = [];\n  let nodes = []; // position info for each node\n  let selected = new Set();\n  let animating = false;\n\n  // SVG elements bookkeeping\n  let svgNodes = []; // group elements for nodes\n  let svgArrows = []; // line elements for arrows\n\n  // helper: append log\n  function log(msg) {\n    const time = new Date().toLocaleTimeString();\n    const li = document.createElement('div');\n    li.textContent = `[${time}] ${msg}`;\n    logBox.prepend(li);\n  }\n\n  // Initialize arrays\n  function init(size) {\n    n = Math.max(1, Math.floor(size) || 1);\n    parent = new Array(n);\n    rankArr = new Array(n);\n    for (let i = 0; i < n; i++) {\n      parent[i] = i;\n      rankArr[i] = 0;\n    }\n    selected.clear();\n    animating = false;\n    resizeSVG();\n    render();\n    log(`Initialized with ${n} elements.`);\n  }\n\n  function reset() {\n    init(n);\n    log('Reset to all separate sets.');\n  }\n\n  // Utility: count components\n  function countComponents() {\n    const roots = new Set();\n    for (let i = 0; i < n; i++) roots.add(findNoCompress(i));\n    return roots.size;\n  }\n\n  // Non-logging simple find used for counting/visualization\n  function findNoCompress(x) {\n    while (parent[x] !== x) x = parent[x];\n    return x;\n  }\n\n  // Find with optional path compression (non-animated variant)\n  function find(x, doCompress) {\n    if (doCompress) {\n      const root = findNoCompress(x);\n      // compress path\n      let cur = x;\n      while (parent[cur] !== root) {\n        const next = parent[cur];\n        parent[cur] = root;\n        cur = next;\n      }\n      return root;\n    } else {\n      return findNoCompress(x);\n    }\n  }\n\n  // Union operation\n  function union(x, y, options = { animate: true }) {\n    if (animating) return Promise.resolve();\n    const rootX = findNoCompress(x);\n    const rootY = findNoCompress(y);\n    if (rootX === rootY) {\n      log(`Union(${x}, ${y}): already in same set (root ${rootX}).`);\n      return Promise.resolve();\n    }\n    // Decide which root becomes parent\n    let attachAtoB = false;\n    if (byRankBox.checked) {\n      if (rankArr[rootX] > rankArr[rootY]) {\n        attachAtoB = false; // attach Y to X\n      } else if (rankArr[rootX] < rankArr[rootY]) {\n        attachAtoB = true; // attach X to Y\n      } else {\n        // equal ranks: attach Y to X and increase X rank\n        attachAtoB = false;\n      }\n    } else {\n      // simple: attach rootY to rootX\n      attachAtoB = false;\n    }\n\n    // Decide final action\n    let newParent, child;\n    if (attachAtoB) {\n      newParent = rootY; child = rootX;\n    } else {\n      newParent = rootX; child = rootY;\n    }\n\n    const doAnimate = animateBox.checked && options.animate;\n    if (!doAnimate) {\n      parent[child] = newParent;\n      if (byRankBox.checked && !attachAtoB && rankArr[rootX] === rankArr[rootY]) {\n        rankArr[newParent]++;\n      } else if (byRankBox.checked && attachAtoB && rankArr[rootX] === rankArr[rootY]) {\n        rankArr[newParent]++; // symmetrical case (rare because attachAtoB picks)\n      }\n      render();\n      log(`Union(${x}, ${y}): made ${newParent} the parent of ${child}.`);\n      return Promise.resolve();\n    } else {\n      // Animated: highlight roots, animate arrow update\n      animating = true;\n      const duration = Math.max(80, Number(stepMsBox.value) || 500);\n      return animateUnion(child, newParent, duration).then(() => {\n        // update arrays\n        parent[child] = newParent;\n        if (byRankBox.checked && rankArr[rootX] === rankArr[rootY]) {\n          // only increment the chosen newParent's rank when ranks equal and we attached one to another\n          rankArr[newParent]++;\n        }\n        animating = false;\n        render();\n        log(`Union(${x}, ${y}): attached ${child} -> ${newParent}${byRankBox.checked ? ' (union by rank applied)' : ''}.`);\n      });\n    }\n  }\n\n  // Animated pointer movement by temporarily drawing a highlighted arrow and then updating parent\n  function animateUnion(childIdx, parentIdx, ms) {\n    return new Promise(resolve => {\n      // flash the two nodes and arrow\n      highlightNode(childIdx, 'nodeSelected');\n      highlightNode(parentIdx, 'nodeSelected');\n      // draw a temporary highlighted arrow from child to new parent (over existing)\n      const from = nodes[childIdx];\n      const to = nodes[parentIdx];\n      const tmp = document.createElementNS('http://www.w3.org/2000/svg','path');\n      tmp.setAttribute('d', pointerPath(from.cx, from.cy, to.cx, to.cy));\n      tmp.setAttribute('class','arrow highlight');\n      tmp.setAttribute('stroke-linecap', 'round');\n      svg.appendChild(tmp);\n\n      // animate (simple fade)\n      tmp.style.opacity = 0;\n      tmp.getBoundingClientRect(); // force style\n      tmp.style.transition = `opacity ${ms/1000}s ease`;\n      tmp.style.opacity = 1;\n      setTimeout(() => {\n        tmp.style.opacity = 0.2;\n        setTimeout(() => {\n          tmp.remove();\n          unhighlightAll();\n          resolve();\n        }, Math.max(80, ms/4));\n      }, ms);\n    });\n  }\n\n  // Highlight helpers\n  function highlightNode(i, cls) {\n    const g = svgNodes[i];\n    if (!g) return;\n    const rect = g.querySelector('rect');\n    rect.classList.add(cls);\n  }\n  function unhighlightAll() {\n    svgNodes.forEach(g => {\n      if (!g) return;\n      const rect = g.querySelector('rect');\n      rect.classList.remove('nodeSelected');\n    });\n  }\n\n  // Find operation with optional animated path compression\n  function doFindQuery(x) {\n    if (animating) return Promise.resolve();\n    const doCompress = pathCompressBox.checked;\n    if (!animateBox.checked || !doCompress) {\n      const root = find(x, doCompress);\n      render();\n      log(`Find(${x}) -> root ${root}${doCompress ? ' (compressed)' : ''}.`);\n      return Promise.resolve(root);\n    } else {\n      // Animated find with path observation and compression\n      animating = true;\n      return animateFindCompress(x).then(root => {\n        animating = false;\n        render();\n        log(`Find(${x}) -> root ${root} (path compressed).`);\n        return root;\n      });\n    }\n  }\n\n  function animateFindCompress(x) {\n    return new Promise(async (resolve) => {\n      // gather path\n      const path = [];\n      let cur = x;\n      while (parent[cur] !== cur) {\n        path.push(cur);\n        cur = parent[cur];\n      }\n      path.push(cur); // include root\n      const root = cur;\n\n      // animate walking along path\n      const duration = Math.max(60, Number(stepMsBox.value) || 400);\n      for (let idx = 0; idx < path.length - 1; idx++) {\n        const u = path[idx];\n        const v = path[idx+1];\n        // animate a small pulse along arrow u->v\n        await animatePulseAlongEdge(u, v, duration);\n      }\n\n      // now compress: set parent of all path nodes to root (except root)\n      for (let i = 0; i < path.length - 1; i++) {\n        const node = path[i];\n        // temporary change arrow style to 'compressed' to show rewiring\n        const line = svgArrows[node];\n        if (line) line.classList.add('compressed');\n        // update data model\n        parent[node] = root;\n        // small pause for each pointer update\n        await new Promise(r => setTimeout(r, Math.max(30, duration/2)));\n        if (line) line.classList.remove('compressed');\n      }\n\n      resolve(root);\n    });\n  }\n\n  function animatePulseAlongEdge(u, v, ms) {\n    return new Promise(resolve => {\n      const from = nodes[u];\n      const to = nodes[v];\n      const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');\n      dot.setAttribute('r', 6);\n      dot.setAttribute('fill', '#f97316');\n      dot.setAttribute('opacity', 0.95);\n      svg.appendChild(dot);\n\n      const steps = 30;\n      let i = 0;\n      const id = setInterval(() => {\n        const t = i / steps;\n        const x = from.cx + (to.cx - from.cx) * t;\n        const y = from.cy + (to.cy - from.cy) * t;\n        dot.setAttribute('cx', x);\n        dot.setAttribute('cy', y);\n        i++;\n        if (i > steps) {\n          clearInterval(id);\n          dot.remove();\n          resolve();\n        }\n      }, Math.max(6, Math.floor(ms/steps)));\n    });\n  }\n\n  // Render the visualization\n  function render() {\n    // update components count\n    const compCnt = countComponents();\n    componentsCount.textContent = `${compCnt} component${compCnt !== 1 ? 's' : ''}`;\n\n    // compute node positions: simple horizontal distribution\n    computePositions();\n\n    // clear svg content, but keep marker definitions\n    while (svg.firstChild) svg.removeChild(svg.firstChild);\n    addDefinitions();\n\n    svgNodes = new Array(n);\n    svgArrows = new Array(n);\n\n    // draw arrows first so they are under nodes\n    for (let i = 0; i < n; i++) {\n      const from = nodes[i];\n      const to = nodes[parent[i]];\n      const pathEl = document.createElementNS('http://www.w3.org/2000/svg','path');\n      pathEl.setAttribute('d', pointerPath(from.cx, from.cy, to.cx, to.cy));\n      pathEl.setAttribute('class','arrow');\n      pathEl.setAttribute('data-from', i);\n      pathEl.setAttribute('data-to', parent[i]);\n      svg.appendChild(pathEl);\n      svgArrows[i] = pathEl;\n    }\n\n    // draw nodes on top\n    for (let i = 0; i < n; i++) {\n      const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      g.setAttribute('transform', `translate(${nodes[i].cx}, ${nodes[i].cy})`);\n      g.style.cursor = 'pointer';\n      g.dataset.index = i;\n\n      const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');\n      rect.setAttribute('x', -30);\n      rect.setAttribute('y', -18);\n      rect.setAttribute('width', 60);\n      rect.setAttribute('height', 36);\n      rect.setAttribute('class', 'nodeBox');\n      rect.setAttribute('rx','8');\n      g.appendChild(rect);\n\n      const idxText = document.createElementNS('http://www.w3.org/2000/svg','text');\n      idxText.setAttribute('y', -2);\n      idxText.setAttribute('class','nodeLabel');\n      idxText.setAttribute('text-anchor','middle');\n      idxText.textContent = i;\n      g.appendChild(idxText);\n\n      const subText = document.createElementNS('http://www.w3.org/2000/svg','text');\n      subText.setAttribute('y', 14);\n      subText.setAttribute('class','nodeSmall');\n      subText.setAttribute('text-anchor','middle');\n      subText.textContent = `p=${parent[i]} r=${rankArr[i]}`;\n      g.appendChild(subText);\n\n      // selection overlay\n      if (selected.has(i)) {\n        rect.classList.add('nodeSelected');\n      }\n\n      // click handler\n      g.addEventListener('click', (ev) => {\n        ev.stopPropagation();\n        onNodeClick(i);\n      });\n\n      svg.appendChild(g);\n      svgNodes[i] = g;\n    }\n\n    // update arrays display\n    renderArrays();\n  }\n\n  function addDefinitions() {\n    // arrowhead marker\n    const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');\n    const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');\n    marker.setAttribute('id','arrowhead');\n    marker.setAttribute('markerWidth','8');\n    marker.setAttribute('markerHeight','8');\n    marker.setAttribute('refX','6');\n    marker.setAttribute('refY','3');\n    marker.setAttribute('orient','auto');\n    const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n    path.setAttribute('d','M0,0 L6,3 L0,6 z');\n    path.setAttribute('fill','#666');\n    marker.appendChild(path);\n    defs.appendChild(marker);\n    svg.appendChild(defs);\n  }\n\n  // compute node positions grouped by root for nicer visuals\n  function computePositions() {\n    // cluster nodes by root\n    const groups = {};\n    for (let i = 0; i < n; i++) {\n      const r = findNoCompress(i);\n      if (!groups[r]) groups[r] = [];\n      groups[r].push(i);\n    }\n    const roots = Object.keys(groups).map(s => parseInt(s)).sort((a,b)=>a-b);\n\n    nodes = new Array(n);\n    const margin = 70;\n    const width = Math.max(800, (n*90));\n    const left = 40;\n    let curX = left;\n    // each group occupies a block\n    for (const r of roots) {\n      const members = groups[r];\n      const blockW = Math.max(120, members.length * 80);\n      // arrange members horizontally within block at two vertical levels to reduce overlap\n      const centerX = curX + blockW / 2;\n      const baseY = 100;\n      for (let i = 0; i < members.length; i++) {\n        const idx = members[i];\n        const x = curX + 40 + (i * ((blockW - 80) / Math.max(1, members.length - 1)));\n        const depth = getDepth(idx);\n        const y = baseY + depth * 60; // deeper nodes lower\n        nodes[idx] = { cx: x, cy: y };\n      }\n      curX += blockW + margin;\n    }\n\n    // fallback: ensure every node has position\n    for (let i = 0; i < n; i++) {\n      if (!nodes[i]) nodes[i] = { cx: 50 + i*60, cy: 120 };\n    }\n  }\n\n  function getDepth(i) {\n    let d = 0;\n    let cur = i;\n    while (parent[cur] !== cur) {\n      d++;\n      cur = parent[cur];\n      if (d > n) break;\n    }\n    return d;\n  }\n\n  // clickable node handling\n  function onNodeClick(i) {\n    // toggle selection (max 2 selections)\n    if (selected.has(i)) {\n      selected.delete(i);\n    } else {\n      if (selected.size >= 2) {\n        // remove oldest selection\n        const first = selected.values().next().value;\n        selected.delete(first);\n      }\n      selected.add(i);\n    }\n    // synchronize numeric inputs\n    const arr = Array.from(selected);\n    if (arr.length >= 1) nodeAinput.value = arr[0];\n    if (arr.length >= 2) nodeBinput.value = arr[1];\n    render();\n  }\n\n  // pointer path (curved) from (x1,y1) to (x2,y2)\n  function pointerPath(x1,y1,x2,y2) {\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const mx = x1 + dx * 0.5;\n    const my = y1 + dy * 0.5;\n    const curve = 20 + Math.min(80, Math.abs(dx)/3);\n    // create a slight arc; using quadratic curve\n    return `M ${x1} ${y1} Q ${mx} ${my - curve} ${x2} ${y2}`;\n  }\n\n  // Render the arrays (parent, rank)\n  function renderArrays() {\n    parentTable.innerHTML = '';\n    rankTable.innerHTML = '';\n    // parent indices header\n    const header = document.createElement('div');\n    header.style.display = 'flex';\n    header.style.gap = '6px';\n    header.style.flexWrap = 'wrap';\n    for (let i = 0; i < n; i++) {\n      const d = document.createElement('div');\n      d.style.minWidth = '36px';\n      d.style.padding = '6px';\n      d.style.border = '1px solid #eee';\n      d.style.borderRadius = '6px';\n      d.style.background = '#fff';\n      d.style.fontSize = '13px';\n      d.style.textAlign = 'center';\n      d.textContent = parent[i];\n      if (selected.has(i)) d.style.boxShadow = 'inset 0 0 0 2px rgba(255,0,102,0.08)';\n      header.appendChild(d);\n    }\n    parentTable.appendChild(header);\n\n    // ranks\n    const rankdiv = document.createElement('div');\n    rankdiv.style.display = 'flex';\n    rankdiv.style.gap = '6px';\n    rankdiv.style.flexWrap = 'wrap';\n    for (let i = 0; i < n; i++) {\n      const d = document.createElement('div');\n      d.style.minWidth = '36px';\n      d.style.padding = '6px';\n      d.style.border = '1px solid #eee';\n      d.style.borderRadius = '6px';\n      d.style.background = '#fff';\n      d.style.fontSize = '13px';\n      d.style.textAlign = 'center';\n      d.textContent = rankArr[i];\n      rankdiv.appendChild(d);\n    }\n    rankTable.appendChild(rankdiv);\n  }\n\n  // UI actions\n  initBtn.addEventListener('click', () => init(Number(initN.value) || 1));\n  resetBtn.addEventListener('click', reset);\n  randomUnionBtn.addEventListener('click', () => {\n    // perform random unions until ~sqrt(n) sets (random)\n    const target = Math.max(1, Math.floor(Math.sqrt(n)));\n    const doAnimate = animateBox.checked;\n    const promises = [];\n    while (countComponents() > target) {\n      const a = Math.floor(Math.random() * n);\n      const b = Math.floor(Math.random() * n);\n      if (findNoCompress(a) === findNoCompress(b)) continue;\n      promises.push(union(a,b,{animate: doAnimate}));\n    }\n    Promise.all(promises).then(() => render());\n  });\n\n  autoUnionBtn.addEventListener('click', () => {\n    // Ask user for k via prompt - but to keep single-file, a quick prompt:\n    const k = Math.max(1, Math.min(n, parseInt(prompt('Make how many components (k)?', '3')) || 3));\n    // Connect nodes into k components: split into k groups and union inside each group\n    const block = Math.ceil(n / k);\n    const ops = [];\n    for (let g = 0; g < k; g++) {\n      const start = g * block;\n      const end = Math.min(n, start + block);\n      for (let i = start; i + 1 < end; i++) {\n        ops.push([i, i+1]);\n      }\n    }\n    // execute sequentially with animation\n    (async () => {\n      for (const [a,b] of ops) {\n        await union(a,b,{animate: true});\n        await new Promise(r => setTimeout(r, 60));\n      }\n      render();\n    })();\n  });\n\n  unionBtn.addEventListener('click', () => {\n    const sel = Array.from(selected);\n    if (sel.length !== 2) { alert('Select exactly 2 nodes (click nodes) or use manual inputs.'); return; }\n    union(sel[0], sel[1]);\n  });\n\n  findBtn.addEventListener('click', () => {\n    const sel = Array.from(selected);\n    if (sel.length === 0) { alert('Select 1 node to find its root.'); return; }\n    doFindQuery(sel[0]);\n  });\n\n  clearSelectionBtn.addEventListener('click', () => { selected.clear(); render(); });\n  randomSelectBtn.addEventListener('click', () => {\n    selected.clear();\n    selected.add(Math.floor(Math.random()*n));\n    selected.add(Math.floor(Math.random()*n));\n    render();\n  });\n\n  // manual A,B buttons\n  unionManual.addEventListener('click', () => {\n    const a = clampNum(Number(nodeAinput.value), 0, n-1);\n    const b = clampNum(Number(nodeBinput.value), 0, n-1);\n    union(a,b);\n    selected.clear(); selected.add(a); selected.add(b); render();\n  });\n  findManual.addEventListener('click', () => {\n    const a = clampNum(Number(nodeAinput.value), 0, n-1);\n    doFindQuery(a);\n    selected.clear(); selected.add(a); render();\n  });\n\n  // quick actions\n  connectLine.addEventListener('click', async () => {\n    for (let i = 0; i+1 < n; i++) {\n      await union(i, i+1, {animate: true});\n    }\n    render();\n    log('Connected all nodes in a line.');\n  });\n\n  connectPairs.addEventListener('click', async () => {\n    for (let i = 0; i+1 < n; i += 2) {\n      await union(i, i+1, {animate: true});\n    }\n    render();\n    log('Connected nodes in pairs.');\n  });\n\n  shuffleBtn.addEventListener('click', () => {\n    // randomize parents and ranks then rerender\n    for (let i = 0; i < n; i++) {\n      parent[i] = i;\n      rankArr[i] = 0;\n    }\n    // perform a number of random unions\n    const times = Math.max(1, Math.floor(n * 0.6));\n    for (let t = 0; t < times; t++) {\n      const a = Math.floor(Math.random()*n);\n      const b = Math.floor(Math.random()*n);\n      if (findNoCompress(a) !== findNoCompress(b)) {\n        // attach b to a w/o animation\n        parent[findNoCompress(b)] = findNoCompress(a);\n      }\n    }\n    render();\n    log('Shuffled: random unions applied (no animation).');\n  });\n\n  // small helpers\n  function clampNum(v, lo, hi) {\n    if (isNaN(v)) return lo;\n    return Math.max(lo, Math.min(hi, Math.floor(v)));\n  }\n\n  // initial render\n  function resizeSVG() {\n    // adjust viewbox width based on n\n    const w = Math.max(900, n*90 + 200);\n    svg.setAttribute('viewBox', `0 0 ${w} 600`);\n  }\n\n  // set up click-away to clear selection\n  svg.addEventListener('click', () => { /* ignore */ });\n\n  // init default\n  init(Number(initN.value) || 10);\n\n  // Expose some functions for console (helpful)\n  window.uf = {\n    parent, rankArr, findNoCompress, find, union\n  };\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Union-Find (Disjoint Set)"
    }
  ],
  "topic": "Union-Find (Disjoint Set)",
  "hasFSM": false,
  "hasTest": true
}