{
  "id": "d80b5b61-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:05:02.824Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Bellman-Ford Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Bellman-Ford Algorithm Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    body { margin: 0; font-family: Arial, sans-serif; display: flex; height: 100vh; }\n    #left { flex: 1; background: #f7f9fc; display:flex; flex-direction:column; }\n    #canvasWrap { flex: 1; position: relative; }\n    canvas { width:100%; height:100%; background: linear-gradient(#fff,#eef); display:block; cursor: crosshair; }\n    #controls { width: 360px; background: #fff; border-left: 1px solid #ddd; padding: 12px; box-sizing: border-box; overflow:auto; }\n    h2 { margin:8px 0; font-size:16px; }\n    .btn { display:inline-block; margin:4px 4px 4px 0; padding:8px 10px; background:#007bff; color:#fff; border-radius:4px; cursor:pointer; user-select:none; }\n    .btn.secondary { background:#6c757d; }\n    .btn.warn { background:#dc3545; }\n    .btn.small { padding:6px 8px; font-size:13px; }\n    .info { margin:8px 0; padding:8px; background:#f1f7ff; border-radius:6px; font-size:13px; }\n    label { display:block; margin-top:8px; font-size:13px; }\n    input[type=number], select { width:100%; padding:6px; box-sizing:border-box; margin-top:6px; }\n    table { width:100%; border-collapse: collapse; margin-top:8px; font-size:13px; }\n    th, td { border:1px solid #ddd; padding:6px; text-align:center; }\n    .status { margin-top:8px; font-size:13px; }\n    .muted { color:#666; font-size:13px; }\n    .small-note { font-size:12px; color:#444; margin-top:6px; }\n    .edgeList { max-height:160px; overflow:auto; border:1px solid #eee; padding:6px; background:#fafafa; margin-top:8px; }\n    .edgeItem { padding:6px; border-bottom:1px dashed #eee; font-size:13px; }\n    .active-mode { background:#28a745 !important; }\n  </style>\n</head>\n<body>\n  <div id=\"left\">\n    <div id=\"canvasWrap\">\n      <canvas id=\"canvas\"></canvas>\n    </div>\n  </div>\n\n  <div id=\"controls\">\n    <h2>Bellman-Ford Algorithm Demo</h2>\n\n    <div class=\"info\">\n      Click on the canvas to add nodes. Use \"Add Edge\" then pick source and target to create directed edges with weights (negative allowed). Set a source node and run Bellman-Ford step-by-step or full-run. Negative cycles (reachable from source) will be detected.\n    </div>\n\n    <div style=\"margin-top:8px;\">\n      <span class=\"btn\" id=\"addNodeBtn\">Add Node</span>\n      <span class=\"btn secondary\" id=\"addEdgeBtn\">Add Edge</span>\n      <span class=\"btn secondary\" id=\"setSourceBtn\">Set Source</span>\n      <span class=\"btn small\" id=\"clearBtn\">Clear</span>\n      <span class=\"btn warn small\" id=\"resetAlgoBtn\">Reset Algo</span>\n    </div>\n\n    <label>Current Mode: <span id=\"modeLabel\" class=\"muted\">Add Node (click canvas)</span></label>\n\n    <label>Nodes / Edges</label>\n    <div class=\"small-note\">Click a node to drag it. While in Add Edge or Set Source mode, click nodes to pick them.</div>\n\n    <div style=\"display:flex; gap:8px; margin-top:8px;\">\n      <div style=\"flex:1\">\n        <label>Source node for algorithm</label>\n        <select id=\"sourceSelect\"><option value=\"\">(none)</option></select>\n      </div>\n      <div style=\"width:120px; display:flex; align-items:flex-end;\">\n        <button class=\"btn small\" id=\"applySourceBtn\">Apply</button>\n      </div>\n    </div>\n\n    <h3 style=\"margin-top:12px; font-size:14px;\">Algorithm Controls</h3>\n    <div style=\"display:flex; gap:8px; flex-wrap:wrap;\">\n      <span class=\"btn\" id=\"stepBtn\">Step</span>\n      <span class=\"btn\" id=\"runBtn\">Run Full</span>\n      <span class=\"btn secondary\" id=\"pauseBtn\">Pause</span>\n    </div>\n\n    <div class=\"status\" id=\"algoStatus\">Iteration: 0, Edge: 0 / 0</div>\n\n    <div style=\"margin-top:8px;\">\n      <label>Animation Speed (ms per relaxation)</label>\n      <input id=\"speedInput\" type=\"number\" value=\"400\" min=\"0\" />\n    </div>\n\n    <h3 style=\"margin-top:12px; font-size:14px;\">Nodes / Distances</h3>\n    <div id=\"tableWrap\"></div>\n\n    <h3 style=\"margin-top:12px; font-size:14px;\">Edges</h3>\n    <div class=\"edgeList\" id=\"edgeList\"></div>\n\n    <div style=\"margin-top:12px;\">\n      <label>Result / Messages</label>\n      <div id=\"message\" class=\"info\">Ready.</div>\n    </div>\n\n    <div style=\"margin-top:12px; font-size:12px; color:#666;\">\n      Tip: Create a negative cycle by adding edges that reduce distance (e.g., a cycle with total weight &lt; 0). Bellman-Ford detects if reachable from the chosen source.\n    </div>\n  </div>\n\n<script>\n(() => {\n  // Canvas and UI setup\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  function resize() {\n    canvas.width = canvas.clientWidth * devicePixelRatio;\n    canvas.height = canvas.clientHeight * devicePixelRatio;\n    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);\n    draw();\n  }\n  window.addEventListener('resize', resize);\n  resize();\n\n  // Graph data structures\n  let nodes = []; // {id, x, y}\n  let edges = []; // {id, u: nodeId, v: nodeId, w}\n  let nodeIdCounter = 0;\n  let edgeIdCounter = 0;\n\n  // Interaction state\n  let mode = 'addNode'; // addNode, addEdge, setSource, none/drag\n  const modeLabel = document.getElementById('modeLabel');\n  const addNodeBtn = document.getElementById('addNodeBtn');\n  const addEdgeBtn = document.getElementById('addEdgeBtn');\n  const setSourceBtn = document.getElementById('setSourceBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const resetAlgoBtn = document.getElementById('resetAlgoBtn');\n  const sourceSelect = document.getElementById('sourceSelect');\n  const applySourceBtn = document.getElementById('applySourceBtn');\n  const edgeListDiv = document.getElementById('edgeList');\n  const tableWrap = document.getElementById('tableWrap');\n  const messageDiv = document.getElementById('message');\n  const stepBtn = document.getElementById('stepBtn');\n  const runBtn = document.getElementById('runBtn');\n  const pauseBtn = document.getElementById('pauseBtn');\n  const speedInput = document.getElementById('speedInput');\n\n  function setMode(m) {\n    mode = m;\n    modeLabel.textContent = {\n      addNode: 'Add Node (click canvas)',\n      addEdge: 'Add Edge (pick source then target)',\n      setSource: 'Set Source (click a node)',\n      none: 'Normal (drag nodes)'\n    }[m] || '';\n    // button highlighting\n    addNodeBtn.classList.toggle('active-mode', m === 'addNode');\n    addEdgeBtn.classList.toggle('active-mode', m === 'addEdge');\n    setSourceBtn.classList.toggle('active-mode', m === 'setSource');\n  }\n  setMode('addNode');\n\n  addNodeBtn.addEventListener('click', () => setMode('addNode'));\n  addEdgeBtn.addEventListener('click', () => setMode('addEdge'));\n  setSourceBtn.addEventListener('click', () => setMode('setSource'));\n  clearBtn.addEventListener('click', () => {\n    if (!confirm('Clear all nodes and edges?')) return;\n    nodes = []; edges = []; nodeIdCounter = 0; edgeIdCounter = 0;\n    bfReset();\n    rebuildSourceSelect();\n    draw();\n    message('Cleared graph.');\n  });\n\n  resetAlgoBtn.addEventListener('click', () => {\n    bfReset();\n    draw();\n    message('Algorithm reset.');\n  });\n\n  // Canvas interactions: add node, select node for edges, drag nodes\n  let draggingNode = null;\n  let dragOffset = {x:0,y:0};\n  let edgeFirstNode = null; // for addEdge\n  canvas.addEventListener('pointerdown', (ev) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = (ev.clientX - rect.left);\n    const y = (ev.clientY - rect.top);\n    const clicked = findNodeAt(x, y);\n\n    if (mode === 'addNode') {\n      addNode(x, y);\n      draw();\n      return;\n    } else if (mode === 'addEdge') {\n      if (!clicked) {\n        message('Click on a node to choose source/target for the edge.');\n        return;\n      }\n      if (!edgeFirstNode) {\n        edgeFirstNode = clicked;\n        message('Picked source node ' + clicked.id + '. Now click target node.');\n      } else {\n        if (clicked.id === edgeFirstNode.id) {\n          message('Self-edge allowed. Creating self-loop.');\n        }\n        const wStr = prompt('Enter weight for edge ' + edgeFirstNode.id + ' → ' + clicked.id + ' (number):', '0');\n        if (wStr === null) { edgeFirstNode = null; message('Edge creation cancelled.'); return; }\n        const w = Number(wStr);\n        if (isNaN(w)) { message('Invalid weight. Edge cancelled.'); edgeFirstNode = null; return; }\n        addEdge(edgeFirstNode.id, clicked.id, w);\n        message('Edge added: ' + edgeFirstNode.id + ' → ' + clicked.id + ' (w=' + w + ')');\n        edgeFirstNode = null;\n        draw();\n      }\n      return;\n    } else if (mode === 'setSource') {\n      if (!clicked) { message('Click on a node to set source.'); return; }\n      setAlgorithmSource(clicked.id);\n      setMode('none');\n      return;\n    } else {\n      // drag mode: if clicked a node, start dragging\n      if (clicked) {\n        draggingNode = clicked;\n        dragOffset.x = x - clicked.x;\n        dragOffset.y = y - clicked.y;\n      } else {\n        draggingNode = null;\n      }\n    }\n  });\n\n  canvas.addEventListener('pointermove', (ev) => {\n    if (!draggingNode) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = (ev.clientX - rect.left);\n    const y = (ev.clientY - rect.top);\n    draggingNode.x = x - dragOffset.x;\n    draggingNode.y = y - dragOffset.y;\n    draw();\n  });\n\n  canvas.addEventListener('pointerup', () => draggingNode = null);\n  canvas.addEventListener('pointerleave', () => draggingNode = null);\n\n  function addNode(x,y) {\n    const id = 'N' + (++nodeIdCounter);\n    nodes.push({id, x, y});\n    rebuildSourceSelect();\n  }\n  function addEdge(u,v,w) {\n    edges.push({id: 'E' + (++edgeIdCounter), u, v, w});\n    rebuildEdgeList();\n    bfReset();\n  }\n  function findNodeAt(x,y) {\n    for (let i = nodes.length-1; i >= 0; i--) {\n      const n = nodes[i];\n      const dx = x - n.x, dy = y - n.y;\n      if (dx*dx + dy*dy <= 20*20) return n;\n    }\n    return null;\n  }\n  function rebuildSourceSelect() {\n    const cur = sourceSelect.value;\n    sourceSelect.innerHTML = '<option value=\"\">(none)</option>';\n    nodes.forEach(n => {\n      const opt = document.createElement('option');\n      opt.value = n.id; opt.textContent = n.id;\n      sourceSelect.appendChild(opt);\n    });\n    if (cur) sourceSelect.value = cur;\n  }\n  function rebuildEdgeList() {\n    edgeListDiv.innerHTML = '';\n    edges.forEach(e => {\n      const div = document.createElement('div');\n      div.className = 'edgeItem';\n      div.textContent = e.id + ': ' + e.u + ' → ' + e.v + '  (w=' + e.w + ')';\n      div.addEventListener('click', () => {\n        if (!confirm('Delete ' + e.id + '?')) return;\n        edges = edges.filter(x => x.id !== e.id);\n        rebuildEdgeList();\n        bfReset();\n        draw();\n      });\n      edgeListDiv.appendChild(div);\n    });\n  }\n\n  // Drawing functions\n  function draw(highlight = {}) {\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    // draw edges\n    edges.forEach(e => {\n      const u = nodes.find(n => n.id === e.u);\n      const v = nodes.find(n => n.id === e.v);\n      if (!u || !v) return;\n      drawArrow(u.x, u.y, v.x, v.y, e, highlight.edge === e.id ? highlight.color : '#333');\n    });\n    // draw nodes\n    nodes.forEach(n => {\n      drawNode(n);\n    });\n\n    // draw selection for edge creation\n    if (edgeFirstNode) {\n      ctx.beginPath();\n      ctx.strokeStyle = '#28a745';\n      ctx.lineWidth = 2;\n      ctx.arc(edgeFirstNode.x, edgeFirstNode.y, 24, 0, Math.PI*2);\n      ctx.stroke();\n    }\n    // draw source marker\n    if (algorithmState.source) {\n      const s = nodes.find(x => x.id === algorithmState.source);\n      if (s) {\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(255,255,0,0.25)';\n        ctx.arc(s.x, s.y, 26, 0, Math.PI*2);\n        ctx.fill();\n      }\n    }\n  }\n\n  function drawNode(n) {\n    ctx.beginPath();\n    ctx.fillStyle = '#007bff';\n    ctx.strokeStyle = '#003f88';\n    ctx.lineWidth = 2;\n    ctx.arc(n.x, n.y, 20, 0, Math.PI*2);\n    ctx.fill();\n    ctx.stroke();\n\n    // label\n    ctx.fillStyle = '#fff';\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(n.id, n.x, n.y - 2);\n\n    // distance shown below\n    if (algorithmState.distances && algorithmState.distances[n.id] !== undefined) {\n      const d = algorithmState.distances[n.id];\n      const txt = (d === Infinity) ? '∞' : d.toFixed(2).replace(/\\.00$/,'');\n      ctx.fillStyle = '#000';\n      ctx.font = '12px sans-serif';\n      ctx.fillText(txt, n.x, n.y + 16);\n    }\n  }\n\n  function drawArrow(x1,y1,x2,y2, edge, color='#333') {\n    const ang = Math.atan2(y2-y1, x2-x1);\n    const startOffset = 22;\n    const endOffset = 26;\n    const sx = x1 + Math.cos(ang) * startOffset;\n    const sy = y1 + Math.sin(ang) * startOffset;\n    const ex = x2 - Math.cos(ang) * endOffset;\n    const ey = y2 - Math.sin(ang) * endOffset;\n\n    ctx.beginPath();\n    ctx.strokeStyle = color || '#333';\n    ctx.lineWidth = 3;\n    ctx.moveTo(sx, sy);\n    ctx.lineTo(ex, ey);\n    ctx.stroke();\n\n    // arrowhead\n    ctx.beginPath();\n    ctx.fillStyle = color || '#333';\n    ctx.moveTo(ex, ey);\n    const ah1 = ex - 8 * Math.cos(ang - Math.PI/6);\n    const ah1y = ey - 8 * Math.sin(ang - Math.PI/6);\n    const ah2 = ex - 8 * Math.cos(ang + Math.PI/6);\n    const ah2y = ey - 8 * Math.sin(ang + Math.PI/6);\n    ctx.lineTo(ah1, ah1y);\n    ctx.lineTo(ah2, ah2y);\n    ctx.closePath();\n    ctx.fill();\n\n    // weight label at midpoint\n    const mx = (sx + ex) / 2;\n    const my = (sy + ey) / 2;\n    ctx.fillStyle = '#000';\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(edge.w, mx, my - 10);\n  }\n\n  // Bellman-Ford algorithm state and logic\n  const algorithmState = {\n    source: null,\n    distances: null,\n    pred: null,\n    iter: 0,\n    edgeIndex: 0,\n    running: false,\n    mode: 'stopped', // stopped, stepping, running, paused, finished\n    highlight: null // {edge: id, color}\n  };\n\n  function setAlgorithmSource(id) {\n    if (!nodes.find(n => n.id === id)) return message('Invalid source.');\n    algorithmState.source = id;\n    sourceSelect.value = id;\n    message('Source set to ' + id);\n    bfReset();\n    draw();\n  }\n  applySourceBtn.addEventListener('click', () => {\n    const v = sourceSelect.value;\n    if (!v) { message('No source selected.'); return; }\n    setAlgorithmSource(v);\n  });\n\n  function bfReset() {\n    algorithmState.distances = {};\n    algorithmState.pred = {};\n    nodes.forEach(n => {\n      algorithmState.distances[n.id] = Infinity;\n      algorithmState.pred[n.id] = null;\n    });\n    algorithmState.iter = 0;\n    algorithmState.edgeIndex = 0;\n    algorithmState.running = false;\n    algorithmState.mode = 'stopped';\n    algorithmState.highlight = null;\n    if (algorithmState.source) algorithmState.distances[algorithmState.source] = 0;\n    updateTable();\n    updateAlgoStatus();\n  }\n\n  // initialize\n  bfReset();\n\n  function message(txt, type='info') {\n    messageDiv.textContent = txt;\n    if (type === 'error') messageDiv.style.background = '#ffe8e8';\n    else messageDiv.style.background = '#f1f7ff';\n  }\n\n  function updateEdgeCountInfo() {\n    rebuildEdgeList(); // keep in sync\n  }\n\n  function updateAlgoStatus() {\n    const E = edges.length, V = nodes.length;\n    document.getElementById('algoStatus').textContent = 'Iteration: ' + algorithmState.iter + ' / ' + Math.max(0, V-1) + ', Edge: ' + algorithmState.edgeIndex + ' / ' + E;\n  }\n\n  function updateTable() {\n    let html = '<table><tr><th>Node</th><th>Distance</th><th>Predecessor</th></tr>';\n    nodes.forEach(n => {\n      const d = algorithmState.distances[n.id];\n      const pd = algorithmState.pred[n.id];\n      html += '<tr><td>' + n.id + '</td><td>' + ((d === Infinity) ? '∞' : d) + '</td><td>' + (pd || '-') + '</td></tr>';\n    });\n    html += '</table>';\n    tableWrap.innerHTML = html;\n    updateEdgeCountInfo();\n  }\n\n  // Stepwise relaxation logic\n  function stepOnce() {\n    if (!algorithmState.source) { message('Set a source node first.'); return; }\n    const V = nodes.length;\n    const E = edges.length;\n    if (V === 0) return;\n\n    // If finished, final negative cycle check\n    if (algorithmState.iter >= Math.max(0, V-1)) {\n      // perform extra pass to detect negative cycle\n      algorithmState.highlight = null;\n      draw();\n      const neg = detectNegativeCycle();\n      if (neg) {\n        message('Negative cycle detected reachable from source: ' + neg.join(' → '));\n        algorithmState.mode = 'finished';\n      } else {\n        message('No negative cycles detected. Algorithm finished.');\n        algorithmState.mode = 'finished';\n      }\n      updateTable();\n      updateAlgoStatus();\n      return;\n    }\n\n    if (E === 0) {\n      algorithmState.iter = Math.max(0, V-1);\n      updateAlgoStatus();\n      updateTable();\n      draw();\n      message('No edges to relax.');\n      return;\n    }\n\n    // If we've completed the edge loop for current iter, advance iter\n    if (algorithmState.edgeIndex >= E) {\n      algorithmState.iter++;\n      algorithmState.edgeIndex = 0;\n      updateAlgoStatus();\n      // if reached V-1 iterations, continue to detection on next step\n      if (algorithmState.iter >= Math.max(0, V-1)) {\n        message('Done iterations. Next step will check for negative cycles.');\n        updateTable();\n        draw();\n        return;\n      }\n    }\n\n    // Relax edge at current index\n    const e = edges[algorithmState.edgeIndex];\n    algorithmState.highlight = {edge: e.id, color: '#17a2b8'};\n    draw(algorithmState.highlight);\n    const u = e.u, v = e.v, w = e.w;\n    const du = algorithmState.distances[u];\n    const dv = algorithmState.distances[v];\n    let relaxed = false;\n    if (du !== Infinity && du + w < dv) {\n      algorithmState.distances[v] = du + w;\n      algorithmState.pred[v] = u;\n      relaxed = true;\n      algorithmState.highlight.color = '#28a745';\n      message('Relaxed edge ' + e.id + ': improved ' + v + ' to ' + algorithmState.distances[v]);\n    } else {\n      algorithmState.highlight.color = '#e0a800';\n      message('Tried edge ' + e.id + ': no improvement.');\n    }\n\n    algorithmState.edgeIndex++;\n    updateTable();\n    updateAlgoStatus();\n  }\n\n  // Run full with animation or instant\n  let runTimer = null;\n  runBtn.addEventListener('click', () => {\n    if (!algorithmState.source) { message('Set a source node first.'); return; }\n    if (algorithmState.mode === 'running') return;\n    algorithmState.mode = 'running';\n    algorithmState.running = true;\n    message('Running algorithm...');\n    const speed = Math.max(0, Number(speedInput.value) || 0);\n    if (speed === 0) {\n      // compute instantly, not animate\n      runInstantly();\n      return;\n    }\n    runTimer = setInterval(() => {\n      stepOnce();\n      draw(algorithmState.highlight);\n      if (algorithmState.mode === 'finished') {\n        clearInterval(runTimer);\n        algorithmState.running = false;\n        runTimer = null;\n      }\n    }, speed);\n  });\n  pauseBtn.addEventListener('click', () => {\n    if (runTimer) { clearInterval(runTimer); runTimer = null; algorithmState.running = false; algorithmState.mode = 'paused'; message('Paused.'); }\n  });\n\n  function runInstantly() {\n    // run algorithm without animation, but still update state\n    const V = nodes.length;\n    const E = edges.length;\n    if (V === 0) return;\n    for (let i = algorithmState.iter; i < Math.max(0, V-1); i++) {\n      for (let j = 0; j < E; j++) {\n        const e = edges[j];\n        const u = e.u, v = e.v, w = e.w;\n        const du = algorithmState.distances[u];\n        if (du !== Infinity && du + w < algorithmState.distances[v]) {\n          algorithmState.distances[v] = du + w;\n          algorithmState.pred[v] = u;\n        }\n      }\n    }\n    algorithmState.iter = Math.max(0, V-1);\n    // detect negative cycle\n    const neg = detectNegativeCycle();\n    if (neg) {\n      message('Negative cycle detected reachable from source: ' + neg.join(' → '));\n    } else {\n      message('Completed: no negative cycle detected.');\n    }\n    algorithmState.mode = 'finished';\n    updateTable();\n    draw();\n  }\n\n  stepBtn.addEventListener('click', () => {\n    if (!algorithmState.source) { message('Set a source node first.'); return; }\n    algorithmState.mode = 'stepping';\n    stepOnce();\n    draw(algorithmState.highlight);\n  });\n\n  // Negative cycle detection: after V-1 iterations, check if any edge can be relaxed. If so, find a cycle.\n  function detectNegativeCycle() {\n    // find an edge (u,v) such that dist[u] + w < dist[v]\n    for (const e of edges) {\n      const u = e.u, v = e.v, w = e.w;\n      if (algorithmState.distances[u] !== Infinity && algorithmState.distances[u] + w < algorithmState.distances[v]) {\n        // there is a negative cycle reachable; recover cycle by following predecessors\n        // start from v and go back up to V steps to ensure inside cycle\n        let x = v;\n        for (let i = 0; i < nodes.length; i++) {\n          if (algorithmState.pred[x]) x = algorithmState.pred[x]; else break;\n        }\n        // now collect cycle\n        const cycle = [];\n        const start = x;\n        do {\n          cycle.push(x);\n          x = algorithmState.pred[x];\n        } while (x && x !== start && cycle.length < nodes.length + 5);\n        cycle.reverse();\n        return cycle;\n      }\n    }\n    return null;\n  }\n\n  // Utility: find node by id\n  function findNodeById(id) { return nodes.find(n => n.id === id); }\n\n  // Initial sample graph to illustrate\n  function createSample() {\n    nodes = [];\n    edges = [];\n    nodeIdCounter = 0; edgeIdCounter = 0;\n    addNode(120, 120); // N1\n    addNode(320, 100); // N2\n    addNode(520, 160); // N3\n    addNode(220, 300); // N4\n    addNode(420, 300); // N5\n    // edges\n    addEdge('N1','N2', 6);\n    addEdge('N1','N4', 7);\n    addEdge('N2','N3', 5);\n    addEdge('N2','N5', -4);\n    addEdge('N2','N4', 8);\n    addEdge('N3','N2', -2);\n    addEdge('N4','N3', -3);\n    addEdge('N4','N5', 9);\n    addEdge('N5','N1', 2);\n    rebuildSourceSelect();\n    bfReset();\n    draw();\n    message('Sample graph created. Set source and run algorithm.');\n  }\n\n  // add sample button via double-click on blank left area (not UI) or just create sample on load\n  createSample();\n\n  // Start with some helpful keyboard shortcuts\n  window.addEventListener('keydown', (e) => {\n    if (e.key === 'n') setMode('addNode');\n    if (e.key === 'e') setMode('addEdge');\n    if (e.key === 's') setMode('setSource');\n    if (e.key === ' ') { e.preventDefault(); stepBtn.click(); }\n  });\n\n  // On load draw\n  draw();\n\n  // Expose for debug\n  window.__demo = { nodes, edges, addNode, addEdge };\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Bellman-Ford Algorithm"
    }
  ],
  "topic": "Bellman-Ford Algorithm",
  "hasFSM": false,
  "hasTest": true
}