{
  "id": "d80a49f1-d1c9-11f0-9efc-d1db1618a544",
  "timestamp": "2025-12-05T11:06:26.724Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<title>Weighted Graph Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<style>\n  :root { --bg:#f6f8fa; --panel:#fff; --accent:#0b69ff; --accent-2:#ff6b6b; --muted:#6b7280; }\n  html,body { height:100%; margin:0; font-family:Inter, \"Segoe UI\", Roboto, Arial; background:var(--bg); color:#111827; }\n  .container { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; }\n  .left { width:320px; background:var(--panel); border-radius:10px; box-shadow:0 6px 18px rgba(12,20,40,0.08); padding:14px; box-sizing:border-box; overflow:auto; }\n  .canvas-wrap { flex:1; background:linear-gradient(180deg,#ffffff, #f8fbff); border-radius:10px; box-shadow:0 6px 18px rgba(12,20,40,0.06); position:relative; overflow:hidden; }\n  h2 { margin:6px 0 10px 0; font-size:16px; }\n  .toolbar { display:flex; flex-wrap:wrap; gap:6px; margin-bottom:10px; }\n  .btn { padding:8px 10px; border-radius:8px; background:#f3f4f6; border:1px solid #e6e7eb; cursor:pointer; font-size:13px; }\n  .btn.active { background:var(--accent); color:white; border-color:transparent; }\n  .btn.warn { background:var(--accent-2); color:white; border-color:transparent; }\n  .info { font-size:13px; color:var(--muted); margin-top:8px; line-height:1.5; }\n  label.small { font-size:12px; color:var(--muted); display:block; margin-top:8px; }\n  input[type=number], input[type=range] { width:100%; margin-top:6px; box-sizing:border-box; padding:6px; border-radius:6px; border:1px solid #e6e7eb; }\n  .svg-canvas { width:100%; height:100%; display:block; }\n  .status { position:absolute; left:12px; bottom:12px; background:rgba(255,255,255,0.9); padding:8px 10px; border-radius:8px; box-shadow:0 6px 18px rgba(12,20,40,0.06); font-size:13px; }\n  .legend { display:flex; gap:8px; align-items:center; margin-top:8px; font-size:13px; }\n  .swatch { width:18px; height:10px; border-radius:3px; display:inline-block; }\n  footer { font-size:12px; color:var(--muted); margin-top:12px; }\n  .small-muted { font-size:12px; color:var(--muted); }\n  .controls-row { display:flex; gap:6px; margin-top:8px; }\n  .input-inline { display:flex; gap:6px; align-items:center; }\n  .node-count { font-weight:600; color:#111827; }\n  /* Tooltip like label for weights */\n  .weight-label { font-family:monospace; font-size:12px; user-select:none; pointer-events:none; }\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <div class=\"left\">\n    <h2>Weighted Graph — Interactive Demo</h2>\n    <div class=\"toolbar\" id=\"toolbar\">\n      <button class=\"btn active\" id=\"mode-move\">Move</button>\n      <button class=\"btn\" id=\"mode-add\">Add Node</button>\n      <button class=\"btn\" id=\"mode-connect\">Connect</button>\n      <button class=\"btn\" id=\"mode-delete\">Delete</button>\n      <button class=\"btn\" id=\"mode-select\">Select S/T</button>\n    </div>\n\n    <div class=\"controls-row\">\n      <button class=\"btn\" id=\"btn-dijkstra\">Dijkstra (shortest)</button>\n      <button class=\"btn\" id=\"btn-mst\">MST (Kruskal)</button>\n      <button class=\"btn\" id=\"btn-clear\">Clear</button>\n    </div>\n\n    <label class=\"small\">Random graph</label>\n    <div class=\"controls-row\">\n      <input type=\"number\" id=\"rand-n\" value=\"8\" min=\"2\" style=\"width:70px\"/>\n      <input type=\"number\" id=\"rand-p\" value=\"30\" min=\"0\" max=\"100\" style=\"width:70px\"/>\n      <button class=\"btn\" id=\"btn-random\">Generate</button>\n    </div>\n\n    <div style=\"margin-top:10px;\">\n      <label class=\"small\">Edge weight on connect</label>\n      <input type=\"range\" id=\"weight-range\" min=\"1\" max=\"20\" value=\"6\"/>\n      <div class=\"input-inline\"><span class=\"small-muted\">Default: </span><div style=\"width:8px\"></div><strong id=\"default-weight\">6</strong></div>\n    </div>\n\n    <div class=\"info\">\n      Controls:\n      <ul>\n        <li>Move: drag nodes.</li>\n        <li>Add Node: click canvas to add node.</li>\n        <li>Connect: click two nodes to create weighted edge (range default used; or double-click weight to edit).</li>\n        <li>Select S/T: click two nodes to set source & target for Dijkstra.</li>\n        <li>Delete: click node or edge.</li>\n      </ul>\n      Edge double-click: edit weight. Edge click while Delete: remove.\n    </div>\n\n    <div class=\"legend\" style=\"margin-top:8px;\">\n      <div><span class=\"swatch\" style=\"background:#111827\"></span> edge</div>\n      <div><span class=\"swatch\" style=\"background:#10b981\"></span> shortest</div>\n      <div><span class=\"swatch\" style=\"background:#ffb020\"></span> MST</div>\n      <div style=\"margin-left:8px;\"><span class=\"node-count\" id=\"node-count\">0</span> nodes</div>\n    </div>\n\n    <footer>\n      Click an edge weight to edit. Shortest path and MST highlight edges; selecting new mode clears selection highlights.\n    </footer>\n  </div>\n\n  <div class=\"canvas-wrap\" id=\"canvasWrap\">\n    <svg id=\"svg\" class=\"svg-canvas\" xmlns=\"http://www.w3.org/2000/svg\">\n      <defs>\n        <filter id=\"shadow\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\n          <feDropShadow dx=\"0\" dy=\"3\" stdDeviation=\"6\" flood-color=\"#000\" flood-opacity=\"0.08\"/>\n        </filter>\n      </defs>\n    </svg>\n\n    <div class=\"status\" id=\"status\">Mode: Move</div>\n  </div>\n</div>\n\n<script>\n/*\n  Weighted Graph Interactive Demo\n  - Undirected weighted graph\n  - Modes: move, add, connect, delete, select (for S/T)\n  - Features: Dijkstra shortest path, Kruskal MST, random graph generator, edit weights\n*/\n\nconst svg = document.getElementById('svg');\nconst status = document.getElementById('status');\nconst nodeCountLabel = document.getElementById('node-count');\nconst defaultWeightEl = document.getElementById('default-weight');\nlet width = svg.clientWidth, height = svg.clientHeight;\n\nwindow.addEventListener('resize', ()=> { width = svg.clientWidth; height = svg.clientHeight; });\n\n// Graph data\nlet nodes = []; // {id, x, y}\nlet edges = []; // {id, u, v, w}\nlet nextNodeId = 1, nextEdgeId = 1;\n\n// UI state\nlet mode = 'move'; // move, add, connect, delete, select\nlet dragging = null;\nlet connectFirst = null;\nlet selectST = []; // [sNodeId, tNodeId]\nlet highlightedEdges = new Set();\nlet highlightedNodes = new Set();\nlet highlightedType = null; // 'shortest' or 'mst'\n\n// default connect weight\nlet defaultWeight = Number(document.getElementById('weight-range').value);\ndefaultWeightEl.textContent = defaultWeight;\n\n// SVG groups for ordering\nconst edgesGroup = document.createElementNS('http://www.w3.org/2000/svg','g');\nconst weightsGroup = document.createElementNS('http://www.w3.org/2000/svg','g');\nconst nodesGroup = document.createElementNS('http://www.w3.org/2000/svg','g');\nsvg.appendChild(edgesGroup);\nsvg.appendChild(weightsGroup);\nsvg.appendChild(nodesGroup);\n\n// element maps\nconst nodeElems = new Map(); // id -> {g, circle, label}\nconst edgeElems = new Map(); // id -> {line, weightText}\n\n// Utilities\nfunction setMode(newMode){\n  mode = newMode;\n  document.querySelectorAll('.btn').forEach(b=>b.classList.remove('active'));\n  if(newMode === 'move') document.getElementById('mode-move').classList.add('active');\n  if(newMode === 'add') document.getElementById('mode-add').classList.add('active');\n  if(newMode === 'connect') document.getElementById('mode-connect').classList.add('active');\n  if(newMode === 'delete') document.getElementById('mode-delete').classList.add('active');\n  if(newMode === 'select') document.getElementById('mode-select').classList.add('active');\n  status.textContent = 'Mode: ' + capitalize(newMode);\n  if(newMode !== 'select'){ clearSelectionST(); }\n  if(newMode !== 'connect'){ connectFirst = null; }\n  if(newMode !== 'move'){ /* nothing */ }\n  clearHighlights();\n}\nfunction capitalize(s){ return s.charAt(0).toUpperCase()+s.slice(1); }\n\n// Drawing\nfunction render(){\n  // clear groups\n  // We'll update existing elements or create new ones to preserve event handlers\n  // Edges\n  edges.forEach(e=>{\n    let u = nodes.find(n=>n.id===e.u);\n    let v = nodes.find(n=>n.id===e.v);\n    if(!u || !v) return;\n    let obj = edgeElems.get(e.id);\n    if(!obj){\n      let line = document.createElementNS('http://www.w3.org/2000/svg','line');\n      line.setAttribute('stroke','#111827');\n      line.setAttribute('stroke-width',2.2);\n      line.setAttribute('stroke-linecap','round');\n      line.style.cursor = 'pointer';\n      line.addEventListener('click', ev => { ev.stopPropagation(); onEdgeClick(e.id); });\n      line.addEventListener('dblclick', ev => { ev.stopPropagation(); editEdgeWeightPrompt(e.id); });\n      edgesGroup.appendChild(line);\n\n      let weightText = document.createElementNS('http://www.w3.org/2000/svg','text');\n      weightText.setAttribute('text-anchor','middle');\n      weightText.setAttribute('alignment-baseline','middle');\n      weightText.setAttribute('class','weight-label');\n      weightText.setAttribute('fill','#111827');\n      weightText.style.cursor = 'pointer';\n      weightText.addEventListener('click', ev=>{ ev.stopPropagation(); editEdgeWeightPrompt(e.id); });\n      weightsGroup.appendChild(weightText);\n\n      obj = { line, weightText };\n      edgeElems.set(e.id, obj);\n    }\n    const {line, weightText} = obj;\n    line.setAttribute('x1', u.x); line.setAttribute('y1', u.y);\n    line.setAttribute('x2', v.x); line.setAttribute('y2', v.y);\n    // weight label midpoint with slight offset perpendicular to edge for clarity\n    const mx = (u.x+v.x)/2, my = (u.y+v.y)/2;\n    const dx = v.x-u.x, dy = v.y-u.y;\n    const len = Math.hypot(dx,dy) || 1;\n    const off = 12;\n    const nx = -dy/len * off;\n    const ny = dx/len * off;\n    weightText.setAttribute('x', mx + nx);\n    weightText.setAttribute('y', my + ny);\n    weightText.textContent = String(e.w);\n    // Styling based on highlight sets\n    if(highlightedEdges.has(e.id)){\n      if(highlightedType === 'shortest'){\n        line.setAttribute('stroke','#10b981'); line.setAttribute('stroke-width',4);\n        weightText.setAttribute('fill','#065f46');\n      } else if(highlightedType === 'mst'){\n        line.setAttribute('stroke','#ffb020'); line.setAttribute('stroke-width',4);\n        weightText.setAttribute('fill','#7a3e00');\n      }\n    } else {\n      line.setAttribute('stroke','#111827'); line.setAttribute('stroke-width',2.2);\n      weightText.setAttribute('fill','#111827');\n    }\n  });\n\n  // Nodes\n  nodes.forEach(n=>{\n    let el = nodeElems.get(n.id);\n    if(!el){\n      let g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      let circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n      circle.setAttribute('r',14);\n      circle.setAttribute('fill','#fff');\n      circle.setAttribute('stroke','#111827');\n      circle.setAttribute('stroke-width',1.6);\n      circle.style.cursor = 'grab';\n      circle.addEventListener('mousedown', ev => { ev.stopPropagation(); onNodeMouseDown(ev, n.id); });\n      circle.addEventListener('dblclick', ev => { ev.stopPropagation(); /* could edit label */ });\n\n      let text = document.createElementNS('http://www.w3.org/2000/svg','text');\n      text.setAttribute('text-anchor','middle');\n      text.setAttribute('alignment-baseline','middle');\n      text.setAttribute('font-size','12');\n      text.setAttribute('fill','#111827');\n      text.style.pointerEvents = 'none';\n\n      g.appendChild(circle);\n      g.appendChild(text);\n      nodesGroup.appendChild(g);\n      el = {g, circle, text};\n      nodeElems.set(n.id, el);\n    }\n    el.g.setAttribute('transform', `translate(${n.x},${n.y})`);\n    el.text.textContent = String(n.id);\n    // highlight style\n    if(highlightedNodes.has(n.id)){\n      el.circle.setAttribute('fill','#10b981');\n      el.text.setAttribute('fill','#fff');\n    } else {\n      el.circle.setAttribute('fill','#fff');\n      el.text.setAttribute('fill','#111827');\n    }\n  });\n\n  nodeCountLabel.textContent = nodes.length;\n}\n\n// Node interactions\nfunction onNodeMouseDown(ev, nodeId){\n  if(mode === 'delete'){\n    removeNode(nodeId);\n    render(); return;\n  }\n  if(mode === 'connect'){\n    if(connectFirst == null){\n      connectFirst = nodeId;\n      status.textContent = 'Connect: selected node '+connectFirst+' (click second)';\n    } else if(connectFirst === nodeId){\n      // clicked same -> cancel\n      connectFirst = null;\n      status.textContent = 'Mode: Connect';\n    } else {\n      // create edge\n      const w = defaultWeight;\n      addEdge(connectFirst, nodeId, w);\n      connectFirst = null;\n      status.textContent = 'Mode: Connect';\n      render();\n    }\n    return;\n  }\n  if(mode === 'select'){\n    if(selectST.length === 0){\n      selectST.push(nodeId);\n      status.textContent = 'Select: Source set to '+nodeId;\n    } else if(selectST.length === 1){\n      if(nodeId === selectST[0]){\n        status.textContent = 'Select: Source unchanged (clicked same)';\n      } else {\n        selectST.push(nodeId);\n        status.textContent = 'Select: Target set to '+nodeId;\n      }\n    } else {\n      selectST = [nodeId];\n      status.textContent = 'Select: Source set to '+nodeId;\n    }\n    updateSelectionVisuals();\n    return;\n  }\n  // default: move mode - start dragging\n  if(mode === 'move'){\n    dragging = { id: nodeId, ox: ev.clientX, oy: ev.clientY };\n    document.addEventListener('mousemove', onDocMouseMove);\n    document.addEventListener('mouseup', onDocMouseUp);\n    // make cursor grabbing\n    const el = nodeElems.get(nodeId);\n    if(el) el.circle.style.cursor = 'grabbing';\n  }\n}\n\n// Dragging handlers\nfunction onDocMouseMove(ev){\n  if(!dragging) return;\n  const node = nodes.find(n=>n.id===dragging.id);\n  if(!node) return;\n  // calculate svg coords (svg is responsive so use getBoundingClientRect)\n  const rect = svg.getBoundingClientRect();\n  let x = ev.clientX - rect.left;\n  let y = ev.clientY - rect.top;\n  // clamp\n  x = Math.max(20, Math.min(rect.width-20, x));\n  y = Math.max(20, Math.min(rect.height-20, y));\n  node.x = x; node.y = y;\n  render();\n}\n\nfunction onDocMouseUp(ev){\n  if(dragging){\n    const el = nodeElems.get(dragging.id);\n    if(el) el.circle.style.cursor = 'grab';\n  }\n  dragging = null;\n  document.removeEventListener('mousemove', onDocMouseMove);\n  document.removeEventListener('mouseup', onDocMouseUp);\n}\n\n// Canvas click for adding nodes or clearing selections\nsvg.addEventListener('click', (ev)=>{\n  const rect = svg.getBoundingClientRect();\n  const x = ev.clientX - rect.left;\n  const y = ev.clientY - rect.top;\n  if(mode === 'add'){\n    addNode(x,y); render(); return;\n  }\n  // if clicked empty space while in select mode reset selection\n  if(mode === 'select'){\n    if(selectST.length>0){\n      clearSelectionST();\n      updateSelectionVisuals();\n    }\n  }\n});\n\n// Graph operations\nfunction addNode(x,y){\n  nodes.push({ id: nextNodeId++, x, y });\n  render();\n}\nfunction addEdge(u,v,w){\n  // avoid duplicate (undirected): check if an edge connecting same nodes exists\n  const exists = edges.find(e => (e.u===u && e.v===v) || (e.u===v && e.v===u));\n  if(exists){ alert('Edge already exists between these nodes'); return; }\n  edges.push({ id: nextEdgeId++, u, v, w: Number(w) });\n}\nfunction removeNode(id){\n  nodes = nodes.filter(n=>n.id!==id);\n  // remove edges connected\n  edges = edges.filter(e => e.u !== id && e.v !== id);\n  // remove elements map entries\n  nodeElems.delete(id);\n  // also delete any edge SVG elements removed\n  // cleanup edgeElems for missing edges\n  Array.from(edgeElems.keys()).forEach(k => {\n    if(!edges.find(e=>e.id===k)){\n      const obj = edgeElems.get(k);\n      if(obj){\n        obj.line.remove(); obj.weightText.remove();\n      }\n      edgeElems.delete(k);\n    }\n  });\n  clearHighlights();\n}\nfunction removeEdge(edgeId){\n  edges = edges.filter(e=>e.id!==edgeId);\n  const obj = edgeElems.get(edgeId);\n  if(obj){ obj.line.remove(); obj.weightText.remove(); }\n  edgeElems.delete(edgeId);\n  clearHighlights();\n}\nfunction editEdgeWeightPrompt(edgeId){\n  const e = edges.find(x=>x.id===edgeId);\n  if(!e) return;\n  const val = prompt('Enter new weight (positive number):', String(e.w));\n  if(val === null) return;\n  const num = Number(val);\n  if(Number.isFinite(num) && num > 0){\n    e.w = num;\n    render();\n  } else {\n    alert('Invalid weight');\n  }\n}\n\nfunction onEdgeClick(edgeId){\n  if(mode === 'delete'){ removeEdge(edgeId); render(); return; }\n  // otherwise toggle highlight (for debug) - but we generally use Dijkstra/MST to highlight\n  // For convenience, show info\n  const e = edges.find(x=>x.id===edgeId);\n  if(e) status.textContent = `Edge ${edgeId}: ${e.u} —(${e.w})— ${e.v}`;\n}\n\n// Selection visuals (S/T)\nfunction updateSelectionVisuals(){\n  clearHighlights();\n  highlightedNodes.clear();\n  if(selectST.length>0) highlightedNodes.add(selectST[0]);\n  if(selectST.length>1) highlightedNodes.add(selectST[1]);\n  // style nodes directly via render\n  render();\n}\nfunction clearSelectionST(){ selectST = []; highlightedNodes.clear(); render(); }\n\n// Highlights\nfunction clearHighlights(){\n  highlightedEdges.clear();\n  highlightedNodes.clear();\n  highlightedType = null;\n  render();\n}\n\n// Algorithms\nfunction dijkstra(sourceId, targetId){\n  // build adjacency list\n  const adj = new Map();\n  nodes.forEach(n => adj.set(n.id, []));\n  edges.forEach(e => {\n    adj.get(e.u).push({to:e.v, w:e.w, id:e.id});\n    adj.get(e.v).push({to:e.u, w:e.w, id:e.id});\n  });\n  const dist = new Map();\n  const prev = new Map();\n  const prevEdge = new Map();\n  nodes.forEach(n => { dist.set(n.id, Infinity); prev.set(n.id, null); prevEdge.set(n.id, null); });\n  dist.set(sourceId, 0);\n  // simple priority queue via array (ok for small graphs)\n  const visited = new Set();\n  while(true){\n    let u = null;\n    let best = Infinity;\n    for(const [id,d] of dist){\n      if(!visited.has(id) && d < best){ best = d; u = id; }\n    }\n    if(u === null) break;\n    visited.add(u);\n    if(u === targetId) break;\n    for(const nei of adj.get(u)){\n      if(visited.has(nei.to)) continue;\n      const alt = dist.get(u) + nei.w;\n      if(alt < dist.get(nei.to)){\n        dist.set(nei.to, alt);\n        prev.set(nei.to, u);\n        prevEdge.set(nei.to, nei.id);\n      }\n    }\n  }\n  const path = [];\n  const pathEdges = [];\n  if(dist.get(targetId) === Infinity) return {dist:Infinity, path:[], pathEdges:[]};\n  let cur = targetId;\n  while(cur !== null && cur !== undefined){\n    path.unshift(cur);\n    const pe = prevEdge.get(cur);\n    if(pe) pathEdges.unshift(pe);\n    cur = prev.get(cur);\n  }\n  return { dist: dist.get(targetId), path, pathEdges };\n}\n\nfunction kruskalMST(){\n  // sort edges by weight\n  const sorted = [...edges].sort((a,b)=>a.w - b.w);\n  // union-find\n  const parent = {};\n  function find(x){ if(parent[x] == null) parent[x] = x; return parent[x] === x ? x : (parent[x] = find(parent[x])); }\n  function union(a,b){ const ra = find(a), rb = find(b); if(ra===rb) return false; parent[ra]=rb; return true; }\n  const chosen = [];\n  let total = 0;\n  for(const e of sorted){\n    if(union(e.u, e.v)){\n      chosen.push(e.id);\n      total += e.w;\n    }\n  }\n  return { chosen, total };\n}\n\n// UI bindings\ndocument.getElementById('mode-move').addEventListener('click', ()=>setMode('move'));\ndocument.getElementById('mode-add').addEventListener('click', ()=>setMode('add'));\ndocument.getElementById('mode-connect').addEventListener('click', ()=>setMode('connect'));\ndocument.getElementById('mode-delete').addEventListener('click', ()=>setMode('delete'));\ndocument.getElementById('mode-select').addEventListener('click', ()=>setMode('select'));\n\ndocument.getElementById('weight-range').addEventListener('input', (e)=>{\n  defaultWeight = Number(e.target.value);\n  defaultWeightEl.textContent = defaultWeight;\n});\n\ndocument.getElementById('btn-clear').addEventListener('click', ()=>{\n  if(!confirm('Clear graph?')) return;\n  // cleanup svg elements\n  nodes.forEach(n => {\n    const el = nodeElems.get(n.id);\n    if(el) el.g.remove();\n  });\n  edges.forEach(e => {\n    const obj = edgeElems.get(e.id);\n    if(obj){ obj.line.remove(); obj.weightText.remove(); }\n  });\n  nodes = []; edges = []; nodeElems.clear(); edgeElems.clear();\n  nextNodeId = 1; nextEdgeId = 1;\n  clearHighlights();\n  render();\n});\n\ndocument.getElementById('btn-random').addEventListener('click', ()=>{\n  const n = Math.max(2, Math.min(40, Number(document.getElementById('rand-n').value) || 8));\n  const p = Math.max(0, Math.min(100, Number(document.getElementById('rand-p').value) || 30));\n  generateRandomGraph(n, p/100);\n});\n\ndocument.getElementById('btn-dijkstra').addEventListener('click', ()=>{\n  if(selectST.length < 2){ alert('Select source and target nodes first (use Select S/T mode)'); return; }\n  const s = selectST[0], t = selectST[1];\n  const res = dijkstra(s,t);\n  if(res.dist === Infinity){ alert('No path exists between selected nodes'); return; }\n  highlightedEdges = new Set(res.pathEdges);\n  highlightedNodes = new Set(res.path);\n  highlightedType = 'shortest';\n  status.textContent = `Shortest path ${s} → ${t}: length ${res.dist}`;\n  render();\n});\n\ndocument.getElementById('btn-mst').addEventListener('click', ()=>{\n  const res = kruskalMST();\n  highlightedEdges = new Set(res.chosen);\n  highlightedNodes = new Set();\n  highlightedType = 'mst';\n  status.textContent = `MST total weight: ${res.total}`;\n  render();\n});\n\n// Random generator\nfunction generateRandomGraph(n, p){\n  // clear first\n  nodes.forEach(nnode => {\n    const el = nodeElems.get(nnode.id);\n    if(el) el.g.remove();\n  });\n  edges.forEach(e => {\n    const obj = edgeElems.get(e.id);\n    if(obj){ obj.line.remove(); obj.weightText.remove(); }\n  });\n  nodes = []; edges = []; nodeElems.clear(); edgeElems.clear();\n  nextNodeId = 1; nextEdgeId = 1;\n\n  // place nodes on circle\n  const rect = svg.getBoundingClientRect();\n  const cx = rect.width/2, cy = rect.height/2;\n  const R = Math.min(rect.width, rect.height)/2 - 60;\n  for(let i=0;i<n;i++){\n    const theta = (i/n) * Math.PI * 2;\n    const x = cx + R * Math.cos(theta);\n    const y = cy + R * Math.sin(theta);\n    addNode(x,y);\n  }\n  // random edges\n  for(let i=0;i<n;i++){\n    for(let j=i+1;j<n;j++){\n      if(Math.random() < p){\n        const w = Math.floor(Math.random()*15) + 1;\n        addEdge(nodes[i].id, nodes[j].id, w);\n      }\n    }\n  }\n  render();\n}\n\n// Helpers for initial demo\nfunction seedDemo(){\n  // small example\n  addNode(120,120); addNode(260,90); addNode(380,160); addNode(220,240); addNode(440,260);\n  addNode(100,260);\n  addEdge(1,2,4); addEdge(2,3,2); addEdge(1,4,7); addEdge(4,3,1); addEdge(2,4,3);\n  addEdge(3,5,5); addEdge(4,6,6); addEdge(1,6,10);\n  render();\n  status.textContent = 'Mode: Move (demo graph loaded)';\n}\nseedDemo();\n\n// initial text selection prevention\nsvg.addEventListener('mousedown', e=>e.preventDefault());\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": false,
  "hasTest": true
}