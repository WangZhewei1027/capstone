{
  "id": "cc1d8640-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:29.143Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency Matrix",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>Adjacency Matrix Explorer</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<style>\n  :root{\n    --bg:#f6f8fa; --panel:#ffffff; --muted:#666; --accent:#0b78d1; --accent-2:#0b9bd1;\n    --ok:#198754; --danger:#d9534f;\n  }\n  html,body{height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:#111}\n  header{padding:14px 18px; display:flex; gap:12px; align-items:center; background:linear-gradient(90deg,#fff,#f7fbff); box-shadow:0 1px 0 rgba(0,0,0,0.05)}\n  header h1{font-size:18px;margin:0}\n  main{display:grid; grid-template-columns:420px 1fr 360px; gap:14px; padding:16px; align-items:start}\n  .panel{background:var(--panel); border-radius:10px; padding:12px; box-shadow:0 6px 18px rgba(20,30,50,0.06)}\n  .controls{display:flex; flex-direction:column; gap:10px}\n  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}\n  label{font-size:13px; color:var(--muted)}\n  input[type=number], select, button, input[type=range]{font-size:13px; padding:6px 8px; border-radius:6px; border:1px solid #ddd; background:white}\n  button{cursor:pointer; border:none; background:var(--accent); color:white; padding:8px 10px}\n  button.ghost{background:transparent; color:var(--accent); border:1px solid #e1efff}\n  button.warn{background:var(--danger)}\n  .small{font-size:12px; padding:6px 8px}\n  .matrixWrap{overflow:auto; max-height:360px; border:1px dashed #eee; padding:8px; border-radius:8px}\n  table.matrix{border-collapse:collapse; font-family:monospace; font-size:13px}\n  table.matrix th, table.matrix td{border:1px solid #eee; padding:6px 8px; min-width:34px; text-align:center}\n  table.matrix th{background:#fbfdff; font-weight:600}\n  td.clickable{cursor:pointer}\n  td.loopCell{background:#fff7e6}\n  .vizWrap{display:flex; flex-direction:column; gap:8px}\n  svg{width:100%; height:520px; background:linear-gradient(180deg,#fbfdff,#ffffff)}\n  .rightPanel{display:flex; flex-direction:column; gap:10px}\n  pre{background:#0b1720; color:#bcd; padding:8px; border-radius:6px; margin:0; overflow:auto}\n  .muted{color:var(--muted); font-size:13px}\n  .stats{display:flex; gap:10px; flex-wrap:wrap}\n  .stat{background:#f7fbff; padding:8px 10px; border-radius:8px; font-size:13px}\n  .footer{padding:10px 16px; font-size:13px; color:var(--muted)}\n  a.link{color:var(--accent)}\n  .adjList{font-family:system-ui; font-size:13px}\n  .controls small{color:var(--muted)}\n  .help{font-size:13px; color:var(--muted); margin-top:6px}\n</style>\n</head>\n<body>\n<header>\n  <h1>Adjacency Matrix Explorer</h1>\n  <div class=\"muted\">Interactive visualizer: create matrices, toggle edges, see graph & adjacency list.</div>\n</header>\n\n<main>\n  <!-- Left: controls & matrix -->\n  <section class=\"panel\">\n    <div class=\"controls\">\n      <div class=\"row\">\n        <label>Nodes:</label>\n        <input id=\"nodeCount\" type=\"number\" min=\"1\" max=\"50\" value=\"6\" style=\"width:72px\" />\n        <button id=\"addNode\" class=\"small\">Add</button>\n        <button id=\"removeNode\" class=\"small ghost\">Remove</button>\n        <label style=\"margin-left:8px\"><input id=\"directed\" type=\"checkbox\" /> Directed</label>\n        <label><input id=\"weighted\" type=\"checkbox\" /> Weighted</label>\n      </div>\n\n      <div class=\"row\">\n        <label>Randomize:</label>\n        <input id=\"prob\" type=\"range\" min=\"0\" max=\"100\" value=\"30\" style=\"width:160px\" />\n        <span id=\"probLabel\" class=\"muted\">30%</span>\n        <button id=\"randBtn\" class=\"small ghost\">Generate</button>\n        <button id=\"clearBtn\" class=\"small warn\">Clear</button>\n      </div>\n\n      <div class=\"row\">\n        <button id=\"exportBtn\" class=\"small\">Export JSON</button>\n        <button id=\"importBtn\" class=\"small ghost\">Import JSON</button>\n        <button id=\"sampleBtn\" class=\"small\">Load Example</button>\n      </div>\n\n      <div class=\"help\">Click cells in the matrix to toggle edges. If \"Weighted\" is on, clicking a cell will prompt for a numeric weight. In undirected mode the matrix is kept symmetric.</div>\n    </div>\n\n    <hr style=\"border:none;border-top:1px solid #eef;margin:10px 0\" />\n\n    <div class=\"matrixWrap panel\" style=\"padding:8px;\">\n      <div style=\"display:flex; justify-content:space-between; align-items:center; margin-bottom:6px\">\n        <strong>Adjacency Matrix</strong>\n        <div class=\"muted\">Rows = from, Cols = to</div>\n      </div>\n      <div id=\"matrixContainer\"></div>\n    </div>\n\n  </section>\n\n  <!-- Middle: visualization -->\n  <section class=\"panel vizWrap\">\n    <div style=\"display:flex; justify-content:space-between; align-items:center\">\n      <div><strong>Graph Visualization</strong><div class=\"muted\" style=\"font-size:13px\">Click edges on the SVG to toggle (or click matrix cells)</div></div>\n      <div class=\"stats\">\n        <div class=\"stat\">Nodes: <span id=\"statNodes\">0</span></div>\n        <div class=\"stat\">Edges: <span id=\"statEdges\">0</span></div>\n        <div class=\"stat\">Self-loops: <span id=\"statLoops\">0</span></div>\n      </div>\n    </div>\n\n    <svg id=\"svgCanvas\" viewBox=\"0 0 800 520\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n\n    <div class=\"muted\">Tip: drag the window to resize the visualization. Node labels are A..Z then numbers.</div>\n  </section>\n\n  <!-- Right: adjacency list & properties -->\n  <aside class=\"panel rightPanel\">\n    <div>\n      <strong>Adjacency List</strong>\n      <div id=\"adjList\" class=\"adjList muted\" style=\"margin-top:8px\"></div>\n    </div>\n\n    <div>\n      <strong>Matrix Info</strong>\n      <div style=\"margin-top:8px\" id=\"matrixInfo\" class=\"muted\"></div>\n    </div>\n\n    <div>\n      <strong>Actions / Utilities</strong>\n      <div style=\"display:flex; gap:8px; margin-top:8px; flex-wrap:wrap\">\n        <button id=\"symCheck\" class=\"small ghost\">Check Symmetry</button>\n        <button id=\"degCalc\" class=\"small\">Compute Degrees</button>\n        <button id=\"floydWarshall\" class=\"small ghost\">Shortest paths (Floyd)</button>\n      </div>\n      <div id=\"utilityOutput\" style=\"margin-top:8px\"></div>\n    </div>\n  </aside>\n</main>\n\n<div class=\"footer panel\" style=\"margin:16px\">\n  This small tool demonstrates the adjacency matrix representation of graphs. The matrix cells represent edges (row = source, column = target). Undirected graphs keep the matrix symmetric. Directed graphs may have asymmetric entries. Weighted edges store numbers & influence edge thickness in the drawing.\n</div>\n\n<script>\n// Utility / state\nlet n = 6;\nlet directed = false;\nlet weighted = false;\nlet matrix = [];\nconst svg = document.getElementById('svgCanvas');\n\nfunction initMatrix(size){\n  matrix = Array.from({length:size}, () => Array.from({length:size}, ()=>0));\n  n = size;\n  document.getElementById('nodeCount').value = size;\n  drawAll();\n}\n\nfunction labelFor(i){\n  if(i < 26) return String.fromCharCode(65 + i); // A-Z\n  return (i+1).toString();\n}\n\n// UI hooks\ndocument.getElementById('nodeCount').addEventListener('change', e=>{\n  let v = parseInt(e.target.value) || 1;\n  v = Math.max(1, Math.min(50, v));\n  if(v > n) {\n    // extend\n    for(let i=0;i<v-n;i++){\n      matrix.push(Array.from({length:n}, ()=>0));\n      n++;\n      for(let r=0;r<n;r++) if(matrix[r].length < n) matrix[r].push(0);\n    }\n  } else if(v < n) {\n    matrix = matrix.slice(0,v).map(r=>r.slice(0,v));\n    n = v;\n  }\n  drawAll();\n});\ndocument.getElementById('addNode').addEventListener('click', ()=>{\n  let newSize = n+1;\n  for(let r=0;r<n;r++) matrix[r].push(0);\n  matrix.push(Array.from({length:newSize}, ()=>0));\n  n = newSize;\n  document.getElementById('nodeCount').value = n;\n  drawAll();\n});\ndocument.getElementById('removeNode').addEventListener('click', ()=>{\n  if(n <= 1) return;\n  matrix = matrix.slice(0,n-1).map(r=>r.slice(0,n-1));\n  n--;\n  document.getElementById('nodeCount').value = n;\n  drawAll();\n});\ndocument.getElementById('directed').addEventListener('change', e=>{\n  directed = e.target.checked;\n  drawAll();\n});\ndocument.getElementById('weighted').addEventListener('change', e=>{\n  weighted = e.target.checked;\n  drawAll();\n});\n\ndocument.getElementById('prob').addEventListener('input', e=>{\n  document.getElementById('probLabel').textContent = e.target.value + '%';\n});\ndocument.getElementById('randBtn').addEventListener('click', ()=>{\n  const p = parseInt(document.getElementById('prob').value)/100;\n  for(let i=0;i<n;i++){\n    for(let j=0;j<n;j++){\n      if(i===j) {\n        // occasionally allow loops\n        matrix[i][j] = Math.random() < (p*0.15) ? (weighted ? Math.round(Math.random()*9)+1 : 1) : 0;\n      } else {\n        if(Math.random() < p) {\n          matrix[i][j] = weighted ? Math.round(Math.random()*9)+1 : 1;\n        } else matrix[i][j] = 0;\n      }\n    }\n  }\n  if(!directed) {\n    // symmetrize\n    for(let i=0;i<n;i++) for(let j=i+1;j<n;j++){\n      matrix[j][i] = matrix[i][j] = (matrix[i][j] || matrix[j][i]) ? (weighted ? Math.max(matrix[i][j], matrix[j][i]) : 1) : 0;\n    }\n  }\n  drawAll();\n});\n\ndocument.getElementById('clearBtn').addEventListener('click', ()=>{\n  for(let i=0;i<n;i++) for(let j=0;j<n;j++) matrix[i][j]=0;\n  drawAll();\n});\n\n// export/import\ndocument.getElementById('exportBtn').addEventListener('click', ()=>{\n  const data = {n, directed, weighted, matrix};\n  const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a'); a.href = url; a.download = 'adjacency_matrix.json'; a.click();\n  URL.revokeObjectURL(url);\n});\ndocument.getElementById('importBtn').addEventListener('click', ()=>{\n  const input = document.createElement('input');\n  input.type = 'file';\n  input.accept = '.json,application/json';\n  input.onchange = ()=>{\n    const file = input.files[0];\n    if(!file) return;\n    const reader = new FileReader();\n    reader.onload = () => {\n      try{\n        const o = JSON.parse(reader.result);\n        if(!o.matrix || !Array.isArray(o.matrix)) throw new Error('Invalid file');\n        matrix = o.matrix;\n        n = matrix.length;\n        directed = !!o.directed;\n        weighted = !!o.weighted;\n        document.getElementById('directed').checked = directed;\n        document.getElementById('weighted').checked = weighted;\n        document.getElementById('nodeCount').value = n;\n        drawAll();\n      }catch(err){\n        alert('Failed to parse: ' + err.message);\n      }\n    };\n    reader.readAsText(file);\n  };\n  input.click();\n});\n\ndocument.getElementById('sampleBtn').addEventListener('click', ()=>{\n  // small example with weights\n  n = 7;\n  matrix = [\n    [0,1,0,0,0,0,0],\n    [1,0,3,0,0,0,0],\n    [0,3,0,2,0,0,0],\n    [0,0,2,0,1,0,0],\n    [0,0,0,1,0,4,0],\n    [0,0,0,0,4,0,5],\n    [0,0,0,0,0,5,0]\n  ];\n  directed = false; weighted = true;\n  document.getElementById('nodeCount').value = n;\n  document.getElementById('directed').checked = directed;\n  document.getElementById('weighted').checked = weighted;\n  drawAll();\n});\n\n// matrix rendering & interactivity\nfunction buildMatrixTable(){\n  const container = document.getElementById('matrixContainer');\n  container.innerHTML = '';\n  const tbl = document.createElement('table');\n  tbl.className = 'matrix';\n  const thead = document.createElement('thead');\n  const headerRow = document.createElement('tr');\n  headerRow.appendChild(document.createElement('th')); // top-left empty\n  for(let j=0;j<n;j++){\n    const th = document.createElement('th');\n    th.textContent = labelFor(j);\n    headerRow.appendChild(th);\n  }\n  thead.appendChild(headerRow);\n  tbl.appendChild(thead);\n\n  const tbody = document.createElement('tbody');\n  for(let i=0;i<n;i++){\n    const tr = document.createElement('tr');\n    const th = document.createElement('th'); th.textContent = labelFor(i);\n    tr.appendChild(th);\n    for(let j=0;j<n;j++){\n      const td = document.createElement('td');\n      td.className = 'clickable' + (i===j ? ' loopCell': '');\n      td.dataset.r = i; td.dataset.c = j;\n      td.addEventListener('click', onMatrixCellClick);\n      td.textContent = matrix[i][j];\n      tr.appendChild(td);\n    }\n    tbody.appendChild(tr);\n  }\n  tbl.appendChild(tbody);\n  container.appendChild(tbl);\n}\n\nfunction onMatrixCellClick(e){\n  const r = Number(this.dataset.r), c = Number(this.dataset.c);\n  if(weighted){\n    const val = prompt('Enter numeric weight (0 to remove):', String(matrix[r][c] || '1'));\n    if(val === null) return;\n    const num = Number(val);\n    if(isNaN(num)) return alert('Please enter a number.');\n    if(!directed && r!==c){\n      matrix[r][c] = matrix[c][r] = num;\n    } else {\n      matrix[r][c] = num;\n    }\n  } else {\n    // toggle 0/1\n    if(!directed && r!==c){\n      const set = matrix[r][c] ? 0 : 1;\n      matrix[r][c] = matrix[c][r] = set;\n    } else {\n      matrix[r][c] = matrix[r][c] ? 0 : 1;\n    }\n  }\n  drawAll();\n}\n\n// drawing graph in SVG\nfunction drawAll(){\n  buildMatrixTable();\n  renderSVG();\n  updateAdjList();\n  updateStats();\n  updateMatrixInfo();\n}\n\nfunction renderSVG(){\n  while(svg.firstChild) svg.removeChild(svg.firstChild);\n  const W = svg.viewBox.baseVal.width || 800;\n  const H = svg.viewBox.baseVal.height || 520;\n  const cx = W/2, cy = H/2;\n  const radius = Math.min(W,H)/2 - 80;\n  const nodes = [];\n  for(let i=0;i<n;i++){\n    const angle = (i/n) * Math.PI*2 - Math.PI/2;\n    const x = cx + Math.cos(angle) * radius;\n    const y = cy + Math.sin(angle) * radius;\n    nodes.push({x,y});\n  }\n\n  // arrow marker for directed edges\n  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');\n  const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');\n  marker.setAttribute('id','arrowhead');\n  marker.setAttribute('markerWidth','10');\n  marker.setAttribute('markerHeight','7');\n  marker.setAttribute('refX','10');\n  marker.setAttribute('refY','3.5');\n  marker.setAttribute('orient','auto');\n  const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n  path.setAttribute('d','M0,0 L10,3.5 L0,7 z');\n  path.setAttribute('fill', '#333');\n  marker.appendChild(path); defs.appendChild(marker);\n  svg.appendChild(defs);\n\n  // edges group (below nodes)\n  const edgesG = document.createElementNS('http://www.w3.org/2000/svg','g');\n  edgesG.setAttribute('class','edges');\n  svg.appendChild(edgesG);\n\n  // For undirected graphs draw i<j edges to avoid duplicates\n  const edgeList = [];\n  for(let i=0;i<n;i++){\n    for(let j=0;j<n;j++){\n      const val = matrix[i][j];\n      if(!val) continue;\n      if(!directed && j < i) continue; // skip duplicate\n      edgeList.push({i,j,w:val});\n    }\n  }\n\n  edgeList.forEach((e, idx)=>{\n    const a = nodes[e.i], b = nodes[e.j];\n    if(e.i === e.j){\n      // self-loop: draw a circular loop\n      const loop = document.createElementNS('http://www.w3.org/2000/svg','path');\n      const loopR = 22 + Math.min(30, Math.abs(e.w || 0)*2);\n      const startX = a.x, startY = a.y - 8;\n      const d = `M ${startX} ${startY} C ${startX - loopR} ${startY - loopR}, ${startX + loopR} ${startY - loopR}, ${startX} ${startY}`;\n      loop.setAttribute('d', d);\n      loop.setAttribute('fill','none');\n      loop.setAttribute('stroke','#333');\n      loop.setAttribute('stroke-width', Math.max(1, (e.w || 1)));\n      loop.style.cursor = 'pointer';\n      loop.addEventListener('click', ev=>{\n        ev.stopPropagation();\n        toggleEdge(e.i, e.j);\n      });\n      edgesG.appendChild(loop);\n\n      // weight label\n      if(weighted){\n        const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');\n        lbl.textContent = e.w;\n        lbl.setAttribute('x', a.x + 6);\n        lbl.setAttribute('y', a.y - loopR - 8);\n        lbl.setAttribute('font-size','12');\n        lbl.setAttribute('fill','#333');\n        edgesG.appendChild(lbl);\n      }\n      return;\n    }\n\n    // for non-self edges: draw line/curve\n    // To avoid overlapping when both (i,j) and (j,i) exist in directed graph, draw a slight arc\n    let line;\n    if(directed && matrix[e.j] && matrix[e.j][e.i]){\n      // both directions exist -> draw curved arc for unique orientation\n      const mx = (a.x + b.x)/2;\n      const my = (a.y + b.y)/2;\n      const dx = b.x - a.x, dy = b.y - a.y;\n      const len = Math.hypot(dx,dy);\n      const nx = -dy/len, ny = dx/len; // normal\n      const arcOffset = 18;\n      const cx1 = mx + nx * arcOffset;\n      const cy1 = my + ny * arcOffset;\n      const d = `M ${a.x} ${a.y} Q ${cx1} ${cy1} ${b.x} ${b.y}`;\n      line = document.createElementNS('http://www.w3.org/2000/svg','path');\n      line.setAttribute('d', d);\n    } else {\n      // straight line\n      line = document.createElementNS('http://www.w3.org/2000/svg','line');\n      line.setAttribute('x1', a.x);\n      line.setAttribute('y1', a.y);\n      line.setAttribute('x2', b.x);\n      line.setAttribute('y2', b.y);\n    }\n    line.setAttribute('stroke','#333');\n    line.setAttribute('fill','none');\n    line.setAttribute('stroke-width', Math.max(1, (e.w || 1)));\n    line.style.cursor = 'pointer';\n\n    // add arrowheads for directed\n    if(directed){\n      line.setAttribute('marker-end', 'url(#arrowhead)');\n    }\n\n    line.addEventListener('click', ev=>{\n      ev.stopPropagation();\n      toggleEdge(e.i, e.j);\n    });\n\n    edgesG.appendChild(line);\n\n    // optionally label weight\n    if(weighted){\n      // compute position\n      let tx, ty;\n      if(line.tagName === 'line'){\n        tx = (a.x + b.x)/2; ty = (a.y + b.y)/2;\n      } else {\n        // path with quadratic: approximate midpoint at t=0.5\n        const pathElem = line;\n        const pathLength = pathElem.getTotalLength ? pathElem.getTotalLength() : 0;\n        if(pathLength){\n          const pt = pathElem.getPointAtLength(pathLength/2);\n          tx = pt.x; ty = pt.y;\n        } else {\n          tx = (a.x + b.x)/2; ty = (a.y + b.y)/2;\n        }\n      }\n      const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');\n      lbl.textContent = e.w;\n      lbl.setAttribute('x', tx + 6);\n      lbl.setAttribute('y', ty - 6);\n      lbl.setAttribute('font-size','12');\n      lbl.setAttribute('fill','#111');\n      edgesG.appendChild(lbl);\n    }\n  });\n\n  // nodes\n  const nodesG = document.createElementNS('http://www.w3.org/2000/svg','g');\n  nodesG.setAttribute('class','nodes');\n  svg.appendChild(nodesG);\n  nodes.forEach((p,i)=>{\n    const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n    g.setAttribute('transform', `translate(${p.x},${p.y})`);\n    // circle\n    const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');\n    circ.setAttribute('r', 20);\n    circ.setAttribute('fill','#fff');\n    circ.setAttribute('stroke','#0b78d1');\n    circ.setAttribute('stroke-width',2);\n    circ.style.cursor = 'default';\n    g.appendChild(circ);\n    // label\n    const tx = document.createElementNS('http://www.w3.org/2000/svg','text');\n    tx.setAttribute('x',0); tx.setAttribute('y',6);\n    tx.setAttribute('text-anchor','middle');\n    tx.setAttribute('font-size','13');\n    tx.setAttribute('fill','#0b78d1');\n    tx.textContent = labelFor(i);\n    g.appendChild(tx);\n\n    nodesG.appendChild(g);\n  });\n}\n\n// toggle edge through UI (click events)\nfunction toggleEdge(i,j){\n  if(weighted){\n    const cur = matrix[i][j] || 0;\n    const val = prompt('Enter numeric weight (0 to remove):', String(cur || '1'));\n    if(val === null) return;\n    const num = Number(val);\n    if(isNaN(num)) return alert('Please enter a number.');\n    if(!directed && i!==j){\n      matrix[i][j] = matrix[j][i] = num;\n    } else {\n      matrix[i][j] = num;\n    }\n  } else {\n    if(!directed && i!==j){\n      const set = matrix[i][j] ? 0 : 1;\n      matrix[i][j] = matrix[j][i] = set;\n    } else {\n      matrix[i][j] = matrix[i][j] ? 0 : 1;\n    }\n  }\n  drawAll();\n}\n\n// adjacency list rendering\nfunction updateAdjList(){\n  const container = document.getElementById('adjList');\n  container.innerHTML = '';\n  for(let i=0;i<n;i++){\n    const line = document.createElement('div');\n    line.style.marginBottom = '6px';\n    const left = document.createElement('strong');\n    left.textContent = labelFor(i) + ': ';\n    left.style.marginRight = '6px';\n    const targets = [];\n    for(let j=0;j<n;j++){\n      if(matrix[i][j]){\n        if(weighted) targets.push(`${labelFor(j)}(${matrix[i][j]})`);\n        else targets.push(labelFor(j));\n      }\n    }\n    const span = document.createElement('span');\n    span.textContent = targets.length ? targets.join(', ') : '—';\n    span.className = 'muted';\n    line.appendChild(left); line.appendChild(span);\n    container.appendChild(line);\n  }\n}\n\n// stats and matrix info\nfunction updateStats(){\n  let edges = 0, loops = 0;\n  if(directed){\n    for(let i=0;i<n;i++) for(let j=0;j<n;j++) if(matrix[i][j]) {\n      edges++;\n      if(i===j) loops++;\n    }\n  } else {\n    for(let i=0;i<n;i++) for(let j=i;j<n;j++) if(matrix[i][j]) {\n      edges++;\n      if(i===j) loops++;\n    }\n  }\n  document.getElementById('statNodes').textContent = n;\n  document.getElementById('statEdges').textContent = edges;\n  document.getElementById('statLoops').textContent = loops;\n}\n\nfunction updateMatrixInfo(){\n  // check symmetry\n  let symmetric = true;\n  for(let i=0;i<n;i++) for(let j=0;j<n;j++) if(matrix[i][j] !== matrix[j][i]) symmetric=false;\n  // degrees (if unweighted we treat non-zero as 1)\n  const degIn = Array(n).fill(0), degOut = Array(n).fill(0);\n  for(let i=0;i<n;i++){\n    for(let j=0;j<n;j++){\n      const val = matrix[i][j] || 0;\n      degOut[i] += val ? 1 : 0;\n      degIn[j] += val ? 1 : 0;\n    }\n  }\n  const info = document.getElementById('matrixInfo');\n  info.innerHTML = `\n    Directed: <strong>${directed ? 'Yes' : 'No'}</strong><br/>\n    Weighted: <strong>${weighted ? 'Yes' : 'No'}</strong><br/>\n    Symmetric: <strong>${symmetric ? 'Yes' : 'No'}</strong><br/>\n    Average out-degree: <strong>${(degOut.reduce((a,b)=>a+b,0)/n).toFixed(2)}</strong>\n  `;\n}\n\n// utilities\ndocument.getElementById('symCheck').addEventListener('click', ()=>{\n  let symmetric = true;\n  const mismatches = [];\n  for(let i=0;i<n;i++) for(let j=0;j<n;j++){\n    if(matrix[i][j] !== matrix[j][i]) mismatches.push(`${labelFor(i)}↔${labelFor(j)}: ${matrix[i][j]} vs ${matrix[j][i]}`);\n  }\n  const out = document.getElementById('utilityOutput');\n  if(mismatches.length===0) out.innerHTML = '<div class=\"muted\">Matrix is symmetric.</div>';\n  else out.innerHTML = `<div class=\"muted\">Found ${mismatches.length} mismatches:<pre style=\"margin-top:6px\">${mismatches.slice(0,20).join('\\n')}</pre></div>`;\n});\n\ndocument.getElementById('degCalc').addEventListener('click', ()=>{\n  const degOut = Array(n).fill(0), degIn = Array(n).fill(0);\n  for(let i=0;i<n;i++) for(let j=0;j<n;j++){\n    const val = matrix[i][j] || 0;\n    degOut[i] += val ? 1 : 0;\n    degIn[j] += val ? 1 : 0;\n  }\n  const lines = [];\n  for(let i=0;i<n;i++){\n    lines.push(`${labelFor(i)}: out=${degOut[i]} in=${degIn[i]}`);\n  }\n  document.getElementById('utilityOutput').innerHTML = `<pre style=\"margin:0\">${lines.join('\\n')}</pre>`;\n});\n\n// Floyd-Warshall for shortest paths (weights considered; 1 for unweighted edges)\ndocument.getElementById('floydWarshall').addEventListener('click', ()=>{\n  const INF = 1e9;\n  // build dist matrix\n  const dist = Array.from({length:n}, (_,i)=>Array.from({length:n}, (_,j)=> (i===j?0:INF)));\n  for(let i=0;i<n;i++) for(let j=0;j<n;j++){\n    if(matrix[i][j]) dist[i][j] = weighted ? matrix[i][j] : 1;\n  }\n  for(let k=0;k<n;k++) for(let i=0;i<n;i++) for(let j=0;j<n;j++){\n    if(dist[i][k] + dist[k][j] < dist[i][j]) dist[i][j] = dist[i][k] + dist[k][j];\n  }\n  const lines = ['All-pairs shortest path distances (INF denotes unreachable):',''];\n  for(let i=0;i<n;i++){\n    const row = dist[i].map(v => v >= INF ? 'INF' : String(v)).join(' ');\n    lines.push(`${labelFor(i)}: ${row}`);\n  }\n  document.getElementById('utilityOutput').innerHTML = `<pre style=\"margin:0\">${lines.join('\\n')}</pre>`;\n});\n\n// initialize\ninitMatrix(n);\ndrawAll();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency Matrix"
    }
  ],
  "topic": "Adjacency Matrix",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}