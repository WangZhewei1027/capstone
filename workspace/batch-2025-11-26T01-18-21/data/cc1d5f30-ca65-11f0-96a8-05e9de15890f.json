{
  "id": "cc1d5f30-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:20:49.790Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Heap (Min/Max)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Interactive Heap (Min / Max) Visualization</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --card:#0b1220;\n      --accent:#60a5fa;\n      --muted:#94a3b8;\n      --node:#111827;\n      --node-border:#334155;\n      --text:#e6eef8;\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    body{background:linear-gradient(180deg,#071028,#071623 40%);color:var(--text);padding:20px;box-sizing:border-box;}\n    .wrap{max-width:1100px;margin:0 auto;display:grid;grid-template-columns:360px 1fr;gap:18px;}\n    .panel{background:linear-gradient(180deg,var(--card),#071422);border:1px solid rgba(255,255,255,0.03);padding:16px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6);}\n    h1{font-size:18px;margin:0 0 8px 0}\n    p.muted{color:var(--muted);font-size:13px;margin:6px 0 12px;}\n    .controls{display:flex;flex-direction:column;gap:10px;}\n    .row{display:flex;gap:8px;align-items:center;}\n    input[type=\"number\"],input[type=\"text\"]{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#071826;color:var(--text);outline:none;}\n    button{padding:8px 10px;border-radius:8px;border:0;background:var(--accent);color:#04263e;font-weight:600;cursor:pointer;}\n    button.gray{background:#223047;color:var(--text);}\n    .small{font-size:13px;padding:6px 8px;border-radius:8px;}\n    .toggles{display:flex;gap:8px;align-items:center;}\n    label.switch{display:flex;align-items:center;gap:8px;font-size:13px;color:var(--muted)}\n    .status{margin-top:12px;font-size:13px;color:var(--muted)}\n    .visual{display:flex;flex-direction:column;gap:12px;height:650px;}\n    .arrayView{background:linear-gradient(180deg,#061523,#071423);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);}\n    .arrayRow{display:flex;gap:8px;flex-wrap:wrap;}\n    .cell{min-width:42px;height:42px;background:linear-gradient(180deg,#0b2230,#06202a);border-radius:8px;display:flex;align-items:center;justify-content:center;color:var(--text);border:2px solid var(--node-border);font-weight:700;box-shadow:0 3px 10px rgba(4,10,20,0.6);}\n    .cell.highlight{background:linear-gradient(180deg,#ffedd5,#ffd7b0);color:#102027;border-color:#f59e0b;transform:scale(1.06);}\n    .arrayIndex{font-size:11px;color:var(--muted);margin-top:6px;text-align:center;}\n    .treeWrap{position:relative;flex:1;background:linear-gradient(180deg,#021421,#031826);border-radius:10px;padding:12px;border:1px solid rgba(255,255,255,0.02);overflow:auto;}\n    svg.lines{position:absolute;left:12px;top:12px;width:calc(100% - 24px);height:calc(100% - 24px);pointer-events:none;overflow:visible;}\n    .level{display:flex;justify-content:space-between;align-items:center;margin:18px 6px;position:relative;min-height:64px;}\n    .node{width:56px;height:56px;border-radius:50%;background:linear-gradient(180deg,#022a3a,#042b39);display:flex;align-items:center;justify-content:center;color:var(--text);font-weight:800;border:2px solid var(--node-border);box-shadow:0 6px 18px rgba(0,0,0,0.6);transition:transform .18s,background .18s,border-color .18s;}\n    .node.highlight{background:linear-gradient(180deg,#fef3c7,#ffedd5);color:#102027;border-color:#fb923c;transform:scale(1.14);}\n    .node.small{width:44px;height:44px;font-size:14px}\n    .legend{font-size:13px;color:var(--muted);margin-top:12px}\n    .footer{margin-top:10px;font-size:13px;color:var(--muted)}\n    .explain{font-size:13px;color:var(--muted);margin-top:12px;line-height:1.4}\n    .ops{display:flex;gap:8px;flex-wrap:wrap;}\n    .muted-box{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;font-size:13px;color:var(--muted);}\n    .code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,monospace;background:#01111a;padding:10px;border-radius:8px;color:#8be9fd;font-size:13px;overflow:auto}\n    footer{margin-top:20px;text-align:center;color:var(--muted);font-size:13px}\n    @media (max-width:900px){.wrap{grid-template-columns:1fr;}}\n  </style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <div class=\"panel\">\n      <h1>Heap (Min/Max) — Interactive Demo</h1>\n      <p class=\"muted\">Try inserting values, popping the top, building from an array, or switching between min-heap and max-heap. Watch the array representation and tree update step-by-step.</p>\n\n      <div class=\"controls\">\n        <div class=\"row\">\n          <input id=\"valueInput\" type=\"number\" placeholder=\"Value to insert (e.g. 42)\" />\n          <button id=\"insertBtn\">Insert</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"popBtn\" class=\"small\">Pop Top</button>\n          <button id=\"peekBtn\" class=\"small gray\">Peek</button>\n          <button id=\"clearBtn\" class=\"small gray\">Clear</button>\n        </div>\n\n        <div class=\"row\">\n          <input id=\"arrInput\" type=\"text\" placeholder=\"Build from list, e.g. 9,4,7,1,0\" />\n          <button id=\"buildBtn\">Build</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"rndBtn\" class=\"small gray\">Random Fill</button>\n          <select id=\"rndCount\" style=\"padding:8px;border-radius:8px;background:#071826;color:var(--text);border:1px solid rgba(255,255,255,0.04);\">\n            <option>7</option><option>10</option><option>15</option><option>20</option>\n          </select>\n        </div>\n\n        <div class=\"toggles\">\n          <label class=\"switch\"><input id=\"typeToggle\" type=\"checkbox\" /> Max-heap</label>\n          <label class=\"switch\"><input id=\"animateToggle\" type=\"checkbox\" checked /> Animate</label>\n          <label class=\"switch\"><input id=\"showIndexes\" type=\"checkbox\" checked /> Show indexes</label>\n        </div>\n\n        <div class=\"status\" id=\"status\">Heap type: <strong id=\"typeLabel\">Min-heap</strong> — size: <strong id=\"sizeLabel\">0</strong></div>\n\n        <div class=\"legend\">\n          Top element is root. Min-heap: smallest at top. Max-heap: largest at top.\n        </div>\n\n        <div class=\"explain\">\n          Key operations:\n          <ul style=\"margin:6px 12px;color:var(--muted)\">\n            <li>Insert: place at end and sift-up to restore heap property (O(log n)).</li>\n            <li>Pop top: swap root with last, remove it, then sift-down root (O(log n)).</li>\n            <li>Build heap from array: bottom-up heapify with repeated sift-down (O(n)).</li>\n          </ul>\n        </div>\n\n        <div class=\"footer\">\n          Implementation uses a binary heap stored in an array (0-based). Child indices: left = 2*i+1, right = 2*i+2.\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel visual\">\n      <div class=\"arrayView\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n          <strong>Array representation (index order)</strong>\n          <div style=\"color:var(--muted);font-size:13px\" id=\"topVal\">Top: —</div>\n        </div>\n        <div class=\"arrayRow\" id=\"arrayRow\" style=\"margin-top:12px;\"></div>\n      </div>\n\n      <div class=\"treeWrap\" id=\"treeWrap\">\n        <svg class=\"lines\" id=\"lines\"></svg>\n        <div id=\"treeLevels\"></div>\n      </div>\n\n      <div style=\"display:flex;gap:12px;align-items:center;\">\n        <div class=\"muted-box\" id=\"opLog\">Operation log: (most recent at top)</div>\n        <div style=\"flex:1\"></div>\n        <div class=\"code\" id=\"complexity\">Insert: O(log n) • Pop: O(log n) • Build: O(n)</div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Heap implementation with animation support\n    class Heap {\n      constructor(isMax=false, onStep=null) {\n        this.data = [];\n        this.isMax = !!isMax;\n        this.onStep = typeof onStep === 'function' ? onStep : ()=>{};\n      }\n      cmp(a,b){\n        return this.isMax ? a > b : a < b;\n      }\n      size(){ return this.data.length; }\n      peek(){ return this.data[0]; }\n      swap(i,j){\n        [this.data[i], this.data[j]] = [this.data[j], this.data[i]];\n      }\n      async insert(value, animate=true){\n        const i = this.data.length;\n        this.data.push(value);\n        await this.onStep({type:'push',index:i});\n        await this._siftUp(i, animate);\n      }\n      async pop(animate=true){\n        if(this.data.length === 0) return undefined;\n        const top = this.data[0];\n        const lastIdx = this.data.length - 1;\n        if(lastIdx === 0){\n          this.data.pop();\n          await this.onStep({type:'pop',poppedIndex:0, value: top});\n          return top;\n        }\n        this.swap(0, lastIdx);\n        await this.onStep({type:'swap',i:0,j:lastIdx});\n        this.data.pop();\n        await this.onStep({type:'pop',poppedIndex:lastIdx, value: top});\n        await this._siftDown(0, animate);\n        return top;\n      }\n      async buildFromArray(arr, animate=true){\n        this.data = arr.slice();\n        await this.onStep({type:'build',array:this.data.slice()});\n        // heapify bottom-up\n        const n = this.data.length;\n        for(let i = Math.floor(n/2)-1; i>=0; i--){\n          await this._siftDown(i, animate);\n        }\n      }\n      async _siftUp(i, animate=true){\n        let idx = i;\n        while(idx > 0){\n          const parent = Math.floor((idx-1)/2);\n          if(this.cmp(this.data[idx], this.data[parent])){\n            this.swap(idx, parent);\n            await this.onStep({type:'swap',i:idx,j:parent});\n            idx = parent;\n          } else break;\n        }\n      }\n      async _siftDown(i, animate=true){\n        let idx = i;\n        const n = this.data.length;\n        while(true){\n          const left = 2*idx + 1;\n          const right = 2*idx + 2;\n          let candidate = idx;\n          if(left < n && this.cmp(this.data[left], this.data[candidate])) candidate = left;\n          if(right < n && this.cmp(this.data[right], this.data[candidate])) candidate = right;\n          if(candidate !== idx){\n            this.swap(idx, candidate);\n            await this.onStep({type:'swap',i:idx,j:candidate});\n            idx = candidate;\n          } else break;\n        }\n      }\n    }\n\n    // UI and visualization\n    const valueInput = document.getElementById('valueInput');\n    const insertBtn = document.getElementById('insertBtn');\n    const popBtn = document.getElementById('popBtn');\n    const peekBtn = document.getElementById('peekBtn');\n    const clearBtn = document.getElementById('clearBtn');\n    const arrInput = document.getElementById('arrInput');\n    const buildBtn = document.getElementById('buildBtn');\n    const rndBtn = document.getElementById('rndBtn');\n    const rndCount = document.getElementById('rndCount');\n    const typeToggle = document.getElementById('typeToggle');\n    const animateToggle = document.getElementById('animateToggle');\n    const showIndexes = document.getElementById('showIndexes');\n\n    const typeLabel = document.getElementById('typeLabel');\n    const sizeLabel = document.getElementById('sizeLabel');\n    const arrayRow = document.getElementById('arrayRow');\n    const treeLevels = document.getElementById('treeLevels');\n    const linesSvg = document.getElementById('lines');\n    const topVal = document.getElementById('topVal');\n    const opLog = document.getElementById('opLog');\n\n    function logOp(msg){\n      const time = new Date().toLocaleTimeString();\n      opLog.innerHTML = `<div style=\"padding:6px 0;border-bottom:1px dashed rgba(255,255,255,0.02)\"><strong style=\"color:var(--accent)\">${time}</strong> — ${msg}</div>` + opLog.innerHTML;\n    }\n\n    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }\n\n    let animDelay = 450; // ms per step\n    function stepDelay(enabled){ return enabled ? sleep(animDelay) : Promise.resolve(); }\n\n    // create heap with callback onStep\n    let heap = new Heap(false, onStep);\n\n    function updateStatus(){\n      typeLabel.textContent = heap.isMax ? \"Max-heap\" : \"Min-heap\";\n      sizeLabel.textContent = heap.size();\n      topVal.textContent = `Top: ${heap.size() ? heap.peek() : '—'}`;\n      renderAll();\n    }\n\n    // Visualization rendering\n    function renderArray(highlightIdxs=[]){\n      arrayRow.innerHTML = '';\n      const arr = heap.data;\n      for(let i=0;i<arr.length;i++){\n        const cell = document.createElement('div');\n        cell.className = 'cell' + (highlightIdxs.includes(i) ? ' highlight' : '');\n        cell.textContent = arr[i];\n        arrayRow.appendChild(cell);\n      }\n      if(arr.length===0){\n        arrayRow.innerHTML = '<div style=\"color:var(--muted)\">[ empty ]</div>';\n      }\n    }\n\n    function renderTree(highlightIdxs=[]){\n      treeLevels.innerHTML = '';\n      linesSvg.innerHTML = '';\n      const arr = heap.data;\n      if(arr.length===0){\n        treeLevels.innerHTML = '<div style=\"color:var(--muted);padding:20px;text-align:center\">Heap is empty</div>';\n        return;\n      }\n      // compute levels\n      let level = 0, i = 0;\n      const positions = []; // store node positions for drawing lines\n      const containerWidth = treeLevels.clientWidth || 800;\n      while(i < arr.length){\n        const cnt = Math.min(Math.pow(2, level), arr.length - i);\n        const row = document.createElement('div');\n        row.className = 'level';\n        // place nodes evenly across the available width\n        for(let j=0;j<cnt;j++){\n          const idx = i + j;\n          const node = document.createElement('div');\n          node.className = 'node' + (highlightIdxs.includes(idx) ? ' highlight' : '') + (arr.length>32 ? ' small' : '');\n          node.textContent = arr[idx];\n          node.dataset.idx = idx;\n          if(showIndexes.checked){\n            const idxDiv = document.createElement('div');\n            idxDiv.className = 'arrayIndex';\n            idxDiv.textContent = idx;\n            idxDiv.style.position = 'absolute';\n            idxDiv.style.top = '62px';\n            idxDiv.style.left = '0';\n            idxDiv.style.width = '100%';\n            node.appendChild(idxDiv);\n          }\n          row.appendChild(node);\n        }\n        treeLevels.appendChild(row);\n        i += cnt;\n        level++;\n      }\n      // compute DOM positions\n      // After layout, measure nodes and draw lines\n      const nodes = treeLevels.querySelectorAll('.node');\n      nodes.forEach(n => {\n        const r = n.getBoundingClientRect();\n        const parentRect = treeLevels.getBoundingClientRect();\n        positions.push({idx: Number(n.dataset.idx), cx: r.left - parentRect.left + r.width/2, cy: r.top - parentRect.top + r.height/2});\n      });\n      // draw lines between parent-child\n      // map index to position\n      const posMap = {};\n      positions.forEach(p => posMap[p.idx] = p);\n      for(let k=0;k<positions.length;k++){\n        const idx = positions[k].idx;\n        const leftIdx = 2*idx + 1;\n        const rightIdx = 2*idx + 2;\n        [leftIdx, rightIdx].forEach(childIdx => {\n          if(posMap[childIdx]){\n            const p = posMap[idx];\n            const c = posMap[childIdx];\n            const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n            line.setAttribute('x1', p.cx);\n            line.setAttribute('y1', p.cy + 22); // slightly below center of circle\n            line.setAttribute('x2', c.cx);\n            line.setAttribute('y2', c.cy - 22);\n            line.setAttribute('stroke', 'rgba(200,220,255,0.06)');\n            line.setAttribute('stroke-width', '2');\n            line.setAttribute('stroke-linecap','round');\n            linesSvg.appendChild(line);\n          }\n        });\n      }\n    }\n\n    async function onStep(evt){\n      // evt types: push, swap, pop, build\n      // we will highlight indices during swap and show array/tree updates\n      if(evt.type === 'push'){\n        renderArray([evt.index]);\n        renderTree([evt.index]);\n        updateStatus();\n        await stepDelay(animateToggle.checked);\n      } else if(evt.type === 'swap'){\n        renderArray([evt.i, evt.j]);\n        renderTree([evt.i, evt.j]);\n        updateStatus();\n        await stepDelay(animateToggle.checked);\n      } else if(evt.type === 'pop'){\n        renderArray([]); renderTree([]);\n        updateStatus();\n        logOp(`Popped value ${evt.value}`);\n        await stepDelay(animateToggle.checked);\n      } else if(evt.type === 'build'){\n        renderArray([]);\n        renderTree([]);\n        updateStatus();\n        logOp('Started building heap from array');\n        await stepDelay(animateToggle.checked);\n      }\n      // after each step, do a full render to ensure final positions\n      renderArray();\n      renderTree();\n    }\n\n    // Initial render\n    updateStatus();\n\n    // Wire up UI\n    insertBtn.addEventListener('click', async () => {\n      const v = valueInput.value.trim();\n      if(v === '') return;\n      const num = Number(v);\n      if(Number.isNaN(num)) return alert('Please enter a number');\n      insertBtn.disabled = true;\n      await heap.insert(num, animateToggle.checked);\n      logOp(`Inserted ${num}`);\n      valueInput.value = '';\n      insertBtn.disabled = false;\n      updateStatus();\n    });\n\n    popBtn.addEventListener('click', async () => {\n      popBtn.disabled = true;\n      const val = await heap.pop(animateToggle.checked);\n      if(val === undefined) logOp('Pop attempted on empty heap');\n      else logOp(`Popped top ${val}`);\n      popBtn.disabled = false;\n      updateStatus();\n    });\n\n    peekBtn.addEventListener('click', () => {\n      const v = heap.peek();\n      alert(heap.size() ? `Top element: ${v}` : 'Heap is empty');\n    });\n\n    clearBtn.addEventListener('click', () => {\n      heap.data = [];\n      logOp('Cleared heap');\n      updateStatus();\n    });\n\n    buildBtn.addEventListener('click', async () => {\n      const text = arrInput.value.trim();\n      if(!text) return;\n      const parts = text.split(',').map(s => s.trim()).filter(s => s.length);\n      const nums = [];\n      for(const p of parts){\n        const n = Number(p);\n        if(Number.isNaN(n)){ alert('Invalid number in list: ' + p); return; }\n        nums.push(n);\n      }\n      buildBtn.disabled = true;\n      await heap.buildFromArray(nums, animateToggle.checked);\n      logOp(`Built heap from array [${nums.join(', ')}]`);\n      buildBtn.disabled = false;\n      updateStatus();\n    });\n\n    rndBtn.addEventListener('click', async () => {\n      const count = Number(rndCount.value) || 10;\n      const arr = [];\n      for(let i=0;i<count;i++) arr.push(Math.floor(Math.random()*100));\n      rndBtn.disabled = true;\n      await heap.buildFromArray(arr, animateToggle.checked);\n      logOp(`Random fill ${count} items`);\n      rndBtn.disabled = false;\n      updateStatus();\n    });\n\n    typeToggle.addEventListener('change', async () => {\n      const wasMax = heap.isMax;\n      heap.isMax = typeToggle.checked;\n      updateStatus();\n      // rebuild heap to respect new comparator (re-heapify data)\n      const arrCopy = heap.data.slice();\n      await heap.buildFromArray(arrCopy, animateToggle.checked);\n      logOp(`Switched to ${heap.isMax ? 'Max' : 'Min'}-heap`);\n    });\n\n    animateToggle.addEventListener('change', () => {\n      // nothing else; delay used in onStep\n    });\n\n    showIndexes.addEventListener('change', () => {\n      renderAll();\n    });\n\n    // handle window resize to re-render tree lines\n    window.addEventListener('resize', () => {\n      renderAll();\n    });\n\n    function renderAll(){\n      renderArray();\n      renderTree();\n    }\n\n    // Seed with a sample\n    (async function seed(){\n      const sample = [9,4,7,1,0,6,5,2,3,8];\n      await heap.buildFromArray(sample, false);\n      logOp('Initialized sample heap');\n      updateStatus();\n    })();\n\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap (Min/Max)"
    }
  ],
  "topic": "Heap (Min/Max)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}