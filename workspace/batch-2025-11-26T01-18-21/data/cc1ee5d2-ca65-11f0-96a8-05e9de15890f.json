{
  "id": "cc1ee5d2-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:20:53.540Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Recursion",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>Recursion Explorer — Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<style>\n  :root{ --bg:#0f1720; --panel:#0b1220; --muted:#9aa7b2; --accent:#66d9ef; --accent2:#7ee787; --glass:rgba(255,255,255,0.035); }\n  html,body{ height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial; background: linear-gradient(180deg,#071020 0%, #081826 60%); color:#e6f0f2; }\n  .wrap{ display:grid; grid-template-columns: 360px 1fr 320px; gap:18px; padding:18px; height:100vh; box-sizing:border-box; align-items:start; }\n  .panel{ background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:10px; padding:14px; box-shadow: 0 6px 18px rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,0.03); }\n  h2{ margin:6px 0 10px 0; font-size:16px; letter-spacing:0.2px; color:var(--accent); }\n  label{ font-size:13px; color:var(--muted); display:block; margin-top:8px; }\n  select,input[type=number]{ width:100%; padding:8px 10px; margin-top:6px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit; }\n  button{ background:linear-gradient(180deg,var(--accent), #35a7b5); color:#042027; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; box-shadow: 0 6px 18px rgba(54,173,185,0.12); }\n  .row{ display:flex; gap:8px; margin-top:10px; }\n  .small{ padding:6px 8px; font-size:13px; background:var(--glass); color:var(--muted); border-radius:8px; border:1px solid rgba(255,255,255,0.02); cursor:pointer; }\n  canvas{ width:100%; height:520px; border-radius:10px; display:block; background:linear-gradient(180deg, rgba(0,0,0,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); }\n  .controls{ display:flex; gap:8px; align-items:center; margin-top:10px; flex-wrap:wrap; }\n  .log{ height:180px; overflow:auto; background:rgba(0,0,0,0.15); border-radius:8px; padding:8px; font-family:monospace; font-size:13px; color:var(--muted); margin-top:10px; }\n  .stack{ height:calc(100vh - 200px); overflow:auto; background:rgba(0,0,0,0.06); border-radius:8px; padding:10px; font-family:monospace; font-size:13px; color:var(--muted); }\n  .frame{ padding:8px; border-radius:8px; background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02)); margin-bottom:8px; border:1px solid rgba(255,255,255,0.02); }\n  .frame.top{ box-shadow: 0 8px 24px rgba(2,6,23,0.6); border-color: rgba(255,255,255,0.04); }\n  .badge{ display:inline-block; padding:3px 6px; border-radius:6px; font-size:12px; color:#042027; background:var(--accent2); margin-left:8px; }\n  .muted{ color:var(--muted); font-size:13px; }\n  pre.code{ background:rgba(0,0,0,0.18); border-radius:8px; padding:10px; font-size:12px; color:#dff; overflow:auto; max-height:200px; }\n  .hint{ font-size:13px; color:var(--muted); margin-top:8px; }\n  .speed{ width:100px; }\n  .footer{ margin-top:12px; color:var(--muted); font-size:13px; }\n  .warn{ color:#ffd08a; font-weight:700; }\n  a{ color:var(--accent); text-decoration:none; }\n</style>\n</head>\n<body>\n<div class=\"wrap\">\n  <div class=\"panel\">\n    <h2>Recursion Explorer</h2>\n    <div class=\"muted\">Experiment with recursive functions. Generate an event trace and visualize how the call stack grows and shrinks as recursive calls enter and return.</div>\n\n    <label>Example</label>\n    <select id=\"example\">\n      <option value=\"factorial\">Factorial (classic)</option>\n      <option value=\"fib_naive\">Fibonacci — naive (exponential)</option>\n      <option value=\"fib_memo\">Fibonacci — memoized (dynamic programming)</option>\n      <option value=\"fractal_tree\">Fractal Tree (graphical recursion)</option>\n    </select>\n\n    <label id=\"paramLabel\">n</label>\n    <input id=\"param\" type=\"number\" min=\"0\" max=\"12\" value=\"6\" />\n\n    <div class=\"row\">\n      <button id=\"generate\">Generate Trace</button>\n      <button id=\"reset\" class=\"small\">Reset</button>\n      <div style=\"flex:1\"></div>\n    </div>\n\n    <div class=\"controls\">\n      <button id=\"play\">Play ▶</button>\n      <button id=\"pause\" class=\"small\">Pause ❙❙</button>\n      <button id=\"step\" class=\"small\">Step ⏭</button>\n      <label class=\"muted\" style=\"margin-left:6px;\">Speed</label>\n      <input type=\"range\" id=\"speed\" class=\"speed\" min=\"50\" max=\"1200\" step=\"50\" value=\"300\">\n      <div class=\"muted\" id=\"speedVal\">300 ms / step</div>\n    </div>\n\n    <div class=\"hint\">Notes: For naive Fibonacci keep n small (≤8). For fractal tree, depth becomes exponential in draw operations; keep depth ≤10 for responsiveness.</div>\n\n    <div class=\"footer\">\n      <div style=\"margin-top:10px;\"><strong>How it works:</strong> When the instrumented recursive function runs it records \"events\" (call/return/draw). The player replays those events so you can inspect the call stack and returned values step-by-step.</div>\n    </div>\n  </div>\n\n  <div class=\"panel\" style=\"display:flex; flex-direction:column;\">\n    <h2>Visualization Canvas</h2>\n    <canvas id=\"canvas\" width=\"900\" height=\"520\"></canvas>\n\n    <div style=\"display:flex; gap:10px; margin-top:10px;\">\n      <div style=\"flex:1\">\n        <div class=\"muted\">Trace Log</div>\n        <div id=\"log\" class=\"log\"></div>\n      </div>\n      <div style=\"width:260px;\">\n        <div class=\"muted\">Function / Code (simplified)</div>\n        <pre id=\"code\" class=\"code\"></pre>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"panel\">\n    <h2>Call Stack</h2>\n    <div id=\"stack\" class=\"stack\"></div>\n    <div style=\"margin-top:10px;\">\n      <div class=\"muted\">Final result</div>\n      <div id=\"result\" class=\"muted\" style=\"margin-top:6px;\">—</div>\n    </div>\n  </div>\n</div>\n\n<script>\n/*\n  Recursion Explorer\n  - Generates event traces for several recursive examples:\n    * factorial (straightforward)\n    * fibonacci (naive exponential)\n    * fibonacci with memoization\n    * fractal tree (graphical)\n  - Replays events allowing step-by-step inspection of call stack and returned values.\n*/\n\n(function(){\n  // DOM\n  const exampleEl = document.getElementById('example');\n  const paramEl = document.getElementById('param');\n  const paramLabel = document.getElementById('paramLabel');\n  const generateBtn = document.getElementById('generate');\n  const resetBtn = document.getElementById('reset');\n  const playBtn = document.getElementById('play');\n  const pauseBtn = document.getElementById('pause');\n  const stepBtn = document.getElementById('step');\n  const speedEl = document.getElementById('speed');\n  const speedVal = document.getElementById('speedVal');\n\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  const logEl = document.getElementById('log');\n  const stackEl = document.getElementById('stack');\n  const codeEl = document.getElementById('code');\n  const resultEl = document.getElementById('result');\n\n  let events = [];      // recorded events\n  let playIdx = 0;\n  let stack = [];\n  let playing = false;\n  let timer = null;\n  let stepDelay = parseInt(speedEl.value,10);\n  let idCounter = 1;\n\n  function setCode(text){\n    codeEl.textContent = text;\n  }\n\n  function clearCanvas(){\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    // subtle gradient backdrop\n    const g = ctx.createLinearGradient(0,0,0,canvas.height);\n    g.addColorStop(0,'rgba(255,255,255,0.01)');\n    g.addColorStop(1,'rgba(255,255,255,0.02)');\n    ctx.fillStyle = g;\n    ctx.fillRect(0,0,canvas.width,canvas.height);\n  }\n\n  function log(msg){\n    const pre = document.createElement('div');\n    pre.textContent = msg;\n    logEl.appendChild(pre);\n    logEl.scrollTop = logEl.scrollHeight;\n  }\n\n  function renderStack(){\n    stackEl.innerHTML = '';\n    for(let i = stack.length-1; i>=0; i--){\n      const f = stack[i];\n      const el = document.createElement('div');\n      el.className = 'frame' + (i === stack.length-1 ? ' top' : '');\n      el.innerHTML = `<div><strong>${f.name}</strong>(${f.args.map(a=>JSON.stringify(a)).join(', ')}) ${f.id ? ('<span class=\"muted\">#'+f.id+'</span>') : ''}</div>\n                      <div class=\"muted\">locals: ${f.locals ? JSON.stringify(f.locals) : '{}'}</div>`;\n      stackEl.appendChild(el);\n    }\n  }\n\n  function pushFrame(ev){\n    const frame = { id: ev.id, name: ev.name, args: ev.args.slice(), locals: ev.locals || {} };\n    stack.push(frame);\n    renderStack();\n    log(`CALL ${ev.name}(${ev.args.join(',')})  -> pushed frame #${ev.id}`);\n  }\n\n  function popFrame(ev){\n    // ideally the top frame matches id (LIFO)\n    const top = stack.pop();\n    if(!top){\n      log(`RETURN ${ev.name} -> (no frame) value=${ev.value}`);\n    } else {\n      if(top.id !== ev.id){\n        // unexpected but handle gracefully: try to find and remove\n        const idx = stack.findIndex(f=>f.id===ev.id);\n        if(idx>=0){\n          stack.splice(idx,1);\n          log(`RETURN ${ev.name} (found non-top frame #${ev.id}) value=${ev.value}`);\n        } else {\n          log(`RETURN ${ev.name} (frame not found) value=${ev.value}`);\n        }\n      } else {\n        log(`RETURN ${ev.name} -> value=${JSON.stringify(ev.value)} (popped #${ev.id})`);\n      }\n    }\n    renderStack();\n  }\n\n  function drawSegment(s){\n    ctx.beginPath();\n    ctx.moveTo(s.x1, s.y1);\n    ctx.lineTo(s.x2, s.y2);\n    ctx.strokeStyle = s.color || '#9ee7ff';\n    ctx.lineWidth = Math.max(1, s.width || 1);\n    ctx.lineCap = 'round';\n    ctx.stroke();\n  }\n\n  function processEvent(ev){\n    // ev: {type:'call'|'return'|'draw'|'memo', ...}\n    if(ev.type === 'call'){\n      pushFrame(ev);\n    } else if(ev.type === 'return'){\n      popFrame(ev);\n      if(ev.finalResult !== undefined){\n        // some generators attach final result metadata\n        resultEl.textContent = JSON.stringify(ev.finalResult);\n      } else {\n        // update result element with latest return value when stack is empty\n        if(stack.length === 0){\n          resultEl.textContent = JSON.stringify(ev.value);\n        }\n      }\n    } else if(ev.type === 'draw'){\n      drawSegment(ev.seg);\n      log(`DRAW segment depth=${ev.depth} at id#${ev.id}`);\n    } else if(ev.type === 'memo'){\n      log(`MEMO HIT for ${ev.name}(${ev.args.join(',')}) => value=${ev.value}`);\n    }\n  }\n\n  function play(){\n    if(playing) return;\n    playing = true;\n    playBtn.disabled = true;\n    stepBtn.disabled = true;\n    pauseBtn.disabled = false;\n    const runStep = ()=>{\n      if(playIdx >= events.length){\n        stop();\n        return;\n      }\n      processEvent(events[playIdx++]);\n      if(playIdx >= events.length){\n        stop();\n      } else {\n        timer = setTimeout(runStep, stepDelay);\n      }\n    };\n    timer = setTimeout(runStep, 0);\n  }\n\n  function stop(){\n    playing = false;\n    playBtn.disabled = false;\n    stepBtn.disabled = false;\n    pauseBtn.disabled = true;\n    if(timer) { clearTimeout(timer); timer = null; }\n    // if finished, ensure displayed result updated\n    if(playIdx >= events.length){\n      // find last return with value\n      for(let i = events.length-1; i>=0; i--){\n        if(events[i].type === 'return' && events[i].value !== undefined){\n          resultEl.textContent = JSON.stringify(events[i].value);\n          break;\n        }\n      }\n    }\n  }\n\n  function step(){\n    if(playIdx >= events.length){\n      stop();\n      return;\n    }\n    processEvent(events[playIdx++]);\n    if(playIdx >= events.length){\n      stop();\n    }\n  }\n\n  // event generators for examples\n  function makeId(){ return idCounter++; }\n\n  function genFactorial(n){\n    events = [];\n    idCounter = 1;\n    function rec(k){\n      const id = makeId();\n      events.push({type:'call', id, name:'fact', args:[k]});\n      if(k <= 1){\n        events.push({type:'return', id, name:'fact', args:[k], value:1});\n        return 1;\n      } else {\n        const v = rec(k-1);\n        const result = k * v;\n        events.push({type:'return', id, name:'fact', args:[k], value:result});\n        return result;\n      }\n    }\n    const res = rec(n);\n    // mark last return as finalResult for UI convenience\n    if(events.length){\n      events[events.length-1].finalResult = res;\n    }\n    return events;\n  }\n\n  function genFibNaive(n){\n    events = [];\n    idCounter = 1;\n    function rec(k){\n      const id = makeId();\n      events.push({type:'call', id, name:'fib', args:[k]});\n      if(k <= 1){\n        events.push({type:'return', id, name:'fib', args:[k], value:k});\n        return k;\n      } else {\n        const a = rec(k-1);\n        const b = rec(k-2);\n        const res = a + b;\n        events.push({type:'return', id, name:'fib', args:[k], value:res});\n        return res;\n      }\n    }\n    const res = rec(n);\n    if(events.length) events[events.length-1].finalResult = res;\n    return events;\n  }\n\n  function genFibMemo(n){\n    events = [];\n    idCounter = 1;\n    const memo = new Map();\n    function rec(k){\n      const id = makeId();\n      events.push({type:'call', id, name:'fibMemo', args:[k]});\n      if(memo.has(k)){\n        const v = memo.get(k);\n        events.push({type:'memo', id, name:'fibMemo', args:[k], value:v});\n        events.push({type:'return', id, name:'fibMemo', args:[k], value:v});\n        return v;\n      }\n      if(k <= 1){\n        memo.set(k,k);\n        events.push({type:'return', id, name:'fibMemo', args:[k], value:k});\n        return k;\n      } else {\n        const a = rec(k-1);\n        const b = rec(k-2);\n        const res = a + b;\n        memo.set(k,res);\n        events.push({type:'return', id, name:'fibMemo', args:[k], value:res});\n        return res;\n      }\n    }\n    const res = rec(n);\n    if(events.length) events[events.length-1].finalResult = res;\n    return events;\n  }\n\n  function genFractalTree(depth){\n    events = [];\n    idCounter = 1;\n    // parameters to control shape\n    const startX = canvas.width/2;\n    const startY = canvas.height - 20;\n    const initialLength = Math.min(canvas.height, canvas.width) * 0.18;\n    const branchAngle = Math.PI/6; // 30deg\n    const scale = 0.72;\n\n    function rec(d, x, y, angle, length){\n      const id = makeId();\n      events.push({type:'call', id, name:'branch', args:[d], depth:d});\n      // compute endpoint\n      const x2 = x + Math.cos(angle) * length;\n      const y2 = y - Math.sin(angle) * length;\n      const width = Math.max(1, d/2 + 1);\n      const color = d < 2 ? '#d8ffd6' : (d < 5 ? '#9ee7ff' : '#7fb5ff');\n      events.push({type:'draw', id, name:'branch', depth:d, seg:{x1:x,y1:y,x2:x2,y2:y2,color:color,width:width}});\n      if(d > 0){\n        rec(d-1, x2, y2, angle - branchAngle, length * scale);\n        rec(d-1, x2, y2, angle + branchAngle, length * scale);\n      }\n      events.push({type:'return', id, name:'branch', args:[d], value:null});\n    }\n\n    rec(depth, startX, startY, Math.PI/2, initialLength);\n    return events;\n  }\n\n  // UI wiring\n  function updateParamLabel(){\n    const ex = exampleEl.value;\n    if(ex === 'fractal_tree'){\n      paramLabel.textContent = 'depth';\n      paramEl.min = 0;\n      paramEl.max = 12;\n      paramEl.value = Math.min(8, Math.max(0, parseInt(paramEl.value||5)));\n    } else {\n      paramLabel.textContent = 'n';\n      paramEl.min = 0;\n      paramEl.max = (ex === 'fib_naive') ? 12 : 24;\n      if(ex === 'fib_naive' && paramEl.value > 12) paramEl.value = 12;\n    }\n    // update code snippet\n    if(ex === 'factorial'){\n      setCode(`function fact(n) {\\n  if (n <= 1) return 1;\\n  return n * fact(n-1);\\n}`);\n    } else if(ex === 'fib_naive'){\n      setCode(`function fib(n) {\\n  if (n <= 1) return n;\\n  return fib(n-1) + fib(n-2);  // two recursive calls\\n}`);\n    } else if(ex === 'fib_memo'){\n      setCode(`function fibMemo(n, memo={}) {\\n  if (n in memo) return memo[n];\\n  if (n <= 1) return n;\\n  memo[n] = fibMemo(n-1,memo) + fibMemo(n-2,memo);\\n  return memo[n];\\n}`);\n    } else if(ex === 'fractal_tree'){\n      setCode(`function branch(depth, x, y, angle, length) {\\n  drawLine(x,y,x2,y2);\\n  if (depth > 0) {\\n    branch(depth-1, x2, y2, angle-θ, length*scale);\\n    branch(depth-1, x2, y2, angle+θ, length*scale);\\n  }\\n}`);\n    }\n  }\n\n  exampleEl.addEventListener('change', ()=>{\n    updateParamLabel();\n  });\n\n  speedEl.addEventListener('input', ()=>{\n    stepDelay = parseInt(speedEl.value,10);\n    speedVal.textContent = `${stepDelay} ms / step`;\n  });\n\n  resetBtn.addEventListener('click', ()=>{\n    events = [];\n    playIdx = 0;\n    stack = [];\n    playing = false;\n    if(timer) { clearTimeout(timer); timer = null; }\n    clearCanvas();\n    logEl.innerHTML = '';\n    stackEl.innerHTML = '';\n    resultEl.textContent = '—';\n    playBtn.disabled = false;\n    stepBtn.disabled = false;\n    pauseBtn.disabled = true;\n    idCounter = 1;\n  });\n\n  generateBtn.addEventListener('click', ()=>{\n    resetBtn.click();\n    const ex = exampleEl.value;\n    const n = Math.max(0, Math.floor(Number(paramEl.value) || 0));\n    // safety caps\n    if(ex === 'fib_naive' && n > 12){\n      alert('Naive Fibonacci grows exponentially — choose n ≤ 12.');\n      return;\n    }\n    if(ex === 'fractal_tree' && n > 12){\n      alert('High fractal depth may be slow; choose depth ≤ 12.');\n      return;\n    }\n\n    clearCanvas();\n    logEl.innerHTML = '';\n    stackEl.innerHTML = '';\n    resultEl.textContent = '—';\n    idCounter = 1;\n\n    if(ex === 'factorial'){\n      events = genFactorial(n);\n    } else if(ex === 'fib_naive'){\n      events = genFibNaive(n);\n    } else if(ex === 'fib_memo'){\n      events = genFibMemo(n);\n    } else if(ex === 'fractal_tree'){\n      events = genFractalTree(n);\n    }\n    playIdx = 0;\n    log(`Generated ${events.length} events for ${ex}(${n}).`);\n    // pre-draw background only; actual draw events will render during playback\n    clearCanvas();\n  });\n\n  playBtn.addEventListener('click', ()=>play());\n  pauseBtn.addEventListener('click', ()=>stop());\n  stepBtn.addEventListener('click', ()=>step());\n\n  // initialize\n  updateParamLabel();\n  clearCanvas();\n  pauseBtn.disabled = true;\n  setCode('// Choose an example and click \"Generate Trace\" to begin.');\n\n  // helpful demo: auto-generate factorial(6) initially\n  setTimeout(()=>{ exampleEl.value = 'factorial'; updateParamLabel(); paramEl.value = 6; generateBtn.click(); }, 400);\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Recursion"
    }
  ],
  "topic": "Recursion",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}