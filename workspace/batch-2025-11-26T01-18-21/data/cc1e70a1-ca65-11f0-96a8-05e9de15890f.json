{
  "id": "cc1e70a1-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:22:05.069Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Kruskal's Algorithm Visualizer</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<style>\n  :root{\n    --bg: #0f1724;\n    --card: #0b1220;\n    --muted: #93a2c3;\n    --accent: #3ddc97;\n    --danger: #ff6b6b;\n    --panel: #071022;\n    --glass: rgba(255,255,255,0.03);\n  }\n  html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;}\n  body{background: linear-gradient(180deg,#071028 0%, #071026 60%, #071827 100%); color:#e6eef8; display:flex; align-items:stretch;}\n  .app{display:flex;flex:1;gap:12px;padding:16px;box-sizing:border-box;}\n  .left{flex:1; background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border-radius:8px; padding:12px; display:flex; flex-direction:column; min-width:0;}\n  .canvas-wrap{flex:1; position:relative; border-radius:6px; background:var(--panel); overflow:hidden; box-shadow: 0 4px 20px rgba(2,6,23,0.6); border:1px solid rgba(255,255,255,0.03);}\n  svg{width:100%;height:100%; display:block; touch-action:none; cursor:default;}\n  .controls{display:flex; gap:8px; margin:8px 0; align-items:center; flex-wrap:wrap;}\n  button, input[type=number], select{background:var(--glass); border:1px solid rgba(255,255,255,0.04); color:var(--muted); padding:8px 10px; border-radius:6px;}\n  button.primary{background:linear-gradient(90deg,#1fa67a,#39d98f); color:#04221a; border:0; font-weight:600;}\n  .panel{width:360px; background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border-radius:8px; padding:12px; box-sizing:border-box; border:1px solid rgba(255,255,255,0.03); display:flex; flex-direction:column;}\n  .section{margin-bottom:12px;}\n  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px;}\n  .list{background:rgba(255,255,255,0.02); border-radius:6px; padding:8px; max-height:280px; overflow:auto;}\n  .edge-item{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:6px;border-radius:6px;}\n  .edge-item.pending{color:#cbd9f1;}\n  .edge-item.accepted{color:var(--accent);}\n  .edge-item.rejected{color:var(--danger);}\n  .footer{display:flex; gap:8px; align-items:center; margin-top:auto;}\n  .legend{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}\n  .dot{width:12px;height:12px;border-radius:50%;}\n  .info{font-size:13px;color:var(--muted);}\n  .big{font-size:18px;color:#dff6e9;font-weight:600;}\n  .node-label{font-size:12px; fill:#04121b; pointer-events:none; font-weight:700;}\n  .edge-weight{font-size:12px; fill:#cbe6e6; pointer-events:none;}\n  .btn-row{display:flex; gap:6px; align-items:center; flex-wrap:wrap;}\n  .hint{font-size:12px;color:var(--muted); margin-top:6px;}\n  .small{font-size:12px;color:var(--muted);}\n  .control-bar{display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap;}\n  .status{font-size:13px;color:var(--muted);}\n  .topbar{display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:8px;}\n  .title{font-weight:700; font-size:16px;}\n  .muted{color:var(--muted);}\n  input[type=range]{width:120px;}\n  a{color:var(--accent); text-decoration:none;}\n  .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.03); color:var(--muted); padding:6px 8px;border-radius:6px;}\n  .selected-edge { stroke-width:6px !important; }\n  .accepted-edge { stroke: #3ddc97 !important; opacity:0.95; }\n  .rejected-edge { stroke: #ff6b6b !important; opacity:0.5; stroke-dasharray:6 6; }\n  .normal-edge { stroke: #9fb4d6; opacity:0.45; }\n  .node-circle{ cursor:grab; stroke:#062432; stroke-width:2px; }\n  .node-circle:active{ cursor:grabbing; }\n  .node-label-bg{ fill:transparent; }\n  .help{font-size:12px;color:var(--muted); margin-top:8px;}\n  /* scrollbar */\n  .list::-webkit-scrollbar { height:6px; width:8px; }\n  .list::-webkit-scrollbar-thumb { background:rgba(255,255,255,0.04); border-radius:8px;}\n  .list::-webkit-scrollbar-track{ background:transparent; }\n</style>\n</head>\n<body>\n<div class=\"app\">\n  <div class=\"left\">\n    <div class=\"topbar\">\n      <div>\n        <div class=\"title\">Kruskal's Algorithm Visualizer</div>\n        <div class=\"muted\" style=\"font-size:13px;\">Step through Kruskal's MST algorithm. Create or randomize graphs, drag nodes, add weighted edges.</div>\n      </div>\n      <div class=\"status\" id=\"status\">Ready</div>\n    </div>\n\n    <div class=\"controls\">\n      <button id=\"addNodeBtn\">Add Node</button>\n      <button id=\"addEdgeBtn\">Add Edge</button>\n      <button id=\"randomBtn\">Random Graph</button>\n      <button id=\"clearBtn\">Clear</button>\n\n      <div style=\"margin-left:auto; display:flex; gap:8px; align-items:center;\">\n        <button id=\"runBtn\" class=\"primary\">Run Kruskal</button>\n        <button id=\"stepBtn\">Step</button>\n        <button id=\"backBtn\">Back</button>\n        <button id=\"autoBtn\">Auto</button>\n      </div>\n    </div>\n\n    <div class=\"canvas-wrap\" id=\"canvasWrap\">\n      <svg id=\"svg\"></svg>\n    </div>\n\n    <div style=\"display:flex; gap:12px; margin-top:8px; align-items:center;\">\n      <div class=\"small\">Speed</div>\n      <input type=\"range\" id=\"speedRange\" min=\"100\" max=\"2000\" step=\"50\" value=\"700\">\n      <div class=\"small\">|  Highlight: <span id=\"highlightMode\">Edge</span></div>\n    </div>\n\n    <div class=\"help\">\n      Controls: Add Node -> click anywhere on canvas to place. Add Edge -> click two nodes. Drag nodes to move. Click an edge to edit weight. The sorted edge list is shown in the right panel. Use Run/Step/Auto to execute Kruskal.\n    </div>\n  </div>\n\n  <div class=\"panel\">\n    <div class=\"section\">\n      <label>Graph Controls</label>\n      <div style=\"display:flex; gap:8px; align-items:center;\">\n        <label>Nodes: <input id=\"nodeCountInput\" type=\"number\" value=\"6\" min=\"2\" style=\"width:64px\"></label>\n        <label>Edges: <input id=\"edgeCountInput\" type=\"number\" value=\"10\" min=\"1\" style=\"width:64px\"></label>\n        <label>Max weight: <input id=\"maxWeightInput\" type=\"number\" value=\"20\" min=\"1\" style=\"width:64px\"></label>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <label>Kruskal Controls</label>\n      <div class=\"btn-row\">\n        <button id=\"resetAlgoBtn\">Reset Algorithm</button>\n        <button id=\"shuffleBtn\">Shuffle Edge Order</button>\n        <button id=\"autoUnionBtn\" class=\"btn-ghost\">Show Unions</button>\n      </div>\n      <div class=\"hint\" id=\"algoHint\">MST weight: <span id=\"mstWeight\">0</span> — Edges in MST: <span id=\"mstCount\">0</span> / <span id=\"needCount\">0</span></div>\n    </div>\n\n    <div class=\"section\">\n      <label>Edges (sorted by weight)</label>\n      <div class=\"list\" id=\"edgeList\"></div>\n    </div>\n\n    <div class=\"section\">\n      <label>Execution Log</label>\n      <div class=\"list\" id=\"logList\" style=\"max-height:140px;\"></div>\n    </div>\n\n    <div class=\"footer\">\n      <div class=\"legend\">\n        <div style=\"display:flex; align-items:center; gap:6px;\"><div class=\"dot\" style=\"background:#9fb4d6\"></div><div class=\"small\">unselected</div></div>\n        <div style=\"display:flex; align-items:center; gap:6px;\"><div class=\"dot\" style=\"background:#3ddc97\"></div><div class=\"small\">accepted</div></div>\n        <div style=\"display:flex; align-items:center; gap:6px;\"><div class=\"dot\" style=\"background:#ff6b6b\"></div><div class=\"small\">rejected</div></div>\n      </div>\n      <div style=\"margin-left:auto;\">\n        <div class=\"small\">Built for learning — Interactive demo</div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<script>\n/*\n  Kruskal's Algorithm Visualizer\n  - Single-file interactive demo\n  - Uses SVG for drawing graph\n  - Supports creating nodes, adding edges, editing weights\n  - Step-through Kruskal: sorted edges, union-find, accept/reject edges, build MST\n  - Auto-run with adjustable speed, back/forward steps via snapshots\n*/\n\n// ---------- Utility ----------\nfunction $(id){ return document.getElementById(id); }\nfunction clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }\nfunction randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }\nfunction deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }\n\n// Color generator for components\nfunction colorForIndex(i){\n  // some pleasant colors\n  const palette = [\"#ffb86b\",\"#8be9fd\",\"#ff79c6\",\"#50fa7b\",\"#bd93f9\",\"#f1fa8c\",\"#82aaff\",\"#ff6b6b\",\"#4dd0e1\",\"#c3e88d\"];\n  return palette[i % palette.length];\n}\n\n// ---------- State ----------\nconst svg = $(\"svg\");\nconst canvasWrap = $(\"canvasWrap\");\n\nlet nodes = [];      // {id,x,y,label}\nlet edges = [];      // {id,u,v,weight}\nlet nextNodeId = 0;\nlet nextEdgeId = 0;\n\nlet mode = null;     // \"add-node-click\" or \"add-edge-first\" etc.\nlet addEdgeState = { firstNode: null };\n\nlet dragging = null;\nlet dragOffset = {x:0,y:0};\n\nlet snapshots = [];   // for stepping/back: array of states\nlet currentStep = -1;\nlet running = false;\nlet autoTimer = null;\nlet showUnions = true;\n\n// Algorithm precomputed arrays\nlet sortedEdges = []; // array of edge IDs in sorted order\nlet needEdges = 0;\n\n// ---------- DOM Elements ----------\nconst addNodeBtn = $(\"addNodeBtn\");\nconst addEdgeBtn = $(\"addEdgeBtn\");\nconst randomBtn = $(\"randomBtn\");\nconst clearBtn = $(\"clearBtn\");\nconst runBtn = $(\"runBtn\");\nconst stepBtn = $(\"stepBtn\");\nconst backBtn = $(\"backBtn\");\nconst autoBtn = $(\"autoBtn\");\nconst resetAlgoBtn = $(\"resetAlgoBtn\");\nconst shuffleBtn = $(\"shuffleBtn\");\nconst autoUnionBtn = $(\"autoUnionBtn\");\nconst speedRange = $(\"speedRange\");\n\nconst nodeCountInput = $(\"nodeCountInput\");\nconst edgeCountInput = $(\"edgeCountInput\");\nconst maxWeightInput = $(\"maxWeightInput\");\n\nconst edgeListEl = $(\"edgeList\");\nconst logListEl = $(\"logList\");\n\nconst statusEl = $(\"status\");\nconst mstWeightEl = $(\"mstWeight\");\nconst mstCountEl = $(\"mstCount\");\nconst needCountEl = $(\"needCount\");\n\n// ---------- SVG elements pool ----------\nconst edgeGroup = document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\");\nconst nodeGroup = document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\");\nsvg.appendChild(edgeGroup);\nsvg.appendChild(nodeGroup);\n\n// ---------- Union-Find ----------\nclass UnionFind {\n  constructor(n){\n    this.parent = Array.from({length:n}, (_,i)=>i);\n    this.rank = Array(n).fill(0);\n  }\n  find(a){\n    if(this.parent[a] !== a) this.parent[a] = this.find(this.parent[a]);\n    return this.parent[a];\n  }\n  union(a,b){\n    let ra = this.find(a), rb = this.find(b);\n    if(ra === rb) return false;\n    if(this.rank[ra] < this.rank[rb]) this.parent[ra] = rb;\n    else if(this.rank[rb] < this.rank[ra]) this.parent[rb] = ra;\n    else { this.parent[rb] = ra; this.rank[ra]++; }\n    return true;\n  }\n}\n\n// ---------- Graph Rendering ----------\nfunction render(){\n  // clear\n  while(edgeGroup.firstChild) edgeGroup.removeChild(edgeGroup.firstChild);\n  while(nodeGroup.firstChild) nodeGroup.removeChild(nodeGroup.firstChild);\n\n  // draw edges under nodes\n  edges.forEach(e => {\n    const u = nodes.find(n=>n.id===e.u), v = nodes.find(n=>n.id===e.v);\n    if(!u || !v) return;\n    const line = document.createElementNS(\"http://www.w3.org/2000/svg\",\"line\");\n    line.setAttribute(\"x1\",u.x); line.setAttribute(\"y1\",u.y);\n    line.setAttribute(\"x2\",v.x); line.setAttribute(\"y2\",v.y);\n    line.setAttribute(\"stroke-linecap\",\"round\");\n    line.setAttribute(\"stroke-width\",\"3\");\n    line.classList.add(\"edge-line\");\n    line.dataset.edgeId = e.id;\n    line.classList.add(\"normal-edge\");\n\n    // click to edit weight\n    line.addEventListener(\"click\", (evt)=>{\n      evt.stopPropagation();\n      const w = prompt(\"Edge weight:\", String(e.weight));\n      if(w === null) return;\n      const nw = parseFloat(w);\n      if(!isNaN(nw)){\n        e.weight = nw;\n        prepareAlgorithm(); // resort edges\n        render();\n        updateEdgeList();\n      }\n    });\n\n    edgeGroup.appendChild(line);\n\n    // weight label\n    const midx = (u.x+v.x)/2, midy = (u.y+v.y)/2;\n    const bg = document.createElementNS(\"http://www.w3.org/2000/svg\",\"rect\");\n    bg.setAttribute(\"x\", midx-12); bg.setAttribute(\"y\", midy-14);\n    bg.setAttribute(\"width\", 24); bg.setAttribute(\"height\", 20);\n    bg.setAttribute(\"rx\", 4); bg.setAttribute(\"ry\",4);\n    bg.setAttribute(\"fill\", \"rgba(2,8,18,0.7)\");\n    bg.setAttribute(\"stroke\", \"rgba(255,255,255,0.02)\");\n    bg.setAttribute(\"pointer-events\",\"none\");\n    edgeGroup.appendChild(bg);\n\n    const text = document.createElementNS(\"http://www.w3.org/2000/svg\",\"text\");\n    text.setAttribute(\"x\", midx); text.setAttribute(\"y\", midy);\n    text.setAttribute(\"text-anchor\",\"middle\");\n    text.setAttribute(\"alignment-baseline\",\"middle\");\n    text.setAttribute(\"class\",\"edge-weight\");\n    text.textContent = e.weight;\n    edgeGroup.appendChild(text);\n  });\n\n  // draw nodes on top\n  nodes.forEach((n, idx) => {\n    const g = document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\");\n    g.setAttribute(\"transform\", `translate(${n.x},${n.y})`);\n    g.classList.add(\"node-g\");\n    g.dataset.nodeId = n.id;\n\n    const circle = document.createElementNS(\"http://www.w3.org/2000/svg\",\"circle\");\n    circle.setAttribute(\"r\", 18);\n    circle.setAttribute(\"cx\", 0);\n    circle.setAttribute(\"cy\", 0);\n    circle.setAttribute(\"fill\",\"#dff6e9\"); // default faded, will color by component during run\n    circle.classList.add(\"node-circle\");\n    circle.style.fill = \"#9fb4d6\"; // default\n    g.appendChild(circle);\n\n    const label = document.createElementNS(\"http://www.w3.org/2000/svg\",\"text\");\n    label.setAttribute(\"x\",0); label.setAttribute(\"y\",2);\n    label.setAttribute(\"text-anchor\",\"middle\");\n    label.setAttribute(\"alignment-baseline\",\"middle\");\n    label.setAttribute(\"class\",\"node-label\");\n    label.textContent = n.label;\n    g.appendChild(label);\n\n    // events\n    g.addEventListener(\"mousedown\", (evt)=>{\n      evt.stopPropagation();\n      dragging = n;\n      const pt = getMousePosition(evt);\n      dragOffset.x = n.x - pt.x;\n      dragOffset.y = n.y - pt.y;\n    });\n    g.addEventListener(\"touchstart\", (evt)=>{\n      evt.stopPropagation();\n      const t = evt.touches[0];\n      dragging = n;\n      const pt = getMousePosition(t);\n      dragOffset.x = n.x - pt.x;\n      dragOffset.y = n.y - pt.y;\n    });\n\n    nodeGroup.appendChild(g);\n  });\n\n  // update edge classes based on algorithm state\n  updateVisualState();\n}\n\n// ---------- Interaction helpers ----------\nfunction getSVGPoint(evt){\n  const rect = svg.getBoundingClientRect();\n  return {\n    x: evt.clientX - rect.left,\n    y: evt.clientY - rect.top\n  };\n}\nfunction getMousePosition(evt){\n  if(evt.clientX !== undefined) return getSVGPoint(evt);\n  if(evt.touches && evt.touches[0]) return getSVGPoint(evt.touches[0]);\n  return {x:0,y:0};\n}\n\n// click on canvas for placing nodes or starting edge\nsvg.addEventListener(\"click\", (evt)=>{\n  if(mode === \"add-node-click\"){\n    const pt = getMousePosition(evt);\n    addNode(pt.x, pt.y);\n    mode = null;\n    addNodeBtn.classList.remove(\"active\");\n    setStatus(\"Node added.\");\n  } else if(mode === \"add-edge\"){\n    // clicking background cancels\n    addEdgeState.firstNode = null;\n    mode = null;\n    addEdgeBtn.classList.remove(\"active\");\n    setStatus(\"Add edge cancelled.\");\n  }\n});\n\nsvg.addEventListener(\"mousemove\", (evt)=>{\n  if(dragging){\n    const pt = getMousePosition(evt);\n    dragging.x = clamp(pt.x + dragOffset.x, 30, svg.clientWidth - 30);\n    dragging.y = clamp(pt.y + dragOffset.y, 30, svg.clientHeight - 30);\n    render();\n    updateEdgeList();\n  }\n});\nsvg.addEventListener(\"mouseup\", ()=>{ dragging = null; });\nsvg.addEventListener(\"mouseleave\", ()=>{ dragging = null; });\nsvg.addEventListener(\"touchmove\", (evt)=>{\n  if(dragging){\n    const pt = getMousePosition(evt.touches[0]);\n    dragging.x = clamp(pt.x + dragOffset.x, 30, svg.clientWidth - 30);\n    dragging.y = clamp(pt.y + dragOffset.y, 30, svg.clientHeight - 30);\n    render();\n    updateEdgeList();\n  }\n});\nsvg.addEventListener(\"touchend\", ()=>{ dragging = null; });\n\n// detect clicks on node elements for edge creation\nnodeGroup.addEventListener(\"click\", (evt)=>{\n  const g = evt.target.closest(\".node-g\");\n  if(!g) return;\n  const nid = parseInt(g.dataset.nodeId);\n  if(mode === \"add-edge\"){\n    if(addEdgeState.firstNode == null){\n      addEdgeState.firstNode = nid;\n      setStatus(\"Select second node for edge.\");\n    } else if(addEdgeState.firstNode === nid){\n      setStatus(\"Can't connect node to itself. Choose another node or cancel.\");\n    } else {\n      const w = prompt(\"Edge weight:\", \"1\");\n      if(w === null) {\n        setStatus(\"Edge creation cancelled.\");\n        addEdgeState.firstNode = null;\n        mode = null;\n        addEdgeBtn.classList.remove(\"active\");\n        return;\n      }\n      const weight = parseFloat(w);\n      if(isNaN(weight)) {\n        setStatus(\"Invalid weight. Edge not created.\");\n        addEdgeState.firstNode = null;\n        mode = null;\n        addEdgeBtn.classList.remove(\"active\");\n        return;\n      }\n      addEdge(addEdgeState.firstNode, nid, weight);\n      addEdgeState.firstNode = null;\n      mode = null;\n      addEdgeBtn.classList.remove(\"active\");\n      setStatus(\"Edge added.\");\n    }\n  }\n});\n\n// add node programmatically\nfunction addNode(x, y){\n  const id = nextNodeId++;\n  nodes.push({id:id, x:x, y:y, label: String(id)});\n  prepareAlgorithm();\n  render();\n  updateEdgeList();\n}\n\n// add edge\nfunction addEdge(u,v,weight){\n  // avoid duplicates: if same endpoints exist (either order), allow but warn? We'll allow duplicates.\n  const id = nextEdgeId++;\n  edges.push({id:id, u:u, v:v, weight:weight});\n  prepareAlgorithm();\n  render();\n  updateEdgeList();\n}\n\n// remove all\nfunction clearGraph(){\n  nodes = []; edges = []; nextNodeId = 0; nextEdgeId = 0;\n  snapshots = []; currentStep = -1;\n  running = false; stopAuto();\n  setStatus(\"Cleared graph.\");\n  prepareAlgorithm();\n  render();\n  updateEdgeList();\n  updateLog();\n}\n\n// random graph generator\nfunction randomGraph(n, m, maxW){\n  clearGraph();\n  const w = svg.clientWidth, h = svg.clientHeight;\n  for(let i=0;i<n;i++){\n    const theta = (i/n)*Math.PI*2;\n    const x = w/2 + (Math.min(w,h)/2 - 80) * Math.cos(theta) * (0.7 + Math.random()*0.6);\n    const y = h/2 + (Math.min(w,h)/2 - 80) * Math.sin(theta) * (0.7 + Math.random()*0.6);\n    addNode(x,y);\n  }\n  const nodeIds = nodes.map(n=>n.id);\n  // ensure connectivity by creating a random spanning tree first\n  const shuffled = nodeIds.slice().sort(()=>Math.random()-0.5);\n  for(let i=1;i<shuffled.length;i++){\n    const u = shuffled[i];\n    const v = shuffled[randInt(0,i-1)];\n    addEdge(u,v, randInt(1, maxW));\n  }\n  // add random extra edges\n  let attempts = 0;\n  while(edges.length < m && attempts < m*6){\n    const a = nodeIds[randInt(0,n-1)];\n    const b = nodeIds[randInt(0,n-1)];\n    if(a===b){ attempts++; continue; }\n    // avoid identical edge duplicates\n    const exists = edges.find(e => (e.u===a && e.v===b) || (e.u===b && e.v===a));\n    if(exists){ attempts++; continue; }\n    addEdge(a,b, randInt(1, maxW));\n    attempts++;\n  }\n  setStatus(\"Random graph created.\");\n  prepareAlgorithm();\n  render();\n  updateEdgeList();\n}\n\n// ---------- Algorithm Preparation ----------\nfunction prepareAlgorithm(){\n  // compute sortedEdges by [weight, id]\n  sortedEdges = edges.slice().sort((a,b)=>{\n    if(a.weight !== b.weight) return a.weight - b.weight;\n    // tie break by endpoints to ensure deterministic order\n    if(Math.min(a.u,a.v) !== Math.min(b.u,b.v)) return Math.min(a.u,a.v) - Math.min(b.u,b.v);\n    if(Math.max(a.u,a.v) !== Math.max(b.u,b.v)) return Math.max(a.u,a.v) - Math.max(b.u,b.v);\n    return a.id - b.id;\n  }).map(e=>e.id);\n\n  needEdges = Math.max(0, nodes.length - 1);\n  needCountEl.textContent = needEdges;\n\n  // reset snapshots\n  snapshots = [];\n  currentStep = -1;\n  updateLog();\n  updateEdgeList();\n  updateVisualState();\n}\n\n// ---------- Execution (Kruskal Step) ----------\nfunction buildInitialSnapshot(){\n  // snapshot includes: parent, rank, selectedEdges (ids), rejectedEdges (ids), consideredIndex (index in sortedEdges), log\n  const uf = new UnionFind(nodes.length);\n  const mapIdToIdx = nodes.reduce((acc,n,i)=>{ acc[n.id] = i; return acc; }, {});\n  // We'll map node ids to indices 0..n-1 to store UF arrays\n  const parent = Array.from({length:nodes.length}, (_,i)=>i);\n  const rank = Array(nodes.length).fill(0);\n  const snap = {\n    parent: parent,\n    rank: rank,\n    selected: [],\n    rejected: [],\n    considered: -1,\n    log: []\n  };\n  snapshots = [deepCopy(snap)];\n  currentStep = 0;\n}\n\n// Get map from node id to index\nfunction idToIndexMap(){\n  const m = {};\n  nodes.forEach((n,i)=> m[n.id] = i);\n  return m;\n}\n\nfunction stepForward(){\n  if(currentStep === -1){\n    if(nodes.length === 0){ setStatus(\"No nodes to run on.\"); return; }\n    buildInitialSnapshot();\n    setStatus(\"Algorithm started.\");\n    updateVisualState();\n    updateEdgeList();\n    updateLog();\n    updateStats();\n    return;\n  }\n  if(currentStep >= snapshots.length-1){\n    // compute next step from last snapshot\n    const prev = deepCopy(snapshots[snapshots.length-1]);\n    const map = idToIndexMap();\n    const uf = new UnionFind(nodes.length);\n    uf.parent = prev.parent.slice();\n    uf.rank = prev.rank.slice();\n    const consideredIdx = prev.considered + 1;\n    if(consideredIdx >= sortedEdges.length){\n      setStatus(\"Algorithm finished. No more edges.\");\n      return;\n    }\n    const edgeId = sortedEdges[consideredIdx];\n    const edge = edges.find(e=>e.id===edgeId);\n    if(!edge){ setStatus(\"Edge missing.\"); return; }\n    const uidx = map[edge.u], vidx = map[edge.v];\n    const ra = uf.find(uidx), rb = uf.find(vidx);\n    prev.considered = consideredIdx;\n    prev.lastEdge = edgeId;\n    if(ra !== rb){\n      uf.union(uidx, vidx);\n      prev.selected.push(edgeId);\n      prev.log.push(`Accepted edge ${edge.u} - ${edge.v} (w=${edge.weight})`);\n    } else {\n      prev.rejected.push(edgeId);\n      prev.log.push(`Rejected edge ${edge.u} - ${edge.v} (forms cycle)`);\n    }\n    // update parent/rank arrays\n    prev.parent = uf.parent.slice();\n    prev.rank = uf.rank.slice();\n    snapshots.push(deepCopy(prev));\n    currentStep = snapshots.length - 1;\n    updateVisualState();\n    updateEdgeList();\n    updateLog();\n    updateStats();\n  } else {\n    // just move to next snapshot (if stepping after back)\n    currentStep++;\n    updateVisualState();\n    updateEdgeList();\n    updateLog();\n    updateStats();\n  }\n}\n\nfunction stepBack(){\n  if(currentStep <= 0){\n    setStatus(\"At initial state.\");\n    return;\n  }\n  currentStep--;\n  updateVisualState();\n  updateEdgeList();\n  updateLog();\n  updateStats();\n  setStatus(\"Stepped back.\");\n}\n\nfunction resetAlgorithm(){\n  snapshots = [];\n  currentStep = -1;\n  updateVisualState();\n  updateEdgeList();\n  updateLog();\n  updateStats();\n  setStatus(\"Algorithm reset.\");\n}\n\nfunction updateStats(){\n  if(currentStep <= 0){\n    mstWeightEl.textContent = \"0\";\n    mstCountEl.textContent = \"0\";\n    return;\n  }\n  const snap = snapshots[currentStep];\n  let total = 0;\n  snap.selected.forEach(eid => {\n    const e = edges.find(x=>x.id===eid);\n    if(e) total += e.weight;\n  });\n  mstWeightEl.textContent = total;\n  mstCountEl.textContent = snap.selected.length;\n}\n\n// ---------- Visual representation based on snapshot ----------\nfunction updateVisualState(){\n  // color nodes by union-find sets if running; highlight considered edge, accepted, rejected\n  // First reset styles\n  const lines = svg.querySelectorAll(\".edge-line\");\n  lines.forEach(l => {\n    l.classList.remove(\"selected-edge\",\"accepted-edge\",\"rejected-edge\");\n    l.classList.remove(\"normal-edge\");\n    l.classList.add(\"normal-edge\");\n    l.style.stroke = \"\";\n  });\n\n  const nodeGs = svg.querySelectorAll(\".node-g\");\n  nodeGs.forEach(g => {\n    const id = parseInt(g.dataset.nodeId);\n    const circle = g.querySelector(\"circle\");\n    circle.style.fill = \"#9fb4d6\";\n  });\n\n  if(currentStep <= 0 || snapshots.length === 0){\n    return;\n  }\n  const snap = snapshots[currentStep];\n  const map = idToIndexMap();\n  // compute component color mapping\n  const parent = snap.parent;\n  const compMap = {};\n  let idx = 0;\n  nodes.forEach(n => {\n    const i = map[n.id];\n    let p = parent[i];\n    // path compression not necessary; parent array is what we have\n    if(!(p in compMap)){\n      compMap[p] = colorForIndex(idx++);\n    }\n  });\n  // color nodes\n  nodes.forEach(n => {\n    const i = map[n.id];\n    const p = parent[i];\n    const color = compMap[p] || \"#9fb4d6\";\n    const g = svg.querySelector(`.node-g[data-node-id=\"${n.id}\"]`);\n    if(g){\n      const circle = g.querySelector(\"circle\");\n      circle.style.fill = color;\n    }\n  });\n\n  // color edges\n  const acceptedSet = new Set(snap.selected);\n  const rejectedSet = new Set(snap.rejected);\n  const consideredEdgeId = snap.lastEdge !== undefined ? snap.lastEdge : null;\n\n  edges.forEach(e => {\n    const line = svg.querySelector(`.edge-line[data-edge-id=\"${e.id}\"]`);\n    if(!line) return;\n    if(e.id === consideredEdgeId){\n      line.classList.add(\"selected-edge\");\n      if(acceptedSet.has(e.id)){\n        line.classList.add(\"accepted-edge\");\n        line.classList.remove(\"rejected-edge\");\n      } else if(rejectedSet.has(e.id)){\n        line.classList.add(\"rejected-edge\");\n        line.classList.remove(\"accepted-edge\");\n      }\n    } else {\n      if(acceptedSet.has(e.id)){\n        line.classList.add(\"accepted-edge\");\n        line.classList.remove(\"rejected-edge\");\n        line.classList.remove(\"selected-edge\");\n      } else if(rejectedSet.has(e.id)){\n        line.classList.add(\"rejected-edge\");\n        line.classList.remove(\"accepted-edge\");\n        line.classList.remove(\"selected-edge\");\n      } else {\n        // normal edge\n        line.classList.remove(\"accepted-edge\");\n        line.classList.remove(\"rejected-edge\");\n        line.classList.remove(\"selected-edge\");\n      }\n    }\n  });\n\n}\n\n// ---------- UI: Edge list & Log ----------\nfunction updateEdgeList(){\n  edgeListEl.innerHTML = \"\";\n  // create display array with status\n  const idToEdge = edges.reduce((acc,e)=>{ acc[e.id]=e; return acc; }, {});\n  let statusMap = {};\n  if(currentStep > 0 && snapshots[currentStep]){\n    const snap = snapshots[currentStep];\n    snap.selected.forEach(id => statusMap[id] = \"accepted\");\n    snap.rejected.forEach(id => statusMap[id] = \"rejected\");\n    if(snap.lastEdge !== undefined) statusMap[snap.lastEdge] = statusMap[snap.lastEdge] || \"considered\";\n  }\n\n  sortedEdges.forEach((eid, idx)=>{\n    const e = idToEdge[eid];\n    if(!e) return;\n    const div = document.createElement(\"div\");\n    div.className = \"edge-item\";\n    let cls = \"pending\";\n    if(statusMap[eid] === \"accepted\") cls = \"accepted\";\n    else if(statusMap[eid] === \"rejected\") cls = \"rejected\";\n    else if(statusMap[eid] === \"considered\") cls = \"pending\";\n    div.classList.add(cls);\n\n    const left = document.createElement(\"div\");\n    left.textContent = `${e.u} — ${e.v}`;\n    left.style.fontWeight = \"600\";\n    left.style.color = (cls===\"accepted\") ? \"#d4fbe6\" : (cls===\"rejected\") ? \"#ffdede\" : \"#cfe6ff\";\n    const right = document.createElement(\"div\");\n    right.style.display=\"flex\"; right.style.gap=\"8px\"; right.style.alignItems=\"center\";\n\n    const wspan = document.createElement(\"div\");\n    wspan.textContent = `w=${e.weight}`;\n    wspan.style.color = \"#93a2c3\";\n    right.appendChild(wspan);\n\n    const btn = document.createElement(\"button\");\n    btn.textContent = \"Focus\";\n    btn.addEventListener(\"click\", ()=>{\n      // highlight on canvas\n      const line = svg.querySelector(`.edge-line[data-edge-id=\"${e.id}\"]`);\n      if(line){\n        line.scrollIntoView({behavior:\"smooth\", block:\"center\", inline:\"center\"});\n        // quick pulse\n        line.style.transition = \"stroke-width 0.2s\";\n        line.style.strokeWidth = \"8px\";\n        setTimeout(()=> line.style.strokeWidth = \"\", 400);\n      }\n    });\n    right.appendChild(btn);\n\n    div.appendChild(left);\n    div.appendChild(right);\n    edgeListEl.appendChild(div);\n  });\n}\n\nfunction updateLog(){\n  logListEl.innerHTML = \"\";\n  if(currentStep <= 0 || snapshots.length === 0){\n    const p = document.createElement(\"div\");\n    p.className = \"edge-item pending\";\n    p.textContent = \"No steps executed yet.\";\n    logListEl.appendChild(p);\n    return;\n  }\n  const snap = snapshots[currentStep];\n  snap.log.slice(-200).forEach(l=>{\n    const p = document.createElement(\"div\");\n    p.className = \"edge-item\";\n    p.textContent = l;\n    logListEl.appendChild(p);\n  });\n}\n\n// ---------- Controls ----------\naddNodeBtn.addEventListener(\"click\", ()=>{\n  mode = \"add-node-click\";\n  addNodeBtn.classList.add(\"active\");\n  addEdgeBtn.classList.remove(\"active\");\n  setStatus(\"Click on canvas to add a node.\");\n});\naddEdgeBtn.addEventListener(\"click\", ()=>{\n  mode = \"add-edge\";\n  addEdgeBtn.classList.add(\"active\");\n  addNodeBtn.classList.remove(\"active\");\n  addEdgeState.firstNode = null;\n  setStatus(\"Click first node to start edge creation.\");\n});\nclearBtn.addEventListener(\"click\", ()=>{ if(confirm(\"Clear graph?\")) clearGraph(); });\nrandomBtn.addEventListener(\"click\", ()=>{\n  const n = parseInt(nodeCountInput.value) || 6;\n  const m = parseInt(edgeCountInput.value) || 10;\n  const maxW = parseInt(maxWeightInput.value) || 20;\n  randomGraph(n,m,maxW);\n});\nrunBtn.addEventListener(\"click\", ()=>{\n  // run until finished\n  if(currentStep === -1) stepForward(); // init\n  running = true;\n  stopAuto();\n  autoTimer = setInterval(()=>{\n    // if finished, stop\n    const lastSnap = snapshots[snapshots.length-1];\n    const consideredIdx = lastSnap ? lastSnap.considered : -1;\n    if(consideredIdx >= sortedEdges.length - 1){\n      stopAuto();\n      running = false;\n      setStatus(\"Algorithm complete.\");\n      return;\n    }\n    stepForward();\n  }, 150);\n  setStatus(\"Running KRUSKAL...\");\n});\nstepBtn.addEventListener(\"click\", ()=>{ stopAuto(); running=false; stepForward(); });\nbackBtn.addEventListener(\"click\", ()=>{ stopAuto(); running=false; stepBack(); });\nautoBtn.addEventListener(\"click\", ()=>{\n  if(autoTimer) { stopAuto(); running=false; autoBtn.textContent=\"Auto\"; setStatus(\"Auto stopped.\"); }\n  else {\n    running = false;\n    autoBtn.textContent=\"Stop\";\n    let delay = parseInt(speedRange.value);\n    autoTimer = setInterval(()=>{ stepForward(); if(snapshots[snapshots.length-1].considered >= sortedEdges.length - 1) { stopAuto(); autoBtn.textContent=\"Auto\"; } }, delay);\n    setStatus(\"Auto stepping...\");\n  }\n});\n\nresetAlgoBtn.addEventListener(\"click\", ()=>{ resetAlgorithm(); });\nshuffleBtn.addEventListener(\"click\", ()=>{\n  // shuffle edges with same weight order randomized, then update sortedEdges\n  edges.sort(()=>Math.random()-0.5);\n  prepareAlgorithm();\n  render();\n  updateEdgeList();\n  setStatus(\"Edges shuffled.\");\n});\nautoUnionBtn.addEventListener(\"click\", ()=>{\n  showUnions = !showUnions;\n  autoUnionBtn.textContent = showUnions ? \"Show Unions\" : \"Hide Unions\";\n});\n\nspeedRange.addEventListener(\"input\", ()=>{\n  if(autoTimer){\n    stopAuto();\n    autoTimer = setInterval(()=>{ stepForward(); }, parseInt(speedRange.value));\n  }\n});\n\nfunction stopAuto(){\n  if(autoTimer){ clearInterval(autoTimer); autoTimer = null; autoBtn.textContent=\"Auto\"; }\n}\n\n// ---------- Status ----------\nfunction setStatus(s){\n  statusEl.textContent = s;\n}\n\n// ---------- Initialization ----------\nfunction initSample(){\n  // create a sample graph\n  clearGraph();\n  const w = svg.clientWidth, h = svg.clientHeight;\n  const coords = [\n    {x: w*0.25, y: h*0.28},\n    {x: w*0.67, y: h*0.2},\n    {x: w*0.78, y: h*0.6},\n    {x: w*0.45, y: h*0.78},\n    {x: w*0.18, y: h*0.62},\n    {x: w*0.5, y: h*0.45},\n  ];\n  coords.forEach((c)=> addNode(c.x, c.y));\n  // add some edges\n  addEdge(0,1,4);\n  addEdge(0,5,2);\n  addEdge(1,5,5);\n  addEdge(1,2,6);\n  addEdge(2,5,1);\n  addEdge(2,3,3);\n  addEdge(3,5,7);\n  addEdge(3,4,8);\n  addEdge(4,0,9);\n  addEdge(4,5,4);\n  prepareAlgorithm();\n  render();\n  updateEdgeList();\n  setStatus(\"Sample graph loaded.\");\n}\n\nwindow.addEventListener(\"resize\", ()=>{\n  render();\n});\n\n// initial sample\ninitSample();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}