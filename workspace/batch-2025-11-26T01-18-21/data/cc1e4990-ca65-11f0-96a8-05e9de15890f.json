{
  "id": "cc1e4990-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:01.423Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Breadth-First Search (BFS) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --cell-size: 28px;\n      --grid-gap: 2px;\n      --bg: #111;\n      --panel: #0f1720;\n      --accent: #38bdf8;\n      --muted: #94a3b8;\n    }\n    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;}\n    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071029 0%, #071a2a 100%);color:#e6eef6}\n    .app{\n      display:flex;\n      gap:18px;\n      padding:18px;\n      max-width:1200px;\n      margin:18px auto;\n      align-items:flex-start;\n    }\n    .left{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      padding:12px;\n      border-radius:12px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n    }\n    .grid {\n      display:grid;\n      gap:var(--grid-gap);\n      background:linear-gradient(180deg, #07192a, #04121a);\n      padding:8px;\n      border-radius:8px;\n    }\n    .cell{\n      width:var(--cell-size);\n      height:var(--cell-size);\n      border-radius:6px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-size:11px;\n      color:#032;\n      user-select:none;\n      cursor:pointer;\n      transition:transform 0.08s, box-shadow 0.08s;\n    }\n    .cell:hover{transform:translateY(-3px)}\n    /* cell states */\n    .empty{background:#e6eef610; border:1px solid rgba(230,238,246,0.04)}\n    .wall{background:#000a0f; border:1px solid rgba(255,255,255,0.02)}\n    .start{background:linear-gradient(180deg,#22c55e,#16a34a); color:white; font-weight:700; box-shadow:0 4px 10px rgba(16,185,129,0.12)}\n    .goal{background:linear-gradient(180deg,#ef4444,#dc2626); color:white; font-weight:700; box-shadow:0 4px 10px rgba(239,68,68,0.12)}\n    .visited{background:linear-gradient(180deg,#bfdbfe,#93c5fd); color:#05233f}\n    .frontier{background:linear-gradient(180deg,#ffd580,#ffb86b); color:#3a2b0d}\n    .path{background:linear-gradient(180deg,#facc15,#f59e0b); color:#2a1b00; font-weight:700}\n    /* layout */\n    .controls{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      margin-bottom:10px;\n      flex-wrap:wrap;\n    }\n    .btn{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--muted);\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      transition:all .12s;\n    }\n    .btn:hover{transform:translateY(-2px); color:var(--accent); border-color:rgba(56,189,248,0.14)}\n    .btn.primary{\n      background:linear-gradient(90deg,#0369a1,#0ea5e9);\n      color:white;border:0;box-shadow:0 6px 16px rgba(14,165,233,0.14)\n    }\n    .panel{\n      margin-left:12px;\n      min-width:320px;\n      max-width:380px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:12px;\n      border:1px solid rgba(255,255,255,0.03);\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n    }\n    .row{display:flex;gap:8px;align-items:center;margin-bottom:8px;flex-wrap:wrap}\n    label{font-size:13px;color:var(--muted)}\n    .small{font-size:12px;color:var(--muted)}\n    .muted{color:var(--muted)}\n    .queue{\n      display:flex;\n      gap:6px;\n      align-items:center;\n      flex-wrap:wrap;\n      padding:8px;\n      border-radius:8px;\n      background:linear-gradient(180deg,#04111a,#031018);\n      border:1px solid rgba(255,255,255,0.02);\n      min-height:40px;\n      max-height:140px;\n      overflow:auto;\n    }\n    .badge{\n      padding:6px 8px;\n      background:rgba(255,255,255,0.03);\n      border-radius:8px;\n      font-size:12px;\n      color:var(--muted);\n    }\n    input[type=range]{width:140px}\n    .legend{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n    .legend .sw{width:18px;height:18px;border-radius:4px;display:inline-block;vertical-align:middle}\n    .footer{font-size:12px;color:var(--muted);margin-top:8px}\n    .title{font-weight:700;font-size:18px;margin-bottom:6px}\n    .subtitle{font-size:13px;color:var(--muted);margin-bottom:8px}\n    .hint{font-size:12px;color:var(--muted);margin-top:12px}\n    .mode-btn{padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:var(--muted);cursor:pointer}\n    .mode-btn.active{background:rgba(255,255,255,0.03);color:var(--accent);border-color:rgba(56,189,248,0.08)}\n    .stats{font-size:13px;color:var(--muted);margin-top:8px;border-radius:8px;padding:8px;background:linear-gradient(180deg,#041018,#031116);border:1px solid rgba(255,255,255,0.02)}\n    .control-row{display:flex;gap:6px;align-items:center}\n    /* responsive */\n    @media (max-width:900px){\n      .app{flex-direction:column; padding:12px}\n      .panel{max-width:none;width:100%}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"left\">\n      <div style=\"display:flex;align-items:center;gap:12px;margin-bottom:10px\">\n        <div class=\"title\">BFS Visualizer</div>\n        <div class=\"small muted\">Breadth-First Search (grid)</div>\n      </div>\n\n      <div class=\"controls\">\n        <button id=\"playBtn\" class=\"btn primary\">Play</button>\n        <button id=\"stepBtn\" class=\"btn\">Step</button>\n        <button id=\"resetBtn\" class=\"btn\">Restart</button>\n        <button id=\"randomBtn\" class=\"btn\">Random Walls</button>\n        <button id=\"clearBtn\" class=\"btn\">Clear Walls</button>\n\n        <div style=\"width:12px\"></div>\n\n        <div style=\"display:flex;align-items:center;gap:8px\">\n          <label class=\"small muted\">Speed</label>\n          <input id=\"speedRange\" type=\"range\" min=\"50\" max=\"1000\" value=\"250\">\n        </div>\n      </div>\n\n      <div style=\"display:flex;gap:12px;align-items:center;margin-bottom:10px\">\n        <div style=\"display:flex;gap:6px\">\n          <button class=\"mode-btn active\" id=\"modeWall\">Wall</button>\n          <button class=\"mode-btn\" id=\"modeStart\">Set Start</button>\n          <button class=\"mode-btn\" id=\"modeGoal\">Set Goal</button>\n        </div>\n\n        <div style=\"display:flex;gap:6px;align-items:center\">\n          <label class=\"small muted\">Grid</label>\n          <select id=\"gridSize\">\n            <option value=\"12\">12 x 12</option>\n            <option value=\"16\">16 x 16</option>\n            <option value=\"20\" selected>20 x 20</option>\n            <option value=\"28\">28 x 28</option>\n            <option value=\"36\">36 x 36</option>\n          </select>\n        </div>\n      </div>\n\n      <div id=\"gridContainer\" style=\"display:flex;justify-content:center;align-items:center;\">\n        <!-- grid injected here -->\n      </div>\n\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"subtitle\">Controls & Explanation</div>\n      <div class=\"small muted\">\n        Click cells to toggle walls (Wall mode).\n        Use Set Start / Set Goal and click a cell to place start/goal.\n        Play animates BFS; Step advances one node.\n        BFS explores layer-by-layer (shortest path by steps on unweighted grid).\n      </div>\n\n      <div style=\"margin-top:12px\" class=\"row\">\n        <div class=\"label small muted\">Queue (front -> back)</div>\n      </div>\n      <div id=\"queue\" class=\"queue\"></div>\n\n      <div class=\"row\" style=\"margin-top:8px\">\n        <div style=\"flex:1\">\n          <div class=\"stats\" id=\"stats\">\n            Steps: 0 · Visited: 0 · Queue size: 0 · Shortest distance: N/A\n          </div>\n        </div>\n      </div>\n\n      <div style=\"margin-top:8px\">\n        <div class=\"legend\">\n          <div class=\"sw empty\" style=\"border:1px solid rgba(255,255,255,0.04)\"></div><div class=\"small muted\">Empty</div>\n          <div class=\"sw wall\" style=\"width:18px;height:18px\"></div><div class=\"small muted\">Wall</div>\n          <div class=\"sw start\"></div><div class=\"small muted\">Start</div>\n          <div class=\"sw goal\"></div><div class=\"small muted\">Goal</div>\n          <div class=\"sw visited\"></div><div class=\"small muted\">Visited</div>\n          <div class=\"sw frontier\"></div><div class=\"small muted\">Frontier</div>\n          <div class=\"sw path\"></div><div class=\"small muted\">Final Path</div>\n        </div>\n      </div>\n\n      <div class=\"hint\">\n        Tip: BFS will always find the shortest path (in steps) in this unweighted grid. Walls block movement.\n      </div>\n\n      <div class=\"footer\">\n        Implementation visualizes queue, visited order, parent pointers, and reconstructs shortest path when goal is reached.\n      </div>\n    </div>\n  </div>\n\n<script>\n(function(){\n  // Grid BFS visualizer\n  const gridContainer = document.getElementById('gridContainer');\n  const queueEl = document.getElementById('queue');\n  const statsEl = document.getElementById('stats');\n\n  const playBtn = document.getElementById('playBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const speedRange = document.getElementById('speedRange');\n  const gridSizeSelect = document.getElementById('gridSize');\n\n  const modeWallBtn = document.getElementById('modeWall');\n  const modeStartBtn = document.getElementById('modeStart');\n  const modeGoalBtn = document.getElementById('modeGoal');\n\n  let mode = 'wall'; // wall | start | goal\n\n  // State\n  let rows = 20, cols = 20;\n  let cells = []; // array of divs\n  let grid = []; // 0 empty, 1 wall\n  let start = {r: Math.floor(rows/2), c: Math.floor(cols/4)};\n  let goal = {r: Math.floor(rows/2), c: Math.floor(cols*3/4)};\n\n  // BFS runtime variables\n  let visited = [];\n  let parent = []; // store parent index\n  let q = []; // queue of indices\n  let isRunning = false;\n  let timer = null;\n  let finished = false;\n  let steps = 0;\n  let visitCount = 0;\n  let lastDistance = null;\n\n  // helpers\n  function idx(r,c){ return r*cols + c; }\n  function rc(i){ return {r: Math.floor(i/cols), c: i%cols}; }\n\n  function buildGrid(r,c){\n    rows = r; cols = c;\n    cells = [];\n    grid = new Array(rows*cols).fill(0);\n    visited = new Array(rows*cols).fill(false);\n    parent = new Array(rows*cols).fill(-1);\n    q = [];\n    finished = false;\n    steps = 0;\n    visitCount = 0;\n    lastDistance = null;\n\n    // update CSS grid\n    const gridEl = document.createElement('div');\n    gridEl.className = 'grid';\n    gridEl.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;\n    gridEl.style.gridTemplateRows = `repeat(${rows}, var(--cell-size))`;\n    gridEl.style.width = `${cols*(parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) + 2)}px`;\n\n    gridEl.addEventListener('contextmenu', e => e.preventDefault());\n    for(let r=0;r<rows;r++){\n      for(let c=0;c<cols;c++){\n        const i = idx(r,c);\n        const cell = document.createElement('div');\n        cell.className = 'cell empty';\n        cell.dataset.i = i;\n        cell.title = `${r},${c}`;\n        cell.addEventListener('click', onCellClick);\n        cell.addEventListener('mousedown', e=> {\n          if (mode === 'wall' && e.buttons === 1) dragging = true;\n        });\n        cells.push(cell);\n        gridEl.appendChild(cell);\n      }\n    }\n    gridContainer.innerHTML = '';\n    gridContainer.appendChild(gridEl);\n\n    // place start and goal\n    if (!start || start.r>=rows || start.c>=cols) start = {r: Math.floor(rows/2), c: Math.floor(cols/4)};\n    if (!goal || goal.r>=rows || goal.c>=cols) goal = {r: Math.floor(rows/2), c: Math.floor(cols*3/4)};\n    updateAll();\n    startBFS();\n  }\n\n  // UI mode selection\n  modeWallBtn.onclick = ()=> setMode('wall');\n  modeStartBtn.onclick = ()=> setMode('start');\n  modeGoalBtn.onclick = ()=> setMode('goal');\n  function setMode(m){\n    mode = m;\n    [modeWallBtn, modeStartBtn, modeGoalBtn].forEach(b=>b.classList.remove('active'));\n    if (m==='wall') modeWallBtn.classList.add('active');\n    if (m==='start') modeStartBtn.classList.add('active');\n    if (m==='goal') modeGoalBtn.classList.add('active');\n  }\n\n  // clicking cells\n  let dragging = false;\n  document.addEventListener('mouseup', ()=> dragging = false);\n  function onCellClick(e){\n    const i = Number(this.dataset.i);\n    const {r,c} = rc(i);\n    if (mode === 'wall'){\n      if (isRunning) { toggleWall(i); restartBFS(); } else { toggleWall(i); startBFS(); }\n    } else if (mode === 'start'){\n      if (i === idx(goal.r,goal.c)) return;\n      start = {r,c};\n      if (grid[i]===1) grid[i]=0;\n      if (isRunning) restartBFS(); else startBFS();\n    } else if (mode === 'goal'){\n      if (i === idx(start.r,start.c)) return;\n      goal = {r,c};\n      if (grid[i]===1) grid[i]=0;\n      if (isRunning) restartBFS(); else startBFS();\n    }\n    updateAll();\n  }\n\n  function toggleWall(i){\n    if (i === idx(start.r,start.c) || i === idx(goal.r,goal.c)) return;\n    grid[i] = grid[i] ? 0 : 1;\n    updateCellVisual(i);\n  }\n\n  function updateCellVisual(i){\n    const el = cells[i];\n    el.className = 'cell';\n    if (i === idx(start.r,start.c)){\n      el.classList.add('start');\n      el.textContent = 'S';\n      return;\n    }\n    if (i === idx(goal.r,goal.c)){\n      el.classList.add('goal');\n      el.textContent = 'G';\n      return;\n    }\n    if (grid[i] === 1){\n      el.classList.add('wall');\n      el.textContent = '';\n      return;\n    }\n    // default empty (color overridden by visited/frontier/path)\n    el.classList.add('empty');\n    el.textContent = '';\n  }\n\n  function updateAll(){\n    for(let i=0;i<rows*cols;i++){\n      updateCellVisual(i);\n      // clear other state classes\n      cells[i].classList.remove('visited','frontier','path');\n      cells[i].style.setProperty('--visit-index','');\n      // clear number label (unless start/goal)\n      if (![idx(start.r,start.c), idx(goal.r,goal.c)].includes(i)){\n        // if visited or frontier will be set later\n      }\n    }\n    refreshQueueUI();\n    updateStats();\n  }\n\n  // BFS core\n  function startBFS(){\n    // reset runtime structures\n    visited = new Array(rows*cols).fill(false);\n    parent = new Array(rows*cols).fill(-1);\n    q = [];\n    finished = false;\n    steps = 0;\n    visitCount = 0;\n    lastDistance = null;\n    // start from start cell\n    const s = idx(start.r, start.c);\n    q.push(s);\n    visited[s] = true;\n    parent[s] = -1;\n    visitCount = 1;\n    markFrontier(s);\n    refreshQueueUI();\n    updateStats();\n  }\n\n  function restartBFS(){\n    stop();\n    startBFS();\n    updateAll();\n  }\n\n  function stop(){\n    isRunning = false;\n    if (timer) clearInterval(timer);\n    playBtn.textContent = 'Play';\n    playBtn.classList.remove('active');\n  }\n\n  function play(){\n    if (finished) {\n      // if finished, restart\n      restartBFS();\n    }\n    if (isRunning){\n      stop();\n      return;\n    }\n    isRunning = true;\n    playBtn.textContent = 'Pause';\n    playBtn.classList.add('active');\n    const speed = Number(speedRange.value);\n    timer = setInterval(()=> {\n      const done = step();\n      if (done) stop();\n    }, speed);\n  }\n\n  playBtn.onclick = play;\n  stepBtn.onclick = ()=> {\n    if (!isRunning){\n      const done = step();\n      if (done) stop();\n    } else {\n      // if running, step does nothing\n    }\n  };\n  resetBtn.onclick = ()=> {\n    restartBFS();\n  };\n  randomBtn.onclick = ()=> {\n    randomizeWalls();\n    restartBFS();\n    updateAll();\n  };\n  clearBtn.onclick = ()=> {\n    grid.fill(0);\n    restartBFS();\n    updateAll();\n  };\n\n  gridSizeSelect.onchange = ()=>{\n    const val = Number(gridSizeSelect.value);\n    buildGrid(val,val);\n  };\n\n  speedRange.oninput = ()=> {\n    if (isRunning){\n      clearInterval(timer);\n      timer = setInterval(()=> {\n        const done = step();\n        if (done) stop();\n      }, Number(speedRange.value));\n    }\n  };\n\n  function randomizeWalls(){\n    // random walls with coverage\n    const coverage = 0.23 + Math.random()*0.26; // 0.23 - 0.49\n    for(let i=0;i<rows*cols;i++){\n      grid[i] = Math.random() < coverage ? 1 : 0;\n    }\n    // ensure start/goal are empty\n    grid[idx(start.r,start.c)] = 0;\n    grid[idx(goal.r,goal.c)] = 0;\n  }\n\n  function neighbors(i){\n    const {r,c} = rc(i);\n    const nbrs = [];\n    if (r>0) nbrs.push(idx(r-1,c));\n    if (c>0) nbrs.push(idx(r,c-1));\n    if (c<cols-1) nbrs.push(idx(r,c+1));\n    if (r<rows-1) nbrs.push(idx(r+1,c));\n    return nbrs;\n  }\n\n  function markVisited(i, visitIndex=null){\n    const el = cells[i];\n    if (i === idx(start.r,start.c) || i === idx(goal.r,goal.c)) return;\n    el.classList.remove('empty','frontier','path','wall');\n    el.classList.add('visited');\n    if (visitIndex!=null){\n      el.textContent = visitIndex;\n      el.style.fontSize = '10px';\n    } else {\n      el.textContent = '';\n    }\n  }\n  function markFrontier(i){\n    const el = cells[i];\n    if (i === idx(start.r,start.c) || i === idx(goal.r,goal.c)) return;\n    el.classList.remove('empty','visited','path','wall');\n    el.classList.add('frontier');\n    el.textContent = '';\n  }\n  function markPath(i){\n    const el = cells[i];\n    if (i === idx(start.r,start.c) || i === idx(goal.r,goal.c)) return;\n    el.classList.remove('empty','visited','frontier','wall');\n    el.classList.add('path');\n    el.textContent = '';\n  }\n\n  function refreshQueueUI(){\n    queueEl.innerHTML = '';\n    for(let i=0;i<q.length;i++){\n      const {r,c} = rc(q[i]);\n      const b = document.createElement('div');\n      b.className = 'badge';\n      b.textContent = `${r},${c}`;\n      if (i===0) b.style.border = '1px solid rgba(255,255,255,0.06)';\n      queueEl.appendChild(b);\n    }\n    updateStats();\n  }\n\n  function updateStats(){\n    const qSize = q.length;\n    const sText = `Steps: ${steps} · Visited: ${visitCount} · Queue size: ${qSize} · Shortest distance: ${lastDistance==null ? 'N/A' : lastDistance}`;\n    statsEl.textContent = sText;\n  }\n\n  // BFS step returns true if finished (reached goal or no path)\n  function step(){\n    if (finished) return true;\n    if (q.length === 0){\n      // no path\n      finished = true;\n      updateStats();\n      return true;\n    }\n    const cur = q.shift();\n    steps++;\n    refreshQueueUI();\n    // mark visited (pop from frontier -> visited)\n    if (!visited[cur]){\n      // In our flow visited[cur] should be true when enqueued,\n      // but handle gracefully\n      visited[cur] = true;\n    }\n    // mark visual visited\n    markVisited(cur, visitCount);\n    visitCount++;\n    // check goal\n    if (cur === idx(goal.r,goal.c)){\n      // done! reconstruct path\n      reconstructPath(cur);\n      finished = true;\n      lastDistance = computeDistance(cur);\n      updateStats();\n      return true;\n    }\n    // expand neighbors\n    const nbrs = neighbors(cur);\n    for(const n of nbrs){\n      if (!visited[n] && grid[n] === 0){\n        visited[n] = true;\n        parent[n] = cur;\n        q.push(n);\n        markFrontier(n);\n      }\n    }\n    refreshQueueUI();\n    updateStats();\n    return false;\n  }\n\n  function computeDistance(i){\n    let d = 0;\n    let cur = i;\n    while(parent[cur] !== -1){\n      d++;\n      cur = parent[cur];\n    }\n    return d;\n  }\n\n  function reconstructPath(endIdx){\n    // walk back parents\n    let cur = endIdx;\n    const path = [];\n    while(cur !== -1){\n      path.push(cur);\n      cur = parent[cur];\n    }\n    // path contains end -> start, mark excluding start and goal maybe keep goal\n    for(let k=1;k<path.length-1;k++){\n      markPath(path[k]);\n    }\n    // mark start and goal visually (ensure labels)\n    updateCellVisual(idx(start.r,start.c));\n    updateCellVisual(idx(goal.r,goal.c));\n    lastDistance = path.length - 1;\n    refreshQueueUI();\n    updateStats();\n  }\n\n  // initialize\n  buildGrid(rows,cols);\n\n  // attach keyboard shortcuts\n  document.addEventListener('keydown', (e)=>{\n    if (e.key === ' ') { e.preventDefault(); play(); }\n    if (e.key === 's') stepBtn.click();\n    if (e.key === 'r') resetBtn.click();\n    if (e.key === 'c') clearBtn.click();\n    if (e.key === 'm') { setMode(mode==='wall'?'start':'wall'); }\n  });\n\n  // small improvement: allow dragging to draw walls\n  let mouseDown = false;\n  document.addEventListener('mousedown', ()=> mouseDown = true);\n  document.addEventListener('mouseup', ()=> mouseDown = false);\n  gridContainer.addEventListener('mousemove', (e)=>{\n    if (!mouseDown) return;\n    const cell = e.target.closest('.cell');\n    if (!cell) return;\n    const i = Number(cell.dataset.i);\n    if (mode !== 'wall') return;\n    toggleWall(i);\n    if (isRunning) restartBFS(); else startBFS();\n    updateCellVisual(i);\n  });\n\n  // ensure when clicking play after finished it restarts\n  playBtn.addEventListener('click', ()=>{\n    if (finished){\n      restartBFS();\n    }\n  });\n\n  // make grid responsive to CSS var size for width calculation\n  window.addEventListener('resize', ()=> {\n    const gridEl = gridContainer.querySelector('.grid');\n    if (!gridEl) return;\n    gridEl.style.width = `${cols*(parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) + 2)}px`;\n  });\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}