{
  "id": "cc1d8642-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:23.166Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Union-Find (Disjoint Set)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<title>Union-Find (Disjoint Set) Visualizer</title>\n<style>\n  :root{ --bg:#0f1724; --card:#0b1220; --accent:#38bdf8; --muted:#94a3b8; color-scheme: dark;}\n  body{font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin:0; background:linear-gradient(180deg,#071021 0%, #081428 60%); color:#e6eef6;}\n  .wrap{max-width:1100px;margin:24px auto;padding:20px;}\n  header{display:flex;align-items:center;justify-content:space-between;gap:12px}\n  h1{font-size:20px;margin:0;color:var(--accent)}\n  p.lead{margin:6px 0 0;color:var(--muted);font-size:13px}\n  .controls{display:flex;flex-wrap:wrap;gap:12px;margin-top:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:12px;border-radius:10px}\n  .control-group{display:flex;gap:8px;align-items:center}\n  label{font-size:13px;color:var(--muted)}\n  input[type=range]{accent-color:var(--accent)}\n  button{background:linear-gradient(90deg,#0b1422,#08131a);border:1px solid rgba(255,255,255,0.04);color:#dbeeff;padding:8px 10px;border-radius:8px;cursor:pointer}\n  button.primary{background:linear-gradient(90deg,#06b6d4,#0ea5a4);color:#002126}\n  .canvas-wrap{display:flex;gap:12px;margin-top:14px}\n  canvas{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));border-radius:10px;border:1px solid rgba(255,255,255,0.03)}\n  .sidebar{width:340px;min-width:260px; background:var(--card); border-radius:10px;padding:12px;box-sizing:border-box}\n  .info{font-size:13px;color:var(--muted);margin-bottom:8px}\n  .arrays{font-family:monospace;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px; font-size:13px; color:#eaf6ff}\n  .log{max-height:260px;overflow:auto;margin-top:8px;padding:8px;background:rgba(255,255,255,0.02);border-radius:6px;font-size:13px}\n  .small{font-size:12px;color:var(--muted)}\n  .legend{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}\n  .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.02);font-size:12px}\n  .status{margin-top:8px;font-size:13px}\n  .footer{margin-top:16px;color:var(--muted);font-size:12px}\n  .btn-row{display:flex;gap:8px;flex-wrap:wrap}\n  .center{display:flex;align-items:center;justify-content:center}\n  .muted{color:var(--muted)}\n  .selected{outline:3px solid rgba(99,102,241,0.12);box-shadow:0 0 0 3px rgba(99,102,241,0.06);border-radius:8px}\n</style>\n</head>\n<body>\n<div class=\"wrap\">\n  <header>\n    <div>\n      <h1>Union-Find (Disjoint Set) Visualizer</h1>\n      <p class=\"lead\">Interactive demo: create elements, perform union/find operations, see trees, path compression and union-by-rank/size in action.</p>\n    </div>\n    <div class=\"small muted\">Click nodes to select. First click = A, second click = B → union(A,B). Click a node and press \"Find\" to run find(A).</div>\n  </header>\n\n  <div class=\"controls\">\n    <div class=\"control-group\">\n      <label>Elements:</label>\n      <input id=\"nRange\" type=\"range\" min=\"2\" max=\"60\" value=\"12\">\n      <div id=\"nVal\" class=\"small muted\">12</div>\n      <button id=\"resetBtn\" class=\"primary\">Reset</button>\n    </div>\n\n    <div class=\"control-group\">\n      <label><input type=\"checkbox\" id=\"useRank\" checked> Union by rank</label>\n      <label><input type=\"checkbox\" id=\"compressDuringFind\" checked> Path compression</label>\n    </div>\n\n    <div class=\"control-group\">\n      <label>Speed:</label>\n      <input id=\"speedRange\" type=\"range\" min=\"50\" max=\"1200\" value=\"350\">\n      <div id=\"speedVal\" class=\"small muted\">350ms</div>\n    </div>\n\n    <div class=\"control-group\">\n      <button id=\"randomUnionBtn\">Random union</button>\n      <button id=\"autoUnionBtn\">Auto-union until one set</button>\n    </div>\n\n    <div class=\"control-group\">\n      <button id=\"findBtn\">Find</button>\n      <button id=\"clearSelectionBtn\">Clear sel</button>\n    </div>\n\n    <div style=\"margin-left:auto\" class=\"small muted\">Visualization: arrows point from node → parent. Roots point to themselves.</div>\n  </div>\n\n  <div class=\"canvas-wrap\" style=\"margin-top:12px\">\n    <canvas id=\"canvas\" width=\"700\" height=\"520\"></canvas>\n    <div class=\"sidebar\">\n      <div class=\"info\">Selected: <span id=\"selText\">none</span></div>\n      <div class=\"btn-row\">\n        <button id=\"shuffleBtn\">Shuffle positions</button>\n        <button id=\"randomizeBtn\">Random components</button>\n      </div>\n\n      <div style=\"margin-top:10px\">\n        <div class=\"arrays\">\n          <div>parent[]: <span id=\"parentArr\"></span></div>\n          <div id=\"rankLabel\">rank[]: <span id=\"rankArr\"></span></div>\n        </div>\n        <div class=\"legend\" id=\"compLegend\"></div>\n      </div>\n\n      <div class=\"status\" id=\"status\">Sets: <strong id=\"setsCount\">0</strong> · Ops: <span id=\"opsCount\">0</span></div>\n\n      <div style=\"margin-top:8px\" class=\"small muted\">Log (latest at top):</div>\n      <div id=\"log\" class=\"log\"></div>\n\n      <div class=\"footer\">Try turning off \"Path compression\" to see deeper trees. Use union-by-rank to reduce height growth.</div>\n    </div>\n  </div>\n</div>\n\n<script>\n(() => {\n  // Configuration and state\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  const nRange = document.getElementById('nRange');\n  const nVal = document.getElementById('nVal');\n  const resetBtn = document.getElementById('resetBtn');\n  const useRankCb = document.getElementById('useRank');\n  const compressCb = document.getElementById('compressDuringFind');\n  const speedRange = document.getElementById('speedRange');\n  const speedVal = document.getElementById('speedVal');\n  const randomUnionBtn = document.getElementById('randomUnionBtn');\n  const autoUnionBtn = document.getElementById('autoUnionBtn');\n  const findBtn = document.getElementById('findBtn');\n  const clearSelectionBtn = document.getElementById('clearSelectionBtn');\n  const selText = document.getElementById('selText');\n  const parentArrEl = document.getElementById('parentArr');\n  const rankArrEl = document.getElementById('rankArr');\n  const rankLabel = document.getElementById('rankLabel');\n  const setsCountEl = document.getElementById('setsCount');\n  const opsCountEl = document.getElementById('opsCount');\n  const logEl = document.getElementById('log');\n  const shuffleBtn = document.getElementById('shuffleBtn');\n  const randomizeBtn = document.getElementById('randomizeBtn');\n  const compLegend = document.getElementById('compLegend');\n\n  let N = Number(nRange.value);\n  let parent = [];\n  let rank = []; // rank or size depending on flag\n  let positions = [];\n  let colors = [];\n  let selected = []; // up to two for union [a, b] or single for find\n  let ops = 0;\n  let animQueue = [];\n  let animRunning = false;\n\n  const nodeRadius = 18;\n  let animSpeed = Number(speedRange.value);\n\n  // Utilities\n  function randColor(seed) {\n    // pick from a palette\n    const palette = ['#60a5fa','#f97316','#f472b6','#34d399','#c084fc','#f59e0b','#06b6d4','#fb7185','#a3e635','#7dd3fc'];\n    return palette[seed % palette.length];\n  }\n\n  function log(msg) {\n    const time = new Date().toLocaleTimeString();\n    const el = document.createElement('div');\n    el.innerHTML = `<span style=\"color:var(--muted);font-size:11px\">[${time}]</span> ${msg}`;\n    logEl.prepend(el);\n  }\n\n  function resetArrays(n) {\n    parent = new Array(n);\n    rank = new Array(n);\n    for (let i=0;i<n;i++){ parent[i]=i; rank[i]=0; }\n    positions = computeCirclePositions(n);\n    colors = new Array(n).fill(0).map((_,i)=>randColor(i));\n    selected = [];\n    ops = 0;\n    updateUI();\n    draw();\n    log(`Reset with ${n} elements.`);\n  }\n\n  function computeCirclePositions(n) {\n    const w = canvas.width, h = canvas.height;\n    if (n<=12) {\n      const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 80;\n      const arr = [];\n      for (let i=0;i<n;i++){\n        const a = (i/n)*Math.PI*2 - Math.PI/2;\n        arr.push({x: cx + r*Math.cos(a), y: cy + r*Math.sin(a)});\n      }\n      return arr;\n    } else {\n      // grid-ish layout\n      const cols = Math.ceil(Math.sqrt(n));\n      const rows = Math.ceil(n/cols);\n      const pad = 30;\n      const cellW = (w - pad*2) / cols;\n      const cellH = (h - pad*2) / rows;\n      const arr = [];\n      for (let i=0;i<n;i++){\n        const c = i % cols;\n        const r = Math.floor(i/cols);\n        const x = pad + c*cellW + cellW/2 + (Math.random()-0.5)*20;\n        const y = pad + r*cellH + cellH/2 + (Math.random()-0.5)*20;\n        arr.push({x,y});\n      }\n      return arr;\n    }\n  }\n\n  function draw() {\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    // compute components for coloring\n    const compRoot = new Array(N);\n    for (let i=0;i<N;i++) compRoot[i] = findNoCompress(i);\n    // map root to color\n    const rootToColor = {};\n    let colorIdx=0;\n    for (let i=0;i<N;i++){\n      const r = compRoot[i];\n      if (!(r in rootToColor)) rootToColor[r] = randColor(colorIdx++);\n    }\n    // draw parent arrows (child -> parent)\n    ctx.lineWidth = 2;\n    for (let i=0;i<N;i++){\n      const p = parent[i];\n      if (p === i) continue;\n      const a = positions[i];\n      const b = positions[p];\n      // line with slight curve\n      const midx = (a.x + b.x)/2 + (a.y - b.y)*0.12;\n      const midy = (a.y + b.y)/2 + (b.x - a.x)*0.12;\n      ctx.beginPath();\n      ctx.strokeStyle = hexToRgba(rootToColor[compRoot[i]], 0.9);\n      ctx.moveTo(a.x, a.y);\n      ctx.quadraticCurveTo(midx, midy, b.x, b.y);\n      ctx.stroke();\n\n      // draw small arrowhead near parent\n      const t = 0.85; // position along curve\n      const qx = (1-t)*(1-t)*a.x + 2*(1-t)*t*midx + t*t*b.x;\n      const qy = (1-t)*(1-t)*a.y + 2*(1-t)*t*midy + t*t*b.y;\n      drawArrowhead(qx, qy, Math.atan2(b.y - a.y, b.x - a.x));\n    }\n\n    // draw nodes\n    for (let i=0;i<N;i++){\n      const pos = positions[i];\n      const root = compRoot[i];\n      const color = rootToColor[root];\n      // node circle\n      ctx.beginPath();\n      ctx.fillStyle = hexToRgba(color, 0.14);\n      ctx.strokeStyle = hexToRgba(color, 0.9);\n      ctx.lineWidth = (selected.includes(i) ? 3.2 : 1.5);\n      ctx.ellipse(pos.x, pos.y, nodeRadius, nodeRadius, 0, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n\n      // inner circle for root nodes\n      if (parent[i] === i) {\n        ctx.beginPath();\n        ctx.fillStyle = hexToRgba(color, 0.22);\n        ctx.ellipse(pos.x, pos.y, nodeRadius-6, nodeRadius-6, 0, 0, Math.PI*2);\n        ctx.fill();\n      }\n\n      // label\n      ctx.fillStyle = '#e6f0ff';\n      ctx.font = '13px monospace';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(i, pos.x, pos.y);\n    }\n\n    // highlight selection markers\n    if (selected.length > 0) {\n      selected.forEach((i, idx) => {\n        const p = positions[i];\n        ctx.beginPath();\n        ctx.strokeStyle = idx===0 ? '#7c3aed' : '#06b6d4';\n        ctx.lineWidth = 3;\n        ctx.ellipse(p.x, p.y, nodeRadius+6, nodeRadius+6, 0, 0, Math.PI*2);\n        ctx.stroke();\n      });\n    }\n  }\n\n  function hexToRgba(hex, alpha=1) {\n    // simple hex to rgba\n    const h = hex.replace('#','');\n    const r = parseInt(h.substring(0,2),16);\n    const g = parseInt(h.substring(2,4),16);\n    const b = parseInt(h.substring(4,6),16);\n    return `rgba(${r},${g},${b},${alpha})`;\n  }\n\n  function drawArrowhead(x,y, angle) {\n    ctx.save();\n    ctx.translate(x,y);\n    ctx.rotate(angle);\n    ctx.beginPath();\n    ctx.fillStyle = ctx.strokeStyle;\n    ctx.moveTo(0,0);\n    ctx.lineTo(-8,-4);\n    ctx.lineTo(-8,4);\n    ctx.closePath();\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Find without compression, used for display\n  function findNoCompress(a) {\n    while (parent[a] !== a) a = parent[a];\n    return a;\n  }\n\n  // Animation queue system\n  function enqueue(stepFn) {\n    animQueue.push(stepFn);\n    if (!animRunning) {\n      processQueue();\n    }\n  }\n\n  function processQueue() {\n    if (animQueue.length === 0) { animRunning = false; return; }\n    animRunning = true;\n    const fn = animQueue.shift();\n    fn();\n    // schedule next\n    setTimeout(processQueue, animSpeed);\n  }\n\n  // Find with optional animation and compression\n  function find(a, animate=true) {\n    return new Promise(resolve => {\n      let path = [];\n      let cur = a;\n      while (parent[cur] !== cur) {\n        path.push(cur);\n        cur = parent[cur];\n      }\n      path.push(cur); // include root\n      const root = cur;\n      ops++; updateUI(`find(${a}) -> ${root}`);\n      if (!animate || !compressCb.checked) {\n        // if no compression, we can just show highlighting then finish\n        enqueue(() => {\n          selected = [...new Set([a])];\n          draw();\n          highlightPath(path);\n        });\n        setTimeout(()=>{ resolve(root); }, animSpeed);\n        return;\n      }\n\n      // Animate path compression: set parent of intermediate nodes to root, one by one\n      enqueue(() => {\n        selected = [a];\n        draw();\n      });\n      // show path highlight\n      enqueue(()=>highlightPath(path));\n\n      // compress step by step\n      const intermediates = path.slice(0, -1); // exclude root at end\n      intermediates.forEach((v, idx) => {\n        enqueue(() => {\n          parent[v] = root;\n          log(`Compressed: parent[${v}] = ${root}`);\n          updateUI();\n          draw();\n        });\n      });\n\n      // final draw\n      enqueue(() => {\n        selected = [];\n        draw();\n      });\n\n      // resolve after queue has processed all steps; estimate time by queue length * speed\n      const wait = (animQueue.length + intermediates.length + 3) * animSpeed;\n      setTimeout(()=>{ resolve(root); }, wait+50);\n    });\n  }\n\n  function highlightPath(path) {\n    // quick visual effect: draw thicker stroke for nodes in path\n    ctx.save();\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.lineWidth = 4;\n    path.forEach((i, idx) => {\n      const pos = positions[i];\n      ctx.beginPath();\n      ctx.strokeStyle = 'rgba(255,255,255,0.12)';\n      ctx.ellipse(pos.x, pos.y, nodeRadius+10 - idx*2, nodeRadius+10 - idx*2, 0, 0, Math.PI*2);\n      ctx.stroke();\n    });\n    ctx.restore();\n  }\n\n  // Union entrypoint; animate steps\n  async function union(a,b) {\n    if (a === undefined || b === undefined) return;\n    if (a < 0 || b < 0 || a>=N || b>=N) return;\n    ops++;\n    log(`union(${a}, ${b})`);\n    updateUI();\n    // find roots (use animated find)\n    const ra = await find(a, true);\n    const rb = await find(b, true);\n    if (ra === rb) {\n      log(`Already in same set (root ${ra}).`);\n      return;\n    }\n\n    // attach based on chosen strategy\n    if (useRankCb.checked) {\n      // union by rank\n      if (rank[ra] < rank[rb]) {\n        parent[ra] = rb;\n        log(`parent[${ra}] -> ${rb} (attached lower rank under higher)`);\n      } else if (rank[ra] > rank[rb]) {\n        parent[rb] = ra;\n        log(`parent[${rb}] -> ${ra}`);\n      } else {\n        parent[rb] = ra;\n        rank[ra] += 1;\n        log(`ranks equal: parent[${rb}] -> ${ra}, rank[${ra}]++`);\n      }\n    } else {\n      // union by size (we store size as negative in rank array? We'll use rank[] as size)\n      // ensure rank contains sizes (if toggled, we interpret rank[] accordingly)\n      // We'll maintain rank as size if useRankCb is false\n      if (rank[ra] < rank[rb]) {\n        // ra smaller size -> attach ra under rb\n        parent[ra] = rb;\n        rank[rb] += rank[ra];\n        log(`parent[${ra}] -> ${rb}, size[${rb}] += ${rank[ra]}`);\n      } else {\n        parent[rb] = ra;\n        rank[ra] += rank[rb];\n        log(`parent[${rb}] -> ${ra}, size[${ra}] += ${rank[rb]}`);\n      }\n    }\n    updateUI();\n    draw();\n  }\n\n  // Helpers for UI updates\n  function updateUI(statusText) {\n    nVal.textContent = N;\n    selText.textContent = selected.length===0 ? 'none' : selected.join(', ');\n    parentArrEl.textContent = '[' + parent.join(', ') + ']';\n    rankArrEl.textContent = '[' + rank.join(', ') + ']';\n    setsCountEl.textContent = countSets();\n    opsCountEl.textContent = ops;\n    speedVal.textContent = animSpeed + 'ms';\n    rankLabel.textContent = useRankCb.checked ? 'rank[]:' : 'size[]:';\n    if (statusText) {\n      document.getElementById('status').title = statusText;\n    }\n    updateLegend();\n  }\n\n  function countSets() {\n    const s = new Set();\n    for (let i=0;i<N;i++) s.add(findNoCompress(i));\n    return s.size;\n  }\n\n  function updateLegend() {\n    compLegend.innerHTML = '';\n    const roots = [...new Set(parent.map((_,i)=>findNoCompress(i)))];\n    roots.forEach((r, idx) => {\n      const color = randColor(idx);\n      const chip = document.createElement('div');\n      chip.className = 'chip';\n      chip.innerHTML = `<span style=\"display:inline-block;width:12px;height:12px;border-radius:50%;background:${color}\"></span> root ${r}`;\n      compLegend.appendChild(chip);\n    });\n  }\n\n  // Canvas mouse interactions\n  canvas.addEventListener('click', (ev) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = ev.clientX - rect.left, y = ev.clientY - rect.top;\n    const hit = hitTest(x,y);\n    if (hit === null) return;\n    if (selected.length === 0) {\n      selected.push(hit);\n    } else if (selected.length === 1) {\n      if (selected[0] === hit) {\n        // interpret as find\n        selected = [hit];\n      } else selected.push(hit);\n    } else {\n      selected = [hit];\n    }\n    updateUI();\n    draw();\n    // If two selected, perform union automatically\n    if (selected.length === 2) {\n      union(selected[0], selected[1]);\n      selected = [];\n    }\n  });\n\n  function hitTest(x,y) {\n    for (let i=0;i<N;i++) {\n      const p = positions[i];\n      const dx = x - p.x, dy = y - p.y;\n      if (dx*dx + dy*dy <= (nodeRadius+8)*(nodeRadius+8)) return i;\n    }\n    return null;\n  }\n\n  // UI wiring\n  nRange.addEventListener('input', () => {\n    N = Number(nRange.value);\n    nVal.textContent = N;\n  });\n\n  resetBtn.addEventListener('click', ()=> {\n    N = Number(nRange.value);\n    init(N);\n  });\n\n  speedRange.addEventListener('input', ()=> {\n    animSpeed = Number(speedRange.value);\n    speedVal.textContent = animSpeed + 'ms';\n  });\n\n  findBtn.addEventListener('click', async ()=> {\n    if (selected.length === 0) {\n      log('No node selected for find.');\n      return;\n    }\n    await find(selected[0], true);\n    selected = [];\n    updateUI();\n    draw();\n  });\n\n  clearSelectionBtn.addEventListener('click', ()=>{ selected=[]; updateUI(); draw(); });\n\n  randomUnionBtn.addEventListener('click', ()=>{\n    // perform one random union\n    const a = randInt(0,N-1), b = randInt(0,N-1);\n    if (a===b) { log('Random pick same index; try again.'); return; }\n    union(a,b);\n  });\n\n  autoUnionBtn.addEventListener('click', ()=> {\n    // continue performing random unions until one set remains\n    const iter = () => {\n      if (countSets() <= 1) {\n        log('Single set achieved.');\n        return;\n      }\n      const a = randInt(0,N-1), b = randInt(0,N-1);\n      if (a!==b) union(a,b);\n      setTimeout(iter, animSpeed + 10);\n    };\n    iter();\n  });\n\n  shuffleBtn.addEventListener('click', ()=> {\n    positions = computeCirclePositions(N).map(p => ({x: p.x + (Math.random()-0.5)*40, y: p.y + (Math.random()-0.5)*40}));\n    draw();\n  });\n\n  randomizeBtn.addEventListener('click', ()=> {\n    // create some random unions to produce random components\n    const m = Math.max(1, Math.floor(N * 0.6));\n    for (let i=0;i<m;i++){\n      const a = randInt(0,N-1), b = randInt(0,N-1);\n      if (a!==b) {\n        // quick union without animation: use settings\n        const ra = findNoCompress(a), rb = findNoCompress(b);\n        if (ra===rb) continue;\n        if (useRankCb.checked) {\n          if (rank[ra] < rank[rb]) parent[ra] = rb;\n          else if (rank[ra] > rank[rb]) parent[rb] = ra;\n          else { parent[rb]=ra; rank[ra]++; }\n        } else {\n          // assume rank[] used as size currently; ensure min size 1\n          if (rank[ra] < rank[rb]) { parent[ra] = rb; rank[rb] += rank[ra]; }\n          else { parent[rb] = ra; rank[ra] += rank[rb]; }\n        }\n      }\n    }\n    log('Randomized components.');\n    updateUI();\n    draw();\n  });\n\n  useRankCb.addEventListener('change', ()=> {\n    // When toggling between rank and size, we convert rank[] meaning\n    if (useRankCb.checked) {\n      // convert sizes to ranks heuristically: set all ranks to 0\n      for (let i=0;i<N;i++) rank[i] = 0;\n      log('Switched to union-by-rank (rank[] reset).');\n    } else {\n      // convert ranks to sizes: compute subtree sizes\n      const sizes = new Array(N).fill(0);\n      for (let i=0;i<N;i++) sizes[findNoCompress(i)]++;\n      for (let i=0;i<N;i++) {\n        if (findNoCompress(i) === i) rank[i] = sizes[i] || 1;\n        else rank[i] = 1;\n      }\n      log('Switched to union-by-size (size[] set for roots).');\n    }\n    updateUI();\n  });\n\n  // Small helpers\n  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }\n\n  // Initialization\n  function init(n) {\n    N = n;\n    // initial arrays\n    parent = new Array(N);\n    rank = new Array(N);\n    for (let i=0;i<N;i++){ parent[i]=i; rank[i]=1; } // by default size=1; if useRank true we'll override to 0\n    if (useRankCb.checked) for (let i=0;i<N;i++) rank[i]=0;\n    positions = computeCirclePositions(N);\n    selected = [];\n    ops = 0;\n    updateUI();\n    draw();\n  }\n\n  // Start\n  init(N);\n\n  // expose some debug functions\n  window.__uf = { get parent(){return parent}, get rank(){return rank}, findNoCompress };\n\n  // initial drawing\n  draw();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Union-Find (Disjoint Set)"
    }
  ],
  "topic": "Union-Find (Disjoint Set)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}