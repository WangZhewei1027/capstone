{
  "id": "cc1e70a0-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:39.590Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Floyd-Warshall Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Floyd–Warshall Algorithm Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 18px; line-height:1.4; color:#111; }\n    h1 { margin: 0 0 6px 0; font-size: 20px; }\n    p.lead { margin: 6px 0 18px 0; color:#444; max-width:900px; }\n    .controls { display:flex; gap:12px; flex-wrap:wrap; margin-bottom:12px; align-items:center; }\n    .panel { border: 1px solid #ddd; padding:10px; border-radius:8px; background:#fafafa; }\n    label { font-size:13px; color:#333; margin-right:6px; }\n    input[type=\"number\"], select { width:70px; }\n    .matrix { display:inline-block; margin:8px 10px 8px 0; vertical-align:top; }\n    table.mat { border-collapse: collapse; }\n    table.mat td, table.mat th { border:1px solid #ccc; padding:6px 8px; min-width:44px; text-align:center; font-family:monospace; }\n    table.mat th { background:#f4f4f4; font-weight:600; font-size:13px; }\n    table.mat td.infinite { color:#999; }\n    table.mat td.updated { background:#e6ffe6; border-color:#7dd77d; }\n    table.mat td.considered { background:#fff7cc; border-color:#f2d97c; }\n    .small { font-size:13px; color:#444; }\n    .btn { background:#007bff; color:white; padding:7px 11px; border-radius:6px; border:none; cursor:pointer; margin-right:6px; }\n    .btn.secondary { background:#6c757d; }\n    .btn.warn { background:#dc3545; }\n    .btn:disabled { opacity:0.5; cursor:not-allowed; }\n    .row { display:flex; gap:12px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }\n    .meta { margin-top:8px; color:#333; }\n    .info { font-size:13px; color:#333; }\n    .footer-note { font-size:12px; color:#666; margin-top:10px; }\n    .path-output { font-family:monospace; margin-top:6px; color:#111; }\n    .legend { font-size:13px; margin-top:6px; }\n    .kbd { background:#eee; border-radius:4px; padding:2px 6px; font-family:monospace; font-size:12px; }\n    .small-input { width:48px; }\n    .matrix-input td input { width:56px; padding:6px; box-sizing:border-box; font-family:monospace; border:1px solid #ccc; border-radius:4px; }\n    .top-controls { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }\n    .status { padding:6px 8px; border-radius:6px; background:#f6f6f6; border:1px solid #eee; }\n    .highlight { font-weight:700; color:#004085; }\n  </style>\n</head>\n<body>\n  <h1>Floyd–Warshall Algorithm Visualizer</h1>\n  <p class=\"lead\">\n    Floyd–Warshall finds shortest paths between all pairs of vertices in a weighted graph (directed or undirected),\n    and can handle negative edge weights (but not negative cycles). This interactive demo lets you edit an adjacency matrix,\n    run the algorithm step-by-step, see updates, and reconstruct shortest paths.\n  </p>\n\n  <div class=\"panel\">\n    <div class=\"top-controls\">\n      <div>\n        <label>Nodes:</label>\n        <input id=\"nodeCount\" type=\"number\" value=\"5\" min=\"2\" max=\"10\" />\n      </div>\n\n      <div>\n        <label>Directed:</label>\n        <select id=\"directed\">\n          <option value=\"true\">Yes</option>\n          <option value=\"false\">No</option>\n        </select>\n      </div>\n\n      <div>\n        <label>Allow negatives:</label>\n        <select id=\"allowNeg\">\n          <option value=\"false\">No</option>\n          <option value=\"true\">Yes</option>\n        </select>\n      </div>\n\n      <button id=\"makeRandom\" class=\"btn\">Random Graph</button>\n      <button id=\"resetBtn\" class=\"btn secondary\">Reset Matrix</button>\n      <button id=\"runBtn\" class=\"btn\">Run Floyd–Warshall</button>\n      <button id=\"runFastBtn\" class=\"btn\">Compute Final Only</button>\n    </div>\n\n    <div class=\"row\" style=\"margin-top:10px;\">\n      <div class=\"matrix panel\" id=\"matrixPanel\" aria-live=\"polite\"></div>\n\n      <div style=\"min-width:360px;\">\n        <div class=\"info\"><strong>Controls while running:</strong></div>\n        <div style=\"margin-top:6px;\">\n          <button id=\"stepBack\" class=\"btn secondary\">◀ Step Back</button>\n          <button id=\"playPause\" class=\"btn\">▶ Play</button>\n          <button id=\"stepForward\" class=\"btn\">Step ▶</button>\n          <label style=\"margin-left:6px\">Speed:</label>\n          <input id=\"speed\" type=\"range\" min=\"100\" max=\"1500\" value=\"600\" />\n        </div>\n\n        <div class=\"meta\" id=\"statusArea\">\n          <div class=\"status\" id=\"statusText\">Status: ready</div>\n          <div class=\"small\" id=\"stepInfo\" style=\"margin-top:6px;\">No run yet.</div>\n        </div>\n\n        <div style=\"margin-top:10px;\">\n          <div class=\"legend\"><span class=\"highlight\">Green</span> = updated; <span class=\"highlight\" style=\"color:#b36b00\">Yellow</span> = currently considered (k,i,j).</div>\n          <div class=\"footer-note\">Tip: empty cell = no edge (∞), diagonal defaults to 0.</div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div style=\"display:flex; gap:10px; margin-top:12px; flex-wrap:wrap;\">\n    <div class=\"panel\" style=\"flex:1; min-width:320px;\">\n      <div style=\"display:flex; gap:10px; align-items:center; margin-bottom:8px;\">\n        <strong>Distance Matrix (current step)</strong>\n        <span style=\"margin-left:auto;\" id=\"diagCheck\"></span>\n      </div>\n      <div id=\"distMatrices\" style=\"display:flex; gap:12px; flex-wrap:wrap;\">\n        <div id=\"distancePanel\" class=\"matrix\"></div>\n        <div id=\"nextPanel\" class=\"matrix\"></div>\n      </div>\n    </div>\n\n    <div class=\"panel\" style=\"min-width:320px; width:420px;\">\n      <strong>Query shortest path</strong>\n      <div style=\"margin-top:8px;\">\n        <label>From:</label>\n        <select id=\"fromNode\"></select>\n        <label>To:</label>\n        <select id=\"toNode\"></select>\n        <button id=\"showPath\" class=\"btn\">Show Path</button>\n      </div>\n      <div class=\"path-output\" id=\"pathResult\">No path query yet.</div>\n      <div style=\"margin-top:10px; font-size:13px; color:#444;\">\n        After computing, use the final matrices to reconstruct a path using the \"next\" table.\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Floyd–Warshall visualizer\n    (() => {\n      const INF = Number.POSITIVE_INFINITY;\n      let n = 5;\n      let directed = true;\n      let allowNeg = false;\n\n      // Matrices\n      let adj = []; // adjacency input as numbers or INF\n      // Snapshots for stepping through algorithm\n      let snapshots = []; // {dist, next, k, i, j, updated, oldValue, newValue}\n      let currentStep = -1;\n      let playing = false;\n      let playTimer = null;\n\n      // DOM\n      const nodeCountInput = document.getElementById('nodeCount');\n      const directedSel = document.getElementById('directed');\n      const allowNegSel = document.getElementById('allowNeg');\n      const matrixPanel = document.getElementById('matrixPanel');\n      const distancePanel = document.getElementById('distancePanel');\n      const nextPanel = document.getElementById('nextPanel');\n      const makeRandomBtn = document.getElementById('makeRandom');\n      const resetBtn = document.getElementById('resetBtn');\n      const runBtn = document.getElementById('runBtn');\n      const runFastBtn = document.getElementById('runFastBtn');\n      const stepForwardBtn = document.getElementById('stepForward');\n      const stepBackBtn = document.getElementById('stepBack');\n      const playPauseBtn = document.getElementById('playPause');\n      const speedInput = document.getElementById('speed');\n      const statusText = document.getElementById('statusText');\n      const stepInfo = document.getElementById('stepInfo');\n      const fromNodeSel = document.getElementById('fromNode');\n      const toNodeSel = document.getElementById('toNode');\n      const showPathBtn = document.getElementById('showPath');\n      const pathResult = document.getElementById('pathResult');\n      const diagCheck = document.getElementById('diagCheck');\n\n      // Utilities\n      function make2DArray(rows, cols, val = INF) {\n        return Array.from({length: rows}, () => Array.from({length: cols}, () => val));\n      }\n      function deepCopyMatrix(m) {\n        return m.map(row => row.slice());\n      }\n      function indexToLabel(i) { return String.fromCharCode(65 + i); } // A, B, C...\n      function formatVal(v) {\n        if (v === INF) return \"∞\";\n        if (Number.isFinite(v)) return (Math.round(v * 100) / 100).toString();\n        return v.toString();\n      }\n\n      // Build initial adjacency matrix\n      function buildDefaultAdj(size) {\n        const a = make2DArray(size, size, INF);\n        for (let i=0;i<size;i++) {\n          a[i][i] = 0;\n        }\n        return a;\n      }\n\n      function renderMatrixInputs() {\n        matrixPanel.innerHTML = '';\n        const tbl = document.createElement('table');\n        tbl.className = 'mat matrix-input';\n        const thead = document.createElement('thead');\n        const headRow = document.createElement('tr');\n        headRow.appendChild(document.createElement('th')); // corner\n        for (let j=0;j<n;j++) {\n          const th = document.createElement('th'); th.textContent = indexToLabel(j); headRow.appendChild(th);\n        }\n        thead.appendChild(headRow);\n        tbl.appendChild(thead);\n\n        const tbody = document.createElement('tbody');\n        for (let i=0;i<n;i++) {\n          const tr = document.createElement('tr');\n          const rowHeader = document.createElement('th'); rowHeader.textContent = indexToLabel(i); tr.appendChild(rowHeader);\n          for (let j=0;j<n;j++) {\n            const td = document.createElement('td');\n            if (i === j) {\n              const input = document.createElement('input');\n              input.type = 'text';\n              input.value = '0';\n              input.disabled = true;\n              td.appendChild(input);\n            } else {\n              const input = document.createElement('input');\n              input.type = 'text';\n              input.value = (adj[i][j] === INF ? '' : String(adj[i][j]));\n              input.addEventListener('change', () => {\n                const val = input.value.trim();\n                if (val === '' || val.toLowerCase() === 'inf' || val === '∞') {\n                  adj[i][j] = INF;\n                } else {\n                  const num = Number(val);\n                  if (!Number.isFinite(num)) {\n                    alert('Please enter a finite number, or leave blank for no edge.');\n                    input.value = (adj[i][j] === INF ? '' : String(adj[i][j]));\n                    return;\n                  }\n                  if (!allowNeg && num < 0) {\n                    alert('Negative weights are not allowed currently (toggle Allow negatives).');\n                    input.value = (adj[i][j] === INF ? '' : String(adj[i][j]));\n                    return;\n                  }\n                  adj[i][j] = num;\n                  if (!directed) {\n                    adj[j][i] = num;\n                    // update symmetric cell display\n                    const otherInput = tbody.querySelector(`tr:nth-child(${j+1}) td:nth-child(${i+1}) input`);\n                    if (otherInput) otherInput.value = String(num);\n                  }\n                }\n                // clear previous runs\n                snapshots = []; currentStep = -1; playing = false; stopPlay();\n                updateStatus('Matrix edited — ready');\n                renderMatrices(null);\n              });\n              td.appendChild(input);\n            }\n            tr.appendChild(td);\n          }\n          tbody.appendChild(tr);\n        }\n        tbl.appendChild(tbody);\n        matrixPanel.appendChild(tbl);\n        populateNodeSelectors();\n      }\n\n      function populateNodeSelectors() {\n        fromNodeSel.innerHTML = ''; toNodeSel.innerHTML = '';\n        for (let i=0;i<n;i++) {\n          const o1 = document.createElement('option'); o1.value = String(i); o1.textContent = indexToLabel(i);\n          const o2 = document.createElement('option'); o2.value = String(i); o2.textContent = indexToLabel(i);\n          fromNodeSel.appendChild(o1); toNodeSel.appendChild(o2);\n        }\n      }\n\n      // Render distance and next matrices based on current snapshot or initial adj\n      function renderMatrices(snapshot) {\n        let dist, next;\n        let considered = null;\n        let updatedCell = null;\n        if (!snapshot) {\n          // show starting matrices (dist = adj)\n          dist = deepCopyMatrix(adj);\n          next = make2DArray(n,n, -1);\n          for (let i=0;i<n;i++) {\n            for (let j=0;j<n;j++) {\n              if (dist[i][j] !== INF) next[i][j] = j;\n            }\n          }\n        } else {\n          dist = snapshot.dist;\n          next = snapshot.next;\n          considered = {k: snapshot.k, i: snapshot.i, j: snapshot.j};\n          if (snapshot.updated) updatedCell = {i: snapshot.i, j: snapshot.j, old: snapshot.oldValue, new: snapshot.newValue};\n        }\n\n        // Distance table\n        distancePanel.innerHTML = '';\n        const dtbl = document.createElement('table'); dtbl.className = 'mat';\n        const dthead = document.createElement('thead');\n        const dh = document.createElement('tr'); dh.appendChild(document.createElement('th'));\n        for (let j=0;j<n;j++){ const th = document.createElement('th'); th.textContent = indexToLabel(j); dh.appendChild(th); }\n        dthead.appendChild(dh); dtbl.appendChild(dthead);\n        const dtbody = document.createElement('tbody');\n        for (let i=0;i<n;i++){\n          const tr = document.createElement('tr');\n          const rh = document.createElement('th'); rh.textContent = indexToLabel(i); tr.appendChild(rh);\n          for (let j=0;j<n;j++){\n            const td = document.createElement('td');\n            td.textContent = formatVal(dist[i][j]);\n            if (dist[i][j] === INF) td.classList.add('infinite');\n            if (considered && considered.i === i && considered.j === j) td.classList.add('considered');\n            if (updatedCell && updatedCell.i === i && updatedCell.j === j) td.classList.add('updated');\n            tr.appendChild(td);\n          }\n          dtbody.appendChild(tr);\n        }\n        dtbl.appendChild(dtbody);\n        const dtcap = document.createElement('div'); dtcap.textContent = 'Distances'; dtcap.style.fontWeight='600'; dtcap.style.marginBottom='6px';\n        distancePanel.appendChild(dtcap); distancePanel.appendChild(dtbl);\n\n        // Next table\n        nextPanel.innerHTML = '';\n        const ntbl = document.createElement('table'); ntbl.className = 'mat';\n        const nthead = document.createElement('thead');\n        const nh = document.createElement('tr'); nh.appendChild(document.createElement('th'));\n        for (let j=0;j<n;j++){ const th = document.createElement('th'); th.textContent = indexToLabel(j); nh.appendChild(th); }\n        nthead.appendChild(nh); ntbl.appendChild(nthead);\n        const ntbody = document.createElement('tbody');\n        for (let i=0;i<n;i++){\n          const tr = document.createElement('tr');\n          const rh = document.createElement('th'); rh.textContent = indexToLabel(i); tr.appendChild(rh);\n          for (let j=0;j<n;j++){\n            const td = document.createElement('td');\n            const v = next[i][j];\n            td.textContent = (v === -1 ? '-' : indexToLabel(v));\n            if (considered && considered.i === i && considered.j === j) td.classList.add('considered');\n            if (updatedCell && updatedCell.i === i && updatedCell.j === j) td.classList.add('updated');\n            tr.appendChild(td);\n          }\n          ntbody.appendChild(tr);\n        }\n        ntbl.appendChild(ntbody);\n        const ntcap = document.createElement('div'); ntcap.textContent = 'Next (for path reconstruction)'; ntcap.style.fontWeight='600'; ntcap.style.marginBottom='6px';\n        nextPanel.appendChild(ntcap); nextPanel.appendChild(ntbl);\n\n        // diag check (negative cycle)\n        if (snapshot) {\n          const negDiag = snapshot.final && snapshot.finalNegCycle;\n          if (negDiag) {\n            diagCheck.innerHTML = '<span style=\"color:#b80d0d; font-weight:700\">Negative cycle detected!</span>';\n          } else {\n            diagCheck.innerHTML = '';\n          }\n        } else {\n          diagCheck.innerHTML = '';\n        }\n      }\n\n      function updateStatus(text) {\n        statusText.textContent = 'Status: ' + text;\n      }\n\n      // Random graph generator\n      function randomizeGraph() {\n        const density = 0.45; // probability of an edge\n        const maxW = 12;\n        for (let i=0;i<n;i++){\n          for (let j=0;j<n;j++){\n            if (i===j) { adj[i][j]=0; continue; }\n            if (Math.random() < density) {\n              // weight\n              let w = Math.floor(Math.random()*maxW) + 1;\n              if (allowNeg && Math.random() < 0.2) w = -w;\n              adj[i][j] = w;\n              if (!directed) adj[j][i] = adj[i][j];\n            } else {\n              adj[i][j] = INF;\n              if (!directed) adj[j][i] = INF;\n            }\n          }\n        }\n        snapshots = []; currentStep = -1; stopPlay();\n        renderMatrixInputs();\n        renderMatrices(null);\n        updateStatus('Random graph created');\n      }\n\n      // Floyd–Warshall algorithm with snapshots (records each (k,i,j) consideration and updates)\n      function runFloydWithSnapshots() {\n        // initialize dist and next\n        let dist = deepCopyMatrix(adj);\n        let next = make2DArray(n,n, -1);\n        for (let i=0;i<n;i++){\n          for (let j=0;j<n;j++){\n            if (dist[i][j] !== INF) next[i][j] = j;\n          }\n        }\n        snapshots = [];\n        // snapshot 0: initial\n        snapshots.push({\n          dist: deepCopyMatrix(dist),\n          next: deepCopyMatrix(next),\n          k: -1, i:-1, j:-1, updated:false, oldValue:null, newValue:null, final:false\n        });\n\n        // main triple loop\n        for (let k=0;k<n;k++){\n          for (let i=0;i<n;i++){\n            for (let j=0;j<n;j++){\n              // capture considered state before update\n              const curSnapshot = {\n                dist: deepCopyMatrix(dist),\n                next: deepCopyMatrix(next),\n                k, i, j, updated:false, oldValue:null, newValue:null, final:false\n              };\n              snapshots.push(curSnapshot);\n\n              const through = (dist[i][k] === INF || dist[k][j] === INF) ? INF : dist[i][k] + dist[k][j];\n              if (through < dist[i][j]) {\n                const old = dist[i][j];\n                dist[i][j] = through;\n                next[i][j] = next[i][k];\n                // record update snapshot\n                const updatedSnap = {\n                  dist: deepCopyMatrix(dist),\n                  next: deepCopyMatrix(next),\n                  k, i, j, updated:true, oldValue: old, newValue: through, final:false\n                };\n                snapshots.push(updatedSnap);\n              }\n            }\n          }\n        }\n\n        // final snapshot: mark final and detect negative cycle\n        const finalSnap = {\n          dist: deepCopyMatrix(dist),\n          next: deepCopyMatrix(next),\n          k: n, i:-1, j:-1, updated:false, oldValue:null, newValue:null, final:true\n        };\n        // detect negative cycle if any dist[i][i] < 0\n        let neg = false;\n        for (let i=0;i<n;i++) {\n          if (finalSnap.dist[i][i] < 0) { neg = true; break; }\n        }\n        finalSnap.finalNegCycle = neg;\n        snapshots.push(finalSnap);\n        return snapshots;\n      }\n\n      // Run fast (no intermediate snapshots) - compute final only\n      function runFloydFinalOnly() {\n        let dist = deepCopyMatrix(adj);\n        let next = make2DArray(n,n, -1);\n        for (let i=0;i<n;i++){\n          for (let j=0;j<n;j++){\n            if (dist[i][j] !== INF) next[i][j] = j;\n          }\n        }\n        for (let k=0;k<n;k++){\n          for (let i=0;i<n;i++){\n            for (let j=0;j<n;j++){\n              const through = (dist[i][k] === INF || dist[k][j] === INF) ? INF : dist[i][k] + dist[k][j];\n              if (through < dist[i][j]) {\n                dist[i][j] = through;\n                next[i][j] = next[i][k];\n              }\n            }\n          }\n        }\n        snapshots = [];\n        const finalSnap = {\n          dist: deepCopyMatrix(dist),\n          next: deepCopyMatrix(next),\n          k: n, i:-1, j:-1, updated:false, oldValue:null, newValue:null, final:true\n        };\n        finalSnap.finalNegCycle = dist.some((row, i) => row[i] < 0);\n        snapshots.push(finalSnap);\n        currentStep = 0;\n        renderMatrices(snapshots[currentStep]);\n        updateStatus('Computed final matrices (no step history).');\n        stepInfo.textContent = `Step ${currentStep+1} of ${snapshots.length} (final only)`;\n      }\n\n      // Playback controls\n      function goToStep(idx) {\n        if (snapshots.length === 0) return;\n        if (idx < 0) idx = 0;\n        if (idx >= snapshots.length) idx = snapshots.length - 1;\n        currentStep = idx;\n        const s = snapshots[currentStep];\n        renderMatrices(s);\n        // update step info\n        stepInfo.textContent = `Step ${currentStep+1} of ${snapshots.length}` + (s.k >= 0 ? ` — considering k=${s.k} (${indexToLabel(s.k)})` : '');\n        // update status indicator\n        if (s.final) {\n          updateStatus('Final result' + (s.finalNegCycle ? ' (negative cycle!)' : ''));\n        } else if (s.k === -1) {\n          updateStatus('Initial');\n        } else if (s.updated) {\n          updateStatus(`Updated dist[${indexToLabel(s.i)}][${indexToLabel(s.j)}]: ${formatVal(s.oldValue)} → ${formatVal(s.newValue)}`);\n        } else {\n          updateStatus(`Considering k=${indexToLabel(s.k)}, i=${indexToLabel(s.i)}, j=${indexToLabel(s.j)}`);\n        }\n        // disable/enable buttons\n        stepBackBtn.disabled = (currentStep <= 0);\n        stepForwardBtn.disabled = (currentStep >= snapshots.length - 1);\n      }\n\n      function stepForward() {\n        if (snapshots.length === 0) return;\n        if (currentStep < snapshots.length - 1) {\n          goToStep(currentStep + 1);\n        }\n      }\n      function stepBack() {\n        if (snapshots.length === 0) return;\n        if (currentStep > 0) {\n          goToStep(currentStep - 1);\n        }\n      }\n\n      function play() {\n        if (snapshots.length === 0) return;\n        playing = true;\n        playPauseBtn.textContent = '❚❚ Pause';\n        const delay = Number(speedInput.value) || 600;\n        playTimer = setInterval(() => {\n          if (currentStep >= snapshots.length - 1) {\n            stopPlay();\n            return;\n          }\n          stepForward();\n        }, delay);\n      }\n      function stopPlay() {\n        playing = false;\n        playPauseBtn.textContent = '▶ Play';\n        if (playTimer) { clearInterval(playTimer); playTimer = null; }\n      }\n\n      // Path reconstruction using next matrix at final snapshot (or any snapshot)\n      function reconstructPath(next, u, v) {\n        if (next[u][v] === -1) return null;\n        const path = [u];\n        let cur = u;\n        const visited = new Set();\n        visited.add(cur);\n        while (cur !== v) {\n          cur = next[cur][v];\n          if (cur === -1 || visited.has(cur)) { // malformed (cycle)\n            return null;\n          }\n          path.push(cur);\n          visited.add(cur);\n        }\n        return path;\n      }\n\n      // Initialize UI and event handlers\n      function init() {\n        // initial setup\n        n = Number(nodeCountInput.value) || 5;\n        directed = (directedSel.value === 'true');\n        allowNeg = (allowNegSel.value === 'true');\n        adj = buildDefaultAdj(n);\n        renderMatrixInputs();\n        renderMatrices(null);\n        updateStatus('ready');\n\n        // events\n        nodeCountInput.addEventListener('change', () => {\n          let newN = Number(nodeCountInput.value);\n          if (!Number.isInteger(newN) || newN < 2) newN = 2;\n          if (newN > 10) newN = 10;\n          nodeCountInput.value = String(newN);\n          n = newN;\n          adj = buildDefaultAdj(n);\n          snapshots = []; currentStep = -1; stopPlay();\n          renderMatrixInputs(); renderMatrices(null);\n        });\n        directedSel.addEventListener('change', () => {\n          directed = (directedSel.value === 'true');\n          // if toggling to undirected, mirror matrix\n          if (!directed) {\n            for (let i=0;i<n;i++){\n              for (let j=0;j<n;j++){\n                if (i!==j) {\n                  // choose minimum if both exist\n                  const aij = adj[i][j], aji = adj[j][i];\n                  if (aij !== INF) adj[j][i] = aij;\n                  else if (aji !== INF) adj[i][j] = aji;\n                }\n              }\n            }\n            renderMatrixInputs();\n            renderMatrices(null);\n          }\n        });\n        allowNegSel.addEventListener('change', () => {\n          allowNeg = (allowNegSel.value === 'true');\n        });\n\n        makeRandomBtn.addEventListener('click', () => {\n          randomizeGraph();\n        });\n\n        resetBtn.addEventListener('click', () => {\n          adj = buildDefaultAdj(n);\n          snapshots = []; currentStep = -1; stopPlay();\n          renderMatrixInputs(); renderMatrices(null);\n          updateStatus('Matrix reset');\n        });\n\n        runBtn.addEventListener('click', () => {\n          // validate no NaN entries in inputs\n          const bad = false;\n          // recompute adj from inputs (in case user edited directly)\n          // but inputs already updated adj on change event; nothing to do.\n          snapshots = runFloydWithSnapshots();\n          currentStep = 0;\n          goToStep(currentStep);\n          updateStatus('Run complete (step history recorded)');\n          stepInfo.textContent = `Step ${currentStep+1} of ${snapshots.length}`;\n        });\n\n        runFastBtn.addEventListener('click', () => {\n          runFloydFinalOnly();\n        });\n\n        stepForwardBtn.addEventListener('click', () => { stopPlay(); stepForward(); });\n        stepBackBtn.addEventListener('click', () => { stopPlay(); stepBack(); });\n        playPauseBtn.addEventListener('click', () => {\n          if (playing) stopPlay(); else play();\n        });\n\n        speedInput.addEventListener('input', () => {\n          if (playing) {\n            stopPlay();\n            play();\n          }\n        });\n\n        showPathBtn.addEventListener('click', () => {\n          if (snapshots.length === 0) { pathResult.textContent = 'No computed matrices yet.'; return; }\n          const finalSnap = snapshots[snapshots.length - 1];\n          if (!finalSnap.final) {\n            // find last final-like snapshot (there is one at end)\n            // but prefer actual final\n          }\n          const next = finalSnap.next;\n          const u = Number(fromNodeSel.value);\n          const v = Number(toNodeSel.value);\n          if (finalSnap.finalNegCycle && finalSnap.dist.some((row, i) => row[i] < 0)) {\n            pathResult.innerHTML = '<span style=\"color:#b80d0d\">Warning: negative cycle exists — shortest paths undefined for some pairs.</span>';\n            return;\n          }\n          if (u === v) {\n            pathResult.textContent = `${indexToLabel(u)} → ${indexToLabel(v)} (trivial): distance 0`;\n            return;\n          }\n          const path = reconstructPath(next, u, v);\n          if (!path) {\n            pathResult.textContent = `No path from ${indexToLabel(u)} to ${indexToLabel(v)}.`;\n            return;\n          }\n          const dist = finalSnap.dist[u][v];\n          pathResult.textContent = `Path: ${path.map(indexToLabel).join(' → ')}  (distance = ${formatVal(dist)})`;\n        });\n\n        // keyboard shortcuts for convenience\n        window.addEventListener('keydown', (e) => {\n          if (e.key === ' ' && document.activeElement.tagName !== 'INPUT') {\n            e.preventDefault();\n            if (playing) stopPlay(); else play();\n          } else if (e.key === 'ArrowRight') { stepForward(); }\n          else if (e.key === 'ArrowLeft') { stepBack(); }\n        });\n\n      }\n\n      init();\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Floyd-Warshall Algorithm"
    }
  ],
  "topic": "Floyd-Warshall Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}