{
  "id": "cc1f0ce3-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:29.010Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Linear Regression",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>Linear Regression Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 0; background: #f5f7fb; color: #222; }\n  header { padding: 18px 22px; background: linear-gradient(90deg,#3b82f6,#06b6d4); color: white; }\n  header h1 { margin: 0; font-size: 20px; }\n  main { display: flex; gap: 18px; padding: 18px; }\n  .canvas-wrap { background: white; border-radius: 8px; padding: 12px; box-shadow: 0 6px 18px rgba(15,23,42,0.08); flex: 1; display: flex; flex-direction: column; }\n  canvas { background: #ffffff; border-radius: 6px; border: 1px solid #e6eef8; cursor: crosshair; }\n  .controls { width: 360px; background: white; border-radius: 8px; padding: 16px; box-shadow: 0 6px 18px rgba(15,23,42,0.06); }\n  .section { margin-bottom: 12px; }\n  label { display: block; font-size: 13px; color: #334155; margin-bottom: 6px; }\n  input[type=\"range\"] { width: 100%; }\n  button, .btn { background: #2563eb; color: white; border: none; padding: 8px 10px; border-radius: 6px; cursor: pointer; }\n  .btn.secondary { background: #e6eef8; color: #0f172a; }\n  .row { display:flex; gap:8px; align-items:center; }\n  .small { font-size: 13px; color: #475569; }\n  .stats { background:#fbfdff; border-radius:6px; padding:10px; border: 1px solid #e6eef8; }\n  .stat-row { display:flex; justify-content:space-between; margin-bottom:6px; font-size:13px; color:#0f172a; }\n  .method { display:flex; gap:8px; margin-bottom:8px; }\n  .hint { font-size:13px; color:#475569; margin-top:8px; }\n  footer { padding:12px 18px; font-size:13px; color:#334155; }\n  .point-count { font-weight:600; color:#0f172a; }\n  .control-grid { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }\n  .link { color:#2563eb; text-decoration:underline; cursor:pointer; background:none; border:none; padding:0; font-size:13px; }\n</style>\n</head>\n<body>\n<header>\n  <h1>Linear Regression — Interactive Demo</h1>\n</header>\n\n<main>\n  <div class=\"canvas-wrap\">\n    <div style=\"display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;\">\n      <div>\n        <strong>Scatter Plot</strong>\n        <div class=\"small\">Click to add points. Drag to move. Shift+Click to remove nearest point.</div>\n      </div>\n      <div class=\"small\">Points: <span id=\"pointCount\" class=\"point-count\">0</span></div>\n    </div>\n    <canvas id=\"plot\" width=\"760\" height=\"520\"></canvas>\n    <div class=\"hint\" style=\"margin-top:10px;\">\n      Closed-form (OLS) = exact least-squares solution. Gradient Descent shows iterative convergence. R² and SSE update live.\n    </div>\n  </div>\n\n  <div class=\"controls\">\n    <div class=\"section\">\n      <label>Data</label>\n      <div class=\"control-grid\">\n        <div>\n          <label class=\"small\">Generate points</label>\n          <div class=\"row\">\n            <input id=\"nPoints\" type=\"number\" min=\"2\" max=\"500\" value=\"20\" style=\"width:80px;padding:6px;border-radius:6px;border:1px solid #e6eef8\" />\n            <select id=\"pattern\" style=\"padding:6px;border-radius:6px;border:1px solid #e6eef8\">\n              <option value=\"linear\">Linear</option>\n              <option value=\"linear_outliers\">Linear + outliers</option>\n              <option value=\"cluster\">Clusters</option>\n              <option value=\"noisy_slope\">Noisy slope</option>\n              <option value=\"random\">Random</option>\n            </select>\n          </div>\n          <div style=\"margin-top:8px;\" class=\"row\">\n            <button id=\"genBtn\" class=\"btn\">Generate</button>\n            <button id=\"clearBtn\" class=\"btn secondary\">Clear</button>\n          </div>\n        </div>\n\n        <div>\n          <label class=\"small\">Noise (std)</label>\n          <input id=\"noise\" type=\"range\" min=\"0\" max=\"2\" step=\"0.01\" value=\"0.25\">\n          <div class=\"small\" style=\"display:flex;justify-content:space-between;\"><span>0</span><span id=\"noiseVal\">0.25</span><span>2</span></div>\n          <div style=\"margin-top:8px;\" class=\"small\">Random seed: <input id=\"seed\" type=\"number\" value=\"42\" style=\"width:90px;padding:6px;border-radius:6px;border:1px solid #e6eef8\" /></div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <label>Method</label>\n      <div class=\"method\">\n        <label><input type=\"radio\" name=\"method\" value=\"ols\" checked> Closed-form (OLS)</label>\n        <label><input type=\"radio\" name=\"method\" value=\"gd\"> Gradient Descent</label>\n      </div>\n\n      <div id=\"gdControls\" style=\"display:none; margin-top:8px;\">\n        <label class=\"small\">Learning rate</label>\n        <input id=\"lr\" type=\"range\" min=\"0.0001\" max=\"0.5\" step=\"0.0001\" value=\"0.01\">\n        <div class=\"row\" style=\"margin-top:6px;\">\n          <label class=\"small\">Iterations</label>\n          <input id=\"iters\" type=\"number\" min=\"1\" max=\"20000\" value=\"200\" style=\"width:100px;padding:6px;border-radius:6px;border:1px solid #e6eef8\" />\n          <button id=\"runGD\" class=\"btn\">Run</button>\n          <button id=\"animateGD\" class=\"btn secondary\">Animate</button>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"section stats\">\n      <div class=\"stat-row\"><div>Slope (m)</div><div id=\"slope\">—</div></div>\n      <div class=\"stat-row\"><div>Intercept (b)</div><div id=\"intercept\">—</div></div>\n      <div class=\"stat-row\"><div>SSE (sum squared errors)</div><div id=\"sse\">—</div></div>\n      <div class=\"stat-row\"><div>R²</div><div id=\"r2\">—</div></div>\n      <div class=\"stat-row\"><div>Method</div><div id=\"methodName\">OLS</div></div>\n    </div>\n\n    <div style=\"margin-top:12px;\">\n      <div class=\"small\">Hints:</div>\n      <ul style=\"margin:8px 0 0 18px; color:#475569; font-size:13px;\">\n        <li>OLS computes the exact minimum of SSE in one step.</li>\n        <li>Gradient Descent iteratively updates parameters by descending the SSE surface.</li>\n        <li>Add and move points to see how slope/intercept change.</li>\n      </ul>\n    </div>\n\n    <div style=\"margin-top:12px; display:flex; justify-content:space-between;\">\n      <button id=\"resetParams\" class=\"btn secondary\">Reset GD params</button>\n      <button id=\"export\" class=\"btn\">Export CSV</button>\n    </div>\n  </div>\n</main>\n\n<footer>\n  Demo: Simple linear regression (1D) — click to add training points. Use Shift+Click to remove the nearest point.\n</footer>\n\n<script>\n/*\n  Linear Regression Interactive Demo\n  - Click canvas to add points\n  - Drag to move points\n  - Shift+Click to remove nearest\n  - Generate datasets, change noise\n  - Compare closed-form OLS and gradient descent\n*/\n\n(() => {\n  // Canvas and drawing\n  const canvas = document.getElementById('plot');\n  const ctx = canvas.getContext('2d');\n  const W = canvas.width, H = canvas.height;\n  const margin = {left:56, right:18, top:18, bottom:48};\n  const innerW = W - margin.left - margin.right;\n  const innerH = H - margin.top - margin.bottom;\n\n  // UI elements\n  const pointCountEl = document.getElementById('pointCount');\n  const genBtn = document.getElementById('genBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const nPointsEl = document.getElementById('nPoints');\n  const noiseEl = document.getElementById('noise');\n  const noiseVal = document.getElementById('noiseVal');\n  const seedEl = document.getElementById('seed');\n  const patternEl = document.getElementById('pattern');\n  const methodRadios = document.getElementsByName('method');\n  const gdControls = document.getElementById('gdControls');\n  const lrEl = document.getElementById('lr');\n  const itersEl = document.getElementById('iters');\n  const runGD = document.getElementById('runGD');\n  const animateGD = document.getElementById('animateGD');\n  const slopeEl = document.getElementById('slope');\n  const interceptEl = document.getElementById('intercept');\n  const sseEl = document.getElementById('sse');\n  const r2El = document.getElementById('r2');\n  const methodNameEl = document.getElementById('methodName');\n  const resetParamsBtn = document.getElementById('resetParams');\n  const exportBtn = document.getElementById('export');\n\n  noiseVal.textContent = noiseEl.value;\n\n  // Data storage: array of {x,y}\n  let points = [];\n\n  // Current model parameters\n  let model = {m: 0, b: 0};        // used for display; if GD is running, modelGD tracks iterative params\n  let modelGD = {m: 0, b: 0};\n  let gdAnimating = false;\n  let gdAnimationId = null;\n\n  // RNG (seedable for reproducible datasets)\n  let seed = Number(seedEl.value) || 1;\n  function rng() {\n    // xorshift32\n    seed = (seed ^ (seed << 13)) >>> 0;\n    seed = (seed ^ (seed >>> 17)) >>> 0;\n    seed = (seed ^ (seed << 5)) >>> 0;\n    return (seed >>> 0) / 4294967295;\n  }\n\n  // Coordinate transforms (data domain chosen: x in [0,1], y in [0,1])\n  function xToPx(x) { return margin.left + x * innerW; }\n  function yToPx(y) { return margin.top + (1 - y) * innerH; } // invert y\n  function pxToX(px) { return Math.min(1, Math.max(0, (px - margin.left) / innerW)); }\n  function pxToY(py) { return Math.min(1, Math.max(0, 1 - (py - margin.top) / innerH)); }\n\n  // Drawing grid, axes, points, line, residuals\n  function draw() {\n    ctx.clearRect(0,0,W,H);\n    drawBackground();\n    drawGrid();\n    drawAxes();\n    drawLine();       // draws fitted line (model)\n    drawResiduals();\n    drawPoints();\n    drawLegend();\n  }\n\n  function drawBackground() {\n    // subtle background\n    ctx.fillStyle = '#fff';\n    ctx.fillRect(0,0,W,H);\n  }\n\n  function drawGrid() {\n    ctx.strokeStyle = '#eef6ff';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    // vertical grid (x)\n    for (let i=0;i<=10;i++) {\n      let x = margin.left + (innerW/10)*i;\n      ctx.moveTo(x, margin.top);\n      ctx.lineTo(x, H - margin.bottom);\n    }\n    // horizontal grid (y)\n    for (let j=0;j<=10;j++) {\n      let y = margin.top + (innerH/10)*j;\n      ctx.moveTo(margin.left, y);\n      ctx.lineTo(W - margin.right, y);\n    }\n    ctx.stroke();\n  }\n\n  function drawAxes() {\n    ctx.strokeStyle = '#cfe7ff';\n    ctx.lineWidth = 1.4;\n    ctx.beginPath();\n    // x axis\n    ctx.moveTo(margin.left, H - margin.bottom);\n    ctx.lineTo(W - margin.right, H - margin.bottom);\n    // y axis\n    ctx.moveTo(margin.left, margin.top);\n    ctx.lineTo(margin.left, H - margin.bottom);\n    ctx.stroke();\n\n    // labels\n    ctx.fillStyle = '#334155';\n    ctx.font = '13px system-ui, -apple-system, \"Segoe UI\", Roboto';\n    ctx.textAlign = 'center';\n    for (let i=0;i<=5;i++) {\n      let x = margin.left + innerW * (i/5);\n      ctx.fillText((i/5).toFixed(2), x, H - margin.bottom + 18);\n    }\n    ctx.textAlign = 'right';\n    for (let i=0;i<=5;i++) {\n      let y = margin.top + innerH * (i/5);\n      ctx.fillText((1 - i/5).toFixed(2), margin.left - 8, y + 4);\n    }\n  }\n\n  function drawPoints() {\n    for (let i=0;i<points.length;i++) {\n      let p = points[i];\n      const px = xToPx(p.x), py = yToPx(p.y);\n      // ring\n      ctx.beginPath();\n      ctx.fillStyle = 'white';\n      ctx.strokeStyle = '#0f172a';\n      ctx.lineWidth = 1.4;\n      ctx.arc(px, py, 6, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n\n      // fill with blue\n      ctx.beginPath();\n      ctx.fillStyle = '#2563eb';\n      ctx.arc(px, py, 3.7, 0, Math.PI*2);\n      ctx.fill();\n    }\n  }\n\n  function drawLine() {\n    if (points.length < 2) return;\n    // Use current method to draw main line (if GD and animating, use modelGD else use model)\n    const activeMethod = getMethod();\n    let m = model.m, b = model.b;\n    if (activeMethod === 'gd') {\n      // when GD animate or run, use modelGD for display; otherwise show model (which might be OLS)\n      m = modelGD.m;\n      b = modelGD.b;\n    }\n    // draw line across x=0..1\n    const y0 = b + m * 0;\n    const y1 = b + m * 1;\n    const px0 = xToPx(0), py0 = yToPx(y0);\n    const px1 = xToPx(1), py1 = yToPx(y1);\n\n    // line\n    ctx.beginPath();\n    ctx.moveTo(px0, py0);\n    ctx.lineTo(px1, py1);\n    ctx.strokeStyle = (activeMethod === 'ols' ? '#065f46' : '#b91c1c');\n    ctx.lineWidth = 2.4;\n    ctx.stroke();\n\n    // area of prediction shadow\n    ctx.strokeStyle = (activeMethod === 'ols' ? 'rgba(6,95,70,0.08)' : 'rgba(185,28,28,0.08)');\n    ctx.lineWidth = 1.0;\n  }\n\n  function drawResiduals() {\n    if (points.length < 1) return;\n    const activeMethod = getMethod();\n    let m = model.m, b = model.b;\n    if (activeMethod === 'gd') {\n      m = modelGD.m;\n      b = modelGD.b;\n    }\n    for (let p of points) {\n      const px = xToPx(p.x), py = yToPx(p.y);\n      const yPred = b + m * p.x;\n      const pyPred = yToPx(yPred);\n      ctx.beginPath();\n      ctx.moveTo(px, py);\n      ctx.lineTo(px, pyPred);\n      ctx.strokeStyle = 'rgba(15,23,42,0.12)';\n      ctx.lineWidth = 1.6;\n      ctx.stroke();\n    }\n  }\n\n  function drawLegend() {\n    // top-left legend with method and parameter values\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    ctx.fillRect(W - margin.right - 180, margin.top + 8, 170, 64);\n    ctx.strokeStyle = '#e6eef8';\n    ctx.strokeRect(W - margin.right - 180, margin.top + 8, 170, 64);\n\n    ctx.fillStyle = '#0f172a';\n    ctx.font = '13px system-ui, -apple-system, \"Segoe UI\", Roboto';\n    ctx.textAlign = 'left';\n    ctx.fillText('Method: ' + capitalize(getMethod()), W - margin.right - 168, margin.top + 26);\n    ctx.fillStyle = '#0f172a';\n    ctx.fillText('m: ' + (Number(modelGD.m.toFixed(4))), W - margin.right - 168, margin.top + 44);\n    ctx.fillText('b: ' + (Number(modelGD.b.toFixed(4))), W - margin.right - 88, margin.top + 44);\n  }\n\n  // Compute OLS closed form\n  function fitOLS(pts) {\n    if (!pts || pts.length === 0) {\n      return {m: 0, b: 0};\n    }\n    const n = pts.length;\n    let meanX = 0, meanY = 0;\n    for (let p of pts) { meanX += p.x; meanY += p.y; }\n    meanX /= n; meanY /= n;\n    let num = 0, den = 0;\n    for (let p of pts) {\n      num += (p.x - meanX) * (p.y - meanY);\n      den += (p.x - meanX) * (p.x - meanX);\n    }\n    // handle zero variance\n    const m = den === 0 ? 0 : num / den;\n    const b = meanY - m * meanX;\n    return {m, b};\n  }\n\n  // Compute error metrics\n  function computeStats(pts, m, b) {\n    if (!pts || pts.length === 0) return {sse: 0, r2: 0};\n    let sse = 0, sst = 0;\n    let meanY = pts.reduce((s,p)=>s+p.y,0) / pts.length;\n    for (let p of pts) {\n      const err = p.y - (b + m * p.x);\n      sse += err * err;\n      const tot = p.y - meanY;\n      sst += tot * tot;\n    }\n    const r2 = (sst === 0) ? 1 : Math.max(0, 1 - sse / sst);\n    return {sse, r2};\n  }\n\n  // Gradient Descent (batch) on SSE for parameters m and b\n  function gradientDescentStep(pts, m, b, lr) {\n    // gradients: d/dm = (-2/N)*sum x*(y - (b+mx)), d/db = (-2/N)*sum (y - (b+mx))\n    const n = pts.length;\n    if (n === 0) return {m,b};\n    let dm = 0, db = 0;\n    for (let p of pts) {\n      const pred = b + m * p.x;\n      const err = p.y - pred;\n      dm += -2 * p.x * err;\n      db += -2 * err;\n    }\n    dm /= n; db /= n;\n    const mNew = m - lr * dm;\n    const bNew = b - lr * db;\n    return {m: mNew, b: bNew};\n  }\n\n  // UI interactions: adding/removing/draging points\n  let draggingIndex = -1;\n  let dragOffset = {dx:0, dy:0};\n\n  canvas.addEventListener('mousedown', (evt) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = evt.clientX - rect.left;\n    const y = evt.clientY - rect.top;\n    const dataX = pxToX(x), dataY = pxToY(y);\n\n    const nearest = findNearestPoint(dataX, dataY);\n    if (evt.shiftKey && nearest.index !== -1 && nearest.dist < 0.08) {\n      // remove nearest\n      points.splice(nearest.index, 1);\n      updateAndDraw();\n      return;\n    }\n\n    if (nearest.index !== -1 && nearest.dist < 0.06) {\n      // start dragging\n      draggingIndex = nearest.index;\n      dragOffset.dx = points[draggingIndex].x - dataX;\n      dragOffset.dy = points[draggingIndex].y - dataY;\n      canvas.style.cursor = 'grabbing';\n    } else {\n      // add a point\n      points.push({x: dataX, y: dataY});\n      updateAndDraw();\n      // Also set this new point as dragging - immediate move while mouse down\n      draggingIndex = points.length - 1;\n      dragOffset.dx = 0;\n      dragOffset.dy = 0;\n    }\n  });\n\n  canvas.addEventListener('mousemove', (evt) => {\n    if (draggingIndex === -1) return;\n    const rect = canvas.getBoundingClientRect();\n    const dataX = pxToX(evt.clientX - rect.left) + dragOffset.dx;\n    const dataY = pxToY(evt.clientY - rect.top) + dragOffset.dy;\n    // clamp\n    points[draggingIndex].x = Math.max(0, Math.min(1, dataX));\n    points[draggingIndex].y = Math.max(0, Math.min(1, dataY));\n    updateAndDraw();\n  });\n\n  window.addEventListener('mouseup', () => {\n    draggingIndex = -1;\n    canvas.style.cursor = 'crosshair';\n  });\n\n  function findNearestPoint(x,y) {\n    let best = {index:-1, dist: Infinity};\n    for (let i=0;i<points.length;i++) {\n      const dx = points[i].x - x;\n      const dy = points[i].y - y;\n      const d = Math.sqrt(dx*dx + dy*dy);\n      if (d < best.dist) { best.dist = d; best.index = i; }\n    }\n    return best;\n  }\n\n  // Buttons and controls\n  genBtn.addEventListener('click', () => {\n    seed = Number(seedEl.value) || 1;\n    generateDataset(Number(nPointsEl.value), patternEl.value, Number(noiseEl.value));\n    updateAndDraw();\n  });\n\n  clearBtn.addEventListener('click', () => {\n    points = [];\n    updateAndDraw();\n  });\n\n  noiseEl.addEventListener('input', () => {\n    noiseVal.textContent = Number(noiseEl.value).toFixed(2);\n  });\n\n  for (const r of methodRadios) {\n    r.addEventListener('change', () => {\n      gdControls.style.display = (getMethod() === 'gd') ? 'block' : 'none';\n      methodNameEl.textContent = getMethod().toUpperCase();\n      if (getMethod() === 'ols') {\n        // compute OLS model immediately\n        model = fitOLS(points);\n        modelGD = { ...model };\n      }\n      updateAndDraw();\n    });\n  }\n\n  function getMethod() {\n    for (const r of methodRadios) if (r.checked) return r.value;\n    return 'ols';\n  }\n\n  runGD.addEventListener('click', () => {\n    if (points.length < 2) return;\n    const lr = Number(lrEl.value);\n    const iters = Number(itersEl.value);\n    // initialize params to OLS for stability or zeros\n    modelGD = { ...model }; // start from closed-form to show refinement quickly\n    // run iteratively\n    for (let i=0;i<iters;i++) {\n      modelGD = gradientDescentStep(points, modelGD.m, modelGD.b, lr);\n    }\n    // update displayed model when done\n    if (getMethod() === 'gd') {\n      updateAndDraw();\n    }\n  });\n\n  animateGD.addEventListener('click', () => {\n    if (points.length < 2) return;\n    if (gdAnimating) {\n      stopGDAnimation();\n    } else {\n      startGDAnimation();\n    }\n  });\n\n  function startGDAnimation() {\n    gdAnimating = true;\n    animateGD.textContent = 'Stop';\n    modelGD = { ...model }; // start from OLS for better visuals\n    let lr = Number(lrEl.value);\n    let step = 0;\n    function stepFn() {\n      if (!gdAnimating) return;\n      // take a few mini-steps per frame for speed\n      for (let k=0;k<3;k++) modelGD = gradientDescentStep(points, modelGD.m, modelGD.b, lr);\n      step++;\n      updateAndDraw();\n      gdAnimationId = requestAnimationFrame(stepFn);\n    }\n    stepFn();\n  }\n\n  function stopGDAnimation() {\n    gdAnimating = false;\n    animateGD.textContent = 'Animate';\n    if (gdAnimationId) cancelAnimationFrame(gdAnimationId);\n    gdAnimationId = null;\n  }\n\n  resetParamsBtn.addEventListener('click', () => {\n    lrEl.value = 0.01;\n    itersEl.value = 200;\n  });\n\n  exportBtn.addEventListener('click', () => {\n    // export points to CSV\n    if (points.length === 0) return alert('No points to export');\n    let csv = 'x,y\\n' + points.map(p => `${p.x},${p.y}`).join('\\n');\n    const blob = new Blob([csv], {type: 'text/csv'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url; a.download = 'points.csv'; document.body.appendChild(a);\n    a.click(); a.remove();\n    URL.revokeObjectURL(url);\n  });\n\n  // Dataset generation patterns\n  function generateDataset(n, pattern='linear', noiseStd=0.2) {\n    points = [];\n    seed = Number(seedEl.value) || 1;\n    if (pattern === 'linear') {\n      const trueM = 0.8, trueB = 0.1;\n      for (let i=0;i<n;i++) {\n        const x = i/(n-1) * 0.9 + 0.05 * rng();\n        const y = trueB + trueM * x + gaussianNoise(0, noiseStd);\n        points.push({x: clamp(x,0,1), y: clamp(y,0,1)});\n      }\n    } else if (pattern === 'linear_outliers') {\n      const trueM = 0.6, trueB = 0.15;\n      for (let i=0;i<n;i++) {\n        let x = rng();\n        let y = trueB + trueM * x + gaussianNoise(0, noiseStd);\n        if (i % Math.max(3, Math.floor(n/8)) === 0) {\n          y += (rng() > 0.5 ? 0.6 : -0.6); // outlier\n        }\n        points.push({x: clamp(x,0,1), y: clamp(y,0,1)});\n      }\n    } else if (pattern === 'cluster') {\n      const centers = [{x:0.2,y:0.2},{x:0.4,y:0.75},{x:0.8,y:0.6}];\n      for (let i=0;i<n;i++) {\n        const c = centers[Math.floor(rng()*centers.length)];\n        points.push({x: clamp(c.x + gaussianNoise(0,0.06),0,1), y: clamp(c.y + gaussianNoise(0,0.06),0,1)});\n      }\n    } else if (pattern === 'noisy_slope') {\n      // slope varies slowly across x\n      for (let i=0;i<n;i++) {\n        const x = rng();\n        const m = 0.2 + 1.0 * x; // slope depends on x\n        const b = 0.05;\n        const y = b + m*x + gaussianNoise(0,noiseStd);\n        points.push({x: clamp(x,0,1), y: clamp(y,0,1)});\n      }\n    } else {\n      for (let i=0;i<n;i++) points.push({x: rng(), y: rng()});\n    }\n    // compute initial OLS\n    model = fitOLS(points);\n    modelGD = { ...model };\n  }\n\n  // Utilities\n  function clamp(v,a,b) { return Math.max(a, Math.min(b, v)); }\n  function gaussianNoise(mean=0, std=1) {\n    // Box-Muller\n    let u = 0, v = 0;\n    while (u === 0) u = rng();\n    while (v === 0) v = rng();\n    let z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n    return z * std + mean;\n  }\n  function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }\n\n  // Update stats/UI and draw\n  function updateAndDraw() {\n    pointCountEl.textContent = points.length;\n    // update models\n    if (points.length >= 2) {\n      // OLS model always available\n      model = fitOLS(points);\n      if (getMethod() === 'ols') {\n        modelGD = { ...model };\n      } else {\n        // if gd not animating, we might still want to keep modelGD; do not override\n        if (!gdAnimating && points.length >= 2 && (modelGD === undefined || isNaN(modelGD.m))) {\n          modelGD = { ...model };\n        }\n      }\n    } else {\n      model = {m:0,b:0};\n      modelGD = {m:0,b:0};\n    }\n\n    // compute stats for whichever method is active (displayed)\n    const activeMethod = getMethod();\n    const m = activeMethod === 'gd' ? modelGD.m : model.m;\n    const b = activeMethod === 'gd' ? modelGD.b : model.b;\n    const stats = computeStats(points, m, b);\n    slopeEl.textContent = points.length < 1 ? '—' : Number(m.toFixed(4));\n    interceptEl.textContent = points.length < 1 ? '—' : Number(b.toFixed(4));\n    sseEl.textContent = points.length < 1 ? '—' : Number(stats.sse.toFixed(6));\n    r2El.textContent = points.length < 1 ? '—' : Number(stats.r2.toFixed(4));\n    methodNameEl.textContent = activeMethod.toUpperCase();\n    draw();\n  }\n\n  // Initialize with sample dataset\n  generateDataset(20, 'linear', Number(noiseEl.value));\n  updateAndDraw();\n\n  // Allow keyboard shortcuts for convenience\n  window.addEventListener('keydown', (e) => {\n    if (e.key === 'g') { genBtn.click(); }\n    if (e.key === 'c') { clearBtn.click(); }\n    if (e.key === ' ') { // space toggles gd animate\n      if (getMethod() === 'gd') animateGD.click();\n    }\n  });\n\n  // Small: when resizing window, keep canvas same but allow crisp redraw\n  window.addEventListener('resize', () => { draw(); });\n\n  // When points change externally (drag, add), stop GD animation (so user can adjust)\n  const stopGDOnInteraction = () => { if (gdAnimating) stopGDAnimation(); };\n  canvas.addEventListener('mousedown', stopGDOnInteraction);\n  genBtn.addEventListener('click', stopGDOnInteraction);\n  clearBtn.addEventListener('click', stopGDOnInteraction);\n\n  // If user toggles method to OLS, compute OLS and show\n  // Already handled by event listener above.\n\n  // Prevent text selection when dragging\n  canvas.addEventListener('dragstart', (e) => e.preventDefault());\n\n  // Initial draw\n  draw();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Linear Regression"
    }
  ],
  "topic": "Linear Regression",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}