{
  "id": "cc1d5f31-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:34.829Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Interactive Graph (Directed / Undirected)</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<style>\n  body { font-family: system-ui, -apple-system, Roboto, \"Segoe UI\", Arial; margin: 0; display: flex; height: 100vh; }\n  #sidebar { width: 320px; padding: 14px; box-sizing: border-box; border-right: 1px solid #ddd; background: #f8f9fb; overflow: auto; }\n  #canvasWrap { flex: 1; position: relative; }\n  canvas { width: 100%; height: 100%; display: block; background: #fff; cursor: crosshair; }\n  h2 { margin: 8px 0 12px; font-size: 16px; }\n  .control { margin-bottom: 10px; }\n  label { display: block; margin-bottom: 6px; font-size: 13px; color: #333; }\n  select, input[type=\"number\"], input[type=\"text\"] { width: 100%; padding: 6px 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }\n  button { padding: 8px 10px; margin-right: 8px; border-radius: 4px; border: 1px solid #5b8; background: #0b8c64; color: white; cursor: pointer; }\n  button.secondary { background: #fff; border: 1px solid #bbb; color: #222; }\n  .modes { display:flex; gap:6px; margin-bottom:10px; }\n  .modeBtn { flex:1; padding:8px; border-radius:4px; border:1px solid #bbb; background:#fff; cursor:pointer; text-align:center; }\n  .modeBtn.active { background: #0b8c64; color: #fff; border-color:#069154; }\n  .small { font-size:13px; color:#555; margin-top:6px; }\n  pre { background:#fff; border:1px solid #ddd; padding:8px; border-radius:4px; max-height:220px; overflow:auto; font-size:13px; }\n  .row { display:flex; gap:8px; align-items:center; }\n  .row > * { flex: 1; }\n  footer { margin-top:12px; font-size:12px; color:#666; }\n  .hint { font-size:12px; color:#666; margin-bottom:8px; }\n</style>\n</head>\n<body>\n  <div id=\"sidebar\">\n    <h2>Interactive Graph (Directed / Undirected)</h2>\n    <div class=\"hint\">\n      Modes:\n      - Add Node: click canvas to add nodes.\n      - Add Edge: click source then target to add an edge (use Weight if needed).\n      - Move: drag nodes.\n      - Delete: click a node or edge to remove.\n    </div>\n\n    <div class=\"modes\">\n      <div id=\"btnAddNode\" class=\"modeBtn active\">Add Node</div>\n      <div id=\"btnAddEdge\" class=\"modeBtn\">Add Edge</div>\n      <div id=\"btnMove\" class=\"modeBtn\">Move</div>\n      <div id=\"btnDelete\" class=\"modeBtn\">Delete</div>\n    </div>\n\n    <div class=\"control\">\n      <label><input type=\"checkbox\" id=\"directedCheck\" checked> Directed graph</label>\n      <div class=\"small\">Toggle whether the graph is directed. When undirected, edges are symmetric.</div>\n    </div>\n\n    <div class=\"control\">\n      <label>Edge weight (used when adding edges)</label>\n      <input type=\"number\" id=\"edgeWeight\" value=\"1\" />\n    </div>\n\n    <div class=\"control row\">\n      <button id=\"clearBtn\" class=\"secondary\">Clear</button>\n      <button id=\"randomBtn\">Random Graph</button>\n    </div>\n\n    <div class=\"control\">\n      <label>Graph info</label>\n      <div class=\"small\" id=\"infoNodes\">Nodes: 0</div>\n      <div class=\"small\" id=\"infoEdges\">Edges: 0</div>\n    </div>\n\n    <div class=\"control\">\n      <label>Adjacency List</label>\n      <pre id=\"adjList\">[]</pre>\n    </div>\n\n    <div class=\"control\">\n      <label>Adjacency Matrix</label>\n      <pre id=\"adjMatrix\">[]</pre>\n    </div>\n\n    <footer>\n      Tip: Try switching between directed and undirected. When undirected, adding an edge creates symmetric entries. Reciprocal directed edges are drawn as curved pair.\n    </footer>\n  </div>\n\n  <div id=\"canvasWrap\">\n    <canvas id=\"graphCanvas\"></canvas>\n  </div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n  let dpr = window.devicePixelRatio || 1;\n\n  function resizeCanvas() {\n    const rect = canvas.getBoundingClientRect();\n    canvas.width = Math.floor(rect.width * dpr);\n    canvas.height = Math.floor(rect.height * dpr);\n    ctx.setTransform(dpr,0,0,dpr,0,0);\n    draw();\n  }\n  window.addEventListener('resize', () => { dpr = window.devicePixelRatio || 1; resizeCanvas(); });\n  resizeCanvas();\n\n  // Graph data\n  let nodes = []; // {id, x, y}\n  let edges = []; // {from, to, weight}\n  let nextNodeId = 0;\n  let mode = 'addnode'; // addnode, addedge, move, delete\n  let isDirected = true;\n\n  // UI elements\n  const btnAddNode = document.getElementById('btnAddNode');\n  const btnAddEdge = document.getElementById('btnAddEdge');\n  const btnMove = document.getElementById('btnMove');\n  const btnDelete = document.getElementById('btnDelete');\n  const directedCheck = document.getElementById('directedCheck');\n  const edgeWeightInput = document.getElementById('edgeWeight');\n  const clearBtn = document.getElementById('clearBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const infoNodes = document.getElementById('infoNodes');\n  const infoEdges = document.getElementById('infoEdges');\n  const adjListPre = document.getElementById('adjList');\n  const adjMatrixPre = document.getElementById('adjMatrix');\n\n  function setMode(newMode) {\n    mode = newMode;\n    [btnAddNode, btnAddEdge, btnMove, btnDelete].forEach(b => b.classList.remove('active'));\n    if (mode === 'addnode') btnAddNode.classList.add('active');\n    if (mode === 'addedge') btnAddEdge.classList.add('active');\n    if (mode === 'move') btnMove.classList.add('active');\n    if (mode === 'delete') btnDelete.classList.add('active');\n    canvas.style.cursor = (mode === 'move') ? 'grab' : 'crosshair';\n    selectedForEdge = null;\n  }\n  btnAddNode.addEventListener('click', () => setMode('addnode'));\n  btnAddEdge.addEventListener('click', () => setMode('addedge'));\n  btnMove.addEventListener('click', () => setMode('move'));\n  btnDelete.addEventListener('click', () => setMode('delete'));\n  directedCheck.addEventListener('change', () => { isDirected = directedCheck.checked; draw(); updateInfo(); });\n\n  clearBtn.addEventListener('click', () => {\n    nodes = []; edges = []; nextNodeId = 0; selectedForEdge = null; draw(); updateInfo();\n  });\n\n  randomBtn.addEventListener('click', () => {\n    // create a small random graph\n    nodes = []; edges = []; nextNodeId = 0;\n    const rect = canvas.getBoundingClientRect();\n    const N = Math.floor(Math.random()*6)+4;\n    for (let i=0;i<N;i++){\n      addNode(Math.random()*(rect.width-80)+40, Math.random()*(rect.height-80)+40);\n    }\n    const M = Math.floor(Math.random()*(N*(N-1)/2));\n    for (let i=0;i<M;i++){\n      const a = nodes[Math.floor(Math.random()*nodes.length)];\n      const b = nodes[Math.floor(Math.random()*nodes.length)];\n      if (!a || !b || a.id===b.id) continue;\n      addEdgeInternal(a.id,b.id, Math.floor(Math.random()*9)+1);\n    }\n    draw(); updateInfo();\n  });\n\n  function addNode(x,y) {\n    nodes.push({id: nextNodeId++, x, y});\n  }\n\n  function addEdgeInternal(from, to, weight=1) {\n    // Add directed edge (from->to) if not duplicate\n    if (edges.some(e => e.from===from && e.to===to)) return;\n    edges.push({from, to, weight});\n    // If graph is undirected, keep symmetric by also adding reverse if missing\n    if (!isDirected) {\n      if (!edges.some(e => e.from===to && e.to===from)) {\n        edges.push({from: to, to: from, weight});\n      }\n    }\n  }\n\n  // For Add Edge mode click handling\n  let selectedForEdge = null;\n\n  // For Move mode\n  let draggingNode = null;\n  let dragOffset = {x:0,y:0};\n\n  // Utility\n  function getNodeAt(x,y) {\n    for (let i=nodes.length-1;i>=0;i--){\n      const n = nodes[i];\n      const dx = x-n.x, dy = y-n.y;\n      if (Math.hypot(dx,dy) <= 18) return n;\n    }\n    return null;\n  }\n\n  function drawArrowhead(x1,y1,x2,y2, size=8) {\n    const angle = Math.atan2(y2-y1, x2-x1);\n    ctx.save();\n    ctx.translate(x2, y2);\n    ctx.rotate(angle);\n    ctx.beginPath();\n    ctx.moveTo(-size, -size/2);\n    ctx.lineTo(0, 0);\n    ctx.lineTo(-size, size/2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function draw() {\n    const rect = canvas.getBoundingClientRect();\n    ctx.clearRect(0,0,rect.width,rect.height);\n\n    // Edges first\n    // We'll draw undirected edges without arrowheads and deduplicate symmetric edges (draw once)\n    const drawnPairs = new Set();\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = '#333';\n    ctx.fillStyle = '#333';\n\n    for (let e of edges) {\n      const a = nodes.find(n => n.id===e.from);\n      const b = nodes.find(n => n.id===e.to);\n      if (!a || !b) continue;\n      // For undirected view, only draw one segment for pair\n      if (!isDirected) {\n        const key = (a.id < b.id) ? `${a.id}-${b.id}` : `${b.id}-${a.id}`;\n        if (drawnPairs.has(key)) continue;\n        drawnPairs.add(key);\n        drawEdgeSegment(a,b, false, null);\n      } else {\n        // directed mode: if reciprocal exists, draw curved pair\n        const reciprocal = edges.find(x => x.from===b.id && x.to===a.id);\n        const pairKey = `${e.from}->${e.to}`;\n        if (reciprocal && e.from < e.to) {\n          // we'll draw both curves in one go: draw e.forward curved one way and reciprocal curved the other\n          drawCurvedPair(a,b);\n        } else if (!reciprocal) {\n          drawEdgeSegment(a,b, true, null);\n        } else if (e.from > e.to) {\n          // already drawn when e.from < e.to\n        }\n      }\n    }\n\n    // Node styling\n    for (const n of nodes) {\n      ctx.beginPath();\n      ctx.fillStyle = '#fff';\n      ctx.strokeStyle = '#1b6';\n      ctx.lineWidth = 2;\n      ctx.arc(n.x, n.y, 18, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n\n      ctx.fillStyle = '#333';\n      ctx.font = '13px system-ui,Segoe UI,Roboto,Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(n.id), n.x, n.y);\n    }\n\n    // If edge selected for creation, highlight source\n    if (selectedForEdge) {\n      ctx.beginPath();\n      ctx.strokeStyle = '#f39c12';\n      ctx.lineWidth = 2;\n      ctx.arc(selectedForEdge.x, selectedForEdge.y, 22, 0, Math.PI*2);\n      ctx.stroke();\n    }\n  }\n\n  function drawEdgeSegment(a,b, arrow=true, weight=null) {\n    // Straight line between centers, offset for loops\n    if (a.id === b.id) {\n      // self-loop: draw a circle arc\n      const x = a.x, y = a.y;\n      ctx.beginPath();\n      ctx.strokeStyle = '#333';\n      ctx.lineWidth = 2;\n      ctx.arc(x+22, y-22, 16, 0.5, 2.5*Math.PI);\n      ctx.stroke();\n      if (arrow && isDirected) {\n        // draw small arrow on loop\n        drawArrowhead(x+22 + Math.cos(1.8)*16, y-22 + Math.sin(1.8)*16, x+22 + Math.cos(1.55)*16, y-22 + Math.sin(1.55)*16);\n      }\n      if (weight !== null) {\n        ctx.fillStyle = '#000';\n        ctx.font = '12px sans-serif';\n        ctx.fillText(String(weight), x+22, y-22);\n      }\n      return;\n    }\n\n    const ax = a.x, ay = a.y, bx = b.x, by = b.y;\n    ctx.beginPath();\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 2;\n\n    // Move endpoints slightly to be at node boundaries\n    const angle = Math.atan2(by - ay, bx - ax);\n    const offset = 18;\n    const sx = ax + Math.cos(angle) * offset;\n    const sy = ay + Math.sin(angle) * offset;\n    const ex = bx - Math.cos(angle) * offset;\n    const ey = by - Math.sin(angle) * offset;\n\n    ctx.moveTo(sx, sy);\n    ctx.lineTo(ex, ey);\n    ctx.stroke();\n\n    if (arrow && isDirected) {\n      ctx.fillStyle = '#333';\n      drawArrowhead(sx, sy, ex, ey, 8);\n    }\n\n    if (weight !== null) {\n      ctx.fillStyle = '#000';\n      ctx.font = '12px sans-serif';\n      const midx = (sx+ex)/2 + (Math.random()*0.1);\n      const midy = (sy+ey)/2;\n      ctx.fillText(String(weight), midx, midy);\n    }\n  }\n\n  function drawCurvedPair(a,b) {\n    // Draw two curved directed edges between a and b (one in each direction)\n    const ax = a.x, ay = a.y, bx = b.x, by = b.y;\n    const dx = bx-ax, dy = by-ay;\n    const dist = Math.hypot(dx,dy);\n    if (dist < 30) { drawEdgeSegment(a,b,true,null); return; }\n\n    // Control point offset perpendicular\n    const mx = (ax+bx)/2, my = (ay+by)/2;\n    const nx = -dy/dist, ny = dx/dist;\n    const offset = Math.min(60, dist/3)+12;\n\n    // First curve: control point = mid + normal*offset\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(ax + Math.cos(Math.atan2(dy,dx))*18, ay + Math.sin(Math.atan2(dy,dx))*18);\n    ctx.quadraticCurveTo(mx + nx*offset, my + ny*offset, bx - Math.cos(Math.atan2(dy,dx))*18, by - Math.sin(Math.atan2(dy,dx))*18);\n    ctx.stroke();\n\n    // Arrow for first\n    const t = 0.65;\n    const cp1x = mx + nx*offset, cp1y = my + ny*offset;\n    const p1x = quadraticPoint(ax + Math.cos(Math.atan2(dy,dx))*18, ay + Math.sin(Math.atan2(dy,dx))*18, cp1x, cp1y, bx - Math.cos(Math.atan2(dy,dx))*18, by - Math.sin(Math.atan2(dy,dx))*18, t);\n    const p1tx = quadraticTangent(ax + Math.cos(Math.atan2(dy,dx))*18, ay + Math.sin(Math.atan2(dy,dx))*18, cp1x, cp1y, bx - Math.cos(Math.atan2(dy,dx))*18, by - Math.sin(Math.atan2(dy,dx))*18, t);\n    ctx.fillStyle = '#333';\n    drawArrowhead(p1x.x - p1tx.x*6, p1x.y - p1tx.y*6, p1x.x, p1x.y, 8);\n\n    // Second curve: control point = mid - normal*offset\n    ctx.beginPath();\n    ctx.moveTo(ax + Math.cos(Math.atan2(dy,dx))*18, ay + Math.sin(Math.atan2(dy,dx))*18);\n    ctx.quadraticCurveTo(mx - nx*offset, my - ny*offset, bx - Math.cos(Math.atan2(dy,dx))*18, by - Math.sin(Math.atan2(dy,dx))*18);\n    ctx.stroke();\n\n    // Arrow for second (opposite direction)\n    const cp2x = mx - nx*offset, cp2y = my - ny*offset;\n    const t2 = 0.35;\n    const p2x = quadraticPoint(ax + Math.cos(Math.atan2(dy,dx))*18, ay + Math.sin(Math.atan2(dy,dx))*18, cp2x, cp2y, bx - Math.cos(Math.atan2(dy,dx))*18, by - Math.sin(Math.atan2(dy,dx))*18, t2);\n    const p2tx = quadraticTangent(ax + Math.cos(Math.atan2(dy,dx))*18, ay + Math.sin(Math.atan2(dy,dx))*18, cp2x, cp2y, bx - Math.cos(Math.atan2(dy,dx))*18, by - Math.sin(Math.atan2(dy,dx))*18, t2);\n    ctx.fillStyle = '#333';\n    drawArrowhead(p2x.x - p2tx.x*6, p2x.y - p2tx.y*6, p2x.x, p2x.y, 8);\n  }\n\n  function quadraticPoint(x0,y0, cx,cy, x1,y1, t) {\n    const x = (1-t)*(1-t)*x0 + 2*(1-t)*t*cx + t*t*x1;\n    const y = (1-t)*(1-t)*y0 + 2*(1-t)*t*cy + t*t*y1;\n    return {x,y};\n  }\n  function quadraticTangent(x0,y0, cx,cy, x1,y1, t) {\n    // derivative\n    const x = 2*(1-t)*(cx - x0) + 2*t*(x1 - cx);\n    const y = 2*(1-t)*(cy - y0) + 2*t*(y1 - cy);\n    const len = Math.hypot(x,y) || 1;\n    return {x: x/len, y: y/len};\n  }\n\n  // Canvas event handling\n  canvas.addEventListener('pointerdown', (ev) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = (ev.clientX - rect.left);\n    const y = (ev.clientY - rect.top);\n    if (mode === 'addnode') {\n      addNode(x,y);\n      draw();\n      updateInfo();\n    } else if (mode === 'addedge') {\n      const n = getNodeAt(x,y);\n      if (n) {\n        if (!selectedForEdge) {\n          selectedForEdge = n;\n        } else {\n          const weight = parseFloat(edgeWeightInput.value) || 1;\n          if (selectedForEdge.id === n.id) {\n            // self loop\n            addEdgeInternal(selectedForEdge.id, n.id, weight);\n          } else {\n            addEdgeInternal(selectedForEdge.id, n.id, weight);\n          }\n          selectedForEdge = null;\n          updateInfo();\n        }\n        draw();\n      }\n    } else if (mode === 'move') {\n      const n = getNodeAt(x,y);\n      if (n) {\n        draggingNode = n;\n        dragOffset.x = x - n.x;\n        dragOffset.y = y - n.y;\n        canvas.setPointerCapture(ev.pointerId);\n        canvas.style.cursor = 'grabbing';\n      }\n    } else if (mode === 'delete') {\n      // check node first\n      const n = getNodeAt(x,y);\n      if (n) {\n        // remove node and incident edges\n        nodes = nodes.filter(nd => nd.id !== n.id);\n        edges = edges.filter(e => e.from !== n.id && e.to !== n.id);\n        updateInfo(); draw(); return;\n      }\n      // else check nearest edge within tolerance\n      const hit = findEdgeNear(x,y, 8);\n      if (hit) {\n        if (isDirected) {\n          // remove single edge\n          edges = edges.filter(e => !(e.from===hit.from && e.to===hit.to));\n        } else {\n          // remove both directions between these nodes\n          edges = edges.filter(e => !( (e.from===hit.from && e.to===hit.to) || (e.from===hit.to && e.to===hit.from) ));\n        }\n        updateInfo(); draw();\n      }\n    }\n  });\n\n  canvas.addEventListener('pointermove', (ev) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = (ev.clientX - rect.left);\n    const y = (ev.clientY - rect.top);\n    if (draggingNode) {\n      draggingNode.x = x - dragOffset.x;\n      draggingNode.y = y - dragOffset.y;\n      draw();\n    }\n  });\n\n  canvas.addEventListener('pointerup', (ev) => {\n    if (draggingNode) {\n      draggingNode = null;\n      canvas.releasePointerCapture(ev.pointerId);\n      canvas.style.cursor = 'grab';\n      updateInfo();\n    }\n  });\n\n  // Clicking blank canvas in addedge mode should deselect source if clicking nowhere\n  canvas.addEventListener('dblclick', () => {\n    selectedForEdge = null; draw();\n  });\n\n  // Edge hit detection\n  function findEdgeNear(px,py, tol=6) {\n    // Return one edge {from,to} if within tol to any drawn segment/curve\n    // Check straight edges and curved pairs by sampling\n    for (const e of edges) {\n      const a = nodes.find(n => n.id===e.from);\n      const b = nodes.find(n => n.id===e.to);\n      if (!a || !b) continue;\n      if (a.id === b.id) {\n        // loop: approximate circle center\n        const cx = a.x+22, cy = a.y-22, r = 16;\n        const d = Math.abs(Math.hypot(px-cx, py-cy) - r);\n        if (d < tol) return {from:a.id, to:b.id};\n      } else {\n        const reciprocal = edges.find(x => x.from===b.id && x.to===a.id);\n        if (isDirected && reciprocal && e.from < e.to) {\n          // we drew two curves; sample points along each curve and check\n          const mx = (a.x+b.x)/2, my = (a.y+b.y)/2;\n          const dist = Math.hypot(b.x-a.x, b.y-a.y);\n          const nx = -(b.y-a.y)/dist, ny = (b.x-a.x)/dist;\n          const offset = Math.min(60, dist/3)+12;\n          // first curve\n          for (let t=0.0;t<=1.0;t+=0.05) {\n            const pt = quadraticPoint(a.x + Math.cos(Math.atan2(b.y-a.y,b.x-a.x))*18, a.y + Math.sin(Math.atan2(b.y-a.y,b.x-a.x))*18, mx + nx*offset, my + ny*offset, b.x - Math.cos(Math.atan2(b.y-a.y,b.x-a.x))*18, b.y - Math.sin(Math.atan2(b.y-a.y,b.x-a.x))*18, t);\n            if (Math.hypot(pt.x-px, pt.y-py) < tol) return {from: e.from, to: e.to};\n          }\n          for (let t=0.0;t<=1.0;t+=0.05) {\n            const pt = quadraticPoint(a.x + Math.cos(Math.atan2(b.y-a.y,b.x-a.x))*18, a.y + Math.sin(Math.atan2(b.y-a.y,b.x-a.x))*18, mx - nx*offset, my - ny*offset, b.x - Math.cos(Math.atan2(b.y-a.y,b.x-a.x))*18, b.y - Math.sin(Math.atan2(b.y-a.y,b.x-a.x))*18, t);\n            if (Math.hypot(pt.x-px, pt.y-py) < tol) return {from: e.from, to: e.to};\n          }\n        } else {\n          // plain segment (or single of pair when e.from > e.to)\n          const angle = Math.atan2(b.y-a.y, b.x-a.x);\n          const sx = a.x + Math.cos(angle) * 18;\n          const sy = a.y + Math.sin(angle) * 18;\n          const ex = b.x - Math.cos(angle) * 18;\n          const ey = b.y - Math.sin(angle) * 18;\n          const d = pointToSegmentDistance({x:px,y:py},{x:sx,y:sy},{x:ex,y:ey});\n          if (d < tol) return {from: e.from, to: e.to};\n        }\n      }\n    }\n    return null;\n  }\n\n  function pointToSegmentDistance(p, v, w) {\n    // p and v,w are points {x,y}\n    const l2 = (v.x-w.x)*(v.x-w.x)+(v.y-w.y)*(v.y-w.y);\n    if (l2===0) return Math.hypot(p.x-v.x, p.y-v.y);\n    let t = ((p.x - v.x)*(w.x - v.x) + (p.y - v.y)*(w.y - v.y)) / l2;\n    t = Math.max(0, Math.min(1, t));\n    const proj = {x: v.x + t*(w.x-v.x), y: v.y + t*(w.y-v.y)};\n    return Math.hypot(p.x-proj.x, p.y-proj.y);\n  }\n\n  // Info & adjacency exporters\n  function buildAdjacency() {\n    const ids = nodes.map(n => n.id).sort((a,b)=>a-b);\n    const idIndex = new Map(ids.map((id,idx)=>[id,idx]));\n    const N = ids.length;\n    const matrix = Array.from({length:N}, ()=>Array(N).fill(0));\n    const list = {};\n    for (const id of ids) list[id] = [];\n    for (const e of edges) {\n      if (!idIndex.has(e.from) || !idIndex.has(e.to)) continue;\n      const i = idIndex.get(e.from), j = idIndex.get(e.to);\n      // For undirected view, show symmetric: but edges array may already contain symmetric entries\n      matrix[i][j] = e.weight;\n      list[e.from].push({to: e.to, w: e.weight});\n      if (!isDirected) {\n        // ensure symmetric in matrix/list display (if reverse missing, show same weight)\n        matrix[j][i] = Math.max(matrix[j][i], e.weight);\n        // add counterpart only if not already present\n        if (!list[e.to].some(x=>x.to===e.from)) list[e.to].push({to:e.from, w:e.weight});\n      }\n    }\n    return {ids, matrix, list};\n  }\n\n  function updateInfo() {\n    infoNodes.textContent = 'Nodes: ' + nodes.length;\n    // Count edges displayed (for undirected count unique pairs)\n    let edgeCount = 0;\n    if (isDirected) edgeCount = edges.length;\n    else {\n      const pairs = new Set();\n      for (const e of edges) {\n        const a = Math.min(e.from, e.to), b = Math.max(e.from, e.to);\n        pairs.add(`${a}-${b}`);\n      }\n      edgeCount = pairs.size;\n    }\n    infoEdges.textContent = 'Edges: ' + edgeCount;\n\n    const adj = buildAdjacency();\n    // Adjacency list as readable string\n    const listLines = adj.ids.map(id => {\n      const seg = adj.list[id].map(x => `${x.to}${(x.w!=null ? '('+x.w+')' : '')}`).join(', ');\n      return `${id}: [ ${seg} ]`;\n    }).join('\\n');\n    adjListPre.textContent = listLines || '[]';\n\n    // Matrix display\n    const header = ['  ', ...adj.ids].join('\\t');\n    const rows = adj.matrix.map((row, idx) => `${adj.ids[idx]}\\t${row.map(v=>v||0).join('\\t')}`).join('\\n');\n    adjMatrixPre.textContent = header + '\\n' + rows;\n  }\n\n  // Initialize with a small sample\n  (function initSample(){\n    addNode(120,120); addNode(260,80); addNode(320,220); addNode(160,260);\n    addEdgeInternal(0,1, 4);\n    addEdgeInternal(1,2, 2);\n    addEdgeInternal(2,0, 7);\n    addEdgeInternal(2,3, 1);\n    updateInfo();\n    draw();\n  })();\n\n  // Recompute on changes\n  function redrawAndUpdate() { draw(); updateInfo(); }\n  // Expose addEdgeInternal to canvas double click to finish if needed\n  // Keep UI responsive\n  // Final draw\n  draw();\n  updateInfo();\n\n  // Keyboard shortcut: Esc clears selectedForEdge\n  window.addEventListener('keydown', (e) => {\n    if (e.key === 'Escape') { selectedForEdge = null; draw(); }\n    if (e.key === 'Delete' || e.key === 'Backspace') {\n      // if in delete mode, allow deleting last node\n      if (mode === 'delete' && nodes.length) {\n        const last = nodes[nodes.length-1];\n        nodes = nodes.slice(0, -1);\n        edges = edges.filter(e => e.from !== last.id && e.to !== last.id);\n        updateInfo(); draw();\n      }\n    }\n  });\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}