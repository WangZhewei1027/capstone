<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Huffman Coding Demonstration</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --accent: #2b8cff;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #a6b0c3;
      --card: #081324;
      --accent-2: #26c6a0;
      --danger: #ff6b6b;
    }
    body {
      margin: 0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #071126 0%, #081226 100%);
      color: #e6eef8;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    header {
      padding: 18px 24px;
      display:flex;
      align-items:center;
      gap:12px;
      border-bottom: 1px solid rgba(255,255,255,0.03);
    }
    header h1 {
      margin:0;
      font-size:18px;
      letter-spacing: -0.2px;
    }
    .container {
      display: grid;
      grid-template-columns: 420px 1fr;
      gap: 18px;
      padding: 18px;
      height: calc(100vh - 68px);
      box-sizing: border-box;
    }
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 10px;
      padding: 14px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
      overflow: auto;
      min-height: 0;
    }
    .input-area textarea {
      width:100%;
      height:200px;
      background: transparent;
      color: var(--muted);
      border: 1px dashed rgba(255,255,255,0.03);
      padding: 10px;
      border-radius: 8px;
      resize: vertical;
    }
    .controls {
      margin-top:10px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    button, .btn {
      background: linear-gradient(180deg,var(--accent), #1b6eea);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight:600;
      box-shadow: 0 6px 12px rgba(43,140,255,0.12);
    }
    button.ghost {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.04);
      color: var(--muted);
      box-shadow: none;
    }
    .small {
      padding:6px 8px;
      font-size:13px;
      border-radius:7px;
    }
    .row {
      display:flex;
      gap:8px;
      align-items:center;
      margin-top:8px;
    }
    .muted {
      color: var(--muted);
      font-size: 13px;
    }
    .freq-table, .code-table {
      margin-top:12px;
      width:100%;
      border-collapse:collapse;
      font-size: 13px;
    }
    .freq-table th, .freq-table td, .code-table th, .code-table td {
      text-align:left;
      padding:6px 8px;
      border-bottom: 1px dashed rgba(255,255,255,0.02);
      color: #d5e4fb;
    }
    .code-table th, .freq-table th {
      color: var(--muted);
      font-weight:700;
    }
    .stats {
      margin-top:12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .stat {
      background: rgba(255,255,255,0.02);
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
    }
    .visual {
      display:flex;
      gap:12px;
      height:100%;
    }
    .right {
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .svg-wrapper {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:10px;
      padding:8px;
      border: 1px solid rgba(255,255,255,0.02);
      min-height: 260px;
      overflow:auto;
    }
    svg { width:100%; height:380px; }
    .steps {
      margin-top:10px;
      font-size:13px;
      max-height:180px;
      overflow:auto;
    }
    .step {
      padding:8px;
      border-radius:8px;
      cursor:pointer;
      display:flex;
      justify-content:space-between;
      gap:8px;
    }
    .step:hover { background: rgba(255,255,255,0.01); }
    .step.active { background: linear-gradient(90deg, rgba(43,140,255,0.08), rgba(38,198,160,0.02)); }
    .bitbox {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      background: rgba(255,255,255,0.02);
      padding:8px;
      border-radius:8px;
      font-size:13px;
      max-height:140px;
      overflow:auto;
      color:#dbeeff;
    }
    .footer-controls {
      display:flex;
      gap:8px;
      margin-top:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .legend { margin-top:8px; font-size:13px; color:var(--muted); }
    .tag { background: rgba(255,255,255,0.03); padding:6px 8px; border-radius:6px; font-size:13px; }
    .danger { background: linear-gradient(180deg,#ff8b8b,#ff6b6b); color:#111; }
    .kbd { background: rgba(255,255,255,0.03); padding:4px 8px; border-radius:6px; font-family: monospace; font-size:12px; }
    @media (max-width:900px){
      .container { grid-template-columns: 1fr; height: auto; padding-bottom: 40px;}
      svg { height: 300px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Huffman Coding — Interactive Demonstration</h1>
    <div style="margin-left:auto" class="muted">Build tree → Generate codes → Encode/Decode</div>
  </header>

  <div class="container">
    <div class="panel input-area">
      <label class="muted">Input text (type or paste). Use the sample button to try a phrase.</label>
      <textarea id="inputText" placeholder="Type text here...">this is an example for huffman encoding</textarea>

      <div class="controls">
        <button id="buildBtn">Build Huffman Tree & Encode</button>
        <button id="sampleBtn" class="ghost small">Load sample</button>
        <button id="clearBtn" class="ghost small">Clear</button>
      </div>

      <div class="row">
        <div class="muted">Decoding:</div>
        <input id="decodeBits" placeholder="Paste encoded bits here" style="flex:1; background:transparent; border:1px dashed rgba(255,255,255,0.03); padding:6px; border-radius:8px; color:var(--muted)" />
        <button id="decodeBtn" class="small">Decode</button>
      </div>

      <div class="row">
        <div id="decodedOutput" style="flex:1; min-height:34px; color:var(--muted)"></div>
      </div>

      <div class="stats">
        <div class="stat">Unique symbols: <span id="uniqueCount">-</span></div>
        <div class="stat">Original size: <span id="origBits">-</span> bits</div>
        <div class="stat">Compressed size: <span id="compBits">-</span> bits</div>
        <div class="stat">Ratio: <span id="ratio">-</span></div>
      </div>

      <div style="margin-top:12px;">
        <div class="muted">Frequencies</div>
        <table class="freq-table" id="freqTable">
          <thead><tr><th>Symbol</th><th>Count</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>

      <div style="margin-top:10px;">
        <div class="muted">Codes</div>
        <table class="code-table" id="codeTable">
          <thead><tr><th>Symbol</th><th>Code</th><th>Length</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>

      <div style="margin-top:10px;">
        <div class="muted">Encoded bitstring</div>
        <div class="bitbox" id="bitstringBox"></div>
        <div class="footer-controls">
          <button id="copyBits" class="small ghost">Copy bits</button>
          <button id="downloadBits" class="small">Download bits (.txt)</button>
          <button id="resetBtn" class="small ghost">Reset view</button>
        </div>
      </div>

    </div>

    <div class="panel right">
      <div style="display:flex; gap:12px;">
        <div style="flex:1;">
          <div class="muted">Huffman Tree (step visualization)</div>
          <div class="svg-wrapper">
            <svg id="treeSvg" viewBox="0 0 1200 500" preserveAspectRatio="xMidYMid meet"></svg>
          </div>
          <div class="row" style="margin-top:8px;">
            <button id="prevStep" class="small ghost">Prev</button>
            <button id="nextStep" class="small ghost">Next</button>
            <div class="muted" style="margin-left:auto">Step <span id="currStep">0</span> / <span id="totalSteps">0</span></div>
          </div>
        </div>

        <div style="width:360px;">
          <div class="muted">Priority queue & merges</div>
          <div class="steps" id="stepsList"></div>
          <div class="legend">Click a step to visualize the forest at that point. Final step is the complete tree.</div>
        </div>
      </div>

      <div style="margin-top:12px;">
        <div class="muted">Notes</div>
        <div class="tag">This demo assumes 8 bits per original character when computing compression ratio. Spaces and punctuation are treated as symbols. For a single unique symbol, the code assigned will be "0".</div>
      </div>
    </div>
  </div>

  <script>
    // Huffman Coding interactive demo
    (function(){
      // Utilities
      function uid() {
        return Math.random().toString(36).slice(2, 9);
      }

      // DOM
      const inputText = document.getElementById('inputText');
      const buildBtn = document.getElementById('buildBtn');
      const sampleBtn = document.getElementById('sampleBtn');
      const clearBtn = document.getElementById('clearBtn');
      const freqTableBody = document.querySelector('#freqTable tbody');
      const codeTableBody = document.querySelector('#codeTable tbody');
      const bitstringBox = document.getElementById('bitstringBox');
      const origBitsEl = document.getElementById('origBits');
      const compBitsEl = document.getElementById('compBits');
      const ratioEl = document.getElementById('ratio');
      const uniqueCountEl = document.getElementById('uniqueCount');
      const decodeBits = document.getElementById('decodeBits');
      const decodeBtn = document.getElementById('decodeBtn');
      const decodedOutput = document.getElementById('decodedOutput');
      const treeSvg = document.getElementById('treeSvg');
      const stepsList = document.getElementById('stepsList');
      const prevStepBtn = document.getElementById('prevStep');
      const nextStepBtn = document.getElementById('nextStep');
      const currStepEl = document.getElementById('currStep');
      const totalStepsEl = document.getElementById('totalSteps');
      const copyBits = document.getElementById('copyBits');
      const downloadBits = document.getElementById('downloadBits');
      const resetBtn = document.getElementById('resetBtn');

      sampleBtn.addEventListener('click', ()=> {
        inputText.value = 'Huffman coding is a compression algorithm that assigns shorter codes to more frequent symbols.';
      });
      clearBtn.addEventListener('click', ()=> {
        inputText.value = '';
        resetDisplay();
      });

      function resetDisplay(){
        freqTableBody.innerHTML = '';
        codeTableBody.innerHTML = '';
        bitstringBox.textContent = '';
        origBitsEl.textContent = '-';
        compBitsEl.textContent = '-';
        ratioEl.textContent = '-';
        uniqueCountEl.textContent = '-';
        decodedOutput.textContent = '';
        stepsList.innerHTML = '';
        treeSvg.innerHTML = '';
        currStepEl.textContent = '0';
        totalStepsEl.textContent = '0';
      }

      // Build Huffman Tree algorithm with snapshots
      function computeFrequencies(text) {
        const freqs = new Map();
        for (const ch of text) {
          freqs.set(ch, (freqs.get(ch) || 0) + 1);
        }
        return freqs;
      }

      function buildHuffmanSnapshots(freqMap) {
        // Node structure stored in nodesMap: id -> {id, weight, symbols:[], leftId, rightId}
        const nodesMap = new Map();
        const roots = []; // array of current root ids
        // initialize leaves
        for (const [sym, w] of freqMap.entries()) {
          const id = uid();
          nodesMap.set(id, { id, weight: w, symbols: [sym], leftId: null, rightId: null, isLeaf: true, symbol: sym });
          roots.push(id);
        }
        // sort initial roots by weight then by symbol for deterministic output
        roots.sort((a,b) => {
          const A = nodesMap.get(a), B=nodesMap.get(b);
          if (A.weight !== B.weight) return A.weight - B.weight;
          return (A.symbols.join('') > B.symbols.join('')) ? 1 : -1;
        });

        // snapshots: array of arrays of root ids
        const snapshots = [];
        // store initial snapshot (before any merges)
        snapshots.push({ roots: roots.slice(), merged: null });

        const mergeSteps = [];
        let stepIndex = 0;
        // Edge case: single symbol -> no merge needed
        while (roots.length > 1) {
          // pick two smallest
          const aId = roots.shift();
          const bId = roots.shift();
          const a = nodesMap.get(aId);
          const b = nodesMap.get(bId);
          // create merged node
          const newId = uid();
          const newNode = {
            id: newId,
            weight: a.weight + b.weight,
            symbols: a.symbols.concat(b.symbols).sort(),
            leftId: aId,
            rightId: bId,
            isLeaf: false
          };
          nodesMap.set(newId, newNode);
          // insert newId back to roots keeping sorted order
          let inserted = false;
          for (let i=0;i<roots.length;i++) {
            const n = nodesMap.get(roots[i]);
            if (newNode.weight < n.weight || (newNode.weight === n.weight && newNode.symbols.join('') < n.symbols.join(''))) {
              roots.splice(i,0,newId);
              inserted = true;
              break;
            }
          }
          if (!inserted) roots.push(newId);

          // record this merge step
          mergeSteps.push({ step: ++stepIndex, pick: [aId,bId], result: newId, nodesBefore: roots.slice(), mergedPair: {a, b}, newNode });

          // snapshot after merge
          snapshots.push({ roots: roots.slice(), merged: { aId, bId, newId } });
        }

        return { nodesMap, snapshots, mergeSteps };
      }

      function generateCodes(nodesMap) {
        // find root (the one node that isn't referenced as child)
        const ids = Array.from(nodesMap.keys());
        const referenced = new Set();
        for (const node of nodesMap.values()) {
          if (node.leftId) referenced.add(node.leftId);
          if (node.rightId) referenced.add(node.rightId);
        }
        let rootId = null;
        for (const id of ids) {
          if (!referenced.has(id)) { rootId = id; break; }
        }
        if (!rootId) rootId = ids[0];

        const codes = {};
        function dfs(id, prefix) {
          const node = nodesMap.get(id);
          if (!node) return;
          if (node.isLeaf) {
            // if prefix is empty (single symbol), assign '0'
            codes[node.symbol] = prefix === '' ? '0' : prefix;
            return;
          }
          // by convention: left edge = 0, right edge = 1
          dfs(node.leftId, prefix + '0');
          dfs(node.rightId, prefix + '1');
        }
        dfs(rootId, '');
        return { codes, rootId };
      }

      function encodeText(text, codes) {
        let bits = '';
        for (const ch of text) {
          bits += codes[ch];
        }
        return bits;
      }

      function decodeBitsToText(bits, nodesMap, rootId) {
        if (!rootId) return '';
        if (!bits) {
          // if tree has single symbol, decode empty string to repeated symbol? In practical terms, encoding would produce '0's.
          // We'll return empty string.
          return '';
        }
        let result = '';
        let nodeId = rootId;
        let i = 0;
        while (i < bits.length) {
          const bit = bits[i];
          const node = nodesMap.get(nodeId);
          if (!node) break;
          if (node.isLeaf) {
            result += node.symbol;
            nodeId = rootId;
            // do not increment i
            continue;
          }
          nodeId = (bit === '0') ? node.leftId : node.rightId;
          i++;
          const nextNode = nodesMap.get(nodeId);
          if (!nextNode) break;
          if (nextNode.isLeaf) {
            result += nextNode.symbol;
            nodeId = rootId;
          }
        }
        return result;
      }

      // Drawing the forest for a given snapshot
      function drawForest(nodesMap, rootIds) {
        // clear svg
        while (treeSvg.firstChild) treeSvg.removeChild(treeSvg.firstChild);

        if (!rootIds || rootIds.length === 0) {
          return;
        }
        // Prepare a copy of node objects with references
        const localNodes = new Map();
        for (const [id, n] of nodesMap.entries()) {
          localNodes.set(id, Object.assign({}, n));
        }

        // For each tree, compute layout: x positions for leaves using in-order traversal
        const trees = [];
        for (const rootId of rootIds) {
          const root = localNodes.get(rootId);
          if (!root) continue;
          // gather leaves count and set up
          let leafCount = 0;
          function countLeaves(node) {
            if (!node) return 0;
            if (node.isLeaf) return 1;
            return countLeaves(localNodes.get(node.leftId)) + countLeaves(localNodes.get(node.rightId));
          }
          leafCount = countLeaves(root);
          trees.push({ rootId, leafCount });
        }
        const totalLeaves = trees.reduce((s,t)=>s+t.leafCount,0);
        // spacing
        const width = 1100;
        const height = 420;
        const leftMargin = 40;
        const rightMargin = 40;
        const avWidth = Math.max(12, (width - leftMargin - rightMargin) / Math.max(1,totalLeaves));

        // create a group for each tree positioned horizontally
        let nextLeafX = leftMargin;
        const svgNS = "http://www.w3.org/2000/svg";

        // assign x positions to leaves by doing inorder and incrementing nextLeafX
        const positions = new Map();
        function assignPositions(node, depth, offsetXRef) {
          if (!node) return { minX: 0, maxX: 0 };
          if (node.isLeaf) {
            const x = nextLeafX + avWidth/2;
            positions.set(node.id, { x, y: 40 + depth*70 });
            nextLeafX += avWidth;
            return { minX: x, maxX: x };
          }
          const left = localNodes.get(node.leftId);
          const right = localNodes.get(node.rightId);
          const L = assignPositions(left, depth+1, offsetXRef);
          const R = assignPositions(right, depth+1, offsetXRef);
          const x = (L.minX + R.maxX)/2;
          positions.set(node.id, { x, y: 40 + depth*70 });
          return { minX: L.minX, maxX: R.maxX };
        }

        for (const t of trees) {
          const root = localNodes.get(t.rootId);
          assignPositions(root, 0);
          // add a small separation between trees
          nextLeafX += avWidth * 0.3;
        }

        // Now draw edges and nodes
        // First edges
        for (const id of localNodes.keys()) {
          const node = localNodes.get(id);
          if (!positions.has(id)) continue;
          if (!node.isLeaf) {
            const p = positions.get(id);
            const leftPos = positions.get(node.leftId);
            const rightPos = positions.get(node.rightId);
            if (leftPos) {
              const line = document.createElementNS(svgNS, 'line');
              line.setAttribute('x1', p.x);
              line.setAttribute('y1', p.y + 14);
              line.setAttribute('x2', leftPos.x);
              line.setAttribute('y2', leftPos.y - 14);
              line.setAttribute('stroke', 'rgba(255,255,255,0.06)');
              line.setAttribute('stroke-width','2');
              treeSvg.appendChild(line);

              // edge label '0' near midpoint
              const mx = (p.x + leftPos.x)/2;
              const my = (p.y + 14 + leftPos.y - 14)/2 - 6;
              const t = document.createElementNS(svgNS, 'text');
              t.setAttribute('x', mx);
              t.setAttribute('y', my);
              t.setAttribute('fill', '#9fbefc');
              t.setAttribute('font-size','12');
              t.setAttribute('text-anchor','middle');
              t.textContent = '0';
              treeSvg.appendChild(t);
            }
            if (rightPos) {
              const line = document.createElementNS(svgNS, 'line');
              line.setAttribute('x1', p.x);
              line.setAttribute('y1', p.y + 14);
              line.setAttribute('x2', rightPos.x);
              line.setAttribute('y2', rightPos.y - 14);
              line.setAttribute('stroke', 'rgba(255,255,255,0.06)');
              line.setAttribute('stroke-width','2');
              treeSvg.appendChild(line);

              const mx = (p.x + rightPos.x)/2;
              const my = (p.y + 14 + rightPos.y - 14)/2 - 6;
              const t = document.createElementNS(svgNS, 'text');
              t.setAttribute('x', mx);
              t.setAttribute('y', my);
              t.setAttribute('fill', '#9ff1d6');
              t.setAttribute('font-size','12');
              t.setAttribute('text-anchor','middle');
              t.textContent = '1';
              treeSvg.appendChild(t);
            }
          }
        }

        // Then nodes (drawn on top)
        for (const id of localNodes.keys()) {
          if (!positions.has(id)) continue;
          const node = localNodes.get(id);
          const pos = positions.get(id);
          const g = document.createElementNS(svgNS, 'g');

          // node circle style: leaves one color, internal another
          const circle = document.createElementNS(svgNS, 'circle');
          circle.setAttribute('cx', pos.x);
          circle.setAttribute('cy', pos.y);
          circle.setAttribute('r', 16);
          circle.setAttribute('fill', node.isLeaf ? '#173a66' : '#1b2a3f');
          circle.setAttribute('stroke', node.isLeaf ? '#2f76ff' : '#26c6a0');
          circle.setAttribute('stroke-width', node.isLeaf ? 1.6 : 1.6);
          g.appendChild(circle);

          // weight text
          const t = document.createElementNS(svgNS, 'text');
          t.setAttribute('x', pos.x);
          t.setAttribute('y', pos.y + 5);
          t.setAttribute('fill', '#dbeeff');
          t.setAttribute('font-size', '12');
          t.setAttribute('text-anchor', 'middle');
          t.setAttribute('font-weight', '600');
          t.textContent = node.weight;
          g.appendChild(t);

          // if leaf, show symbol above
          if (node.isLeaf) {
            const sym = node.symbol === ' ' ? '␣' : node.symbol === '\n' ? '\\n' : node.symbol;
            const s = document.createElementNS(svgNS, 'text');
            s.setAttribute('x', pos.x);
            s.setAttribute('y', pos.y - 22);
            s.setAttribute('fill', '#a9d1ff');
            s.setAttribute('font-size', '12');
            s.setAttribute('text-anchor', 'middle');
            s.textContent = sym;
            g.appendChild(s);
          }

          treeSvg.appendChild(g);
        }

        // Set viewbox size
        const vbW = Math.max(600, nextLeafX + 40);
        treeSvg.setAttribute('viewBox', `0 0 ${vbW} 500`);
      }

      // UI state
      let globalNodesMap = new Map();
      let globalSnapshots = [];
      let globalMergeSteps = [];
      let globalCodes = {};
      let globalRootId = null;
      let currentStepIndex = 0;

      function renderStepsList(snapshots, mergeSteps, nodesMap) {
        stepsList.innerHTML = '';
        const total = snapshots.length;
        for (let i=0;i<snapshots.length;i++) {
          const snap = snapshots[i];
          const div = document.createElement('div');
          div.className = 'step';
          div.dataset.index = i;
          const left = document.createElement('div');
          left.style.flex = '1';
          left.innerHTML = `<strong>Step ${i}</strong>`;
          const right = document.createElement('div');
          right.style.color = 'var(--muted)';
          if (i === 0) {
            right.textContent = `initial: ${snap.roots.length} trees`;
          } else {
            const m = snap.merged;
            const a = nodesMap.get(m.aId);
            const b = nodesMap.get(m.bId);
            right.textContent = `merged ${a.weight} + ${b.weight} → ${nodesMap.get(m.newId).weight}`;
          }
          div.appendChild(left);
          div.appendChild(right);
          div.addEventListener('click', ()=> {
            setStep(i);
          });
          stepsList.appendChild(div);
        }
        totalStepsEl.textContent = Math.max(0,total-1);
      }

      function setStep(i) {
        currentStepIndex = i;
        currStepEl.textContent = i;
        // highlight active
        const children = stepsList.children;
        for (const ch of children) {
          ch.classList.toggle('active', Number(ch.dataset.index) === i);
        }
        // draw forest at snapshot i
        const snap = globalSnapshots[i];
        drawForest(globalNodesMap, snap.roots);
      }

      buildBtn.addEventListener('click', ()=> {
        const text = inputText.value;
        if (!text) { alert('Please enter some text.'); return; }
        // compute frequencies
        const freqMap = computeFrequencies(text);
        // sort freqMap by weight desc for table
        const freqArray = Array.from(freqMap.entries()).sort((a,b)=>b[1]-a[1] || a[0].localeCompare(b[0]));
        freqTableBody.innerHTML = '';
        for (const [sym, cnt] of freqArray) {
          const tr = document.createElement('tr');
          const td1 = document.createElement('td');
          td1.textContent = sym === ' ' ? '␣ (space)' : (sym === '\n' ? '\\n' : sym);
          const td2 = document.createElement('td');
          td2.textContent = cnt;
          tr.appendChild(td1); tr.appendChild(td2);
          freqTableBody.appendChild(tr);
        }
        uniqueCountEl.textContent = freqMap.size;

        // build tree snapshots
        const { nodesMap, snapshots, mergeSteps } = buildHuffmanSnapshots(freqMap);

        // generate codes
        const { codes, rootId } = generateCodes(nodesMap);
        globalNodesMap = nodesMap;
        globalSnapshots = snapshots;
        globalMergeSteps = mergeSteps;
        globalCodes = codes;
        globalRootId = rootId;

        // fill codes table
        const codesArray = Object.entries(codes).sort((a,b)=> a[0].localeCompare(b[0]));
        codeTableBody.innerHTML = '';
        for (const [sym, code] of codesArray) {
          const tr = document.createElement('tr');
          const td1 = document.createElement('td');
          td1.textContent = sym === ' ' ? '␣ (space)' : (sym === '\n' ? '\\n' : sym);
          const td2 = document.createElement('td');
          td2.innerHTML = `<span class="kbd">${code}</span>`;
          const td3 = document.createElement('td');
          td3.textContent = code.length;
          tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
          codeTableBody.appendChild(tr);
        }

        // encode
        const bits = encodeText(text, codes);
        bitstringBox.textContent = bits || '(empty)';

        // stats
        const origBits = text.length * 8;
        origBitsEl.textContent = origBits;
        const compBits = bits.length;
        compBitsEl.textContent = compBits;
        const ratio = (origBits === 0) ? '-' : ( (compBits / origBits * 100).toFixed(2) + '%' );
        ratioEl.textContent = ratio;

        // render steps
        renderStepsList(snapshots, mergeSteps, nodesMap);
        setStep(snapshots.length - 1); // final tree
      });

      prevStepBtn.addEventListener('click', ()=> {
        const newIndex = Math.max(0, currentStepIndex - 1);
        setStep(newIndex);
      });
      nextStepBtn.addEventListener('click', ()=> {
        const newIndex = Math.min(globalSnapshots.length-1, currentStepIndex + 1);
        setStep(newIndex);
      });

      decodeBtn.addEventListener('click', ()=> {
        const bits = decodeBits.value.trim();
        if (!globalNodesMap || globalNodesMap.size === 0) {
          decodedOutput.textContent = 'Build a Huffman tree first.';
          return;
        }
        if (!bits) {
          decodedOutput.textContent = '(empty)';
          return;
        }
        // validate bits
        if (!/^[01]+$/.test(bits)) {
          decodedOutput.textContent = 'Invalid bits (only 0/1 allowed).';
          return;
        }
        const decoded = decodeBitsToText(bits, globalNodesMap, globalRootId);
        decodedOutput.textContent = decoded || '(no output)';
      });

      copyBits.addEventListener('click', async ()=> {
        const bits = bitstringBox.textContent;
        if (!bits) return;
        try {
          await navigator.clipboard.writeText(bits);
          copyBits.textContent = 'Copied!';
          setTimeout(()=> copyBits.textContent = 'Copy bits', 1200);
        } catch(e) {
          copyBits.textContent = 'Failed';
          setTimeout(()=> copyBits.textContent = 'Copy bits', 1200);
        }
      });

      downloadBits.addEventListener('click', ()=> {
        const bits = bitstringBox.textContent;
        if (!bits) return;
        const blob = new Blob([bits], {type: 'text/plain;charset=utf-8'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'huffman_bits.txt';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      });

      resetBtn.addEventListener('click', ()=> {
        if (globalSnapshots && globalSnapshots.length > 0) {
          setStep(globalSnapshots.length-1);
        }
      });

      // Initialize
      resetDisplay();
      // Build once for initial content
      buildBtn.click();

      // Helper: decode using codes mapping if user prefers (not used in UI presently)
      window._huffman_demo = {
        computeFrequencies, buildHuffmanSnapshots, generateCodes, encodeText, decodeBitsToText
      };
    })();
  </script>
</body>
</html>