<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Hash Table Interactive Demo</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#38bdf8;
    --muted:#94a3b8;
    --good:#10b981;
    --bad:#ef4444;
    --card:#071029;
  }
  body{
    margin:0;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: linear-gradient(180deg,#07102b 0%, #0b1220 100%);
    color:#e6eef8;
    min-height:100vh;
    display:flex;
    gap:20px;
    padding:18px;
    box-sizing:border-box;
  }
  .container{
    display:flex;
    gap:18px;
    width:100%;
  }
  .left{
    width:360px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    border:1px solid rgba(255,255,255,0.04);
    border-radius:12px;
    padding:16px;
    box-sizing:border-box;
  }
  h1{margin:6px 0 10px;font-size:18px;}
  p.small{font-size:13px;color:var(--muted);margin:8px 0 12px;line-height:1.35}
  label{display:block;font-size:13px;margin-top:8px;color:var(--muted)}
  input[type="text"], input[type="number"], select {
    width:100%;
    padding:8px 10px;
    margin-top:6px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.06);
    background:rgba(255,255,255,0.02);
    color:inherit;
    box-sizing:border-box;
  }
  .row {display:flex;gap:8px;margin-top:12px}
  button{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.04);
    color:inherit;
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    font-weight:600;
  }
  button.primary{
    background:linear-gradient(180deg,var(--accent),#0ea5c9);
    color:#052127;
    border:none;
  }
  .stats{
    margin-top:14px;
    display:grid;
    grid-template-columns:repeat(2,1fr);
    gap:8px;
  }
  .stat{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    padding:10px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.02);
    font-size:13px;
  }
  .stat strong{display:block;font-size:16px}
  .visual{
    flex:1;
    padding:12px;
    border-radius:12px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    border:1px solid rgba(255,255,255,0.04);
    min-height:600px;
    box-sizing:border-box;
    overflow:auto;
  }
  .controls-note{
    font-size:12px;color:var(--muted);margin-top:8px;
  }
  .buckets{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    margin-top:12px;
  }
  .bucket{
    width:200px;
    min-height:48px;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
    border-radius:8px;
    padding:8px;
    box-sizing:border-box;
    border:1px solid rgba(255,255,255,0.02);
    position:relative;
  }
  .bucket-header{
    font-size:12px;color:var(--muted);display:flex;align-items:center;gap:8px;margin-bottom:6px;
  }
  .index-bubble{
    background:rgba(255,255,255,0.03);padding:4px 8px;border-radius:999px;font-weight:700;font-size:13px;
  }
  .chain{
    display:flex;gap:8px;flex-wrap:wrap;
  }
  .node{
    background:linear-gradient(180deg,#06293e,#043a55);
    border-radius:8px;padding:6px 8px;font-size:13px;box-shadow:0 2px 0 rgba(0,0,0,0.25);
    display:flex;flex-direction:column;gap:3px;border:1px solid rgba(255,255,255,0.02);
  }
  .node small{font-size:11px;color:var(--muted)}
  .highlight{box-shadow:0 0 0 3px rgba(56,189,248,0.12) inset, 0 6px 18px rgba(2,6,23,0.5)}
  .found {box-shadow:0 0 0 3px rgba(16,185,129,0.12) inset}
  .notfound {box-shadow:0 0 0 3px rgba(239,68,68,0.08) inset}
  .notice{
    margin-top:12px;padding:10px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);font-size:13px;border:1px solid rgba(255,255,255,0.02)
  }
  .footer{
    margin-top:12px;font-size:13px;color:var(--muted)
  }
  .muted{color:var(--muted)}
  .controls-row{display:flex;gap:8px}
  .small-btn{padding:6px 8px;font-size:13px;border-radius:8px}
  .toggle{display:flex;gap:6px;align-items:center;margin-top:8px}
  .help{font-size:13px;color:var(--muted);margin-top:10px}
  .badge{font-size:12px;padding:4px 6px;border-radius:999px;background:rgba(255,255,255,0.02)}
  footer{margin-top:18px;color:var(--muted);font-size:13px}
</style>
</head>
<body>
<div class="container">
  <div class="left">
    <h1>Hash Table — Interactive Demo</h1>
    <p class="small">
      This demo implements a hash table with separate chaining (each bucket holds a small list).
      You can insert, lookup and remove keys. The table auto-resizes when the load factor grows past the threshold.
    </p>

    <label>Key (string or number)</label>
    <input id="keyInput" type="text" placeholder="e.g. 'apple' or 42">

    <label>Value</label>
    <input id="valueInput" type="text" placeholder="e.g. 'fruit'">

    <div class="row">
      <button id="putBtn" class="primary">Insert / Update</button>
      <button id="getBtn">Get</button>
      <button id="removeBtn">Remove</button>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="containsBtn" class="small-btn">Contains?</button>
      <button id="randomBtn" class="small-btn">Insert Random</button>
      <button id="fillBtn" class="small-btn">Fill 40</button>
    </div>

    <label>Hash function</label>
    <select id="hashSelect">
      <option value="djb2">djb2 (recommended)</option>
      <option value="sum">Simple sum of char codes</option>
      <option value="js">JavaScript's built-in (string -> JSON) hashed by char codes</option>
    </select>

    <label>Initial capacity</label>
    <input id="capacityInput" type="number" min="2" step="1" value="8">

    <label>Resize load factor threshold (autosize when entries / capacity &gt; threshold)</label>
    <input id="thresholdInput" type="number" min="0.1" max="2" step="0.05" value="0.75">

    <div class="controls-note">Use "Fill 40" to create many collisions and trigger rehashing.</div>

    <div class="stats">
      <div class="stat"><strong id="statEntries">0</strong><span class="muted">entries</span></div>
      <div class="stat"><strong id="statCapacity">8</strong><span class="muted">capacity (buckets)</span></div>
      <div class="stat"><strong id="statLF">0.00</strong><span class="muted">load factor</span></div>
      <div class="stat"><strong id="statCollisions">0</strong><span class="muted">collisions (total inserts that went to non-empty bucket)</span></div>
    </div>

    <div class="notice" id="notice">No actions yet. Insert keys to see how hashing maps them into buckets.</div>

    <div class="footer">
      Quick notes:
      <ul style="margin:8px 0 0 18px">
        <li><b>Separate chaining</b> stores multiple items per bucket (simple arrays here).</li>
        <li>Average lookup is O(1 + α) where α = load factor (n / m).</li>
        <li>When α grows, the table resizes (capacity doubles) and rehashes all items.</li>
      </ul>
    </div>

  </div>

  <div class="visual">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div>
        <h2 style="margin:6px 0 2px">Buckets</h2>
        <div class="muted" style="margin-top:2px">Each bucket is a chain (list) — collisions are appended into the chain.</div>
      </div>
      <div style="display:flex;gap:10px;align-items:center;">
        <div class="muted">Highlighting shows hashing and traversal.</div>
        <button id="clearBtn" class="small-btn">Clear</button>
      </div>
    </div>

    <div id="buckets" class="buckets" style="margin-top:12px"></div>

    <div id="explain" class="help">
      How it works: When inserting, the key is converted to a hash number by the selected function, then we compute index = hash % capacity.
      If a bucket already holds items, the new item collides and is added to that bucket's chain.
    </div>
  </div>
</div>

<script>
(function(){
  // Simple interactive hash table with separate chaining
  // Data structures:
  // buckets: Array of arrays, each element is {key, value, hash}
  // stats: entries, collisions, capacity, threshold

  // DOM
  const keyInput = document.getElementById('keyInput');
  const valueInput = document.getElementById('valueInput');
  const putBtn = document.getElementById('putBtn');
  const getBtn = document.getElementById('getBtn');
  const removeBtn = document.getElementById('removeBtn');
  const containsBtn = document.getElementById('containsBtn');
  const randomBtn = document.getElementById('randomBtn');
  const fillBtn = document.getElementById('fillBtn');
  const bucketsDiv = document.getElementById('buckets');
  const clearBtn = document.getElementById('clearBtn');
  const notice = document.getElementById('notice');
  const hashSelect = document.getElementById('hashSelect');
  const statEntries = document.getElementById('statEntries');
  const statCapacity = document.getElementById('statCapacity');
  const statLF = document.getElementById('statLF');
  const statCollisions = document.getElementById('statCollisions');
  const capacityInput = document.getElementById('capacityInput');
  const thresholdInput = document.getElementById('thresholdInput');

  // Implementation
  let capacity = Math.max(2, parseInt(capacityInput.value) || 8);
  let threshold = parseFloat(thresholdInput.value) || 0.75;
  let buckets = [];
  let entries = 0;
  let collisions = 0;

  function initBuckets(n){
    capacity = n;
    buckets = Array.from({length:n}, ()=>[]);
    render();
  }

  function toKeyString(k){
    // normalize keys so different types produce distinct strings
    if (k === null) return 'null';
    if (k === undefined) return 'undefined';
    if (typeof k === 'object') return JSON.stringify(k);
    return String(k);
  }

  function hash_djb2(str){
    // djb2 by Dan Bernstein
    let h = 5381;
    for (let i=0;i<str.length;i++){
      h = ((h << 5) + h) + str.charCodeAt(i); // h * 33 + c
      h = h & 0xFFFFFFFF;
    }
    return Math.abs(h);
  }
  function hash_sum(str){
    let s = 0;
    for (let i=0;i<str.length;i++) s += str.charCodeAt(i);
    return Math.abs(s);
  }
  function hash_jsish(str){
    // a quick JS-like mix for demonstration (not real built-in hash)
    let h = 0;
    for(let i=0;i<str.length;i++){
      h = ((h << 5) - h) + str.charCodeAt(i);
      h |= 0;
    }
    return Math.abs(h);
  }

  function getHash(key){
    const k = toKeyString(key);
    const fn = hashSelect.value;
    if (fn === 'djb2') return hash_djb2(k);
    if (fn === 'sum') return hash_sum(k);
    return hash_jsish(k);
  }

  function indexForHash(h){
    return h % capacity;
  }

  function findInBucket(bucket, key){
    for (let i=0;i<bucket.length;i++){
      if (bucket[i].key === key) return i;
    }
    return -1;
  }

  // Render
  function render(highlight = {}) {
    bucketsDiv.innerHTML = '';
    statEntries.textContent = entries;
    statCapacity.textContent = capacity;
    statLF.textContent = (entries / capacity).toFixed(2);
    statCollisions.textContent = collisions;

    for (let i=0;i<capacity;i++){
      const b = buckets[i];
      const div = document.createElement('div');
      div.className = 'bucket';
      if (highlight.bucket === i) div.classList.add('highlight');
      const header = document.createElement('div');
      header.className = 'bucket-header';
      const idx = document.createElement('div');
      idx.className = 'index-bubble';
      idx.textContent = i;
      const count = document.createElement('div');
      count.style.marginLeft = '6px';
      count.style.fontSize = '13px';
      count.style.color = 'var(--muted)';
      count.textContent = `${b.length} item${b.length===1?'':'s'}`;
      header.appendChild(idx);
      header.appendChild(count);
      div.appendChild(header);

      const chain = document.createElement('div');
      chain.className = 'chain';

      for (let j=0;j<b.length;j++){
        const node = document.createElement('div');
        node.className = 'node';
        if (highlight.found && highlight.bucket === i && highlight.at === j) node.classList.add('found');
        if (highlight.visiting && highlight.bucket === i && highlight.at === j) node.classList.add('highlight');
        if (highlight.notfound && highlight.bucket === i) node.classList.add('notfound');

        const kv = document.createElement('div');
        kv.textContent = b[j].key + ' → ' + b[j].value;
        const small = document.createElement('small');
        small.textContent = 'h=' + b[j].hash;
        node.appendChild(kv);
        node.appendChild(small);
        chain.appendChild(node);
      }
      div.appendChild(chain);
      bucketsDiv.appendChild(div);
    }
  }

  function notify(msg, severity){
    notice.textContent = msg;
    if (severity === 'ok') notice.style.borderLeft = '4px solid rgba(16,185,129,0.6)';
    else if (severity === 'warn') notice.style.borderLeft = '4px solid rgba(250,204,21,0.6)';
    else if (severity === 'err') notice.style.borderLeft = '4px solid rgba(239,68,68,0.7)';
    else notice.style.borderLeft = 'none';
  }

  // Operations with simple animations (timeouts)
  function put(keyRaw, value, animate = true){
    const key = toKeyString(keyRaw);
    const h = getHash(keyRaw);
    const idx = indexForHash(h);
    const bucket = buckets[idx];

    // If update existing key => replace
    const existingIndex = findInBucket(bucket, key);
    if (existingIndex !== -1){
      // animate visiting then updating
      if (animate){
        render({bucket: idx, visiting: true, at: existingIndex});
        setTimeout(()=>{
          bucket[existingIndex].value = value;
          notify(`Updated key "${key}" in bucket ${idx}.`);
          render({bucket: idx, found: true, at: existingIndex});
        }, 450);
      } else {
        bucket[existingIndex].value = value;
        notify(`Updated key "${key}".`);
        render();
      }
      return;
    }

    // New insert: if bucket non-empty -> collision
    if (bucket.length > 0) collisions++;

    bucket.push({key, value, hash: h});
    entries++;

    // Animate insertion: highlight bucket then newly added node
    if (animate){
      render({bucket: idx});
      setTimeout(()=> {
        render({bucket: idx, found: true, at: bucket.length-1});
        notify(`Inserted key "${key}" into bucket ${idx} (hash ${h}).`);
      }, 300);
    } else {
      notify(`Inserted key "${key}".`);
      render();
    }

    // Check load factor -> resize if necessary
    setTimeout(()=> {
      if ((entries / capacity) > threshold) {
        autoResize();
      }
    }, 650);
  }

  function get(keyRaw, animate=true){
    const key = toKeyString(keyRaw);
    const h = getHash(keyRaw);
    const idx = indexForHash(h);
    const bucket = buckets[idx];

    // Traverse chain
    if (animate){
      // show bucket highlight then traverse nodes
      render({bucket: idx});
      let i = 0;
      function step(){
        if (i < bucket.length){
          render({bucket: idx, visiting: true, at: i});
          if (bucket[i].key === key){
            setTimeout(()=> {
              render({bucket: idx, found: true, at: i});
              notify(`Found key "${key}" → ${bucket[i].value}`, 'ok');
            }, 350);
            return;
          }
          i++;
          setTimeout(step, 350);
        } else {
          render({bucket: idx, notfound: true});
          notify(`Key "${key}" not found in bucket ${idx}.`, 'err');
        }
      }
      setTimeout(step, 200);
    } else {
      const pos = findInBucket(bucket, key);
      if (pos !== -1) {
        notify(`Found key "${key}" → ${bucket[pos].value}`, 'ok');
      } else {
        notify(`Key "${key}" not found.`, 'err');
      }
      render();
    }
  }

  function contains(keyRaw, animate=true){
    const key = toKeyString(keyRaw);
    const h = getHash(keyRaw);
    const idx = indexForHash(h);
    const bucket = buckets[idx];
    const pos = findInBucket(bucket, key);
    if (pos !== -1){
      if (animate) {
        render({bucket: idx, found: true, at: pos});
      } else render();
      notify(`Yes: key "${key}" is present.`, 'ok');
    } else {
      if (animate) {
        render({bucket: idx, notfound: true});
      } else render();
      notify(`No: key "${key}" not found.`, 'err');
    }
  }

  function remove(keyRaw, animate=true){
    const key = toKeyString(keyRaw);
    const h = getHash(keyRaw);
    const idx = indexForHash(h);
    const bucket = buckets[idx];
    const pos = findInBucket(bucket, key);
    if (pos === -1){
      render({bucket: idx, notfound: true});
      notify(`Key "${key}" not found; nothing removed.`, 'err');
      return;
    }

    // Animate removing
    if (animate){
      render({bucket: idx, visiting: true, at: pos});
      setTimeout(()=> {
        bucket.splice(pos,1);
        entries--;
        notify(`Removed key "${key}" from bucket ${idx}.`, 'ok');
        render({bucket: idx});
      }, 400);
    } else {
      bucket.splice(pos,1);
      entries--;
      render();
      notify(`Removed key "${key}".`, 'ok');
    }
  }

  function autoResize(){
    const oldCap = capacity;
    const newCap = capacity * 2;
    notify(`Resizing table: ${oldCap} → ${newCap} buckets (rehashing all items)...`, 'warn');

    // Collect all items
    const items = [];
    for (let b of buckets) for (let item of b) items.push(item);

    // Create new buckets
    capacity = newCap;
    buckets = Array.from({length:capacity}, ()=>[]);
    render();

    // Re-insert items with animation
    let i = 0;
    function stepRehash(){
      if (i < items.length){
        const it = items[i];
        const idx = indexForHash(it.hash);
        buckets[idx].push(it);
        render({bucket: idx, found: true, at: buckets[idx].length-1});
        i++;
        setTimeout(stepRehash, 120);
      } else {
        notify(`Resizing complete. New capacity: ${capacity}.`, 'ok');
        render();
      }
    }
    setTimeout(stepRehash, 250);
  }

  // Utility: random key generator
  function randomKey(){
    const adjectives = ['red','fast','blue','tiny','big','cold','hot','silent','loud','happy','sad','green','round'];
    const nouns = ['apple','rocket','car','mountain','river','book','phone','cat','dog','cloud','leaf','stone'];
    return adjectives[Math.floor(Math.random()*adjectives.length)] + '_' + nouns[Math.floor(Math.random()*nouns.length)] + '_' + Math.floor(Math.random()*1000);
  }

  // Wire up UI
  putBtn.addEventListener('click', ()=>{
    const key = keyInput.value.trim();
    const val = valueInput.value;
    if (key === '') { notify('Please provide a key.'); return; }
    put(key, val || '(empty)');
  });
  getBtn.addEventListener('click', ()=>{
    const key = keyInput.value.trim();
    if (key === '') { notify('Please provide a key.'); return; }
    get(key);
  });
  containsBtn.addEventListener('click', ()=> {
    const key = keyInput.value.trim();
    if (key === '') { notify('Please provide a key.'); return; }
    contains(key);
  });
  removeBtn.addEventListener('click', ()=>{
    const key = keyInput.value.trim();
    if (key === '') { notify('Please provide a key.'); return; }
    remove(key);
  });
  randomBtn.addEventListener('click', ()=>{
    const k = randomKey();
    keyInput.value = k;
    valueInput.value = 'val-'+Math.floor(Math.random()*1000);
    put(k, valueInput.value);
  });

  fillBtn.addEventListener('click', ()=>{
    // Fill many keys quickly to show collisions and resizing
    let added = 0;
    const target = 40;
    function addOne(){
      if (added >= target) return;
      const k = randomKey() + '_' + Math.floor(Math.random()*1000);
      put(k, 'v'+Math.floor(Math.random()*10000), false);
      added++;
      setTimeout(addOne, 30);
    }
    addOne();
    notify('Filling table with many entries...');
  });

  clearBtn.addEventListener('click', ()=>{
    entries = 0;
    collisions = 0;
    initBuckets(Math.max(2, parseInt(capacityInput.value) || 8));
    notify('Cleared table.');
  });

  capacityInput.addEventListener('change', ()=>{
    let val = parseInt(capacityInput.value) || 8;
    if (val < 2) val = 2;
    capacityInput.value = val;
    initBuckets(val);
    notify(`Capacity set to ${val}.`);
  });

  thresholdInput.addEventListener('change', ()=>{
    let t = parseFloat(thresholdInput.value);
    if (isNaN(t) || t <= 0) t = 0.75;
    threshold = t;
    thresholdInput.value = t;
    notify(`Threshold set to ${t}.`);
  });

  hashSelect.addEventListener('change', ()=>{
    notify(`Hash function switched to ${hashSelect.value}. Existing entries will behave based on the hash of their stored keys when they were inserted. Clear and reinsert to re-evaluate with new function.`, 'warn');
  });

  // Initialize
  initBuckets(capacity);
  notify('Hash table initialized. Try inserting keys.', 'ok');

  // Expose for console debugging (optional)
  window.__ht = {
    put, get, remove, contains, buckets: ()=>buckets, stats: ()=>({entries,capacity,collisions,threshold})
  };
})();
</script>
</body>
</html>