<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Linear Search Visualizer</title>
<style>
  :root{
    --bg:#0f1720;
    --panel:#0b1220;
    --accent:#22c1c3;
    --muted:#9aa6b2;
    --box:#0f2a3a;
    --found:#2ecc71;
    --fail:#e74c3c;
    --highlight:#f6d365;
    --glass: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071029 0%, #04121b 100%);color:#e6eef3}
  .container{max-width:1100px;margin:28px auto;padding:20px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
  header{display:flex;align-items:center;gap:16px;margin-bottom:16px}
  h1{font-size:20px;margin:0;color:var(--accent)}
  p.lead{margin:0;color:var(--muted);font-size:13px}
  .top-row{display:flex;gap:16px;flex-wrap:wrap}
  .panel{background:var(--panel);padding:12px;border-radius:10px;flex:1;min-width:260px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  input[type=text],input[type=number],select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:var(--glass);color:inherit}
  button{background:linear-gradient(180deg,var(--accent),#18a7a9);border:none;padding:8px 12px;border-radius:8px;color:#042028;cursor:pointer;font-weight:600}
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}
  .array-visual{padding:18px 12px;display:flex;gap:10px;align-items:flex-end;overflow:auto}
  .slot{min-width:56px;height:56px;border-radius:8px;background:var(--box);display:flex;flex-direction:column;align-items:center;justify-content:center;border:2px solid rgba(255,255,255,0.03);transition:all .18s;cursor:pointer}
  .slot.index{font-size:11px;color:var(--muted);opacity:0.9}
  .slot.value{font-size:16px;font-weight:700}
  .slot.active{background:linear-gradient(180deg,#1b4660,#0f2a3a);transform:translateY(-8px);box-shadow:0 8px 24px rgba(3,12,30,0.6);border-color:rgba(255,255,255,0.09)}
  .slot.found{background:linear-gradient(180deg,#36d07a,#1b8b56);box-shadow:0 10px 30px rgba(15,80,50,0.35);border-color:rgba(255,255,255,0.06);transform:translateY(-8px)}
  .slot.nope{background:linear-gradient(180deg,#2b2b36,#141416);opacity:0.6}
  .controls-row{display:flex;gap:8px;margin-top:10px;align-items:center;flex-wrap:wrap}
  .right-stats{min-width:240px}
  .stat{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;margin-bottom:8px}
  .stat strong{display:block;color:var(--accent);font-size:18px}
  .pseudocode{background:linear-gradient(180deg, rgba(0,0,0,0.2), transparent);padding:12px;border-radius:8px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:13px}
  .code-line{padding:6px 8px;border-radius:6px;margin-bottom:6px}
  .code-line.hl{background:linear-gradient(90deg, rgba(246,211,101,0.14), rgba(246,211,101,0.06));border:1px solid rgba(246,211,101,0.06)}
  .code-line.small{font-size:13px;color:var(--muted)}
  .trace{max-height:180px;overflow:auto;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;margin-top:8px}
  .trace .item{font-size:13px;padding:6px;border-bottom:1px dashed rgba(255,255,255,0.02)}
  footer{margin-top:12px;font-size:12px;color:var(--muted)}
  .controls .input-group{display:flex;gap:8px;align-items:center}
  .small{font-size:13px;color:var(--muted)}
  .speed{display:flex;gap:6px;align-items:center}
  .hint{font-size:12px;color:var(--muted)}
  .row{display:flex;gap:12px}
  @media (max-width:900px){
    .top-row{flex-direction:column}
    .right-stats{min-width:unset}
  }
</style>
</head>
<body>
<div class="container" role="application" aria-label="Linear Search Visualizer">
  <header>
    <div>
      <h1>Linear Search Visualizer</h1>
      <p class="lead">Step through the linear search algorithm — compare values sequentially until the target is found.</p>
    </div>
  </header>

  <div class="top-row">
    <div class="panel" aria-live="polite">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
        <div style="min-width:0;flex:1">
          <div class="controls">
            <div class="input-group">
              <label class="small" for="arrInput">Array (comma or space separated)</label>
              <input id="arrInput" type="text" value="34, 7, 23, 32, 5, 62, 32, 7" style="min-width:220px" aria-label="Array input">
            </div>
            <div class="input-group">
              <label class="small" for="targetInput">Target</label>
              <input id="targetInput" type="text" value="7" style="width:72px" aria-label="Target value input">
            </div>
          </div>
        </div>

        <div style="display:flex;gap:8px;align-items:center">
          <button id="applyBtn">Apply</button>
          <button id="randomBtn" class="secondary">Randomize</button>
          <button id="clearBtn" class="secondary" title="Clear highlights">Reset</button>
        </div>
      </div>

      <div class="controls-row" style="margin-top:12px">
        <div class="controls" style="align-items:center">
          <button id="stepBtn" class="secondary">Step</button>
          <button id="backBtn" class="secondary">Back</button>
          <button id="playBtn">Play</button>
          <button id="stopBtn" class="secondary">Stop</button>
          <div class="speed small" style="margin-left:6px">
            <label class="small">Speed</label>
            <input id="speed" type="range" min="100" max="2000" step="100" value="600" title="Playback speed (ms)">
            <span id="speedVal" class="small">600ms</span>
          </div>
        </div>

        <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
          <label class="small">Random size</label>
          <input id="randSize" type="number" value="8" min="1" max="30" style="width:64px">
        </div>
      </div>

      <div style="margin-top:14px">
        <div class="array-visual" id="arrayContainer" role="list" aria-label="Array elements"></div>
      </div>

      <div style="display:flex;gap:12px;margin-top:10px;flex-wrap:wrap">
        <div style="flex:1">
          <div class="pseudocode" aria-hidden="false">
            <div class="code-line small" id="code0">// Linear Search</div>
            <div class="code-line" id="code1">for i from 0 to n-1</div>
            <div class="code-line" id="code2">  if arr[i] == target</div>
            <div class="code-line" id="code3">    return i  // found</div>
            <div class="code-line" id="code4">return -1  // not found</div>
          </div>

          <div class="trace" id="trace"></div>
        </div>

        <div class="right-stats" style="min-width:240px">
          <div class="stat">
            <div class="small">Status</div>
            <strong id="status">Idle</strong>
            <div class="small" id="subStatus">No search running</div>
          </div>

          <div class="stat">
            <div class="small">Comparisons</div>
            <strong id="comparisons">0</strong>
            <div class="small">Each step compares arr[i] to target</div>
          </div>

          <div class="stat">
            <div class="small">Result</div>
            <strong id="result">—</strong>
            <div class="small" id="resultDetail">Index (if found) or -1</div>
          </div>

          <div class="stat">
            <div class="small">Complexity</div>
            <div class="small">Best: O(1) — target at first position</div>
            <div class="small">Average: O(n) — target uniformly likely</div>
            <div class="small">Worst: O(n) — not found or at last position</div>
          </div>
        </div>
      </div>

    </div>

    <div style="flex:0 0 260px">
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>How it works</strong>
        </div>
        <p class="small" style="margin-top:8px">
          Linear search checks each element in order until it finds the target. It's simple and works on unsorted arrays but may require checking every item.
        </p>
        <hr style="opacity:.06">
        <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px">
          <div><span class="small">Click an array element to set the target to that value.</span></div>
          <div><span class="small">Use Step to advance one comparison; Play to run automatically.</span></div>
          <div><span class="small">Back rewinds through previous steps (limited to current run).</span></div>
        </div>
      </div>

      <div class="panel" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>Current run</strong>
        </div>
        <div style="margin-top:10px">
          <div class="small">Generator state: <span id="genState">not started</span></div>
          <div class="small">Steps recorded: <span id="stepsCount">0</span></div>
        </div>
      </div>
    </div>
  </div>

  <footer>
    Tip: Linear search is best when arrays are small or unsorted. For sorted arrays, consider binary search (O(log n)).
  </footer>
</div>

<script>
(function(){
  // Utilities
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));

  // Elements
  const arrInput = $('#arrInput');
  const targetInput = $('#targetInput');
  const applyBtn = $('#applyBtn');
  const randomBtn = $('#randomBtn');
  const clearBtn = $('#clearBtn');
  const arrayContainer = $('#arrayContainer');
  const stepBtn = $('#stepBtn');
  const backBtn = $('#backBtn');
  const playBtn = $('#playBtn');
  const stopBtn = $('#stopBtn');
  const traceEl = $('#trace');
  const statusEl = $('#status');
  const subStatusEl = $('#subStatus');
  const comparisonsEl = $('#comparisons');
  const resultEl = $('#result');
  const resultDetailEl = $('#resultDetail');
  const codeLines = [$('#code0'),$('#code1'),$('#code2'),$('#code3'),$('#code4')];
  const stepsCountEl = $('#stepsCount');
  const genStateEl = $('#genState');
  const speedRange = $('#speed');
  const speedVal = $('#speedVal');
  const randSize = $('#randSize');

  let array = [];
  let target = null;

  // Generator and run state
  let gen = null;
  let playing = false;
  let playTimer = null;
  let recordedSteps = []; // history of state objects
  let stepPointer = -1; // points into recordedSteps
  let comparisons = 0;

  // Initialize default
  function parseArrayInput(text){
    // Accept commas or whitespace
    if(!text.trim()) return [];
    const parts = text.trim().split(/[\s,]+/);
    return parts.map(p=>{
      // Try parse number
      if(p.match(/^[-+]?\d+(\.\d+)?$/)) return Number(p);
      return p;
    });
  }

  function renderArray(){
    arrayContainer.innerHTML = '';
    array.forEach((val,i)=>{
      const slot = document.createElement('div');
      slot.className = 'slot';
      slot.setAttribute('role','listitem');
      slot.setAttribute('data-index',i);
      slot.innerHTML = `<div class="index">[${i}]</div><div class="value">${String(val)}</div>`;
      slot.title = `Index ${i}: ${String(val)} — click to set target`;
      slot.addEventListener('click', ()=>{
        targetInput.value = String(val);
        safelyApplyInputs();
      });
      arrayContainer.appendChild(slot);
    });
  }

  function safeSetStatus(s, sub=''){
    statusEl.textContent = s;
    subStatusEl.textContent = sub;
  }

  function highlightCode(lineIdx){
    codeLines.forEach((el,idx)=> el.classList.toggle('hl', idx===lineIdx));
  }

  function clearHighlights(){
    Array.from(arrayContainer.children).forEach(ch=>{
      ch.classList.remove('active','found','nope');
    });
    highlightCode(null);
  }

  function updateStats(){
    comparisonsEl.textContent = comparisons;
    stepsCountEl.textContent = recordedSteps.length;
    genStateEl.textContent = gen ? (gen.done ? 'done' : 'running') : 'not started';
  }

  // The generator implementing linear search
  function* linearSearchGen(arr, tgt){
    let comps = 0;
    for(let i=0;i<arr.length;i++){
      comps++;
      // yield compare event
      const equal = (arr[i] === tgt) || (String(arr[i]) === String(tgt));
      yield {type:'compare', i, comparisons:comps, value:arr[i], equal};
      if(equal){
        // found
        yield {type:'found', i, comparisons:comps, value:arr[i]};
        return {index:i, comparisons:comps};
      }
    }
    yield {type:'notfound', comparisons:comps};
    return {index:-1, comparisons:comps};
  }

  function resetRun(preserveArray=false){
    if(!preserveArray) {
      array = parseArrayInput(arrInput.value || '');
    }
    target = targetInput.value;
    gen = null;
    playing = false;
    clearInterval(playTimer);
    playTimer = null;
    recordedSteps = [];
    stepPointer = -1;
    comparisons = 0;
    resultEl.textContent = '—';
    resultDetailEl.textContent = 'Index (if found) or -1';
    safeSetStatus('Idle','No search running');
    clearHighlights();
    traceEl.innerHTML = '';
    updateStats();
    genStateEl.textContent = 'not started';
  }

  function safelyApplyInputs(){
    // update array and target without starting run
    array = parseArrayInput(arrInput.value || '');
    target = targetInput.value;
    renderArray();
    resetRun(true);
  }

  function startGenerator(){
    if(gen && !gen.done) return; // already running
    target = targetInput.value;
    gen = linearSearchGen(array, target);
    gen.done = false;
    genStateEl.textContent = 'running';
    safeSetStatus('Ready','Press Step or Play to run');
    updateStats();
  }

  // Handle a single yielded state
  function handleState(state, record=true){
    // state can be compare/found/notfound
    comparisons = state.comparisons || comparisons;
    comparisonsEl.textContent = comparisons;
    if(record){
      recordedSteps.push(state);
      stepPointer = recordedSteps.length - 1;
      stepsCountEl.textContent = recordedSteps.length;
    } else {
      // if not recording (should not happen usually)
      stepPointer = recordedSteps.length - 1;
    }

    // Visual update according to state
    clearHighlights();
    if(state.type === 'compare'){
      // highlight current index as active
      const el = arrayContainer.children[state.i];
      if(el) el.classList.add('active');
      // mark previous ones as 'nope' (except if found earlier)
      for(let j=0;j<state.i;j++){
        const e = arrayContainer.children[j];
        if(e && !e.classList.contains('found')) e.classList.add('nope');
      }
      safeSetStatus('Comparing', `arr[${state.i}] (${String(state.value)}) == target?`);
      // pseudocode highlight
      highlightCode(2); // "if arr[i] == target"
      traceEl.insertAdjacentHTML('afterbegin', `<div class="item">Compare index ${state.i}: ${String(state.value)} == ${String(target)} → ${state.equal ? 'true' : 'false'}</div>`);
      if(state.equal){
        // next yield will be 'found' in generator; we don't mark found until that yield,
        // but some generators yield compare then found. We'll leave found marking for found state.
      }
    } else if(state.type === 'found'){
      // mark index as found
      const el = arrayContainer.children[state.i];
      if(el) el.classList.add('found');
      // mark prev as nope
      for(let j=0;j<state.i;j++){
        const e = arrayContainer.children[j];
        if(e && !e.classList.contains('found')) e.classList.add('nope');
      }
      safeSetStatus('Found', `Value at index ${state.i}`);
      resultEl.textContent = state.i;
      resultDetailEl.textContent = `Value: ${String(state.value)} — comparisons: ${state.comparisons}`;
      traceEl.insertAdjacentHTML('afterbegin', `<div class="item">Found at index ${state.i} (value ${String(state.value)}). Comparisons: ${state.comparisons}</div>`);
      highlightCode(3); // return i
    } else if(state.type === 'notfound'){
      // mark all as nope
      for(let j=0;j<array.length;j++){
        const e = arrayContainer.children[j];
        if(e) e.classList.add('nope');
      }
      safeSetStatus('Not found', `Target ${String(target)} not present`);
      resultEl.textContent = -1;
      resultDetailEl.textContent = `Comparisons: ${state.comparisons}`;
      traceEl.insertAdjacentHTML('afterbegin', `<div class="item">Not found after ${state.comparisons} comparisons.</div>`);
      highlightCode(4); // return -1
    }
    updateStats();
    // mark generator as done if type is found or notfound
    if(state.type === 'found' || state.type === 'notfound'){
      if(gen) gen.done = true;
      genStateEl.textContent = 'done';
      playing = false;
      clearInterval(playTimer);
      playTimer = null;
    }
  }

  // Step forward one yield
  function stepForward(){
    if(!gen){
      startGenerator();
    }
    if(!gen) return;
    if(gen.done){
      safeSetStatus('Done','No further steps');
      return;
    }
    const {value, done} = gen.next();
    if(value) handleState(value, true);
    if(done){
      gen.done = true;
      genStateEl.textContent = 'done';
      playing = false;
      clearInterval(playTimer);
    }
  }

  // Step back by moving pointer to previous recorded state
  function stepBack(){
    if(stepPointer <= -1) {
      safeSetStatus('Idle','Nothing to rewind');
      return;
    }
    // Move pointer back one
    stepPointer--;
    // Re-render using recordedSteps up to stepPointer
    clearHighlights();
    traceEl.innerHTML = '';
    comparisons = 0;
    resultEl.textContent = '—';
    resultDetailEl.textContent = 'Index (if found) or -1';
    safeSetStatus('Rewound','Viewing previous state');
    highlightCode(null);
    // Reset status and markings
    for(let s=0;s<=stepPointer;s++){
      const st = recordedSteps[s];
      // Re-apply each state but do not re-record
      if(st.type === 'compare'){
        comparisons = st.comparisons;
        // mark previous items up to st.i-1 as nope
        for(let j=0;j<st.i;j++){
          const e = arrayContainer.children[j];
          if(e) e.classList.add('nope');
        }
        const el = arrayContainer.children[st.i];
        if(el) el.classList.add('active');
        traceEl.insertAdjacentHTML('afterbegin', `<div class="item">Compare index ${st.i}: ${String(st.value)} == ${String(target)} → ${st.equal ? 'true' : 'false'}</div>`);
      } else if(st.type === 'found'){
        comparisons = st.comparisons;
        for(let j=0;j<st.i;j++){
          const e = arrayContainer.children[j];
          if(e) e.classList.add('nope');
        }
        const el = arrayContainer.children[st.i];
        if(el) el.classList.add('found');
        traceEl.insertAdjacentHTML('afterbegin', `<div class="item">Found at index ${st.i} (value ${String(st.value)}). Comparisons: ${st.comparisons}</div>`);
        resultEl.textContent = st.i;
        resultDetailEl.textContent = `Value: ${String(st.value)} — comparisons: ${st.comparisons}`;
      } else if(st.type === 'notfound'){
        comparisons = st.comparisons;
        for(let j=0;j<array.length;j++){
          const e = arrayContainer.children[j];
          if(e) e.classList.add('nope');
        }
        traceEl.insertAdjacentHTML('afterbegin', `<div class="item">Not found after ${st.comparisons} comparisons.</div>`);
        resultEl.textContent = -1;
        resultDetailEl.textContent = `Comparisons: ${st.comparisons}`;
      }
    }
    // Update live displays
    comparisonsEl.textContent = comparisons;
    stepsCountEl.textContent = recordedSteps.length;
    // Update pseudocode highlight to reflect current pointer
    if(stepPointer >= 0){
      const current = recordedSteps[stepPointer];
      if(current.type === 'compare') highlightCode(2);
      else if(current.type === 'found') highlightCode(3);
      else if(current.type === 'notfound') highlightCode(4);
    } else {
      highlightCode(null);
    }
  }

  // Play automatically
  function play(){
    if(playing) return;
    if(!gen) startGenerator();
    if(!gen) return;
    playing = true;
    safeSetStatus('Playing','Auto advancing comparisons');
    const stepMs = Number(speedRange.value) || 600;
    clearInterval(playTimer);
    playTimer = setInterval(()=>{
      if(!gen || gen.done){
        clearInterval(playTimer);
        playing = false;
        playTimer = null;
        genStateEl.textContent = gen && gen.done ? 'done' : 'stopped';
        safeSetStatus('Stopped','Playback ended');
        return;
      }
      stepForward();
    }, stepMs);
  }

  function stop(){
    playing = false;
    clearInterval(playTimer);
    playTimer = null;
    safeSetStatus('Stopped','Playback paused');
  }

  // UI events
  applyBtn.addEventListener('click', ()=>{
    safelyApplyInputs();
  });

  randomBtn.addEventListener('click', ()=> {
    const n = Math.max(1, Math.min(30, Number(randSize.value) || 8));
    const arr = new Array(n).fill(0).map(()=> Math.floor(Math.random()*100));
    arrInput.value = arr.join(', ');
    targetInput.value = String(arr[Math.floor(Math.random()*arr.length)]);
    safelyApplyInputs();
  });

  clearBtn.addEventListener('click', ()=>{
    arrInput.value = '';
    targetInput.value = '';
    safelyApplyInputs();
  });

  stepBtn.addEventListener('click', ()=>{
    stop();
    stepForward();
  });

  backBtn.addEventListener('click', ()=>{
    stop();
    stepBack();
  });

  playBtn.addEventListener('click', ()=>{
    play();
  });

  stopBtn.addEventListener('click', ()=>{
    stop();
  });

  speedRange.addEventListener('input', ()=>{
    speedVal.textContent = speedRange.value + 'ms';
    if(playing){
      // restart timer with new interval
      stop();
      play();
    }
  });

  // Allow pressing Enter in target input to start search
  targetInput.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){
      stop();
      startGenerator();
      stepForward();
    }
  });

  arrInput.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){
      safelyApplyInputs();
    }
  });

  // Initial setup
  safelyApplyInputs();

  // Accessibility: keyboard shortcuts
  document.addEventListener('keydown', (e)=>{
    if(e.altKey && e.key.toLowerCase() === 'p'){ // Alt+P play/pause
      if(playing) stop(); else play();
    } else if(e.key === 'ArrowRight'){ // next
      stop();
      stepForward();
    } else if(e.key === 'ArrowLeft'){
      stop();
      stepBack();
    }
  });

  // Announce when hovering on boxes (helpful for screen readers)
  arrayContainer.addEventListener('mouseover', (e)=>{
    const slot = e.target.closest('.slot');
    if(slot){
      slot.setAttribute('aria-pressed','false');
    }
  });

  // Small safety: if user modifies array while mid-run, reset
  arrInput.addEventListener('input', ()=>{
    // if there are recorded steps, warn and reset run automatically
    if(recordedSteps.length > 0){
      resetRun();
    }
  });

  // Expose for debugging in console (optional)
  window._lsViz = {
    resetRun, startGenerator, stepForward, stepBack, play, stop,
    state: ()=> ({array, target, gen, recordedSteps, stepPointer, comparisons})
  };

})();
</script>
</body>
</html>