<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Binary Search - Interactive Demo</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#22c1c3;
    --muted:#94a3b8;
    --good:#16a34a;
    --bad:#ef4444;
    --card:#0b1320;
    --glass: rgba(255,255,255,0.03);
  }
  body{
    margin:0;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: linear-gradient(180deg,#071029 0%, #081226 65%, #02080e 100%);
    color:#e6eef8;
    padding:18px;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }
  .wrap{
    max-width:1100px;
    margin:0 auto;
    display:grid;
    grid-template-columns: 420px 1fr;
    gap:18px;
  }
  header{
    grid-column: 1/-1;
    display:flex;
    align-items:center;
    gap:12px;
    margin-bottom:6px;
  }
  h1{font-size:18px;margin:0}
  p.desc{margin:0;color:var(--muted);font-size:13px}
  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    border:1px solid rgba(255,255,255,0.04);
    padding:12px;
    border-radius:10px;
    box-shadow: 0 6px 18px rgba(2,6,23,0.6);
  }
  .controls{
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
  input[type="text"], input[type="number"], textarea, select{
    width:100%;
    padding:8px 10px;
    border-radius:8px;
    background:var(--glass);
    color:inherit;
    border:1px solid rgba(255,255,255,0.03);
    outline:none;
    font-size:13px;
  }
  textarea{min-height:70px;resize:vertical}
  .row{display:flex;gap:8px}
  .row > *{flex:1}
  button{
    background:linear-gradient(90deg,var(--accent),#6ee7b7);
    border:none;
    color:#001218;
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    font-weight:600;
    box-shadow: 0 6px 16px rgba(14,165,233,0.08);
  }
  button.ghost{
    background:transparent;
    border:1px solid rgba(255,255,255,0.04);
    color:var(--muted);
    font-weight:600;
  }
  .small{font-size:13px;padding:6px 8px;border-radius:8px}
  .controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .vis{
    min-height:420px;
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .arrayVis{
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    border:1px solid rgba(255,255,255,0.03);
    border-radius:10px;
    padding:14px;
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  .arrayRow{
    display:flex;
    gap:8px;
    align-items:end;
    justify-content:center;
    flex-wrap:wrap;
    padding:6px;
  }
  .cell{
    min-width:44px;
    height:52px;
    background:rgba(255,255,255,0.03);
    border-radius:8px;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    border:1px solid rgba(255,255,255,0.02);
    font-weight:700;
    color:#e6f6ff;
  }
  .cell .idx{position:absolute;bottom:-18px;font-size:12px;color:var(--muted)}
  .cell.low{box-shadow:0 4px 14px rgba(34,193,195,0.08);border-color:#0ea5a4}
  .cell.high{box-shadow:0 4px 14px rgba(93,77,198,0.08);border-color:#6d28d9}
  .cell.mid{box-shadow:0 6px 20px rgba(99,102,241,0.12);border-color:#6366f1}
  .cell.found{background:linear-gradient(90deg,#16a34a,#34d399);color:#001218;border-color:rgba(0,0,0,0.15);box-shadow:0 8px 28px rgba(16,185,129,0.12)}
  .legend{display:flex;gap:8px;flex-wrap:wrap}
  .legend span{font-size:12px;color:var(--muted)}
  .legend .tag{display:inline-flex;gap:6px;align-items:center;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-weight:600}
  .tag .dot{width:12px;height:12px;border-radius:3px}
  .dot.low{background:#0ea5a4}
  .dot.high{background:#6d28d9}
  .dot.mid{background:#6366f1}
  .dot.found{background:#16a34a}
  .controlsPlayback{display:flex;gap:8px;align-items:center}
  .bigbtn{padding:10px 14px;font-size:15px}
  .statusbar{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .badge{background:rgba(255,255,255,0.02);padding:8px 10px;border-radius:8px;font-size:13px;color:var(--muted);border:1px solid rgba(255,255,255,0.02)}
  .code{
    background:#061224;
    border-radius:10px;
    padding:12px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
    font-size:13px;
    color:#cfeffd;
    border:1px solid rgba(255,255,255,0.03);
  }
  .code pre{margin:0;white-space:pre-wrap}
  .line{display:block;padding:4px 6px;border-radius:6px}
  .line.active{background:linear-gradient(90deg, rgba(99,102,241,0.12), rgba(34,193,195,0.06));border-left:3px solid rgba(99,102,241,0.6);color:#eaf9ff}
  .info{
    font-size:13px;color:var(--muted);
  }
  .footer{grid-column:1/-1;text-align:center;margin-top:6px;color:var(--muted);font-size:13px}
  @media (max-width:980px){
    .wrap{grid-template-columns:1fr; padding-bottom:40px}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Binary Search — Interactive Demo</h1>
      <p class="desc">Visualize how binary search narrows the search range on a sorted array. Step through, autoplay, and compare iterative & recursive variants.</p>
    </div>
  </header>

  <section class="panel" aria-labelledby="controls">
    <div class="controls">
      <label for="arrayInput">Array (numbers, comma separated)</label>
      <textarea id="arrayInput" placeholder="e.g. 1,3,4,8,12,15,20">2,5,7,9,13,18,21,34,55</textarea>

      <div class="row">
        <div>
          <label for="sortChk"><input id="sortChk" type="checkbox" checked> Keep array sorted (auto-sort)</label>
        </div>
        <div>
          <label for="sizeInput">Generate size</label>
          <input id="sizeInput" type="number" min="2" value="9">
        </div>
      </div>

      <div class="row">
        <button id="generateBtn" class="small">Generate random sorted array</button>
        <button id="applyBtn" class="small ghost">Apply / Start</button>
      </div>

      <label for="targetInput">Target value</label>
      <div class="row">
        <input id="targetInput" type="text" placeholder="Number to search for" />
        <button id="randomTargetBtn" class="small ghost">Pick random</button>
      </div>

      <div class="controls-grid">
        <div>
          <label>Algorithm variant</label>
          <select id="variantSelect">
            <option value="iterative">Iterative</option>
            <option value="recursive">Recursive (simulated)</option>
          </select>
        </div>
        <div>
          <label>Animation speed (ms)</label>
          <input id="speedRange" type="range" min="80" max="1500" value="600">
        </div>
      </div>

      <div class="row" style="align-items:center">
        <div class="controlsPlayback">
          <button id="playBtn" class="bigbtn">Play ▶️</button>
          <button id="prevBtn" class="ghost small">◀ Prev</button>
          <button id="nextBtn" class="ghost small">Next ▶</button>
          <button id="resetBtn" class="ghost small">Reset</button>
        </div>
        <div style="text-align:right">
          <div class="statusbar" style="justify-content:flex-end">
            <div class="badge">Step: <span id="stepIdx">0</span>/<span id="stepTotal">0</span></div>
            <div class="badge">Comparisons: <span id="compCount">0</span></div>
          </div>
        </div>
      </div>

      <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
        <div class="legend">
          <span class="tag"><span class="dot low"></span> low</span>
          <span class="tag"><span class="dot mid"></span> mid</span>
          <span class="tag"><span class="dot high"></span> high</span>
          <span class="tag"><span class="dot found"></span> found</span>
        </div>
      </div>
    </div>
  </section>

  <section class="panel vis" aria-live="polite">
    <div class="arrayVis panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <strong id="message">Ready</strong>
          <div class="info" id="submessage">Array must be sorted for correct result. You can auto-sort.</div>
        </div>
        <div style="text-align:right">
          <div class="badge">n = <span id="nVal">0</span></div>
          <div class="badge">Target = <span id="targetVal">—</span></div>
        </div>
      </div>

      <div class="arrayRow" id="arrayRow" aria-hidden="false">
        <!-- cells injected here -->
      </div>
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="display:flex;gap:8px;align-items:center">
          <div class="badge">low = <span id="lowVal">—</span></div>
          <div class="badge">mid = <span id="midVal">—</span></div>
          <div class="badge">high = <span id="highVal">—</span></div>
        </div>
        <div style="text-align:right">
          <div class="badge" id="resultBadge">Status: <span id="statusTxt">idle</span></div>
        </div>
      </div>
    </div>

    <div class="code" style="display:flex;gap:10px">
      <div style="flex:1">
        <div style="font-weight:700;margin-bottom:6px">Pseudocode (iterative)</div>
        <pre id="codeIter">
<span class="line" data-line="1">1  low ← 0</span>
<span class="line" data-line="2">2  high ← n - 1</span>
<span class="line" data-line="3">3  while low ≤ high do</span>
<span class="line" data-line="4">4      mid ← floor((low + high) / 2)</span>
<span class="line" data-line="5">5      if A[mid] = target then</span>
<span class="line" data-line="6">6          return mid</span>
<span class="line" data-line="7">7      else if A[mid] < target then</span>
<span class="line" data-line="8">8          low ← mid + 1</span>
<span class="line" data-line="9">9      else</span>
<span class="line" data-line="10">10         high ← mid - 1</span>
<span class="line" data-line="11">11 return -1</span>
        </pre>
      </div>
      <div style="flex:1">
        <div style="font-weight:700;margin-bottom:6px">Pseudocode (recursive)</div>
        <pre id="codeRec">
<span class="line" data-line="1">1  function binarySearch(A, target, low, high)</span>
<span class="line" data-line="2">2      if low > high then</span>
<span class="line" data-line="3">3          return -1</span>
<span class="line" data-line="4">4      mid ← floor((low + high) / 2)</span>
<span class="line" data-line="5">5      if A[mid] = target then</span>
<span class="line" data-line="6">6          return mid</span>
<span class="line" data-line="7">7      else if A[mid] < target then</span>
<span class="line" data-line="8">8          return binarySearch(A, target, mid + 1, high)</span>
<span class="line" data-line="9">9      else</span>
<span class="line" data-line="10">10         return binarySearch(A, target, low, mid - 1)</span>
        </pre>
      </div>
    </div>

    <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-top:12px">
      <div class="panel" style="flex:1;padding:10px">
        <div style="font-weight:700">Complexity</div>
        <div class="info" style="margin-top:6px">Time: O(log n) — each step halves the search range. Space: O(1) iterative / O(log n) recursive (call stack).</div>
      </div>

      <div class="panel" style="min-width:260px;padding:10px">
        <div style="font-weight:700">Algorithm trace</div>
        <div class="info" style="margin-top:6px">
          Use Play to autoplay steps. "Comparisons" counts how many times A[mid] was compared to target.
        </div>
      </div>
    </div>

  </section>

  <div class="footer">
    Tip: Binary search only works on sorted arrays. If unsure, enable "Keep array sorted".
  </div>
</div>

<script>
(function(){
  // Utility
  function qs(id){return document.getElementById(id)}
  function clamp(v,min,max){return Math.max(min,Math.min(max,v))}
  function parseArrayText(s){
    if(!s) return [];
    return s.split(',')
      .map(t => t.trim())
      .filter(t => t !== '')
      .map(t => {
        const n = Number(t);
        return isNaN(n) ? null : n;
      })
      .filter(x => x !== null);
  }

  // State
  let arr = [];
  let target = null;
  let states = []; // recorded states to step through
  let step = 0;
  let playing = false;
  let timer = null;

  // DOM
  const arrayInput = qs('arrayInput');
  const applyBtn = qs('applyBtn');
  const generateBtn = qs('generateBtn');
  const sizeInput = qs('sizeInput');
  const sortChk = qs('sortChk');
  const targetInput = qs('targetInput');
  const randomTargetBtn = qs('randomTargetBtn');
  const variantSelect = qs('variantSelect');
  const speedRange = qs('speedRange');
  const playBtn = qs('playBtn');
  const nextBtn = qs('nextBtn');
  const prevBtn = qs('prevBtn');
  const resetBtn = qs('resetBtn');
  const arrayRow = qs('arrayRow');
  const stepIdx = qs('stepIdx');
  const stepTotal = qs('stepTotal');
  const compCount = qs('compCount');
  const nVal = qs('nVal');
  const targetVal = qs('targetVal');
  const lowVal = qs('lowVal');
  const midVal = qs('midVal');
  const highVal = qs('highVal');
  const statusTxt = qs('statusTxt');
  const message = qs('message');
  const submessage = qs('submessage');
  const codeIter = qs('codeIter');
  const codeRec = qs('codeRec');
  const resultBadge = qs('resultBadge');

  // Initialize UI
  function renderArrayCells(){
    arrayRow.innerHTML = '';
    for(let i=0;i<arr.length;i++){
      const val = arr[i];
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.index = i;
      cell.innerHTML = '<span>'+val+'</span><div class="idx">'+i+'</div>';
      arrayRow.appendChild(cell);
    }
  }

  function highlightPseudocode(lineNumber, variant){
    // Clear previous
    const codeBlock = variant === 'iterative' ? codeIter : codeRec;
    const otherBlock = variant === 'iterative' ? codeRec : codeIter;
    otherBlock.querySelectorAll('.line').forEach(l=>l.classList.remove('active'));
    codeBlock.querySelectorAll('.line').forEach(l=>{
      const ln = Number(l.dataset.line);
      if(ln === lineNumber) l.classList.add('active'); else l.classList.remove('active');
    });
  }

  // State record structure:
  // { low, high, mid, action, compCount, line } action: 'enter','mid','found','left','right','done'
  function computeIterativeStates(a, t){
    const s = [];
    let low = 0;
    let high = a.length - 1;
    let comps = 0;
    // initial
    s.push({low,high,mid:null,action:'init',compCount:comps,line:1});
    while(low <= high){
      // mid calc
      const mid = Math.floor((low + high)/2);
      s.push({low,high,mid,action:'mid',compCount:comps,line:4});
      comps++;
      if(a[mid] === t){
        s.push({low,high,mid,action:'found',compCount:comps,line:5});
        return {states:s, compCount:comps, result:mid};
      } else if (a[mid] < t){
        s.push({low,high,mid,action:'left-to-right',compCount:comps,line:7}); // a[mid] < target => move low
        low = mid + 1;
        s.push({low,high,mid:Math.floor((low+high)/2),action:'updated',compCount:comps,line:8});
      } else {
        s.push({low,high,mid,action:'right-to-left',compCount:comps,line:9});
        high = mid - 1;
        s.push({low,high,mid: high>=low?Math.floor((low+high)/2):null,action:'updated',compCount:comps,line:10});
      }
    }
    s.push({low,high,mid:null,action:'notfound',compCount:comps,line:11});
    return {states:s, compCount:comps, result:-1};
  }

  function computeRecursiveStates(a, t){
    const s = [];
    let comps = 0;
    function rec(low, high){
      s.push({low,high,mid:null,action:'enter-call',compCount:comps,line:1});
      if(low > high){
        s.push({low,high,mid:null,action:'no-range',compCount:comps,line:2});
        return -1;
      }
      const mid = Math.floor((low+high)/2);
      s.push({low,high,mid,action:'mid',compCount:comps,line:4});
      comps++;
      if(a[mid] === t){
        s.push({low,high,mid,action:'found',compCount:comps,line:5});
        return mid;
      } else if (a[mid] < t){
        s.push({low,high,mid,action:'go-right',compCount:comps,line:7});
        const res = rec(mid+1, high);
        s.push({low,high,mid,action:'returned-from-right',compCount:comps,line:8});
        return res;
      } else {
        s.push({low,high,mid,action:'go-left',compCount:comps,line:9});
        const res = rec(low, mid-1);
        s.push({low,high,mid,action:'returned-from-left',compCount:comps,line:10});
        return res;
      }
    }
    const result = rec(0, a.length-1);
    s.push({low:0,high:a.length-1,mid:null,action:'done',compCount:comps,line:3});
    return {states:s, compCount:comps, result};
  }

  function applySettings(){
    // parse array
    let inputArr = parseArrayText(arrayInput.value);
    if(inputArr.length === 0){
      message.textContent = 'Array empty';
      submessage.textContent = 'Please provide numbers separated by commas or generate an array.';
      arr = [];
      renderArrayCells();
      updateMeta();
      return;
    }
    if(sortChk.checked){
      inputArr = inputArr.slice().sort((a,b)=>a-b);
    }
    arr = inputArr;
    renderArrayCells();
    // parse target
    const tVal = targetInput.value.trim();
    if(tVal === ''){
      target = null;
      targetVal.textContent = '—';
    } else {
      const nt = Number(tVal);
      target = isNaN(nt) ? null : nt;
      targetVal.textContent = target === null ? 'invalid' : target;
    }
    // compute states
    if(target === null){
      message.textContent = 'Target not set';
      submessage.textContent = 'Enter a numeric target value to start the demonstration.';
      statusTxt.textContent = 'idle';
      updateMeta();
      return;
    }
    buildStatesAndReset();
  }

  function buildStatesAndReset(){
    const variant = variantSelect.value;
    if(arr.length === 0){
      message.textContent = 'No array';
      statusTxt.textContent = 'idle';
      return;
    }
    message.textContent = 'Computing steps...';
    if(variant === 'iterative'){
      const res = computeIterativeStates(arr, target);
      states = res.states;
    } else {
      const res = computeRecursiveStates(arr, target);
      states = res.states;
    }
    step = 0;
    playing = false;
    clearInterval(timer);
    playBtn.textContent = 'Play ▶️';
    updateUI();
    message.textContent = 'Ready — step through';
    statusTxt.textContent = 'ready';
  }

  function updateMeta(){
    nVal.textContent = arr.length;
    stepIdx.textContent = Math.max(0,step);
    stepTotal.textContent = states.length;
    compCount.textContent = states.length>0 ? states[Math.max(0,Math.min(step,states.length-1))].compCount : 0;
  }

  function clearHighlights(){
    arrayRow.querySelectorAll('.cell').forEach(c=>{
      c.classList.remove('low','mid','high','found');
      c.style.transform = '';
    });
  }

  function updateUI(){
    // reflect step state
    updateMeta();
    clearHighlights();
    // default values
    lowVal.textContent = '—';
    midVal.textContent = '—';
    highVal.textContent = '—';
    resultBadge.style.background = '';
    resultBadge.style.borderColor = '';
    if(states.length === 0){
      statusTxt.textContent = 'idle';
      stepTotal.textContent = 0;
      return;
    }
    // clamp step index
    step = clamp(step, 0, states.length-1);
    const st = states[step];
    // highlight pseudocode
    const variant = variantSelect.value;
    highlightPseudocode(st.line || 0, variant);

    // display low/mid/high
    if(typeof st.low === 'number') lowVal.textContent = st.low; else lowVal.textContent = '—';
    if(typeof st.mid === 'number') midVal.textContent = st.mid; else midVal.textContent = '—';
    if(typeof st.high === 'number') highVal.textContent = st.high; else highVal.textContent = '—';
    stepIdx.textContent = step+1;
    stepTotal.textContent = states.length;
    compCount.textContent = st.compCount;

    // label cells
    arrayRow.querySelectorAll('.cell').forEach(c=>{
      const idx = Number(c.dataset.index);
      if(st.action === 'found' && typeof st.mid === 'number' && idx === st.mid){
        c.classList.add('found');
      } else {
        c.classList.remove('found');
      }
      // low/high/mid labels (mid has higher priority visually)
      c.classList.remove('low','high','mid');
      if(typeof st.mid === 'number' && idx === st.mid) c.classList.add('mid');
      else {
        if(typeof st.low === 'number' && idx === st.low) c.classList.add('low');
        if(typeof st.high === 'number' && idx === st.high) c.classList.add('high');
      }
    });

    // update message / status depending on action
    switch(st.action){
      case 'init':
        statusTxt.textContent = 'initialized';
        message.textContent = 'low and high set';
        break;
      case 'mid':
        statusTxt.textContent = 'comparing';
        message.textContent = 'Compute mid and compare A[mid] to target';
        break;
      case 'found':
        statusTxt.textContent = 'found';
        message.textContent = 'Target found!';
        resultBadge.style.background = 'linear-gradient(90deg,#16a34a,#34d399)';
        break;
      case 'left-to-right':
      case 'go-right':
        statusTxt.textContent = 'move right';
        message.textContent = 'A[mid] < target → move low to mid + 1';
        break;
      case 'right-to-left':
      case 'go-left':
        statusTxt.textContent = 'move left';
        message.textContent = 'A[mid] > target → move high to mid - 1';
        break;
      case 'updated':
      case 'returned-from-right':
      case 'returned-from-left':
        statusTxt.textContent = 'updated';
        message.textContent = 'Range updated';
        break;
      case 'notfound':
      case 'no-range':
      case 'done':
        statusTxt.textContent = 'not found';
        message.textContent = 'Target does not exist in the array';
        resultBadge.style.background = 'linear-gradient(90deg,#ef4444,#fb7185)';
        break;
      default:
        statusTxt.textContent = st.action;
        message.textContent = '';
    }
  }

  // Playback controls
  function startPlaying(){
    if(states.length === 0) return;
    playing = true;
    playBtn.textContent = 'Pause ⏸';
    const ms = Number(speedRange.value) || 600;
    clearInterval(timer);
    timer = setInterval(()=>{
      if(step >= states.length - 1){
        stopPlaying();
        return;
      }
      step++;
      updateUI();
    }, ms);
  }
  function stopPlaying(){
    playing = false;
    playBtn.textContent = 'Play ▶️';
    clearInterval(timer);
  }

  // Button handlers
  applyBtn.addEventListener('click', applySettings);
  arrayInput.addEventListener('keydown', function(e){ if(e.key === 'Enter' && (e.metaKey || e.ctrlKey)) applySettings(); });
  generateBtn.addEventListener('click', function(){
    const size = clamp(Number(sizeInput.value) || 9, 2, 200);
    // generate random sorted array with random gaps
    const base = Math.floor(Math.random()*5)+1;
    let val = Math.floor(Math.random()*5);
    const out = [];
    for(let i=0;i<size;i++){
      val += Math.floor(Math.random()*6) + 1 + Math.floor(Math.random()*base);
      out.push(val);
    }
    arrayInput.value = out.join(', ');
    if(sortChk.checked){
      // already sorted
    }
    applySettings();
  });

  randomTargetBtn.addEventListener('click', function(){
    // choose a value from array (chance to pick non-existing)
    if(arr.length === 0){
      // pick random small int
      const r = Math.floor(Math.random()*40);
      targetInput.value = r;
      target = r;
      targetVal.textContent = r;
      return;
    }
    // either pick existing or random near range
    if(Math.random() < 0.7){
      const idx = Math.floor(Math.random()*arr.length);
      targetInput.value = arr[idx];
    } else {
      const min = arr[0];
      const max = arr[arr.length-1];
      const r = Math.floor(min + Math.random()*(max-min+10)) + (Math.random()<0.5?0:5);
      targetInput.value = r;
    }
    applySettings();
  });

  playBtn.addEventListener('click', function(){
    if(playing) stopPlaying();
    else startPlaying();
  });

  nextBtn.addEventListener('click', function(){
    stopPlaying();
    if(states.length === 0) return;
    if(step < states.length - 1) step++;
    updateUI();
  });
  prevBtn.addEventListener('click', function(){
    stopPlaying();
    if(states.length === 0) return;
    if(step > 0) step--;
    updateUI();
  });
  resetBtn.addEventListener('click', function(){
    stopPlaying();
    step = 0;
    updateUI();
  });

  // Update speed dynamically
  speedRange.addEventListener('input', function(){
    if(playing){
      startPlaying(); // restart with new ms
    }
  });

  variantSelect.addEventListener('change', function(){
    // When variant toggled, rebuild states
    if(target !== null && arr.length>0){
      buildStatesAndReset();
    }
  });

  // initial render
  applySettings();

  // keyboard shortcuts
  document.addEventListener('keydown', function(e){
    if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;
    if(e.key === ' ') { e.preventDefault(); if(playing) stopPlaying(); else startPlaying(); }
    if(e.key === 'ArrowRight') { e.preventDefault(); nextBtn.click(); }
    if(e.key === 'ArrowLeft') { e.preventDefault(); prevBtn.click(); }
    if(e.key.toLowerCase() === 'r') { e.preventDefault(); resetBtn.click(); }
  });

  // Initial also render pseudocode highlights off
  highlightPseudocode(0, variantSelect.value);
})();
</script>
</body>
</html>