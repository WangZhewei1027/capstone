<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Dijkstra's Algorithm — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#06b6d4;
      --muted:#9aa6b2;
      --card:#071224;
      --good:#16a34a;
      --warn:#f59e0b;
      --danger:#ef4444;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    body{background:linear-gradient(180deg,#071226 0%, #07182b 100%); color:#e6eef3; display:flex; gap:12px; padding:12px; box-sizing:border-box;}
    .left {
      width:360px;
      min-width:260px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      border-radius:12px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
      height:calc(100vh - 24px);
      overflow:auto;
    }
    .title{font-weight:700;font-size:18px;display:flex;align-items:center;gap:8px}
    .controls{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
    button, select, input[type=number]{
      background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px;border-radius:8px;
      cursor:pointer;
    }
    button.primary{background:linear-gradient(90deg,var(--accent),#0ea5a0);color:#042025;border:font-weight:700;}
    .modes{display:flex;gap:6px;flex-wrap:wrap}
    .mode-btn{flex:1;padding:8px;border-radius:8px;text-align:center}
    .mode-btn.active{background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.06);color:#fff}
    .section{background:transparent;border-radius:8px;padding:8px;display:flex;flex-direction:column;gap:8px}
    label{font-size:13px;color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center}
    .small{font-size:12px;color:var(--muted)}
    .log{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:8px;padding:8px;height:160px;overflow:auto;font-family:monospace;font-size:12px;color:#d8eef2;border:1px solid rgba(255,255,255,0.03)}
    .stats{display:flex;gap:8px;flex-wrap:wrap}
    .stat{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;flex:1;text-align:center}
    .svg-wrap{flex:1;background:transparent;border-radius:12px;overflow:hidden;position:relative}
    svg{width:100%;height:100%;display:block;touch-action:none}
    .hint{font-size:12px;color:var(--muted)}
    .footer{font-size:12px;color:var(--muted); text-align:center;}
    .top-row{display:flex;gap:8px;align-items:center;justify-content:space-between}
    input[type=range]{width:100%}
    .node-label{font-size:12px;pointer-events:none;}
    .edge-weight{font-size:12px;pointer-events:none;fill:#e6eef3}
    .btn-row{display:flex;gap:8px}
    .mini{padding:6px;font-size:13px}
  </style>
</head>
<body>
  <div class="left">
    <div class="title">
      <div style="width:36px;height:36px;border-radius:8px;background:linear-gradient(90deg,var(--accent),#0ea5a0);display:flex;align-items:center;justify-content:center;color:#012426;font-weight:700">D</div>
      <div>
        Dijkstra's Algorithm
        <div style="font-size:12px;color:var(--muted)">Interactive visualizer — non-negative weights</div>
      </div>
    </div>

    <div class="section">
      <div class="top-row">
        <div class="modes" style="flex:1">
          <div class="mode-btn active" id="mode-addnode" data-mode="addNode">Add Node</div>
          <div class="mode-btn" id="mode-addedge" data-mode="addEdge">Add Edge</div>
          <div class="mode-btn" id="mode-move" data-mode="move">Move</div>
          <div class="mode-btn" id="mode-delete" data-mode="delete">Delete</div>
        </div>
      </div>

      <div class="row">
        <label style="flex:1">
          Directed edges by default
          <input type="checkbox" id="default-directed" style="margin-left:8px">
        </label>
      </div>

      <div class="row">
        <button id="btn-random" class="mini">Generate Random Graph</button>
        <button id="btn-clear" class="mini">Clear</button>
      </div>

      <div class="row">
        <label style="flex:1">Nodes:
          <span id="node-count" class="small">0</span>
        </label>
        <label style="flex:1">Edges:
          <span id="edge-count" class="small">0</span>
        </label>
      </div>

    </div>

    <div class="section">
      <div style="display:flex;gap:8px;align-items:center;">
        <button id="set-source" class="primary">Set Source</button>
        <button id="set-target">Set Target</button>
        <button id="clear-sets" title="Clear source/target">Clear</button>
      </div>

      <div class="row" style="gap:6px;">
        <button id="init-run" class="primary">Run →</button>
        <button id="step" class="mini">Step</button>
        <button id="auto" class="mini">Auto</button>
        <button id="reset-algo" class="mini">Reset Algo</button>
        <label style="flex:1">
          Speed
          <input type="range" id="speed" min="0.1" max="2.5" step="0.1" value="1">
        </label>
      </div>

      <div class="row">
        <label style="flex:1">Current source: <span id="source-show" class="small">—</span></label>
        <label style="flex:1">Current target: <span id="target-show" class="small">—</span></label>
      </div>
    </div>

    <div class="section">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:700">Algorithm log</div>
        <div class="small">Step-by-step</div>
      </div>
      <div id="log" class="log"></div>
      <div style="display:flex;gap:8px;margin-top:6px">
        <button id="export-image" class="mini">Export PNG</button>
        <button id="export-json" class="mini">Export JSON</button>
        <button id="import-json" class="mini">Import JSON</button>
      </div>
    </div>

    <div style="display:flex;gap:8px;">
      <div style="flex:1" class="small">Instructions: Add nodes by clicking the canvas. In "Add Edge" mode click source then target and enter weight. Use Move to reposition nodes. Choose a source then Run or Step.</div>
    </div>

    <div class="footer">Non-negative weights only • Demo &nbsp;|&nbsp; Click node to select in modes</div>
  </div>

  <div class="svg-wrap" id="graph-wrap" style="flex:1">
    <svg id="svg" viewBox="0 0 1600 900" preserveAspectRatio="xMidYMid meet"></svg>
  </div>

  <script>
    // Basic utilities
    const svg = document.getElementById('svg');
    const wrap = document.getElementById('graph-wrap');
    const logEl = document.getElementById('log');

    let nodes = []; // {id,x,y}
    let edges = []; // {id,source,target,weight,directed}
    let nextNodeId = 1;
    let nextEdgeId = 1;

    // Mode handling
    let mode = 'addNode';
    let modeButtons = document.querySelectorAll('.mode-btn');
    modeButtons.forEach(b=>{
      b.addEventListener('click', ()=>{
        modeButtons.forEach(x=>x.classList.remove('active'));
        b.classList.add('active');
        mode = b.dataset.mode;
        selectedForEdge = null;
      });
    });

    // Defaults
    const defaultDirectedCheckbox = document.getElementById('default-directed');

    // Selection state for adding edges
    let selectedForEdge = null;

    // Source/Target
    let sourceNode = null;
    let targetNode = null;

    // Algorithm state
    let algoState = null;
    let autoplay = false;
    let autoplayTimer = null;

    // Visual elements caches
    const gEdges = document.createElementNS('http://www.w3.org/2000/svg','g');
    const gEdgeWeights = document.createElementNS('http://www.w3.org/2000/svg','g');
    const gNodes = document.createElementNS('http://www.w3.org/2000/svg','g');
    svg.appendChild(gEdges);
    svg.appendChild(gEdgeWeights);
    svg.appendChild(gNodes);

    // Mouse handling
    let isDragging = false;
    let dragNode = null;
    let dragOffset = {x:0,y:0};

    // Utility: log
    function log(msg){
      const at = new Date().toLocaleTimeString();
      logEl.innerHTML = `<div>[${at}] ${msg}</div>` + logEl.innerHTML;
    }

    // Helpers: counts
    function updateCounts(){
      document.getElementById('node-count').textContent = nodes.length;
      document.getElementById('edge-count').textContent = edges.length;
      document.getElementById('source-show').textContent = sourceNode===null? '—' : 'Node '+sourceNode;
      document.getElementById('target-show').textContent = targetNode===null? '—' : 'Node '+targetNode;
    }

    // Create node
    function createNode(x,y){
      const id = nextNodeId++;
      nodes.push({id,x,y});
      draw();
      updateCounts();
      return id;
    }

    // Create edge
    function createEdge(s,t,w,directed=false){
      const id = nextEdgeId++;
      edges.push({id,source:s,target:t,weight:Number(w),directed:Boolean(directed)});
      draw();
      updateCounts();
      return id;
    }

    // Remove node and connected edges
    function removeNode(id){
      nodes = nodes.filter(n=>n.id!==id);
      edges = edges.filter(e=> e.source!==id && e.target!==id);
      if (sourceNode===id) sourceNode=null;
      if (targetNode===id) targetNode=null;
      draw();
      updateCounts();
    }

    // Remove edge by id
    function removeEdge(id){
      edges = edges.filter(e=>e.id!==id);
      draw();
      updateCounts();
    }

    // Find node at coords
    function nodeAt(x,y){
      for (let i=nodes.length-1;i>=0;i--){
        const n = nodes[i];
        const dx = x - n.x;
        const dy = y - n.y;
        if (Math.hypot(dx,dy) <= 26) return n;
      }
      return null;
    }

    // SVG coordinate conversion
    function clientToSVG(cx,cy){
      const pt = svg.createSVGPoint();
      pt.x = cx; pt.y = cy;
      const sp = pt.matrixTransform(svg.getScreenCTM().inverse());
      return {x:sp.x, y:sp.y};
    }

    // Drawing
    function clearSVG(){
      while(gEdges.firstChild) gEdges.removeChild(gEdges.firstChild);
      while(gEdgeWeights.firstChild) gEdgeWeights.removeChild(gEdgeWeights.firstChild);
      while(gNodes.firstChild) gNodes.removeChild(gNodes.firstChild);
    }

    function draw(){
      clearSVG();
      // draw edges
      edges.forEach(e=>{
        const s = nodes.find(n=>n.id===e.source);
        const t = nodes.find(n=>n.id===e.target);
        if (!s || !t) return;
        // compute shortened line endpoints (radius 22)
        const dx = t.x-s.x, dy = t.y-s.y;
        const dist = Math.hypot(dx,dy) || 1;
        const nx = dx/dist, ny = dy/dist;
        const r = 28;
        const sx = s.x + nx*r;
        const sy = s.y + ny*r;
        const tx = t.x - nx*r;
        const ty = t.y - ny*r;

        // line
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',sx); line.setAttribute('y1',sy);
        line.setAttribute('x2',tx); line.setAttribute('y2',ty);
        line.setAttribute('stroke','#6ee7b7');
        line.setAttribute('stroke-width', e.directed?3:2);
        line.setAttribute('stroke-opacity',0.12);
        line.setAttribute('data-edge-id', e.id);
        line.style.cursor = 'pointer';
        line.addEventListener('click', (evt)=>{
          evt.stopPropagation();
          if (mode === 'delete'){
            if (confirm('Delete this edge?')) removeEdge(e.id);
          } else {
            // toggle directedness if in addEdge? no
            log(`Edge ${e.source} → ${e.target} (w=${e.weight})`);
          }
        });
        gEdges.appendChild(line);

        // arrowhead if directed
        if (e.directed){
          const arrow = document.createElementNS('http://www.w3.org/2000/svg','path');
          const ah = 10;
          // rotate arrow to direction
          const angle = Math.atan2(ty-sy, tx-sx);
          const ax = tx, ay = ty;
          const p1x = ax - ah*Math.cos(angle - Math.PI/6);
          const p1y = ay - ah*Math.sin(angle - Math.PI/6);
          const p2x = ax - ah*Math.cos(angle + Math.PI/6);
          const p2y = ay - ah*Math.sin(angle + Math.PI/6);
          arrow.setAttribute('d', `M ${ax} ${ay} L ${p1x} ${p1y} L ${p2x} ${p2y} Z`);
          arrow.setAttribute('fill','#6ee7b7');
          arrow.setAttribute('fill-opacity',0.12);
          arrow.setAttribute('data-edge-id', e.id);
          gEdges.appendChild(arrow);
        }

        // weight label
        const mx = (sx+tx)/2 + (-ny)*12;
        const my = (sy+ty)/2 + (nx)*12;
        const text = document.createElementNS('http://www.w3.org/2000/svg','text');
        text.setAttribute('x', mx);
        text.setAttribute('y', my);
        text.setAttribute('text-anchor','middle');
        text.setAttribute('dominant-baseline','central');
        text.setAttribute('fill','#e6eef3');
        text.setAttribute('font-size',12);
        text.setAttribute('pointer-events','none');
        text.textContent = e.weight;
        text.classList.add('edge-weight');
        text.setAttribute('data-edge-id', e.id);
        gEdgeWeights.appendChild(text);
      });

      // draw nodes
      nodes.forEach(n=>{
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('transform', `translate(${n.x},${n.y})`);
        g.setAttribute('data-node-id', n.id);
        // circle background
        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('r', 26);
        circle.setAttribute('fill', '#062033');
        circle.setAttribute('stroke', '#0ea5a0');
        circle.setAttribute('stroke-opacity',0.08);
        circle.setAttribute('stroke-width', 2);
        circle.style.cursor = 'pointer';
        g.appendChild(circle);

        // node id label
        const idText = document.createElementNS('http://www.w3.org/2000/svg','text');
        idText.setAttribute('y', -2);
        idText.setAttribute('text-anchor','middle');
        idText.setAttribute('fill','#e6eef3');
        idText.setAttribute('font-size',14);
        idText.setAttribute('font-weight',700);
        idText.textContent = n.id;
        g.appendChild(idText);

        // distance label (dynamic)
        const distText = document.createElementNS('http://www.w3.org/2000/svg','text');
        distText.setAttribute('y', 18);
        distText.setAttribute('text-anchor','middle');
        distText.setAttribute('fill','#93c5fd');
        distText.setAttribute('font-size',12);
        distText.setAttribute('class','node-dist');
        distText.textContent = '∞';
        g.appendChild(distText);

        g.addEventListener('mousedown', (evt)=>{
          evt.stopPropagation();
          if (mode === 'move'){
            isDragging = true;
            dragNode = n;
            const pt = clientToSVG(evt.clientX, evt.clientY);
            dragOffset.x = n.x - pt.x;
            dragOffset.y = n.y - pt.y;
          }
        });
        g.addEventListener('click', (evt)=>{
          evt.stopPropagation();
          if (mode === 'addEdge'){
            if (!selectedForEdge){
              selectedForEdge = n.id;
              log(`Selected node ${n.id} as edge source (click target node).`);
            } else if (selectedForEdge === n.id){
              selectedForEdge = null;
              log('Cancelled edge creation.');
            } else {
              // prompt weight
              let w = prompt(`Enter weight for edge ${selectedForEdge} → ${n.id} (non-negative number):`, "1");
              if (w === null){ selectedForEdge = null; return; }
              w = Number(w);
              if (!Number.isFinite(w) || w < 0) { alert('Invalid weight. Must be non-negative number.'); selectedForEdge = null; return; }
              const directed = defaultDirectedCheckbox.checked;
              createEdge(selectedForEdge, n.id, w, directed);
              log(`Created ${directed? 'directed':'undirected'} edge ${selectedForEdge} → ${n.id} (w=${w}).`);
              selectedForEdge = null;
            }
          } else if (mode === 'addNode'){
            // nothing special: clicking node selects for source/target if using set buttons
          } else if (mode === 'delete'){
            if (confirm('Delete this node and its edges?')) removeNode(n.id);
          } else if (mode === 'move'){
            // nothing: handled by drag
          }
        });

        // double click to create directed edge from this to new node? leave out.

        gNodes.appendChild(g);
      });

      // After draw: update highlights for source/target/algo state
      updateAllNodeDisplays();
      updateAllEdgeDisplays();
    }

    // Update node displays (distances, colors)
    function updateAllNodeDisplays(){
      nodes.forEach(n=>{
        const g = gNodes.querySelector(`g[data-node-id='${n.id}']`);
        if (!g) return;
        const distText = g.querySelector('.node-dist');
        if (algoState && algoState.dist && algoState.dist[n.id] !== undefined){
          const d = algoState.dist[n.id];
          distText.textContent = (d === Infinity) ? '∞' : d;
        } else {
          distText.textContent = '∞';
        }
        const circle = g.querySelector('circle');
        circle.setAttribute('stroke-opacity', 0.08);
        circle.setAttribute('fill', '#062033');
        circle.setAttribute('stroke','#0ea5a0');
        // colors for source/target/visited/current
        if (n.id === sourceNode){
          circle.setAttribute('fill','#06323a');
          circle.setAttribute('stroke','#06b6d4');
          circle.setAttribute('stroke-opacity',0.9);
        }
        if (algoState && algoState.visited && algoState.visited.has(n.id)){
          circle.setAttribute('fill','#08212b');
          circle.setAttribute('stroke','#93c5fd');
          circle.setAttribute('stroke-opacity',0.6);
        }
        if (algoState && algoState.current === n.id){
          circle.setAttribute('fill','#0ea5a0');
          circle.setAttribute('stroke','#0b3b33');
          circle.setAttribute('stroke-opacity',0.95);
        }
        if (n.id === targetNode){
          circle.setAttribute('stroke','#f59e0b');
          circle.setAttribute('stroke-opacity',0.95);
        }
      });
    }

    // Update edge visuals for relaxations/highlights
    function updateAllEdgeDisplays(){
      // default style
      gEdges.querySelectorAll('[data-edge-id]').forEach(el=>{
        el.setAttribute('stroke-opacity',0.12);
        el.setAttribute('fill-opacity',0.12);
        if (el.tagName === 'path'){
          el.setAttribute('fill-opacity',0.12);
        }
      });
      // highlight last relaxed edge if present
      if (algoState && algoState.lastRelaxedEdge){
        const id = algoState.lastRelaxedEdge;
        gEdges.querySelectorAll(`[data-edge-id='${id}']`).forEach(el=>{
          el.setAttribute('stroke-opacity',0.9);
          el.setAttribute('stroke','#60a5fa');
          el.setAttribute('fill','#60a5fa');
          el.setAttribute('fill-opacity',0.9);
        });
      }
      // highlight final shortest path if finished
      if (algoState && algoState.finished && algoState.prev){
        if (targetNode !== null && algoState.prev[targetNode]){
          const path = [];
          let cur = targetNode;
          while (cur !== undefined && algoState.prev[cur]){
            const p = algoState.prev[cur];
            // find edge id p -> cur
            const e = edges.find(ed=> ed.source===p && ed.target===cur) || edges.find(ed => (!ed.directed && ((ed.source===p && ed.target===cur) || (ed.source===cur && ed.target===p))));
            if (e) path.push(e.id);
            cur = p;
          }
          path.forEach(id=>{
            gEdges.querySelectorAll(`[data-edge-id='${id}']`).forEach(el=>{
              el.setAttribute('stroke','#f59e0b');
              el.setAttribute('stroke-opacity',0.95);
              el.setAttribute('fill','#f59e0b');
              el.setAttribute('fill-opacity',0.95);
            });
          });
        }
      }
    }

    // Export/import JSON
    document.getElementById('export-json').addEventListener('click', ()=>{
      const data = {nodes,edges,nextNodeId,nextEdgeId,sourceNode,targetNode};
      const txt = JSON.stringify(data, null, 2);
      const blob = new Blob([txt], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'graph-dijkstra.json';
      a.click();
      URL.revokeObjectURL(url);
    });
    document.getElementById('import-json').addEventListener('click', ()=>{
      const input = document.createElement('input');
      input.type='file';
      input.accept='application/json';
      input.onchange = ()=> {
        const f = input.files[0];
        const reader = new FileReader();
        reader.onload = () => {
          try{
            const data = JSON.parse(reader.result);
            nodes = data.nodes || [];
            edges = data.edges || [];
            nextNodeId = data.nextNodeId || (nodes.length+1);
            nextEdgeId = data.nextEdgeId || (edges.length+1);
            sourceNode = data.sourceNode || null;
            targetNode = data.targetNode || null;
            algoState = null;
            draw();
            updateCounts();
            log('Imported graph from file.');
          }catch(e){
            alert('Invalid file.');
          }
        };
        reader.readAsText(f);
      };
      input.click();
    });

    // Export PNG (simple)
    document.getElementById('export-image').addEventListener('click', ()=>{
      const svgData = new XMLSerializer().serializeToString(svg);
      const svgBlob = new Blob([svgData], {type:'image/svg+xml;charset=utf-8'});
      const url = URL.createObjectURL(svgBlob);
      const img = new Image();
      img.onload = ()=>{
        const canvas = document.createElement('canvas');
        canvas.width = svg.viewBox.baseVal.width;
        canvas.height = svg.viewBox.baseVal.height;
        const ctx = canvas.getContext('2d'); ctx.fillStyle = '#071226'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img,0,0);
        const a = document.createElement('a');
        a.href = canvas.toDataURL('image/png');
        a.download = 'dijkstra-graph.png';
        a.click();
        URL.revokeObjectURL(url);
      };
      img.src = url;
    });

    // Random graph generation
    document.getElementById('btn-random').addEventListener('click', ()=>{
      const n = Number(prompt('Number of nodes', '8'));
      if (!n || n < 1) return;
      const density = Number(prompt('Edge density (0.0 - 1.0)', '0.25'));
      const maxW = Number(prompt('Max edge weight', '15'));
      nodes = [];
      edges = [];
      nextNodeId = 1;
      nextEdgeId = 1;
      for (let i=0;i<n;i++){
        const x = 120 + Math.random()*(svg.viewBox.baseVal.width-240);
        const y = 80 + Math.random()*(svg.viewBox.baseVal.height-160);
        createNode(x,y);
      }
      // create edges
      for (let i=0;i<n;i++){
        for (let j=i+1;j<n;j++){
          if (Math.random() < density){
            const w = Math.max(1, Math.round(Math.random()*maxW));
            const directed = Math.random() < 0.35; // sometimes directed
            createEdge(nodes[i].id, nodes[j].id, w, directed);
            if (!directed && Math.random() < 0.3){
              // maybe create another edge opposite? skip
            }
          }
        }
      }
      algoState = null;
      draw();
      updateCounts();
      log('Random graph generated.');
    });

    // Clear graph
    document.getElementById('btn-clear').addEventListener('click', ()=>{
      if (!confirm('Clear the entire graph?')) return;
      nodes = []; edges = []; nextNodeId=1; nextEdgeId=1;
      sourceNode = null; targetNode = null; algoState = null;
      draw(); updateCounts(); log('Graph cleared.');
    });

    // Set source/target buttons
    document.getElementById('set-source').addEventListener('click', ()=>{
      alert('Click a node to set as source.');
      modeButtons.forEach(x=>x.classList.remove('active'));
      mode = 'setSource';
      // temporary click handler
      const handler = (evt)=>{
        const pt = clientToSVG(evt.clientX, evt.clientY);
        const n = nodeAt(pt.x, pt.y);
        if (n){
          sourceNode = n.id; log(`Source set to node ${n.id}`); updateCounts(); draw();
        } else {
          alert('Click on a node.');
        }
        mode = 'addNode';
        document.getElementById('mode-addnode').classList.add('active');
        window.removeEventListener('click', handler);
      };
      window.addEventListener('click', handler);
    });

    document.getElementById('set-target').addEventListener('click', ()=>{
      alert('Click a node to set as target.');
      modeButtons.forEach(x=>x.classList.remove('active'));
      mode = 'setTarget';
      const handler = (evt)=>{
        const pt = clientToSVG(evt.clientX, evt.clientY);
        const n = nodeAt(pt.x, pt.y);
        if (n){
          targetNode = n.id; log(`Target set to node ${n.id}`); updateCounts(); draw();
        } else {
          alert('Click on a node.');
        }
        mode = 'addNode';
        document.getElementById('mode-addnode').classList.add('active');
        window.removeEventListener('click', handler);
      };
      window.addEventListener('click', handler);
    });

    document.getElementById('clear-sets').addEventListener('click', ()=>{
      sourceNode = null; targetNode = null; updateCounts(); log('Source and target cleared.'); draw();
    });

    // Canvas click to add node
    svg.addEventListener('click', (evt)=>{
      const pt = clientToSVG(evt.clientX, evt.clientY);
      if (mode === 'addNode'){
        createNode(pt.x, pt.y);
        log(`Node ${nextNodeId-1} created.`);
      } else if (mode === 'addEdge'){
        // clicking empty space cancels selection
        if (selectedForEdge !== null){
          selectedForEdge = null;
          log('Cancelled edge creation.');
        }
      }
    });

    // mousemove for dragging nodes
    window.addEventListener('mousemove', (evt)=>{
      if (isDragging && dragNode){
        const pt = clientToSVG(evt.clientX, evt.clientY);
        dragNode.x = pt.x + dragOffset.x;
        dragNode.y = pt.y + dragOffset.y;
        draw();
      }
    });
    window.addEventListener('mouseup', (evt)=>{
      isDragging = false; dragNode = null;
    });

    // click on edges to show info or delete handled in draw()

    // Algorithm: Priority queue (min-heap)
    class MinPQ {
      constructor(){ this.data = []; }
      push(item){
        this.data.push(item);
        this._siftUp(this.data.length-1);
      }
      pop(){
        if (this.data.length===0) return null;
        const top = this.data[0];
        const last = this.data.pop();
        if (this.data.length>0){
          this.data[0] = last;
          this._siftDown(0);
        }
        return top;
      }
      _siftUp(i){
        while(i>0){
          const p = Math.floor((i-1)/2);
          if (this.data[p].dist <= this.data[i].dist) break;
          [this.data[p], this.data[i]] = [this.data[i], this.data[p]];
          i = p;
        }
      }
      _siftDown(i){
        const n = this.data.length;
        while(true){
          let l = 2*i+1, r = 2*i+2, smallest = i;
          if (l<n && this.data[l].dist < this.data[smallest].dist) smallest = l;
          if (r<n && this.data[r].dist < this.data[smallest].dist) smallest = r;
          if (smallest === i) break;
          [this.data[i], this.data[smallest]] = [this.data[smallest], this.data[i]];
          i = smallest;
        }
      }
      empty(){ return this.data.length===0; }
      clear(){ this.data=[]; }
    }

    // Build adjacency
    function buildAdj(){
      const adj = new Map(); // id -> [{to,weight,edgeId}]
      nodes.forEach(n=> adj.set(n.id, []));
      edges.forEach(e=>{
        if (!adj.has(e.source)) return;
        if (!adj.has(e.target)) return;
        adj.get(e.source).push({to:e.target, weight:e.weight, edgeId:e.id});
        if (!e.directed){
          adj.get(e.target).push({to:e.source, weight:e.weight, edgeId:e.id});
        }
      });
      return adj;
    }

    // Initialize algorithm
    function algoInit(){
      if (!sourceNode){
        alert('Please set a source node first.');
        return false;
      }
      const adj = buildAdj();
      const dist = {};
      const prev = {};
      nodes.forEach(n=>{ dist[n.id] = Infinity; prev[n.id] = null; });
      dist[sourceNode] = 0;
      const pq = new MinPQ();
      pq.push({node:sourceNode, dist:0});
      algoState = {adj, dist, prev, visited: new Set(), pq, current:null, finished:false, lastRelaxedEdge:null};
      log(`Initialized algorithm with source ${sourceNode}.`);
      updateAllNodeDisplays();
      updateAllEdgeDisplays();
      return true;
    }

    // One step of Dijkstra
    function algoStep(){
      if (!algoState){
        const ok = algoInit();
        if (!ok) return;
      }
      if (algoState.finished){
        log('Algorithm has already finished. Reset to run again.');
        return;
      }
      const pq = algoState.pq;
      // pop until we find a not-visited node
      let top = null;
      while(!pq.empty()){
        top = pq.pop();
        if (!algoState.visited.has(top.node)) break;
        top = null;
      }
      if (!top){
        algoState.finished = true;
        log('Priority queue empty. Algorithm finished.');
        updateAllNodeDisplays();
        updateAllEdgeDisplays();
        return;
      }
      const u = top.node;
      algoState.current = u;
      algoState.visited.add(u);
      algoState.lastRelaxedEdge = null;
      log(`Visited node ${u} with distance ${algoState.dist[u]}.`);
      // relax edges
      const neighbors = algoState.adj.get(u) || [];
      neighbors.forEach(nbr=>{
        if (algoState.visited.has(nbr.to)) return;
        const alt = algoState.dist[u] + nbr.weight;
        if (alt < algoState.dist[nbr.to]){
          algoState.dist[nbr.to] = alt;
          algoState.prev[nbr.to] = u;
          algoState.pq.push({node:nbr.to, dist:alt});
          algoState.lastRelaxedEdge = nbr.edgeId;
          log(`Relaxed edge ${u} → ${nbr.to}, new dist ${alt}`);
        } else {
          log(`Checked edge ${u} → ${nbr.to}, no improvement (alt=${alt}).`);
        }
      });

      // if target defined and popped, finish early
      if (targetNode !== null && u === targetNode){
        algoState.finished = true;
        log(`Target node ${targetNode} reached. Algorithm finished.`);
      }

      // If pq empty and all reachable visited
      if (algoState.pq.empty() && !algoState.finished){
        algoState.finished = true;
        log('No more reachable nodes. Algorithm finished.');
      }

      updateAllNodeDisplays();
      updateAllEdgeDisplays();

      if (algoState.finished){
        // highlight shortest path if target
        if (targetNode !== null && algoState.prev[targetNode]){
          const pathNodes = [];
          let cur = targetNode;
          while(cur !== null){
            pathNodes.push(cur);
            cur = algoState.prev[cur];
          }
          log('Shortest path: ' + pathNodes.reverse().join(' → ') + ` (distance ${algoState.dist[targetNode]})`);
        } else {
          log('Algorithm finished.');
        }
      }
    }

    // Run algorithm to completion
    function algoRunFull(){
      if (!algoState){
        const ok = algoInit();
        if (!ok) return;
      }
      // run until finished
      while(!algoState.finished){
        algoStep();
      }
      draw();
    }

    // Buttons
    document.getElementById('init-run').addEventListener('click', ()=>{
      algoRunFull();
    });
    document.getElementById('step').addEventListener('click', ()=>{
      algoStep();
    });

    // Auto-play
    document.getElementById('auto').addEventListener('click', ()=>{
      autoplay = !autoplay;
      const btn = document.getElementById('auto');
      if (autoplay){
        btn.textContent = 'Pause';
        if (!algoState) { const ok = algoInit(); if (!ok){ autoplay=false; btn.textContent='Auto'; return; } }
        const speed = Number(document.getElementById('speed').value);
        autoplayTimer = setInterval(()=>{
          if (algoState.finished) { clearInterval(autoplayTimer); autoplay=false; btn.textContent='Auto'; return; }
          algoStep();
        }, 700 / speed);
      } else {
        btn.textContent = 'Auto';
        clearInterval(autoplayTimer);
      }
    });

    document.getElementById('reset-algo').addEventListener('click', ()=>{
      algoState = null;
      autoplay = false;
      clearInterval(autoplayTimer);
      document.getElementById('auto').textContent = 'Auto';
      updateAllNodeDisplays();
      updateAllEdgeDisplays();
      log('Algorithm state reset.');
    });

    // keyboard: press Delete to delete selected mode's purpose? Not necessary.

    // init canvas viewbox size from window
    function initView(){
      const w = Math.max(1200, window.innerWidth - 420);
      const h = Math.max(720, window.innerHeight - 40);
      svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
      svg.style.minHeight = '100%';
      // set default sizes if empty
      if (nodes.length === 0){
        // create a small sample graph
        // createNode(200,150); createNode(420,140); createNode(600,260);
      }
      draw();
    }
    initView();
    window.addEventListener('resize', initView);

    // initial demonstration: small sample graph
    (function sample(){
      const a = createNode(220,180);
      const b = createNode(420,120);
      const c = createNode(640,200);
      const d = createNode(360,300);
      const e = createNode(570,340);
      createEdge(a,b,4,false);
      createEdge(a,d,2,false);
      createEdge(d,b,1,false);
      createEdge(b,c,5,false);
      createEdge(d,e,10,false);
      createEdge(e,c,3,false);
      updateCounts();
      log('Sample graph created. Set a source and run the algorithm.');
    })();

    // update displays periodically for animations or external changes
    setInterval(()=>{ updateAllNodeDisplays(); updateAllEdgeDisplays(); }, 300);

  </script>
</body>
</html>