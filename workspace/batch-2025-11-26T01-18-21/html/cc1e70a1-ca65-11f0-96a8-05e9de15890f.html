<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Kruskal's Algorithm Visualizer</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root{
    --bg: #0f1724;
    --card: #0b1220;
    --muted: #93a2c3;
    --accent: #3ddc97;
    --danger: #ff6b6b;
    --panel: #071022;
    --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  body{background: linear-gradient(180deg,#071028 0%, #071026 60%, #071827 100%); color:#e6eef8; display:flex; align-items:stretch;}
  .app{display:flex;flex:1;gap:12px;padding:16px;box-sizing:border-box;}
  .left{flex:1; background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border-radius:8px; padding:12px; display:flex; flex-direction:column; min-width:0;}
  .canvas-wrap{flex:1; position:relative; border-radius:6px; background:var(--panel); overflow:hidden; box-shadow: 0 4px 20px rgba(2,6,23,0.6); border:1px solid rgba(255,255,255,0.03);}
  svg{width:100%;height:100%; display:block; touch-action:none; cursor:default;}
  .controls{display:flex; gap:8px; margin:8px 0; align-items:center; flex-wrap:wrap;}
  button, input[type=number], select{background:var(--glass); border:1px solid rgba(255,255,255,0.04); color:var(--muted); padding:8px 10px; border-radius:6px;}
  button.primary{background:linear-gradient(90deg,#1fa67a,#39d98f); color:#04221a; border:0; font-weight:600;}
  .panel{width:360px; background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border-radius:8px; padding:12px; box-sizing:border-box; border:1px solid rgba(255,255,255,0.03); display:flex; flex-direction:column;}
  .section{margin-bottom:12px;}
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px;}
  .list{background:rgba(255,255,255,0.02); border-radius:6px; padding:8px; max-height:280px; overflow:auto;}
  .edge-item{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:6px;border-radius:6px;}
  .edge-item.pending{color:#cbd9f1;}
  .edge-item.accepted{color:var(--accent);}
  .edge-item.rejected{color:var(--danger);}
  .footer{display:flex; gap:8px; align-items:center; margin-top:auto;}
  .legend{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
  .dot{width:12px;height:12px;border-radius:50%;}
  .info{font-size:13px;color:var(--muted);}
  .big{font-size:18px;color:#dff6e9;font-weight:600;}
  .node-label{font-size:12px; fill:#04121b; pointer-events:none; font-weight:700;}
  .edge-weight{font-size:12px; fill:#cbe6e6; pointer-events:none;}
  .btn-row{display:flex; gap:6px; align-items:center; flex-wrap:wrap;}
  .hint{font-size:12px;color:var(--muted); margin-top:6px;}
  .small{font-size:12px;color:var(--muted);}
  .control-bar{display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap;}
  .status{font-size:13px;color:var(--muted);}
  .topbar{display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:8px;}
  .title{font-weight:700; font-size:16px;}
  .muted{color:var(--muted);}
  input[type=range]{width:120px;}
  a{color:var(--accent); text-decoration:none;}
  .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.03); color:var(--muted); padding:6px 8px;border-radius:6px;}
  .selected-edge { stroke-width:6px !important; }
  .accepted-edge { stroke: #3ddc97 !important; opacity:0.95; }
  .rejected-edge { stroke: #ff6b6b !important; opacity:0.5; stroke-dasharray:6 6; }
  .normal-edge { stroke: #9fb4d6; opacity:0.45; }
  .node-circle{ cursor:grab; stroke:#062432; stroke-width:2px; }
  .node-circle:active{ cursor:grabbing; }
  .node-label-bg{ fill:transparent; }
  .help{font-size:12px;color:var(--muted); margin-top:8px;}
  /* scrollbar */
  .list::-webkit-scrollbar { height:6px; width:8px; }
  .list::-webkit-scrollbar-thumb { background:rgba(255,255,255,0.04); border-radius:8px;}
  .list::-webkit-scrollbar-track{ background:transparent; }
</style>
</head>
<body>
<div class="app">
  <div class="left">
    <div class="topbar">
      <div>
        <div class="title">Kruskal's Algorithm Visualizer</div>
        <div class="muted" style="font-size:13px;">Step through Kruskal's MST algorithm. Create or randomize graphs, drag nodes, add weighted edges.</div>
      </div>
      <div class="status" id="status">Ready</div>
    </div>

    <div class="controls">
      <button id="addNodeBtn">Add Node</button>
      <button id="addEdgeBtn">Add Edge</button>
      <button id="randomBtn">Random Graph</button>
      <button id="clearBtn">Clear</button>

      <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
        <button id="runBtn" class="primary">Run Kruskal</button>
        <button id="stepBtn">Step</button>
        <button id="backBtn">Back</button>
        <button id="autoBtn">Auto</button>
      </div>
    </div>

    <div class="canvas-wrap" id="canvasWrap">
      <svg id="svg"></svg>
    </div>

    <div style="display:flex; gap:12px; margin-top:8px; align-items:center;">
      <div class="small">Speed</div>
      <input type="range" id="speedRange" min="100" max="2000" step="50" value="700">
      <div class="small">|  Highlight: <span id="highlightMode">Edge</span></div>
    </div>

    <div class="help">
      Controls: Add Node -> click anywhere on canvas to place. Add Edge -> click two nodes. Drag nodes to move. Click an edge to edit weight. The sorted edge list is shown in the right panel. Use Run/Step/Auto to execute Kruskal.
    </div>
  </div>

  <div class="panel">
    <div class="section">
      <label>Graph Controls</label>
      <div style="display:flex; gap:8px; align-items:center;">
        <label>Nodes: <input id="nodeCountInput" type="number" value="6" min="2" style="width:64px"></label>
        <label>Edges: <input id="edgeCountInput" type="number" value="10" min="1" style="width:64px"></label>
        <label>Max weight: <input id="maxWeightInput" type="number" value="20" min="1" style="width:64px"></label>
      </div>
    </div>

    <div class="section">
      <label>Kruskal Controls</label>
      <div class="btn-row">
        <button id="resetAlgoBtn">Reset Algorithm</button>
        <button id="shuffleBtn">Shuffle Edge Order</button>
        <button id="autoUnionBtn" class="btn-ghost">Show Unions</button>
      </div>
      <div class="hint" id="algoHint">MST weight: <span id="mstWeight">0</span> — Edges in MST: <span id="mstCount">0</span> / <span id="needCount">0</span></div>
    </div>

    <div class="section">
      <label>Edges (sorted by weight)</label>
      <div class="list" id="edgeList"></div>
    </div>

    <div class="section">
      <label>Execution Log</label>
      <div class="list" id="logList" style="max-height:140px;"></div>
    </div>

    <div class="footer">
      <div class="legend">
        <div style="display:flex; align-items:center; gap:6px;"><div class="dot" style="background:#9fb4d6"></div><div class="small">unselected</div></div>
        <div style="display:flex; align-items:center; gap:6px;"><div class="dot" style="background:#3ddc97"></div><div class="small">accepted</div></div>
        <div style="display:flex; align-items:center; gap:6px;"><div class="dot" style="background:#ff6b6b"></div><div class="small">rejected</div></div>
      </div>
      <div style="margin-left:auto;">
        <div class="small">Built for learning — Interactive demo</div>
      </div>
    </div>
  </div>
</div>

<script>
/*
  Kruskal's Algorithm Visualizer
  - Single-file interactive demo
  - Uses SVG for drawing graph
  - Supports creating nodes, adding edges, editing weights
  - Step-through Kruskal: sorted edges, union-find, accept/reject edges, build MST
  - Auto-run with adjustable speed, back/forward steps via snapshots
*/

// ---------- Utility ----------
function $(id){ return document.getElementById(id); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }

// Color generator for components
function colorForIndex(i){
  // some pleasant colors
  const palette = ["#ffb86b","#8be9fd","#ff79c6","#50fa7b","#bd93f9","#f1fa8c","#82aaff","#ff6b6b","#4dd0e1","#c3e88d"];
  return palette[i % palette.length];
}

// ---------- State ----------
const svg = $("svg");
const canvasWrap = $("canvasWrap");

let nodes = [];      // {id,x,y,label}
let edges = [];      // {id,u,v,weight}
let nextNodeId = 0;
let nextEdgeId = 0;

let mode = null;     // "add-node-click" or "add-edge-first" etc.
let addEdgeState = { firstNode: null };

let dragging = null;
let dragOffset = {x:0,y:0};

let snapshots = [];   // for stepping/back: array of states
let currentStep = -1;
let running = false;
let autoTimer = null;
let showUnions = true;

// Algorithm precomputed arrays
let sortedEdges = []; // array of edge IDs in sorted order
let needEdges = 0;

// ---------- DOM Elements ----------
const addNodeBtn = $("addNodeBtn");
const addEdgeBtn = $("addEdgeBtn");
const randomBtn = $("randomBtn");
const clearBtn = $("clearBtn");
const runBtn = $("runBtn");
const stepBtn = $("stepBtn");
const backBtn = $("backBtn");
const autoBtn = $("autoBtn");
const resetAlgoBtn = $("resetAlgoBtn");
const shuffleBtn = $("shuffleBtn");
const autoUnionBtn = $("autoUnionBtn");
const speedRange = $("speedRange");

const nodeCountInput = $("nodeCountInput");
const edgeCountInput = $("edgeCountInput");
const maxWeightInput = $("maxWeightInput");

const edgeListEl = $("edgeList");
const logListEl = $("logList");

const statusEl = $("status");
const mstWeightEl = $("mstWeight");
const mstCountEl = $("mstCount");
const needCountEl = $("needCount");

// ---------- SVG elements pool ----------
const edgeGroup = document.createElementNS("http://www.w3.org/2000/svg","g");
const nodeGroup = document.createElementNS("http://www.w3.org/2000/svg","g");
svg.appendChild(edgeGroup);
svg.appendChild(nodeGroup);

// ---------- Union-Find ----------
class UnionFind {
  constructor(n){
    this.parent = Array.from({length:n}, (_,i)=>i);
    this.rank = Array(n).fill(0);
  }
  find(a){
    if(this.parent[a] !== a) this.parent[a] = this.find(this.parent[a]);
    return this.parent[a];
  }
  union(a,b){
    let ra = this.find(a), rb = this.find(b);
    if(ra === rb) return false;
    if(this.rank[ra] < this.rank[rb]) this.parent[ra] = rb;
    else if(this.rank[rb] < this.rank[ra]) this.parent[rb] = ra;
    else { this.parent[rb] = ra; this.rank[ra]++; }
    return true;
  }
}

// ---------- Graph Rendering ----------
function render(){
  // clear
  while(edgeGroup.firstChild) edgeGroup.removeChild(edgeGroup.firstChild);
  while(nodeGroup.firstChild) nodeGroup.removeChild(nodeGroup.firstChild);

  // draw edges under nodes
  edges.forEach(e => {
    const u = nodes.find(n=>n.id===e.u), v = nodes.find(n=>n.id===e.v);
    if(!u || !v) return;
    const line = document.createElementNS("http://www.w3.org/2000/svg","line");
    line.setAttribute("x1",u.x); line.setAttribute("y1",u.y);
    line.setAttribute("x2",v.x); line.setAttribute("y2",v.y);
    line.setAttribute("stroke-linecap","round");
    line.setAttribute("stroke-width","3");
    line.classList.add("edge-line");
    line.dataset.edgeId = e.id;
    line.classList.add("normal-edge");

    // click to edit weight
    line.addEventListener("click", (evt)=>{
      evt.stopPropagation();
      const w = prompt("Edge weight:", String(e.weight));
      if(w === null) return;
      const nw = parseFloat(w);
      if(!isNaN(nw)){
        e.weight = nw;
        prepareAlgorithm(); // resort edges
        render();
        updateEdgeList();
      }
    });

    edgeGroup.appendChild(line);

    // weight label
    const midx = (u.x+v.x)/2, midy = (u.y+v.y)/2;
    const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
    bg.setAttribute("x", midx-12); bg.setAttribute("y", midy-14);
    bg.setAttribute("width", 24); bg.setAttribute("height", 20);
    bg.setAttribute("rx", 4); bg.setAttribute("ry",4);
    bg.setAttribute("fill", "rgba(2,8,18,0.7)");
    bg.setAttribute("stroke", "rgba(255,255,255,0.02)");
    bg.setAttribute("pointer-events","none");
    edgeGroup.appendChild(bg);

    const text = document.createElementNS("http://www.w3.org/2000/svg","text");
    text.setAttribute("x", midx); text.setAttribute("y", midy);
    text.setAttribute("text-anchor","middle");
    text.setAttribute("alignment-baseline","middle");
    text.setAttribute("class","edge-weight");
    text.textContent = e.weight;
    edgeGroup.appendChild(text);
  });

  // draw nodes on top
  nodes.forEach((n, idx) => {
    const g = document.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute("transform", `translate(${n.x},${n.y})`);
    g.classList.add("node-g");
    g.dataset.nodeId = n.id;

    const circle = document.createElementNS("http://www.w3.org/2000/svg","circle");
    circle.setAttribute("r", 18);
    circle.setAttribute("cx", 0);
    circle.setAttribute("cy", 0);
    circle.setAttribute("fill","#dff6e9"); // default faded, will color by component during run
    circle.classList.add("node-circle");
    circle.style.fill = "#9fb4d6"; // default
    g.appendChild(circle);

    const label = document.createElementNS("http://www.w3.org/2000/svg","text");
    label.setAttribute("x",0); label.setAttribute("y",2);
    label.setAttribute("text-anchor","middle");
    label.setAttribute("alignment-baseline","middle");
    label.setAttribute("class","node-label");
    label.textContent = n.label;
    g.appendChild(label);

    // events
    g.addEventListener("mousedown", (evt)=>{
      evt.stopPropagation();
      dragging = n;
      const pt = getMousePosition(evt);
      dragOffset.x = n.x - pt.x;
      dragOffset.y = n.y - pt.y;
    });
    g.addEventListener("touchstart", (evt)=>{
      evt.stopPropagation();
      const t = evt.touches[0];
      dragging = n;
      const pt = getMousePosition(t);
      dragOffset.x = n.x - pt.x;
      dragOffset.y = n.y - pt.y;
    });

    nodeGroup.appendChild(g);
  });

  // update edge classes based on algorithm state
  updateVisualState();
}

// ---------- Interaction helpers ----------
function getSVGPoint(evt){
  const rect = svg.getBoundingClientRect();
  return {
    x: evt.clientX - rect.left,
    y: evt.clientY - rect.top
  };
}
function getMousePosition(evt){
  if(evt.clientX !== undefined) return getSVGPoint(evt);
  if(evt.touches && evt.touches[0]) return getSVGPoint(evt.touches[0]);
  return {x:0,y:0};
}

// click on canvas for placing nodes or starting edge
svg.addEventListener("click", (evt)=>{
  if(mode === "add-node-click"){
    const pt = getMousePosition(evt);
    addNode(pt.x, pt.y);
    mode = null;
    addNodeBtn.classList.remove("active");
    setStatus("Node added.");
  } else if(mode === "add-edge"){
    // clicking background cancels
    addEdgeState.firstNode = null;
    mode = null;
    addEdgeBtn.classList.remove("active");
    setStatus("Add edge cancelled.");
  }
});

svg.addEventListener("mousemove", (evt)=>{
  if(dragging){
    const pt = getMousePosition(evt);
    dragging.x = clamp(pt.x + dragOffset.x, 30, svg.clientWidth - 30);
    dragging.y = clamp(pt.y + dragOffset.y, 30, svg.clientHeight - 30);
    render();
    updateEdgeList();
  }
});
svg.addEventListener("mouseup", ()=>{ dragging = null; });
svg.addEventListener("mouseleave", ()=>{ dragging = null; });
svg.addEventListener("touchmove", (evt)=>{
  if(dragging){
    const pt = getMousePosition(evt.touches[0]);
    dragging.x = clamp(pt.x + dragOffset.x, 30, svg.clientWidth - 30);
    dragging.y = clamp(pt.y + dragOffset.y, 30, svg.clientHeight - 30);
    render();
    updateEdgeList();
  }
});
svg.addEventListener("touchend", ()=>{ dragging = null; });

// detect clicks on node elements for edge creation
nodeGroup.addEventListener("click", (evt)=>{
  const g = evt.target.closest(".node-g");
  if(!g) return;
  const nid = parseInt(g.dataset.nodeId);
  if(mode === "add-edge"){
    if(addEdgeState.firstNode == null){
      addEdgeState.firstNode = nid;
      setStatus("Select second node for edge.");
    } else if(addEdgeState.firstNode === nid){
      setStatus("Can't connect node to itself. Choose another node or cancel.");
    } else {
      const w = prompt("Edge weight:", "1");
      if(w === null) {
        setStatus("Edge creation cancelled.");
        addEdgeState.firstNode = null;
        mode = null;
        addEdgeBtn.classList.remove("active");
        return;
      }
      const weight = parseFloat(w);
      if(isNaN(weight)) {
        setStatus("Invalid weight. Edge not created.");
        addEdgeState.firstNode = null;
        mode = null;
        addEdgeBtn.classList.remove("active");
        return;
      }
      addEdge(addEdgeState.firstNode, nid, weight);
      addEdgeState.firstNode = null;
      mode = null;
      addEdgeBtn.classList.remove("active");
      setStatus("Edge added.");
    }
  }
});

// add node programmatically
function addNode(x, y){
  const id = nextNodeId++;
  nodes.push({id:id, x:x, y:y, label: String(id)});
  prepareAlgorithm();
  render();
  updateEdgeList();
}

// add edge
function addEdge(u,v,weight){
  // avoid duplicates: if same endpoints exist (either order), allow but warn? We'll allow duplicates.
  const id = nextEdgeId++;
  edges.push({id:id, u:u, v:v, weight:weight});
  prepareAlgorithm();
  render();
  updateEdgeList();
}

// remove all
function clearGraph(){
  nodes = []; edges = []; nextNodeId = 0; nextEdgeId = 0;
  snapshots = []; currentStep = -1;
  running = false; stopAuto();
  setStatus("Cleared graph.");
  prepareAlgorithm();
  render();
  updateEdgeList();
  updateLog();
}

// random graph generator
function randomGraph(n, m, maxW){
  clearGraph();
  const w = svg.clientWidth, h = svg.clientHeight;
  for(let i=0;i<n;i++){
    const theta = (i/n)*Math.PI*2;
    const x = w/2 + (Math.min(w,h)/2 - 80) * Math.cos(theta) * (0.7 + Math.random()*0.6);
    const y = h/2 + (Math.min(w,h)/2 - 80) * Math.sin(theta) * (0.7 + Math.random()*0.6);
    addNode(x,y);
  }
  const nodeIds = nodes.map(n=>n.id);
  // ensure connectivity by creating a random spanning tree first
  const shuffled = nodeIds.slice().sort(()=>Math.random()-0.5);
  for(let i=1;i<shuffled.length;i++){
    const u = shuffled[i];
    const v = shuffled[randInt(0,i-1)];
    addEdge(u,v, randInt(1, maxW));
  }
  // add random extra edges
  let attempts = 0;
  while(edges.length < m && attempts < m*6){
    const a = nodeIds[randInt(0,n-1)];
    const b = nodeIds[randInt(0,n-1)];
    if(a===b){ attempts++; continue; }
    // avoid identical edge duplicates
    const exists = edges.find(e => (e.u===a && e.v===b) || (e.u===b && e.v===a));
    if(exists){ attempts++; continue; }
    addEdge(a,b, randInt(1, maxW));
    attempts++;
  }
  setStatus("Random graph created.");
  prepareAlgorithm();
  render();
  updateEdgeList();
}

// ---------- Algorithm Preparation ----------
function prepareAlgorithm(){
  // compute sortedEdges by [weight, id]
  sortedEdges = edges.slice().sort((a,b)=>{
    if(a.weight !== b.weight) return a.weight - b.weight;
    // tie break by endpoints to ensure deterministic order
    if(Math.min(a.u,a.v) !== Math.min(b.u,b.v)) return Math.min(a.u,a.v) - Math.min(b.u,b.v);
    if(Math.max(a.u,a.v) !== Math.max(b.u,b.v)) return Math.max(a.u,a.v) - Math.max(b.u,b.v);
    return a.id - b.id;
  }).map(e=>e.id);

  needEdges = Math.max(0, nodes.length - 1);
  needCountEl.textContent = needEdges;

  // reset snapshots
  snapshots = [];
  currentStep = -1;
  updateLog();
  updateEdgeList();
  updateVisualState();
}

// ---------- Execution (Kruskal Step) ----------
function buildInitialSnapshot(){
  // snapshot includes: parent, rank, selectedEdges (ids), rejectedEdges (ids), consideredIndex (index in sortedEdges), log
  const uf = new UnionFind(nodes.length);
  const mapIdToIdx = nodes.reduce((acc,n,i)=>{ acc[n.id] = i; return acc; }, {});
  // We'll map node ids to indices 0..n-1 to store UF arrays
  const parent = Array.from({length:nodes.length}, (_,i)=>i);
  const rank = Array(nodes.length).fill(0);
  const snap = {
    parent: parent,
    rank: rank,
    selected: [],
    rejected: [],
    considered: -1,
    log: []
  };
  snapshots = [deepCopy(snap)];
  currentStep = 0;
}

// Get map from node id to index
function idToIndexMap(){
  const m = {};
  nodes.forEach((n,i)=> m[n.id] = i);
  return m;
}

function stepForward(){
  if(currentStep === -1){
    if(nodes.length === 0){ setStatus("No nodes to run on."); return; }
    buildInitialSnapshot();
    setStatus("Algorithm started.");
    updateVisualState();
    updateEdgeList();
    updateLog();
    updateStats();
    return;
  }
  if(currentStep >= snapshots.length-1){
    // compute next step from last snapshot
    const prev = deepCopy(snapshots[snapshots.length-1]);
    const map = idToIndexMap();
    const uf = new UnionFind(nodes.length);
    uf.parent = prev.parent.slice();
    uf.rank = prev.rank.slice();
    const consideredIdx = prev.considered + 1;
    if(consideredIdx >= sortedEdges.length){
      setStatus("Algorithm finished. No more edges.");
      return;
    }
    const edgeId = sortedEdges[consideredIdx];
    const edge = edges.find(e=>e.id===edgeId);
    if(!edge){ setStatus("Edge missing."); return; }
    const uidx = map[edge.u], vidx = map[edge.v];
    const ra = uf.find(uidx), rb = uf.find(vidx);
    prev.considered = consideredIdx;
    prev.lastEdge = edgeId;
    if(ra !== rb){
      uf.union(uidx, vidx);
      prev.selected.push(edgeId);
      prev.log.push(`Accepted edge ${edge.u} - ${edge.v} (w=${edge.weight})`);
    } else {
      prev.rejected.push(edgeId);
      prev.log.push(`Rejected edge ${edge.u} - ${edge.v} (forms cycle)`);
    }
    // update parent/rank arrays
    prev.parent = uf.parent.slice();
    prev.rank = uf.rank.slice();
    snapshots.push(deepCopy(prev));
    currentStep = snapshots.length - 1;
    updateVisualState();
    updateEdgeList();
    updateLog();
    updateStats();
  } else {
    // just move to next snapshot (if stepping after back)
    currentStep++;
    updateVisualState();
    updateEdgeList();
    updateLog();
    updateStats();
  }
}

function stepBack(){
  if(currentStep <= 0){
    setStatus("At initial state.");
    return;
  }
  currentStep--;
  updateVisualState();
  updateEdgeList();
  updateLog();
  updateStats();
  setStatus("Stepped back.");
}

function resetAlgorithm(){
  snapshots = [];
  currentStep = -1;
  updateVisualState();
  updateEdgeList();
  updateLog();
  updateStats();
  setStatus("Algorithm reset.");
}

function updateStats(){
  if(currentStep <= 0){
    mstWeightEl.textContent = "0";
    mstCountEl.textContent = "0";
    return;
  }
  const snap = snapshots[currentStep];
  let total = 0;
  snap.selected.forEach(eid => {
    const e = edges.find(x=>x.id===eid);
    if(e) total += e.weight;
  });
  mstWeightEl.textContent = total;
  mstCountEl.textContent = snap.selected.length;
}

// ---------- Visual representation based on snapshot ----------
function updateVisualState(){
  // color nodes by union-find sets if running; highlight considered edge, accepted, rejected
  // First reset styles
  const lines = svg.querySelectorAll(".edge-line");
  lines.forEach(l => {
    l.classList.remove("selected-edge","accepted-edge","rejected-edge");
    l.classList.remove("normal-edge");
    l.classList.add("normal-edge");
    l.style.stroke = "";
  });

  const nodeGs = svg.querySelectorAll(".node-g");
  nodeGs.forEach(g => {
    const id = parseInt(g.dataset.nodeId);
    const circle = g.querySelector("circle");
    circle.style.fill = "#9fb4d6";
  });

  if(currentStep <= 0 || snapshots.length === 0){
    return;
  }
  const snap = snapshots[currentStep];
  const map = idToIndexMap();
  // compute component color mapping
  const parent = snap.parent;
  const compMap = {};
  let idx = 0;
  nodes.forEach(n => {
    const i = map[n.id];
    let p = parent[i];
    // path compression not necessary; parent array is what we have
    if(!(p in compMap)){
      compMap[p] = colorForIndex(idx++);
    }
  });
  // color nodes
  nodes.forEach(n => {
    const i = map[n.id];
    const p = parent[i];
    const color = compMap[p] || "#9fb4d6";
    const g = svg.querySelector(`.node-g[data-node-id="${n.id}"]`);
    if(g){
      const circle = g.querySelector("circle");
      circle.style.fill = color;
    }
  });

  // color edges
  const acceptedSet = new Set(snap.selected);
  const rejectedSet = new Set(snap.rejected);
  const consideredEdgeId = snap.lastEdge !== undefined ? snap.lastEdge : null;

  edges.forEach(e => {
    const line = svg.querySelector(`.edge-line[data-edge-id="${e.id}"]`);
    if(!line) return;
    if(e.id === consideredEdgeId){
      line.classList.add("selected-edge");
      if(acceptedSet.has(e.id)){
        line.classList.add("accepted-edge");
        line.classList.remove("rejected-edge");
      } else if(rejectedSet.has(e.id)){
        line.classList.add("rejected-edge");
        line.classList.remove("accepted-edge");
      }
    } else {
      if(acceptedSet.has(e.id)){
        line.classList.add("accepted-edge");
        line.classList.remove("rejected-edge");
        line.classList.remove("selected-edge");
      } else if(rejectedSet.has(e.id)){
        line.classList.add("rejected-edge");
        line.classList.remove("accepted-edge");
        line.classList.remove("selected-edge");
      } else {
        // normal edge
        line.classList.remove("accepted-edge");
        line.classList.remove("rejected-edge");
        line.classList.remove("selected-edge");
      }
    }
  });

}

// ---------- UI: Edge list & Log ----------
function updateEdgeList(){
  edgeListEl.innerHTML = "";
  // create display array with status
  const idToEdge = edges.reduce((acc,e)=>{ acc[e.id]=e; return acc; }, {});
  let statusMap = {};
  if(currentStep > 0 && snapshots[currentStep]){
    const snap = snapshots[currentStep];
    snap.selected.forEach(id => statusMap[id] = "accepted");
    snap.rejected.forEach(id => statusMap[id] = "rejected");
    if(snap.lastEdge !== undefined) statusMap[snap.lastEdge] = statusMap[snap.lastEdge] || "considered";
  }

  sortedEdges.forEach((eid, idx)=>{
    const e = idToEdge[eid];
    if(!e) return;
    const div = document.createElement("div");
    div.className = "edge-item";
    let cls = "pending";
    if(statusMap[eid] === "accepted") cls = "accepted";
    else if(statusMap[eid] === "rejected") cls = "rejected";
    else if(statusMap[eid] === "considered") cls = "pending";
    div.classList.add(cls);

    const left = document.createElement("div");
    left.textContent = `${e.u} — ${e.v}`;
    left.style.fontWeight = "600";
    left.style.color = (cls==="accepted") ? "#d4fbe6" : (cls==="rejected") ? "#ffdede" : "#cfe6ff";
    const right = document.createElement("div");
    right.style.display="flex"; right.style.gap="8px"; right.style.alignItems="center";

    const wspan = document.createElement("div");
    wspan.textContent = `w=${e.weight}`;
    wspan.style.color = "#93a2c3";
    right.appendChild(wspan);

    const btn = document.createElement("button");
    btn.textContent = "Focus";
    btn.addEventListener("click", ()=>{
      // highlight on canvas
      const line = svg.querySelector(`.edge-line[data-edge-id="${e.id}"]`);
      if(line){
        line.scrollIntoView({behavior:"smooth", block:"center", inline:"center"});
        // quick pulse
        line.style.transition = "stroke-width 0.2s";
        line.style.strokeWidth = "8px";
        setTimeout(()=> line.style.strokeWidth = "", 400);
      }
    });
    right.appendChild(btn);

    div.appendChild(left);
    div.appendChild(right);
    edgeListEl.appendChild(div);
  });
}

function updateLog(){
  logListEl.innerHTML = "";
  if(currentStep <= 0 || snapshots.length === 0){
    const p = document.createElement("div");
    p.className = "edge-item pending";
    p.textContent = "No steps executed yet.";
    logListEl.appendChild(p);
    return;
  }
  const snap = snapshots[currentStep];
  snap.log.slice(-200).forEach(l=>{
    const p = document.createElement("div");
    p.className = "edge-item";
    p.textContent = l;
    logListEl.appendChild(p);
  });
}

// ---------- Controls ----------
addNodeBtn.addEventListener("click", ()=>{
  mode = "add-node-click";
  addNodeBtn.classList.add("active");
  addEdgeBtn.classList.remove("active");
  setStatus("Click on canvas to add a node.");
});
addEdgeBtn.addEventListener("click", ()=>{
  mode = "add-edge";
  addEdgeBtn.classList.add("active");
  addNodeBtn.classList.remove("active");
  addEdgeState.firstNode = null;
  setStatus("Click first node to start edge creation.");
});
clearBtn.addEventListener("click", ()=>{ if(confirm("Clear graph?")) clearGraph(); });
randomBtn.addEventListener("click", ()=>{
  const n = parseInt(nodeCountInput.value) || 6;
  const m = parseInt(edgeCountInput.value) || 10;
  const maxW = parseInt(maxWeightInput.value) || 20;
  randomGraph(n,m,maxW);
});
runBtn.addEventListener("click", ()=>{
  // run until finished
  if(currentStep === -1) stepForward(); // init
  running = true;
  stopAuto();
  autoTimer = setInterval(()=>{
    // if finished, stop
    const lastSnap = snapshots[snapshots.length-1];
    const consideredIdx = lastSnap ? lastSnap.considered : -1;
    if(consideredIdx >= sortedEdges.length - 1){
      stopAuto();
      running = false;
      setStatus("Algorithm complete.");
      return;
    }
    stepForward();
  }, 150);
  setStatus("Running KRUSKAL...");
});
stepBtn.addEventListener("click", ()=>{ stopAuto(); running=false; stepForward(); });
backBtn.addEventListener("click", ()=>{ stopAuto(); running=false; stepBack(); });
autoBtn.addEventListener("click", ()=>{
  if(autoTimer) { stopAuto(); running=false; autoBtn.textContent="Auto"; setStatus("Auto stopped."); }
  else {
    running = false;
    autoBtn.textContent="Stop";
    let delay = parseInt(speedRange.value);
    autoTimer = setInterval(()=>{ stepForward(); if(snapshots[snapshots.length-1].considered >= sortedEdges.length - 1) { stopAuto(); autoBtn.textContent="Auto"; } }, delay);
    setStatus("Auto stepping...");
  }
});

resetAlgoBtn.addEventListener("click", ()=>{ resetAlgorithm(); });
shuffleBtn.addEventListener("click", ()=>{
  // shuffle edges with same weight order randomized, then update sortedEdges
  edges.sort(()=>Math.random()-0.5);
  prepareAlgorithm();
  render();
  updateEdgeList();
  setStatus("Edges shuffled.");
});
autoUnionBtn.addEventListener("click", ()=>{
  showUnions = !showUnions;
  autoUnionBtn.textContent = showUnions ? "Show Unions" : "Hide Unions";
});

speedRange.addEventListener("input", ()=>{
  if(autoTimer){
    stopAuto();
    autoTimer = setInterval(()=>{ stepForward(); }, parseInt(speedRange.value));
  }
});

function stopAuto(){
  if(autoTimer){ clearInterval(autoTimer); autoTimer = null; autoBtn.textContent="Auto"; }
}

// ---------- Status ----------
function setStatus(s){
  statusEl.textContent = s;
}

// ---------- Initialization ----------
function initSample(){
  // create a sample graph
  clearGraph();
  const w = svg.clientWidth, h = svg.clientHeight;
  const coords = [
    {x: w*0.25, y: h*0.28},
    {x: w*0.67, y: h*0.2},
    {x: w*0.78, y: h*0.6},
    {x: w*0.45, y: h*0.78},
    {x: w*0.18, y: h*0.62},
    {x: w*0.5, y: h*0.45},
  ];
  coords.forEach((c)=> addNode(c.x, c.y));
  // add some edges
  addEdge(0,1,4);
  addEdge(0,5,2);
  addEdge(1,5,5);
  addEdge(1,2,6);
  addEdge(2,5,1);
  addEdge(2,3,3);
  addEdge(3,5,7);
  addEdge(3,4,8);
  addEdge(4,0,9);
  addEdge(4,5,4);
  prepareAlgorithm();
  render();
  updateEdgeList();
  setStatus("Sample graph loaded.");
}

window.addEventListener("resize", ()=>{
  render();
});

// initial sample
initSample();

</script>
</body>
</html>