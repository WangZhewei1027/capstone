<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Interactive Knapsack Problem Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --accent: #2b7cff; --muted: #666; --ok: #2ca02c; --bad: #d9534f; --bg: #f8f9fb; }
    body { font-family: Inter, Roboto, Arial, sans-serif; margin: 0; padding: 20px; background: var(--bg); color: #111; }
    header { display:flex; align-items:center; gap:12px; }
    h1 { margin: 0; font-size: 20px; }
    .container { display: grid; grid-template-columns: 420px 1fr; gap: 18px; margin-top: 16px; }
    .panel { background: #fff; border-radius: 8px; padding: 12px; box-shadow: 0 1px 4px rgba(20,30,40,0.06); }
    label { font-size: 13px; color: var(--muted); display:block; margin-bottom:6px; }
    .controls { display:flex; flex-direction:column; gap:8px; }
    .row { display:flex; gap:8px; align-items:center; }
    input[type="number"], input[type="text"], select { padding:8px 10px; border-radius:6px; border:1px solid #e3e6ea; font-size:14px; }
    button { background: var(--accent); color: white; border: none; padding: 8px 12px; border-radius:6px; cursor:pointer; }
    button.secondary { background:#eef3ff; color:var(--accent); border:1px solid rgba(43,124,255,0.12); }
    button.danger { background: #fff0f0; color: var(--bad); border:1px solid rgba(217,83,79,0.12); }
    table { width:100%; border-collapse:collapse; margin-top:8px; font-size:13px; }
    th, td { padding:6px 8px; border-bottom:1px solid #f0f2f5; text-align:left; }
    th { font-weight:600; font-size:13px; color:#333; }
    .small { font-size:13px; color:var(--muted); }
    .item-row.selected { background: linear-gradient(90deg, rgba(43,124,255,0.05), rgba(43,124,255,0.02)); }
    .chart { display:flex; gap:8px; align-items:end; height:180px; border-top:1px dashed #eee; padding-top:10px; margin-top:12px; }
    .bar { width:26px; position:relative; border-radius:4px; background:#e6eefc; display:flex; align-items:flex-end; justify-content:center; }
    .bar .value { font-size:11px; padding:4px; color:#063; font-weight:700; background: rgba(34,197,94,0.08); border-radius:4px; margin-bottom:4px; }
    .bar .label { position:absolute; bottom:-18px; font-size:11px; color:var(--muted); white-space:nowrap; transform:translateX(-50%); left:50%; }
    .bar.selected { box-shadow: 0 6px 18px rgba(43,124,255,0.08); background: linear-gradient(180deg,#2b7cff22,#2b7cff12); }
    .info { margin-top:10px; display:flex; gap:12px; flex-wrap:wrap; }
    .pill { background:#fff; border:1px solid #eef2fb; padding:8px 10px; border-radius:8px; font-size:13px; }
    .dp-grid { overflow:auto; max-height:280px; border:1px solid #f0f2f5; margin-top:8px; }
    .dp-table { border-collapse:collapse; font-size:12px; }
    .dp-table td, .dp-table th { padding:4px 6px; border:1px solid #f3f5f7; text-align:center; min-width:28px; }
    .dp-cell.highlight { background: linear-gradient(180deg,#2b7cff22,#2b7cff12); font-weight:700; }
    .note { font-size:13px; color:var(--muted); margin-top:8px; }
    .footer { margin-top:10px; font-size:13px; color:var(--muted); }
    .algo-desc { font-size:13px; color:var(--muted); margin-top:8px; }
    .flex-between { display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .tiny { font-size:12px; color:var(--muted); }
    .muted { color:var(--muted); }
    input[type="number"].small { width:64px; }
    .actions { display:flex; gap:8px; }
    .code-block { background:#0f1724; color:#e6eefc; padding:10px; border-radius:6px; font-size:12px; overflow:auto; }
    .warn { color:var(--bad); font-weight:700; }
  </style>
</head>
<body>
  <header>
    <h1>Knapsack Problem — Interactive Demo</h1>
    <div class="small muted">Try algorithms: 0/1 (Dynamic Programming), Brute-force, Fractional Greedy</div>
  </header>

  <div class="container">
    <div class="panel">
      <div class="controls">
        <div class="row flex-between">
          <div>
            <label>Capacity (W)</label>
            <input id="capacity" type="number" value="50" min="0" />
          </div>
          <div>
            <label>Algorithm</label>
            <select id="algo">
              <option value="dp">0/1 Knapsack (Dynamic Programming)</option>
              <option value="bruteforce">Brute-force (exact)</option>
              <option value="fractional">Fractional Greedy (approx)</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div style="flex:1">
            <label>Items</label>
            <table id="itemsTable">
              <thead>
                <tr><th>#</th><th>Weight</th><th>Value</th><th>Ratio</th><th></th></tr>
              </thead>
              <tbody id="itemsBody"></tbody>
            </table>
            <div style="margin-top:8px; display:flex; gap:8px;">
              <button id="addItem" class="secondary">+ Add Item</button>
              <button id="randomItems" class="secondary">Randomize</button>
              <button id="clearItems" class="danger">Clear</button>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:8px; align-items:center;">
          <div class="actions" style="margin-left:auto">
            <button id="compute">Compute</button>
            <button id="animateDP" class="secondary">Visualize DP (if available)</button>
          </div>
        </div>

        <div class="note" id="noteArea">
          Tip: Use small number of items (≤20) for brute-force. DP visualization limited by capacity (≤200).
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="flex-between">
        <div>
          <div class="small muted">Result</div>
          <h2 id="resultTitle">No run yet</h2>
        </div>
        <div class="tiny muted" id="statsArea">—</div>
      </div>

      <div class="info" id="summary">
        <!-- pills inserted here -->
      </div>

      <div id="selectionList" style="margin-top:8px;"></div>

      <div id="chartArea"></div>

      <div id="dpArea"></div>

      <div class="footer">
        <div class="algo-desc" id="algoDesc">
          Select an algorithm and click "Compute". You can edit items inline or randomize. This demo supports:
          <ul>
            <li><b>0/1 DP:</b> exact integer 0/1 knapsack using dynamic programming with backtracking.</li>
            <li><b>Brute-force:</b> tries every subset (exact); only use for small n.</li>
            <li><b>Fractional Greedy:</b> sorts by value/weight ratio and fills capacity with fractions (optimal for fractional knapsack).</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Knapsack interactive demo
    (function(){
      // DOM elements
      const itemsBody = document.getElementById('itemsBody');
      const capacityInput = document.getElementById('capacity');
      const addItemBtn = document.getElementById('addItem');
      const randomBtn = document.getElementById('randomItems');
      const clearBtn = document.getElementById('clearItems');
      const computeBtn = document.getElementById('compute');
      const animateDPBtn = document.getElementById('animateDP');
      const algoSelect = document.getElementById('algo');
      const resultTitle = document.getElementById('resultTitle');
      const statsArea = document.getElementById('statsArea');
      const summary = document.getElementById('summary');
      const selectionList = document.getElementById('selectionList');
      const chartArea = document.getElementById('chartArea');
      const dpArea = document.getElementById('dpArea');
      const noteArea = document.getElementById('noteArea');

      let items = [];
      let lastDP = null; // store last dp table for visualization
      let lastSelection = null;

      function renderItems(){
        itemsBody.innerHTML = '';
        items.forEach((it, idx) => {
          const tr = document.createElement('tr');
          tr.className = 'item-row';
          tr.dataset.index = idx;
          const ratio = it.w > 0 ? (it.v / it.w).toFixed(3) : '—';
          tr.innerHTML = `
            <td>${idx+1}</td>
            <td><input type="number" min="0" class="small" data-field="w" value="${it.w}" /></td>
            <td><input type="number" min="0" class="small" data-field="v" value="${it.v}" /></td>
            <td class="tiny">${ratio}</td>
            <td><button data-action="remove" class="secondary">Remove</button></td>
          `;
          itemsBody.appendChild(tr);
        });
      }

      function addItem(w=10, v=10){
        items.push({w: Math.max(0, Math.floor(w)), v: Math.max(0, Math.floor(v))});
        renderItems();
      }

      function randomize(n=6, wMin=1, wMax=20, vMin=1, vMax=50){
        items = [];
        for(let i=0;i<n;i++){
          const w = randInt(wMin, wMax);
          const v = randInt(vMin, vMax);
          items.push({w,v});
        }
        renderItems();
      }

      function clearItems(){
        items = [];
        renderItems();
        clearResults();
      }

      function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

      // init
      randomize(6);

      // event delegation for item edits and removes
      itemsBody.addEventListener('input', (e)=>{
        const tr = e.target.closest('tr');
        if(!tr) return;
        const idx = +tr.dataset.index;
        const field = e.target.dataset.field;
        if(field && items[idx]){
          const val = Math.max(0, Math.floor(Number(e.target.value) || 0));
          items[idx][field] = val;
          renderItems();
        }
      });

      itemsBody.addEventListener('click', (e)=>{
        const tr = e.target.closest('tr');
        if(!tr) return;
        const idx = +tr.dataset.index;
        const action = e.target.dataset.action;
        if(action === 'remove'){
          items.splice(idx,1);
          renderItems();
        }
      });

      addItemBtn.addEventListener('click', ()=>{ addItem(10,10); });

      randomBtn.addEventListener('click', ()=>{
        const n = Math.max(1, parseInt(prompt('How many random items?', '6')) || 6);
        randomize(Math.min(20, n));
        clearResults();
      });

      clearBtn.addEventListener('click', ()=>{
        if(!confirm('Clear all items?')) return;
        clearItems();
      });

      capacityInput.addEventListener('input', ()=>{
        // keep numeric
        if(capacityInput.value === '') return;
        capacityInput.value = Math.max(0, Math.floor(Number(capacityInput.value) || 0));
      });

      computeBtn.addEventListener('click', runSelectedAlgo);

      animateDPBtn.addEventListener('click', visualizeDP);

      function clearResults(){
        resultTitle.textContent = 'No run yet';
        statsArea.textContent = '—';
        summary.innerHTML = '';
        selectionList.innerHTML = '';
        chartArea.innerHTML = '';
        dpArea.innerHTML = '';
        lastDP = null;
        lastSelection = null;
      }

      function runSelectedAlgo(){
        dpArea.innerHTML = '';
        const algo = algoSelect.value;
        const W = Math.max(0, Math.floor(Number(capacityInput.value) || 0));
        if(items.length === 0){
          alert('Add some items first.');
          return;
        }
        if(algo === 'bruteforce' && items.length > 24){
          if(!confirm(`Brute-force with ${items.length} items will be slow (2^${items.length} subsets). Continue?`)) return;
        }
        const start = performance.now();
        let res;
        try {
          if(algo === 'dp'){
            res = knapsackDP(items, W);
            lastDP = res.dpTable; // store for visualization
          } else if(algo === 'bruteforce'){
            res = knapsackBruteForce(items, W);
            lastDP = null;
          } else if(algo === 'fractional'){
            res = knapsackFractional(items, W);
            lastDP = null;
          }
        } catch(err){
          alert('Error: ' + err.message);
          return;
        }
        const took = (performance.now() - start).toFixed(2);
        displayResult(res, took);
      }

      function displayResult(res, timeMs){
        const W = Math.max(0, Math.floor(Number(capacityInput.value) || 0));
        resultTitle.textContent = `${res.name} — total value: ${res.value}, weight: ${res.weight}/${W}`;
        statsArea.textContent = `time: ${timeMs} ms | items: ${items.length}`;
        summary.innerHTML = `
          <div class="pill">Total value: <b>${res.value}</b></div>
          <div class="pill">Total weight: <b>${res.weight}</b></div>
          <div class="pill">Algorithm: <b>${res.algoLabel}</b></div>
        `;
        // selection
        selectionList.innerHTML = '';
        if(res.selected && res.selected.length > 0){
          const ul = document.createElement('div');
          ul.innerHTML = '<div class="small muted">Selected items (index : weight / value)</div>';
          const list = document.createElement('div');
          list.style.display='flex'; list.style.gap='8px'; list.style.flexWrap='wrap'; list.style.marginTop='6px';
          res.selected.forEach(si=>{
            const d = document.createElement('div');
            d.className='pill';
            d.textContent = `${si.index+1}: w=${si.w}, v=${si.v}${si.fraction!==undefined? (' (f=' + si.fraction + ')') : ''}`;
            list.appendChild(d);
          });
          ul.appendChild(list);
          selectionList.appendChild(ul);
        } else {
          selectionList.innerHTML = '<div class="small muted">No items selected.</div>';
        }

        // chart
        chartArea.innerHTML = '';
        const chartWrapper = document.createElement('div');
        chartWrapper.className = 'chart';
        const maxWeight = Math.max(1, ...items.map(it=>it.w));
        const maxValue = Math.max(1, ...items.map(it=>it.v));
        resIndices = new Set((res.selected || []).map(s => s.index));
        items.forEach((it, idx)=>{
          const bar = document.createElement('div');
          bar.className = 'bar' + (resIndices.has(idx) ? ' selected' : '');
          // height relates to value primarily; weight shown by color intensity
          const hRatio = it.v / maxValue;
          const heightPercent = Math.max(8, Math.round(hRatio*100));
          bar.style.height = (heightPercent*1.6) + 'px'; // scaled for display
          // create inner value label
          const valueLabel = document.createElement('div');
          valueLabel.className='value';
          valueLabel.textContent = it.v;
          // label below
          const lab = document.createElement('div');
          lab.className = 'label';
          lab.textContent = (idx+1) + ' (w:'+it.w+')';
          // color by weight
          const weightRatio = it.w / maxWeight;
          const bg = blendColor('#e6eefc', '#2b7cff22', weightRatio);
          bar.style.background = resIndices.has(idx) ? 'linear-gradient(180deg,#2b7cff22,#2b7cff12)' : bg;
          bar.appendChild(valueLabel);
          bar.appendChild(lab);
          chartWrapper.appendChild(bar);
        });
        chartArea.appendChild(chartWrapper);

        // highlight selected rows in table
        document.querySelectorAll('.item-row').forEach(tr=>{
          const idx = +tr.dataset.index;
          if(resIndices.has(idx)){
            tr.classList.add('selected');
          } else tr.classList.remove('selected');
        });

        lastSelection = res.selected || [];
        // If there is a DP table and capacity small, render small preview
        if(lastDP && Number(capacityInput.value) <= 200 && items.length <= 40){
          dpArea.innerHTML = '<div class="small muted">DP table available — click "Visualize DP" to see full table/animation.</div>';
        } else if(lastDP){
          dpArea.innerHTML = '<div class="small muted">DP table computed but not shown (capacity too large or many items). Use small capacity ≤200 to visualize.</div>';
        } else {
          dpArea.innerHTML = '';
        }
      }

      // DP algorithm for 0/1 knapsack (exact), returns table for visualization and selected items
      function knapsackDP(items, W){
        // ensure integer weights
        const n = items.length;
        const dp = Array.from({length: n+1}, ()=> new Array(W+1).fill(0));
        // fill table
        for(let i=1;i<=n;i++){
          const wt = items[i-1].w;
          const val = items[i-1].v;
          for(let w=0; w<=W; w++){
            if(wt <= w){
              const take = dp[i-1][w-wt] + val;
              const leave = dp[i-1][w];
              dp[i][w] = Math.max(take, leave);
            } else {
              dp[i][w] = dp[i-1][w];
            }
          }
        }
        // backtrack selected
        let w = W;
        const selected = [];
        let totalW = 0;
        for(let i=n; i>0; i--){
          if(dp[i][w] !== dp[i-1][w]){ // means item i-1 is taken
            selected.push({index: i-1, w: items[i-1].w, v: items[i-1].v});
            w -= items[i-1].w;
            totalW += items[i-1].w;
          }
        }
        selected.reverse();
        return { name: '0/1 Knapsack (DP)', value: dp[n][W], weight: totalW, selected, dpTable: dp, algoLabel: '0/1 DP' };
      }

      // Brute force: check all subsets
      function knapsackBruteForce(items, W){
        const n = items.length;
        if(n > 28) throw new Error('Too many items for brute-force');
        let bestV = 0, bestW = 0, bestMask = 0;
        const limit = 1<<n;
        for(let mask=0; mask<limit; mask++){
          let sumW = 0, sumV = 0;
          for(let i=0;i<n;i++){
            if(mask & (1<<i)){
              sumW += items[i].w;
              sumV += items[i].v;
            }
          }
          if(sumW <= W && sumV > bestV){
            bestV = sumV; bestW = sumW; bestMask = mask;
          }
        }
        const selected = [];
        for(let i=0;i<n;i++){
          if(bestMask & (1<<i)) selected.push({index:i, w: items[i].w, v: items[i].v});
        }
        return { name: 'Brute-force (exact)', value: bestV, weight: bestW, selected, algoLabel: 'Brute-force' };
      }

      // Fractional greedy knapsack
      function knapsackFractional(items, W){
        // sort by ratio
        const arr = items.map((it, idx)=> ({...it, index: idx, ratio: it.w>0? it.v/it.w: Infinity}));
        arr.sort((a,b)=> b.ratio - a.ratio);
        let rem = W;
        let totalV = 0, totalW = 0;
        const selected = [];
        for(const it of arr){
          if(rem === 0) break;
          if(it.w <= rem){
            selected.push({index: it.index, w: it.w, v: it.v, fraction: 1});
            rem -= it.w;
            totalV += it.v;
            totalW += it.w;
          } else {
            const frac = rem / it.w;
            selected.push({index: it.index, w: it.w, v: Math.round(it.v * frac*100)/100, fraction: Math.round(frac*1000)/1000});
            totalV += it.v * frac;
            totalW += rem;
            rem = 0;
            break;
          }
        }
        totalV = Math.round(totalV*100)/100;
        return { name: 'Fractional Greedy', value: totalV, weight: totalW, selected, algoLabel: 'Fractional (greedy, optimal for fractional knapsack)' };
      }

      // DP visualization: if lastDP present
      function visualizeDP(){
        if(!lastDP){
          alert('No DP table available. Run 0/1 DP first (algorithm must be "0/1 Knapsack (Dynamic Programming)").');
          return;
        }
        const dp = lastDP;
        const n = dp.length - 1;
        const W = dp[0].length - 1;
        if(W > 200){
          if(!confirm('Capacity is large. Visualizing may be slow. Continue?')) return;
        }
        dpArea.innerHTML = '<div class="small muted">DP table (rows = items, columns = capacity). Click cells to see source.</div>';
        const gridWrap = document.createElement('div');
        gridWrap.className = 'dp-grid';
        const table = document.createElement('table');
        table.className = 'dp-table';
        // header row capacities
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        headerRow.appendChild(cell('th', 'i\\w'));
        for(let w=0; w<=W; w++) headerRow.appendChild(cell('th', w));
        thead.appendChild(headerRow);
        table.appendChild(thead);
        const tbody = document.createElement('tbody');
        for(let i=0;i<=n;i++){
          const row = document.createElement('tr');
          row.appendChild(cell('td', i));
          for(let w=0; w<=W; w++){
            const td = cell('td', dp[i][w]);
            td.dataset.i = i; td.dataset.w = w;
            td.addEventListener('click', ()=> onDPClick(dp, td));
            row.appendChild(td);
          }
          tbody.appendChild(row);
        }
        table.appendChild(tbody);
        gridWrap.appendChild(table);
        dpArea.appendChild(gridWrap);
        // also show backtracking path highlight
        highlightBacktrack(dp);
      }

      function onDPClick(dp, td){
        // show explanation of how value was formed from previous row
        const i = +td.dataset.i, w = +td.dataset.w;
        const max = dp[i][w];
        let text = `dp[${i}][${w}] = ${max}\n`;
        if(i === 0) text += 'Base row (no items).';
        else {
          const notTake = dp[i-1][w];
          text += `Not take item ${i}: dp[${i-1}][${w}] = ${notTake}\n`;
          const wt = items[i-1].w, val = items[i-1].v;
          if(wt <= w){
            const take = dp[i-1][w-wt] + val;
            text += `Take item ${i}: dp[${i-1}][${w-wt}] + v${i} (${val}) = ${take}\n`;
            text += take >= notTake ? 'Take gives the max.' : 'Not taking gives the max.';
          } else {
            text += `Item ${i} too heavy for this capacity (${wt} > ${w}).`;
          }
        }
        alert(text);
      }

      function highlightBacktrack(dp){
        // highlight cells used by optimal backtrack path
        const n = dp.length - 1;
        const W = dp[0].length - 1;
        let w = W;
        const tableCells = dpArea.querySelectorAll('td');
        // clear existing highlight
        tableCells.forEach(td=> td.classList.remove('highlight'));
        for(let i=n; i>0; i--){
          const cell = dpArea.querySelector(`td[data-i="${i}"][data-w="${w}"]`);
          if(!cell) continue;
          const fromAbove = dp[i-1][w];
          if(dp[i][w] !== fromAbove){
            // chosen
            cell.classList.add('highlight');
            w -= items[i-1].w;
            if(w < 0) w = 0;
          } else {
            // not chosen, highlight the cell too for visibility (optional)
            const prev = dpArea.querySelector(`td[data-i="${i-1}"][data-w="${w}"]`);
            if(prev) prev.classList.add('highlight');
          }
        }
      }

      function cell(tag, content){
        const el = document.createElement(tag);
        el.textContent = content;
        return el;
      }

      // small color blend util
      function blendColor(a,b,t){
        // naive: return linear gradient or just hex interpolation? we'll return a CSS linear-gradient or a solid computed color
        // Simple solid blend between two hex/rgb strings: approximate by extracting numbers if hex given
        // Fallback to first color
        try {
          // parse hex like #rrggbb
          function hexToRgb(hex){
            hex = hex.replace('#','');
            if(hex.length === 3) hex = hex.split('').map(ch=>ch+ch).join('');
            const r = parseInt(hex.substring(0,2),16);
            const g = parseInt(hex.substring(2,4),16);
            const bl = parseInt(hex.substring(4,6),16);
            return [r,g,bl];
          }
          const c1 = hexToRgb('#e6eefc');
          const c2 = [43,124,255];
          const r = Math.round(c1[0] + (c2[0]-c1[0])*t);
          const g = Math.round(c1[1] + (c2[1]-c1[1])*t);
          const bl = Math.round(c1[2] + (c2[2]-c1[2])*t);
          return `rgb(${r},${g},${bl},${0.18 + t*0.25})`;
        } catch(e){
          return a;
        }
      }

      // initial compute run to show something
      runSelectedAlgo();

      // helpful keyboard: Enter runs compute
      document.addEventListener('keydown', (e)=>{
        if((e.key === 'Enter' || e.key === 'Return') && document.activeElement.tagName !== 'INPUT') runSelectedAlgo();
      });

    })();
  </script>
</body>
</html>