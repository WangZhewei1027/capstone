<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Radix Sort Visualizer (LSD) — Interactive Demo</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#4f46e5;
    --muted:#94a3b8;
    --card:#0b1220;
    --box:#111827;
    --good:#10b981;
    --danger:#ef4444;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071129);color:#e6eef6;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
  .container{max-width:1100px;margin:28px auto;padding:18px;}
  header{display:flex;align-items:center;gap:12px;margin-bottom:14px;}
  header h1{font-size:20px;margin:0;}
  .controls{display:flex;flex-wrap:wrap;gap:8px;background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;margin-bottom:14px;}
  .controls label{font-size:13px;color:var(--muted);display:flex;flex-direction:column;}
  input[type="text"]{min-width:260px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;}
  button{background:var(--accent);color:white;padding:8px 12px;border-radius:8px;border:0;font-weight:600;cursor:pointer;}
  button.secondary{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.04);}
  .small{padding:6px 8px;font-size:13px;}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;}
  .visual{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:14px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);}
  .array-row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:12px;}
  .num{min-width:40px;min-height:40px;padding:6px 8px;border-radius:8px;background:linear-gradient(180deg,#0b1220,#091021);display:flex;align-items:center;justify-content:center;font-weight:700;border:1px solid rgba(255,255,255,0.03);box-shadow:0 6px 14px rgba(2,6,23,0.6);position:relative;}
  .num.small{min-width:34px;min-height:34px;font-size:14px;}
  .panel{display:flex;gap:12px;align-items:flex-start;margin-top:12px;}
  .buckets{display:flex;gap:8px;flex-wrap:wrap;align-items:flex-start;padding:6px;}
  .bucket{min-width:72px;min-height:70px;background:#071428;border-radius:8px;padding:8px;border:1px solid rgba(255,255,255,0.03);}
  .bucket h4{margin:0;color:var(--muted);font-size:12px;text-align:center;}
  .bucket .bucket-content{display:flex;flex-direction:column;gap:6px;align-items:center;margin-top:8px;min-height:18px;}
  .status{margin-top:12px;color:var(--muted);font-size:13px;}
  .legend{display:flex;gap:8px;align-items:center;color:var(--muted);font-size:13px;margin-left:auto;}
  .controls-group{display:flex;gap:8px;align-items:center;}
  .speed{width:140px;}
  .info{margin-top:12px;color:var(--muted);font-size:13px;line-height:1.4;}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px;}
  pre{background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;overflow:auto;color:#cfe8ff;font-size:13px;}
  .footer{margin-top:14px;color:var(--muted);font-size:13px;display:flex;gap:12px;align-items:center;}
  .badge{font-size:12px;padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.03);}
  .muted{color:var(--muted);}
  .controls .help{font-size:12px;color:var(--muted);margin-left:8px;}
  .highlight{background:linear-gradient(90deg, rgba(79,70,229,0.12), rgba(79,70,229,0.03));border:1px solid rgba(79,70,229,0.12);padding:8px;border-radius:8px;}
  .checkbox{display:flex;gap:6px;align-items:center;cursor:pointer;}
  /* small responsive */
  @media (max-width:900px){
    .grid{grid-template-columns:1fr; }
  }
</style>
</head>
<body>
<div class="container">
  <header>
    <svg width="36" height="36" viewBox="0 0 24 24" fill="none" aria-hidden><path d="M4 6h16M4 12h16M4 18h16" stroke="#7c83ff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
    <div>
      <h1>Radix Sort Visualizer (LSD) — Interactive Demo</h1>
      <div class="muted" style="font-size:13px;margin-top:4px;">Least Significant Digit (LSD) radix sort for integers — step-through animation.</div>
    </div>
  </header>

  <div class="controls">
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
      <label>
        Input numbers (comma/space separated)
        <input id="inputArray" type="text" value="170, 45, 75, 90, 802, 24, 2, 66" />
      </label>

      <label>
        Base (radix)
        <select id="radixSelect" style="padding:8px;border-radius:8px;background:transparent;color:inherit;border:1px solid rgba(255,255,255,0.04);">
          <option value="2">2 (binary)</option>
          <option value="4">4</option>
          <option value="8">8</option>
          <option value="10" selected>10 (decimal)</option>
          <option value="16">16 (hex)</option>
        </select>
      </label>

      <label style="min-width:130px;">
        Random array
        <div style="display:flex;gap:6px;">
          <input id="randCount" type="number" value="12" min="1" style="width:72px;padding:6px;border-radius:8px;background:transparent;color:inherit;border:1px solid rgba(255,255,255,0.04);" />
          <input id="randMax" type="number" value="999" min="1" style="width:72px;padding:6px;border-radius:8px;background:transparent;color:inherit;border:1px solid rgba(255,255,255,0.04);" />
        </div>
      </label>

      <div class="controls-group">
        <button id="btnRandom" class="small secondary">Randomize</button>
        <button id="btnLoad" class="small">Load & Prepare</button>
      </div>
    </div>

    <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
      <div style="display:flex;gap:8px;align-items:center">
        <label style="display:flex;flex-direction:column;align-items:flex-end;">
          Speed
          <input id="speed" class="speed" type="range" min="0.2" max="2.5" step="0.1" value="1" />
        </label>
      </div>

      <div class="controls-group">
        <button id="btnStart" class="small">Play</button>
        <button id="btnStep" class="small secondary">Step</button>
        <button id="btnBack" class="small secondary">Back</button>
        <button id="btnReset" class="small secondary">Reset</button>
      </div>
    </div>
  </div>

  <div class="visual">
    <div style="display:flex;align-items:center;gap:12px;">
      <div class="badge">LSD Radix Sort</div>
      <div class="muted">Stable, digit-by-digit (least significant to most)</div>
      <div class="legend">
        <div class="muted">Radix (base): <strong id="radixLabel">10</strong></div>
      </div>
    </div>

    <div style="margin-top:12px;">
      <div class="muted">Initial array:</div>
      <div id="initialArray" class="array-row"></div>
    </div>

    <div class="grid">
      <div>
        <div class="muted" style="margin-bottom:8px;">Active group (sorting):</div>
        <div id="activePanel" class="panel highlight" style="min-height:160px;padding:12px;border-radius:10px;">
          <div style="flex:1;">
            <div class="muted">Group label: <span id="groupLabel">—</span></div>
            <div id="groupArray" class="array-row" style="margin-top:8px;"></div>
          </div>

          <div style="width:420px;">
            <div class="muted">Buckets:</div>
            <div id="buckets" class="buckets" style="margin-top:8px;"></div>
          </div>
        </div>

        <div class="status"><span id="statusText">Press "Load & Prepare" to build events.</span></div>
      </div>

      <div>
        <div class="muted" style="margin-bottom:8px;">Final result (combined):</div>
        <div class="visual" style="padding:10px;">
          <div id="resultArray" class="array-row"></div>
          <div class="info" style="margin-top:10px;">
            This demo handles negative integers by sorting negative and non-negative groups separately:
            negative values are sorted by their absolute values, then reversed and re-negated so that the overall array is correctly ascending.
          </div>
        </div>
      </div>
    </div>

    <div style="margin-top:12px;">
      <div style="display:flex;gap:12px;align-items:flex-start;">
        <div style="flex:1;">
          <h3 style="margin:6px 0 8px 0;">Pseudocode (LSD Radix Sort)</h3>
          <pre>
function radixSortLSD(array, base):
  for d = 0 to maxDigits-1:
    create base buckets (0..base-1)
    for each value in array (in order):          // stable placement
      digit = (value / base^d) % base
      buckets[digit].append(value)
    array = concatenate buckets in order
  return array
          </pre>
        </div>
        <div style="width:340px;">
          <h3 style="margin:6px 0 8px 0;">Complexity & notes</h3>
          <div class="muted" style="font-size:13px;line-height:1.4;">
            - Time: O(d*(n + b)) where d = number of digits, b = radix (base).<br>
            - Space: O(n + b).<br>
            - Stable sort; works well for integers and fixed-length keys.<br>
            - Negative values: handled by splitting negatives and positives.
          </div>
        </div>
      </div>
    </div>

    <div class="footer">
      <div class="muted">Use Step / Play to observe placements and collections per digit.</div>
    </div>
  </div>
</div>

<script>
(() => {
  // Utility helpers
  const $ = id => document.getElementById(id);
  const randInt = (min,max) => Math.floor(Math.random()*(max-min+1))+min;

  // DOM elements
  const inputArray = $('inputArray');
  const btnRandom = $('btnRandom');
  const btnLoad = $('btnLoad');
  const btnStart = $('btnStart');
  const btnStep = $('btnStep');
  const btnBack = $('btnBack');
  const btnReset = $('btnReset');
  const speedRange = $('speed');
  const radixSelect = $('radixSelect');
  const radLabel = $('radixLabel');
  const initialArrayDiv = $('initialArray');
  const groupArrayDiv = $('groupArray');
  const bucketsDiv = $('buckets');
  const statusText = $('statusText');
  const resultArrayDiv = $('resultArray');
  const groupLabel = $('groupLabel');

  const randCount = $('randCount');
  const randMax = $('randMax');

  // State
  let inputNumbers = [];
  let events = []; // sequence of events for animation
  let eventIndex = -1;
  let playing = false;
  let playTimer = null;
  let speed = parseFloat(speedRange.value) || 1;
  let base = parseInt(radixSelect.value,10) || 10;

  // Colors for items by value (consistent mapping)
  function colorForValue(v){
    // deterministic color by value
    const seed = Math.abs(v*2654435761) >>> 0;
    const r = 80 + (seed % 120);
    const g = 90 + ((seed>>8) % 90);
    const b = 130 + ((seed>>16) % 80);
    return `rgb(${r},${g},${b})`;
  }

  function parseInput(text){
    if(!text) return [];
    const parts = text.split(/[\s,;]+/).filter(s=>s.trim().length>0);
    const nums = [];
    for(const p of parts){
      const n = Number(p);
      if(Number.isFinite(n) && Number.isInteger(n)){
        nums.push(n);
      }
    }
    return nums;
  }

  function renderInitialArray(arr){
    initialArrayDiv.innerHTML = '';
    for(const v of arr){
      const el = document.createElement('div');
      el.className = 'num';
      el.textContent = v;
      el.style.background = `linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.1)), ${colorForValue(v)}`;
      el.style.color = '#fff';
      initialArrayDiv.appendChild(el);
    }
  }

  function clearActivePanel(){
    groupArrayDiv.innerHTML = '';
    bucketsDiv.innerHTML = '';
  }

  function renderArrayTo(div, arr, small=false){
    div.innerHTML = '';
    for(const v of arr){
      const el = document.createElement('div');
      el.className = 'num' + (small? ' small':'');
      el.textContent = v;
      el.style.background = `linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.1)), ${colorForValue(v)}`;
      el.style.color = '#fff';
      div.appendChild(el);
    }
  }

  function createBucketsDom(b){
    bucketsDiv.innerHTML = '';
    for(let i=0;i<b;i++){
      const bucket = document.createElement('div');
      bucket.className = 'bucket';
      const h = document.createElement('h4');
      h.textContent = 'bucket ' + i;
      bucket.appendChild(h);
      const content = document.createElement('div');
      content.className = 'bucket-content';
      bucket.appendChild(content);
      bucketsDiv.appendChild(bucket);
    }
  }

  // Build events for LSD radix sort for one group (non-negative integers, values >= 0)
  function buildEventsLSDForGroup(arr, base, groupName){
    // arr assumed non-negative integers
    const events = [];
    if(arr.length === 0){
      return events;
    }
    const maxVal = Math.max(...arr);
    const maxDigits = Math.max(1, Math.ceil(Math.log(maxVal+1) / Math.log(base)));
    let state = arr.slice();

    for(let d=0; d<maxDigits; d++){
      // placement events: one per element in current order
      const buckets = Array.from({length: base}, ()=>[]);
      for(let i=0;i<state.length;i++){
        const value = state[i];
        const digit = Math.floor(value / Math.pow(base, d)) % base;
        // push place event
        events.push({
          type: 'place',
          group: groupName,
          pass: d,
          value,
          digit,
          idx: i
        });
        buckets[digit].push(value);
      }
      // after placements, collect event
      const newArray = [].concat(...buckets);
      events.push({
        type: 'collect',
        group: groupName,
        pass: d,
        newArray: newArray.slice()
      });
      state = newArray;
    }
    // final state event
    events.push({
      type: 'groupDone',
      group: groupName,
      finalArray: state.slice()
    });
    return events;
  }

  // Build combined events for entire input (handles negatives by splitting)
  function buildAllEvents(arr, base){
    const positives = arr.filter(x=>x>=0);
    const negatives = arr.filter(x=>x<0).map(x=>-x); // store absolute values for sorting
    const allEvents = [];

    // initial separation event
    allEvents.push({type:'separate', positives: positives.slice(), negatives: negatives.slice()});

    // sort negatives (their values are absolute)
    if(negatives.length>0){
      allEvents.push({type:'focus', group: 'negatives', note: 'Sorting negative values by absolute digits'});
      const evNeg = buildEventsLSDForGroup(negatives, base, 'negatives');
      allEvents.push(...evNeg);
      // after groupDone there will be finalArray of absolute values (sorted ascending by abs)
      // we will need to reverse and reapply negative sign when combining.
    }

    // sort positives
    if(positives.length>0){
      allEvents.push({type:'focus', group: 'positives', note: 'Sorting non-negative values'});
      const evPos = buildEventsLSDForGroup(positives, base, 'positives');
      allEvents.push(...evPos);
    }

    // combine event: take sorted negatives (reverse and negate), then sorted positives
    allEvents.push({type:'combine'});
    allEvents.push({type:'done'});
    return allEvents;
  }

  // Rendering & animation of events
  let model = {
    separatedPos: [],
    separatedNegAbs: [],
    sortedPos: [],
    sortedNegAbs: []
  };

  function resetModel(){
    model = {
      separatedPos: [],
      separatedNegAbs: [],
      sortedPos: [],
      sortedNegAbs: []
    };
  }

  function prepareAndBuild(){
    base = parseInt(radixSelect.value,10) || 10;
    radLabel.textContent = base;
    inputNumbers = parseInput(inputArray.value);
    if(inputNumbers.length === 0){
      statusText.textContent = 'No valid integers found in input.';
      return;
    }
    renderInitialArray(inputNumbers);
    clearActivePanel();
    resultArrayDiv.innerHTML = '';
    resetModel();
    events = buildAllEvents(inputNumbers, base);
    eventIndex = -1;
    playing = false;
    updateControlButtons();
    statusText.textContent = `Prepared ${events.length} events. Ready to play.`;
  }

  function stepForward(){
    if(eventIndex >= events.length - 1) return;
    eventIndex++;
    applyEvent(events[eventIndex]);
    updateControlButtons();
  }

  function stepBack(){
    // For simplicity, reset to start and replay up to eventIndex-1
    if(eventIndex <= -1) return;
    eventIndex--;
    // Reset visuals and model, then replay events up to eventIndex
    clearActivePanel();
    resultArrayDiv.innerHTML = '';
    renderInitialArray(inputNumbers);
    resetModel();
    clearBucketsAndGroup();
    for(let i=0;i<=eventIndex;i++){
      applyEvent(events[i], {replayMode:true});
    }
    updateControlButtons();
  }

  function clearBucketsAndGroup(){
    groupLabel.textContent = '—';
    groupArrayDiv.innerHTML = '';
    bucketsDiv.innerHTML = '';
  }

  function applyEvent(ev, opts={}){
    opts = opts || {};
    switch(ev.type){
      case 'separate':
        // show separated arrays
        model.separatedPos = ev.positives.slice();
        model.separatedNegAbs = ev.negatives.slice();
        groupLabel.textContent = 'Separation';
        renderArrayTo(groupArrayDiv, ['negatives:',''] , true);
        // show separated as two groups by rendering them in the active array area
        // We'll show negative abs and positives below in active area temporarily
        createBucketsDom(base);
        // Render both groups in active area (negatives left, positives right)
        groupArrayDiv.innerHTML = '';
        const negLabel = document.createElement('div'); negLabel.className='muted'; negLabel.textContent='Negatives (abs):';
        const posLabel = document.createElement('div'); posLabel.className='muted'; posLabel.textContent='Positives:';
        groupArrayDiv.appendChild(negLabel);
        renderArrayTo(groupArrayDiv, model.separatedNegAbs);
        groupArrayDiv.appendChild(posLabel);
        renderArrayTo(groupArrayDiv, model.separatedPos);
        statusText.textContent = `Separated ${model.separatedNegAbs.length} negatives and ${model.separatedPos.length} non-negatives.`;
        break;

      case 'focus':
        // prepare panel for group
        createBucketsDom(base);
        groupLabel.textContent = ev.group === 'negatives' ? 'NEGATIVES (abs)' : 'POSITIVES';
        if(ev.group === 'negatives'){
          renderArrayTo(groupArrayDiv, model.separatedNegAbs);
        } else {
          renderArrayTo(groupArrayDiv, model.separatedPos);
        }
        statusText.textContent = ev.note || `Focusing on ${ev.group}`;
        break;

      case 'place':
        // place value into a bucket (append)
        {
          const bucketBoxes = bucketsDiv.querySelectorAll('.bucket');
          // find bucket content by digit
          const bucketContent = bucketBoxes[ev.digit].querySelector('.bucket-content');
          // create element
          const node = document.createElement('div');
          node.className = 'num small';
          node.textContent = ev.value;
          node.style.background = `linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.1)), ${colorForValue(ev.value * (ev.group==='negatives'? -1:1))}`;
          node.style.color = '#fff';
          // append with slight opacity animation
          node.style.opacity = '0';
          bucketContent.appendChild(node);
          requestAnimationFrame(()=>{ node.style.transition = 'opacity 280ms'; node.style.opacity = '1'; });
          statusText.textContent = `Pass ${ev.pass}: placed ${ev.value} into bucket ${ev.digit} (${ev.group})`;
          // optionally highlight source position
          highlightSourceIndex(ev);
        }
        break;

      case 'collect':
        {
          // update the group's array display to collected newArray
          if(ev.group === 'negatives'){
            model.sortedNegAbs = ev.newArray.slice();
            renderArrayTo(groupArrayDiv, ev.newArray);
            // clear bucket contents visually (but keep them for the animation sense)
            // We'll clear after a slight delay to emphasize collection
            setTimeout(()=> {
              const bucketContents = bucketsDiv.querySelectorAll('.bucket-content');
              bucketContents.forEach(bc=>bc.innerHTML='');
            }, 300);
          } else {
            model.sortedPos = ev.newArray.slice();
            renderArrayTo(groupArrayDiv, ev.newArray);
            setTimeout(()=> {
              const bucketContents = bucketsDiv.querySelectorAll('.bucket-content');
              bucketContents.forEach(bc=>bc.innerHTML='');
            }, 300);
          }
          statusText.textContent = `Pass ${ev.pass} collected (group ${ev.group}). New group order: [${ev.newArray.join(', ')}]`;
        }
        break;

      case 'groupDone':
        if(ev.group === 'negatives'){
          model.sortedNegAbs = ev.finalArray.slice();
          statusText.textContent = `Negatives sorted by absolute values: [${model.sortedNegAbs.join(', ')}]`;
        } else {
          model.sortedPos = ev.finalArray.slice();
          statusText.textContent = `Positives sorted: [${model.sortedPos.join(', ')}]`;
        }
        // clear buckets
        setTimeout(()=> {
          const bucketContents = bucketsDiv.querySelectorAll('.bucket-content');
          bucketContents.forEach(bc=>bc.innerHTML='');
        }, 200);
        break;

      case 'combine':
        // produce final array: reverse sortedNegAbs, map to negative values, then append positives
        const finalNegs = model.sortedNegAbs.slice().reverse().map(x=>-x);
        const finalPos = model.sortedPos.slice();
        const finalArr = finalNegs.concat(finalPos);
        renderArrayTo(resultArrayDiv, finalArr);
        statusText.textContent = `Combined final result: [${finalArr.join(', ')}]`;
        // also show in active panel a summary
        groupLabel.textContent = 'Result combined';
        groupArrayDiv.innerHTML = '';
        renderArrayTo(groupArrayDiv, finalArr);
        break;

      case 'done':
        statusText.textContent = 'Sorting complete.';
        break;

      default:
        console.warn('Unknown event', ev);
    }
  }

  function highlightSourceIndex(ev){
    // If possible, highlight the source item in groupArrayDiv corresponding to ev.idx
    // We'll attempt to set a slight pulse effect on the element
    const arrNodes = groupArrayDiv.querySelectorAll('.num');
    if(arrNodes && arrNodes[ev.idx]){
      const el = arrNodes[ev.idx];
      el.style.transition = 'transform 240ms, box-shadow 240ms';
      el.style.transform = 'scale(1.06)';
      el.style.boxShadow = '0 10px 18px rgba(0,0,0,0.45)';
      setTimeout(()=>{ el.style.transform = ''; el.style.boxShadow=''; }, 280);
    }
  }

  // Playback controls
  function play(){
    if(playing) return;
    playing = true;
    btnStart.textContent = 'Pause';
    scheduleNext();
  }

  function pause(){
    playing = false;
    btnStart.textContent = 'Play';
    if(playTimer) {
      clearTimeout(playTimer);
      playTimer = null;
    }
  }

  function scheduleNext(){
    if(!playing) return;
    const interval = Math.max(180, 600 / (speed || 1));
    playTimer = setTimeout(()=>{
      if(eventIndex >= events.length - 1){
        pause();
        return;
      }
      stepForward();
      scheduleNext();
    }, interval);
  }

  function updateControlButtons(){
    btnBack.disabled = (eventIndex <= -1);
    btnStep.disabled = (eventIndex >= events.length - 1);
    btnStart.disabled = (events.length === 0);
    btnReset.disabled = (eventIndex <= -1 && events.length>0);
  }

  // Event listeners
  btnRandom.addEventListener('click', ()=>{
    const n = Math.max(1, Math.min(500, parseInt(randCount.value)||12));
    const maxv = Math.max(1, parseInt(randMax.value)||999);
    const arr = [];
    for(let i=0;i<n;i++){
      // generate some negatives too sometimes
      const sign = Math.random() < 0.18 ? -1 : 1;
      arr.push(sign * randInt(0, maxv));
    }
    inputArray.value = arr.join(', ');
  });

  btnLoad.addEventListener('click', ()=> {
    try{
      prepareAndBuild();
    }catch(e){
      console.error(e);
      statusText.textContent = 'Error preparing: ' + e.message;
    }
  });

  btnStep.addEventListener('click', ()=> {
    pause();
    stepForward();
  });
  btnBack.addEventListener('click', ()=> {
    pause();
    stepBack();
  });
  btnStart.addEventListener('click', ()=>{
    if(playing){
      pause();
    } else {
      if(events.length === 0){
        prepareAndBuild();
      }
      play();
    }
  });
  btnReset.addEventListener('click', ()=>{
    pause();
    eventIndex = -1;
    clearActivePanel();
    resultArrayDiv.innerHTML = '';
    renderInitialArray(inputNumbers);
    resetModel();
    statusText.textContent = 'Reset to initial state.';
    updateControlButtons();
  });

  speedRange.addEventListener('input', (e)=>{
    speed = parseFloat(e.target.value);
  });

  radixSelect.addEventListener('change', ()=>{
    radLabel.textContent = radixSelect.value;
  });

  // Initialize UI
  renderInitialArray(parseInput(inputArray.value));
  updateControlButtons();
  statusText.textContent = 'Ready. Edit numbers and press "Load & Prepare".';

  // Accessibility: allow Enter in input to load
  inputArray.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){
      e.preventDefault();
      prepareAndBuild();
    }
  });

})();
</script>
</body>
</html>