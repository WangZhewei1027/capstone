<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Merge Sort Visualizer</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --muted:#9aa7bf;
    --accent:#60a5fa;
    --success:#34d399;
    --danger:#fb7185;
    --compare:#a78bfa;
    --write:#f59e0b;
    --range:#1e293b;
    --bar:#60a5fa;
    --sorted:#38bdf8;
    font-family: Inter, Roboto, system-ui, -apple-system, "Segoe UI", "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071029 0%, #061226 100%);color:#cbd5e1}
  .container{max-width:1100px;margin:18px auto;padding:18px;}
  header{display:flex;align-items:center;gap:18px;margin-bottom:12px}
  h1{font-size:20px;margin:0;color:var(--accent)}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:10px 0}
  .controls > *{background:var(--panel);border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:8px;color:var(--muted)}
  .btn{cursor:pointer;padding:8px 12px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);color:#e6eef8;border:1px solid rgba(255,255,255,0.03)}
  .btn:active{transform:translateY(1px)}
  .btn.secondary{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.03)}
  .controls label{display:flex;gap:6px;align-items:center;font-size:13px}
  .slider{width:160px}
  .panel{background:linear-gradient(180deg,var(--panel),rgba(255,255,255,0.01));padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  .viz{height:360px;margin-top:14px;display:flex;align-items:flex-end;gap:4px;padding:10px;overflow:hidden;border-radius:8px;background:linear-gradient(180deg,#071023 0,#071a28 100%);border:1px solid rgba(255,255,255,0.02)}
  .bar{flex:1 1 auto;display:flex;align-items:flex-end;justify-content:center;background:linear-gradient(180deg,var(--bar),#2b6cb0);border-radius:4px 4px 4px 4px;transition:height 200ms linear, background-color 120ms linear, transform 120ms ease;min-width:4px;position:relative}
  .bar.small{min-width:2px}
  .bar .val{position:absolute;top:-18px;font-size:11px;color:#e6eef8;opacity:0.9}
  .bar.compare{background:linear-gradient(180deg,var(--compare),#7c3aed);transform:scaleX(1.02)}
  .bar.write{background:linear-gradient(180deg,var(--write),#d97706);transform:scaleX(1.02)}
  .bar.range{outline:3px solid rgba(96,165,250,0.08);box-shadow:inset 0 0 30px rgba(2,6,23,0.6)}
  .bar.sorted{background:linear-gradient(180deg,var(--sorted),#0ea5e9)}
  .info{display:flex;gap:12px;margin-top:12px;align-items:flex-start}
  .side{flex:0 0 360px}
  pre{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;background:linear-gradient(180deg,#04101a,#071429);padding:10px;border-radius:8px;color:#cbd5e1;max-height:320px;overflow:auto;margin:0;font-size:13px;border:1px solid rgba(255,255,255,0.02)}
  .legend{display:flex;gap:8px;flex-wrap:wrap;font-size:13px;margin-top:8px}
  .legend .item{display:flex;gap:6px;align-items:center}
  .swatch{width:18px;height:12px;border-radius:3px}
  .swatch.range{background:linear-gradient(180deg,rgba(96,165,250,0.06),transparent);border:1px solid rgba(96,165,250,0.06)}
  .log{max-height:120px;overflow:auto;font-size:13px;padding:8px;border-radius:6px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
  .status{font-size:13px;color:var(--muted)}
  footer{margin-top:12px;color:var(--muted);font-size:13px}
  @media (max-width:880px){
    .info{flex-direction:column}
    .side{flex:1}
    .controls label{width:100%}
    .slider{width:140px}
    .viz{height:280px}
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Merge Sort Visualizer</h1>
      <div class="status panel" id="status">Ready — generate an array to begin.</div>
    </header>

    <div class="controls">
      <div class="panel" style="display:flex;gap:8px;align-items:center;">
        <button id="startBtn" class="btn">Start</button>
        <button id="pauseBtn" class="btn secondary">Pause</button>
        <button id="stepBtn" class="btn secondary">Step</button>
        <button id="resetBtn" class="btn secondary">Reset</button>
      </div>

      <div class="panel" style="display:flex;gap:8px;align-items:center;">
        <label>Size
          <input id="size" type="range" min="6" max="90" value="32" class="slider">
        </label>
        <span id="sizeVal" style="min-width:30px;text-align:center;color:var(--muted)">32</span>
      </div>

      <div class="panel" style="display:flex;gap:8px;align-items:center;">
        <label>Speed
          <input id="speed" type="range" min="10" max="1000" value="180" class="slider">
        </label>
        <span id="speedVal" style="min-width:40px;text-align:center;color:var(--muted)">180 ms</span>
      </div>

      <div class="panel" style="display:flex;gap:8px;align-items:center;">
        <button id="randomizeBtn" class="btn secondary">Randomize</button>
        <label style="margin-left:6px"><input id="order" type="checkbox"> Descending</label>
      </div>
    </div>

    <div class="panel">
      <div class="viz" id="viz"></div>
      <div class="info">
        <div class="side">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <strong style="color:#e6eef8">Pseudocode (Merge Sort)</strong>
            <small style="color:var(--muted)">Lines highlight during action</small>
          </div>
          <pre id="pseudocode">
// MergeSort(A, l, r)
// if r - l <= 1: return
// m = (l + r) / 2
// MergeSort(A, l, m)
// MergeSort(A, m, r)
// merge two sorted halves:
// i = l, j = m, k = l
// while i < m and j < r:
//   if A[i] <= A[j]:
//     B[k++] = A[i++]
//   else:
//     B[k++] = A[j++]
// copy remaining elements
// copy B back into A
          </pre>
        </div>

        <div style="flex:1;">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <strong style="color:#e6eef8">Legend & Log</strong>
            <div class="legend">
              <div class="item"><div class="swatch compare" style="background:linear-gradient(180deg,var(--compare),#7c3aed)"></div><span style="color:var(--muted)">Comparing</span></div>
              <div class="item"><div class="swatch write" style="background:linear-gradient(180deg,var(--write),#d97706)"></div><span style="color:var(--muted)">Write</span></div>
              <div class="item"><div class="swatch range"></div><span style="color:var(--muted)">Current merge range</span></div>
              <div class="item"><div class="swatch" style="background:linear-gradient(180deg,var(--sorted),#0ea5e9)"></div><span style="color:var(--muted)">Sorted segment</span></div>
            </div>
          </div>

          <div class="log panel" id="log"></div>
        </div>
      </div>
    </div>

    <footer>
      Tip: Use "Step" to proceed one recorded animation at a time. Pause stops automatic playback.
    </footer>
  </div>

<script>
// Merge Sort Visualizer
// Single-file demo. No external libs.

(function(){
  // DOM
  const viz = document.getElementById('viz');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const stepBtn = document.getElementById('stepBtn');
  const resetBtn = document.getElementById('resetBtn');
  const randomizeBtn = document.getElementById('randomizeBtn');
  const sizeInput = document.getElementById('size');
  const sizeVal = document.getElementById('sizeVal');
  const speedInput = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const orderCheckbox = document.getElementById('order');
  const log = document.getElementById('log');
  const status = document.getElementById('status');

  let array = [];
  let bars = [];
  let actions = [];
  let actionIndex = 0;
  let isPlaying = false;
  let isPaused = false;
  let isStarted = false;
  let comparatorDescending = false;

  // Initialize
  const defaultSize = +sizeInput.value;
  sizeVal.textContent = defaultSize;
  speedVal.textContent = speedInput.value + ' ms';
  comparatorDescending = orderCheckbox.checked;

  function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

  function generateArray(n){
    array = new Array(n).fill(0).map((_,i) => randInt(5, 400));
    // optionally shuffle to avoid sorted
    for(let i=array.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [array[i],array[j]]=[array[j],array[i]];
    }
    renderArray();
    logMessage(`Generated array of ${n} elements.`);
    status.textContent = 'Array generated. Click Start to record merges and animate.';
    isStarted = false;
    actions = [];
    actionIndex = 0;
    updateButtons();
  }

  function renderArray(){
    viz.innerHTML = '';
    bars = [];
    const n = array.length;
    // determine width: let each bar flex and min-width small; set class small if many
    const small = n > 70;
    for(let i=0;i<n;i++){
      const b = document.createElement('div');
      b.className = 'bar' + (small ? ' small' : '');
      b.style.height = `${array[i]}px`;
      b.dataset.index = i;
      const val = document.createElement('div');
      val.className = 'val';
      val.textContent = array[i];
      b.appendChild(val);
      viz.appendChild(b);
      bars.push(b);
    }
  }

  function logMessage(s){
    const time = new Date().toLocaleTimeString();
    log.innerHTML = `<div style="color:var(--muted);font-size:12px">[${time}]</div>` + `<div>${s}</div>` + log.innerHTML;
  }

  // Recording actions during merge sort (non-visual), to be animated later.
  // Action types: range {l,m,r}, compare {a,b}, write {index,value}, done
  function recordMergeSort(arr){
    actions = [];
    function cmp(a,b){
      return comparatorDescending ? b - a : a - b;
    }
    function mergeSortRec(a,l,r){
      if(r - l <= 1) return;
      const m = Math.floor((l + r) / 2);
      mergeSortRec(a,l,m);
      mergeSortRec(a,m,r);
      // record range
      actions.push({type:'range', l, m, r});
      let left = a.slice(l,m);
      let right = a.slice(m,r);
      let i=0,j=0,k=l;
      while(i < left.length && j < right.length){
        // compare indices (original positions before overwrite)
        const idxL = l + i;
        const idxR = m + j;
        actions.push({type:'compare', a: idxL, b: idxR});
        if(cmp(left[i], right[j]) <= 0){
          actions.push({type:'write', index:k, value:left[i]});
          a[k++] = left[i++];
        } else {
          actions.push({type:'write', index:k, value:right[j]});
          a[k++] = right[j++];
        }
      }
      while(i < left.length){
        actions.push({type:'write', index:k, value:left[i]});
        a[k++] = left[i++];
      }
      while(j < right.length){
        actions.push({type:'write', index:k, value:right[j]});
        a[k++] = right[j++];
      }
      // optional: mark this segment as sorted (for visualization we'll treat completed when all writes done)
    }
    const copy = arr.slice();
    mergeSortRec(copy, 0, copy.length);
    actions.push({type:'done'});
    return actions;
  }

  // Visualization step: apply one action
  function applyAction(act){
    // clear temporary highlights except range/stays
    // We'll not clear the range here; range acts to set a "current" merge highlight which remains until next range.
    if(!act) return;
    if(act.type === 'range'){
      // clear all range styles first
      bars.forEach(b => b.classList.remove('range'));
      const {l,m,r} = act;
      for(let i=l;i<r;i++){
        if(bars[i]) bars[i].classList.add('range');
      }
      logMessage(`Merging range [${l}, ${r}) (mid=${m}).`);
      highlightPseudo('range');
    } else if(act.type === 'compare'){
      const a = act.a, b = act.b;
      if(bars[a]) bars[a].classList.add('compare');
      if(bars[b]) bars[b].classList.add('compare');
      highlightPseudo('compare');
      // clear compare highlights after a short time (we keep them until next action processing or after write)
      setTimeout(()=>{
        if(bars[a]) bars[a].classList.remove('compare');
        if(bars[b]) bars[b].classList.remove('compare');
      }, Math.max(60, getDelay()/2));
      logMessage(`Compare positions ${a} and ${b}.`);
    } else if(act.type === 'write'){
      const idx = act.index;
      const val = act.value;
      // animate write: change height & value text & temporary class
      if(bars[idx]){
        bars[idx].classList.add('write');
        bars[idx].style.height = `${val}px`;
        const v = bars[idx].querySelector('.val');
        if(v) v.textContent = val;
        // remove write after short time
        setTimeout(()=>{ if(bars[idx]) bars[idx].classList.remove('write'); }, Math.max(80, getDelay()/2));
      }
      // reflect in array so subsequent operations see updated heights
      array[idx] = val;
      highlightPseudo('write');
      logMessage(`Write ${val} at index ${idx}.`);
    } else if(act.type === 'done'){
      // mark everything sorted
      bars.forEach(b => b.classList.add('sorted'));
      bars.forEach(b => b.classList.remove('range'));
      logMessage('Merge sort complete.');
      highlightPseudo('done');
    }
  }

  // Pseudocode highlighting: simple mapping
  const pseudoEl = document.getElementById('pseudocode');
  const pseudoLines = pseudoEl.textContent.split('\n');
  function highlightPseudo(kind){
    // We'll create styled lines by reconstructing with simple highlights matching action type.
    const map = {
      'range': 4,      // "merge two sorted halves:"
      'compare': 9,    // "if A[i] <= A[j]:"
      'write': 10,     // "B[k++] = A[i++]" or "B[k++] = A[j++]"
      'done': 0
    };
    const lineToHighlight = map[kind] || 0;
    const newHtml = pseudoLines.map((ln,i)=>{
      const index = i;
      const escaped = ln.replace(/</g,'&lt;').replace(/>/g,'&gt;');
      if(i === lineToHighlight) return `<span style="background:linear-gradient(90deg, rgba(96,165,250,0.08), rgba(96,165,250,0.02));display:block;padding:2px 4px;border-radius:4px">${escaped}</span>`;
      return escaped;
    }).join('\n');
    pseudoEl.innerHTML = newHtml;
  }

  // Playback controls
  function getDelay(){ return Math.max(10, +speedInput.value); }

  function updateButtons(){
    if(isPlaying){
      startBtn.disabled = true;
      pauseBtn.textContent = 'Pause';
      pauseBtn.classList.remove('secondary');
      pauseBtn.classList.add('btn');
    } else {
      startBtn.disabled = false;
      pauseBtn.textContent = 'Pause';
      pauseBtn.classList.remove('btn');
      pauseBtn.classList.add('secondary');
    }
  }

  function processNextAction(){
    if(actionIndex >= actions.length) return false;
    const act = actions[actionIndex++];
    applyAction(act);
    // when write occurs inside range and whole range completed, we don't specially mark, we rely on done action at end or eventual next range
    return true;
  }

  async function play(){
    if(actions.length === 0){
      logMessage('No recorded actions. Click Start first.');
      return;
    }
    if(actionIndex >= actions.length){
      logMessage('Already finished. Reset to run again.');
      return;
    }
    isPlaying = true;
    isPaused = false;
    updateButtons();
    status.textContent = 'Playing...';
    while(isPlaying && actionIndex < actions.length){
      processNextAction();
      await new Promise(res => setTimeout(res, getDelay()));
    }
    isPlaying = false;
    updateButtons();
    if(actionIndex >= actions.length){
      status.textContent = 'Finished.';
      isStarted = false;
    } else {
      status.textContent = 'Paused.';
    }
  }

  // Button handlers
  startBtn.addEventListener('click', ()=>{
    if(isPlaying) return;
    // if not recorded, record now
    comparatorDescending = orderCheckbox.checked;
    actions = recordMergeSort(array.slice());
    actionIndex = 0;
    // clear previous visual markers
    bars.forEach(b => b.classList.remove('sorted','range','compare','write'));
    // start playing
    isStarted = true;
    play();
  });

  pauseBtn.addEventListener('click', ()=>{
    if(isPlaying){
      // pause
      isPlaying = false;
      isPaused = true;
      updateButtons();
      status.textContent = 'Paused.';
      logMessage('Playback paused.');
    } else {
      // resume (if there are remaining actions)
      if(actionIndex >= actions.length){
        logMessage('Nothing to resume; animation already finished.');
        return;
      }
      play();
    }
  });

  stepBtn.addEventListener('click', ()=>{
    if(actions.length === 0){
      // record one time so step can show the first action
      comparatorDescending = orderCheckbox.checked;
      actions = recordMergeSort(array.slice());
      actionIndex = 0;
      bars.forEach(b => b.classList.remove('sorted','range','compare','write'));
    }
    if(isPlaying){
      // if playing, step isn't allowed
      logMessage('Cannot step while playing — pause first.');
      return;
    }
    if(actionIndex >= actions.length){
      logMessage('Finished. Reset to run again.');
      return;
    }
    processNextAction();
    if(actionIndex >= actions.length){
      status.textContent = 'Finished.';
      isStarted = false;
    } else {
      status.textContent = 'Paused.';
    }
  });

  resetBtn.addEventListener('click', ()=>{
    isPlaying = false;
    isPaused = false;
    actions = [];
    actionIndex = 0;
    // regenerate visual from current array values (no recording)
    renderArray();
    logMessage('Reset visualization to current array.');
    status.textContent = 'Reset.';
    updateButtons();
  });

  randomizeBtn.addEventListener('click', ()=>{
    generateArray(+sizeInput.value);
  });

  sizeInput.addEventListener('input', (e)=>{
    sizeVal.textContent = e.target.value;
  });

  speedInput.addEventListener('input', (e)=>{
    speedVal.textContent = e.target.value + ' ms';
  });

  orderCheckbox.addEventListener('change', (e)=>{
    comparatorDescending = e.target.checked;
  });

  // keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key === ' '){ e.preventDefault(); pauseBtn.click(); }
    if(e.key === 'Enter'){ startBtn.click(); }
    if(e.key === 'ArrowRight'){ stepBtn.click(); }
  });

  // initial generate
  generateArray(defaultSize);

  // Small note: resizing window should keep bars responsive. We'll re-render heights when container width changes (not necessary).
})();
</script>
</body>
</html>