{
  "meta": {
    "concept": "PriorityQueue",
    "topic": "Priority Queue — Binary Heap Visualization",
    "educational_goal": "Demonstrate enqueue, dequeue, peek, priority change and visual heap reordering with optional stability and animations",
    "expected_interactions": [
      "ENQUEUE",
      "ENQUEUE_RANDOM",
      "DEQUEUE",
      "PEEK",
      "DEQUEUE_ALL",
      "CHANGE_PRIORITY",
      "CLEAR",
      "TOGGLE_SETTINGS",
      "ARRAY_NODE_CLICK"
    ]
  },
  "states": [
    {
      "id": "S0_Idle",
      "label": "idle",
      "type": "idle",
      "entry_actions": [
        "renderTree(pq ? pq.heap : [])",
        "renderArrayView(pq ? pq.heap : [])",
        "updateMeta()",
        "enableControls()"
      ],
      "exit_actions": []
    },
    {
      "id": "S1_Enqueueing",
      "label": "enqueueing",
      "type": "atomic",
      "entry_actions": [
        "readInputValues(#itemValue,#itemPriority,#queueType)",
        "logEnqueue()",
        "pq.enqueue(value,priority) // async",
        "set animInProgress = true"
      ],
      "exit_actions": [
        "renderArrayView(pq.heap)",
        "renderTree(pq.heap)",
        "updateMeta()",
        "set animInProgress = false"
      ]
    },
    {
      "id": "S2_EnqueueRandom",
      "label": "enqueue_random",
      "type": "atomic",
      "entry_actions": [
        "computeRandomCount()",
        "loop: pq.enqueue(randomVal, randomPriority) // async",
        "log each enqueue",
        "set animInProgress = true"
      ],
      "exit_actions": [
        "renderArrayView(pq.heap)",
        "renderTree(pq.heap)",
        "updateMeta()",
        "set animInProgress = false"
      ]
    },
    {
      "id": "S3_Dequeueing",
      "label": "dequeueing",
      "type": "atomic",
      "entry_actions": [
        "assert pq not empty",
        "logDequeue(peek())",
        "pq.dequeue() // async",
        "set animInProgress = true"
      ],
      "exit_actions": [
        "pushToExtracted(popped)",
        "renderExtracted()",
        "renderArrayView(pq.heap)",
        "renderTree(pq.heap)",
        "updateMeta()",
        "set animInProgress = false"
      ]
    },
    {
      "id": "S4_DequeueAll",
      "label": "dequeue_all",
      "type": "compound",
      "entry_actions": [
        "log('Dequeue All')",
        "set animInProgress = true",
        "loop while pq not empty: await pq.dequeue() and collect extracted"
      ],
      "exit_actions": [
        "renderArrayView(pq.heap)",
        "renderTree(pq.heap)",
        "updateMeta()",
        "set animInProgress = false"
      ]
    },
    {
      "id": "S5_Peek",
      "label": "peek",
      "type": "atomic",
      "entry_actions": [
        "read pq.peek()",
        "logPeek()"
      ],
      "exit_actions": []
    },
    {
      "id": "S6_Clear",
      "label": "clear",
      "type": "atomic",
      "entry_actions": [
        "pq.clear()",
        "extracted = []",
        "renderArrayView([])",
        "renderTree([])",
        "updateMeta()",
        "log('Cleared queue.')"
      ],
      "exit_actions": []
    },
    {
      "id": "S7_ChangePriority",
      "label": "change_priority",
      "type": "atomic",
      "entry_actions": [
        "readInputs(#changeId,#changePr)",
        "validateChangeInputs()",
        "pq.changePriorityById(id,newPr) // async",
        "set animInProgress = true"
      ],
      "exit_actions": [
        "log change result",
        "renderArrayView(pq.heap)",
        "renderTree(pq.heap)",
        "updateMeta()",
        "set animInProgress = false"
      ]
    },
    {
      "id": "S8_ErrorAlert",
      "label": "error_alert",
      "type": "atomic",
      "entry_actions": [
        "showAlert(message) // native alert() called in code",
        "log('alert shown')"
      ],
      "exit_actions": [
        "clearAlertState()"
      ]
    },
    {
      "id": "S9_RecreateSettings",
      "label": "recreate_with_settings",
      "type": "atomic",
      "entry_actions": [
        "preserve = pq.heap.slice()",
        "createPQ()",
        "reinsert preserved items via pq.enqueue(...) // async loop",
        "set animInProgress = true"
      ],
      "exit_actions": [
        "set animInProgress = false",
        "renderArrayView(pq.heap)",
        "renderTree(pq.heap)",
        "updateMeta()"
      ]
    },
    {
      "id": "S10_Swapping",
      "label": "swapping",
      "type": "atomic",
      "entry_actions": [
        "onUpdate swap event -> renderTree(heap, indices)",
        "apply .highlight on swapped nodes",
        "optional wait for animationDelay"
      ],
      "exit_actions": [
        "remove .highlight",
        "renderTree(pq.heap)"
      ]
    },
    {
      "id": "S11_CreatingPQ",
      "label": "creating_pq",
      "type": "atomic",
      "entry_actions": [
        "createPQ()",
        "render initial seeded heap if any"
      ],
      "exit_actions": []
    },
    {
      "id": "S12_PrefillId",
      "label": "prefill_id",
      "type": "atomic",
      "entry_actions": [
        "arrayView .nodeBox clicked -> extract id from .id text",
        "set #changeId.value = extractedId"
      ],
      "exit_actions": []
    }
  ],
  "events": [
    {
      "id": "ENQUEUE_CLICK",
      "event_type": "user_action",
      "description": "User clicks Enqueue button or presses Enter in item inputs"
    },
    {
      "id": "ENQUEUE_RANDOM_CLICK",
      "event_type": "user_action",
      "description": "User clicks Enqueue Random button"
    },
    {
      "id": "DEQUEUE_CLICK",
      "event_type": "user_action",
      "description": "User clicks Dequeue button"
    },
    {
      "id": "PEEK_CLICK",
      "event_type": "user_action",
      "description": "User clicks Peek button"
    },
    {
      "id": "DEQUEUE_ALL_CLICK",
      "event_type": "user_action",
      "description": "User clicks Dequeue All button"
    },
    {
      "id": "CLEAR_CLICK",
      "event_type": "user_action",
      "description": "User clicks Clear button"
    },
    {
      "id": "CHANGE_CLICK",
      "event_type": "user_action",
      "description": "User clicks Change priority button"
    },
    {
      "id": "ARRAY_VIEW_NODE_CLICK",
      "event_type": "user_action",
      "description": "User clicks a node box in the array view to prefill change id"
    },
    {
      "id": "KEY_ENTER",
      "event_type": "user_action",
      "description": "User presses Enter in itemValue or itemPriority to trigger enqueue"
    },
    {
      "id": "SETTINGS_CHANGE",
      "event_type": "user_action",
      "description": "User changes queue type or stable checkbox"
    },
    {
      "id": "ANIM_TOGGLE",
      "event_type": "user_action",
      "description": "User toggles animation checkbox"
    },
    {
      "id": "SPEED_CHANGE",
      "event_type": "user_action",
      "description": "User changes animation speed range"
    },
    {
      "id": "ENQUEUE_COMPLETE",
      "event_type": "system_event",
      "description": "PQ.enqueue finished (including internal swaps/animations)"
    },
    {
      "id": "DEQUEUE_COMPLETE",
      "event_type": "system_event",
      "description": "PQ.dequeue finished (including internal swaps/animations)"
    },
    {
      "id": "DEQUEUE_ALL_COMPLETE",
      "event_type": "system_event",
      "description": "Dequeue all loop finished (queue empty)"
    },
    {
      "id": "CHANGE_COMPLETE",
      "event_type": "system_event",
      "description": "changePriorityById finished"
    },
    {
      "id": "SWAP_EVENT",
      "event_type": "system_event",
      "description": "PQ internal swap occurred (onUpdate with type:'swap')"
    },
    {
      "id": "UPDATE_EVENT",
      "event_type": "system_event",
      "description": "onUpdate generic update event (type:'update','pop','push','replaceRoot',etc.)"
    },
    {
      "id": "ALERT_SHOWN",
      "event_type": "system_event",
      "description": "Native alert() shown due to invalid inputs"
    },
    {
      "id": "ALERT_DISMISSED",
      "event_type": "user_action",
      "description": "User dismisses native alert() (browser modal resolved)"
    },
    {
      "id": "CREATE_PQ",
      "event_type": "system_event",
      "description": "createPQ() called to instantiate or recreate the PQ"
    },
    {
      "id": "RECREATE_COMPLETE",
      "event_type": "system_event",
      "description": "Recreated PQ and reinserted preserved items"
    }
  ],
  "transitions": [
    {
      "from": "S0_Idle",
      "to": "S11_CreatingPQ",
      "event": "CREATE_PQ",
      "guard": "pq == null || forceCreate",
      "actions": [
        "createPQ()",
        "renderArrayView([])",
        "renderTree([])",
        "updateMeta()"
      ],
      "triggers": "#queueType, #stableChk, #clearBtn",
      "expected_observables": [
        "dom:createPQ_called",
        "dom:#meta updated"
      ],
      "timeout": 2000
    },
    {
      "from": "S0_Idle",
      "to": "S1_Enqueueing",
      "event": "ENQUEUE_CLICK",
      "guard": "animInProgress === false",
      "actions": [
        "readInputValues(#itemValue,#itemPriority)",
        "log(`Enqueue \"${value}\" (prio ${priority})`)",
        "pq.enqueue(value,priority) // async",
        "set animInProgress = true"
      ],
      "triggers": "#enqueueBtn, #itemValue, #itemPriority",
      "expected_observables": [
        "dom:#enqueueBtn:click",
        "dom:#itemValue:keydown(Enter)",
        "dom:logArea prepended"
      ],
      "timeout": 5000
    },
    {
      "from": "S1_Enqueueing",
      "to": "S10_Swapping",
      "event": "SWAP_EVENT",
      "guard": "true",
      "actions": [
        "renderTree(evt.heap, evt.indices)",
        "statusLine.textContent = `Swapped indices ${evt.indices[0]} ↔ ${evt.indices[1]}`"
      ],
      "triggers": "dom:onUpdate(type:'swap')",
      "expected_observables": [
        "dom:heapSvg .highlight",
        "dom:arrayView updated"
      ],
      "timeout": 2000
    },
    {
      "from": "S10_Swapping",
      "to": "S1_Enqueueing",
      "event": "UPDATE_EVENT",
      "guard": "evt.type === 'update' || animationDelay elapsed",
      "actions": [
        "remove highlight",
        "renderTree(evt.heap)"
      ],
      "triggers": "dom:onUpdate(type:'update')",
      "expected_observables": [
        "dom:visualizationComplete",
        "dom:heapSvg rendered"
      ],
      "timeout": 3000
    },
    {
      "from": "S1_Enqueueing",
      "to": "S0_Idle",
      "event": "ENQUEUE_COMPLETE",
      "guard": "true",
      "actions": [
        "renderArrayView(pq.heap)",
        "renderTree(pq.heap)",
        "updateMeta()",
        "set animInProgress = false"
      ],
      "triggers": "dom:onUpdate(type:'update'), dom:heapSvg",
      "expected_observables": [
        "dom:arrayView changed",
        "dom:heapSvg changed"
      ],
      "timeout": 5000
    },
    {
      "from": "S0_Idle",
      "to": "S2_EnqueueRandom",
      "event": "ENQUEUE_RANDOM_CLICK",
      "guard": "animInProgress === false",
      "actions": [
        "compute random count",
        "loop enqueue random items via pq.enqueue(...)",
        "set animInProgress = true"
      ],
      "triggers": "#enqueueRand",
      "expected_observables": [
        "dom:#enqueueRand:click",
        "dom:logArea entries for each enqueue"
      ],
      "timeout": 15000
    },
    {
      "from": "S2_EnqueueRandom",
      "to": "S0_Idle",
      "event": "ENQUEUE_COMPLETE",
      "guard": "after last random enqueue",
      "actions": [
        "renderArrayView(pq.heap)",
        "renderTree(pq.heap)",
        "updateMeta()",
        "set animInProgress = false"
      ],
      "triggers": "dom:onUpdate(type:'update')",
      "expected_observables": [
        "dom:arrayView updated",
        "dom:heapSvg updated"
      ],
      "timeout": 20000
    },
    {
      "from": "S0_Idle",
      "to": "S3_Dequeueing",
      "event": "DEQUEUE_CLICK",
      "guard": "pq && !pq.isEmpty() && animInProgress === false",
      "actions": [
        "logDequeue(peek())",
        "await pq.dequeue()",
        "set animInProgress = true"
      ],
      "triggers": "#dequeueBtn",
      "expected_observables": [
        "dom:#dequeueBtn:click",
        "dom:logArea prepended"
      ],
      "timeout": 10000
    },
    {
      "from": "S3_Dequeueing",
      "to": "S10_Swapping",
      "event": "SWAP_EVENT",
      "guard": "true",
      "actions": [
        "renderTree(evt.heap, evt.indices)",
        "statusLine.textContent = `Swapped indices ${evt.indices[0]} ↔ ${evt.indices[1]}`"
      ],
      "triggers": "dom:onUpdate(type:'swap')",
      "expected_observables": [
        "dom:heapSvg .highlight"
      ],
      "timeout": 3000
    },
    {
      "from": "S3_Dequeueing",
      "to": "S0_Idle",
      "event": "DEQUEUE_COMPLETE",
      "guard": "true",
      "actions": [
        "extracted.unshift(popped summary)",
        "renderExtracted()",
        "renderArrayView(pq.heap)",
        "renderTree(pq.heap)",
        "updateMeta()",
        "set animInProgress = false"
      ],
      "triggers": "dom:onUpdate(type:'update'), dom:#extracted changed",
      "expected_observables": [
        "dom:extracted updated",
        "dom:arrayView updated"
      ],
      "timeout": 10000
    },
    {
      "from": "S0_Idle",
      "to": "S4_DequeueAll",
      "event": "DEQUEUE_ALL_CLICK",
      "guard": "pq && !pq.isEmpty() && animInProgress === false",
      "actions": [
        "log('Dequeue All (extracting until empty)')",
        "set animInProgress = true",
        "loop await pq.dequeue() until empty"
      ],
      "triggers": "#dequeueAll",
      "expected_observables": [
        "dom:#dequeueAll:click",
        "dom:logArea entries"
      ],
      "timeout": 60000
    },
    {
      "from": "S4_DequeueAll",
      "to": "S0_Idle",
      "event": "DEQUEUE_ALL_COMPLETE",
      "guard": "pq.isEmpty()",
      "actions": [
        "renderArrayView([])",
        "renderTree([])",
        "renderExtracted()",
        "updateMeta()",
        "set animInProgress = false"
      ],
      "triggers": "dom:onUpdate until pq.isEmpty",
      "expected_observables": [
        "dom:arrayView shows (empty)",
        "dom:heapSvg shows (empty)"
      ],
      "timeout": 60000
    },
    {
      "from": "S0_Idle",
      "to": "S5_Peek",
      "event": "PEEK_CLICK",
      "guard": "true",
      "actions": [
        "const p = pq ? pq.peek() : null",
        "log peek message or 'empty'"
      ],
      "triggers": "#peekBtn",
      "expected_observables": [
        "dom:#peekBtn:click",
        "dom:logArea prepended"
      ],
      "timeout": 2000
    },
    {
      "from": "S5_Peek",
      "to": "S0_Idle",
      "event": "UPDATE_EVENT",
      "guard": "true",
      "actions": [],
      "triggers": "dom:logArea updated",
      "expected_observables": [
        "dom:logArea has entry"
      ],
      "timeout": 1000
    },
    {
      "from": "S0_Idle",
      "to": "S6_Clear",
      "event": "CLEAR_CLICK",
      "guard": "animInProgress === false",
      "actions": [
        "pq.clear()",
        "extracted = []",
        "renderArrayView([])",
        "renderTree([])",
        "updateMeta()",
        "log('Cleared queue.')"
      ],
      "triggers": "#clearBtn",
      "expected_observables": [
        "dom:#clearBtn:click",
        "dom:arrayView shows (empty)"
      ],
      "timeout": 2000
    },
    {
      "from": "S0_Idle",
      "to": "S7_ChangePriority",
      "event": "CHANGE_CLICK",
      "guard": "changeId.value.trim() !== '' && changePr.value !== '' && animInProgress === false",
      "actions": [
        "read id and newPr from #changeId,#changePr",
        "log attempt",
        "pq.changePriorityById(id,newPr) // async",
        "set animInProgress = true"
      ],
      "triggers": "#changeBtn",
      "expected_observables": [
        "dom:#changeBtn:click",
        "dom:logArea entry"
      ],
      "timeout": 10000
    },
    {
      "from": "S0_Idle",
      "to": "S8_ErrorAlert",
      "event": "ALERT_SHOWN",
      "guard": "changeId empty or changePr empty",
      "actions": [
        "alert('Enter id to change' or 'Enter new priority')",
        "log alert"
      ],
      "triggers": "#changeBtn",
      "expected_observables": [
        "dom:alert modal shown"
      ],
      "timeout": 1000
    },
    {
      "from": "S8_ErrorAlert",
      "to": "S0_Idle",
      "event": "ALERT_DISMISSED",
      "guard": "true",
      "actions": [
        "clear error UI if any",
        "focus #changeId or #changePr appropriately"
      ],
      "triggers": "browser alert dismissal",
      "expected_observables": [
        "dom:alert closed"
      ],
      "timeout": 500
    },
    {
      "from": "S7_ChangePriority",
      "to": "S0_Idle",
      "event": "CHANGE_COMPLETE",
      "guard": "ok || not ok",
      "actions": [
        "if ok log success else log not found",
        "renderArrayView(pq.heap)",
        "renderTree(pq.heap)",
        "updateMeta()",
        "set animInProgress = false"
      ],
      "triggers": "dom:onUpdate(type:'update' or 'change')",
      "expected_observables": [
        "dom:arrayView changed",
        "dom:logArea entry"
      ],
      "timeout": 10000
    },
    {
      "from": "S0_Idle",
      "to": "S12_PrefillId",
      "event": "ARRAY_VIEW_NODE_CLICK",
      "guard": "clicked element matches .nodeBox",
      "actions": [
        "const id = clickedBox.querySelector('.id').textContent.match(/id:(\\d+)/)[1]",
        "set #changeId.value = id"
      ],
      "triggers": "#arrayView .nodeBox, .nodeBox .id",
      "expected_observables": [
        "dom:nodeBox clicked",
        "dom:#changeId.value set"
      ],
      "timeout": 500
    },
    {
      "from": "S12_PrefillId",
      "to": "S0_Idle",
      "event": "UPDATE_EVENT",
      "guard": "true",
      "actions": [],
      "triggers": "dom:#changeId updated",
      "expected_observables": [
        "dom:#changeId.value changed"
      ],
      "timeout": 200
    },
    {
      "from": "S0_Idle",
      "to": "S9_RecreateSettings",
      "event": "SETTINGS_CHANGE",
      "guard": "true",
      "actions": [
        "preserve pq.heap",
        "createPQ() with new settings",
        "reinsert preserved items via pq.enqueue(...) // async",
        "set animInProgress = true"
      ],
      "triggers": "#queueType, #stableChk",
      "expected_observables": [
        "dom:#queueType:change",
        "dom:#stableChk:change"
      ],
      "timeout": 20000
    },
    {
      "from": "S9_RecreateSettings",
      "to": "S0_Idle",
      "event": "RECREATE_COMPLETE",
      "guard": "true",
      "actions": [
        "set animInProgress = false",
        "renderArrayView(pq.heap)",
        "renderTree(pq.heap)",
        "updateMeta()"
      ],
      "triggers": "dom:onUpdate cycles for reinserted items",
      "expected_observables": [
        "dom:arrayView updated",
        "dom:logArea entry"
      ],
      "timeout": 20000
    },
    {
      "from": "S1_Enqueueing",
      "to": "S10_Swapping",
      "event": "SWAP_EVENT",
      "guard": "evt.indices",
      "actions": [
        "renderTree(evt.heap, evt.indices)",
        "statusLine.textContent = `Swapped indices ${evt.indices[0]} ↔ ${evt.indices[1]}`"
      ],
      "triggers": "dom:onUpdate(type:'swap')",
      "expected_observables": [
        "dom:heapSvg contains .highlight",
        "dom:arrayView updated"
      ],
      "timeout": 3000
    },
    {
      "from": "S3_Dequeueing",
      "to": "S10_Swapping",
      "event": "SWAP_EVENT",
      "guard": "evt.indices",
      "actions": [
        "renderTree(evt.heap, evt.indices)",
        "statusLine.textContent = `Swapped indices ${evt.indices[0]} ↔ ${evt.indices[1]}`"
      ],
      "triggers": "dom:onUpdate(type:'swap')",
      "expected_observables": [
        "dom:heapSvg contains .highlight"
      ],
      "timeout": 3000
    }
  ],
  "components": [
    "#enqueueBtn",
    "#enqueueRand",
    "#dequeueBtn",
    "#peekBtn",
    "#dequeueAll",
    "#clearBtn",
    "#changeBtn",
    "#itemValue",
    "#itemPriority",
    "#queueType",
    "#stableChk",
    "#animChk",
    "#speedRange",
    "#changeId",
    "#changePr",
    "#arrayView",
    "#heapSvg",
    "#logArea",
    "#extracted",
    "#meta",
    "#statusLine",
    ".nodeBox",
    ".nodeCircle",
    ".nodeText",
    ".nodeSub",
    ".id",
    ".muted",
    ".chip",
    ".small",
    ".alt",
    ".ghost",
    ".danger",
    ".arrayView"
  ]
}