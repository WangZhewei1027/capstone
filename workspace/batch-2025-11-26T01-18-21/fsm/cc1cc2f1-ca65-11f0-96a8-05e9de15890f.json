{
  "meta": {
    "concept": "HashTable",
    "topic": "Hash Table Interactive Demo",
    "educational_goal": "Demonstrate separate-chaining hash table operations (insert/update, lookup, remove), collision behavior and auto-resize/rehash",
    "expected_interactions": [
      "insert",
      "update",
      "get",
      "contains",
      "remove",
      "insert_random",
      "fill",
      "clear",
      "change_capacity",
      "change_threshold",
      "change_hash_function"
    ]
  },
  "states": [
    {
      "id": "S0_IDLE",
      "label": "idle",
      "type": "idle",
      "entry_actions": [
        "render()",
        "updateStatsDisplay()",
        "enableControls()"
      ],
      "exit_actions": []
    },
    {
      "id": "S1_READING_INPUT",
      "label": "reading_input",
      "type": "atomic",
      "entry_actions": [
        "read keyInput.value",
        "read valueInput.value",
        "trimKey()"
      ],
      "exit_actions": []
    },
    {
      "id": "S2_INSERTING_NEW",
      "label": "inserting_new",
      "type": "atomic",
      "entry_actions": [
        "computeHash()",
        "indexForHash()",
        "appendToBucket()",
        "entries++",
        "maybeIncrementCollisions()",
        "render({bucket: idx})"
      ],
      "exit_actions": [
        "render({bucket: idx, found:true, at:pos})"
      ]
    },
    {
      "id": "S3_UPDATING_EXISTING",
      "label": "updating_existing",
      "type": "atomic",
      "entry_actions": [
        "render({bucket: idx, visiting:true, at:existingIndex})",
        "replaceBucketValue()"
      ],
      "exit_actions": [
        "render({bucket: idx, found:true, at:existingIndex})",
        "notifyUpdated()"
      ]
    },
    {
      "id": "S4_TRAVERSING_SEARCH",
      "label": "traversing_search",
      "type": "atomic",
      "entry_actions": [
        "render({bucket: idx})",
        "iterateBucketWithDelays()"
      ],
      "exit_actions": []
    },
    {
      "id": "S5_FOUND",
      "label": "found",
      "type": "atomic",
      "entry_actions": [
        "render({bucket: idx, found:true, at:pos})",
        "notifyFound()"
      ],
      "exit_actions": []
    },
    {
      "id": "S6_NOT_FOUND",
      "label": "not_found",
      "type": "atomic",
      "entry_actions": [
        "render({bucket: idx, notfound:true})",
        "notifyNotFound()"
      ],
      "exit_actions": []
    },
    {
      "id": "S7_REMOVING",
      "label": "removing",
      "type": "atomic",
      "entry_actions": [
        "render({bucket: idx, visiting:true, at:pos})",
        "delayThenSpliceBucket()",
        "entries--"
      ],
      "exit_actions": [
        "render({bucket: idx})",
        "notifyRemoved()"
      ]
    },
    {
      "id": "S8_AUTOREZIZING",
      "label": "resizing_rehashing",
      "type": "compound",
      "entry_actions": [
        "notifyResizingStart()",
        "collectAllItems()",
        "createNewBuckets(newCap)",
        "render()",
        "startRehashAnimation()"
      ],
      "exit_actions": [
        "notifyResizingComplete()",
        "render()"
      ]
    },
    {
      "id": "S9_FILLING",
      "label": "filling_many",
      "type": "atomic",
      "entry_actions": [
        "startFillLoop(target=40)",
        "insertManyWithoutAnimation()",
        "notifyFilling()"
      ],
      "exit_actions": [
        "render()",
        "notifyFillComplete()"
      ]
    },
    {
      "id": "S10_CLEARING",
      "label": "clearing",
      "type": "atomic",
      "entry_actions": [
        "entries=0",
        "collisions=0",
        "initBuckets(parseInt(#capacityInput.value))",
        "render()"
      ],
      "exit_actions": [
        "notifyCleared()"
      ]
    },
    {
      "id": "S11_SETTING_CAPACITY",
      "label": "setting_capacity",
      "type": "atomic",
      "entry_actions": [
        "read #capacityInput.change value",
        "coerceMin2()",
        "initBuckets(val)",
        "notifyCapacitySet()"
      ],
      "exit_actions": []
    },
    {
      "id": "S12_SETTING_THRESHOLD",
      "label": "setting_threshold",
      "type": "atomic",
      "entry_actions": [
        "read #thresholdInput.change value",
        "coerceThreshold()",
        "threshold = t",
        "notifyThresholdSet()"
      ],
      "exit_actions": []
    },
    {
      "id": "S13_SWITCH_HASH",
      "label": "switch_hash_function",
      "type": "atomic",
      "entry_actions": [
        "read #hashSelect.value",
        "notifyHashSwitch()"
      ],
      "exit_actions": []
    },
    {
      "id": "S14_ERROR_NOTICE",
      "label": "error_notice",
      "type": "atomic",
      "entry_actions": [
        "notify('Please provide a key.')",
        "render()"
      ],
      "exit_actions": []
    }
  ],
  "events": [
    {
      "id": "USER_CLICK_PUT",
      "event_type": "user_action",
      "description": "User clicks the Insert / Update button",
      "triggers": "#putBtn"
    },
    {
      "id": "USER_CLICK_GET",
      "event_type": "user_action",
      "description": "User clicks the Get button",
      "triggers": "#getBtn"
    },
    {
      "id": "USER_CLICK_REMOVE",
      "event_type": "user_action",
      "description": "User clicks the Remove button",
      "triggers": "#removeBtn"
    },
    {
      "id": "USER_CLICK_CONTAINS",
      "event_type": "user_action",
      "description": "User clicks the Contains? button",
      "triggers": "#containsBtn"
    },
    {
      "id": "USER_CLICK_RANDOM",
      "event_type": "user_action",
      "description": "User clicks Insert Random button",
      "triggers": "#randomBtn"
    },
    {
      "id": "USER_CLICK_FILL",
      "event_type": "user_action",
      "description": "User clicks Fill 40 button",
      "triggers": "#fillBtn"
    },
    {
      "id": "USER_CLICK_CLEAR",
      "event_type": "user_action",
      "description": "User clicks Clear button",
      "triggers": "#clearBtn"
    },
    {
      "id": "USER_CHANGE_CAPACITY",
      "event_type": "user_action",
      "description": "User changes the initial capacity input",
      "triggers": "#capacityInput"
    },
    {
      "id": "USER_CHANGE_THRESHOLD",
      "event_type": "user_action",
      "description": "User changes the resize threshold input",
      "triggers": "#thresholdInput"
    },
    {
      "id": "USER_CHANGE_HASHFUNC",
      "event_type": "user_action",
      "description": "User switches the hash function select",
      "triggers": "#hashSelect"
    },
    {
      "id": "ANIM_INSERT_STEP_COMPLETE",
      "event_type": "system_event",
      "description": "Insertion animation step completed (node shown)",
      "triggers": "dom:setTimeout -> render({bucket: idx, found:true, at:...})"
    },
    {
      "id": "ANIM_UPDATE_COMPLETE",
      "event_type": "system_event",
      "description": "Update animation complete (value replaced)",
      "triggers": "dom:setTimeout -> replace value"
    },
    {
      "id": "ANIM_TRAVERSE_STEP",
      "event_type": "system_event",
      "description": "Traversal step during get()",
      "triggers": "dom:setTimeout traversal steps (200/350ms)"
    },
    {
      "id": "ANIM_REMOVE_COMPLETE",
      "event_type": "system_event",
      "description": "Remove splice completed after timeout",
      "triggers": "dom:setTimeout -> bucket.splice"
    },
    {
      "id": "AUTO_RESIZE_START",
      "event_type": "system_event",
      "description": "Auto-resize triggered due to load factor exceeding threshold",
      "triggers": "internal:entries/capacity/threshold check (setTimeout 650ms)"
    },
    {
      "id": "AUTO_RESIZE_REHASH_STEP",
      "event_type": "system_event",
      "description": "One rehash step during auto-resize (each item moved)",
      "triggers": "dom:setTimeout stepRehash (120ms)"
    },
    {
      "id": "AUTO_RESIZE_COMPLETE",
      "event_type": "system_event",
      "description": "Auto-resize and rehash complete",
      "triggers": "end of stepRehash sequence"
    },
    {
      "id": "FILL_LOOP_STEP",
      "event_type": "system_event",
      "description": "Fill 40 loop step inserted one item",
      "triggers": "dom:setTimeout addOne (30ms)"
    },
    {
      "id": "INPUT_KEY_EMPTY",
      "event_type": "system_event",
      "description": "User attempted action but key input is empty (validation)",
      "triggers": "dom:check keyInput.value.trim() === ''"
    }
  ],
  "transitions": [
    {
      "from": "S0_IDLE",
      "to": "S1_READING_INPUT",
      "event": "USER_CLICK_PUT",
      "guard": "keyInput.value.trim() !== ''",
      "actions": [
        "capture key and value",
        "disableControls(optional)"
      ],
      "expected_observables": [
        "dom:#keyInput.value read",
        "dom:#valueInput.value read"
      ],
      "timeout": 0
    },
    {
      "from": "S0_IDLE",
      "to": "S14_ERROR_NOTICE",
      "event": "USER_CLICK_PUT",
      "guard": "keyInput.value.trim() === ''",
      "actions": [
        "notify('Please provide a key.')"
      ],
      "expected_observables": [
        "dom:#notice.textContent === 'Please provide a key.'"
      ],
      "timeout": 0
    },
    {
      "from": "S1_READING_INPUT",
      "to": "S3_UPDATING_EXISTING",
      "event": "ANIM_UPDATE_COMPLETE",
      "guard": "existingKeyFoundInBucket",
      "actions": [
        "render visiting",
        "replaceBucketValue()"
      ],
      "expected_observables": [
        "dom:bucket node value changed",
        "dom:#notice updated with 'Updated key'"
      ],
      "timeout": 500
    },
    {
      "from": "S1_READING_INPUT",
      "to": "S2_INSERTING_NEW",
      "event": "ANIM_INSERT_STEP_COMPLETE",
      "guard": "keyNotFoundInBucket",
      "actions": [
        "append new item to bucket",
        "entries++",
        "maybe collisions++"
      ],
      "expected_observables": [
        "dom:#buckets child count increased",
        "dom:#statEntries updated",
        "dom:#statCollisions maybe updated"
      ],
      "timeout": 350
    },
    {
      "from": "S2_INSERTING_NEW",
      "to": "S0_IDLE",
      "event": "ANIM_INSERT_STEP_COMPLETE",
      "guard": "true",
      "actions": [
        "notify inserted",
        "render final bucket view"
      ],
      "expected_observables": [
        "dom:#notice contains 'Inserted key'",
        "dom:#buckets shows new node"
      ],
      "timeout": 350
    },
    {
      "from": "S2_INSERTING_NEW",
      "to": "S8_AUTOREZIZING",
      "event": "AUTO_RESIZE_START",
      "guard": "(entries / capacity) > threshold",
      "actions": [
        "notify resizing",
        "collect items",
        "set capacity = capacity*2",
        "create new buckets"
      ],
      "expected_observables": [
        "dom:#notice contains 'Resizing table'",
        "dom:#statCapacity increases"
      ],
      "timeout": 650
    },
    {
      "from": "S8_AUTOREZIZING",
      "to": "S8_AUTOREZIZING",
      "event": "AUTO_RESIZE_REHASH_STEP",
      "guard": "rehash items remaining",
      "actions": [
        "move one item to new bucket",
        "render({bucket: idx, found:true, at:...})"
      ],
      "expected_observables": [
        "dom:#buckets shows incremental nodes",
        "dom:bucket highlighted during rehash"
      ],
      "timeout": 120
    },
    {
      "from": "S8_AUTOREZIZING",
      "to": "S0_IDLE",
      "event": "AUTO_RESIZE_COMPLETE",
      "guard": "all items rehashed",
      "actions": [
        "notify resizing complete",
        "render()"
      ],
      "expected_observables": [
        "dom:#notice contains 'Resizing complete'",
        "dom:#statCapacity updated",
        "dom:#buckets fully rehashed"
      ],
      "timeout": 250
    },
    {
      "from": "S0_IDLE",
      "to": "S4_TRAVERSING_SEARCH",
      "event": "USER_CLICK_GET",
      "guard": "keyInput.value.trim() !== ''",
      "actions": [
        "capture key",
        "render({bucket: idx})",
        "start traversal step loop"
      ],
      "expected_observables": [
        "dom:#keyInput read",
        "dom:#buckets bucket highlighted"
      ],
      "timeout": 0
    },
    {
      "from": "S0_IDLE",
      "to": "S14_ERROR_NOTICE",
      "event": "USER_CLICK_GET",
      "guard": "keyInput.value.trim() === ''",
      "actions": [
        "notify('Please provide a key.')"
      ],
      "expected_observables": [
        "dom:#notice updated"
      ],
      "timeout": 0
    },
    {
      "from": "S4_TRAVERSING_SEARCH",
      "to": "S5_FOUND",
      "event": "ANIM_TRAVERSE_STEP",
      "guard": "bucket[i].key === key",
      "actions": [
        "render found node",
        "notify found with value"
      ],
      "expected_observables": [
        "dom:#notice contains 'Found key'",
        "dom:#buckets shows found highlight"
      ],
      "timeout": 350
    },
    {
      "from": "S4_TRAVERSING_SEARCH",
      "to": "S6_NOT_FOUND",
      "event": "ANIM_TRAVERSE_STEP",
      "guard": "completed traversal without match",
      "actions": [
        "render notfound on bucket",
        "notify not found"
      ],
      "expected_observables": [
        "dom:#notice contains 'not found'",
        "dom:#buckets bucket shows notfound"
      ],
      "timeout": 350
    },
    {
      "from": "S5_FOUND",
      "to": "S0_IDLE",
      "event": "ANIM_TRAVERSE_STEP",
      "guard": "true",
      "actions": [
        "render()"
      ],
      "expected_observables": [
        "dom:#statEntries unchanged"
      ],
      "timeout": 0
    },
    {
      "from": "S6_NOT_FOUND",
      "to": "S0_IDLE",
      "event": "ANIM_TRAVERSE_STEP",
      "guard": "true",
      "actions": [
        "render()"
      ],
      "expected_observables": [
        "dom:#notice set to not found"
      ],
      "timeout": 0
    },
    {
      "from": "S0_IDLE",
      "to": "S7_REMOVING",
      "event": "USER_CLICK_REMOVE",
      "guard": "keyInput.value.trim() !== '' && keyExistsInBucket",
      "actions": [
        "render visiting",
        "delayThenRemove()"
      ],
      "expected_observables": [
        "dom:#buckets shows visiting highlight",
        "dom:#statEntries decreases after remove"
      ],
      "timeout": 400
    },
    {
      "from": "S0_IDLE",
      "to": "S6_NOT_FOUND",
      "event": "USER_CLICK_REMOVE",
      "guard": "keyInput.value.trim() !== '' && !keyExistsInBucket",
      "actions": [
        "render notfound",
        "notify not found remove"
      ],
      "expected_observables": [
        "dom:#notice contains 'not found; nothing removed.'"
      ],
      "timeout": 0
    },
    {
      "from": "S0_IDLE",
      "to": "S14_ERROR_NOTICE",
      "event": "USER_CLICK_REMOVE",
      "guard": "keyInput.value.trim() === ''",
      "actions": [
        "notify('Please provide a key.')"
      ],
      "expected_observables": [
        "dom:#notice updated"
      ],
      "timeout": 0
    },
    {
      "from": "S0_IDLE",
      "to": "S5_FOUND",
      "event": "USER_CLICK_CONTAINS",
      "guard": "keyInput.value.trim() !== '' && keyExistsInBucket",
      "actions": [
        "render({bucket: idx, found:true, at:pos})",
        "notify contains yes"
      ],
      "expected_observables": [
        "dom:#notice contains 'Yes: key'",
        "dom:#buckets shows found highlight"
      ],
      "timeout": 0
    },
    {
      "from": "S0_IDLE",
      "to": "S6_NOT_FOUND",
      "event": "USER_CLICK_CONTAINS",
      "guard": "keyInput.value.trim() !== '' && !keyExistsInBucket",
      "actions": [
        "render({bucket: idx, notfound:true})",
        "notify contains no"
      ],
      "expected_observables": [
        "dom:#notice contains 'No: key'",
        "dom:#buckets shows notfound highlight"
      ],
      "timeout": 0
    },
    {
      "from": "S0_IDLE",
      "to": "S14_ERROR_NOTICE",
      "event": "USER_CLICK_CONTAINS",
      "guard": "keyInput.value.trim() === ''",
      "actions": [
        "notify('Please provide a key.')"
      ],
      "expected_observables": [
        "dom:#notice updated"
      ],
      "timeout": 0
    },
    {
      "from": "S0_IDLE",
      "to": "S2_INSERTING_NEW",
      "event": "USER_CLICK_RANDOM",
      "guard": "true",
      "actions": [
        "generate random key/value",
        "set #keyInput and #valueInput",
        "call put(k, v)"
      ],
      "expected_observables": [
        "dom:#keyInput.value changed",
        "dom:#buckets updated with new node"
      ],
      "timeout": 0
    },
    {
      "from": "S0_IDLE",
      "to": "S9_FILLING",
      "event": "USER_CLICK_FILL",
      "guard": "true",
      "actions": [
        "start fill loop (40 inserts)",
        "insert many with animate=false"
      ],
      "expected_observables": [
        "dom:#notice contains 'Filling table with many entries...'",
        "dom:#statEntries increases to ~40"
      ],
      "timeout": 30
    },
    {
      "from": "S9_FILLING",
      "to": "S0_IDLE",
      "event": "FILL_LOOP_STEP",
      "guard": "filled all target entries",
      "actions": [
        "render()",
        "notify fill complete"
      ],
      "expected_observables": [
        "dom:#statEntries reflects filled count",
        "dom:#buckets populated"
      ],
      "timeout": 30
    },
    {
      "from": "S0_IDLE",
      "to": "S10_CLEARING",
      "event": "USER_CLICK_CLEAR",
      "guard": "true",
      "actions": [
        "entries=0",
        "collisions=0",
        "initBuckets(parseInt(#capacityInput.value))"
      ],
      "expected_observables": [
        "dom:#buckets emptied",
        "dom:#statEntries === '0'",
        "dom:#notice contains 'Cleared table.'"
      ],
      "timeout": 0
    },
    {
      "from": "S0_IDLE",
      "to": "S11_SETTING_CAPACITY",
      "event": "USER_CHANGE_CAPACITY",
      "guard": "true",
      "actions": [
        "read value",
        "coerce min 2",
        "initBuckets(val)",
        "notify capacity set"
      ],
      "expected_observables": [
        "dom:#capacityInput.value changed",
        "dom:#buckets re-rendered"
      ],
      "timeout": 0
    },
    {
      "from": "S0_IDLE",
      "to": "S12_SETTING_THRESHOLD",
      "event": "USER_CHANGE_THRESHOLD",
      "guard": "true",
      "actions": [
        "read threshold",
        "coerce threshold",
        "assign threshold",
        "notify threshold set"
      ],
      "expected_observables": [
        "dom:#thresholdInput.value changed",
        "dom:#notice updated"
      ],
      "timeout": 0
    },
    {
      "from": "S0_IDLE",
      "to": "S13_SWITCH_HASH",
      "event": "USER_CHANGE_HASHFUNC",
      "guard": "true",
      "actions": [
        "read new hashSelect.value",
        "notify hash function switched"
      ],
      "expected_observables": [
        "dom:#hashSelect.value changed",
        "dom:#notice contains 'Hash function switched'"
      ],
      "timeout": 0
    },
    {
      "from": "S14_ERROR_NOTICE",
      "to": "S0_IDLE",
      "event": "ANIM_TRAVERSE_STEP",
      "guard": "true",
      "actions": [
        "clear temporary notice or continue"
      ],
      "expected_observables": [
        "dom:#notice updated"
      ],
      "timeout": 500
    }
  ],
  "components": [
    "input#keyInput",
    "input#valueInput",
    "button#putBtn",
    "button#putBtn.primary",
    "button#getBtn",
    "button#removeBtn",
    "button#containsBtn",
    "button#containsBtn.small-btn",
    "button#randomBtn",
    "button#randomBtn.small-btn",
    "button#fillBtn",
    "button#fillBtn.small-btn",
    "select#hashSelect",
    "input#capacityInput",
    "input#thresholdInput",
    "button#clearBtn",
    "button#clearBtn.small-btn",
    "div#buckets",
    "div#notice",
    "strong#statEntries",
    "strong#statCapacity",
    "strong#statLF",
    "strong#statCollisions"
  ]
}