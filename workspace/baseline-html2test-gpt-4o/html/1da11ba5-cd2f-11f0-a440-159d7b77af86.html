<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topological Sort Demonstration</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #graphInput {
            width: 300px;
        }
        .graph {
            margin-bottom: 20px;
        }
        .node, .arrow {
            display: inline-block;
            vertical-align: middle;
        }
        .node {
            width: 30px;
            height: 30px;
            background-color: #4CAF50;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            margin: 5px;
        }
    </style>
</head>
<body>

    <h1>Topological Sort Visualization</h1>
    <div>
        <textarea id="graphInput" rows="10" placeholder="Enter edges in format: A->B,B->C,C->D"></textarea>
        <button onclick="performTopologicalSort()">Sort</button>
    </div>

    <div id="graphRepresentation"></div>
    <h2>Topological Sort Result:</h2>
    <div id="result"></div>

    <script>
        function performTopologicalSort() {
            const input = document.getElementById('graphInput').value;
            if (!input.trim()) {
                alert('Please enter a graph');
                return;
            }

            const edges = input.split(',').map(edge => edge.split('->'));
            const graph = {};
            const inDegree = {};

            edges.forEach(([from, to]) => {
                if (!graph[from]) graph[from] = [];
                graph[from].push(to);

                if (!inDegree[to]) inDegree[to] = 0;
                inDegree[to]++;
                
                if (!inDegree[from]) inDegree[from] = 0;
            });

            const queue = [];
            for (const node in inDegree) {
                if (inDegree[node] === 0) {
                    queue.push(node);
                }
            }

            const result = [];
            while (queue.length > 0) {
                const node = queue.shift();
                result.push(node);

                if (graph[node]) {
                    graph[node].forEach(neighbour => {
                        inDegree[neighbour]--;
                        if (inDegree[neighbour] === 0) {
                            queue.push(neighbour);
                        }
                    });
                }
            }

            if (result.length !== Object.keys(inDegree).length) {
                alert('Graph has a cycle. Topological sort is not possible.');
                renderGraph(edges, graph, true);
                return;
            }
            
            renderGraph(edges, graph);
            document.getElementById('result').textContent = result.join(' ');
        }

        function renderGraph(edges, graph, hasCycle = false) {
            const graphContainer = document.getElementById('graphRepresentation');
            graphContainer.innerHTML = '<h2>Graph:</h2>';
            edges.forEach(([from, to]) => {
                const edgeRepresentation = `
                    <div class="graph">
                        <span class="node">${from}</span>
                        <span class="arrow">â†’</span>
                        <span class="node">${to}</span>
                    </div>
                `;
                graphContainer.innerHTML += edgeRepresentation;
            });
            if (hasCycle) {
                graphContainer.innerHTML += '<p style="color:red;">Cycle Detected!</p>';
            }
        }
    </script>

</body>
</html>