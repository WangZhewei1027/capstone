<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hash Table Demonstration</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        #hashTable {
            border-collapse: collapse;
            margin-top: 20px;
        }
        #hashTable th, #hashTable td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        #hashTable th {
            background-color: #4CAF50;
            color: white;
        }
        input[type="text"], button {
            padding: 8px;
            margin: 5px;
        }
    </style>
</head>
<body>

<h1>Interactive Hash Table Example</h1>

<div>
    <input type="text" id="key" placeholder="Key">
    <input type="text" id="value" placeholder="Value">
    <button onclick="addToHashTable()">Add</button>
</div>

<table id="hashTable">
    <thead>
        <tr>
            <th>Index</th>
            <th>Key</th>
            <th>Value</th>
        </tr>
    </thead>
    <tbody>
    </tbody>
</table>

<script>
    class HashTable {
        constructor(size=7) {
            this.data = new Array(size);
        }

        _hash(key) {
            let hash = 0;
            for (let i = 0; i < key.length; i++) {
                hash = (hash + key.charCodeAt(i) * i) % this.data.length;
            }
            return hash;
        }

        set(key, value) {
            const address = this._hash(key);
            if (!this.data[address]) {
                this.data[address] = [];
            }
            this.data[address].push([key, value]);
            this.updateHTML();
        }

        get(key) {
            const address = this._hash(key);
            const currentBucket = this.data[address];
            if (currentBucket) {
                for (let i = 0; i < currentBucket.length; i++) {
                    if (currentBucket[i][0] === key) {
                        return currentBucket[i][1];
                    }
                }
            }
            return undefined;
        }

        updateHTML() {
            const tbody = document.querySelector('#hashTable tbody');
            tbody.innerHTML = ''; // Clear the table before updating

            this.data.forEach((bucket, index) => {
                if (bucket) {
                    bucket.forEach(([key, value]) => {
                        const row = document.createElement('tr');
                        row.innerHTML = `<td>${index}</td><td>${key}</td><td>${value}</td>`;
                        tbody.appendChild(row);
                    });
                }
            });
        }
    }

    const hashTable = new HashTable();

    function addToHashTable() {
        const key = document.getElementById('key').value;
        const value = document.getElementById('value').value;

        if (key && value) {
            hashTable.set(key, value);
            document.getElementById('key').value = '';
            document.getElementById('value').value = '';
        } else {
            alert("Both key and value are required.");
        }
    }
</script>

</body>
</html>