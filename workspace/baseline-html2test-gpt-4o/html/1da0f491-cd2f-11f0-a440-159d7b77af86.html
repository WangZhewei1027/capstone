<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Union-Find (Disjoint Set) Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        form {
            margin-bottom: 20px;
        }
        input[type="text"] {
            width: 50px;
        }
        .output {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Union-Find (Disjoint Set) Demo</h1>

    <form id="unionFindForm">
        <label for="numElements">Number of elements:</label>
        <input type="text" id="numElements" value="0"> 
        <button type="button" onclick="initialize()">Initialize</button> <br/><br/>
        
        <fieldset>
            <legend>Union</legend>
            <label for="unionA">Element A:</label>
            <input type="text" id="unionA"> 
            <label for="unionB">Element B:</label>
            <input type="text" id="unionB"> 
            <button type="button" onclick="union()">Union</button>
        </fieldset>
        <br/>
        <fieldset>
            <legend>Find</legend>
            <label for="findElement">Element:</label>
            <input type="text" id="findElement"> 
            <button type="button" onclick="find()">Find</button>
        </fieldset>
    </form>

    <div class="output" id="output"></div>

    <script>
        class UnionFind {
            constructor(size) {
                this.parent = new Array(size);
                this.rank = new Array(size);
                for (let i = 0; i < size; i++) {
                    this.parent[i] = i;
                    this.rank[i] = 1;
                }
            }

            find(p) {
                if (this.parent[p] !== p) {
                    this.parent[p] = this.find(this.parent[p]); // Path compression
                }
                return this.parent[p];
            }

            union(p, q) {
                let rootP = this.find(p);
                let rootQ = this.find(q);

                if (rootP !== rootQ) {
                    if (this.rank[rootP] > this.rank[rootQ]) {
                        this.parent[rootQ] = rootP;
                    } else if (this.rank[rootP] < this.rank[rootQ]) {
                        this.parent[rootP] = rootQ;
                    } else {
                        this.parent[rootQ] = rootP;
                        this.rank[rootP]++;
                    }
                }
            }
        }

        let unionFind = null;

        function initialize() {
            const size = parseInt(document.getElementById('numElements').value);
            unionFind = new UnionFind(size);
            document.getElementById('output').textContent = `Initialized Disjoint Set with ${size} elements.`;
        }

        function find() {
            if (!unionFind) {
                alert("Please initialize the disjoint set first.");
                return;
            }
            const element = parseInt(document.getElementById('findElement').value);
            const representative = unionFind.find(element);
            document.getElementById('output').textContent = `Find: The representative of element ${element} is ${representative}.`;
        }

        function union() {
            if (!unionFind) {
                alert("Please initialize the disjoint set first.");
                return;
            }
            const a = parseInt(document.getElementById('unionA').value);
            const b = parseInt(document.getElementById('unionB').value);
            unionFind.union(a, b);
            document.getElementById('output').textContent = `Union: Elements ${a} and ${b} are now connected.`;
        }
    </script>
</body>
</html>