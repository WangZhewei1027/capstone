<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
        }
        #graphContainer {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        .node {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background-color: lightblue;
            margin: 10px;
            position: relative;
        }
        .edge {
            position: absolute;
            background-color: grey;
            height: 2px;
            transform-origin: 0 0;
        }
    </style>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const nodes = [
                { id: 'A', connections: { B: 1, C: 4 } },
                { id: 'B', connections: { A: 1, C: 2, D: 5 } },
                { id: 'C', connections: { A: 4, B: 2, D: 1 } },
                { id: 'D', connections: { B: 5, C: 1 } }
            ];

            function drawGraph() {
                const container = document.getElementById('graphContainer');
                
                nodes.forEach((node, index) => {
                    const nodeElement = document.createElement('div');
                    nodeElement.className = 'node';
                    nodeElement.textContent = node.id;
                    nodeElement.style.left = `${index * 100}px`;
                    nodeElement.style.top = `${index % 2 * 120}px`;
                    container.appendChild(nodeElement);
                });

                nodes.forEach(oneNode => {
                    const fromIndex = nodes.findIndex(n => n.id === oneNode.id);
                    for (const [to, weight] of Object.entries(oneNode.connections)) {
                        const toIndex = nodes.findIndex(n => n.id === to);
                        if (fromIndex < toIndex) {
                            const edge = document.createElement('div');
                            edge.className = 'edge';
                            const startX = fromIndex * 100 + 25;
                            const startY = fromIndex % 2 * 120 + 25;
                            const endX = toIndex * 100 + 25;
                            const endY = toIndex % 2 * 120 + 25;
                            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                            edge.style.width = `${length}px`;
                            edge.style.left = `${startX}px`;
                            edge.style.top = `${startY}px`;
                            edge.style.transform = `rotate(${Math.atan2(endY - startY, endX - startX)}rad)`;
                            container.appendChild(edge);
                        }
                    }
                });
            }

            function dijkstra(startNodeId) {
                const distances = {};
                const visited = {};
                const previous = {};
                const unvisitedNodes = new Set(nodes.map(n => n.id));

                nodes.forEach(node => distances[node.id] = Infinity);
                distances[startNodeId] = 0;

                while (unvisitedNodes.size > 0) {
                    const currentNodeId = [...unvisitedNodes].reduce((minNodeId, currentNodeId) => {
                        if (distances[currentNodeId] < distances[minNodeId] || minNodeId === null) {
                            return currentNodeId;
                        }
                        return minNodeId;
                    }, null);

                    const currentNode = nodes.find(node => node.id === currentNodeId);
                    unvisitedNodes.delete(currentNodeId);

                    for (const [neighborId, weight] of Object.entries(currentNode.connections)) {
                        if (!visited[neighborId]) {
                            const newDistance = distances[currentNodeId] + weight;
                            if (newDistance < distances[neighborId]) {
                                distances[neighborId] = newDistance;
                                previous[neighborId] = currentNodeId;
                            }
                        }
                    }
                    visited[currentNodeId] = true;
                }

                return { distances, previous };
            }

            function displayShortestPath(distances, previous, sourceId, destinationId) {
                if (sourceId === destinationId) {
                    alert('Source and destination are the same.');
                    return;
                }

                let path = [];
                let currentNodeId = destinationId;
                while (currentNodeId !== sourceId) {
                    path.push(currentNodeId);
                    currentNodeId = previous[currentNodeId];
                    if (currentNodeId === undefined) {
                        alert('No path found');
                        return;
                    }
                }
                path.push(sourceId);
                path.reverse();

                alert(`Shortest path from ${sourceId} to ${destinationId}: ${path.join(' -> ')} with distance ${distances[destinationId]}`);
            }

            drawGraph();

            const { distances, previous } = dijkstra('A');
            displayShortestPath(distances, previous, 'A', 'D');
        });
    </script>
</head>
<body>
    <h1>Dijkstra's Algorithm Visualization</h1>
    <div id="graphContainer"></div>
</body>
</html>