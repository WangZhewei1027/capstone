<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red-Black Tree Visualizer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin-top: 50px;
        }
        .node {
            display: inline-block;
            margin: 5px;
            width: 40px;
            height: 40px;
            line-height: 40px;
            border-radius: 20px;
            color: white;
        }
        .red {
            background-color: red;
        }
        .black {
            background-color: black;
        }
        #tree {
            width: 100%;
            overflow-y: auto;
            display: flex;
            justify-content: center;
        }
    </style>
</head>
<body>
    <h1>Red-Black Tree Visualizer</h1>
    <div>
        <input type="number" id="nodeValue" placeholder="Enter value" min="0">
        <button onclick="insertNode()">Insert</button>
    </div>
    <div id="tree"></div>
    
    <script>
        class RedBlackTreeNode {
            constructor(value, color = 'red') {
                this.value = value;
                this.color = color;
                this.left = null;
                this.right = null;
                this.parent = null;
            }
        }

        class RedBlackTree {
            constructor() {
                this.root = null;
            }

            insert(value) {
                let newNode = new RedBlackTreeNode(value);
                if (this.root === null) {
                    newNode.color = 'black'; // Root is always black
                    this.root = newNode;
                } else {
                    this.root = this.insertNode(this.root, newNode);
                    this.fixViolation(newNode);
                }
            }

            insertNode(root, node) {
                if (root === null) {
                    return node;
                }
                if (node.value < root.value) {
                    root.left = this.insertNode(root.left, node);
                    root.left.parent = root;
                } else {
                    root.right = this.insertNode(root.right, node);
                    root.right.parent = root;
                }
                return root;
            }

            fixViolation(node) {
                let parentNode = null;
                let grandParentNode = null;

                while ((node !== this.root) && (node.color === 'red') && (node.parent.color === 'red')) {
                    parentNode = node.parent;
                    grandParentNode = parentNode.parent;

                    /* Case A:
                        Parent is left child of Grand-parent */
                    if (parentNode === grandParentNode.left) {
                        let uncleNode = grandParentNode.right;

                        // Case 1: Uncle is red
                        if (uncleNode != null && uncleNode.color === 'red') {
                            grandParentNode.color = 'red';
                            parentNode.color = 'black';
                            uncleNode.color = 'black';
                            node = grandParentNode;
                        } else {
                            // Case 2: Node is right child, left rotation needed
                            if (node === parentNode.right) {
                                this.rotateLeft(parentNode);
                                node = parentNode;
                                parentNode = node.parent;
                            }

                            // Case 3: Node is left child, right rotation needed
                            this.rotateRight(grandParentNode);
                            let tempColor = parentNode.color;
                            parentNode.color = grandParentNode.color;
                            grandParentNode.color = tempColor;
                            node = parentNode;
                        }
                    } else {
                        /* Case B:
                           Parent is right child of Grand-parent */
                        let uncleNode = grandParentNode.left;

                        // Case 1: Uncle is red
                        if ((uncleNode != null) && (uncleNode.color === 'red')) {
                            grandParentNode.color = 'red';
                            parentNode.color = 'black';
                            uncleNode.color = 'black';
                            node = grandParentNode;
                        } else {
                            // Case 2: Node is left child, right rotation needed
                            if (node === parentNode.left) {
                                this.rotateRight(parentNode);
                                node = parentNode;
                                parentNode = node.parent;
                            }

                            // Case 3: Node is right child, left rotation needed
                            this.rotateLeft(grandParentNode);
                            let tempColor = parentNode.color;
                            parentNode.color = grandParentNode.color;
                            grandParentNode.color = tempColor;
                            node = parentNode;
                        }
                    }
                }

                this.root.color = 'black';
            }

            rotateLeft(node) {
                let rightNode = node.right;
                node.right = rightNode.left;

                if (node.right !== null)
                    node.right.parent = node;

                rightNode.parent = node.parent;

                if (node.parent === null)
                    this.root = rightNode;
                else if (node === node.parent.left)
                    node.parent.left = rightNode;
                else
                    node.parent.right = rightNode;

                rightNode.left = node;
                node.parent = rightNode;
            }

            rotateRight(node) {
                let leftNode = node.left;
                node.left = leftNode.right;

                if (node.left !== null)
                    node.left.parent = node;

                leftNode.parent = node.parent;

                if (node.parent === null)
                    this.root = leftNode;
                else if (node === node.parent.left)
                    node.parent.left = leftNode;
                else
                    node.parent.right = leftNode;

                leftNode.right = node;
                node.parent = leftNode;
            }

            renderNode(node, container) {
                if (node) {
                    let divNode = document.createElement('div');
                    divNode.innerText = node.value;
                    divNode.className = `node ${node.color}`;
                    container.appendChild(divNode);
                    let wrapper = document.createElement('div');
                    wrapper.style.display = 'flex';
                    wrapper.style.flexDirection = node.left || node.right ? 'column' : 'row';
                    wrapper.style.alignItems = 'center';
                    wrapper.style.justifyContent = 'center';

                    container.appendChild(wrapper);
                    if (node.left || node.right) {
                        if (node.left) {
                            this.renderNode(node.left, wrapper);
                        } else {
                            wrapper.appendChild(document.createElement('div'));
                        }
                        if (node.right) {
                            this.renderNode(node.right, wrapper);
                        } else {
                            wrapper.appendChild(document.createElement('div'));
                        }
                    }
                }
            }

            render() {
                const treeContainer = document.getElementById('tree');
                treeContainer.innerHTML = '';
                this.renderNode(this.root, treeContainer);
            }
        }

        const rbTree = new RedBlackTree();

        function insertNode() {
            const value = parseInt(document.getElementById('nodeValue').value);
            if (!isNaN(value)) {
                rbTree.insert(value);
                rbTree.render();
            }
        }
    </script>
</body>
</html>