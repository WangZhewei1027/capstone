<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prim's Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin-top: 50px;
        }
        #canvas {
            border: 1px solid black;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Prim's Algorithm Visualization</h1>
    <canvas id="canvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Define nodes and edges for a sample graph
        const nodes = [
            {x: 100, y: 100, label: 'A'},
            {x: 300, y: 100, label: 'B'},
            {x: 500, y: 100, label: 'C'},
            {x: 200, y: 300, label: 'D'},
            {x: 400, y: 300, label: 'E'}
        ];

        const edges = [
            {start: 0, end: 1, weight: 3},
            {start: 0, end: 3, weight: 1},
            {start: 1, end: 2, weight: 1},
            {start: 1, end: 4, weight: 5},
            {start: 2, end: 4, weight: 8},
            {start: 3, end: 4, weight: 2}
        ];

        // Draw nodes
        function drawNodes() {
            ctx.fillStyle = 'blue';
            nodes.forEach(node => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillText(node.label, node.x - 8, node.y + 5);
            });
        }

        // Draw edges
        function drawEdges() {
            ctx.strokeStyle = 'gray';
            edges.forEach(edge => {
                const startNode = nodes[edge.start];
                const endNode = nodes[edge.end];
                ctx.beginPath();
                ctx.moveTo(startNode.x, startNode.y);
                ctx.lineTo(endNode.x, endNode.y);
                ctx.stroke();
                // Draw the weight
                const midX = (startNode.x + endNode.x) / 2;
                const midY = (startNode.y + endNode.y) / 2;
                ctx.fillText(edge.weight, midX - 10, midY);
            });
        }

        // Prim's Algorithm Implementation
        function primsAlgorithm() {
            const mst = [];
            const includedNodes = new Set();
            includedNodes.add(0);

            while (mst.length < nodes.length - 1) {
                let minEdge = null;

                edges.forEach(edge => {
                    const startIncluded = includedNodes.has(edge.start);
                    const endIncluded = includedNodes.has(edge.end);
                    const includedNotBoth = startIncluded !== endIncluded;

                    if (includedNotBoth) {
                        if (!minEdge || edge.weight < minEdge.weight) {
                            minEdge = edge;
                        }
                    }
                });

                if (minEdge) {
                    mst.push(minEdge);
                    includedNodes.add(minEdge.start);
                    includedNodes.add(minEdge.end);
                }
            }

            // Highlight the MST edges
            ctx.strokeStyle = 'red';
            mst.forEach(edge => {
                const startNode = nodes[edge.start];
                const endNode = nodes[edge.end];
                ctx.beginPath();
                ctx.moveTo(startNode.x, startNode.y);
                ctx.lineTo(endNode.x, endNode.y);
                ctx.stroke();
            });

            console.log('Minimum Spanning Tree Edges:', mst);
        }

        // Initialize canvas
        function initialize() {
            drawNodes();
            drawEdges();
            primsAlgorithm();
        }

        initialize();
    </script>
</body>
</html>