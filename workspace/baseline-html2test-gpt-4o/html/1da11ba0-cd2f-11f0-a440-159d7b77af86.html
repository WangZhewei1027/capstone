<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f4f4f9;
        }
        .graph {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-gap: 20px;
        }
        .node {
            background-color: #80b3ff;
            border-radius: 50%;
            height: 60px;
            width: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-weight: bold;
            position: relative;
        }
        .node span {
            position: absolute;
            top: -20px;
            transform: translateY(-100%);
        }
    </style>
</head>
<body>
    <div class="graph">
        <div id="A" class="node">A</div>
        <div id="B" class="node">B</div>
        <div id="C" class="node">C</div>
        <div id="D" class="node">D</div>
        <div id="E" class="node">E</div>
        <div id="F" class="node">F</div>
    </div>

    <script>
        function dijkstraAlgorithm(startNode, graph) {
            const nodes = new Set(Object.keys(graph));
            const distances = Object.fromEntries(nodes, Infinity);
            distances[startNode] = 0;
            const previousNodes = Object.fromEntries(nodes, null);

            while (nodes.size > 0) {
                const currentNode = [...nodes].reduce((closest, node) =>
                    distances[node] < distances[closest] ? node : closest, [...nodes][0]);
                
                nodes.delete(currentNode);
                
                for (const [neighbor, weight] of Object.entries(graph[currentNode])) {
                    const alternative = distances[currentNode] + weight;
                    if (alternative < distances[neighbor]) {
                        distances[neighbor] = alternative;
                        previousNodes[neighbor] = currentNode;
                    }
                }
            }
            return {distances, previousNodes};
        }

        function visualizePath(graph, startNode) {
            const { distances } = dijkstraAlgorithm(startNode, graph);

            Object.entries(distances).forEach(([node, distance]) => {
                const nodeElement = document.getElementById(node);
                const distanceText = document.createElement('span');
                distanceText.textContent = distance;
                nodeElement.appendChild(distanceText);
            });
        }

        const graph = {
            A: { B: 1, C: 4 },
            B: { A: 1, C: 2, D: 5 },
            C: { A: 4, B: 2, E: 3 },
            D: { B: 5, E: 1 },
            E: { C: 3, D: 1, F: 7 },
            F: { E: 7 }
        };

        visualizePath(graph, 'A');
    </script>
</body>
</html>