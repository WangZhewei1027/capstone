{
  "id": "1da0cd81-cd2f-11f0-a440-159d7b77af86",
  "timestamp": "2025-11-29T14:25:25.709Z",
  "type": "html-to-test",
  "htmlModel": "gpt-4o",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Red-Black Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Red-Black Tree Visualizer</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            text-align: center;\n            margin-top: 50px;\n        }\n        .node {\n            display: inline-block;\n            margin: 5px;\n            width: 40px;\n            height: 40px;\n            line-height: 40px;\n            border-radius: 20px;\n            color: white;\n        }\n        .red {\n            background-color: red;\n        }\n        .black {\n            background-color: black;\n        }\n        #tree {\n            width: 100%;\n            overflow-y: auto;\n            display: flex;\n            justify-content: center;\n        }\n    </style>\n</head>\n<body>\n    <h1>Red-Black Tree Visualizer</h1>\n    <div>\n        <input type=\"number\" id=\"nodeValue\" placeholder=\"Enter value\" min=\"0\">\n        <button onclick=\"insertNode()\">Insert</button>\n    </div>\n    <div id=\"tree\"></div>\n    \n    <script>\n        class RedBlackTreeNode {\n            constructor(value, color = 'red') {\n                this.value = value;\n                this.color = color;\n                this.left = null;\n                this.right = null;\n                this.parent = null;\n            }\n        }\n\n        class RedBlackTree {\n            constructor() {\n                this.root = null;\n            }\n\n            insert(value) {\n                let newNode = new RedBlackTreeNode(value);\n                if (this.root === null) {\n                    newNode.color = 'black'; // Root is always black\n                    this.root = newNode;\n                } else {\n                    this.root = this.insertNode(this.root, newNode);\n                    this.fixViolation(newNode);\n                }\n            }\n\n            insertNode(root, node) {\n                if (root === null) {\n                    return node;\n                }\n                if (node.value < root.value) {\n                    root.left = this.insertNode(root.left, node);\n                    root.left.parent = root;\n                } else {\n                    root.right = this.insertNode(root.right, node);\n                    root.right.parent = root;\n                }\n                return root;\n            }\n\n            fixViolation(node) {\n                let parentNode = null;\n                let grandParentNode = null;\n\n                while ((node !== this.root) && (node.color === 'red') && (node.parent.color === 'red')) {\n                    parentNode = node.parent;\n                    grandParentNode = parentNode.parent;\n\n                    /* Case A:\n                        Parent is left child of Grand-parent */\n                    if (parentNode === grandParentNode.left) {\n                        let uncleNode = grandParentNode.right;\n\n                        // Case 1: Uncle is red\n                        if (uncleNode != null && uncleNode.color === 'red') {\n                            grandParentNode.color = 'red';\n                            parentNode.color = 'black';\n                            uncleNode.color = 'black';\n                            node = grandParentNode;\n                        } else {\n                            // Case 2: Node is right child, left rotation needed\n                            if (node === parentNode.right) {\n                                this.rotateLeft(parentNode);\n                                node = parentNode;\n                                parentNode = node.parent;\n                            }\n\n                            // Case 3: Node is left child, right rotation needed\n                            this.rotateRight(grandParentNode);\n                            let tempColor = parentNode.color;\n                            parentNode.color = grandParentNode.color;\n                            grandParentNode.color = tempColor;\n                            node = parentNode;\n                        }\n                    } else {\n                        /* Case B:\n                           Parent is right child of Grand-parent */\n                        let uncleNode = grandParentNode.left;\n\n                        // Case 1: Uncle is red\n                        if ((uncleNode != null) && (uncleNode.color === 'red')) {\n                            grandParentNode.color = 'red';\n                            parentNode.color = 'black';\n                            uncleNode.color = 'black';\n                            node = grandParentNode;\n                        } else {\n                            // Case 2: Node is left child, right rotation needed\n                            if (node === parentNode.left) {\n                                this.rotateRight(parentNode);\n                                node = parentNode;\n                                parentNode = node.parent;\n                            }\n\n                            // Case 3: Node is right child, left rotation needed\n                            this.rotateLeft(grandParentNode);\n                            let tempColor = parentNode.color;\n                            parentNode.color = grandParentNode.color;\n                            grandParentNode.color = tempColor;\n                            node = parentNode;\n                        }\n                    }\n                }\n\n                this.root.color = 'black';\n            }\n\n            rotateLeft(node) {\n                let rightNode = node.right;\n                node.right = rightNode.left;\n\n                if (node.right !== null)\n                    node.right.parent = node;\n\n                rightNode.parent = node.parent;\n\n                if (node.parent === null)\n                    this.root = rightNode;\n                else if (node === node.parent.left)\n                    node.parent.left = rightNode;\n                else\n                    node.parent.right = rightNode;\n\n                rightNode.left = node;\n                node.parent = rightNode;\n            }\n\n            rotateRight(node) {\n                let leftNode = node.left;\n                node.left = leftNode.right;\n\n                if (node.left !== null)\n                    node.left.parent = node;\n\n                leftNode.parent = node.parent;\n\n                if (node.parent === null)\n                    this.root = leftNode;\n                else if (node === node.parent.left)\n                    node.parent.left = leftNode;\n                else\n                    node.parent.right = leftNode;\n\n                leftNode.right = node;\n                node.parent = leftNode;\n            }\n\n            renderNode(node, container) {\n                if (node) {\n                    let divNode = document.createElement('div');\n                    divNode.innerText = node.value;\n                    divNode.className = `node ${node.color}`;\n                    container.appendChild(divNode);\n                    let wrapper = document.createElement('div');\n                    wrapper.style.display = 'flex';\n                    wrapper.style.flexDirection = node.left || node.right ? 'column' : 'row';\n                    wrapper.style.alignItems = 'center';\n                    wrapper.style.justifyContent = 'center';\n\n                    container.appendChild(wrapper);\n                    if (node.left || node.right) {\n                        if (node.left) {\n                            this.renderNode(node.left, wrapper);\n                        } else {\n                            wrapper.appendChild(document.createElement('div'));\n                        }\n                        if (node.right) {\n                            this.renderNode(node.right, wrapper);\n                        } else {\n                            wrapper.appendChild(document.createElement('div'));\n                        }\n                    }\n                }\n            }\n\n            render() {\n                const treeContainer = document.getElementById('tree');\n                treeContainer.innerHTML = '';\n                this.renderNode(this.root, treeContainer);\n            }\n        }\n\n        const rbTree = new RedBlackTree();\n\n        function insertNode() {\n            const value = parseInt(document.getElementById('nodeValue').value);\n            if (!isNaN(value)) {\n                rbTree.insert(value);\n                rbTree.render();\n            }\n        }\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Red-Black Tree"
    }
  ],
  "topic": "Red-Black Tree",
  "hasFSM": false,
  "hasTest": true
}