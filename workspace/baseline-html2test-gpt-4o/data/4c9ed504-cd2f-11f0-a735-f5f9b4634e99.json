{
  "id": "4c9ed504-cd2f-11f0-a735-f5f9b4634e99",
  "timestamp": "2025-11-29T14:26:33.209Z",
  "type": "html-to-test",
  "htmlModel": "gpt-4o",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Dijkstra's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            padding-top: 20px;\n        }\n        #graphContainer {\n            display: flex;\n            justify-content: center;\n            margin-bottom: 20px;\n        }\n        .node {\n            width: 50px;\n            height: 50px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            border-radius: 50%;\n            background-color: lightblue;\n            margin: 10px;\n            position: relative;\n        }\n        .edge {\n            position: absolute;\n            background-color: grey;\n            height: 2px;\n            transform-origin: 0 0;\n        }\n    </style>\n    <script>\n        document.addEventListener('DOMContentLoaded', function() {\n            const nodes = [\n                { id: 'A', connections: { B: 1, C: 4 } },\n                { id: 'B', connections: { A: 1, C: 2, D: 5 } },\n                { id: 'C', connections: { A: 4, B: 2, D: 1 } },\n                { id: 'D', connections: { B: 5, C: 1 } }\n            ];\n\n            function drawGraph() {\n                const container = document.getElementById('graphContainer');\n                \n                nodes.forEach((node, index) => {\n                    const nodeElement = document.createElement('div');\n                    nodeElement.className = 'node';\n                    nodeElement.textContent = node.id;\n                    nodeElement.style.left = `${index * 100}px`;\n                    nodeElement.style.top = `${index % 2 * 120}px`;\n                    container.appendChild(nodeElement);\n                });\n\n                nodes.forEach(oneNode => {\n                    const fromIndex = nodes.findIndex(n => n.id === oneNode.id);\n                    for (const [to, weight] of Object.entries(oneNode.connections)) {\n                        const toIndex = nodes.findIndex(n => n.id === to);\n                        if (fromIndex < toIndex) {\n                            const edge = document.createElement('div');\n                            edge.className = 'edge';\n                            const startX = fromIndex * 100 + 25;\n                            const startY = fromIndex % 2 * 120 + 25;\n                            const endX = toIndex * 100 + 25;\n                            const endY = toIndex % 2 * 120 + 25;\n                            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));\n                            edge.style.width = `${length}px`;\n                            edge.style.left = `${startX}px`;\n                            edge.style.top = `${startY}px`;\n                            edge.style.transform = `rotate(${Math.atan2(endY - startY, endX - startX)}rad)`;\n                            container.appendChild(edge);\n                        }\n                    }\n                });\n            }\n\n            function dijkstra(startNodeId) {\n                const distances = {};\n                const visited = {};\n                const previous = {};\n                const unvisitedNodes = new Set(nodes.map(n => n.id));\n\n                nodes.forEach(node => distances[node.id] = Infinity);\n                distances[startNodeId] = 0;\n\n                while (unvisitedNodes.size > 0) {\n                    const currentNodeId = [...unvisitedNodes].reduce((minNodeId, currentNodeId) => {\n                        if (distances[currentNodeId] < distances[minNodeId] || minNodeId === null) {\n                            return currentNodeId;\n                        }\n                        return minNodeId;\n                    }, null);\n\n                    const currentNode = nodes.find(node => node.id === currentNodeId);\n                    unvisitedNodes.delete(currentNodeId);\n\n                    for (const [neighborId, weight] of Object.entries(currentNode.connections)) {\n                        if (!visited[neighborId]) {\n                            const newDistance = distances[currentNodeId] + weight;\n                            if (newDistance < distances[neighborId]) {\n                                distances[neighborId] = newDistance;\n                                previous[neighborId] = currentNodeId;\n                            }\n                        }\n                    }\n                    visited[currentNodeId] = true;\n                }\n\n                return { distances, previous };\n            }\n\n            function displayShortestPath(distances, previous, sourceId, destinationId) {\n                if (sourceId === destinationId) {\n                    alert('Source and destination are the same.');\n                    return;\n                }\n\n                let path = [];\n                let currentNodeId = destinationId;\n                while (currentNodeId !== sourceId) {\n                    path.push(currentNodeId);\n                    currentNodeId = previous[currentNodeId];\n                    if (currentNodeId === undefined) {\n                        alert('No path found');\n                        return;\n                    }\n                }\n                path.push(sourceId);\n                path.reverse();\n\n                alert(`Shortest path from ${sourceId} to ${destinationId}: ${path.join(' -> ')} with distance ${distances[destinationId]}`);\n            }\n\n            drawGraph();\n\n            const { distances, previous } = dijkstra('A');\n            displayShortestPath(distances, previous, 'A', 'D');\n        });\n    </script>\n</head>\n<body>\n    <h1>Dijkstra's Algorithm Visualization</h1>\n    <div id=\"graphContainer\"></div>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}