{
  "id": "47b74371-d1d4-11f0-959c-5fbc7dc7191d",
  "timestamp": "2025-12-05T12:17:29.097Z",
  "type": "html-to-test",
  "htmlModel": "gpt-4o-mini",
  "playwrightModel": "gpt-4o-mini",
  "status": "success",
  "question": "Huffman Coding",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Huffman Coding Demo</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 20px;\n            background-color: #f4f4f4;\n        }\n        #output {\n            margin-top: 20px;\n            padding: 10px;\n            background: #fff;\n            border: 1px solid #ccc;\n        }\n        .code {\n            margin: 5px 0;\n        }\n    </style>\n</head>\n<body>\n    <h1>Huffman Coding Demonstration</h1>\n    <label for=\"textInput\">Enter text to encode:</label><br>\n    <textarea id=\"textInput\" rows=\"4\" cols=\"50\"></textarea><br>\n    <button id=\"encodeButton\">Encode</button>\n    <div id=\"output\"></div>\n\n    <script>\n        class Node {\n            constructor(char, freq) {\n                this.char = char;\n                this.freq = freq;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class MinHeap {\n            constructor() {\n                this.nodes = [];\n            }\n            \n            insert(node) {\n                this.nodes.push(node);\n                this.bubbleUp();\n            }\n\n            bubbleUp() {\n                let index = this.nodes.length - 1;\n                while (index > 0) {\n                    let parentIndex = Math.floor((index - 1) / 2);\n                    if (this.nodes[index].freq >= this.nodes[parentIndex].freq) break;\n                    [this.nodes[index], this.nodes[parentIndex]] = [this.nodes[parentIndex], this.nodes[index]];\n                    index = parentIndex;\n                }\n            }\n\n            extractMin() {\n                if (this.nodes.length === 0) return null;\n                if (this.nodes.length === 1) return this.nodes.pop();\n                const minNode = this.nodes[0];\n                this.nodes[0] = this.nodes.pop();\n                this.bubbleDown();\n                return minNode;\n            }\n\n            bubbleDown() {\n                let index = 0;\n                const length = this.nodes.length;\n                while (true) {\n                    let leftChildIdx = index * 2 + 1;\n                    let rightChildIdx = index * 2 + 2;\n                    let smallest = index;\n\n                    if (leftChildIdx < length && this.nodes[leftChildIdx].freq < this.nodes[smallest].freq) {\n                        smallest = leftChildIdx;\n                    }\n                    if (rightChildIdx < length && this.nodes[rightChildIdx].freq < this.nodes[smallest].freq) {\n                        smallest = rightChildIdx;\n                    }\n                    if (smallest === index) break;\n\n                    [this.nodes[index], this.nodes[smallest]] = [this.nodes[smallest], this.nodes[index]];\n                    index = smallest;\n                }\n            }\n\n            isEmpty() {\n                return this.nodes.length === 0;\n            }\n        }\n\n        function buildHuffmanTree(text) {\n            const frequency = {};\n            for (const char of text) {\n                frequency[char] = (frequency[char] || 0) + 1;\n            }\n\n            const minHeap = new MinHeap();\n            for (const char in frequency) {\n                minHeap.insert(new Node(char, frequency[char]));\n            }\n\n            while (minHeap.nodes.length > 1) {\n                const left = minHeap.extractMin();\n                const right = minHeap.extractMin();\n                const merged = new Node(null, left.freq + right.freq);\n                merged.left = left;\n                merged.right = right;\n                minHeap.insert(merged);\n            }\n\n            return minHeap.extractMin();\n        }\n\n        function generateCodes(node, prefix, codes) {\n            if (node) {\n                if (node.char !== null) {\n                    codes[node.char] = prefix;\n                }\n                generateCodes(node.left, prefix + '0', codes);\n                generateCodes(node.right, prefix + '1', codes);\n            }\n        }\n\n        function huffmanEncode(text) {\n            const root = buildHuffmanTree(text);\n            const codes = {};\n            generateCodes(root, '', codes);\n            let encoded = '';\n            for (const char of text) {\n                encoded += codes[char];\n            }\n            return { codes, encoded };\n        }\n\n        document.getElementById('encodeButton').onclick = function() {\n            const text = document.getElementById('textInput').value;\n            const result = huffmanEncode(text);\n            let outputHtml = '<h3>Huffman Codes:</h3>';\n            for (const char in result.codes) {\n                outputHtml += `<div class=\"code\">${char}: ${result.codes[char]}</div>`;\n            }\n            outputHtml += `<h3>Encoded Output:</h3><div>${result.encoded}</div>`;\n            document.getElementById('output').innerHTML = outputHtml;\n        };\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Huffman Coding"
    }
  ],
  "topic": "Huffman Coding",
  "hasFSM": false,
  "hasTest": true
}