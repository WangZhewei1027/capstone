<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huffman Coding Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
        }
        #output {
            margin-top: 20px;
            padding: 10px;
            background: #fff;
            border: 1px solid #ccc;
        }
        .code {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <h1>Huffman Coding Demonstration</h1>
    <label for="textInput">Enter text to encode:</label><br>
    <textarea id="textInput" rows="4" cols="50"></textarea><br>
    <button id="encodeButton">Encode</button>
    <div id="output"></div>

    <script>
        class Node {
            constructor(char, freq) {
                this.char = char;
                this.freq = freq;
                this.left = null;
                this.right = null;
            }
        }

        class MinHeap {
            constructor() {
                this.nodes = [];
            }
            
            insert(node) {
                this.nodes.push(node);
                this.bubbleUp();
            }

            bubbleUp() {
                let index = this.nodes.length - 1;
                while (index > 0) {
                    let parentIndex = Math.floor((index - 1) / 2);
                    if (this.nodes[index].freq >= this.nodes[parentIndex].freq) break;
                    [this.nodes[index], this.nodes[parentIndex]] = [this.nodes[parentIndex], this.nodes[index]];
                    index = parentIndex;
                }
            }

            extractMin() {
                if (this.nodes.length === 0) return null;
                if (this.nodes.length === 1) return this.nodes.pop();
                const minNode = this.nodes[0];
                this.nodes[0] = this.nodes.pop();
                this.bubbleDown();
                return minNode;
            }

            bubbleDown() {
                let index = 0;
                const length = this.nodes.length;
                while (true) {
                    let leftChildIdx = index * 2 + 1;
                    let rightChildIdx = index * 2 + 2;
                    let smallest = index;

                    if (leftChildIdx < length && this.nodes[leftChildIdx].freq < this.nodes[smallest].freq) {
                        smallest = leftChildIdx;
                    }
                    if (rightChildIdx < length && this.nodes[rightChildIdx].freq < this.nodes[smallest].freq) {
                        smallest = rightChildIdx;
                    }
                    if (smallest === index) break;

                    [this.nodes[index], this.nodes[smallest]] = [this.nodes[smallest], this.nodes[index]];
                    index = smallest;
                }
            }

            isEmpty() {
                return this.nodes.length === 0;
            }
        }

        function buildHuffmanTree(text) {
            const frequency = {};
            for (const char of text) {
                frequency[char] = (frequency[char] || 0) + 1;
            }

            const minHeap = new MinHeap();
            for (const char in frequency) {
                minHeap.insert(new Node(char, frequency[char]));
            }

            while (minHeap.nodes.length > 1) {
                const left = minHeap.extractMin();
                const right = minHeap.extractMin();
                const merged = new Node(null, left.freq + right.freq);
                merged.left = left;
                merged.right = right;
                minHeap.insert(merged);
            }

            return minHeap.extractMin();
        }

        function generateCodes(node, prefix, codes) {
            if (node) {
                if (node.char !== null) {
                    codes[node.char] = prefix;
                }
                generateCodes(node.left, prefix + '0', codes);
                generateCodes(node.right, prefix + '1', codes);
            }
        }

        function huffmanEncode(text) {
            const root = buildHuffmanTree(text);
            const codes = {};
            generateCodes(root, '', codes);
            let encoded = '';
            for (const char of text) {
                encoded += codes[char];
            }
            return { codes, encoded };
        }

        document.getElementById('encodeButton').onclick = function() {
            const text = document.getElementById('textInput').value;
            const result = huffmanEncode(text);
            let outputHtml = '<h3>Huffman Codes:</h3>';
            for (const char in result.codes) {
                outputHtml += `<div class="code">${char}: ${result.codes[char]}</div>`;
            }
            outputHtml += `<h3>Encoded Output:</h3><div>${result.encoded}</div>`;
            document.getElementById('output').innerHTML = outputHtml;
        };
    </script>
</body>
</html>