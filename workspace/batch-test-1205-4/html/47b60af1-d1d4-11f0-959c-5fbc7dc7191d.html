<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Union-Find (Disjoint Set) Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 20px;
        }
        #output {
            margin-top: 20px;
            font-size: 1.2em;
        }
        #elements {
            margin-top: 20px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>

<h1>Union-Find (Disjoint Set) Visualization</h1>
<p>Use the buttons below to perform Union and Find operations on elements.</p>

<div id="elements">
    <input type="number" id="element1" placeholder="Element 1 (0-9)" min="0" max="9">
    <input type="number" id="element2" placeholder="Element 2 (0-9)" min="0" max="9">
    <button onclick="union()">Union</button>
    <button onclick="find()">Find</button>
</div>

<div id="output"></div>

<script>
    class UnionFind {
        constructor(size) {
            this.parent = Array.from({ length: size }, (_, i) => i);
            this.rank = Array(size).fill(1);
        }

        find(x) {
            if (this.parent[x] !== x) {
                this.parent[x] = this.find(this.parent[x]); // Path compression
            }
            return this.parent[x];
        }

        union(x, y) {
            const rootX = this.find(x);
            const rootY = this.find(y);

            if (rootX !== rootY) {
                // Union by rank
                if (this.rank[rootX] > this.rank[rootY]) {
                    this.parent[rootY] = rootX;
                } else if (this.rank[rootX] < this.rank[rootY]) {
                    this.parent[rootX] = rootY;
                } else {
                    this.parent[rootY] = rootX;
                    this.rank[rootX]++;
                }
            }
        }

        getSets() {
            const sets = {};
            for (let i = 0; i < this.parent.length; i++) {
                const root = this.find(i);
                if (!sets[root]) {
                    sets[root] = [];
                }
                sets[root].push(i);
            }
            return Object.values(sets);
        }
    }

    const uf = new UnionFind(10);

    function union() {
        const elem1 = parseInt(document.getElementById('element1').value);
        const elem2 = parseInt(document.getElementById('element2').value);
        if (isNaN(elem1) || isNaN(elem2) || elem1 < 0 || elem1 > 9 || elem2 < 0 || elem2 > 9) {
            alert("Please enter valid elements (0-9).");
            return;
        }
        uf.union(elem1, elem2);
        updateOutput();
    }

    function find() {
        const elem = parseInt(document.getElementById('element1').value);
        if (isNaN(elem) || elem < 0 || elem > 9) {
            alert("Please enter a valid element (0-9) to find.");
            return;
        }
        const result = uf.find(elem);
        document.getElementById('output').innerText = `Element ${elem} belongs to set with root ${result}.`;
    }

    function updateOutput() {
        const sets = uf.getSets();
        document.getElementById('output').innerText = 'Current sets: ' + JSON.stringify(sets);
    }
</script>

</body>
</html>