{
  "meta": {
    "concept": "Dijkstra",
    "topic": "Dijkstra's Algorithm — Interactive Demo",
    "educational_goal": "Visualize Dijkstra's shortest-path algorithm with interactive graph editing and step/auto execution",
    "expected_interactions": [
      "add_node",
      "add_edge",
      "move_node",
      "delete_node_or_edge",
      "set_source",
      "set_target",
      "run_full",
      "step",
      "auto",
      "reset_algo",
      "import",
      "export",
      "generate_random",
      "clear_graph"
    ]
  },
  "states": [
    {
      "id": "S0_Idle",
      "label": "Idle (AddNode default)",
      "type": "idle",
      "entry_actions": [
        "mode = 'addNode'",
        "document.querySelectorAll('.mode-btn').forEach(x=>x.classList.remove('active'))",
        "document.getElementById('mode-addnode').classList.add('active')",
        "draw()",
        "updateCounts()"
      ],
      "exit_actions": []
    },
    {
      "id": "S1_Mode_AddNode",
      "label": "Mode:AddNode",
      "type": "mode",
      "entry_actions": [
        "mode = 'addNode'",
        "document.getElementById('mode-addnode').classList.add('active')",
        "clear selectedForEdge"
      ],
      "exit_actions": []
    },
    {
      "id": "S2_Mode_AddEdge",
      "label": "Mode:AddEdge",
      "type": "mode",
      "entry_actions": [
        "mode = 'addEdge'",
        "document.getElementById('mode-addedge').classList.add('active')",
        "selectedForEdge = null"
      ],
      "exit_actions": [
        "selectedForEdge = null"
      ]
    },
    {
      "id": "S3_Mode_Move",
      "label": "Mode:Move",
      "type": "mode",
      "entry_actions": [
        "mode = 'move'",
        "document.getElementById('mode-move').classList.add('active')"
      ],
      "exit_actions": []
    },
    {
      "id": "S4_Mode_Delete",
      "label": "Mode:Delete",
      "type": "mode",
      "entry_actions": [
        "mode = 'delete'",
        "document.getElementById('mode-delete').classList.add('active')"
      ],
      "exit_actions": []
    },
    {
      "id": "S5_SetSource",
      "label": "SetSourceMode",
      "type": "modal",
      "entry_actions": [
        "mode = 'setSource'",
        "alert('Click a node to set as source.')",
        "attach one-time window click handler to capture node and set sourceNode"
      ],
      "exit_actions": [
        "remove the one-time window click handler",
        "mode = 'addNode'",
        "document.getElementById('mode-addnode').classList.add('active')"
      ]
    },
    {
      "id": "S6_SetTarget",
      "label": "SetTargetMode",
      "type": "modal",
      "entry_actions": [
        "mode = 'setTarget'",
        "alert('Click a node to set as target.')",
        "attach one-time window click handler to capture node and set targetNode"
      ],
      "exit_actions": [
        "remove the one-time window click handler",
        "mode = 'addNode'",
        "document.getElementById('mode-addnode').classList.add('active')"
      ]
    },
    {
      "id": "S7_EdgeSelection_AwaitingTarget",
      "label": "EdgeSelection:AwaitingTarget",
      "type": "atomic",
      "entry_actions": [
        "selectedForEdge = <sourceNodeId>",
        "log(`Selected node ${selectedForEdge} as edge source (click target node).`)"
      ],
      "exit_actions": [
        "selectedForEdge = null"
      ]
    },
    {
      "id": "S8_NodeDragging",
      "label": "NodeDragging",
      "type": "atomic",
      "entry_actions": [
        "isDragging = true",
        "dragNode = <nodeObject>",
        "capture dragOffset"
      ],
      "exit_actions": [
        "isDragging = false",
        "dragNode = null",
        "draw()"
      ]
    },
    {
      "id": "S9_Algo_Idle",
      "label": "Algorithm:Idle",
      "type": "idle",
      "entry_actions": [
        "algoState = null",
        "autoplay = false",
        "clearInterval(autoplayTimer)",
        "updateAllNodeDisplays()",
        "updateAllEdgeDisplays()"
      ],
      "exit_actions": []
    },
    {
      "id": "S10_Algo_Initialized",
      "label": "Algorithm:Initialized",
      "type": "atomic",
      "entry_actions": [
        "algoInit()",
        "updateAllNodeDisplays()",
        "updateAllEdgeDisplays()",
        "log('Initialized algorithm with source')"
      ],
      "exit_actions": []
    },
    {
      "id": "S11_Algo_Running_Auto",
      "label": "Algorithm:RunningAuto",
      "type": "composite",
      "entry_actions": [
        "autoplay = true",
        "document.getElementById('auto').textContent = 'Pause'",
        "ensure algoState initialized (algoInit if needed)",
        "autoplayTimer = setInterval(()=>{ if (algoState.finished) clearInterval(autoplayTimer); else algoStep(); }, 700 / Number(document.getElementById('speed').value))"
      ],
      "exit_actions": [
        "autoplay = false",
        "clearInterval(autoplayTimer)",
        "document.getElementById('auto').textContent = 'Auto'"
      ]
    },
    {
      "id": "S12_Algo_Stepping",
      "label": "Algorithm:StepExecuted",
      "type": "atomic",
      "entry_actions": [
        "algoStep()",
        "updateAllNodeDisplays()",
        "updateAllEdgeDisplays()"
      ],
      "exit_actions": []
    },
    {
      "id": "S13_Algo_Finished",
      "label": "Algorithm:Finished",
      "type": "final",
      "entry_actions": [
        "algoState.finished = true",
        "updateAllNodeDisplays()",
        "updateAllEdgeDisplays()",
        "if (targetNode && algoState.prev[targetNode]) highlight final path and log it"
      ],
      "exit_actions": []
    },
    {
      "id": "S14_Importing",
      "label": "ImportingJSON",
      "type": "atomic",
      "entry_actions": [
        "open file input element",
        "read selected file with FileReader",
        "on load parse JSON and set nodes, edges, nextNodeId, nextEdgeId, sourceNode, targetNode",
        "draw()",
        "updateCounts()",
        "log('Imported graph from file.')"
      ],
      "exit_actions": []
    },
    {
      "id": "S15_Exporting",
      "label": "Exporting",
      "type": "atomic",
      "entry_actions": [
        "serialize {nodes,edges,nextNodeId,nextEdgeId,sourceNode,targetNode}",
        "create blob and trigger download",
        "log('Exported JSON')"
      ],
      "exit_actions": []
    },
    {
      "id": "S16_Confirming_ClearGraph",
      "label": "ConfirmingClearGraph",
      "type": "atomic",
      "entry_actions": [
        "confirm('Clear the entire graph?')"
      ],
      "exit_actions": []
    }
  ],
  "events": [
    {
      "id": "CLICK_MODE_ADDNODE",
      "event_type": "user_action",
      "description": "User clicks the Add Node mode button",
      "triggers": "#mode-addnode"
    },
    {
      "id": "CLICK_MODE_ADDEDGE",
      "event_type": "user_action",
      "description": "User clicks the Add Edge mode button",
      "triggers": "#mode-addedge"
    },
    {
      "id": "CLICK_MODE_MOVE",
      "event_type": "user_action",
      "description": "User clicks the Move mode button",
      "triggers": "#mode-move"
    },
    {
      "id": "CLICK_MODE_DELETE",
      "event_type": "user_action",
      "description": "User clicks the Delete mode button",
      "triggers": "#mode-delete"
    },
    {
      "id": "CLICK_DEFAULT_DIRECTED",
      "event_type": "user_action",
      "description": "User toggles 'Directed edges by default' checkbox",
      "triggers": "#default-directed"
    },
    {
      "id": "CLICK_BTN_RANDOM",
      "event_type": "user_action",
      "description": "User clicks Generate Random Graph",
      "triggers": "#btn-random"
    },
    {
      "id": "CLICK_BTN_CLEAR",
      "event_type": "user_action",
      "description": "User clicks Clear Graph",
      "triggers": "#btn-clear"
    },
    {
      "id": "CLICK_SET_SOURCE",
      "event_type": "user_action",
      "description": "User clicks Set Source button",
      "triggers": "#set-source"
    },
    {
      "id": "CLICK_SET_TARGET",
      "event_type": "user_action",
      "description": "User clicks Set Target button",
      "triggers": "#set-target"
    },
    {
      "id": "CLICK_CLEAR_SETS",
      "event_type": "user_action",
      "description": "User clicks Clear (source/target) button",
      "triggers": "#clear-sets"
    },
    {
      "id": "CLICK_INIT_RUN",
      "event_type": "user_action",
      "description": "User clicks Run → (run to completion)",
      "triggers": "#init-run"
    },
    {
      "id": "CLICK_STEP",
      "event_type": "user_action",
      "description": "User clicks Step",
      "triggers": "#step"
    },
    {
      "id": "CLICK_AUTO",
      "event_type": "user_action",
      "description": "User clicks Auto (toggle autoplay)",
      "triggers": "#auto"
    },
    {
      "id": "CLICK_RESET_ALGO",
      "event_type": "user_action",
      "description": "User clicks Reset Algo",
      "triggers": "#reset-algo"
    },
    {
      "id": "CHANGE_SPEED",
      "event_type": "user_action",
      "description": "User changes the speed slider",
      "triggers": "#speed"
    },
    {
      "id": "CLICK_EXPORT_JSON",
      "event_type": "user_action",
      "description": "User clicks Export JSON",
      "triggers": "#export-json"
    },
    {
      "id": "CLICK_IMPORT_JSON",
      "event_type": "user_action",
      "description": "User clicks Import JSON",
      "triggers": "#import-json"
    },
    {
      "id": "CLICK_EXPORT_IMAGE",
      "event_type": "user_action",
      "description": "User clicks Export PNG",
      "triggers": "#export-image"
    },
    {
      "id": "SVG_CLICK_EMPTY",
      "event_type": "user_action",
      "description": "User clicks the SVG canvas (empty space)",
      "triggers": "#svg"
    },
    {
      "id": "NODE_CLICK",
      "event_type": "user_action",
      "description": "User clicks a node (g[data-node-id])",
      "triggers": "svg g[data-node-id]"
    },
    {
      "id": "NODE_MOUSEDOWN",
      "event_type": "user_action",
      "description": "User mouses down on a node (start drag)",
      "triggers": "svg g[data-node-id]"
    },
    {
      "id": "MOUSEMOVE_WINDOW",
      "event_type": "user_action",
      "description": "Mouse moved (global) (for dragging)",
      "triggers": "window"
    },
    {
      "id": "MOUSEUP_WINDOW",
      "event_type": "user_action",
      "description": "Mouse up (global) (end drag)",
      "triggers": "window"
    },
    {
      "id": "EDGE_CLICK",
      "event_type": "user_action",
      "description": "User clicks an edge line or arrow (line/path with data-edge-id)",
      "triggers": "svg line[data-edge-id], svg path[data-edge-id]"
    },
    {
      "id": "IMPORT_FILE_LOADED",
      "event_type": "system_event",
      "description": "FileReader has loaded imported JSON",
      "triggers": "file input change -> FileReader.onload"
    },
    {
      "id": "ALGO_INITIALIZED",
      "event_type": "system_event",
      "description": "Algorithm initialized (algoInit complete)",
      "triggers": "internal: algoInit()"
    },
    {
      "id": "ALGO_STEP_COMPLETE",
      "event_type": "system_event",
      "description": "One algorithm step completed (algoStep end)",
      "triggers": "internal: algoStep()"
    },
    {
      "id": "ALGO_FINISHED",
      "event_type": "system_event",
      "description": "Algorithm reached finished state",
      "triggers": "internal: algoState.finished === true"
    },
    {
      "id": "EXPORT_COMPLETE",
      "event_type": "system_event",
      "description": "Export (JSON or PNG) completed",
      "triggers": "internal: download triggered"
    },
    {
      "id": "RANDOM_GENERATION_COMPLETE",
      "event_type": "system_event",
      "description": "Random graph generation completed",
      "triggers": "#btn-random -> prompt accepted"
    },
    {
      "id": "CLEAR_GRAPH_CONFIRMED",
      "event_type": "user_action",
      "description": "User confirmed clearing the graph",
      "triggers": "#btn-clear (confirm)"
    }
  ],
  "transitions": [
    {
      "from": "S0_Idle",
      "to": "S1_Mode_AddNode",
      "event": "CLICK_MODE_ADDNODE",
      "guard": "true",
      "actions": [
        "mode='addNode'",
        "document.querySelectorAll('.mode-btn').forEach(x=>x.classList.remove('active'))",
        "document.getElementById('mode-addnode').classList.add('active')",
        "selectedForEdge = null"
      ],
      "triggers": "#mode-addnode",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S2_Mode_AddEdge",
      "event": "CLICK_MODE_ADDEDGE",
      "guard": "true",
      "actions": [
        "mode='addEdge'",
        "document.querySelectorAll('.mode-btn').forEach(x=>x.classList.remove('active'))",
        "document.getElementById('mode-addedge').classList.add('active')",
        "selectedForEdge = null"
      ],
      "triggers": "#mode-addedge",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S3_Mode_Move",
      "event": "CLICK_MODE_MOVE",
      "guard": "true",
      "actions": [
        "mode='move'",
        "document.querySelectorAll('.mode-btn').forEach(x=>x.classList.remove('active'))",
        "document.getElementById('mode-move').classList.add('active')"
      ],
      "triggers": "#mode-move",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S4_Mode_Delete",
      "event": "CLICK_MODE_DELETE",
      "guard": "true",
      "actions": [
        "mode='delete'",
        "document.querySelectorAll('.mode-btn').forEach(x=>x.classList.remove('active'))",
        "document.getElementById('mode-delete').classList.add('active')"
      ],
      "triggers": "#mode-delete",
      "timeout": 0
    },
    {
      "from": "S1_Mode_AddNode",
      "to": "S1_Mode_AddNode",
      "event": "SVG_CLICK_EMPTY",
      "guard": "mode === 'addNode'",
      "actions": [
        "const pt = clientToSVG(evt.clientX, evt.clientY)",
        "createNode(pt.x, pt.y)",
        "log(`Node ${nextNodeId-1} created.`)",
        "updateCounts()"
      ],
      "triggers": "#svg",
      "timeout": 0
    },
    {
      "from": "S2_Mode_AddEdge",
      "to": "S7_EdgeSelection_AwaitingTarget",
      "event": "NODE_CLICK",
      "guard": "selectedForEdge === null && mode === 'addEdge'",
      "actions": [
        "selectedForEdge = <clickedNodeId>",
        "log(`Selected node ${selectedForEdge} as edge source (click target node).`)"
      ],
      "triggers": "svg g[data-node-id]",
      "timeout": 0
    },
    {
      "from": "S7_EdgeSelection_AwaitingTarget",
      "to": "S2_Mode_AddEdge",
      "event": "NODE_CLICK",
      "guard": "mode === 'addEdge' && selectedForEdge !== null && clickedNodeId !== selectedForEdge",
      "actions": [
        "let w = prompt(`Enter weight for edge ${selectedForEdge} → ${clickedNodeId} (non-negative number):`, '1')",
        "if (w !== null){ w = Number(w); if (Number.isFinite(w) && w >= 0){ createEdge(selectedForEdge, clickedNodeId, w, document.getElementById('default-directed').checked); log(`Created ${document.getElementById('default-directed').checked? 'directed':'undirected'} edge ${selectedForEdge} → ${clickedNodeId} (w=${w}).`); } else { alert('Invalid weight. Must be non-negative number.'); } }",
        "selectedForEdge = null",
        "draw()",
        "updateCounts()"
      ],
      "triggers": "svg g[data-node-id]",
      "timeout": 0
    },
    {
      "from": "S7_EdgeSelection_AwaitingTarget",
      "to": "S2_Mode_AddEdge",
      "event": "NODE_CLICK",
      "guard": "mode === 'addEdge' && clickedNodeId === selectedForEdge",
      "actions": [
        "selectedForEdge = null",
        "log('Cancelled edge creation.')"
      ],
      "triggers": "svg g[data-node-id]",
      "timeout": 0
    },
    {
      "from": "S7_EdgeSelection_AwaitingTarget",
      "to": "S2_Mode_AddEdge",
      "event": "SVG_CLICK_EMPTY",
      "guard": "mode === 'addEdge' && selectedForEdge !== null",
      "actions": [
        "selectedForEdge = null",
        "log('Cancelled edge creation.')"
      ],
      "triggers": "#svg",
      "timeout": 0
    },
    {
      "from": "S3_Mode_Move",
      "to": "S8_NodeDragging",
      "event": "NODE_MOUSEDOWN",
      "guard": "mode === 'move'",
      "actions": [
        "isDragging = true",
        "dragNode = <clickedNodeObject>",
        "const pt = clientToSVG(evt.clientX, evt.clientY)",
        "dragOffset.x = dragNode.x - pt.x; dragOffset.y = dragNode.y - pt.y"
      ],
      "triggers": "svg g[data-node-id]",
      "timeout": 0
    },
    {
      "from": "S8_NodeDragging",
      "to": "S8_NodeDragging",
      "event": "MOUSEMOVE_WINDOW",
      "guard": "isDragging === true",
      "actions": [
        "const pt = clientToSVG(evt.clientX, evt.clientY)",
        "dragNode.x = pt.x + dragOffset.x; dragNode.y = pt.y + dragOffset.y",
        "draw()"
      ],
      "triggers": "window",
      "timeout": 0
    },
    {
      "from": "S8_NodeDragging",
      "to": "S3_Mode_Move",
      "event": "MOUSEUP_WINDOW",
      "guard": "isDragging === true",
      "actions": [
        "isDragging = false",
        "dragNode = null",
        "draw()"
      ],
      "triggers": "window",
      "timeout": 0
    },
    {
      "from": "S4_Mode_Delete",
      "to": "S4_Mode_Delete",
      "event": "NODE_CLICK",
      "guard": "mode === 'delete'",
      "actions": [
        "if (confirm('Delete this node and its edges?')) removeNode(<clickedNodeId>);",
        "draw(); updateCounts()"
      ],
      "triggers": "svg g[data-node-id]",
      "timeout": 0
    },
    {
      "from": "S4_Mode_Delete",
      "to": "S4_Mode_Delete",
      "event": "EDGE_CLICK",
      "guard": "mode === 'delete'",
      "actions": [
        "if (confirm('Delete this edge?')) removeEdge(<clickedEdgeId>);",
        "draw(); updateCounts()"
      ],
      "triggers": "svg line[data-edge-id], svg path[data-edge-id]",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S5_SetSource",
      "event": "CLICK_SET_SOURCE",
      "guard": "true",
      "actions": [
        "alert('Click a node to set as source.')",
        "mode = 'setSource'",
        "document.querySelectorAll('.mode-btn').forEach(x=>x.classList.remove('active'))",
        "attach temporary window click handler to capture node and set sourceNode"
      ],
      "triggers": "#set-source",
      "timeout": 0
    },
    {
      "from": "S5_SetSource",
      "to": "S1_Mode_AddNode",
      "event": "NODE_CLICK",
      "guard": "true",
      "actions": [
        "const pt = clientToSVG(evt.clientX, evt.clientY)",
        "const n = nodeAt(pt.x, pt.y)",
        "if (n){ sourceNode = n.id; log(`Source set to node ${n.id}`); updateCounts(); draw(); } else { alert('Click on a node.'); }",
        "mode = 'addNode'",
        "document.getElementById('mode-addnode').classList.add('active')",
        "remove the temporary window click handler"
      ],
      "triggers": "window (click) then svg g[data-node-id]",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S6_SetTarget",
      "event": "CLICK_SET_TARGET",
      "guard": "true",
      "actions": [
        "alert('Click a node to set as target.')",
        "mode = 'setTarget'",
        "document.querySelectorAll('.mode-btn').forEach(x=>x.classList.remove('active'))",
        "attach temporary window click handler to capture node and set targetNode"
      ],
      "triggers": "#set-target",
      "timeout": 0
    },
    {
      "from": "S6_SetTarget",
      "to": "S1_Mode_AddNode",
      "event": "NODE_CLICK",
      "guard": "true",
      "actions": [
        "const pt = clientToSVG(evt.clientX, evt.clientY)",
        "const n = nodeAt(pt.x, pt.y)",
        "if (n){ targetNode = n.id; log(`Target set to node ${n.id}`); updateCounts(); draw(); } else { alert('Click on a node.'); }",
        "mode = 'addNode'",
        "document.getElementById('mode-addnode').classList.add('active')",
        "remove the temporary window click handler"
      ],
      "triggers": "window (click) then svg g[data-node-id]",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S10_Algo_Initialized",
      "event": "CLICK_INIT_RUN",
      "guard": "true",
      "actions": [
        "algoRunFull()",
        "draw()"
      ],
      "triggers": "#init-run",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S12_Algo_Stepping",
      "event": "CLICK_STEP",
      "guard": "true",
      "actions": [
        "algoStep()"
      ],
      "triggers": "#step",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S11_Algo_Running_Auto",
      "event": "CLICK_AUTO",
      "guard": "autoplay === false",
      "actions": [
        "autoplay = true",
        "document.getElementById('auto').textContent = 'Pause'",
        "if (!algoState) { const ok = algoInit(); if (!ok) { autoplay=false; document.getElementById('auto').textContent='Auto'; return; } }",
        "autoplayTimer = setInterval(()=>{ if (algoState.finished){ clearInterval(autoplayTimer); autoplay=false; document.getElementById('auto').textContent='Auto'; } else algoStep(); }, 700/Number(document.getElementById('speed').value))"
      ],
      "triggers": "#auto",
      "timeout": 0
    },
    {
      "from": "S11_Algo_Running_Auto",
      "to": "S9_Algo_Idle",
      "event": "CLICK_AUTO",
      "guard": "autoplay === true",
      "actions": [
        "autoplay = false",
        "clearInterval(autoplayTimer)",
        "document.getElementById('auto').textContent = 'Auto'"
      ],
      "triggers": "#auto",
      "timeout": 0
    },
    {
      "from": "S10_Algo_Initialized",
      "to": "S13_Algo_Finished",
      "event": "ALGO_FINISHED",
      "guard": "true",
      "actions": [
        "updateAllNodeDisplays()",
        "updateAllEdgeDisplays()",
        "log('Algorithm finished.')"
      ],
      "triggers": "internal: algoState.finished === true",
      "timeout": 0
    },
    {
      "from": "S12_Algo_Stepping",
      "to": "S10_Algo_Initialized",
      "event": "ALGO_STEP_COMPLETE",
      "guard": "algoState && !algoState.finished",
      "actions": [
        "updateAllNodeDisplays()",
        "updateAllEdgeDisplays()"
      ],
      "triggers": "internal: algoStep finished one iteration",
      "timeout": 0
    },
    {
      "from": "S12_Algo_Stepping",
      "to": "S13_Algo_Finished",
      "event": "ALGO_FINISHED",
      "guard": "algoState && algoState.finished === true",
      "actions": [
        "updateAllNodeDisplays()",
        "updateAllEdgeDisplays()",
        "log('Algorithm finished.')"
      ],
      "triggers": "internal: algoStep sets algoState.finished",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S9_Algo_Idle",
      "event": "CLICK_RESET_ALGO",
      "guard": "true",
      "actions": [
        "algoState = null",
        "autoplay = false",
        "clearInterval(autoplayTimer)",
        "document.getElementById('auto').textContent = 'Auto'",
        "updateAllNodeDisplays()",
        "updateAllEdgeDisplays()",
        "log('Algorithm state reset.')"
      ],
      "triggers": "#reset-algo",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S15_Exporting",
      "event": "CLICK_EXPORT_JSON",
      "guard": "true",
      "actions": [
        "const data = {nodes,edges,nextNodeId,nextEdgeId,sourceNode,targetNode};",
        "serialize and trigger download via Blob and anchor",
        "log('Exported graph to JSON')"
      ],
      "triggers": "#export-json",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S14_Importing",
      "event": "CLICK_IMPORT_JSON",
      "guard": "true",
      "actions": [
        "open a file input element",
        "on file selection start FileReader and wait for IMPORT_FILE_LOADED"
      ],
      "triggers": "#import-json",
      "timeout": 0
    },
    {
      "from": "S14_Importing",
      "to": "S0_Idle",
      "event": "IMPORT_FILE_LOADED",
      "guard": "parsed JSON valid",
      "actions": [
        "nodes = data.nodes || []; edges = data.edges || []; nextNodeId = data.nextNodeId || (nodes.length+1); nextEdgeId = data.nextEdgeId || (edges.length+1); sourceNode = data.sourceNode || null; targetNode = data.targetNode || null; algoState = null; draw(); updateCounts(); log('Imported graph from file.');"
      ],
      "triggers": "FileReader.onload",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S0_Idle",
      "event": "CLICK_BTN_RANDOM",
      "guard": "user confirms prompts and valid inputs",
      "actions": [
        "prompt number of nodes",
        "prompt density",
        "prompt max weight",
        "generate nodes and edges programmatically via createNode/createEdge",
        "algoState = null; draw(); updateCounts(); log('Random graph generated.')"
      ],
      "triggers": "#btn-random",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S0_Idle",
      "event": "CLICK_BTN_CLEAR",
      "guard": "confirm('Clear the entire graph?') === true",
      "actions": [
        "nodes = []; edges = []; nextNodeId=1; nextEdgeId=1; sourceNode = null; targetNode = null; algoState = null; draw(); updateCounts(); log('Graph cleared.')"
      ],
      "triggers": "#btn-clear",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S1_Mode_AddNode",
      "event": "CLICK_CLEAR_SETS",
      "guard": "true",
      "actions": [
        "sourceNode = null; targetNode = null; updateCounts(); log('Source and target cleared.'); draw()"
      ],
      "triggers": "#clear-sets",
      "timeout": 0
    },
    {
      "from": "S2_Mode_AddEdge",
      "to": "S2_Mode_AddEdge",
      "event": "EDGE_CLICK",
      "guard": "mode !== 'delete'",
      "actions": [
        "log(`Edge ${edgeObj.source} → ${edgeObj.target} (w=${edgeObj.weight})`)"
      ],
      "triggers": "svg line[data-edge-id], svg path[data-edge-id]",
      "timeout": 0
    },
    {
      "from": "S2_Mode_AddEdge",
      "to": "S2_Mode_AddEdge",
      "event": "EDGE_CLICK",
      "guard": "mode === 'delete'",
      "actions": [
        "if (confirm('Delete this edge?')) removeEdge(<clickedEdgeId>); draw(); updateCounts();"
      ],
      "triggers": "svg line[data-edge-id], svg path[data-edge-id]",
      "timeout": 0
    },
    {
      "from": "S0_Idle",
      "to": "S15_Exporting",
      "event": "CLICK_EXPORT_IMAGE",
      "guard": "true",
      "actions": [
        "serialize svg to string, create Blob, drawImage onto canvas, trigger PNG download",
        "log('Exported PNG')"
      ],
      "triggers": "#export-image",
      "timeout": 0
    }
  ],
  "components": [
    "#mode-addnode",
    "#mode-addedge",
    "#mode-move",
    "#mode-delete",
    ".mode-btn",
    "#default-directed",
    "#btn-random",
    "#btn-clear",
    "#node-count",
    "#edge-count",
    "#set-source",
    "#set-target",
    "#clear-sets",
    "#init-run",
    "#step",
    "#auto",
    "#reset-algo",
    "#speed",
    "#source-show",
    "#target-show",
    "#log",
    "#export-image",
    "#export-json",
    "#import-json",
    "#svg",
    "#graph-wrap",
    "svg g[data-node-id]",
    "svg line[data-edge-id]",
    "svg path[data-edge-id]",
    "svg text.edge-weight",
    "g.node-dist"
  ]
}