<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Fibonacci Sequence Explorer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --accent:#60a5fa; --muted:#94a3b8; --accent2:#f97316;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; background:linear-gradient(180deg,#071027 0%, #081424 60%); color:#e6eef8;}
    .wrap{max-width:1100px;margin:28px auto;padding:22px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,0.7);border:1px solid rgba(255,255,255,0.03)}
    h1{margin:0 0 8px;font-size:22px}
    p.lead{margin:6px 0 18px;color:var(--muted);line-height:1.45}
    .controls{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:14px}
    .card{background:var(--card);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);min-width:220px;flex:1}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    input[type=number], select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:var(--glass);color:inherit}
    button{background:linear-gradient(90deg,var(--accent) 0%, #7dd3fc 100%);border:none;color:#042031;padding:10px 14px;border-radius:8px;font-weight:600;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .output{margin-top:16px;display:grid;grid-template-columns:1fr 360px;gap:12px}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);overflow:auto}
    .small{font-size:13px;color:var(--muted)}
    pre{white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;background:transparent;padding:8px;border-radius:8px;margin:8px 0;color:#dbeafe}
    canvas{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:8px;border:1px solid rgba(255,255,255,0.03);width:100%;height:360px}
    .sequence{max-height:320px;overflow:auto;padding:8px}
    .pill{display:inline-block;padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.03);margin:4px 6px 6px 0;font-size:13px}
    .important{color:var(--accent2);font-weight:700}
    footer{margin-top:16px;color:var(--muted);font-size:13px}
    .flex-between{display:flex;justify-content:space-between;align-items:center}
    .ratio-table{max-height:220px;overflow:auto;padding:6px;background:transparent;border-radius:6px}
    .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  </style>
</head>
<body>
  <div class="wrap" role="main">
    <h1>Fibonacci Sequence Explorer</h1>
    <p class="lead">Interactive demo: compute Fibonacci numbers (BigInt), compare methods (iterative, naive recursive, memoized, fast doubling), inspect ratios approaching the golden ratio, and visualize a Fibonacci spiral.</p>

    <div class="controls">
      <div class="card">
        <label for="n">n (which Fibonacci number)</label>
        <input id="n" type="number" value="12" min="0" max="10000" step="1"/>
        <div style="display:flex;gap:8px;margin-top:8px">
          <div style="flex:1">
            <label for="method">Method</label>
            <select id="method">
              <option value="fast">Fast doubling (O(log n))</option>
              <option value="iter">Iterative (O(n))</option>
              <option value="memo">Recursive with memo (O(n))</option>
              <option value="naive">Naive recursion (exponential) — limited</option>
            </select>
          </div>
          <div style="width:120px">
            <label for="mode">Mode</label>
            <select id="mode">
              <option value="value">Compute F(n)</option>
              <option value="sequence">Compute full sequence up to n</option>
            </select>
          </div>
        </div>

        <div style="display:flex;gap:8px;margin-top:10px">
          <button id="compute">Compute</button>
          <button id="clear" class="secondary">Clear output</button>
        </div>

        <div style="margin-top:10px" class="small">
          Notes: Values use BigInt for exact integer results. Naive recursion will be disabled for n &gt; 40 to avoid freezes.
        </div>
      </div>

      <div class="card">
        <label>Visualization controls</label>
        <div style="display:flex;gap:8px;align-items:center">
          <label style="min-width:100px" class="small">Draw first k squares</label>
          <input id="kDraw" type="number" value="8" min="1" max="20" style="width:84px;padding:8px;border-radius:8px"/>
        </div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="draw" class="secondary">Draw Spiral</button>
          <button id="animate" class="secondary">Animate</button>
        </div>

        <div style="margin-top:10px" class="small">
          The spiral is an approximation using quarter-circles inside Fibonacci squares. Scaling is automatic.
        </div>
      </div>

      <div class="card" style="min-width:240px;max-width:320px">
        <div class="flex-between">
          <div>
            <div class="small">Last computation</div>
            <div id="lastInfo" style="font-weight:700;font-size:15px;margin-top:6px">n = 12 • method = fast</div>
          </div>
          <div style="text-align:right">
            <div class="small">Time</div>
            <div id="timeTaken" style="font-weight:700;font-size:15px;margin-top:6px">—</div>
          </div>
        </div>

        <div style="margin-top:10px">
          <div class="small">Result (F(n))</div>
          <pre id="result" style="max-height:120px;overflow:auto">—</pre>
          <div style="display:flex;gap:8px">
            <button id="copyResult" class="secondary">Copy</button>
            <button id="showLatex" class="secondary">Show formula</button>
          </div>
        </div>
      </div>
    </div>

    <div class="output">
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <h3 style="margin:0;font-size:16px">Sequence & Ratios</h3>
          <div class="small">Golden ratio ≈ <span class="important">1.6180339887</span></div>
        </div>

        <div style="margin-top:8px" class="row">
          <div style="flex:1">
            <div class="small">Sequence (first numbers)</div>
            <div class="sequence panel" id="sequenceList">
              <!-- pills -->
            </div>
          </div>
          <div style="width:240px">
            <div class="small">Ratios F(k)/F(k-1)</div>
            <div class="ratio-table panel" id="ratios">
              <!-- ratios -->
            </div>
          </div>
        </div>

        <div style="margin-top:10px" class="small">
          You can copy the F(n) value or view the closed-form Binet-like idea. The fast-doubling method computes huge Fibonacci numbers quickly.
        </div>
      </div>

      <div class="panel">
        <h3 style="margin:0;font-size:16px">Fibonacci Spiral</h3>
        <canvas id="canvas" width="640" height="480" aria-label="Fibonacci spiral canvas"></canvas>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
          <div class="small">Color</div>
          <input id="color" type="color" value="#60a5fa" style="height:34px;border-radius:6px;border:none;background:transparent"/>
          <div style="flex:1"></div>
          <div class="small">Scale</div>
          <input id="scale" type="range" min="0.1" max="2.5" step="0.05" value="1.0" style="width:160px"/>
        </div>
      </div>
    </div>

    <footer>
      Implementation notes: Uses BigInt for exact values, fast doubling recursion for O(log n) performance, and long division of BigInt for decimal ratio display when needed.
    </footer>
  </div>

  <script>
    // Utilities and Fibonacci implementations using BigInt
    const el = id => document.getElementById(id);

    function fibIterative(n){
      n = Number(n);
      if(n === 0) return 0n;
      let a = 0n, b = 1n;
      for(let i=1;i<=n-1;i++){
        let t = a + b;
        a = b;
        b = t;
      }
      return b;
    }

    // naive recursive (Number) - only for small n to illustrate
    function fibNaiveNumber(n){
      if(n <= 1) return n;
      return fibNaiveNumber(n-1) + fibNaiveNumber(n-2);
    }

    // memoized recursion using BigInt
    function fibMemoBig(n, memo=new Map()){
      n = Number(n);
      if(n === 0) return 0n;
      if(n === 1) return 1n;
      if(memo.has(n)) return memo.get(n);
      let val = fibMemoBig(n-1, memo) + fibMemoBig(n-2, memo);
      memo.set(n, val);
      return val;
    }

    // fast doubling method returns F(n) as BigInt
    function fibFastDoubling(n){
      n = BigInt(n);
      function pair(k){
        if(k === 0n) return [0n, 1n];
        let [a,b] = pair(k >> 1n);
        // c = F(2m) = F(m) * (2*F(m+1) − F(m))
        let c = a * ((b << 1n) - a);
        // d = F(2m+1) = F(m)^2 + F(m+1)^2
        let d = a*a + b*b;
        if((k & 1n) === 0n) return [c,d];
        else return [d, c + d];
      }
      return pair(n)[0];
    }

    // compute sequence up to n using iterative for display (fast)
    function computeSequenceUpTo(n){
      n = Number(n);
      const seq = [];
      if(n >= 0) seq.push(0n);
      if(n >= 1) seq.push(1n);
      for(let i=2;i<=n;i++){
        seq.push(seq[i-1] + seq[i-2]);
      }
      return seq;
    }

    // BigInt division giving decimal approximation to "places" digits
    function bigRatioDecimal(a, b, places = 10){
      // a and b are BigInt
      if(b === 0n) return "NaN";
      const intPart = a / b;
      let rem = a % b;
      if(places <= 0) return intPart.toString();
      let out = intPart.toString() + ".";
      for(let i=0;i<places;i++){
        rem *= 10n;
        let digit = rem / b;
        out += digit.toString();
        rem = rem % b;
        if(rem === 0n){
          // pad remaining zeros
          for(let j=i+1;j<places;j++) out += "0";
          break;
        }
      }
      return out;
    }

    // UI wiring
    const $n = el('n'), $method = el('method'), $compute = el('compute'), $result = el('result');
    const $time = el('timeTaken'), $last = el('lastInfo'), $sequenceList = el('sequenceList'), $ratios = el('ratios');
    const $copy = el('copyResult'), $clear = el('clear'), $mode = el('mode');
    const $canvas = el('canvas'), ctx = $canvas.getContext('2d');
    const $draw = el('draw'), $animate = el('animate'), $kDraw = el('kDraw'), $color = el('color'), $scale = el('scale'), $showLatex = el('showLatex');

    function formatBigIntForDisplay(x){
      // show full number but with thin separators for readability (group every 3)
      let s = x.toString();
      // for negative not relevant
      let i = s.length;
      let parts = [];
      while(i > 3){
        parts.unshift(s.slice(i-3, i));
        i -= 3;
      }
      parts.unshift(s.slice(0,i));
      return parts.join(',');
    }

    function updateLastInfo(n, method){
      $last.textContent = `n = ${n} • method = ${method}`;
    }

    function computeValue(){
      const nVal = Number($n.value);
      const method = $method.value;
      const mode = $mode.value;
      if(Number.isNaN(nVal) || nVal < 0){
        alert('Please enter a non-negative integer for n.');
        return;
      }
      if(method === 'naive' && nVal > 40){
        if(!confirm('Naive recursion for n > 40 will be very slow. Continue?')) return;
      }

      updateLastInfo(nVal, method);
      $result.textContent = 'Computing...';
      $time.textContent = '...';

      setTimeout(()=>{ // allow UI update
        const t0 = performance.now();
        let res;
        try{
          if(method === 'fast') res = fibFastDoubling(nVal);
          else if(method === 'iter') res = fibIterative(nVal);
          else if(method === 'memo') res = fibMemoBig(nVal);
          else if(method === 'naive'){
            // use Number version for tiny n
            res = BigInt(fibNaiveNumber(nVal));
          }
        } catch(err){
          res = `Error: ${err}`;
        }
        const t1 = performance.now();
        const elapsed = (t1 - t0).toFixed(3) + ' ms';
        $time.textContent = elapsed;
        $result.textContent = (typeof res === 'bigint' ? formatBigIntForDisplay(res) : res.toString());
        // if mode==sequence, compute sequence fast for display
        if(mode === 'sequence'){
          const seq = computeSequenceUpTo(nVal);
          renderSequence(seq);
          renderRatios(seq);
        } else {
          // show sequence up to min(20,n) for convenience
          const seq = computeSequenceUpTo(Math.min(nVal, 20));
          renderSequence(seq);
          renderRatios(seq);
        }
      }, 10);
    }

    function renderSequence(seq){
      $sequenceList.innerHTML = '';
      seq.forEach((v, idx) => {
        const pill = document.createElement('div');
        pill.className = 'pill';
        pill.title = `F(${idx})`;
        pill.textContent = `F(${idx}) = ${idx <= 20 ? v.toString() : abbreviateBigInt(v)}`;
        $sequenceList.appendChild(pill);
      });
    }

    function abbreviateBigInt(bn){
      const s = bn.toString();
      if(s.length <= 22) return s;
      return s.slice(0,12) + '…' + s.slice(-6);
    }

    function renderRatios(seq){
      $ratios.innerHTML = '';
      if(seq.length < 2){
        $ratios.textContent = 'Ratios not available (need at least 2 terms).';
        return;
      }
      const table = document.createElement('div');
      seq.forEach((v, idx) => {
        if(idx === 0) return;
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.justifyContent = 'space-between';
        row.style.fontSize = '13px';
        row.style.padding = '6px 4px';
        row.style.borderBottom = '1px dashed rgba(255,255,255,0.02)';
        let ratioStr;
        try {
          ratioStr = bigRatioDecimal(v, seq[idx-1], 10);
        } catch(e) {
          ratioStr = 'N/A';
        }
        row.innerHTML = `<div>F(${idx})/F(${idx-1})</div><div style="color:var(--accent)">${ratioStr}</div>`;
        table.appendChild(row);
      });
      $ratios.appendChild(table);
    }

    // Copy result
    $copy.addEventListener('click', ()=>{
      const txt = $result.textContent;
      navigator.clipboard?.writeText(txt).then(()=> alert('Copied to clipboard'), ()=> alert('Copy failed'));
    });

    $compute.addEventListener('click', computeValue);
    $clear.addEventListener('click', ()=>{
      $result.textContent = '—';
      $time.textContent = '—';
      $sequenceList.innerHTML = '';
      $ratios.innerHTML = '';
    });

    // Show formula (simple explanation)
    $showLatex.addEventListener('click', ()=>{
      alert('Fibonacci recurrence: F(0)=0, F(1)=1, and F(n)=F(n-1)+F(n-2).\n\nClosed form (Binet):\nF(n) = (phi^n - psi^n)/sqrt(5), where phi = (1+sqrt(5))/2, psi=(1-sqrt(5))/2.\n\nFor large n, psi^n → 0, so F(n) ≈ phi^n / sqrt(5).');
    });

    // Canvas drawing of Fibonacci squares and spiral
    function clearCanvas(){
      ctx.clearRect(0,0,$canvas.width,$canvas.height);
      // subtle background grid
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(0,0,$canvas.width,$canvas.height);
    }

    function drawSpiral(k){
      clearCanvas();
      const color = $color.value;
      const scale = Number($scale.value);
      // compute fibonacci numbers for squares
      const kMax = Math.max(1, Math.min(20, k));
      const fibs = [];
      fibs.push(1n); // treat F(1)=1
      fibs.push(1n);
      for(let i=2;i<kMax;i++) fibs.push(fibs[i-1] + fibs[i-2]);

      // convert to Number for size calculations (use approximate if too big)
      const sizes = fibs.map(b => {
        const s = b.toString();
        // if digits too many, use magnitude only
        if(s.length > 12) {
          // approximate using leading digits
          return Math.pow(10, s.length - 1);
        }
        return Number(b);
      });

      // layout squares starting from center
      // We'll place squares in a spiral: right, up, left, down repeating
      const directions = [[1,0],[0,-1],[-1,0],[0,1]];
      // compute bounding box of the layout to scale to canvas
      let x = 0, y = 0;
      let minX = 0, minY = 0, maxX = sizes[0], maxY = sizes[0];
      let rects = [];
      rects.push({x:0,y:0,w:sizes[0],h:sizes[0]});
      let cx = 0, cy = 0;
      for(let i=1;i<kMax;i++){
        const dir = directions[(i-1) % 4];
        // position new square adjacent to previous square based on direction
        if(dir[0] === 1) { // right
          x = rects[i-1].x + rects[i-1].w;
          y = rects[i-1].y + rects[i-1].h - sizes[i];
        } else if(dir[0] === -1) { // left
          x = rects[i-1].x - sizes[i];
          y = rects[i-1].y;
        } else if(dir[1] === -1) { // up
          x = rects[i-1].x;
          y = rects[i-1].y - sizes[i];
        } else { // down
          x = rects[i-1].x + rects[i-1].w - sizes[i];
          y = rects[i-1].y + rects[i-1].h;
        }
        rects.push({x,y,w:sizes[i],h:sizes[i]});
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x + sizes[i]);
        maxY = Math.max(maxY, y + sizes[i]);
      }

      const contentW = maxX - minX;
      const contentH = maxY - minY;
      const margin = 20;
      const canvasW = $canvas.width;
      const canvasH = $canvas.height;
      const fitScale = Math.min((canvasW - margin) / contentW, (canvasH - margin) / contentH) * scale;
      // center offset
      const offsetX = (canvasW - contentW * fitScale) / 2 - minX * fitScale;
      const offsetY = (canvasH - contentH * fitScale) / 2 - minY * fitScale;

      // draw squares
      ctx.lineWidth = 2;
      for(let i=0;i<rects.length;i++){
        const r = rects[i];
        ctx.fillStyle = i % 2 === 0 ? shadeColor(color, -8) : shadeColor(color, 8);
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.beginPath();
        ctx.rect(Math.round(offsetX + r.x * fitScale), Math.round(offsetY + r.y * fitScale), Math.round(r.w * fitScale), Math.round(r.h * fitScale));
        ctx.fill();
        ctx.stroke();
      }

      // draw spiral arcs (quarter-circles) inside each square
      ctx.strokeStyle = color;
      ctx.lineWidth = Math.max(2, Math.round(2 * fitScale / 2));
      ctx.beginPath();
      for(let i=0;i<rects.length;i++){
        const r = rects[i];
        // choose arc center and radius based on square and orientation
        // orientation cycles: 0:right,1:up,2:left,3:down (same as before)
        const ori = (i-1) >= 0 ? ((i-1) % 4) : 0;
        const x0 = offsetX, y0 = offsetY;
        let cxArc, cyArc, rArc, start, end;
        if(i === 0){
          // first square draw quarter circle from bottom-left to bottom-right (approx)
          cxArc = offsetX + r.x + r.w;
          cyArc = offsetY + r.y + r.h;
          rArc = r.w * fitScale;
          start = Math.PI;
          end = Math.PI * 1.5;
        } else {
          switch(ori){
            case 0: // right
              cxArc = offsetX + rects[i-1].x + rects[i-1].w;
              cyArc = offsetY + r.y + r.h;
              start = Math.PI;
              end = Math.PI*1.5;
              break;
            case 1: // up
              cxArc = offsetX + r.x;
              cyArc = offsetY + rects[i-1].y;
              start = Math.PI*1.5;
              end = Math.PI*2;
              break;
            case 2: // left
              cxArc = offsetX + r.x;
              cyArc = offsetY + r.y;
              start = 0;
              end = Math.PI*0.5;
              break;
            case 3: // down
              cxArc = offsetX + r.x + r.w;
              cyArc = offsetY + r.y;
              start = Math.PI*0.5;
              end = Math.PI;
              break;
            default:
              cxArc = offsetX + r.x;
              cyArc = offsetY + r.y;
              start = 0; end = Math.PI*0.5;
          }
          rArc = r.w * fitScale;
        }
        ctx.beginPath();
        ctx.arc(cxArc, cyArc, Math.abs(rArc), start, end);
        ctx.stroke();
      }
    }

    // utility to darken/lighten color hex
    function shadeColor(hex, percent) {
      // hex like #rrggbb
      let c = hex.substring(1);
      const num = parseInt(c,16);
      let r = (num >> 16) + percent;
      let g = ((num >> 8) & 0x00FF) + percent;
      let b = (num & 0x0000FF) + percent;
      r = Math.max(Math.min(255,r),0);
      g = Math.max(Math.min(255,g),0);
      b = Math.max(Math.min(255,b),0);
      return "#" + (r<<16 | g<<8 | b).toString(16).padStart(6,'0');
    }

    $draw.addEventListener('click', ()=>{
      let k = Number($kDraw.value);
      if(isNaN(k) || k < 1) k = 1;
      k = Math.min(20, Math.max(1,k));
      drawSpiral(k);
    });

    // simple animation showing increasing squares
    let animId = null;
    $animate.addEventListener('click', ()=>{
      if(animId !== null){
        cancelAnimationFrame(animId);
        animId = null;
        $animate.textContent = 'Animate';
        return;
      }
      let k = 1;
      const maxK = Math.min(16, Math.max(4, Number($kDraw.value)));
      $animate.textContent = 'Stop';
      function step(){
        drawSpiral(k);
        k++;
        if(k > maxK) k = 1;
        animId = requestAnimationFrame(()=> setTimeout(step, 700));
      }
      step();
    });

    // handle resizing canvas to device pixel ratio
    function resizeCanvas(){
      const dpr = window.devicePixelRatio || 1;
      const width = $canvas.clientWidth;
      const height = $canvas.clientHeight;
      $canvas.width = Math.round(width * dpr);
      $canvas.height = Math.round(height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      clearCanvas();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // initial render
    renderSequence(computeSequenceUpTo(12));
    renderRatios(computeSequenceUpTo(12));
    drawSpiral(8);

    // small helper: on Enter key in n input compute
    $n.addEventListener('keypress', (e)=>{
      if(e.key === 'Enter') computeValue();
    });
  </script>
</body>
</html>