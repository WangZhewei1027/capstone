<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bellman-Ford Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        #graph {
            margin-top: 20px;
        }
        #output {
            margin-top: 20px;
            border: 1px solid #007BFF;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .node {
            display: inline-block;
            padding: 5px 10px;
        }
    </style>
</head>
<body>
    <h1>Bellman-Ford Algorithm Visualizer</h1>
    <div>
        <label for="edges">Enter Edges (e.g., A B 4, A C 2):</label><br>
        <textarea id="edges" rows="5" cols="30" placeholder="e.g., A B 4\nA C 2\nB C -1"></textarea><br>
        <label for="source">Enter Source Node (e.g., A):</label>
        <input id="source" type="text" placeholder="e.g., A"><br>
        <button onclick="runBellmanFord()">Run Bellman-Ford</button>
    </div>

    <div id="output"></div>

    <script>
        function runBellmanFord() {
            const edgesInput = document.getElementById('edges').value.trim();
            const source = document.getElementById('source').value.trim();
            const edges = edgesInput.split('\n').map(line => {
                const [start, end, weight] = line.split(' ');
                return { start, end, weight: parseInt(weight) };
            });
            
            const nodes = new Set();
            edges.forEach(edge => {
                nodes.add(edge.start);
                nodes.add(edge.end);
            });
            
            const distances = {};
            const predecessors = {};
            const numNodes = nodes.size;

            // Step 1: Initialize distances from source to all other nodes as INFINITE
            nodes.forEach(node => {
                distances[node] = Infinity;
                predecessors[node] = null;
            });
            distances[source] = 0;

            // Step 2: Relax edges up to |V| - 1 times
            for (let i = 1; i <= numNodes - 1; i++) {
                edges.forEach(({ start, end, weight }) => {
                    if (distances[start] !== Infinity && distances[start] + weight < distances[end]) {
                        distances[end] = distances[start] + weight;
                        predecessors[end] = start;
                    }
                });
            }

            // Step 3: Check for negative-weight cycles
            let hasNegativeCycle = false;
            edges.forEach(({ start, end, weight }) => {
                if (distances[start] !== Infinity && distances[start] + weight < distances[end]) {
                    hasNegativeCycle = true;
                }
            });

            // Display results
            const outputDiv = document.getElementById('output');
            outputDiv.innerHTML = '';
            if (hasNegativeCycle) {
                outputDiv.innerHTML = 'Negative weight cycle detected!';
            } else {
                outputDiv.innerHTML = '<h3>Distances:</h3>';
                for (const node of nodes) {
                    outputDiv.innerHTML += `${node}: ${distances[node] === Infinity ? 'Infinity' : distances[node]}<br>`;
                }
                outputDiv.innerHTML += '<h3>Predecessors:</h3>';
                for (const node of nodes) {
                    outputDiv.innerHTML += `${node}: ${predecessors[node] !== null ? predecessors[node] : 'None'}<br>`;
                }
            }
        }
    </script>
</body>
</html>