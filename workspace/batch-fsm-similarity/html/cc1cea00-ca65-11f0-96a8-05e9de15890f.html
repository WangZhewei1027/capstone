<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hash Map Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#38bdf8;
      --muted:#94a3b8;
      --card:#071025;
      --ok:#10b981;
      --warn:#f59e0b;
      --danger:#ef4444;
      color-scheme: dark;
    }
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071021 0%, #07172b 100%);color:#e6eef6;}
    header{padding:18px 22px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;gap:18px}
    header h1{margin:0;font-size:18px;letter-spacing:0.2px}
    .container{display:grid;grid-template-columns:360px 1fr;gap:18px;padding:18px;align-items:start}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03)}
    .controls{display:flex;flex-direction:column;gap:10px}
    label{font-size:13px;color:var(--muted);margin-bottom:6px;display:block}
    input[type="text"],select,input[type="number"]{width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
    .row{display:flex;gap:8px}
    button{padding:8px 10px;border-radius:8px;border:0;background:var(--accent);color:#042029;cursor:pointer;font-weight:600}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.05);color:var(--muted);font-weight:600}
    .small{padding:6px 8px;font-size:13px}
    .muted{color:var(--muted);font-size:13px}
    .vis{padding:14px;display:flex;flex-direction:column;gap:12px}
    .grid{display:flex;gap:8px;flex-wrap:wrap}
    .bucket{width:88px;min-height:88px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));border:1px solid rgba(255,255,255,0.03);padding:8px;position:relative;box-shadow:0 6px 20px rgba(0,0,0,0.35)}
    .bucket .index{position:absolute;right:8px;bottom:6px;font-size:12px;color:var(--muted)}
    .entry{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:6px;padding:6px;font-size:13px;margin-bottom:6px;display:flex;justify-content:space-between;gap:6px;border:1px solid rgba(255,255,255,0.02)}
    .hashline{font-size:13px;color:var(--muted);display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .log{background:#021325;border-radius:8px;padding:10px;font-family:monospace;height:160px;overflow:auto;border:1px solid rgba(255,255,255,0.03)}
    .status{display:flex;gap:8px;align-items:center;padding:8px;border-radius:8px}
    .pill{font-size:12px;padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03)}
    .highlight{box-shadow:0 0 0 3px rgba(56,189,248,0.08) inset,0 8px 24px rgba(2,6,23,0.6);border-color:var(--accent)!important}
    .ok{border-color:var(--ok);box-shadow:0 0 0 3px rgba(16,185,129,0.06) inset}
    .warn{border-color:var(--warn)}
    .danger{border-color:var(--danger)}
    .controls .actions{display:flex;gap:8px;flex-wrap:wrap}
    .muted-sm{font-size:12px;color:var(--muted)}
    footer{padding:12px 22px;color:var(--muted);font-size:13px;border-top:1px solid rgba(255,255,255,0.02);display:flex;gap:12px;align-items:center}
    .kbd{background:rgba(255,255,255,0.03);padding:4px 8px;border-radius:6px;border:1px solid rgba(255,255,255,0.02);font-family:monospace}
    .controls .option-row{display:flex;gap:8px;align-items:center}
    .small-muted{font-size:12px;color:var(--muted)}
    .entry-key{font-weight:700}
    .entry-val{color:var(--muted);font-size:12px}
    .bucket-empty{opacity:0.55;font-size:13px;color:var(--muted)}
    .bucket .tombstone{opacity:0.5;font-size:12px;color:var(--warn);font-style:italic}
    .controls hr{border:0;border-top:1px dashed rgba(255,255,255,0.02);margin:8px 0}
    .switch{display:flex;gap:8px;align-items:center}
    .note{font-size:13px;color:var(--muted);margin-top:6px}
  </style>
</head>
<body>
  <header>
    <h1>Hash Map Visualizer</h1>
    <div class="muted-sm">Interactive demo: separate chaining & linear probing, collisions, resizing, and lookup</div>
  </header>

  <div class="container">
    <div class="panel controls">
      <div>
        <label>Collision Strategy</label>
        <select id="strategy">
          <option value="chaining">Separate Chaining (Linked lists)</option>
          <option value="probing">Open Addressing (Linear Probing)</option>
        </select>
      </div>

      <div class="row">
        <div style="flex:1">
          <label>Key</label>
          <input id="key" type="text" placeholder="e.g. apple or 42" />
        </div>
        <div style="width:120px">
          <label>Value</label>
          <input id="value" type="text" placeholder="value" />
        </div>
      </div>

      <div class="actions">
        <button id="putBtn">Put</button>
        <button id="getBtn" class="ghost">Get</button>
        <button id="removeBtn" class="ghost">Remove</button>
        <button id="clearBtn" class="ghost small">Clear</button>
      </div>

      <hr />

      <div class="option-row">
        <label style="width:140px">Initial Capacity</label>
        <input id="capacity" type="number" value="8" min="4" max="256" />
      </div>
      <div class="option-row">
        <label style="width:140px">Resize Enabled</label>
        <input id="resizeToggle" type="checkbox" checked />
      </div>
      <div class="option-row">
        <label style="width:140px">Load Factor Threshold</label>
        <input id="threshold" type="number" step="0.1" value="0.7" min="0.2" max="0.95" />
      </div>

      <div style="margin-top:10px;display:flex;gap:8px">
        <button id="randomBtn" class="small">Insert Random</button>
        <button id="fillBtn" class="small ghost">Fill to Resize</button>
        <button id="rebuildBtn" class="small ghost">Rebuild</button>
      </div>

      <hr />

      <div class="muted-sm">Visualization controls</div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="toggleInternals" class="small ghost">Toggle Internals</button>
        <button id="stepMode" class="small ghost">Step Mode: Off</button>
      </div>

      <hr />
      <div>
        <div class="muted-sm">Stats</div>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
          <div class="pill">Capacity: <span id="statCapacity">-</span></div>
          <div class="pill">Size: <span id="statSize">-</span></div>
          <div class="pill">Load: <span id="statLoad">-</span></div>
        </div>
        <div class="note">Keys are treated as strings. Hash function shown during operations. Resize will rehash entries.</div>
      </div>

      <hr />
      <div class="muted-sm">Operation Log</div>
      <div id="log" class="log"></div>
    </div>

    <div class="panel vis">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="hashline"><strong id="modeLabel">Separate Chaining</strong><span class="muted">• Visualizing buckets</span></div>
        <div class="status">
          <div class="pill">Hash: <span id="lastHash">-</span></div>
          <div class="pill">Index: <span id="lastIndex">-</span></div>
        </div>
      </div>

      <div id="buckets" class="grid" style="padding:8px;min-height:120px"></div>

      <div style="display:flex;gap:8px;align-items:center">
        <div class="muted-sm">Legend:</div>
        <div class="pill">occupied</div>
        <div class="pill" style="border-color:var(--warn)">tombstone (probing)</div>
        <div class="pill" style="border-color:rgba(255,255,255,0.02)">empty</div>
      </div>
      <div class="muted-sm" style="margin-top:6px">Tip: Use small capacities like 4-16 to better observe collisions and resizing.</div>
    </div>
  </div>

  <footer>
    <div class="muted-sm">This demo implements a simple HashMap with two strategies. For demonstration only — not production-safe.</div>
    <div style="margin-left:auto" class="muted-sm">Author: Interactive Demo • Hashing: polynomial rolling (strings)</div>
  </footer>

  <script>
    // HashMap visualizer
    (function(){
      // Utility functions
      function log(...args){
        const el = document.getElementById('log');
        const line = document.createElement('div');
        line.textContent = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
        el.appendChild(line);
        el.scrollTop = el.scrollHeight;
      }
      function assert(b, msg){ if(!b) throw new Error(msg || 'Assertion failed'); }

      // Simple stable hash function for strings/numbers
      function hashString(key){
        // Convert to string
        const s = String(key);
        // polynomial rolling hash base 127 mod large int (JavaScript safe)
        let h = 2166136261 >>> 0; // FNV offset basis
        for(let i=0;i<s.length;i++){
          h ^= s.charCodeAt(i);
          h = Math.imul(h, 16777619) >>> 0; // FNV prime
        }
        return h >>> 0;
      }

      // HashMap implementations
      class HashMap {
        constructor({capacity=8, strategy='chaining', resizeEnabled=true, loadFactor=0.7, onVisualUpdate=null, stepMode=false}={}){
          this.capacity = Math.max(4, capacity|0);
          this.strategy = strategy;
          this.resizeEnabled = !!resizeEnabled;
          this.loadFactor = loadFactor;
          this.size = 0;
          this.onVisualUpdate = onVisualUpdate; // callback to update UI
          this.stepMode = stepMode;

          // internal representation
          if(this.strategy === 'chaining') this._buckets = new Array(this.capacity).fill(null).map(()=>[]);
          else this._buckets = new Array(this.capacity).fill(null); // for probing: null = empty, {k,v} = entry, tombstone = special
          this._TOMBSTONE = {tombstone:true};
        }

        _indexFor(key){
          const h = hashString(key);
          const idx = h % this.capacity;
          return {hash:h, index:idx};
        }

        _shouldResize(){
          if(!this.resizeEnabled) return false;
          return this.size / this.capacity > this.loadFactor;
        }

        _resize(newCapacity){
          const old = {buckets: this._buckets, capacity: this.capacity};
          this.capacity = Math.max(4, newCapacity|0);
          if(this.strategy === 'chaining') this._buckets = new Array(this.capacity).fill(null).map(()=>[]);
          else this._buckets = new Array(this.capacity).fill(null);
          const oldSize = this.size;
          this.size = 0;
          // Reinsert entries
          if(this.strategy === 'chaining'){
            for(let bucket of old.buckets){
              for(let entry of bucket){
                this.put(entry.k, entry.v, /*rebuilding*/true);
              }
            }
          } else {
            for(let slot of old.buckets){
              if(slot && slot !== this._TOMBSTONE){
                this.put(slot.k, slot.v, /*rebuilding*/true);
              }
            }
          }
          log(`Resized: ${old.capacity} -> ${this.capacity}. Rehashed ${oldSize} entries.`);
          this._visualUpdate('resize');
        }

        _visualUpdate(op, details){
          if(this.onVisualUpdate) this.onVisualUpdate({op, details, map:this});
        }

        put(key, value, rebuilding=false){
          const {hash, index} = this._indexFor(key);
          this._visualUpdate('hash', {hash, index, key, value});
          if(this.strategy === 'chaining'){
            const bucket = this._buckets[index];
            // find if key exists
            const existing = bucket.find(e => e.k === key);
            if(existing){
              existing.v = value;
              this._visualUpdate('put_replace', {key, value, index});
              if(!rebuilding) log(`Updated key "${key}" at bucket ${index}.`);
              return;
            }
            bucket.push({k:key, v:value, h:hash});
            this.size++;
            this._visualUpdate('put', {key, value, index});
            if(!rebuilding) log(`Inserted "${key}" -> "${value}" at bucket ${index}.`);
            if(this._shouldResize()) this._resize(this.capacity * 2);
          } else {
            // linear probing insertion
            let i = index;
            let firstTomb = -1;
            for(let probe=0; probe < this.capacity; probe++){
              const slot = this._buckets[i];
              this._visualUpdate('probing', {probeIndex:i, probeStep:probe});
              if(slot === null){
                const place = (firstTomb >= 0) ? firstTomb : i;
                this._buckets[place] = {k:key, v:value, h:hash};
                this.size++;
                this._visualUpdate('put', {key, value, index:place, probeSteps:probe+1});
                if(!rebuilding) log(`Inserted "${key}" -> "${value}" at index ${place} after ${probe+1} probes.`);
                if(this._shouldResize()) this._resize(this.capacity * 2);
                return;
              } else if(slot === this._TOMBSTONE){
                if(firstTomb < 0) firstTomb = i;
              } else if(slot.k === key){
                slot.v = value;
                this._visualUpdate('put_replace', {key, value, index:i});
                if(!rebuilding) log(`Updated key "${key}" at index ${i}.`);
                return;
              }
              i = (i+1) % this.capacity;
            }
            // table full (shouldn't happen if resizing enabled)
            if(firstTomb >= 0){
              this._buckets[firstTomb] = {k:key,v:value,h:hash};
              this.size++;
              this._visualUpdate('put', {key, value, index:firstTomb, probeSteps:this.capacity});
              if(!rebuilding) log(`Inserted at tombstone slot ${firstTomb}.`);
            } else {
              log('HashMap full, cannot insert');
            }
          }
        }

        get(key){
          const {hash, index} = this._indexFor(key);
          this._visualUpdate('hash', {hash, index, key});
          if(this.strategy === 'chaining'){
            const bucket = this._buckets[index];
            const found = bucket.find(e => e.k === key);
            this._visualUpdate('get', {key, index, found:!!found});
            if(found){ log(`Found "${key}" -> "${found.v}" at bucket ${index}.`); return found.v; }
            log(`Key "${key}" not found in bucket ${index}.`); return undefined;
          } else {
            let i = index;
            for(let probe=0; probe < this.capacity; probe++){
              const slot = this._buckets[i];
              this._visualUpdate('probing', {probeIndex:i, probeStep:probe});
              if(slot === null){
                this._visualUpdate('get', {key, index:i, found:false});
                log(`Key "${key}" not found after ${probe+1} probes (empty slot).`);
                return undefined;
              } else if(slot === this._TOMBSTONE){
                // continue probing
              } else if(slot.k === key){
                this._visualUpdate('get', {key, index:i, found:true});
                log(`Found "${key}" -> "${slot.v}" at index ${i} after ${probe+1} probes.`);
                return slot.v;
              }
              i = (i+1) % this.capacity;
            }
            this._visualUpdate('get', {key, index:-1, found:false});
            log(`Key "${key}" not found after full table probe.`);
            return undefined;
          }
        }

        remove(key){
          const {hash, index} = this._indexFor(key);
          this._visualUpdate('hash', {hash, index, key});
          if(this.strategy === 'chaining'){
            const bucket = this._buckets[index];
            const idx = bucket.findIndex(e => e.k === key);
            if(idx >= 0){
              const removed = bucket.splice(idx,1)[0];
              this.size--;
              this._visualUpdate('remove', {key, index});
              log(`Removed "${key}" from bucket ${index}.`);
              return removed.v;
            }
            log(`Key "${key}" not found to remove.`);
            return undefined;
          } else {
            let i = index;
            for(let probe=0; probe < this.capacity; probe++){
              const slot = this._buckets[i];
              this._visualUpdate('probing', {probeIndex:i, probeStep:probe});
              if(slot === null){
                this._visualUpdate('remove', {key, index:i, found:false});
                log(`Key "${key}" not found to remove (empty slot at ${i}).`);
                return undefined;
              } else if(slot === this._TOMBSTONE){
                // continue
              } else if(slot.k === key){
                const val = slot.v;
                this._buckets[i] = this._TOMBSTONE;
                this.size--;
                this._visualUpdate('remove', {key, index:i, found:true});
                log(`Removed "${key}" at index ${i} (tombstone left).`);
                return val;
              }
              i = (i+1) % this.capacity;
            }
            this._visualUpdate('remove', {key, index:-1, found:false});
            log(`Key "${key}" not found to remove after full probe.`);
            return undefined;
          }
        }

        entries(){
          const out = [];
          if(this.strategy === 'chaining'){
            for(let bucket of this._buckets){
              for(let e of bucket) out.push([e.k,e.v]);
            }
          } else {
            for(let slot of this._buckets){
              if(slot && slot !== this._TOMBSTONE) out.push([slot.k, slot.v]);
            }
          }
          return out;
        }

        clear(){
          this.size = 0;
          if(this.strategy === 'chaining') this._buckets = new Array(this.capacity).fill(null).map(()=>[]);
          else this._buckets = new Array(this.capacity).fill(null);
          this._visualUpdate('clear');
        }
      }

      // UI wiring
      const strategyEl = document.getElementById('strategy');
      const keyEl = document.getElementById('key');
      const valueEl = document.getElementById('value');
      const putBtn = document.getElementById('putBtn');
      const getBtn = document.getElementById('getBtn');
      const removeBtn = document.getElementById('removeBtn');
      const clearBtn = document.getElementById('clearBtn');
      const capacityEl = document.getElementById('capacity');
      const resizeToggle = document.getElementById('resizeToggle');
      const thresholdEl = document.getElementById('threshold');
      const randomBtn = document.getElementById('randomBtn');
      const fillBtn = document.getElementById('fillBtn');
      const rebuildBtn = document.getElementById('rebuildBtn');
      const bucketsEl = document.getElementById('buckets');
      const statCapacity = document.getElementById('statCapacity');
      const statSize = document.getElementById('statSize');
      const statLoad = document.getElementById('statLoad');
      const lastHash = document.getElementById('lastHash');
      const lastIndex = document.getElementById('lastIndex');
      const modeLabel = document.getElementById('modeLabel');
      const toggleInternals = document.getElementById('toggleInternals');
      const stepModeBtn = document.getElementById('stepMode');

      let showInternals = true;
      let stepMode = false;
      let visualPaused = false;

      function updateStepButton(){ stepModeBtn.textContent = `Step Mode: ${stepMode ? 'On' : 'Off'}`; }

      stepModeBtn.addEventListener('click', ()=>{
        stepMode = !stepMode; updateStepButton();
        hm.stepMode = stepMode;
      });

      toggleInternals.addEventListener('click', ()=>{
        showInternals = !showInternals;
        renderBuckets();
      });

      function makeMapFromUI(){
        const capacity = Math.max(4, parseInt(capacityEl.value) || 8);
        const strategy = strategyEl.value;
        const resizeEnabled = resizeToggle.checked;
        const loadFactor = parseFloat(thresholdEl.value) || 0.7;
        return new HashMap({
          capacity, strategy, resizeEnabled, loadFactor,
          onVisualUpdate: visualUpdate, stepMode
        });
      }

      let hm = makeMapFromUI();

      // Rebuild map if settings changed
      function rebuildFromSettings(){
        const entries = hm.entries();
        hm = makeMapFromUI();
        for(const [k,v] of entries) hm.put(k,v, true);
        renderBuckets();
        log('Rebuilt map with current settings.');
      }

      strategyEl.addEventListener('change', ()=>{
        modeLabel.textContent = (strategyEl.value === 'chaining') ? 'Separate Chaining' : 'Linear Probing';
        rebuildFromSettings();
      });

      capacityEl.addEventListener('change', ()=>{
        rebuildFromSettings();
      });

      resizeToggle.addEventListener('change', ()=>{ hm.resizeEnabled = resizeToggle.checked; });
      thresholdEl.addEventListener('change', ()=>{ hm.loadFactor = parseFloat(thresholdEl.value) || 0.7; });

      rebuildBtn.addEventListener('click', ()=>{ rebuildFromSettings(); });

      putBtn.addEventListener('click', async ()=>{
        const k = keyEl.value.trim();
        const v = valueEl.value;
        if(!k){ log('Key required'); return; }
        await hm.put(k, v);
        renderBuckets();
      });

      getBtn.addEventListener('click', async ()=>{
        const k = keyEl.value.trim();
        if(!k){ log('Key required'); return; }
        const r = await hm.get(k);
        renderBuckets();
      });

      removeBtn.addEventListener('click', async ()=>{
        const k = keyEl.value.trim();
        if(!k){ log('Key required'); return; }
        await hm.remove(k);
        renderBuckets();
      });

      clearBtn.addEventListener('click', ()=>{
        hm.clear();
        renderBuckets();
        log('Cleared map.');
      });

      randomBtn.addEventListener('click', ()=>{
        const rndKey = Math.random().toString(36).slice(2,8);
        const rndVal = Math.random().toString(36).slice(2,6);
        hm.put(rndKey, rndVal);
        log(`Random insert: ${rndKey} -> ${rndVal}`);
        renderBuckets();
      });

      fillBtn.addEventListener('click', ()=>{
        // Insert many entries to force collisions/resizing
        const base = ['aa','ab','ac','ad','ae','af','ag','ah','ai','aj','ak','al','am','an','ao','ap'];
        for(let i=0;i<base.length;i++){
          const k = base[i] + Math.floor(Math.random()*100);
          hm.put(k, 'v'+i);
        }
        renderBuckets();
        log('Inserted multiple keys to produce collisions/resizes.');
      });

      // Visualization: highlight steps and display buckets
      let lastVisual = {op:null, details:null};

      async function visualUpdate(evt){
        // evt: {op, details, map}
        lastVisual = evt;
        // display hash/index if present
        if(evt.details && typeof evt.details.hash !== 'undefined') lastHash.textContent = evt.details.hash;
        if(evt.details && typeof evt.details.index !== 'undefined') lastIndex.textContent = evt.details.index;
        else { /* keep previous */ }
        // show a brief highlight for certain ops
        if(evt.op === 'probing' && evt.details){
          // highlight probed index
          renderBuckets(evt);
        } else {
          renderBuckets(evt);
        }
        // if step mode is on, pause until user clicks map
        if(stepMode){
          visualPaused = true;
          log('[Step] Paused. Click anywhere on bucket area to continue.');
          await new Promise(resolve=>{
            function resume(){
              visualPaused = false;
              document.removeEventListener('click', resume);
              resolve();
            }
            document.addEventListener('click', resume);
          });
        }
      }

      // Render buckets to DOM
      function renderBuckets(highlightEvent){
        bucketsEl.innerHTML = '';
        statCapacity.textContent = hm.capacity;
        statSize.textContent = hm.size;
        statLoad.textContent = (hm.size / hm.capacity).toFixed(3);

        for(let i=0;i<hm.capacity;i++){
          const b = document.createElement('div');
          b.className = 'bucket';
          b.dataset.index = i;
          // highlight if probing events point here
          if(highlightEvent && highlightEvent.details){
            if(highlightEvent.details.probeIndex === i && highlightEvent.op === 'probing'){
              b.classList.add('highlight');
            }
            if(highlightEvent.op === 'hash' && highlightEvent.details.index === i){
              b.classList.add('ok');
            }
            if(highlightEvent.op === 'remove' && highlightEvent.details.index === i){
              b.classList.add('danger');
            }
            if(highlightEvent.op === 'put' && highlightEvent.details.index === i){
              b.classList.add('ok');
            }
          }

          if(hm.strategy === 'chaining'){
            const bucket = hm._buckets[i];
            if(bucket.length === 0){
              const empty = document.createElement('div');
              empty.className = 'bucket-empty';
              empty.textContent = '(empty)';
              b.appendChild(empty);
            } else {
              for(const e of bucket){
                const ent = document.createElement('div');
                ent.className = 'entry';
                const left = document.createElement('div');
                left.innerHTML = `<div class="entry-key">${escapeHtml(String(e.k))}</div><div class="entry-val">${escapeHtml(String(e.v))}</div>`;
                const right = document.createElement('div');
                right.className = 'muted-sm';
                right.textContent = e.h;
                ent.appendChild(left);
                ent.appendChild(right);
                b.appendChild(ent);
              }
            }
          } else {
            const slot = hm._buckets[i];
            if(slot === null){
              const empty = document.createElement('div');
              empty.className = 'bucket-empty';
              empty.textContent = '(empty)';
              b.appendChild(empty);
            } else if(slot === hm._TOMBSTONE){
              const t = document.createElement('div');
              t.className = 'bucket-empty tombstone';
              t.textContent = '(tombstone)';
              b.appendChild(t);
            } else {
              const ent = document.createElement('div');
              ent.className = 'entry';
              const left = document.createElement('div');
              left.innerHTML = `<div class="entry-key">${escapeHtml(String(slot.k))}</div><div class="entry-val">${escapeHtml(String(slot.v))}</div>`;
              const right = document.createElement('div');
              right.className = 'muted-sm';
              right.textContent = slot.h;
              ent.appendChild(left); ent.appendChild(right);
              b.appendChild(ent);
            }
          }
          const idx = document.createElement('div');
          idx.className = 'index';
          idx.textContent = i;
          b.appendChild(idx);

          bucketsEl.appendChild(b);
        }
      }

      // Escape for safety in UI
      function escapeHtml(s){
        return s.replace(/[&<>"']/g, (m)=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
      }

      // initial render
      renderBuckets();

      // Click handler on bucket area to allow step mode continuation
      bucketsEl.addEventListener('click', ()=>{ /* used by step-mode resume in visualUpdate via document click */ });

      // expose some utilities to console for debugging
      window.__hashmap_demo = {hm, renderBuckets, log};

      // Small welcome log
      log('HashMap visualizer ready. Strategy:', strategyEl.value, 'Capacity:', hm.capacity);
    })();
  </script>
</body>
</html>