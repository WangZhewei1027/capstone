<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Priority Queue (Binary Heap) — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --muted:#9aa7bb;
      --accent:#3ddc97;
      --accent2:#60a5fa;
      --card:#081223;
      --danger:#fb7185;
    }
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(180deg,#071026, #071027 60%);color:#cfe8ff}
    .wrap{max-width:1100px;margin:20px auto;padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
    h1{margin:6px 0 8px;font-size:20px}
    p.lead{margin:0 0 18px;color:var(--muted);font-size:13px}
    .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:14px}
    .card{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02);min-width:220px}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    input[type="text"], input[type="number"], select{width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;box-sizing:border-box}
    .row{display:flex;gap:8px}
    button{padding:8px 10px;border-radius:8px;border:0;background:var(--accent);color:#012017;cursor:pointer;font-weight:600}
    button.alt{background:var(--accent2);color:#071640}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
    button.danger{background:var(--danger);color:#4b0710}
    .small{padding:6px 8px;font-size:13px}
    .viz{display:flex;gap:12px;margin-top:14px}
    .left{flex:1;min-width:300px}
    .right{width:360px;min-width:260px}
    .arrayView{display:flex;flex-wrap:wrap;gap:8px;padding:10px;min-height:70px}
    .nodeBox{min-width:82px;flex:0 0 82px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:8px;padding:8px;text-align:center;border:1px solid rgba(255,255,255,0.03)}
    .muted{color:var(--muted);font-size:13px}
    .id{font-size:11px;color:var(--muted);margin-top:4px}
    .heapCanvas{background:transparent;min-height:320px;border-radius:8px;padding:6px;position:relative}
    .log{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));padding:8px;border-radius:8px;height:200px;overflow:auto;border:1px solid rgba(255,255,255,0.02)}
    .status{margin-top:8px;color:var(--muted);font-size:13px}
    .controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .info{font-size:13px;color:var(--muted);margin-top:10px}
    svg{width:100%;height:360px;display:block}
    .nodeCircle{fill:#07293a;stroke:rgba(255,255,255,0.06);stroke-width:1.5}
    .nodeText{font-size:12px;fill:#dff7ff;text-anchor:middle}
    .nodeSub{font-size:11px;fill:var(--muted);text-anchor:middle}
    .link{stroke:rgba(255,255,255,0.06);stroke-width:1.2}
    .highlight{filter:drop-shadow(0 6px 12px rgba(52,211,153,0.08));stroke:rgba(61,220,151,0.9);stroke-width:2}
    .swapAnim{animation:swapFlash 700ms ease}
    @keyframes swapFlash{
      0%{transform:scale(1)}
      50%{transform:scale(1.05)}
      100%{transform:scale(1)}
    }
    .footer{display:flex;justify-content:space-between;align-items:center;margin-top:12px;color:var(--muted);font-size:13px}
    .badge{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:999px}
    .extractedList{display:flex;flex-wrap:wrap;gap:6px;padding:8px;border-radius:6px}
    .chip{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:999px;font-size:13px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Priority Queue — Interactive Binary Heap Demo</h1>
    <p class="lead">This demo implements a priority queue using a binary heap (array-backed). Try enqueueing items with priorities, peek, dequeue, change priorities, and watch the heap (tree + array) update. Choose Min or Max behavior and enable stability (FIFO for equal priorities).</p>

    <div class="controls">
      <div class="card" style="flex:1;min-width:420px">
        <div style="display:flex;gap:10px;align-items:center">
          <div style="flex:1">
            <label>Item value (string)</label>
            <input id="itemValue" type="text" placeholder="e.g. task-A" value="task"/>
          </div>
          <div style="width:120px">
            <label>Priority (number)</label>
            <input id="itemPriority" type="number" value="5" />
          </div>
          <div style="width:140px">
            <label>Type</label>
            <select id="queueType">
              <option value="min">Min-Heap (smallest priority first)</option>
              <option value="max">Max-Heap (largest priority first)</option>
            </select>
          </div>
        </div>

        <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
          <button id="enqueueBtn">Enqueue</button>
          <button id="enqueueRand" class="alt small">Enqueue Random</button>
          <button id="dequeueBtn" class="ghost small">Dequeue</button>
          <button id="peekBtn" class="ghost small">Peek</button>
          <button id="dequeueAll" class="danger small">Dequeue All</button>
        </div>

        <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
          <div style="width:140px">
            <label>Change priority by ID</label>
            <input id="changeId" type="text" placeholder="id e.g. 3" />
          </div>
          <div style="width:120px">
            <label>New priority</label>
            <input id="changePr" type="number" />
          </div>
          <div style="display:flex;align-items:end">
            <button id="changeBtn" class="small">Change</button>
          </div>
        </div>

        <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
          <label style="margin:0"><input id="stableChk" type="checkbox" /> Stable (preserve insertion order for ties)</label>
          <label style="margin:0"><input id="animChk" type="checkbox" checked /> Animate swaps</label>
          <label style="margin:0">Speed <input id="speedRange" type="range" min="50" max="1200" value="300" style="vertical-align:middle" /></label>
          <button id="clearBtn" class="ghost small">Clear</button>
        </div>

      </div>

      <div class="card">
        <label>Current Queue</label>
        <div class="muted" id="meta">size: 0 — implementation: binary heap</div>
        <div style="margin-top:8px" class="arrayView" id="arrayView"></div>
        <div class="status" id="statusLine"></div>
      </div>
    </div>

    <div class="viz">
      <div class="left card">
        <label>Heap tree (visual)</label>
        <div class="heapCanvas">
          <svg id="heapSvg" viewBox="0 0 1000 360" preserveAspectRatio="xMidYMid meet"></svg>
        </div>
      </div>

      <div class="right card">
        <label>Logs & Extracted</label>
        <div class="log" id="logArea"></div>
        <div class="info" style="margin-top:8px">
          Extracted (dequeued in order):
          <div class="extractedList" id="extracted"></div>
        </div>

        <div class="info">
          Complexity: Enqueue/Dequeue — O(log n) average & worst, Peek — O(1). This demo uses a binary heap stored in an array. When "stable" is enabled, a monotonic insertion index breaks ties preserving FIFO order for equal priorities.
        </div>
      </div>
    </div>

    <div class="footer">
      <div class="badge">Implementation: binary heap (array)</div>
      <div class="muted">Notes: equal priorities use the selected stability behavior. Try inserting many items and watch how the heap reorders.</div>
    </div>
  </div>

  <script>
    // Priority Queue (binary heap) implementation with visualization callbacks.
    (function(){
      // Utility sleep
      const sleep = ms => new Promise(r=>setTimeout(r,ms));

      class PriorityQueue {
        constructor({type='min', stable=false, onUpdate=null, animate=true, animationDelay=250} = {}) {
          this.heap = []; // array of nodes
          this.type = type; // 'min' or 'max'
          this.stable = stable;
          this._insertCounter = 0; // for stable tie-break
          this.onUpdate = onUpdate;
          this.animate = animate;
          this.animationDelay = animationDelay;
        }

        size(){ return this.heap.length; }
        isEmpty(){ return this.size() === 0; }

        // comparator returns true if a has higher priority than b (i.e., should be above)
        _cmp(a,b){
          if (a.priority === b.priority) {
            if (this.stable) {
              // lower insertOrder means earlier insertion -> higher priority for ties in min-heap
              return (this.type === 'min') ? (a.insertOrder < b.insertOrder) : (a.insertOrder > b.insertOrder);
            }
            return false; // treat as equal
          }
          return (this.type === 'min') ? (a.priority < b.priority) : (a.priority > b.priority);
        }

        // swap with animation/update
        async _swap(i,j){
          const h = this.heap;
          const tmp = h[i];
          h[i] = h[j];
          h[j] = tmp;
          if (this.onUpdate) {
            this.onUpdate({type:'swap', indices:[i,j], heap:this.heap.slice()});
          }
          if (this.animate) await sleep(this.animationDelay);
        }

        async enqueue(value, priority=0){
          const node = {id: ++PriorityQueue._UID, value: String(value), priority: Number(priority), insertOrder: this._insertCounter++};
          this.heap.push(node);
          if (this.onUpdate) this.onUpdate({type:'push', index:this.heap.length-1, node, heap:this.heap.slice()});
          await this._heapifyUp(this.heap.length-1);
          if (this.onUpdate) this.onUpdate({type:'update', heap:this.heap.slice()});
          return node;
        }

        peek(){
          return this.heap[0] || null;
        }

        async dequeue(){
          if (this.isEmpty()) return null;
          const root = this.heap[0];
          if (this.heap.length === 1) {
            this.heap.pop();
            if (this.onUpdate) this.onUpdate({type:'pop', heap:this.heap.slice()});
            return root;
          }
          // replace root with last and heapify down
          this.heap[0] = this.heap.pop();
          if (this.onUpdate) this.onUpdate({type:'replaceRoot', heap:this.heap.slice()});
          await this._heapifyDown(0);
          if (this.onUpdate) this.onUpdate({type:'update', heap:this.heap.slice()});
          return root;
        }

        async changePriorityById(id, newPriority){
          const idx = this.heap.findIndex(n => String(n.id) === String(id));
          if (idx === -1) return false;
          const old = this.heap[idx].priority;
          this.heap[idx].priority = Number(newPriority);
          if (this.onUpdate) this.onUpdate({type:'change', index:idx, node:this.heap[idx], heap:this.heap.slice()});
          // decide whether to bubble up or down
          if ((this.type === 'min' && this.heap[idx].priority < old) || (this.type === 'max' && this.heap[idx].priority > old)) {
            await this._heapifyUp(idx);
          } else {
            await this._heapifyDown(idx);
          }
          if (this.onUpdate) this.onUpdate({type:'update', heap:this.heap.slice()});
          return true;
        }

        async removeById(id){
          const idx = this.heap.findIndex(n => String(n.id) === String(id));
          if (idx === -1) return false;
          if (idx === this.heap.length-1) {
            this.heap.pop();
            if (this.onUpdate) this.onUpdate({type:'pop', heap:this.heap.slice()});
            return true;
          }
          // swap with last and pop
          await this._swap(idx, this.heap.length-1);
          this.heap.pop();
          if (this.onUpdate) this.onUpdate({type:'removed', heap:this.heap.slice()});
          // fix heap at idx
          await this._heapifyUp(idx);
          await this._heapifyDown(idx);
          if (this.onUpdate) this.onUpdate({type:'update', heap:this.heap.slice()});
          return true;
        }

        async _heapifyUp(index){
          let i = index;
          while (i > 0) {
            const parent = Math.floor((i-1)/2);
            if (this._cmp(this.heap[i], this.heap[parent])) {
              await this._swap(i, parent);
              i = parent;
            } else break;
          }
        }

        async _heapifyDown(index){
          let i = index;
          const n = this.heap.length;
          while (true) {
            const left = 2*i + 1;
            const right = 2*i + 2;
            let candidate = i;
            if (left < n && this._cmp(this.heap[left], this.heap[candidate])) candidate = left;
            if (right < n && this._cmp(this.heap[right], this.heap[candidate])) candidate = right;
            if (candidate !== i) {
              await this._swap(i, candidate);
              i = candidate;
            } else break;
          }
        }

        clear(){
          this.heap = [];
          this._insertCounter = 0;
          if (this.onUpdate) this.onUpdate({type:'clear', heap:this.heap.slice()});
        }
      }
      // static unique id counter
      PriorityQueue._UID = 0;

      // ----- UI wiring & visualization -----
      const svg = document.getElementById('heapSvg');
      const arrayView = document.getElementById('arrayView');
      const logArea = document.getElementById('logArea');
      const extractedDiv = document.getElementById('extracted');
      const meta = document.getElementById('meta');
      const statusLine = document.getElementById('statusLine');

      // controls
      const enqueueBtn = document.getElementById('enqueueBtn');
      const enqueueRandBtn = document.getElementById('enqueueRand');
      const dequeueBtn = document.getElementById('dequeueBtn');
      const peekBtn = document.getElementById('peekBtn');
      const dequeueAllBtn = document.getElementById('dequeueAll');
      const clearBtn = document.getElementById('clearBtn');
      const itemValue = document.getElementById('itemValue');
      const itemPriority = document.getElementById('itemPriority');
      const queueType = document.getElementById('queueType');
      const stableChk = document.getElementById('stableChk');
      const animChk = document.getElementById('animChk');
      const speedRange = document.getElementById('speedRange');
      const changeBtn = document.getElementById('changeBtn');
      const changeId = document.getElementById('changeId');
      const changePr = document.getElementById('changePr');

      // state
      let pq = null;
      let animInProgress = false;
      let extracted = [];

      function log(msg){
        const time = new Date().toLocaleTimeString();
        const el = document.createElement('div');
        el.style.marginBottom = '6px';
        el.innerHTML = `<span style="color:var(--muted);font-size:12px">[${time}]</span> ${msg}`;
        logArea.prepend(el);
      }

      function renderArrayView(heap){
        arrayView.innerHTML = '';
        if (!heap.length) {
          const e = document.createElement('div');
          e.className = 'muted';
          e.textContent = '(empty)';
          arrayView.appendChild(e);
          return;
        }
        heap.forEach((n, idx) => {
          const box = document.createElement('div');
          box.className = 'nodeBox';
          box.innerHTML = `<div style="font-weight:700">${escapeHtml(n.value)}</div>
                           <div class="muted">prio: ${n.priority}</div>
                           <div class="id">id:${n.id}${pq.stable ? ' • ord:'+n.insertOrder : ''}</div>
                           <div class="muted" style="margin-top:6px;font-size:12px">idx:${idx}</div>`;
          arrayView.appendChild(box);
        });
      }

      // simple escape
      function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

      function renderTree(heap, highlightIndices=[]){
        // draw nodes per index with positions
        const W = 1000, H = 360;
        const levels = Math.max(1, Math.ceil(Math.log2(heap.length+1)));
        svg.innerHTML = '';
        if (heap.length === 0) {
          const text = document.createElementNS('http://www.w3.org/2000/svg','text');
          text.setAttribute('x','500');
          text.setAttribute('y','180');
          text.setAttribute('text-anchor','middle');
          text.setAttribute('fill','var(--muted)');
          text.setAttribute('font-size','16');
          text.textContent = '(empty)';
          svg.appendChild(text);
          return;
        }

        const positions = []; // {x,y}
        const levelHeight = H / (levels + 1);

        for (let i=0;i<heap.length;i++){
          const level = Math.floor(Math.log2(i+1));
          const levelStart = Math.pow(2, level)-1;
          const posInLevel = i - levelStart;
          const nodesAtLevel = Math.pow(2, level);
          const gap = W / nodesAtLevel;
          const x = gap*(posInLevel + 0.5);
          const y = 30 + level * levelHeight;
          positions.push({x,y});
        }

        // draw links
        for (let i=1;i<heap.length;i++){
          const parent = Math.floor((i-1)/2);
          const a = positions[parent], b = positions[i];
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', a.x);
          line.setAttribute('y1', a.y + 20);
          line.setAttribute('x2', b.x);
          line.setAttribute('y2', b.y - 18);
          line.setAttribute('class','link');
          line.style.stroke = 'rgba(255,255,255,0.05)';
          svg.appendChild(line);
        }

        // draw nodes
        heap.forEach((n,i) => {
          const pos = positions[i];
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('transform', `translate(${pos.x},${pos.y})`);
          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circle.setAttribute('r', 28);
          circle.setAttribute('class','nodeCircle');
          if (highlightIndices.includes(i)) circle.setAttribute('class','nodeCircle highlight');
          g.appendChild(circle);

          const valText = document.createElementNS('http://www.w3.org/2000/svg','text');
          valText.setAttribute('y','-3');
          valText.setAttribute('class','nodeText');
          valText.textContent = `${n.value}`;
          g.appendChild(valText);

          const subText = document.createElementNS('http://www.w3.org/2000/svg','text');
          subText.setAttribute('y','16');
          subText.setAttribute('class','nodeSub');
          subText.textContent = `id:${n.id} p:${n.priority}`;
          g.appendChild(subText);

          svg.appendChild(g);
        });
      }

      // initialize PQ with hooks
      function createPQ(){
        if (pq && !animInProgress) pq = null;
        const type = queueType.value;
        const stable = stableChk.checked;
        const anim = animChk.checked;
        const speed = Number(speedRange.value);
        pq = new PriorityQueue({
          type, stable, onUpdate: onPQUpdate, animate:anim, animationDelay: speed
        });
        extracted = [];
        updateMeta();
        renderArrayView([]);
        renderTree([]);
        extractedDiv.innerHTML = '';
        log(`Created new ${type === 'min' ? 'Min' : 'Max'}-heap priority queue${stable ? ' (stable)' : ''}, animation ${anim ? 'on' : 'off'} (delay ${speed}ms).`);
      }

      // on update callback from pq
      let lastUpdate = null;
      function onPQUpdate(evt){
        lastUpdate = evt;
        // render quickly — for swaps include highlight
        if (evt.type === 'swap' && evt.indices) {
          renderArrayView(evt.heap);
          renderTree(evt.heap, evt.indices);
          statusLine.textContent = `Swapped indices ${evt.indices[0]} ↔ ${evt.indices[1]}`;
        } else {
          renderArrayView(evt.heap);
          renderTree(evt.heap);
          statusLine.textContent = `Operation: ${evt.type}`;
        }
        updateMeta();
      }

      function updateMeta(){
        meta.textContent = `size: ${pq ? pq.size() : 0} — implementation: binary heap — type: ${queueType.value.toUpperCase()}${stableChk.checked ? ' • stable' : ''}`;
      }

      // Button handlers
      enqueueBtn.addEventListener('click', async ()=>{
        if (!pq) createPQ();
        if (animInProgress) return;
        const val = itemValue.value || 'item';
        const pr = Number(itemPriority.value) || 0;
        animInProgress = true;
        log(`Enqueue "${val}" (prio ${pr})`);
        const node = await pq.enqueue(val, pr);
        renderArrayView(pq.heap);
        renderTree(pq.heap);
        updateMeta();
        animInProgress = false;
      });

      enqueueRandBtn.addEventListener('click', async ()=>{
        if (!pq) createPQ();
        if (animInProgress) return;
        animInProgress = true;
        const count = Math.floor(Math.random()*5) + 1;
        for (let i=0;i<count;i++){
          const val = 't-'+Math.random().toString(36).slice(2,6);
          const pr = Math.floor(Math.random()*20) - 5;
          log(`Enqueue "${val}" (prio ${pr})`);
          await pq.enqueue(val, pr);
        }
        renderArrayView(pq.heap);
        renderTree(pq.heap);
        updateMeta();
        animInProgress = false;
      });

      dequeueBtn.addEventListener('click', async ()=>{
        if (!pq) { createPQ(); return; }
        if (animInProgress) return;
        if (pq.isEmpty()) { log('Dequeue attempted on empty queue'); return; }
        animInProgress = true;
        const top = pq.peek();
        log(`Dequeue -> id:${top.id} "${top.value}" (prio ${top.priority})`);
        const popped = await pq.dequeue();
        extracted.unshift(`${popped.value} (id:${popped.id}, p:${popped.priority})`);
        renderExtracted();
        renderArrayView(pq.heap);
        renderTree(pq.heap);
        updateMeta();
        animInProgress = false;
      });

      peekBtn.addEventListener('click', ()=>{
        if (!pq) createPQ();
        const p = pq.peek();
        if (!p) { log('Peek: queue empty'); return; }
        log(`Peek -> id:${p.id} "${p.value}" (prio ${p.priority})`);
      });

      dequeueAllBtn.addEventListener('click', async ()=>{
        if (!pq) createPQ();
        if (animInProgress) return;
        if (pq.isEmpty()) { log('Queue empty — nothing to dequeue'); return; }
        animInProgress = true;
        log('Dequeue All (extracting until empty)...');
        while (!pq.isEmpty()){
          const popped = await pq.dequeue();
          extracted.unshift(`${popped.value} (id:${popped.id}, p:${popped.priority})`);
          renderExtracted();
        }
        renderArrayView(pq.heap);
        renderTree(pq.heap);
        updateMeta();
        animInProgress = false;
      });

      clearBtn.addEventListener('click', ()=>{
        if (!pq) createPQ();
        if (animInProgress) return;
        pq.clear();
        extracted = [];
        extractedDiv.innerHTML = '';
        renderArrayView([]);
        renderTree([]);
        updateMeta();
        log('Cleared queue.');
      });

      changeBtn.addEventListener('click', async ()=>{
        if (!pq) createPQ();
        if (animInProgress) return;
        const id = changeId.value.trim();
        const newPr = changePr.value;
        if (!id) { alert('Enter id to change'); return; }
        if (newPr === '') { alert('Enter new priority'); return; }
        if (pq.isEmpty()) { log('Queue empty — cannot change'); return; }
        animInProgress = true;
        const ok = await pq.changePriorityById(id, Number(newPr));
        if (ok) log(`Changed priority of id:${id} to ${newPr}`);
        else log(`ID ${id} not found`);
        renderArrayView(pq.heap);
        renderTree(pq.heap);
        updateMeta();
        animInProgress = false;
      });

      // when type/stability/anim settings change, recreate PQ preserving content optionally
      queueType.addEventListener('change', ()=> {
        recreateWithSettings();
      });
      stableChk.addEventListener('change', ()=> recreateWithSettings());
      animChk.addEventListener('change', ()=> {
        if (pq) pq.animate = animChk.checked;
      });
      speedRange.addEventListener('input', ()=> {
        if (pq) pq.animationDelay = Number(speedRange.value);
      });

      function recreateWithSettings(){
        if (!pq) { createPQ(); return; }
        // preserve items: pull out heap array
        const preserved = pq.heap.slice();
        createPQ();
        // reinsert preserved (preserve insertOrder to maintain stability)
        (async ()=>{
          animInProgress = true;
          for (let n of preserved){
            // keep id and insertOrder — but enqueue creates new node with new id; to preserve ids we directly push
            // For simplicity here we re-enqueue values (new ids). This is OK for demo since user didn't expect id persistence.
            await pq.enqueue(n.value, n.priority);
          }
          animInProgress = false;
        })();
      }

      function renderExtracted(){
        extractedDiv.innerHTML = '';
        extracted.forEach(x=>{
          const c = document.createElement('div');
          c.className = 'chip';
          c.textContent = x;
          extractedDiv.appendChild(c);
        });
      }

      // create initial PQ
      createPQ();

      // seed some items
      (async ()=>{
        await pq.enqueue('alpha', 4);
        await pq.enqueue('beta', 2);
        await pq.enqueue('gamma', 7);
        await pq.enqueue('delta', 2);
        await pq.enqueue('epsilon', 5);
        renderArrayView(pq.heap);
        renderTree(pq.heap);
        updateMeta();
        log('Seeded with example items.');
      })();

      // allow clicking nodes in array view to prefill change ID field
      arrayView.addEventListener('click', (e)=>{
        const box = e.target.closest('.nodeBox');
        if (!box) return;
        const idLine = box.querySelector('.id');
        if (!idLine) return;
        const m = idLine.textContent.match(/id:(\d+)/);
        if (m) { changeId.value = m[1]; }
      });

      // keyboard Enter to enqueue
      itemValue.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') enqueueBtn.click(); });
      itemPriority.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') enqueueBtn.click(); });

      // small UX: resize SVG viewBox on window resize to keep things crisp
      window.addEventListener('resize', ()=> renderTree(pq ? pq.heap : []));

    })();
  </script>
</body>
</html>