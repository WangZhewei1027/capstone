<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Bellman-Ford Algorithm Visualization</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#06b6d4;
    --muted:#94a3b8;
    --card:#071021;
    --success:#16a34a;
    --danger:#dc2626;
    --yellow:#f59e0b;
  }
  *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{margin:0;min-height:100vh;background:linear-gradient(180deg,#071021 0%, #071a2a 100%);color:#e6eef6}
  header{padding:16px 20px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;gap:12px}
  header h1{font-size:18px;margin:0;color:var(--accent)}
  .container{display:flex;gap:12px;padding:12px;height:calc(100vh - 72px)}
  .left{flex:1;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:8px;padding:12px;position:relative;overflow:hidden}
  #svgCanvas{width:100%;height:100%;border-radius:6px;background:
    repeating-linear-gradient(45deg, rgba(255,255,255,0.01) 0 1px, transparent 1px 24px);}
  .right{width:360px;display:flex;flex-direction:column;gap:12px}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);overflow:auto}
  label{display:block;color:var(--muted);font-size:12px;margin-bottom:6px}
  input[type="number"], select, input[type="text"]{width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:inherit}
  button{padding:8px 10px;border-radius:6px;border:0;background:var(--accent);color:#06202a;cursor:pointer}
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
  .row{display:flex;gap:8px}
  .small{padding:6px 8px;font-size:13px}
  .nodes-list, .edges-list{max-height:140px;overflow:auto;padding:6px;border-radius:6px;background:rgba(0,0,0,0.2);border:1px dashed rgba(255,255,255,0.02)}
  .node-item, .edge-item{display:flex;justify-content:space-between;align-items:center;padding:6px;border-bottom:1px dashed rgba(255,255,255,0.02);font-size:13px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .log{max-height:220px;overflow:auto;background:rgba(0,0,0,0.25);padding:8px;border-radius:6px;font-size:13px}
  .log p{margin:6px 0}
  .node-circle{cursor:pointer;stroke:#0b1220;stroke-width:2px}
  .edge-line{stroke:#94a3b8;stroke-width:2px;opacity:0.9}
  .edge-label{font-size:12px;fill:#e6eef6;pointer-events:none}
  .distance{font-size:12px;fill:#e6eef6;pointer-events:none}
  .node-label{font-size:12px;fill:#e6eef6;pointer-events:none}
  .badge{padding:4px 8px;border-radius:999px;background:rgba(0,0,0,0.3);font-size:12px}
  footer{padding:12px;text-align:center;color:var(--muted);font-size:13px}
  .status{padding:8px;border-radius:6px;background:rgba(255,255,255,0.02);font-size:13px}
  .highlight-success{stroke:var(--success) !important;stroke-width:3px}
  .highlight-fail{stroke:rgba(255,255,255,0.06) !important}
  .highlight-active{stroke:var(--yellow) !important;stroke-width:3px;opacity:1}
  .neg-cycle{stroke:var(--danger) !important;stroke-width:3px;opacity:1}
  .node-updated{fill:var(--success) !important}
  .muted-text{color:var(--muted)}
  .help{font-size:13px;color:var(--muted);margin-top:6px}
  .small-muted{font-size:12px;color:var(--muted)}
  .edge-controls{display:flex;gap:8px;align-items:center}
</style>
</head>
<body>
<header>
  <h1>Bellman-Ford Algorithm Visualization</h1>
  <div class="small-muted">Directed weighted graphs • negative edges allowed • step-by-step + detect negative cycles</div>
</header>

<div class="container">
  <div class="left card">
    <svg id="svgCanvas" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="7" markerHeight="7" orient="auto">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="#94a3b8"/>
        </marker>
        <marker id="arrow-active" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--yellow)"/>
        </marker>
        <marker id="arrow-success" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--success)"/>
        </marker>
        <marker id="arrow-danger" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--danger)"/>
        </marker>
      </defs>
    </svg>
    <div style="position:absolute;right:14px;bottom:14px;background:rgba(0,0,0,0.25);padding:8px;border-radius:6px;font-size:13px">
      Click nodes to select (for edge creation). Drag nodes to reposition.
    </div>
  </div>

  <div class="right">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <strong>Graph Controls</strong>
          <div class="small-muted" style="margin-top:6px">Create nodes/edges or generate a random graph.</div>
        </div>
        <div class="badge">Bellman-Ford</div>
      </div>
      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.02);margin:8px 0">
      <div class="row" style="margin-bottom:6px">
        <button id="addNodeBtn" class="small">Add Node</button>
        <button id="addEdgeModeBtn" class="small secondary">Add Edge</button>
        <button id="removeSelectedBtn" class="small secondary">Remove Selected</button>
      </div>

      <label>Random graph</label>
      <div class="row" style="margin-bottom:8px">
        <input id="rndN" type="number" min="2" max="20" value="6" style="width:72px">
        <input id="rndP" type="number" min="0" max="1" step="0.1" value="0.4" style="width:72px">
        <input id="rndRange" type="text" value="-5..10" style="width:100px">
        <button id="rndGen" class="small">Generate</button>
      </div>
      <div class="help">Weight range format: min..max (e.g. -5..10). p=probability of directed edge between ordered pair.</div>
    </div>

    <div class="card">
      <strong>Graph Items</strong>
      <div style="margin-top:8px">
        <label>Nodes</label>
        <div id="nodesList" class="nodes-list"></div>
      </div>
      <div style="margin-top:8px">
        <label>Edges</label>
        <div id="edgesList" class="edges-list"></div>
      </div>
    </div>

    <div class="card">
      <strong>Algorithm Controls</strong>
      <div style="margin-top:8px">
        <label>Source node</label>
        <select id="sourceSelect"></select>
      </div>

      <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
        <button id="startBtn">Start (Auto)</button>
        <button id="stepBtn" class="secondary">Step</button>
        <button id="pauseBtn" class="secondary" disabled>Pause</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>

      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <label style="margin:0">Speed</label>
        <input id="speedRange" type="range" min="100" max="2000" value="700" style="flex:1">
        <div class="small-muted" id="speedVal">700ms</div>
      </div>

      <div style="margin-top:8px">
        <button id="detectNegBtn" class="small">Detect Negative Cycle</button>
        <div class="small-muted help">After running the algorithm, this will perform an extra pass to identify negative cycles reachable from the source.</div>
      </div>
    </div>

    <div class="card">
      <strong>Status & Log</strong>
      <div class="status" id="statusText">Idle. Add nodes and edges, pick a source, then Start or Step.</div>
      <div style="margin-top:8px" class="log" id="logArea"></div>
    </div>

  </div>
</div>

<footer>Interactive demo — Drag nodes, create edges, run Bellman-Ford. This is a client-side visualization.</footer>

<script>
(function(){
  /* Data structures */
  let nodes = []; // {id,label,x,y,svgGroup,...}
  let edges = []; // {id, u, v, w, svgLine, svgLabel}
  let nextNodeId = 0;
  let nextEdgeId = 0;
  const svg = document.getElementById('svgCanvas');
  const nodesListDiv = document.getElementById('nodesList');
  const edgesListDiv = document.getElementById('edgesList');
  const sourceSelect = document.getElementById('sourceSelect');
  const logArea = document.getElementById('logArea');
  const statusText = document.getElementById('statusText');
  const speedRange = document.getElementById('speedRange');
  const speedVal = document.getElementById('speedVal');

  speedRange.addEventListener('input', ()=> speedVal.textContent = speedRange.value + 'ms');

  /* Algorithm state */
  let dist = {};
  let prev = {};
  let algoRunning = false;
  let stepMode = false;
  let autoTimer = null;
  let currIter = 1;
  let currEdgeIndex = 0; // index in edges order for the current iteration
  let sourceNode = null;
  let selectedNode = null;
  let addEdgeMode = false;
  let edgeTmpFrom = null;

  // SVG sizes
  function viewSize(){ return {w: svg.clientWidth, h: svg.clientHeight}; }

  /* Utility */
  function log(msg, type='info'){
    const p = document.createElement('p');
    p.style.margin = '6px 0';
    if(type==='info'){ p.style.color = '#cfeff6'; }
    else if(type==='success'){ p.style.color = 'lightgreen'; }
    else if(type==='danger'){ p.style.color = 'salmon' }
    p.textContent = msg;
    logArea.appendChild(p);
    logArea.scrollTop = logArea.scrollHeight;
  }

  function setStatus(s){ statusText.textContent = s; }

  /* Node / Edge creation and rendering */
  function createNode(x,y,label){
    const id = nextNodeId++;
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('data-id', id);
    g.style.cursor = 'pointer';

    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('r', 26);
    circle.setAttribute('cx', x);
    circle.setAttribute('cy', y);
    circle.setAttribute('fill', '#021423');
    circle.classList.add('node-circle');
    circle.style.transition = 'fill .2s';

    const labelText = document.createElementNS('http://www.w3.org/2000/svg','text');
    labelText.setAttribute('x', x);
    labelText.setAttribute('y', y-4);
    labelText.setAttribute('text-anchor','middle');
    labelText.classList.add('node-label');
    labelText.textContent = label;

    const distText = document.createElementNS('http://www.w3.org/2000/svg','text');
    distText.setAttribute('x', x);
    distText.setAttribute('y', y+14);
    distText.setAttribute('text-anchor','middle');
    distText.classList.add('distance');
    distText.textContent = '∞';

    g.appendChild(circle);
    g.appendChild(labelText);
    g.appendChild(distText);
    svg.appendChild(g);

    const node = {id, label, x, y, g, circle, labelText, distText};
    nodes.push(node);
    makeDraggable(node);
    updateLists();
    return node;
  }

  function removeNode(nodeId){
    // remove edges adjacent
    const remEdges = edges.filter(e => e.u===nodeId || e.v===nodeId).map(e=>e.id);
    remEdges.forEach(removeEdgeById);
    const ni = nodes.findIndex(n=>n.id===nodeId);
    if(ni>=0){
      svg.removeChild(nodes[ni].g);
      nodes.splice(ni,1);
    }
    updateLists();
  }

  function createEdge(uId,vId,w){
    if(uId===vId) { log('Self-loops are allowed, but often not useful', 'info'); }
    const id = nextEdgeId++;
    const uNode = getNode(uId), vNode = getNode(vId);
    const line = document.createElementNS('http://www.w3.org/2000/svg','path');
    line.setAttribute('fill','none');
    line.setAttribute('marker-end','url(#arrow)');
    line.classList.add('edge-line');
    line.style.transition = 'stroke .25s, stroke-width .25s, opacity .2s';

    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.classList.add('edge-label');
    label.textContent = w;

    svg.insertBefore(line, svg.firstChild); // behind nodes
    svg.appendChild(label);

    const edge = {id, u:uId, v:vId, w: Number(w), line, label, marker:'arrow'};
    edges.push(edge);
    updateEdgePosition(edge);
    updateLists();
    return edge;
  }

  function removeEdgeById(edgeId){
    const ei = edges.findIndex(e=>e.id===edgeId);
    if(ei>=0){
      svg.removeChild(edges[ei].line);
      svg.removeChild(edges[ei].label);
      edges.splice(ei,1);
    }
    updateLists();
  }

  function getNode(id){ return nodes.find(n=>n.id===id); }
  function getEdge(id){ return edges.find(e=>e.id===id); }

  function updateEdgePosition(edge){
    const u = getNode(edge.u), v = getNode(edge.v);
    if(!u || !v) return;
    const dx = v.x - u.x, dy = v.y - u.y;
    const distn = Math.sqrt(dx*dx+dy*dy);
    // shorten line ends to not overlap circles (radius 26)
    const r = 26;
    const ux = u.x + (dx/distn)*r;
    const uy = u.y + (dy/distn)*r;
    const vx = v.x - (dx/distn)*r;
    const vy = v.y - (dy/distn)*r;
    // create a slight curve
    const mx = (ux+vx)/2 + (-dy/distn)*20;
    const my = (uy+vy)/2 + (dx/distn)*12;
    const d = `M ${ux} ${uy} Q ${mx} ${my} ${vx} ${vy}`;
    edge.line.setAttribute('d', d);
    // place label near mid of curve
    edge.label.setAttribute('x', mx);
    edge.label.setAttribute('y', my-6);
    edge.label.textContent = edge.w;
    // choose correct marker depending on edge.line stroke color classes
    updateEdgeMarker(edge);
  }

  function updateEdgeMarker(edge){
    // choose marker id string based on classes
    let marker = 'arrow';
    if(edge.line.classList.contains('highlight-active')) marker = 'arrow-active';
    else if(edge.line.classList.contains('highlight-success')) marker = 'arrow-success';
    else if(edge.line.classList.contains('neg-cycle')) marker = 'arrow-danger';
    edge.line.setAttribute('marker-end', `url(#${marker})`);
  }

  /* Draggable nodes */
  function makeDraggable(node){
    let dragging = false;
    let offset = {x:0,y:0};
    const onDown = (e) => {
      e.preventDefault();
      dragging = true;
      const pt = getPoint(e);
      offset.x = node.x - pt.x;
      offset.y = node.y - pt.y;
      selectedNode = node;
      highlightSelection();
    };
    const onMove = (e) => {
      if(!dragging) return;
      const pt = getPoint(e);
      node.x = pt.x + offset.x;
      node.y = pt.y + offset.y;
      node.circle.setAttribute('cx', node.x);
      node.circle.setAttribute('cy', node.y);
      node.labelText.setAttribute('x', node.x);
      node.labelText.setAttribute('y', node.y-4);
      node.distText.setAttribute('x', node.x);
      node.distText.setAttribute('y', node.y+14);
      edges.forEach(updateEdgePosition);
    };
    const onUp = (e) => { dragging = false; };
    node.g.addEventListener('mousedown', onDown);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    // touch support
    node.g.addEventListener('touchstart', (ev)=> { onDown(ev.touches[0]); }, {passive:false});
    window.addEventListener('touchmove', (ev)=> { onMove(ev.touches[0]); }, {passive:false});
    window.addEventListener('touchend', onUp);
    // click selection for edge creation
    node.g.addEventListener('click', (e) => {
      e.stopPropagation();
      if(addEdgeMode){
        if(edgeTmpFrom==null){
          edgeTmpFrom = node.id;
          setStatus(`Pick destination node (from ${getNode(edgeTmpFrom).label}).`);
        } else {
          const to = node.id;
          const weight = prompt('Edge weight (integer or decimal):', '1');
          if(weight!==null && weight.trim()!==''){
            createEdge(edgeTmpFrom,to,Number(weight));
            log(`Added edge ${getNode(edgeTmpFrom).label} → ${getNode(to).label} (w=${weight})`);
          }
          edgeTmpFrom = null;
          addEdgeMode = false;
          document.getElementById('addEdgeModeBtn').classList.remove('active');
          setStatus('Edge created (if accepted).');
        }
      } else {
        // normal click selects node
        selectedNode = node;
        highlightSelection();
      }
    });
  }

  function getPoint(e){
    const rect = svg.getBoundingClientRect();
    return {x: e.clientX - rect.left, y: e.clientY - rect.top};
  }

  /* UI list updates */
  function updateLists(){
    // nodes list
    nodesListDiv.innerHTML = '';
    nodes.forEach(n=>{
      const d = document.createElement('div');
      d.className = 'node-item';
      d.innerHTML = `<div>${n.label}</div><div style="display:flex;gap:6px"><button class="small secondary" data-id="${n.id}" data-action="setSource">Set as source</button><button class="small secondary" data-id="${n.id}" data-action="delNode">Del</button></div>`;
      nodesListDiv.appendChild(d);
    });
    // edges list
    edgesListDiv.innerHTML = '';
    edges.forEach(e=>{
      const u = getNode(e.u).label, v = getNode(e.v).label;
      const d = document.createElement('div');
      d.className = 'edge-item';
      d.innerHTML = `<div>${u} → ${v} (w=${e.w})</div><div style="display:flex;gap:6px"><button class="small secondary" data-id="${e.id}" data-action="delEdge">Del</button></div>`;
      edgesListDiv.appendChild(d);
    });

    // attach handlers
    nodesListDiv.querySelectorAll('button').forEach(btn=>{
      btn.addEventListener('click', ()=> {
        const id = Number(btn.getAttribute('data-id'));
        const act = btn.getAttribute('data-action');
        if(act==='setSource'){
          sourceNode = id;
          sourceSelect.value = String(id);
          setStatus(`Source set to ${getNode(id).label}`);
        } else if(act==='delNode'){
          removeNode(id);
        }
      });
    });
    edgesListDiv.querySelectorAll('button').forEach(btn=>{
      btn.addEventListener('click', ()=> {
        const id = Number(btn.getAttribute('data-id'));
        removeEdgeById(id);
      });
    });

    // source select
    sourceSelect.innerHTML = '';
    nodes.forEach(n=>{
      const opt = document.createElement('option');
      opt.value = n.id;
      opt.textContent = n.label;
      sourceSelect.appendChild(opt);
    });
    if(sourceNode==null && nodes.length>0) { sourceNode = nodes[0].id; }
    if(sourceNode!=null) sourceSelect.value = sourceNode;
    sourceSelect.addEventListener('change', ()=> { sourceNode = Number(sourceSelect.value); setStatus('Source changed.'); });
    refreshNodeDistances();
  }

  function refreshNodeDistances(){
    nodes.forEach(n=>{
      const v = dist.hasOwnProperty(n.id) ? dist[n.id] : Infinity;
      n.distText.textContent = (v===Infinity) ? '∞' : String(v);
      n.circle.style.fill = '#021423';
    });
  }

  function highlightSelection(){
    nodes.forEach(n => n.circle.style.stroke = (selectedNode && n.id===selectedNode.id) ? 'var(--accent)' : '#0b1220');
  }

  /* Controls wiring */
  document.getElementById('addNodeBtn').addEventListener('click', ()=>{
    const s = viewSize();
    const x = 50 + Math.random()*(s.w-100);
    const y = 50 + Math.random()*(s.h-100);
    const label = String.fromCharCode(65 + (nodes.length % 26));
    const node = createNode(x,y,label + (Math.floor(nodes.length/26) ? String(Math.floor(nodes.length/26)) : ''));
    log(`Node ${node.label} added`);
  });

  document.getElementById('addEdgeModeBtn').addEventListener('click', (e)=>{
    addEdgeMode = !addEdgeMode;
    edgeTmpFrom = null;
    e.target.classList.toggle('active', addEdgeMode);
    setStatus(addEdgeMode ? 'Edge creation mode: click source then destination' : 'Edge creation canceled');
  });

  document.getElementById('removeSelectedBtn').addEventListener('click', ()=>{
    if(selectedNode){ removeNode(selectedNode.id); selectedNode = null; setStatus('Selected node removed'); }
    else setStatus('No node selected');
  });

  document.getElementById('rndGen').addEventListener('click', ()=>{
    // parse settings
    const n = Math.max(2, Math.min(20, Number(document.getElementById('rndN').value) || 6));
    let p = Number(document.getElementById('rndP').value);
    p = Math.max(0, Math.min(1, isNaN(p)?0.4:p));
    const range = document.getElementById('rndRange').value.split('..').map(s=>Number(s.trim()));
    const min = isNaN(range[0]) ? -5 : range[0];
    const max = isNaN(range[1]) ? 10 : range[1];
    // clear existing
    nodes.slice().forEach(nm=> removeNode(nm.id));
    // create nodes
    const s = viewSize();
    for(let i=0;i<n;i++){
      const x = 60 + (i%(Math.ceil(Math.sqrt(n))))*(80);
      const y = 60 + Math.floor(i/(Math.ceil(Math.sqrt(n))))*80;
      createNode(Math.min(s.w-60, x + (Math.random()*40-20)), Math.min(s.h-60, y + (Math.random()*40-20)), String.fromCharCode(65 + i));
    }
    // create edges with probability p for each ordered pair
    for(let i=0;i<n;i++){
      for(let j=0;j<n;j++){
        if(i===j) continue;
        if(Math.random() < p){
          const w = Math.floor(min + Math.random()*(max-min+1));
          createEdge(nodes[i].id, nodes[j].id, w);
        }
      }
    }
    log(`Random graph generated: ${n} nodes, p=${p}, weights ${min}..${max}`);
  });

  /* Algorithm implementation (stepwise) */
  function initAlgorithm(){
    if(nodes.length===0){ alert('No nodes'); return false; }
    if(edges.length===0){ alert('No edges'); return false; }
    if(sourceNode==null){ alert('Pick source node'); return false; }
    // initialize
    dist = {}; prev = {};
    nodes.forEach(n=>{ dist[n.id]=Infinity; prev[n.id]=null; });
    dist[sourceNode]=0;
    prev[sourceNode]=null;
    currIter = 1;
    currEdgeIndex = 0;
    stepMode = false;
    algoRunning = true;
    refreshNodeDistances();
    setStatus(`Initialized. Starting from ${getNode(sourceNode).label}. Iteration ${currIter} of ${nodes.length-1}`);
    log(`Algorithm initialized. Source ${getNode(sourceNode).label}`);
    return true;
  }

  function startAuto(){
    if(!initAlgorithm()) return;
    stepMode = false;
    document.getElementById('pauseBtn').disabled = false;
    autoTimer = setTimeout(autoStep, speedRange.value);
  }

  function autoStep(){
    if(!algoRunning){ return; }
    if(currIter > nodes.length - 1){
      // finished relaxation rounds automatically
      setStatus('Main relaxations finished. You can detect negative cycles or inspect results.');
      log('Main relaxations finished (|V|-1 iterations).');
      algoRunning = false;
      document.getElementById('pauseBtn').disabled = true;
      return;
    }
    // process one edge
    if(currEdgeIndex >= edges.length){
      currIter++;
      currEdgeIndex = 0;
      setStatus(`Iteration ${currIter} of ${nodes.length-1}`);
      log(`--- Iteration ${currIter-1} complete ---`);
      if(currIter > nodes.length -1){
        // finished
        setStatus('Main relaxations finished. You can detect negative cycles or inspect results.');
        log('Main relaxations finished (|V|-1 iterations).');
        algoRunning = false;
        document.getElementById('pauseBtn').disabled = true;
        return;
      }
    } else {
      relaxEdgeVisual(edges[currEdgeIndex], ()=> {
        currEdgeIndex++;
        autoTimer = setTimeout(autoStep, speedRange.value);
      });
    }
  }

  function stepOnce(){
    if(!algoRunning){
      // first step: initialize
      if(!initAlgorithm()) return;
      stepMode = true;
      setStatus(`Step mode. Iteration ${currIter} of ${nodes.length-1}, edge 0/${edges.length}`);
    }
    if(currIter > nodes.length - 1){
      setStatus('Main relaxations finished. You can detect negative cycles or inspect results.');
      log('Main relaxations finished (|V|-1 iterations).');
      algoRunning = false;
      return;
    }
    if(edges.length===0){
      setStatus('No edges to process.');
      algoRunning = false;
      return;
    }
    if(currEdgeIndex >= edges.length){
      currIter++;
      currEdgeIndex = 0;
      log(`--- Iteration ${currIter-1} complete ---`);
      setStatus(`Iteration ${currIter} of ${nodes.length-1}`);
      if(currIter > nodes.length -1){
        setStatus('Main relaxations finished. You can detect negative cycles or inspect results.');
        log('Main relaxations finished (|V|-1 iterations).');
        algoRunning = false;
        return;
      }
    } else {
      relaxEdgeVisual(edges[currEdgeIndex], ()=> {
        currEdgeIndex++;
        setStatus(`Iteration ${currIter} of ${nodes.length-1}, edge ${currEdgeIndex}/${edges.length}`);
      });
    }
  }

  function relaxEdgeVisual(edge, cb){
    // highlight active
    clearEdgeHighlights();
    edge.line.classList.add('highlight-active');
    updateEdgeMarker(edge);
    const u = edge.u, v = edge.v, w = edge.w;
    const du = dist[u], dv = dist[v];
    setStatus(`Relaxing edge ${getNode(u).label}→${getNode(v).label} (w=${w})`);
    log(`Relaxing edge ${getNode(u).label}→${getNode(v).label} (w=${w}). dist[u]=${du===Infinity?'∞':du}, dist[v]=${dv===Infinity?'∞':dv}`);
    // simulate evaluation time
    setTimeout(()=>{
      // attempt relax
      if(du !== Infinity && du + w < dv){
        // success
        dist[v] = du + w;
        prev[v] = u;
        // update node visual
        const nv = getNode(v);
        nv.distText.textContent = String(dist[v]);
        // highlight edge success
        edge.line.classList.remove('highlight-active');
        edge.line.classList.add('highlight-success');
        updateEdgeMarker(edge);
        log(`Updated dist[${getNode(v).label}] = ${dist[v]} via ${getNode(u).label}`, 'success');
        // small flash on node
        nv.circle.style.fill = 'var(--success)';
        setTimeout(()=> nv.circle.style.fill = '#021423', 350);
      } else {
        // no change
        edge.line.classList.remove('highlight-active');
        edge.line.classList.add('highlight-fail');
        updateEdgeMarker(edge);
        log(`No update for ${getNode(v).label}`);
      }
      // cleanup highlight after a bit
      setTimeout(()=>{
        edge.line.classList.remove('highlight-success','highlight-fail','highlight-active');
        updateEdgeMarker(edge);
      }, Math.max(200, speedRange.value/2));
      cb && cb();
    }, Math.max(120, speedRange.value/3));
  }

  function clearEdgeHighlights(){
    edges.forEach(e=>{
      e.line.classList.remove('highlight-active','highlight-success','highlight-fail','neg-cycle');
      updateEdgeMarker(e);
    });
  }

  function resetAlgorithm(){
    algoRunning = false;
    stepMode = false;
    clearTimeout(autoTimer);
    autoTimer = null;
    currIter = 1;
    currEdgeIndex = 0;
    dist = {};
    prev = {};
    nodes.forEach(n=>{ dist[n.id]=Infinity; prev[n.id]=null; n.distText.textContent='∞'; n.circle.style.fill = '#021423'; });
    clearEdgeHighlights();
    log('Algorithm reset.');
    setStatus('Reset complete.');
    document.getElementById('pauseBtn').disabled = true;
  }

  function detectNegativeCycle(){
    if(Object.keys(dist).length===0){ alert('Run algorithm main relaxations first (auto or step).'); return; }
    // perform one extra pass: any edge that can still relax indicates negative cycle reachable from source
    let found = false;
    const negEdges = [];
    edges.forEach(e=>{
      const u = e.u, v = e.v, w = e.w;
      if(dist[u] !== Infinity && dist[u] + w < dist[v]){
        found = true;
        negEdges.push(e);
      }
    });
    if(!found){
      setStatus('No negative-weight cycles detected reachable from the source.');
      log('No negative-weight cycles detected (reachable from source).', 'success');
      return;
    }
    // highlight all edges part of negative cycle detection
    negEdges.forEach(e=>{
      e.line.classList.add('neg-cycle');
      e.line.classList.remove('highlight-success','highlight-fail','highlight-active');
      updateEdgeMarker(e);
    });
    setStatus('Negative-weight cycle(s) detected (highlighted in red).');
    log(`Negative-weight cycle detected (or reachable). Highlighting ${negEdges.length} edge(s).`, 'danger');
  }

  /* Buttons */
  document.getElementById('startBtn').addEventListener('click', ()=>{
    if(algoRunning){ setStatus('Algorithm already running. Use Pause or Step.'); return; }
    startAuto();
  });

  document.getElementById('pauseBtn').addEventListener('click', ()=>{
    if(autoTimer){ clearTimeout(autoTimer); autoTimer = null; setStatus('Paused.'); document.getElementById('pauseBtn').disabled = true; }
    algoRunning = false;
  });

  document.getElementById('stepBtn').addEventListener('click', ()=>{
    stepOnce();
  });

  document.getElementById('resetBtn').addEventListener('click', ()=>{
    resetAlgorithm();
  });

  document.getElementById('detectNegBtn').addEventListener('click', ()=>{
    detectNegativeCycle();
  });

  // keyboard: Space to step
  window.addEventListener('keydown', (e)=>{
    if(e.code === 'Space'){ e.preventDefault(); stepOnce(); }
  });

  // click on background to deselect or add node
  svg.addEventListener('click', (e)=>{
    if(addEdgeMode){
      // cancel edge creation
      edgeTmpFrom = null;
      addEdgeMode = false;
      document.getElementById('addEdgeModeBtn').classList.remove('active');
      setStatus('Edge creation canceled.');
      return;
    }
    selectedNode = null;
    highlightSelection();
  });

  // initialize canvas with a small sample
  (function initSample(){
    const s = viewSize();
    const A = createNode(120,120,'A');
    const B = createNode(320,90,'B');
    const C = createNode(260,260,'C');
    const D = createNode(480,210,'D');
    createEdge(A.id,B.id,4);
    createEdge(A.id,C.id,2);
    createEdge(C.id,B.id,1);
    createEdge(B.id,D.id,2);
    createEdge(C.id,D.id,5);
    createEdge(D.id,C.id,-7); // negative edge creating negative cycle with C->D->C
    log('Sample graph loaded. Try Start (auto) or Step through relaxations.');
    updateLists();
  })();

  // window resize: adjust edge positions
  window.addEventListener('resize', ()=> edges.forEach(updateEdgePosition));

})();
</script>
</body>
</html>