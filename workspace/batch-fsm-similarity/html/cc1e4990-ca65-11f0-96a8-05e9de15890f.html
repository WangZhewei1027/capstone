<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Breadth-First Search (BFS) Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --cell-size: 28px;
      --grid-gap: 2px;
      --bg: #111;
      --panel: #0f1720;
      --accent: #38bdf8;
      --muted: #94a3b8;
    }
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071029 0%, #071a2a 100%);color:#e6eef6}
    .app{
      display:flex;
      gap:18px;
      padding:18px;
      max-width:1200px;
      margin:18px auto;
      align-items:flex-start;
    }
    .left{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:12px;
      border-radius:12px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }
    .grid {
      display:grid;
      gap:var(--grid-gap);
      background:linear-gradient(180deg, #07192a, #04121a);
      padding:8px;
      border-radius:8px;
    }
    .cell{
      width:var(--cell-size);
      height:var(--cell-size);
      border-radius:6px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      color:#032;
      user-select:none;
      cursor:pointer;
      transition:transform 0.08s, box-shadow 0.08s;
    }
    .cell:hover{transform:translateY(-3px)}
    /* cell states */
    .empty{background:#e6eef610; border:1px solid rgba(230,238,246,0.04)}
    .wall{background:#000a0f; border:1px solid rgba(255,255,255,0.02)}
    .start{background:linear-gradient(180deg,#22c55e,#16a34a); color:white; font-weight:700; box-shadow:0 4px 10px rgba(16,185,129,0.12)}
    .goal{background:linear-gradient(180deg,#ef4444,#dc2626); color:white; font-weight:700; box-shadow:0 4px 10px rgba(239,68,68,0.12)}
    .visited{background:linear-gradient(180deg,#bfdbfe,#93c5fd); color:#05233f}
    .frontier{background:linear-gradient(180deg,#ffd580,#ffb86b); color:#3a2b0d}
    .path{background:linear-gradient(180deg,#facc15,#f59e0b); color:#2a1b00; font-weight:700}
    /* layout */
    .controls{
      display:flex;
      gap:12px;
      align-items:center;
      margin-bottom:10px;
      flex-wrap:wrap;
    }
    .btn{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      transition:all .12s;
    }
    .btn:hover{transform:translateY(-2px); color:var(--accent); border-color:rgba(56,189,248,0.14)}
    .btn.primary{
      background:linear-gradient(90deg,#0369a1,#0ea5e9);
      color:white;border:0;box-shadow:0 6px 16px rgba(14,165,233,0.14)
    }
    .panel{
      margin-left:12px;
      min-width:320px;
      max-width:380px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.03);
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }
    .row{display:flex;gap:8px;align-items:center;margin-bottom:8px;flex-wrap:wrap}
    label{font-size:13px;color:var(--muted)}
    .small{font-size:12px;color:var(--muted)}
    .muted{color:var(--muted)}
    .queue{
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
      padding:8px;
      border-radius:8px;
      background:linear-gradient(180deg,#04111a,#031018);
      border:1px solid rgba(255,255,255,0.02);
      min-height:40px;
      max-height:140px;
      overflow:auto;
    }
    .badge{
      padding:6px 8px;
      background:rgba(255,255,255,0.03);
      border-radius:8px;
      font-size:12px;
      color:var(--muted);
    }
    input[type=range]{width:140px}
    .legend{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .legend .sw{width:18px;height:18px;border-radius:4px;display:inline-block;vertical-align:middle}
    .footer{font-size:12px;color:var(--muted);margin-top:8px}
    .title{font-weight:700;font-size:18px;margin-bottom:6px}
    .subtitle{font-size:13px;color:var(--muted);margin-bottom:8px}
    .hint{font-size:12px;color:var(--muted);margin-top:12px}
    .mode-btn{padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:var(--muted);cursor:pointer}
    .mode-btn.active{background:rgba(255,255,255,0.03);color:var(--accent);border-color:rgba(56,189,248,0.08)}
    .stats{font-size:13px;color:var(--muted);margin-top:8px;border-radius:8px;padding:8px;background:linear-gradient(180deg,#041018,#031116);border:1px solid rgba(255,255,255,0.02)}
    .control-row{display:flex;gap:6px;align-items:center}
    /* responsive */
    @media (max-width:900px){
      .app{flex-direction:column; padding:12px}
      .panel{max-width:none;width:100%}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <div style="display:flex;align-items:center;gap:12px;margin-bottom:10px">
        <div class="title">BFS Visualizer</div>
        <div class="small muted">Breadth-First Search (grid)</div>
      </div>

      <div class="controls">
        <button id="playBtn" class="btn primary">Play</button>
        <button id="stepBtn" class="btn">Step</button>
        <button id="resetBtn" class="btn">Restart</button>
        <button id="randomBtn" class="btn">Random Walls</button>
        <button id="clearBtn" class="btn">Clear Walls</button>

        <div style="width:12px"></div>

        <div style="display:flex;align-items:center;gap:8px">
          <label class="small muted">Speed</label>
          <input id="speedRange" type="range" min="50" max="1000" value="250">
        </div>
      </div>

      <div style="display:flex;gap:12px;align-items:center;margin-bottom:10px">
        <div style="display:flex;gap:6px">
          <button class="mode-btn active" id="modeWall">Wall</button>
          <button class="mode-btn" id="modeStart">Set Start</button>
          <button class="mode-btn" id="modeGoal">Set Goal</button>
        </div>

        <div style="display:flex;gap:6px;align-items:center">
          <label class="small muted">Grid</label>
          <select id="gridSize">
            <option value="12">12 x 12</option>
            <option value="16">16 x 16</option>
            <option value="20" selected>20 x 20</option>
            <option value="28">28 x 28</option>
            <option value="36">36 x 36</option>
          </select>
        </div>
      </div>

      <div id="gridContainer" style="display:flex;justify-content:center;align-items:center;">
        <!-- grid injected here -->
      </div>

    </div>

    <div class="panel">
      <div class="subtitle">Controls & Explanation</div>
      <div class="small muted">
        Click cells to toggle walls (Wall mode).
        Use Set Start / Set Goal and click a cell to place start/goal.
        Play animates BFS; Step advances one node.
        BFS explores layer-by-layer (shortest path by steps on unweighted grid).
      </div>

      <div style="margin-top:12px" class="row">
        <div class="label small muted">Queue (front -> back)</div>
      </div>
      <div id="queue" class="queue"></div>

      <div class="row" style="margin-top:8px">
        <div style="flex:1">
          <div class="stats" id="stats">
            Steps: 0 · Visited: 0 · Queue size: 0 · Shortest distance: N/A
          </div>
        </div>
      </div>

      <div style="margin-top:8px">
        <div class="legend">
          <div class="sw empty" style="border:1px solid rgba(255,255,255,0.04)"></div><div class="small muted">Empty</div>
          <div class="sw wall" style="width:18px;height:18px"></div><div class="small muted">Wall</div>
          <div class="sw start"></div><div class="small muted">Start</div>
          <div class="sw goal"></div><div class="small muted">Goal</div>
          <div class="sw visited"></div><div class="small muted">Visited</div>
          <div class="sw frontier"></div><div class="small muted">Frontier</div>
          <div class="sw path"></div><div class="small muted">Final Path</div>
        </div>
      </div>

      <div class="hint">
        Tip: BFS will always find the shortest path (in steps) in this unweighted grid. Walls block movement.
      </div>

      <div class="footer">
        Implementation visualizes queue, visited order, parent pointers, and reconstructs shortest path when goal is reached.
      </div>
    </div>
  </div>

<script>
(function(){
  // Grid BFS visualizer
  const gridContainer = document.getElementById('gridContainer');
  const queueEl = document.getElementById('queue');
  const statsEl = document.getElementById('stats');

  const playBtn = document.getElementById('playBtn');
  const stepBtn = document.getElementById('stepBtn');
  const resetBtn = document.getElementById('resetBtn');
  const randomBtn = document.getElementById('randomBtn');
  const clearBtn = document.getElementById('clearBtn');
  const speedRange = document.getElementById('speedRange');
  const gridSizeSelect = document.getElementById('gridSize');

  const modeWallBtn = document.getElementById('modeWall');
  const modeStartBtn = document.getElementById('modeStart');
  const modeGoalBtn = document.getElementById('modeGoal');

  let mode = 'wall'; // wall | start | goal

  // State
  let rows = 20, cols = 20;
  let cells = []; // array of divs
  let grid = []; // 0 empty, 1 wall
  let start = {r: Math.floor(rows/2), c: Math.floor(cols/4)};
  let goal = {r: Math.floor(rows/2), c: Math.floor(cols*3/4)};

  // BFS runtime variables
  let visited = [];
  let parent = []; // store parent index
  let q = []; // queue of indices
  let isRunning = false;
  let timer = null;
  let finished = false;
  let steps = 0;
  let visitCount = 0;
  let lastDistance = null;

  // helpers
  function idx(r,c){ return r*cols + c; }
  function rc(i){ return {r: Math.floor(i/cols), c: i%cols}; }

  function buildGrid(r,c){
    rows = r; cols = c;
    cells = [];
    grid = new Array(rows*cols).fill(0);
    visited = new Array(rows*cols).fill(false);
    parent = new Array(rows*cols).fill(-1);
    q = [];
    finished = false;
    steps = 0;
    visitCount = 0;
    lastDistance = null;

    // update CSS grid
    const gridEl = document.createElement('div');
    gridEl.className = 'grid';
    gridEl.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
    gridEl.style.gridTemplateRows = `repeat(${rows}, var(--cell-size))`;
    gridEl.style.width = `${cols*(parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) + 2)}px`;

    gridEl.addEventListener('contextmenu', e => e.preventDefault());
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const i = idx(r,c);
        const cell = document.createElement('div');
        cell.className = 'cell empty';
        cell.dataset.i = i;
        cell.title = `${r},${c}`;
        cell.addEventListener('click', onCellClick);
        cell.addEventListener('mousedown', e=> {
          if (mode === 'wall' && e.buttons === 1) dragging = true;
        });
        cells.push(cell);
        gridEl.appendChild(cell);
      }
    }
    gridContainer.innerHTML = '';
    gridContainer.appendChild(gridEl);

    // place start and goal
    if (!start || start.r>=rows || start.c>=cols) start = {r: Math.floor(rows/2), c: Math.floor(cols/4)};
    if (!goal || goal.r>=rows || goal.c>=cols) goal = {r: Math.floor(rows/2), c: Math.floor(cols*3/4)};
    updateAll();
    startBFS();
  }

  // UI mode selection
  modeWallBtn.onclick = ()=> setMode('wall');
  modeStartBtn.onclick = ()=> setMode('start');
  modeGoalBtn.onclick = ()=> setMode('goal');
  function setMode(m){
    mode = m;
    [modeWallBtn, modeStartBtn, modeGoalBtn].forEach(b=>b.classList.remove('active'));
    if (m==='wall') modeWallBtn.classList.add('active');
    if (m==='start') modeStartBtn.classList.add('active');
    if (m==='goal') modeGoalBtn.classList.add('active');
  }

  // clicking cells
  let dragging = false;
  document.addEventListener('mouseup', ()=> dragging = false);
  function onCellClick(e){
    const i = Number(this.dataset.i);
    const {r,c} = rc(i);
    if (mode === 'wall'){
      if (isRunning) { toggleWall(i); restartBFS(); } else { toggleWall(i); startBFS(); }
    } else if (mode === 'start'){
      if (i === idx(goal.r,goal.c)) return;
      start = {r,c};
      if (grid[i]===1) grid[i]=0;
      if (isRunning) restartBFS(); else startBFS();
    } else if (mode === 'goal'){
      if (i === idx(start.r,start.c)) return;
      goal = {r,c};
      if (grid[i]===1) grid[i]=0;
      if (isRunning) restartBFS(); else startBFS();
    }
    updateAll();
  }

  function toggleWall(i){
    if (i === idx(start.r,start.c) || i === idx(goal.r,goal.c)) return;
    grid[i] = grid[i] ? 0 : 1;
    updateCellVisual(i);
  }

  function updateCellVisual(i){
    const el = cells[i];
    el.className = 'cell';
    if (i === idx(start.r,start.c)){
      el.classList.add('start');
      el.textContent = 'S';
      return;
    }
    if (i === idx(goal.r,goal.c)){
      el.classList.add('goal');
      el.textContent = 'G';
      return;
    }
    if (grid[i] === 1){
      el.classList.add('wall');
      el.textContent = '';
      return;
    }
    // default empty (color overridden by visited/frontier/path)
    el.classList.add('empty');
    el.textContent = '';
  }

  function updateAll(){
    for(let i=0;i<rows*cols;i++){
      updateCellVisual(i);
      // clear other state classes
      cells[i].classList.remove('visited','frontier','path');
      cells[i].style.setProperty('--visit-index','');
      // clear number label (unless start/goal)
      if (![idx(start.r,start.c), idx(goal.r,goal.c)].includes(i)){
        // if visited or frontier will be set later
      }
    }
    refreshQueueUI();
    updateStats();
  }

  // BFS core
  function startBFS(){
    // reset runtime structures
    visited = new Array(rows*cols).fill(false);
    parent = new Array(rows*cols).fill(-1);
    q = [];
    finished = false;
    steps = 0;
    visitCount = 0;
    lastDistance = null;
    // start from start cell
    const s = idx(start.r, start.c);
    q.push(s);
    visited[s] = true;
    parent[s] = -1;
    visitCount = 1;
    markFrontier(s);
    refreshQueueUI();
    updateStats();
  }

  function restartBFS(){
    stop();
    startBFS();
    updateAll();
  }

  function stop(){
    isRunning = false;
    if (timer) clearInterval(timer);
    playBtn.textContent = 'Play';
    playBtn.classList.remove('active');
  }

  function play(){
    if (finished) {
      // if finished, restart
      restartBFS();
    }
    if (isRunning){
      stop();
      return;
    }
    isRunning = true;
    playBtn.textContent = 'Pause';
    playBtn.classList.add('active');
    const speed = Number(speedRange.value);
    timer = setInterval(()=> {
      const done = step();
      if (done) stop();
    }, speed);
  }

  playBtn.onclick = play;
  stepBtn.onclick = ()=> {
    if (!isRunning){
      const done = step();
      if (done) stop();
    } else {
      // if running, step does nothing
    }
  };
  resetBtn.onclick = ()=> {
    restartBFS();
  };
  randomBtn.onclick = ()=> {
    randomizeWalls();
    restartBFS();
    updateAll();
  };
  clearBtn.onclick = ()=> {
    grid.fill(0);
    restartBFS();
    updateAll();
  };

  gridSizeSelect.onchange = ()=>{
    const val = Number(gridSizeSelect.value);
    buildGrid(val,val);
  };

  speedRange.oninput = ()=> {
    if (isRunning){
      clearInterval(timer);
      timer = setInterval(()=> {
        const done = step();
        if (done) stop();
      }, Number(speedRange.value));
    }
  };

  function randomizeWalls(){
    // random walls with coverage
    const coverage = 0.23 + Math.random()*0.26; // 0.23 - 0.49
    for(let i=0;i<rows*cols;i++){
      grid[i] = Math.random() < coverage ? 1 : 0;
    }
    // ensure start/goal are empty
    grid[idx(start.r,start.c)] = 0;
    grid[idx(goal.r,goal.c)] = 0;
  }

  function neighbors(i){
    const {r,c} = rc(i);
    const nbrs = [];
    if (r>0) nbrs.push(idx(r-1,c));
    if (c>0) nbrs.push(idx(r,c-1));
    if (c<cols-1) nbrs.push(idx(r,c+1));
    if (r<rows-1) nbrs.push(idx(r+1,c));
    return nbrs;
  }

  function markVisited(i, visitIndex=null){
    const el = cells[i];
    if (i === idx(start.r,start.c) || i === idx(goal.r,goal.c)) return;
    el.classList.remove('empty','frontier','path','wall');
    el.classList.add('visited');
    if (visitIndex!=null){
      el.textContent = visitIndex;
      el.style.fontSize = '10px';
    } else {
      el.textContent = '';
    }
  }
  function markFrontier(i){
    const el = cells[i];
    if (i === idx(start.r,start.c) || i === idx(goal.r,goal.c)) return;
    el.classList.remove('empty','visited','path','wall');
    el.classList.add('frontier');
    el.textContent = '';
  }
  function markPath(i){
    const el = cells[i];
    if (i === idx(start.r,start.c) || i === idx(goal.r,goal.c)) return;
    el.classList.remove('empty','visited','frontier','wall');
    el.classList.add('path');
    el.textContent = '';
  }

  function refreshQueueUI(){
    queueEl.innerHTML = '';
    for(let i=0;i<q.length;i++){
      const {r,c} = rc(q[i]);
      const b = document.createElement('div');
      b.className = 'badge';
      b.textContent = `${r},${c}`;
      if (i===0) b.style.border = '1px solid rgba(255,255,255,0.06)';
      queueEl.appendChild(b);
    }
    updateStats();
  }

  function updateStats(){
    const qSize = q.length;
    const sText = `Steps: ${steps} · Visited: ${visitCount} · Queue size: ${qSize} · Shortest distance: ${lastDistance==null ? 'N/A' : lastDistance}`;
    statsEl.textContent = sText;
  }

  // BFS step returns true if finished (reached goal or no path)
  function step(){
    if (finished) return true;
    if (q.length === 0){
      // no path
      finished = true;
      updateStats();
      return true;
    }
    const cur = q.shift();
    steps++;
    refreshQueueUI();
    // mark visited (pop from frontier -> visited)
    if (!visited[cur]){
      // In our flow visited[cur] should be true when enqueued,
      // but handle gracefully
      visited[cur] = true;
    }
    // mark visual visited
    markVisited(cur, visitCount);
    visitCount++;
    // check goal
    if (cur === idx(goal.r,goal.c)){
      // done! reconstruct path
      reconstructPath(cur);
      finished = true;
      lastDistance = computeDistance(cur);
      updateStats();
      return true;
    }
    // expand neighbors
    const nbrs = neighbors(cur);
    for(const n of nbrs){
      if (!visited[n] && grid[n] === 0){
        visited[n] = true;
        parent[n] = cur;
        q.push(n);
        markFrontier(n);
      }
    }
    refreshQueueUI();
    updateStats();
    return false;
  }

  function computeDistance(i){
    let d = 0;
    let cur = i;
    while(parent[cur] !== -1){
      d++;
      cur = parent[cur];
    }
    return d;
  }

  function reconstructPath(endIdx){
    // walk back parents
    let cur = endIdx;
    const path = [];
    while(cur !== -1){
      path.push(cur);
      cur = parent[cur];
    }
    // path contains end -> start, mark excluding start and goal maybe keep goal
    for(let k=1;k<path.length-1;k++){
      markPath(path[k]);
    }
    // mark start and goal visually (ensure labels)
    updateCellVisual(idx(start.r,start.c));
    updateCellVisual(idx(goal.r,goal.c));
    lastDistance = path.length - 1;
    refreshQueueUI();
    updateStats();
  }

  // initialize
  buildGrid(rows,cols);

  // attach keyboard shortcuts
  document.addEventListener('keydown', (e)=>{
    if (e.key === ' ') { e.preventDefault(); play(); }
    if (e.key === 's') stepBtn.click();
    if (e.key === 'r') resetBtn.click();
    if (e.key === 'c') clearBtn.click();
    if (e.key === 'm') { setMode(mode==='wall'?'start':'wall'); }
  });

  // small improvement: allow dragging to draw walls
  let mouseDown = false;
  document.addEventListener('mousedown', ()=> mouseDown = true);
  document.addEventListener('mouseup', ()=> mouseDown = false);
  gridContainer.addEventListener('mousemove', (e)=>{
    if (!mouseDown) return;
    const cell = e.target.closest('.cell');
    if (!cell) return;
    const i = Number(cell.dataset.i);
    if (mode !== 'wall') return;
    toggleWall(i);
    if (isRunning) restartBFS(); else startBFS();
    updateCellVisual(i);
  });

  // ensure when clicking play after finished it restarts
  playBtn.addEventListener('click', ()=>{
    if (finished){
      restartBFS();
    }
  });

  // make grid responsive to CSS var size for width calculation
  window.addEventListener('resize', ()=> {
    const gridEl = gridContainer.querySelector('.grid');
    if (!gridEl) return;
    gridEl.style.width = `${cols*(parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) + 2)}px`;
  });

})();
</script>
</body>
</html>