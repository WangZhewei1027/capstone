<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prim's Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        canvas {
            border: 1px solid #000;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Prim's Algorithm Visualization</h1>
    <button id="generateGraph">Generate Random Graph</button>
    <canvas id="graphCanvas" width="600" height="400"></canvas>
    
    <script>
        const canvas = document.getElementById('graphCanvas');
        const context = canvas.getContext('2d');
        let graph = [];
        const numNodes = 10;

        // Create a random graph
        function generateGraph() {
            graph = Array.from({ length: numNodes }, () => []);
            for (let i = 0; i < numNodes; i++) {
                for (let j = 0; j < numNodes; j++) {
                    if (i !== j && Math.random() < 0.4) { // 40% chance to create an edge
                        const weight = Math.floor(Math.random() * 10) + 1; // random weight between 1 and 10
                        graph[i].push({ node: j, weight: weight });
                    }
                }
            }
            drawGraph();
        }

        function drawGraph() {
            context.clearRect(0, 0, canvas.width, canvas.height);
            const angleStep = (2 * Math.PI) / numNodes;
            const radius = 150;

            // Draw nodes
            for (let i = 0; i < numNodes; i++) {
                const x = canvas.width / 2 + radius * Math.cos(i * angleStep);
                const y = canvas.height / 2 + radius * Math.sin(i * angleStep);
                context.fillStyle = 'blue';
                context.beginPath();
                context.arc(x, y, 15, 0, 2 * Math.PI);
                context.fill();
                context.fillStyle = 'white';
                context.fillText(i, x - 5, y + 5);
            }

            // Draw edges
            context.strokeStyle = 'grey';
            for (let node = 0; node < numNodes; node++) {
                graph[node].forEach(edge => {
                    const x1 = canvas.width / 2 + radius * Math.cos(node * angleStep);
                    const y1 = canvas.height / 2 + radius * Math.sin(node * angleStep);
                    const x2 = canvas.width / 2 + radius * Math.cos(edge.node * angleStep);
                    const y2 = canvas.height / 2 + radius * Math.sin(edge.node * angleStep);
                    context.beginPath();
                    context.moveTo(x1, y1);
                    context.lineTo(x2, y2);
                    context.stroke();
                });
            }
        }

        function prim() {
            const selected = Array(numNodes).fill(false);
            const edges = [];
            const mstEdges = [];
            let totalCost = 0;

            // Start with the first node
            selected[0] = true;
            for (let count = 1; count < numNodes; count++) {
                let minEdge = { weight: Infinity };
                let fromNode = -1;

                // Find the minimum edge connecting the selected nodes
                for (let i = 0; i < numNodes; i++) {
                    if (selected[i]) {
                        for (const edge of graph[i]) {
                            if (!selected[edge.node] && edge.weight < minEdge.weight) {
                                minEdge = edge;
                                fromNode = i;
                            }
                        }
                    }
                }

                selected[minEdge.node] = true;
                mstEdges.push({ from: fromNode, to: minEdge.node, weight: minEdge.weight });
                totalCost += minEdge.weight;
            }

            return { edges: mstEdges, cost: totalCost };
        }

        function visualizeMST() {
            const { edges, cost } = prim();
            context.clearRect(0, 0, canvas.width, canvas.height);
            drawGraph();

            // Highlight MST edges
            context.strokeStyle = 'red';
            edges.forEach(edge => {
                const x1 = canvas.width / 2 + 150 * Math.cos(edge.from * (2 * Math.PI / numNodes));
                const y1 = canvas.height / 2 + 150 * Math.sin(edge.from * (2 * Math.PI / numNodes));
                const x2 = canvas.width / 2 + 150 * Math.cos(edge.to * (2 * Math.PI / numNodes));
                const y2 = canvas.height / 2 + 150 * Math.sin(edge.to * (2 * Math.PI / numNodes));
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.stroke();
            });

            alert(`Total Cost of Minimum Spanning Tree: ${cost}`);
        }

        document.getElementById('generateGraph').addEventListener('click', () => {
            generateGraph();
            setTimeout(visualizeMST, 1000); // Visualize after generating
        });

        generateGraph();  // Generate graph initially
    </script>
</body>
</html>