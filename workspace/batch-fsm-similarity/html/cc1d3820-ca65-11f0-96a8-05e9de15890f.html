<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Binary Search Tree (BST) Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    :root { --bg:#f6f8fb; --panel:#ffffff; --accent:#2b79ff; --muted:#6b7280; --good:#10b981; --bad:#ef4444; }
    body { margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); color:#0f172a; }
    header { padding:16px 20px; display:flex; gap:12px; align-items:center; background:linear-gradient(90deg,#f8fafc,#eef2ff); border-bottom:1px solid #e6eefc; }
    h1 { margin:0; font-size:18px; font-weight:600; color:#0b1220; }
    main { display:flex; gap:20px; padding:18px; }
    .controls { width:360px; background:var(--panel); border-radius:10px; padding:16px; box-shadow:0 6px 18px rgba(11,20,40,0.06); }
    .visual { flex:1; min-height:520px; background:var(--panel); border-radius:10px; padding:12px; box-shadow:0 6px 18px rgba(11,20,40,0.06); display:flex; flex-direction:column; }
    label { display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    .row { display:flex; gap:8px; align-items:center; margin-bottom:10px; }
    input[type="number"], input[type="text"] { padding:8px 10px; border-radius:8px; border:1px solid #e6eefc; background:#fafafa; width:100%; font-size:14px; }
    button { background:var(--accent); color:white; border:none; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600; }
    button.secondary { background:#eef2ff; color:var(--accent); box-shadow:none; font-weight:600; }
    button.warn { background:var(--bad); }
    .small { padding:6px 8px; font-size:13px; border-radius:8px; }
    .muted { color:var(--muted); font-size:13px; }
    .controls .section { margin-bottom:14px; padding-bottom:8px; border-bottom:1px dashed #eef4ff; }
    .traversals button { margin-right:8px; margin-bottom:8px; }
    .status { margin-top:12px; font-size:13px; color:var(--muted); }
    .info { font-size:13px; color:var(--muted); margin-top:8px; }
    svg { width:100%; height:100%; overflow:visible; }
    .node { cursor:default; transition:transform .18s ease, fill .2s ease; }
    .node circle { fill: #ffffff; stroke: #9fb7ff; stroke-width:2; }
    .node text { font-size:12px; font-weight:700; fill:#0f172a; text-anchor:middle; dominant-baseline:central; }
    .edge { stroke:#cde0ff; stroke-width:2; }
    .visited circle { fill:#fff7e6; stroke:#f59e0b; stroke-width:2.5; }
    .found circle { fill:#ecfeff; stroke:#06b6d4; stroke-width:2.5; }
    .highlight circle { fill:#edeffd; stroke:#6366f1; stroke-width:2.5; transform:scale(1.07); }
    .legend { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .leg-item { display:flex; gap:6px; align-items:center; font-size:12px; color:var(--muted); }
    .badge { width:14px; height:14px; border-radius:4px; border:1px solid rgba(0,0,0,0.06); }
    .badge.visit { background:#fff7e6; border-color:#f59e0b; }
    .badge.found { background:#ecfeff; border-color:#06b6d4; }
    .badge.highlight { background:#edeffd; border-color:#6366f1; }
    footer { padding:8px 18px; font-size:13px; color:var(--muted); text-align:center; }
    .meta { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .pill { background:#f1f5f9; border-radius:999px; padding:6px 8px; font-size:12px; color:var(--muted); }
    .result { margin-top:8px; font-size:14px; font-weight:600; color:#0b1220; }
    .node-count { font-weight:700; color:var(--accent); }
    .input-row { display:flex; gap:8px; }
  </style>
</head>
<body>
  <header>
    <h1>Binary Search Tree (BST) — Interactive Visualizer</h1>
    <div style="margin-left:auto; color:var(--muted); font-size:13px;">Insert / Delete / Search / Traversals • Animated</div>
  </header>

  <main>
    <aside class="controls" aria-label="controls">
      <div class="section">
        <label>Value (integer)</label>
        <div class="input-row">
          <input id="valueInput" type="number" placeholder="e.g. 42" />
          <button id="insertBtn" class="small">Insert</button>
          <button id="deleteBtn" class="small warn">Delete</button>
        </div>
        <div class="input-row" style="margin-top:8px;">
          <input id="searchInput" type="number" placeholder="Search value" />
          <button id="searchBtn" class="small secondary">Search</button>
        </div>
        <div class="row" style="margin-top:10px;">
          <button id="randomBtn" class="small">Random (7)</button>
          <button id="clearBtn" class="small secondary">Clear</button>
        </div>
        <div class="status">
          Nodes: <span id="nodeCount" class="node-count">0</span> • Height: <span id="treeHeight">0</span>
        </div>
      </div>

      <div class="section">
        <label>Traversals & Animations</label>
        <div class="traversals">
          <button id="inorderBtn" class="small secondary">In-order</button>
          <button id="preorderBtn" class="small secondary">Pre-order</button>
          <button id="postorderBtn" class="small secondary">Post-order</button>
          <button id="levelBtn" class="small secondary">Level-order</button>
        </div>
        <div class="row" style="margin-top:8px;">
          <label style="margin:0;">Animation speed</label>
          <input id="speed" type="range" min="50" max="1200" value="350" style="flex:1" />
        </div>
        <div class="result" id="traversalResult">Result: —</div>
        <div class="info">Tip: Use traversal buttons to animate node visits. Search animates the path taken.</div>
      </div>

      <div class="">
        <label>Complexity</label>
        <div class="meta">
          <div class="pill">Avg search/insert: O(log n)</div>
          <div class="pill">Worst-case: O(n)</div>
          <div class="pill">Space: O(n)</div>
        </div>
        <div class="legend">
          <div class="leg-item"><span class="badge visit"></span> visited</div>
          <div class="leg-item"><span class="badge found"></span> found</div>
          <div class="leg-item"><span class="badge highlight"></span> currently exploring</div>
        </div>
      </div>
    </aside>

    <section class="visual" aria-label="visualization">
      <svg id="svgCanvas" viewBox="0 0 1200 600" preserveAspectRatio="xMidYMin meet"></svg>
      <div style="padding:8px 10px; font-size:13px; color:var(--muted); border-top:1px dashed #eef4ff; margin-top:8px;">
        Structure: <span id="structureText">Empty</span>
      </div>
    </section>
  </main>

  <footer>
    BST operations demonstrated: insert, delete, search, inorder/preorder/postorder/level-order traversal. Duplicates ignored.
  </footer>

<script>
(() => {
  // Basic BST implementation with visualization-friendly methods
  class Node {
    constructor(v) { this.v = v; this.left = null; this.right = null; this.x = 0; this.y = 0; }
  }

  class BST {
    constructor() { this.root = null; this._size = 0; }
    get size() { return this._size; }
    insert(v) {
      if (this.root === null) { this.root = new Node(v); this._size = 1; return true; }
      let cur = this.root, parent = null;
      while (cur) {
        parent = cur;
        if (v === cur.v) return false; // ignore duplicates
        if (v < cur.v) cur = cur.left; else cur = cur.right;
      }
      if (v < parent.v) parent.left = new Node(v); else parent.right = new Node(v);
      this._size++;
      return true;
    }
    find(v) {
      let cur = this.root, path = [];
      while (cur) {
        path.push(cur);
        if (v === cur.v) return { found: true, path };
        cur = v < cur.v ? cur.left : cur.right;
      }
      return { found: false, path };
    }
    delete(v) {
      // delete node, return whether deleted
      const deleteRec = (node, v) => {
        if (!node) return [node, false];
        if (v < node.v) {
          let [newLeft, removed] = deleteRec(node.left, v); node.left = newLeft; return [node, removed];
        } else if (v > node.v) {
          let [newRight, removed] = deleteRec(node.right, v); node.right = newRight; return [node, removed];
        } else {
          // delete this node
          if (!node.left && !node.right) return [null, true];
          if (!node.left) return [node.right, true];
          if (!node.right) return [node.left, true];
          // two children: replace with inorder successor
          let succ = node.right; while (succ.left) succ = succ.left;
          node.v = succ.v;
          let [newRight] = deleteRec(node.right, succ.v);
          node.right = newRight;
          return [node, true];
        }
      };
      const [newRoot, removed] = deleteRec(this.root, v);
      if (removed) { this.root = newRoot; this._size--; }
      return removed;
    }
    // Traversals: return array of nodes (Node references)
    inorder(node=this.root, out=[]) { if(!node) return out; this.inorder(node.left,out); out.push(node); this.inorder(node.right,out); return out; }
    preorder(node=this.root, out=[]) { if(!node) return out; out.push(node); this.preorder(node.left,out); this.preorder(node.right,out); return out; }
    postorder(node=this.root, out=[]) { if(!node) return out; this.postorder(node.left,out); this.postorder(node.right,out); out.push(node); return out; }
    levelOrder() {
      let out = []; if(!this.root) return out;
      let q = [this.root];
      while(q.length){ let n = q.shift(); out.push(n); if(n.left) q.push(n.left); if(n.right) q.push(n.right); }
      return out;
    }
    height(node=this.root) {
      if(!node) return 0;
      return 1 + Math.max(this.height(node.left), this.height(node.right));
    }
    // for visualization, assign x positions using inorder index, and y by depth
    layout(gapX=70, gapY=80) {
      let idx = 0;
      const assignX = (n, depth) => {
        if(!n) return;
        assignX(n.left, depth+1);
        n.x = idx * gapX;
        n.y = depth * gapY;
        idx++;
        assignX(n.right, depth+1);
      };
      assignX(this.root, 0);
      // center x coordinates so tree is centered at middle
      const all = this.inorder();
      if(all.length===0) return { width:0, height:0 };
      const minX = Math.min(...all.map(n=>n.x)), maxX = Math.max(...all.map(n=>n.x));
      // translate so leftmost has margin 40
      const margin = 40;
      const shift = margin - minX;
      all.forEach(n => n.x += shift);
      const width = maxX - minX + margin*2 + 80;
      const height = (Math.max(...all.map(n=>n.y)) || 0) + gapY + 60;
      return { width, height };
    }
    // structure text representation (parentheses)
    structure(node=this.root) {
      if(!node) return '';
      const L = this.structure(node.left), R = this.structure(node.right);
      if(!L && !R) return `${node.v}`;
      return `${node.v}(${L||'-'},${R||'-'})`;
    }
  }

  // UI & drawing
  const svg = document.getElementById('svgCanvas');
  const valueInput = document.getElementById('valueInput');
  const insertBtn = document.getElementById('insertBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const clearBtn = document.getElementById('clearBtn');
  const randomBtn = document.getElementById('randomBtn');
  const searchInput = document.getElementById('searchInput');
  const searchBtn = document.getElementById('searchBtn');

  const inorderBtn = document.getElementById('inorderBtn');
  const preorderBtn = document.getElementById('preorderBtn');
  const postorderBtn = document.getElementById('postorderBtn');
  const levelBtn = document.getElementById('levelBtn');
  const traversalResult = document.getElementById('traversalResult');
  const nodeCountSpan = document.getElementById('nodeCount');
  const treeHeightSpan = document.getElementById('treeHeight');
  const structureText = document.getElementById('structureText');
  const speedInput = document.getElementById('speed');

  const tree = new BST();
  let animating = false;
  const nodeR = 20;

  function clearSVG() { while(svg.firstChild) svg.removeChild(svg.firstChild); }

  function draw() {
    clearSVG();
    const layout = tree.layout(90, 90);
    svg.setAttribute('viewBox', `0 0 ${Math.max(100, layout.width)} ${Math.max(200, layout.height)}`);
    const nodes = tree.inorder(); // all nodes
    if(nodes.length===0) {
      structureText.textContent = 'Empty';
      nodeCountSpan.textContent = '0';
      treeHeightSpan.textContent = '0';
      traversalResult.textContent = 'Result: —';
      return;
    }
    // draw edges first
    const edgesGroup = make('g');
    svg.appendChild(edgesGroup);
    const drawEdges = (n) => {
      if(!n) return;
      if(n.left) {
        const line = make('line'); line.setAttribute('x1', n.x); line.setAttribute('y1', n.y); line.setAttribute('x2', n.left.x); line.setAttribute('y2', n.left.y);
        line.classList.add('edge'); edgesGroup.appendChild(line);
      }
      if(n.right) {
        const line = make('line'); line.setAttribute('x1', n.x); line.setAttribute('y1', n.y); line.setAttribute('x2', n.right.x); line.setAttribute('y2', n.right.y);
        line.classList.add('edge'); edgesGroup.appendChild(line);
      }
      drawEdges(n.left); drawEdges(n.right);
    };
    drawEdges(tree.root);

    // draw nodes
    const nodesGroup = make('g');
    svg.appendChild(nodesGroup);
    const drawNodes = (n) => {
      if(!n) return;
      const g = make('g'); g.classList.add('node'); g.setAttribute('transform', `translate(${n.x}, ${n.y})`);
      const circ = make('circle'); circ.setAttribute('r', nodeR); circ.setAttribute('cx', 0); circ.setAttribute('cy', 0);
      const txt = make('text'); txt.textContent = n.v; g.appendChild(circ); g.appendChild(txt);
      // store a mapping for quick reference
      g._nodeRef = n;
      nodesGroup.appendChild(g);
      drawNodes(n.left); drawNodes(n.right);
    };
    drawNodes(tree.root);

    // place nodes visually a bit lower (y coords are top-based), add little shadow/label
    // update status
    nodeCountSpan.textContent = String(tree.size);
    treeHeightSpan.textContent = String(tree.height());
    structureText.textContent = tree.structure() || 'Empty';
  }

  function make(tag){ return document.createElementNS('http://www.w3.org/2000/svg', tag); }

  // Animation helpers
  function highlightPath(path, found, speed, cb) {
    if(!path || path.length===0) { cb && cb(); return; }
    animating = true;
    disableControls(true);
    let i = 0;
    const nodes = Array.from(svg.querySelectorAll('.node'));
    const resetAll = () => {
      nodes.forEach(g => { g.classList.remove('visited','found','highlight'); });
    };
    resetAll();
    const step = () => {
      if(i>0) {
        // mark previous as visited
        const prev = path[i-1];
        const gprev = nodes.find(g => g._nodeRef === prev);
        if(gprev) { gprev.classList.remove('highlight'); gprev.classList.add('visited'); }
      }
      if(i < path.length) {
        const cur = path[i];
        const gcur = nodes.find(g => g._nodeRef === cur);
        if(gcur) { gcur.classList.add('highlight'); }
        i++;
        setTimeout(step, speed);
      } else {
        // done: mark last
        const last = path[path.length-1];
        const glast = nodes.find(g => g._nodeRef === last);
        if(glast) {
          if(found) { glast.classList.remove('highlight'); glast.classList.add('found'); }
          else { glast.classList.remove('highlight'); glast.classList.add('visited'); }
        }
        animating = false;
        disableControls(false);
        cb && cb();
      }
    };
    step();
  }

  function animateSequence(nodeArr, speed, cb) {
    animating = true; disableControls(true);
    const nodes = Array.from(svg.querySelectorAll('.node'));
    nodes.forEach(g => { g.classList.remove('visited','found','highlight'); });
    let i = 0;
    const step = () => {
      if(i>0) {
        const prev = nodeArr[i-1];
        const gprev = nodes.find(g => g._nodeRef === prev);
        if(gprev) gprev.classList.remove('highlight'), gprev.classList.add('visited');
      }
      if(i < nodeArr.length) {
        const cur = nodeArr[i];
        const gcur = nodes.find(g => g._nodeRef === cur);
        if(gcur) gcur.classList.add('highlight');
        i++;
        setTimeout(step, speed);
      } else {
        animating = false; disableControls(false); cb && cb();
      }
    };
    step();
  }

  function disableControls(disable) {
    const els = [insertBtn, deleteBtn, clearBtn, randomBtn, searchBtn, inorderBtn, preorderBtn, postorderBtn, levelBtn];
    els.forEach(e => e.disabled = disable);
    speedInput.disabled = disable;
    valueInput.disabled = disable;
    searchInput.disabled = disable;
  }

  // Event handlers
  insertBtn.addEventListener('click', () => {
    const v = parseInt(valueInput.value);
    if(Number.isNaN(v)) return alert('Enter an integer to insert.');
    const ok = tree.insert(v);
    if(!ok) alert('Value already exists in BST (duplicates ignored).');
    valueInput.value = '';
    draw();
  });
  deleteBtn.addEventListener('click', () => {
    const v = parseInt(valueInput.value);
    if(Number.isNaN(v)) return alert('Enter an integer to delete.');
    const ok = tree.delete(v);
    if(!ok) alert('Value not found.');
    valueInput.value = '';
    draw();
  });
  clearBtn.addEventListener('click', () => {
    if(!confirm('Clear the entire tree?')) return;
    tree.root = null; tree._size = 0;
    draw();
  });
  randomBtn.addEventListener('click', () => {
    if(animating) return;
    // generate 7 unique random integers between 1..99
    const count = 7;
    const set = new Set();
    while(set.size < count) set.add(Math.floor(Math.random()*99)+1);
    set.forEach(n => tree.insert(n));
    draw();
  });

  searchBtn.addEventListener('click', () => {
    if(animating) return;
    const v = parseInt(searchInput.value);
    if(Number.isNaN(v)) return alert('Enter an integer to search.');
    const {found, path} = tree.find(v);
    if(path.length===0) { alert('Tree is empty.'); return; }
    const speed = parseInt(speedInput.value);
    highlightPath(path, found, speed, () => {
      if(found) traversalResult.textContent = `Result: Found ${v} (visited ${path.length} nodes)`;
      else traversalResult.textContent = `Result: Not found (visited ${path.length} nodes)`;
    });
  });

  inorderBtn.addEventListener('click', ()=> {
    if(animating) return;
    const arr = tree.inorder();
    if(arr.length===0) { alert('Tree is empty.'); return; }
    animateSequence(arr, parseInt(speedInput.value), ()=> traversalResult.textContent = 'Result: In-order: ' + arr.map(n=>n.v).join(', '));
  });
  preorderBtn.addEventListener('click', ()=> {
    if(animating) return;
    const arr = tree.preorder();
    if(arr.length===0) { alert('Tree is empty.'); return; }
    animateSequence(arr, parseInt(speedInput.value), ()=> traversalResult.textContent = 'Result: Pre-order: ' + arr.map(n=>n.v).join(', '));
  });
  postorderBtn.addEventListener('click', ()=> {
    if(animating) return;
    const arr = tree.postorder();
    if(arr.length===0) { alert('Tree is empty.'); return; }
    animateSequence(arr, parseInt(speedInput.value), ()=> traversalResult.textContent = 'Result: Post-order: ' + arr.map(n=>n.v).join(', '));
  });
  levelBtn.addEventListener('click', ()=> {
    if(animating) return;
    const arr = tree.levelOrder();
    if(arr.length===0) { alert('Tree is empty.'); return; }
    animateSequence(arr, parseInt(speedInput.value), ()=> traversalResult.textContent = 'Result: Level-order: ' + arr.map(n=>n.v).join(', '));
  });

  // make clicking on a node prefill the input for quick delete/search
  svg.addEventListener('click', (ev) => {
    if(ev.target && ev.target.parentNode && ev.target.parentNode.classList && ev.target.parentNode.classList.contains('node')) {
      const node = ev.target.parentNode._nodeRef;
      if(node) {
        valueInput.value = node.v;
        searchInput.value = node.v;
      }
    }
  });

  // initial draw (empty)
  draw();

  // keyboard shortcuts: Enter in value input -> insert
  valueInput.addEventListener('keypress', (e)=> { if(e.key === 'Enter') insertBtn.click(); });
  searchInput.addEventListener('keypress', (e)=> { if(e.key === 'Enter') searchBtn.click(); });

  // small helper: allow dragging pan on svg if larger than container (optional)
  let isDown=false, startX=0, startY=0, viewBox = {x:0,y:0,w:1200,h:600};
  svg.addEventListener('mousedown', (e) => {
    if(e.button !== 0) return;
    isDown = true; startX = e.clientX; startY = e.clientY;
    const vb = svg.getAttribute('viewBox').split(' ').map(Number); viewBox = {x:vb[0], y:vb[1], w:vb[2], h:vb[3]};
    svg.style.cursor = 'grabbing';
  });
  window.addEventListener('mouseup', ()=> { isDown = false; svg.style.cursor = 'default'; });
  window.addEventListener('mousemove', (e) => {
    if(!isDown) return;
    const dx = (startX - e.clientX), dy = (startY - e.clientY);
    svg.setAttribute('viewBox', `${viewBox.x + dx} ${viewBox.y + dy} ${viewBox.w} ${viewBox.h}`);
  });

  // small accessibility: make svg resize on window
  window.addEventListener('resize', () => draw());

  // expose tree for console debugging (optional)
  window.__bst = tree;
})();
</script>
</body>
</html>