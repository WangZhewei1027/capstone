<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Binary Tree (BST) Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    :root {
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #38bdf8;
      --muted: #94a3b8;
      --good: #10b981;
      --danger: #ef4444;
      --card: #071025;
      --text: #e6eef8;
    }
    html,body { height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; background: linear-gradient(180deg,#071029 0%, #041025 100%); color:var(--text); }
    .container { max-width:1200px; margin:18px auto; padding:18px; }
    header { display:flex; gap:16px; align-items:center; margin-bottom:16px; }
    h1 { margin:0; font-size:20px; letter-spacing:0.2px; }
    p.desc { margin:4px 0 0 0; color:var(--muted); font-size:13px; max-width:780px; }
    .layout { display:grid; grid-template-columns: 340px 1fr; gap:16px; align-items:start; }
    .panel { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); padding:14px; border-radius:10px; }
    .controls { display:flex; flex-direction:column; gap:10px; }
    label { font-size:13px; color:var(--muted); }
    .row { display:flex; gap:8px; align-items:center; }
    input[type="number"], input[type="text"], select { padding:8px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:var(--text); width:100%; outline:none; }
    button { background:var(--panel); border:1px solid rgba(255,255,255,0.04); color:var(--text); padding:8px 10px; border-radius:6px; cursor:pointer; }
    button.primary { background:linear-gradient(90deg,#0ea5e9,#06b6d4); color:#021024; border:none; font-weight:600; }
    button.warn { background:linear-gradient(90deg,#fb7185,#fb923c); color:#071024; border:none; }
    .small { padding:6px 8px; font-size:13px; }
    .canvasWrap { background: linear-gradient(180deg,#041021,#02101a); min-height:620px; border-radius:10px; padding:12px; border:1px solid rgba(255,255,255,0.03); position:relative; overflow:auto; }
    svg { width:100%; height:600px; display:block; }
    .legend { display:flex; gap:8px; align-items:center; margin-top:8px; color:var(--muted); font-size:13px; }
    .badge { display:inline-flex; gap:8px; align-items:center; padding:6px 8px; border-radius:6px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.02); }
    .muted { color:var(--muted); font-size:13px; }
    .footer { margin-top:10px; color:var(--muted); font-size:13px; }
    .note { font-size:13px; color:var(--muted); margin-top:6px; }
    .controls .group { background:rgba(255,255,255,0.01); padding:10px; border-radius:8px; display:flex; flex-direction:column; gap:8px; }
    .flex { display:flex; gap:8px; align-items:center; }
    .status { font-size:13px; color:var(--muted); min-height:20px; }
    .node-label { font-weight:700; font-size:13px; }
    footer { margin-top:16px; color:var(--muted); font-size:12px; text-align:right; }
    a { color:var(--accent); text-decoration:none; }
    @media (max-width:900px){
      .layout { grid-template-columns: 1fr; }
      svg { height:520px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Binary Tree Visualizer (BST)</h1>
        <p class="desc">Interactive demonstration of a Binary Search Tree: insert, delete, search, and traverse with animated layout and highlights. Designed to teach how a binary tree organizes data and operates.</p>
      </div>
    </header>

    <div class="layout">
      <div class="panel controls">
        <div class="group">
          <label>Node value (integer)</label>
          <div class="row">
            <input id="valueInput" type="number" placeholder="e.g., 42" />
            <button id="insertBtn" class="primary small">Insert</button>
            <button id="deleteBtn" class="small">Delete</button>
          </div>
          <div class="row">
            <input id="searchInput" type="number" placeholder="Search value" />
            <button id="searchBtn" class="small">Search</button>
            <button id="clearSearchBtn" class="small">Clear</button>
          </div>
          <div class="row">
            <button id="randomBtn" class="small">Random tree</button>
            <input id="randomCount" type="number" value="8" min="1" max="40" style="width:72px" />
            <button id="clearBtn" class="small">Clear</button>
          </div>
        </div>

        <div class="group">
          <label>Traversals (animated)</label>
          <div class="flex">
            <button id="inorderBtn" class="small">In-order</button>
            <button id="preorderBtn" class="small">Pre-order</button>
            <button id="postorderBtn" class="small">Post-order</button>
            <button id="levelorderBtn" class="small">Level-order</button>
            <button id="stopAnimBtn" class="small">Stop</button>
          </div>
          <div class="note">Traversal will highlight nodes in the order they are visited. Level-order = breadth-first.</div>
        </div>

        <div class="group">
          <label>Step-through insertion (visualize path)</label>
          <div class="row">
            <input id="stepInput" type="number" placeholder="Value to insert" />
            <button id="stepInsertBtn" class="small">Step Insert</button>
            <button id="skipStepBtn" class="small">Skip Steps</button>
          </div>
          <div class="note">Use this to see how an inserted value navigates the tree to its spot.</div>
        </div>

        <div class="group">
          <label>Options & info</label>
          <div style="display:flex; gap:8px; align-items:center;">
            <label style="margin:0;">Allow duplicates</label>
            <input id="dupToggle" type="checkbox"/>
          </div>
          <div class="status" id="status">Nodes: 0 | Height: 0</div>
          <div class="note">This visualizer implements a Binary Search Tree (BST). Left child &lt; parent; Right child &gt; parent (duplicates optional).</div>
        </div>

        <div class="group">
          <label>Examples (quick)</label>
          <div class="flex">
            <button id="example1" class="small">Balanced 7</button>
            <button id="example2" class="small">Skewed</button>
            <button id="example3" class="small">Custom set</button>
          </div>
        </div>

      </div>

      <div class="panel canvasWrap">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div class="muted">Click a node to remove it (quick delete). Double-click to show details.</div>
          <div class="legend">
            <div class="badge"><span style="display:inline-block;width:12px;height:12px;border-radius:3px;background:var(--accent)"></span> Current highlight</div>
            <div class="badge"><span style="display:inline-block;width:12px;height:12px;border-radius:3px;background:var(--good)"></span> Found / success</div>
            <div class="badge"><span style="display:inline-block;width:12px;height:12px;border-radius:3px;background:var(--danger)"></span> Remove / selected</div>
          </div>
        </div>

        <svg id="svgCanvas" xmlns="http://www.w3.org/2000/svg"></svg>

        <div class="footer">Tip: Insert numbers, try traversals and watch how the layout changes. This is a BST—structure depends on insertion order.</div>
      </div>
    </div>

    <footer style="max-width:1200px;margin:10px auto 40px auto;">
      Built for education — source in this single HTML file.
    </footer>
  </div>

<script>
/*
 Binary Search Tree Visualizer
 - Single-file demonstration
 - Features: insert, delete, search, traversals (animated), random trees, step-through insert
 - Rendering uses SVG, layout computed by inorder positions
*/

(() => {
  // Utilities
  const $ = id => document.getElementById(id);
  const svg = $('svgCanvas');
  const NS = "http://www.w3.org/2000/svg";

  // State
  let root = null;
  let allowDuplicates = false;
  let animations = { running: false, queue: [], currentTimeouts: [] };
  let stepMode = { active: false, steps: [], idx: 0, value: null, skip: false };

  // Visual constants
  const NODE_RADIUS = 20;
  const LEVEL_HEIGHT = 100;
  const H_SPACING = 30; // base spacing between inorder positions

  // Node class
  class Node {
    constructor(value) {
      this.value = value;
      this.left = null;
      this.right = null;
      // layout positions
      this.x = 0;
      this.y = 0;
      // for highlighting
      this.id = 'n' + Math.random().toString(36).slice(2,9);
    }
  }

  // BST operations
  function insertBST(value) {
    if (root === null) {
      root = new Node(value);
      updateAndRender();
      return root;
    }
    let cur = root;
    let parent = null;
    const path = [];
    while (cur) {
      parent = cur;
      path.push(cur);
      if (value === cur.value) {
        if (!allowDuplicates) return null;
        // decide to go right for duplicates
        cur = cur.right;
      } else if (value < cur.value) {
        cur = cur.left;
      } else {
        cur = cur.right;
      }
    }
    const node = new Node(value);
    if (value === parent.value) {
      parent.right = node;
    } else if (value < parent.value) {
      parent.left = node;
    } else {
      parent.right = node;
    }
    updateAndRender();
    return node;
  }

  function searchBST(value) {
    let cur = root;
    const path = [];
    while (cur) {
      path.push(cur);
      if (value === cur.value) return { found: cur, path };
      if (value < cur.value) cur = cur.left;
      else cur = cur.right;
    }
    return { found: null, path };
  }

  function deleteBST(value) {
    // delete first node found with the value (standard BST delete)
    const res = _deleteNode(root, null, value);
    if (res.deleted) {
      root = res.newRoot;
      updateAndRender();
      return true;
    }
    return false;
  }

  function _deleteNode(node, parent, value) {
    if (!node) return {deleted:false, newRoot: root};
    if (value < node.value) return _deleteNode(node.left, node, value);
    if (value > node.value) return _deleteNode(node.right, node, value);
    // found node
    if (!node.left && !node.right) {
      if (!parent) return {deleted:true, newRoot: null};
      if (parent.left === node) parent.left = null; else parent.right = null;
      return {deleted:true, newRoot: root};
    }
    if (!node.left || !node.right) {
      const child = node.left || node.right;
      if (!parent) return {deleted:true, newRoot: child};
      if (parent.left === node) parent.left = child; else parent.right = child;
      return {deleted:true, newRoot: root};
    }
    // two children: replace with inorder successor (min in right subtree)
    let succParent = node;
    let succ = node.right;
    while (succ.left) { succParent = succ; succ = succ.left; }
    node.value = succ.value;
    // remove successor node
    if (succParent.left === succ) succParent.left = succ.right;
    else succParent.right = succ.right;
    return {deleted:true, newRoot: root};
  }

  // Traversals returning arrays of nodes visited
  function inorder(node, out=[]) {
    if (!node) return out;
    inorder(node.left, out);
    out.push(node);
    inorder(node.right, out);
    return out;
  }
  function preorder(node, out=[]) {
    if (!node) return out;
    out.push(node);
    preorder(node.left, out);
    preorder(node.right, out);
    return out;
  }
  function postorder(node, out=[]) {
    if (!node) return out;
    postorder(node.left, out);
    postorder(node.right, out);
    out.push(node);
    return out;
  }
  function levelorder(node) {
    const out = [];
    if (!node) return out;
    const q = [node];
    while (q.length) {
      const n = q.shift();
      out.push(n);
      if (n.left) q.push(n.left);
      if (n.right) q.push(n.right);
    }
    return out;
  }

  // Layout computation
  function computeLayout() {
    // assign inorder x positions based on index
    const nodes = [];
    (function collect(n, depth=0) {
      if (!n) return;
      collect(n.left, depth+1);
      nodes.push({node:n, depth});
      collect(n.right, depth+1);
    })(root);
    // map node -> inorder index
    const indexMap = new Map();
    nodes.forEach((it, idx) => indexMap.set(it.node, idx));
    const total = Math.max(1, nodes.length);
    // set x,y
    (function assign(n, depth=0) {
      if (!n) return;
      assign(n.left, depth+1);
      const idx = indexMap.get(n);
      n.x = (idx + 1) * H_SPACING + idx*10 + NODE_RADIUS + 20;
      n.y = depth * LEVEL_HEIGHT + NODE_RADIUS + 20;
      assign(n.right, depth+1);
    })(root);
  }

  // Rendering
  function clearSVG() {
    while (svg.firstChild) svg.removeChild(svg.firstChild);
  }

  function render() {
    clearSVG();
    if (!root) {
      // show placeholder text
      const t = document.createElementNS(NS,'text');
      t.setAttribute('x', '50%');
      t.setAttribute('y', '50%');
      t.setAttribute('text-anchor','middle');
      t.setAttribute('fill','rgba(255,255,255,0.06)');
      t.setAttribute('font-size','20');
      t.textContent = 'Tree is empty — insert some values';
      svg.appendChild(t);
      updateStatus();
      return;
    }
    computeLayout();
    // draw edges then nodes (so nodes on top)
    (function drawEdges(n){
      if (!n) return;
      if (n.left) {
        drawLine(n, n.left);
        drawEdges(n.left);
      }
      if (n.right) {
        drawLine(n, n.right);
        drawEdges(n.right);
      }
    })(root);

    // draw nodes
    (function drawNodes(n){
      if (!n) return;
      drawNode(n);
      drawNodes(n.left);
      drawNodes(n.right);
    })(root);

    updateStatus();
  }

  function drawLine(a,b) {
    const g = document.createElementNS(NS,'g');
    const line = document.createElementNS(NS,'line');
    line.setAttribute('x1', a.x);
    line.setAttribute('y1', a.y);
    line.setAttribute('x2', b.x);
    line.setAttribute('y2', b.y);
    line.setAttribute('stroke','rgba(255,255,255,0.06)');
    line.setAttribute('stroke-width','2');
    g.appendChild(line);
    svg.appendChild(g);
  }

  function drawNode(n) {
    const g = document.createElementNS(NS,'g');
    g.setAttribute('transform', `translate(${n.x},${n.y})`);
    g.setAttribute('data-id', n.id);
    // circle
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('r', NODE_RADIUS);
    c.setAttribute('fill', 'rgba(2,8,20,0.9)');
    c.setAttribute('stroke', 'rgba(255,255,255,0.06)');
    c.setAttribute('stroke-width','2');
    c.setAttribute('class','nodeCircle');
    g.appendChild(c);
    // text
    const t = document.createElementNS(NS,'text');
    t.setAttribute('x', 0);
    t.setAttribute('y', 6);
    t.setAttribute('text-anchor','middle');
    t.setAttribute('font-size','13');
    t.setAttribute('fill','white');
    t.setAttribute('font-weight','600');
    t.textContent = n.value;
    g.appendChild(t);

    // event handlers
    g.addEventListener('click', (ev) => {
      ev.stopPropagation();
      // quick delete on click
      highlightNodes([n], {color:'var(--danger)', duration:600}).then(() => {
        deleteNodeByRef(n);
      });
    });
    g.addEventListener('dblclick', (ev) => {
      ev.stopPropagation();
      alert('Node value: ' + n.value + '\\nLeft: ' + (n.left ? n.left.value : 'null') + '\\nRight: ' + (n.right ? n.right.value : 'null'));
    });

    svg.appendChild(g);
  }

  function deleteNodeByRef(nodeRef) {
    // delete by value: delete first occurrence of that value found in BST
    deleteBST(nodeRef.value);
  }

  // Highlighting and animation helpers
  function highlightNodes(nodeList, {color='var(--accent)', duration=800} = {}) {
    // returns a promise that resolves after animation
    return new Promise(res => {
      // find svg groups by data-id
      const ids = nodeList.map(n => n.id);
      const groups = [];
      for (const g of svg.querySelectorAll('g')) {
        if (ids.includes(g.getAttribute('data-id'))) groups.push(g);
      }
      groups.forEach(g => {
        const circle = g.querySelector('circle');
        if (!circle) return;
        circle._origFill = circle._origFill || circle.getAttribute('fill');
        circle.setAttribute('fill', color);
        circle.setAttribute('stroke', 'rgba(255,255,255,0.18)');
        circle.setAttribute('r', NODE_RADIUS + 6);
      });
      const t = setTimeout(() => {
        groups.forEach(g => {
          const circle = g.querySelector('circle');
          if (!circle) return;
          circle.setAttribute('fill', circle._origFill || 'rgba(2,8,20,0.9)');
          circle.setAttribute('stroke', 'rgba(255,255,255,0.06)');
          circle.setAttribute('r', NODE_RADIUS);
        });
        res();
      }, duration);
      animations.currentTimeouts.push(t);
    });
  }

  function animateTraversal(nodes, color='var(--accent)', stepDelay=700) {
    stopAnimations();
    animations.running = true;
    let promise = Promise.resolve();
    nodes.forEach((n, idx) => {
      promise = promise.then(() => {
        if (!animations.running) return Promise.resolve();
        return highlightNodes([n], {color, duration: stepDelay});
      });
    });
    // finish
    promise.then(() => { animations.running = false; animations.currentTimeouts = []; });
  }

  function stopAnimations() {
    animations.running = false;
    animations.currentTimeouts.forEach(t => clearTimeout(t));
    animations.currentTimeouts = [];
  }

  // Status
  function updateStatus() {
    const count = countNodes(root);
    const h = treeHeight(root);
    $('status').textContent = `Nodes: ${count} | Height: ${h}`;
  }
  function countNodes(n) { if (!n) return 0; return 1 + countNodes(n.left) + countNodes(n.right); }
  function treeHeight(n) { if (!n) return 0; return 1 + Math.max(treeHeight(n.left), treeHeight(n.right)); }

  // UI wiring
  $('insertBtn').addEventListener('click', () => {
    const val = parseInt($('valueInput').value);
    if (Number.isNaN(val)) return alert('Please enter a number.');
    insertBST(val);
    $('valueInput').value = '';
    render();
  });

  $('deleteBtn').addEventListener('click', () => {
    const val = parseInt($('valueInput').value);
    if (Number.isNaN(val)) return alert('Please enter a number to delete.');
    const ok = deleteBST(val);
    if (!ok) alert('Value not found: ' + val);
    $('valueInput').value = '';
    render();
  });

  $('searchBtn').addEventListener('click', () => {
    const val = parseInt($('searchInput').value);
    if (Number.isNaN(val)) return alert('Enter a number to search.');
    const res = searchBST(val);
    animateSearchPath(res.path, res.found);
  });

  function animateSearchPath(path, foundNode) {
    if (!path.length) {
      alert('Tree is empty.');
      return;
    }
    stopAnimations();
    // animate path: highlight nodes visited (accent), final node green if found else red
    let promise = Promise.resolve();
    path.forEach((n, idx) => {
      promise = promise.then(() => highlightNodes([n], {color:'var(--accent)', duration:500}));
    });
    promise = promise.then(() => {
      if (foundNode) return highlightNodes([foundNode], {color:'var(--good)', duration:900});
      // highlight last visited as danger
      const last = path[path.length-1];
      return highlightNodes([last], {color:'var(--danger)', duration:900});
    });
    promise.then(() => updateStatus());
  }

  $('clearSearchBtn').addEventListener('click', () => {
    stopAnimations();
    render();
    $('searchInput').value = '';
  });

  $('randomBtn').addEventListener('click', () => {
    const n = parseInt($('randomCount').value) || 8;
    generateRandomTree(n);
  });

  function generateRandomTree(n) {
    root = null;
    const arr = [];
    while (arr.length < n) {
      const v = Math.floor(Math.random() * (n*4)) + 1;
      if (!allowDuplicates && arr.includes(v)) continue;
      arr.push(v);
    }
    arr.forEach(v => insertBST(v));
    render();
  }

  $('clearBtn').addEventListener('click', () => {
    root = null;
    stopAnimations();
    render();
  });

  $('inorderBtn').addEventListener('click', () => {
    if (!root) return;
    const nodes = inorder(root);
    animateTraversal(nodes, 'var(--accent)', 600);
  });
  $('preorderBtn').addEventListener('click', () => {
    if (!root) return;
    animateTraversal(preorder(root), 'var(--accent)', 600);
  });
  $('postorderBtn').addEventListener('click', () => {
    if (!root) return;
    animateTraversal(postorder(root), 'var(--accent)', 600);
  });
  $('levelorderBtn').addEventListener('click', () => {
    if (!root) return;
    animateTraversal(levelorder(root), 'var(--accent)', 600);
  });
  $('stopAnimBtn').addEventListener('click', () => {
    stopAnimations();
    render();
  });

  $('dupToggle').addEventListener('change', (e) => {
    allowDuplicates = e.target.checked;
  });

  // Step-through insertion
  $('stepInsertBtn').addEventListener('click', () => {
    const v = parseInt($('stepInput').value);
    if (Number.isNaN(v)) return alert('Enter a number to step through insertion.');
    stepMode.active = true;
    stepMode.value = v;
    stepMode.idx = 0;
    stepMode.skip = false;
    // compute steps where we would visit nodes until place found
    stepMode.steps = computeInsertPath(v);
    if (!stepMode.steps) {
      // empty tree: insert at root immediately
      insertBST(v);
      render();
      stepMode.active = false;
      return;
    }
    // animate each step sequentially, pause between steps, let user skip
    async function runSteps() {
      for (let i=0;i<stepMode.steps.length;i++) {
        if (stepMode.skip) break;
        const n = stepMode.steps[i];
        await highlightNodes([n], {color:'var(--accent)', duration:700});
      }
      if (!stepMode.skip) {
        // final highlight to indicate insertion point
        await highlightNodes(stepMode.steps.slice(-1), {color:'var(--good)', duration:700});
      }
      // perform actual insertion (unless skip)
      if (!stepMode.skip) insertBST(v);
      else insertBST(v); // still insert if skipped but visual steps skipped
      render();
      stepMode.active = false;
    }
    runSteps();
  });

  $('skipStepBtn').addEventListener('click', () => {
    if (!stepMode.active) return;
    stepMode.skip = true;
    stopAnimations();
    render();
  });

  function computeInsertPath(value) {
    if (!root) return null;
    const path = [];
    let cur = root;
    while (cur) {
      path.push(cur);
      if (value === cur.value && !allowDuplicates) break;
      if (value < cur.value) {
        if (!cur.left) break;
        cur = cur.left;
      } else {
        if (!cur.right) break;
        cur = cur.right;
      }
    }
    return path;
  }

  // quick examples
  $('example1').addEventListener('click', () => {
    root = null;
    // balanced-ish insertion order
    [50,30,70,20,40,60,80].forEach(v => insertBST(v));
    render();
  });
  $('example2').addEventListener('click', () => {
    root = null;
    // skewed (ascending)
    [5,10,15,20,25,30].forEach(v => insertBST(v));
    render();
  });
  $('example3').addEventListener('click', () => {
    root = null;
    [15,6,23,4,7,71,5,50].forEach(v => insertBST(v));
    render();
  });

  // canvas click to clear highlights
  svg.addEventListener('click', () => {
    stopAnimations();
    render();
  });

  // initial render
  render();

  // Expose some functions to console for educational experimentation
  window._BST = {
    root,
    insert: (v) => { insertBST(v); render(); },
    delete: (v) => { deleteBST(v); render(); },
    inorder: () => inorder(root).map(n=>n.value),
    preorder: () => preorder(root).map(n=>n.value),
    postorder: () => postorder(root).map(n=>n.value),
    levelorder: () => levelorder(root).map(n=>n.value),
    render,
    getRoot: () => root
  };

})();
</script>
</body>
</html>