<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Longest Common Subsequence Visualizer</title>
<style>
  :root{
    --bg:#f7f9fc;
    --panel:#ffffff;
    --accent:#2b87ff;
    --muted:#6b7280;
    --good:#10b981;
    --warn:#ffb020;
    --danger:#ef4444;
    --cell:#eef2ff;
  }
  body{
    font-family: Inter, Roboto, "Segoe UI", Arial, sans-serif;
    background: linear-gradient(180deg,#e8f0ff 0%,var(--bg) 40%);
    margin:0;
    color:#111827;
    padding:20px;
  }
  header{
    display:flex;
    gap:16px;
    align-items:center;
    margin-bottom:16px;
  }
  h1{font-size:20px;margin:0;}
  .container{
    display:grid;
    grid-template-columns: 360px 1fr;
    gap:18px;
    align-items:start;
  }
  .panel{
    background:var(--panel);
    border-radius:10px;
    padding:14px;
    box-shadow:0 6px 20px rgba(20,30,60,0.06);
  }
  label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px;}
  textarea, input[type=text]{
    width:100%;
    box-sizing:border-box;
    padding:8px 10px;
    border-radius:8px;
    border:1px solid #e6e9ef;
    font-family:monospace;
    resize:vertical;
    min-height:46px;
  }
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;}
  button{
    background:var(--accent);
    color:white;
    border:0;
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    font-weight:600;
  }
  button.secondary{
    background:#f3f4f6;
    color:#111827;
    border:1px solid #e5e7eb;
  }
  .small{font-size:13px;padding:6px 8px;}
  .muted{color:var(--muted);font-size:13px;margin-top:8px;}
  .visual{
    overflow:auto;
    padding:10px;
  }
  table.lcs{
    border-collapse:collapse;
    background:white;
    margin:6px 0;
    box-shadow:0 2px 8px rgba(10,20,60,0.04);
    border-radius:8px;
    overflow:hidden;
  }
  table.lcs td, table.lcs th{
    border:1px solid #eef2f7;
    padding:8px;
    min-width:36px;
    text-align:center;
    font-family:monospace;
    font-size:14px;
    vertical-align:middle;
    position:relative;
    background:white;
  }
  table.lcs th{
    background:#fbfdff;
    color:#374151;
    font-weight:600;
    min-width:24px;
  }
  .charcell{background:linear-gradient(180deg,#ffffff,#f6f9ff); font-weight:700;}
  .value{font-weight:700;color:#111827;}
  .dir{font-size:12px;color:#94a3b8;position:absolute;bottom:4px;right:4px;}
  .match{background:linear-gradient(180deg,#fff8ef,#fff5ee); border-left:4px solid var(--good);}
  .path{background:linear-gradient(90deg,#fffbeb,#fff7f4); border-left:4px solid var(--warn);}
  .current{outline:3px solid rgba(43,135,255,0.16); box-shadow:0 6px 18px rgba(43,135,255,0.08) inset;}
  .labels{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:8px}
  .info{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-top:8px}
  .badge{background:#eef2ff;color:var(--accent);padding:6px 10px;border-radius:999px;font-weight:700}
  .pseudocode{background:#0f1724;color:#f8fafc;padding:12px;border-radius:8px;margin-top:12px;font-family:monospace;font-size:13px;white-space:pre-wrap}
  .footer{margin-top:12px;color:var(--muted);font-size:13px;}
  .options{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
  .limit{width:72px;}
  .resultList{max-height:160px;overflow:auto;border:1px dashed #e6eefc;padding:8px;border-radius:8px;background:#fbfdff}
  .tooltip{
    position:relative;
  }
  .tooltip:hover::after{
    content:attr(data-tip);
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    bottom:calc(100% + 8px);
    background:#111827;color:white;padding:6px 8px;border-radius:6px;font-size:12px;white-space:nowrap;z-index:10;
  }
  .smallnote{font-size:12px;color:var(--muted);margin-top:8px}
  @media(max-width:920px){
    .container{grid-template-columns:1fr; }
  }
</style>
</head>
<body>
  <header>
    <h1>Longest Common Subsequence (LCS) Visualizer</h1>
    <div class="muted">Interactive demonstration with DP table, backtracking, and "all LCS" enumeration.</div>
  </header>

  <div class="container">
    <div class="panel">
      <label for="a">String A</label>
      <textarea id="a" placeholder="Enter first string (A)">ABCBDAB</textarea>

      <label for="b" style="margin-top:10px">String B</label>
      <textarea id="b" placeholder="Enter second string (B)">BDCABA</textarea>

      <div class="controls">
        <button id="compute">Compute DP Table</button>
        <button class="secondary" id="random">Random Strings</button>
        <button class="secondary" id="clear">Clear</button>
        <button id="findAll" class="small">Find All LCS</button>
        <input type="number" id="limit" class="limit" value="50" min="1" title="Max number of sequences to return">
      </div>

      <div class="options">
        <label class="muted">Tie-breaker</label>
        <select id="tiebreaker">
          <option value="left">Prefer LEFT on ties</option>
          <option value="up">Prefer UP on ties</option>
        </select>
        <label class="muted">Auto-play backtrack</label>
        <input type="checkbox" id="autoplay" checked>
        <label class="muted">Speed</label>
        <input type="range" id="speed" min="100" max="1200" value="400">
      </div>

      <div class="info">
        <div class="badge" id="lengthBadge">LCS length: -</div>
        <div class="muted" id="oneLCS">Sequence: -</div>
      </div>

      <div class="smallnote">You can hover any DP cell to see how its value was derived (match or from up/left). Click "Find All LCS" to enumerate distinct sequences (limited).</div>

      <div style="margin-top:12px" class="pseudocode">
Pseudocode (dynamic programming):
for i from 0..m:
  dp[i][0] = 0
for j from 0..n:
  dp[0][j] = 0
for i from 1..m:
  for j from 1..n:
    if A[i-1] == B[j-1]:
      dp[i][j] = dp[i-1][j-1] + 1
    else:
      dp[i][j] = max(dp[i-1][j], dp[i][j-1])

Time: O(m*n)   Space: O(m*n) (can be reduced to O(min(m,n)) for length only)
      </div>
    </div>

    <div class="panel visual">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:700">DP Table & Backtracking</div>
        <div>
          <button id="step" class="secondary small">Step Backtrack</button>
          <button id="play" class="small">Play</button>
          <button id="resetHighlight" class="secondary small">Reset</button>
        </div>
      </div>

      <div id="tableContainer" style="overflow:auto;margin-top:10px"></div>

      <div style="margin-top:10px;display:flex;gap:12px;align-items:start">
        <div style="flex:1">
          <div style="font-weight:700;margin-bottom:6px">Backtrack path (cells visited)</div>
          <div id="pathDisplay" class="resultList">No computation yet.</div>
        </div>
        <div style="width:320px">
          <div style="font-weight:700;margin-bottom:6px">All LCS results</div>
          <div id="allResults" class="resultList">Press "Find All LCS" to enumerate sequences.</div>
        </div>
      </div>

      <div class="footer">Tip: Use short strings for exhaustive "all LCS" enumeration to avoid exponential results. This demo caps the number of sequences returned by the limit input.</div>
    </div>
  </div>

<script>
(function(){
  // Utility helpers
  const el = id => document.getElementById(id);
  const escapeHTML = s => (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

  // DOM elements
  const taA = el('a'), taB = el('b');
  const computeBtn = el('compute'), randomBtn = el('random'), clearBtn = el('clear');
  const tableContainer = el('tableContainer');
  const lengthBadge = el('lengthBadge'), oneLCS = el('oneLCS');
  const stepBtn = el('step'), playBtn = el('play'), resetBtn = el('resetHighlight');
  const pathDisplay = el('pathDisplay'), allResults = el('allResults');
  const findAllBtn = el('findAll'), limitInput = el('limit');
  const tiebreaker = el('tiebreaker'), autoplay = el('autoplay'), speed = el('speed');

  // State
  let A = '', B = '';
  let dp = []; // (m+1) x (n+1)
  let m=0,n=0;
  let path = []; // list of positions visited during deterministic backtrack
  let playInterval = null;

  function computeDP(){
    A = taA.value || '';
    B = taB.value || '';
    m = A.length; n = B.length;
    dp = Array.from({length:m+1}, ()=> new Array(n+1).fill(0));
    for(let i=1;i<=m;i++){
      for(let j=1;j<=n;j++){
        if(A[i-1] === B[j-1]){
          dp[i][j] = dp[i-1][j-1] + 1;
        } else {
          dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
        }
      }
    }
    renderTable();
    const len = dp[m][n];
    lengthBadge.textContent = 'LCS length: ' + len;
    // deterministic backtrack to produce one LCS according to tiebreaker
    const seq = deterministicBacktrack(tiebreaker.value);
    oneLCS.textContent = 'Sequence: ' + (seq || '∅');
    path = buildPathForHighlight(tiebreaker.value); // store path for step/play
    renderPathList();
    allResults.innerHTML = 'Press "Find All LCS" to enumerate sequences.';
  }

  // Render DP table as HTML table
  function renderTable(){
    tableContainer.innerHTML = '';
    // Build table element
    const tbl = document.createElement('table');
    tbl.className = 'lcs';
    const thead = document.createElement('thead');
    const headRow = document.createElement('tr');
    headRow.appendChild(document.createElement('th')); // top-left empty
    headRow.appendChild(document.createElement('th')); // empty for A char column header
    // column labels: first an empty (for the zero column), then characters of B
    const thEmpty = document.createElement('th');
    thEmpty.className = 'charcell';
    thEmpty.colSpan = 0;
    headRow.appendChild(thEmpty); // placeholder, we'll build differently below

    // We'll construct full grid in tbody for easier control
    tbl.appendChild(renderGrid());
    tableContainer.appendChild(tbl);
  }

  function renderGrid(){
    const tbody = document.createElement('tbody');
    // First row: top header (empty cell + chars of B)
    const topRow = document.createElement('tr');
    topRow.appendChild(createHeaderCell('')); // empty top-left
    topRow.appendChild(createHeaderCell('')); // zero column label
    for(let j=1;j<=n;j++){
      topRow.appendChild(createHeaderCell(escapeHTML(B[j-1])));
    }
    tbody.appendChild(topRow);

    // Rows for i=0..m
    // Row for i=0: values dp[0][j]
    const row0 = document.createElement('tr');
    row0.appendChild(createHeaderCell(escapeHTML(''))); // label for A char column (empty)
    row0.appendChild(createValueCell(0,0, 0, 'zero')); // dp[0][0]
    for(let j=1;j<=n;j++){
      row0.appendChild(createValueCell(0,j, dp[0][j]));
    }
    tbody.appendChild(row0);

    // Rows i=1..m
    for(let i=1;i<=m;i++){
      const row = document.createElement('tr');
      // header: character A[i-1]
      row.appendChild(createHeaderCell(escapeHTML(A[i-1])));
      // values for j=0..n
      for(let j=0;j<=n;j++){
        row.appendChild(createValueCell(i,j, dp[i][j]));
      }
      tbody.appendChild(row);
    }
    return tbody;
  }

  function createHeaderCell(text){
    const th = document.createElement('th');
    th.innerHTML = text || '';
    th.className = 'charcell';
    return th;
  }

  function createValueCell(i,j, val){
    const td = document.createElement('td');
    td.dataset.i = i; td.dataset.j = j;
    const vdiv = document.createElement('div');
    vdiv.className = 'value';
    vdiv.textContent = val;
    td.appendChild(vdiv);

    // compute arrows/derivation tooltip
    let tip = `dp[${i}][${j}] = ${val}`;
    if(i>0 && j>0 && A[i-1] === B[j-1]){
      td.classList.add('match');
      tip += ` (match '${A[i-1]}', from dp[${i-1}][${j-1}] + 1)`;
      const dir = document.createElement('div'); dir.className='dir'; dir.textContent='↖';
      td.appendChild(dir);
    } else {
      // check from up / left
      const dirs = [];
      if(i>0 && dp[i][j] === dp[i-1][j]) dirs.push('↑');
      if(j>0 && dp[i][j] === dp[i][j-1]) dirs.push('←');
      if(dirs.length) {
        const dir = document.createElement('div'); dir.className='dir'; dir.textContent = dirs.join(' ');
        td.appendChild(dir);
        tip += ' (from ' + dirs.join(', ') + ')';
      }
    }
    td.title = tip;
    td.classList.add('tooltip');
    // make interactive: clicking a cell highlights it
    td.addEventListener('click', ()=> {
      clearHighlights();
      td.classList.add('current');
    });
    return td;
  }

  function clearHighlights(){
    const tds = tableContainer.querySelectorAll('td');
    tds.forEach(td => td.classList.remove('path','current'));
    // also clear path list selection
  }

  // Deterministic backtrack to produce a single LCS (uses tie-breaker)
  function deterministicBacktrack(tie='left'){
    if(!dp || m===0 || n===0) return '';
    let i = m, j = n;
    const chars = [];
    while(i>0 && j>0){
      if(A[i-1] === B[j-1]){
        chars.push(A[i-1]);
        i--; j--;
      } else {
        const up = dp[i-1][j], left = dp[i][j-1];
        if(up > left) i--;
        else if(left > up) j--;
        else { // tie
          if(tie === 'left') j--; else i--;
        }
      }
    }
    return chars.reverse().join('');
  }

  // Build path positions list for highlighting deterministic backtrack
  function buildPathForHighlight(tie='left'){
    const positions = [];
    if(!dp || m===0 || n===0) return positions;
    let i = m, j = n;
    while(i>0 || j>0){
      positions.push([i,j]);
      if(i>0 && j>0 && A[i-1] === B[j-1]){
        i--; j--;
      } else if (i===0){
        j--;
      } else if (j===0){
        i--;
      } else {
        const up = dp[i-1][j], left = dp[i][j-1];
        if(up > left) i--;
        else if(left > up) j--;
        else { if(tie==='left') j--; else i--; }
      }
    }
    positions.push([0,0]);
    return positions;
  }

  // Render path list (positions visited)
  function renderPathList(){
    if(!path || path.length===0){
      pathDisplay.innerHTML = 'No path.';
      return;
    }
    pathDisplay.innerHTML = '';
    const ul = document.createElement('div');
    ul.style.display='flex'; ul.style.flexDirection='column'; ul.style.gap='6px';
    path.forEach((p,idx)=>{
      const [i,j] = p;
      const item = document.createElement('div');
      item.textContent = `${idx+1}. dp[${i}][${j}] = ${dp[i] ? dp[i][j] : (i===0 && j===0 ? 0 : '')} ` +
        ((i>0 && j>0 && A[i-1]===B[j-1]) ? ` (match '${A[i-1]}')` : '');
      item.style.cursor='pointer';
      item.addEventListener('click', ()=> {
        // highlight the corresponding cell in table
        clearHighlights();
        const td = tableContainer.querySelector(`td[data-i='${i}'][data-j='${j}']`);
        if(td) td.classList.add('path','current');
      });
      ul.appendChild(item);
    });
    pathDisplay.appendChild(ul);
  }

  // Step through path
  let stepIndex = 0;
  function stepBacktrack(){
    if(!path || path.length===0) return;
    if(stepIndex >= path.length) stepIndex = 0;
    const [i,j] = path[stepIndex];
    clearHighlights();
    const td = tableContainer.querySelector(`td[data-i='${i}'][data-j='${j}']`);
    if(td) td.classList.add('path','current');
    // mark all previous as path as well
    for(let k=0;k<=stepIndex;k++){
      const [ii,jj] = path[k];
      const cell = tableContainer.querySelector(`td[data-i='${ii}'][data-j='${jj}']`);
      if(cell) cell.classList.add('path');
    }
    stepIndex++;
  }

  // Play animation
  function playBacktrack(){
    if(playInterval) { clearInterval(playInterval); playInterval=null; playBtn.textContent='Play'; return; }
    if(!path || path.length===0) return;
    stepIndex = 0;
    const interval = parseInt(speed.value,10) || 400;
    playBtn.textContent='Stop';
    playInterval = setInterval(()=>{
      if(stepIndex >= path.length){
        clearInterval(playInterval); playInterval=null; playBtn.textContent='Play'; return;
      }
      stepBacktrack();
    }, interval);
  }

  // Reset highlights
  function resetHighlights(){
    clearHighlights();
    stepIndex = 0;
    if(playInterval){ clearInterval(playInterval); playInterval=null; playBtn.textContent='Play'; }
  }

  // Find all LCS using memoized recursion with limit
  function allLCS(i,j, memo, cap){
    const key = i+','+j;
    if(memo.has(key)) return memo.get(key);
    const res = new Set();
    if(i===0 || j===0){
      res.add('');
      memo.set(key, res);
      return res;
    }
    if(A[i-1] === B[j-1]){
      const prev = allLCS(i-1,j-1,memo,cap);
      for(const s of prev){
        if(res.size >= cap) break;
        res.add(s + A[i-1]);
      }
      memo.set(key,res);
      return res;
    } else {
      const up = dp[i-1][j], left = dp[i][j-1];
      if(up > left){
        const s = allLCS(i-1,j,memo,cap);
        for(const x of s){ if(res.size >= cap) break; res.add(x); }
      } else if(left > up){
        const s = allLCS(i,j-1,memo,cap);
        for(const x of s){ if(res.size >= cap) break; res.add(x); }
      } else {
        // both equal: union of both branches
        const s1 = allLCS(i-1,j,memo,cap);
        const s2 = allLCS(i,j-1,memo,cap);
        for(const x of s1){ if(res.size >= cap) break; res.add(x); }
        for(const x of s2){ if(res.size >= cap) break; res.add(x); }
      }
      memo.set(key,res);
      return res;
    }
  }

  // Event listeners
  computeBtn.addEventListener('click', ()=> {
    computeDP();
    if(autoplay.checked){
      // highlight full deterministic path automatically
      resetHighlights();
      const interval = Math.max(120, parseInt(speed.value,10) || 400);
      let idx = 0;
      playBtn.textContent='Stop';
      playInterval = setInterval(()=>{
        if(idx >= path.length){ clearInterval(playInterval); playInterval=null; playBtn.textContent='Play'; return;}
        const [i,j] = path[idx];
        const td = tableContainer.querySelector(`td[data-i='${i}'][data-j='${j}']`);
        if(td) td.classList.add('path');
        idx++;
      }, interval);
    }
  });

  randomBtn.addEventListener('click', ()=> {
    const alph = 'ABCDEF';
    const lenA = 6 + Math.floor(Math.random()*5);
    const lenB = 6 + Math.floor(Math.random()*5);
    const rand = (len)=> Array.from({length:len}, ()=> alph[Math.floor(Math.random()*alph.length)]).join('');
    taA.value = rand(lenA);
    taB.value = rand(lenB);
    computeDP();
  });

  clearBtn.addEventListener('click', ()=> {
    taA.value = '';
    taB.value = '';
    tableContainer.innerHTML = '';
    lengthBadge.textContent = 'LCS length: -';
    oneLCS.textContent = 'Sequence: -';
    pathDisplay.innerHTML = 'No computation yet.';
    allResults.innerHTML = 'Press "Find All LCS" to enumerate sequences.';
  });

  stepBtn.addEventListener('click', ()=> {
    if(!dp || dp.length===0) return;
    if(path.length===0) path = buildPathForHighlight(tiebreaker.value);
    stepBacktrack();
  });

  playBtn.addEventListener('click', ()=> {
    if(!dp || dp.length===0) return;
    if(path.length===0) path = buildPathForHighlight(tiebreaker.value);
    playBacktrack();
  });

  resetBtn.addEventListener('click', resetHighlights);

  findAllBtn.addEventListener('click', ()=>{
    if(!dp || dp.length===0) return;
    const cap = Math.max(1, parseInt(limitInput.value,10) || 50);
    allResults.innerHTML = 'Computing...';
    setTimeout(()=>{
      const memo = new Map();
      const setRes = allLCS(m,n,memo, cap);
      // results are reversed (we appended chars to the right), keep them as is
      const arr = Array.from(setRes);
      arr.sort((a,b)=> b.length - a.length || a.localeCompare(b)); // prefer longer and lexicographic
      if(arr.length === 0) {
        allResults.innerHTML = '∅';
      } else {
        // They are built with characters appended as we went forward; ensure they are of length dp[m][n]
        const clean = arr.map(x=> x).filter(x=> x.length === dp[m][n]);
        const limited = clean.slice(0, cap);
        allResults.innerHTML = '';
        limited.forEach((s,idx)=>{
          const d = document.createElement('div');
          d.textContent = `${idx+1}. ${s || '∅'}`;
          allResults.appendChild(d);
        });
        if(clean.length > cap){
          const more = document.createElement('div');
          more.textContent = `... ${clean.length - cap} more (truncated by limit)`;
          more.style.color = '#6b7280';
          allResults.appendChild(more);
        }
      }
    }, 50);
  });

  // Recompute when tiebreaker changed to update deterministic LCS and path
  tiebreaker.addEventListener('change', ()=>{
    if(!dp || dp.length===0) return;
    const seq = deterministicBacktrack(tiebreaker.value);
    oneLCS.textContent = 'Sequence: ' + (seq || '∅');
    path = buildPathForHighlight(tiebreaker.value);
    renderPathList();
    resetHighlights();
  });

  // Speed slider just updates label in UI implicitly
  speed.addEventListener('input', ()=> { /* no-op */ });

  // initial compute
  computeDP();

  // expose computeDP for debugging
  window._lcs_compute = computeDP;
})();
</script>
</body>
</html>