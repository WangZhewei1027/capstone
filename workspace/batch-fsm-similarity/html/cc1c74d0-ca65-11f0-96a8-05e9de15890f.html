<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Linked List Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#06b6d4;
      --muted:#94a3b8;
      --node:#0ea5a4;
      --node2:#7dd3fc;
      --danger:#fb7185;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#071024 0%, #041022 60%);
      color: #e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app{
      max-width:1100px;
      margin:28px auto;
      padding:20px;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: 0 6px 30px rgba(2,6,23,0.6);
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:18px;
    }
    h1{ margin:0 0 6px 0; font-size:20px; color: #dbeafe;}
    p.lead{ margin:0 0 12px 0; color:var(--muted); font-size:13px; }
    .controls{
      padding:14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.01));
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.03);
    }
    label{ display:block; font-size:13px; color:var(--muted); margin-top:8px;}
    input[type="text"], input[type="number"], select{
      width:100%;
      padding:8px 10px;
      margin-top:6px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:rgba(255,255,255,0.02);
      color: #e6eef8;
      box-sizing:border-box;
    }
    .row { display:flex; gap:8px; margin-top:10px; }
    button{
      cursor:pointer;
      border:0;
      padding:8px 10px;
      border-radius:8px;
      color: #022;
      background:var(--accent);
      font-weight:600;
      box-shadow: 0 6px 20px rgba(6,182,212,0.08);
      transition:transform .12s ease, box-shadow .12s ease, opacity .12s;
    }
    button.secondary{
      background:linear-gradient(180deg,#1f2937,#111827);
      color: #e6eef8;
      box-shadow:none;
      border:1px solid rgba(255,255,255,0.02);
    }
    button.warn{ background: var(--danger); color:#fff; box-shadow:none;}
    button:active{ transform: translateY(1px) }
    .visual{
      padding:14px;
      border-radius:10px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border:1px solid rgba(255,255,255,0.02);
      position:relative;
      min-height:280px;
      overflow:auto;
    }
    .canvas{
      display:flex;
      align-items:center;
      gap:36px;
      padding:20px;
      min-height:180px;
      position:relative;
      transition:height .25s;
    }
    .node {
      min-width:84px;
      height:54px;
      border-radius:10px;
      background: linear-gradient(180deg,var(--node), var(--node2));
      display:flex;
      align-items:center;
      justify-content:center;
      color:#001217;
      font-weight:700;
      font-size:18px;
      position:relative;
      box-shadow: 0 6px 18px rgba(6,182,212,0.08);
      transition: transform .25s, box-shadow .18s, opacity .25s;
      flex-shrink:0;
    }
    .node.small{ min-width:58px; height:44px; font-size:15px; }
    .node::after{
      content:"";
      position:absolute;
      right:-24px;
      top:50%;
      transform:translateY(-50%);
      width:36px;
      height:2px;
      background: transparent;
    }
    .node.highlight{ box-shadow: 0 10px 30px rgba(6,182,212,0.18); transform:translateY(-6px); }
    .node.match { outline:3px solid rgba(96,165,250,0.16); box-shadow:0 12px 30px rgba(59,130,246,0.12); transform:scale(1.03); }
    .node.new{ box-shadow: 0 12px 30px rgba(34,197,94,0.12); transform:scale(1.06); }
    .node.removed{ opacity:0.18; transform:scale(.95); }
    .info{
      margin-top:12px;
      font-size:13px;
      color:var(--muted);
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      padding:10px;
      border-radius:8px;
      border:1px dashed rgba(255,255,255,0.02);
    }
    .log{
      margin-top:12px;
      font-size:13px;
      max-height:160px;
      overflow:auto;
      padding:10px;
      background:rgba(255,255,255,0.01);
      border-radius:8px;
      border:1px dotted rgba(255,255,255,0.02);
    }
    .controls small{ color:var(--muted); display:block; margin-top:6px; }
    .meta{ font-size:13px; color:var(--muted); margin-top:10px; }
    .center{ display:flex; align-items:center; gap:8px; }
    .badge{
      padding:6px 8px;
      border-radius:8px;
      background:rgba(255,255,255,0.02);
      color:var(--muted);
      font-size:12px;
      border:1px solid rgba(255,255,255,0.02);
    }
    footer{ color:var(--muted); font-size:12px; margin-top:10px; text-align:center; grid-column:1/-1; }
    /* svg arrow styles */
    svg.arrows { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; overflow:visible; }
    .hidden{ opacity:0; pointer-events:none; }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Linked List Visualizer">
    <div>
      <h1>Linked List Visualizer</h1>
      <p class="lead">Interactive demo of a singly linked list. Create, search, insert, delete and reverse while watching the nodes and pointers update.</p>

      <div class="controls" aria-live="polite">
        <label>Value <small>(text allowed)</small>
          <input id="valueInput" type="text" placeholder="e.g. 42 or 'apple'">
        </label>

        <label>Index <small>(0 = head)</small>
          <input id="indexInput" type="number" min="0" value="0">
        </label>

        <div class="row">
          <button id="prependBtn" title="Insert at head">Add Head</button>
          <button id="appendBtn" title="Insert at tail">Add Tail</button>
          <button id="insertBtn" title="Insert at index">Insert @ Index</button>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="removeValueBtn" class="secondary" title="Remove first occurrence of value">Remove Value</button>
          <button id="removeIndexBtn" class="secondary" title="Remove at index">Remove Index</button>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="searchBtn" class="secondary">Search</button>
          <button id="reverseBtn" class="secondary">Reverse</button>
          <button id="clearBtn" class="warn">Clear</button>
        </div>

        <div class="meta center">
          <div class="badge" id="sizeBadge">Size: 0</div>
          <div style="flex:1"></div>
          <small style="color:var(--muted)">Operations are animated sequentially</small>
        </div>

        <div class="log" id="log" aria-live="polite" role="log"></div>
      </div>

      <div class="info" style="margin-top:12px;">
        Tip: Use "Index" field for insert/remove operations. Search will highlight visited nodes. Reverse flips the list.
      </div>
      <footer>Built for teaching â€” singly linked list (JS)</footer>
    </div>

    <div class="visual" id="visualArea">
      <div id="canvas" class="canvas" aria-hidden="false"></div>
      <svg id="arrowLayer" class="arrows" aria-hidden="true"></svg>
    </div>
  </div>

  <script>
    // Linked List implementation (singly linked list)
    class Node {
      constructor(value){
        this.value = value;
        this.next = null;
      }
    }

    class LinkedList {
      constructor(){
        this.head = null;
        this.size = 0;
      }
      prepend(value){
        const node = new Node(value);
        node.next = this.head;
        this.head = node;
        this.size++;
        return node;
      }
      append(value){
        const node = new Node(value);
        if (!this.head) {
          this.head = node;
        } else {
          let cur = this.head;
          while (cur.next) cur = cur.next;
          cur.next = node;
        }
        this.size++;
        return node;
      }
      insertAt(value, index){
        if (index <= 0) return this.prepend(value);
        if (index >= this.size) return this.append(value);
        const node = new Node(value);
        let prev = null, cur = this.head, i=0;
        while (i<index){
          prev = cur;
          cur = cur.next;
          i++;
        }
        prev.next = node;
        node.next = cur;
        this.size++;
        return node;
      }
      removeAt(index){
        if (this.size===0) return null;
        if (index <= 0){
          const removed = this.head;
          this.head = this.head.next;
          this.size--;
          return removed;
        }
        if (index >= this.size-1){
          // remove tail
          let prev=null, cur=this.head;
          while (cur.next){
            prev = cur;
            cur = cur.next;
          }
          prev.next = null;
          this.size--;
          return cur;
        }
        let prev=null, cur=this.head, i=0;
        while (i<index){
          prev = cur;
          cur = cur.next;
          i++;
        }
        prev.next = cur.next;
        this.size--;
        return cur;
      }
      removeValue(value){
        if (!this.head) return null;
        if (this.head.value === value){
          const removed = this.head;
          this.head = this.head.next;
          this.size--;
          return removed;
        }
        let prev=this.head, cur=this.head.next;
        while (cur){
          if (cur.value === value){
            prev.next = cur.next;
            this.size--;
            return cur;
          }
          prev = cur;
          cur = cur.next;
        }
        return null;
      }
      indexOf(value){
        let idx=0, cur=this.head;
        while (cur){
          if (cur.value === value) return idx;
          cur = cur.next; idx++;
        }
        return -1;
      }
      toArray(){
        const arr=[];
        let cur=this.head;
        while (cur){ arr.push(cur.value); cur = cur.next;}
        return arr;
      }
      reverse(){
        let prev=null, cur=this.head;
        while (cur){
          const nxt = cur.next;
          cur.next = prev;
          prev = cur;
          cur = nxt;
        }
        this.head = prev;
      }
      clear(){
        this.head = null; this.size = 0;
      }
    }

    // UI and animations
    const list = new LinkedList();
    const canvas = document.getElementById('canvas');
    const svg = document.getElementById('arrowLayer');
    const sizeBadge = document.getElementById('sizeBadge');
    const logEl = document.getElementById('log');

    // Controls
    const valueInput = document.getElementById('valueInput');
    const indexInput = document.getElementById('indexInput');
    const prependBtn = document.getElementById('prependBtn');
    const appendBtn = document.getElementById('appendBtn');
    const insertBtn = document.getElementById('insertBtn');
    const removeValueBtn = document.getElementById('removeValueBtn');
    const removeIndexBtn = document.getElementById('removeIndexBtn');
    const searchBtn = document.getElementById('searchBtn');
    const reverseBtn = document.getElementById('reverseBtn');
    const clearBtn = document.getElementById('clearBtn');

    let busy = false; // prevent concurrent operations

    // Utility
    function log(msg){
      const p = document.createElement('div');
      p.textContent = msg;
      logEl.prepend(p);
    }
    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

    // Render function: draws nodes and arrows
    function render(highlightIndices = [], extra = {newIndex:null, removedIndex:null, matchIndex:null}){
      // Clear canvas and svg
      canvas.innerHTML = '';
      svg.innerHTML = '';
      // Build nodes
      const arr = list.toArray();
      arr.forEach((val, i)=>{
        const nodeEl = document.createElement('div');
        nodeEl.className = 'node';
        nodeEl.textContent = String(val);
        nodeEl.dataset.index = i;
        if (i === extra.newIndex) nodeEl.classList.add('new');
        if (i === extra.removedIndex) nodeEl.classList.add('removed');
        if (i === extra.matchIndex) nodeEl.classList.add('match');
        if (highlightIndices.includes(i)) nodeEl.classList.add('highlight');
        canvas.appendChild(nodeEl);
      });
      // if empty, show placeholder
      if (arr.length===0){
        const p = document.createElement('div');
        p.style.color = 'var(--muted)';
        p.textContent = 'List is empty';
        canvas.appendChild(p);
      }

      // Draw arrows using SVG lines with markers
      // Wait for layout to compute positions then draw
      requestAnimationFrame(()=> {
        const nodes = Array.from(canvas.querySelectorAll('.node'));
        // ensure svg size matches visual area
        const areaRect = canvas.getBoundingClientRect();
        svg.setAttribute('width', areaRect.width);
        svg.setAttribute('height', areaRect.height);
        svg.style.left = canvas.offsetLeft + 'px';
        svg.style.top = canvas.offsetTop + 'px';

        // define marker
        const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
        defs.innerHTML = `
          <marker id="arrow" viewBox="0 0 10 10" refX="6" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#6EE7B7"/>
          </marker>
          <marker id="arrowBlue" viewBox="0 0 10 10" refX="6" refY="5" markerWidth="6" markerHeight="6" orient="auto">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#7dd3fc" opacity="0.95"/>
          </marker>
        `;
        svg.appendChild(defs);

        nodes.forEach((nEl, idx) => {
          const nextEl = nodes[idx+1];
          if (!nextEl) return;
          const r1 = nEl.getBoundingClientRect();
          const r2 = nextEl.getBoundingClientRect();
          // convert to canvas-relative coordinates
          const cRect = canvas.getBoundingClientRect();
          const x1 = r1.right - cRect.left - 6; // little offset
          const y1 = r1.top + r1.height/2 - cRect.top;
          const x2 = r2.left - cRect.left + 6;
          const y2 = r2.top + r2.height/2 - cRect.top;

          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', x1);
          line.setAttribute('y1', y1);
          line.setAttribute('x2', x2);
          line.setAttribute('y2', y2);
          line.setAttribute('stroke', 'rgba(125,211,252,0.25)');
          line.setAttribute('stroke-width', '2.5');
          line.setAttribute('marker-end', 'url(#arrowBlue)');
          svg.appendChild(line);
        });

        // If there's a tail (no next), draw null box
        const last = nodes[nodes.length-1];
        if (last){
          const r = last.getBoundingClientRect();
          const cRect = canvas.getBoundingClientRect();
          const x1 = r.right - cRect.left + 12;
          const y1 = r.top + r.height/2 - cRect.top;
          const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
          rect.setAttribute('x', x1);
          rect.setAttribute('y', y1 - 10);
          rect.setAttribute('width', 36);
          rect.setAttribute('height', 20);
          rect.setAttribute('rx', 6);
          rect.setAttribute('fill', 'rgba(255,255,255,0.02)');
          rect.setAttribute('stroke', 'rgba(255,255,255,0.03)');
          svg.appendChild(rect);
        }
      });

      sizeBadge.textContent = 'Size: ' + list.size;
    }

    // initialize with sample data
    ['A','B','C'].forEach(v=>list.append(v));
    render();

    // Animation helpers: walk nodes with highlight
    async function highlightWalk(value, options={stopOnMatch:true}){
      const arr = list.toArray();
      for(let i=0;i<arr.length;i++){
        render([i]);
        log(`Visiting index ${i} (value=${arr[i]})`);
        await sleep(600);
        if (arr[i] === value){
          render([], {matchIndex:i});
          log(`Found value at index ${i}`);
          if (options.stopOnMatch) return i;
          // else continue
        }
      }
      render();
      return -1;
    }

    // Event handlers with animations
    prependBtn.addEventListener('click', async ()=>{
      if (busy) return; busy=true;
      const val = valueInput.value.trim();
      if (val===''){ alert('Enter a value'); busy=false; return; }
      log(`Inserting "${val}" at head`);
      // animate: show highlight at head (existing)
      if (list.size>0){
        render([0]);
        await sleep(350);
      }
      list.prepend(val);
      // show new node emphasized
      render([], {newIndex:0});
      await sleep(450);
      render();
      busy=false;
    });

    appendBtn.addEventListener('click', async ()=>{
      if (busy) return; busy=true;
      const val = valueInput.value.trim();
      if (val===''){ alert('Enter a value'); busy=false; return; }
      log(`Appending "${val}" to tail`);
      // animate walking to tail
      const arr = list.toArray();
      for (let i=0;i<arr.length;i++){
        render([i]);
        await sleep(200);
      }
      list.append(val);
      render([], {newIndex: list.size-1});
      await sleep(450);
      render();
      busy=false;
    });

    insertBtn.addEventListener('click', async ()=>{
      if (busy) return; busy=true;
      const val = valueInput.value.trim();
      let idx = parseInt(indexInput.value, 10);
      if (val===''){ alert('Enter a value'); busy=false; return; }
      if (isNaN(idx) || idx < 0) idx = 0;
      log(`Inserting "${val}" at index ${idx}`);
      // walk to insertion point (show current positions)
      const arr = list.toArray();
      const target = Math.min(idx, list.size); // allow appending
      for (let i=0;i<target;i++){
        render([i]);
        await sleep(220);
      }
      // Show where it will be inserted by highlighting neighbor
      render([], {newIndex: target});
      await sleep(400);
      list.insertAt(val, idx);
      render();
      busy=false;
    });

    removeValueBtn.addEventListener('click', async ()=>{
      if (busy) return; busy=true;
      const val = valueInput.value.trim();
      if (val===''){ alert('Enter a value'); busy=false; return; }
      log(`Removing first occurrence of "${val}"`);
      // Walk until found
      const idx = await highlightWalk(val);
      if (idx === -1){
        log(`Value "${val}" not found`);
        alert('Value not found');
        busy=false;
        render();
        return;
      }
      // animate removal
      render([], {removedIndex: idx});
      await sleep(400);
      list.removeAt(idx);
      render();
      busy=false;
    });

    removeIndexBtn.addEventListener('click', async ()=>{
      if (busy) return; busy=true;
      let idx = parseInt(indexInput.value, 10);
      if (isNaN(idx) || idx < 0) { alert('Enter a valid index'); busy=false; return; }
      if (list.size===0){
        alert('List empty'); busy=false; return;
      }
      if (idx >= list.size) idx = list.size - 1;
      log(`Removing node at index ${idx}`);
      // walk to index
      for (let i=0;i<=idx;i++){
        render([i]);
        await sleep(200);
      }
      render([], {removedIndex: idx});
      await sleep(360);
      list.removeAt(idx);
      render();
      busy=false;
    });

    searchBtn.addEventListener('click', async ()=>{
      if (busy) return; busy=true;
      const val = valueInput.value.trim();
      if (val===''){ alert('Enter a value'); busy=false; return; }
      log(`Searching for "${val}"`);
      const idx = await highlightWalk(val, {stopOnMatch:true});
      if (idx === -1) {
        alert('Not found');
        log('Search completed: not found');
      } else {
        alert('Found at index ' + idx);
      }
      busy=false;
    });

    reverseBtn.addEventListener('click', async ()=>{
      if (busy) return; busy=true;
      if (list.size <= 1){ log('Nothing to reverse'); busy=false; return; }
      log('Reversing list');
      // simple animated reverse: show highlights walking and then render reversed
      // highlight nodes sequentially
      const arr = list.toArray();
      for (let i=0;i<arr.length;i++){
        render([i]);
        await sleep(160);
      }
      list.reverse();
      render();
      await sleep(360);
      busy=false;
    });

    clearBtn.addEventListener('click', async ()=>{
      if (busy) return; busy=true;
      if (!confirm('Clear the entire list?')){ busy=false; return; }
      log('Clearing list');
      // fade out nodes
      const arr = list.toArray();
      for (let i=0;i<arr.length;i++){
        render([], {removedIndex: i});
        await sleep(80);
      }
      list.clear();
      render();
      busy=false;
    });

    // Accessibility: allow Enter to trigger append by default
    valueInput.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter'){
        appendBtn.click();
      }
    });

    // Resize observer to re-render arrows when layout changes
    let resizeObserver = new ResizeObserver(()=> render());
    resizeObserver.observe(canvas);

  </script>
</body>
</html>