<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Insertion Sort Visualizer</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#38bdf8;
    --muted:#94a3b8;
    --bar:#60a5fa;
    --key:#f97316;
    --compare:#ef4444;
    --shift:#a78bfa;
    --sorted:#10b981;
    --text:#e6eef8;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#061126);font-family:Inter,Segoe UI,system-ui,Arial;color:var(--text)}
  .app{max-width:1100px;margin:18px auto;padding:20px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6)}
  h1{margin:0 0 10px;font-size:20px}
  .controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:12px}
  .controls > *{background:var(--panel);padding:10px;border-radius:8px;box-shadow:inset 0 -2px 0 rgba(255,255,255,0.02)}
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
  input[type=range]{width:180px}
  .btn{background:linear-gradient(180deg,#0b2236,#04202a);color:var(--text);padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .btn:disabled{opacity:0.5;cursor:not-allowed}
  .stats{display:flex;gap:12px;align-items:center;margin-left:auto;font-size:13px;color:var(--muted)}
  .visual{position:relative;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);height:340px;border-radius:8px;padding:14px;display:flex;align-items:flex-end;overflow:hidden}
  .bars{display:flex;align-items:flex-end;gap:4px;height:100%;width:100%}
  .bar{background:var(--bar);flex:1 1 auto;border-radius:4px;transition:height 200ms ease, background-color 160ms ease;display:flex;align-items:flex-end;justify-content:center;color:#021025;font-weight:700;font-size:11px}
  .bar.small{font-size:10px}
  .bar .label{transform:translateY(6px);color:rgba(0,0,0,0.5)}
  .bar.key{background:linear-gradient(180deg,var(--key),#ffb07a)}
  .bar.compare{background:linear-gradient(180deg,var(--compare),#ff988a)}
  .bar.shift{background:linear-gradient(180deg,var(--shift),#cdb7ff)}
  .bar.sorted{background:linear-gradient(180deg,var(--sorted),#78f3bf)}
  .footer{display:flex;gap:20px;margin-top:12px;align-items:flex-start;flex-wrap:wrap}
  .pseudo{background:#051226;border-radius:8px;padding:12px;color:var(--muted);font-family:monospace;font-size:13px;min-width:260px}
  .pseudo .line{padding:4px 6px;border-radius:4px}
  .pseudo .line.active{background:rgba(56,189,248,0.12);color:var(--accent)}
  .explain{flex:1;min-width:300px;color:var(--muted);font-size:14px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);padding:12px;border-radius:8px}
  .top-row{display:flex;gap:12px;align-items:center}
  .small-note{font-size:12px;color:var(--muted)}
  .control-block{min-width:160px}
  .flexcol{display:flex;flex-direction:column}
</style>
</head>
<body>
<div class="app" role="main" aria-label="Insertion Sort Visualizer">
  <div class="top-row">
    <div>
      <h1>Insertion Sort Visualizer</h1>
      <div class="small-note">See how insertion sort builds a sorted section by removing one element (the key) and inserting it into the correct place.</div>
    </div>
    <div class="stats" style="margin-left:auto">
      <div>Comparisons: <span id="compCount">0</span></div>
      <div>Moves: <span id="moveCount">0</span></div>
    </div>
  </div>

  <div class="controls" aria-hidden="false">
    <div class="control-block">
      <label for="size">Array size: <span id="sizeVal">30</span></label>
      <input id="size" type="range" min="5" max="80" value="30">
    </div>

    <div class="control-block">
      <label for="speed">Speed (ms delay): <span id="speedVal">200</span></label>
      <input id="speed" type="range" min="10" max="1000" step="10" value="200">
    </div>

    <div style="display:flex;gap:8px;align-items:center">
      <button id="randomize" class="btn">Randomize</button>
      <button id="start" class="btn">Start</button>
      <button id="pause" class="btn" disabled>Pause</button>
      <button id="step" class="btn">Step</button>
      <button id="reset" class="btn">Reset</button>
    </div>

    <div class="small-note" style="margin-left:auto;min-width:180px;text-align:right">
      Colors: <span style="color:var(--sorted)">■</span> sorted <span style="margin-left:8px;color:var(--key)">■</span> key <span style="margin-left:8px;color:var(--compare)">■</span> comparing <span style="margin-left:8px;color:var(--shift)">■</span> shifting
    </div>
  </div>

  <div class="visual" aria-hidden="false">
    <div class="bars" id="bars" role="img" aria-label="Array bars"></div>
  </div>

  <div class="footer">
    <div class="pseudo" aria-hidden="false">
      <div style="font-weight:600;color:var(--text);margin-bottom:8px">Pseudocode</div>
      <div id="p1" class="line">1. for i = 1 to n - 1</div>
      <div id="p2" class="line">2. &nbsp;&nbsp;&nbsp; key = A[i]</div>
      <div id="p3" class="line">3. &nbsp;&nbsp;&nbsp; j = i - 1</div>
      <div id="p4" class="line">4. &nbsp;&nbsp;&nbsp; while j >= 0 and A[j] &gt; key</div>
      <div id="p5" class="line">5. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A[j+1] = A[j]  (shift)</div>
      <div id="p6" class="line">6. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = j - 1</div>
      <div id="p7" class="line">7. &nbsp;&nbsp;&nbsp; A[j+1] = key  (insert)</div>
    </div>

    <div class="explain" aria-hidden="false">
      <div style="font-weight:600;color:var(--text);margin-bottom:6px">How it works</div>
      Insertion sort iterates the array, treating the left part as sorted. For each element (the key), it compares the key to elements in the sorted part and shifts larger elements one position to the right until the correct spot for the key is found; then it inserts the key. It is stable and efficient for small or mostly-sorted arrays.
      <ul style="margin-top:8px;color:var(--muted);font-size:13px">
        <li>Time: O(n^2) worst / average, O(n) best (already sorted)</li>
        <li>Space: O(1) auxiliary</li>
        <li>Good for small inputs or incremental insertions</li>
      </ul>
    </div>
  </div>
</div>

<script>
/* Insertion Sort Visualizer
   Single-file demo with controls:
   - Randomize / Start / Pause / Step / Reset
   - Array size and speed sliders
   - Pseudocode highlighting and counters
*/

const barsContainer = document.getElementById('bars');
const sizeInput = document.getElementById('size');
const speedInput = document.getElementById('speed');
const sizeVal = document.getElementById('sizeVal');
const speedVal = document.getElementById('speedVal');
const randomizeBtn = document.getElementById('randomize');
const startBtn = document.getElementById('start');
const pauseBtn = document.getElementById('pause');
const stepBtn = document.getElementById('step');
const resetBtn = document.getElementById('reset');
const compCountEl = document.getElementById('compCount');
const moveCountEl = document.getElementById('moveCount');

let arr = [];
let bars = [];
let generator = null;
let running = false;
let paused = false;
let done = false;
let comparisons = 0;
let moves = 0;

sizeVal.textContent = sizeInput.value;
speedVal.textContent = speedInput.value;

sizeInput.addEventListener('input', ()=> {
  sizeVal.textContent = sizeInput.value;
  buildArray(parseInt(sizeInput.value));
});
speedInput.addEventListener('input', ()=> {
  speedVal.textContent = speedInput.value;
});

randomizeBtn.addEventListener('click', ()=> {
  stop();
  buildArray(parseInt(sizeInput.value), true);
});

startBtn.addEventListener('click', ()=> {
  if(done) { buildArray(parseInt(sizeInput.value), true); }
  if(!generator) generator = insertionSort(arr);
  if(!running) {
    running = true;
    paused = false;
    toggleButtons();
    run();
  }
});

pauseBtn.addEventListener('click', ()=> {
  paused = true;
  running = false;
  toggleButtons();
});

stepBtn.addEventListener('click', ()=> {
  if(!generator) generator = insertionSort(arr);
  if(!running) {
    step();
  }
});

resetBtn.addEventListener('click', ()=> {
  stop(true);
  buildArray(parseInt(sizeInput.value), true);
});

function toggleButtons(){
  startBtn.disabled = running;
  pauseBtn.disabled = !running;
  stepBtn.disabled = running;
  randomizeBtn.disabled = running;
  resetBtn.disabled = running;
}

function stop(resetDone=false){
  running = false;
  paused = false;
  toggleButtons();
  if(resetDone){
    generator = null;
    done = false;
    comparisons = 0;
    moves = 0;
    updateCounters();
    clearHighlights();
  }
}

function updateCounters(){
  compCountEl.textContent = comparisons;
  moveCountEl.textContent = moves;
}

// Create new array and render bars
function buildArray(n=30, randomize=true){
  arr = [];
  for(let i=0;i<n;i++){
    arr.push( Math.floor(Math.random() * 90) + 10 ); // values between 10 and 99
  }
  comparisons = 0;
  moves = 0;
  updateCounters();
  generator = null;
  done = false;
  render();
}

function render(){
  barsContainer.innerHTML = '';
  bars = [];
  const n = arr.length;
  for(let i=0;i<n;i++){
    const b = document.createElement('div');
    b.className = 'bar';
    b.style.height = percentHeight(arr[i]) ;
    b.dataset.index = i;
    const lbl = document.createElement('div');
    lbl.className = 'label';
    lbl.textContent = arr[i];
    b.appendChild(lbl);
    barsContainer.appendChild(b);
    bars.push(b);
  }
  clearHighlights();
}

// convert value to CSS height
function percentHeight(v){
  // v roughly 10..99 => map to 6%..92%
  const minH = 6;
  const maxH = 92;
  const height = minH + ((v-10)/90) * (maxH-minH);
  return height + '%';
}

function clearHighlights(){
  document.querySelectorAll('.bar').forEach(b=>{
    b.classList.remove('key','compare','shift','sorted');
  });
  ['p1','p2','p3','p4','p5','p6','p7'].forEach(id=>{
    document.getElementById(id).classList.remove('active');
  });
}

// Sleep utility
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

// Generator that yields actions for each meaningful step
function* insertionSort(A){
  const n = A.length;
  // mark first element as sorted visually
  yield {type:'markSorted', index:0};
  for(let i=1;i<n;i++){
    // start of loop: i
    yield {type:'start_i', i};
    let key = A[i];
    // highlight key
    yield {type:'key', i, key};
    let j = i - 1;
    yield {type:'set_j', j};
    // while j >= 0:
    while(true){
      if(j >= 0){
        // compare A[j] and key
        yield {type:'compare', j, i};
        if(A[j] > key){
          // shift: A[j+1] = A[j]
          A[j+1] = A[j];
          yield {type:'shift', from:j, to:j+1, val:A[j]}; // moved value
          j = j - 1;
          yield {type:'dec_j', j};
          continue;
        } else {
          break;
        }
      } else {
        break;
      }
    }
    // insert key at j+1
    A[j+1] = key;
    yield {type:'insert', index:j+1, key};
    // mark element i as sorted (the sorted region is 0..i)
    yield {type:'markSorted', index:i};
  }
  yield {type:'done'};
}

// Map pseudocode highlighting
function highlightPseudo(lineId){
  ['p1','p2','p3','p4','p5','p6','p7'].forEach(id=>{
    document.getElementById(id).classList.toggle('active', id===lineId);
  });
}

// Apply a single action to DOM and state
function applyAction(action){
  switch(action.type){
    case 'start_i':
      clearHighlights();
      highlightPseudo('p1');
      break;
    case 'key':
      clearHighlights();
      highlightPseudo('p2');
      // mark the selected i as key color
      bars.forEach(b=>b.classList.remove('key'));
      if(bars[action.i]) bars[action.i].classList.add('key');
      break;
    case 'set_j':
      highlightPseudo('p3');
      break;
    case 'compare':
      comparisons++;
      updateCounters();
      highlightPseudo('p4');
      // color compared bar and key bar
      bars.forEach(b=>b.classList.remove('compare'));
      if(bars[action.j]) bars[action.j].classList.add('compare');
      // key bar: find first bar with class key (there should be)
      break;
    case 'shift':
      // shift value from 'from' to 'to' (we already mutated arr in generator)
      moves++;
      updateCounters();
      highlightPseudo('p5');
      // update DOM height for index to reflect shifted value
      if(bars[action.to]){
        bars[action.to].style.height = percentHeight(action.val);
        bars[action.to].querySelector('.label').textContent = action.val;
        bars[action.to].classList.add('shift');
      }
      // remove key highlight from original index if it was overwritten (visual)
      bars.forEach(b=>b.classList.remove('key'));
      break;
    case 'dec_j':
      highlightPseudo('p6');
      break;
    case 'insert':
      moves++;
      updateCounters();
      highlightPseudo('p7');
      if(bars[action.index]){
        bars[action.index].style.height = percentHeight(action.key);
        bars[action.index].querySelector('.label').textContent = action.key;
        // visually mark inserted briefly
        bars[action.index].classList.add('key');
      }
      // remove any compare/shift classes
      bars.forEach(b=>{ b.classList.remove('compare','shift'); });
      break;
    case 'markSorted':
      // mark everything up to index as sorted
      for(let k=0;k<=action.index;k++){
        if(bars[k]) {
          bars[k].classList.remove('key','compare','shift');
          bars[k].classList.add('sorted');
        }
      }
      // ensure pseudocode not stuck
      break;
    case 'done':
      // finalize
      bars.forEach(b=>{ b.classList.remove('key','compare','shift'); b.classList.add('sorted'); });
      clearHighlights();
      done = true;
      running = false;
      toggleButtons();
      break;
  }
}

// Run loop that consumes the generator automatically
async function run(){
  toggleButtons();
  const delay = ()=>Math.max(10, parseInt(speedInput.value));
  if(!generator) generator = insertionSort(arr);
  while(running){
    const res = generator.next();
    if(res.done) { applyAction({type:'done'}); done=true; running=false; toggleButtons(); break; }
    applyAction(res.value);
    // wait but allow pausing
    let waited = 0;
    const d = delay();
    while(waited < d){
      if(!running){ // paused by UI
        return;
      }
      await sleep(20);
      waited += 20;
    }
  }
}

// Step one action
function step(){
  if(!generator) generator = insertionSort(arr);
  const res = generator.next();
  if(res.done) { applyAction({type:'done'}); done=true; running=false; toggleButtons(); return; }
  applyAction(res.value);
}

// Initialize on load
buildArray(parseInt(sizeInput.value), true);
toggleButtons();

</script>
</body>
</html>