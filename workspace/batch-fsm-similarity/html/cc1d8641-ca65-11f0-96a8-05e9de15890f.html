<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Adjacency List — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#60a5fa;
      --muted:#94a3b8;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#071026 0%, #081226 100%);
      color: #e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .wrap{
      max-width:1100px;
      margin:24px auto;
      display:grid;
      grid-template-columns: 380px 1fr;
      gap:18px;
      padding:18px;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      padding:14px;
      border-radius:10px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
    }
    h1{ margin:4px 0 8px 0; font-size:18px; }
    p.lead{ margin:0 0 12px 0; color:var(--muted); font-size:13px; line-height:1.3}
    .controls{ display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px }
    button, .toggle {
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
    }
    button.primary{
      background:linear-gradient(90deg,var(--accent),#3b82f6);
      border: none;
      color:white;
      box-shadow: 0 6px 18px rgba(59,130,246,0.15);
    }
    .small{ padding:6px 8px; font-size:12px }
    label.inline{ display:flex; gap:8px; align-items:center; font-size:13px; color:var(--muted) }
    input[type="checkbox"]{ transform:scale(1.05); }
    .side-info{ font-size:13px; color:var(--muted); margin-top:8px }
    .svg-wrap{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
      border:1px solid rgba(255,255,255,0.04);
      border-radius:10px;
      height:560px;
      overflow:hidden;
      position:relative;
    }
    svg{ width:100%; height:100%; display:block; background:transparent; cursor:crosshair; }
    .adj-list{
      margin-top:12px;
      background:var(--glass);
      border-radius:8px;
      padding:10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:13px;
      color:#e6eef8;
      max-height:220px;
      overflow:auto;
      border:1px solid rgba(255,255,255,0.03);
    }
    .row{ display:flex; gap:8px; margin-bottom:8px; align-items:center; }
    .muted{ color:var(--muted); font-size:12px }
    .legend{ display:flex; gap:8px; align-items:center; margin-top:8px }
    .bubble{ width:14px; height:14px; border-radius:7px; display:inline-block; }
    .node-b{ background: #60a5fa }
    .edge-b{ background: rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.03) }
    .footer-note{ font-size:12px; color:var(--muted); margin-top:10px }
    .help{ font-size:13px; color:var(--muted); margin-top:8px }
    .controls .active{ box-shadow: inset 0 -2px 0 rgba(0,0,0,0.15); border-radius:8px; border-color: rgba(255,255,255,0.08); color:white; }
    .selected{ stroke:#fff; stroke-width:2px; }
    .node-label{ pointer-events:none; user-select:none; font-size:13px; fill:#e6eef8 }
    .edge-label{ font-size:12px; fill:#e6eef8; pointer-events:none }
    .btn-danger{ background:linear-gradient(90deg,#ef4444,#f97316); border:none; color:white }
    .small-input{ padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:var(--muted); font-size:13px }
    pre.adj-text{ margin:0; white-space:pre-wrap; word-break:break-word; color:#dbeafe; }
    .top-controls{ display:flex; gap:8px; align-items:center; justify-content:space-between }
    .right-top{ display:flex; gap:8px; align-items:center }
    .note{ font-size:12px; color:var(--muted) }
    .link-like{ color:#93c5fd; cursor:pointer; text-decoration:underline; font-size:13px }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel" style="min-height:560px;">
      <h1>Adjacency List — Interactive Demo</h1>
      <p class="lead">An adjacency list represents a graph by storing for each node a list of its adjacent neighbors. This demo lets you build a graph visually and see the adjacency list update live.</p>

      <div class="row top-controls">
        <div style="display:flex; gap:8px; align-items:center;">
          <label class="inline"><input id="directed" type="checkbox"> Directed</label>
          <label class="inline"><input id="weighted" type="checkbox"> Weighted</label>
        </div>
        <div class="right-top">
          <button id="modeAddEdge" class="small">Add Edge (click nodes)</button>
          <button id="clearBtn" class="small">Clear</button>
        </div>
      </div>

      <div class="controls" style="margin-top:10px;">
        <button id="sampleBtn">Load Sample Graph</button>
        <button id="autoLayout" class="small">Auto Layout</button>
        <button id="exportBtn" class="small">Export JSON</button>
        <button id="importBtn" class="small">Import JSON</button>
      </div>

      <div class="help">
        How to use:
        <ul style="margin:6px 0 0 18px; color:var(--muted)">
          <li>Click empty space in the right panel to add a node.</li>
          <li>Click "Add Edge" then click two nodes to connect them. Hold "Weighted" to enter a weight.</li>
          <li>Drag nodes to reposition. Click a node to select it and remove with "Delete Selected".</li>
        </ul>
      </div>

      <div style="display:flex; gap:8px; margin-top:12px;">
        <button id="deleteSelected" class="small">Delete Selected</button>
        <button id="deleteEdge" class="small">Delete Selected Edge</button>
        <div style="flex:1"></div>
        <div class="muted">Nodes: <span id="nodeCount">0</span> | Edges: <span id="edgeCount">0</span></div>
      </div>

      <div class="adj-list" id="adjContainer" aria-live="polite" style="margin-top:12px;">
        <strong style="display:block; margin-bottom:8px;">Adjacency List (live)</strong>
        <pre class="adj-text" id="adjText">(empty)</pre>
      </div>

      <div class="legend">
        <span class="bubble node-b"></span><span class="muted">Node</span>
        <span class="bubble edge-b" style="width:36px;height:10px;border-radius:6px"></span><span class="muted">Edge</span>
      </div>

      <div class="footer-note">Click "Export JSON" to copy the graph as JSON. "Import JSON" lets you paste back a saved graph.</div>
    </div>

    <div class="svg-wrap panel">
      <svg id="svgCanvas" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet" tabindex="0">
        <defs>
          <marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L10,5 L0,10 z" fill="#dbeafe" />
          </marker>
          <marker id="arrow-dark" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L10,5 L0,10 z" fill="#1f2937" />
          </marker>
        </defs>
        <!-- edges and nodes will be created dynamically -->
      </svg>
    </div>
  </div>

  <script>
    // Simple interactive graph with adjacency list display
    (function(){
      const svg = document.getElementById('svgCanvas');
      const adjText = document.getElementById('adjText');
      const nodeCountEl = document.getElementById('nodeCount');
      const edgeCountEl = document.getElementById('edgeCount');
      const directedCheckbox = document.getElementById('directed');
      const weightedCheckbox = document.getElementById('weighted');
      const modeAddEdgeBtn = document.getElementById('modeAddEdge');
      const clearBtn = document.getElementById('clearBtn');
      const sampleBtn = document.getElementById('sampleBtn');
      const autoLayoutBtn = document.getElementById('autoLayout');
      const exportBtn = document.getElementById('exportBtn');
      const importBtn = document.getElementById('importBtn');
      const deleteSelectedBtn = document.getElementById('deleteSelected');
      const deleteEdgeBtn = document.getElementById('deleteEdge');

      let graph = {
        nodes: [], // {id, label, x, y}
        edges: []  // {id, from, to, weight}
      };

      let state = {
        nextNodeId: 1,
        nextEdgeId: 1,
        modeAddEdge: false,
        selectedNodeId: null,
        selectedEdgeId: null,
        edgeFrom: null,
        dragging: null,
        dragOffset: {x:0,y:0}
      };

      // Helpers to create SVG elements
      function svgEl(tag, attrs){
        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for(const k in attrs) el.setAttribute(k, attrs[k]);
        return el;
      }

      // Render functions
      function render(){
        while(svg.lastChild && svg.lastChild.tagName !== 'defs') { svg.removeChild(svg.lastChild); } 
        // Remove existing children except defs (keep defs at top)
        // Actually remove everything after defs
        const defs = svg.querySelector('defs');
        // Clear but keep defs
        Array.from(svg.querySelectorAll(':scope > *')).forEach(node => {
          if(node !== defs) svg.removeChild(node);
        });

        // Draw edges
        graph.edges.forEach(edge => {
          const fromNode = graph.nodes.find(n => n.id === edge.from);
          const toNode = graph.nodes.find(n => n.id === edge.to);
          if(!fromNode || !toNode) return;
          const line = svgEl('line', {
            x1: fromNode.x, y1: fromNode.y, x2: toNode.x, y2: toNode.y,
            stroke: 'rgba(255,255,255,0.12)', 'stroke-width': 2, 'stroke-linecap': 'round',
            'data-edge-id': edge.id,
            pointerEvents: 'stroke'
          });
          // arrow for directed
          if(directedCheckbox.checked){
            line.setAttribute('marker-end', 'url(#arrow)');
          }
          if(state.selectedEdgeId === edge.id){
            line.setAttribute('stroke', '#93c5fd');
            line.setAttribute('stroke-width', 3);
          }
          svg.appendChild(line);

          // Edge label (weight) - placed at midpoint slightly offset
          if(edge.weight !== undefined && edge.weight !== null){
            const mx = (fromNode.x + toNode.x)/2;
            const my = (fromNode.y + toNode.y)/2;
            const label = svgEl('text', { x: mx + 8, y: my - 6, 'class':'edge-label' });
            label.textContent = edge.weight;
            svg.appendChild(label);
          }

          // Add transparent thick line for easier clicking
          const hit = svgEl('line', {
            x1: fromNode.x, y1: fromNode.y, x2: toNode.x, y2: toNode.y,
            stroke: 'transparent', 'stroke-width': 12, 'data-edge-id': edge.id
          });
          hit.addEventListener('click', (e)=> {
            e.stopPropagation();
            selectEdge(edge.id);
          });
          svg.appendChild(hit);
        });

        // Draw nodes (circles + labels)
        graph.nodes.forEach(node => {
          const g = svgEl('g', {'data-node-id': node.id, cursor:'pointer'});
          const circle = svgEl('circle', {
            cx: node.x, cy: node.y, r: 20, fill:'#60a5fa', stroke:'rgba(255,255,255,0.06)', 'stroke-width':1
          });
          if(state.selectedNodeId === node.id){
            circle.setAttribute('stroke','#fff');
            circle.setAttribute('stroke-width','2');
          }
          g.appendChild(circle);
          const text = svgEl('text', { x: node.x, y: node.y+5, 'text-anchor':'middle', 'class':'node-label' });
          text.textContent = node.label;
          g.appendChild(text);
          // Event handlers: click to select or to build edge, drag to move
          g.addEventListener('mousedown', (e)=>{
            e.stopPropagation();
            if(state.modeAddEdge){
              if(state.edgeFrom === null){
                state.edgeFrom = node.id;
                highlightNode(node.id, true);
              } else if(state.edgeFrom === node.id){
                // clicking same node cancels
                state.edgeFrom = null;
                highlightNode(node.id, false);
              } else {
                // create edge from edgeFrom -> node.id
                const fromId = state.edgeFrom;
                const toId = node.id;
                createEdge(fromId, toId);
                highlightNode(state.edgeFrom, false);
                state.edgeFrom = null;
              }
            } else {
              // start dragging
              state.dragging = node.id;
              const pt = getMousePos(e);
              const n = node;
              state.dragOffset.x = n.x - pt.x;
              state.dragOffset.y = n.y - pt.y;
            }
          });
          g.addEventListener('click', (e)=>{
            e.stopPropagation();
            if(!state.modeAddEdge) selectNode(node.id);
          });
          svg.appendChild(g);
        });

        nodeCountEl.textContent = graph.nodes.length;
        edgeCountEl.textContent = graph.edges.length;
        renderAdjList();
      }

      function highlightNode(nodeId, on){
        // temporary highlight during edge creation
        const nodeGroup = svg.querySelector('[data-node-id="'+nodeId+'"]');
        if(!nodeGroup) return;
        const circle = nodeGroup.querySelector('circle');
        if(on){
          circle.setAttribute('stroke','#fde68a');
          circle.setAttribute('stroke-width','2');
        } else {
          circle.setAttribute('stroke','rgba(255,255,255,0.06)');
          circle.setAttribute('stroke-width','1');
        }
      }

      function renderAdjList(){
        // Build adjacency list based on directed flag
        const directed = directedCheckbox.checked;
        const adj = {};
        graph.nodes.forEach(n => adj[n.id] = []);
        graph.edges.forEach(e => {
          const entry = { to: e.to, weight: e.weight };
          adj[e.from].push(entry);
          if(!directed){
            // undirected: add reverse
            adj[e.to].push({ to: e.from, weight: e.weight });
          }
        });
        // Produce pretty text
        const lines = [];
        graph.nodes.forEach(n => {
          const entries = adj[n.id].map(en => {
            const label = graph.nodes.find(x=>x.id===en.to)?.label || en.to;
            return en.weight !== undefined && en.weight !== null ? `${label}(${en.to}, w=${en.weight})` : `${label}(${en.to})`;
          });
          lines.push(`${n.label} (${n.id}): [ ${entries.join(', ')} ]`);
        });
        adjText.textContent = lines.length ? lines.join('\n') : '(empty)';
      }

      // Interactions
      svg.addEventListener('click', (e)=>{
        // click on background -> add node
        if(state.modeAddEdge){
          // if in edge mode clicking empty cancels any in-progress edge selection
          if(state.edgeFrom !== null){
            highlightNode(state.edgeFrom, false);
            state.edgeFrom = null;
          }
          return;
        }
        const pt = getMousePos(e);
        addNodeAt(pt.x, pt.y);
      });

      window.addEventListener('mousemove', (e)=>{
        if(state.dragging !== null){
          const pt = getMousePos(e);
          const node = graph.nodes.find(n => n.id === state.dragging);
          if(node){
            node.x = Math.max(30, Math.min(970, pt.x + state.dragOffset.x));
            node.y = Math.max(30, Math.min(670, pt.y + state.dragOffset.y));
            render();
          }
        }
      });

      window.addEventListener('mouseup', (e)=>{
        state.dragging = null;
      });

      function getMousePos(evt){
        const rect = svg.getBoundingClientRect();
        // Map to viewBox coordinates (svg viewBox is 0 0 1000 700)
        const viewBoxWidth = 1000, viewBoxHeight = 700;
        const x = (evt.clientX - rect.left) * (viewBoxWidth / rect.width);
        const y = (evt.clientY - rect.top) * (viewBoxHeight / rect.height);
        return { x,y };
      }

      function addNodeAt(x,y,label){
        const id = state.nextNodeId++;
        const lab = label || ('N'+id);
        graph.nodes.push({ id, label: lab, x, y });
        render();
      }

      function createEdge(from, to, weight){
        // Prevent duplicate exact edge (for directed). For undirected, keep single pair existence.
        const exists = graph.edges.some(e => {
          if(directedCheckbox.checked){
            return e.from === from && e.to === to;
          } else {
            return (e.from === from && e.to === to) || (e.from === to && e.to === from);
          }
        });
        if(exists){
          alert('Edge already exists between those nodes.');
          return;
        }
        let w = null;
        if(weight !== undefined){
          w = weight;
        } else if(weightedCheckbox.checked){
          const val = prompt('Enter weight (number or text):', '1');
          if(val === null) return; // cancel
          w = isNaN(Number(val)) ? val : Number(val);
        }
        const edge = { id: state.nextEdgeId++, from, to, weight: w };
        graph.edges.push(edge);
        render();
      }

      function selectNode(id){
        state.selectedNodeId = (state.selectedNodeId === id) ? null : id;
        state.selectedEdgeId = null;
        render();
      }

      function selectEdge(id){
        state.selectedEdgeId = (state.selectedEdgeId === id) ? null : id;
        state.selectedNodeId = null;
        render();
      }

      deleteSelectedBtn.addEventListener('click', ()=>{
        if(state.selectedNodeId === null){
          alert('No node selected.');
          return;
        }
        // remove node and edges touching it
        const nid = state.selectedNodeId;
        graph.nodes = graph.nodes.filter(n => n.id !== nid);
        graph.edges = graph.edges.filter(e => e.from !== nid && e.to !== nid);
        state.selectedNodeId = null;
        render();
      });

      deleteEdgeBtn.addEventListener('click', ()=>{
        if(state.selectedEdgeId === null){
          alert('No edge selected.');
          return;
        }
        const eid = state.selectedEdgeId;
        graph.edges = graph.edges.filter(e => e.id !== eid);
        state.selectedEdgeId = null;
        render();
      });

      modeAddEdgeBtn.addEventListener('click', ()=>{
        state.modeAddEdge = !state.modeAddEdge;
        modeAddEdgeBtn.classList.toggle('active', state.modeAddEdge);
        if(!state.modeAddEdge){
          if(state.edgeFrom !== null){
            highlightNode(state.edgeFrom, false);
            state.edgeFrom = null;
          }
        }
      });

      clearBtn.addEventListener('click', ()=>{
        if(!confirm('Clear the entire graph?')) return;
        graph.nodes = [];
        graph.edges = [];
        state.nextNodeId = 1;
        state.nextEdgeId = 1;
        state.selectedNodeId = null;
        state.selectedEdgeId = null;
        state.edgeFrom = null;
        render();
      });

      directedCheckbox.addEventListener('change', render);
      weightedCheckbox.addEventListener('change', ()=>{/* nothing special */});

      sampleBtn.addEventListener('click', ()=>{
        // small sample graph
        graph = { nodes: [], edges: [] };
        state.nextNodeId = 1;
        state.nextEdgeId = 1;
        addNodeAt(200,110,'A'); addNodeAt(380,90,'B'); addNodeAt(540,160,'C');
        addNodeAt(300,280,'D'); addNodeAt(520,300,'E');
        // add edges
        createEdge(1,2); createEdge(2,3); createEdge(1,4); createEdge(4,5); createEdge(3,5);
      });

      autoLayoutBtn.addEventListener('click', ()=>{
        // Simple circular layout
        const n = graph.nodes.length;
        if(n===0) return;
        const cx = 500, cy = 350, r = Math.min(260, n*25);
        graph.nodes.forEach((node,i)=> {
          const a = (i / n) * Math.PI * 2;
          node.x = cx + Math.cos(a) * r;
          node.y = cy + Math.sin(a) * r;
        });
        render();
      });

      exportBtn.addEventListener('click', ()=>{
        const json = JSON.stringify(graph, null, 2);
        // copy to clipboard
        navigator.clipboard?.writeText(json).then(()=> {
          alert('Graph JSON copied to clipboard.');
        }).catch(()=> {
          // fallback
          prompt('Copy this JSON', json);
        });
      });

      importBtn.addEventListener('click', ()=>{
        const txt = prompt('Paste graph JSON (nodes & edges arrays):');
        if(!txt) return;
        try{
          const obj = JSON.parse(txt);
          if(!Array.isArray(obj.nodes) || !Array.isArray(obj.edges)) throw new Error('Invalid format');
          graph = { nodes: obj.nodes.map(n=>({...n})), edges: obj.edges.map(e=>({...e})) };
          // set next ids
          state.nextNodeId = (graph.nodes.reduce((m,n)=>Math.max(m,n.id),0) || 0) + 1;
          state.nextEdgeId = (graph.edges.reduce((m,e)=>Math.max(m,e.id),0) || 0) + 1;
          render();
        }catch(err){
          alert('Failed to import JSON: ' + err.message);
        }
      });

      // Keyboard support: Delete key to remove selected node/edge
      window.addEventListener('keydown', (e)=>{
        if(e.key === 'Delete' || e.key === 'Backspace'){
          if(state.selectedNodeId !== null){
            deleteSelectedBtn.click();
          }else if(state.selectedEdgeId !== null){
            deleteEdgeBtn.click();
          }
        }
        if(e.key === 'e' || e.key === 'E'){
          // toggle edge mode
          modeAddEdgeBtn.click();
        }
      });

      // Small utilities: click on adjacency list line selects node
      adjText.addEventListener('click', (e)=>{
        // find closest label like "N3 (3):"
        // Not necessary to implement heavy parsing; but we can detect digits
        const sel = window.getSelection().toString();
        if(!sel) return;
        const m = sel.match(/\((\d+)\)/);
        if(m){
          const id = Number(m[1]);
          selectNode(id);
        }
      });

      // Initialize
      render();

      // Make sure viewBox is correct size
      svg.setAttribute('viewBox','0 0 1000 700');
    })();
  </script>
</body>
</html>