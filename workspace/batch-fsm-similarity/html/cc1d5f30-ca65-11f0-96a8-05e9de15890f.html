<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Interactive Heap (Min / Max) Visualization</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#60a5fa;
      --muted:#94a3b8;
      --node:#111827;
      --node-border:#334155;
      --text:#e6eef8;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{background:linear-gradient(180deg,#071028,#071623 40%);color:var(--text);padding:20px;box-sizing:border-box;}
    .wrap{max-width:1100px;margin:0 auto;display:grid;grid-template-columns:360px 1fr;gap:18px;}
    .panel{background:linear-gradient(180deg,var(--card),#071422);border:1px solid rgba(255,255,255,0.03);padding:16px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6);}
    h1{font-size:18px;margin:0 0 8px 0}
    p.muted{color:var(--muted);font-size:13px;margin:6px 0 12px;}
    .controls{display:flex;flex-direction:column;gap:10px;}
    .row{display:flex;gap:8px;align-items:center;}
    input[type="number"],input[type="text"]{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#071826;color:var(--text);outline:none;}
    button{padding:8px 10px;border-radius:8px;border:0;background:var(--accent);color:#04263e;font-weight:600;cursor:pointer;}
    button.gray{background:#223047;color:var(--text);}
    .small{font-size:13px;padding:6px 8px;border-radius:8px;}
    .toggles{display:flex;gap:8px;align-items:center;}
    label.switch{display:flex;align-items:center;gap:8px;font-size:13px;color:var(--muted)}
    .status{margin-top:12px;font-size:13px;color:var(--muted)}
    .visual{display:flex;flex-direction:column;gap:12px;height:650px;}
    .arrayView{background:linear-gradient(180deg,#061523,#071423);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);}
    .arrayRow{display:flex;gap:8px;flex-wrap:wrap;}
    .cell{min-width:42px;height:42px;background:linear-gradient(180deg,#0b2230,#06202a);border-radius:8px;display:flex;align-items:center;justify-content:center;color:var(--text);border:2px solid var(--node-border);font-weight:700;box-shadow:0 3px 10px rgba(4,10,20,0.6);}
    .cell.highlight{background:linear-gradient(180deg,#ffedd5,#ffd7b0);color:#102027;border-color:#f59e0b;transform:scale(1.06);}
    .arrayIndex{font-size:11px;color:var(--muted);margin-top:6px;text-align:center;}
    .treeWrap{position:relative;flex:1;background:linear-gradient(180deg,#021421,#031826);border-radius:10px;padding:12px;border:1px solid rgba(255,255,255,0.02);overflow:auto;}
    svg.lines{position:absolute;left:12px;top:12px;width:calc(100% - 24px);height:calc(100% - 24px);pointer-events:none;overflow:visible;}
    .level{display:flex;justify-content:space-between;align-items:center;margin:18px 6px;position:relative;min-height:64px;}
    .node{width:56px;height:56px;border-radius:50%;background:linear-gradient(180deg,#022a3a,#042b39);display:flex;align-items:center;justify-content:center;color:var(--text);font-weight:800;border:2px solid var(--node-border);box-shadow:0 6px 18px rgba(0,0,0,0.6);transition:transform .18s,background .18s,border-color .18s;}
    .node.highlight{background:linear-gradient(180deg,#fef3c7,#ffedd5);color:#102027;border-color:#fb923c;transform:scale(1.14);}
    .node.small{width:44px;height:44px;font-size:14px}
    .legend{font-size:13px;color:var(--muted);margin-top:12px}
    .footer{margin-top:10px;font-size:13px;color:var(--muted)}
    .explain{font-size:13px;color:var(--muted);margin-top:12px;line-height:1.4}
    .ops{display:flex;gap:8px;flex-wrap:wrap;}
    .muted-box{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;font-size:13px;color:var(--muted);}
    .code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,monospace;background:#01111a;padding:10px;border-radius:8px;color:#8be9fd;font-size:13px;overflow:auto}
    footer{margin-top:20px;text-align:center;color:var(--muted);font-size:13px}
    @media (max-width:900px){.wrap{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1>Heap (Min/Max) — Interactive Demo</h1>
      <p class="muted">Try inserting values, popping the top, building from an array, or switching between min-heap and max-heap. Watch the array representation and tree update step-by-step.</p>

      <div class="controls">
        <div class="row">
          <input id="valueInput" type="number" placeholder="Value to insert (e.g. 42)" />
          <button id="insertBtn">Insert</button>
        </div>

        <div class="row">
          <button id="popBtn" class="small">Pop Top</button>
          <button id="peekBtn" class="small gray">Peek</button>
          <button id="clearBtn" class="small gray">Clear</button>
        </div>

        <div class="row">
          <input id="arrInput" type="text" placeholder="Build from list, e.g. 9,4,7,1,0" />
          <button id="buildBtn">Build</button>
        </div>

        <div class="row">
          <button id="rndBtn" class="small gray">Random Fill</button>
          <select id="rndCount" style="padding:8px;border-radius:8px;background:#071826;color:var(--text);border:1px solid rgba(255,255,255,0.04);">
            <option>7</option><option>10</option><option>15</option><option>20</option>
          </select>
        </div>

        <div class="toggles">
          <label class="switch"><input id="typeToggle" type="checkbox" /> Max-heap</label>
          <label class="switch"><input id="animateToggle" type="checkbox" checked /> Animate</label>
          <label class="switch"><input id="showIndexes" type="checkbox" checked /> Show indexes</label>
        </div>

        <div class="status" id="status">Heap type: <strong id="typeLabel">Min-heap</strong> — size: <strong id="sizeLabel">0</strong></div>

        <div class="legend">
          Top element is root. Min-heap: smallest at top. Max-heap: largest at top.
        </div>

        <div class="explain">
          Key operations:
          <ul style="margin:6px 12px;color:var(--muted)">
            <li>Insert: place at end and sift-up to restore heap property (O(log n)).</li>
            <li>Pop top: swap root with last, remove it, then sift-down root (O(log n)).</li>
            <li>Build heap from array: bottom-up heapify with repeated sift-down (O(n)).</li>
          </ul>
        </div>

        <div class="footer">
          Implementation uses a binary heap stored in an array (0-based). Child indices: left = 2*i+1, right = 2*i+2.
        </div>
      </div>
    </div>

    <div class="panel visual">
      <div class="arrayView">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <strong>Array representation (index order)</strong>
          <div style="color:var(--muted);font-size:13px" id="topVal">Top: —</div>
        </div>
        <div class="arrayRow" id="arrayRow" style="margin-top:12px;"></div>
      </div>

      <div class="treeWrap" id="treeWrap">
        <svg class="lines" id="lines"></svg>
        <div id="treeLevels"></div>
      </div>

      <div style="display:flex;gap:12px;align-items:center;">
        <div class="muted-box" id="opLog">Operation log: (most recent at top)</div>
        <div style="flex:1"></div>
        <div class="code" id="complexity">Insert: O(log n) • Pop: O(log n) • Build: O(n)</div>
      </div>
    </div>
  </div>

  <script>
    // Heap implementation with animation support
    class Heap {
      constructor(isMax=false, onStep=null) {
        this.data = [];
        this.isMax = !!isMax;
        this.onStep = typeof onStep === 'function' ? onStep : ()=>{};
      }
      cmp(a,b){
        return this.isMax ? a > b : a < b;
      }
      size(){ return this.data.length; }
      peek(){ return this.data[0]; }
      swap(i,j){
        [this.data[i], this.data[j]] = [this.data[j], this.data[i]];
      }
      async insert(value, animate=true){
        const i = this.data.length;
        this.data.push(value);
        await this.onStep({type:'push',index:i});
        await this._siftUp(i, animate);
      }
      async pop(animate=true){
        if(this.data.length === 0) return undefined;
        const top = this.data[0];
        const lastIdx = this.data.length - 1;
        if(lastIdx === 0){
          this.data.pop();
          await this.onStep({type:'pop',poppedIndex:0, value: top});
          return top;
        }
        this.swap(0, lastIdx);
        await this.onStep({type:'swap',i:0,j:lastIdx});
        this.data.pop();
        await this.onStep({type:'pop',poppedIndex:lastIdx, value: top});
        await this._siftDown(0, animate);
        return top;
      }
      async buildFromArray(arr, animate=true){
        this.data = arr.slice();
        await this.onStep({type:'build',array:this.data.slice()});
        // heapify bottom-up
        const n = this.data.length;
        for(let i = Math.floor(n/2)-1; i>=0; i--){
          await this._siftDown(i, animate);
        }
      }
      async _siftUp(i, animate=true){
        let idx = i;
        while(idx > 0){
          const parent = Math.floor((idx-1)/2);
          if(this.cmp(this.data[idx], this.data[parent])){
            this.swap(idx, parent);
            await this.onStep({type:'swap',i:idx,j:parent});
            idx = parent;
          } else break;
        }
      }
      async _siftDown(i, animate=true){
        let idx = i;
        const n = this.data.length;
        while(true){
          const left = 2*idx + 1;
          const right = 2*idx + 2;
          let candidate = idx;
          if(left < n && this.cmp(this.data[left], this.data[candidate])) candidate = left;
          if(right < n && this.cmp(this.data[right], this.data[candidate])) candidate = right;
          if(candidate !== idx){
            this.swap(idx, candidate);
            await this.onStep({type:'swap',i:idx,j:candidate});
            idx = candidate;
          } else break;
        }
      }
    }

    // UI and visualization
    const valueInput = document.getElementById('valueInput');
    const insertBtn = document.getElementById('insertBtn');
    const popBtn = document.getElementById('popBtn');
    const peekBtn = document.getElementById('peekBtn');
    const clearBtn = document.getElementById('clearBtn');
    const arrInput = document.getElementById('arrInput');
    const buildBtn = document.getElementById('buildBtn');
    const rndBtn = document.getElementById('rndBtn');
    const rndCount = document.getElementById('rndCount');
    const typeToggle = document.getElementById('typeToggle');
    const animateToggle = document.getElementById('animateToggle');
    const showIndexes = document.getElementById('showIndexes');

    const typeLabel = document.getElementById('typeLabel');
    const sizeLabel = document.getElementById('sizeLabel');
    const arrayRow = document.getElementById('arrayRow');
    const treeLevels = document.getElementById('treeLevels');
    const linesSvg = document.getElementById('lines');
    const topVal = document.getElementById('topVal');
    const opLog = document.getElementById('opLog');

    function logOp(msg){
      const time = new Date().toLocaleTimeString();
      opLog.innerHTML = `<div style="padding:6px 0;border-bottom:1px dashed rgba(255,255,255,0.02)"><strong style="color:var(--accent)">${time}</strong> — ${msg}</div>` + opLog.innerHTML;
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    let animDelay = 450; // ms per step
    function stepDelay(enabled){ return enabled ? sleep(animDelay) : Promise.resolve(); }

    // create heap with callback onStep
    let heap = new Heap(false, onStep);

    function updateStatus(){
      typeLabel.textContent = heap.isMax ? "Max-heap" : "Min-heap";
      sizeLabel.textContent = heap.size();
      topVal.textContent = `Top: ${heap.size() ? heap.peek() : '—'}`;
      renderAll();
    }

    // Visualization rendering
    function renderArray(highlightIdxs=[]){
      arrayRow.innerHTML = '';
      const arr = heap.data;
      for(let i=0;i<arr.length;i++){
        const cell = document.createElement('div');
        cell.className = 'cell' + (highlightIdxs.includes(i) ? ' highlight' : '');
        cell.textContent = arr[i];
        arrayRow.appendChild(cell);
      }
      if(arr.length===0){
        arrayRow.innerHTML = '<div style="color:var(--muted)">[ empty ]</div>';
      }
    }

    function renderTree(highlightIdxs=[]){
      treeLevels.innerHTML = '';
      linesSvg.innerHTML = '';
      const arr = heap.data;
      if(arr.length===0){
        treeLevels.innerHTML = '<div style="color:var(--muted);padding:20px;text-align:center">Heap is empty</div>';
        return;
      }
      // compute levels
      let level = 0, i = 0;
      const positions = []; // store node positions for drawing lines
      const containerWidth = treeLevels.clientWidth || 800;
      while(i < arr.length){
        const cnt = Math.min(Math.pow(2, level), arr.length - i);
        const row = document.createElement('div');
        row.className = 'level';
        // place nodes evenly across the available width
        for(let j=0;j<cnt;j++){
          const idx = i + j;
          const node = document.createElement('div');
          node.className = 'node' + (highlightIdxs.includes(idx) ? ' highlight' : '') + (arr.length>32 ? ' small' : '');
          node.textContent = arr[idx];
          node.dataset.idx = idx;
          if(showIndexes.checked){
            const idxDiv = document.createElement('div');
            idxDiv.className = 'arrayIndex';
            idxDiv.textContent = idx;
            idxDiv.style.position = 'absolute';
            idxDiv.style.top = '62px';
            idxDiv.style.left = '0';
            idxDiv.style.width = '100%';
            node.appendChild(idxDiv);
          }
          row.appendChild(node);
        }
        treeLevels.appendChild(row);
        i += cnt;
        level++;
      }
      // compute DOM positions
      // After layout, measure nodes and draw lines
      const nodes = treeLevels.querySelectorAll('.node');
      nodes.forEach(n => {
        const r = n.getBoundingClientRect();
        const parentRect = treeLevels.getBoundingClientRect();
        positions.push({idx: Number(n.dataset.idx), cx: r.left - parentRect.left + r.width/2, cy: r.top - parentRect.top + r.height/2});
      });
      // draw lines between parent-child
      // map index to position
      const posMap = {};
      positions.forEach(p => posMap[p.idx] = p);
      for(let k=0;k<positions.length;k++){
        const idx = positions[k].idx;
        const leftIdx = 2*idx + 1;
        const rightIdx = 2*idx + 2;
        [leftIdx, rightIdx].forEach(childIdx => {
          if(posMap[childIdx]){
            const p = posMap[idx];
            const c = posMap[childIdx];
            const line = document.createElementNS('http://www.w3.org/2000/svg','line');
            line.setAttribute('x1', p.cx);
            line.setAttribute('y1', p.cy + 22); // slightly below center of circle
            line.setAttribute('x2', c.cx);
            line.setAttribute('y2', c.cy - 22);
            line.setAttribute('stroke', 'rgba(200,220,255,0.06)');
            line.setAttribute('stroke-width', '2');
            line.setAttribute('stroke-linecap','round');
            linesSvg.appendChild(line);
          }
        });
      }
    }

    async function onStep(evt){
      // evt types: push, swap, pop, build
      // we will highlight indices during swap and show array/tree updates
      if(evt.type === 'push'){
        renderArray([evt.index]);
        renderTree([evt.index]);
        updateStatus();
        await stepDelay(animateToggle.checked);
      } else if(evt.type === 'swap'){
        renderArray([evt.i, evt.j]);
        renderTree([evt.i, evt.j]);
        updateStatus();
        await stepDelay(animateToggle.checked);
      } else if(evt.type === 'pop'){
        renderArray([]); renderTree([]);
        updateStatus();
        logOp(`Popped value ${evt.value}`);
        await stepDelay(animateToggle.checked);
      } else if(evt.type === 'build'){
        renderArray([]);
        renderTree([]);
        updateStatus();
        logOp('Started building heap from array');
        await stepDelay(animateToggle.checked);
      }
      // after each step, do a full render to ensure final positions
      renderArray();
      renderTree();
    }

    // Initial render
    updateStatus();

    // Wire up UI
    insertBtn.addEventListener('click', async () => {
      const v = valueInput.value.trim();
      if(v === '') return;
      const num = Number(v);
      if(Number.isNaN(num)) return alert('Please enter a number');
      insertBtn.disabled = true;
      await heap.insert(num, animateToggle.checked);
      logOp(`Inserted ${num}`);
      valueInput.value = '';
      insertBtn.disabled = false;
      updateStatus();
    });

    popBtn.addEventListener('click', async () => {
      popBtn.disabled = true;
      const val = await heap.pop(animateToggle.checked);
      if(val === undefined) logOp('Pop attempted on empty heap');
      else logOp(`Popped top ${val}`);
      popBtn.disabled = false;
      updateStatus();
    });

    peekBtn.addEventListener('click', () => {
      const v = heap.peek();
      alert(heap.size() ? `Top element: ${v}` : 'Heap is empty');
    });

    clearBtn.addEventListener('click', () => {
      heap.data = [];
      logOp('Cleared heap');
      updateStatus();
    });

    buildBtn.addEventListener('click', async () => {
      const text = arrInput.value.trim();
      if(!text) return;
      const parts = text.split(',').map(s => s.trim()).filter(s => s.length);
      const nums = [];
      for(const p of parts){
        const n = Number(p);
        if(Number.isNaN(n)){ alert('Invalid number in list: ' + p); return; }
        nums.push(n);
      }
      buildBtn.disabled = true;
      await heap.buildFromArray(nums, animateToggle.checked);
      logOp(`Built heap from array [${nums.join(', ')}]`);
      buildBtn.disabled = false;
      updateStatus();
    });

    rndBtn.addEventListener('click', async () => {
      const count = Number(rndCount.value) || 10;
      const arr = [];
      for(let i=0;i<count;i++) arr.push(Math.floor(Math.random()*100));
      rndBtn.disabled = true;
      await heap.buildFromArray(arr, animateToggle.checked);
      logOp(`Random fill ${count} items`);
      rndBtn.disabled = false;
      updateStatus();
    });

    typeToggle.addEventListener('change', async () => {
      const wasMax = heap.isMax;
      heap.isMax = typeToggle.checked;
      updateStatus();
      // rebuild heap to respect new comparator (re-heapify data)
      const arrCopy = heap.data.slice();
      await heap.buildFromArray(arrCopy, animateToggle.checked);
      logOp(`Switched to ${heap.isMax ? 'Max' : 'Min'}-heap`);
    });

    animateToggle.addEventListener('change', () => {
      // nothing else; delay used in onStep
    });

    showIndexes.addEventListener('change', () => {
      renderAll();
    });

    // handle window resize to re-render tree lines
    window.addEventListener('resize', () => {
      renderAll();
    });

    function renderAll(){
      renderArray();
      renderTree();
    }

    // Seed with a sample
    (async function seed(){
      const sample = [9,4,7,1,0,6,5,2,3,8];
      await heap.buildFromArray(sample, false);
      logOp('Initialized sample heap');
      updateStatus();
    })();

  </script>
</body>
</html>