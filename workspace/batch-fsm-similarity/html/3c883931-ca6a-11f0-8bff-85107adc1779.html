<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Heap (Min/Max) Demonstration</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 2rem;
    max-width: 700px;
  }
  h1 {
    text-align: center;
  }
  .container {
    display: flex;
    flex-wrap: wrap;
    gap: 1.5rem;
  }
  .heap-container {
    flex: 1 1 300px;
    border: 1px solid #ddd;
    padding: 1rem;
    border-radius: 6px;
    background: #f9f9f9;
  }
  label {
    display: block;
    margin: 0.6rem 0 0.3rem;
  }
  input[type="number"] {
    width: 7rem;
    padding: 0.3rem;
    font-size: 1rem;
  }
  input[type="text"] {
    width: 100%;
    padding: 0.5rem;
    font-family: monospace;
    font-size: 1rem;
  }
  button {
    margin-top: 0.8rem;
    padding: 0.5rem 1rem;
    font-size: 1rem;
    cursor: pointer;
  }
  pre {
    background: #fff;
    padding: 1rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-family: monospace;
    overflow-x: auto;
  }
  .heap-visual {
    margin-top: 1rem;
    font-family: monospace;
    white-space: pre;
    line-height: 1.2;
  }
</style>
</head>
<body>
<h1>Heap (Min/Max) Visualization & Demo</h1>
<p>
  This demo lets you work with Min Heap and Max Heap data structures.
  Enter numbers and insert or extract from the heap to see its state.
</p>

<div class="container">
  <div class="heap-container" id="minHeapSection">
    <h2>Min Heap</h2>
    <label for="minInput">Enter number to insert:</label>
    <input type="number" id="minInput" />
    <br />
    <button id="minInsertBtn">Insert</button>
    <button id="minExtractBtn">Extract Min</button>

    <h3>Heap Array:</h3>
    <pre id="minHeapArray">[]</pre>

    <h3>Heap Tree Visualization:</h3>
    <div class="heap-visual" id="minHeapVisual"></div>
  </div>

  <div class="heap-container" id="maxHeapSection">
    <h2>Max Heap</h2>
    <label for="maxInput">Enter number to insert:</label>
    <input type="number" id="maxInput" />
    <br />
    <button id="maxInsertBtn">Insert</button>
    <button id="maxExtractBtn">Extract Max</button>

    <h3>Heap Array:</h3>
    <pre id="maxHeapArray">[]</pre>

    <h3>Heap Tree Visualization:</h3>
    <div class="heap-visual" id="maxHeapVisual"></div>
  </div>
</div>

<script>
class Heap {
  constructor(comparator) {
    this.data = [];
    this.compare = comparator; // comparator(a, b) returns true if a has higher priority than b for the heap
  }

  size() {
    return this.data.length;
  }

  insert(value) {
    this.data.push(value);
    this._heapifyUp(this.size() - 1);
  }

  peek() {
    if (this.size() === 0) return null;
    return this.data[0];
  }

  extract() {
    if (this.size() === 0) return null;
    if (this.size() === 1) return this.data.pop();

    const top = this.data[0];
    this.data[0] = this.data.pop();
    this._heapifyDown(0);
    return top;
  }

  _heapifyUp(index) {
    let currentIndex = index;
    while (currentIndex > 0) {
      const parentIndex = Math.floor((currentIndex - 1) / 2);
      if (this.compare(this.data[currentIndex], this.data[parentIndex])) {
        [this.data[currentIndex], this.data[parentIndex]] = [this.data[parentIndex], this.data[currentIndex]];
        currentIndex = parentIndex;
      } else {
        break;
      }
    }
  }

  _heapifyDown(index) {
    let currentIndex = index;
    const size = this.size();

    while (true) {
      const leftChild = 2 * currentIndex + 1;
      const rightChild = 2 * currentIndex + 2;
      let candidate = currentIndex;

      if (leftChild < size && this.compare(this.data[leftChild], this.data[candidate])) {
        candidate = leftChild;
      }
      if (rightChild < size && this.compare(this.data[rightChild], this.data[candidate])) {
        candidate = rightChild;
      }
      if (candidate === currentIndex) break;

      [this.data[currentIndex], this.data[candidate]] = [this.data[candidate], this.data[currentIndex]];
      currentIndex = candidate;
    }
  }
}

// Visualize heap as a tree-like structure (sideways, with root on top)
function visualizeHeap(data) {
  if (data.length === 0) return "(empty)";
  // We'll use breadth-first levels and print them with spacing accordingly
  // To keep it simple, we'll print each level on its own line separated by spaces

  // Calculate height of the heap tree
  const height = Math.floor(Math.log2(data.length)) + 1;

  const lines = [];
  let index = 0;

  for (let level = 0; level < height; level++) {
    const levelCount = 2 ** level;
    let line = "";
    // Calculate padding at start and between elements for better visualization
    // Max nodes at bottom level = 2^(height-1)
    // We'll use spacing proportional to max nodes to keep it aligned roughly
    const maxNodesBottom = 2 ** (height - 1);
    const spaceBetween = Math.floor(60 / (levelCount));
    const spaceStart = Math.floor(spaceBetween / 2);

    line += " ".repeat(spaceStart);
    for (let i = 0; i < levelCount && index < data.length; i++, index++) {
      line += data[index].toString().padStart(2, " ");
      line += " ".repeat(spaceBetween);
    }
    lines.push(line);
  }
  return lines.join("\n");
}

const minHeap = new Heap((a, b) => a < b);
const maxHeap = new Heap((a, b) => a > b);

function updateDisplay() {
  document.getElementById("minHeapArray").textContent = JSON.stringify(minHeap.data);
  document.getElementById("minHeapVisual").textContent = visualizeHeap(minHeap.data);

  document.getElementById("maxHeapArray").textContent = JSON.stringify(maxHeap.data);
  document.getElementById("maxHeapVisual").textContent = visualizeHeap(maxHeap.data);
}

document.getElementById("minInsertBtn").addEventListener("click", () => {
  const valStr = document.getElementById("minInput").value;
  if (valStr === "") return alert("Enter a number to insert in Min Heap");
  const val = Number(valStr);
  if (isNaN(val)) return alert("Enter a valid number");
  minHeap.insert(val);
  document.getElementById("minInput").value = "";
  updateDisplay();
});

document.getElementById("minExtractBtn").addEventListener("click", () => {
  if (minHeap.size() === 0) return alert("Min Heap is empty");
  const extracted = minHeap.extract();
  alert("Extracted Min: " + extracted);
  updateDisplay();
});

document.getElementById("maxInsertBtn").addEventListener("click", () => {
  const valStr = document.getElementById("maxInput").value;
  if (valStr === "") return alert("Enter a number to insert in Max Heap");
  const val = Number(valStr);
  if (isNaN(val)) return alert("Enter a valid number");
  maxHeap.insert(val);
  document.getElementById("maxInput").value = "";
  updateDisplay();
});

document.getElementById("maxExtractBtn").addEventListener("click", () => {
  if (maxHeap.size() === 0) return alert("Max Heap is empty");
  const extracted = maxHeap.extract();
  alert("Extracted Max: " + extracted);
  updateDisplay();
});

// Initialize display
updateDisplay();
</script>
</body>
</html>