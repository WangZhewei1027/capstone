<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Deque (Double-Ended Queue) â€” Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#22c1c3;
      --muted:#94a3b8;
      --glass: rgba(255,255,255,0.03);
      --green:#10b981;
      --red:#ef4444;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    body{background:
      linear-gradient(180deg,#071025 0%, #04111b 40%),
      radial-gradient(600px 400px at 10% 20%, rgba(34,193,195,0.06), transparent 8%),
      radial-gradient(400px 300px at 90% 80%, rgba(59,130,246,0.03), transparent 10%);
      color:#e6eef6; padding:28px; box-sizing:border-box;}
    .container{max-width:1100px;margin:0 auto;}
    header{display:flex;align-items:center;gap:18px;margin-bottom:18px;}
    h1{font-size:20px;margin:0;}
    p.lead{margin:0;color:var(--muted);font-size:13px;}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); padding:16px;border-radius:10px;box-shadow: 0 6px 18px rgba(2,6,23,0.6); margin-bottom:16px;}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
    input[type="text"]{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;min-width:140px;}
    button{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.05));border:1px solid rgba(255,255,255,0.05);color:inherit;padding:8px 12px;border-radius:8px;cursor:pointer;}
    button:active{transform:translateY(1px);}
    button.warn{border-color:rgba(255,165,0,0.12)}
    button.crit{border-color:rgba(255,0,0,0.12); color:var(--red)}
    .visual{padding:18px;display:flex;flex-direction:column;gap:12px;align-items:center;}
    .deque-row{display:flex;gap:10px;align-items:center;min-height:110px;transition:all .25s ease;}
    .node{min-width:68px;min-height:64px;padding:8px;border-radius:8px;background:var(--glass);display:flex;flex-direction:column;align-items:center;justify-content:center;border:1px solid rgba(255,255,255,0.03);box-shadow: 0 6px 14px rgba(2,6,23,0.45);transition:transform .18s ease, box-shadow .18s ease;position:relative;}
    .node .val{font-weight:600;font-size:14px;}
    .node .lbl{font-size:11px;color:var(--muted);margin-top:6px;}
    .node.front{box-shadow:0 10px 30px rgba(34,193,195,0.08);border-color:rgba(34,193,195,0.12)}
    .node.back{box-shadow:0 10px 30px rgba(99,102,241,0.06);border-color:rgba(99,102,241,0.12)}
    .node.empty{opacity:.28;border-style:dashed}
    .meta{display:flex;gap:12px;align-items:center;color:var(--muted);font-size:13px;}
    pre{background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;overflow:auto;margin:0;font-size:13px}
    .log{max-height:160px;overflow:auto;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02);font-size:13px;}
    .row{display:flex;gap:12px;align-items:center;}
    .info{color:var(--muted);font-size:13px}
    .badge{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));border-radius:999px;padding:6px 10px;font-weight:600;color:var(--accent);border:1px solid rgba(255,255,255,0.03)}
    footer{color:var(--muted);font-size:12px;margin-top:12px}
    @media (max-width:720px){
      .deque-row{flex-wrap:wrap;justify-content:center}
      .controls{justify-content:center}
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Deque â€” Double-Ended Queue (interactive)</h1>
        <p class="lead">A deque supports fast insertion/removal at both ends. Try pushing, popping, peeking and watch the structure update.</p>
      </div>
      <div style="margin-left:auto" class="meta">
        <div class="badge">Amortized O(1) ops</div>
        <div class="info">Implemented with a doubly-linked list</div>
      </div>
    </header>

    <section class="card">
      <div class="controls" style="margin-bottom:12px;">
        <input id="valueInput" type="text" placeholder="Value (string/number)" />
        <button id="pushFrontBtn">Push Front</button>
        <button id="pushBackBtn">Push Back</button>
        <button id="popFrontBtn">Pop Front</button>
        <button id="popBackBtn">Pop Back</button>
        <button id="peekFrontBtn">Peek Front</button>
        <button id="peekBackBtn">Peek Back</button>
        <button id="clearBtn" class="crit">Clear</button>
        <button id="randomBtn" class="warn">Random ops</button>
      </div>

      <div class="visual">
        <div style="display:flex;gap:12px;align-items:center;width:100%;justify-content:space-between;">
          <div class="meta"><strong>Size:</strong>&nbsp;<span id="sizeLabel">0</span></div>
          <div class="meta"><strong>Front index:</strong>&nbsp;<span id="frontIdx">â€”</span>&nbsp;&nbsp;<strong>Back index:</strong>&nbsp;<span id="backIdx">â€”</span></div>
          <div class="meta info">Tip: press Enter to push to back, Shift+Enter to push to front.</div>
        </div>

        <div class="deque-row" id="dequeRow" aria-live="polite" style="margin-top:8px;"></div>

        <div style="display:flex;gap:12px;width:100%;margin-top:6px;flex-wrap:wrap;">
          <div style="flex:1">
            <div style="margin-bottom:8px;color:var(--muted)">Operations log</div>
            <div class="log" id="log"></div>
          </div>
          <div style="width:360px;max-width:40%;">
            <div style="margin-bottom:8px;color:var(--muted)">Deque class (source)</div>
            <pre id="code">
class DequeNode {
  constructor(value){ this.value = value; this.prev = null; this.next = null; }
}
class Deque {
  constructor(){
    this.head = null; this.tail = null; this._size = 0;
  }
  pushFront(value){ /* ... */ }
  pushBack(value){ /* ... */ }
  popFront(){ /* ... */ }
  popBack(){ /* ... */ }
  peekFront(){ /* ... */ }
  peekBack(){ /* ... */ }
  size(){ return this._size; }
  clear(){ /* ... */ }
  toArray(){ /* ... */ }
}
            </pre>
          </div>
        </div>
      </div>
    </section>

    <section class="card">
      <div style="display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap;">
        <div style="flex:1;">
          <h3 style="margin:0 0 8px 0;font-size:16px">Explanation</h3>
          <p class="info" style="margin-top:0">
            A deque (double-ended queue) allows adding and removing items from both the front and the back.
            In this demo the Deque class is implemented as a doubly-linked list so push/pop at either end run in O(1) time.
          </p>
          <ul class="info" style="margin:6px 0 0 18px;">
            <li>pushFront(value) â€” insert at front</li>
            <li>pushBack(value) â€” insert at back</li>
            <li>popFront() â€” remove and return front (or undefined if empty)</li>
            <li>popBack() â€” remove and return back (or undefined if empty)</li>
            <li>peekFront()/peekBack() â€” look without removing</li>
            <li>size(), clear(), toArray()</li>
          </ul>
        </div>

        <div style="width:320px;">
          <h4 style="margin:0 0 8px 0;font-size:15px">Complexity</h4>
          <div class="info" style="line-height:1.5">
            - pushFront/pushBack/popFront/popBack: O(1)<br>
            - peekFront/peekBack: O(1)<br>
            - toArray: O(n)
          </div>
        </div>
      </div>
    </section>

    <footer>Built with plain JavaScript â€” Doubly-linked list Deque visualization.</footer>
  </div>

  <script>
    // Doubly-linked list Deque implementation
    class DequeNode {
      constructor(value){
        this.value = value;
        this.prev = null;
        this.next = null;
      }
    }

    class Deque {
      constructor(){
        this.head = null; // front
        this.tail = null; // back
        this._size = 0;
      }

      pushFront(value){
        const node = new DequeNode(value);
        if(!this.head){
          this.head = this.tail = node;
        } else {
          node.next = this.head;
          this.head.prev = node;
          this.head = node;
        }
        this._size++;
        return this;
      }

      pushBack(value){
        const node = new DequeNode(value);
        if(!this.tail){
          this.head = this.tail = node;
        } else {
          node.prev = this.tail;
          this.tail.next = node;
          this.tail = node;
        }
        this._size++;
        return this;
      }

      popFront(){
        if(!this.head) return undefined;
        const val = this.head.value;
        if(this.head === this.tail){
          this.head = this.tail = null;
        } else {
          this.head = this.head.next;
          this.head.prev = null;
        }
        this._size--;
        return val;
      }

      popBack(){
        if(!this.tail) return undefined;
        const val = this.tail.value;
        if(this.head === this.tail){
          this.head = this.tail = null;
        } else {
          this.tail = this.tail.prev;
          this.tail.next = null;
        }
        this._size--;
        return val;
      }

      peekFront(){
        return this.head ? this.head.value : undefined;
      }

      peekBack(){
        return this.tail ? this.tail.value : undefined;
      }

      size(){ return this._size; }

      clear(){
        this.head = this.tail = null;
        this._size = 0;
      }

      toArray(){
        const arr = [];
        let cur = this.head;
        while(cur){
          arr.push(cur.value);
          cur = cur.next;
        }
        return arr;
      }
    }

    // UI wiring
    const dq = new Deque();
    const dequeRow = document.getElementById('dequeRow');
    const logEl = document.getElementById('log');
    const sizeLabel = document.getElementById('sizeLabel');
    const frontIdx = document.getElementById('frontIdx');
    const backIdx = document.getElementById('backIdx');
    const valueInput = document.getElementById('valueInput');

    const pushFrontBtn = document.getElementById('pushFrontBtn');
    const pushBackBtn = document.getElementById('pushBackBtn');
    const popFrontBtn = document.getElementById('popFrontBtn');
    const popBackBtn = document.getElementById('popBackBtn');
    const peekFrontBtn = document.getElementById('peekFrontBtn');
    const peekBackBtn = document.getElementById('peekBackBtn');
    const clearBtn = document.getElementById('clearBtn');
    const randomBtn = document.getElementById('randomBtn');

    function log(msg, type){
      const time = new Date().toLocaleTimeString();
      const el = document.createElement('div');
      el.textContent = `[${time}] ${msg}`;
      if(type === 'err') el.style.color = 'var(--red)';
      logEl.prepend(el);
    }

    function render(){
      // update metadata
      sizeLabel.textContent = dq.size();
      frontIdx.textContent = dq.head ? '0' : 'â€”';
      backIdx.textContent = dq.tail ? String(Math.max(0, dq.size()-1)) : 'â€”';

      // clear view
      dequeRow.innerHTML = '';

      // if empty show placeholder
      if(dq.size() === 0){
        const emptyNode = document.createElement('div');
        emptyNode.className = 'node empty';
        emptyNode.style.minWidth = '240px';
        emptyNode.innerHTML = '<div class="val" style="opacity:.8">EMPTY DEQUE</div><div class="lbl">pushFront / pushBack to add</div>';
        dequeRow.appendChild(emptyNode);
        return;
      }

      // render nodes left-to-right: front -> back
      const arr = dq.toArray();
      arr.forEach((v,i) => {
        const n = document.createElement('div');
        n.className = 'node';
        if(i === 0) n.classList.add('front');
        if(i === arr.length - 1) n.classList.add('back');
        n.innerHTML = `<div class="val">${escapeHtml(String(v))}</div><div class="lbl">index ${i}</div>`;
        dequeRow.appendChild(n);
      });
    }

    function escapeHtml(s){
      return s.replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch]));
    }

    // Hook up buttons
    pushFrontBtn.addEventListener('click', () => {
      const v = valueInput.value.trim();
      if(v === ''){ log('Enter a value to push (front).', 'err'); return; }
      dq.pushFront(v);
      log(`pushFront(${v})`);
      valueInput.value = '';
      render();
    });

    pushBackBtn.addEventListener('click', () => {
      const v = valueInput.value.trim();
      if(v === ''){ log('Enter a value to push (back).', 'err'); return; }
      dq.pushBack(v);
      log(`pushBack(${v})`);
      valueInput.value = '';
      render();
    });

    popFrontBtn.addEventListener('click', () => {
      const v = dq.popFront();
      if(v === undefined){ log('popFront() â†’ undefined (deque empty)', 'err'); }
      else log(`popFront() â†’ ${v}`);
      render();
    });

    popBackBtn.addEventListener('click', () => {
      const v = dq.popBack();
      if(v === undefined){ log('popBack() â†’ undefined (deque empty)', 'err'); }
      else log(`popBack() â†’ ${v}`);
      render();
    });

    peekFrontBtn.addEventListener('click', () => {
      const v = dq.peekFront();
      if(v === undefined) log('peekFront() â†’ undefined (deque empty)', 'err');
      else log(`peekFront() â†’ ${v}`);
    });

    peekBackBtn.addEventListener('click', () => {
      const v = dq.peekBack();
      if(v === undefined) log('peekBack() â†’ undefined (deque empty)', 'err');
      else log(`peekBack() â†’ ${v}`);
    });

    clearBtn.addEventListener('click', () => {
      dq.clear();
      log('clear()');
      render();
    });

    // random ops: perform a sequence of random pushes/pops
    randomBtn.addEventListener('click', () => {
      const ops = [
        () => { const v = randomValue(); dq.pushFront(v); log(`pushFront(${v})`); },
        () => { const v = randomValue(); dq.pushBack(v); log(`pushBack(${v})`); },
        () => { const v = dq.popFront(); log(`popFront() â†’ ${v === undefined ? 'undefined' : v}`); },
        () => { const v = dq.popBack(); log(`popBack() â†’ ${v === undefined ? 'undefined' : v}`); },
      ];
      const steps = 6 + Math.floor(Math.random()*6);
      let i = 0;
      const t = setInterval(() => {
        const op = ops[Math.floor(Math.random()*ops.length)];
        op();
        render();
        i++;
        if(i >= steps) clearInterval(t);
      }, 250);
    });

    function randomValue(){
      const sample = ['A','B','C','1','2','3','ðŸŽ','ðŸš€','foo','bar','42'];
      return sample[Math.floor(Math.random()*sample.length)];
    }

    // keyboard shortcuts: Enter => pushBack, Shift+Enter => pushFront, Escape => clear
    valueInput.addEventListener('keydown', (e) => {
      if(e.key === 'Enter'){
        e.preventDefault();
        if(e.shiftKey) pushFrontBtn.click();
        else pushBackBtn.click();
      } else if(e.key === 'Escape'){
        clearBtn.click();
      }
    });

    // initial demo setup
    (function initDemo(){
      log('Deque demo ready. Enter a value and use the buttons or press Enter.');
      // small example
      dq.pushBack('x'); dq.pushFront('y'); dq.pushBack(7);
      log('Example: pushBack("x"), pushFront("y"), pushBack(7)');
      render();
    })();

    // expose for console experimentation
    window.Deque = Deque;
    window._dq = dq;
  </script>
</body>
</html>