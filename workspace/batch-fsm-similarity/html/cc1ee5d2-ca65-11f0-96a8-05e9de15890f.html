<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Recursion Explorer — Interactive Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{ --bg:#0f1720; --panel:#0b1220; --muted:#9aa7b2; --accent:#66d9ef; --accent2:#7ee787; --glass:rgba(255,255,255,0.035); }
  html,body{ height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; background: linear-gradient(180deg,#071020 0%, #081826 60%); color:#e6f0f2; }
  .wrap{ display:grid; grid-template-columns: 360px 1fr 320px; gap:18px; padding:18px; height:100vh; box-sizing:border-box; align-items:start; }
  .panel{ background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:10px; padding:14px; box-shadow: 0 6px 18px rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,0.03); }
  h2{ margin:6px 0 10px 0; font-size:16px; letter-spacing:0.2px; color:var(--accent); }
  label{ font-size:13px; color:var(--muted); display:block; margin-top:8px; }
  select,input[type=number]{ width:100%; padding:8px 10px; margin-top:6px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit; }
  button{ background:linear-gradient(180deg,var(--accent), #35a7b5); color:#042027; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; box-shadow: 0 6px 18px rgba(54,173,185,0.12); }
  .row{ display:flex; gap:8px; margin-top:10px; }
  .small{ padding:6px 8px; font-size:13px; background:var(--glass); color:var(--muted); border-radius:8px; border:1px solid rgba(255,255,255,0.02); cursor:pointer; }
  canvas{ width:100%; height:520px; border-radius:10px; display:block; background:linear-gradient(180deg, rgba(0,0,0,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); }
  .controls{ display:flex; gap:8px; align-items:center; margin-top:10px; flex-wrap:wrap; }
  .log{ height:180px; overflow:auto; background:rgba(0,0,0,0.15); border-radius:8px; padding:8px; font-family:monospace; font-size:13px; color:var(--muted); margin-top:10px; }
  .stack{ height:calc(100vh - 200px); overflow:auto; background:rgba(0,0,0,0.06); border-radius:8px; padding:10px; font-family:monospace; font-size:13px; color:var(--muted); }
  .frame{ padding:8px; border-radius:8px; background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02)); margin-bottom:8px; border:1px solid rgba(255,255,255,0.02); }
  .frame.top{ box-shadow: 0 8px 24px rgba(2,6,23,0.6); border-color: rgba(255,255,255,0.04); }
  .badge{ display:inline-block; padding:3px 6px; border-radius:6px; font-size:12px; color:#042027; background:var(--accent2); margin-left:8px; }
  .muted{ color:var(--muted); font-size:13px; }
  pre.code{ background:rgba(0,0,0,0.18); border-radius:8px; padding:10px; font-size:12px; color:#dff; overflow:auto; max-height:200px; }
  .hint{ font-size:13px; color:var(--muted); margin-top:8px; }
  .speed{ width:100px; }
  .footer{ margin-top:12px; color:var(--muted); font-size:13px; }
  .warn{ color:#ffd08a; font-weight:700; }
  a{ color:var(--accent); text-decoration:none; }
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h2>Recursion Explorer</h2>
    <div class="muted">Experiment with recursive functions. Generate an event trace and visualize how the call stack grows and shrinks as recursive calls enter and return.</div>

    <label>Example</label>
    <select id="example">
      <option value="factorial">Factorial (classic)</option>
      <option value="fib_naive">Fibonacci — naive (exponential)</option>
      <option value="fib_memo">Fibonacci — memoized (dynamic programming)</option>
      <option value="fractal_tree">Fractal Tree (graphical recursion)</option>
    </select>

    <label id="paramLabel">n</label>
    <input id="param" type="number" min="0" max="12" value="6" />

    <div class="row">
      <button id="generate">Generate Trace</button>
      <button id="reset" class="small">Reset</button>
      <div style="flex:1"></div>
    </div>

    <div class="controls">
      <button id="play">Play ▶</button>
      <button id="pause" class="small">Pause ❙❙</button>
      <button id="step" class="small">Step ⏭</button>
      <label class="muted" style="margin-left:6px;">Speed</label>
      <input type="range" id="speed" class="speed" min="50" max="1200" step="50" value="300">
      <div class="muted" id="speedVal">300 ms / step</div>
    </div>

    <div class="hint">Notes: For naive Fibonacci keep n small (≤8). For fractal tree, depth becomes exponential in draw operations; keep depth ≤10 for responsiveness.</div>

    <div class="footer">
      <div style="margin-top:10px;"><strong>How it works:</strong> When the instrumented recursive function runs it records "events" (call/return/draw). The player replays those events so you can inspect the call stack and returned values step-by-step.</div>
    </div>
  </div>

  <div class="panel" style="display:flex; flex-direction:column;">
    <h2>Visualization Canvas</h2>
    <canvas id="canvas" width="900" height="520"></canvas>

    <div style="display:flex; gap:10px; margin-top:10px;">
      <div style="flex:1">
        <div class="muted">Trace Log</div>
        <div id="log" class="log"></div>
      </div>
      <div style="width:260px;">
        <div class="muted">Function / Code (simplified)</div>
        <pre id="code" class="code"></pre>
      </div>
    </div>
  </div>

  <div class="panel">
    <h2>Call Stack</h2>
    <div id="stack" class="stack"></div>
    <div style="margin-top:10px;">
      <div class="muted">Final result</div>
      <div id="result" class="muted" style="margin-top:6px;">—</div>
    </div>
  </div>
</div>

<script>
/*
  Recursion Explorer
  - Generates event traces for several recursive examples:
    * factorial (straightforward)
    * fibonacci (naive exponential)
    * fibonacci with memoization
    * fractal tree (graphical)
  - Replays events allowing step-by-step inspection of call stack and returned values.
*/

(function(){
  // DOM
  const exampleEl = document.getElementById('example');
  const paramEl = document.getElementById('param');
  const paramLabel = document.getElementById('paramLabel');
  const generateBtn = document.getElementById('generate');
  const resetBtn = document.getElementById('reset');
  const playBtn = document.getElementById('play');
  const pauseBtn = document.getElementById('pause');
  const stepBtn = document.getElementById('step');
  const speedEl = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const logEl = document.getElementById('log');
  const stackEl = document.getElementById('stack');
  const codeEl = document.getElementById('code');
  const resultEl = document.getElementById('result');

  let events = [];      // recorded events
  let playIdx = 0;
  let stack = [];
  let playing = false;
  let timer = null;
  let stepDelay = parseInt(speedEl.value,10);
  let idCounter = 1;

  function setCode(text){
    codeEl.textContent = text;
  }

  function clearCanvas(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // subtle gradient backdrop
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0,'rgba(255,255,255,0.01)');
    g.addColorStop(1,'rgba(255,255,255,0.02)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function log(msg){
    const pre = document.createElement('div');
    pre.textContent = msg;
    logEl.appendChild(pre);
    logEl.scrollTop = logEl.scrollHeight;
  }

  function renderStack(){
    stackEl.innerHTML = '';
    for(let i = stack.length-1; i>=0; i--){
      const f = stack[i];
      const el = document.createElement('div');
      el.className = 'frame' + (i === stack.length-1 ? ' top' : '');
      el.innerHTML = `<div><strong>${f.name}</strong>(${f.args.map(a=>JSON.stringify(a)).join(', ')}) ${f.id ? ('<span class="muted">#'+f.id+'</span>') : ''}</div>
                      <div class="muted">locals: ${f.locals ? JSON.stringify(f.locals) : '{}'}</div>`;
      stackEl.appendChild(el);
    }
  }

  function pushFrame(ev){
    const frame = { id: ev.id, name: ev.name, args: ev.args.slice(), locals: ev.locals || {} };
    stack.push(frame);
    renderStack();
    log(`CALL ${ev.name}(${ev.args.join(',')})  -> pushed frame #${ev.id}`);
  }

  function popFrame(ev){
    // ideally the top frame matches id (LIFO)
    const top = stack.pop();
    if(!top){
      log(`RETURN ${ev.name} -> (no frame) value=${ev.value}`);
    } else {
      if(top.id !== ev.id){
        // unexpected but handle gracefully: try to find and remove
        const idx = stack.findIndex(f=>f.id===ev.id);
        if(idx>=0){
          stack.splice(idx,1);
          log(`RETURN ${ev.name} (found non-top frame #${ev.id}) value=${ev.value}`);
        } else {
          log(`RETURN ${ev.name} (frame not found) value=${ev.value}`);
        }
      } else {
        log(`RETURN ${ev.name} -> value=${JSON.stringify(ev.value)} (popped #${ev.id})`);
      }
    }
    renderStack();
  }

  function drawSegment(s){
    ctx.beginPath();
    ctx.moveTo(s.x1, s.y1);
    ctx.lineTo(s.x2, s.y2);
    ctx.strokeStyle = s.color || '#9ee7ff';
    ctx.lineWidth = Math.max(1, s.width || 1);
    ctx.lineCap = 'round';
    ctx.stroke();
  }

  function processEvent(ev){
    // ev: {type:'call'|'return'|'draw'|'memo', ...}
    if(ev.type === 'call'){
      pushFrame(ev);
    } else if(ev.type === 'return'){
      popFrame(ev);
      if(ev.finalResult !== undefined){
        // some generators attach final result metadata
        resultEl.textContent = JSON.stringify(ev.finalResult);
      } else {
        // update result element with latest return value when stack is empty
        if(stack.length === 0){
          resultEl.textContent = JSON.stringify(ev.value);
        }
      }
    } else if(ev.type === 'draw'){
      drawSegment(ev.seg);
      log(`DRAW segment depth=${ev.depth} at id#${ev.id}`);
    } else if(ev.type === 'memo'){
      log(`MEMO HIT for ${ev.name}(${ev.args.join(',')}) => value=${ev.value}`);
    }
  }

  function play(){
    if(playing) return;
    playing = true;
    playBtn.disabled = true;
    stepBtn.disabled = true;
    pauseBtn.disabled = false;
    const runStep = ()=>{
      if(playIdx >= events.length){
        stop();
        return;
      }
      processEvent(events[playIdx++]);
      if(playIdx >= events.length){
        stop();
      } else {
        timer = setTimeout(runStep, stepDelay);
      }
    };
    timer = setTimeout(runStep, 0);
  }

  function stop(){
    playing = false;
    playBtn.disabled = false;
    stepBtn.disabled = false;
    pauseBtn.disabled = true;
    if(timer) { clearTimeout(timer); timer = null; }
    // if finished, ensure displayed result updated
    if(playIdx >= events.length){
      // find last return with value
      for(let i = events.length-1; i>=0; i--){
        if(events[i].type === 'return' && events[i].value !== undefined){
          resultEl.textContent = JSON.stringify(events[i].value);
          break;
        }
      }
    }
  }

  function step(){
    if(playIdx >= events.length){
      stop();
      return;
    }
    processEvent(events[playIdx++]);
    if(playIdx >= events.length){
      stop();
    }
  }

  // event generators for examples
  function makeId(){ return idCounter++; }

  function genFactorial(n){
    events = [];
    idCounter = 1;
    function rec(k){
      const id = makeId();
      events.push({type:'call', id, name:'fact', args:[k]});
      if(k <= 1){
        events.push({type:'return', id, name:'fact', args:[k], value:1});
        return 1;
      } else {
        const v = rec(k-1);
        const result = k * v;
        events.push({type:'return', id, name:'fact', args:[k], value:result});
        return result;
      }
    }
    const res = rec(n);
    // mark last return as finalResult for UI convenience
    if(events.length){
      events[events.length-1].finalResult = res;
    }
    return events;
  }

  function genFibNaive(n){
    events = [];
    idCounter = 1;
    function rec(k){
      const id = makeId();
      events.push({type:'call', id, name:'fib', args:[k]});
      if(k <= 1){
        events.push({type:'return', id, name:'fib', args:[k], value:k});
        return k;
      } else {
        const a = rec(k-1);
        const b = rec(k-2);
        const res = a + b;
        events.push({type:'return', id, name:'fib', args:[k], value:res});
        return res;
      }
    }
    const res = rec(n);
    if(events.length) events[events.length-1].finalResult = res;
    return events;
  }

  function genFibMemo(n){
    events = [];
    idCounter = 1;
    const memo = new Map();
    function rec(k){
      const id = makeId();
      events.push({type:'call', id, name:'fibMemo', args:[k]});
      if(memo.has(k)){
        const v = memo.get(k);
        events.push({type:'memo', id, name:'fibMemo', args:[k], value:v});
        events.push({type:'return', id, name:'fibMemo', args:[k], value:v});
        return v;
      }
      if(k <= 1){
        memo.set(k,k);
        events.push({type:'return', id, name:'fibMemo', args:[k], value:k});
        return k;
      } else {
        const a = rec(k-1);
        const b = rec(k-2);
        const res = a + b;
        memo.set(k,res);
        events.push({type:'return', id, name:'fibMemo', args:[k], value:res});
        return res;
      }
    }
    const res = rec(n);
    if(events.length) events[events.length-1].finalResult = res;
    return events;
  }

  function genFractalTree(depth){
    events = [];
    idCounter = 1;
    // parameters to control shape
    const startX = canvas.width/2;
    const startY = canvas.height - 20;
    const initialLength = Math.min(canvas.height, canvas.width) * 0.18;
    const branchAngle = Math.PI/6; // 30deg
    const scale = 0.72;

    function rec(d, x, y, angle, length){
      const id = makeId();
      events.push({type:'call', id, name:'branch', args:[d], depth:d});
      // compute endpoint
      const x2 = x + Math.cos(angle) * length;
      const y2 = y - Math.sin(angle) * length;
      const width = Math.max(1, d/2 + 1);
      const color = d < 2 ? '#d8ffd6' : (d < 5 ? '#9ee7ff' : '#7fb5ff');
      events.push({type:'draw', id, name:'branch', depth:d, seg:{x1:x,y1:y,x2:x2,y2:y2,color:color,width:width}});
      if(d > 0){
        rec(d-1, x2, y2, angle - branchAngle, length * scale);
        rec(d-1, x2, y2, angle + branchAngle, length * scale);
      }
      events.push({type:'return', id, name:'branch', args:[d], value:null});
    }

    rec(depth, startX, startY, Math.PI/2, initialLength);
    return events;
  }

  // UI wiring
  function updateParamLabel(){
    const ex = exampleEl.value;
    if(ex === 'fractal_tree'){
      paramLabel.textContent = 'depth';
      paramEl.min = 0;
      paramEl.max = 12;
      paramEl.value = Math.min(8, Math.max(0, parseInt(paramEl.value||5)));
    } else {
      paramLabel.textContent = 'n';
      paramEl.min = 0;
      paramEl.max = (ex === 'fib_naive') ? 12 : 24;
      if(ex === 'fib_naive' && paramEl.value > 12) paramEl.value = 12;
    }
    // update code snippet
    if(ex === 'factorial'){
      setCode(`function fact(n) {\n  if (n <= 1) return 1;\n  return n * fact(n-1);\n}`);
    } else if(ex === 'fib_naive'){
      setCode(`function fib(n) {\n  if (n <= 1) return n;\n  return fib(n-1) + fib(n-2);  // two recursive calls\n}`);
    } else if(ex === 'fib_memo'){
      setCode(`function fibMemo(n, memo={}) {\n  if (n in memo) return memo[n];\n  if (n <= 1) return n;\n  memo[n] = fibMemo(n-1,memo) + fibMemo(n-2,memo);\n  return memo[n];\n}`);
    } else if(ex === 'fractal_tree'){
      setCode(`function branch(depth, x, y, angle, length) {\n  drawLine(x,y,x2,y2);\n  if (depth > 0) {\n    branch(depth-1, x2, y2, angle-θ, length*scale);\n    branch(depth-1, x2, y2, angle+θ, length*scale);\n  }\n}`);
    }
  }

  exampleEl.addEventListener('change', ()=>{
    updateParamLabel();
  });

  speedEl.addEventListener('input', ()=>{
    stepDelay = parseInt(speedEl.value,10);
    speedVal.textContent = `${stepDelay} ms / step`;
  });

  resetBtn.addEventListener('click', ()=>{
    events = [];
    playIdx = 0;
    stack = [];
    playing = false;
    if(timer) { clearTimeout(timer); timer = null; }
    clearCanvas();
    logEl.innerHTML = '';
    stackEl.innerHTML = '';
    resultEl.textContent = '—';
    playBtn.disabled = false;
    stepBtn.disabled = false;
    pauseBtn.disabled = true;
    idCounter = 1;
  });

  generateBtn.addEventListener('click', ()=>{
    resetBtn.click();
    const ex = exampleEl.value;
    const n = Math.max(0, Math.floor(Number(paramEl.value) || 0));
    // safety caps
    if(ex === 'fib_naive' && n > 12){
      alert('Naive Fibonacci grows exponentially — choose n ≤ 12.');
      return;
    }
    if(ex === 'fractal_tree' && n > 12){
      alert('High fractal depth may be slow; choose depth ≤ 12.');
      return;
    }

    clearCanvas();
    logEl.innerHTML = '';
    stackEl.innerHTML = '';
    resultEl.textContent = '—';
    idCounter = 1;

    if(ex === 'factorial'){
      events = genFactorial(n);
    } else if(ex === 'fib_naive'){
      events = genFibNaive(n);
    } else if(ex === 'fib_memo'){
      events = genFibMemo(n);
    } else if(ex === 'fractal_tree'){
      events = genFractalTree(n);
    }
    playIdx = 0;
    log(`Generated ${events.length} events for ${ex}(${n}).`);
    // pre-draw background only; actual draw events will render during playback
    clearCanvas();
  });

  playBtn.addEventListener('click', ()=>play());
  pauseBtn.addEventListener('click', ()=>stop());
  stepBtn.addEventListener('click', ()=>step());

  // initialize
  updateParamLabel();
  clearCanvas();
  pauseBtn.disabled = true;
  setCode('// Choose an example and click "Generate Trace" to begin.');

  // helpful demo: auto-generate factorial(6) initially
  setTimeout(()=>{ exampleEl.value = 'factorial'; updateParamLabel(); paramEl.value = 6; generateBtn.click(); }, 400);

})();
</script>
</body>
</html>