<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Counting Sort Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#7dd3fc;
      --muted:#94a3b8;
      --good:#60a5fa;
      --danger:#fb7185;
      --card:#081127;
      --glass: rgba(255,255,255,0.03);
      --glass-2: rgba(255,255,255,0.02);
      --text:#e6eef8;
      --mono: 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--mono);
      background: linear-gradient(180deg,#051025 0%, #071526 55%, #071326 100%);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:20px;
    }
    h1{margin:0 0 10px 0;font-size:20px}
    .app{
      display:grid;
      grid-template-columns: 380px 1fr;
      gap:18px;
      align-items:start;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      padding:14px;
      border-radius:10px;
      box-shadow: 0 6px 24px rgba(2,6,23,0.6), inset 0 1px rgba(255,255,255,0.02);
    }
    .controls h2{font-size:16px;margin:0 0 8px 0}
    label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    .row{display:flex;gap:10px;align-items:center;margin-bottom:8px}
    input[type="number"], input[type="text"], select{
      width:100%;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:var(--glass);
      color:var(--text);
      outline:none;
    }
    button{
      background:linear-gradient(180deg,var(--good),#2b6cb0);
      color:white;
      border:none;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      box-shadow: 0 6px 16px rgba(29,78,216,0.12);
    }
    button.ghost{
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--text);
      box-shadow:none;
    }
    .small{font-size:13px;padding:6px 10px}
    .muted{color:var(--muted);font-size:13px}
    .visual{
      padding:16px;
      min-height:420px;
    }
    .arrays{
      display:flex;
      flex-direction:column;
      gap:18px;
      margin-bottom:12px;
    }
    .array-row{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .array-title{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:13px;
      color:var(--muted);
      margin-bottom:6px;
    }
    .boxes{
      display:flex;
      gap:8px;
      align-items:end;
      padding:6px;
      overflow:auto;
      min-height:72px;
      background:var(--glass-2);
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .cell{
      width:46px;
      min-width:46px;
      height:64px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:8px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      color:var(--text);
      font-weight:700;
      position:relative;
      transition:transform .18s ease, box-shadow .18s ease, background .18s;
      border:1px solid rgba(255,255,255,0.03);
    }
    .cell.small{width:40px;height:56px}
    .cell .val{font-size:16px}
    .cell .idx{font-size:12px;color:var(--muted);position:absolute;bottom:6px}
    .highlight{
      box-shadow:0 8px 28px rgba(125,211,252,0.08);
      transform:translateY(-6px) scale(1.02);
      border-color:rgba(125,211,252,0.18);
      background:linear-gradient(180deg, rgba(125,211,252,0.06), rgba(125,211,252,0.02));
    }
    .placed{
      background:linear-gradient(180deg, rgba(96,165,250,0.08), rgba(96,165,250,0.03));
      border-color:rgba(96,165,250,0.12);
      box-shadow:0 8px 24px rgba(96,165,250,0.06);
      transform:translateY(-4px);
    }
    .muted-cell{opacity:0.4}
    .legend{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}
    .legend .dot{width:12px;height:12px;border-radius:3px}
    .dot.current{background:var(--accent)}
    .dot.placed{background:var(--good)}
    .controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
    .play-controls{display:flex;gap:8px;align-items:center;margin-top:8px}
    .status{font-size:13px;color:var(--muted)}
    .stepper{display:flex;gap:6px}
    .speed{display:flex;gap:8px;align-items:center}
    .info{font-size:13px;color:var(--muted);line-height:1.5}
    .footer{
      margin-top:10px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }
    pre{background:transparent;color:var(--muted);font-size:13px;margin:0}
    .note{font-size:12px;color:var(--muted)}
    /* Responsive */
    @media (max-width:980px){
      .app{grid-template-columns:1fr; padding-bottom:60px}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="card controls">
      <h1>Counting Sort — Visual Playground</h1>
      <div style="margin-bottom:10px" class="muted">Step through Counting Sort (stable) on non‑negative integers. See counts, cumulative counts, and placement into output.</div>

      <div style="margin-top:10px" class="card" id="inputCard">
        <h2>Input & Parameters</h2>
        <label>Array (comma separated) — values must be integers ≥ 0</label>
        <input id="arrInput" type="text" placeholder="e.g. 4,2,2,8,3,3,1" value="4,2,2,8,3,3,1" />
        <div class="row" style="margin-top:8px">
          <div style="flex:1">
            <label>Number of elements (generate)</label>
            <input id="nInput" type="number" min="1" max="40" value="7" />
          </div>
          <div style="width:120px">
            <label>Max value (k)</label>
            <input id="kInput" type="number" min="0" max="100" value="8" />
          </div>
        </div>
        <div class="row" style="margin-top:10px">
          <button id="genRnd">Generate Random</button>
          <button id="useCustom" class="ghost">Use From Text</button>
          <div style="flex:1"></div>
        </div>
        <div style="margin-top:10px">
          <label>Options</label>
          <div style="display:flex;gap:10px;align-items:center">
            <label style="display:flex;gap:8px;align-items:center"><input id="stableToggle" type="checkbox" checked /> Stable (right-to-left placement)</label>
            <label style="display:flex;gap:8px;align-items:center"><input id="copyBack" type="checkbox" checked /> Copy back to original (final step)</label>
          </div>
        </div>
      </div>

      <div style="margin-top:12px" class="card">
        <h2>Controls</h2>
        <div class="controls-grid">
          <div>
            <label>Record Steps</label>
            <button id="recordBtn">Record (prepare steps)</button>
          </div>
          <div>
            <label>Reset</label>
            <button id="resetBtn" class="ghost">Reset View</button>
          </div>
        </div>

        <div class="play-controls">
          <div class="stepper">
            <button id="backBtn" class="small ghost">⟲ Back</button>
            <button id="stepBack" class="small ghost">◀ Step</button>
            <button id="playBtn" class="small">▶ Play</button>
            <button id="stepFwd" class="small ghost">Step ▶</button>
            <button id="fwdBtn" class="small ghost">Forward ⟳</button>
          </div>
          <div style="margin-left:auto" class="speed">
            <span class="muted">Speed</span>
            <input id="speed" type="range" min="100" max="1600" step="50" value="600" />
          </div>
        </div>

        <div style="margin-top:10px;display:flex;justify-content:space-between;align-items:center">
          <div>
            <div class="status" id="status">Status: idle</div>
          </div>
          <div style="text-align:right">
            <div class="muted">Step <span id="curStep">0</span> / <span id="totalSteps">0</span></div>
          </div>
        </div>
      </div>

      <div style="margin-top:12px" class="card">
        <h2>Quick Notes</h2>
        <div class="info">
          - Counting sort is fastest when k (range of values) is not much larger than n (number of elements).<br>
          - Time: O(n + k). Space: O(n + k). Stable by placing from right→left.<br>
          - Only works directly for integers in a small non‑negative range.
        </div>
        <div style="margin-top:10px" class="footer">
          <div class="muted">Algorithm: Counting Sort</div>
          <div class="muted">Complexity: O(n + k)</div>
        </div>
      </div>
    </div>

    <div class="card visual">
      <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:6px">
        <div>
          <div style="font-weight:700">Visualization</div>
          <div class="muted" style="margin-top:6px" id="stepDesc">Prepare by recording steps...</div>
        </div>
        <div class="legend">
          <div style="display:flex;gap:8px;align-items:center">
            <div class="dot current"></div><div class="muted">current / being processed</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <div class="dot placed" style="margin-left:6px"></div><div class="muted">placed</div>
          </div>
        </div>
      </div>

      <div class="arrays">
        <div class="array-row">
          <div class="array-title"><div>Input Array</div><div class="muted">indices below</div></div>
          <div class="boxes" id="inputBoxes" aria-label="Input array"></div>
        </div>

        <div class="array-row">
          <div class="array-title"><div>Counts Array (0..k)</div><div class="muted">counts & cumulative during phase</div></div>
          <div class="boxes" id="countBoxes" aria-label="Counts array"></div>
        </div>

        <div class="array-row">
          <div class="array-title"><div>Output Array</div><div class="muted">built gradually</div></div>
          <div class="boxes" id="outBoxes" aria-label="Output array"></div>
        </div>
      </div>

      <div style="margin-top:8px;display:flex;gap:12px;align-items:center;justify-content:space-between">
        <div class="muted">Tip: Click "Record" to compute an animation timeline you can step through.</div>
        <div class="muted">Values highlighted as they change. Final output shows sorted array.</div>
      </div>
    </div>
  </div>

  <script>
  // Counting Sort Visualizer
  (function(){
    // DOM elements
    const arrInput = document.getElementById('arrInput');
    const nInput = document.getElementById('nInput');
    const kInput = document.getElementById('kInput');
    const genBtn = document.getElementById('genRnd');
    const useCustom = document.getElementById('useCustom');
    const recordBtn = document.getElementById('recordBtn');
    const resetBtn = document.getElementById('resetBtn');
    const stableToggle = document.getElementById('stableToggle');
    const copyBack = document.getElementById('copyBack');
    const inputBoxes = document.getElementById('inputBoxes');
    const countBoxes = document.getElementById('countBoxes');
    const outBoxes = document.getElementById('outBoxes');
    const status = document.getElementById('status');
    const stepDesc = document.getElementById('stepDesc');
    const curStepLabel = document.getElementById('curStep');
    const totalStepsLabel = document.getElementById('totalSteps');
    const playBtn = document.getElementById('playBtn');
    const backBtn = document.getElementById('backBtn');
    const fwdBtn = document.getElementById('fwdBtn');
    const stepBack = document.getElementById('stepBack');
    const stepFwd = document.getElementById('stepFwd');
    const speedInput = document.getElementById('speed');

    let arr = [];
    let steps = []; // snapshot steps
    let playTimer = null;
    let currentStep = 0;

    // Helpers
    function parseArrayInput(txt){
      if(!txt.trim()) return [];
      const parts = txt.split(',').map(s => s.trim()).filter(Boolean);
      const vals = [];
      for(const p of parts){
        const n = Number(p);
        if(!Number.isInteger(n)) return {error:'All values must be integers.'};
        if(n < 0) return {error:'Values must be non-negative.'};
        vals.push(n);
      }
      return {vals};
    }

    function clamp(v, a,b){ return Math.max(a, Math.min(b, v)); }

    function genRandomArray(n,k){
      const out = [];
      for(let i=0;i<n;i++){
        out.push(Math.floor(Math.random()*(k+1)));
      }
      return out;
    }

    function setStatus(txt){
      status.textContent = 'Status: ' + txt;
    }

    function renderSnapshot(step){
      if(!step) return;
      const s = step;
      // Input
      renderBoxes(inputBoxes, s.arr, {
        highlightIndex: s.currentIndex,
        highlightLabel: s.phase === 'count' ? 'counting' : (s.phase === 'place' ? 'placing' : 'current'),
        highlightValue: s.currentValue,
        placedIndices: s.placedInputIndices || [],
        muted: s.phase === 'place' ? s.mutedInputIndices || [] : []
      });

      // Counts
      renderBoxes(countBoxes, s.counts, {
        small:true,
        highlightIndex: s.countIndex,
        highlightLabel: s.countLabel,
        placedIndices: s.countsPlaced || [],
        muted: s.phase === 'init' ? [] : []
      });

      // Output
      renderBoxes(outBoxes, s.out, {
        small:false,
        highlightIndex: s.outputIndex,
        placedIndices: s.placedOutputIndices || [],
        muted: s.mutedOutputIndices || []
      });

      // Step info
      stepDesc.innerHTML = s.desc || '';
      curStepLabel.textContent = currentStep;
      totalStepsLabel.textContent = steps.length-1;
    }

    function renderBoxes(container, arrayVals, opts = {}){
      container.innerHTML = '';
      const small = !!opts.small;
      const highlightIndex = typeof opts.highlightIndex === 'number' ? opts.highlightIndex : null;
      const placed = new Set((opts.placedIndices || []).map(i=>i));
      const muted = new Set((opts.muted || []).map(i=>i));
      arrayVals.forEach((v,i)=>{
        const div = document.createElement('div');
        div.className = 'cell' + (small? ' small':'');
        if(i === highlightIndex) div.classList.add('highlight');
        if(placed.has(i)) div.classList.add('placed');
        if(muted.has(i)) div.classList.add('muted-cell');
        const val = document.createElement('div');
        val.className = 'val';
        val.textContent = (v===null || typeof v === 'undefined') ? '' : v;
        const idx = document.createElement('div');
        idx.className = 'idx';
        idx.textContent = i;
        div.appendChild(val);
        div.appendChild(idx);
        container.appendChild(div);
      });
    }

    // Build snapshots (steps) for counting sort
    function recordCountingSort(initialArr, k, options){
      // options: stable(bool), copyBack(bool)
      const snapshots = [];
      const n = initialArr.length;
      const arrCopy = initialArr.slice();
      const counts = new Array(k+1).fill(0);
      const out = new Array(n).fill(null);

      // helper to push snapshot
      function push(desc, phase, extras = {}){
        snapshots.push({
          desc,
          phase,
          arr: arrCopy.slice(),
          counts: counts.slice(),
          out: out.slice(),
          currentIndex: typeof extras.currentIndex === 'number' ? extras.currentIndex : null,
          currentValue: typeof extras.currentValue === 'number' ? extras.currentValue : null,
          countIndex: typeof extras.countIndex === 'number' ? extras.countIndex : null,
          outputIndex: typeof extras.outputIndex === 'number' ? extras.outputIndex : null,
          placedOutputIndices: extras.placedOutputIndices ? extras.placedOutputIndices.slice() : [],
          placedInputIndices: extras.placedInputIndices ? extras.placedInputIndices.slice() : [],
          countsPlaced: extras.countsPlaced ? extras.countsPlaced.slice() : [],
          mutedInputIndices: extras.mutedInputIndices ? extras.mutedInputIndices.slice() : [],
          mutedOutputIndices: extras.mutedOutputIndices ? extras.mutedOutputIndices.slice() : [],
          countLabel: extras.countLabel || null
        });
      }

      // Initial snapshot
      push('Initial arrays. Counts initialized to 0.', 'init');

      // Counting occurrences
      for(let i=0;i<n;i++){
        const v = arrCopy[i];
        counts[v]++;
        push(`Counting: read arr[${i}] = ${v} → increment counts[${v}] (now ${counts[v]})`, 'count', {
          currentIndex:i,
          currentValue:v,
          countIndex:v,
          countsPlaced: [v]
        });
      }

      // Cumulative (prefix sums)
      push('Counts complete. Now compute cumulative counts (prefix sums).', 'cumulative');
      for(let i=1;i<=k;i++){
        counts[i] += counts[i-1];
        push(`Cumulative: counts[${i}] += counts[${i-1}] → ${counts[i]}`, 'cumulative', {
          countIndex: i,
          countLabel: `counts[${i}] = ${counts[i]}`
        });
      }

      // Build output: stable placement: if stable, iterate from right to left; else left to right (not stable)
      push('Begin building output array.', 'place');
      if(options.stable){
        const placedOutput = [];
        for(let i=n-1;i>=0;i--){
          const v = arrCopy[i];
          counts[v]--;
          const pos = counts[v];
          out[pos] = v;
          placedOutput.push(pos);
          push(`Place: arr[${i}] = ${v} → decrement counts[${v}] -> ${counts[v]}, place at out[${pos}]`, 'place', {
            currentIndex:i,
            currentValue:v,
            countIndex:v,
            outputIndex:pos,
            placedOutputIndices: placedOutput.slice(),
            mutedInputIndices: (new Array(n)).fill(null).map((_,j)=> j< i ? j : null).filter(x=>x!==null)
          });
        }
      } else {
        // not stable: left-to-right placement using counts as next index
        const placedOutput = [];
        for(let i=0;i<n;i++){
          const v = arrCopy[i];
          const pos = counts[v] - 1 - (counts[v]-counts[v]); // this is messy; simpler: we can use a pointer array
          // simpler approach: build pointers from cumulative: we'll convert counts to starting positions
          // For non-stable, we can compute starts
        }
        // For clarity, implement non-stable as placing left-to-right using an auxiliary pointers array.
        // Recompute counts from scratch to get frequencies
        const freq = new Array(k+1).fill(0);
        for(let j=0;j<n;j++) freq[arrCopy[j]]++;
        const ptr = new Array(k+1).fill(0);
        let acc = 0;
        for(let j=0;j<=k;j++){ ptr[j] = acc; acc += freq[j]; }
        push('Non-stable placement will place left→right using start pointers.', 'place');
        const placedOutput = [];
        for(let i=0;i<n;i++){
          const v = arrCopy[i];
          const pos = ptr[v];
          out[pos] = v;
          ptr[v]++;
          placedOutput.push(pos);
          push(`Place (non-stable): arr[${i}] = ${v} → write at out[${pos}]`, 'place', {
            currentIndex:i,
            currentValue:v,
            outputIndex:pos,
            placedOutputIndices: placedOutput.slice()
          });
        }
      }

      // Optionally copy back to original array
      if(options.copyBack){
        push('Copying output back to input array (final sorted result).', 'final-copy', {
          placedInputIndices: (new Array(n)).fill(0).map((_,i)=>i)
        });
        // copy
        for(let i=0;i<n;i++) arrCopy[i] = out[i];
        push('Final: input array replaced by sorted output.', 'done');
      } else {
        push('Final: sorted array is in the output array (input unchanged).', 'done');
      }

      // Prepend a dummy zero index so steps start from 0 for convenience
      // We'll keep snapshots as-is and set currentStep pointer starting at 0 as first snapshot index 0
      return snapshots;
    }

    // UI event handlers
    genBtn.addEventListener('click', ()=>{
      const n = clamp(parseInt(nInput.value) || 0, 1, 40);
      const k = clamp(parseInt(kInput.value) || 0, 0, 100);
      arr = genRandomArray(n,k);
      arrInput.value = arr.join(',');
      setStatus('Random array generated.');
    });

    useCustom.addEventListener('click', ()=>{
      const parsed = parseArrayInput(arrInput.value);
      if(parsed.error){
        alert(parsed.error);
        return;
      }
      arr = parsed.vals.slice();
      nInput.value = arr.length;
      const maxv = arr.length ? Math.max(...arr) : 0;
      kInput.value = Math.max(parseInt(kInput.value||0), maxv);
      setStatus('Using custom array from text.');
    });

    recordBtn.addEventListener('click', ()=>{
      // create arr from text if needed
      const parsed = parseArrayInput(arrInput.value);
      if(parsed.error){
        alert(parsed.error);
        return;
      }
      arr = parsed.vals.slice();
      const k = clamp(parseInt(kInput.value) || 0, 0, 500);
      if(arr.some(v => v > k)){
        if(!confirm(`Some values are greater than k=${k}. Increase k automatically to ${Math.max(...arr)}?`)){
          return;
        } else {
          kInput.value = Math.max(...arr);
        }
      }
      const options = { stable: !!stableToggle.checked, copyBack: !!copyBack.checked };
      setStatus('Recording steps...');
      steps = recordCountingSort(arr, parseInt(kInput.value), options);
      // Add a small sentinel step 0 that shows initial (already there)
      currentStep = 0;
      totalStepsLabel.textContent = Math.max(0, steps.length-1);
      curStepLabel.textContent = currentStep;
      setStatus('Steps recorded. Ready.');
      renderSnapshot(steps[currentStep]);
    });

    // Step controls
    function goToStep(i){
      if(!steps || steps.length === 0) return;
      i = clamp(i, 0, steps.length-1);
      currentStep = i;
      renderSnapshot(steps[currentStep]);
    }

    stepFwd.addEventListener('click', ()=>{
      goToStep(currentStep+1);
    });
    stepBack.addEventListener('click', ()=>{
      goToStep(currentStep-1);
    });
    backBtn.addEventListener('click', ()=>{
      goToStep(0);
    });
    fwdBtn.addEventListener('click', ()=>{
      goToStep(steps.length-1);
    });

    playBtn.addEventListener('click', ()=>{
      if(!steps || steps.length === 0) return;
      if(playTimer){
        // stop
        clearInterval(playTimer); playTimer = null;
        playBtn.textContent = '▶ Play';
        setStatus('Paused.');
      } else {
        playBtn.textContent = '❚❚ Pause';
        setStatus('Playing...');
        const speed = parseInt(speedInput.value);
        playTimer = setInterval(()=>{
          if(currentStep < steps.length-1){
            currentStep++;
            renderSnapshot(steps[currentStep]);
          } else {
            clearInterval(playTimer); playTimer = null;
            playBtn.textContent = '▶ Play';
            setStatus('Finished.');
          }
        }, speed);
      }
    });

    speedInput.addEventListener('input', ()=>{
      if(playTimer){
        clearInterval(playTimer);
        playTimer = null;
        playBtn.textContent = '▶ Play';
        setStatus('Speed changed; playback stopped. Press Play again.');
      }
    });

    resetBtn.addEventListener('click', ()=>{
      steps = [];
      currentStep = 0;
      inputBoxes.innerHTML = '';
      countBoxes.innerHTML = '';
      outBoxes.innerHTML = '';
      curStepLabel.textContent = 0;
      totalStepsLabel.textContent = 0;
      stepDesc.textContent = 'Prepare by recording steps...';
      setStatus('Reset.');
      playBtn.textContent = '▶ Play';
      if(playTimer){ clearInterval(playTimer); playTimer = null; }
    });

    // initial render
    setStatus('Idle. Enter array and press Record.');
    // Preload default parsed array
    (function initDefault(){
      const parsed = parseArrayInput(arrInput.value);
      if(!parsed.error){
        arr = parsed.vals.slice();
        const k = parseInt(kInput.value) || (arr.length?Math.max(...arr):0);
        // render minimal view
        const dummyCounts = new Array(k+1).fill(0);
        const dummyOut = new Array(arr.length).fill(null);
        renderBoxes(inputBoxes, arr);
        renderBoxes(countBoxes, dummyCounts, {small:true});
        renderBoxes(outBoxes, dummyOut);
      }
    })();

  })();
  </script>
</body>
</html>