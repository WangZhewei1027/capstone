{
  "id": "cc1ebec0-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:22:11.590Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Topological Sort Visualizer (Kahn & DFS)</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin:0; display:flex; height:100vh; }\n    #left { width:370px; padding:14px; box-sizing:border-box; border-right:1px solid #e0e0e0; background:#fafafa; overflow:auto;}\n    #canvasWrap { flex:1; display:flex; flex-direction:column; }\n    h2 { margin:6px 0 12px 0; font-size:18px; }\n    label { display:block; margin:8px 0 4px 0; font-size:13px; color:#333; }\n    button, input[type=\"range\"], select { margin-right:8px; }\n    .modeBtn { padding:8px 10px; margin:4px 4px 8px 0; cursor:pointer; border:1px solid #bbb; background:white; border-radius:6px; }\n    .modeBtn.active { background:#e6f4ff; border-color:#7fc1ff; }\n    #svgArea { flex:1; background:linear-gradient(180deg,#fff,#fbfbff); }\n    svg { width:100%; height:100%; display:block; }\n    .panel { background:white; padding:10px; border-radius:8px; box-shadow:0 1px 2px rgba(0,0,0,0.04); margin-bottom:12px; }\n    .small { font-size:13px; color:#555; }\n    .status { margin-top:8px; padding:8px; border-radius:6px; background:#fffbe6; color:#5a4a00; display:inline-block; }\n    .listBox { max-height:120px; overflow:auto; background:#fff; border:1px solid #eee; padding:8px; border-radius:6px; font-family:monospace; font-size:13px; }\n    .infoRow { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }\n    .footer { padding:8px; text-align:right; font-size:12px; color:#666; }\n    .hint { font-size:12px; color:#777; margin-top:6px; }\n    .smallBtn { padding:6px 8px; font-size:13px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer; }\n  </style>\n</head>\n<body>\n  <div id=\"left\">\n    <h2>Topological Sort Visualizer</h2>\n\n    <div class=\"panel\">\n      <div class=\"small\">Graph editing</div>\n      <div style=\"margin-top:8px;\">\n        <button id=\"addNodeBtn\" class=\"modeBtn\">Add Node</button>\n        <button id=\"addEdgeBtn\" class=\"modeBtn\">Add Edge</button>\n        <button id=\"removeNodeBtn\" class=\"modeBtn\">Delete Node</button>\n        <button id=\"removeEdgeBtn\" class=\"modeBtn\">Delete Edge</button>\n      </div>\n      <div class=\"hint\">Click on the canvas to add nodes. In \"Add Edge\" click source then target. Use Delete modes to remove.</div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"small\">Random DAG</div>\n      <div style=\"margin-top:8px;\">\n        <label>Nodes: <input id=\"rndNodes\" type=\"number\" min=\"1\" max=\"20\" value=\"8\" style=\"width:70px\"></label>\n        <label>Edge density: <input id=\"rndDensity\" type=\"range\" min=\"0\" max=\"1\" step=\"0.05\" value=\"0.25\" style=\"width:150px; vertical-align:middle\"></label>\n        <span id=\"densityLabel\" style=\"font-size:13px; color:#444;\">25%</span>\n      </div>\n      <div style=\"margin-top:8px;\">\n        <button id=\"randomDagBtn\" class=\"smallBtn\">Generate Random DAG</button>\n        <button id=\"clearBtn\" class=\"smallBtn\">Clear All</button>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"small\">Kahn's Algorithm (BFS)</div>\n      <div style=\"margin-top:8px;\" class=\"infoRow\">\n        <button id=\"kahnStartBtn\" class=\"smallBtn\">Initialize</button>\n        <button id=\"kahnStepBtn\" class=\"smallBtn\" disabled>Step</button>\n        <button id=\"kahnAutoBtn\" class=\"smallBtn\" disabled>Auto</button>\n        <button id=\"kahnFinishBtn\" class=\"smallBtn\" disabled>Finish</button>\n        <button id=\"kahnResetBtn\" class=\"smallBtn\">Reset</button>\n      </div>\n      <div style=\"margin-top:8px;\">\n        <label>Speed: <input id=\"speedKahn\" type=\"range\" min=\"100\" max=\"1500\" step=\"100\" value=\"600\"></label>\n      </div>\n      <div style=\"margin-top:8px;\">\n        <div class=\"small\">Queue: <span id=\"kahnQueue\" class=\"listBox\" style=\"display:inline-block; width:100%;\"></span></div>\n        <div class=\"small\" style=\"margin-top:6px;\">Output order: <div id=\"kahnOutput\" class=\"listBox\" style=\"margin-top:6px;\"></div></div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"small\">DFS-based Topological Sort</div>\n      <div style=\"margin-top:8px;\" class=\"infoRow\">\n        <button id=\"dfsStartBtn\" class=\"smallBtn\">Start</button>\n        <button id=\"dfsAutoBtn\" class=\"smallBtn\" disabled>Auto</button>\n        <button id=\"dfsFinishBtn\" class=\"smallBtn\" disabled>Finish</button>\n        <button id=\"dfsResetBtn\" class=\"smallBtn\">Reset</button>\n      </div>\n      <div style=\"margin-top:8px;\">\n        <label>Speed: <input id=\"speedDfs\" type=\"range\" min=\"100\" max=\"1500\" step=\"100\" value=\"700\"></label>\n      </div>\n      <div style=\"margin-top:8px;\">\n        <div class=\"small\">Visited order (finish times): <div id=\"dfsOutput\" class=\"listBox\" style=\"margin-top:6px;\"></div></div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"small\">Graph Info</div>\n      <div style=\"margin-top:8px;\">\n        <div class=\"small\">Adjacency:</div>\n        <pre id=\"adjPre\" class=\"listBox\" style=\"white-space:pre-wrap;\"></pre>\n        <div class=\"small\" style=\"margin-top:6px;\">Indegrees:</div>\n        <pre id=\"indegPre\" class=\"listBox\" style=\"white-space:pre-wrap;\"></pre>\n      </div>\n    </div>\n\n    <div class=\"footer\">Tips: Use random DAG to quickly test. Visual cues: green = ready (in queue), blue = processed, orange = DFS visiting, red = cycle.</div>\n  </div>\n\n  <div id=\"canvasWrap\">\n    <div id=\"svgArea\">\n      <svg id=\"svg\" viewBox=\"0 0 1000 700\" preserveAspectRatio=\"xMidYMid meet\">\n        <defs>\n          <marker id=\"arrow\" viewBox=\"0 0 10 10\" refX=\"9\" refY=\"5\" markerWidth=\"7\" markerHeight=\"7\" orient=\"auto-start-reverse\">\n            <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#333\"></path>\n          </marker>\n          <marker id=\"arrowRed\" viewBox=\"0 0 10 10\" refX=\"9\" refY=\"5\" markerWidth=\"7\" markerHeight=\"7\" orient=\"auto-start-reverse\">\n            <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#c33\"></path>\n          </marker>\n        </defs>\n        <!-- edges and nodes inserted here -->\n      </svg>\n    </div>\n  </div>\n\n<script>\n(function(){\n  // Basic structures\n  let nodes = []; // {id, x, y}\n  let edges = []; // {from, to}\n  let nextNodeId = 0;\n\n  const svg = document.getElementById('svg');\n  const NS = \"http://www.w3.org/2000/svg\";\n  const R = 20; // node radius\n\n  // UI elements\n  const addNodeBtn = document.getElementById('addNodeBtn');\n  const addEdgeBtn = document.getElementById('addEdgeBtn');\n  const removeNodeBtn = document.getElementById('removeNodeBtn');\n  const removeEdgeBtn = document.getElementById('removeEdgeBtn');\n  const randomDagBtn = document.getElementById('randomDagBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const rndNodes = document.getElementById('rndNodes');\n  const rndDensity = document.getElementById('rndDensity');\n  const densityLabel = document.getElementById('densityLabel');\n\n  const kahnStartBtn = document.getElementById('kahnStartBtn');\n  const kahnStepBtn = document.getElementById('kahnStepBtn');\n  const kahnAutoBtn = document.getElementById('kahnAutoBtn');\n  const kahnFinishBtn = document.getElementById('kahnFinishBtn');\n  const kahnResetBtn = document.getElementById('kahnResetBtn');\n  const speedKahn = document.getElementById('speedKahn');\n  const kahnQueue = document.getElementById('kahnQueue');\n  const kahnOutput = document.getElementById('kahnOutput');\n\n  const dfsStartBtn = document.getElementById('dfsStartBtn');\n  const dfsAutoBtn = document.getElementById('dfsAutoBtn');\n  const dfsFinishBtn = document.getElementById('dfsFinishBtn');\n  const dfsResetBtn = document.getElementById('dfsResetBtn');\n  const speedDfs = document.getElementById('speedDfs');\n  const dfsOutput = document.getElementById('dfsOutput');\n\n  const adjPre = document.getElementById('adjPre');\n  const indegPre = document.getElementById('indegPre');\n\n  // Modes: 'addNode', 'addEdge', 'removeNode', 'removeEdge', null\n  let mode = null;\n  let selectedNodeForEdge = null;\n  let selectedNodeForDelete = null;\n\n  // SVG elements containers\n  const edgeLayer = document.createElementNS(NS, 'g');\n  const nodeLayer = document.createElementNS(NS, 'g');\n  svg.appendChild(edgeLayer);\n  svg.appendChild(nodeLayer);\n\n  // Kahn algorithm state\n  let kahnState = null; // {indeg, queue, output, active, timer}\n  // DFS state\n  let dfsState = null; // {color, output, timer, active, stackSim?}\n\n  // Utility: compute adjacency and indegree\n  function buildAdjacency() {\n    const adj = {};\n    nodes.forEach(n => adj[n.id] = []);\n    edges.forEach(e => {\n      if(adj[e.from]) adj[e.from].push(e.to);\n    });\n    const indeg = {};\n    nodes.forEach(n => indeg[n.id] = 0);\n    edges.forEach(e => {\n      indeg[e.to] = (indeg[e.to] || 0) + 1;\n    });\n    return {adj, indeg};\n  }\n\n  function updateInfoPanels() {\n    const {adj, indeg} = buildAdjacency();\n    let s = '';\n    Object.keys(adj).sort((a,b)=>+a-+b).forEach(k=>{\n      s += k + ' -> [' + adj[k].join(', ') + ']\\n';\n    });\n    adjPre.textContent = s || '(empty)';\n    let t = '';\n    Object.keys(indeg).sort((a,b)=>+a-+b).forEach(k=>{\n      t += k + ': ' + indeg[k] + '\\n';\n    });\n    indegPre.textContent = t || '(empty)';\n  }\n\n  // Drawing\n  function clearSvg() {\n    while(edgeLayer.firstChild) edgeLayer.removeChild(edgeLayer.firstChild);\n    while(nodeLayer.firstChild) nodeLayer.removeChild(nodeLayer.firstChild);\n  }\n\n  function drawGraph(highlight = {}) {\n    // highlight can have keys: queueSet, processedSet, visitingSet, cycleSet, edgeRemovedSet\n    clearSvg();\n    const {adj} = buildAdjacency();\n    // draw edges first\n    edges.forEach((e, idx) => {\n      const from = nodes.find(n => n.id === e.from);\n      const to = nodes.find(n => n.id === e.to);\n      if(!from || !to) return;\n      const g = document.createElementNS(NS,'g');\n      g.setAttribute('data-edge-index', idx);\n      let stroke = '#666';\n      let marker = 'arrow';\n      if(highlight.cycleEdges && highlight.cycleEdges.has(idx)) { stroke = '#c33'; marker = 'arrowRed'; }\n      else if(highlight.edgeRemovedSet && highlight.edgeRemovedSet.has(idx)) { stroke = '#bbb'; }\n      const path = document.createElementNS(NS,'path');\n      path.setAttribute('fill','none');\n      path.setAttribute('stroke', stroke);\n      path.setAttribute('stroke-width','2');\n      path.setAttribute('marker-end', 'url(#' + marker + ')');\n      const dx = to.x - from.x;\n      const dy = to.y - from.y;\n      const dist = Math.sqrt(dx*dx + dy*dy);\n      const offset = R;\n      const sx = from.x + (dx/dist) * offset;\n      const sy = from.y + (dy/dist) * offset;\n      const ex = to.x - (dx/dist) * offset;\n      const ey = to.y - (dy/dist) * offset;\n      // simple quadratic curve offset for clarity\n      const mx = (sx+ex)/2 + (-dy/dist) * 30; // perpendicular offset\n      const my = (sy+ey)/2 + (dx/dist) * 30;\n      const d = `M ${sx} ${sy} Q ${mx} ${my} ${ex} ${ey}`;\n      path.setAttribute('d', d);\n      path.style.cursor = 'pointer';\n      // allow clicking to delete edge in removeEdge mode\n      path.addEventListener('click', (ev) => {\n        ev.stopPropagation();\n        if(mode === 'removeEdge') {\n          // select this edge to delete\n          edges.splice(idx,1);\n          drawGraph();\n          updateInfoPanels();\n        }\n      });\n      g.appendChild(path);\n      edgeLayer.appendChild(g);\n    });\n\n    // draw nodes\n    nodes.forEach(n => {\n      const g = document.createElementNS(NS, 'g');\n      g.setAttribute('transform', `translate(${n.x},${n.y})`);\n      g.setAttribute('data-id', n.id);\n      g.style.cursor = 'pointer';\n      const circle = document.createElementNS(NS,'circle');\n      circle.setAttribute('r', R);\n      circle.setAttribute('cx', 0);\n      circle.setAttribute('cy', 0);\n      circle.setAttribute('stroke', '#333');\n      circle.setAttribute('stroke-width', 1.5);\n      circle.setAttribute('fill', '#fff');\n      // coloring\n      if(highlight.queueSet && highlight.queueSet.has(n.id)) {\n        circle.setAttribute('fill', '#e6ffec');\n        circle.setAttribute('stroke','#1b9a60');\n      } else if(highlight.processedSet && highlight.processedSet.has(n.id)) {\n        circle.setAttribute('fill', '#e8f4ff');\n        circle.setAttribute('stroke','#2a75b8');\n      } else if(highlight.visitingSet && highlight.visitingSet.has(n.id)) {\n        circle.setAttribute('fill', '#ffe9c9');\n        circle.setAttribute('stroke','#d37a00');\n      } else if(highlight.cycleSet && highlight.cycleSet.has(n.id)) {\n        circle.setAttribute('fill', '#ffdfe0');\n        circle.setAttribute('stroke','#c33');\n      } else {\n        circle.setAttribute('fill', '#fff');\n        circle.setAttribute('stroke','#333');\n      }\n      // selected node for edge\n      if(selectedNodeForEdge === n.id && (mode === 'addEdge' || mode === 'removeEdge')) {\n        circle.setAttribute('stroke-width', 3);\n        circle.setAttribute('stroke', '#3b82f6');\n      }\n      g.appendChild(circle);\n      const text = document.createElementNS(NS,'text');\n      text.setAttribute('x', 0);\n      text.setAttribute('y', 6);\n      text.setAttribute('text-anchor', 'middle');\n      text.setAttribute('font-size', 13);\n      text.setAttribute('fill', '#111');\n      text.textContent = n.id;\n      g.appendChild(text);\n\n      // Node click behavior\n      g.addEventListener('click', (ev) => {\n        ev.stopPropagation();\n        if(mode === 'addEdge') {\n          if(selectedNodeForEdge == null) {\n            selectedNodeForEdge = n.id;\n            drawGraph(currentHighlights());\n          } else {\n            const src = selectedNodeForEdge;\n            const dst = n.id;\n            selectedNodeForEdge = null;\n            if(src !== dst) {\n              // prevent duplicate edges\n              if(!edges.some(e=>e.from===src && e.to===dst)) {\n                edges.push({from:src, to:dst});\n              }\n            }\n            drawGraph();\n            updateInfoPanels();\n          }\n        } else if(mode === 'removeNode') {\n          // remove node and any incident edges\n          nodes = nodes.filter(x=>x.id !== n.id);\n          edges = edges.filter(e => e.from !== n.id && e.to !== n.id);\n          drawGraph();\n          updateInfoPanels();\n        } else if(mode === 'removeEdge') {\n          // select edge by clicking node? Not needed; edges clickable.\n        } else if(mode === 'addNode') {\n          // do nothing\n        } else {\n          // maybe allow dragging (handled separately)\n        }\n      });\n\n      // dragging\n      let dragging = false;\n      let offset = {x:0,y:0};\n      g.addEventListener('mousedown', (ev) => {\n        ev.stopPropagation();\n        if(mode === 'addNode' || mode === 'addEdge' || mode === 'removeNode' || mode === 'removeEdge') {\n          // not dragging in modes; only in normal mode\n        } else {\n          dragging = true;\n          offset.x = ev.clientX;\n          offset.y = ev.clientY;\n          selectedDragNode = n.id;\n        }\n      });\n      nodeLayer.appendChild(g);\n    });\n  }\n\n  // SVG click to add node when mode addNode\n  svg.addEventListener('click', (ev) => {\n    const pt = svg.createSVGPoint();\n    pt.x = ev.clientX;\n    pt.y = ev.clientY;\n    const ctm = svg.getScreenCTM();\n    const svgP = pt.matrixTransform(ctm.inverse());\n    if(mode === 'addNode') {\n      const id = nextNodeId++;\n      nodes.push({id:id, x: svgP.x, y: svgP.y});\n      drawGraph();\n      updateInfoPanels();\n    } else {\n      // if not adding, clear selected edge node\n      if(selectedNodeForEdge != null) {\n        selectedNodeForEdge = null;\n        drawGraph(currentHighlights());\n      }\n    }\n  });\n\n  // drag handling across whole svg\n  let selectedDragNode = null;\n  function onPointerMove(ev) {\n    if(selectedDragNode != null) {\n      // compute svg coordinates\n      const pt = svg.createSVGPoint();\n      pt.x = ev.clientX;\n      pt.y = ev.clientY;\n      const ctm = svg.getScreenCTM();\n      const svgP = pt.matrixTransform(ctm.inverse());\n      const node = nodes.find(n => n.id === selectedDragNode);\n      if(node) {\n        node.x = svgP.x;\n        node.y = svgP.y;\n        drawGraph(currentHighlights());\n      }\n    }\n  }\n  function onPointerUp(ev) {\n    if(selectedDragNode != null) {\n      selectedDragNode = null;\n      updateInfoPanels();\n    }\n  }\n  window.addEventListener('mousemove', onPointerMove);\n  window.addEventListener('mouseup', onPointerUp);\n\n  // Mode buttons\n  function setMode(m) {\n    mode = m;\n    [addNodeBtn, addEdgeBtn, removeNodeBtn, removeEdgeBtn].forEach(b=>b.classList.remove('active'));\n    if(m === 'addNode') addNodeBtn.classList.add('active');\n    if(m === 'addEdge') addEdgeBtn.classList.add('active');\n    if(m === 'removeNode') removeNodeBtn.classList.add('active');\n    if(m === 'removeEdge') removeEdgeBtn.classList.add('active');\n    selectedNodeForEdge = null;\n    drawGraph(currentHighlights());\n  }\n  addNodeBtn.addEventListener('click', ()=> setMode('addNode'));\n  addEdgeBtn.addEventListener('click', ()=> setMode('addEdge'));\n  removeNodeBtn.addEventListener('click', ()=> setMode('removeNode'));\n  removeEdgeBtn.addEventListener('click', ()=> setMode('removeEdge'));\n  // clicking outside resets mode\n  svg.addEventListener('dblclick', ()=> setMode(null));\n\n  // Random DAG generator\n  rndDensity.addEventListener('input', () => {\n    densityLabel.textContent = Math.round(rndDensity.value * 100) + '%';\n  });\n  randomDagBtn.addEventListener('click', ()=> {\n    const n = Math.max(1, Math.min(20, parseInt(rndNodes.value||8)));\n    nodes = [];\n    edges = [];\n    nextNodeId = 0;\n    // Create nodes with positions (spread)\n    const margin = 60;\n    const W = 900, H = 600;\n    // generate a random topological order\n    const order = [];\n    for(let i=0;i<n;i++) order.push(nextNodeId++);\n    // shuffle order slightly\n    for(let i=order.length-1;i>0;i--){\n      const j = Math.floor(Math.random()*(i+1));\n      [order[i], order[j]] = [order[j], order[i]];\n    }\n    // assign nodes with positions along left->right\n    for(let i=0;i<n;i++){\n      const x = margin + (i/(Math.max(1,n-1))) * (W - 2*margin) + (Math.random()-0.5)*40;\n      const y = margin + Math.random() * (H - 2*margin);\n      nodes.push({id: order[i], x, y});\n    }\n    // Add edges only from earlier in top order to later (to ensure acyclic)\n    const p = parseFloat(rndDensity.value);\n    for(let i=0;i<n;i++){\n      for(let j=i+1;j<n;j++){\n        if(Math.random() < p) {\n          edges.push({from: order[i], to: order[j]});\n        }\n      }\n    }\n    nextNodeId = Math.max(...order)+1;\n    drawGraph();\n    updateInfoPanels();\n    setMode(null);\n  });\n\n  clearBtn.addEventListener('click', ()=> {\n    nodes = [];\n    edges = [];\n    nextNodeId = 0;\n    drawGraph();\n    updateInfoPanels();\n    setMode(null);\n  });\n\n  // Kahn's algorithm implementation (step-by-step)\n  function resetKahn() {\n    if(kahnState && kahnState.timer) clearInterval(kahnState.timer);\n    kahnState = null;\n    kahnQueue.textContent = '';\n    kahnOutput.textContent = '';\n    kahnStepBtn.disabled = true;\n    kahnAutoBtn.disabled = true;\n    kahnFinishBtn.disabled = true;\n    // clear highlights\n    drawGraph({});\n  }\n\n  kahnResetBtn.addEventListener('click', () => {\n    resetKahn();\n  });\n\n  kahnStartBtn.addEventListener('click', () => {\n    if(nodes.length === 0) { alert('Graph is empty'); return; }\n    const {adj, indeg} = buildAdjacency();\n    const q = [];\n    Object.keys(indeg).forEach(k => {\n      if(indeg[k] === 0) q.push(+k);\n    });\n    kahnState = {\n      indeg: Object.assign({}, indeg),\n      queue: q,\n      output: [],\n      active: true,\n      edgeRemovedSet: new Set()\n    };\n    updateKahnUI();\n    kahnStepBtn.disabled = false;\n    kahnAutoBtn.disabled = false;\n    kahnFinishBtn.disabled = false;\n    drawGraph(currentHighlights());\n  });\n\n  function updateKahnUI() {\n    if(!kahnState) return;\n    kahnQueue.textContent = '[' + kahnState.queue.join(', ') + ']';\n    kahnOutput.textContent = kahnState.output.join(' ➜ ') || '(empty)';\n    updateInfoPanels();\n  }\n\n  function currentHighlights() {\n    const h = {};\n    if(kahnState) {\n      h.queueSet = new Set(kahnState.queue);\n      h.processedSet = new Set(kahnState.output);\n      h.edgeRemovedSet = kahnState.edgeRemovedSet;\n    }\n    if(dfsState) {\n      h.visitingSet = new Set(Object.keys(dfsState.color || {}).filter(k=>dfsState.color[k]==='gray').map(x=>+x));\n      // finished nodes in dfsState.output are processed\n      h.processedSet = new Set((h.processedSet ? Array.from(h.processedSet) : []).concat(dfsState.output || []));\n    }\n    return h;\n  }\n\n  kahnStepBtn.addEventListener('click', () => {\n    if(!kahnState) return;\n    stepKahn();\n  });\n\n  kahnAutoBtn.addEventListener('click', () => {\n    if(!kahnState) return;\n    if(kahnState.timer) {\n      clearInterval(kahnState.timer); kahnState.timer = null; kahnAutoBtn.textContent = 'Auto';\n    } else {\n      kahnAutoBtn.textContent = 'Stop';\n      kahnState.timer = setInterval(() => {\n        if(!stepKahn()) {\n          clearInterval(kahnState.timer); kahnState.timer = null; kahnAutoBtn.textContent = 'Auto';\n        }\n      }, parseInt(speedKahn.value));\n    }\n  });\n\n  kahnFinishBtn.addEventListener('click', () => {\n    if(!kahnState) return;\n    while(stepKahn()) { /* run to finish */ }\n  });\n\n  function stepKahn() {\n    if(!kahnState) return false;\n    const {adj} = buildAdjacency();\n    if(kahnState.queue.length === 0) {\n      const remaining = nodes.map(n=>n.id).filter(id => !kahnState.output.includes(id));\n      if(remaining.length === 0) {\n        // finished successfully\n        drawGraph(currentHighlights());\n        kahnQueue.textContent = '[]';\n        kahnOutput.textContent = kahnState.output.join(' ➜ ');\n        alert('Kahn: Topological order found:\\n' + kahnState.output.join(' -> '));\n        kahnStepBtn.disabled = true;\n        kahnAutoBtn.disabled = true;\n        kahnFinishBtn.disabled = true;\n        return false;\n      } else {\n        // cycle detected\n        // highlight nodes with remaining indegree\n        const cycleNodes = new Set(remaining);\n        // find edges connecting cycle nodes to highlight\n        const cycleEdges = new Set();\n        edges.forEach((e, idx) => {\n          if(cycleNodes.has(e.from) && cycleNodes.has(e.to)) cycleEdges.add(idx);\n        });\n        drawGraph({cycleSet: cycleNodes, cycleEdges});\n        kahnQueue.textContent = '[]';\n        kahnOutput.textContent = kahnState.output.join(' ➜ ');\n        alert('Kahn: Cycle detected — no topological ordering exists.');\n        kahnStepBtn.disabled = true;\n        kahnAutoBtn.disabled = true;\n        kahnFinishBtn.disabled = true;\n        return false;\n      }\n    }\n    // pop front\n    const u = kahnState.queue.shift();\n    // mark u as processed\n    kahnState.output.push(u);\n    // remove outgoing edges conceptually: reduce indegrees\n    edges.forEach((e, idx) => {\n      if(e.from === u) {\n        const v = e.to;\n        kahnState.indeg[v]--;\n        // optionally mark this edge as removed (for visuals)\n        kahnState.edgeRemovedSet.add(idx);\n        if(kahnState.indeg[v] === 0) {\n          kahnState.queue.push(v);\n        }\n      }\n    });\n    updateKahnUI();\n    drawGraph(currentHighlights());\n    return true;\n  }\n\n  // DFS-based topo sort with animation\n  function resetDfs() {\n    if(dfsState && dfsState.timer) clearInterval(dfsState.timer);\n    dfsState = null;\n    dfsOutput.textContent = '';\n    dfsAutoBtn.disabled = true;\n    dfsFinishBtn.disabled = true;\n    drawGraph(currentHighlights());\n  }\n  dfsResetBtn.addEventListener('click', resetDfs);\n\n  dfsStartBtn.addEventListener('click', () => {\n    if(nodes.length === 0) { alert('Graph is empty'); return; }\n    const {adj} = buildAdjacency();\n    dfsState = {\n      color: {}, // white/gray/black\n      output: [],\n      stack: [], // manual stack frames for iterative stepping\n      active: true,\n      timer: null,\n      cycleDetected: false,\n      cycleEdges: new Set()\n    };\n    nodes.forEach(n => dfsState.color[n.id] = 'white');\n    // prepare stack by pushing all nodes as start options\n    // We'll perform iterative DFS: for each white node, push frame {v, iterIndex}\n    const todo = nodes.map(n => n.id);\n    // Start first node when stepping\n    dfsAutoBtn.disabled = false;\n    dfsFinishBtn.disabled = false;\n    dfsOutput.textContent = '';\n    drawGraph(currentHighlights());\n  });\n\n  dfsAutoBtn.addEventListener('click', ()=> {\n    if(!dfsState) return;\n    if(dfsState.timer) {\n      clearInterval(dfsState.timer); dfsState.timer = null; dfsAutoBtn.textContent = 'Auto';\n    } else {\n      dfsAutoBtn.textContent = 'Stop';\n      dfsState.timer = setInterval(() => {\n        if(!stepDfs()) {\n          clearInterval(dfsState.timer); dfsState.timer = null; dfsAutoBtn.textContent = 'Auto';\n        }\n      }, parseInt(speedDfs.value));\n    }\n  });\n\n  dfsFinishBtn.addEventListener('click', ()=> {\n    if(!dfsState) return;\n    while(stepDfs()) { /* run to finish */ }\n  });\n\n  function stepDfs() {\n    if(!dfsState) return false;\n    const {adj} = buildAdjacency();\n    // find any white node to start if stack empty\n    if(dfsState.stack.length === 0) {\n      const white = nodes.map(n=>n.id).find(id => dfsState.color[id] === 'white');\n      if(white === undefined) {\n        // finished\n        dfsOutput.textContent = dfsState.output.join(' ← ') || '(empty)';\n        if(dfsState.cycleDetected) {\n          drawGraph({cycleSet: new Set(dfsState.cycleNodes || []), cycleEdges: dfsState.cycleEdges});\n          alert('DFS: Cycle detected.');\n        } else {\n          // Topological order is reverse of finishing times\n          const order = [...dfsState.output].reverse();\n          alert('DFS: Topological order (one possible):\\n' + order.join(' -> '));\n        }\n        dfsAutoBtn.disabled = true;\n        dfsFinishBtn.disabled = true;\n        return false;\n      } else {\n        // push frame to start DFS from this node\n        dfsState.stack.push({v: white, iter: 0});\n      }\n    }\n\n    // simulate recursion with stack frames\n    const frame = dfsState.stack[dfsState.stack.length - 1];\n    const v = frame.v;\n    if(dfsState.color[v] === 'white') {\n      dfsState.color[v] = 'gray'; // discovered\n      drawGraph(currentHighlights());\n      // continue to process neighbors\n      return true;\n    }\n    const neighbors = adj[v] || [];\n    if(frame.iter < neighbors.length) {\n      const to = neighbors[frame.iter++];\n      if(dfsState.color[to] === 'white') {\n        dfsState.stack.push({v: to, iter: 0});\n      } else if(dfsState.color[to] === 'gray') {\n        // back edge -> cycle\n        dfsState.cycleDetected = true;\n        dfsState.cycleNodes = dfsState.stack.map(f=>f.v);\n        // find edges among cycle nodes to highlight\n        edges.forEach((e, idx) => {\n          if(dfsState.cycleNodes.includes(e.from) && dfsState.cycleNodes.includes(e.to)) {\n            dfsState.cycleEdges.add(idx);\n          }\n        });\n        drawGraph({cycleSet: new Set(dfsState.cycleNodes), cycleEdges: dfsState.cycleEdges});\n        dfsOutput.textContent = dfsState.output.join(' ← ');\n        return false;\n      } else {\n        // already black, continue\n      }\n      drawGraph(currentHighlights());\n      return true;\n    } else {\n      // finished all neighbors\n      dfsState.stack.pop();\n      dfsState.color[v] = 'black';\n      dfsState.output.push(v); // append at finish time\n      dfsOutput.textContent = dfsState.output.join(' ← ');\n      drawGraph(currentHighlights());\n      return true;\n    }\n  }\n\n  // Initialize with a small sample graph\n  function initSample() {\n    nodes = [{id:0,x:120,y:100},{id:1,x:240,y:60},{id:2,x:240,y:180},{id:3,x:380,y:60},{id:4,x:380,y:180},{id:5,x:520,y:120}];\n    edges = [{from:0,to:1},{from:0,to:2},{from:1,to:3},{from:2,to:4},{from:3,to:5},{from:4,to:5}];\n    nextNodeId = 6;\n    drawGraph();\n    updateInfoPanels();\n  }\n\n  // kick off\n  initSample();\n\n  // expose some helpful console utilities if needed\n  window._topo = {nodes, edges, drawGraph, buildAdjacency};\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}