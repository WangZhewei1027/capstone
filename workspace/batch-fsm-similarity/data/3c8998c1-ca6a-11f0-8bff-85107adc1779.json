{
  "id": "3c8998c1-ca6a-11f0-8bff-85107adc1779",
  "timestamp": "2025-11-26T01:51:46.219Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Dijkstra's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    background: #fafafa;\n  }\n  h1 {\n    margin: 20px 0 5px;\n  }\n  #container {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n    max-width: 960px;\n    margin-bottom: 20px;\n  }\n  #graphCanvas {\n    background: #fff;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n  }\n  #controls {\n    max-width: 960px;\n    background: #fff;\n    padding: 15px 20px;\n    border-radius: 6px;\n    box-shadow: 0 0 8px rgba(0,0,0,.1);\n    margin-bottom: 30px;\n  }\n  label {\n    display: inline-block;\n    margin: 8px 10px 8px 0;\n  }\n  select, button {\n    margin-right: 15px;\n    padding: 6px 12px;\n    font-size: 1rem;\n  }\n  #log {\n    max-width: 960px;\n    height: 180px;\n    overflow-y: auto;\n    background: #222;\n    color: #eee;\n    font-family: monospace;\n    font-size: 14px;\n    padding: 12px;\n    border-radius: 6px;\n    box-sizing: border-box;\n  }\n  #speedLabel {\n    vertical-align: middle;\n  }\n  input[type=range] {\n    vertical-align: middle;\n  }\n  #info {\n    max-width: 960px;\n    margin: 0 10px 20px 10px;\n    font-size: 14px;\n    color: #333;\n  }\n  a {\n    color: #007acc;\n  }\n</style>\n</head>\n<body>\n<h1>Dijkstra's Algorithm Visualization</h1>\n<div id=\"info\">\n  <p>This interactive visualization demonstrates Dijkstra's algorithm finding the shortest path on a weighted graph. \n  Select start and end nodes, then press <b>Run Algorithm</b>. You can change the animation speed, reset, or generate a new graph.</p>\n  <p>Graph nodes are shown as circles; edges show weights; the shortest path is highlighted in green.</p>\n</div>\n<div id=\"container\">\n  <canvas id=\"graphCanvas\" width=\"800\" height=\"500\"></canvas>\n</div>\n<div id=\"controls\">\n  <label for=\"startNode\">Start Node:</label>\n  <select id=\"startNode\"></select>\n\n  <label for=\"endNode\">End Node:</label>\n  <select id=\"endNode\"></select>\n\n  <button id=\"runBtn\">Run Algorithm</button>\n  <button id=\"stepBtn\" disabled>Step</button>\n  <button id=\"resetBtn\">Reset</button>\n  <button id=\"newGraphBtn\">New Graph</button>\n\n  <label for=\"speedRange\" id=\"speedLabel\">Animation Speed:</label>\n  <input type=\"range\" id=\"speedRange\" min=\"50\" max=\"2000\" value=\"500\" step=\"10\" />\n  <span id=\"speedValue\">500 ms</span>\n</div>\n<div id=\"log\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n\n  const runBtn = document.getElementById('runBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const newGraphBtn = document.getElementById('newGraphBtn');\n\n  const startNodeSelect = document.getElementById('startNode');\n  const endNodeSelect = document.getElementById('endNode');\n\n  const speedRange = document.getElementById('speedRange');\n  const speedValue = document.getElementById('speedValue');\n\n  const logElem = document.getElementById('log');\n\n  const NODE_RADIUS = 20;\n  const EDGE_COLOR = '#999';\n  const EDGE_HIGHLIGHT = '#2a9d8f';\n  const PATH_COLOR = '#2a9d8f';\n  const NODE_COLOR = '#264653';\n  const NODE_HIGHLIGHT = '#e76f51';\n  const NODE_VISITED = '#f4a261';\n  const NODE_CURRENT = '#e76f51';\n  const LABEL_COLOR = '#222';\n  const BACKGROUND_COLOR = '#fff';\n\n  // Graph data structure\n  // nodes: {id: string, x: number, y: number, neighbors: Array<{id, weight}>}\n  // Using adjacency list with weights\n  let graph = { nodes: [] };\n\n  // Algorithm state\n  let distances = {}; // nodeId -> current shortest distance\n  let previous = {}; // nodeId -> previous node in path\n  let visited = new Set();\n  let unvisited = new Set();\n  let pq = []; // priority queue simulated with array of {node, dist} objects\n  let startNode = null;\n  let endNode = null;\n\n  let animationSpeed = 500;\n\n  let intervalId = null;\n  let algorithmRunning = false;\n  let algorithmSteps = []; // steps for stepwise run\n  let stepIdx = 0;\n\n  // Utility: shuffle array\n  function shuffle(array) {\n    for (let i=array.length-1; i>0; i--) {\n      const j = Math.floor(Math.random()*(i+1));\n      [array[i], array[j]] = [array[j], array[i]];\n    }\n  }\n\n  // Priority queue helpers\n  function enqueuePQ(pq, node, dist) {\n    pq.push({node, dist});\n    pq.sort((a,b) => a.dist - b.dist);\n  }\n  function dequeuePQ(pq) {\n    return pq.shift();\n  }\n\n  // Clear log\n  function clearLog() {\n    logElem.textContent = '';\n  }\n  // Add line to log (and scroll)\n  function log(message) {\n    const line = document.createElement('div');\n    line.textContent = message;\n    logElem.appendChild(line);\n    logElem.scrollTop = logElem.scrollHeight;\n  }\n\n  // Generate a simple random connected graph with weighted edges\n  // For demo: 10 nodes placed randomly, edges between near nodes\n  function generateRandomGraph(numNodes=10, maxEdgesPerNode=4, maxWeight=20) {\n    const width = canvas.width;\n    const height = canvas.height;\n\n    // Generate nodes with random positions away from edges\n    const margin = NODE_RADIUS * 3;\n    let nodes = [];\n    for (let i=0; i<numNodes; i++) {\n      const node = {\n        id: i.toString(),\n        x: Math.random()*(width - 2*margin) + margin,\n        y: Math.random()*(height - 2*margin) + margin,\n        neighbors: []\n      };\n      nodes.push(node);\n    }\n\n    // We want undirected weighted edges connecting nodes to nearby nodes.\n    // First connect nodes in a chain to guarantee connectivity:\n    for(let i=0; i<numNodes-1; i++) {\n      const w = 1 + Math.floor(Math.random()*maxWeight);\n      nodes[i].neighbors.push({id: nodes[i+1].id, weight: w});\n      nodes[i+1].neighbors.push({id: nodes[i].id, weight: w});\n    }\n\n    // Add some extra edges to add complexity:\n    nodes.forEach((node, i) => {\n      // Find nodes sorted by distance\n      let dists = nodes.map(other => {\n        if (other.id === node.id) return null;\n        const dx = other.x - node.x;\n        const dy = other.y - node.y;\n        const dist = Math.sqrt(dx*dx + dy*dy);\n        return {id: other.id, dist};\n      }).filter(v => v !== null);\n      dists.sort((a,b)=> a.dist - b.dist);\n\n      let edgesAdded = node.neighbors.length;\n      for (let j=1; edgesAdded < maxEdgesPerNode && j < dists.length; j++) {\n        let neighborId = dists[j].id;\n        // Check if edge already exists:\n        if (!node.neighbors.find(n => n.id === neighborId)) {\n          const w = Math.max(1, Math.round(dists[j].dist / 15)) + Math.floor(Math.random()*3);\n          node.neighbors.push({id: neighborId, weight: w});\n          const otherNode = nodes.find(n => n.id === neighborId);\n          otherNode.neighbors.push({id: node.id, weight: w});\n          edgesAdded++;\n        }\n      }\n    });\n\n    return {nodes};\n  }\n\n  // Draw graph on canvas\n  function drawGraph(options={highlightEdges:[], highlightNodes:[], shortestPath: []}) {\n    ctx.clearRect(0,0,canvas.width, canvas.height);\n\n    // Draw edges\n    ctx.lineWidth = 2;\n    graph.nodes.forEach(node => {\n      node.neighbors.forEach(neighbor => {\n        // To draw each edge only once, draw if node.id < neighbor.id\n        if (node.id < neighbor.id) {\n          let neighborNode = graph.nodes.find(n => n.id === neighbor.id);\n          let isPathEdge = options.shortestPath.some((edgeIdx, idx, arr) => {\n            if (idx === arr.length - 1) return false;\n            let from = arr[idx], to = arr[idx+1];\n            return ( (node.id === from && neighborNode.id === to) || (node.id === to && neighborNode.id === from) );\n          });\n\n          let isHighlighted = options.highlightEdges.some(e => e[0] === node.id && e[1] === neighbor.id)\n                              || options.highlightEdges.some(e => e[1] === node.id && e[0] === neighbor.id);\n\n          ctx.strokeStyle = isPathEdge ? PATH_COLOR : (isHighlighted ? EDGE_HIGHLIGHT : EDGE_COLOR);\n          ctx.beginPath();\n          ctx.moveTo(node.x, node.y);\n          ctx.lineTo(neighborNode.x, neighborNode.y);\n          ctx.stroke();\n\n          // Draw edge weight at midpoint\n          const midX = (node.x + neighborNode.x) / 2;\n          const midY = (node.y + neighborNode.y) / 2;\n          ctx.fillStyle = LABEL_COLOR;\n          ctx.font = '14px Arial';\n          ctx.fillText(neighbor.weight.toString(), midX + 4, midY - 4);\n        }\n      });\n    });\n\n    // Draw nodes\n    graph.nodes.forEach(node => {\n      // Determine node color\n      let fillColor = NODE_COLOR;\n      if (options.shortestPath.includes(node.id)) {\n        fillColor = PATH_COLOR;\n      } else if (options.highlightNodes.includes(node.id)) {\n        fillColor = NODE_CURRENT;\n      } else if (visited.has(node.id)) {\n        fillColor = NODE_VISITED;\n      }\n\n      ctx.beginPath();\n      ctx.fillStyle = fillColor;\n      ctx.strokeStyle = '#111';\n      ctx.lineWidth = 2;\n      ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2*Math.PI);\n      ctx.fill();\n      ctx.stroke();\n\n      // Node label\n      ctx.fillStyle = '#fff';\n      ctx.font = '16px Arial bold';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(node.id, node.x, node.y);\n\n      // Distance label (if exists)\n      if (distances[node.id] !== undefined && distances[node.id] !== Infinity) {\n        ctx.fillStyle = '#222';\n        ctx.font = '12px monospace';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'top';\n        ctx.fillText(`Dist: ${distances[node.id]}`, node.x, node.y + NODE_RADIUS + 2);\n      }\n    });\n  }\n\n  // Populate start/end node selectors\n  function populateNodeSelectors() {\n    [startNodeSelect, endNodeSelect].forEach(select => {\n      select.innerHTML = '';\n      graph.nodes.forEach(node => {\n        let opt = document.createElement('option');\n        opt.value = node.id;\n        opt.textContent = node.id;\n        select.appendChild(opt);\n      });\n    });\n    // Default selections\n    startNodeSelect.selectedIndex = 0;\n    endNodeSelect.selectedIndex = graph.nodes.length-1;\n  }\n\n  // Initialize/reset algorithm state\n  function initializeAlgorithm() {\n    distances = {};\n    previous = {};\n    visited = new Set();\n    unvisited = new Set(graph.nodes.map(n => n.id));\n    pq = [];\n    algorithmSteps = [];\n    stepIdx = 0;\n\n    graph.nodes.forEach(n => distances[n.id] = Infinity);\n    distances[startNode] = 0;\n    enqueuePQ(pq, startNode, 0);\n  }\n\n  // Prepare algorithm steps for stepwise execution & animation\n  function prepareAlgorithmSteps() {\n    algorithmSteps = [];\n\n    let localDistances = {...distances};\n    let localPrevious = {...previous};\n    let localVisited = new Set();\n    let localPQ = [...pq];\n\n    while (localPQ.length > 0) {\n      // Get node with smallest distance\n      localPQ.sort((a,b) => a.dist - b.dist);\n      let {node: currentNode, dist: currentDist} = localPQ.shift();\n\n      if (localVisited.has(currentNode)) continue;\n      localVisited.add(currentNode);\n\n      // Step: mark current node as visited, record state\n      algorithmSteps.push({\n        type: 'visit',\n        currentNode,\n        distances: {...localDistances},\n        visited: new Set(localVisited),\n        previous: {...localPrevious},\n        pq: [...localPQ],\n      });\n\n      // Early stop if reached end node\n      if (currentNode === endNode) break;\n\n      // For each neighbor of currentNode:\n      let curNodeObj = graph.nodes.find(n => n.id === currentNode);\n      for(let neighbor of curNodeObj.neighbors) {\n        if (localVisited.has(neighbor.id)) continue;\n        let altDist = localDistances[currentNode] + neighbor.weight;\n        if (altDist < (localDistances[neighbor.id] ?? Infinity)) {\n          localDistances[neighbor.id] = altDist;\n          localPrevious[neighbor.id] = currentNode;\n          localPQ.push({node: neighbor.id, dist: altDist});\n\n          // Step: update neighbor distance\n          algorithmSteps.push({\n            type: 'update',\n            currentNode,\n            neighborId: neighbor.id,\n            newDist: altDist,\n            distances: {...localDistances},\n            visited: new Set(localVisited),\n            previous: {...localPrevious},\n            pq: [...localPQ],\n          });\n        }\n      }\n    }\n\n    // Add final step showing shortest path\n    let path = reconstructPath(localPrevious, startNode, endNode);\n    algorithmSteps.push({\n      type: 'done',\n      path,\n      distances: {...localDistances},\n      visited: new Set(localVisited),\n      previous: {...localPrevious},\n      pq: [],\n    });\n  }\n\n  // Reconstruct path from previous map\n  function reconstructPath(prev, start, end) {\n    let path = [];\n    let current = end;\n    while (current !== undefined) {\n      path.push(current);\n      if (current === start) break;\n      current = prev[current];\n    }\n    if (path[path.length-1] !== start) return []; // no path\n    return path.reverse();\n  }\n\n  // Draw step state\n  function drawStep(step) {\n    // Highlight current node\n    let highlightNodes = [];\n    let highlightEdges = [];\n    if (step.type === 'visit') {\n      highlightNodes = [step.currentNode];\n    } else if (step.type === 'update') {\n      highlightNodes = [step.currentNode, step.neighborId];\n    } else if (step.type === 'done') {\n      // path already in step.path\n    }\n\n    // Replace global distances and visited with step snapshot\n    distances = step.distances;\n    visited = step.visited;\n\n    drawGraph({\n      highlightNodes,\n      highlightEdges,\n      shortestPath: step.path || []\n    });\n  }\n\n  // Run algorithm animation step by step\n  function runAlgorithmAnimation() {\n    if (stepIdx >= algorithmSteps.length) {\n      clearInterval(intervalId);\n      algorithmRunning = false;\n      stepBtn.disabled = true;\n      runBtn.disabled = false;\n      log(\"Algorithm completed.\");\n      return;\n    }\n    const step = algorithmSteps[stepIdx];\n    drawStep(step);\n\n    // Log info about step\n    if (step.type === 'visit') {\n      log(`Visit node ${step.currentNode} with distance ${distances[step.currentNode]}`);\n    } else if (step.type === 'update') {\n      log(`Update distance of node ${step.neighborId} to ${step.newDist} via ${step.currentNode}`);\n    } else if (step.type === 'done') {\n      if (step.path.length > 0) {\n        log(`Shortest path found: ${step.path.join(' → ')} with distance ${distances[endNode]}`);\n      } else {\n        log(\"No path found from start to end node.\");\n      }\n    }\n    stepIdx++;\n  }\n\n  // Manual step one step\n  function stepAlgorithm() {\n    if (stepIdx >= algorithmSteps.length) {\n      log(\"Algorithm completed.\");\n      stepBtn.disabled = true;\n      runBtn.disabled = false;\n      algorithmRunning = false;\n      return;\n    }\n    const step = algorithmSteps[stepIdx];\n    drawStep(step);\n\n    if (step.type === 'visit') {\n      log(`Visit node ${step.currentNode} with distance ${distances[step.currentNode]}`);\n    } else if (step.type === 'update') {\n      log(`Update distance of node ${step.neighborId} to ${step.newDist} via ${step.currentNode}`);\n    } else if (step.type === 'done') {\n      if (step.path.length > 0) {\n        log(`Shortest path found: ${step.path.join(' → ')} with distance ${distances[endNode]}`);\n      } else {\n        log(\"No path found from start to end node.\");\n      }\n      stepBtn.disabled = true;\n      runBtn.disabled = false;\n      algorithmRunning = false;\n    }\n    stepIdx++;\n  }\n\n  // Event handlers\n  runBtn.addEventListener('click', () => {\n    if (algorithmRunning) return; // ignore while running\n\n    startNode = startNodeSelect.value;\n    endNode = endNodeSelect.value;\n    if (startNode === endNode) {\n      alert(\"Start node and end node must be different.\");\n      return;\n    }\n\n    initializeAlgorithm();\n    prepareAlgorithmSteps();\n    stepIdx = 0;\n    algorithmRunning = true;\n    clearLog();\n    log(`Running Dijkstra's algorithm from node ${startNode} to node ${endNode}...`);\n\n    runBtn.disabled = true;\n    stepBtn.disabled = true;\n    resetBtn.disabled = true;\n    newGraphBtn.disabled = true;\n    startNodeSelect.disabled = true;\n    endNodeSelect.disabled = true;\n\n    intervalId = setInterval(() => {\n      runAlgorithmAnimation();\n      if (!algorithmRunning) {\n        clearInterval(intervalId);\n        resetBtn.disabled = false;\n        newGraphBtn.disabled = false;\n        startNodeSelect.disabled = false;\n        endNodeSelect.disabled = false;\n      }\n    }, animationSpeed);\n  });\n\n  stepBtn.addEventListener('click', () => {\n    if (!algorithmRunning) {\n      startNode = startNodeSelect.value;\n      endNode = endNodeSelect.value;\n      if (startNode === endNode) {\n        alert(\"Start node and end node must be different.\");\n        return;\n      }\n      initializeAlgorithm();\n      prepareAlgorithmSteps();\n      stepIdx = 0;\n      algorithmRunning = true;\n      clearLog();\n      log(`Running Dijkstra's algorithm (stepwise) from node ${startNode} to node ${endNode}...`);\n      runBtn.disabled = true;\n      resetBtn.disabled = true;\n      newGraphBtn.disabled = true;\n      startNodeSelect.disabled = true;\n      endNodeSelect.disabled = true;\n    }\n    stepAlgorithm();\n    if (!algorithmRunning) {\n      resetBtn.disabled = false;\n      newGraphBtn.disabled = false;\n      startNodeSelect.disabled = false;\n      endNodeSelect.disabled = false;\n      runBtn.disabled = false;\n    }\n  });\n\n  resetBtn.addEventListener('click', () => {\n    clearInterval(intervalId);\n    algorithmRunning = false;\n    resetBtn.disabled = false;\n    runBtn.disabled = false;\n    stepBtn.disabled = true;\n    newGraphBtn.disabled = false;\n    startNodeSelect.disabled = false;\n    endNodeSelect.disabled = false;\n    clearLog();\n    distances = {};\n    previous = {};\n    visited.clear();\n    stepIdx = 0;\n    drawGraph();\n  });\n\n  newGraphBtn.addEventListener('click', () => {\n    clearInterval(intervalId);\n    algorithmRunning = false;\n    graph = generateRandomGraph();\n    populateNodeSelectors();\n    startNode = null;\n    endNode = null;\n    distances = {};\n    previous = {};\n    visited.clear();\n    stepIdx = 0;\n    clearLog();\n    drawGraph();\n    runBtn.disabled = false;\n    stepBtn.disabled = true;\n    resetBtn.disabled = false;\n    startNodeSelect.disabled = false;\n    endNodeSelect.disabled = false;\n  });\n\n  speedRange.addEventListener('input', () => {\n    animationSpeed = parseInt(speedRange.value, 10);\n    speedValue.textContent = animationSpeed + \" ms\";\n    if (algorithmRunning) {\n      clearInterval(intervalId);\n      intervalId = setInterval(runAlgorithmAnimation, animationSpeed);\n    }\n  });\n\n  // Initialize page\n  function init() {\n    graph = generateRandomGraph();\n    populateNodeSelectors();\n    drawGraph();\n    runBtn.disabled = false;\n    stepBtn.disabled = true;\n    resetBtn.disabled = false;\n    speedValue.textContent = speedRange.value + \" ms\";\n  }\n\n  init();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}