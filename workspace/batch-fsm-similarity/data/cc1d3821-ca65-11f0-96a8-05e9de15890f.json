{
  "id": "cc1d3821-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:06.770Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Red-Black Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\"/>\n  <title>Red-Black Tree Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n  <style>\n    body { font-family: Arial, Helvetica, sans-serif; margin: 0; display: flex; height: 100vh; }\n    #left { width: 360px; padding: 16px; box-sizing: border-box; background: #f7f9fb; border-right: 1px solid #ddd; overflow:auto; }\n    #main { flex: 1; position: relative; display:flex; flex-direction:column; }\n    h1 { font-size: 18px; margin: 4px 0 8px; }\n    label { display:block; margin-top:8px; font-weight:600; }\n    input[type=\"number\"], input[type=\"text\"] { width: 100%; padding:8px; box-sizing:border-box; margin-top:6px; border:1px solid #bbb; border-radius:4px; }\n    button { padding:8px 10px; margin-top:10px; border-radius:4px; border:1px solid #2b6cb0; background:linear-gradient(#3182CE,#2B6CB0); color:white; cursor:pointer; }\n    button.secondary { background:linear-gradient(#e7e7e7,#dcdcdc); color:#222; border:1px solid #bbb; margin-left:8px; }\n    #controls { display:flex; align-items:flex-start; gap:8px; flex-wrap:wrap; }\n    .row { margin-top:12px; }\n    #svgwrap { flex:1; background:linear-gradient(#fff,#f2f8ff); position:relative; }\n    svg { width:100%; height:100%; }\n    .node circle { stroke:#333; stroke-width:2px; }\n    .node text { font-size:12px; font-weight:700; fill:#fff; pointer-events:none; text-anchor:middle; dominant-baseline:central; }\n    .node.black text { fill:#fff; }\n    .node.red text { fill:#fff; }\n    .edge { stroke:#666; stroke-width:2px; stroke-linecap:round; }\n    #info { margin-top:14px; font-size:13px; }\n    .prop { margin-top:6px; padding:8px; background:#fff; border-radius:6px; border:1px solid #eee; }\n    .ok { color:green; font-weight:700; }\n    .bad { color:red; font-weight:700; }\n    #legend { margin-top:10px; }\n    .legendItem { display:flex; align-items:center; gap:8px; margin-top:6px; }\n    .sample { width:20px; height:20px; border-radius:50%; display:inline-block; border:2px solid #333; vertical-align:middle; }\n    #footer { padding:8px 12px; font-size:12px; color:#444; border-top:1px solid #eee; background:#fafafa; }\n    .small { font-size:12px; color:#555; margin-top:6px; }\n    input[type=\"range\"] { width:100%; }\n    .muted { color:#666; font-size:13px; }\n  </style>\n</head>\n<body>\n  <div id=\"left\">\n    <h1>Red-Black Tree Visualizer</h1>\n    <div class=\"muted\">Insert, delete and watch balancing (rotations and recolorings). Animation steps are highlighted.</div>\n\n    <div class=\"row\">\n      <label>Value to Insert</label>\n      <input id=\"insertVal\" type=\"number\" placeholder=\"e.g. 42\">\n      <div style=\"display:flex; gap:8px;\">\n        <button id=\"btnInsert\">Insert</button>\n        <button id=\"btnInsertStep\" class=\"secondary\">Insert (animated)</button>\n      </div>\n      <div style=\"display:flex; gap:8px;\">\n        <button id=\"btnRandom\" class=\"secondary\">Insert Random</button>\n        <button id=\"btnBulk\" class=\"secondary\">Bulk Insert (10)</button>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <label>Value to Delete</label>\n      <input id=\"deleteVal\" type=\"number\" placeholder=\"e.g. 42\">\n      <div style=\"display:flex; gap:8px;\">\n        <button id=\"btnDelete\" class=\"secondary\">Delete (animated)</button>\n        <button id=\"btnClear\" class=\"secondary\">Clear</button>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <label>Animation Speed (ms)</label>\n      <input id=\"speed\" type=\"range\" min=\"100\" max=\"1500\" value=\"600\">\n      <div class=\"small\">Step duration: <span id=\"speedVal\">600</span> ms</div>\n    </div>\n\n    <div id=\"legend\">\n      <div class=\"legendItem\"><div class=\"sample\" style=\"background:red;\"></div><div>Red node</div></div>\n      <div class=\"legendItem\"><div class=\"sample\" style=\"background:black;\"></div><div>Black node</div></div>\n    </div>\n\n    <div id=\"info\">\n      <div class=\"prop\">\n        <div><strong>Properties</strong></div>\n        <div id=\"propContent\" class=\"small\">Tree is empty</div>\n      </div>\n\n      <div class=\"prop\" style=\"margin-top:10px;\">\n        <div><strong>Last action</strong></div>\n        <div id=\"lastAction\" class=\"small\">—</div>\n      </div>\n\n      <div class=\"prop\" style=\"margin-top:10px;\">\n        <div><strong>Tips</strong></div>\n        <ul class=\"small\" style=\"margin:6px 0 0 18px; padding:0;\">\n          <li>Insertions recolor and rotate to keep black-depth balanced.</li>\n          <li>Try insert sequences that cause rotations: 10, 20, 30, ...</li>\n          <li>Deletion is animated and follows classic RB-Tree fix-up rules.</li>\n        </ul>\n      </div>\n    </div>\n\n    <div style=\"margin-top:12px;\">\n      <button id=\"btnExample\" class=\"secondary\">Load Example (classic)</button>\n    </div>\n\n    <div id=\"footer\">Interactive implementation — shows rotations and recolorings step-by-step.</div>\n  </div>\n\n  <div id=\"main\">\n    <div id=\"svgwrap\">\n      <svg id=\"svg\" viewBox=\"0 0 1200 600\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n    </div>\n  </div>\n\n  <script>\n  (function(){\n    // Colors\n    const RED = true, BLACK = false;\n\n    let nodeIdCounter = 1;\n\n    class Node {\n      constructor(value){\n        this.value = value;\n        this.left = null;\n        this.right = null;\n        this.parent = null;\n        this.color = RED;\n        this.id = nodeIdCounter++;\n        // visualization state\n        this.x = 0; this.y = 0;\n      }\n    }\n\n    class RBTree {\n      constructor(svg){\n        this.root = null;\n        this.svg = svg;\n        this.nodeMap = new Map(); // node -> DOM group\n        this.running = false;\n        this.stepDuration = 600;\n      }\n\n      setSpeed(ms){ this.stepDuration = ms; }\n\n      async insertValue(value, animated=true){\n        if(this.running) return;\n        this.running = true;\n        try {\n          if(this.find(value)) {\n            this.setLast(`Value ${value} already present`);\n            this.running = false; return;\n          }\n          let z = new Node(value);\n          // BST insert\n          let y = null;\n          let x = this.root;\n          while(x !== null){\n            y = x;\n            if(z.value < x.value) x = x.left;\n            else x = x.right;\n          }\n          z.parent = y;\n          if(y === null){\n            this.root = z;\n          } else if(z.value < y.value){\n            y.left = z;\n          } else {\n            y.right = z;\n          }\n          z.left = null; z.right = null; z.color = RED;\n          this.updateVisualization();\n          await this.animateFlashNode(z, 'inserting', this.stepDuration/2);\n\n          await this.insertFixup(z, animated);\n          this.setLast(`Inserted ${value}`);\n        } catch(e){\n          console.error(e);\n        }\n        this.running = false;\n        this.updateVisualization();\n      }\n\n      async insertFixup(z, animated=true){\n        while(z.parent && z.parent.color === RED){\n          let p = z.parent;\n          let g = p.parent;\n          if(!g) break;\n          if(p === g.left){\n            let y = g.right;\n            if(y && y.color === RED){\n              // case 1\n              p.color = BLACK;\n              y.color = BLACK;\n              g.color = RED;\n              this.updateVisualization();\n              if(animated) await this.animateRecolor([p,y,g], this.stepDuration);\n              z = g;\n            } else {\n              if(z === p.right){\n                // case 2\n                z = p;\n                await this.leftRotate(z, animated);\n              }\n              // case 3\n              p.color = BLACK;\n              g.color = RED;\n              await this.rightRotate(g, animated);\n            }\n          } else {\n            // mirror\n            let y = g.left;\n            if(y && y.color === RED){\n              p.color = BLACK;\n              y.color = BLACK;\n              g.color = RED;\n              this.updateVisualization();\n              if(animated) await this.animateRecolor([p,y,g], this.stepDuration);\n              z = g;\n            } else {\n              if(z === p.left){\n                z = p;\n                await this.rightRotate(z, animated);\n              }\n              p.color = BLACK;\n              g.color = RED;\n              await this.leftRotate(g, animated);\n            }\n          }\n        }\n        if(this.root) {\n          this.root.color = BLACK;\n          this.updateVisualization();\n          if(animated) await this.animateRecolor([this.root], this.stepDuration/2);\n        }\n      }\n\n      async deleteValue(val, animated=true){\n        if(this.running) return;\n        this.running = true;\n        try {\n          let z = this.find(val);\n          if(!z){\n            this.setLast(`Value ${val} not found`);\n            this.running = false;\n            return;\n          }\n          await this.animateFlashNode(z, 'deleting', this.stepDuration);\n          await this.deleteNode(z, animated);\n          this.setLast(`Deleted ${val}`);\n        } catch(e){\n          console.error(e);\n        }\n        this.running = false;\n        this.updateVisualization();\n      }\n\n      // Helper to transplant subtree u into v's place\n      transplant(u, v){\n        if(u.parent === null) {\n          this.root = v;\n        } else if(u === u.parent.left) {\n          u.parent.left = v;\n        } else {\n          u.parent.right = v;\n        }\n        if(v) v.parent = u.parent;\n      }\n\n      minimum(x){\n        while(x.left) x = x.left;\n        return x;\n      }\n\n      async deleteNode(z, animated=true){\n        // Standard CLRS delete\n        let y = z;\n        let yOriginalColor = y.color;\n        let x = null;\n        if(!z.left){\n          x = z.right;\n          this.transplant(z, z.right);\n        } else if(!z.right){\n          x = z.left;\n          this.transplant(z, z.left);\n        } else {\n          y = this.minimum(z.right);\n          yOriginalColor = y.color;\n          x = y.right;\n          if(y.parent === z){\n            if(x) x.parent = y;\n          } else {\n            this.transplant(y, y.right);\n            y.right = z.right;\n            if(y.right) y.right.parent = y;\n          }\n          this.transplant(z, y);\n          y.left = z.left;\n          if(y.left) y.left.parent = y;\n          y.color = z.color;\n        }\n        this.updateVisualization();\n        if(animated) await this.sleep(this.stepDuration/2);\n        if(yOriginalColor === BLACK){\n          await this.deleteFixup(x, animated);\n        }\n      }\n\n      async deleteFixup(x, animated=true){\n        // x may be null (treated as black)\n        while(x !== this.root && this.getColor(x) === BLACK){\n          if(x === (x && x.parent && x.parent.left)){\n            let w = x.parent.right;\n            // Case 1\n            if(this.getColor(w) === RED){\n              w.color = BLACK;\n              x.parent.color = RED;\n              this.updateVisualization();\n              if(animated) await this.animateRecolor([w, x.parent], this.stepDuration);\n              await this.leftRotate(x.parent, animated);\n              w = x.parent.right;\n            }\n            if(this.getColor(w.left) === BLACK && this.getColor(w.right) === BLACK){\n              // Case 2\n              if(w) w.color = RED;\n              this.updateVisualization();\n              if(animated) await this.animateRecolor([w], this.stepDuration);\n              x = x.parent;\n            } else {\n              if(this.getColor(w.right) === BLACK){\n                // Case 3\n                if(w.left) w.left.color = BLACK;\n                w.color = RED;\n                this.updateVisualization();\n                if(animated) await this.animateRecolor([w, w.left], this.stepDuration);\n                await this.rightRotate(w, animated);\n                w = x.parent.right;\n              }\n              // Case 4\n              if(w) w.color = x.parent.color;\n              x.parent.color = BLACK;\n              if(w && w.right) w.right.color = BLACK;\n              this.updateVisualization();\n              if(animated) await this.animateRecolor([x.parent, w, (w && w.right)], this.stepDuration);\n              await this.leftRotate(x.parent, animated);\n              x = this.root;\n            }\n          } else {\n            // mirror\n            let w = x.parent.left;\n            if(this.getColor(w) === RED){\n              w.color = BLACK;\n              x.parent.color = RED;\n              this.updateVisualization();\n              if(animated) await this.animateRecolor([w, x.parent], this.stepDuration);\n              await this.rightRotate(x.parent, animated);\n              w = x.parent.left;\n            }\n            if(this.getColor(w.right) === BLACK && this.getColor(w.left) === BLACK){\n              if(w) w.color = RED;\n              this.updateVisualization();\n              if(animated) await this.animateRecolor([w], this.stepDuration);\n              x = x.parent;\n            } else {\n              if(this.getColor(w.left) === BLACK){\n                if(w.right) w.right.color = BLACK;\n                w.color = RED;\n                this.updateVisualization();\n                if(animated) await this.animateRecolor([w, w.right], this.stepDuration);\n                await this.leftRotate(w, animated);\n                w = x.parent.left;\n              }\n              if(w) w.color = x.parent.color;\n              x.parent.color = BLACK;\n              if(w && w.left) w.left.color = BLACK;\n              this.updateVisualization();\n              if(animated) await this.animateRecolor([x.parent, w, (w && w.left)], this.stepDuration);\n              await this.rightRotate(x.parent, animated);\n              x = this.root;\n            }\n          }\n        }\n        if(x) x.color = BLACK;\n        this.updateVisualization();\n        if(animated) await this.animateRecolor([x], this.stepDuration/2);\n      }\n\n      getColor(node){\n        return node ? node.color : BLACK;\n      }\n\n      async leftRotate(x, animated=true){\n        if(!x || !x.right) return;\n        let y = x.right;\n        // visualization: highlight rotation\n        this.setLast(`Left rotate at ${x.value}`);\n        // perform rotation\n        x.right = y.left;\n        if(y.left) y.left.parent = x;\n        y.parent = x.parent;\n        if(!x.parent) this.root = y;\n        else if(x === x.parent.left) x.parent.left = y;\n        else x.parent.right = y;\n        y.left = x;\n        x.parent = y;\n        this.updateVisualization();\n        if(animated) await this.animateRotation(x,y,this.stepDuration);\n      }\n\n      async rightRotate(x, animated=true){\n        if(!x || !x.left) return;\n        let y = x.left;\n        this.setLast(`Right rotate at ${x.value}`);\n        x.left = y.right;\n        if(y.right) y.right.parent = x;\n        y.parent = x.parent;\n        if(!x.parent) this.root = y;\n        else if(x === x.parent.right) x.parent.right = y;\n        else x.parent.left = y;\n        y.right = x;\n        x.parent = y;\n        this.updateVisualization();\n        if(animated) await this.animateRotation(x,y,this.stepDuration);\n      }\n\n      find(value){\n        let x = this.root;\n        while(x){\n          if(value === x.value) return x;\n          x = value < x.value ? x.left : x.right;\n        }\n        return null;\n      }\n\n      // Visualization utilities\n\n      updateVisualization(){\n        // compute positions via inorder layout\n        const positions = [];\n        let xCounter = 0;\n        const assign = (node, depth=0) => {\n          if(!node) return;\n          assign(node.left, depth+1);\n          node.x = ++xCounter;\n          node.y = depth;\n          positions.push(node);\n          assign(node.right, depth+1);\n        };\n        assign(this.root, 0);\n\n        // compute scale to SVG width\n        const view = this.svg.viewBox.baseVal;\n        const width = view.width || 1200;\n        const height = view.height || 600;\n        const levelHeight = 80;\n        let maxX = Math.max(1, xCounter);\n        // map logical x (1..maxX) to pixel x range with padding\n        const pad = 40;\n        const xFor = ix => pad + (ix-1) * ((width-2*pad)/(maxX-1 || 1));\n        const yFor = depth => pad + depth * levelHeight;\n\n        // ensure DOM nodes exist\n        const existing = new Set();\n        // create groups for nodes\n        const gParent = this.svg;\n        // draw edges first or reuse\n        // update/create node groups\n        const nodesToRender = [];\n        const collect = (n) => { if(!n) return; nodesToRender.push(n); collect(n.left); collect(n.right); };\n        collect(this.root);\n        // create missing node groups\n        nodesToRender.forEach(n=>{\n          if(!this.nodeMap.has(n)){\n            const g = document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\");\n            g.setAttribute(\"class\",\"node\");\n            g.setAttribute(\"data-id\", n.id);\n            const circle = document.createElementNS(\"http://www.w3.org/2000/svg\",\"circle\");\n            circle.setAttribute(\"r\", 18);\n            circle.setAttribute(\"cx\", 0);\n            circle.setAttribute(\"cy\", 0);\n            const text = document.createElementNS(\"http://www.w3.org/2000/svg\",\"text\");\n            text.textContent = String(n.value);\n            g.appendChild(circle);\n            g.appendChild(text);\n            // tooltip\n            g.addEventListener('mouseenter', ()=>{ g.style.filter = 'drop-shadow(0 2px 4px rgba(0,0,0,0.2))'; });\n            g.addEventListener('mouseleave', ()=>{ g.style.filter = 'none'; });\n            gParent.appendChild(g);\n            this.nodeMap.set(n, g);\n          } else {\n            const g = this.nodeMap.get(n);\n            // update label if needed\n            const txt = g.querySelector('text');\n            if(txt && txt.textContent !== String(n.value)) txt.textContent = String(n.value);\n          }\n        });\n\n        // Remove DOM nodes that are no longer in the tree\n        Array.from(this.nodeMap.keys()).forEach(k=>{\n          if(!nodesToRender.includes(k)){\n            const g = this.nodeMap.get(k);\n            if(g && g.parentNode) g.parentNode.removeChild(g);\n            this.nodeMap.delete(k);\n          }\n        });\n\n        // draw edges: remove all edges and recreate for simplicity\n        // remove existing edges\n        Array.from(gParent.querySelectorAll('.edge')).forEach(e=> e.parentNode.removeChild(e));\n        // create lines\n        nodesToRender.forEach(n=>{\n          if(n.left){\n            const line = document.createElementNS(\"http://www.w3.org/2000/svg\",\"line\");\n            line.setAttribute(\"class\",\"edge\");\n            line.setAttribute(\"data-from\", n.id);\n            line.setAttribute(\"data-to\", n.left.id);\n            line.setAttribute(\"x1\", xFor(n.x));\n            line.setAttribute(\"y1\", yFor(n.y));\n            line.setAttribute(\"x2\", xFor(n.left.x));\n            line.setAttribute(\"y2\", yFor(n.left.y));\n            gParent.insertBefore(line, gParent.firstChild);\n          }\n          if(n.right){\n            const line = document.createElementNS(\"http://www.w3.org/2000/svg\",\"line\");\n            line.setAttribute(\"class\",\"edge\");\n            line.setAttribute(\"data-from\", n.id);\n            line.setAttribute(\"data-to\", n.right.id);\n            line.setAttribute(\"x1\", xFor(n.x));\n            line.setAttribute(\"y1\", yFor(n.y));\n            line.setAttribute(\"x2\", xFor(n.right.x));\n            line.setAttribute(\"y2\", yFor(n.right.y));\n            gParent.insertBefore(line, gParent.firstChild);\n          }\n        });\n\n        // place nodes groups at new coords (immediately)\n        nodesToRender.forEach(n=>{\n          const g = this.nodeMap.get(n);\n          if(!g) return;\n          const cx = xFor(n.x);\n          const cy = yFor(n.y);\n          g.setAttribute('transform', `translate(${cx},${cy})`);\n          g.dataset.cx = cx; g.dataset.cy = cy;\n          // color classes\n          if(n.color === RED){\n            g.classList.remove('black'); g.classList.add('red');\n            const circle = g.querySelector('circle');\n            circle.style.fill = '#e53e3e';\n            circle.style.stroke = '#6b0000';\n            const txt = g.querySelector('text'); txt.style.fill = '#fff';\n          } else {\n            g.classList.remove('red'); g.classList.add('black');\n            const circle = g.querySelector('circle');\n            circle.style.fill = '#111';\n            circle.style.stroke = '#333';\n            const txt = g.querySelector('text'); txt.style.fill = '#fff';\n          }\n        });\n\n        // update edges positions (immediate)\n        Array.from(gParent.querySelectorAll('.edge')).forEach(line=>{\n          const fromId = Number(line.getAttribute('data-from'));\n          const toId = Number(line.getAttribute('data-to'));\n          const fromNode = nodesToRender.find(n=>n.id===fromId);\n          const toNode = nodesToRender.find(n=>n.id===toId);\n          if(fromNode && toNode){\n            line.setAttribute('x1', xFor(fromNode.x));\n            line.setAttribute('y1', yFor(fromNode.y));\n            line.setAttribute('x2', xFor(toNode.x));\n            line.setAttribute('y2', yFor(toNode.y));\n          }\n        });\n\n        // update properties inspection\n        this.updateProperties();\n      }\n\n      async animateRotation(xNode, yNode, duration=600){\n        // animate nodes moving to new positions after rotation.\n        // We'll call updateVisualization to compute positions and then tween positions for smooth effect.\n        this.updateVisualization(); // positions set after rotation (since rotation changed tree structure)\n        await this.sleep(duration);\n      }\n\n      async animateRecolor(nodes, duration=600){\n        // briefly highlight recolored nodes\n        const doms = nodes.filter(Boolean).map(n=>this.nodeMap.get(n)).filter(Boolean);\n        doms.forEach(g=> {\n          g.style.outline = '3px solid rgba(255,215,0,0.8)';\n          g.style.transition = `outline ${Math.min(200,duration/3)}ms ease`;\n        });\n        await this.sleep(Math.min(200,duration/3));\n        doms.forEach(g=> g.style.outline = 'none');\n        await this.sleep(duration - Math.min(200,duration/3));\n        this.updateVisualization();\n      }\n\n      async animateFlashNode(node, purpose, duration=400){\n        const g = this.nodeMap.get(node);\n        if(!g) return;\n        const orig = g.style.transform;\n        g.style.transition = `transform ${duration/2}ms ease`;\n        g.style.transform += ' scale(1.14)';\n        await this.sleep(duration/2);\n        g.style.transform = orig;\n        await this.sleep(duration/2);\n      }\n\n      sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }\n\n      setLast(msg){\n        const el = document.getElementById('lastAction');\n        if(el) el.textContent = msg;\n      }\n\n      updateProperties(){\n        const el = document.getElementById('propContent');\n        if(!el) return;\n        if(!this.root){ el.innerHTML = 'Tree is empty'; return; }\n        // check property 1: root is black\n        const prop = [];\n        prop.push({ok: this.root.color === BLACK, text: 'Root is black'});\n        // property 2: red nodes have black children\n        let redOk = true; const reds = [];\n        const check = (n) => {\n          if(!n) return;\n          if(n.color === RED){\n            if((n.left && n.left.color === RED) || (n.right && n.right.color === RED)) redOk = false;\n            reds.push(n.value);\n          }\n          check(n.left); check(n.right);\n        };\n        check(this.root);\n        prop.push({ok: redOk, text: 'No red node has a red child'});\n        // property 3: every path from root to leaves has same number of black nodes\n        const blackHeights = new Set();\n        const compute = (n, count) => {\n          if(n === null){ blackHeights.add(count); return; }\n          if(n.color === BLACK) count++;\n          compute(n.left, count); compute(n.right, count);\n        };\n        compute(this.root, 0);\n        prop.push({ok: blackHeights.size === 1, text: 'Equal black-height on all root-leaf paths (' + Array.from(blackHeights).join(',') + ')'});\n        el.innerHTML = prop.map(p => `<div class=\"${p.ok ? 'ok' : 'bad'}\">${p.text}</div>`).join('');\n      }\n    }\n\n    // UI wiring\n    const svg = document.getElementById('svg');\n    const tree = new RBTree(svg);\n\n    const speedInput = document.getElementById('speed');\n    const speedVal = document.getElementById('speedVal');\n    speedInput.addEventListener('input', ()=>{\n      const ms = Number(speedInput.value);\n      speedVal.textContent = ms;\n      tree.setSpeed(ms);\n    });\n    tree.setSpeed(Number(speedInput.value));\n\n    document.getElementById('btnInsert').addEventListener('click', ()=>{\n      const v = Number(document.getElementById('insertVal').value);\n      if(Number.isFinite(v)) tree.insertValue(v, false);\n    });\n    document.getElementById('btnInsertStep').addEventListener('click', ()=>{\n      const v = Number(document.getElementById('insertVal').value);\n      if(Number.isFinite(v)) tree.insertValue(Number(v), true);\n    });\n    document.getElementById('btnRandom').addEventListener('click', ()=>{\n      const v = Math.floor(Math.random()*100);\n      document.getElementById('insertVal').value = v;\n      tree.insertValue(v, true);\n    });\n    document.getElementById('btnBulk').addEventListener('click', async ()=>{\n      for(let i=0;i<10;i++){\n        const v = Math.floor(Math.random()*200);\n        document.getElementById('insertVal').value = v;\n        await tree.insertValue(v, true);\n        await tree.sleep(120);\n      }\n    });\n    document.getElementById('btnDelete').addEventListener('click', ()=>{\n      const v = Number(document.getElementById('deleteVal').value);\n      if(Number.isFinite(v)) tree.deleteValue(v, true);\n    });\n    document.getElementById('btnClear').addEventListener('click', ()=>{\n      // clear svg and tree\n      tree.root = null;\n      tree.nodeMap.forEach(g=>{ if(g.parentNode) g.parentNode.removeChild(g); });\n      tree.nodeMap.clear();\n      Array.from(svg.querySelectorAll('.edge')).forEach(e=> e.parentNode.removeChild(e));\n      tree.updateVisualization();\n      tree.setLast('Cleared tree');\n    });\n\n    document.getElementById('btnExample').addEventListener('click', async ()=>{\n      // classic example causing rotations: 11, 2, 14, 1, 7, 15, 5, 8, 4\n      const seq = [11,2,14,1,7,15,5,8,4];\n      for(let v of seq){ await tree.insertValue(v, true); await tree.sleep(150); }\n    });\n\n    // Initialize with small example\n    (async function init(){\n      tree.updateVisualization();\n      tree.setLast('Ready');\n    })();\n\n    // make svg responsive resizing\n    function fitView(){\n      svg.setAttribute('viewBox', '0 0 1200 600');\n    }\n    window.addEventListener('resize', fitView);\n    fitView();\n\n  })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Red-Black Tree"
    }
  ],
  "topic": "Red-Black Tree",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}