{
  "id": "3c8aaa30-ca6a-11f0-8bff-85107adc1779",
  "timestamp": "2025-11-26T01:51:10.579Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Linear Regression",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Linear Regression Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f5f5f5;\n  }\n  h1 {\n    text-align: center;\n  }\n  #container {\n    max-width: 900px;\n    margin: auto;\n    background: white;\n    padding: 20px;\n    box-shadow: 0 0 10px rgba(0,0,0,0.1);\n  }\n  #canvas-container {\n    text-align: center;\n    margin-bottom: 20px;\n  }\n  canvas {\n    border: 1px solid #ccc;\n    background-color: #fff;\n  }\n  #instructions {\n    margin-bottom: 15px;\n    font-size: 16px;\n    text-align: center;\n  }\n  #clear-btn {\n    display: block;\n    margin: 0 auto 20px;\n    background: #007bff;\n    color: white;\n    border: none;\n    padding: 10px 20px;\n    font-size: 16px;\n    cursor: pointer;\n    border-radius: 5px;\n  }\n  #clear-btn:hover {\n    background: #0056b3;\n  }\n  #equation {\n    text-align: center;\n    font-size: 20px;\n    font-weight: bold;\n    color: #333;\n  }\n  #footer {\n    text-align: center;\n    margin-top: 30px;\n    font-size: 13px;\n    color: #666;\n  }\n</style>\n</head>\n<body>\n<div id=\"container\">\n  <h1>Linear Regression Demo</h1>\n  <div id=\"instructions\">\n    Click on the canvas below to add data points. The blue line is the linear regression fit.\n  </div>\n  <div id=\"canvas-container\">\n    <canvas id=\"plot\" width=\"800\" height=\"500\"></canvas>\n  </div>\n  <button id=\"clear-btn\">Clear Points</button>\n  <div id=\"equation\">No points yet</div>\n</div>\n<div id=\"footer\">Demo by ChatGPT - Linear Regression Interactive Visualization</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('plot');\n  const ctx = canvas.getContext('2d');\n  const clearBtn = document.getElementById('clear-btn');\n  const equationDiv = document.getElementById('equation');\n\n  const width = canvas.width;\n  const height = canvas.height;\n  const margin = 50;\n\n  let points = [];\n\n  // Coordinate system will map data X,Y to canvas\n  // We'll map data x,y in dataCoords (real values) to canvas coords (pixels)\n  // We want to dynamically adjust axes scales to encompass points nicely\n\n  // We'll store data points as {x: num, y: num} in data coords\n\n  // Draw coordinate axes and labels\n  function drawAxes(xMin, xMax, yMin, yMax) {\n    ctx.clearRect(0, 0, width, height);\n\n    ctx.strokeStyle = \"#000\";\n    ctx.lineWidth = 2;\n\n    // X axis line\n    const yZero = mapY(0, yMin, yMax);\n    ctx.beginPath();\n    ctx.moveTo(margin, yZero);\n    ctx.lineTo(width - margin, yZero);\n    ctx.stroke();\n\n    // Y axis line\n    const xZero = mapX(0, xMin, xMax);\n    ctx.beginPath();\n    ctx.moveTo(xZero, margin);\n    ctx.lineTo(xZero, height - margin);\n    ctx.stroke();\n\n    ctx.fillStyle = \"#000\";\n    ctx.font = '12px Arial';\n\n    // Draw tick marks and labels on X axis\n    const xTicks = 8;\n    for(let i=0; i<= xTicks; i++) {\n      let xVal = xMin + (xMax - xMin)*i/xTicks;\n      let px = mapX(xVal, xMin, xMax);\n      let py = yZero;\n\n      ctx.beginPath();\n      ctx.moveTo(px, py - 5);\n      ctx.lineTo(px, py + 5);\n      ctx.stroke();\n\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      ctx.fillText(xVal.toFixed(2), px, py + 8);\n    }\n\n    // Draw tick marks and labels on Y axis\n    const yTicks = 8;\n    for(let i=0; i<= yTicks; i++) {\n      let yVal = yMin + (yMax - yMin)*i/yTicks;\n      let px = xZero;\n      let py = mapY(yVal, yMin, yMax);\n\n      ctx.beginPath();\n      ctx.moveTo(px - 5, py);\n      ctx.lineTo(px + 5, py);\n      ctx.stroke();\n\n      if (Math.abs(yVal) > (yMax - yMin) / 50) { \n      // avoid cluttering zero label with \"0.00\", just space it out a bit\n        ctx.textAlign = 'right';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(yVal.toFixed(2), px - 8, py);\n      }\n    }\n\n    // Axis labels\n    ctx.fillStyle = \"#333\";\n    ctx.font = '16px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('X', width/2, height - margin + 35);\n    ctx.textAlign = 'center';\n    ctx.save();\n    ctx.translate(margin - 35, height/2);\n    ctx.rotate(-Math.PI/2);\n    ctx.fillText('Y', 0, 0);\n    ctx.restore();\n  }\n\n  // Map data X to canvas X\n  function mapX(x, xMin, xMax) {\n    return margin + ((x - xMin) / (xMax - xMin)) * (width - 2*margin);\n  }\n  // Map data Y to canvas Y (y grows downward on canvas so we invert)\n  function mapY(y, yMin, yMax) {\n    return height - margin - ((y - yMin) / (yMax - yMin)) * (height - 2*margin);\n  }\n  // Inverse mapping: from canvas coord to data coord\n  function invMapX(px, xMin, xMax) {\n    return xMin + ((px - margin) / (width - 2*margin)) * (xMax - xMin);\n  }\n  function invMapY(py, yMin, yMax) {\n    return yMin + ((height - margin - py) / (height - 2*margin)) * (yMax - yMin);\n  }\n\n  // Compute linear regression coefficients: y = a*x + b\n  function linearRegression(data) {\n    const n = data.length;\n    if (n === 0) return null;\n    if (n === 1) return {a: 0, b: data[0].y}; // flat line at y\n\n    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;\n    for (let i = 0; i < n; i++) {\n      const p = data[i];\n      sumX += p.x;\n      sumY += p.y;\n      sumXY += p.x*p.y;\n      sumX2 += p.x*p.x;\n    }\n    const denominator = (n*sumX2 - sumX*sumX);\n    if (denominator === 0) {\n      // vertical line or all x are the same, return horizontal line at mean y\n      return {a: 0, b: sumY/n};\n    }\n    const a = (n*sumXY - sumX*sumY) / denominator;\n    const b = (sumY - a*sumX) / n;\n\n    return {a,b};\n  }\n\n  // Draw points\n  function drawPoints(data, xMin, xMax, yMin, yMax) {\n    ctx.fillStyle = '#d9534f';\n    data.forEach(p => {\n      const cx = mapX(p.x, xMin, xMax);\n      const cy = mapY(p.y, yMin, yMax);\n      ctx.beginPath();\n      ctx.arc(cx, cy, 6, 0, 2*Math.PI);\n      ctx.fill();\n      ctx.strokeStyle = '#a94442';\n      ctx.lineWidth = 1.5;\n      ctx.stroke();\n    });\n  }\n\n  // Draw regression line\n  function drawRegressionLine(coeffs, xMin, xMax, yMin, yMax) {\n    if (!coeffs) return;\n    let {a, b} = coeffs;\n\n    // Calculate y for the edges of the x range\n    const y1 = a*xMin + b;\n    const y2 = a*xMax + b;\n\n    // Clamp line to visible y range (optional)\n    // But here we just clip line to canvas by points\n\n    // Map to canvas coordinates\n    const x1 = mapX(xMin, xMin, xMax);\n    const y1c = mapY(y1, yMin, yMax);\n    const x2 = mapX(xMax, xMin, xMax);\n    const y2c = mapY(y2, yMin, yMax);\n\n    ctx.strokeStyle = '#337ab7';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1c);\n    ctx.lineTo(x2, y2c);\n    ctx.stroke();\n  }\n\n  // Calculate nice axis bounds with some padding\n  function calculateBounds(data) {\n    if (data.length === 0) {\n      return {xMin: -10, xMax: 10, yMin: -10, yMax: 10};\n    }\n    let xs = data.map(p => p.x);\n    let ys = data.map(p => p.y);\n\n    let xMin = Math.min(...xs);\n    let xMax = Math.max(...xs);\n    let yMin = Math.min(...ys);\n    let yMax = Math.max(...ys);\n\n    // Add 10% padding or min 1 unit\n    let xPadding = Math.max((xMax - xMin)*0.1, 1);\n    let yPadding = Math.max((yMax - yMin)*0.1, 1);\n\n    if (xMin === xMax) {\n      xMin -= 5;\n      xMax += 5;\n    } else {\n      xMin -= xPadding;\n      xMax += xPadding;\n    }\n\n    if (yMin === yMax) {\n      yMin -= 5;\n      yMax += 5;\n    } else {\n      yMin -= yPadding;\n      yMax += yPadding;\n    }\n    return {xMin, xMax, yMin, yMax};\n  }\n\n  // Main redraw function\n  function redraw() {\n    const bounds = calculateBounds(points);\n    drawAxes(bounds.xMin, bounds.xMax, bounds.yMin, bounds.yMax);\n    drawPoints(points, bounds.xMin, bounds.xMax, bounds.yMin, bounds.yMax);\n    if (points.length > 1) {\n      const coeffs = linearRegression(points);\n      drawRegressionLine(coeffs, bounds.xMin, bounds.xMax, bounds.yMin, bounds.yMax);\n      equationDiv.textContent = `y = ${coeffs.a.toFixed(4)}x + ${coeffs.b.toFixed(4)}`;\n    } else if (points.length === 1) {\n      equationDiv.textContent = `Only one point: y = ${points[0].y.toFixed(4)}`;\n    } else {\n      equationDiv.textContent = 'No points yet';\n    }\n  }\n\n  // Handle user clicking on canvas to add points\n  canvas.addEventListener('click', e => {\n    const rect = canvas.getBoundingClientRect();\n    const px = e.clientX - rect.left;\n    const py = e.clientY - rect.top;\n\n    // We map px, py to data coords base on current bounds\n    const bounds = calculateBounds(points);\n    const xVal = invMapX(px, bounds.xMin, bounds.xMax);\n    const yVal = invMapY(py, bounds.yMin, bounds.yMax);\n\n    points.push({x: xVal, y: yVal});\n\n    redraw();\n  });\n\n  // Clear points button\n  clearBtn.addEventListener('click', () => {\n    points = [];\n    redraw();\n  });\n\n  // Initial draw with no points\n  redraw();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Linear Regression"
    }
  ],
  "topic": "Linear Regression",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}