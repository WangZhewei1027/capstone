{
  "id": "3c888750-ca6a-11f0-8bff-85107adc1779",
  "timestamp": "2025-11-26T01:51:26.540Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Weighted Graph Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    background: #f0f0f0;\n    display: flex; flex-direction: column; align-items: center;\n    height: 100vh;\n  }\n  h1 {\n    margin-top: 1rem;\n    color: #333;\n  }\n  #graphCanvas {\n    border: 1px solid #999;\n    background: #fff;\n    margin-top: 1rem;\n    cursor: pointer;\n  }\n  #info {\n    margin-top: 10px;\n    width: 600px;\n    text-align: center;\n    color: #555;\n  }\n  #controls {\n    margin-top: 10px;\n  }\n  button {\n    margin: 0 5px;\n    padding: 6px 12px;\n    font-size: 14px;\n    cursor: pointer;\n  }\n  #pathResult {\n    margin-top: 15px;\n    font-size: 14px;\n    font-weight: 600;\n    color: #222;\n  }\n</style>\n</head>\n<body>\n<h1>Weighted Graph Visualization & Dijkstra's Shortest Path</h1>\n<canvas id=\"graphCanvas\" width=\"600\" height=\"600\" aria-label=\"Weighted graph visualization\"></canvas>\n<div id=\"info\">\n  <p><strong>Instructions:</strong> Click on nodes to set <em>Start</em> and <em>End</em> nodes for shortest path.</p>\n  <p>Edges show their weights. The shortest path (if calculated) is highlighted in red.</p>\n</div>\n<div id=\"controls\">\n  <button id=\"resetSelection\">Reset Start/End Selection</button>\n  <button id=\"randomizeGraph\">Randomize Graph</button>\n</div>\n<div id=\"pathResult\" aria-live=\"polite\"></div>\n\n<script>\n(() => {\n  const canvas = document.getElementById(\"graphCanvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const width = canvas.width;\n  const height = canvas.height;\n\n  // Parameters for graph layout & nodes\n  const nodeRadius = 20;\n  const numNodes = 9;\n\n  // Graph data structures\n  // nodes: array of {id, x, y}\n  // edges: array of {from, to, weight}\n\n  // Generate a weighted graph arranged roughly in a circle but can randomize positions\n  function generateGraph() {\n    const nodes = [];\n    const edges = [];\n    // Place nodes evenly around a circle\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const radius = 220;\n\n    for (let i = 0; i < numNodes; i++) {\n      let angle = (2 * Math.PI * i) / numNodes;\n      // Slight random offset for more organic feel\n      let x = centerX + radius * Math.cos(angle) + (Math.random() - 0.5) * 30;\n      let y = centerY + radius * Math.sin(angle) + (Math.random() - 0.5) * 30;\n      nodes.push({ id: i, x, y });\n    }\n\n    // Connect nodes with weighted edges to form a connected graph\n    // We'll create edges to neighbors + some random other edges\n\n    // Ensuring the graph is connected by connecting nodes in a ring first\n    for (let i = 0; i < numNodes; i++) {\n      let from = i;\n      let to = (i + 1) % numNodes;\n      let weight = Math.floor(1 + Math.random() * 15);\n      edges.push({ from, to, weight });\n      edges.push({ from: to, to: from, weight }); // undirected graph so add both directions\n    }\n\n    // Add some random extra edges for complexity\n    for (let i = 0; i < numNodes * 2; i++) {\n      let from = Math.floor(Math.random() * numNodes);\n      let to = Math.floor(Math.random() * numNodes);\n      if (from !== to && !edges.find(e => e.from === from && e.to === to)) {\n        let weight = Math.floor(1 + Math.random() * 15);\n        edges.push({ from, to, weight });\n        edges.push({ from: to, to: from, weight });\n      }\n    }\n\n    return { nodes, edges };\n  }\n\n  // Draw node as circle with label\n  function drawNode(node, highlight = false, role = null) {\n    ctx.beginPath();\n    ctx.arc(node.x, node.y, nodeRadius, 0, 2 * Math.PI);\n    ctx.fillStyle = highlight ? \"#ff6666\" : \"#4a90e2\";\n    ctx.fill();\n    ctx.strokeStyle = \"#333\";\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    if (role === \"start\") {\n      ctx.fillStyle = \"#0a0\";\n      ctx.font = \"bold 16px Arial\";\n      ctx.fillText(\"S\", node.x - 7, node.y + 6);\n    } else if (role === \"end\") {\n      ctx.fillStyle = \"#a00\";\n      ctx.font = \"bold 16px Arial\";\n      ctx.fillText(\"E\", node.x - 7, node.y + 6);\n    } else {\n      ctx.fillStyle = \"#fff\";\n      ctx.font = \"bold 14px Arial\";\n      ctx.fillText(node.id, node.x - 5, node.y + 5);\n    }\n  }\n\n  // Draw edge as line with weight label\n  function drawEdge(edge, highlight = false) {\n    const fromNode = nodes[edge.from];\n    const toNode = nodes[edge.to];\n\n    // Draw line\n    ctx.strokeStyle = highlight ? \"#ff0000\" : \"#666\";\n    ctx.lineWidth = highlight ? 4 : 1.8;\n    ctx.beginPath();\n    ctx.moveTo(fromNode.x, fromNode.y);\n    ctx.lineTo(toNode.x, toNode.y);\n    ctx.stroke();\n\n    // Draw arrowhead for direction (optional, but undirected graph so skip arrow)\n\n    // Draw weight label midway\n    const midX = (fromNode.x + toNode.x) / 2;\n    const midY = (fromNode.y + toNode.y) / 2;\n\n    // Offset text slightly perpendicular to edge direction\n    const dx = toNode.x - fromNode.x;\n    const dy = toNode.y - fromNode.y;\n    const offset = 12;\n    const len = Math.sqrt(dx * dx + dy * dy);\n    const textX = midX - (dy / len) * offset;\n    const textY = midY + (dx / len) * offset;\n\n    ctx.fillStyle = highlight ? \"#ff0000\" : \"#222\";\n    ctx.font = \"14px Arial\";\n    ctx.fillText(edge.weight, textX, textY);\n  }\n\n  // Draw entire graph\n  function drawGraph() {\n    ctx.clearRect(0, 0, width, height);\n\n    // Draw edges first\n    for (const edge of edges) {\n      // To avoid double drawing weights on undirected edges, draw only if from < to\n      // (But since stored both directions, skip duplicates)\n      if (edge.from < edge.to) {\n        let highlighting = false;\n        if (shortestPathEdges.has(edgeKey(edge.from, edge.to))) {\n          highlighting = true;\n        }\n        drawEdge(edge, highlighting);\n      }\n    }\n\n    // Draw nodes\n    for (const node of nodes) {\n      let role = null;\n      if (startNode !== null && node.id === startNode) role = \"start\";\n      if (endNode !== null && node.id === endNode) role = \"end\";\n      let highlight = false;\n      // Highlight nodes on shortest path also\n      if (shortestPathNodes.has(node.id)) highlight = true;\n      drawNode(node, highlight, role);\n    }\n  }\n\n  // Utility to generate a unique key for an edge ignoring direction since graph is undirected\n  function edgeKey(a, b) {\n    return a < b ? `${a}-${b}` : `${b}-${a}`;\n  }\n\n  // Find node under mouse position\n  function getNodeAtPosition(x, y) {\n    for (const node of nodes) {\n      const dx = x - node.x;\n      const dy = y - node.y;\n      if (dx * dx + dy * dy <= nodeRadius * nodeRadius) return node;\n    }\n    return null;\n  }\n\n  // Dijkstra's shortest path algorithm\n  function dijkstra(nodes, edges, source, target) {\n    const dist = new Array(nodes.length).fill(Infinity);\n    const prev = new Array(nodes.length).fill(null);\n    dist[source] = 0;\n\n    // Build adjacency list\n    const adj = new Map();\n    for(let n=0;n<nodes.length;n++){\n      adj.set(n, []);\n    }\n    for (const e of edges) {\n      adj.get(e.from).push({ node: e.to, weight: e.weight });\n    }\n\n    const visited = new Set();\n\n    while (true) {\n      // select unvisited node with smallest dist\n      let u = null;\n      let uDist = Infinity;\n      for (let i = 0; i < nodes.length; i++) {\n        if (!visited.has(i) && dist[i] < uDist) {\n          uDist = dist[i];\n          u = i;\n        }\n      }\n      if (u === null || u === target) break;\n      visited.add(u);\n\n      // relax edges\n      for (const neighbor of adj.get(u)) {\n        if (visited.has(neighbor.node)) continue;\n        const alt = dist[u] + neighbor.weight;\n        if (alt < dist[neighbor.node]) {\n          dist[neighbor.node] = alt;\n          prev[neighbor.node] = u;\n        }\n      }\n    }\n\n    // Reconstruct path\n    if (dist[target] === Infinity) {\n      return { distance: Infinity, path: [] };\n    }\n    const path = [];\n    for (let at = target; at !== null; at = prev[at]) {\n      path.push(at);\n    }\n    path.reverse();\n    return { distance: dist[target], path };\n  }\n\n  // Variables \n  let { nodes, edges } = generateGraph();\n\n  // State for start and end selection\n  let startNode = null;\n  let endNode = null;\n\n  // To highlight shortest path edges and nodes\n  let shortestPathEdges = new Set();\n  let shortestPathNodes = new Set();\n\n  // Draw initial graph\n  drawGraph();\n\n  // Handle canvas clicks\n  canvas.addEventListener(\"click\", e => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n\n    const clicked = getNodeAtPosition(mx, my);\n    if (clicked === null) return;\n\n    if (startNode === null) {\n      startNode = clicked.id;\n      shortestPathEdges.clear();\n      shortestPathNodes.clear();\n      drawGraph();\n      updatePathResult();\n    } else if (endNode === null && clicked.id !== startNode) {\n      endNode = clicked.id;\n      calculateAndShowPath();\n    } else {\n      // Both start and end set -> reset and start new start selection with clicked node\n      startNode = clicked.id;\n      endNode = null;\n      shortestPathEdges.clear();\n      shortestPathNodes.clear();\n      drawGraph();\n      updatePathResult();\n    }\n  });\n\n  // Calculate and highlight shortest path\n  function calculateAndShowPath() {\n    if (startNode === null || endNode === null) return;\n\n    const result = dijkstra(nodes, edges, startNode, endNode);\n    shortestPathEdges.clear();\n    shortestPathNodes.clear();\n\n    if (result.distance === Infinity) {\n      // no path\n      updatePathResult(\"No path found between selected nodes.\");\n    } else {\n      // highlight nodes and edges in path\n      result.path.forEach(n => shortestPathNodes.add(n));\n      // add edges between path nodes\n      for (let i = 0; i < result.path.length - 1; i++) {\n        shortestPathEdges.add(edgeKey(result.path[i], result.path[i + 1]));\n      }\n\n      updatePathResult(`Shortest path distance: ${result.distance}, Path: ${result.path.join(\" â†’ \")}`);\n    }\n    drawGraph();\n  }\n\n  // Update textual path result info\n  function updatePathResult(msg = \"\") {\n    const div = document.getElementById(\"pathResult\");\n    if (msg) {\n      div.textContent = msg;\n    } else if (startNode === null) {\n      div.textContent = \"Click a node to select Start node.\";\n    } else if (endNode === null) {\n      div.textContent = `Start node selected: ${startNode}. Click another node to select End node.`;\n    } else {\n      div.textContent = \"\";\n    }\n  }\n\n  // Initial info message\n  updatePathResult();\n\n  // Reset selection button\n  document.getElementById(\"resetSelection\").addEventListener(\"click\", () => {\n    startNode = null;\n    endNode = null;\n    shortestPathEdges.clear();\n    shortestPathNodes.clear();\n    drawGraph();\n    updatePathResult();\n  });\n\n  // Randomize graph button\n  document.getElementById(\"randomizeGraph\").addEventListener(\"click\", () => {\n    startNode = null;\n    endNode = null;\n    shortestPathEdges.clear();\n    shortestPathNodes.clear();\n    const g = generateGraph();\n    nodes = g.nodes;\n    edges = g.edges;\n    drawGraph();\n    updatePathResult();\n  });\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}