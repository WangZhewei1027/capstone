{
  "id": "3c8998c0-ca6a-11f0-8bff-85107adc1779",
  "timestamp": "2025-11-26T01:51:45.072Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Breadth-First Search (BFS) Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    display: flex;\n    height: 100vh;\n    overflow: hidden;\n  }\n  #leftPanel {\n    width: 320px;\n    background: #f7f7f7;\n    padding: 20px;\n    box-sizing: border-box;\n    border-right: 1px solid #ccc;\n    overflow-y: auto;\n  }\n  #graphCanvas {\n    flex-grow: 1;\n    background: #222;\n    display: block;\n  }\n  h1 {\n    font-size: 1.5rem;\n    margin-top: 0;\n  }\n  label {\n    display: block;\n    margin-top: 15px;\n    font-weight: bold;\n  }\n  input[type=\"text\"], select {\n    width: 100%;\n    padding: 7px;\n    margin-top: 5px;\n    box-sizing: border-box;\n    font-family: monospace;\n  }\n  button {\n    margin-top: 20px;\n    background: #0078d7;\n    border: none;\n    color: white;\n    font-size: 1rem;\n    padding: 10px;\n    width: 100%;\n    cursor: pointer;\n    border-radius: 3px;\n    transition: background 0.3s;\n  }\n  button:hover {\n    background: #005ea1;\n  }\n  #steps {\n    margin-top: 20px;\n    max-height: 200px;\n    overflow-y: auto;\n    background: #fff;\n    border: 1px solid #ccc;\n    padding: 10px;\n    font-size: 0.85rem;\n    line-height: 1.4;\n    white-space: pre-wrap;\n    user-select: none;\n  }\n  #legend {\n    margin-top: 20px;\n    font-size: 0.9rem;\n    background: #fff;\n    padding: 10px;\n    border: 1px solid #ccc;\n    line-height: 1.4;\n  }\n  .color-box {\n    display: inline-block;\n    width: 15px;\n    height: 15px;\n    vertical-align: middle;\n    margin-right: 6px;\n    border-radius: 3px;\n  }\n  #info {\n    margin-top: 20px;\n    font-size: 0.9rem;\n    color: #555;\n  }\n  a {\n    color: #0078d7;\n    text-decoration: none;\n  }\n  a:hover {\n    text-decoration: underline;\n  }\n</style>\n</head>\n<body>\n<div id=\"leftPanel\">\n  <h1>Breadth-First Search (BFS) Demo</h1>\n  <label for=\"graphInput\">Graph Adjacency List (JSON)</label>\n  <textarea id=\"graphInput\" rows=\"10\" style=\"width:100%; font-family: monospace; font-size:14px;\">{\n  \"A\": [\"B\", \"C\"],\n  \"B\": [\"A\", \"D\", \"E\"],\n  \"C\": [\"A\", \"F\"],\n  \"D\": [\"B\"],\n  \"E\": [\"B\", \"F\"],\n  \"F\": [\"C\", \"E\"]\n}</textarea>\n\n  <label for=\"startNode\">Start Node</label>\n  <input type=\"text\" id=\"startNode\" value=\"A\" maxlength=\"2\" />\n\n  <button id=\"runBFS\">Run BFS</button>\n\n  <div id=\"info\">\n    Edit the graph adjacency list in JSON format.<br />\n    Each key is a node and its value is an array of neighboring nodes.<br />\n    Maximum 15 nodes recommended.<br />\n    <br />\n    Nodes are automatically laid out in a circle.<br />\n    Click \"Run BFS\" to see the order in which nodes are visited.<br />\n  </div>\n\n  <div id=\"legend\">\n    <div><span class=\"color-box\" style=\"background:#555;\"></span> Unvisited node</div>\n    <div><span class=\"color-box\" style=\"background:#f39c12;\"></span> In queue (frontier)</div>\n    <div><span class=\"color-box\" style=\"background:#27ae60;\"></span> Visited node</div>\n    <div><span class=\"color-box\" style=\"background:#2980b9;\"></span> Current processing node</div>\n  </div>\n\n  <div id=\"steps\"></div>\n</div>\n\n<canvas id=\"graphCanvas\"></canvas>\n\n<script>\n(() => {\n  const canvas = document.getElementById(\"graphCanvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const graphInput = document.getElementById(\"graphInput\");\n  const startNodeInput = document.getElementById(\"startNode\");\n  const runBtn = document.getElementById(\"runBFS\");\n  const stepsDiv = document.getElementById(\"steps\");\n\n  let WIDTH, HEIGHT;\n  const nodeRadius = 22;\n\n  let graph = {};\n  let nodes = []; // sorted list of nodes\n  let positions = {}; // node => {x,y}\n\n  // BFS state\n  let queue = [];\n  let visited = new Set();\n  let processing = null;\n  let bfsSteps = [];\n  let stepIndex = 0;\n  let timer = null;\n\n  function resize() {\n    WIDTH = window.innerWidth - 320;\n    HEIGHT = window.innerHeight;\n    canvas.width = WIDTH;\n    canvas.height = HEIGHT;\n  }\n  window.addEventListener(\"resize\", resize);\n  resize();\n\n  function parseGraph(input) {\n    try {\n      const obj = JSON.parse(input);\n      // Validate: keys and neighbors are strings, neighbors is array\n      for (const k in obj) {\n        if (!Array.isArray(obj[k])) throw new Error(\"Neighbors must be arrays.\");\n        for (const n of obj[k]) {\n          if (typeof n !== \"string\") throw new Error(\"Neighbor nodes must be strings.\");\n        }\n      }\n      return obj;\n    } catch (e) {\n      alert(\"Invalid JSON adjacency list:\\n\" + e.message);\n      return null;\n    }\n  }\n\n  // Automatically compute positions in a circle centered inside canvas\n  function layoutNodes(nodes) {\n    const centerX = WIDTH / 2;\n    const centerY = HEIGHT / 2;\n    const radius = Math.min(WIDTH, HEIGHT) / 2 - 80;\n    const pos = {};\n    const count = nodes.length;\n    nodes.forEach((node, i) => {\n      const angle = (2 * Math.PI * i) / count - Math.PI / 2; // start at top\n      pos[node] = {\n        x: centerX + radius * Math.cos(angle),\n        y: centerY + radius * Math.sin(angle),\n      };\n    });\n    return pos;\n  }\n\n  function drawNode(node, color, borderColor) {\n    const { x, y } = positions[node];\n    ctx.beginPath();\n    ctx.fillStyle = color;\n    ctx.strokeStyle = borderColor || \"#111\";\n    ctx.lineWidth = 2;\n    ctx.shadowColor = \"rgba(0,0,0,0.6)\";\n    ctx.shadowBlur = 4;\n    ctx.shadowOffsetX = 1;\n    ctx.shadowOffsetY = 1;\n    ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.stroke();\n    ctx.shadowBlur = 0;\n    ctx.shadowOffsetX = 0;\n    ctx.shadowOffsetY = 0;\n\n    // Text (node label)\n    ctx.fillStyle = \"#fff\";\n    ctx.font = \"bold 18px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(node, x, y);\n  }\n\n  function drawEdge(n1, n2, color, width = 2) {\n    const p1 = positions[n1];\n    const p2 = positions[n2];\n\n    // Draw line with arrow\n    ctx.strokeStyle = color;\n    ctx.lineWidth = width;\n    ctx.beginPath();\n    ctx.moveTo(p1.x, p1.y);\n    ctx.lineTo(p2.x, p2.y);\n    ctx.stroke();\n\n    // Draw arrowhead\n    const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n    const arrowLength = 10;\n    ctx.beginPath();\n    ctx.moveTo(p2.x, p2.y);\n    ctx.lineTo(p2.x - arrowLength * Math.cos(angle - Math.PI / 6), p2.y - arrowLength * Math.sin(angle - Math.PI / 6));\n    ctx.lineTo(p2.x - arrowLength * Math.cos(angle + Math.PI / 6), p2.y - arrowLength * Math.sin(angle + Math.PI / 6));\n    ctx.lineTo(p2.x, p2.y);\n    ctx.fillStyle = color;\n    ctx.fill();\n  }\n\n  // For an undirected graph, draw each edge once.\n  function drawGraph(currentNode = null, queueSet = new Set(), visitedSet = new Set()) {\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Draw edges\n    const drawnEdges = new Set();\n    for (const node of nodes) {\n      for (const neighbor of graph[node]) {\n        // Create a unique id for edge so we don't draw twice in undirected graph\n        const edgeId = [node, neighbor].sort().join(\"__\");\n        if (!drawnEdges.has(edgeId)) {\n          drawnEdges.add(edgeId);\n          drawEdge(node, neighbor, \"#ccc\", 1.5);\n        }\n      }\n    }\n\n    // Draw nodes with colors based on state\n    for (const node of nodes) {\n      if (node === currentNode) {\n        drawNode(node, \"#2980b9\");\n      } else if (visitedSet.has(node)) {\n        drawNode(node, \"#27ae60\");\n      } else if (queueSet.has(node)) {\n        drawNode(node, \"#f39c12\");\n      } else {\n        drawNode(node, \"#555\");\n      }\n    }\n  }\n\n  function sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  async function animateBFS(start) {\n    const visitedSet = new Set();\n    const queueArr = [];\n    const stepsLog = [];\n\n    if (!graph.hasOwnProperty(start)) {\n      alert(\"Start node not found in graph.\");\n      return;\n    }\n\n    queueArr.push(start);\n    visitedSet.add(start);\n\n    stepsLog.push(`Enqueued start node: ${start}`);\n    drawGraph(null, new Set(queueArr), visitedSet);\n    await sleep(1000);\n\n    while (queueArr.length > 0) {\n      const current = queueArr.shift();\n      stepsLog.push(`Dequeued node: ${current} (processing)`);\n      drawGraph(current, new Set(queueArr), visitedSet);\n      stepsDiv.textContent = stepsLog.join(\"\\n\");\n      await sleep(1200);\n\n      for (const neighbor of graph[current]) {\n        if (!visitedSet.has(neighbor)) {\n          visitedSet.add(neighbor);\n          queueArr.push(neighbor);\n          stepsLog.push(`  -> Enqueued neighbor: ${neighbor}`);\n          drawGraph(current, new Set(queueArr), visitedSet);\n          stepsDiv.textContent = stepsLog.join(\"\\n\");\n          await sleep(1000);\n        }\n      }\n      stepsLog.push(`Finished processing node: ${current}\\n`);\n      drawGraph(null, new Set(queueArr), visitedSet);\n      stepsDiv.textContent = stepsLog.join(\"\\n\");\n      await sleep(800);\n    }\n\n    stepsLog.push(\"BFS complete! All reachable nodes visited.\");\n    stepsDiv.textContent = stepsLog.join(\"\\n\");\n    drawGraph(null, new Set(), visitedSet);\n  }\n\n  runBtn.addEventListener(\"click\", () => {\n    if (timer) {\n      // Cancel any ongoing animation\n      timer = null;\n    }\n    const g = parseGraph(graphInput.value);\n    if (!g) return;\n\n    graph = g;\n    // Sort nodes by name for consistency\n    nodes = Object.keys(graph).sort();\n    if (nodes.length > 15) {\n      alert(\"Warning: too many nodes might slow down the visualization (max 15 recommended).\");\n    }\n    positions = layoutNodes(nodes);\n\n    stepsDiv.textContent = \"\";\n    drawGraph();\n\n    const start = startNodeInput.value.trim();\n    if (!start) {\n      alert(\"Please enter a start node.\");\n      return;\n    }\n\n    animateBFS(start);\n  });\n\n  // Initial draw\n  graph = parseGraph(graphInput.value);\n  nodes = Object.keys(graph).sort();\n  positions = layoutNodes(nodes);\n  drawGraph();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}