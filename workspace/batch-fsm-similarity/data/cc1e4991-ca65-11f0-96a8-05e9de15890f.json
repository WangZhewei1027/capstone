{
  "id": "cc1e4991-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:22:20.319Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Dijkstra's Algorithm — Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#06b6d4;\n      --muted:#9aa6b2;\n      --card:#071224;\n      --good:#16a34a;\n      --warn:#f59e0b;\n      --danger:#ef4444;\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;}\n    body{background:linear-gradient(180deg,#071226 0%, #07182b 100%); color:#e6eef3; display:flex; gap:12px; padding:12px; box-sizing:border-box;}\n    .left {\n      width:360px;\n      min-width:260px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      border-radius:12px;\n      padding:12px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:10px;\n      height:calc(100vh - 24px);\n      overflow:auto;\n    }\n    .title{font-weight:700;font-size:18px;display:flex;align-items:center;gap:8px}\n    .controls{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}\n    button, select, input[type=number]{\n      background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px;border-radius:8px;\n      cursor:pointer;\n    }\n    button.primary{background:linear-gradient(90deg,var(--accent),#0ea5a0);color:#042025;border:font-weight:700;}\n    .modes{display:flex;gap:6px;flex-wrap:wrap}\n    .mode-btn{flex:1;padding:8px;border-radius:8px;text-align:center}\n    .mode-btn.active{background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.06);color:#fff}\n    .section{background:transparent;border-radius:8px;padding:8px;display:flex;flex-direction:column;gap:8px}\n    label{font-size:13px;color:var(--muted)}\n    .row{display:flex;gap:8px;align-items:center}\n    .small{font-size:12px;color:var(--muted)}\n    .log{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:8px;padding:8px;height:160px;overflow:auto;font-family:monospace;font-size:12px;color:#d8eef2;border:1px solid rgba(255,255,255,0.03)}\n    .stats{display:flex;gap:8px;flex-wrap:wrap}\n    .stat{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;flex:1;text-align:center}\n    .svg-wrap{flex:1;background:transparent;border-radius:12px;overflow:hidden;position:relative}\n    svg{width:100%;height:100%;display:block;touch-action:none}\n    .hint{font-size:12px;color:var(--muted)}\n    .footer{font-size:12px;color:var(--muted); text-align:center;}\n    .top-row{display:flex;gap:8px;align-items:center;justify-content:space-between}\n    input[type=range]{width:100%}\n    .node-label{font-size:12px;pointer-events:none;}\n    .edge-weight{font-size:12px;pointer-events:none;fill:#e6eef3}\n    .btn-row{display:flex;gap:8px}\n    .mini{padding:6px;font-size:13px}\n  </style>\n</head>\n<body>\n  <div class=\"left\">\n    <div class=\"title\">\n      <div style=\"width:36px;height:36px;border-radius:8px;background:linear-gradient(90deg,var(--accent),#0ea5a0);display:flex;align-items:center;justify-content:center;color:#012426;font-weight:700\">D</div>\n      <div>\n        Dijkstra's Algorithm\n        <div style=\"font-size:12px;color:var(--muted)\">Interactive visualizer — non-negative weights</div>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <div class=\"top-row\">\n        <div class=\"modes\" style=\"flex:1\">\n          <div class=\"mode-btn active\" id=\"mode-addnode\" data-mode=\"addNode\">Add Node</div>\n          <div class=\"mode-btn\" id=\"mode-addedge\" data-mode=\"addEdge\">Add Edge</div>\n          <div class=\"mode-btn\" id=\"mode-move\" data-mode=\"move\">Move</div>\n          <div class=\"mode-btn\" id=\"mode-delete\" data-mode=\"delete\">Delete</div>\n        </div>\n      </div>\n\n      <div class=\"row\">\n        <label style=\"flex:1\">\n          Directed edges by default\n          <input type=\"checkbox\" id=\"default-directed\" style=\"margin-left:8px\">\n        </label>\n      </div>\n\n      <div class=\"row\">\n        <button id=\"btn-random\" class=\"mini\">Generate Random Graph</button>\n        <button id=\"btn-clear\" class=\"mini\">Clear</button>\n      </div>\n\n      <div class=\"row\">\n        <label style=\"flex:1\">Nodes:\n          <span id=\"node-count\" class=\"small\">0</span>\n        </label>\n        <label style=\"flex:1\">Edges:\n          <span id=\"edge-count\" class=\"small\">0</span>\n        </label>\n      </div>\n\n    </div>\n\n    <div class=\"section\">\n      <div style=\"display:flex;gap:8px;align-items:center;\">\n        <button id=\"set-source\" class=\"primary\">Set Source</button>\n        <button id=\"set-target\">Set Target</button>\n        <button id=\"clear-sets\" title=\"Clear source/target\">Clear</button>\n      </div>\n\n      <div class=\"row\" style=\"gap:6px;\">\n        <button id=\"init-run\" class=\"primary\">Run →</button>\n        <button id=\"step\" class=\"mini\">Step</button>\n        <button id=\"auto\" class=\"mini\">Auto</button>\n        <button id=\"reset-algo\" class=\"mini\">Reset Algo</button>\n        <label style=\"flex:1\">\n          Speed\n          <input type=\"range\" id=\"speed\" min=\"0.1\" max=\"2.5\" step=\"0.1\" value=\"1\">\n        </label>\n      </div>\n\n      <div class=\"row\">\n        <label style=\"flex:1\">Current source: <span id=\"source-show\" class=\"small\">—</span></label>\n        <label style=\"flex:1\">Current target: <span id=\"target-show\" class=\"small\">—</span></label>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center\">\n        <div style=\"font-weight:700\">Algorithm log</div>\n        <div class=\"small\">Step-by-step</div>\n      </div>\n      <div id=\"log\" class=\"log\"></div>\n      <div style=\"display:flex;gap:8px;margin-top:6px\">\n        <button id=\"export-image\" class=\"mini\">Export PNG</button>\n        <button id=\"export-json\" class=\"mini\">Export JSON</button>\n        <button id=\"import-json\" class=\"mini\">Import JSON</button>\n      </div>\n    </div>\n\n    <div style=\"display:flex;gap:8px;\">\n      <div style=\"flex:1\" class=\"small\">Instructions: Add nodes by clicking the canvas. In \"Add Edge\" mode click source then target and enter weight. Use Move to reposition nodes. Choose a source then Run or Step.</div>\n    </div>\n\n    <div class=\"footer\">Non-negative weights only • Demo &nbsp;|&nbsp; Click node to select in modes</div>\n  </div>\n\n  <div class=\"svg-wrap\" id=\"graph-wrap\" style=\"flex:1\">\n    <svg id=\"svg\" viewBox=\"0 0 1600 900\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n  </div>\n\n  <script>\n    // Basic utilities\n    const svg = document.getElementById('svg');\n    const wrap = document.getElementById('graph-wrap');\n    const logEl = document.getElementById('log');\n\n    let nodes = []; // {id,x,y}\n    let edges = []; // {id,source,target,weight,directed}\n    let nextNodeId = 1;\n    let nextEdgeId = 1;\n\n    // Mode handling\n    let mode = 'addNode';\n    let modeButtons = document.querySelectorAll('.mode-btn');\n    modeButtons.forEach(b=>{\n      b.addEventListener('click', ()=>{\n        modeButtons.forEach(x=>x.classList.remove('active'));\n        b.classList.add('active');\n        mode = b.dataset.mode;\n        selectedForEdge = null;\n      });\n    });\n\n    // Defaults\n    const defaultDirectedCheckbox = document.getElementById('default-directed');\n\n    // Selection state for adding edges\n    let selectedForEdge = null;\n\n    // Source/Target\n    let sourceNode = null;\n    let targetNode = null;\n\n    // Algorithm state\n    let algoState = null;\n    let autoplay = false;\n    let autoplayTimer = null;\n\n    // Visual elements caches\n    const gEdges = document.createElementNS('http://www.w3.org/2000/svg','g');\n    const gEdgeWeights = document.createElementNS('http://www.w3.org/2000/svg','g');\n    const gNodes = document.createElementNS('http://www.w3.org/2000/svg','g');\n    svg.appendChild(gEdges);\n    svg.appendChild(gEdgeWeights);\n    svg.appendChild(gNodes);\n\n    // Mouse handling\n    let isDragging = false;\n    let dragNode = null;\n    let dragOffset = {x:0,y:0};\n\n    // Utility: log\n    function log(msg){\n      const at = new Date().toLocaleTimeString();\n      logEl.innerHTML = `<div>[${at}] ${msg}</div>` + logEl.innerHTML;\n    }\n\n    // Helpers: counts\n    function updateCounts(){\n      document.getElementById('node-count').textContent = nodes.length;\n      document.getElementById('edge-count').textContent = edges.length;\n      document.getElementById('source-show').textContent = sourceNode===null? '—' : 'Node '+sourceNode;\n      document.getElementById('target-show').textContent = targetNode===null? '—' : 'Node '+targetNode;\n    }\n\n    // Create node\n    function createNode(x,y){\n      const id = nextNodeId++;\n      nodes.push({id,x,y});\n      draw();\n      updateCounts();\n      return id;\n    }\n\n    // Create edge\n    function createEdge(s,t,w,directed=false){\n      const id = nextEdgeId++;\n      edges.push({id,source:s,target:t,weight:Number(w),directed:Boolean(directed)});\n      draw();\n      updateCounts();\n      return id;\n    }\n\n    // Remove node and connected edges\n    function removeNode(id){\n      nodes = nodes.filter(n=>n.id!==id);\n      edges = edges.filter(e=> e.source!==id && e.target!==id);\n      if (sourceNode===id) sourceNode=null;\n      if (targetNode===id) targetNode=null;\n      draw();\n      updateCounts();\n    }\n\n    // Remove edge by id\n    function removeEdge(id){\n      edges = edges.filter(e=>e.id!==id);\n      draw();\n      updateCounts();\n    }\n\n    // Find node at coords\n    function nodeAt(x,y){\n      for (let i=nodes.length-1;i>=0;i--){\n        const n = nodes[i];\n        const dx = x - n.x;\n        const dy = y - n.y;\n        if (Math.hypot(dx,dy) <= 26) return n;\n      }\n      return null;\n    }\n\n    // SVG coordinate conversion\n    function clientToSVG(cx,cy){\n      const pt = svg.createSVGPoint();\n      pt.x = cx; pt.y = cy;\n      const sp = pt.matrixTransform(svg.getScreenCTM().inverse());\n      return {x:sp.x, y:sp.y};\n    }\n\n    // Drawing\n    function clearSVG(){\n      while(gEdges.firstChild) gEdges.removeChild(gEdges.firstChild);\n      while(gEdgeWeights.firstChild) gEdgeWeights.removeChild(gEdgeWeights.firstChild);\n      while(gNodes.firstChild) gNodes.removeChild(gNodes.firstChild);\n    }\n\n    function draw(){\n      clearSVG();\n      // draw edges\n      edges.forEach(e=>{\n        const s = nodes.find(n=>n.id===e.source);\n        const t = nodes.find(n=>n.id===e.target);\n        if (!s || !t) return;\n        // compute shortened line endpoints (radius 22)\n        const dx = t.x-s.x, dy = t.y-s.y;\n        const dist = Math.hypot(dx,dy) || 1;\n        const nx = dx/dist, ny = dy/dist;\n        const r = 28;\n        const sx = s.x + nx*r;\n        const sy = s.y + ny*r;\n        const tx = t.x - nx*r;\n        const ty = t.y - ny*r;\n\n        // line\n        const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n        line.setAttribute('x1',sx); line.setAttribute('y1',sy);\n        line.setAttribute('x2',tx); line.setAttribute('y2',ty);\n        line.setAttribute('stroke','#6ee7b7');\n        line.setAttribute('stroke-width', e.directed?3:2);\n        line.setAttribute('stroke-opacity',0.12);\n        line.setAttribute('data-edge-id', e.id);\n        line.style.cursor = 'pointer';\n        line.addEventListener('click', (evt)=>{\n          evt.stopPropagation();\n          if (mode === 'delete'){\n            if (confirm('Delete this edge?')) removeEdge(e.id);\n          } else {\n            // toggle directedness if in addEdge? no\n            log(`Edge ${e.source} → ${e.target} (w=${e.weight})`);\n          }\n        });\n        gEdges.appendChild(line);\n\n        // arrowhead if directed\n        if (e.directed){\n          const arrow = document.createElementNS('http://www.w3.org/2000/svg','path');\n          const ah = 10;\n          // rotate arrow to direction\n          const angle = Math.atan2(ty-sy, tx-sx);\n          const ax = tx, ay = ty;\n          const p1x = ax - ah*Math.cos(angle - Math.PI/6);\n          const p1y = ay - ah*Math.sin(angle - Math.PI/6);\n          const p2x = ax - ah*Math.cos(angle + Math.PI/6);\n          const p2y = ay - ah*Math.sin(angle + Math.PI/6);\n          arrow.setAttribute('d', `M ${ax} ${ay} L ${p1x} ${p1y} L ${p2x} ${p2y} Z`);\n          arrow.setAttribute('fill','#6ee7b7');\n          arrow.setAttribute('fill-opacity',0.12);\n          arrow.setAttribute('data-edge-id', e.id);\n          gEdges.appendChild(arrow);\n        }\n\n        // weight label\n        const mx = (sx+tx)/2 + (-ny)*12;\n        const my = (sy+ty)/2 + (nx)*12;\n        const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n        text.setAttribute('x', mx);\n        text.setAttribute('y', my);\n        text.setAttribute('text-anchor','middle');\n        text.setAttribute('dominant-baseline','central');\n        text.setAttribute('fill','#e6eef3');\n        text.setAttribute('font-size',12);\n        text.setAttribute('pointer-events','none');\n        text.textContent = e.weight;\n        text.classList.add('edge-weight');\n        text.setAttribute('data-edge-id', e.id);\n        gEdgeWeights.appendChild(text);\n      });\n\n      // draw nodes\n      nodes.forEach(n=>{\n        const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n        g.setAttribute('transform', `translate(${n.x},${n.y})`);\n        g.setAttribute('data-node-id', n.id);\n        // circle background\n        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n        circle.setAttribute('r', 26);\n        circle.setAttribute('fill', '#062033');\n        circle.setAttribute('stroke', '#0ea5a0');\n        circle.setAttribute('stroke-opacity',0.08);\n        circle.setAttribute('stroke-width', 2);\n        circle.style.cursor = 'pointer';\n        g.appendChild(circle);\n\n        // node id label\n        const idText = document.createElementNS('http://www.w3.org/2000/svg','text');\n        idText.setAttribute('y', -2);\n        idText.setAttribute('text-anchor','middle');\n        idText.setAttribute('fill','#e6eef3');\n        idText.setAttribute('font-size',14);\n        idText.setAttribute('font-weight',700);\n        idText.textContent = n.id;\n        g.appendChild(idText);\n\n        // distance label (dynamic)\n        const distText = document.createElementNS('http://www.w3.org/2000/svg','text');\n        distText.setAttribute('y', 18);\n        distText.setAttribute('text-anchor','middle');\n        distText.setAttribute('fill','#93c5fd');\n        distText.setAttribute('font-size',12);\n        distText.setAttribute('class','node-dist');\n        distText.textContent = '∞';\n        g.appendChild(distText);\n\n        g.addEventListener('mousedown', (evt)=>{\n          evt.stopPropagation();\n          if (mode === 'move'){\n            isDragging = true;\n            dragNode = n;\n            const pt = clientToSVG(evt.clientX, evt.clientY);\n            dragOffset.x = n.x - pt.x;\n            dragOffset.y = n.y - pt.y;\n          }\n        });\n        g.addEventListener('click', (evt)=>{\n          evt.stopPropagation();\n          if (mode === 'addEdge'){\n            if (!selectedForEdge){\n              selectedForEdge = n.id;\n              log(`Selected node ${n.id} as edge source (click target node).`);\n            } else if (selectedForEdge === n.id){\n              selectedForEdge = null;\n              log('Cancelled edge creation.');\n            } else {\n              // prompt weight\n              let w = prompt(`Enter weight for edge ${selectedForEdge} → ${n.id} (non-negative number):`, \"1\");\n              if (w === null){ selectedForEdge = null; return; }\n              w = Number(w);\n              if (!Number.isFinite(w) || w < 0) { alert('Invalid weight. Must be non-negative number.'); selectedForEdge = null; return; }\n              const directed = defaultDirectedCheckbox.checked;\n              createEdge(selectedForEdge, n.id, w, directed);\n              log(`Created ${directed? 'directed':'undirected'} edge ${selectedForEdge} → ${n.id} (w=${w}).`);\n              selectedForEdge = null;\n            }\n          } else if (mode === 'addNode'){\n            // nothing special: clicking node selects for source/target if using set buttons\n          } else if (mode === 'delete'){\n            if (confirm('Delete this node and its edges?')) removeNode(n.id);\n          } else if (mode === 'move'){\n            // nothing: handled by drag\n          }\n        });\n\n        // double click to create directed edge from this to new node? leave out.\n\n        gNodes.appendChild(g);\n      });\n\n      // After draw: update highlights for source/target/algo state\n      updateAllNodeDisplays();\n      updateAllEdgeDisplays();\n    }\n\n    // Update node displays (distances, colors)\n    function updateAllNodeDisplays(){\n      nodes.forEach(n=>{\n        const g = gNodes.querySelector(`g[data-node-id='${n.id}']`);\n        if (!g) return;\n        const distText = g.querySelector('.node-dist');\n        if (algoState && algoState.dist && algoState.dist[n.id] !== undefined){\n          const d = algoState.dist[n.id];\n          distText.textContent = (d === Infinity) ? '∞' : d;\n        } else {\n          distText.textContent = '∞';\n        }\n        const circle = g.querySelector('circle');\n        circle.setAttribute('stroke-opacity', 0.08);\n        circle.setAttribute('fill', '#062033');\n        circle.setAttribute('stroke','#0ea5a0');\n        // colors for source/target/visited/current\n        if (n.id === sourceNode){\n          circle.setAttribute('fill','#06323a');\n          circle.setAttribute('stroke','#06b6d4');\n          circle.setAttribute('stroke-opacity',0.9);\n        }\n        if (algoState && algoState.visited && algoState.visited.has(n.id)){\n          circle.setAttribute('fill','#08212b');\n          circle.setAttribute('stroke','#93c5fd');\n          circle.setAttribute('stroke-opacity',0.6);\n        }\n        if (algoState && algoState.current === n.id){\n          circle.setAttribute('fill','#0ea5a0');\n          circle.setAttribute('stroke','#0b3b33');\n          circle.setAttribute('stroke-opacity',0.95);\n        }\n        if (n.id === targetNode){\n          circle.setAttribute('stroke','#f59e0b');\n          circle.setAttribute('stroke-opacity',0.95);\n        }\n      });\n    }\n\n    // Update edge visuals for relaxations/highlights\n    function updateAllEdgeDisplays(){\n      // default style\n      gEdges.querySelectorAll('[data-edge-id]').forEach(el=>{\n        el.setAttribute('stroke-opacity',0.12);\n        el.setAttribute('fill-opacity',0.12);\n        if (el.tagName === 'path'){\n          el.setAttribute('fill-opacity',0.12);\n        }\n      });\n      // highlight last relaxed edge if present\n      if (algoState && algoState.lastRelaxedEdge){\n        const id = algoState.lastRelaxedEdge;\n        gEdges.querySelectorAll(`[data-edge-id='${id}']`).forEach(el=>{\n          el.setAttribute('stroke-opacity',0.9);\n          el.setAttribute('stroke','#60a5fa');\n          el.setAttribute('fill','#60a5fa');\n          el.setAttribute('fill-opacity',0.9);\n        });\n      }\n      // highlight final shortest path if finished\n      if (algoState && algoState.finished && algoState.prev){\n        if (targetNode !== null && algoState.prev[targetNode]){\n          const path = [];\n          let cur = targetNode;\n          while (cur !== undefined && algoState.prev[cur]){\n            const p = algoState.prev[cur];\n            // find edge id p -> cur\n            const e = edges.find(ed=> ed.source===p && ed.target===cur) || edges.find(ed => (!ed.directed && ((ed.source===p && ed.target===cur) || (ed.source===cur && ed.target===p))));\n            if (e) path.push(e.id);\n            cur = p;\n          }\n          path.forEach(id=>{\n            gEdges.querySelectorAll(`[data-edge-id='${id}']`).forEach(el=>{\n              el.setAttribute('stroke','#f59e0b');\n              el.setAttribute('stroke-opacity',0.95);\n              el.setAttribute('fill','#f59e0b');\n              el.setAttribute('fill-opacity',0.95);\n            });\n          });\n        }\n      }\n    }\n\n    // Export/import JSON\n    document.getElementById('export-json').addEventListener('click', ()=>{\n      const data = {nodes,edges,nextNodeId,nextEdgeId,sourceNode,targetNode};\n      const txt = JSON.stringify(data, null, 2);\n      const blob = new Blob([txt], {type:'application/json'});\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = 'graph-dijkstra.json';\n      a.click();\n      URL.revokeObjectURL(url);\n    });\n    document.getElementById('import-json').addEventListener('click', ()=>{\n      const input = document.createElement('input');\n      input.type='file';\n      input.accept='application/json';\n      input.onchange = ()=> {\n        const f = input.files[0];\n        const reader = new FileReader();\n        reader.onload = () => {\n          try{\n            const data = JSON.parse(reader.result);\n            nodes = data.nodes || [];\n            edges = data.edges || [];\n            nextNodeId = data.nextNodeId || (nodes.length+1);\n            nextEdgeId = data.nextEdgeId || (edges.length+1);\n            sourceNode = data.sourceNode || null;\n            targetNode = data.targetNode || null;\n            algoState = null;\n            draw();\n            updateCounts();\n            log('Imported graph from file.');\n          }catch(e){\n            alert('Invalid file.');\n          }\n        };\n        reader.readAsText(f);\n      };\n      input.click();\n    });\n\n    // Export PNG (simple)\n    document.getElementById('export-image').addEventListener('click', ()=>{\n      const svgData = new XMLSerializer().serializeToString(svg);\n      const svgBlob = new Blob([svgData], {type:'image/svg+xml;charset=utf-8'});\n      const url = URL.createObjectURL(svgBlob);\n      const img = new Image();\n      img.onload = ()=>{\n        const canvas = document.createElement('canvas');\n        canvas.width = svg.viewBox.baseVal.width;\n        canvas.height = svg.viewBox.baseVal.height;\n        const ctx = canvas.getContext('2d'); ctx.fillStyle = '#071226'; ctx.fillRect(0,0,canvas.width,canvas.height);\n        ctx.drawImage(img,0,0);\n        const a = document.createElement('a');\n        a.href = canvas.toDataURL('image/png');\n        a.download = 'dijkstra-graph.png';\n        a.click();\n        URL.revokeObjectURL(url);\n      };\n      img.src = url;\n    });\n\n    // Random graph generation\n    document.getElementById('btn-random').addEventListener('click', ()=>{\n      const n = Number(prompt('Number of nodes', '8'));\n      if (!n || n < 1) return;\n      const density = Number(prompt('Edge density (0.0 - 1.0)', '0.25'));\n      const maxW = Number(prompt('Max edge weight', '15'));\n      nodes = [];\n      edges = [];\n      nextNodeId = 1;\n      nextEdgeId = 1;\n      for (let i=0;i<n;i++){\n        const x = 120 + Math.random()*(svg.viewBox.baseVal.width-240);\n        const y = 80 + Math.random()*(svg.viewBox.baseVal.height-160);\n        createNode(x,y);\n      }\n      // create edges\n      for (let i=0;i<n;i++){\n        for (let j=i+1;j<n;j++){\n          if (Math.random() < density){\n            const w = Math.max(1, Math.round(Math.random()*maxW));\n            const directed = Math.random() < 0.35; // sometimes directed\n            createEdge(nodes[i].id, nodes[j].id, w, directed);\n            if (!directed && Math.random() < 0.3){\n              // maybe create another edge opposite? skip\n            }\n          }\n        }\n      }\n      algoState = null;\n      draw();\n      updateCounts();\n      log('Random graph generated.');\n    });\n\n    // Clear graph\n    document.getElementById('btn-clear').addEventListener('click', ()=>{\n      if (!confirm('Clear the entire graph?')) return;\n      nodes = []; edges = []; nextNodeId=1; nextEdgeId=1;\n      sourceNode = null; targetNode = null; algoState = null;\n      draw(); updateCounts(); log('Graph cleared.');\n    });\n\n    // Set source/target buttons\n    document.getElementById('set-source').addEventListener('click', ()=>{\n      alert('Click a node to set as source.');\n      modeButtons.forEach(x=>x.classList.remove('active'));\n      mode = 'setSource';\n      // temporary click handler\n      const handler = (evt)=>{\n        const pt = clientToSVG(evt.clientX, evt.clientY);\n        const n = nodeAt(pt.x, pt.y);\n        if (n){\n          sourceNode = n.id; log(`Source set to node ${n.id}`); updateCounts(); draw();\n        } else {\n          alert('Click on a node.');\n        }\n        mode = 'addNode';\n        document.getElementById('mode-addnode').classList.add('active');\n        window.removeEventListener('click', handler);\n      };\n      window.addEventListener('click', handler);\n    });\n\n    document.getElementById('set-target').addEventListener('click', ()=>{\n      alert('Click a node to set as target.');\n      modeButtons.forEach(x=>x.classList.remove('active'));\n      mode = 'setTarget';\n      const handler = (evt)=>{\n        const pt = clientToSVG(evt.clientX, evt.clientY);\n        const n = nodeAt(pt.x, pt.y);\n        if (n){\n          targetNode = n.id; log(`Target set to node ${n.id}`); updateCounts(); draw();\n        } else {\n          alert('Click on a node.');\n        }\n        mode = 'addNode';\n        document.getElementById('mode-addnode').classList.add('active');\n        window.removeEventListener('click', handler);\n      };\n      window.addEventListener('click', handler);\n    });\n\n    document.getElementById('clear-sets').addEventListener('click', ()=>{\n      sourceNode = null; targetNode = null; updateCounts(); log('Source and target cleared.'); draw();\n    });\n\n    // Canvas click to add node\n    svg.addEventListener('click', (evt)=>{\n      const pt = clientToSVG(evt.clientX, evt.clientY);\n      if (mode === 'addNode'){\n        createNode(pt.x, pt.y);\n        log(`Node ${nextNodeId-1} created.`);\n      } else if (mode === 'addEdge'){\n        // clicking empty space cancels selection\n        if (selectedForEdge !== null){\n          selectedForEdge = null;\n          log('Cancelled edge creation.');\n        }\n      }\n    });\n\n    // mousemove for dragging nodes\n    window.addEventListener('mousemove', (evt)=>{\n      if (isDragging && dragNode){\n        const pt = clientToSVG(evt.clientX, evt.clientY);\n        dragNode.x = pt.x + dragOffset.x;\n        dragNode.y = pt.y + dragOffset.y;\n        draw();\n      }\n    });\n    window.addEventListener('mouseup', (evt)=>{\n      isDragging = false; dragNode = null;\n    });\n\n    // click on edges to show info or delete handled in draw()\n\n    // Algorithm: Priority queue (min-heap)\n    class MinPQ {\n      constructor(){ this.data = []; }\n      push(item){\n        this.data.push(item);\n        this._siftUp(this.data.length-1);\n      }\n      pop(){\n        if (this.data.length===0) return null;\n        const top = this.data[0];\n        const last = this.data.pop();\n        if (this.data.length>0){\n          this.data[0] = last;\n          this._siftDown(0);\n        }\n        return top;\n      }\n      _siftUp(i){\n        while(i>0){\n          const p = Math.floor((i-1)/2);\n          if (this.data[p].dist <= this.data[i].dist) break;\n          [this.data[p], this.data[i]] = [this.data[i], this.data[p]];\n          i = p;\n        }\n      }\n      _siftDown(i){\n        const n = this.data.length;\n        while(true){\n          let l = 2*i+1, r = 2*i+2, smallest = i;\n          if (l<n && this.data[l].dist < this.data[smallest].dist) smallest = l;\n          if (r<n && this.data[r].dist < this.data[smallest].dist) smallest = r;\n          if (smallest === i) break;\n          [this.data[i], this.data[smallest]] = [this.data[smallest], this.data[i]];\n          i = smallest;\n        }\n      }\n      empty(){ return this.data.length===0; }\n      clear(){ this.data=[]; }\n    }\n\n    // Build adjacency\n    function buildAdj(){\n      const adj = new Map(); // id -> [{to,weight,edgeId}]\n      nodes.forEach(n=> adj.set(n.id, []));\n      edges.forEach(e=>{\n        if (!adj.has(e.source)) return;\n        if (!adj.has(e.target)) return;\n        adj.get(e.source).push({to:e.target, weight:e.weight, edgeId:e.id});\n        if (!e.directed){\n          adj.get(e.target).push({to:e.source, weight:e.weight, edgeId:e.id});\n        }\n      });\n      return adj;\n    }\n\n    // Initialize algorithm\n    function algoInit(){\n      if (!sourceNode){\n        alert('Please set a source node first.');\n        return false;\n      }\n      const adj = buildAdj();\n      const dist = {};\n      const prev = {};\n      nodes.forEach(n=>{ dist[n.id] = Infinity; prev[n.id] = null; });\n      dist[sourceNode] = 0;\n      const pq = new MinPQ();\n      pq.push({node:sourceNode, dist:0});\n      algoState = {adj, dist, prev, visited: new Set(), pq, current:null, finished:false, lastRelaxedEdge:null};\n      log(`Initialized algorithm with source ${sourceNode}.`);\n      updateAllNodeDisplays();\n      updateAllEdgeDisplays();\n      return true;\n    }\n\n    // One step of Dijkstra\n    function algoStep(){\n      if (!algoState){\n        const ok = algoInit();\n        if (!ok) return;\n      }\n      if (algoState.finished){\n        log('Algorithm has already finished. Reset to run again.');\n        return;\n      }\n      const pq = algoState.pq;\n      // pop until we find a not-visited node\n      let top = null;\n      while(!pq.empty()){\n        top = pq.pop();\n        if (!algoState.visited.has(top.node)) break;\n        top = null;\n      }\n      if (!top){\n        algoState.finished = true;\n        log('Priority queue empty. Algorithm finished.');\n        updateAllNodeDisplays();\n        updateAllEdgeDisplays();\n        return;\n      }\n      const u = top.node;\n      algoState.current = u;\n      algoState.visited.add(u);\n      algoState.lastRelaxedEdge = null;\n      log(`Visited node ${u} with distance ${algoState.dist[u]}.`);\n      // relax edges\n      const neighbors = algoState.adj.get(u) || [];\n      neighbors.forEach(nbr=>{\n        if (algoState.visited.has(nbr.to)) return;\n        const alt = algoState.dist[u] + nbr.weight;\n        if (alt < algoState.dist[nbr.to]){\n          algoState.dist[nbr.to] = alt;\n          algoState.prev[nbr.to] = u;\n          algoState.pq.push({node:nbr.to, dist:alt});\n          algoState.lastRelaxedEdge = nbr.edgeId;\n          log(`Relaxed edge ${u} → ${nbr.to}, new dist ${alt}`);\n        } else {\n          log(`Checked edge ${u} → ${nbr.to}, no improvement (alt=${alt}).`);\n        }\n      });\n\n      // if target defined and popped, finish early\n      if (targetNode !== null && u === targetNode){\n        algoState.finished = true;\n        log(`Target node ${targetNode} reached. Algorithm finished.`);\n      }\n\n      // If pq empty and all reachable visited\n      if (algoState.pq.empty() && !algoState.finished){\n        algoState.finished = true;\n        log('No more reachable nodes. Algorithm finished.');\n      }\n\n      updateAllNodeDisplays();\n      updateAllEdgeDisplays();\n\n      if (algoState.finished){\n        // highlight shortest path if target\n        if (targetNode !== null && algoState.prev[targetNode]){\n          const pathNodes = [];\n          let cur = targetNode;\n          while(cur !== null){\n            pathNodes.push(cur);\n            cur = algoState.prev[cur];\n          }\n          log('Shortest path: ' + pathNodes.reverse().join(' → ') + ` (distance ${algoState.dist[targetNode]})`);\n        } else {\n          log('Algorithm finished.');\n        }\n      }\n    }\n\n    // Run algorithm to completion\n    function algoRunFull(){\n      if (!algoState){\n        const ok = algoInit();\n        if (!ok) return;\n      }\n      // run until finished\n      while(!algoState.finished){\n        algoStep();\n      }\n      draw();\n    }\n\n    // Buttons\n    document.getElementById('init-run').addEventListener('click', ()=>{\n      algoRunFull();\n    });\n    document.getElementById('step').addEventListener('click', ()=>{\n      algoStep();\n    });\n\n    // Auto-play\n    document.getElementById('auto').addEventListener('click', ()=>{\n      autoplay = !autoplay;\n      const btn = document.getElementById('auto');\n      if (autoplay){\n        btn.textContent = 'Pause';\n        if (!algoState) { const ok = algoInit(); if (!ok){ autoplay=false; btn.textContent='Auto'; return; } }\n        const speed = Number(document.getElementById('speed').value);\n        autoplayTimer = setInterval(()=>{\n          if (algoState.finished) { clearInterval(autoplayTimer); autoplay=false; btn.textContent='Auto'; return; }\n          algoStep();\n        }, 700 / speed);\n      } else {\n        btn.textContent = 'Auto';\n        clearInterval(autoplayTimer);\n      }\n    });\n\n    document.getElementById('reset-algo').addEventListener('click', ()=>{\n      algoState = null;\n      autoplay = false;\n      clearInterval(autoplayTimer);\n      document.getElementById('auto').textContent = 'Auto';\n      updateAllNodeDisplays();\n      updateAllEdgeDisplays();\n      log('Algorithm state reset.');\n    });\n\n    // keyboard: press Delete to delete selected mode's purpose? Not necessary.\n\n    // init canvas viewbox size from window\n    function initView(){\n      const w = Math.max(1200, window.innerWidth - 420);\n      const h = Math.max(720, window.innerHeight - 40);\n      svg.setAttribute('viewBox', `0 0 ${w} ${h}`);\n      svg.style.minHeight = '100%';\n      // set default sizes if empty\n      if (nodes.length === 0){\n        // create a small sample graph\n        // createNode(200,150); createNode(420,140); createNode(600,260);\n      }\n      draw();\n    }\n    initView();\n    window.addEventListener('resize', initView);\n\n    // initial demonstration: small sample graph\n    (function sample(){\n      const a = createNode(220,180);\n      const b = createNode(420,120);\n      const c = createNode(640,200);\n      const d = createNode(360,300);\n      const e = createNode(570,340);\n      createEdge(a,b,4,false);\n      createEdge(a,d,2,false);\n      createEdge(d,b,1,false);\n      createEdge(b,c,5,false);\n      createEdge(d,e,10,false);\n      createEdge(e,c,3,false);\n      updateCounts();\n      log('Sample graph created. Set a source and run the algorithm.');\n    })();\n\n    // update displays periodically for animations or external changes\n    setInterval(()=>{ updateAllNodeDisplays(); updateAllEdgeDisplays(); }, 300);\n\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}