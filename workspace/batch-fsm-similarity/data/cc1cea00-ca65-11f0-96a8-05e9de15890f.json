{
  "id": "cc1cea00-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:36.957Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Hash Map",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Hash Map Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#38bdf8;\n      --muted:#94a3b8;\n      --card:#071025;\n      --ok:#10b981;\n      --warn:#f59e0b;\n      --danger:#ef4444;\n      color-scheme: dark;\n    }\n    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;}\n    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071021 0%, #07172b 100%);color:#e6eef6;}\n    header{padding:18px 22px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;gap:18px}\n    header h1{margin:0;font-size:18px;letter-spacing:0.2px}\n    .container{display:grid;grid-template-columns:360px 1fr;gap:18px;padding:18px;align-items:start}\n    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03)}\n    .controls{display:flex;flex-direction:column;gap:10px}\n    label{font-size:13px;color:var(--muted);margin-bottom:6px;display:block}\n    input[type=\"text\"],select,input[type=\"number\"]{width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}\n    .row{display:flex;gap:8px}\n    button{padding:8px 10px;border-radius:8px;border:0;background:var(--accent);color:#042029;cursor:pointer;font-weight:600}\n    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.05);color:var(--muted);font-weight:600}\n    .small{padding:6px 8px;font-size:13px}\n    .muted{color:var(--muted);font-size:13px}\n    .vis{padding:14px;display:flex;flex-direction:column;gap:12px}\n    .grid{display:flex;gap:8px;flex-wrap:wrap}\n    .bucket{width:88px;min-height:88px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));border:1px solid rgba(255,255,255,0.03);padding:8px;position:relative;box-shadow:0 6px 20px rgba(0,0,0,0.35)}\n    .bucket .index{position:absolute;right:8px;bottom:6px;font-size:12px;color:var(--muted)}\n    .entry{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:6px;padding:6px;font-size:13px;margin-bottom:6px;display:flex;justify-content:space-between;gap:6px;border:1px solid rgba(255,255,255,0.02)}\n    .hashline{font-size:13px;color:var(--muted);display:flex;align-items:center;gap:8px;flex-wrap:wrap}\n    .log{background:#021325;border-radius:8px;padding:10px;font-family:monospace;height:160px;overflow:auto;border:1px solid rgba(255,255,255,0.03)}\n    .status{display:flex;gap:8px;align-items:center;padding:8px;border-radius:8px}\n    .pill{font-size:12px;padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03)}\n    .highlight{box-shadow:0 0 0 3px rgba(56,189,248,0.08) inset,0 8px 24px rgba(2,6,23,0.6);border-color:var(--accent)!important}\n    .ok{border-color:var(--ok);box-shadow:0 0 0 3px rgba(16,185,129,0.06) inset}\n    .warn{border-color:var(--warn)}\n    .danger{border-color:var(--danger)}\n    .controls .actions{display:flex;gap:8px;flex-wrap:wrap}\n    .muted-sm{font-size:12px;color:var(--muted)}\n    footer{padding:12px 22px;color:var(--muted);font-size:13px;border-top:1px solid rgba(255,255,255,0.02);display:flex;gap:12px;align-items:center}\n    .kbd{background:rgba(255,255,255,0.03);padding:4px 8px;border-radius:6px;border:1px solid rgba(255,255,255,0.02);font-family:monospace}\n    .controls .option-row{display:flex;gap:8px;align-items:center}\n    .small-muted{font-size:12px;color:var(--muted)}\n    .entry-key{font-weight:700}\n    .entry-val{color:var(--muted);font-size:12px}\n    .bucket-empty{opacity:0.55;font-size:13px;color:var(--muted)}\n    .bucket .tombstone{opacity:0.5;font-size:12px;color:var(--warn);font-style:italic}\n    .controls hr{border:0;border-top:1px dashed rgba(255,255,255,0.02);margin:8px 0}\n    .switch{display:flex;gap:8px;align-items:center}\n    .note{font-size:13px;color:var(--muted);margin-top:6px}\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Hash Map Visualizer</h1>\n    <div class=\"muted-sm\">Interactive demo: separate chaining & linear probing, collisions, resizing, and lookup</div>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"panel controls\">\n      <div>\n        <label>Collision Strategy</label>\n        <select id=\"strategy\">\n          <option value=\"chaining\">Separate Chaining (Linked lists)</option>\n          <option value=\"probing\">Open Addressing (Linear Probing)</option>\n        </select>\n      </div>\n\n      <div class=\"row\">\n        <div style=\"flex:1\">\n          <label>Key</label>\n          <input id=\"key\" type=\"text\" placeholder=\"e.g. apple or 42\" />\n        </div>\n        <div style=\"width:120px\">\n          <label>Value</label>\n          <input id=\"value\" type=\"text\" placeholder=\"value\" />\n        </div>\n      </div>\n\n      <div class=\"actions\">\n        <button id=\"putBtn\">Put</button>\n        <button id=\"getBtn\" class=\"ghost\">Get</button>\n        <button id=\"removeBtn\" class=\"ghost\">Remove</button>\n        <button id=\"clearBtn\" class=\"ghost small\">Clear</button>\n      </div>\n\n      <hr />\n\n      <div class=\"option-row\">\n        <label style=\"width:140px\">Initial Capacity</label>\n        <input id=\"capacity\" type=\"number\" value=\"8\" min=\"4\" max=\"256\" />\n      </div>\n      <div class=\"option-row\">\n        <label style=\"width:140px\">Resize Enabled</label>\n        <input id=\"resizeToggle\" type=\"checkbox\" checked />\n      </div>\n      <div class=\"option-row\">\n        <label style=\"width:140px\">Load Factor Threshold</label>\n        <input id=\"threshold\" type=\"number\" step=\"0.1\" value=\"0.7\" min=\"0.2\" max=\"0.95\" />\n      </div>\n\n      <div style=\"margin-top:10px;display:flex;gap:8px\">\n        <button id=\"randomBtn\" class=\"small\">Insert Random</button>\n        <button id=\"fillBtn\" class=\"small ghost\">Fill to Resize</button>\n        <button id=\"rebuildBtn\" class=\"small ghost\">Rebuild</button>\n      </div>\n\n      <hr />\n\n      <div class=\"muted-sm\">Visualization controls</div>\n      <div style=\"display:flex;gap:8px;margin-top:8px\">\n        <button id=\"toggleInternals\" class=\"small ghost\">Toggle Internals</button>\n        <button id=\"stepMode\" class=\"small ghost\">Step Mode: Off</button>\n      </div>\n\n      <hr />\n      <div>\n        <div class=\"muted-sm\">Stats</div>\n        <div style=\"display:flex;gap:8px;margin-top:8px;align-items:center\">\n          <div class=\"pill\">Capacity: <span id=\"statCapacity\">-</span></div>\n          <div class=\"pill\">Size: <span id=\"statSize\">-</span></div>\n          <div class=\"pill\">Load: <span id=\"statLoad\">-</span></div>\n        </div>\n        <div class=\"note\">Keys are treated as strings. Hash function shown during operations. Resize will rehash entries.</div>\n      </div>\n\n      <hr />\n      <div class=\"muted-sm\">Operation Log</div>\n      <div id=\"log\" class=\"log\"></div>\n    </div>\n\n    <div class=\"panel vis\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center\">\n        <div class=\"hashline\"><strong id=\"modeLabel\">Separate Chaining</strong><span class=\"muted\">• Visualizing buckets</span></div>\n        <div class=\"status\">\n          <div class=\"pill\">Hash: <span id=\"lastHash\">-</span></div>\n          <div class=\"pill\">Index: <span id=\"lastIndex\">-</span></div>\n        </div>\n      </div>\n\n      <div id=\"buckets\" class=\"grid\" style=\"padding:8px;min-height:120px\"></div>\n\n      <div style=\"display:flex;gap:8px;align-items:center\">\n        <div class=\"muted-sm\">Legend:</div>\n        <div class=\"pill\">occupied</div>\n        <div class=\"pill\" style=\"border-color:var(--warn)\">tombstone (probing)</div>\n        <div class=\"pill\" style=\"border-color:rgba(255,255,255,0.02)\">empty</div>\n      </div>\n      <div class=\"muted-sm\" style=\"margin-top:6px\">Tip: Use small capacities like 4-16 to better observe collisions and resizing.</div>\n    </div>\n  </div>\n\n  <footer>\n    <div class=\"muted-sm\">This demo implements a simple HashMap with two strategies. For demonstration only — not production-safe.</div>\n    <div style=\"margin-left:auto\" class=\"muted-sm\">Author: Interactive Demo • Hashing: polynomial rolling (strings)</div>\n  </footer>\n\n  <script>\n    // HashMap visualizer\n    (function(){\n      // Utility functions\n      function log(...args){\n        const el = document.getElementById('log');\n        const line = document.createElement('div');\n        line.textContent = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');\n        el.appendChild(line);\n        el.scrollTop = el.scrollHeight;\n      }\n      function assert(b, msg){ if(!b) throw new Error(msg || 'Assertion failed'); }\n\n      // Simple stable hash function for strings/numbers\n      function hashString(key){\n        // Convert to string\n        const s = String(key);\n        // polynomial rolling hash base 127 mod large int (JavaScript safe)\n        let h = 2166136261 >>> 0; // FNV offset basis\n        for(let i=0;i<s.length;i++){\n          h ^= s.charCodeAt(i);\n          h = Math.imul(h, 16777619) >>> 0; // FNV prime\n        }\n        return h >>> 0;\n      }\n\n      // HashMap implementations\n      class HashMap {\n        constructor({capacity=8, strategy='chaining', resizeEnabled=true, loadFactor=0.7, onVisualUpdate=null, stepMode=false}={}){\n          this.capacity = Math.max(4, capacity|0);\n          this.strategy = strategy;\n          this.resizeEnabled = !!resizeEnabled;\n          this.loadFactor = loadFactor;\n          this.size = 0;\n          this.onVisualUpdate = onVisualUpdate; // callback to update UI\n          this.stepMode = stepMode;\n\n          // internal representation\n          if(this.strategy === 'chaining') this._buckets = new Array(this.capacity).fill(null).map(()=>[]);\n          else this._buckets = new Array(this.capacity).fill(null); // for probing: null = empty, {k,v} = entry, tombstone = special\n          this._TOMBSTONE = {tombstone:true};\n        }\n\n        _indexFor(key){\n          const h = hashString(key);\n          const idx = h % this.capacity;\n          return {hash:h, index:idx};\n        }\n\n        _shouldResize(){\n          if(!this.resizeEnabled) return false;\n          return this.size / this.capacity > this.loadFactor;\n        }\n\n        _resize(newCapacity){\n          const old = {buckets: this._buckets, capacity: this.capacity};\n          this.capacity = Math.max(4, newCapacity|0);\n          if(this.strategy === 'chaining') this._buckets = new Array(this.capacity).fill(null).map(()=>[]);\n          else this._buckets = new Array(this.capacity).fill(null);\n          const oldSize = this.size;\n          this.size = 0;\n          // Reinsert entries\n          if(this.strategy === 'chaining'){\n            for(let bucket of old.buckets){\n              for(let entry of bucket){\n                this.put(entry.k, entry.v, /*rebuilding*/true);\n              }\n            }\n          } else {\n            for(let slot of old.buckets){\n              if(slot && slot !== this._TOMBSTONE){\n                this.put(slot.k, slot.v, /*rebuilding*/true);\n              }\n            }\n          }\n          log(`Resized: ${old.capacity} -> ${this.capacity}. Rehashed ${oldSize} entries.`);\n          this._visualUpdate('resize');\n        }\n\n        _visualUpdate(op, details){\n          if(this.onVisualUpdate) this.onVisualUpdate({op, details, map:this});\n        }\n\n        put(key, value, rebuilding=false){\n          const {hash, index} = this._indexFor(key);\n          this._visualUpdate('hash', {hash, index, key, value});\n          if(this.strategy === 'chaining'){\n            const bucket = this._buckets[index];\n            // find if key exists\n            const existing = bucket.find(e => e.k === key);\n            if(existing){\n              existing.v = value;\n              this._visualUpdate('put_replace', {key, value, index});\n              if(!rebuilding) log(`Updated key \"${key}\" at bucket ${index}.`);\n              return;\n            }\n            bucket.push({k:key, v:value, h:hash});\n            this.size++;\n            this._visualUpdate('put', {key, value, index});\n            if(!rebuilding) log(`Inserted \"${key}\" -> \"${value}\" at bucket ${index}.`);\n            if(this._shouldResize()) this._resize(this.capacity * 2);\n          } else {\n            // linear probing insertion\n            let i = index;\n            let firstTomb = -1;\n            for(let probe=0; probe < this.capacity; probe++){\n              const slot = this._buckets[i];\n              this._visualUpdate('probing', {probeIndex:i, probeStep:probe});\n              if(slot === null){\n                const place = (firstTomb >= 0) ? firstTomb : i;\n                this._buckets[place] = {k:key, v:value, h:hash};\n                this.size++;\n                this._visualUpdate('put', {key, value, index:place, probeSteps:probe+1});\n                if(!rebuilding) log(`Inserted \"${key}\" -> \"${value}\" at index ${place} after ${probe+1} probes.`);\n                if(this._shouldResize()) this._resize(this.capacity * 2);\n                return;\n              } else if(slot === this._TOMBSTONE){\n                if(firstTomb < 0) firstTomb = i;\n              } else if(slot.k === key){\n                slot.v = value;\n                this._visualUpdate('put_replace', {key, value, index:i});\n                if(!rebuilding) log(`Updated key \"${key}\" at index ${i}.`);\n                return;\n              }\n              i = (i+1) % this.capacity;\n            }\n            // table full (shouldn't happen if resizing enabled)\n            if(firstTomb >= 0){\n              this._buckets[firstTomb] = {k:key,v:value,h:hash};\n              this.size++;\n              this._visualUpdate('put', {key, value, index:firstTomb, probeSteps:this.capacity});\n              if(!rebuilding) log(`Inserted at tombstone slot ${firstTomb}.`);\n            } else {\n              log('HashMap full, cannot insert');\n            }\n          }\n        }\n\n        get(key){\n          const {hash, index} = this._indexFor(key);\n          this._visualUpdate('hash', {hash, index, key});\n          if(this.strategy === 'chaining'){\n            const bucket = this._buckets[index];\n            const found = bucket.find(e => e.k === key);\n            this._visualUpdate('get', {key, index, found:!!found});\n            if(found){ log(`Found \"${key}\" -> \"${found.v}\" at bucket ${index}.`); return found.v; }\n            log(`Key \"${key}\" not found in bucket ${index}.`); return undefined;\n          } else {\n            let i = index;\n            for(let probe=0; probe < this.capacity; probe++){\n              const slot = this._buckets[i];\n              this._visualUpdate('probing', {probeIndex:i, probeStep:probe});\n              if(slot === null){\n                this._visualUpdate('get', {key, index:i, found:false});\n                log(`Key \"${key}\" not found after ${probe+1} probes (empty slot).`);\n                return undefined;\n              } else if(slot === this._TOMBSTONE){\n                // continue probing\n              } else if(slot.k === key){\n                this._visualUpdate('get', {key, index:i, found:true});\n                log(`Found \"${key}\" -> \"${slot.v}\" at index ${i} after ${probe+1} probes.`);\n                return slot.v;\n              }\n              i = (i+1) % this.capacity;\n            }\n            this._visualUpdate('get', {key, index:-1, found:false});\n            log(`Key \"${key}\" not found after full table probe.`);\n            return undefined;\n          }\n        }\n\n        remove(key){\n          const {hash, index} = this._indexFor(key);\n          this._visualUpdate('hash', {hash, index, key});\n          if(this.strategy === 'chaining'){\n            const bucket = this._buckets[index];\n            const idx = bucket.findIndex(e => e.k === key);\n            if(idx >= 0){\n              const removed = bucket.splice(idx,1)[0];\n              this.size--;\n              this._visualUpdate('remove', {key, index});\n              log(`Removed \"${key}\" from bucket ${index}.`);\n              return removed.v;\n            }\n            log(`Key \"${key}\" not found to remove.`);\n            return undefined;\n          } else {\n            let i = index;\n            for(let probe=0; probe < this.capacity; probe++){\n              const slot = this._buckets[i];\n              this._visualUpdate('probing', {probeIndex:i, probeStep:probe});\n              if(slot === null){\n                this._visualUpdate('remove', {key, index:i, found:false});\n                log(`Key \"${key}\" not found to remove (empty slot at ${i}).`);\n                return undefined;\n              } else if(slot === this._TOMBSTONE){\n                // continue\n              } else if(slot.k === key){\n                const val = slot.v;\n                this._buckets[i] = this._TOMBSTONE;\n                this.size--;\n                this._visualUpdate('remove', {key, index:i, found:true});\n                log(`Removed \"${key}\" at index ${i} (tombstone left).`);\n                return val;\n              }\n              i = (i+1) % this.capacity;\n            }\n            this._visualUpdate('remove', {key, index:-1, found:false});\n            log(`Key \"${key}\" not found to remove after full probe.`);\n            return undefined;\n          }\n        }\n\n        entries(){\n          const out = [];\n          if(this.strategy === 'chaining'){\n            for(let bucket of this._buckets){\n              for(let e of bucket) out.push([e.k,e.v]);\n            }\n          } else {\n            for(let slot of this._buckets){\n              if(slot && slot !== this._TOMBSTONE) out.push([slot.k, slot.v]);\n            }\n          }\n          return out;\n        }\n\n        clear(){\n          this.size = 0;\n          if(this.strategy === 'chaining') this._buckets = new Array(this.capacity).fill(null).map(()=>[]);\n          else this._buckets = new Array(this.capacity).fill(null);\n          this._visualUpdate('clear');\n        }\n      }\n\n      // UI wiring\n      const strategyEl = document.getElementById('strategy');\n      const keyEl = document.getElementById('key');\n      const valueEl = document.getElementById('value');\n      const putBtn = document.getElementById('putBtn');\n      const getBtn = document.getElementById('getBtn');\n      const removeBtn = document.getElementById('removeBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const capacityEl = document.getElementById('capacity');\n      const resizeToggle = document.getElementById('resizeToggle');\n      const thresholdEl = document.getElementById('threshold');\n      const randomBtn = document.getElementById('randomBtn');\n      const fillBtn = document.getElementById('fillBtn');\n      const rebuildBtn = document.getElementById('rebuildBtn');\n      const bucketsEl = document.getElementById('buckets');\n      const statCapacity = document.getElementById('statCapacity');\n      const statSize = document.getElementById('statSize');\n      const statLoad = document.getElementById('statLoad');\n      const lastHash = document.getElementById('lastHash');\n      const lastIndex = document.getElementById('lastIndex');\n      const modeLabel = document.getElementById('modeLabel');\n      const toggleInternals = document.getElementById('toggleInternals');\n      const stepModeBtn = document.getElementById('stepMode');\n\n      let showInternals = true;\n      let stepMode = false;\n      let visualPaused = false;\n\n      function updateStepButton(){ stepModeBtn.textContent = `Step Mode: ${stepMode ? 'On' : 'Off'}`; }\n\n      stepModeBtn.addEventListener('click', ()=>{\n        stepMode = !stepMode; updateStepButton();\n        hm.stepMode = stepMode;\n      });\n\n      toggleInternals.addEventListener('click', ()=>{\n        showInternals = !showInternals;\n        renderBuckets();\n      });\n\n      function makeMapFromUI(){\n        const capacity = Math.max(4, parseInt(capacityEl.value) || 8);\n        const strategy = strategyEl.value;\n        const resizeEnabled = resizeToggle.checked;\n        const loadFactor = parseFloat(thresholdEl.value) || 0.7;\n        return new HashMap({\n          capacity, strategy, resizeEnabled, loadFactor,\n          onVisualUpdate: visualUpdate, stepMode\n        });\n      }\n\n      let hm = makeMapFromUI();\n\n      // Rebuild map if settings changed\n      function rebuildFromSettings(){\n        const entries = hm.entries();\n        hm = makeMapFromUI();\n        for(const [k,v] of entries) hm.put(k,v, true);\n        renderBuckets();\n        log('Rebuilt map with current settings.');\n      }\n\n      strategyEl.addEventListener('change', ()=>{\n        modeLabel.textContent = (strategyEl.value === 'chaining') ? 'Separate Chaining' : 'Linear Probing';\n        rebuildFromSettings();\n      });\n\n      capacityEl.addEventListener('change', ()=>{\n        rebuildFromSettings();\n      });\n\n      resizeToggle.addEventListener('change', ()=>{ hm.resizeEnabled = resizeToggle.checked; });\n      thresholdEl.addEventListener('change', ()=>{ hm.loadFactor = parseFloat(thresholdEl.value) || 0.7; });\n\n      rebuildBtn.addEventListener('click', ()=>{ rebuildFromSettings(); });\n\n      putBtn.addEventListener('click', async ()=>{\n        const k = keyEl.value.trim();\n        const v = valueEl.value;\n        if(!k){ log('Key required'); return; }\n        await hm.put(k, v);\n        renderBuckets();\n      });\n\n      getBtn.addEventListener('click', async ()=>{\n        const k = keyEl.value.trim();\n        if(!k){ log('Key required'); return; }\n        const r = await hm.get(k);\n        renderBuckets();\n      });\n\n      removeBtn.addEventListener('click', async ()=>{\n        const k = keyEl.value.trim();\n        if(!k){ log('Key required'); return; }\n        await hm.remove(k);\n        renderBuckets();\n      });\n\n      clearBtn.addEventListener('click', ()=>{\n        hm.clear();\n        renderBuckets();\n        log('Cleared map.');\n      });\n\n      randomBtn.addEventListener('click', ()=>{\n        const rndKey = Math.random().toString(36).slice(2,8);\n        const rndVal = Math.random().toString(36).slice(2,6);\n        hm.put(rndKey, rndVal);\n        log(`Random insert: ${rndKey} -> ${rndVal}`);\n        renderBuckets();\n      });\n\n      fillBtn.addEventListener('click', ()=>{\n        // Insert many entries to force collisions/resizing\n        const base = ['aa','ab','ac','ad','ae','af','ag','ah','ai','aj','ak','al','am','an','ao','ap'];\n        for(let i=0;i<base.length;i++){\n          const k = base[i] + Math.floor(Math.random()*100);\n          hm.put(k, 'v'+i);\n        }\n        renderBuckets();\n        log('Inserted multiple keys to produce collisions/resizes.');\n      });\n\n      // Visualization: highlight steps and display buckets\n      let lastVisual = {op:null, details:null};\n\n      async function visualUpdate(evt){\n        // evt: {op, details, map}\n        lastVisual = evt;\n        // display hash/index if present\n        if(evt.details && typeof evt.details.hash !== 'undefined') lastHash.textContent = evt.details.hash;\n        if(evt.details && typeof evt.details.index !== 'undefined') lastIndex.textContent = evt.details.index;\n        else { /* keep previous */ }\n        // show a brief highlight for certain ops\n        if(evt.op === 'probing' && evt.details){\n          // highlight probed index\n          renderBuckets(evt);\n        } else {\n          renderBuckets(evt);\n        }\n        // if step mode is on, pause until user clicks map\n        if(stepMode){\n          visualPaused = true;\n          log('[Step] Paused. Click anywhere on bucket area to continue.');\n          await new Promise(resolve=>{\n            function resume(){\n              visualPaused = false;\n              document.removeEventListener('click', resume);\n              resolve();\n            }\n            document.addEventListener('click', resume);\n          });\n        }\n      }\n\n      // Render buckets to DOM\n      function renderBuckets(highlightEvent){\n        bucketsEl.innerHTML = '';\n        statCapacity.textContent = hm.capacity;\n        statSize.textContent = hm.size;\n        statLoad.textContent = (hm.size / hm.capacity).toFixed(3);\n\n        for(let i=0;i<hm.capacity;i++){\n          const b = document.createElement('div');\n          b.className = 'bucket';\n          b.dataset.index = i;\n          // highlight if probing events point here\n          if(highlightEvent && highlightEvent.details){\n            if(highlightEvent.details.probeIndex === i && highlightEvent.op === 'probing'){\n              b.classList.add('highlight');\n            }\n            if(highlightEvent.op === 'hash' && highlightEvent.details.index === i){\n              b.classList.add('ok');\n            }\n            if(highlightEvent.op === 'remove' && highlightEvent.details.index === i){\n              b.classList.add('danger');\n            }\n            if(highlightEvent.op === 'put' && highlightEvent.details.index === i){\n              b.classList.add('ok');\n            }\n          }\n\n          if(hm.strategy === 'chaining'){\n            const bucket = hm._buckets[i];\n            if(bucket.length === 0){\n              const empty = document.createElement('div');\n              empty.className = 'bucket-empty';\n              empty.textContent = '(empty)';\n              b.appendChild(empty);\n            } else {\n              for(const e of bucket){\n                const ent = document.createElement('div');\n                ent.className = 'entry';\n                const left = document.createElement('div');\n                left.innerHTML = `<div class=\"entry-key\">${escapeHtml(String(e.k))}</div><div class=\"entry-val\">${escapeHtml(String(e.v))}</div>`;\n                const right = document.createElement('div');\n                right.className = 'muted-sm';\n                right.textContent = e.h;\n                ent.appendChild(left);\n                ent.appendChild(right);\n                b.appendChild(ent);\n              }\n            }\n          } else {\n            const slot = hm._buckets[i];\n            if(slot === null){\n              const empty = document.createElement('div');\n              empty.className = 'bucket-empty';\n              empty.textContent = '(empty)';\n              b.appendChild(empty);\n            } else if(slot === hm._TOMBSTONE){\n              const t = document.createElement('div');\n              t.className = 'bucket-empty tombstone';\n              t.textContent = '(tombstone)';\n              b.appendChild(t);\n            } else {\n              const ent = document.createElement('div');\n              ent.className = 'entry';\n              const left = document.createElement('div');\n              left.innerHTML = `<div class=\"entry-key\">${escapeHtml(String(slot.k))}</div><div class=\"entry-val\">${escapeHtml(String(slot.v))}</div>`;\n              const right = document.createElement('div');\n              right.className = 'muted-sm';\n              right.textContent = slot.h;\n              ent.appendChild(left); ent.appendChild(right);\n              b.appendChild(ent);\n            }\n          }\n          const idx = document.createElement('div');\n          idx.className = 'index';\n          idx.textContent = i;\n          b.appendChild(idx);\n\n          bucketsEl.appendChild(b);\n        }\n      }\n\n      // Escape for safety in UI\n      function escapeHtml(s){\n        return s.replace(/[&<>\"']/g, (m)=>({ '&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;' }[m]));\n      }\n\n      // initial render\n      renderBuckets();\n\n      // Click handler on bucket area to allow step mode continuation\n      bucketsEl.addEventListener('click', ()=>{ /* used by step-mode resume in visualUpdate via document click */ });\n\n      // expose some utilities to console for debugging\n      window.__hashmap_demo = {hm, renderBuckets, log};\n\n      // Small welcome log\n      log('HashMap visualizer ready. Strategy:', strategyEl.value, 'Capacity:', hm.capacity);\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Hash Map"
    }
  ],
  "topic": "Hash Map",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}