{
  "id": "3c89e6e0-ca6a-11f0-8bff-85107adc1779",
  "timestamp": "2025-11-26T01:51:32.508Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Kruskal's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    display: flex; flex-direction: column; height: 100vh;\n  }\n  h1 {\n    text-align: center;\n    margin: 1rem 0 0.2rem 0;\n  }\n  #container {\n    display: flex;\n    flex: 1;\n    overflow: hidden;\n  }\n  #graph-container {\n    flex: 2;\n    position: relative;\n    background: #f0f0f0;\n    margin: 1rem;\n    border-radius: 8px;\n  }\n  canvas {\n    width: 100%; height: 100%;\n    display: block;\n  }\n  #controls {\n    flex: 1;\n    margin: 1rem 1rem 1rem 0;\n    padding: 1rem;\n    background: #fff;\n    border-radius: 8px;\n    box-shadow: 0 0 10px #ccc;\n    overflow-y: auto;\n  }\n  button {\n    padding: 0.6rem 1rem;\n    margin: 0.2rem 0.5rem 1rem 0;\n    font-size: 1rem;\n    cursor: pointer;\n  }\n  #edges-list {\n    max-height: 150px;\n    overflow-y: auto;\n    border: 1px solid #ddd;\n    padding: 0.5rem;\n    border-radius: 5px;\n    font-size: 0.9rem;\n    background: #fafafa;\n  }\n  pre {\n    background: #222;\n    color: #0f0;\n    padding: 0.5rem;\n    border-radius: 5px;\n    height: 200px;\n    overflow-y: auto;\n    white-space: pre-wrap;\n  }\n  .highlight {\n    background-color: #d1ffd1;\n  }\n</style>\n</head>\n<body>\n<h1>Kruskal's Algorithm Visualization</h1>\n<div id=\"container\">\n  <div id=\"graph-container\">\n    <canvas id=\"graph\" width=\"700\" height=\"500\"></canvas>\n  </div>\n  <div id=\"controls\">\n    <h2>Graph & Steps</h2>\n    <div>\n      <label for=\"edgesInput\">Enter edges (one per line):</label><br>\n      <small>Format: <code>node1,node2,weight</code> with nodes as letters/numbers</small><br>\n      <textarea id=\"edgesInput\" rows=\"8\" style=\"width: 100%; font-family: monospace;\">A,B,4\nA,H,8\nB,H,11\nB,C,8\nH,I,7\nH,G,1\nI,C,2\nI,G,6\nG,F,2\nC,F,4\nC,D,7\nD,F,14\nD,E,9\nF,E,10</textarea>\n    </div>\n    <div style=\"margin-top:0.8rem;\">\n      <button id=\"btnReset\">Load Graph</button>\n      <button id=\"btnStep\" disabled>Next Step</button>\n      <button id=\"btnAuto\" disabled>Auto Run</button>\n      <button id=\"btnPause\" disabled>Pause</button>\n    </div>\n    <h3>Edges sorted by weight:</h3>\n    <div id=\"edges-list\"></div>\n    <h3>Algorithm Log:</h3>\n    <pre id=\"log\"></pre>\n  </div>\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('graph');\n  const ctx = canvas.getContext('2d');\n  const edgesInput = document.getElementById('edgesInput');\n  const edgesListDiv = document.getElementById('edges-list');\n  const logPre = document.getElementById('log');\n  const btnReset = document.getElementById('btnReset');\n  const btnStep = document.getElementById('btnStep');\n  const btnAuto = document.getElementById('btnAuto');\n  const btnPause = document.getElementById('btnPause');\n\n  // Settings for drawing\n  const nodeRadius = 20;\n  const colors = {\n    nodeFill: '#3388ff',\n    nodeText: '#fff',\n    edgeDefault: '#999',\n    edgeSelected: '#f55',\n    edgeMST: '#28a745',\n    text: '#333',\n    edgeRejected: '#bbb',\n  };\n\n  // Graph data structures\n  class DisjointSet {\n    constructor() {\n      this.parent = new Map();\n      this.rank = new Map();\n    }\n    makeSet(x) {\n      this.parent.set(x, x);\n      this.rank.set(x, 0);\n    }\n    find(x) {\n      if (this.parent.get(x) !== x) {\n        this.parent.set(x, this.find(this.parent.get(x)));\n      }\n      return this.parent.get(x);\n    }\n    union(x, y) {\n      const rootX = this.find(x);\n      const rootY = this.find(y);\n      if (rootX === rootY) return false;\n      const rankX = this.rank.get(rootX);\n      const rankY = this.rank.get(rootY);\n      if (rankX < rankY) {\n        this.parent.set(rootX, rootY);\n      } else if (rankX > rankY) {\n        this.parent.set(rootY, rootX);\n      } else {\n        this.parent.set(rootY, rootX);\n        this.rank.set(rootX, rankX + 1);\n      }\n      return true;\n    }\n  }\n\n  // For positioning nodes automatically in a circle\n  function positionNodes(nodes, width, height, margin = 80) {\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const r = Math.min(width, height) / 2 - margin;\n    const angleStep = (2 * Math.PI) / nodes.length;\n    const positions = new Map();\n\n    nodes.forEach((node, i) => {\n      const angle = i * angleStep - Math.PI / 2;\n      const x = centerX + r * Math.cos(angle);\n      const y = centerY + r * Math.sin(angle);\n      positions.set(node, { x, y });\n    });\n    return positions;\n  }\n\n  // Parse edge input text into array of edges\n  // Each edge: { u: string, v: string, w: number }\n  function parseEdges(input) {\n    const edges = [];\n    const lines = input.trim().split('\\n');\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i].trim();\n      if (!line) continue;\n      const parts = line.split(',');\n      if (parts.length !== 3) {\n        throw new Error(`Invalid edge format at line ${i+1}`);\n      }\n      const u = parts[0].trim();\n      const v = parts[1].trim();\n      const w = +parts[2];\n      if (!u || !v || isNaN(w)) {\n        throw new Error(`Invalid edge data at line ${i+1}`);\n      }\n      edges.push({ u, v, w });\n    }\n    return edges;\n  }\n\n  // Draw functions\n\n  function drawGraph(nodes, positions, edges, mstEdges, currentEdgeIndex, disjointSet) {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw edges\n    edges.forEach((edge, i) => {\n      const posU = positions.get(edge.u);\n      const posV = positions.get(edge.v);\n      const inMST = mstEdges.has(i);\n      let color = colors.edgeDefault;\n\n      if (i === currentEdgeIndex) {\n        // Highlight current edge differently depending on whether included or rejected\n        if (inMST) {\n          color = colors.edgeMST;\n        } else {\n          color = colors.edgeSelected;\n        }\n      } else if (inMST) {\n        color = colors.edgeMST;\n      } else if (currentEdgeIndex > i) {\n        color = colors.edgeRejected;\n      }\n\n      ctx.strokeStyle = color;\n      ctx.lineWidth = (i === currentEdgeIndex) ? 4 : 2;\n      ctx.beginPath();\n      ctx.moveTo(posU.x, posU.y);\n      ctx.lineTo(posV.x, posV.y);\n      ctx.stroke();\n\n      // Draw weight halfway on edge\n      const midX = (posU.x + posV.x) / 2;\n      const midY = (posU.y + posV.y) / 2;\n      ctx.fillStyle = colors.text;\n      ctx.font = '14px Arial';\n      ctx.fillText(edge.w, midX + 5, midY - 5);\n    });\n\n    // Draw nodes\n    nodes.forEach(node => {\n      const pos = positions.get(node);\n      ctx.beginPath();\n      ctx.fillStyle = colors.nodeFill;\n      ctx.strokeStyle = '#222';\n      ctx.lineWidth = 2;\n      ctx.arc(pos.x, pos.y, nodeRadius, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.stroke();\n\n      ctx.fillStyle = colors.nodeText;\n      ctx.font = 'bold 16px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(node, pos.x, pos.y);\n    });\n  }\n\n  // Display edges sorted by weight with highlight\n  function displayEdgesList(edges, currentEdgeIndex, mstEdges) {\n    edgesListDiv.innerHTML = '';\n    edges.forEach((edge, i) => {\n      const div = document.createElement('div');\n      div.textContent = `${edge.u} - ${edge.v} : ${edge.w}`;\n      if (i === currentEdgeIndex) {\n        div.classList.add('highlight');\n      } else if (mstEdges.has(i)) {\n        div.style.color = 'green';\n        div.style.fontWeight = 'bold';\n      } else if (i < currentEdgeIndex) {\n        div.style.color = 'gray';\n      }\n      edgesListDiv.appendChild(div);\n    });\n  }\n\n  // Algorithm state\n  let nodes = [];\n  let edges = [];\n  let positions = new Map();\n\n  let sortedEdges = [];\n  let mstEdges = new Set();\n  let djs;\n\n  let currentIndex = -1;\n  let running = false;\n  let autoInterval = null;\n\n  function log(msg) {\n    logPre.textContent += msg + \"\\n\";\n    logPre.scrollTop = logPre.scrollHeight;\n  }\n\n  function resetLog() {\n    logPre.textContent = '';\n  }\n\n  // Initialize everything on load or reset\n  function initializeGraph() {\n    try {\n      edges = parseEdges(edgesInput.value);\n    } catch (e) {\n      alert(\"Error parsing edges: \" + e.message);\n      return false;\n    }\n    // Collect unique nodes\n    const uniqueNodesSet = new Set();\n    edges.forEach(e => {\n      uniqueNodesSet.add(e.u);\n      uniqueNodesSet.add(e.v);\n    });\n    nodes = Array.from(uniqueNodesSet).sort();\n\n    positions = positionNodes(nodes, canvas.width, canvas.height);\n\n    // Sort edges by weight ascending\n    sortedEdges = edges.slice().sort((a, b) => a.w - b.w);\n\n    mstEdges.clear();\n\n    djs = new DisjointSet();\n    nodes.forEach(n => djs.makeSet(n));\n\n    currentIndex = -1;\n    resetLog();\n    log(\"Graph loaded.\");\n    btnStep.disabled = false;\n    btnAuto.disabled = false;\n    btnPause.disabled = true;\n    running = false;\n    if (autoInterval) {\n      clearInterval(autoInterval);\n      autoInterval = null;\n    }\n\n    displayEdgesList(sortedEdges, currentIndex, mstEdges);\n    drawGraph(nodes, positions, sortedEdges, mstEdges, currentIndex, djs);\n    return true;\n  }\n\n  // Perform one step of Kruskal's Algorithm\n  // Returns true if able to step, false if finished\n  function stepKruskal() {\n    currentIndex++;\n    if (currentIndex >= sortedEdges.length) {\n      log(\"Algorithm completed: Minimum Spanning Tree constructed.\");\n      btnStep.disabled = true;\n      btnAuto.disabled = true;\n      btnPause.disabled = true;\n      running = false;\n      if (autoInterval) {\n        clearInterval(autoInterval);\n        autoInterval = null;\n      }\n      return false;\n    }\n\n    const edge = sortedEdges[currentIndex];\n    const u = edge.u;\n    const v = edge.v;\n\n    const rootU = djs.find(u);\n    const rootV = djs.find(v);\n\n    displayEdgesList(sortedEdges, currentIndex, mstEdges);\n\n    if (rootU !== rootV) {\n      djs.union(u, v);\n      mstEdges.add(currentIndex);\n      log(`Step ${currentIndex + 1}: Edge (${u} - ${v}, weight: ${edge.w}) included in MST.`);\n    } else {\n      log(`Step ${currentIndex + 1}: Edge (${u} - ${v}, weight: ${edge.w}) creates a cycle and is skipped.`);\n    }\n\n    drawGraph(nodes, positions, sortedEdges, mstEdges, currentIndex, djs);\n\n    // Check if MST complete (if MST contains nodes-1 edges)\n    if (mstEdges.size === nodes.length - 1) {\n      log(\"Minimum Spanning Tree completed early.\");\n      btnStep.disabled = true;\n      btnAuto.disabled = true;\n      btnPause.disabled = true;\n      running = false;\n      if (autoInterval) {\n        clearInterval(autoInterval);\n        autoInterval = null;\n      }\n      return false;\n    }\n\n    return true;\n  }\n\n  // Auto run the algorithm step by step every interval ms\n  function autoRun() {\n    if (running) return;\n    running = true;\n    btnStep.disabled = true;\n    btnAuto.disabled = true;\n    btnPause.disabled = false;\n\n    autoInterval = setInterval(() => {\n      const cont = stepKruskal();\n      if (!cont) {\n        clearInterval(autoInterval);\n        autoInterval = null;\n        running = false;\n        btnPause.disabled = true;\n      }\n    }, 1200);\n  }\n\n  // Pause the auto run\n  function pauseRun() {\n    if (autoInterval) {\n      clearInterval(autoInterval);\n      autoInterval = null;\n    }\n    running = false;\n    btnStep.disabled = false;\n    btnAuto.disabled = false;\n    btnPause.disabled = true;\n  }\n\n  // Event listeners\n  btnReset.addEventListener('click', () => {\n    if(initializeGraph()){\n      log(\"Press 'Next Step' to start the algorithm or 'Auto Run' to run automatically.\");\n    }\n  });\n\n  btnStep.addEventListener('click', () => {\n    if (!running) {\n      const cont = stepKruskal();\n      if (!cont) {\n        btnStep.disabled = true;\n        btnAuto.disabled = true;\n        btnPause.disabled = true;\n      }\n    }\n  });\n\n  btnAuto.addEventListener('click', () => {\n    autoRun();\n  });\n\n  btnPause.addEventListener('click', () => {\n    pauseRun();\n  });\n\n  // Initialize on page load\n  window.onload = () => {\n    if (initializeGraph()) {\n      log(\"Press 'Next Step' to start the algorithm or 'Auto Run' to run automatically.\");\n    }\n  };\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}