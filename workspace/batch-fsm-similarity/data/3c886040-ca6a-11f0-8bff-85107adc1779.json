{
  "id": "3c886040-ca6a-11f0-8bff-85107adc1779",
  "timestamp": "2025-11-26T01:52:00.693Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Graph Visualization (Directed / Undirected)</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    display: flex; flex-direction: column; align-items: center;\n    background: #f0f0f0;\n    height: 100vh;\n  }\n  h1 {\n    margin: 1rem 0 0.5rem 0;\n  }\n  #controls {\n    margin: 0.5rem;\n  }\n  label {\n    margin-right: 1rem;\n    font-weight: 600;\n  }\n  #canvasContainer {\n    border: 1px solid #ccc;\n    background: white;\n    position: relative;\n    box-shadow: 0 0 12px rgba(0,0,0,0.1);\n  }\n  canvas {\n    display: block;\n  }\n  #instructions {\n    max-width: 600px;\n    background: white;\n    margin-top: 0.5rem;\n    padding: 0.75rem 1rem;\n    border-radius: 6px;\n    box-shadow: 0 0 8px rgba(0,0,0,0.15);\n  }\n  button {\n    margin-left: 0.5rem;\n    padding: 0.3rem 0.7rem;\n    font-weight: 600;\n  }\n</style>\n</head>\n<body>\n<h1>Graph Visualization (Directed / Undirected)</h1>\n<div id=\"controls\">\n  <label>\n    <input type=\"radio\" name=\"mode\" value=\"addNode\" checked /> Add Node\n  </label>\n  <label>\n    <input type=\"radio\" name=\"mode\" value=\"addEdge\" /> Add Edge\n  </label>\n  <label>\n    <input type=\"checkbox\" id=\"directedCheckbox\" /> Directed Graph\n  </label>\n  <button id=\"clearBtn\">Clear Graph</button>\n</div>\n<div id=\"canvasContainer\">\n  <canvas id=\"graphCanvas\" width=\"800\" height=\"600\"></canvas>\n</div>\n<div id=\"instructions\">\n  <strong>Instructions:</strong>\n  <ul>\n    <li><b>Add Node:</b> Select \"Add Node\" mode, then click on the canvas to add nodes.</li>\n    <li><b>Add Edge:</b> Select \"Add Edge\" mode, then click on two nodes to create an edge.</li>\n    <li><b>Directed Graph:</b> Check to make edges directed (arrows), uncheck for undirected edges (lines).</li>\n    <li><b>Clear Graph:</b> Remove all nodes and edges and start fresh.</li>\n  </ul>\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n\n  const NODE_RADIUS = 20;\n  let nodes = [];\n  let edges = [];\n  let isDirected = false;\n  let mode = 'addNode'; // 'addNode' or 'addEdge'\n  let selectedNodeIndexForEdge = null;\n\n  // Utility: distance between two points\n  function dist(x1, y1, x2, y2) {\n    return Math.sqrt((x1-x2)**2 + (y1-y2)**2);\n  }\n\n  // Find node index at canvas position (x,y)\n  function findNodeAt(x, y) {\n    for (let i = 0; i < nodes.length; i++) {\n      let n = nodes[i];\n      if (dist(x, y, n.x, n.y) <= NODE_RADIUS) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  // Draw a directed edge (arrow) from (x1,y1) to (x2,y2)\n  function drawArrow(x1, y1, x2, y2) {\n    const headlen = 12; // length of head in pixels\n    const angle = Math.atan2(y2 - y1, x2 - x1);\n    // line\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    // Shorten line a bit so arrowhead does not overlap node circle\n    const lineEndX = x2 - NODE_RADIUS * Math.cos(angle);\n    const lineEndY = y2 - NODE_RADIUS * Math.sin(angle);\n    ctx.lineTo(lineEndX, lineEndY);\n    ctx.stroke();\n\n    // arrowhead\n    ctx.beginPath();\n    ctx.moveTo(lineEndX, lineEndY);\n    ctx.lineTo(lineEndX - headlen * Math.cos(angle - Math.PI / 6), lineEndY - headlen * Math.sin(angle - Math.PI / 6));\n    ctx.lineTo(lineEndX - headlen * Math.cos(angle + Math.PI / 6), lineEndY - headlen * Math.sin(angle + Math.PI / 6));\n    ctx.lineTo(lineEndX, lineEndY);\n    ctx.fill();\n  }\n\n  // Draw undirected edge (line) between nodes\n  function drawUndirectedEdge(x1, y1, x2, y2) {\n    ctx.beginPath();\n    // shorten from both ends so edges do not overlap node circles\n    let angle = Math.atan2(y2 - y1, x2 - x1);\n    let startX = x1 + NODE_RADIUS * Math.cos(angle);\n    let startY = y1 + NODE_RADIUS * Math.sin(angle);\n    let endX = x2 - NODE_RADIUS * Math.cos(angle);\n    let endY = y2 - NODE_RADIUS * Math.sin(angle);\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n  }\n\n  // Draw the entire graph\n  function drawGraph() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = '#333';\n    ctx.fillStyle = '#1976d2'; // Nodes color fill\n\n    // Draw edges first so nodes appear on top\n    ctx.fillStyle = '#333';\n    edges.forEach(edge => {\n      const from = nodes[edge.from];\n      const to = nodes[edge.to];\n      if (isDirected) {\n        drawArrow(from.x, from.y, to.x, to.y);\n      } else {\n        drawUndirectedEdge(from.x, from.y, to.x, to.y);\n      }\n    });\n\n    // Draw nodes\n    nodes.forEach((node, idx) => {\n      // Node circle\n      ctx.beginPath();\n      ctx.fillStyle = '#1976d2';\n      ctx.strokeStyle = '#0d47a1';\n      ctx.lineWidth = 3;\n      ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n\n      // Node label (index)\n      ctx.fillStyle = 'white';\n      ctx.font = 'bold 16px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(idx, node.x, node.y);\n    });\n\n    // If in addEdge mode and one node selected, highlight it\n    if (mode === 'addEdge' && selectedNodeIndexForEdge !== null) {\n      const n = nodes[selectedNodeIndexForEdge];\n      ctx.beginPath();\n      ctx.strokeStyle = 'orange';\n      ctx.lineWidth = 4;\n      ctx.arc(n.x, n.y, NODE_RADIUS + 6, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n  }\n\n  // Add node at position (x, y)\n  function addNode(x, y) {\n    // Prevent node too close to canvas edges\n    if (x < NODE_RADIUS) x = NODE_RADIUS + 2;\n    if (y < NODE_RADIUS) y = NODE_RADIUS + 2;\n    if (x > canvas.width - NODE_RADIUS) x = canvas.width - NODE_RADIUS - 2;\n    if (y > canvas.height - NODE_RADIUS) y = canvas.height - NODE_RADIUS - 2;\n\n    nodes.push({ x, y });\n  }\n\n  function addEdge(fromIndex, toIndex) {\n    // Prevent duplicate edges\n    const exists = edges.some(e => e.from === fromIndex && e.to === toIndex);\n    if (exists) return false;\n\n    edges.push({ from: fromIndex, to: toIndex });\n    return true;\n  }\n\n  // Canvas click event handler\n  canvas.addEventListener('click', e => {\n    const rect = canvas.getBoundingClientRect();\n    const clickX = e.clientX - rect.left;\n    const clickY = e.clientY - rect.top;\n\n    if (mode === 'addNode') {\n      addNode(clickX, clickY);\n      drawGraph();\n    } else if (mode === 'addEdge') {\n      const clickedNodeIndex = findNodeAt(clickX, clickY);\n      if (clickedNodeIndex === -1) {\n        // clicked empty space, ignore\n        return;\n      }\n      if (selectedNodeIndexForEdge === null) {\n        selectedNodeIndexForEdge = clickedNodeIndex;\n      } else {\n        // Add edge from selectedNodeIndexForEdge to clickedNodeIndex\n        if (selectedNodeIndexForEdge !== clickedNodeIndex) {\n          if (addEdge(selectedNodeIndexForEdge, clickedNodeIndex)) {\n            // Edge added\n          }\n        }\n        // Reset selection\n        selectedNodeIndexForEdge = null;\n      }\n      drawGraph();\n    }\n  });\n\n  // Radio input change for mode\n  const modeRadios = document.querySelectorAll('input[name=mode]');\n  modeRadios.forEach(radio => {\n    radio.addEventListener('change', e => {\n      mode = e.target.value;\n      selectedNodeIndexForEdge = null;\n      drawGraph();\n    });\n  });\n\n  // Directed checkbox change\n  const directedCheckbox = document.getElementById('directedCheckbox');\n  directedCheckbox.addEventListener('change', e => {\n    isDirected = e.target.checked;\n    drawGraph();\n  });\n\n  // Clear button\n  const clearBtn = document.getElementById('clearBtn');\n  clearBtn.addEventListener('click', () => {\n    nodes = [];\n    edges = [];\n    selectedNodeIndexForEdge = null;\n    drawGraph();\n  });\n\n  drawGraph();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}