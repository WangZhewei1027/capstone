{
  "id": "3c89e6e1-ca6a-11f0-8bff-85107adc1779",
  "timestamp": "2025-11-26T01:51:24.438Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Prim's Algorithm Demonstration</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    background: #f0f0f0;\n  }\n  h1 {\n    margin-top: 20px;\n    margin-bottom: 10px;\n  }\n  #canvas-container {\n    position: relative;\n    background: #fff;\n    border: 1px solid #ccc;\n    margin-top: 10px;\n    box-shadow: 0 0 8px rgba(0,0,0,0.15);\n  }\n  canvas {\n    display: block;\n    background: #fafafa;\n  }\n  #controls {\n    margin-top: 10px;\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n    justify-content: center;\n  }\n  #controls button, #controls select {\n    padding: 8px 15px;\n    font-size: 14px;\n    cursor: pointer;\n  }\n  #log {\n    margin-top: 15px;\n    width: 800px;\n    max-width: 95vw;\n    height: 160px;\n    overflow-y: auto;\n    background: #111;\n    color: #0f0;\n    font-family: monospace, monospace;\n    font-size: 13px;\n    border-radius: 5px;\n    padding: 10px;\n    box-sizing: border-box;\n    white-space: pre-wrap;\n    user-select: text;\n  }\n  #graph-size {\n    margin-left: 10px;\n  }\n  @media (max-width: 850px) {\n    #log, #canvas-container {\n      width: 95vw;\n    }\n  }\n</style>\n</head>\n<body>\n<h1>Prim's Algorithm Visualization</h1>\n<div id=\"canvas-container\">\n  <canvas id=\"graph-canvas\" width=\"800\" height=\"600\"></canvas>\n</div>\n\n<div id=\"controls\">\n  <button id=\"generate-graph\">Generate Random Graph</button>\n  <label for=\"graph-size\">Number of vertices:\n    <select id=\"graph-size\">\n      <option value=\"5\">5</option>\n      <option value=\"7\" selected>7</option>\n      <option value=\"9\">9</option>\n      <option value=\"12\">12</option>\n      <option value=\"15\">15</option>\n    </select>\n  </label>\n  <button id=\"start-prim\" disabled>Start Prim's Algorithm</button>\n  <button id=\"next-step\" disabled>Next Step</button>\n  <button id=\"reset\" disabled>Reset</button>\n</div>\n\n<div id=\"log\" aria-live=\"polite\" aria-label=\"Algorithm execution log\"></div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('graph-canvas');\n  const ctx = canvas.getContext('2d');\n\n  const generateBtn = document.getElementById('generate-graph');\n  const startBtn = document.getElementById('start-prim');\n  const nextBtn = document.getElementById('next-step');\n  const resetBtn = document.getElementById('reset');\n  const sizeSelect = document.getElementById('graph-size');\n  const logDiv = document.getElementById('log');\n\n  const WIDTH = canvas.width;\n  const HEIGHT = canvas.height;\n\n  // Graph data structures\n  let vertices = []; // {id, x, y}\n  // edges: adjacency list: { [vertexId]: [ {to, weight} ]}\n  let edges = {};\n\n  // Prim's algorithm state:\n  let primStarted = false;\n  let primVisited = new Set();\n  let primEdges = []; // {from, to, weight} edges in MST\n  let primEdgeCandidates = []; // edges connecting visited to unvisited: min heap property by weight\n  \n  // To step through the algorithm\n  let sequenceSteps = [];\n  let stepIndex = 0;\n\n  // Utility: log message to #log and scroll bottom\n  function log(msg) {\n    logDiv.textContent += msg + \"\\n\";\n    logDiv.scrollTop = logDiv.scrollHeight;\n  }\n  function clearLog() {\n    logDiv.textContent = \"\";\n  }\n\n  // Draw functions\n  const RADIUS = 18;\n  function drawGraph() {\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Draw edges\n    ctx.lineCap = 'round';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.font = \"14px Arial\";\n\n    // Draw all edges (thin gray)\n    for (const fromId in edges) {\n      for (const edge of edges[fromId]) {\n        if (parseInt(fromId) < edge.to) { // undirected, avoid duplicates\n          const v1 = vertices[fromId];\n          const v2 = vertices[edge.to];\n          drawLine(v1, v2, '#bbb', 1);\n          drawWeightLabel(v1, v2, edge.weight, '#666');\n        }\n      }\n    }\n\n    // Draw MST edges (highlighted thick green)\n    primEdges.forEach(({from, to, weight}) => {\n      const v1 = vertices[from];\n      const v2 = vertices[to];\n      drawLine(v1, v2, '#28a745', 4);\n      drawWeightLabel(v1, v2, weight, '#155724', true);\n    });\n\n    // Draw edges candidates (blue dashed)\n    if (primStarted) {\n      primEdgeCandidates.forEach(({from, to, weight}) => {\n        const v1 = vertices[from];\n        const v2 = vertices[to];\n        drawLine(v1, v2, '#1e90ff', 2, [5,5]);\n        drawWeightLabel(v1, v2, weight, '#004080');\n      });\n    }\n\n    // Draw nodes\n    vertices.forEach(v => {\n      let fillColor = '#eee';\n      let borderColor = '#aaa';\n      if (primVisited.has(v.id)) {\n        fillColor = '#28a745';\n        borderColor = '#155724';\n      }\n      drawNode(v, fillColor, borderColor);\n    });\n  }\n\n  function drawNode(v, fill, stroke) {\n    ctx.beginPath();\n    ctx.arc(v.x, v.y, RADIUS, 0, 2 * Math.PI);\n    ctx.fillStyle = fill;\n    ctx.fill();\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = stroke;\n    ctx.stroke();\n\n    // Draw id inside circle\n    ctx.fillStyle = stroke;\n    ctx.font = \"bold 16px Arial\";\n    ctx.fillText(v.id, v.x, v.y);\n  }\n\n  function drawLine(v1, v2, color, width=1, dash=[]) {\n    ctx.beginPath();\n    ctx.setLineDash(dash);\n    ctx.moveTo(v1.x, v1.y);\n    ctx.lineTo(v2.x, v2.y);\n    ctx.strokeStyle = color;\n    ctx.lineWidth = width;\n    ctx.stroke();\n    ctx.setLineDash([]);\n  }\n\n  function drawWeightLabel(v1, v2, weight, color, bold = false) {\n    const midX = (v1.x + v2.x) / 2;\n    const midY = (v1.y + v2.y) / 2;\n    ctx.fillStyle = color;\n    ctx.font = (bold ? \"bold 16px Arial\" : \"14px Arial\");\n    ctx.fillText(weight, midX, midY - 12);\n  }\n\n  // Random graph generator (connected graph)\n  // We'll use a method: generate vertices, then connect them with a random spanning tree,\n  // then add some random extra edges.\n  function generateRandomGraph(vertexCount) {\n    vertices = [];\n    edges = {};\n\n    // Generate vertices positions on canvas with padding\n    const padding = 50;\n    for (let i = 0; i < vertexCount; i++) {\n      let x, y;\n      let attempts = 0;\n      // Avoid overlapping nodes roughly\n      do {\n        x = Math.random() * (WIDTH - 2*padding) + padding;\n        y = Math.random() * (HEIGHT - 2*padding) + padding;\n        attempts++;\n        if (attempts > 30) break; // break to avoid infinite loop\n      } while(vertices.some(v => dist(v.x, v.y, x, y) < RADIUS*3));\n\n      vertices.push({id: i, x, y});\n      edges[i] = [];\n    }\n\n    // Helper: Euclidean distance rounded and min 1\n    function edgeWeight(v1, v2) {\n      return Math.max(1, Math.round(dist(v1.x, v1.y, v2.x, v2.y)));\n    }\n\n    // Create a connected spanning tree first:\n    const connected = new Set();\n    connected.add(0);\n    const unconnected = new Set(vertices.slice(1).map(v => v.id));\n\n    while (unconnected.size > 0) {\n      const from = randomChoice([...connected]);\n      const to = randomChoice([...unconnected]);\n      const weight = edgeWeight(vertices[from], vertices[to]);\n      addEdge(from, to, weight);\n      connected.add(to);\n      unconnected.delete(to);\n    }\n\n    // Add some extra edges randomly for complexity (around 30% more edges)\n    const edgeLimit = Math.floor(vertexCount * 1.3);\n    let currentEdges = vertexCount - 1; // spanning tree edges count\n    while (currentEdges < edgeLimit) {\n      let v1 = getRandomInt(0, vertexCount - 1);\n      let v2 = getRandomInt(0, vertexCount - 1);\n      if (v1 === v2) continue;\n      if (hasEdge(v1, v2)) continue;\n      let weight = edgeWeight(vertices[v1], vertices[v2]);\n      addEdge(v1, v2, weight);\n      currentEdges++;\n    }\n  }\n\n  // Add undirected edge\n  function addEdge(from, to, weight) {\n    edges[from].push({to, weight});\n    edges[to].push({to: from, weight});\n  }\n  // Check if edge exists\n  function hasEdge(v1, v2) {\n    return edges[v1].some(e => e.to === v2);\n  }\n\n  // Distance helper\n  function dist(x1, y1, x2, y2) {\n    return Math.sqrt((x1-x2)**2 + (y1-y2)**2);\n  }\n\n  // Random element from array\n  function randomChoice(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n  }\n  // Random int inclusive\n  function getRandomInt(min, max) {\n    return Math.floor(Math.random() * (max - min +1)) + min;\n  }\n\n  // Prim's Algorithm Implementation (stepwise)\n  /*\n    General idea:\n    - Start from vertex 0.\n    - Keep track of visited vertices.\n    - Maintain a priority queue of edges crossing the cut.\n    - At each step:\n      1. Pick the minimum weight edge from candidates connecting visited to unvisited.\n      2. Add new vertex and edge.\n      3. Add new edges from the newly visited vertex to candidates.\n  */\n\n  // Priority queue based on weight\n  class MinHeap {\n    constructor() { this.heap = []; }\n    size() { return this.heap.length; }\n    push(e) {\n      this.heap.push(e);\n      this._bubbleUp(this.heap.length - 1);\n    }\n    pop() {\n      if (this.heap.length === 0) return null;\n      const min = this.heap[0];\n      const end = this.heap.pop();\n      if (this.heap.length > 0) {\n        this.heap[0] = end;\n        this._sinkDown(0);\n      }\n      return min;\n    }\n    _bubbleUp(n) {\n      const e = this.heap[n];\n      while (n > 0) {\n        let parentN = Math.floor((n - 1) / 2);\n        let parent = this.heap[parentN];\n        if (e.weight >= parent.weight) break;\n        this.heap[parentN] = e;\n        this.heap[n] = parent;\n        n = parentN;\n      }\n    }\n    _sinkDown(n) {\n      const length = this.heap.length;\n      const e = this.heap[n];\n      while(true) {\n        let leftN = 2*n + 1;\n        let rightN = 2*n + 2;\n        let swapN = null;\n\n        if (leftN < length) {\n          let left = this.heap[leftN];\n          if(left.weight < e.weight) swapN = leftN;\n        }\n        if (rightN < length) {\n          let right = this.heap[rightN];\n          if ((swapN === null && right.weight < e.weight) ||\n              (swapN !== null && right.weight < this.heap[swapN].weight)) {\n            swapN = rightN;\n          }\n        }\n        if (swapN === null) break;\n        this.heap[n] = this.heap[swapN];\n        this.heap[swapN] = e;\n        n = swapN;\n      }\n    }\n  }\n\n  // Prepare the sequence of steps for visualization\n  function preparePrimSteps() {\n    primVisited = new Set();\n    primEdges = [];\n    primEdgeCandidates = [];\n\n    const vertexCount = vertices.length;\n    const visited = new Set();\n    const mstEdges = [];\n\n    // MinHeap for edges: stores objects {from, to, weight}\n    const edgeHeap = new MinHeap();\n\n    // Start from vertex 0\n    const start = 0;\n    visited.add(start);\n\n    // Add initial edges from start\n    edges[start].forEach(e => {\n      edgeHeap.push({from: start, to: e.to, weight: e.weight});\n    });\n\n    sequenceSteps = [];\n\n    // Log initial step\n    sequenceSteps.push({\n      type: \"start\",\n      visited: new Set(visited),\n      mstEdges: mstEdges.slice(),\n      candidates: edgeHeap.heap.slice(),\n      message: `Start from vertex ${start}.`\n    });\n\n    while(visited.size < vertexCount) {\n      if (edgeHeap.size() === 0) {\n        // Graph disconnected (shouldn't happen here)\n        sequenceSteps.push({\n          type: \"error\",\n          visited: new Set(visited),\n          mstEdges: mstEdges.slice(),\n          candidates: [],\n          message: `No connecting edges left. Graph might be disconnected.`\n        });\n        break;\n      }\n\n      // Take min edge connecting visited to unvisited\n      let minEdge = null;\n      while(edgeHeap.size() > 0) {\n        const candidate = edgeHeap.pop();\n        if (!visited.has(candidate.to)) {\n          minEdge = candidate;\n          break;\n        }\n      }\n      if (!minEdge) {\n        // No new edges found\n        sequenceSteps.push({\n          type: \"error\",\n          visited: new Set(visited),\n          mstEdges: mstEdges.slice(),\n          candidates: [],\n          message: `No new connecting edges to unvisited vertices.`\n        });\n        break;\n      }\n\n      // Add edge and vertex to MST\n      visited.add(minEdge.to);\n      mstEdges.push(minEdge);\n\n      // Add new candidate edges from this vertex\n      edges[minEdge.to].forEach(e => {\n        if (!visited.has(e.to)) {\n          edgeHeap.push({from: minEdge.to, to: e.to, weight: e.weight});\n        }\n      });\n\n      // Save step state\n      sequenceSteps.push({\n        type: \"add_edge\",\n        visited: new Set(visited),\n        mstEdges: mstEdges.slice(),\n        candidates: edgeHeap.heap.slice(),\n        newEdge: minEdge,\n        message: `Add edge (${minEdge.from} -> ${minEdge.to}) with weight ${minEdge.weight}.`\n      });\n    }\n\n    // Final step: MST complete\n    sequenceSteps.push({\n      type: \"complete\",\n      visited: new Set(visited),\n      mstEdges: mstEdges.slice(),\n      candidates: [],\n      message: `Minimum Spanning Tree completed with ${mstEdges.length} edges.`\n    });\n  }\n\n  // Update visual state for one step\n  function updateStateFromStep(step) {\n    primVisited = step.visited;\n    primEdges = step.mstEdges;\n    primEdgeCandidates = step.candidates;\n\n    drawGraph();\n    log(step.message);\n  }\n\n  // Controls logic\n  function resetState() {\n    primStarted = false;\n    primVisited.clear();\n    primEdges = [];\n    primEdgeCandidates = [];\n    sequenceSteps = [];\n    stepIndex = 0;\n    startBtn.disabled = false;\n    nextBtn.disabled = true;\n    resetBtn.disabled = true;\n    clearLog();\n    drawGraph();\n  }\n\n  generateBtn.addEventListener('click', () => {\n    const vcount = parseInt(sizeSelect.value);\n    generateRandomGraph(vcount);\n    resetState();\n  });\n\n  startBtn.addEventListener('click', () => {\n    clearLog();\n    preparePrimSteps();\n    primStarted = true;\n    stepIndex = 0;\n    updateStateFromStep(sequenceSteps[stepIndex]);\n\n    startBtn.disabled = true;\n    nextBtn.disabled = false;\n    resetBtn.disabled = false;\n  });\n\n  nextBtn.addEventListener('click', () => {\n    stepIndex++;\n    if (stepIndex < sequenceSteps.length) {\n      updateStateFromStep(sequenceSteps[stepIndex]);\n      if (sequenceSteps[stepIndex].type === \"complete\" || sequenceSteps[stepIndex].type === \"error\") {\n        nextBtn.disabled = true;\n      }\n    } else {\n      nextBtn.disabled = true;\n    }\n  });\n\n  resetBtn.addEventListener('click', () => {\n    resetState();\n  });\n\n  // Initial draw\n  generateRandomGraph(parseInt(sizeSelect.value));\n  resetState();\n\n  // Accessibility: add keyboard shortcuts\n  document.addEventListener('keydown', e => {\n    if (primStarted && !nextBtn.disabled && (e.key === 'n' || e.key === 'ArrowRight')) {\n      nextBtn.click();\n    }\n    if (!primStarted && e.key === 's') {\n      startBtn.click();\n    }\n    if (e.key === 'r') {\n      resetBtn.click();\n    }\n  });\n\n  // Informative title / instructions\n  const instructions = \n`Controls:\n- Generate Random Graph: Generates a new random connected graph.\n- Number of vertices: Select how many vertices to generate.\n- Start Prim's Algorithm: Begin step-by-step MST construction.\n- Next Step: Execute the next step of Prim's algorithm.\n- Reset: Reset to initial newly generated graph state.\n\nKeyboard Shortcuts:\n- 's': Start Prim's algorithm\n- 'n' or Right Arrow: Next step\n- 'r': Reset\n\nPrim's Algorithm:\nBuilds a Minimum Spanning Tree (MST) starting from vertex 0,\nadding the cheapest edge that connects already visited vertices\nto an unvisited vertex until all vertices are included.`;\n\n  logDiv.textContent = instructions;\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}