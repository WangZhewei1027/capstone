{
  "id": "cc1f33f1-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:03.171Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>K-Means Clustering Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<style>\n  :root{--bg:#111;--panel:#0f1720;--accent:#2dd4bf;--muted:#94a3b8;--card:#0b1220}\n  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n  body{background:linear-gradient(180deg,#030617 0%, #081226 60%);color:#e6eef6;display:flex;flex-direction:column;align-items:center;padding:18px;box-sizing:border-box;}\n  h1{margin:6px 0 12px;font-size:20px;}\n  .app{width:100%;max-width:1200px;display:grid;grid-template-columns:360px 1fr;gap:18px;}\n  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 6px 18px rgba(2,6,23,0.6)}\n  .controls .row{display:flex;align-items:center;gap:8px;margin-bottom:10px}\n  label{font-size:13px;color:var(--muted);min-width:110px}\n  input[type=\"range\"]{flex:1}\n  input[type=\"number\"]{width:68px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}\n  select{padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}\n  button{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);color:inherit;padding:8px 10px;border-radius:8px;cursor:pointer}\n  button.primary{background:linear-gradient(180deg,#06b6d4,#0891b2);color:#022;font-weight:600;border:none}\n  .toolbar{display:flex;gap:8px;flex-wrap:wrap}\n  canvas{display:block;width:100%;height:100%;border-radius:10px;cursor:crosshair}\n  .stats{font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px;margin-top:8px}\n  .legend{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}\n  .legend .item{display:flex;align-items:center;gap:8px;padding:6px 8px;background:rgba(255,255,255,0.02);border-radius:8px;font-size:13px}\n  .small{font-size:12px;color:var(--muted)}\n  .footer{margin-top:12px;font-size:12px;color:var(--muted)}\n  .canvas-wrap{position:relative;min-height:540px}\n  #mainCanvas{width:100%;height:540px;background:linear-gradient(180deg,#071226,#041025);border-radius:10px;display:block}\n  .info-box{position:absolute;right:14px;top:14px;padding:8px 10px;background:rgba(2,6,23,0.6);border-radius:8px;border:1px solid rgba(255,255,255,0.03);font-size:13px}\n  .muted{color:var(--muted)}\n  .btn-row{display:flex;gap:8px;flex-wrap:wrap}\n  .toggle{display:inline-flex;align-items:center;gap:8px}\n  .btn-ghost{background:transparent;border:1px dashed rgba(255,255,255,0.04);}\n  .small-muted{font-size:12px;color:#9fb3c5}\n  .hint{font-size:12px;color:#9fb3c5;margin-top:6px}\n  .control-block{padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02);margin-bottom:10px}\n  .footer .link{color:var(--accent);text-decoration:none}\n</style>\n</head>\n<body>\n  <h1>K-Means Clustering — Interactive Demo</h1>\n  <div class=\"app\">\n    <div class=\"panel controls\">\n      <div class=\"control-block\">\n        <div class=\"row\"><label>K (clusters)</label>\n          <input id=\"kInput\" type=\"number\" min=\"1\" max=\"12\" step=\"1\" value=\"3\">\n        </div>\n        <div class=\"row\"><label>Points</label>\n          <input id=\"pointsSlider\" type=\"range\" min=\"10\" max=\"800\" value=\"150\"><input id=\"pointsCount\" type=\"number\" min=\"1\" max=\"5000\" value=\"150\">\n        </div>\n        <div class=\"row\"><label>Init method</label>\n          <select id=\"initMethod\"><option value=\"kmeans++\">K-Means++</option><option value=\"random\">Random</option></select>\n        </div>\n        <div class=\"row\"><label>Data</label>\n          <select id=\"dataMode\"><option value=\"blobs\">Blobs</option><option value=\"uniform\">Uniform</option><option value=\"circle\">Circular</option></select>\n        </div>\n        <div style=\"display:flex;gap:8px;margin-top:8px\">\n          <button id=\"genBtn\" class=\"primary\">Generate Points</button>\n          <button id=\"clearBtn\" class=\"btn-ghost\">Clear</button>\n        </div>\n        <div class=\"hint\">Click on canvas to add points when \"Add Points\" is enabled. Empty clusters are reinitialized automatically.</div>\n      </div>\n\n      <div class=\"control-block\">\n        <div class=\"row\"><label>Run controls</label>\n          <div class=\"toolbar\">\n            <button id=\"initBtn\">Initialize Centroids</button>\n            <button id=\"stepBtn\">Step</button>\n            <button id=\"runBtn\" class=\"primary\">Run</button>\n            <button id=\"stopBtn\">Stop</button>\n            <button id=\"autoConvergeBtn\">Run to Convergence</button>\n          </div>\n        </div>\n\n        <div class=\"row\"><label>Speed</label>\n          <input id=\"speed\" type=\"range\" min=\"50\" max=\"1200\" value=\"300\">\n        </div>\n\n        <div class=\"row\"><label>Add Points</label>\n          <label class=\"toggle\"><input id=\"addPointsToggle\" type=\"checkbox\"> Enable</label>\n        </div>\n\n        <div class=\"row\"><label>Show Regions</label>\n          <label class=\"toggle\"><input id=\"showRegions\" type=\"checkbox\" checked> Voronoi-like</label>\n        </div>\n      </div>\n\n      <div class=\"control-block\">\n        <div class=\"stats\">\n          <div>Iterations: <span id=\"iter\">0</span></div>\n          <div>Inertia (sum squared dist): <span id=\"inertia\">0</span></div>\n          <div>Points: <span id=\"totalPoints\">0</span></div>\n          <div class=\"small-muted\">Click \"Step\" to run one iteration. \"Run\" performs continuous steps.</div>\n        </div>\n      </div>\n\n      <div class=\"control-block\">\n        <div class=\"legend\" id=\"legend\"></div>\n        <div class=\"footer\">Made for demonstration. Algorithm: assignment → update. Empty clusters are reinitialized.</div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"canvas-wrap\">\n        <canvas id=\"mainCanvas\" width=\"900\" height=\"540\"></canvas>\n        <div class=\"info-box\" id=\"infoBox\">Hover points for coords</div>\n      </div>\n    </div>\n  </div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('mainCanvas');\n  const ctx = canvas.getContext('2d', {alpha:false});\n  const dpr = window.devicePixelRatio || 1;\n  const W = canvas.width;\n  const H = canvas.height;\n\n  // UI elements\n  const kInput = document.getElementById('kInput');\n  const pointsSlider = document.getElementById('pointsSlider');\n  const pointsCount = document.getElementById('pointsCount');\n  const genBtn = document.getElementById('genBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const initBtn = document.getElementById('initBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const runBtn = document.getElementById('runBtn');\n  const stopBtn = document.getElementById('stopBtn');\n  const autoConvergeBtn = document.getElementById('autoConvergeBtn');\n  const initMethod = document.getElementById('initMethod');\n  const speed = document.getElementById('speed');\n  const addPointsToggle = document.getElementById('addPointsToggle');\n  const showRegions = document.getElementById('showRegions');\n  const dataMode = document.getElementById('dataMode');\n  const iterEl = document.getElementById('iter');\n  const inertiaEl = document.getElementById('inertia');\n  const totalPointsEl = document.getElementById('totalPoints');\n  const legendEl = document.getElementById('legend');\n  const infoBox = document.getElementById('infoBox');\n\n  // Data\n  let points = []; // {x,y,cluster}\n  let centroids = []; // {x,y,color}\n  let k = parseInt(kInput.value,10);\n  let iteration = 0;\n  let running = false;\n  let animateTimer = null;\n\n  // Settings\n  const pointRadius = 3;\n  const centroidRadius = 8;\n  const colors = []; // generate later\n\n  function makeColors(n) {\n    const arr = [];\n    for (let i=0;i<n;i++){\n      const hue = Math.round((i*360/n + 20) % 360);\n      arr.push(`hsl(${hue}deg 85% 60%)`);\n    }\n    return arr;\n  }\n\n  function resizeCanvas() {\n    // keep fixed pixel size from attributes\n  }\n\n  // Utility\n  function rand(min,max){ return Math.random()*(max-min)+min; }\n  function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }\n  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }\n\n  function generatePoints(n, mode='blobs') {\n    points = [];\n    if (mode === 'uniform') {\n      for (let i=0;i<n;i++){\n        points.push({x:rand(20,W-20), y:rand(20,H-20), cluster:-1});\n      }\n    } else if (mode === 'circle') {\n      const cx = W/2, cy = H/2;\n      for (let i=0;i<n;i++){\n        const r = Math.pow(Math.random(),0.5) * Math.min(W,H)/2 * 0.9;\n        const ang = Math.random()*Math.PI*2;\n        points.push({x:clamp(cx + Math.cos(ang)*r, 10, W-10), y:clamp(cy + Math.sin(ang)*r,10,H-10), cluster:-1});\n      }\n    } else { // blobs\n      const blobCount = Math.max(2, Math.round(k * (Math.random()*0.8 + 0.6)));\n      const centers = [];\n      for (let i=0;i<blobCount;i++){\n        centers.push({x:rand(40,W-40), y:rand(40,H-40), s:rand(20,80)});\n      }\n      for (let i=0;i<n;i++){\n        const b = centers[Math.floor(Math.random()*centers.length)];\n        points.push({\n          x: clamp(b.x + rand(-1,1)*b.s, 6, W-6),\n          y: clamp(b.y + rand(-1,1)*b.s, 6, H-6),\n          cluster:-1\n        });\n      }\n    }\n    iteration = 0;\n    updateStats();\n    draw();\n  }\n\n  function randomCentroids(k, method='kmeans++') {\n    centroids = [];\n    const cols = makeColors(k);\n    if (method === 'random') {\n      for (let i=0;i<k;i++){\n        centroids.push({x:rand(20,W-20), y:rand(20,H-20), color:cols[i]});\n      }\n    } else { // kmeans++\n      if (points.length === 0) {\n        // fallback to random\n        for (let i=0;i<k;i++){\n          centroids.push({x:rand(20,W-20), y:rand(20,H-20), color:cols[i]});\n        }\n      } else {\n        // choose first uniformly\n        const choice0 = points[Math.floor(Math.random()*points.length)];\n        centroids.push({x:choice0.x, y:choice0.y, color:cols[0]});\n        const K = k;\n        const dists = new Array(points.length).fill(0);\n        for (let c=1;c<K;c++){\n          // compute squared distances to nearest centroid\n          let sum = 0;\n          for (let i=0;i<points.length;i++){\n            const p = points[i];\n            let minD = Infinity;\n            for (let j=0;j<centroids.length;j++){\n              const dx=p.x-centroids[j].x, dy=p.y-centroids[j].y;\n              const d = dx*dx+dy*dy;\n              if (d < minD) minD = d;\n            }\n            dists[i] = minD;\n            sum += minD;\n          }\n          if (sum === 0) {\n            // everything same -> random\n            const r = points[Math.floor(Math.random()*points.length)];\n            centroids.push({x:r.x,y:r.y,color:cols[c]});\n            continue;\n          }\n          // pick by weighted probability\n          let r = Math.random()*sum;\n          let idx = 0;\n          for (let i=0;i<dists.length;i++){\n            r -= dists[i];\n            if (r <= 0){ idx = i; break; }\n          }\n          const p = points[idx];\n          centroids.push({x:p.x,y:p.y,color:cols[c]});\n        }\n      }\n    }\n    // ensure colors assigned\n    centroids.forEach((c,i)=>{ c.color = makeColors(k)[i]; });\n    iteration = 0;\n    updateStats();\n    draw();\n  }\n\n  function assignPoints() {\n    let changed = 0;\n    for (let i=0;i<points.length;i++){\n      const p = points[i];\n      let best = -1, bestD = Infinity;\n      for (let j=0;j<centroids.length;j++){\n        const d = dist2(p, centroids[j]);\n        if (d < bestD){ bestD = d; best = j; }\n      }\n      if (p.cluster !== best){ changed++; p.cluster = best; }\n    }\n    return changed;\n  }\n\n  function updateCentroids() {\n    const sums = new Array(k).fill(0).map(()=>({x:0,y:0,count:0}));\n    for (let i=0;i<points.length;i++){\n      const p = points[i];\n      if (p.cluster >= 0 && p.cluster < k) {\n        const s = sums[p.cluster];\n        s.x += p.x; s.y += p.y; s.count += 1;\n      }\n    }\n    const old = centroids.map(c => ({x:c.x,y:c.y}));\n    let anyMoved = false;\n    for (let i=0;i<k;i++){\n      const s = sums[i];\n      if (!centroids[i]) {\n        // create new centroid at random point\n        if (points.length) {\n          const r = points[Math.floor(Math.random()*points.length)];\n          centroids[i] = {x:r.x,y:r.y,color:makeColors(k)[i]};\n        } else {\n          centroids[i] = {x:rand(20,W-20), y:rand(20,H-20), color:makeColors(k)[i]};\n        }\n        anyMoved = true;\n        continue;\n      }\n      if (s.count === 0) {\n        // empty cluster -> reinit to random point\n        if (points.length) {\n          const r = points[Math.floor(Math.random()*points.length)];\n          centroids[i].x = r.x; centroids[i].y = r.y;\n        } else {\n          centroids[i].x = rand(20,W-20); centroids[i].y = rand(20,H-20);\n        }\n        anyMoved = true;\n      } else {\n        const nx = s.x / s.count, ny = s.y / s.count;\n        if (Math.hypot(nx - centroids[i].x, ny - centroids[i].y) > 1e-6) anyMoved = true;\n        centroids[i].x = nx; centroids[i].y = ny;\n      }\n    }\n    return anyMoved;\n  }\n\n  function computeInertia() {\n    let s = 0;\n    for (let i=0;i<points.length;i++){\n      const p = points[i];\n      if (p.cluster >= 0) s += dist2(p, centroids[p.cluster]);\n    }\n    return s;\n  }\n\n  function stepOnce(animated=true) {\n    if (centroids.length !== k) return;\n    // assignment\n    assignPoints();\n    // update -> produce new locations then optionally animate\n    const prev = centroids.map(c => ({x:c.x,y:c.y}));\n    const sums = new Array(k).fill(0).map(()=>({x:0,y:0,count:0}));\n    for (let i=0;i<points.length;i++){\n      const p = points[i];\n      if (p.cluster >= 0) {\n        const s = sums[p.cluster];\n        s.x += p.x; s.y += p.y; s.count += 1;\n      }\n    }\n    const newPositions = [];\n    for (let i=0;i<k;i++){\n      const s = sums[i];\n      if (s.count === 0) {\n        if (points.length) {\n          const r = points[Math.floor(Math.random()*points.length)];\n          newPositions.push({x:r.x,y:r.y});\n        } else {\n          newPositions.push({x:rand(20,W-20),y:rand(20,H-20)});\n        }\n      } else {\n        newPositions.push({x:s.x/s.count, y:s.y/s.count});\n      }\n    }\n\n    if (animated) {\n      const frames = Math.max(6, Math.round(600 / Math.max(50, speed.value)));\n      let fa = 0;\n      const start = performance.now();\n      function animateCentroids() {\n        fa++;\n        const t = Math.min(1, fa/frames);\n        for (let i=0;i<k;i++){\n          const ox = prev[i].x, oy = prev[i].y;\n          const nx = newPositions[i].x, ny = newPositions[i].y;\n          centroids[i].x = ox + (nx - ox) * easeOutCubic(t);\n          centroids[i].y = oy + (ny - oy) * easeOutCubic(t);\n        }\n        draw();\n        if (t < 1) requestAnimationFrame(animateCentroids);\n        else {\n          iteration++;\n          updateStats();\n        }\n      }\n      requestAnimationFrame(animateCentroids);\n    } else {\n      for (let i=0;i<k;i++){\n        centroids[i].x = newPositions[i].x; centroids[i].y = newPositions[i].y;\n      }\n      iteration++;\n      updateStats();\n      draw();\n    }\n  }\n\n  function easeOutCubic(t){ return 1 - Math.pow(1-t,3); }\n\n  function runContinuous() {\n    if (running) return;\n    running = true;\n    runLoop();\n  }\n  function stopRunning() { running = false; if (animateTimer) { clearTimeout(animateTimer); animateTimer = null; } }\n\n  function runLoop() {\n    if (!running) return;\n    const start = performance.now();\n    stepOnce(true);\n    // schedule next based on speed\n    const delay = parseInt(speed.value,10);\n    animateTimer = setTimeout(()=>{ requestAnimationFrame(runLoop); }, delay);\n  }\n\n  function runToConvergence(maxIter=500) {\n    if (centroids.length !== k) return;\n    stopRunning();\n    const loop = () => {\n      const changed = assignPoints();\n      const moved = updateCentroids();\n      iteration++;\n      updateStats();\n      draw();\n      if ((changed > 0 || moved) && iteration < maxIter) {\n        setTimeout(loop, Math.max(10, parseInt(speed.value,10)));\n      }\n    };\n    loop();\n  }\n\n  function updateStats() {\n    iterEl.textContent = iteration;\n    inertiaEl.textContent = computeInertia().toFixed(1);\n    totalPointsEl.textContent = points.length;\n    // legend: show sizes\n    renderLegend();\n  }\n\n  function renderLegend() {\n    legendEl.innerHTML = '';\n    for (let i=0;i<k;i++){\n      const count = points.filter(p => p.cluster === i).length;\n      const el = document.createElement('div');\n      el.className = 'item';\n      el.innerHTML = `<div style=\"width:14px;height:14px;border-radius:3px;background:${centroids[i] ? centroids[i].color : makeColors(k)[i]};box-shadow:0 0 12px rgba(0,0,0,0.5)\"></div><div>Cluster ${i+1} &middot; ${count}</div>`;\n      legendEl.appendChild(el);\n    }\n  }\n\n  function drawRegions() {\n    if (!showRegions.checked) return;\n    const grid = 12; // block size\n    for (let y=0;y<H;y+=grid){\n      for (let x=0;x<W;x+=grid){\n        let best = -1, bestD = Infinity;\n        for (let j=0;j<centroids.length;j++){\n          const dx = (x+grid/2) - centroids[j].x;\n          const dy = (y+grid/2) - centroids[j].y;\n          const d = dx*dx+dy*dy;\n          if (d < bestD){ bestD = d; best = j; }\n        }\n        if (best >= 0) {\n          ctx.fillStyle = hexToRgba(centroids[best].color, 0.07);\n          ctx.fillRect(x,y,grid,grid);\n        }\n      }\n    }\n  }\n\n  function draw() {\n    // background\n    ctx.clearRect(0,0,W,H);\n    ctx.fillStyle = '#041025';\n    ctx.fillRect(0,0,W,H);\n\n    if (centroids.length === k && showRegions.checked && centroids.length > 0) {\n      drawRegions();\n    }\n\n    // draw points\n    for (let i=0;i<points.length;i++){\n      const p = points[i];\n      const c = (p.cluster >= 0 && centroids[p.cluster]) ? centroids[p.cluster].color : '#9fb3c5';\n      ctx.beginPath();\n      ctx.fillStyle = c;\n      ctx.globalAlpha = 0.95;\n      ctx.arc(p.x, p.y, pointRadius, 0, Math.PI*2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n    }\n\n    // draw centroids\n    for (let i=0;i<centroids.length;i++){\n      const c = centroids[i];\n      // halo\n      ctx.beginPath();\n      ctx.fillStyle = hexToRgba(c.color, 0.18);\n      ctx.arc(c.x, c.y, centroidRadius+8, 0, Math.PI*2);\n      ctx.fill();\n\n      ctx.beginPath();\n      ctx.fillStyle = c.color;\n      ctx.arc(c.x, c.y, centroidRadius, 0, Math.PI*2);\n      ctx.fill();\n\n      ctx.strokeStyle = '#021018';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n\n      // label\n      ctx.fillStyle = '#071a1f';\n      ctx.font = '11px sans-serif';\n      ctx.fillText('C'+(i+1), c.x+centroidRadius+6, c.y+4);\n    }\n  }\n\n  function hexToRgba(hslStr, a) {\n    // hsl(...) -> convert to rgba; canvas accepts \"hsl(...)\" with alpha via hsla; easiest:\n    if (hslStr.startsWith('hsl')) {\n      return hslStr.replace('hsl', 'hsla').replace(')', `, ${a})`);\n    }\n    // fallback\n    return `rgba(255,255,255,${a})`;\n  }\n\n  // Interactions\n  canvas.addEventListener('click', (e)=>{\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left);\n    const y = (e.clientY - rect.top);\n    if (addPointsToggle.checked) {\n      points.push({x:x,y:y,cluster:-1});\n      iteration = 0;\n      updateStats();\n      draw();\n    } else {\n      // hover info: display nearest point if any\n      let nearest = null, bestD = 25*25;\n      for (let i=0;i<points.length;i++){\n        const p = points[i];\n        const dx = p.x - x, dy = p.y - y;\n        const d = dx*dx+dy*dy;\n        if (d < bestD) { bestD = d; nearest = p; }\n      }\n      if (nearest) {\n        infoBox.innerHTML = `Point: (${nearest.x.toFixed(1)}, ${nearest.y.toFixed(1)}) &nbsp; Cluster: ${nearest.cluster>=0 ? nearest.cluster+1 : '—'}`;\n      } else {\n        infoBox.innerHTML = `Canvas: (${x.toFixed(1)}, ${y.toFixed(1)})`;\n      }\n    }\n  });\n\n  canvas.addEventListener('mousemove', (e)=>{\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left);\n    const y = (e.clientY - rect.top);\n    let nearest = null, bestD = 20*20;\n    for (let i=0;i<points.length;i++){\n      const p = points[i];\n      const dx = p.x - x, dy = p.y - y;\n      const d = dx*dx+dy*dy;\n      if (d < bestD) { bestD = d; nearest = p; }\n    }\n    if (nearest) {\n      infoBox.innerHTML = `Point: (${nearest.x.toFixed(1)}, ${nearest.y.toFixed(1)}) &nbsp; Cluster: ${nearest.cluster>=0 ? nearest.cluster+1 : '—'}`;\n    } else {\n      infoBox.innerHTML = `Canvas: (${x.toFixed(1)}, ${y.toFixed(1)})`;\n    }\n  });\n\n  // UI wiring\n  pointsSlider.addEventListener('input', ()=>{ pointsCount.value = pointsSlider.value; });\n  pointsCount.addEventListener('change', ()=>{ pointsSlider.value = pointsCount.value; });\n\n  genBtn.addEventListener('click', ()=>{\n    k = Math.max(1, Math.min(12, parseInt(kInput.value,10)));\n    const n = parseInt(pointsCount.value,10) || 100;\n    generatePoints(n, dataMode.value);\n    // auto init centroids\n    randomCentroids(k, initMethod.value);\n  });\n\n  clearBtn.addEventListener('click', ()=>{\n    points = [];\n    centroids = [];\n    iteration = 0;\n    updateStats();\n    draw();\n  });\n\n  initBtn.addEventListener('click', ()=>{\n    k = Math.max(1, Math.min(12, parseInt(kInput.value,10)));\n    randomCentroids(k, initMethod.value);\n  });\n\n  stepBtn.addEventListener('click', ()=>{\n    k = Math.max(1, Math.min(12, parseInt(kInput.value,10)));\n    if (centroids.length !== k) randomCentroids(k, initMethod.value);\n    stepOnce(true);\n  });\n\n  runBtn.addEventListener('click', ()=>{\n    k = Math.max(1, Math.min(12, parseInt(kInput.value,10)));\n    if (centroids.length !== k) randomCentroids(k, initMethod.value);\n    runContinuous();\n  });\n\n  stopBtn.addEventListener('click', ()=>{\n    stopRunning();\n  });\n\n  autoConvergeBtn.addEventListener('click', ()=>{\n    k = Math.max(1, Math.min(12, parseInt(kInput.value,10)));\n    if (centroids.length !== k) randomCentroids(k, initMethod.value);\n    runToConvergence(800);\n  });\n\n  kInput.addEventListener('change', ()=>{\n    k = Math.max(1, Math.min(12, parseInt(kInput.value,10)));\n    // if we change k, reinit centroids\n    centroids = [];\n    randomCentroids(k, initMethod.value);\n  });\n\n  initMethod.addEventListener('change', ()=>{ /* no-op */ });\n  showRegions.addEventListener('change', ()=>{ draw(); });\n\n  // initial setup\n  (function initDemo(){\n    k = parseInt(kInput.value,10);\n    generatePoints(parseInt(pointsCount.value,10), dataMode.value);\n    randomCentroids(k, initMethod.value);\n  })();\n\n  // animation loop to draw at steady state (not necessary but keeps fresh)\n  setInterval(()=>{ draw(); }, 800);\n\n  // helper for color alpha conversion (already defined)\n  function hexToRgbaFallback(hex, a) {\n    // not used\n    return `rgba(255,255,255,${a})`;\n  }\n\n  // keep stats updated every 200ms\n  setInterval(()=>{ updateStats(); }, 300);\n\n  // expose for debugging\n  window._kmeans = {points, centroids, stepOnce, randomCentroids, assignPoints, updateCentroids};\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}