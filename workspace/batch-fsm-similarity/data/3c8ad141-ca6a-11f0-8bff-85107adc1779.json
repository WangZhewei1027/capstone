{
  "id": "3c8ad141-ca6a-11f0-8bff-85107adc1779",
  "timestamp": "2025-11-26T01:51:37.502Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>K-Means Clustering Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f7f7f7;\n    text-align: center;\n  }\n  canvas {\n    border: 1px solid #ccc;\n    background: white;\n    margin-top: 10px;\n    cursor: crosshair;\n  }\n  #controls {\n    margin-top: 15px;\n  }\n  input[type=number] {\n    width: 60px;\n    padding: 4px;\n    font-size: 14px;\n  }\n  button {\n    padding: 6px 12px;\n    margin-left: 10px;\n    font-size: 14px;\n    cursor: pointer;\n  }\n  #info {\n    max-width: 700px;\n    margin: 10px auto;\n    font-size: 14px;\n    color: #444;\n  }\n</style>\n</head>\n<body>\n<h1>K-Means Clustering Interactive Demo</h1>\n<p>Click on the canvas to add data points. Adjust the number of clusters (K) below, then press \"Run K-Means\".</p>\n<canvas id=\"canvas\" width=\"700\" height=\"500\" title=\"Click to add points\"></canvas>\n<div id=\"controls\">\n  <label for=\"kInput\">Number of clusters (K): </label>\n  <input type=\"number\" id=\"kInput\" value=\"3\" min=\"1\" max=\"10\" />\n  <button id=\"runBtn\">Run K-Means</button>\n  <button id=\"resetBtn\">Reset</button>\n</div>\n<div id=\"info\"></div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  const kInput = document.getElementById('kInput');\n  const runBtn = document.getElementById('runBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const info = document.getElementById('info');\n  \n  const width = canvas.width;\n  const height = canvas.height;\n  \n  let points = [];\n  let clusters = [];\n  let assignments = [];\n  const maxIterations = 100;\n  \n  // Colors for clusters (up to 10)\n  const clusterColors = [\n    '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',\n    '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe'\n  ];\n  \n  // Add a point at (x,y)\n  function addPoint(x, y) {\n    if (points.length >= 500) {\n      alert('Maximum 500 points allowed.');\n      return;\n    }\n    points.push({x, y});\n    assignments.push(-1);\n    draw();\n  }\n  \n  // Draw all points and clusters\n  function draw(clusterCenters = null) {\n    ctx.clearRect(0, 0, width, height);\n    \n    // Draw points with colors by assigned cluster\n    points.forEach((p, i) => {\n      let color = '#999'; // default gray if no assignment\n      if (assignments[i] !== -1 && clusterColors[assignments[i]]) {\n        color = clusterColors[assignments[i]];\n      }\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, 5, 0, Math.PI*2);\n      ctx.fill();\n      ctx.strokeStyle = '#333';\n      ctx.lineWidth = 1;\n      ctx.stroke();\n    });\n    \n    // Draw cluster centers\n    if (clusterCenters) {\n      clusterCenters.forEach((c, i) => {\n        ctx.fillStyle = clusterColors[i];\n        ctx.strokeStyle = '#222';\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.arc(c.x, c.y, 10, 0, Math.PI*2);\n        ctx.fill();\n        ctx.stroke();\n        // Draw \"center\" small black dot\n        ctx.fillStyle = '#000';\n        ctx.beginPath();\n        ctx.arc(c.x, c.y, 3, 0, Math.PI*2);\n        ctx.fill();\n      });\n    }\n  }\n  \n  // Euclidean distance squared (faster than sqrt)\n  function dist2(a, b) {\n    let dx = a.x - b.x;\n    let dy = a.y - b.y;\n    return dx*dx + dy*dy;\n  }\n  \n  // Initialize cluster centers randomly from points\n  function initializeCenters(k) {\n    if (points.length < k) {\n      alert('Number of clusters cannot exceed number of points.');\n      return null;\n    }\n    const centers = [];\n    const usedIndices = new Set();\n    while (centers.length < k) {\n      const idx = Math.floor(Math.random() * points.length);\n      if (!usedIndices.has(idx)) {\n        usedIndices.add(idx);\n        centers.push({x: points[idx].x, y: points[idx].y});\n      }\n    }\n    return centers;\n  }\n  \n  // Assign points to nearest center, return true if assignments changed\n  function assignPoints(centers) {\n    let changed = false;\n    for (let i=0; i < points.length; i++) {\n      let minDist = Infinity;\n      let bestCluster = -1;\n      for (let c=0; c < centers.length; c++) {\n        let d = dist2(points[i], centers[c]);\n        if (d < minDist) {\n          minDist = d;\n          bestCluster = c;\n        }\n      }\n      if (assignments[i] !== bestCluster) {\n        changed = true;\n        assignments[i] = bestCluster;\n      }\n    }\n    return changed;\n  }\n  \n  // Update cluster centers given assignments\n  function updateCenters(k) {\n    const sums = Array(k).fill(null).map(() => ({x:0,y:0,count:0}));\n    for (let i=0; i < points.length; i++) {\n      const c = assignments[i];\n      sums[c].x += points[i].x;\n      sums[c].y += points[i].y;\n      sums[c].count++;\n    }\n    const newCenters = sums.map(s => {\n      if (s.count === 0) {\n        // In case cluster lost all points, reinitialize randomly\n        const p = points[Math.floor(Math.random()*points.length)];\n        return {x: p.x, y: p.y};\n      }\n      return {x: s.x / s.count, y: s.y / s.count};\n    });\n    return newCenters;\n  }\n  \n  // K-Means main loop\n  async function runKMeans(k) {\n    if (points.length === 0) {\n      alert('Please add some points first.');\n      return;\n    }\n    if (k < 1) {\n      alert('K must be at least 1.');\n      return;\n    }\n    if (k > points.length) {\n      alert('K cannot be greater than number of points.');\n      return;\n    }\n    \n    // Initialize\n    let centers = initializeCenters(k);\n    if (!centers) return;\n    assignments.fill(-1);\n    \n    draw(centers);\n    info.textContent = '';\n    \n    for (let iter=0; iter < maxIterations; iter++) {\n      const changed = assignPoints(centers);\n      centers = updateCenters(k);\n      draw(centers);\n      info.textContent = `Iteration: ${iter+1}`;\n      \n      await new Promise(r => setTimeout(r, 300)); // slow down for visualization\n      \n      if (!changed) {\n        info.textContent += ' - Converged';\n        break;\n      }\n    }\n  }\n  \n  \n  // Event Listeners\n  canvas.addEventListener('click', e => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    addPoint(x, y);\n  });\n  \n  runBtn.addEventListener('click', () => {\n    const k = parseInt(kInput.value,10);\n    runKMeans(k);\n  });\n  \n  resetBtn.addEventListener('click', () => {\n    points = [];\n    assignments = [];\n    clusters = [];\n    info.textContent = '';\n    draw();\n  });\n  \n  // Initial draw\n  draw();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}