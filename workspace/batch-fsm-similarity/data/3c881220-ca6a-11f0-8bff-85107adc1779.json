{
  "id": "3c881220-ca6a-11f0-8bff-85107adc1779",
  "timestamp": "2025-11-26T01:52:30.054Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <title>Binary Search Tree (BST) Demo</title>\n  <style>\n    body {\n      font-family: Arial, sans-serif;\n      margin: 0;\n      padding: 20px;\n      background: #f0f2f5;\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      min-height: 100vh;\n    }\n    h1 {\n      margin-bottom: 10px;\n      color: #222;\n    }\n    #controls {\n      margin-bottom: 15px;\n      display: flex;\n      flex-wrap: wrap;\n      gap: 10px;\n      justify-content: center;\n    }\n    input[type=\"number\"] {\n      padding: 8px;\n      font-size: 16px;\n      width: 120px;\n      border-radius: 4px;\n      border: 1px solid #ccc;\n    }\n    button {\n      padding: 8px 16px;\n      font-size: 16px;\n      background-color: #4CAF50;\n      border: none;\n      border-radius: 4px;\n      color: white;\n      cursor: pointer;\n      transition: background-color 0.2s ease;\n    }\n    button:hover:not(:disabled) {\n      background-color: #45a047;\n    }\n    button:disabled {\n      background-color: #888;\n      cursor: default;\n    }\n    #message {\n      margin: 10px 0 20px 0;\n      min-height: 20px;\n      color: #d32f2f;\n      font-weight: bold;\n    }\n    #bstCanvas {\n      border: 1px solid #ccc;\n      background: white;\n      box-shadow: 0 2px 6px rgba(0,0,0,0.2);\n      border-radius: 6px;\n      max-width: 100%;\n      height: 500px;\n    }\n    #traversalOutputs {\n      margin-top: 20px;\n      width: 80%;\n      max-width: 800px;\n      display: flex;\n      flex-wrap: wrap;\n      gap: 15px;\n      justify-content: space-around;\n    }\n    .traversalBlock {\n      background: white;\n      padding: 15px 20px;\n      border-radius: 6px;\n      box-shadow: 0 1px 4px rgba(0,0,0,0.15);\n      flex: 1 1 250px;\n      min-width: 220px;\n    }\n    .traversalBlock h3 {\n      margin-top: 0;\n      font-weight: normal;\n      text-align: center;\n      color: #333;\n    }\n    .traversalBlock .output {\n      margin-top: 8px;\n      font-weight: bold;\n      font-family: monospace;\n      color: #1565c0;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n  </style>\n</head>\n<body>\n  <h1>Binary Search Tree (BST) Demo</h1>\n\n  <div id=\"controls\">\n    <input type=\"number\" id=\"valueInput\" placeholder=\"Enter value\" />\n    <button id=\"insertBtn\">Insert</button>\n    <button id=\"deleteBtn\">Delete</button>\n    <button id=\"searchBtn\">Search</button>\n    <button id=\"clearBtn\" title=\"Clear entire tree\" style=\"background-color:#d32f2f;\">Clear</button>\n  </div>\n  <div id=\"message\"></div>\n\n  <canvas id=\"bstCanvas\" width=\"900\" height=\"500\" aria-label=\"Binary Search Tree visualization\"></canvas>\n\n  <div id=\"traversalOutputs\">\n    <div class=\"traversalBlock\">\n      <h3>In-order Traversal</h3>\n      <div class=\"output\" id=\"inorderOutput\"></div>\n    </div>\n    <div class=\"traversalBlock\">\n      <h3>Pre-order Traversal</h3>\n      <div class=\"output\" id=\"preorderOutput\"></div>\n    </div>\n    <div class=\"traversalBlock\">\n      <h3>Post-order Traversal</h3>\n      <div class=\"output\" id=\"postorderOutput\"></div>\n    </div>\n    <div class=\"traversalBlock\">\n      <h3>Level-order Traversal (BFS)</h3>\n      <div class=\"output\" id=\"levelorderOutput\"></div>\n    </div>\n  </div>\n\n  <script>\n    // BST Node class\n    class Node {\n      constructor(value) {\n        this.value = value;\n        this.left = null;\n        this.right = null;\n        this.x = 0; // for visualization\n        this.y = 0; // for visualization\n      }\n    }\n\n    // BST class with insert, search, delete, and traversals\n    class BST {\n      constructor() {\n        this.root = null;\n      }\n\n      insert(value) {\n        if (this.root === null) {\n          this.root = new Node(value);\n          return true;\n        } \n        else {\n          return this._insert(this.root, value);\n        }\n      }\n\n      _insert(node, value) {\n        if (value === node.value) {\n          return false; // no duplicates\n        }\n        else if (value < node.value) {\n          if (node.left === null) {\n            node.left = new Node(value);\n            return true;\n          } else {\n            return this._insert(node.left, value);\n          }\n        } \n        else {\n          if (node.right === null) {\n            node.right = new Node(value);\n            return true;\n          } else {\n            return this._insert(node.right, value);\n          }\n        }\n      }\n\n      search(value) {\n        return this._search(this.root, value);\n      }\n\n      _search(node, value) {\n        if (node === null) return false;\n        if (value === node.value) return true;\n        if (value < node.value) return this._search(node.left, value);\n        else return this._search(node.right, value);\n      }\n\n      delete(value) {\n        const { newRoot, deleted } = this._delete(this.root, value);\n        this.root = newRoot;\n        return deleted;\n      }\n\n      _delete(node, value) {\n        if (node === null) return { newRoot: null, deleted: false };\n\n        let deleted = false;\n\n        if (value < node.value) {\n          const result = this._delete(node.left, value);\n          node.left = result.newRoot;\n          deleted = result.deleted;\n          return { newRoot: node, deleted };\n        }\n        else if (value > node.value) {\n          const result = this._delete(node.right, value);\n          node.right = result.newRoot;\n          deleted = result.deleted;\n          return { newRoot: node, deleted };\n        }\n        else {\n          // Node to be deleted found\n          deleted = true;\n\n          // Case 1: No children\n          if (node.left === null && node.right === null) {\n            return { newRoot: null, deleted };\n          }\n          // Case 2: One child\n          else if (node.left === null) {\n            return { newRoot: node.right, deleted };\n          }\n          else if (node.right === null) {\n            return { newRoot: node.left, deleted };\n          }\n          // Case 3: Two children\n          else {\n            // Find inorder successor (smallest in right subtree)\n            let successorParent = node;\n            let successor = node.right;\n            while (successor.left !== null) {\n              successorParent = successor;\n              successor = successor.left;\n            }\n            node.value = successor.value; // Copy successor's value\n            // Delete successor node\n            if (successorParent !== node) {\n              successorParent.left = successor.right;\n            } else {\n              successorParent.right = successor.right;\n            }\n            return { newRoot: node, deleted };\n          }\n        }\n      }\n\n      // Traversals\n      inorder() {\n        const result = [];\n        function traverse(node) {\n          if (node) {\n            traverse(node.left);\n            result.push(node.value);\n            traverse(node.right);\n          }\n        }\n        traverse(this.root);\n        return result;\n      }\n\n      preorder() {\n        const result = [];\n        function traverse(node) {\n          if (node) {\n            result.push(node.value);\n            traverse(node.left);\n            traverse(node.right);\n          }\n        }\n        traverse(this.root);\n        return result;\n      }\n\n      postorder() {\n        const result = [];\n        function traverse(node) {\n          if (node) {\n            traverse(node.left);\n            traverse(node.right);\n            result.push(node.value);\n          }\n        }\n        traverse(this.root);\n        return result;\n      }\n\n      levelorder() {\n        const result = [];\n        if (this.root === null) return result;\n\n        const queue = [this.root];\n        while (queue.length > 0) {\n          const node = queue.shift();\n          result.push(node.value);\n          if (node.left) queue.push(node.left);\n          if (node.right) queue.push(node.right);\n        }\n        return result;\n      }\n    }\n\n    // Visualization on canvas\n\n    const canvas = document.getElementById('bstCanvas');\n    const ctx = canvas.getContext('2d');\n\n    const radius = 20;\n    const verticalGap = 75; // vertical distance between levels\n\n    function clearCanvas() {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Compute horizontal positions - using inorder indexing\n    function assignPositions(root) {\n      // We assign x coordinate based on inorder sequence index\n      let xPos = 0;\n      const xGap = 50; // horizontal gap between nodes\n\n      function inorderAssign(node, depth) {\n        if (!node) return;\n        inorderAssign(node.left, depth + 1);\n        node.x = xPos * xGap + radius + 10;\n        node.y = depth * verticalGap + radius + 10;\n        xPos++;\n        inorderAssign(node.right, depth + 1);\n      }\n      xPos = 0;\n      inorderAssign(root, 0);\n    }\n\n    function drawLine(x1, y1, x2, y2) {\n      ctx.beginPath();\n      ctx.strokeStyle = '#777';\n      ctx.lineWidth = 2;\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.stroke();\n    }\n\n    function drawNode(node, highlight = false, highlightColor = '#ff9800') {\n      if (!node) return;\n      ctx.beginPath();\n      ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);\n      ctx.fillStyle = highlight ? highlightColor : '#4caf50';\n      ctx.fill();\n      ctx.lineWidth = 3;\n      ctx.strokeStyle = '#2e7d32';\n      ctx.stroke();\n\n      ctx.fillStyle = 'white';\n      ctx.font = 'bold 16px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(node.value, node.x, node.y);\n    }\n\n    // Recursively draw tree edges and nodes\n    function drawTree(node, searchPath = []) {\n      if (!node) return;\n      // Draw edges to children first\n      if (node.left) {\n        drawLine(node.x, node.y, node.left.x, node.left.y);\n        drawTree(node.left, searchPath);\n      }\n      if (node.right) {\n        drawLine(node.x, node.y, node.right.x, node.right.y);\n        drawTree(node.right, searchPath);\n      }\n      // Draw node\n      const highlight = searchPath.includes(node);\n      drawNode(node, highlight);\n    }\n\n    // Highlight nodes in search path (used in search visualization)\n    function highlightSearchPath(node, value, path=[]) {\n      if (node === null) return path;\n      path.push(node);\n      if (value === node.value) return path;\n      else if (value < node.value) return highlightSearchPath(node.left, value, path);\n      else return highlightSearchPath(node.right, value, path);\n    }\n\n\n    // Main Application logic\n    const bst = new BST();\n\n    // UI elements\n    const valueInput = document.getElementById('valueInput');\n    const insertBtn = document.getElementById('insertBtn');\n    const deleteBtn = document.getElementById('deleteBtn');\n    const searchBtn = document.getElementById('searchBtn');\n    const clearBtn = document.getElementById('clearBtn');\n    const messageDiv = document.getElementById('message');\n\n    const inorderOutput = document.getElementById('inorderOutput');\n    const preorderOutput = document.getElementById('preorderOutput');\n    const postorderOutput = document.getElementById('postorderOutput');\n    const levelorderOutput = document.getElementById('levelorderOutput');\n\n    function updateTraversals() {\n      inorderOutput.textContent = bst.inorder().join(' → ') || '(empty)';\n      preorderOutput.textContent = bst.preorder().join(' → ') || '(empty)';\n      postorderOutput.textContent = bst.postorder().join(' → ') || '(empty)';\n      levelorderOutput.textContent = bst.levelorder().join(' → ') || '(empty)';\n    }\n\n    function renderTree(searchPath=[]) {\n      clearCanvas();\n      if (!bst.root) {\n        // Show a message in canvas area when empty\n        ctx.fillStyle = '#666';\n        ctx.font = '18px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(\"Tree is empty\", canvas.width/2, canvas.height/2);\n        return;\n      }\n      assignPositions(bst.root);\n      drawTree(bst.root, searchPath);\n    }\n\n    function resetMessage() {\n      messageDiv.textContent = '';\n      messageDiv.style.color = '#d32f2f';\n    }\n\n    // Insert handler\n    insertBtn.addEventListener('click', () => {\n      resetMessage();\n      const val = parseInt(valueInput.value.trim(), 10);\n      if (isNaN(val)) {\n        messageDiv.textContent = 'Please enter a valid number to insert.';\n        return;\n      }\n      const inserted = bst.insert(val);\n      if (!inserted) {\n        messageDiv.textContent = `Value ${val} already exists in the tree. Duplicates not allowed.`;\n      } else {\n        messageDiv.style.color = '#2e7d32';\n        messageDiv.textContent = `Inserted ${val} successfully.`;\n      }\n      updateTraversals();\n      renderTree();\n      valueInput.value = '';\n      valueInput.focus();\n    });\n\n    // Delete handler\n    deleteBtn.addEventListener('click', () => {\n      resetMessage();\n      const val = parseInt(valueInput.value.trim(), 10);\n      if (isNaN(val)) {\n        messageDiv.textContent = 'Please enter a valid number to delete.';\n        return;\n      }\n      const deleted = bst.delete(val);\n      if (!deleted) {\n        messageDiv.textContent = `Value ${val} was not found in the tree.`;\n      } else {\n        messageDiv.style.color = '#2e7d32';\n        messageDiv.textContent = `Deleted ${val} successfully.`;\n      }\n      updateTraversals();\n      renderTree();\n      valueInput.value = '';\n      valueInput.focus();\n    });\n\n    // Search handler with highlight animation\n    searchBtn.addEventListener('click', () => {\n      resetMessage();\n      const val = parseInt(valueInput.value.trim(), 10);\n      if (isNaN(val)) {\n        messageDiv.textContent = 'Please enter a valid number to search.';\n        return;\n      }\n      if (bst.root === null) {\n        messageDiv.textContent = 'Tree is empty.';\n        return;\n      }\n\n      const path = highlightSearchPath(bst.root, val);\n\n      let i = 0;\n      function animateStep() {\n        if (i < path.length) {\n          clearCanvas();\n          assignPositions(bst.root);\n          drawTree(bst.root, path.slice(0, i+1));\n          i++;\n          setTimeout(animateStep, 600);\n        }\n        else {\n          if (path[path.length-1].value === val) {\n            messageDiv.style.color = '#2e7d32';\n            messageDiv.textContent = `Value ${val} found in the tree.`;\n          } else {\n            messageDiv.style.color = '#d32f2f';\n            messageDiv.textContent = `Value ${val} NOT found in the tree.`;\n          }\n          updateTraversals();\n        }\n      }\n      animateStep();\n      valueInput.value = '';\n      valueInput.focus();\n    });\n\n    // Clear tree handler\n    clearBtn.addEventListener('click', () => {\n      resetMessage();\n      if (bst.root === null) {\n        messageDiv.textContent = 'Tree is already empty.';\n        return;\n      }\n      bst.root = null;\n      messageDiv.style.color = '#2e7d32';\n      messageDiv.textContent = 'Tree cleared successfully.';\n      updateTraversals();\n      renderTree();\n      valueInput.value = '';\n      valueInput.focus();\n    });\n\n    // Initial UI state\n    updateTraversals();\n    renderTree();\n\n    // Enable enter key for input field to do insert by default\n    valueInput.addEventListener('keydown', (e) => {\n      if (e.key === 'Enter') {\n        insertBtn.click();\n      }\n    });\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}