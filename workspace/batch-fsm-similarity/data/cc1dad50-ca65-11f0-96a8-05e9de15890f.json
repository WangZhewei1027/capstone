{
  "id": "cc1dad50-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:21.623Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Priority Queue",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Priority Queue (Binary Heap) — Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --muted:#9aa7bb;\n      --accent:#3ddc97;\n      --accent2:#60a5fa;\n      --card:#081223;\n      --danger:#fb7185;\n    }\n    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(180deg,#071026, #071027 60%);color:#cfe8ff}\n    .wrap{max-width:1100px;margin:20px auto;padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}\n    h1{margin:6px 0 8px;font-size:20px}\n    p.lead{margin:0 0 18px;color:var(--muted);font-size:13px}\n    .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:14px}\n    .card{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02);min-width:220px}\n    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}\n    input[type=\"text\"], input[type=\"number\"], select{width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;box-sizing:border-box}\n    .row{display:flex;gap:8px}\n    button{padding:8px 10px;border-radius:8px;border:0;background:var(--accent);color:#012017;cursor:pointer;font-weight:600}\n    button.alt{background:var(--accent2);color:#071640}\n    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}\n    button.danger{background:var(--danger);color:#4b0710}\n    .small{padding:6px 8px;font-size:13px}\n    .viz{display:flex;gap:12px;margin-top:14px}\n    .left{flex:1;min-width:300px}\n    .right{width:360px;min-width:260px}\n    .arrayView{display:flex;flex-wrap:wrap;gap:8px;padding:10px;min-height:70px}\n    .nodeBox{min-width:82px;flex:0 0 82px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:8px;padding:8px;text-align:center;border:1px solid rgba(255,255,255,0.03)}\n    .muted{color:var(--muted);font-size:13px}\n    .id{font-size:11px;color:var(--muted);margin-top:4px}\n    .heapCanvas{background:transparent;min-height:320px;border-radius:8px;padding:6px;position:relative}\n    .log{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));padding:8px;border-radius:8px;height:200px;overflow:auto;border:1px solid rgba(255,255,255,0.02)}\n    .status{margin-top:8px;color:var(--muted);font-size:13px}\n    .controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}\n    .info{font-size:13px;color:var(--muted);margin-top:10px}\n    svg{width:100%;height:360px;display:block}\n    .nodeCircle{fill:#07293a;stroke:rgba(255,255,255,0.06);stroke-width:1.5}\n    .nodeText{font-size:12px;fill:#dff7ff;text-anchor:middle}\n    .nodeSub{font-size:11px;fill:var(--muted);text-anchor:middle}\n    .link{stroke:rgba(255,255,255,0.06);stroke-width:1.2}\n    .highlight{filter:drop-shadow(0 6px 12px rgba(52,211,153,0.08));stroke:rgba(61,220,151,0.9);stroke-width:2}\n    .swapAnim{animation:swapFlash 700ms ease}\n    @keyframes swapFlash{\n      0%{transform:scale(1)}\n      50%{transform:scale(1.05)}\n      100%{transform:scale(1)}\n    }\n    .footer{display:flex;justify-content:space-between;align-items:center;margin-top:12px;color:var(--muted);font-size:13px}\n    .badge{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:999px}\n    .extractedList{display:flex;flex-wrap:wrap;gap:6px;padding:8px;border-radius:6px}\n    .chip{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:999px;font-size:13px}\n  </style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <h1>Priority Queue — Interactive Binary Heap Demo</h1>\n    <p class=\"lead\">This demo implements a priority queue using a binary heap (array-backed). Try enqueueing items with priorities, peek, dequeue, change priorities, and watch the heap (tree + array) update. Choose Min or Max behavior and enable stability (FIFO for equal priorities).</p>\n\n    <div class=\"controls\">\n      <div class=\"card\" style=\"flex:1;min-width:420px\">\n        <div style=\"display:flex;gap:10px;align-items:center\">\n          <div style=\"flex:1\">\n            <label>Item value (string)</label>\n            <input id=\"itemValue\" type=\"text\" placeholder=\"e.g. task-A\" value=\"task\"/>\n          </div>\n          <div style=\"width:120px\">\n            <label>Priority (number)</label>\n            <input id=\"itemPriority\" type=\"number\" value=\"5\" />\n          </div>\n          <div style=\"width:140px\">\n            <label>Type</label>\n            <select id=\"queueType\">\n              <option value=\"min\">Min-Heap (smallest priority first)</option>\n              <option value=\"max\">Max-Heap (largest priority first)</option>\n            </select>\n          </div>\n        </div>\n\n        <div style=\"display:flex;gap:8px;margin-top:10px;align-items:center\">\n          <button id=\"enqueueBtn\">Enqueue</button>\n          <button id=\"enqueueRand\" class=\"alt small\">Enqueue Random</button>\n          <button id=\"dequeueBtn\" class=\"ghost small\">Dequeue</button>\n          <button id=\"peekBtn\" class=\"ghost small\">Peek</button>\n          <button id=\"dequeueAll\" class=\"danger small\">Dequeue All</button>\n        </div>\n\n        <div style=\"display:flex;gap:8px;margin-top:10px;align-items:center\">\n          <div style=\"width:140px\">\n            <label>Change priority by ID</label>\n            <input id=\"changeId\" type=\"text\" placeholder=\"id e.g. 3\" />\n          </div>\n          <div style=\"width:120px\">\n            <label>New priority</label>\n            <input id=\"changePr\" type=\"number\" />\n          </div>\n          <div style=\"display:flex;align-items:end\">\n            <button id=\"changeBtn\" class=\"small\">Change</button>\n          </div>\n        </div>\n\n        <div style=\"display:flex;gap:8px;margin-top:10px;align-items:center\">\n          <label style=\"margin:0\"><input id=\"stableChk\" type=\"checkbox\" /> Stable (preserve insertion order for ties)</label>\n          <label style=\"margin:0\"><input id=\"animChk\" type=\"checkbox\" checked /> Animate swaps</label>\n          <label style=\"margin:0\">Speed <input id=\"speedRange\" type=\"range\" min=\"50\" max=\"1200\" value=\"300\" style=\"vertical-align:middle\" /></label>\n          <button id=\"clearBtn\" class=\"ghost small\">Clear</button>\n        </div>\n\n      </div>\n\n      <div class=\"card\">\n        <label>Current Queue</label>\n        <div class=\"muted\" id=\"meta\">size: 0 — implementation: binary heap</div>\n        <div style=\"margin-top:8px\" class=\"arrayView\" id=\"arrayView\"></div>\n        <div class=\"status\" id=\"statusLine\"></div>\n      </div>\n    </div>\n\n    <div class=\"viz\">\n      <div class=\"left card\">\n        <label>Heap tree (visual)</label>\n        <div class=\"heapCanvas\">\n          <svg id=\"heapSvg\" viewBox=\"0 0 1000 360\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n        </div>\n      </div>\n\n      <div class=\"right card\">\n        <label>Logs & Extracted</label>\n        <div class=\"log\" id=\"logArea\"></div>\n        <div class=\"info\" style=\"margin-top:8px\">\n          Extracted (dequeued in order):\n          <div class=\"extractedList\" id=\"extracted\"></div>\n        </div>\n\n        <div class=\"info\">\n          Complexity: Enqueue/Dequeue — O(log n) average & worst, Peek — O(1). This demo uses a binary heap stored in an array. When \"stable\" is enabled, a monotonic insertion index breaks ties preserving FIFO order for equal priorities.\n        </div>\n      </div>\n    </div>\n\n    <div class=\"footer\">\n      <div class=\"badge\">Implementation: binary heap (array)</div>\n      <div class=\"muted\">Notes: equal priorities use the selected stability behavior. Try inserting many items and watch how the heap reorders.</div>\n    </div>\n  </div>\n\n  <script>\n    // Priority Queue (binary heap) implementation with visualization callbacks.\n    (function(){\n      // Utility sleep\n      const sleep = ms => new Promise(r=>setTimeout(r,ms));\n\n      class PriorityQueue {\n        constructor({type='min', stable=false, onUpdate=null, animate=true, animationDelay=250} = {}) {\n          this.heap = []; // array of nodes\n          this.type = type; // 'min' or 'max'\n          this.stable = stable;\n          this._insertCounter = 0; // for stable tie-break\n          this.onUpdate = onUpdate;\n          this.animate = animate;\n          this.animationDelay = animationDelay;\n        }\n\n        size(){ return this.heap.length; }\n        isEmpty(){ return this.size() === 0; }\n\n        // comparator returns true if a has higher priority than b (i.e., should be above)\n        _cmp(a,b){\n          if (a.priority === b.priority) {\n            if (this.stable) {\n              // lower insertOrder means earlier insertion -> higher priority for ties in min-heap\n              return (this.type === 'min') ? (a.insertOrder < b.insertOrder) : (a.insertOrder > b.insertOrder);\n            }\n            return false; // treat as equal\n          }\n          return (this.type === 'min') ? (a.priority < b.priority) : (a.priority > b.priority);\n        }\n\n        // swap with animation/update\n        async _swap(i,j){\n          const h = this.heap;\n          const tmp = h[i];\n          h[i] = h[j];\n          h[j] = tmp;\n          if (this.onUpdate) {\n            this.onUpdate({type:'swap', indices:[i,j], heap:this.heap.slice()});\n          }\n          if (this.animate) await sleep(this.animationDelay);\n        }\n\n        async enqueue(value, priority=0){\n          const node = {id: ++PriorityQueue._UID, value: String(value), priority: Number(priority), insertOrder: this._insertCounter++};\n          this.heap.push(node);\n          if (this.onUpdate) this.onUpdate({type:'push', index:this.heap.length-1, node, heap:this.heap.slice()});\n          await this._heapifyUp(this.heap.length-1);\n          if (this.onUpdate) this.onUpdate({type:'update', heap:this.heap.slice()});\n          return node;\n        }\n\n        peek(){\n          return this.heap[0] || null;\n        }\n\n        async dequeue(){\n          if (this.isEmpty()) return null;\n          const root = this.heap[0];\n          if (this.heap.length === 1) {\n            this.heap.pop();\n            if (this.onUpdate) this.onUpdate({type:'pop', heap:this.heap.slice()});\n            return root;\n          }\n          // replace root with last and heapify down\n          this.heap[0] = this.heap.pop();\n          if (this.onUpdate) this.onUpdate({type:'replaceRoot', heap:this.heap.slice()});\n          await this._heapifyDown(0);\n          if (this.onUpdate) this.onUpdate({type:'update', heap:this.heap.slice()});\n          return root;\n        }\n\n        async changePriorityById(id, newPriority){\n          const idx = this.heap.findIndex(n => String(n.id) === String(id));\n          if (idx === -1) return false;\n          const old = this.heap[idx].priority;\n          this.heap[idx].priority = Number(newPriority);\n          if (this.onUpdate) this.onUpdate({type:'change', index:idx, node:this.heap[idx], heap:this.heap.slice()});\n          // decide whether to bubble up or down\n          if ((this.type === 'min' && this.heap[idx].priority < old) || (this.type === 'max' && this.heap[idx].priority > old)) {\n            await this._heapifyUp(idx);\n          } else {\n            await this._heapifyDown(idx);\n          }\n          if (this.onUpdate) this.onUpdate({type:'update', heap:this.heap.slice()});\n          return true;\n        }\n\n        async removeById(id){\n          const idx = this.heap.findIndex(n => String(n.id) === String(id));\n          if (idx === -1) return false;\n          if (idx === this.heap.length-1) {\n            this.heap.pop();\n            if (this.onUpdate) this.onUpdate({type:'pop', heap:this.heap.slice()});\n            return true;\n          }\n          // swap with last and pop\n          await this._swap(idx, this.heap.length-1);\n          this.heap.pop();\n          if (this.onUpdate) this.onUpdate({type:'removed', heap:this.heap.slice()});\n          // fix heap at idx\n          await this._heapifyUp(idx);\n          await this._heapifyDown(idx);\n          if (this.onUpdate) this.onUpdate({type:'update', heap:this.heap.slice()});\n          return true;\n        }\n\n        async _heapifyUp(index){\n          let i = index;\n          while (i > 0) {\n            const parent = Math.floor((i-1)/2);\n            if (this._cmp(this.heap[i], this.heap[parent])) {\n              await this._swap(i, parent);\n              i = parent;\n            } else break;\n          }\n        }\n\n        async _heapifyDown(index){\n          let i = index;\n          const n = this.heap.length;\n          while (true) {\n            const left = 2*i + 1;\n            const right = 2*i + 2;\n            let candidate = i;\n            if (left < n && this._cmp(this.heap[left], this.heap[candidate])) candidate = left;\n            if (right < n && this._cmp(this.heap[right], this.heap[candidate])) candidate = right;\n            if (candidate !== i) {\n              await this._swap(i, candidate);\n              i = candidate;\n            } else break;\n          }\n        }\n\n        clear(){\n          this.heap = [];\n          this._insertCounter = 0;\n          if (this.onUpdate) this.onUpdate({type:'clear', heap:this.heap.slice()});\n        }\n      }\n      // static unique id counter\n      PriorityQueue._UID = 0;\n\n      // ----- UI wiring & visualization -----\n      const svg = document.getElementById('heapSvg');\n      const arrayView = document.getElementById('arrayView');\n      const logArea = document.getElementById('logArea');\n      const extractedDiv = document.getElementById('extracted');\n      const meta = document.getElementById('meta');\n      const statusLine = document.getElementById('statusLine');\n\n      // controls\n      const enqueueBtn = document.getElementById('enqueueBtn');\n      const enqueueRandBtn = document.getElementById('enqueueRand');\n      const dequeueBtn = document.getElementById('dequeueBtn');\n      const peekBtn = document.getElementById('peekBtn');\n      const dequeueAllBtn = document.getElementById('dequeueAll');\n      const clearBtn = document.getElementById('clearBtn');\n      const itemValue = document.getElementById('itemValue');\n      const itemPriority = document.getElementById('itemPriority');\n      const queueType = document.getElementById('queueType');\n      const stableChk = document.getElementById('stableChk');\n      const animChk = document.getElementById('animChk');\n      const speedRange = document.getElementById('speedRange');\n      const changeBtn = document.getElementById('changeBtn');\n      const changeId = document.getElementById('changeId');\n      const changePr = document.getElementById('changePr');\n\n      // state\n      let pq = null;\n      let animInProgress = false;\n      let extracted = [];\n\n      function log(msg){\n        const time = new Date().toLocaleTimeString();\n        const el = document.createElement('div');\n        el.style.marginBottom = '6px';\n        el.innerHTML = `<span style=\"color:var(--muted);font-size:12px\">[${time}]</span> ${msg}`;\n        logArea.prepend(el);\n      }\n\n      function renderArrayView(heap){\n        arrayView.innerHTML = '';\n        if (!heap.length) {\n          const e = document.createElement('div');\n          e.className = 'muted';\n          e.textContent = '(empty)';\n          arrayView.appendChild(e);\n          return;\n        }\n        heap.forEach((n, idx) => {\n          const box = document.createElement('div');\n          box.className = 'nodeBox';\n          box.innerHTML = `<div style=\"font-weight:700\">${escapeHtml(n.value)}</div>\n                           <div class=\"muted\">prio: ${n.priority}</div>\n                           <div class=\"id\">id:${n.id}${pq.stable ? ' • ord:'+n.insertOrder : ''}</div>\n                           <div class=\"muted\" style=\"margin-top:6px;font-size:12px\">idx:${idx}</div>`;\n          arrayView.appendChild(box);\n        });\n      }\n\n      // simple escape\n      function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }\n\n      function renderTree(heap, highlightIndices=[]){\n        // draw nodes per index with positions\n        const W = 1000, H = 360;\n        const levels = Math.max(1, Math.ceil(Math.log2(heap.length+1)));\n        svg.innerHTML = '';\n        if (heap.length === 0) {\n          const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n          text.setAttribute('x','500');\n          text.setAttribute('y','180');\n          text.setAttribute('text-anchor','middle');\n          text.setAttribute('fill','var(--muted)');\n          text.setAttribute('font-size','16');\n          text.textContent = '(empty)';\n          svg.appendChild(text);\n          return;\n        }\n\n        const positions = []; // {x,y}\n        const levelHeight = H / (levels + 1);\n\n        for (let i=0;i<heap.length;i++){\n          const level = Math.floor(Math.log2(i+1));\n          const levelStart = Math.pow(2, level)-1;\n          const posInLevel = i - levelStart;\n          const nodesAtLevel = Math.pow(2, level);\n          const gap = W / nodesAtLevel;\n          const x = gap*(posInLevel + 0.5);\n          const y = 30 + level * levelHeight;\n          positions.push({x,y});\n        }\n\n        // draw links\n        for (let i=1;i<heap.length;i++){\n          const parent = Math.floor((i-1)/2);\n          const a = positions[parent], b = positions[i];\n          const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n          line.setAttribute('x1', a.x);\n          line.setAttribute('y1', a.y + 20);\n          line.setAttribute('x2', b.x);\n          line.setAttribute('y2', b.y - 18);\n          line.setAttribute('class','link');\n          line.style.stroke = 'rgba(255,255,255,0.05)';\n          svg.appendChild(line);\n        }\n\n        // draw nodes\n        heap.forEach((n,i) => {\n          const pos = positions[i];\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('transform', `translate(${pos.x},${pos.y})`);\n          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          circle.setAttribute('r', 28);\n          circle.setAttribute('class','nodeCircle');\n          if (highlightIndices.includes(i)) circle.setAttribute('class','nodeCircle highlight');\n          g.appendChild(circle);\n\n          const valText = document.createElementNS('http://www.w3.org/2000/svg','text');\n          valText.setAttribute('y','-3');\n          valText.setAttribute('class','nodeText');\n          valText.textContent = `${n.value}`;\n          g.appendChild(valText);\n\n          const subText = document.createElementNS('http://www.w3.org/2000/svg','text');\n          subText.setAttribute('y','16');\n          subText.setAttribute('class','nodeSub');\n          subText.textContent = `id:${n.id} p:${n.priority}`;\n          g.appendChild(subText);\n\n          svg.appendChild(g);\n        });\n      }\n\n      // initialize PQ with hooks\n      function createPQ(){\n        if (pq && !animInProgress) pq = null;\n        const type = queueType.value;\n        const stable = stableChk.checked;\n        const anim = animChk.checked;\n        const speed = Number(speedRange.value);\n        pq = new PriorityQueue({\n          type, stable, onUpdate: onPQUpdate, animate:anim, animationDelay: speed\n        });\n        extracted = [];\n        updateMeta();\n        renderArrayView([]);\n        renderTree([]);\n        extractedDiv.innerHTML = '';\n        log(`Created new ${type === 'min' ? 'Min' : 'Max'}-heap priority queue${stable ? ' (stable)' : ''}, animation ${anim ? 'on' : 'off'} (delay ${speed}ms).`);\n      }\n\n      // on update callback from pq\n      let lastUpdate = null;\n      function onPQUpdate(evt){\n        lastUpdate = evt;\n        // render quickly — for swaps include highlight\n        if (evt.type === 'swap' && evt.indices) {\n          renderArrayView(evt.heap);\n          renderTree(evt.heap, evt.indices);\n          statusLine.textContent = `Swapped indices ${evt.indices[0]} ↔ ${evt.indices[1]}`;\n        } else {\n          renderArrayView(evt.heap);\n          renderTree(evt.heap);\n          statusLine.textContent = `Operation: ${evt.type}`;\n        }\n        updateMeta();\n      }\n\n      function updateMeta(){\n        meta.textContent = `size: ${pq ? pq.size() : 0} — implementation: binary heap — type: ${queueType.value.toUpperCase()}${stableChk.checked ? ' • stable' : ''}`;\n      }\n\n      // Button handlers\n      enqueueBtn.addEventListener('click', async ()=>{\n        if (!pq) createPQ();\n        if (animInProgress) return;\n        const val = itemValue.value || 'item';\n        const pr = Number(itemPriority.value) || 0;\n        animInProgress = true;\n        log(`Enqueue \"${val}\" (prio ${pr})`);\n        const node = await pq.enqueue(val, pr);\n        renderArrayView(pq.heap);\n        renderTree(pq.heap);\n        updateMeta();\n        animInProgress = false;\n      });\n\n      enqueueRandBtn.addEventListener('click', async ()=>{\n        if (!pq) createPQ();\n        if (animInProgress) return;\n        animInProgress = true;\n        const count = Math.floor(Math.random()*5) + 1;\n        for (let i=0;i<count;i++){\n          const val = 't-'+Math.random().toString(36).slice(2,6);\n          const pr = Math.floor(Math.random()*20) - 5;\n          log(`Enqueue \"${val}\" (prio ${pr})`);\n          await pq.enqueue(val, pr);\n        }\n        renderArrayView(pq.heap);\n        renderTree(pq.heap);\n        updateMeta();\n        animInProgress = false;\n      });\n\n      dequeueBtn.addEventListener('click', async ()=>{\n        if (!pq) { createPQ(); return; }\n        if (animInProgress) return;\n        if (pq.isEmpty()) { log('Dequeue attempted on empty queue'); return; }\n        animInProgress = true;\n        const top = pq.peek();\n        log(`Dequeue -> id:${top.id} \"${top.value}\" (prio ${top.priority})`);\n        const popped = await pq.dequeue();\n        extracted.unshift(`${popped.value} (id:${popped.id}, p:${popped.priority})`);\n        renderExtracted();\n        renderArrayView(pq.heap);\n        renderTree(pq.heap);\n        updateMeta();\n        animInProgress = false;\n      });\n\n      peekBtn.addEventListener('click', ()=>{\n        if (!pq) createPQ();\n        const p = pq.peek();\n        if (!p) { log('Peek: queue empty'); return; }\n        log(`Peek -> id:${p.id} \"${p.value}\" (prio ${p.priority})`);\n      });\n\n      dequeueAllBtn.addEventListener('click', async ()=>{\n        if (!pq) createPQ();\n        if (animInProgress) return;\n        if (pq.isEmpty()) { log('Queue empty — nothing to dequeue'); return; }\n        animInProgress = true;\n        log('Dequeue All (extracting until empty)...');\n        while (!pq.isEmpty()){\n          const popped = await pq.dequeue();\n          extracted.unshift(`${popped.value} (id:${popped.id}, p:${popped.priority})`);\n          renderExtracted();\n        }\n        renderArrayView(pq.heap);\n        renderTree(pq.heap);\n        updateMeta();\n        animInProgress = false;\n      });\n\n      clearBtn.addEventListener('click', ()=>{\n        if (!pq) createPQ();\n        if (animInProgress) return;\n        pq.clear();\n        extracted = [];\n        extractedDiv.innerHTML = '';\n        renderArrayView([]);\n        renderTree([]);\n        updateMeta();\n        log('Cleared queue.');\n      });\n\n      changeBtn.addEventListener('click', async ()=>{\n        if (!pq) createPQ();\n        if (animInProgress) return;\n        const id = changeId.value.trim();\n        const newPr = changePr.value;\n        if (!id) { alert('Enter id to change'); return; }\n        if (newPr === '') { alert('Enter new priority'); return; }\n        if (pq.isEmpty()) { log('Queue empty — cannot change'); return; }\n        animInProgress = true;\n        const ok = await pq.changePriorityById(id, Number(newPr));\n        if (ok) log(`Changed priority of id:${id} to ${newPr}`);\n        else log(`ID ${id} not found`);\n        renderArrayView(pq.heap);\n        renderTree(pq.heap);\n        updateMeta();\n        animInProgress = false;\n      });\n\n      // when type/stability/anim settings change, recreate PQ preserving content optionally\n      queueType.addEventListener('change', ()=> {\n        recreateWithSettings();\n      });\n      stableChk.addEventListener('change', ()=> recreateWithSettings());\n      animChk.addEventListener('change', ()=> {\n        if (pq) pq.animate = animChk.checked;\n      });\n      speedRange.addEventListener('input', ()=> {\n        if (pq) pq.animationDelay = Number(speedRange.value);\n      });\n\n      function recreateWithSettings(){\n        if (!pq) { createPQ(); return; }\n        // preserve items: pull out heap array\n        const preserved = pq.heap.slice();\n        createPQ();\n        // reinsert preserved (preserve insertOrder to maintain stability)\n        (async ()=>{\n          animInProgress = true;\n          for (let n of preserved){\n            // keep id and insertOrder — but enqueue creates new node with new id; to preserve ids we directly push\n            // For simplicity here we re-enqueue values (new ids). This is OK for demo since user didn't expect id persistence.\n            await pq.enqueue(n.value, n.priority);\n          }\n          animInProgress = false;\n        })();\n      }\n\n      function renderExtracted(){\n        extractedDiv.innerHTML = '';\n        extracted.forEach(x=>{\n          const c = document.createElement('div');\n          c.className = 'chip';\n          c.textContent = x;\n          extractedDiv.appendChild(c);\n        });\n      }\n\n      // create initial PQ\n      createPQ();\n\n      // seed some items\n      (async ()=>{\n        await pq.enqueue('alpha', 4);\n        await pq.enqueue('beta', 2);\n        await pq.enqueue('gamma', 7);\n        await pq.enqueue('delta', 2);\n        await pq.enqueue('epsilon', 5);\n        renderArrayView(pq.heap);\n        renderTree(pq.heap);\n        updateMeta();\n        log('Seeded with example items.');\n      })();\n\n      // allow clicking nodes in array view to prefill change ID field\n      arrayView.addEventListener('click', (e)=>{\n        const box = e.target.closest('.nodeBox');\n        if (!box) return;\n        const idLine = box.querySelector('.id');\n        if (!idLine) return;\n        const m = idLine.textContent.match(/id:(\\d+)/);\n        if (m) { changeId.value = m[1]; }\n      });\n\n      // keyboard Enter to enqueue\n      itemValue.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') enqueueBtn.click(); });\n      itemPriority.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') enqueueBtn.click(); });\n\n      // small UX: resize SVG viewBox on window resize to keep things crisp\n      window.addEventListener('resize', ()=> renderTree(pq ? pq.heap : []));\n\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Priority Queue"
    }
  ],
  "topic": "Priority Queue",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}