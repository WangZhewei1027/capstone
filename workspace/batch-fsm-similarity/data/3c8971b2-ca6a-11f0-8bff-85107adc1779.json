{
  "id": "3c8971b2-ca6a-11f0-8bff-85107adc1779",
  "timestamp": "2025-11-26T01:51:24.886Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Depth-First Search (DFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Depth-First Search (DFS) Demonstration</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  #graph {\n    margin: 20px 0;\n  }\n  svg {\n    border: 1px solid #ccc;\n    background: #fafafa;\n  }\n  circle.node {\n    fill: #ddd;\n    stroke: #666;\n    stroke-width: 2px;\n    cursor: pointer;\n    transition: fill 0.3s;\n  }\n  circle.node.visited {\n    fill: #4caf50;\n    stroke: #2e7d32;\n  }\n  circle.node.current {\n    fill: #ff9800;\n    stroke: #ef6c00;\n  }\n  line.edge {\n    stroke: #999;\n    stroke-width: 2px;\n    transition: stroke 0.3s;\n  }\n  line.edge.visited {\n    stroke: #4caf50;\n    stroke-width: 3px;\n  }\n  #controls {\n    margin: 10px 0;\n  }\n  #log {\n    background: #222;\n    color: #eee;\n    height: 150px;\n    overflow-y: auto;\n    padding: 10px;\n    border-radius: 5px;\n    font-family: monospace;\n    white-space: pre-wrap;\n  }\n  button {\n    padding: 8px 14px;\n    margin-right: 10px;\n    font-size: 14px;\n    cursor: pointer;\n  }\n  select {\n    font-size: 14px;\n    padding: 6px;\n  }\n  #title {\n    margin-bottom: 5px;\n  }\n</style>\n</head>\n<body>\n<h1 id=\"title\">Depth-First Search (DFS) Visualization</h1>\n\n<div id=\"controls\">\n  <label for=\"startNode\">Select start node:</label>\n  <select id=\"startNode\"></select>\n  <button id=\"startDFS\">Start DFS</button>\n  <button id=\"reset\">Reset</button>\n</div>\n\n<div id=\"graph\">\n<!-- SVG graph will be rendered here -->\n<svg width=\"600\" height=\"400\" aria-label=\"Graph visualization\"></svg>\n</div>\n\n<h3>DFS Log</h3>\n<div id=\"log\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n\n<script>\n// Graph data: nodes and edges\n// We'll define a sample connected graph\nconst nodes = [\n  { id: 'A', x: 100, y: 80 },\n  { id: 'B', x: 250, y: 50 },\n  { id: 'C', x: 250, y: 150 },\n  { id: 'D', x: 400, y: 90 },\n  { id: 'E', x: 400, y: 210 },\n  { id: 'F', x: 550, y: 50 },\n  { id: 'G', x: 550, y: 150 },\n];\n\nconst edges = [\n  { from: 'A', to: 'B' },\n  { from: 'A', to: 'C' },\n  { from: 'B', to: 'D' },\n  { from: 'C', to: 'E' },\n  { from: 'D', to: 'F' },\n  { from: 'E', to: 'G' },\n  { from: 'F', to: 'G' }\n];\n\n// Build adjacency list for DFS\nconst adjacency = {};\nnodes.forEach(n => adjacency[n.id] = []);\nedges.forEach(({from, to}) => {\n  adjacency[from].push(to);\n  adjacency[to].push(from); // Undirected graph\n});\n\n// Sort adjacency lists for consistent traversal order\nfor (const k in adjacency) {\n  adjacency[k].sort();\n}\n\nconst svg = document.querySelector('svg');\nconst LOG = document.getElementById('log');\nconst startSelect = document.getElementById('startNode');\nconst startBtn = document.getElementById('startDFS');\nconst resetBtn = document.getElementById('reset');\n\nlet nodeElements = {};\nlet edgeElements = {};\nlet running = false;\nlet visited = new Set();\nlet stack = [];\n\n// Populate start node selector\nfunction populateStartNodes() {\n  startSelect.innerHTML = '';\n  for (const node of nodes) {\n    const option = document.createElement('option');\n    option.value = node.id;\n    option.textContent = node.id;\n    startSelect.appendChild(option);\n  }\n}\npopulateStartNodes();\n\nfunction log(message) {\n  LOG.textContent += message + '\\n';\n  LOG.scrollTop = LOG.scrollHeight;\n}\n\n// Create SVG graph elements\nfunction drawGraph() {\n  svg.innerHTML = '';\n  nodeElements = {};\n  edgeElements = {};\n\n  // Draw edges first\n  for (const e of edges) {\n    const fromNode = nodes.find(n => n.id === e.from);\n    const toNode = nodes.find(n => n.id === e.to);\n    const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    line.setAttribute('x1', fromNode.x);\n    line.setAttribute('y1', fromNode.y);\n    line.setAttribute('x2', toNode.x);\n    line.setAttribute('y2', toNode.y);\n    line.classList.add('edge');\n    // Store for easy reference, edge key: \"A-B\" sorted\n    let key = [e.from, e.to].sort().join('-');\n    edgeElements[key] = line;\n    svg.appendChild(line);\n  }\n\n  // Draw nodes\n  for (const n of nodes) {\n    const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    g.setAttribute('tabindex', '0'); // Make focusable\n    g.setAttribute('role', 'button');\n    g.setAttribute('aria-label', `Node ${n.id}`);\n\n    const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    circle.setAttribute('cx', n.x);\n    circle.setAttribute('cy', n.y);\n    circle.setAttribute('r', 20);\n    circle.classList.add('node');\n    g.appendChild(circle);\n\n    const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    text.setAttribute('x', n.x);\n    text.setAttribute('y', n.y + 6);\n    text.setAttribute('text-anchor', 'middle');\n    text.setAttribute('font-size', '16px');\n    text.setAttribute('pointer-events', 'none');\n    text.textContent = n.id;\n    g.appendChild(text);\n\n    nodeElements[n.id] = circle;\n    svg.appendChild(g);\n\n    // Clicking a node selects it as start node if DFS not running\n    g.addEventListener('click', () => {\n      if (!running) {\n        startSelect.value = n.id;\n      }\n    });\n  }\n}\n\ndrawGraph();\n\nfunction resetGraph() {\n  visited.clear();\n  stack = [];\n  running = false;\n  LOG.textContent = '';\n  for (const nId in nodeElements) {\n    nodeElements[nId].classList.remove('visited', 'current');\n  }\n  for (const eKey in edgeElements) {\n    edgeElements[eKey].classList.remove('visited');\n  }\n  startBtn.disabled = false;\n  startSelect.disabled = false;\n  resetBtn.disabled = false;\n}\n\nresetBtn.addEventListener('click', () => {\n  resetGraph();\n});\n\n// Utility function to get edge between two nodes (undirected)\nfunction getEdgeElement(a, b) {\n  const key = [a, b].sort().join('-');\n  return edgeElements[key];\n}\n\n// Async DFS function to animate steps with delay\nasync function dfs(start) {\n  running = true;\n  startBtn.disabled = true;\n  startSelect.disabled = true;\n  resetBtn.disabled = true;\n\n  log(`Starting DFS from node ${start}`);\n  stack.push(start);\n\n  while (stack.length > 0) {\n    const current = stack.pop();\n    if (!visited.has(current)) {\n      // Visit current node\n      visited.add(current);\n      log(`Visited node ${current}`);\n      // Visually mark node as visited\n      if (nodeElements[current]) {\n        nodeElements[current].classList.add('current');\n        // Pause to highlight current node\n        await new Promise(r => setTimeout(r, 700));\n        nodeElements[current].classList.remove('current');\n        nodeElements[current].classList.add('visited');\n      }\n\n      // Get neighbors in reverse order to get lex order with stack\n      const neighbors = adjacency[current].slice().reverse();\n      for (const neighbor of neighbors) {\n        if (!visited.has(neighbor)) {\n          stack.push(neighbor);\n          // Visually mark the edge traversed\n          const edge = getEdgeElement(current, neighbor);\n          if (edge) {\n            edge.classList.add('visited');\n          }\n          log(`Add neighbor ${neighbor} to stack`);\n          // Small pause to show edge highlight\n          await new Promise(r => setTimeout(r, 300));\n        }\n      }\n    } else {\n      log(`Node ${current} already visited, skipping.`);\n    }\n  }\n  log('DFS complete.');\n  running = false;\n  startBtn.disabled = false;\n  startSelect.disabled = false;\n  resetBtn.disabled = false;\n}\n\nstartBtn.addEventListener('click', () => {\n  if (running) return;\n  resetGraph();\n  const start = startSelect.value;\n  dfs(start);\n});\n\n// Initial reset to clear any highlights\nresetGraph();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Depth-First Search (DFS)"
    }
  ],
  "topic": "Depth-First Search (DFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}