{
  "id": "cc1e70a2-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:47.735Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<title>Prim's Algorithm Visualizer</title>\n<style>\n  :root{\n    --bg:#0f1724;\n    --panel:#0b1220cc;\n    --text:#e6eef8;\n    --muted:#9fb0cf;\n    --accent:#60a5fa;\n    --good:#34d399;\n    --warn:#fb923c;\n    --danger:#ef4444;\n  }\n  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;color:var(--text);background:linear-gradient(180deg,#071021 0%, #0a1628 100%);}\n  .container{display:flex;flex-direction:column;height:100%;gap:12px;padding:14px;}\n  .topbar{display:flex;gap:12px;align-items:center;}\n  .controls, .infos{background:var(--panel);padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(2,6,23,0.6);display:flex;gap:12px;align-items:center;flex-wrap:wrap;}\n  label{font-size:13px;color:var(--muted)}\n  input[type=range]{accent-color:var(--accent)}\n  button{background:linear-gradient(180deg,#1f2937,#111827);color:var(--text);border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}\n  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}\n  .small{padding:6px 8px;font-size:13px}\n  .svgwrapper{flex:1;background:linear-gradient(180deg,#071428 0%, #071a28 100%);border-radius:12px;position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}\n  svg{width:100%;height:100%;display:block}\n  .sidebar{width:360px;min-width:260px;max-width:420px;background:var(--panel);padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(2,6,23,0.6);display:flex;flex-direction:column;gap:10px;}\n  .row{display:flex;gap:8px;align-items:center}\n  .muted{color:var(--muted);font-size:13px}\n  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;gap:8px}\n  .pq{max-height:140px;overflow:auto}\n  .pq-item{display:flex;justify-content:space-between;padding:6px;border-radius:6px;background:rgba(255,255,255,0.02);font-size:13px}\n  .code{font-family:monospace;background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;font-size:13px;line-height:1.5}\n  .code .hl{background:linear-gradient(90deg, rgba(96,165,250,0.15), rgba(96,165,250,0.06));display:block;padding:2px 6px;border-radius:4px}\n  footer{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:13px;padding:6px 0}\n  .legend{display:flex;gap:8px;align-items:center}\n  .legend .item{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}\n  .swatch{width:18px;height:10px;border-radius:4px}\n  /* node and edge tooltip */\n  .tooltip{position:absolute;pointer-events:none;padding:6px 8px;background:#020617;border-radius:6px;border:1px solid rgba(255,255,255,0.04);color:var(--text);font-size:13px}\n  /* small helpers */\n  .flexcol{display:flex;flex-direction:column}\n  .grow{flex:1}\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <div class=\"topbar\">\n    <div class=\"controls\">\n      <label class=\"muted\">Nodes: <span id=\"nodeCountLabel\">10</span></label>\n      <input id=\"nodeCount\" type=\"range\" min=\"3\" max=\"20\" value=\"10\">\n      <label class=\"muted\">Density: <span id=\"densityLabel\">0.4</span></label>\n      <input id=\"density\" type=\"range\" min=\"0\" max=\"100\" value=\"40\">\n      <label class=\"muted\">Max Weight: <span id=\"maxWLabel\">20</span></label>\n      <input id=\"maxWeight\" type=\"range\" min=\"2\" max=\"50\" value=\"20\">\n      <button id=\"regen\" title=\"Generate new random graph\">Generate</button>\n      <button id=\"clear\" class=\"ghost\" title=\"Clear MST / reset algorithm\">Reset</button>\n    </div>\n    <div class=\"infos\">\n      <div class=\"muted\">Mode:</div>\n      <button id=\"selectStart\" class=\"small\">Choose Start Node</button>\n      <button id=\"autoRun\" class=\"small\">Auto Run</button>\n      <button id=\"stepBtn\" class=\"small\">Step</button>\n      <label class=\"muted\">Speed</label>\n      <input id=\"speed\" type=\"range\" min=\"100\" max=\"2000\" value=\"700\">\n    </div>\n  </div>\n\n  <div style=\"display:flex;gap:12px;flex:1;min-height:420px;\">\n    <div class=\"svgwrapper\" id=\"canvasWrapper\" style=\"flex:1;min-width:0;min-height:420px\">\n      <svg id=\"svgCanvas\" viewBox=\"0 0 1000 700\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n      <div id=\"tooltip\" class=\"tooltip\" style=\"display:none\"></div>\n    </div>\n\n    <div class=\"sidebar\">\n      <div class=\"card\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n          <div>\n            <div style=\"font-weight:700\">Prim's Algorithm</div>\n            <div class=\"muted\" style=\"font-size:13px\">Minimum Spanning Tree (MST) visualizer — weighted undirected graph</div>\n          </div>\n          <div style=\"text-align:right\">\n            <div class=\"muted\" style=\"font-size:13px\">MST Weight</div>\n            <div id=\"mstWeight\" style=\"font-weight:800;font-size:18px\">0</div>\n          </div>\n        </div>\n        <div style=\"display:flex;gap:8px\">\n          <div class=\"muted\" style=\"width:110px\">Visited</div>\n          <div id=\"visitedList\" class=\"muted\" style=\"flex:1\"></div>\n        </div>\n        <div style=\"display:flex;gap:8px\">\n          <div class=\"muted\" style=\"width:110px\">Edges in MST</div>\n          <div id=\"mstEdges\" class=\"muted\" style=\"flex:1\"></div>\n        </div>\n      </div>\n\n      <div class=\"card\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center\">\n          <div style=\"font-weight:700\">Priority Queue (frontier)</div>\n          <div class=\"muted\" style=\"font-size:12px\">min-weight first</div>\n        </div>\n        <div class=\"pq\" id=\"pqList\" aria-live=\"polite\"></div>\n      </div>\n\n      <div class=\"card\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center\">\n          <div style=\"font-weight:700\">Pseudo-code</div>\n        </div>\n        <div class=\"code\" id=\"pseudocode\">\n          <div id=\"line0\">1. Initialize MST set with start node.</div>\n          <div id=\"line1\">2. Insert all edges from start node into PQ.</div>\n          <div id=\"line2\">3. While PQ not empty and MST not complete:</div>\n          <div id=\"line3\" style=\"padding-left:14px\">a) Extract min edge (u,v,w).</div>\n          <div id=\"line4\" style=\"padding-left:14px\">b) If v not in MST, add edge to MST and add v to MST set.</div>\n          <div id=\"line5\" style=\"padding-left:14px\">c) Insert edges from v to PQ.</div>\n        </div>\n      </div>\n\n      <div class=\"card\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center\">\n          <div style=\"font-weight:700\">Legend</div>\n        </div>\n        <div class=\"legend\">\n          <div class=\"item\"><div class=\"swatch\" style=\"background:linear-gradient(90deg,#60a5fa,#3b82f6)\"></div> Frontier edge</div>\n          <div class=\"item\"><div class=\"swatch\" style=\"background:linear-gradient(90deg,#34d399,#16a34a)\"></div> MST edge</div>\n          <div class=\"item\"><div class=\"swatch\" style=\"background:linear-gradient(90deg,#f97316,#fb923c)\"></div> Selected edge</div>\n          <div class=\"item\"><div class=\"swatch\" style=\"background:#aab4bf\"></div> Idle edge</div>\n        </div>\n      </div>\n\n      <footer>\n        <div class=\"muted\">Click nodes to drag. Click \"Choose Start Node\" and pick a node.</div>\n        <div class=\"muted\">Author: Prim Visualizer</div>\n      </footer>\n    </div>\n  </div>\n</div>\n\n<script>\n/*\n  Prim's Algorithm Visualizer\n  - Undirected weighted graph\n  - Interactive: generate graph, select start node, step through algorithm or auto-run\n  - Visual cues: frontier edges (blue), selected edge (orange), MST edges (green)\n*/\n\nconst svg = document.getElementById('svgCanvas');\nconst tooltip = document.getElementById('tooltip');\nconst nodeCountInput = document.getElementById('nodeCount');\nconst densityInput = document.getElementById('density');\nconst maxWeightInput = document.getElementById('maxWeight');\nconst nodeCountLabel = document.getElementById('nodeCountLabel');\nconst densityLabel = document.getElementById('densityLabel');\nconst maxWLabel = document.getElementById('maxWLabel');\nconst regenBtn = document.getElementById('regen');\nconst clearBtn = document.getElementById('clear');\nconst selectStartBtn = document.getElementById('selectStart');\nconst autoRunBtn = document.getElementById('autoRun');\nconst stepBtn = document.getElementById('stepBtn');\nconst pqListEl = document.getElementById('pqList');\nconst mstWeightEl = document.getElementById('mstWeight');\nconst visitedListEl = document.getElementById('visitedList');\nconst mstEdgesEl = document.getElementById('mstEdges');\nconst speedInput = document.getElementById('speed');\n\nconst pseudocode = [\n  document.getElementById('line0'),\n  document.getElementById('line1'),\n  document.getElementById('line2'),\n  document.getElementById('line3'),\n  document.getElementById('line4'),\n  document.getElementById('line5'),\n];\n\nlet W = 1000, H = 700;\nlet state = {\n  nodes: [], // {id,x,y,el,txt}\n  edges: [], // {id,u,v,w,line,txt}\n  adj: [],   // adjacency list\n  mstSet: new Set(),\n  pq: [],    // array of {u,v,w,edgeId}\n  mstEdges: new Set(),\n  visitedOrder: [],\n  startNode: null,\n  running:false,\n  auto:false,\n  wantChooseStart:false,\n  selectedEdge:null,\n  lastAddedEdge:null,\n  timer:null\n};\n\nfunction randInt(a,b){return Math.floor(Math.random()*(b-a+1))+a}\n\nfunction clearSVG(){\n  while(svg.firstChild) svg.removeChild(svg.firstChild);\n}\n\nfunction makeGraph(n=10,density=0.4,maxW=20){\n  // Reset state\n  state.nodes = [];\n  state.edges = [];\n  state.adj = Array.from({length:n},()=>[]);\n  state.mstSet.clear();\n  state.pq = [];\n  state.mstEdges.clear();\n  state.visitedOrder = [];\n  state.startNode = null;\n  state.selectedEdge = null;\n  state.lastAddedEdge = null;\n  state.running = false;\n  state.auto = false;\n  if(state.timer) clearInterval(state.timer);\n\n  clearSVG();\n  // place nodes in circle-ish positions for readability\n  const cx = W/2, cy = H/2, r = Math.min(W,H)/2 - 90;\n  for(let i=0;i<n;i++){\n    const ang = (2*Math.PI*i)/n + (Math.random()-0.5)*0.4;\n    const rr = r*(0.6 + Math.random()*0.4);\n    const nx = cx + rr*Math.cos(ang) + randInt(-30,30);\n    const ny = cy + rr*Math.sin(ang) + randInt(-20,20);\n    const g = createNode(i, nx, ny);\n    state.nodes.push(g);\n  }\n\n  // add edges randomly based on density\n  let edgeId = 0;\n  for(let i=0;i<n;i++){\n    for(let j=i+1;j<n;j++){\n      if(Math.random() < density){\n        const w = randInt(1, maxW);\n        const e = createEdge(edgeId++, i, j, w);\n        state.edges.push(e);\n        state.adj[i].push({to:j,w,edgeId:e.id});\n        state.adj[j].push({to:i,w,edgeId:e.id});\n      }\n    }\n  }\n\n  // Ensure connectivity: if disconnected, connect components\n  const comp = Array(n).fill(-1);\n  let cid=0;\n  function dfs(u,c){\n    comp[u]=c;\n    for(const nb of state.adj[u]) if(comp[nb.to]===-1) dfs(nb.to,c);\n  }\n  for(let i=0;i<n;i++) if(comp[i]===-1) dfs(i,cid++);\n  if(cid>1){\n    // connect components by adding edges between random nodes of components\n    // collect nodes per component\n    const groups = Array.from({length:cid},()=>[]);\n    for(let i=0;i<n;i++) groups[comp[i]].push(i);\n    for(let k=1;k<cid;k++){\n      const a = groups[k][randInt(0,groups[k].length-1)];\n      const b = groups[0][randInt(0,groups[0].length-1)];\n      const w = randInt(1, maxW);\n      const e = createEdge(edgeId++, a, b, w);\n      state.edges.push(e);\n      state.adj[a].push({to:b,w,edgeId:e.id});\n      state.adj[b].push({to:a,w,edgeId:e.id});\n    }\n  }\n\n  refreshVisual();\n}\n\nfunction createNode(id,x,y){\n  const g = document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\");\n  g.setAttribute('data-id',id);\n  g.style.cursor='grab';\n  const circle = document.createElementNS(\"http://www.w3.org/2000/svg\",\"circle\");\n  circle.setAttribute('cx',x);\n  circle.setAttribute('cy',y);\n  circle.setAttribute('r',18);\n  circle.setAttribute('fill','#020617');\n  circle.setAttribute('stroke','#9fb0cf');\n  circle.setAttribute('stroke-opacity',0.12);\n  circle.setAttribute('stroke-width',1.8);\n\n  const txt = document.createElementNS(\"http://www.w3.org/2000/svg\",\"text\");\n  txt.setAttribute('x',x);\n  txt.setAttribute('y',y+5);\n  txt.setAttribute('fill','#dbeafe');\n  txt.setAttribute('font-size',12);\n  txt.setAttribute('font-family','monospace');\n  txt.setAttribute('text-anchor','middle');\n  txt.textContent = id;\n\n  g.appendChild(circle);\n  g.appendChild(txt);\n  svg.appendChild(g);\n\n  const node = {id,x,y,el:g,circle,txt};\n  makeDraggable(node);\n  node.el.addEventListener('mouseenter', ()=>showTooltipNode(node));\n  node.el.addEventListener('mouseleave', hideTooltip);\n  node.el.addEventListener('click', (ev)=>{\n    ev.stopPropagation();\n    if(state.wantChooseStart){\n      setStartNode(node.id);\n      state.wantChooseStart=false;\n      selectStartBtn.textContent='Choose Start Node';\n    }\n  });\n  return node;\n}\n\nfunction createEdge(id,u,v,w){\n  // draw line under nodes\n  const nu = {x:0,y:0}, nv = {x:0,y:0};\n  if(state.nodes[u]){ nu.x = state.nodes[u].x; nu.y=state.nodes[u].y; }\n  if(state.nodes[v]){ nv.x = state.nodes[v].x; nv.y=state.nodes[v].y; }\n  const line = document.createElementNS(\"http://www.w3.org/2000/svg\",\"line\");\n  line.setAttribute('x1',nu.x);\n  line.setAttribute('y1',nu.y);\n  line.setAttribute('x2',nv.x);\n  line.setAttribute('y2',nv.y);\n  line.setAttribute('stroke','#aab4bf');\n  line.setAttribute('stroke-opacity',0.14);\n  line.setAttribute('stroke-width',3);\n  line.setAttribute('data-id',id);\n  line.style.cursor='pointer';\n\n  const midx=(nu.x+nv.x)/2, midy=(nu.y+nv.y)/2;\n  const txt = document.createElementNS(\"http://www.w3.org/2000/svg\",\"text\");\n  txt.setAttribute('x',midx);\n  txt.setAttribute('y',midy-8);\n  txt.setAttribute('fill','#e6eef8');\n  txt.setAttribute('font-size',12);\n  txt.setAttribute('text-anchor','middle');\n  txt.setAttribute('pointer-events','none');\n  txt.textContent = w;\n\n  // put line first so it stays under nodes\n  svg.insertBefore(line, svg.firstChild);\n  svg.appendChild(txt);\n\n  const edge = {id,u,v,w,line,txt};\n  line.addEventListener('mouseenter', ()=>showTooltipEdge(edge));\n  line.addEventListener('mouseleave', hideTooltip);\n  line.addEventListener('click', (ev)=>{ ev.stopPropagation(); /* future: allow edit */});\n  return edge;\n}\n\nfunction makeDraggable(node){\n  let drag=false, offsetX=0, offsetY=0;\n  node.el.addEventListener('mousedown', (ev)=>{\n    drag=true;\n    node.el.style.cursor='grabbing';\n    offsetX = ev.clientX;\n    offsetY = ev.clientY;\n    ev.preventDefault();\n  });\n  window.addEventListener('mousemove', (ev)=>{\n    if(!drag) return;\n    const dx = (ev.clientX - offsetX) * (1000/svg.clientWidth);\n    const dy = (ev.clientY - offsetY) * (700/svg.clientHeight);\n    offsetX = ev.clientX; offsetY = ev.clientY;\n    node.x += dx; node.y += dy;\n    node.circle.setAttribute('cx', node.x);\n    node.circle.setAttribute('cy', node.y);\n    node.txt.setAttribute('x', node.x);\n    node.txt.setAttribute('y', node.y+5);\n    updateEdgesForNode(node.id);\n  });\n  window.addEventListener('mouseup', ()=>{\n    if(drag){\n      drag=false;\n      node.el.style.cursor='grab';\n    }\n  });\n}\n\nfunction updateEdgesForNode(nodeId){\n  for(const e of state.edges){\n    if(e.u===nodeId || e.v===nodeId){\n      const u = state.nodes[e.u], v = state.nodes[e.v];\n      e.line.setAttribute('x1', u.x);\n      e.line.setAttribute('y1', u.y);\n      e.line.setAttribute('x2', v.x);\n      e.line.setAttribute('y2', v.y);\n      const midx=(u.x+v.x)/2, midy=(u.y+v.y)/2;\n      e.txt.setAttribute('x',midx);\n      e.txt.setAttribute('y',midy-8);\n    }\n  }\n}\n\nfunction showTooltip(text,x,y){\n  tooltip.style.left = x + 12 + 'px';\n  tooltip.style.top = y + 12 + 'px';\n  tooltip.style.display = 'block';\n  tooltip.textContent = text;\n}\n\nfunction showTooltipNode(node){\n  showTooltip('Node ' + node.id, node.x, node.y);\n}\nfunction showTooltipEdge(edge){\n  showTooltip(`Edge ${edge.u} — ${edge.v} (w=${edge.w})`, (state.nodes[edge.u].x+state.nodes[edge.v].x)/2, (state.nodes[edge.u].y+state.nodes[edge.v].y)/2);\n}\nfunction hideTooltip(){ tooltip.style.display='none'; }\n\nfunction refreshVisual(){\n  // update edges styles by status\n  for(const e of state.edges){\n    // default\n    let color = '#aab4bf';\n    let opacity = 0.12;\n    let width = 3;\n    if(state.mstEdges.has(e.id)){\n      color = '#34d399';\n      opacity = 0.95;\n      width = 4.4;\n    } else if(state.selectedEdge && state.selectedEdge.edgeId===e.id){\n      color = '#fb923c';\n      opacity = 0.98;\n      width = 4.6;\n    } else if(state.pq.some(it=>it.edgeId===e.id)){\n      color = '#60a5fa';\n      opacity = 0.95;\n      width = 3.8;\n    }\n    e.line.setAttribute('stroke', color);\n    e.line.setAttribute('stroke-opacity', opacity);\n    e.line.setAttribute('stroke-width', width);\n    // ensure weight text color\n    e.txt.setAttribute('fill', (state.mstEdges.has(e.id) ? '#dcfce7' : '#e6eef8'));\n  }\n\n  // update visited nodes appearance\n  for(const n of state.nodes){\n    if(state.mstSet.has(n.id)){\n      n.circle.setAttribute('fill','#0b1220');\n      n.circle.setAttribute('stroke','#7ee787');\n      n.circle.setAttribute('stroke-width',2.6);\n      n.txt.setAttribute('fill','#d9fbe4');\n    } else {\n      n.circle.setAttribute('fill','#020617');\n      n.circle.setAttribute('stroke','#9fb0cf');\n      n.circle.setAttribute('stroke-opacity',0.12);\n      n.circle.setAttribute('stroke-width',1.8);\n      n.txt.setAttribute('fill','#e6eef8');\n    }\n  }\n\n  updatePQUI();\n  updateInfoUI();\n  highlightPseudo();\n}\n\nfunction updatePQUI(){\n  // sort pq by weight\n  state.pq.sort((a,b)=>a.w - b.w || a.v - b.v);\n  pqListEl.innerHTML = '';\n  for(const it of state.pq.slice()){\n    const div = document.createElement('div');\n    div.className='pq-item';\n    // show u -> v (w)\n    const left = document.createElement('div'); left.textContent = `${it.u} → ${it.v}`;\n    const right = document.createElement('div'); right.textContent = `w=${it.w}`;\n    div.appendChild(left); div.appendChild(right);\n    pqListEl.appendChild(div);\n  }\n}\n\nfunction updateInfoUI(){\n  mstWeightEl.textContent = Array.from(state.mstEdges).reduce((s,eid)=>{\n    const e = state.edges.find(x=>x.id===eid);\n    return s + (e?e.w:0);\n  },0);\n\n  visitedListEl.textContent = Array.from(state.mstSet).join(', ');\n  mstEdgesEl.textContent = Array.from(state.mstEdges).map(eid=>{\n    const e = state.edges.find(x=>x.id===eid);\n    return e ? `${e.u}-${e.v}` : '';\n  }).join(', ');\n}\n\nfunction setStartNode(id){\n  // reset algorithm state but keep graph\n  state.mstSet.clear();\n  state.mstEdges.clear();\n  state.pq=[];\n  state.visitedOrder=[];\n  state.startNode = id;\n  state.mstSet.add(id);\n  state.visitedOrder.push(id);\n  // push adjacent edges of start into pq\n  for(const nb of state.adj[id]){\n    state.pq.push({u:id, v:nb.to, w:nb.w, edgeId:nb.edgeId});\n  }\n  state.selectedEdge = null;\n  state.lastAddedEdge = null;\n  refreshVisual();\n}\n\nfunction stepPrim(){\n  // single step of Prim's algorithm\n  if(!state.startNode) {\n    alert('Please choose a start node first (press \"Choose Start Node\")');\n    return;\n  }\n  if(state.mstSet.size === state.nodes.length){\n    // done\n    state.running=false;\n    state.auto=false;\n    if(state.timer) clearInterval(state.timer);\n    return;\n  }\n  // if pq empty and not all visited -> graph disconnected (shouldn't happen)\n  if(state.pq.length===0){\n    // nothing to extract\n    state.running=false;\n    state.auto=false;\n    if(state.timer) clearInterval(state.timer);\n    alert('Priority queue empty. Graph might be disconnected.');\n    return;\n  }\n\n  // extract min edge whose v is not in MST (while pq exists)\n  // state.selectedEdge used to highlight extraction\n  while(state.pq.length){\n    // get min\n    state.pq.sort((a,b)=>a.w-b.w || a.u-b.u || a.v-b.v);\n    const e = state.pq.shift();\n    state.selectedEdge = e;\n    refreshVisual();\n    // highlight extraction briefly (when auto-run, will be visible)\n    // Check if v not already in MST (note: we might store edges where the endpoint is in MST)\n    if(!state.mstSet.has(e.v)){\n      // add edge to MST\n      state.mstEdges.add(e.edgeId);\n      state.mstSet.add(e.v);\n      state.visitedOrder.push(e.v);\n      state.lastAddedEdge = e;\n      // push edges from new node\n      for(const nb of state.adj[e.v]){\n        if(!state.mstSet.has(nb.to)){\n          state.pq.push({u:e.v, v:nb.to, w:nb.w, edgeId:nb.edgeId});\n        }\n      }\n      refreshVisual();\n      return;\n    } else {\n      // edge leads to already visited; continue\n      // continue loop to extract next min\n      refreshVisual();\n    }\n  }\n}\n\nfunction autoRunToggle(){\n  state.auto = !state.auto;\n  if(state.auto){\n    autoRunBtn.textContent = 'Pause';\n    // start timer\n    state.timer = setInterval(()=>{\n      if(state.mstSet.size === state.nodes.length || state.pq.length===0){\n        state.auto=false;\n        autoRunBtn.textContent='Auto Run';\n        clearInterval(state.timer);\n        return;\n      }\n      // small pre-step highlight: if queue empty -> finish\n      stepPrim();\n    }, Math.max(80, speedInput.value));\n  } else {\n    autoRunBtn.textContent = 'Auto Run';\n    if(state.timer) clearInterval(state.timer);\n  }\n}\n\nfunction resetAlgorithm(){\n  state.mstSet.clear();\n  state.pq=[];\n  state.mstEdges.clear();\n  state.visitedOrder=[];\n  state.startNode=null;\n  state.selectedEdge=null;\n  state.lastAddedEdge=null;\n  state.running=false;\n  state.auto=false;\n  if(state.timer) clearInterval(state.timer);\n  refreshVisual();\n}\n\nfunction highlightPseudo(){\n  // clear highlights\n  pseudocode.forEach(p=>p.className='');\n  // Decide which line to highlight:\n  // 0: start not chosen\n  if(!state.startNode){\n    pseudocode[0].className='hl';\n    return;\n  }\n  // when start chosen: show line1\n  pseudocode[1].className='hl';\n  // if PQ empty and not complete: highlight line2\n  if(state.pq.length===0 && state.mstSet.size < state.nodes.length){\n    pseudocode[2].className='hl';\n    return;\n  }\n  // if selectedEdge exists: highlight line3 (extract)\n  if(state.selectedEdge){\n    pseudocode[3].className='hl';\n    // if edge leads to new node then highlight 4 and 5\n    if(!state.mstSet.has(state.selectedEdge.v)){\n      pseudocode[4].className='hl';\n      pseudocode[5].className='hl';\n    }\n  }\n}\n\nfunction wireUI(){\n  nodeCountInput.addEventListener('input',()=>{\n    nodeCountLabel.textContent = nodeCountInput.value;\n  });\n  densityInput.addEventListener('input',()=>{\n    densityLabel.textContent = (densityInput.value/100).toFixed(2);\n  });\n  maxWeightInput.addEventListener('input',()=>{\n    maxWLabel.textContent = maxWeightInput.value;\n  });\n  regenBtn.addEventListener('click', ()=>{\n    makeGraph(parseInt(nodeCountInput.value), densityInput.value/100, parseInt(maxWeightInput.value));\n  });\n  clearBtn.addEventListener('click', resetAlgorithm);\n  selectStartBtn.addEventListener('click', ()=>{\n    state.wantChooseStart = !state.wantChooseStart;\n    selectStartBtn.textContent = state.wantChooseStart ? 'Click a node...' : 'Choose Start Node';\n  });\n  stepBtn.addEventListener('click', ()=>{\n    stepPrim();\n  });\n  autoRunBtn.addEventListener('click', autoRunToggle);\n  speedInput.addEventListener('input', ()=>{\n    if(state.auto){\n      clearInterval(state.timer);\n      state.timer = setInterval(()=>{\n        if(state.mstSet.size === state.nodes.length || state.pq.length===0){\n          state.auto=false;\n          autoRunBtn.textContent='Auto Run';\n          clearInterval(state.timer);\n          return;\n        }\n        stepPrim();\n      }, Math.max(80, speedInput.value));\n    }\n  });\n  // clicking on blank canvas cancels choosing start\n  svg.addEventListener('click', ()=>{\n    if(state.wantChooseStart){\n      state.wantChooseStart=false;\n      selectStartBtn.textContent='Choose Start Node';\n    }\n  });\n\n  // resize handling: keep viewBox static; svg scales automatically\n  window.addEventListener('resize', ()=>{});\n}\n\n// initialize with default graph\n(function init(){\n  W = 1000; H = 700;\n  nodeCountLabel.textContent = nodeCountInput.value;\n  densityLabel.textContent = (densityInput.value/100).toFixed(2);\n  maxWLabel.textContent = maxWeightInput.value;\n  wireUI();\n  makeGraph(parseInt(nodeCountInput.value), densityInput.value/100, parseInt(maxWeightInput.value));\n})();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}