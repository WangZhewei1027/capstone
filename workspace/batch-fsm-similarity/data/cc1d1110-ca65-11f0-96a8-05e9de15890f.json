{
  "id": "cc1d1110-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:01.285Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Binary Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\"/>\n  <title>Binary Tree (BST) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n  <style>\n    :root {\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #38bdf8;\n      --muted: #94a3b8;\n      --good: #10b981;\n      --danger: #ef4444;\n      --card: #071025;\n      --text: #e6eef8;\n    }\n    html,body { height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial; background: linear-gradient(180deg,#071029 0%, #041025 100%); color:var(--text); }\n    .container { max-width:1200px; margin:18px auto; padding:18px; }\n    header { display:flex; gap:16px; align-items:center; margin-bottom:16px; }\n    h1 { margin:0; font-size:20px; letter-spacing:0.2px; }\n    p.desc { margin:4px 0 0 0; color:var(--muted); font-size:13px; max-width:780px; }\n    .layout { display:grid; grid-template-columns: 340px 1fr; gap:16px; align-items:start; }\n    .panel { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); padding:14px; border-radius:10px; }\n    .controls { display:flex; flex-direction:column; gap:10px; }\n    label { font-size:13px; color:var(--muted); }\n    .row { display:flex; gap:8px; align-items:center; }\n    input[type=\"number\"], input[type=\"text\"], select { padding:8px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:var(--text); width:100%; outline:none; }\n    button { background:var(--panel); border:1px solid rgba(255,255,255,0.04); color:var(--text); padding:8px 10px; border-radius:6px; cursor:pointer; }\n    button.primary { background:linear-gradient(90deg,#0ea5e9,#06b6d4); color:#021024; border:none; font-weight:600; }\n    button.warn { background:linear-gradient(90deg,#fb7185,#fb923c); color:#071024; border:none; }\n    .small { padding:6px 8px; font-size:13px; }\n    .canvasWrap { background: linear-gradient(180deg,#041021,#02101a); min-height:620px; border-radius:10px; padding:12px; border:1px solid rgba(255,255,255,0.03); position:relative; overflow:auto; }\n    svg { width:100%; height:600px; display:block; }\n    .legend { display:flex; gap:8px; align-items:center; margin-top:8px; color:var(--muted); font-size:13px; }\n    .badge { display:inline-flex; gap:8px; align-items:center; padding:6px 8px; border-radius:6px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.02); }\n    .muted { color:var(--muted); font-size:13px; }\n    .footer { margin-top:10px; color:var(--muted); font-size:13px; }\n    .note { font-size:13px; color:var(--muted); margin-top:6px; }\n    .controls .group { background:rgba(255,255,255,0.01); padding:10px; border-radius:8px; display:flex; flex-direction:column; gap:8px; }\n    .flex { display:flex; gap:8px; align-items:center; }\n    .status { font-size:13px; color:var(--muted); min-height:20px; }\n    .node-label { font-weight:700; font-size:13px; }\n    footer { margin-top:16px; color:var(--muted); font-size:12px; text-align:right; }\n    a { color:var(--accent); text-decoration:none; }\n    @media (max-width:900px){\n      .layout { grid-template-columns: 1fr; }\n      svg { height:520px; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <header>\n      <div>\n        <h1>Binary Tree Visualizer (BST)</h1>\n        <p class=\"desc\">Interactive demonstration of a Binary Search Tree: insert, delete, search, and traverse with animated layout and highlights. Designed to teach how a binary tree organizes data and operates.</p>\n      </div>\n    </header>\n\n    <div class=\"layout\">\n      <div class=\"panel controls\">\n        <div class=\"group\">\n          <label>Node value (integer)</label>\n          <div class=\"row\">\n            <input id=\"valueInput\" type=\"number\" placeholder=\"e.g., 42\" />\n            <button id=\"insertBtn\" class=\"primary small\">Insert</button>\n            <button id=\"deleteBtn\" class=\"small\">Delete</button>\n          </div>\n          <div class=\"row\">\n            <input id=\"searchInput\" type=\"number\" placeholder=\"Search value\" />\n            <button id=\"searchBtn\" class=\"small\">Search</button>\n            <button id=\"clearSearchBtn\" class=\"small\">Clear</button>\n          </div>\n          <div class=\"row\">\n            <button id=\"randomBtn\" class=\"small\">Random tree</button>\n            <input id=\"randomCount\" type=\"number\" value=\"8\" min=\"1\" max=\"40\" style=\"width:72px\" />\n            <button id=\"clearBtn\" class=\"small\">Clear</button>\n          </div>\n        </div>\n\n        <div class=\"group\">\n          <label>Traversals (animated)</label>\n          <div class=\"flex\">\n            <button id=\"inorderBtn\" class=\"small\">In-order</button>\n            <button id=\"preorderBtn\" class=\"small\">Pre-order</button>\n            <button id=\"postorderBtn\" class=\"small\">Post-order</button>\n            <button id=\"levelorderBtn\" class=\"small\">Level-order</button>\n            <button id=\"stopAnimBtn\" class=\"small\">Stop</button>\n          </div>\n          <div class=\"note\">Traversal will highlight nodes in the order they are visited. Level-order = breadth-first.</div>\n        </div>\n\n        <div class=\"group\">\n          <label>Step-through insertion (visualize path)</label>\n          <div class=\"row\">\n            <input id=\"stepInput\" type=\"number\" placeholder=\"Value to insert\" />\n            <button id=\"stepInsertBtn\" class=\"small\">Step Insert</button>\n            <button id=\"skipStepBtn\" class=\"small\">Skip Steps</button>\n          </div>\n          <div class=\"note\">Use this to see how an inserted value navigates the tree to its spot.</div>\n        </div>\n\n        <div class=\"group\">\n          <label>Options & info</label>\n          <div style=\"display:flex; gap:8px; align-items:center;\">\n            <label style=\"margin:0;\">Allow duplicates</label>\n            <input id=\"dupToggle\" type=\"checkbox\"/>\n          </div>\n          <div class=\"status\" id=\"status\">Nodes: 0 | Height: 0</div>\n          <div class=\"note\">This visualizer implements a Binary Search Tree (BST). Left child &lt; parent; Right child &gt; parent (duplicates optional).</div>\n        </div>\n\n        <div class=\"group\">\n          <label>Examples (quick)</label>\n          <div class=\"flex\">\n            <button id=\"example1\" class=\"small\">Balanced 7</button>\n            <button id=\"example2\" class=\"small\">Skewed</button>\n            <button id=\"example3\" class=\"small\">Custom set</button>\n          </div>\n        </div>\n\n      </div>\n\n      <div class=\"panel canvasWrap\">\n        <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n          <div class=\"muted\">Click a node to remove it (quick delete). Double-click to show details.</div>\n          <div class=\"legend\">\n            <div class=\"badge\"><span style=\"display:inline-block;width:12px;height:12px;border-radius:3px;background:var(--accent)\"></span> Current highlight</div>\n            <div class=\"badge\"><span style=\"display:inline-block;width:12px;height:12px;border-radius:3px;background:var(--good)\"></span> Found / success</div>\n            <div class=\"badge\"><span style=\"display:inline-block;width:12px;height:12px;border-radius:3px;background:var(--danger)\"></span> Remove / selected</div>\n          </div>\n        </div>\n\n        <svg id=\"svgCanvas\" xmlns=\"http://www.w3.org/2000/svg\"></svg>\n\n        <div class=\"footer\">Tip: Insert numbers, try traversals and watch how the layout changes. This is a BST—structure depends on insertion order.</div>\n      </div>\n    </div>\n\n    <footer style=\"max-width:1200px;margin:10px auto 40px auto;\">\n      Built for education — source in this single HTML file.\n    </footer>\n  </div>\n\n<script>\n/*\n Binary Search Tree Visualizer\n - Single-file demonstration\n - Features: insert, delete, search, traversals (animated), random trees, step-through insert\n - Rendering uses SVG, layout computed by inorder positions\n*/\n\n(() => {\n  // Utilities\n  const $ = id => document.getElementById(id);\n  const svg = $('svgCanvas');\n  const NS = \"http://www.w3.org/2000/svg\";\n\n  // State\n  let root = null;\n  let allowDuplicates = false;\n  let animations = { running: false, queue: [], currentTimeouts: [] };\n  let stepMode = { active: false, steps: [], idx: 0, value: null, skip: false };\n\n  // Visual constants\n  const NODE_RADIUS = 20;\n  const LEVEL_HEIGHT = 100;\n  const H_SPACING = 30; // base spacing between inorder positions\n\n  // Node class\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n      // layout positions\n      this.x = 0;\n      this.y = 0;\n      // for highlighting\n      this.id = 'n' + Math.random().toString(36).slice(2,9);\n    }\n  }\n\n  // BST operations\n  function insertBST(value) {\n    if (root === null) {\n      root = new Node(value);\n      updateAndRender();\n      return root;\n    }\n    let cur = root;\n    let parent = null;\n    const path = [];\n    while (cur) {\n      parent = cur;\n      path.push(cur);\n      if (value === cur.value) {\n        if (!allowDuplicates) return null;\n        // decide to go right for duplicates\n        cur = cur.right;\n      } else if (value < cur.value) {\n        cur = cur.left;\n      } else {\n        cur = cur.right;\n      }\n    }\n    const node = new Node(value);\n    if (value === parent.value) {\n      parent.right = node;\n    } else if (value < parent.value) {\n      parent.left = node;\n    } else {\n      parent.right = node;\n    }\n    updateAndRender();\n    return node;\n  }\n\n  function searchBST(value) {\n    let cur = root;\n    const path = [];\n    while (cur) {\n      path.push(cur);\n      if (value === cur.value) return { found: cur, path };\n      if (value < cur.value) cur = cur.left;\n      else cur = cur.right;\n    }\n    return { found: null, path };\n  }\n\n  function deleteBST(value) {\n    // delete first node found with the value (standard BST delete)\n    const res = _deleteNode(root, null, value);\n    if (res.deleted) {\n      root = res.newRoot;\n      updateAndRender();\n      return true;\n    }\n    return false;\n  }\n\n  function _deleteNode(node, parent, value) {\n    if (!node) return {deleted:false, newRoot: root};\n    if (value < node.value) return _deleteNode(node.left, node, value);\n    if (value > node.value) return _deleteNode(node.right, node, value);\n    // found node\n    if (!node.left && !node.right) {\n      if (!parent) return {deleted:true, newRoot: null};\n      if (parent.left === node) parent.left = null; else parent.right = null;\n      return {deleted:true, newRoot: root};\n    }\n    if (!node.left || !node.right) {\n      const child = node.left || node.right;\n      if (!parent) return {deleted:true, newRoot: child};\n      if (parent.left === node) parent.left = child; else parent.right = child;\n      return {deleted:true, newRoot: root};\n    }\n    // two children: replace with inorder successor (min in right subtree)\n    let succParent = node;\n    let succ = node.right;\n    while (succ.left) { succParent = succ; succ = succ.left; }\n    node.value = succ.value;\n    // remove successor node\n    if (succParent.left === succ) succParent.left = succ.right;\n    else succParent.right = succ.right;\n    return {deleted:true, newRoot: root};\n  }\n\n  // Traversals returning arrays of nodes visited\n  function inorder(node, out=[]) {\n    if (!node) return out;\n    inorder(node.left, out);\n    out.push(node);\n    inorder(node.right, out);\n    return out;\n  }\n  function preorder(node, out=[]) {\n    if (!node) return out;\n    out.push(node);\n    preorder(node.left, out);\n    preorder(node.right, out);\n    return out;\n  }\n  function postorder(node, out=[]) {\n    if (!node) return out;\n    postorder(node.left, out);\n    postorder(node.right, out);\n    out.push(node);\n    return out;\n  }\n  function levelorder(node) {\n    const out = [];\n    if (!node) return out;\n    const q = [node];\n    while (q.length) {\n      const n = q.shift();\n      out.push(n);\n      if (n.left) q.push(n.left);\n      if (n.right) q.push(n.right);\n    }\n    return out;\n  }\n\n  // Layout computation\n  function computeLayout() {\n    // assign inorder x positions based on index\n    const nodes = [];\n    (function collect(n, depth=0) {\n      if (!n) return;\n      collect(n.left, depth+1);\n      nodes.push({node:n, depth});\n      collect(n.right, depth+1);\n    })(root);\n    // map node -> inorder index\n    const indexMap = new Map();\n    nodes.forEach((it, idx) => indexMap.set(it.node, idx));\n    const total = Math.max(1, nodes.length);\n    // set x,y\n    (function assign(n, depth=0) {\n      if (!n) return;\n      assign(n.left, depth+1);\n      const idx = indexMap.get(n);\n      n.x = (idx + 1) * H_SPACING + idx*10 + NODE_RADIUS + 20;\n      n.y = depth * LEVEL_HEIGHT + NODE_RADIUS + 20;\n      assign(n.right, depth+1);\n    })(root);\n  }\n\n  // Rendering\n  function clearSVG() {\n    while (svg.firstChild) svg.removeChild(svg.firstChild);\n  }\n\n  function render() {\n    clearSVG();\n    if (!root) {\n      // show placeholder text\n      const t = document.createElementNS(NS,'text');\n      t.setAttribute('x', '50%');\n      t.setAttribute('y', '50%');\n      t.setAttribute('text-anchor','middle');\n      t.setAttribute('fill','rgba(255,255,255,0.06)');\n      t.setAttribute('font-size','20');\n      t.textContent = 'Tree is empty — insert some values';\n      svg.appendChild(t);\n      updateStatus();\n      return;\n    }\n    computeLayout();\n    // draw edges then nodes (so nodes on top)\n    (function drawEdges(n){\n      if (!n) return;\n      if (n.left) {\n        drawLine(n, n.left);\n        drawEdges(n.left);\n      }\n      if (n.right) {\n        drawLine(n, n.right);\n        drawEdges(n.right);\n      }\n    })(root);\n\n    // draw nodes\n    (function drawNodes(n){\n      if (!n) return;\n      drawNode(n);\n      drawNodes(n.left);\n      drawNodes(n.right);\n    })(root);\n\n    updateStatus();\n  }\n\n  function drawLine(a,b) {\n    const g = document.createElementNS(NS,'g');\n    const line = document.createElementNS(NS,'line');\n    line.setAttribute('x1', a.x);\n    line.setAttribute('y1', a.y);\n    line.setAttribute('x2', b.x);\n    line.setAttribute('y2', b.y);\n    line.setAttribute('stroke','rgba(255,255,255,0.06)');\n    line.setAttribute('stroke-width','2');\n    g.appendChild(line);\n    svg.appendChild(g);\n  }\n\n  function drawNode(n) {\n    const g = document.createElementNS(NS,'g');\n    g.setAttribute('transform', `translate(${n.x},${n.y})`);\n    g.setAttribute('data-id', n.id);\n    // circle\n    const c = document.createElementNS(NS,'circle');\n    c.setAttribute('r', NODE_RADIUS);\n    c.setAttribute('fill', 'rgba(2,8,20,0.9)');\n    c.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n    c.setAttribute('stroke-width','2');\n    c.setAttribute('class','nodeCircle');\n    g.appendChild(c);\n    // text\n    const t = document.createElementNS(NS,'text');\n    t.setAttribute('x', 0);\n    t.setAttribute('y', 6);\n    t.setAttribute('text-anchor','middle');\n    t.setAttribute('font-size','13');\n    t.setAttribute('fill','white');\n    t.setAttribute('font-weight','600');\n    t.textContent = n.value;\n    g.appendChild(t);\n\n    // event handlers\n    g.addEventListener('click', (ev) => {\n      ev.stopPropagation();\n      // quick delete on click\n      highlightNodes([n], {color:'var(--danger)', duration:600}).then(() => {\n        deleteNodeByRef(n);\n      });\n    });\n    g.addEventListener('dblclick', (ev) => {\n      ev.stopPropagation();\n      alert('Node value: ' + n.value + '\\\\nLeft: ' + (n.left ? n.left.value : 'null') + '\\\\nRight: ' + (n.right ? n.right.value : 'null'));\n    });\n\n    svg.appendChild(g);\n  }\n\n  function deleteNodeByRef(nodeRef) {\n    // delete by value: delete first occurrence of that value found in BST\n    deleteBST(nodeRef.value);\n  }\n\n  // Highlighting and animation helpers\n  function highlightNodes(nodeList, {color='var(--accent)', duration=800} = {}) {\n    // returns a promise that resolves after animation\n    return new Promise(res => {\n      // find svg groups by data-id\n      const ids = nodeList.map(n => n.id);\n      const groups = [];\n      for (const g of svg.querySelectorAll('g')) {\n        if (ids.includes(g.getAttribute('data-id'))) groups.push(g);\n      }\n      groups.forEach(g => {\n        const circle = g.querySelector('circle');\n        if (!circle) return;\n        circle._origFill = circle._origFill || circle.getAttribute('fill');\n        circle.setAttribute('fill', color);\n        circle.setAttribute('stroke', 'rgba(255,255,255,0.18)');\n        circle.setAttribute('r', NODE_RADIUS + 6);\n      });\n      const t = setTimeout(() => {\n        groups.forEach(g => {\n          const circle = g.querySelector('circle');\n          if (!circle) return;\n          circle.setAttribute('fill', circle._origFill || 'rgba(2,8,20,0.9)');\n          circle.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n          circle.setAttribute('r', NODE_RADIUS);\n        });\n        res();\n      }, duration);\n      animations.currentTimeouts.push(t);\n    });\n  }\n\n  function animateTraversal(nodes, color='var(--accent)', stepDelay=700) {\n    stopAnimations();\n    animations.running = true;\n    let promise = Promise.resolve();\n    nodes.forEach((n, idx) => {\n      promise = promise.then(() => {\n        if (!animations.running) return Promise.resolve();\n        return highlightNodes([n], {color, duration: stepDelay});\n      });\n    });\n    // finish\n    promise.then(() => { animations.running = false; animations.currentTimeouts = []; });\n  }\n\n  function stopAnimations() {\n    animations.running = false;\n    animations.currentTimeouts.forEach(t => clearTimeout(t));\n    animations.currentTimeouts = [];\n  }\n\n  // Status\n  function updateStatus() {\n    const count = countNodes(root);\n    const h = treeHeight(root);\n    $('status').textContent = `Nodes: ${count} | Height: ${h}`;\n  }\n  function countNodes(n) { if (!n) return 0; return 1 + countNodes(n.left) + countNodes(n.right); }\n  function treeHeight(n) { if (!n) return 0; return 1 + Math.max(treeHeight(n.left), treeHeight(n.right)); }\n\n  // UI wiring\n  $('insertBtn').addEventListener('click', () => {\n    const val = parseInt($('valueInput').value);\n    if (Number.isNaN(val)) return alert('Please enter a number.');\n    insertBST(val);\n    $('valueInput').value = '';\n    render();\n  });\n\n  $('deleteBtn').addEventListener('click', () => {\n    const val = parseInt($('valueInput').value);\n    if (Number.isNaN(val)) return alert('Please enter a number to delete.');\n    const ok = deleteBST(val);\n    if (!ok) alert('Value not found: ' + val);\n    $('valueInput').value = '';\n    render();\n  });\n\n  $('searchBtn').addEventListener('click', () => {\n    const val = parseInt($('searchInput').value);\n    if (Number.isNaN(val)) return alert('Enter a number to search.');\n    const res = searchBST(val);\n    animateSearchPath(res.path, res.found);\n  });\n\n  function animateSearchPath(path, foundNode) {\n    if (!path.length) {\n      alert('Tree is empty.');\n      return;\n    }\n    stopAnimations();\n    // animate path: highlight nodes visited (accent), final node green if found else red\n    let promise = Promise.resolve();\n    path.forEach((n, idx) => {\n      promise = promise.then(() => highlightNodes([n], {color:'var(--accent)', duration:500}));\n    });\n    promise = promise.then(() => {\n      if (foundNode) return highlightNodes([foundNode], {color:'var(--good)', duration:900});\n      // highlight last visited as danger\n      const last = path[path.length-1];\n      return highlightNodes([last], {color:'var(--danger)', duration:900});\n    });\n    promise.then(() => updateStatus());\n  }\n\n  $('clearSearchBtn').addEventListener('click', () => {\n    stopAnimations();\n    render();\n    $('searchInput').value = '';\n  });\n\n  $('randomBtn').addEventListener('click', () => {\n    const n = parseInt($('randomCount').value) || 8;\n    generateRandomTree(n);\n  });\n\n  function generateRandomTree(n) {\n    root = null;\n    const arr = [];\n    while (arr.length < n) {\n      const v = Math.floor(Math.random() * (n*4)) + 1;\n      if (!allowDuplicates && arr.includes(v)) continue;\n      arr.push(v);\n    }\n    arr.forEach(v => insertBST(v));\n    render();\n  }\n\n  $('clearBtn').addEventListener('click', () => {\n    root = null;\n    stopAnimations();\n    render();\n  });\n\n  $('inorderBtn').addEventListener('click', () => {\n    if (!root) return;\n    const nodes = inorder(root);\n    animateTraversal(nodes, 'var(--accent)', 600);\n  });\n  $('preorderBtn').addEventListener('click', () => {\n    if (!root) return;\n    animateTraversal(preorder(root), 'var(--accent)', 600);\n  });\n  $('postorderBtn').addEventListener('click', () => {\n    if (!root) return;\n    animateTraversal(postorder(root), 'var(--accent)', 600);\n  });\n  $('levelorderBtn').addEventListener('click', () => {\n    if (!root) return;\n    animateTraversal(levelorder(root), 'var(--accent)', 600);\n  });\n  $('stopAnimBtn').addEventListener('click', () => {\n    stopAnimations();\n    render();\n  });\n\n  $('dupToggle').addEventListener('change', (e) => {\n    allowDuplicates = e.target.checked;\n  });\n\n  // Step-through insertion\n  $('stepInsertBtn').addEventListener('click', () => {\n    const v = parseInt($('stepInput').value);\n    if (Number.isNaN(v)) return alert('Enter a number to step through insertion.');\n    stepMode.active = true;\n    stepMode.value = v;\n    stepMode.idx = 0;\n    stepMode.skip = false;\n    // compute steps where we would visit nodes until place found\n    stepMode.steps = computeInsertPath(v);\n    if (!stepMode.steps) {\n      // empty tree: insert at root immediately\n      insertBST(v);\n      render();\n      stepMode.active = false;\n      return;\n    }\n    // animate each step sequentially, pause between steps, let user skip\n    async function runSteps() {\n      for (let i=0;i<stepMode.steps.length;i++) {\n        if (stepMode.skip) break;\n        const n = stepMode.steps[i];\n        await highlightNodes([n], {color:'var(--accent)', duration:700});\n      }\n      if (!stepMode.skip) {\n        // final highlight to indicate insertion point\n        await highlightNodes(stepMode.steps.slice(-1), {color:'var(--good)', duration:700});\n      }\n      // perform actual insertion (unless skip)\n      if (!stepMode.skip) insertBST(v);\n      else insertBST(v); // still insert if skipped but visual steps skipped\n      render();\n      stepMode.active = false;\n    }\n    runSteps();\n  });\n\n  $('skipStepBtn').addEventListener('click', () => {\n    if (!stepMode.active) return;\n    stepMode.skip = true;\n    stopAnimations();\n    render();\n  });\n\n  function computeInsertPath(value) {\n    if (!root) return null;\n    const path = [];\n    let cur = root;\n    while (cur) {\n      path.push(cur);\n      if (value === cur.value && !allowDuplicates) break;\n      if (value < cur.value) {\n        if (!cur.left) break;\n        cur = cur.left;\n      } else {\n        if (!cur.right) break;\n        cur = cur.right;\n      }\n    }\n    return path;\n  }\n\n  // quick examples\n  $('example1').addEventListener('click', () => {\n    root = null;\n    // balanced-ish insertion order\n    [50,30,70,20,40,60,80].forEach(v => insertBST(v));\n    render();\n  });\n  $('example2').addEventListener('click', () => {\n    root = null;\n    // skewed (ascending)\n    [5,10,15,20,25,30].forEach(v => insertBST(v));\n    render();\n  });\n  $('example3').addEventListener('click', () => {\n    root = null;\n    [15,6,23,4,7,71,5,50].forEach(v => insertBST(v));\n    render();\n  });\n\n  // canvas click to clear highlights\n  svg.addEventListener('click', () => {\n    stopAnimations();\n    render();\n  });\n\n  // initial render\n  render();\n\n  // Expose some functions to console for educational experimentation\n  window._BST = {\n    root,\n    insert: (v) => { insertBST(v); render(); },\n    delete: (v) => { deleteBST(v); render(); },\n    inorder: () => inorder(root).map(n=>n.value),\n    preorder: () => preorder(root).map(n=>n.value),\n    postorder: () => postorder(root).map(n=>n.value),\n    levelorder: () => levelorder(root).map(n=>n.value),\n    render,\n    getRoot: () => root\n  };\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Tree"
    }
  ],
  "topic": "Binary Tree",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}