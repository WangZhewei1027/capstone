{
  "id": "cc1ee5d1-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:30.185Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Huffman Coding",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Huffman Coding Demonstration</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root {\n      --accent: #2b8cff;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --muted: #a6b0c3;\n      --card: #081324;\n      --accent-2: #26c6a0;\n      --danger: #ff6b6b;\n    }\n    body {\n      margin: 0;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background: linear-gradient(180deg, #071126 0%, #081226 100%);\n      color: #e6eef8;\n      -webkit-font-smoothing: antialiased;\n      -moz-osx-font-smoothing: grayscale;\n    }\n    header {\n      padding: 18px 24px;\n      display:flex;\n      align-items:center;\n      gap:12px;\n      border-bottom: 1px solid rgba(255,255,255,0.03);\n    }\n    header h1 {\n      margin:0;\n      font-size:18px;\n      letter-spacing: -0.2px;\n    }\n    .container {\n      display: grid;\n      grid-template-columns: 420px 1fr;\n      gap: 18px;\n      padding: 18px;\n      height: calc(100vh - 68px);\n      box-sizing: border-box;\n    }\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: 10px;\n      padding: 14px;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.6);\n      overflow: auto;\n      min-height: 0;\n    }\n    .input-area textarea {\n      width:100%;\n      height:200px;\n      background: transparent;\n      color: var(--muted);\n      border: 1px dashed rgba(255,255,255,0.03);\n      padding: 10px;\n      border-radius: 8px;\n      resize: vertical;\n    }\n    .controls {\n      margin-top:10px;\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n    }\n    button, .btn {\n      background: linear-gradient(180deg,var(--accent), #1b6eea);\n      color: white;\n      border: none;\n      padding: 8px 12px;\n      border-radius: 8px;\n      cursor: pointer;\n      font-weight:600;\n      box-shadow: 0 6px 12px rgba(43,140,255,0.12);\n    }\n    button.ghost {\n      background: transparent;\n      border: 1px solid rgba(255,255,255,0.04);\n      color: var(--muted);\n      box-shadow: none;\n    }\n    .small {\n      padding:6px 8px;\n      font-size:13px;\n      border-radius:7px;\n    }\n    .row {\n      display:flex;\n      gap:8px;\n      align-items:center;\n      margin-top:8px;\n    }\n    .muted {\n      color: var(--muted);\n      font-size: 13px;\n    }\n    .freq-table, .code-table {\n      margin-top:12px;\n      width:100%;\n      border-collapse:collapse;\n      font-size: 13px;\n    }\n    .freq-table th, .freq-table td, .code-table th, .code-table td {\n      text-align:left;\n      padding:6px 8px;\n      border-bottom: 1px dashed rgba(255,255,255,0.02);\n      color: #d5e4fb;\n    }\n    .code-table th, .freq-table th {\n      color: var(--muted);\n      font-weight:700;\n    }\n    .stats {\n      margin-top:12px;\n      display:flex;\n      gap:10px;\n      flex-wrap:wrap;\n    }\n    .stat {\n      background: rgba(255,255,255,0.02);\n      padding:8px 10px;\n      border-radius:8px;\n      font-size:13px;\n    }\n    .visual {\n      display:flex;\n      gap:12px;\n      height:100%;\n    }\n    .right {\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .svg-wrapper {\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius:10px;\n      padding:8px;\n      border: 1px solid rgba(255,255,255,0.02);\n      min-height: 260px;\n      overflow:auto;\n    }\n    svg { width:100%; height:380px; }\n    .steps {\n      margin-top:10px;\n      font-size:13px;\n      max-height:180px;\n      overflow:auto;\n    }\n    .step {\n      padding:8px;\n      border-radius:8px;\n      cursor:pointer;\n      display:flex;\n      justify-content:space-between;\n      gap:8px;\n    }\n    .step:hover { background: rgba(255,255,255,0.01); }\n    .step.active { background: linear-gradient(90deg, rgba(43,140,255,0.08), rgba(38,198,160,0.02)); }\n    .bitbox {\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;\n      background: rgba(255,255,255,0.02);\n      padding:8px;\n      border-radius:8px;\n      font-size:13px;\n      max-height:140px;\n      overflow:auto;\n      color:#dbeeff;\n    }\n    .footer-controls {\n      display:flex;\n      gap:8px;\n      margin-top:10px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .legend { margin-top:8px; font-size:13px; color:var(--muted); }\n    .tag { background: rgba(255,255,255,0.03); padding:6px 8px; border-radius:6px; font-size:13px; }\n    .danger { background: linear-gradient(180deg,#ff8b8b,#ff6b6b); color:#111; }\n    .kbd { background: rgba(255,255,255,0.03); padding:4px 8px; border-radius:6px; font-family: monospace; font-size:12px; }\n    @media (max-width:900px){\n      .container { grid-template-columns: 1fr; height: auto; padding-bottom: 40px;}\n      svg { height: 300px; }\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Huffman Coding — Interactive Demonstration</h1>\n    <div style=\"margin-left:auto\" class=\"muted\">Build tree → Generate codes → Encode/Decode</div>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"panel input-area\">\n      <label class=\"muted\">Input text (type or paste). Use the sample button to try a phrase.</label>\n      <textarea id=\"inputText\" placeholder=\"Type text here...\">this is an example for huffman encoding</textarea>\n\n      <div class=\"controls\">\n        <button id=\"buildBtn\">Build Huffman Tree & Encode</button>\n        <button id=\"sampleBtn\" class=\"ghost small\">Load sample</button>\n        <button id=\"clearBtn\" class=\"ghost small\">Clear</button>\n      </div>\n\n      <div class=\"row\">\n        <div class=\"muted\">Decoding:</div>\n        <input id=\"decodeBits\" placeholder=\"Paste encoded bits here\" style=\"flex:1; background:transparent; border:1px dashed rgba(255,255,255,0.03); padding:6px; border-radius:8px; color:var(--muted)\" />\n        <button id=\"decodeBtn\" class=\"small\">Decode</button>\n      </div>\n\n      <div class=\"row\">\n        <div id=\"decodedOutput\" style=\"flex:1; min-height:34px; color:var(--muted)\"></div>\n      </div>\n\n      <div class=\"stats\">\n        <div class=\"stat\">Unique symbols: <span id=\"uniqueCount\">-</span></div>\n        <div class=\"stat\">Original size: <span id=\"origBits\">-</span> bits</div>\n        <div class=\"stat\">Compressed size: <span id=\"compBits\">-</span> bits</div>\n        <div class=\"stat\">Ratio: <span id=\"ratio\">-</span></div>\n      </div>\n\n      <div style=\"margin-top:12px;\">\n        <div class=\"muted\">Frequencies</div>\n        <table class=\"freq-table\" id=\"freqTable\">\n          <thead><tr><th>Symbol</th><th>Count</th></tr></thead>\n          <tbody></tbody>\n        </table>\n      </div>\n\n      <div style=\"margin-top:10px;\">\n        <div class=\"muted\">Codes</div>\n        <table class=\"code-table\" id=\"codeTable\">\n          <thead><tr><th>Symbol</th><th>Code</th><th>Length</th></tr></thead>\n          <tbody></tbody>\n        </table>\n      </div>\n\n      <div style=\"margin-top:10px;\">\n        <div class=\"muted\">Encoded bitstring</div>\n        <div class=\"bitbox\" id=\"bitstringBox\"></div>\n        <div class=\"footer-controls\">\n          <button id=\"copyBits\" class=\"small ghost\">Copy bits</button>\n          <button id=\"downloadBits\" class=\"small\">Download bits (.txt)</button>\n          <button id=\"resetBtn\" class=\"small ghost\">Reset view</button>\n        </div>\n      </div>\n\n    </div>\n\n    <div class=\"panel right\">\n      <div style=\"display:flex; gap:12px;\">\n        <div style=\"flex:1;\">\n          <div class=\"muted\">Huffman Tree (step visualization)</div>\n          <div class=\"svg-wrapper\">\n            <svg id=\"treeSvg\" viewBox=\"0 0 1200 500\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n          </div>\n          <div class=\"row\" style=\"margin-top:8px;\">\n            <button id=\"prevStep\" class=\"small ghost\">Prev</button>\n            <button id=\"nextStep\" class=\"small ghost\">Next</button>\n            <div class=\"muted\" style=\"margin-left:auto\">Step <span id=\"currStep\">0</span> / <span id=\"totalSteps\">0</span></div>\n          </div>\n        </div>\n\n        <div style=\"width:360px;\">\n          <div class=\"muted\">Priority queue & merges</div>\n          <div class=\"steps\" id=\"stepsList\"></div>\n          <div class=\"legend\">Click a step to visualize the forest at that point. Final step is the complete tree.</div>\n        </div>\n      </div>\n\n      <div style=\"margin-top:12px;\">\n        <div class=\"muted\">Notes</div>\n        <div class=\"tag\">This demo assumes 8 bits per original character when computing compression ratio. Spaces and punctuation are treated as symbols. For a single unique symbol, the code assigned will be \"0\".</div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Huffman Coding interactive demo\n    (function(){\n      // Utilities\n      function uid() {\n        return Math.random().toString(36).slice(2, 9);\n      }\n\n      // DOM\n      const inputText = document.getElementById('inputText');\n      const buildBtn = document.getElementById('buildBtn');\n      const sampleBtn = document.getElementById('sampleBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const freqTableBody = document.querySelector('#freqTable tbody');\n      const codeTableBody = document.querySelector('#codeTable tbody');\n      const bitstringBox = document.getElementById('bitstringBox');\n      const origBitsEl = document.getElementById('origBits');\n      const compBitsEl = document.getElementById('compBits');\n      const ratioEl = document.getElementById('ratio');\n      const uniqueCountEl = document.getElementById('uniqueCount');\n      const decodeBits = document.getElementById('decodeBits');\n      const decodeBtn = document.getElementById('decodeBtn');\n      const decodedOutput = document.getElementById('decodedOutput');\n      const treeSvg = document.getElementById('treeSvg');\n      const stepsList = document.getElementById('stepsList');\n      const prevStepBtn = document.getElementById('prevStep');\n      const nextStepBtn = document.getElementById('nextStep');\n      const currStepEl = document.getElementById('currStep');\n      const totalStepsEl = document.getElementById('totalSteps');\n      const copyBits = document.getElementById('copyBits');\n      const downloadBits = document.getElementById('downloadBits');\n      const resetBtn = document.getElementById('resetBtn');\n\n      sampleBtn.addEventListener('click', ()=> {\n        inputText.value = 'Huffman coding is a compression algorithm that assigns shorter codes to more frequent symbols.';\n      });\n      clearBtn.addEventListener('click', ()=> {\n        inputText.value = '';\n        resetDisplay();\n      });\n\n      function resetDisplay(){\n        freqTableBody.innerHTML = '';\n        codeTableBody.innerHTML = '';\n        bitstringBox.textContent = '';\n        origBitsEl.textContent = '-';\n        compBitsEl.textContent = '-';\n        ratioEl.textContent = '-';\n        uniqueCountEl.textContent = '-';\n        decodedOutput.textContent = '';\n        stepsList.innerHTML = '';\n        treeSvg.innerHTML = '';\n        currStepEl.textContent = '0';\n        totalStepsEl.textContent = '0';\n      }\n\n      // Build Huffman Tree algorithm with snapshots\n      function computeFrequencies(text) {\n        const freqs = new Map();\n        for (const ch of text) {\n          freqs.set(ch, (freqs.get(ch) || 0) + 1);\n        }\n        return freqs;\n      }\n\n      function buildHuffmanSnapshots(freqMap) {\n        // Node structure stored in nodesMap: id -> {id, weight, symbols:[], leftId, rightId}\n        const nodesMap = new Map();\n        const roots = []; // array of current root ids\n        // initialize leaves\n        for (const [sym, w] of freqMap.entries()) {\n          const id = uid();\n          nodesMap.set(id, { id, weight: w, symbols: [sym], leftId: null, rightId: null, isLeaf: true, symbol: sym });\n          roots.push(id);\n        }\n        // sort initial roots by weight then by symbol for deterministic output\n        roots.sort((a,b) => {\n          const A = nodesMap.get(a), B=nodesMap.get(b);\n          if (A.weight !== B.weight) return A.weight - B.weight;\n          return (A.symbols.join('') > B.symbols.join('')) ? 1 : -1;\n        });\n\n        // snapshots: array of arrays of root ids\n        const snapshots = [];\n        // store initial snapshot (before any merges)\n        snapshots.push({ roots: roots.slice(), merged: null });\n\n        const mergeSteps = [];\n        let stepIndex = 0;\n        // Edge case: single symbol -> no merge needed\n        while (roots.length > 1) {\n          // pick two smallest\n          const aId = roots.shift();\n          const bId = roots.shift();\n          const a = nodesMap.get(aId);\n          const b = nodesMap.get(bId);\n          // create merged node\n          const newId = uid();\n          const newNode = {\n            id: newId,\n            weight: a.weight + b.weight,\n            symbols: a.symbols.concat(b.symbols).sort(),\n            leftId: aId,\n            rightId: bId,\n            isLeaf: false\n          };\n          nodesMap.set(newId, newNode);\n          // insert newId back to roots keeping sorted order\n          let inserted = false;\n          for (let i=0;i<roots.length;i++) {\n            const n = nodesMap.get(roots[i]);\n            if (newNode.weight < n.weight || (newNode.weight === n.weight && newNode.symbols.join('') < n.symbols.join(''))) {\n              roots.splice(i,0,newId);\n              inserted = true;\n              break;\n            }\n          }\n          if (!inserted) roots.push(newId);\n\n          // record this merge step\n          mergeSteps.push({ step: ++stepIndex, pick: [aId,bId], result: newId, nodesBefore: roots.slice(), mergedPair: {a, b}, newNode });\n\n          // snapshot after merge\n          snapshots.push({ roots: roots.slice(), merged: { aId, bId, newId } });\n        }\n\n        return { nodesMap, snapshots, mergeSteps };\n      }\n\n      function generateCodes(nodesMap) {\n        // find root (the one node that isn't referenced as child)\n        const ids = Array.from(nodesMap.keys());\n        const referenced = new Set();\n        for (const node of nodesMap.values()) {\n          if (node.leftId) referenced.add(node.leftId);\n          if (node.rightId) referenced.add(node.rightId);\n        }\n        let rootId = null;\n        for (const id of ids) {\n          if (!referenced.has(id)) { rootId = id; break; }\n        }\n        if (!rootId) rootId = ids[0];\n\n        const codes = {};\n        function dfs(id, prefix) {\n          const node = nodesMap.get(id);\n          if (!node) return;\n          if (node.isLeaf) {\n            // if prefix is empty (single symbol), assign '0'\n            codes[node.symbol] = prefix === '' ? '0' : prefix;\n            return;\n          }\n          // by convention: left edge = 0, right edge = 1\n          dfs(node.leftId, prefix + '0');\n          dfs(node.rightId, prefix + '1');\n        }\n        dfs(rootId, '');\n        return { codes, rootId };\n      }\n\n      function encodeText(text, codes) {\n        let bits = '';\n        for (const ch of text) {\n          bits += codes[ch];\n        }\n        return bits;\n      }\n\n      function decodeBitsToText(bits, nodesMap, rootId) {\n        if (!rootId) return '';\n        if (!bits) {\n          // if tree has single symbol, decode empty string to repeated symbol? In practical terms, encoding would produce '0's.\n          // We'll return empty string.\n          return '';\n        }\n        let result = '';\n        let nodeId = rootId;\n        let i = 0;\n        while (i < bits.length) {\n          const bit = bits[i];\n          const node = nodesMap.get(nodeId);\n          if (!node) break;\n          if (node.isLeaf) {\n            result += node.symbol;\n            nodeId = rootId;\n            // do not increment i\n            continue;\n          }\n          nodeId = (bit === '0') ? node.leftId : node.rightId;\n          i++;\n          const nextNode = nodesMap.get(nodeId);\n          if (!nextNode) break;\n          if (nextNode.isLeaf) {\n            result += nextNode.symbol;\n            nodeId = rootId;\n          }\n        }\n        return result;\n      }\n\n      // Drawing the forest for a given snapshot\n      function drawForest(nodesMap, rootIds) {\n        // clear svg\n        while (treeSvg.firstChild) treeSvg.removeChild(treeSvg.firstChild);\n\n        if (!rootIds || rootIds.length === 0) {\n          return;\n        }\n        // Prepare a copy of node objects with references\n        const localNodes = new Map();\n        for (const [id, n] of nodesMap.entries()) {\n          localNodes.set(id, Object.assign({}, n));\n        }\n\n        // For each tree, compute layout: x positions for leaves using in-order traversal\n        const trees = [];\n        for (const rootId of rootIds) {\n          const root = localNodes.get(rootId);\n          if (!root) continue;\n          // gather leaves count and set up\n          let leafCount = 0;\n          function countLeaves(node) {\n            if (!node) return 0;\n            if (node.isLeaf) return 1;\n            return countLeaves(localNodes.get(node.leftId)) + countLeaves(localNodes.get(node.rightId));\n          }\n          leafCount = countLeaves(root);\n          trees.push({ rootId, leafCount });\n        }\n        const totalLeaves = trees.reduce((s,t)=>s+t.leafCount,0);\n        // spacing\n        const width = 1100;\n        const height = 420;\n        const leftMargin = 40;\n        const rightMargin = 40;\n        const avWidth = Math.max(12, (width - leftMargin - rightMargin) / Math.max(1,totalLeaves));\n\n        // create a group for each tree positioned horizontally\n        let nextLeafX = leftMargin;\n        const svgNS = \"http://www.w3.org/2000/svg\";\n\n        // assign x positions to leaves by doing inorder and incrementing nextLeafX\n        const positions = new Map();\n        function assignPositions(node, depth, offsetXRef) {\n          if (!node) return { minX: 0, maxX: 0 };\n          if (node.isLeaf) {\n            const x = nextLeafX + avWidth/2;\n            positions.set(node.id, { x, y: 40 + depth*70 });\n            nextLeafX += avWidth;\n            return { minX: x, maxX: x };\n          }\n          const left = localNodes.get(node.leftId);\n          const right = localNodes.get(node.rightId);\n          const L = assignPositions(left, depth+1, offsetXRef);\n          const R = assignPositions(right, depth+1, offsetXRef);\n          const x = (L.minX + R.maxX)/2;\n          positions.set(node.id, { x, y: 40 + depth*70 });\n          return { minX: L.minX, maxX: R.maxX };\n        }\n\n        for (const t of trees) {\n          const root = localNodes.get(t.rootId);\n          assignPositions(root, 0);\n          // add a small separation between trees\n          nextLeafX += avWidth * 0.3;\n        }\n\n        // Now draw edges and nodes\n        // First edges\n        for (const id of localNodes.keys()) {\n          const node = localNodes.get(id);\n          if (!positions.has(id)) continue;\n          if (!node.isLeaf) {\n            const p = positions.get(id);\n            const leftPos = positions.get(node.leftId);\n            const rightPos = positions.get(node.rightId);\n            if (leftPos) {\n              const line = document.createElementNS(svgNS, 'line');\n              line.setAttribute('x1', p.x);\n              line.setAttribute('y1', p.y + 14);\n              line.setAttribute('x2', leftPos.x);\n              line.setAttribute('y2', leftPos.y - 14);\n              line.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n              line.setAttribute('stroke-width','2');\n              treeSvg.appendChild(line);\n\n              // edge label '0' near midpoint\n              const mx = (p.x + leftPos.x)/2;\n              const my = (p.y + 14 + leftPos.y - 14)/2 - 6;\n              const t = document.createElementNS(svgNS, 'text');\n              t.setAttribute('x', mx);\n              t.setAttribute('y', my);\n              t.setAttribute('fill', '#9fbefc');\n              t.setAttribute('font-size','12');\n              t.setAttribute('text-anchor','middle');\n              t.textContent = '0';\n              treeSvg.appendChild(t);\n            }\n            if (rightPos) {\n              const line = document.createElementNS(svgNS, 'line');\n              line.setAttribute('x1', p.x);\n              line.setAttribute('y1', p.y + 14);\n              line.setAttribute('x2', rightPos.x);\n              line.setAttribute('y2', rightPos.y - 14);\n              line.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n              line.setAttribute('stroke-width','2');\n              treeSvg.appendChild(line);\n\n              const mx = (p.x + rightPos.x)/2;\n              const my = (p.y + 14 + rightPos.y - 14)/2 - 6;\n              const t = document.createElementNS(svgNS, 'text');\n              t.setAttribute('x', mx);\n              t.setAttribute('y', my);\n              t.setAttribute('fill', '#9ff1d6');\n              t.setAttribute('font-size','12');\n              t.setAttribute('text-anchor','middle');\n              t.textContent = '1';\n              treeSvg.appendChild(t);\n            }\n          }\n        }\n\n        // Then nodes (drawn on top)\n        for (const id of localNodes.keys()) {\n          if (!positions.has(id)) continue;\n          const node = localNodes.get(id);\n          const pos = positions.get(id);\n          const g = document.createElementNS(svgNS, 'g');\n\n          // node circle style: leaves one color, internal another\n          const circle = document.createElementNS(svgNS, 'circle');\n          circle.setAttribute('cx', pos.x);\n          circle.setAttribute('cy', pos.y);\n          circle.setAttribute('r', 16);\n          circle.setAttribute('fill', node.isLeaf ? '#173a66' : '#1b2a3f');\n          circle.setAttribute('stroke', node.isLeaf ? '#2f76ff' : '#26c6a0');\n          circle.setAttribute('stroke-width', node.isLeaf ? 1.6 : 1.6);\n          g.appendChild(circle);\n\n          // weight text\n          const t = document.createElementNS(svgNS, 'text');\n          t.setAttribute('x', pos.x);\n          t.setAttribute('y', pos.y + 5);\n          t.setAttribute('fill', '#dbeeff');\n          t.setAttribute('font-size', '12');\n          t.setAttribute('text-anchor', 'middle');\n          t.setAttribute('font-weight', '600');\n          t.textContent = node.weight;\n          g.appendChild(t);\n\n          // if leaf, show symbol above\n          if (node.isLeaf) {\n            const sym = node.symbol === ' ' ? '␣' : node.symbol === '\\n' ? '\\\\n' : node.symbol;\n            const s = document.createElementNS(svgNS, 'text');\n            s.setAttribute('x', pos.x);\n            s.setAttribute('y', pos.y - 22);\n            s.setAttribute('fill', '#a9d1ff');\n            s.setAttribute('font-size', '12');\n            s.setAttribute('text-anchor', 'middle');\n            s.textContent = sym;\n            g.appendChild(s);\n          }\n\n          treeSvg.appendChild(g);\n        }\n\n        // Set viewbox size\n        const vbW = Math.max(600, nextLeafX + 40);\n        treeSvg.setAttribute('viewBox', `0 0 ${vbW} 500`);\n      }\n\n      // UI state\n      let globalNodesMap = new Map();\n      let globalSnapshots = [];\n      let globalMergeSteps = [];\n      let globalCodes = {};\n      let globalRootId = null;\n      let currentStepIndex = 0;\n\n      function renderStepsList(snapshots, mergeSteps, nodesMap) {\n        stepsList.innerHTML = '';\n        const total = snapshots.length;\n        for (let i=0;i<snapshots.length;i++) {\n          const snap = snapshots[i];\n          const div = document.createElement('div');\n          div.className = 'step';\n          div.dataset.index = i;\n          const left = document.createElement('div');\n          left.style.flex = '1';\n          left.innerHTML = `<strong>Step ${i}</strong>`;\n          const right = document.createElement('div');\n          right.style.color = 'var(--muted)';\n          if (i === 0) {\n            right.textContent = `initial: ${snap.roots.length} trees`;\n          } else {\n            const m = snap.merged;\n            const a = nodesMap.get(m.aId);\n            const b = nodesMap.get(m.bId);\n            right.textContent = `merged ${a.weight} + ${b.weight} → ${nodesMap.get(m.newId).weight}`;\n          }\n          div.appendChild(left);\n          div.appendChild(right);\n          div.addEventListener('click', ()=> {\n            setStep(i);\n          });\n          stepsList.appendChild(div);\n        }\n        totalStepsEl.textContent = Math.max(0,total-1);\n      }\n\n      function setStep(i) {\n        currentStepIndex = i;\n        currStepEl.textContent = i;\n        // highlight active\n        const children = stepsList.children;\n        for (const ch of children) {\n          ch.classList.toggle('active', Number(ch.dataset.index) === i);\n        }\n        // draw forest at snapshot i\n        const snap = globalSnapshots[i];\n        drawForest(globalNodesMap, snap.roots);\n      }\n\n      buildBtn.addEventListener('click', ()=> {\n        const text = inputText.value;\n        if (!text) { alert('Please enter some text.'); return; }\n        // compute frequencies\n        const freqMap = computeFrequencies(text);\n        // sort freqMap by weight desc for table\n        const freqArray = Array.from(freqMap.entries()).sort((a,b)=>b[1]-a[1] || a[0].localeCompare(b[0]));\n        freqTableBody.innerHTML = '';\n        for (const [sym, cnt] of freqArray) {\n          const tr = document.createElement('tr');\n          const td1 = document.createElement('td');\n          td1.textContent = sym === ' ' ? '␣ (space)' : (sym === '\\n' ? '\\\\n' : sym);\n          const td2 = document.createElement('td');\n          td2.textContent = cnt;\n          tr.appendChild(td1); tr.appendChild(td2);\n          freqTableBody.appendChild(tr);\n        }\n        uniqueCountEl.textContent = freqMap.size;\n\n        // build tree snapshots\n        const { nodesMap, snapshots, mergeSteps } = buildHuffmanSnapshots(freqMap);\n\n        // generate codes\n        const { codes, rootId } = generateCodes(nodesMap);\n        globalNodesMap = nodesMap;\n        globalSnapshots = snapshots;\n        globalMergeSteps = mergeSteps;\n        globalCodes = codes;\n        globalRootId = rootId;\n\n        // fill codes table\n        const codesArray = Object.entries(codes).sort((a,b)=> a[0].localeCompare(b[0]));\n        codeTableBody.innerHTML = '';\n        for (const [sym, code] of codesArray) {\n          const tr = document.createElement('tr');\n          const td1 = document.createElement('td');\n          td1.textContent = sym === ' ' ? '␣ (space)' : (sym === '\\n' ? '\\\\n' : sym);\n          const td2 = document.createElement('td');\n          td2.innerHTML = `<span class=\"kbd\">${code}</span>`;\n          const td3 = document.createElement('td');\n          td3.textContent = code.length;\n          tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);\n          codeTableBody.appendChild(tr);\n        }\n\n        // encode\n        const bits = encodeText(text, codes);\n        bitstringBox.textContent = bits || '(empty)';\n\n        // stats\n        const origBits = text.length * 8;\n        origBitsEl.textContent = origBits;\n        const compBits = bits.length;\n        compBitsEl.textContent = compBits;\n        const ratio = (origBits === 0) ? '-' : ( (compBits / origBits * 100).toFixed(2) + '%' );\n        ratioEl.textContent = ratio;\n\n        // render steps\n        renderStepsList(snapshots, mergeSteps, nodesMap);\n        setStep(snapshots.length - 1); // final tree\n      });\n\n      prevStepBtn.addEventListener('click', ()=> {\n        const newIndex = Math.max(0, currentStepIndex - 1);\n        setStep(newIndex);\n      });\n      nextStepBtn.addEventListener('click', ()=> {\n        const newIndex = Math.min(globalSnapshots.length-1, currentStepIndex + 1);\n        setStep(newIndex);\n      });\n\n      decodeBtn.addEventListener('click', ()=> {\n        const bits = decodeBits.value.trim();\n        if (!globalNodesMap || globalNodesMap.size === 0) {\n          decodedOutput.textContent = 'Build a Huffman tree first.';\n          return;\n        }\n        if (!bits) {\n          decodedOutput.textContent = '(empty)';\n          return;\n        }\n        // validate bits\n        if (!/^[01]+$/.test(bits)) {\n          decodedOutput.textContent = 'Invalid bits (only 0/1 allowed).';\n          return;\n        }\n        const decoded = decodeBitsToText(bits, globalNodesMap, globalRootId);\n        decodedOutput.textContent = decoded || '(no output)';\n      });\n\n      copyBits.addEventListener('click', async ()=> {\n        const bits = bitstringBox.textContent;\n        if (!bits) return;\n        try {\n          await navigator.clipboard.writeText(bits);\n          copyBits.textContent = 'Copied!';\n          setTimeout(()=> copyBits.textContent = 'Copy bits', 1200);\n        } catch(e) {\n          copyBits.textContent = 'Failed';\n          setTimeout(()=> copyBits.textContent = 'Copy bits', 1200);\n        }\n      });\n\n      downloadBits.addEventListener('click', ()=> {\n        const bits = bitstringBox.textContent;\n        if (!bits) return;\n        const blob = new Blob([bits], {type: 'text/plain;charset=utf-8'});\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = 'huffman_bits.txt';\n        document.body.appendChild(a);\n        a.click();\n        a.remove();\n        URL.revokeObjectURL(url);\n      });\n\n      resetBtn.addEventListener('click', ()=> {\n        if (globalSnapshots && globalSnapshots.length > 0) {\n          setStep(globalSnapshots.length-1);\n        }\n      });\n\n      // Initialize\n      resetDisplay();\n      // Build once for initial content\n      buildBtn.click();\n\n      // Helper: decode using codes mapping if user prefers (not used in UI presently)\n      window._huffman_demo = {\n        computeFrequencies, buildHuffmanSnapshots, generateCodes, encodeText, decodeBitsToText\n      };\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Huffman Coding"
    }
  ],
  "topic": "Huffman Coding",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}