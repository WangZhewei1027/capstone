{
  "id": "cc1cc2f1-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:00.798Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Hash Table",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<title>Hash Table Interactive Demo</title>\n<style>\n  :root{\n    --bg:#0f1724;\n    --panel:#0b1220;\n    --accent:#38bdf8;\n    --muted:#94a3b8;\n    --good:#10b981;\n    --bad:#ef4444;\n    --card:#071029;\n  }\n  body{\n    margin:0;\n    font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    background: linear-gradient(180deg,#07102b 0%, #0b1220 100%);\n    color:#e6eef8;\n    min-height:100vh;\n    display:flex;\n    gap:20px;\n    padding:18px;\n    box-sizing:border-box;\n  }\n  .container{\n    display:flex;\n    gap:18px;\n    width:100%;\n  }\n  .left{\n    width:360px;\n    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n    border:1px solid rgba(255,255,255,0.04);\n    border-radius:12px;\n    padding:16px;\n    box-sizing:border-box;\n  }\n  h1{margin:6px 0 10px;font-size:18px;}\n  p.small{font-size:13px;color:var(--muted);margin:8px 0 12px;line-height:1.35}\n  label{display:block;font-size:13px;margin-top:8px;color:var(--muted)}\n  input[type=\"text\"], input[type=\"number\"], select {\n    width:100%;\n    padding:8px 10px;\n    margin-top:6px;\n    border-radius:8px;\n    border:1px solid rgba(255,255,255,0.06);\n    background:rgba(255,255,255,0.02);\n    color:inherit;\n    box-sizing:border-box;\n  }\n  .row {display:flex;gap:8px;margin-top:12px}\n  button{\n    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n    border:1px solid rgba(255,255,255,0.04);\n    color:inherit;\n    padding:8px 10px;\n    border-radius:8px;\n    cursor:pointer;\n    font-weight:600;\n  }\n  button.primary{\n    background:linear-gradient(180deg,var(--accent),#0ea5c9);\n    color:#052127;\n    border:none;\n  }\n  .stats{\n    margin-top:14px;\n    display:grid;\n    grid-template-columns:repeat(2,1fr);\n    gap:8px;\n  }\n  .stat{\n    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n    padding:10px;\n    border-radius:8px;\n    border:1px solid rgba(255,255,255,0.02);\n    font-size:13px;\n  }\n  .stat strong{display:block;font-size:16px}\n  .visual{\n    flex:1;\n    padding:12px;\n    border-radius:12px;\n    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n    border:1px solid rgba(255,255,255,0.04);\n    min-height:600px;\n    box-sizing:border-box;\n    overflow:auto;\n  }\n  .controls-note{\n    font-size:12px;color:var(--muted);margin-top:8px;\n  }\n  .buckets{\n    display:flex;\n    flex-wrap:wrap;\n    gap:10px;\n    margin-top:12px;\n  }\n  .bucket{\n    width:200px;\n    min-height:48px;\n    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));\n    border-radius:8px;\n    padding:8px;\n    box-sizing:border-box;\n    border:1px solid rgba(255,255,255,0.02);\n    position:relative;\n  }\n  .bucket-header{\n    font-size:12px;color:var(--muted);display:flex;align-items:center;gap:8px;margin-bottom:6px;\n  }\n  .index-bubble{\n    background:rgba(255,255,255,0.03);padding:4px 8px;border-radius:999px;font-weight:700;font-size:13px;\n  }\n  .chain{\n    display:flex;gap:8px;flex-wrap:wrap;\n  }\n  .node{\n    background:linear-gradient(180deg,#06293e,#043a55);\n    border-radius:8px;padding:6px 8px;font-size:13px;box-shadow:0 2px 0 rgba(0,0,0,0.25);\n    display:flex;flex-direction:column;gap:3px;border:1px solid rgba(255,255,255,0.02);\n  }\n  .node small{font-size:11px;color:var(--muted)}\n  .highlight{box-shadow:0 0 0 3px rgba(56,189,248,0.12) inset, 0 6px 18px rgba(2,6,23,0.5)}\n  .found {box-shadow:0 0 0 3px rgba(16,185,129,0.12) inset}\n  .notfound {box-shadow:0 0 0 3px rgba(239,68,68,0.08) inset}\n  .notice{\n    margin-top:12px;padding:10px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);font-size:13px;border:1px solid rgba(255,255,255,0.02)\n  }\n  .footer{\n    margin-top:12px;font-size:13px;color:var(--muted)\n  }\n  .muted{color:var(--muted)}\n  .controls-row{display:flex;gap:8px}\n  .small-btn{padding:6px 8px;font-size:13px;border-radius:8px}\n  .toggle{display:flex;gap:6px;align-items:center;margin-top:8px}\n  .help{font-size:13px;color:var(--muted);margin-top:10px}\n  .badge{font-size:12px;padding:4px 6px;border-radius:999px;background:rgba(255,255,255,0.02)}\n  footer{margin-top:18px;color:var(--muted);font-size:13px}\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <div class=\"left\">\n    <h1>Hash Table — Interactive Demo</h1>\n    <p class=\"small\">\n      This demo implements a hash table with separate chaining (each bucket holds a small list).\n      You can insert, lookup and remove keys. The table auto-resizes when the load factor grows past the threshold.\n    </p>\n\n    <label>Key (string or number)</label>\n    <input id=\"keyInput\" type=\"text\" placeholder=\"e.g. 'apple' or 42\">\n\n    <label>Value</label>\n    <input id=\"valueInput\" type=\"text\" placeholder=\"e.g. 'fruit'\">\n\n    <div class=\"row\">\n      <button id=\"putBtn\" class=\"primary\">Insert / Update</button>\n      <button id=\"getBtn\">Get</button>\n      <button id=\"removeBtn\">Remove</button>\n    </div>\n\n    <div class=\"row\" style=\"margin-top:8px\">\n      <button id=\"containsBtn\" class=\"small-btn\">Contains?</button>\n      <button id=\"randomBtn\" class=\"small-btn\">Insert Random</button>\n      <button id=\"fillBtn\" class=\"small-btn\">Fill 40</button>\n    </div>\n\n    <label>Hash function</label>\n    <select id=\"hashSelect\">\n      <option value=\"djb2\">djb2 (recommended)</option>\n      <option value=\"sum\">Simple sum of char codes</option>\n      <option value=\"js\">JavaScript's built-in (string -> JSON) hashed by char codes</option>\n    </select>\n\n    <label>Initial capacity</label>\n    <input id=\"capacityInput\" type=\"number\" min=\"2\" step=\"1\" value=\"8\">\n\n    <label>Resize load factor threshold (autosize when entries / capacity &gt; threshold)</label>\n    <input id=\"thresholdInput\" type=\"number\" min=\"0.1\" max=\"2\" step=\"0.05\" value=\"0.75\">\n\n    <div class=\"controls-note\">Use \"Fill 40\" to create many collisions and trigger rehashing.</div>\n\n    <div class=\"stats\">\n      <div class=\"stat\"><strong id=\"statEntries\">0</strong><span class=\"muted\">entries</span></div>\n      <div class=\"stat\"><strong id=\"statCapacity\">8</strong><span class=\"muted\">capacity (buckets)</span></div>\n      <div class=\"stat\"><strong id=\"statLF\">0.00</strong><span class=\"muted\">load factor</span></div>\n      <div class=\"stat\"><strong id=\"statCollisions\">0</strong><span class=\"muted\">collisions (total inserts that went to non-empty bucket)</span></div>\n    </div>\n\n    <div class=\"notice\" id=\"notice\">No actions yet. Insert keys to see how hashing maps them into buckets.</div>\n\n    <div class=\"footer\">\n      Quick notes:\n      <ul style=\"margin:8px 0 0 18px\">\n        <li><b>Separate chaining</b> stores multiple items per bucket (simple arrays here).</li>\n        <li>Average lookup is O(1 + α) where α = load factor (n / m).</li>\n        <li>When α grows, the table resizes (capacity doubles) and rehashes all items.</li>\n      </ul>\n    </div>\n\n  </div>\n\n  <div class=\"visual\">\n    <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n      <div>\n        <h2 style=\"margin:6px 0 2px\">Buckets</h2>\n        <div class=\"muted\" style=\"margin-top:2px\">Each bucket is a chain (list) — collisions are appended into the chain.</div>\n      </div>\n      <div style=\"display:flex;gap:10px;align-items:center;\">\n        <div class=\"muted\">Highlighting shows hashing and traversal.</div>\n        <button id=\"clearBtn\" class=\"small-btn\">Clear</button>\n      </div>\n    </div>\n\n    <div id=\"buckets\" class=\"buckets\" style=\"margin-top:12px\"></div>\n\n    <div id=\"explain\" class=\"help\">\n      How it works: When inserting, the key is converted to a hash number by the selected function, then we compute index = hash % capacity.\n      If a bucket already holds items, the new item collides and is added to that bucket's chain.\n    </div>\n  </div>\n</div>\n\n<script>\n(function(){\n  // Simple interactive hash table with separate chaining\n  // Data structures:\n  // buckets: Array of arrays, each element is {key, value, hash}\n  // stats: entries, collisions, capacity, threshold\n\n  // DOM\n  const keyInput = document.getElementById('keyInput');\n  const valueInput = document.getElementById('valueInput');\n  const putBtn = document.getElementById('putBtn');\n  const getBtn = document.getElementById('getBtn');\n  const removeBtn = document.getElementById('removeBtn');\n  const containsBtn = document.getElementById('containsBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const fillBtn = document.getElementById('fillBtn');\n  const bucketsDiv = document.getElementById('buckets');\n  const clearBtn = document.getElementById('clearBtn');\n  const notice = document.getElementById('notice');\n  const hashSelect = document.getElementById('hashSelect');\n  const statEntries = document.getElementById('statEntries');\n  const statCapacity = document.getElementById('statCapacity');\n  const statLF = document.getElementById('statLF');\n  const statCollisions = document.getElementById('statCollisions');\n  const capacityInput = document.getElementById('capacityInput');\n  const thresholdInput = document.getElementById('thresholdInput');\n\n  // Implementation\n  let capacity = Math.max(2, parseInt(capacityInput.value) || 8);\n  let threshold = parseFloat(thresholdInput.value) || 0.75;\n  let buckets = [];\n  let entries = 0;\n  let collisions = 0;\n\n  function initBuckets(n){\n    capacity = n;\n    buckets = Array.from({length:n}, ()=>[]);\n    render();\n  }\n\n  function toKeyString(k){\n    // normalize keys so different types produce distinct strings\n    if (k === null) return 'null';\n    if (k === undefined) return 'undefined';\n    if (typeof k === 'object') return JSON.stringify(k);\n    return String(k);\n  }\n\n  function hash_djb2(str){\n    // djb2 by Dan Bernstein\n    let h = 5381;\n    for (let i=0;i<str.length;i++){\n      h = ((h << 5) + h) + str.charCodeAt(i); // h * 33 + c\n      h = h & 0xFFFFFFFF;\n    }\n    return Math.abs(h);\n  }\n  function hash_sum(str){\n    let s = 0;\n    for (let i=0;i<str.length;i++) s += str.charCodeAt(i);\n    return Math.abs(s);\n  }\n  function hash_jsish(str){\n    // a quick JS-like mix for demonstration (not real built-in hash)\n    let h = 0;\n    for(let i=0;i<str.length;i++){\n      h = ((h << 5) - h) + str.charCodeAt(i);\n      h |= 0;\n    }\n    return Math.abs(h);\n  }\n\n  function getHash(key){\n    const k = toKeyString(key);\n    const fn = hashSelect.value;\n    if (fn === 'djb2') return hash_djb2(k);\n    if (fn === 'sum') return hash_sum(k);\n    return hash_jsish(k);\n  }\n\n  function indexForHash(h){\n    return h % capacity;\n  }\n\n  function findInBucket(bucket, key){\n    for (let i=0;i<bucket.length;i++){\n      if (bucket[i].key === key) return i;\n    }\n    return -1;\n  }\n\n  // Render\n  function render(highlight = {}) {\n    bucketsDiv.innerHTML = '';\n    statEntries.textContent = entries;\n    statCapacity.textContent = capacity;\n    statLF.textContent = (entries / capacity).toFixed(2);\n    statCollisions.textContent = collisions;\n\n    for (let i=0;i<capacity;i++){\n      const b = buckets[i];\n      const div = document.createElement('div');\n      div.className = 'bucket';\n      if (highlight.bucket === i) div.classList.add('highlight');\n      const header = document.createElement('div');\n      header.className = 'bucket-header';\n      const idx = document.createElement('div');\n      idx.className = 'index-bubble';\n      idx.textContent = i;\n      const count = document.createElement('div');\n      count.style.marginLeft = '6px';\n      count.style.fontSize = '13px';\n      count.style.color = 'var(--muted)';\n      count.textContent = `${b.length} item${b.length===1?'':'s'}`;\n      header.appendChild(idx);\n      header.appendChild(count);\n      div.appendChild(header);\n\n      const chain = document.createElement('div');\n      chain.className = 'chain';\n\n      for (let j=0;j<b.length;j++){\n        const node = document.createElement('div');\n        node.className = 'node';\n        if (highlight.found && highlight.bucket === i && highlight.at === j) node.classList.add('found');\n        if (highlight.visiting && highlight.bucket === i && highlight.at === j) node.classList.add('highlight');\n        if (highlight.notfound && highlight.bucket === i) node.classList.add('notfound');\n\n        const kv = document.createElement('div');\n        kv.textContent = b[j].key + ' → ' + b[j].value;\n        const small = document.createElement('small');\n        small.textContent = 'h=' + b[j].hash;\n        node.appendChild(kv);\n        node.appendChild(small);\n        chain.appendChild(node);\n      }\n      div.appendChild(chain);\n      bucketsDiv.appendChild(div);\n    }\n  }\n\n  function notify(msg, severity){\n    notice.textContent = msg;\n    if (severity === 'ok') notice.style.borderLeft = '4px solid rgba(16,185,129,0.6)';\n    else if (severity === 'warn') notice.style.borderLeft = '4px solid rgba(250,204,21,0.6)';\n    else if (severity === 'err') notice.style.borderLeft = '4px solid rgba(239,68,68,0.7)';\n    else notice.style.borderLeft = 'none';\n  }\n\n  // Operations with simple animations (timeouts)\n  function put(keyRaw, value, animate = true){\n    const key = toKeyString(keyRaw);\n    const h = getHash(keyRaw);\n    const idx = indexForHash(h);\n    const bucket = buckets[idx];\n\n    // If update existing key => replace\n    const existingIndex = findInBucket(bucket, key);\n    if (existingIndex !== -1){\n      // animate visiting then updating\n      if (animate){\n        render({bucket: idx, visiting: true, at: existingIndex});\n        setTimeout(()=>{\n          bucket[existingIndex].value = value;\n          notify(`Updated key \"${key}\" in bucket ${idx}.`);\n          render({bucket: idx, found: true, at: existingIndex});\n        }, 450);\n      } else {\n        bucket[existingIndex].value = value;\n        notify(`Updated key \"${key}\".`);\n        render();\n      }\n      return;\n    }\n\n    // New insert: if bucket non-empty -> collision\n    if (bucket.length > 0) collisions++;\n\n    bucket.push({key, value, hash: h});\n    entries++;\n\n    // Animate insertion: highlight bucket then newly added node\n    if (animate){\n      render({bucket: idx});\n      setTimeout(()=> {\n        render({bucket: idx, found: true, at: bucket.length-1});\n        notify(`Inserted key \"${key}\" into bucket ${idx} (hash ${h}).`);\n      }, 300);\n    } else {\n      notify(`Inserted key \"${key}\".`);\n      render();\n    }\n\n    // Check load factor -> resize if necessary\n    setTimeout(()=> {\n      if ((entries / capacity) > threshold) {\n        autoResize();\n      }\n    }, 650);\n  }\n\n  function get(keyRaw, animate=true){\n    const key = toKeyString(keyRaw);\n    const h = getHash(keyRaw);\n    const idx = indexForHash(h);\n    const bucket = buckets[idx];\n\n    // Traverse chain\n    if (animate){\n      // show bucket highlight then traverse nodes\n      render({bucket: idx});\n      let i = 0;\n      function step(){\n        if (i < bucket.length){\n          render({bucket: idx, visiting: true, at: i});\n          if (bucket[i].key === key){\n            setTimeout(()=> {\n              render({bucket: idx, found: true, at: i});\n              notify(`Found key \"${key}\" → ${bucket[i].value}`, 'ok');\n            }, 350);\n            return;\n          }\n          i++;\n          setTimeout(step, 350);\n        } else {\n          render({bucket: idx, notfound: true});\n          notify(`Key \"${key}\" not found in bucket ${idx}.`, 'err');\n        }\n      }\n      setTimeout(step, 200);\n    } else {\n      const pos = findInBucket(bucket, key);\n      if (pos !== -1) {\n        notify(`Found key \"${key}\" → ${bucket[pos].value}`, 'ok');\n      } else {\n        notify(`Key \"${key}\" not found.`, 'err');\n      }\n      render();\n    }\n  }\n\n  function contains(keyRaw, animate=true){\n    const key = toKeyString(keyRaw);\n    const h = getHash(keyRaw);\n    const idx = indexForHash(h);\n    const bucket = buckets[idx];\n    const pos = findInBucket(bucket, key);\n    if (pos !== -1){\n      if (animate) {\n        render({bucket: idx, found: true, at: pos});\n      } else render();\n      notify(`Yes: key \"${key}\" is present.`, 'ok');\n    } else {\n      if (animate) {\n        render({bucket: idx, notfound: true});\n      } else render();\n      notify(`No: key \"${key}\" not found.`, 'err');\n    }\n  }\n\n  function remove(keyRaw, animate=true){\n    const key = toKeyString(keyRaw);\n    const h = getHash(keyRaw);\n    const idx = indexForHash(h);\n    const bucket = buckets[idx];\n    const pos = findInBucket(bucket, key);\n    if (pos === -1){\n      render({bucket: idx, notfound: true});\n      notify(`Key \"${key}\" not found; nothing removed.`, 'err');\n      return;\n    }\n\n    // Animate removing\n    if (animate){\n      render({bucket: idx, visiting: true, at: pos});\n      setTimeout(()=> {\n        bucket.splice(pos,1);\n        entries--;\n        notify(`Removed key \"${key}\" from bucket ${idx}.`, 'ok');\n        render({bucket: idx});\n      }, 400);\n    } else {\n      bucket.splice(pos,1);\n      entries--;\n      render();\n      notify(`Removed key \"${key}\".`, 'ok');\n    }\n  }\n\n  function autoResize(){\n    const oldCap = capacity;\n    const newCap = capacity * 2;\n    notify(`Resizing table: ${oldCap} → ${newCap} buckets (rehashing all items)...`, 'warn');\n\n    // Collect all items\n    const items = [];\n    for (let b of buckets) for (let item of b) items.push(item);\n\n    // Create new buckets\n    capacity = newCap;\n    buckets = Array.from({length:capacity}, ()=>[]);\n    render();\n\n    // Re-insert items with animation\n    let i = 0;\n    function stepRehash(){\n      if (i < items.length){\n        const it = items[i];\n        const idx = indexForHash(it.hash);\n        buckets[idx].push(it);\n        render({bucket: idx, found: true, at: buckets[idx].length-1});\n        i++;\n        setTimeout(stepRehash, 120);\n      } else {\n        notify(`Resizing complete. New capacity: ${capacity}.`, 'ok');\n        render();\n      }\n    }\n    setTimeout(stepRehash, 250);\n  }\n\n  // Utility: random key generator\n  function randomKey(){\n    const adjectives = ['red','fast','blue','tiny','big','cold','hot','silent','loud','happy','sad','green','round'];\n    const nouns = ['apple','rocket','car','mountain','river','book','phone','cat','dog','cloud','leaf','stone'];\n    return adjectives[Math.floor(Math.random()*adjectives.length)] + '_' + nouns[Math.floor(Math.random()*nouns.length)] + '_' + Math.floor(Math.random()*1000);\n  }\n\n  // Wire up UI\n  putBtn.addEventListener('click', ()=>{\n    const key = keyInput.value.trim();\n    const val = valueInput.value;\n    if (key === '') { notify('Please provide a key.'); return; }\n    put(key, val || '(empty)');\n  });\n  getBtn.addEventListener('click', ()=>{\n    const key = keyInput.value.trim();\n    if (key === '') { notify('Please provide a key.'); return; }\n    get(key);\n  });\n  containsBtn.addEventListener('click', ()=> {\n    const key = keyInput.value.trim();\n    if (key === '') { notify('Please provide a key.'); return; }\n    contains(key);\n  });\n  removeBtn.addEventListener('click', ()=>{\n    const key = keyInput.value.trim();\n    if (key === '') { notify('Please provide a key.'); return; }\n    remove(key);\n  });\n  randomBtn.addEventListener('click', ()=>{\n    const k = randomKey();\n    keyInput.value = k;\n    valueInput.value = 'val-'+Math.floor(Math.random()*1000);\n    put(k, valueInput.value);\n  });\n\n  fillBtn.addEventListener('click', ()=>{\n    // Fill many keys quickly to show collisions and resizing\n    let added = 0;\n    const target = 40;\n    function addOne(){\n      if (added >= target) return;\n      const k = randomKey() + '_' + Math.floor(Math.random()*1000);\n      put(k, 'v'+Math.floor(Math.random()*10000), false);\n      added++;\n      setTimeout(addOne, 30);\n    }\n    addOne();\n    notify('Filling table with many entries...');\n  });\n\n  clearBtn.addEventListener('click', ()=>{\n    entries = 0;\n    collisions = 0;\n    initBuckets(Math.max(2, parseInt(capacityInput.value) || 8));\n    notify('Cleared table.');\n  });\n\n  capacityInput.addEventListener('change', ()=>{\n    let val = parseInt(capacityInput.value) || 8;\n    if (val < 2) val = 2;\n    capacityInput.value = val;\n    initBuckets(val);\n    notify(`Capacity set to ${val}.`);\n  });\n\n  thresholdInput.addEventListener('change', ()=>{\n    let t = parseFloat(thresholdInput.value);\n    if (isNaN(t) || t <= 0) t = 0.75;\n    threshold = t;\n    thresholdInput.value = t;\n    notify(`Threshold set to ${t}.`);\n  });\n\n  hashSelect.addEventListener('change', ()=>{\n    notify(`Hash function switched to ${hashSelect.value}. Existing entries will behave based on the hash of their stored keys when they were inserted. Clear and reinsert to re-evaluate with new function.`, 'warn');\n  });\n\n  // Initialize\n  initBuckets(capacity);\n  notify('Hash table initialized. Try inserting keys.', 'ok');\n\n  // Expose for console debugging (optional)\n  window.__ht = {\n    put, get, remove, contains, buckets: ()=>buckets, stats: ()=>({entries,capacity,collisions,threshold})\n  };\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Hash Table"
    }
  ],
  "topic": "Hash Table",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}