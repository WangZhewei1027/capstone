{
  "id": "cc1d5f32-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:22:09.657Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Interactive Weighted Graph Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<style>\n  html,body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial; }\n  #app { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; background: #f6f7fb; }\n  #canvas-wrap { flex:1; background:#fff; border:1px solid #ddd; border-radius:8px; position:relative; overflow:hidden; }\n  svg { width:100%; height:100%; display:block; touch-action:none; }\n  #controls { width:360px; max-width:40%; min-width:240px; background:#fff; border:1px solid #ddd; border-radius:8px; padding:12px; box-sizing:border-box; overflow:auto; }\n  h2 { margin:8px 0 6px; font-size:16px; }\n  .row { display:flex; gap:8px; margin:8px 0; align-items:center; }\n  button { padding:8px 10px; border-radius:6px; border:1px solid #bbb; background:#fafafa; cursor:pointer; }\n  button.primary { background:#2563eb; color:white; border-color:#1e40af; }\n  label { font-size:13px; }\n  select,input[type=\"number\"],input[type=\"text\"] { padding:6px 8px; border-radius:6px; border:1px solid #ccc; }\n  .muted { color:#666; font-size:13px; }\n  .mode-btn { flex:1; padding:8px; border-radius:6px; border:1px solid #cfd8e3; background:#f5f7fb; cursor:pointer; }\n  .mode-btn.active { background:#e6f0ff; border-color:#9fbff9; }\n  ul { padding-left:18px; margin:6px 0; font-size:13px; }\n  .legend { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }\n  .legend div { display:flex; gap:6px; align-items:center; font-size:13px; }\n  .dot { width:14px; height:14px; border-radius:50%; display:inline-block; }\n  .info { font-size:13px; margin-top:8px; color:#333; }\n  #log { margin-top:10px; font-family:monospace; font-size:13px; max-height:160px; overflow:auto; border-top:1px dashed #eee; padding-top:8px; color:#333; }\n  small.hint { display:block; margin-top:6px; color:#666; font-size:12px; }\n  .weight-input { width:90px; }\n  .edge-weight-label { font-family:monospace; font-size:12px; pointer-events:none; }\n</style>\n</head>\n<body>\n<div id=\"app\">\n  <div id=\"canvas-wrap\">\n    <svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\"></svg>\n  </div>\n\n  <div id=\"controls\">\n    <h2>Weighted Graph Interactive Demo</h2>\n    <div class=\"row\">\n      <button id=\"mode-add-node\" class=\"mode-btn active\">Add Node</button>\n      <button id=\"mode-add-edge\" class=\"mode-btn\">Add Edge</button>\n      <button id=\"mode-move\" class=\"mode-btn\">Move</button>\n      <button id=\"mode-delete\" class=\"mode-btn\">Delete</button>\n    </div>\n    <div class=\"row\">\n      <label><input type=\"checkbox\" id=\"directed\"> Directed</label>\n      <label style=\"margin-left:8px;\"><input type=\"checkbox\" id=\"allow-multi\"> Allow Multi-edges</label>\n    </div>\n\n    <div style=\"border-top:1px solid #eee; padding-top:8px; margin-top:8px;\">\n      <h2>Create / Generate</h2>\n      <div class=\"row\">\n        <button id=\"clear-graph\">Clear Graph</button>\n        <button id=\"random-graph\" class=\"primary\">Random Graph</button>\n      </div>\n      <div class=\"row\">\n        <label>Nodes: <input id=\"rand-n\" type=\"number\" min=\"2\" value=\"7\" style=\"width:72px\"></label>\n        <label>Density %: <input id=\"rand-density\" type=\"number\" min=\"5\" max=\"100\" value=\"35\" style=\"width:72px\"></label>\n        <label>Max weight: <input id=\"rand-maxw\" type=\"number\" min=\"1\" value=\"20\" style=\"width:78px\"></label>\n      </div>\n      <small class=\"hint\">Click the canvas to add nodes. In \"Add Edge\" mode click source then target and enter weight.</small>\n    </div>\n\n    <div style=\"border-top:1px solid #eee; padding-top:8px; margin-top:8px;\">\n      <h2>Algorithms</h2>\n      <div class=\"row\">\n        <button id=\"dijkstra-btn\">Dijkstra (Shortest Path)</button>\n        <button id=\"prim-btn\">Prim's MST</button>\n        <button id=\"kruskal-btn\">Kruskal's MST</button>\n      </div>\n      <div class=\"row\">\n        <label>Source: <input id=\"alg-src\" type=\"text\" placeholder=\"click to set\" readonly style=\"width:76px\"></label>\n        <label>Target: <input id=\"alg-tgt\" type=\"text\" placeholder=\"click to set\" readonly style=\"width:76px\"></label>\n        <button id=\"set-src\" title=\"Click a node on canvas to set source\">Set Src</button>\n        <button id=\"set-tgt\" title=\"Click a node on canvas to set target\">Set Tgt</button>\n      </div>\n      <small class=\"hint\">Use \"Set Src/Tgt\" then run Dijkstra. MSTs ignore direction (graph treated undirected).</small>\n    </div>\n\n    <div style=\"border-top:1px solid #eee; padding-top:8px; margin-top:8px;\">\n      <h2>Legend & Info</h2>\n      <div class=\"legend\">\n        <div><span class=\"dot\" style=\"background:#2563eb\"></span> Selected</div>\n        <div><span class=\"dot\" style=\"background:#10b981\"></span> Path / MST</div>\n        <div><span class=\"dot\" style=\"background:#bbb\"></span> Regular</div>\n        <div><span style=\"width:16px; height:2px; background:#333; display:inline-block\"></span> Edge</div>\n      </div>\n      <div class=\"info\" id=\"status\">Nodes: 0 • Edges: 0</div>\n    </div>\n\n    <div id=\"log\"></div>\n  </div>\n</div>\n\n<script>\n/*\nInteractive Weighted Graph Demo\n- Modes: Add Node, Add Edge, Move (drag), Delete\n- Add Edge: click source -> click target -> prompt weight\n- Directed toggle\n- Random graph generator\n- Dijkstra shortest path (choose source and target)\n- Prim's and Kruskal's MST (graph treated as undirected)\n- Visual: SVG rendering, draggable nodes, weight labels\n*/\n\nconst svg = document.getElementById('svg');\nconst modeBtns = {\n  addNode: document.getElementById('mode-add-node'),\n  addEdge: document.getElementById('mode-add-edge'),\n  move: document.getElementById('mode-move'),\n  del: document.getElementById('mode-delete')\n};\nlet mode = 'addNode';\nfor (const k in modeBtns) {\n  modeBtns[k].addEventListener('click', () => setMode(k));\n}\nfunction setMode(m) {\n  mode = m;\n  Object.values(modeBtns).forEach(b => b.classList.remove('active'));\n  modeBtns[m].classList.add('active');\n  clearTempSelection();\n  log('Mode: ' + mode);\n}\n\nconst directedCheckbox = document.getElementById('directed');\nconst allowMulti = document.getElementById('allow-multi');\nconst statusEl = document.getElementById('status');\nconst logEl = document.getElementById('log');\nfunction log(...args) {\n  const s = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');\n  const line = document.createElement('div');\n  line.textContent = s;\n  logEl.prepend(line);\n}\n\nlet nodes = []; // {id,x,y,el}\nlet edges = []; // {id,u,v,weight,el,dir}\nlet nodeIdCounter = 1;\nlet edgeIdCounter = 1;\n\nfunction updateStatus() {\n  statusEl.textContent = `Nodes: ${nodes.length} • Edges: ${edges.length}`;\n}\nfunction clearSvg() {\n  while (svg.firstChild) svg.removeChild(svg.firstChild);\n}\n\n// Render helpers: groups for edges and nodes\nconst gEdges = (() => { const g = document.createElementNS('http://www.w3.org/2000/svg','g'); svg.appendChild(g); return g; })();\nconst gNodes = (() => { const g = document.createElementNS('http://www.w3.org/2000/svg','g'); svg.appendChild(g); return g; })();\n\nfunction createNode(x,y,label=null) {\n  const id = nodeIdCounter++;\n  const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n  g.classList.add('node-group');\n  const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n  circle.setAttribute('r', 18);\n  circle.setAttribute('fill', '#bbb');\n  circle.setAttribute('stroke', '#555');\n  circle.setAttribute('stroke-width', '1');\n  circle.style.cursor = 'pointer';\n  const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n  text.setAttribute('text-anchor','middle');\n  text.setAttribute('dy','6');\n  text.setAttribute('font-size','12');\n  text.setAttribute('fill','#fff');\n  text.textContent = label || id;\n  g.appendChild(circle);\n  g.appendChild(text);\n  g.setAttribute('transform', `translate(${x},${y})`);\n  g.dataset.id = id;\n  g.onpointerdown = nodePointerDown;\n  svg.appendChild(g); // append to root but visually nodes above edges due stacking order; keep simple\n  nodes.push({id, x, y, g, circle, text});\n  updateStatus();\n  return id;\n}\n\nfunction createEdge(uId, vId, weight, directed=false, silent=false) {\n  // Prevent duplicate edges unless allowMulti true\n  if (!allowMulti.checked) {\n    const dup = edges.find(e => e.u===uId && e.v===vId && e.dir===directed);\n    if (dup) { if(!silent) log('Edge already exists'); return null; }\n    if (!directed) {\n      const dup2 = edges.find(e => e.u===vId && e.v===uId && e.dir===false);\n      if (dup2) { if(!silent) log('Edge already exists (undirected duplicate)'); return null; }\n    }\n  }\n  const u = nodes.find(n=>n.id===uId); const v = nodes.find(n=>n.id===vId);\n  if (!u || !v) return null;\n  const id = edgeIdCounter++;\n  // edge group contains line and weight label (and optional arrow)\n  const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n  g.classList.add('edge-group');\n  const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n  line.setAttribute('stroke','#333'); line.setAttribute('stroke-width','2');\n  const weightLabel = document.createElementNS('http://www.w3.org/2000/svg','text');\n  weightLabel.setAttribute('text-anchor','middle');\n  weightLabel.setAttribute('dy','-6');\n  weightLabel.setAttribute('class','edge-weight-label');\n  weightLabel.textContent = weight;\n  // arrow marker if directed\n  if (directed) {\n    const markerId = 'arrow-' + id;\n    const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');\n    const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');\n    marker.setAttribute('id', markerId);\n    marker.setAttribute('markerWidth','8'); marker.setAttribute('markerHeight','8');\n    marker.setAttribute('refX','6'); marker.setAttribute('refY','3');\n    marker.setAttribute('orient','auto');\n    const poly = document.createElementNS('http://www.w3.org/2000/svg','path');\n    poly.setAttribute('d','M0,0 L6,3 L0,6 z');\n    poly.setAttribute('fill','#333');\n    marker.appendChild(poly);\n    defs.appendChild(marker);\n    g.appendChild(defs);\n    line.setAttribute('marker-end', 'url(#'+markerId+')');\n  }\n  g.appendChild(line);\n  g.appendChild(weightLabel);\n  // lower z-index than nodes\n  gEdges.appendChild(g);\n  const e = {id, u:uId, v:vId, weight: Number(weight), g, line, weightLabel, dir: directed};\n  edges.push(e);\n  updateEdgePosition(e);\n  updateStatus();\n  return id;\n}\n\nfunction updateEdgePosition(e) {\n  const u = nodes.find(n=>n.id===e.u);\n  const v = nodes.find(n=>n.id===e.v);\n  if (!u || !v) return;\n  // line endpoints offset a bit from node centers\n  const dx = v.x - u.x, dy = v.y - u.y;\n  const dist = Math.hypot(dx,dy) || 1;\n  const ox = (dx/dist) * 20, oy = (dy/dist) * 20;\n  const x1 = u.x + ox, y1 = u.y + oy;\n  const x2 = v.x - ox, y2 = v.y - oy;\n  e.line.setAttribute('x1', x1);\n  e.line.setAttribute('y1', y1);\n  e.line.setAttribute('x2', x2);\n  e.line.setAttribute('y2', y2);\n  // label midpoint\n  const mx = (x1+x2)/2, my = (y1+y2)/2;\n  e.weightLabel.setAttribute('x', mx);\n  e.weightLabel.setAttribute('y', my);\n  // stroke color default\n  e.line.setAttribute('stroke','#333');\n  e.line.setAttribute('stroke-width','2');\n}\n\nfunction updateAllEdges() {\n  edges.forEach(updateEdgePosition);\n}\n\nfunction removeNodeById(id) {\n  // remove edges touching node\n  const toRemove = edges.filter(e => e.u===id || e.v===id).map(e=>e.id);\n  toRemove.forEach(removeEdgeById);\n  const idx = nodes.findIndex(n=>n.id===id);\n  if (idx>=0) {\n    const n = nodes[idx];\n    if (n.g && n.g.parentNode) n.g.parentNode.removeChild(n.g);\n    nodes.splice(idx,1);\n  }\n  updateStatus();\n}\n\nfunction removeEdgeById(id) {\n  const idx = edges.findIndex(e=>e.id===id);\n  if (idx>=0) {\n    const e = edges[idx];\n    if (e.g && e.g.parentNode) e.g.parentNode.removeChild(e.g);\n    edges.splice(idx,1);\n  }\n  updateStatus();\n}\n\n// Canvas interactions\nsvg.addEventListener('pointerdown', svgPointerDown);\nfunction svgPointerDown(evt) {\n  const pt = getSvgPoint(evt);\n  if (mode === 'addNode') {\n    createNode(pt.x, pt.y);\n    render();\n    return;\n  }\n  if (mode === 'addEdge') {\n    // handled by node clicks\n    clearTempSelection();\n    log('Add Edge: click source then target');\n    return;\n  }\n  if (mode === 'move') {\n    // will be handled by node pointer events\n    return;\n  }\n  if (mode === 'del') {\n    // clicking empty space does nothing\n    return;\n  }\n}\n\n// Node pointer interactions: pointerdown used for select, drag\nlet dragging = null;\nlet dragOffset = {x:0,y:0};\nlet tempSelection = {firstNode: null, setSrc: false, setTgt:false};\n\nfunction nodePointerDown(evt) {\n  evt.stopPropagation();\n  const g = evt.currentTarget;\n  const id = Number(g.dataset.id);\n  if (mode === 'addEdge') {\n    if (!tempSelection.firstNode) {\n      tempSelection.firstNode = id;\n      highlightNode(id, '#2563eb');\n      log('Selected source node ' + id + '. Now click target.');\n    } else {\n      const src = tempSelection.firstNode;\n      const tgt = id;\n      if (src === tgt) {\n        log('Cannot create self-loop (ignored).');\n        clearTempSelection();\n        return;\n      }\n      const w = prompt('Edge weight (number):', '1');\n      if (w === null) { clearTempSelection(); return; }\n      const weight = Number(w);\n      if (Number.isNaN(weight)) { alert('Invalid weight'); clearTempSelection(); return; }\n      createEdge(src, tgt, weight, directedCheckbox.checked);\n      log(`Edge created: ${src} -> ${tgt} w=${weight}`);\n      clearTempSelection();\n      render();\n    }\n    return;\n  }\n  if (mode === 'move') {\n    // start dragging\n    dragging = nodes.find(n=>n.id===id);\n    const pt = getSvgPoint(evt);\n    dragOffset.x = dragging.x - pt.x;\n    dragOffset.y = dragging.y - pt.y;\n    svg.setPointerCapture(evt.pointerId);\n    svg.onpointermove = nodePointerMove;\n    svg.onpointerup = nodePointerUp;\n    highlightNode(id, '#2563eb');\n    return;\n  }\n  if (mode === 'del') {\n    // delete node or its edges\n    if (confirm('Delete node ' + id + ' and its edges?')) {\n      removeNodeById(id);\n      render();\n      log('Deleted node ' + id);\n    }\n    return;\n  }\n  // Other modes: selection for algorithms\n  if (tempSelection.setSrc) {\n    document.getElementById('alg-src').value = id;\n    tempSelection.setSrc = false;\n    highlightNode(id, '#2563eb');\n    log('Source set to ' + id);\n    return;\n  }\n  if (tempSelection.setTgt) {\n    document.getElementById('alg-tgt').value = id;\n    tempSelection.setTgt = false;\n    highlightNode(id, '#2563eb');\n    log('Target set to ' + id);\n    return;\n  }\n}\n\n// dragging handlers\nfunction nodePointerMove(evt) {\n  if (!dragging) return;\n  const pt = getSvgPoint(evt);\n  dragging.x = pt.x + dragOffset.x;\n  dragging.y = pt.y + dragOffset.y;\n  dragging.g.setAttribute('transform', `translate(${dragging.x},${dragging.y})`);\n  updateAllEdges();\n}\nfunction nodePointerUp(evt) {\n  if (dragging) {\n    svg.releasePointerCapture(evt.pointerId);\n    svg.onpointermove = null; svg.onpointerup = null;\n    dragging = null;\n  }\n}\n\n// utility: get SVG point from event\nfunction getSvgPoint(evt) {\n  const rect = svg.getBoundingClientRect();\n  const x = evt.clientX - rect.left;\n  const y = evt.clientY - rect.top;\n  return {x,y};\n}\n\n// highlight node by id\nfunction highlightNode(id, color) {\n  nodes.forEach(n => {\n    if (n.id===id) {\n      n.circle.setAttribute('fill', color || '#2563eb');\n    } else {\n      n.circle.setAttribute('fill', '#bbb');\n    }\n  });\n}\n\n// clear temporary selections or highlights\nfunction clearTempSelection() {\n  tempSelection.firstNode = null;\n  tempSelection.setSrc = false;\n  tempSelection.setTgt = false;\n  nodes.forEach(n => n.circle.setAttribute('fill','#bbb'));\n}\n\nfunction render() {\n  // bring nodes visually above edges by re-appending to svg\n  // We keep edges in gEdges and nodes in gNodes; but earlier we appended nodes directly.\n  // For simplicity reposition groups: remove all nodes elements and re-add in a layer on top.\n  // First update edges positions\n  updateAllEdges();\n  // Update node group transforms and labels\n  nodes.forEach(n => {\n    n.g.setAttribute('transform', `translate(${n.x},${n.y})`);\n    n.text.textContent = n.id;\n  });\n  updateStatus();\n}\n\n// Controls wiring\ndocument.getElementById('clear-graph').addEventListener('click', () => {\n  if (!confirm('Clear entire graph?')) return;\n  // remove nodes and edges DOM\n  nodes.forEach(n => { if (n.g.parentNode) n.g.parentNode.removeChild(n.g); });\n  edges.forEach(e => { if (e.g.parentNode) e.g.parentNode.removeChild(e.g); });\n  nodes = []; edges = [];\n  updateStatus();\n  log('Graph cleared');\n});\ndocument.getElementById('random-graph').addEventListener('click', () => {\n  const n = Math.max(2, Number(document.getElementById('rand-n').value) || 5);\n  const density = Math.min(100, Math.max(1, Number(document.getElementById('rand-density').value) || 30));\n  const maxw = Math.max(1, Number(document.getElementById('rand-maxw').value) || 10);\n  // clear existing\n  document.getElementById('clear-graph').click();\n  // add nodes at random positions\n  const rect = svg.getBoundingClientRect();\n  for (let i=0;i<n;i++) {\n    createNode(40 + Math.random()*(rect.width-80), 40 + Math.random()*(rect.height-80));\n  }\n  // add edges probabilistically\n  for (let i=0;i<n;i++) for (let j=i+1;j<n;j++) {\n    if (Math.random()*100 < density) {\n      const w = Math.ceil(Math.random()*maxw);\n      createEdge(nodes[i].id, nodes[j].id, w, directedCheckbox.checked && Math.random() < 0.5, true);\n    }\n  }\n  render();\n  log(`Random graph: ${n} nodes, density ${density}%`);\n});\n\n// Algorithm buttons\ndocument.getElementById('set-src').addEventListener('click', () => {\n  tempSelection.setSrc = true;\n  tempSelection.setTgt = false;\n  log('Click a node to set Source');\n});\ndocument.getElementById('set-tgt').addEventListener('click', () => {\n  tempSelection.setTgt = true;\n  tempSelection.setSrc = false;\n  log('Click a node to set Target');\n});\n\ndocument.getElementById('dijkstra-btn').addEventListener('click', () => {\n  const srcVal = document.getElementById('alg-src').value;\n  const tgtVal = document.getElementById('alg-tgt').value;\n  if (!srcVal || !tgtVal) { alert('Set source and target first'); return; }\n  const src = Number(srcVal), tgt = Number(tgtVal);\n  if (!nodes.find(n=>n.id===src) || !nodes.find(n=>n.id===tgt)) { alert('Invalid source/target'); return; }\n  runDijkstra(src, tgt);\n});\n\ndocument.getElementById('prim-btn').addEventListener('click', () => {\n  if (nodes.length===0) { alert('Graph empty'); return; }\n  runPrim();\n});\ndocument.getElementById('kruskal-btn').addEventListener('click', () => {\n  if (nodes.length===0) { alert('Graph empty'); return; }\n  runKruskal();\n});\n\n// Dijkstra implementation (works with directed edges according to edge.dir)\nfunction runDijkstra(src, tgt) {\n  // build adjacency list\n  const adj = new Map();\n  nodes.forEach(n => adj.set(n.id, []));\n  edges.forEach(e => {\n    adj.get(e.u).push({to:e.v, w:e.weight, id:e.id});\n    if (!e.dir) adj.get(e.v).push({to:e.u, w:e.weight, id:e.id});\n  });\n  // Dijkstra\n  const dist = new Map(); const prev = new Map(); const prevEdge = new Map();\n  nodes.forEach(n=> { dist.set(n.id, Infinity); prev.set(n.id,null); prevEdge.set(n.id,null); });\n  dist.set(src,0);\n  const pq = new Set(nodes.map(n=>n.id));\n  while (pq.size) {\n    // extract min (simple linear)\n    let u=null, best=Infinity;\n    for (const id of pq) { if (dist.get(id) < best) { best = dist.get(id); u=id; } }\n    if (u===null) break;\n    pq.delete(u);\n    if (u===tgt) break;\n    for (const e of adj.get(u)) {\n      const alt = dist.get(u) + e.w;\n      if (alt < dist.get(e.to)) { dist.set(e.to, alt); prev.set(e.to, u); prevEdge.set(e.to, e.id); }\n    }\n  }\n  if (dist.get(tgt) === Infinity) {\n    alert('No path found');\n    return;\n  }\n  // reconstruct path\n  const pathNodes = [];\n  const pathEdges = [];\n  let cur = tgt;\n  while (cur !== null) {\n    pathNodes.push(cur);\n    const pe = prevEdge.get(cur);\n    if (pe !== null) pathEdges.push(pe);\n    cur = prev.get(cur);\n  }\n  pathNodes.reverse();\n  pathEdges.reverse();\n  log(`Dijkstra: shortest ${dist.get(tgt)} via nodes ${pathNodes.join(' -> ')}`);\n  // Visual highlight path\n  clearHighlights();\n  pathNodes.forEach(id => {\n    const n = nodes.find(x=>x.id===id); if(n) n.circle.setAttribute('fill','#10b981');\n  });\n  edges.forEach(e => {\n    if (pathEdges.includes(e.id)) {\n      e.line.setAttribute('stroke','#10b981');\n      e.line.setAttribute('stroke-width','4');\n    } else {\n      e.line.setAttribute('stroke','#ddd');\n    }\n  });\n}\n\n// Prim's MST (graph treated as undirected)\nfunction runPrim() {\n  // build undirected adjacency\n  const adj = new Map();\n  nodes.forEach(n => adj.set(n.id, []));\n  edges.forEach(e => {\n    adj.get(e.u).push({to:e.v,w:e.weight,id:e.id});\n    adj.get(e.v).push({to:e.u,w:e.weight,id:e.id});\n  });\n  const start = nodes[0].id;\n  const inMST = new Set([start]);\n  const edgeList = [];\n  while (inMST.size < nodes.length) {\n    let bestEdge = null, bestW = Infinity;\n    for (const u of inMST) {\n      for (const e of adj.get(u)) {\n        if (!inMST.has(e.to) && e.w < bestW) { bestW = e.w; bestEdge = {u, v:e.to, id:e.id, w:e.w}; }\n      }\n    }\n    if (!bestEdge) break; // disconnected\n    inMST.add(bestEdge.v);\n    edgeList.push(bestEdge.id);\n  }\n  if (inMST.size < nodes.length) { alert('Graph is disconnected; MST covers only a component.'); }\n  // compute weight\n  let total = 0; edgeList.forEach(id=>{ const e = edges.find(x=>x.id===id); if (e) total += e.weight; });\n  log(`Prim's MST weight = ${total}; edges: ${edgeList.join(', ')}`);\n  clearHighlights();\n  edgeList.forEach(id => {\n    const e = edges.find(x=>x.id===id); if (e) { e.line.setAttribute('stroke','#10b981'); e.line.setAttribute('stroke-width','4'); }\n  });\n  // color nodes in MST\n  edges.filter(e=>edgeList.includes(e.id)).forEach(e => {\n    const nu = nodes.find(n=>n.id===e.u); const nv = nodes.find(n=>n.id===e.v);\n    if (nu) nu.circle.setAttribute('fill','#10b981');\n    if (nv) nv.circle.setAttribute('fill','#10b981');\n  });\n}\n\n// Kruskal's MST\nfunction runKruskal() {\n  // treat undirected: build list unique edges by undirected pair\n  const list = [];\n  edges.forEach(e => {\n    // normalize u < v for undirected MST treatment\n    const a = Math.min(e.u,e.v), b = Math.max(e.u,e.v);\n    // keep single instance; if multiple edges between same pair exist, keep all (Kruskal handles)\n    list.push({id:e.id, u:a, v:b, w:e.weight});\n  });\n  list.sort((a,b)=>a.w - b.w);\n  // union-find\n  const parent = new Map();\n  nodes.forEach(n=> parent.set(n.id, n.id));\n  function find(x){ if (parent.get(x)===x) return x; const r=find(parent.get(x)); parent.set(x,r); return r; }\n  function unite(a,b){ parent.set(find(a), find(b)); }\n  const picked = [];\n  for (const e of list) {\n    if (find(e.u) !== find(e.v)) {\n      unite(e.u, e.v);\n      picked.push(e.id);\n    }\n  }\n  let total = 0; picked.forEach(id=>{ const e = edges.find(x=>x.id===id); if (e) total += e.weight; });\n  log(`Kruskal's MST weight = ${total}; edges: ${picked.join(', ')}`);\n  clearHighlights();\n  picked.forEach(id => {\n    const e = edges.find(x=>x.id===id); if (e) { e.line.setAttribute('stroke','#10b981'); e.line.setAttribute('stroke-width','4'); }\n  });\n  edges.filter(e=>picked.includes(e.id)).forEach(e => {\n    const nu = nodes.find(n=>n.id===e.u); const nv = nodes.find(n=>n.id===e.v);\n    if (nu) nu.circle.setAttribute('fill','#10b981');\n    if (nv) nv.circle.setAttribute('fill','#10b981');\n  });\n}\n\nfunction clearHighlights() {\n  edges.forEach(e => { e.line.setAttribute('stroke','#ddd'); e.line.setAttribute('stroke-width','2'); });\n  nodes.forEach(n => { n.circle.setAttribute('fill','#bbb'); });\n}\n\n// Deletion of edges by clicking them in delete mode\n// We'll add pointer listeners for edge lines\nfunction attachEdgeListeners(e) {\n  e.line.style.cursor = 'pointer';\n  e.line.onpointerdown = (evt) => {\n    evt.stopPropagation();\n    if (mode === 'del') {\n      if (confirm('Delete this edge?')) {\n        removeEdgeById(e.id);\n      }\n    } else {\n      // show simple info\n      alert(`Edge ${e.id}: ${e.u} -> ${e.v}  weight=${e.weight}  ${e.dir ? '(directed)' : '(undirected)'}`);\n    }\n  };\n}\n\n// Whenever a new edge is created, attach listener\nconst origCreateEdge = createEdge;\ncreateEdge = function(u,v,w,d,silent){\n  const id = origCreateEdge(u,v,w,d,silent);\n  const e = edges.find(x=>x.id===id);\n  if (e) attachEdgeListeners(e);\n  return id;\n};\n\n// initial sample graph\n(function seed(){\n  createNode(120,100); createNode(300,80); createNode(260,220); createNode(110,240); createNode(420,180);\n  createEdge(1,2,4,false); createEdge(2,3,2,false); createEdge(3,4,7,false); createEdge(4,1,3,false); createEdge(2,5,5,false);\n  render();\n  log('Sample graph created');\n})();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}