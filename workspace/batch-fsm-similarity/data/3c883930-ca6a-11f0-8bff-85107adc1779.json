{
  "id": "3c883930-ca6a-11f0-8bff-85107adc1779",
  "timestamp": "2025-11-26T01:51:51.194Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Red-Black Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Red-Black Tree Visualization & Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 10px;\n    background: #f9f9f9;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n  h1 {\n    color: #222;\n  }\n  #controls {\n    margin-bottom: 10px;\n  }\n  input[type=number] {\n    width: 80px;\n    padding: 5px;\n    font-size: 1em;\n  }\n  button {\n    padding: 6px 10px;\n    margin-left: 8px;\n    font-size: 1em;\n    cursor: pointer;\n  }\n  #messages {\n    margin-top: 10px;\n    min-height: 18px;\n    font-weight: bold;\n    color: #444;\n  }\n  #canvasContainer {\n    border: 1px solid #ccc;\n    background: white;\n    border-radius: 6px;\n  }\n  canvas {\n    display: block;\n  }\n  footer {\n    margin-top: 20px;\n    font-size: 0.85em;\n    color: #777;\n  }\n</style>\n</head>\n<body>\n<h1>Red-Black Tree Visualizer & Demo</h1>\n<div id=\"controls\">\n  <input type=\"number\" id=\"inputKey\" placeholder=\"Enter key\" />\n  <button id=\"insertBtn\">Insert</button>\n  <button id=\"deleteBtn\">Delete</button>\n  <button id=\"resetBtn\" title=\"Reset the tree\">Reset</button>\n</div>\n<div id=\"messages\"></div>\n<div id=\"canvasContainer\">\n  <canvas id=\"treeCanvas\" width=\"900\" height=\"460\"></canvas>\n</div>\n\n<script>\n// Red-Black Tree Implementation + Visualization\n\n// Node colors\nconst RED = true;\nconst BLACK = false;\n\nclass RBNode {\n  constructor(key, color = RED, parent = null) {\n    this.key = key;\n    this.color = color; // true=red, false=black\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n  }\n}\n\n// Red-Black Tree class\nclass RBTree {\n  constructor() {\n    this.NIL = new RBNode(null, BLACK); // Sentinel NIL node\n    this.root = this.NIL;\n  }\n\n  leftRotate(x) {\n    const y = x.right;\n    x.right = y.left;\n    if (y.left !== this.NIL) {\n      y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === null) {\n      this.root = y;\n    } else if (x === x.parent.left) {\n      x.parent.left = y;\n    } else {\n      x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n  }\n\n  rightRotate(y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== this.NIL) {\n      x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === null) {\n      this.root = x;\n    } else if (y === y.parent.right) {\n      y.parent.right = x;\n    } else {\n      y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n  }\n\n  insert(key) {\n    let node = new RBNode(key);\n    node.left = this.NIL;\n    node.right = this.NIL;\n\n    let y = null;\n    let x = this.root;\n\n    while (x !== this.NIL) {\n      y = x;\n      if (node.key < x.key) {\n        x = x.left;\n      } else if (node.key > x.key) {\n        x = x.right;\n      } else {\n        // Duplicate keys are not allowed\n        return false;\n      }\n    }\n\n    node.parent = y;\n    if (y === null) {\n      this.root = node;\n    } else if (node.key < y.key) {\n      y.left = node;\n    } else {\n      y.right = node;\n    }\n\n    node.color = RED;\n    this.insertFixup(node);\n    return true;\n  }\n\n  insertFixup(z) {\n    while (z.parent && z.parent.color === RED) {\n      if (z.parent === z.parent.parent.left) {\n        let y = z.parent.parent.right;\n        if (y.color === RED) {\n          // Case 1\n          z.parent.color = BLACK;\n          y.color = BLACK;\n          z.parent.parent.color = RED;\n          z = z.parent.parent;\n        } else {\n          if (z === z.parent.right) {\n            // Case 2\n            z = z.parent;\n            this.leftRotate(z);\n          }\n          // Case 3\n          z.parent.color = BLACK;\n          z.parent.parent.color = RED;\n          this.rightRotate(z.parent.parent);\n        }\n      } else {\n        let y = z.parent.parent.left;\n        if (y.color === RED) {\n          // Case 1 mirror\n          z.parent.color = BLACK;\n          y.color = BLACK;\n          z.parent.parent.color = RED;\n          z = z.parent.parent;\n        } else {\n          if (z === z.parent.left) {\n            // Case 2 mirror\n            z = z.parent;\n            this.rightRotate(z);\n          }\n          // Case 3 mirror\n          z.parent.color = BLACK;\n          z.parent.parent.color = RED;\n          this.leftRotate(z.parent.parent);\n        }\n      }\n    }\n    this.root.color = BLACK;\n  }\n\n  transplant(u, v) {\n    if (u.parent === null) {\n      this.root = v;\n    } else if (u === u.parent.left) {\n      u.parent.left = v;\n    } else {\n      u.parent.right = v;\n    }\n    v.parent = u.parent;\n  }\n\n  minimum(x) {\n    while (x.left !== this.NIL) {\n      x = x.left;\n    }\n    return x;\n  }\n\n  delete(key) {\n    let z = this.search(this.root, key);\n    if (z === this.NIL) {\n      return false;\n    }\n    let y = z;\n    let yOriginalColor = y.color;\n    let x;\n\n    if (z.left === this.NIL) {\n      x = z.right;\n      this.transplant(z, z.right);\n    } else if (z.right === this.NIL) {\n      x = z.left;\n      this.transplant(z, z.left);\n    } else {\n      y = this.minimum(z.right);\n      yOriginalColor = y.color;\n      x = y.right;\n      if (y.parent === z) {\n        x.parent = y;\n      } else {\n        this.transplant(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.transplant(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n      y.color = z.color;\n    }\n    if (yOriginalColor === BLACK) {\n      this.deleteFixup(x);\n    }\n    return true;\n  }\n\n  deleteFixup(x) {\n    while (x !== this.root && x.color === BLACK) {\n      if (x === x.parent.left) {\n        let w = x.parent.right;\n        if (w.color === RED) {\n          w.color = BLACK;\n          x.parent.color = RED;\n          this.leftRotate(x.parent);\n          w = x.parent.right;\n        }\n        if (w.left.color === BLACK && w.right.color === BLACK) {\n          w.color = RED;\n          x = x.parent;\n        } else {\n          if (w.right.color === BLACK) {\n            w.left.color = BLACK;\n            w.color = RED;\n            this.rightRotate(w);\n            w = x.parent.right;\n          }\n          w.color = x.parent.color;\n          x.parent.color = BLACK;\n          w.right.color = BLACK;\n          this.leftRotate(x.parent);\n          x = this.root;\n        }\n      } else {\n        let w = x.parent.left;\n        if (w.color === RED) {\n          w.color = BLACK;\n          x.parent.color = RED;\n          this.rightRotate(x.parent);\n          w = x.parent.left;\n        }\n        if (w.right.color === BLACK && w.left.color === BLACK) {\n          w.color = RED;\n          x = x.parent;\n        } else {\n          if (w.left.color === BLACK) {\n            w.right.color = BLACK;\n            w.color = RED;\n            this.leftRotate(w);\n            w = x.parent.left;\n          }\n          w.color = x.parent.color;\n          x.parent.color = BLACK;\n          w.left.color = BLACK;\n          this.rightRotate(x.parent);\n          x = this.root;\n        }\n      }\n    }\n    x.color = BLACK;\n  }\n\n  search(node, key) {\n    while (node !== this.NIL && key !== node.key) {\n      if (key < node.key) {\n        node = node.left;\n      } else {\n        node = node.right;\n      }\n    }\n    return node;\n  }\n\n  inorderTraversal(node, cb) {\n    if (node !== this.NIL) {\n      this.inorderTraversal(node.left, cb);\n      cb(node);\n      this.inorderTraversal(node.right, cb);\n    }\n  }\n}\n\n// Visualization and UI\n\nconst canvas = document.getElementById('treeCanvas');\nconst ctx = canvas.getContext('2d');\nconst insertBtn = document.getElementById('insertBtn');\nconst deleteBtn = document.getElementById('deleteBtn');\nconst resetBtn = document.getElementById('resetBtn');\nconst inputKey = document.getElementById('inputKey');\nconst messages = document.getElementById('messages');\n\nconst tree = new RBTree();\n\n// Visualization parameters\nconst NODE_RADIUS = 20;\nconst LEVEL_HEIGHT = 70;\nconst FONT_SIZE = 14;\nconst H_SPACING_MIN = 20;\n\nfunction clearCanvas() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nfunction drawNode(node, x, y) {\n  // Draw circle\n  ctx.beginPath();\n  ctx.arc(x, y, NODE_RADIUS, 0, 2 * Math.PI);\n  ctx.fillStyle = node.color === RED ? '#d9534f' : '#222'; // red or black\n  ctx.fill();\n  ctx.lineWidth = 2;\n  ctx.strokeStyle = '#333';\n  ctx.stroke();\n\n  // Draw text\n  ctx.fillStyle = node.color === RED ? '#fff' : '#fff';\n  ctx.font = `${FONT_SIZE}px Arial`;\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n  ctx.fillText(node.key, x, y);\n}\n\nfunction drawLine(x1, y1, x2, y2) {\n  ctx.beginPath();\n  ctx.strokeStyle = '#444';\n  ctx.lineWidth = 2;\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n  ctx.stroke();\n}\n\n// Compute tree layout to position nodes\n\nfunction computePositions(root) {\n  const positions = new Map();\n\n  // Modified Reingold-Tilford algorithm (simple version) with horizontal position by inorder index\n  // Step 1: inorder traversal and assign x by order count\n  let count = 0;\n  function inorder(node, depth) {\n    if (node === tree.NIL) return;\n    inorder(node.left, depth + 1);\n    positions.set(node, {x: count, depth});\n    count++;\n    inorder(node.right, depth + 1);\n  }\n  inorder(root, 0);\n\n  // Spread positions horizontally according to canvas width\n  // Calculate max depth for y positioning and max count for x scaling\n  let maxDepth = 0;\n  positions.forEach(({depth}) => {\n    if(depth > maxDepth) maxDepth = depth;\n  });\n\n  const nodeCount = count;\n  const hSpacing = Math.max(H_SPACING_MIN, canvas.width / (nodeCount + 1));\n  const verticalSpacing = LEVEL_HEIGHT;\n\n  // Convert x counts to pixel coordinates\n  const coords = new Map();\n  positions.forEach(({x, depth}, node) => {\n    coords.set(node, {\n      x: (x + 1) * hSpacing,\n      y: (depth + 1) * verticalSpacing\n    });\n  });\n\n  return coords;\n}\n\n// Draw the tree recursively including lines\nfunction drawTree(root) {\n  clearCanvas();\n  if (root === tree.NIL) return;\n  const coords = computePositions(root);\n\n  // Draw edges first\n  coords.forEach((pos, node) => {\n    if(node.left !== tree.NIL) {\n      let childPos = coords.get(node.left);\n      drawLine(pos.x, pos.y, childPos.x, childPos.y);\n    }\n    if(node.right !== tree.NIL) {\n      let childPos = coords.get(node.right);\n      drawLine(pos.x, pos.y, childPos.x, childPos.y);\n    }\n  });\n  // Draw nodes on top\n  coords.forEach((pos, node) => {\n    drawNode(node, pos.x, pos.y);\n  });\n}\n\n// UI and interaction\n\nfunction showMessage(msg, isError = false) {\n  messages.textContent = msg;\n  messages.style.color = isError ? '#d9534f' : '#2a7f62';\n}\n\nfunction clearMessage() {\n  messages.textContent = '';\n}\n\nfunction tryInsertKey(keyVal) {\n  if (isNaN(keyVal)) {\n    showMessage('Please enter a valid integer key.', true);\n    return;\n  }\n  const inserted = tree.insert(keyVal);\n  if (inserted) {\n    showMessage(`Inserted key ${keyVal}.`);\n    drawTree(tree.root);\n  } else {\n    showMessage(`Duplicate key ${keyVal} not inserted.`, true);\n  }\n}\n\nfunction tryDeleteKey(keyVal) {\n  if (isNaN(keyVal)) {\n    showMessage('Please enter a valid integer key.', true);\n    return;\n  }\n  const deleted = tree.delete(keyVal);\n  if (deleted) {\n    showMessage(`Deleted key ${keyVal}.`);\n    drawTree(tree.root);\n  } else {\n    showMessage(`Key ${keyVal} not found.`, true);\n  }\n}\n\ninsertBtn.addEventListener('click', () => {\n  const val = parseInt(inputKey.value, 10);\n  tryInsertKey(val);\n  inputKey.value = '';\n  inputKey.focus();\n});\n\ndeleteBtn.addEventListener('click', () => {\n  const val = parseInt(inputKey.value, 10);\n  tryDeleteKey(val);\n  inputKey.value = '';\n  inputKey.focus();\n});\n\nresetBtn.addEventListener('click', () => {\n  tree.root = tree.NIL;\n  clearCanvas();\n  clearMessage();\n  inputKey.value = '';\n  inputKey.focus();\n});\n\ninputKey.addEventListener('keydown', (e) => {\n  if(e.key === 'Enter') {\n    insertBtn.click();\n  }\n});\n\n// Initial draw (empty)\nclearCanvas();\n\n</script>\n<footer>Red-Black Tree demo & visualization by ChatGPT</footer>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Red-Black Tree"
    }
  ],
  "topic": "Red-Black Tree",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}