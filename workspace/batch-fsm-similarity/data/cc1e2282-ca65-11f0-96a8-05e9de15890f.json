{
  "id": "cc1e2282-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:45.164Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Depth-First Search (DFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<title>Depth-First Search (DFS) Visualizer</title>\n<style>\n  :root{\n    --bg:#0f1724;\n    --panel:#0b1220;\n    --accent:#3b82f6;\n    --muted:#94a3b8;\n    --card:#0f172c;\n    --ok:#16a34a;\n    --danger:#ef4444;\n    --edge:#6b7280;\n    --text:#e6eef8;\n  }\n  html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;}\n  body{background:linear-gradient(180deg,#061029 0%, #071220 100%); color:var(--text); display:flex; flex-direction:column; align-items:center; gap:12px; padding:18px;}\n  h1{margin:0;font-size:20px;letter-spacing:0.2px;}\n  .container{width:1100px; max-width:calc(100vw - 36px); display:grid; grid-template-columns: 720px 1fr; gap:14px;}\n  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02) 0%, rgba(255,255,255,0.01) 100%); border:1px solid rgba(255,255,255,0.04); border-radius:10px; padding:12px; box-sizing:border-box;}\n  .left{height:640px; display:flex; flex-direction:column; gap:10px;}\n  #canvasWrap{flex:1; background:transparent; border-radius:8px; display:flex; align-items:center; justify-content:center; position:relative; min-height:0;}\n  svg{width:100%; height:100%; overflow:visible; touch-action:none;}\n  .controls{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}\n  .controls > *{font-size:13px;}\n  button, select, input[type=\"number\"], input[type=\"range\"]{background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--text); padding:6px 8px; border-radius:6px;}\n  button:hover{border-color:rgba(255,255,255,0.12);}\n  .small{font-size:12px;padding:6px;}\n  .panel{display:flex; flex-direction:column; gap:8px;}\n  .right{height:640px; overflow:auto;}\n  .legend{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}\n  .chip{display:inline-flex; gap:6px; align-items:center; padding:6px 8px; border-radius:8px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); font-size:13px;}\n  .chip .sw{width:14px; height:14px; border-radius:3px;}\n  #info{font-size:13px; color:var(--muted); line-height:1.3;}\n  .adj{font-family:monospace; font-size:13px; color:var(--muted); white-space:pre; overflow:auto; max-height:180px;}\n  .stackBox{font-family:monospace; background:rgba(255,255,255,0.02); padding:8px; border-radius:6px; border:1px solid rgba(255,255,255,0.03);}\n  .times{display:flex; gap:8px; flex-wrap:wrap;}\n  .nodeLabel{font-size:12px; fill:var(--text); pointer-events:none; text-anchor:middle; dominant-baseline:middle;}\n  .edgeLabel{font-size:12px; fill:var(--muted); pointer-events:none;}\n  .smallText{font-size:12px;color:var(--muted);}\n  .footer{display:flex; justify-content:space-between; align-items:center; gap:12px;margin-top:6px;}\n  .logo{font-weight:600; color:var(--muted); font-size:13px;}\n  input[type=\"color\"]{padding:2px;border-radius:6px;}\n  .hint{font-size:12px;color:var(--muted);}\n  .btnPrimary{background:linear-gradient(180deg,var(--accent), #1e63d6);border:none;padding:8px 10px;border-radius:8px;color:white;font-weight:600;}\n  .btnDanger{background:linear-gradient(180deg,#ef4444,#c92b2b);border:none;padding:6px 8px;border-radius:8px;color:white;}\n  .controlsGroup{display:flex; gap:6px; align-items:center; flex-wrap:wrap;}\n  .nodeCircle{cursor:pointer; stroke:#111827; stroke-width:1.5px;}\n  .edgeLine{stroke-width:2.2px; stroke-linecap:round;}\n  .edgeArrow{fill:currentColor;}\n  /* responsive */\n  @media (max-width:1000px){ .container{grid-template-columns:1fr; } .left{order:1} .right{order:2} }\n</style>\n</head>\n<body>\n  <div style=\"width:100%; max-width:1100px; display:flex; justify-content:space-between; align-items:center;\">\n    <h1>Depth-First Search (DFS) Visualizer</h1>\n    <div class=\"logo\">Interactive demonstration — step, play, inspect edges</div>\n  </div>\n\n  <div class=\"container\">\n    <div class=\"card left\">\n      <div class=\"controls\">\n        <div class=\"controlsGroup\">\n          <label class=\"smallText\">Mode:</label>\n          <select id=\"mode\">\n            <option value=\"recursive\">Recursive (generator)</option>\n            <option value=\"iterative\">Iterative (explicit stack)</option>\n          </select>\n          <label class=\"smallText\">Directed:</label>\n          <select id=\"directed\">\n            <option value=\"true\">Yes</option>\n            <option value=\"false\">No</option>\n          </select>\n        </div>\n\n        <div class=\"controlsGroup\">\n          <label class=\"smallText\">Nodes:</label>\n          <input id=\"nodeCount\" type=\"number\" value=\"8\" min=\"2\" max=\"20\" style=\"width:66px\"/>\n          <label class=\"smallText\">Density:</label>\n          <input id=\"density\" type=\"range\" min=\"0\" max=\"1\" step=\"0.05\" value=\"0.25\"/>\n          <button id=\"randomize\" class=\"small\">Random graph</button>\n        </div>\n\n        <div class=\"controlsGroup\">\n          <label class=\"smallText\">Start:</label>\n          <select id=\"startNode\"></select>\n          <button id=\"run\" class=\"btnPrimary\">Run</button>\n          <button id=\"stepBtn\">Step</button>\n          <button id=\"playBtn\" class=\"small\">Play</button>\n          <button id=\"pauseBtn\" class=\"small\">Pause</button>\n          <button id=\"resetBtn\" class=\"small\">Reset</button>\n        </div>\n\n        <div class=\"controlsGroup\">\n          <label class=\"smallText\">Speed:</label>\n          <input id=\"speed\" type=\"range\" min=\"100\" max=\"2000\" step=\"50\" value=\"600\"/>\n          <span class=\"smallText\" id=\"speedLabel\">600 ms</span>\n        </div>\n      </div>\n\n      <div id=\"canvasWrap\">\n        <svg id=\"svg\" viewBox=\"0 0 720 560\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n      </div>\n\n      <div style=\"display:flex; justify-content:space-between; align-items:center; gap:12px;\">\n        <div class=\"legend\">\n          <div class=\"chip\"><div class=\"sw\" style=\"background:#ffffff;border:1px solid #94a3b8\"></div> White (unvisited)</div>\n          <div class=\"chip\"><div class=\"sw\" style=\"background:#f59e0b\"></div> Gray (discovered)</div>\n          <div class=\"chip\"><div class=\"sw\" style=\"background:#10b981\"></div> Black (finished)</div>\n          <div class=\"chip\"><div class=\"sw\" style=\"background:#9ca3ff\"></div> Tree edge</div>\n          <div class=\"chip\"><div class=\"sw\" style=\"background:#ef4444\"></div> Back edge</div>\n          <div class=\"chip\"><div class=\"sw\" style=\"background:#06b6d4\"></div> Forward edge</div>\n          <div class=\"chip\"><div class=\"sw\" style=\"background:#f97316\"></div> Cross edge</div>\n        </div>\n\n        <div style=\"display:flex; gap:8px; align-items:center;\">\n          <div class=\"hint\">Click a node to drag. Shift+click two nodes to toggle an edge between them.</div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"card right\">\n      <div style=\"display:flex; justify-content:space-between; gap:12px; align-items:flex-start;\">\n        <div style=\"flex:1;\">\n          <h3 style=\"margin:6px 0 4px 0\">Status & Data</h3>\n          <div id=\"info\">Press \"Random graph\" or create nodes/edges, choose start node and press Run. Use Step/Play to watch DFS explore the graph. The panel shows discovery/finish times, current stack, adjacency list and edge classifications.</div>\n        </div>\n        <div style=\"width:220px;\">\n          <h3 style=\"margin:6px 0 4px 0\">Execution</h3>\n          <div class=\"times\">\n            <div class=\"stackBox\" id=\"stackView\">Stack: []</div>\n            <div class=\"stackBox\" id=\"timeView\">Time: 0</div>\n          </div>\n        </div>\n      </div>\n\n      <div style=\"display:flex; gap:12px; margin-top:10px;\">\n        <div style=\"flex:1;\">\n          <h4 style=\"margin:6px 0\">Discovery & Finish Times</h4>\n          <div id=\"timesList\" class=\"adj\">-</div>\n        </div>\n        <div style=\"width:260px;\">\n          <h4 style=\"margin:6px 0\">Adjacency List</h4>\n          <div id=\"adjList\" class=\"adj\">-</div>\n          <div style=\"margin-top:8px; display:flex; gap:8px;\">\n            <button id=\"clearEdges\" class=\"small\">Clear Edges</button>\n            <button id=\"clearNodes\" class=\"small\">Clear Nodes</button>\n          </div>\n        </div>\n      </div>\n\n      <div style=\"margin-top:12px;\">\n        <h4 style=\"margin:6px 0\">Edge Classifications (so far)</h4>\n        <div id=\"edgeClasses\" class=\"adj\">-</div>\n      </div>\n\n      <div style=\"margin-top:12px; display:flex; gap:8px; align-items:center;\">\n        <button id=\"explainBtn\" class=\"small\">Show explanation</button>\n        <div id=\"explainText\" class=\"smallText\" style=\"flex:1; display:none;\">\n          Depth-First Search (DFS) is an algorithm for traversing or searching graph structures. It explores as far along each branch before backtracking. Time complexity is O(V+E). Use recursion or an explicit stack to implement it.\n        </div>\n      </div>\n\n      <div class=\"footer\">\n        <div class=\"smallText\">Edge types are determined using discovery/finish times: tree/back/forward/cross (for directed graphs). For undirected graphs, cross/forward edges are less meaningful.</div>\n        <div class=\"smallText\">Built for demonstration — single-file.</div>\n      </div>\n    </div>\n  </div>\n\n<script>\n/*\n  DFS Visualizer\n  - Single-file interactive demo\n  - Supports recursive (generator-based) and iterative DFS\n  - Visualizes node colors, discovery/finish times, stack, and edge classifications\n  - Simple graph editor: Shift+click two nodes to toggle an edge between them; drag nodes\n*/\n\n(() => {\n  // Utilities\n  const svg = document.getElementById('svg');\n  const NS = \"http://www.w3.org/2000/svg\";\n  const WIDTH = 720, HEIGHT = 560;\n  svg.setAttribute('viewBox', `0 0 ${WIDTH} ${HEIGHT}`);\n\n  let nodes = [], edges = []; // edges: {u,v,directed}\n  let dragging = null, dragOffset = {x:0,y:0};\n  let selectedForEdge = null;\n\n  // DOM controls\n  const nodeCountInput = document.getElementById('nodeCount');\n  const densityInput = document.getElementById('density');\n  const randomizeBtn = document.getElementById('randomize');\n  const directedSelect = document.getElementById('directed');\n  const startSelect = document.getElementById('startNode');\n  const runBtn = document.getElementById('run');\n  const stepBtn = document.getElementById('stepBtn');\n  const playBtn = document.getElementById('playBtn');\n  const pauseBtn = document.getElementById('pauseBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const modeSelect = document.getElementById('mode');\n  const speedInput = document.getElementById('speed');\n  const speedLabel = document.getElementById('speedLabel');\n  const timesList = document.getElementById('timesList');\n  const adjList = document.getElementById('adjList');\n  const edgeClassesDiv = document.getElementById('edgeClasses');\n  const stackView = document.getElementById('stackView');\n  const timeView = document.getElementById('timeView');\n  const clearEdgesBtn = document.getElementById('clearEdges');\n  const clearNodesBtn = document.getElementById('clearNodes');\n  const explainBtn = document.getElementById('explainBtn');\n  const explainText = document.getElementById('explainText');\n\n  speedInput.addEventListener('input', ()=> speedLabel.textContent = `${speedInput.value} ms`);\n\n  // Graph drawing helpers\n  function createNode(id, x, y){\n    return {id, x, y, r:18};\n  }\n  function addNode(x,y){\n    const id = nodes.length;\n    nodes.push(createNode(id, x, y));\n    rebuildStartSelect();\n    render();\n  }\n  function removeAllNodes(){\n    nodes = [];\n    edges = [];\n    render();\n  }\n  function clearEdges(){\n    edges = [];\n    render();\n  }\n  function toggleEdge(u,v){\n    // check if exists (for directed graph consider either orientation for undirected)\n    const d = isDirected();\n    const found = edges.findIndex(e => e.u===u && e.v===v && e.directed===d);\n    if(found >= 0){\n      edges.splice(found,1);\n    } else {\n      // if undirected, ensure not duplicate both directions\n      if(!d){\n        // remove any existing undirected between these two\n        const existing = edges.findIndex(e => !e.directed && ((e.u===u && e.v===v) || (e.u===v && e.v===u)));\n        if(existing >= 0) return;\n      }\n      edges.push({u,v,directed:d});\n    }\n    render();\n  }\n  function isDirected(){ return directedSelect.value === \"true\"; }\n\n  // Layout: place nodes in a circle by default\n  function createRandomGraph(n,density){\n    nodes = [];\n    edges = [];\n    const cx = WIDTH/2, cy = HEIGHT/2;\n    const R = Math.min(WIDTH, HEIGHT)/2 - 60;\n    for(let i=0;i<n;i++){\n      const angle = (i/n) * Math.PI*2;\n      const jitter = (Math.random()*0.6 - 0.3) * 30;\n      const x = cx + (R + jitter) * Math.cos(angle);\n      const y = cy + (R + jitter) * Math.sin(angle);\n      nodes.push(createNode(i,x,y));\n    }\n    // Add edges based on density\n    for(let i=0;i<n;i++){\n      for(let j=0;j<n;j++){\n        if(i===j) continue;\n        if(Math.random() < density){\n          if(isDirected()){\n            edges.push({u:i,v:j,directed:true});\n          } else {\n            // undirected, add only once for i<j\n            if(i<j) edges.push({u:i,v:j,directed:false});\n          }\n        }\n      }\n    }\n    rebuildStartSelect();\n    render();\n  }\n\n  // Build adjacency list representation based on directed or not\n  function buildAdjacency(){\n    const n = nodes.length;\n    const adj = Array.from({length:n}, ()=>[]);\n    for(const e of edges){\n      adj[e.u].push(e.v);\n      if(!e.directed){\n        adj[e.v].push(e.u);\n      }\n    }\n    // sort neighbors for deterministic traversal\n    for(let i=0;i<n;i++){\n      adj[i].sort((a,b)=>a-b);\n    }\n    return adj;\n  }\n\n  // Rendering\n  function clearSVG(){\n    while(svg.firstChild) svg.removeChild(svg.firstChild);\n  }\n\n  function render(){\n    clearSVG();\n    const adj = buildAdjacency();\n    // draw arrow marker defs\n    const defs = document.createElementNS(NS,'defs');\n    const marker = document.createElementNS(NS,'marker');\n    marker.setAttribute('id','arrow');\n    marker.setAttribute('markerWidth','8');\n    marker.setAttribute('markerHeight','8');\n    marker.setAttribute('refX','8');\n    marker.setAttribute('refY','3');\n    marker.setAttribute('orient','auto');\n    marker.setAttribute('markerUnits','strokeWidth');\n    const path = document.createElementNS(NS,'path');\n    path.setAttribute('d','M0,0 L6,3 L0,6 z');\n    path.setAttribute('fill','#ffffff');\n    marker.appendChild(path);\n    defs.appendChild(marker);\n    svg.appendChild(defs);\n\n    // draw edges (base)\n    edges.forEach((e,idx) => {\n      const u = nodes[e.u], v = nodes[e.v];\n      if(!u || !v) return;\n      // compute line endpoints offset from circle\n      const dx = v.x - u.x, dy = v.y - u.y;\n      const len = Math.hypot(dx,dy) || 1;\n      const ux = dx/len, uy = dy/len;\n      const startX = u.x + ux * u.r;\n      const startY = u.y + uy * u.r;\n      const endX = v.x - ux * v.r;\n      const endY = v.y - uy * v.r;\n\n      const g = document.createElementNS(NS,'g');\n      g.setAttribute('data-edge-idx', idx);\n\n      const line = document.createElementNS(NS,'line');\n      line.setAttribute('x1', startX);\n      line.setAttribute('y1', startY);\n      line.setAttribute('x2', endX);\n      line.setAttribute('y2', endY);\n      line.setAttribute('class','edgeLine');\n      line.setAttribute('stroke', '#8b95a6');\n      line.setAttribute('stroke-opacity', 0.9);\n      line.setAttribute('stroke-width', 2.2);\n      if(e.directed) {\n        line.setAttribute('marker-end', 'url(#arrow)');\n      }\n      g.appendChild(line);\n\n      // small label showing \"u→v\"\n      const mx = (startX+endX)/2, my = (startY+endY)/2;\n      const lbl = document.createElementNS(NS,'text');\n      lbl.setAttribute('x', mx + (-uy*8));\n      lbl.setAttribute('y', my + (ux*8));\n      lbl.setAttribute('class','edgeLabel');\n      lbl.textContent = `${e.u}→${e.v}`;\n      g.appendChild(lbl);\n\n      svg.appendChild(g);\n    });\n\n    // draw nodes\n    nodes.forEach((n) => {\n      const g = document.createElementNS(NS,'g');\n      g.setAttribute('transform', `translate(${n.x}, ${n.y})`);\n      g.setAttribute('data-node', n.id);\n\n      const circle = document.createElementNS(NS,'circle');\n      circle.setAttribute('r', n.r);\n      circle.setAttribute('class','nodeCircle');\n      circle.setAttribute('fill', '#ffffff');\n      circle.setAttribute('stroke', '#111827');\n      circle.setAttribute('stroke-width', '1.5');\n      circle.style.transition = 'fill 200ms, transform 100ms';\n      g.appendChild(circle);\n\n      const label = document.createElementNS(NS,'text');\n      label.setAttribute('class','nodeLabel');\n      label.textContent = n.id;\n      g.appendChild(label);\n\n      // event listeners for dragging & edge creation\n      g.addEventListener('mousedown', (ev) => {\n        ev.preventDefault();\n        const id = n.id;\n        if(ev.shiftKey){\n          // edge creation: select node or toggle edge if second selected\n          if(selectedForEdge === null){\n            selectedForEdge = id;\n            highlightNode(id, true);\n          } else if(selectedForEdge === id){\n            highlightNode(selectedForEdge, false);\n            selectedForEdge = null;\n          } else {\n            // toggle edge between selectedForEdge and id\n            toggleEdge(selectedForEdge, id);\n            highlightNode(selectedForEdge, false);\n            selectedForEdge = null;\n          }\n        } else {\n          dragging = id;\n          const pt = svgPoint(ev.clientX, ev.clientY);\n          dragOffset.x = n.x - pt.x;\n          dragOffset.y = n.y - pt.y;\n        }\n      });\n\n      g.addEventListener('dblclick', (ev) => {\n        // double click to remove node and incident edges\n        const id = n.id;\n        nodes = nodes.filter(no => no.id !== id).map((no,i) => ({...no, id:i}));\n        edges = edges.filter(e => e.u !== id && e.v !== id).map(e => {\n          // adjust indices down by 1 for nodes greater than removed id\n          const adj = (x) => x > id ? x-1 : x;\n          return {u:adj(e.u), v:adj(e.v), directed:e.directed};\n        });\n        rebuildStartSelect();\n        render();\n      });\n\n      svg.appendChild(g);\n    });\n\n    // attach mousemove/up to document for dragging\n    document.onmousemove = (ev) => {\n      if(dragging === null) return;\n      const pt = svgPoint(ev.clientX, ev.clientY);\n      const node = nodes.find(n => n.id === dragging);\n      if(!node) return;\n      node.x = Math.max(30, Math.min(WIDTH-30, pt.x + dragOffset.x));\n      node.y = Math.max(30, Math.min(HEIGHT-30, pt.y + dragOffset.y));\n      render(); // re-render edges/nodes positions\n    };\n    document.onmouseup = () => {\n      dragging = null;\n    };\n\n    updateInfoUI();\n  }\n\n  function highlightNode(id, on){\n    const el = svg.querySelector(`g[data-node=\"${id}\"] circle`);\n    if(el) el.setAttribute('stroke', on ? '#f59e0b' : '#111827');\n  }\n\n  function svgPoint(clientX, clientY){\n    const pt = svg.createSVGPoint();\n    pt.x = clientX; pt.y = clientY;\n    const ctm = svg.getScreenCTM().inverse();\n    const p = pt.matrixTransform(ctm);\n    return {x:p.x, y:p.y};\n  }\n\n  // DFS engine: produce a generator of step events to animate\n  function* dfsRecursive(start){\n    const n = nodes.length;\n    const adj = buildAdjacency();\n    const color = Array(n).fill('white');\n    const d = Array(n).fill(0), f = Array(n).fill(0);\n    let time = 0;\n    function* visit(u){\n      color[u] = 'gray'; time++; d[u]=time;\n      yield {type:'discover', node:u, time};\n      for(const v of adj[u]){\n        yield {type:'examine', u, v};\n        if(color[v] === 'white'){\n          yield {type:'edgeClass', u, v, cls:'tree'};\n          yield* visit(v);\n        } else if(color[v] === 'gray'){\n          yield {type:'edgeClass', u, v, cls:'back'};\n        } else { // black\n          // classify using d/f times\n          if(d[u] < d[v]) yield {type:'edgeClass', u, v, cls:'forward'};\n          else yield {type:'edgeClass', u, v, cls:'cross'};\n        }\n      }\n      color[u] = 'black'; time++; f[u]=time;\n      yield {type:'finish', node:u, time};\n    }\n\n    // Start at provided start; then continue with any remaining white nodes\n    if(start !== null) {\n      if(color[start] === 'white') yield* visit(start);\n    }\n    for(let u=0;u<n;u++){\n      if(color[u] === 'white') yield* visit(u);\n    }\n    yield {type:'done', d,f,time};\n  }\n\n  function* dfsIterative(start){\n    // We'll simulate an explicit stack of frames {u, iterIndex}\n    const n = nodes.length;\n    const adj = buildAdjacency();\n    const color = Array(n).fill('white');\n    const d = Array(n).fill(0), f = Array(n).fill(0);\n    let time = 0;\n    const stack = [];\n    function push(u){\n      stack.push({u, i:0});\n      color[u] = 'gray'; time++; d[u]=time;\n      return {type:'push', u, time, stack:[...stack.map(s=>s.u)]};\n    }\n    function pop(){\n      const frame = stack.pop();\n      color[frame.u] = 'black'; time++; f[frame.u]=time;\n      return {type:'pop', u:frame.u, time, stack:[...stack.map(s=>s.u)]};\n    }\n\n    if(start !== null){\n      if(color[start] === 'white'){\n        yield push(start);\n      }\n    }\n    // main loop\n    while(stack.length){\n      const top = stack[stack.length-1];\n      const u = top.u;\n      const neighbors = adj[u];\n      if(top.i < neighbors.length){\n        const v = neighbors[top.i++];\n        yield {type:'examine', u, v, stack:[...stack.map(s=>s.u)]};\n        if(color[v] === 'white'){\n          yield {type:'edgeClass', u, v, cls:'tree'};\n          yield push(v);\n        } else if(color[v] === 'gray'){\n          yield {type:'edgeClass', u, v, cls:'back'};\n        } else {\n          // black\n          if(d[u] < d[v]) yield {type:'edgeClass', u, v, cls:'forward'};\n          else yield {type:'edgeClass', u, v, cls:'cross'};\n        }\n      } else {\n        yield pop();\n      }\n    }\n\n    // continue with any remaining white nodes\n    for(let s=0;s<n;s++){\n      if(color[s] === 'white'){\n        yield push(s);\n        while(stack.length){\n          const top = stack[stack.length-1];\n          const u = top.u;\n          const neighbors = adj[u];\n          if(top.i < neighbors.length){\n            const v = neighbors[top.i++];\n            yield {type:'examine', u, v, stack:[...stack.map(s=>s.u)]};\n            if(color[v] === 'white'){\n              yield {type:'edgeClass', u, v, cls:'tree'};\n              yield push(v);\n            } else if(color[v] === 'gray'){\n              yield {type:'edgeClass', u, v, cls:'back'};\n            } else {\n              if(d[u] < d[v]) yield {type:'edgeClass', u, v, cls:'forward'};\n              else yield {type:'edgeClass', u, v, cls:'cross'};\n            }\n          } else {\n            yield pop();\n          }\n        }\n      }\n    }\n    yield {type:'done', d,f,time};\n  }\n\n  // Animation state\n  let animGen = null;\n  let automator = null;\n  let animState = {\n    colors: [], d:[], f:[], edgeClass: new Map(), stack:[]\n  };\n\n  function resetAnim(){\n    if(automator) { clearInterval(automator); automator = null; }\n    animGen = null;\n    animState = { colors: Array(nodes.length).fill('white'), d:Array(nodes.length).fill(0), f:Array(nodes.length).fill(0), edgeClass:new Map(), stack:[]};\n    updateUIFromState();\n    renderColorState();\n    edgeClassesDiv.textContent = '-';\n  }\n\n  function runDFS(startNodeIdx){\n    resetAnim();\n    const mode = modeSelect.value;\n    if(mode === 'recursive'){\n      animGen = dfsRecursive(startNodeIdx);\n    } else {\n      animGen = dfsIterative(startNodeIdx);\n    }\n    stepOnce(); // take first step\n  }\n\n  function stepOnce(){\n    if(!animGen) return;\n    const res = animGen.next();\n    if(res.done){\n      animGen = null;\n      return;\n    }\n    handleEvent(res.value);\n  }\n\n  function handleEvent(ev){\n    if(!ev) return;\n    switch(ev.type){\n      case 'discover':\n        animState.colors[ev.node] = 'gray';\n        animState.d[ev.node] = ev.time;\n        timeView.textContent = `Time: ${ev.time}`;\n        addLog(`Discover ${ev.node} (d=${ev.time})`);\n        break;\n      case 'finish':\n        animState.colors[ev.node] = 'black';\n        animState.f[ev.node] = ev.time;\n        timeView.textContent = `Time: ${ev.time}`;\n        addLog(`Finish ${ev.node} (f=${ev.time})`);\n        break;\n      case 'examine':\n        // highlight edge being examined temporarily\n        highlightEdge(ev.u, ev.v, '#ffffff', 3);\n        addLog(`Examine edge ${ev.u}→${ev.v}`);\n        break;\n      case 'edgeClass':\n        animState.edgeClass.set(`${ev.u}-${ev.v}`, ev.cls);\n        addLog(`Edge ${ev.u}→${ev.v} classified as ${ev.cls}`);\n        break;\n      case 'push':\n        animState.stack = ev.stack || [];\n        animState.colors[ev.u] = 'gray';\n        animState.d[ev.u] = ev.time;\n        timeView.textContent = `Time: ${ev.time}`;\n        addLog(`Push ${ev.u} onto stack`);\n        break;\n      case 'pop':\n        animState.stack = ev.stack || [];\n        animState.colors[ev.u] = 'black';\n        animState.f[ev.u] = ev.time;\n        timeView.textContent = `Time: ${ev.time}`;\n        addLog(`Pop ${ev.u} (finished)`);\n        break;\n      case 'done':\n        animState.d = ev.d; animState.f = ev.f;\n        addLog(`DFS complete. Time=${ev.time}`);\n        break;\n    }\n    updateUIFromState();\n    renderColorState();\n    renderEdgeClasses();\n  }\n\n  function highlightEdge(u,v,color, width=3){\n    // find matching edge element and color it briefly\n    const edgesEls = svg.querySelectorAll('g[data-edge-idx]');\n    edgesEls.forEach(g => {\n      const idx = +g.getAttribute('data-edge-idx');\n      const e = edges[idx];\n      if(!e) return;\n      if(e.u===u && e.v===v){\n        const line = g.querySelector('line');\n        if(line){\n          const prevCol = line.getAttribute('data-prev-stroke') || line.getAttribute('stroke');\n          line.setAttribute('data-prev-stroke', prevCol);\n          line.setAttribute('stroke', color);\n          line.setAttribute('stroke-width', width.toString());\n          setTimeout(()=> {\n            line.setAttribute('stroke', prevCol);\n            line.setAttribute('stroke-width', '2.2');\n          }, 400);\n        }\n      }\n    });\n  }\n\n  function renderColorState(){\n    // set node fill (white/gray/black) and show discovery/finish times\n    nodes.forEach(n => {\n      const g = svg.querySelector(`g[data-node=\"${n.id}\"]`);\n      if(!g) return;\n      const circle = g.querySelector('circle');\n      const label = g.querySelector('text.nodeLabel') || g.querySelector('text');\n      const color = animState.colors[n.id] || 'white';\n      let fill = '#ffffff';\n      if(color === 'white') fill = '#ffffff';\n      if(color === 'gray') fill = '#f59e0b';\n      if(color === 'black') fill = '#10b981';\n      circle.setAttribute('fill', fill);\n      // show d/f small labels near node\n      // remove previous small time labels\n      const old = g.querySelectorAll('text.timeLabel');\n      old.forEach(x => x.remove());\n      const d = animState.d[n.id], f=animState.f[n.id];\n      if(d) {\n        const td = document.createElementNS(NS,'text');\n        td.setAttribute('x', 0);\n        td.setAttribute('y', -n.r - 10);\n        td.setAttribute('class','timeLabel');\n        td.setAttribute('font-size','11');\n        td.setAttribute('fill','#94a3b8');\n        td.setAttribute('text-anchor','middle');\n        td.textContent = `d=${d}`;\n        g.appendChild(td);\n      }\n      if(f){\n        const tf = document.createElementNS(NS,'text');\n        tf.setAttribute('x', 0);\n        tf.setAttribute('y', n.r + 14);\n        tf.setAttribute('class','timeLabel');\n        tf.setAttribute('font-size','11');\n        tf.setAttribute('fill','#94a3b8');\n        tf.setAttribute('text-anchor','middle');\n        tf.textContent = `f=${f}`;\n        g.appendChild(tf);\n      }\n    });\n  }\n\n  function renderEdgeClasses(){\n    // color edges by classification stored in animState.edgeClass\n    const edgesEls = svg.querySelectorAll('g[data-edge-idx]');\n    edgesEls.forEach(g => {\n      const idx = +g.getAttribute('data-edge-idx');\n      const e = edges[idx];\n      if(!e) return;\n      const cls = animState.edgeClass.get(`${e.u}-${e.v}`);\n      const line = g.querySelector('line');\n      let col = '#8b95a6';\n      if(cls === 'tree') col = '#9ca3ff';\n      if(cls === 'back') col = '#ef4444';\n      if(cls === 'forward') col = '#06b6d4';\n      if(cls === 'cross') col = '#f97316';\n      if(line) line.setAttribute('stroke', col);\n    });\n    updateEdgeClassesText();\n  }\n\n  // UI updates\n  function rebuildStartSelect(){\n    startSelect.innerHTML = '';\n    for(let i=0;i<nodes.length;i++){\n      const opt = document.createElement('option');\n      opt.value = i;\n      opt.textContent = `Node ${i}`;\n      startSelect.appendChild(opt);\n    }\n  }\n  function updateInfoUI(){\n    // adjacency list\n    const n = nodes.length;\n    if(n === 0){\n      adjList.textContent = '-';\n      timesList.textContent = '-';\n      stackView.textContent = 'Stack: []';\n      timeView.textContent = 'Time: 0';\n      return;\n    }\n    const adj = buildAdjacency();\n    let s = '';\n    for(let i=0;i<n;i++){\n      s += `${i}: [${adj[i].join(', ')}]\\n`;\n    }\n    adjList.textContent = s.trim();\n    // times display\n    let t = '';\n    for(let i=0;i<n;i++){\n      t += `${i}: d=${animState.d[i] || '-'} f=${animState.f[i] || '-'}\\n`;\n    }\n    timesList.textContent = t.trim();\n  }\n  function updateUIFromState(){\n    updateInfoUI();\n    stackView.textContent = `Stack: [${animState.stack.join(', ')}]`;\n  }\n  function updateEdgeClassesText(){\n    if(animState.edgeClass.size === 0){\n      edgeClassesDiv.textContent = '-';\n      return;\n    }\n    let lines = [];\n    for(const [k,cls] of animState.edgeClass.entries()){\n      const [u,v] = k.split('-');\n      lines.push(`${u}→${v}: ${cls}`);\n    }\n    edgeClassesDiv.textContent = lines.join('\\n');\n  }\n\n  // Logging small messages (append to info area temporarily)\n  function addLog(msg){\n    // Insert into info text briefly\n    const prev = document.getElementById('info');\n    if(prev){\n      prev.textContent = msg;\n      setTimeout(()=> {\n        prev.textContent = 'Press \"Random graph\" or create nodes/edges, choose start node and press Run. Use Step/Play to watch DFS explore the graph. The panel shows discovery/finish times, current stack, adjacency list and edge classifications.';\n      }, 2000);\n    }\n  }\n\n  // Controls wiring\n  randomizeBtn.addEventListener('click', ()=>{\n    const n = Math.max(2, Math.min(20, +nodeCountInput.value || 8));\n    const dens = +densityInput.value;\n    createRandomGraph(n,dens);\n    resetAnim();\n  });\n\n  runBtn.addEventListener('click', ()=>{\n    if(nodes.length === 0) { alert(\"No nodes to run DFS on.\"); return; }\n    const start = +startSelect.value;\n    runDFS(start);\n  });\n\n  stepBtn.addEventListener('click', ()=>{\n    if(!animGen){\n      // if none, start fresh from selected start\n      if(nodes.length === 0) return;\n      const start = +startSelect.value;\n      runDFS(start);\n      return;\n    }\n    stepOnce();\n  });\n\n  playBtn.addEventListener('click', ()=>{\n    if(!animGen){\n      if(nodes.length === 0) return;\n      const start = +startSelect.value;\n      runDFS(start);\n    }\n    if(automator) return;\n    automator = setInterval(() => {\n      if(!animGen){ clearInterval(automator); automator=null; return; }\n      stepOnce();\n    }, +speedInput.value);\n  });\n\n  pauseBtn.addEventListener('click', ()=>{\n    if(automator) { clearInterval(automator); automator=null; }\n  });\n\n  resetBtn.addEventListener('click', ()=>{\n    resetAnim();\n  });\n\n  directedSelect.addEventListener('change', ()=>{\n    // rebuilding edges to keep directed flag consistent (simple approach: remove edges when toggling)\n    // Instead, when switching to directed, keep edges but mark directed true; when switching to undirected, collapse duplicates.\n    const newDirected = isDirected();\n    if(newDirected){\n      edges = edges.map(e => ({...e, directed:true}));\n    } else {\n      // collapse to single undirected edges (u<v)\n      const s = new Set();\n      const ne = [];\n      edges.forEach(e=>{\n        const a = Math.min(e.u,e.v), b=Math.max(e.u,e.v);\n        const key = `${a}-${b}`;\n        if(!s.has(key)){\n          s.add(key);\n          ne.push({u:a,v:b,directed:false});\n        }\n      });\n      edges = ne;\n    }\n    render();\n    resetAnim();\n  });\n\n  clearEdgesBtn.addEventListener('click', ()=> { clearEdges(); resetAnim(); });\n  clearNodesBtn.addEventListener('click', ()=> { removeAllNodes(); rebuildStartSelect(); resetAnim(); });\n\n  explainBtn.addEventListener('click', ()=> {\n    explainText.style.display = explainText.style.display === 'none' ? 'block' : 'none';\n  });\n\n  // Initial graph\n  createRandomGraph(8, 0.25);\n  resetAnim();\n\n  // Explanatory summary on load\n  // Provide keyboard shortcuts: space = step\n  window.addEventListener('keydown', (ev) => {\n    if(ev.code === 'Space') { ev.preventDefault(); stepBtn.click(); }\n  });\n\n  // Resize handling\n  window.addEventListener('resize', () => {\n    // nothing special since svg is responsive\n  });\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Depth-First Search (DFS)"
    }
  ],
  "topic": "Depth-First Search (DFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}