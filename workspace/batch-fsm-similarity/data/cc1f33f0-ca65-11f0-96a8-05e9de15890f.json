{
  "id": "cc1f33f0-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:56.468Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "K-Nearest Neighbors (KNN)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>K-Nearest Neighbors (KNN) Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#071126;\n      --accent:#0ea5a5;\n      --muted:#94a3b8;\n      --card:#071126;\n      --white:#e6eef8;\n    }\n    *{box-sizing:border-box;font-family:Inter,Segoe UI,Roboto,Arial,Helvetica,sans-serif}\n    body{margin:0;background:linear-gradient(180deg,#041025 0%, #07142a 100%);color:var(--white)}\n    .app{display:flex;flex-direction:column;min-height:100vh;padding:20px;gap:18px}\n    header{display:flex;align-items:center;gap:16px}\n    header h1{margin:0;font-size:18px;letter-spacing:0.3px}\n    .main{display:flex;gap:18px;align-items:flex-start}\n    .panel{background:rgba(255,255,255,0.03);padding:14px;border-radius:10px;min-width:320px;max-width:420px}\n    .canvas-wrap{flex:1;display:flex;flex-direction:column;gap:12px;align-items:center}\n    canvas{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:8px; box-shadow:0 6px 20px rgba(2,6,23,0.6)}\n    .controls{display:grid;grid-template-columns:1fr 1fr;gap:10px}\n    label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}\n    select,input[type=range],input[type=number],button{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--white)}\n    .row{display:flex;gap:8px}\n    .btn{cursor:pointer;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));color:var(--white)}\n    .small{font-size:12px;padding:6px}\n    .legend{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n    .badge{display:inline-flex;align-items:center;gap:8px;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}\n    .swatch{width:14px;height:14px;border-radius:3px;display:inline-block;border:1px solid rgba(0,0,0,0.2)}\n    .info{font-size:13px;color:var(--muted);line-height:1.35;margin-top:8px}\n    .matrix{display:grid;grid-template-columns:repeat(3,1fr);gap:6px}\n    pre{background:rgba(0,0,0,0.15);padding:10px;border-radius:8px;overflow:auto}\n    footer{font-size:12px;color:var(--muted);text-align:center;margin-top:6px}\n    @media (max-width:900px){\n      .main{flex-direction:column}\n      .panel{max-width:100%}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <header>\n      <h1>K-Nearest Neighbors (KNN) — Interactive Demo</h1>\n      <div style=\"color:var(--muted);font-size:13px\">Explore K selection, distance metrics, weighting, decision boundary and evaluation</div>\n    </header>\n\n    <div class=\"main\">\n      <div class=\"panel\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:10px\">\n          <div>\n            <div style=\"font-weight:600\">Dataset Controls</div>\n            <div style=\"font-size:13px;color:var(--muted)\">Create and edit points (click to add, drag to move).</div>\n          </div>\n          <div class=\"legend\" id=\"legend\"></div>\n        </div>\n\n        <div style=\"display:grid;gap:10px\">\n          <div>\n            <label>Mode</label>\n            <select id=\"mode\">\n              <option value=\"classify\">Classification</option>\n              <option value=\"regress\">Regression (continuous value)</option>\n            </select>\n          </div>\n\n          <div style=\"display:flex;gap:8px\">\n            <div style=\"flex:1\">\n              <label>Number of classes</label>\n              <select id=\"nclasses\">\n                <option>2</option><option>3</option><option>4</option>\n              </select>\n            </div>\n            <div style=\"flex:1\">\n              <label>Points per class</label>\n              <input id=\"pointsPerClass\" type=\"number\" min=\"1\" max=\"200\" value=\"40\">\n            </div>\n          </div>\n\n          <div style=\"display:flex;gap:8px\">\n            <div style=\"flex:1\">\n              <label>Cluster spread (std)</label>\n              <input id=\"std\" type=\"range\" min=\"0.03\" max=\"0.25\" step=\"0.01\" value=\"0.08\">\n            </div>\n            <div style=\"flex:1\">\n              <label>Seed (randomness)</label>\n              <input id=\"seed\" type=\"number\" value=\"1\" min=\"0\" step=\"1\">\n            </div>\n          </div>\n\n          <div class=\"row\">\n            <button class=\"btn\" id=\"btnGenerate\">Generate random dataset</button>\n            <button class=\"btn\" id=\"btnClear\">Clear points</button>\n          </div>\n\n          <hr style=\"border:none;border-top:1px solid rgba(255,255,255,0.03)\">\n\n          <div>\n            <label>K (neighbors)</label>\n            <input id=\"k\" type=\"range\" min=\"1\" max=\"40\" value=\"5\">\n            <div style=\"display:flex;justify-content:space-between;font-size:13px;color:var(--muted)\">\n              <span>K = <strong id=\"kVal\">5</strong></span>\n              <span><input id=\"autoK\" type=\"checkbox\"> auto (sqrt(n))</span>\n            </div>\n          </div>\n\n          <div style=\"display:flex;gap:8px\">\n            <div style=\"flex:1\">\n              <label>Distance metric</label>\n              <select id=\"dist\">\n                <option value=\"euclidean\">Euclidean (L2)</option>\n                <option value=\"manhattan\">Manhattan (L1)</option>\n                <option value=\"chebyshev\">Chebyshev (L∞)</option>\n              </select>\n            </div>\n            <div style=\"flex:1\">\n              <label>Weighting</label>\n              <select id=\"weighting\">\n                <option value=\"uniform\">Uniform</option>\n                <option value=\"distance\">Inverse distance</option>\n              </select>\n            </div>\n          </div>\n\n          <div style=\"display:flex;gap:8px\">\n            <button class=\"btn\" id=\"btnToggleBoundary\">Toggle decision boundary</button>\n            <button class=\"btn\" id=\"btnPredictMode\">Predict on click</button>\n          </div>\n\n          <div style=\"display:flex;gap:8px\">\n            <button class=\"btn small\" id=\"btnCV\">K-fold eval (5) -> accuracy</button>\n            <button class=\"btn small\" id=\"btnConf\">Show confusion matrix</button>\n            <button class=\"btn small\" id=\"btnExport\">Export dataset (JSON)</button>\n          </div>\n\n          <div class=\"info\" id=\"info\">\n            Click on the canvas to add a point. Use the \"Predict on click\" mode to classify a new point and visualize its nearest neighbors.\n          </div>\n        </div>\n      </div>\n\n      <div class=\"canvas-wrap\">\n        <div style=\"display:flex;gap:12px;align-items:center\">\n          <canvas id=\"grid\" width=\"600\" height=\"600\"></canvas>\n          <div style=\"width:220px\">\n            <div style=\"display:flex;flex-direction:column;gap:6px\">\n              <div style=\"font-weight:600\">Interactive Inspector</div>\n              <div id=\"inspector\" class=\"badge\" style=\"background:transparent;padding:6px 0;color:var(--muted)\">\n                No selected point.\n              </div>\n\n              <div style=\"font-weight:600;margin-top:8px\">Quick actions</div>\n              <div style=\"display:flex;flex-direction:column;gap:6px;margin-top:6px\">\n                <button class=\"btn small\" id=\"btnAddNoise\">Add small noise to all points</button>\n                <button class=\"btn small\" id=\"btnNormalize\">Normalize coords (0..1)</button>\n                <button class=\"btn small\" id=\"btnShuffle\">Shuffle labels (debug)</button>\n              </div>\n\n              <div style=\"margin-top:10px\">\n                <div style=\"font-weight:600\">Last prediction</div>\n                <pre id=\"lastPred\" style=\"height:120px;margin:6px 0 0 0\">No predictions yet.</pre>\n              </div>\n\n            </div>\n          </div>\n        </div>\n        <footer>Tip: drag points to reposition. Toggle decision boundary to see how changing K and weighting affects the regions.</footer>\n      </div>\n    </div>\n  </div>\n\n<script>\n/*\n  K-Nearest Neighbors (KNN) Interactive Demo\n  - Click to add points (current class selected via legend)\n  - Drag points to move\n  - Toggle \"Predict on click\" to classify a new point and highlight k nearest neighbors\n  - Toggle decision boundary to render low-res grid colored by predicted class\n  - Evaluate with k-fold cross-validation for classification mode\n*/\n\n(() => {\n  // Utilities\n  function rand(seed) { // simple seeded RNG\n    let s = seed >>> 0;\n    return function() {\n      s = (s + 0x6D2B79F5) | 0;\n      let t = Math.imul(s ^ s >>> 15, 1 | s);\n      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;\n      return ((t ^ t >>> 14) >>> 0) / 4294967296;\n    };\n  }\n\n  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}\n  function distL2(a,b){let dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy);}\n  function distL1(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y);}\n  function distLInf(a,b){return Math.max(Math.abs(a.x-b.x),Math.abs(a.y-b.y));}\n\n  // DOM\n  const canvas = document.getElementById('grid');\n  const ctx = canvas.getContext('2d');\n  const legendDiv = document.getElementById('legend');\n  const kRange = document.getElementById('k');\n  const kVal = document.getElementById('kVal');\n  const autoK = document.getElementById('autoK');\n  const btnGenerate = document.getElementById('btnGenerate');\n  const btnClear = document.getElementById('btnClear');\n  const btnToggleBoundary = document.getElementById('btnToggleBoundary');\n  const btnPredictMode = document.getElementById('btnPredictMode');\n  const btnCV = document.getElementById('btnCV');\n  const btnConf = document.getElementById('btnConf');\n  const btnExport = document.getElementById('btnExport');\n  const nclassesSelect = document.getElementById('nclasses');\n  const pointsPerClassInput = document.getElementById('pointsPerClass');\n  const stdRange = document.getElementById('std');\n  const seedInput = document.getElementById('seed');\n  const distSelect = document.getElementById('dist');\n  const weightingSelect = document.getElementById('weighting');\n  const modeSelect = document.getElementById('mode');\n  const infoDiv = document.getElementById('info');\n  const inspector = document.getElementById('inspector');\n  const lastPred = document.getElementById('lastPred');\n  const btnAddNoise = document.getElementById('btnAddNoise');\n  const btnNormalize = document.getElementById('btnNormalize');\n  const btnShuffle = document.getElementById('btnShuffle');\n\n  const width = canvas.width;\n  const height = canvas.height;\n\n  // State\n  let points = []; // {x:0..1,y:0..1,label:number,val:number}\n  let colors = []; // per class color\n  const defaultColors = ['#ef4444','#f97316','#f59e0b','#10b981','#3b82f6','#8b5cf6']; // extended\n  let selectedClass = 0;\n  let showBoundary = false;\n  let predictOnClick = false;\n  let dragging = null;\n  let hover = null;\n  let nearestNeighbors = null; // when predicting\n  let lastPrediction = null;\n  let rng = rand(1);\n\n  // Initialize UI\n  function initColors(n) {\n    colors = [];\n    for (let i=0;i<n;i++){\n      colors.push(defaultColors[i%defaultColors.length]);\n    }\n  }\n\n  function updateLegend() {\n    legendDiv.innerHTML = '';\n    let n = parseInt(nclassesSelect.value,10);\n    for (let i=0;i<n;i++){\n      const b = document.createElement('div');\n      b.className = 'badge';\n      b.style.cursor = 'pointer';\n      b.onclick = () => { selectedClass = i; updateLegend(); };\n      b.innerHTML = `<span class=\"swatch\" style=\"background:${colors[i]}\"></span> Class ${i}` + (selectedClass===i ? ' ✓' : '');\n      legendDiv.appendChild(b);\n    }\n  }\n\n  function datasetSize(){ return points.length; }\n\n  // Coordinate transforms: data [0,1] -> canvas pixels (with margin)\n  const margin = 20;\n  function toCanvas(pt){ return {cx: margin + pt.x * (width - 2*margin), cy: margin + (1-pt.y) * (height - 2*margin)}; }\n  function toData(cx,cy){ return {x: clamp((cx - margin) / (width - 2*margin), 0, 1), y: clamp(1 - (cy - margin) / (height - 2*margin), 0, 1)}; }\n\n  // Drawing\n  function draw() {\n    // clear\n    ctx.clearRect(0,0,width,height);\n\n    // boundary background if enabled: compute low-res grid\n    if (showBoundary && points.length>0) {\n      renderDecisionBoundary();\n    } else {\n      // draw subtle grid background\n      ctx.fillStyle = 'rgba(255,255,255,0.01)';\n      ctx.fillRect(0,0,width,height);\n    }\n\n    // axes box\n    ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n    ctx.lineWidth = 1;\n    roundRect(ctx, margin-1, margin-1, width-2*margin+2, height-2*margin+2, 6, false, true);\n\n    // draw points\n    for (let i=0;i<points.length;i++){\n      const p = points[i];\n      const c = toCanvas(p);\n      ctx.beginPath();\n      ctx.fillStyle = colors[p.label%colors.length] || '#fff';\n      ctx.strokeStyle = '#081024';\n      ctx.lineWidth = 1;\n      ctx.arc(c.cx, c.cy, 6, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n\n      // if regression show value as label\n      if (modeSelect.value === 'regress' && typeof p.val === 'number') {\n        ctx.fillStyle = 'rgba(255,255,255,0.9)';\n        ctx.font = '11px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(p.val.toFixed(2), c.cx, c.cy);\n      }\n    }\n\n    // draw selected neighbors highlight\n    if (nearestNeighbors && nearestNeighbors.length>0){\n      for (let i=0;i<nearestNeighbors.length;i++){\n        const item = nearestNeighbors[i];\n        const p = item.point;\n        const c = toCanvas(p);\n        ctx.beginPath();\n        ctx.strokeStyle = 'rgba(255,255,255,0.9)';\n        ctx.lineWidth = 2 + (1 - i/nearestNeighbors.length)*3;\n        ctx.arc(c.cx, c.cy, 10 + (1 - i/nearestNeighbors.length)*6, 0, Math.PI*2);\n        ctx.stroke();\n      }\n    }\n\n    // hover point highlight\n    if (hover && hover.idx != null) {\n      const p = points[hover.idx];\n      const c = toCanvas(p);\n      ctx.beginPath();\n      ctx.strokeStyle = 'rgba(255,255,255,0.6)';\n      ctx.lineWidth = 2;\n      ctx.arc(c.cx, c.cy, 9, 0, Math.PI*2);\n      ctx.stroke();\n    }\n\n    // if dragging some point, draw coordinates\n    if (dragging && dragging.idx!=null) {\n      const p = points[dragging.idx];\n      inspector.innerHTML = `Dragging point #${dragging.idx}<br>label: ${p.label} ${modeSelect.value==='regress'?('<br>value: '+(p.val||0).toFixed(2)) : ''}<br>x:${p.x.toFixed(2)} y:${p.y.toFixed(2)}`;\n    } else if (lastPrediction) {\n      const lp = lastPrediction;\n      if (modeSelect.value==='classify') {\n        inspector.innerHTML = `Predicted: <strong style=\"color:${colors[lp.label]}\">${lp.label}</strong><br>` +\n                              `Class probs: ${Object.entries(lp.probs).map(([k,v])=>`${k}:${(v*100).toFixed(1)}%`).join(' ')}<br>` +\n                              `K=${lp.k}, dist=${distSelect.value}, weight=${weightingSelect.value}`;\n      } else {\n        inspector.innerHTML = `Predicted value: <strong>${lp.value.toFixed(3)}</strong><br>K=${lp.k} weighting=${weightingSelect.value}`;\n      }\n    } else {\n      inspector.innerHTML = `No selected point.<br>Total points: ${points.length}`;\n    }\n  }\n\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (typeof r === 'undefined') r = 5;\n    if (typeof r === 'number') r = {tl:r,tr:r,br:r,bl:r};\n    ctx.beginPath();\n    ctx.moveTo(x + r.tl, y);\n    ctx.lineTo(x + w - r.tr, y);\n    ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);\n    ctx.lineTo(x + w, y + h - r.br);\n    ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);\n    ctx.lineTo(x + r.bl, y + h);\n    ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);\n    ctx.lineTo(x, y + r.tl);\n    ctx.quadraticCurveTo(x, y, x + r.tl, y);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // Decision boundary: draw low-res grid of predictions\n  function renderDecisionBoundary() {\n    // create small offscreen grid for speed\n    const res = 80; // grid resolution (80x80)\n    const img = ctx.createImageData(res, res);\n    const dataArr = img.data;\n    // For regression we map predicted value to color scale\n    let minVal = Infinity, maxVal = -Infinity;\n    let gridPred = new Array(res*res);\n    for (let gy=0; gy<res; gy++){\n      for (let gx=0; gx<res; gx++){\n        const x = gx / (res - 1);\n        const y = 1 - gy / (res - 1);\n        const pred = knnPredict({x,y}, parseK(), true);\n        gridPred[gy*res+gx] = pred;\n        if (modeSelect.value === 'regress') {\n          minVal = Math.min(minVal, pred.value);\n          maxVal = Math.max(maxVal, pred.value);\n        }\n      }\n    }\n    // paint pixels\n    for (let gy=0; gy<res; gy++){\n      for (let gx=0; gx<res; gx++){\n        const idx = (gy*res+gx)*4;\n        const pred = gridPred[gy*res+gx];\n        if (modeSelect.value === 'classify') {\n          const label = pred.label;\n          const hex = colors[label%colors.length] || '#ffffff';\n          const c = hexToRgb(hex);\n          // apply alpha to keep points visible\n          dataArr[idx] = c.r;\n          dataArr[idx+1] = c.g;\n          dataArr[idx+2] = c.b;\n          dataArr[idx+3] = 32; // low alpha\n        } else {\n          // regression: map value to blue->red gradient\n          const v = (pred.value - minVal) / Math.max(1e-9, maxVal - minVal);\n          const c = lerpColor({r:59,g:130,b:246}, {r:239,g:68,b:68}, v);\n          dataArr[idx] = c.r;\n          dataArr[idx+1] = c.g;\n          dataArr[idx+2] = c.b;\n          dataArr[idx+3] = 36;\n        }\n      }\n    }\n    // draw image scaled to plotting area (inside margins)\n    const tempCanvas = document.createElement('canvas');\n    tempCanvas.width = res; tempCanvas.height = res;\n    const tctx = tempCanvas.getContext('2d');\n    tctx.putImageData(img,0,0);\n    ctx.drawImage(tempCanvas, margin, margin, width - 2*margin, height - 2*margin);\n  }\n\n  // KNN core\n  function parseK(){\n    let k = parseInt(kRange.value,10);\n    if (autoK.checked) {\n      const n = points.length;\n      k = Math.max(1, Math.round(Math.sqrt(Math.max(1,n))));\n      kRange.value = Math.min(kRange.max, Math.max(kRange.min,k));\n      kVal.textContent = kRange.value;\n    }\n    return Math.max(1, Math.min(points.length || 1, k));\n  }\n\n  function distanceFn() {\n    const d = distSelect.value;\n    if (d==='euclidean') return distL2;\n    if (d==='manhattan') return distL1;\n    if (d==='chebyshev') return distLInf;\n    return distL2;\n  }\n\n  function knnPredict(queryPoint, kOverride=null, returnNeighbors=false) {\n    if (points.length===0) return null;\n    const k = kOverride || parseK();\n    const distf = distanceFn();\n    const arr = points.map((p,idx)=>({point:p,idx, d: distf(p, queryPoint)}));\n    arr.sort((a,b)=>a.d-b.d);\n    const neighbors = arr.slice(0,Math.min(k, arr.length));\n    if (modeSelect.value === 'classify') {\n      const probs = {};\n      for (let i=0;i<neighbors.length;i++){\n        const nb = neighbors[i];\n        const lab = nb.point.label;\n        let w = 1;\n        if (weightingSelect.value === 'distance') {\n          w = 1 / (nb.d + 1e-6);\n        }\n        probs[lab] = (probs[lab] || 0) + w;\n      }\n      // normalize\n      const total = Object.values(probs).reduce((a,b)=>a+b,0);\n      for (let k2 in probs) probs[k2] = probs[k2] / (total || 1);\n      // choose best (tie-break by smallest avg distance to class among neighbors)\n      const bestLabel = Object.keys(probs).reduce((acc,l)=> probs[l] > (probs[acc]||0) ? l : acc);\n      const result = {label: parseInt(bestLabel,10), probs, k};\n      if (returnNeighbors) result.neighbors = neighbors;\n      if (returnNeighbors) {\n        // attach neighbors in order\n        result.neighbors = neighbors;\n      }\n      return result;\n    } else {\n      // regression: each point must have p.val numeric\n      let num = 0; let den = 0;\n      for (let i=0;i<neighbors.length;i++){\n        const nb = neighbors[i];\n        const v = (typeof nb.point.val === 'number') ? nb.point.val : 0;\n        let w = 1;\n        if (weightingSelect.value === 'distance') w = 1 / (nb.d + 1e-6);\n        num += v * w;\n        den += w;\n      }\n      const val = num / Math.max(1e-9,den);\n      const result = {value: val, k};\n      if (returnNeighbors) result.neighbors = neighbors;\n      return result;\n    }\n  }\n\n  // Helpers\n  function hexToRgb(hex) {\n    const m = hex.replace('#','');\n    const bigint = parseInt(m,16);\n    if (m.length===3) {\n      const r = parseInt(m[0]+m[0],16);\n      const g = parseInt(m[1]+m[1],16);\n      const b = parseInt(m[2]+m[2],16);\n      return {r,g,b};\n    } else {\n      return {r:(bigint>>16)&255,g:(bigint>>8)&255,b:bigint&255};\n    }\n  }\n  function lerpColor(a,b,t){\n    return {r: Math.round(a.r + (b.r-a.r)*t), g: Math.round(a.g + (b.g-a.g)*t), b: Math.round(a.b + (b.b-a.b)*t)};\n  }\n\n  // Generate dataset\n  function generateClusters() {\n    const nclasses = parseInt(nclassesSelect.value,10);\n    const per = Math.max(1, parseInt(pointsPerClassInput.value,10));\n    const std = parseFloat(stdRange.value);\n    const seed = parseInt(seedInput.value,10) || 0;\n    rng = rand(seed);\n    initColors(nclasses);\n    points = [];\n    // pick cluster centers evenly spaced\n    for (let c=0;c<nclasses;c++){\n      const angle = (c / nclasses) * Math.PI*2;\n      // centers on a ring inside [0.15,0.85]\n      const cx = 0.5 + 0.28 * Math.cos(angle) + (rng()-0.5)*0.07;\n      const cy = 0.5 + 0.28 * Math.sin(angle) + (rng()-0.5)*0.07;\n      for (let i=0;i<per;i++){\n        const x = clamp(cx + gaussian()*std, 0, 1);\n        const y = clamp(cy + gaussian()*std, 0, 1);\n        const p = {x,y,label:c};\n        if (modeSelect.value === 'regress') {\n          // for regression set continuous val based on position or cluster id\n          p.val = (c / Math.max(1,nclasses-1)) + (rng()-0.5)*0.15;\n        }\n        points.push(p);\n      }\n    }\n    updateLegend();\n    draw();\n  }\n\n  // Simple gaussian via Box-Muller\n  function gaussian(){\n    let u = 0, v = 0;\n    while(u===0) u = rng();\n    while(v===0) v = rng();\n    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n  }\n\n  // Canvas interactions\n  function getPointAtCanvas(cx,cy){\n    for (let i=points.length-1;i>=0;i--){\n      const p = points[i];\n      const c = toCanvas(p);\n      const d = Math.hypot(cx - c.cx, cy - c.cy);\n      if (d <= 8) return i;\n    }\n    return null;\n  }\n\n  canvas.addEventListener('mousedown', (ev)=>{\n    const r = canvas.getBoundingClientRect();\n    const cx = ev.clientX - r.left;\n    const cy = ev.clientY - r.top;\n    const idx = getPointAtCanvas(cx,cy);\n    if (idx!=null) {\n      dragging = {idx, offsetX: cx - toCanvas(points[idx]).cx, offsetY: cy - toCanvas(points[idx]).cy};\n    } else {\n      // if predictOnClick mode active: predict and show neighbors\n      const d = toData(cx,cy);\n      if (predictOnClick) {\n        const pred = knnPredict(d, null, true);\n        nearestNeighbors = pred.neighbors;\n        lastPrediction = pred;\n        lastPred.textContent = JSON.stringify(pred, null, 2);\n        draw();\n      } else {\n        // otherwise add a new point with selectedClass\n        const p = {x:d.x,y:d.y,label:selectedClass};\n        if (modeSelect.value === 'regress') p.val = (selectedClass/(parseInt(nclassesSelect.value)-1 || 1)) + (Math.random()-0.5)*0.1;\n        points.push(p);\n        draw();\n      }\n    }\n  });\n\n  window.addEventListener('mousemove', (ev)=>{\n    const r = canvas.getBoundingClientRect();\n    const cx = ev.clientX - r.left;\n    const cy = ev.clientY - r.top;\n    if (dragging) {\n      const nx = cx - dragging.offsetX;\n      const ny = cy - dragging.offsetY;\n      const d = toData(nx,ny);\n      const p = points[dragging.idx];\n      p.x = clamp(d.x,0,1);\n      p.y = clamp(d.y,0,1);\n      nearestNeighbors = null;\n      lastPrediction = null;\n      draw();\n    } else {\n      const idx = getPointAtCanvas(cx,cy);\n      if (idx!=null) {\n        hover = {idx};\n      } else hover = null;\n      draw();\n    }\n  });\n\n  window.addEventListener('mouseup', ()=>{\n    if (dragging) {\n      dragging = null;\n    }\n    draw();\n  });\n\n  // Buttons\n  btnGenerate.addEventListener('click', ()=>{ generateClusters(); lastPrediction = null; nearestNeighbors = null; lastPred.textContent = 'No predictions yet.'; });\n  btnClear.addEventListener('click', ()=>{ points = []; lastPrediction=null; nearestNeighbors=null; lastPred.textContent = 'No predictions yet.'; draw(); });\n  btnToggleBoundary.addEventListener('click', ()=>{ showBoundary = !showBoundary; btnToggleBoundary.textContent = (showBoundary ? 'Hide decision boundary' : 'Toggle decision boundary'); draw(); });\n  btnPredictMode.addEventListener('click', ()=>{ predictOnClick = !predictOnClick; btnPredictMode.textContent = (predictOnClick ? 'Predict mode: ON' : 'Predict on click'); });\n  kRange.addEventListener('input', ()=>{ kVal.textContent = kRange.value; lastPrediction=null; draw(); });\n  autoK.addEventListener('change', ()=>{ parseK(); draw(); });\n  distSelect.addEventListener('change', ()=>{ lastPrediction=null; draw(); });\n  weightingSelect.addEventListener('change', ()=>{ lastPrediction=null; draw(); });\n  nclassesSelect.addEventListener('change', ()=>{ initColors(parseInt(nclassesSelect.value,10)); updateLegend(); draw(); });\n  modeSelect.addEventListener('change', ()=>{ // regenerate values for regression/class\n    if (modeSelect.value === 'regress') {\n      // ensure points have val\n      for (let p of points) { if (typeof p.val !== 'number') p.val = p.label / Math.max(1, parseInt(nclassesSelect.value)-1); }\n    } else {\n      // classification: ensure labels integer\n      for (let p of points) { p.label = p.label || 0; }\n    }\n    draw();\n  });\n\n  btnCV.addEventListener('click', ()=>{\n    if (modeSelect.value !== 'classify') {\n      alert('Cross-validation accuracy is only implemented for classification mode in this demo.');\n      return;\n    }\n    if (points.length < 5) { alert('Too few points to evaluate.'); return; }\n    const folds = 5;\n    // shuffle indices\n    const idxs = [...Array(points.length).keys()];\n    shuffleArray(idxs);\n    const foldSize = Math.ceil(points.length / folds);\n    const accs = [];\n    const n = parseInt(nclassesSelect.value,10);\n    for (let f=0; f<folds; f++){\n      const testIdx = idxs.slice(f*foldSize, (f+1)*foldSize);\n      const trainIdx = idxs.filter(i=>!testIdx.includes(i));\n      const train = trainIdx.map(i=>points[i]);\n      const test = testIdx.map(i=>points[i]);\n      if (train.length===0 || test.length===0) continue;\n      // temporarily replace points with train for prediction\n      const oldPoints = points;\n      points = train;\n      let correct = 0;\n      for (let t of test) {\n        const pred = knnPredict({x:t.x,y:t.y}, parseK());\n        if (pred && pred.label === t.label) correct++;\n      }\n      const acc = correct / test.length;\n      accs.push(acc);\n      points = oldPoints;\n    }\n    const mean = accs.reduce((a,b)=>a+b,0)/accs.length;\n    alert(`K-fold (${folds}) accuracy: ${(mean*100).toFixed(2)}%`);\n  });\n\n  btnConf.addEventListener('click', ()=>{\n    if (modeSelect.value !== 'classify') { alert('Confusion matrix is only for classification mode.'); return; }\n    if (points.length < 5) { alert('Too few points to evaluate.'); return; }\n    // simple leave-one-out confusion matrix\n    const nlabels = parseInt(nclassesSelect.value,10);\n    const mat = Array.from({length:nlabels}, ()=>Array(nlabels).fill(0));\n    for (let i=0;i<points.length;i++){\n      const hold = points.splice(i,1)[0];\n      const pred = knnPredict({x:hold.x,y:hold.y}, parseK());\n      if (pred) mat[hold.label][pred.label] += 1;\n      points.splice(i,0,hold);\n    }\n    // show matrix\n    let txt = 'Confusion matrix (rows: true, cols: predicted)\\n';\n    txt += mat.map(row=>row.join('\\t')).join('\\n');\n    alert(txt);\n  });\n\n  btnExport.addEventListener('click', ()=>{\n    const data = JSON.stringify(points, null, 2);\n    // show in a new window\n    const w = window.open('', '_blank');\n    w.document.write('<pre>'+data.replace(/</g,'&lt;')+'</pre>');\n  });\n\n  btnAddNoise.addEventListener('click', ()=>{\n    for (let p of points) {\n      p.x = clamp(p.x + (Math.random()-0.5)*0.02, 0, 1);\n      p.y = clamp(p.y + (Math.random()-0.5)*0.02, 0, 1);\n    }\n    draw();\n  });\n\n  btnNormalize.addEventListener('click', ()=>{\n    // normalize to current min/max\n    if (points.length===0) return;\n    const minx = Math.min(...points.map(p=>p.x));\n    const maxx = Math.max(...points.map(p=>p.x));\n    const miny = Math.min(...points.map(p=>p.y));\n    const maxy = Math.max(...points.map(p=>p.y));\n    for (let p of points) {\n      p.x = (p.x - minx) / (maxx - minx || 1);\n      p.y = (p.y - miny) / (maxy - miny || 1);\n    }\n    draw();\n  });\n\n  btnShuffle.addEventListener('click', ()=>{\n    // randomly shuffle labels\n    const nclasses = parseInt(nclassesSelect.value,10);\n    for (let p of points) p.label = Math.floor(Math.random()*nclasses);\n    draw();\n  });\n\n  // helpers\n  function shuffleArray(arr) {\n    for (let i=arr.length-1;i>0;i--){\n      const j = Math.floor(Math.random()*(i+1));\n      [arr[i],arr[j]] = [arr[j],arr[i]];\n    }\n  }\n\n  // initial\n  initColors(parseInt(nclassesSelect.value,10));\n  updateLegend();\n  draw();\n\n  // keyboard shortcuts for convenience\n  window.addEventListener('keydown',(e)=>{\n    if (e.key === 'b') { showBoundary = !showBoundary; btnToggleBoundary.textContent = (showBoundary ? 'Hide decision boundary' : 'Toggle decision boundary'); draw(); }\n    if (e.key === 'p') { predictOnClick = !predictOnClick; btnPredictMode.textContent = (predictOnClick ? 'Predict mode: ON' : 'Predict on click'); }\n  });\n\n  // Expose some functions for interactive layering (not strictly necessary)\n  window.demo = {points, draw, knnPredict};\n\n  // Provide initial data\n  generateClusters();\n\n  // Keep k label updated\n  kVal.textContent = kRange.value;\n\n  // Finish: small explanation for user\n  infoDiv.innerHTML = `\n    Click on the canvas to add points. Select a class on the legend to add points of that class.\n    Toggle \"Predict on click\" to classify a new point: when you click it will show its k nearest neighbors,\n    and the predicted class (or value for regression). Toggle the decision boundary to see regions where the model predicts each class.\n  `;\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Nearest Neighbors (KNN)"
    }
  ],
  "topic": "K-Nearest Neighbors (KNN)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}