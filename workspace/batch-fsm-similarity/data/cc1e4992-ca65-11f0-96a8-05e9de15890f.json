{
  "id": "cc1e4992-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:56.405Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Bellman-Ford Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Bellman-Ford Algorithm Visualization</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<style>\n  :root{\n    --bg:#0f1724;\n    --panel:#0b1220;\n    --accent:#06b6d4;\n    --muted:#94a3b8;\n    --card:#071021;\n    --success:#16a34a;\n    --danger:#dc2626;\n    --yellow:#f59e0b;\n  }\n  *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n  body{margin:0;min-height:100vh;background:linear-gradient(180deg,#071021 0%, #071a2a 100%);color:#e6eef6}\n  header{padding:16px 20px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;gap:12px}\n  header h1{font-size:18px;margin:0;color:var(--accent)}\n  .container{display:flex;gap:12px;padding:12px;height:calc(100vh - 72px)}\n  .left{flex:1;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:8px;padding:12px;position:relative;overflow:hidden}\n  #svgCanvas{width:100%;height:100%;border-radius:6px;background:\n    repeating-linear-gradient(45deg, rgba(255,255,255,0.01) 0 1px, transparent 1px 24px);}\n  .right{width:360px;display:flex;flex-direction:column;gap:12px}\n  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);overflow:auto}\n  label{display:block;color:var(--muted);font-size:12px;margin-bottom:6px}\n  input[type=\"number\"], select, input[type=\"text\"]{width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:inherit}\n  button{padding:8px 10px;border-radius:6px;border:0;background:var(--accent);color:#06202a;cursor:pointer}\n  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}\n  .row{display:flex;gap:8px}\n  .small{padding:6px 8px;font-size:13px}\n  .nodes-list, .edges-list{max-height:140px;overflow:auto;padding:6px;border-radius:6px;background:rgba(0,0,0,0.2);border:1px dashed rgba(255,255,255,0.02)}\n  .node-item, .edge-item{display:flex;justify-content:space-between;align-items:center;padding:6px;border-bottom:1px dashed rgba(255,255,255,0.02);font-size:13px}\n  .controls{display:flex;gap:8px;flex-wrap:wrap}\n  .log{max-height:220px;overflow:auto;background:rgba(0,0,0,0.25);padding:8px;border-radius:6px;font-size:13px}\n  .log p{margin:6px 0}\n  .node-circle{cursor:pointer;stroke:#0b1220;stroke-width:2px}\n  .edge-line{stroke:#94a3b8;stroke-width:2px;opacity:0.9}\n  .edge-label{font-size:12px;fill:#e6eef6;pointer-events:none}\n  .distance{font-size:12px;fill:#e6eef6;pointer-events:none}\n  .node-label{font-size:12px;fill:#e6eef6;pointer-events:none}\n  .badge{padding:4px 8px;border-radius:999px;background:rgba(0,0,0,0.3);font-size:12px}\n  footer{padding:12px;text-align:center;color:var(--muted);font-size:13px}\n  .status{padding:8px;border-radius:6px;background:rgba(255,255,255,0.02);font-size:13px}\n  .highlight-success{stroke:var(--success) !important;stroke-width:3px}\n  .highlight-fail{stroke:rgba(255,255,255,0.06) !important}\n  .highlight-active{stroke:var(--yellow) !important;stroke-width:3px;opacity:1}\n  .neg-cycle{stroke:var(--danger) !important;stroke-width:3px;opacity:1}\n  .node-updated{fill:var(--success) !important}\n  .muted-text{color:var(--muted)}\n  .help{font-size:13px;color:var(--muted);margin-top:6px}\n  .small-muted{font-size:12px;color:var(--muted)}\n  .edge-controls{display:flex;gap:8px;align-items:center}\n</style>\n</head>\n<body>\n<header>\n  <h1>Bellman-Ford Algorithm Visualization</h1>\n  <div class=\"small-muted\">Directed weighted graphs • negative edges allowed • step-by-step + detect negative cycles</div>\n</header>\n\n<div class=\"container\">\n  <div class=\"left card\">\n    <svg id=\"svgCanvas\" xmlns=\"http://www.w3.org/2000/svg\">\n      <defs>\n        <marker id=\"arrow\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\" markerWidth=\"7\" markerHeight=\"7\" orient=\"auto\">\n          <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#94a3b8\"/>\n        </marker>\n        <marker id=\"arrow-active\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\" markerWidth=\"8\" markerHeight=\"8\" orient=\"auto\">\n          <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"var(--yellow)\"/>\n        </marker>\n        <marker id=\"arrow-success\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\" markerWidth=\"8\" markerHeight=\"8\" orient=\"auto\">\n          <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"var(--success)\"/>\n        </marker>\n        <marker id=\"arrow-danger\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\" markerWidth=\"8\" markerHeight=\"8\" orient=\"auto\">\n          <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"var(--danger)\"/>\n        </marker>\n      </defs>\n    </svg>\n    <div style=\"position:absolute;right:14px;bottom:14px;background:rgba(0,0,0,0.25);padding:8px;border-radius:6px;font-size:13px\">\n      Click nodes to select (for edge creation). Drag nodes to reposition.\n    </div>\n  </div>\n\n  <div class=\"right\">\n    <div class=\"card\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center\">\n        <div>\n          <strong>Graph Controls</strong>\n          <div class=\"small-muted\" style=\"margin-top:6px\">Create nodes/edges or generate a random graph.</div>\n        </div>\n        <div class=\"badge\">Bellman-Ford</div>\n      </div>\n      <hr style=\"border:none;border-top:1px solid rgba(255,255,255,0.02);margin:8px 0\">\n      <div class=\"row\" style=\"margin-bottom:6px\">\n        <button id=\"addNodeBtn\" class=\"small\">Add Node</button>\n        <button id=\"addEdgeModeBtn\" class=\"small secondary\">Add Edge</button>\n        <button id=\"removeSelectedBtn\" class=\"small secondary\">Remove Selected</button>\n      </div>\n\n      <label>Random graph</label>\n      <div class=\"row\" style=\"margin-bottom:8px\">\n        <input id=\"rndN\" type=\"number\" min=\"2\" max=\"20\" value=\"6\" style=\"width:72px\">\n        <input id=\"rndP\" type=\"number\" min=\"0\" max=\"1\" step=\"0.1\" value=\"0.4\" style=\"width:72px\">\n        <input id=\"rndRange\" type=\"text\" value=\"-5..10\" style=\"width:100px\">\n        <button id=\"rndGen\" class=\"small\">Generate</button>\n      </div>\n      <div class=\"help\">Weight range format: min..max (e.g. -5..10). p=probability of directed edge between ordered pair.</div>\n    </div>\n\n    <div class=\"card\">\n      <strong>Graph Items</strong>\n      <div style=\"margin-top:8px\">\n        <label>Nodes</label>\n        <div id=\"nodesList\" class=\"nodes-list\"></div>\n      </div>\n      <div style=\"margin-top:8px\">\n        <label>Edges</label>\n        <div id=\"edgesList\" class=\"edges-list\"></div>\n      </div>\n    </div>\n\n    <div class=\"card\">\n      <strong>Algorithm Controls</strong>\n      <div style=\"margin-top:8px\">\n        <label>Source node</label>\n        <select id=\"sourceSelect\"></select>\n      </div>\n\n      <div style=\"margin-top:8px;display:flex;gap:8px;flex-wrap:wrap\">\n        <button id=\"startBtn\">Start (Auto)</button>\n        <button id=\"stepBtn\" class=\"secondary\">Step</button>\n        <button id=\"pauseBtn\" class=\"secondary\" disabled>Pause</button>\n        <button id=\"resetBtn\" class=\"secondary\">Reset</button>\n      </div>\n\n      <div style=\"margin-top:8px;display:flex;gap:8px;align-items:center\">\n        <label style=\"margin:0\">Speed</label>\n        <input id=\"speedRange\" type=\"range\" min=\"100\" max=\"2000\" value=\"700\" style=\"flex:1\">\n        <div class=\"small-muted\" id=\"speedVal\">700ms</div>\n      </div>\n\n      <div style=\"margin-top:8px\">\n        <button id=\"detectNegBtn\" class=\"small\">Detect Negative Cycle</button>\n        <div class=\"small-muted help\">After running the algorithm, this will perform an extra pass to identify negative cycles reachable from the source.</div>\n      </div>\n    </div>\n\n    <div class=\"card\">\n      <strong>Status & Log</strong>\n      <div class=\"status\" id=\"statusText\">Idle. Add nodes and edges, pick a source, then Start or Step.</div>\n      <div style=\"margin-top:8px\" class=\"log\" id=\"logArea\"></div>\n    </div>\n\n  </div>\n</div>\n\n<footer>Interactive demo — Drag nodes, create edges, run Bellman-Ford. This is a client-side visualization.</footer>\n\n<script>\n(function(){\n  /* Data structures */\n  let nodes = []; // {id,label,x,y,svgGroup,...}\n  let edges = []; // {id, u, v, w, svgLine, svgLabel}\n  let nextNodeId = 0;\n  let nextEdgeId = 0;\n  const svg = document.getElementById('svgCanvas');\n  const nodesListDiv = document.getElementById('nodesList');\n  const edgesListDiv = document.getElementById('edgesList');\n  const sourceSelect = document.getElementById('sourceSelect');\n  const logArea = document.getElementById('logArea');\n  const statusText = document.getElementById('statusText');\n  const speedRange = document.getElementById('speedRange');\n  const speedVal = document.getElementById('speedVal');\n\n  speedRange.addEventListener('input', ()=> speedVal.textContent = speedRange.value + 'ms');\n\n  /* Algorithm state */\n  let dist = {};\n  let prev = {};\n  let algoRunning = false;\n  let stepMode = false;\n  let autoTimer = null;\n  let currIter = 1;\n  let currEdgeIndex = 0; // index in edges order for the current iteration\n  let sourceNode = null;\n  let selectedNode = null;\n  let addEdgeMode = false;\n  let edgeTmpFrom = null;\n\n  // SVG sizes\n  function viewSize(){ return {w: svg.clientWidth, h: svg.clientHeight}; }\n\n  /* Utility */\n  function log(msg, type='info'){\n    const p = document.createElement('p');\n    p.style.margin = '6px 0';\n    if(type==='info'){ p.style.color = '#cfeff6'; }\n    else if(type==='success'){ p.style.color = 'lightgreen'; }\n    else if(type==='danger'){ p.style.color = 'salmon' }\n    p.textContent = msg;\n    logArea.appendChild(p);\n    logArea.scrollTop = logArea.scrollHeight;\n  }\n\n  function setStatus(s){ statusText.textContent = s; }\n\n  /* Node / Edge creation and rendering */\n  function createNode(x,y,label){\n    const id = nextNodeId++;\n    const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n    g.setAttribute('data-id', id);\n    g.style.cursor = 'pointer';\n\n    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n    circle.setAttribute('r', 26);\n    circle.setAttribute('cx', x);\n    circle.setAttribute('cy', y);\n    circle.setAttribute('fill', '#021423');\n    circle.classList.add('node-circle');\n    circle.style.transition = 'fill .2s';\n\n    const labelText = document.createElementNS('http://www.w3.org/2000/svg','text');\n    labelText.setAttribute('x', x);\n    labelText.setAttribute('y', y-4);\n    labelText.setAttribute('text-anchor','middle');\n    labelText.classList.add('node-label');\n    labelText.textContent = label;\n\n    const distText = document.createElementNS('http://www.w3.org/2000/svg','text');\n    distText.setAttribute('x', x);\n    distText.setAttribute('y', y+14);\n    distText.setAttribute('text-anchor','middle');\n    distText.classList.add('distance');\n    distText.textContent = '∞';\n\n    g.appendChild(circle);\n    g.appendChild(labelText);\n    g.appendChild(distText);\n    svg.appendChild(g);\n\n    const node = {id, label, x, y, g, circle, labelText, distText};\n    nodes.push(node);\n    makeDraggable(node);\n    updateLists();\n    return node;\n  }\n\n  function removeNode(nodeId){\n    // remove edges adjacent\n    const remEdges = edges.filter(e => e.u===nodeId || e.v===nodeId).map(e=>e.id);\n    remEdges.forEach(removeEdgeById);\n    const ni = nodes.findIndex(n=>n.id===nodeId);\n    if(ni>=0){\n      svg.removeChild(nodes[ni].g);\n      nodes.splice(ni,1);\n    }\n    updateLists();\n  }\n\n  function createEdge(uId,vId,w){\n    if(uId===vId) { log('Self-loops are allowed, but often not useful', 'info'); }\n    const id = nextEdgeId++;\n    const uNode = getNode(uId), vNode = getNode(vId);\n    const line = document.createElementNS('http://www.w3.org/2000/svg','path');\n    line.setAttribute('fill','none');\n    line.setAttribute('marker-end','url(#arrow)');\n    line.classList.add('edge-line');\n    line.style.transition = 'stroke .25s, stroke-width .25s, opacity .2s';\n\n    const label = document.createElementNS('http://www.w3.org/2000/svg','text');\n    label.classList.add('edge-label');\n    label.textContent = w;\n\n    svg.insertBefore(line, svg.firstChild); // behind nodes\n    svg.appendChild(label);\n\n    const edge = {id, u:uId, v:vId, w: Number(w), line, label, marker:'arrow'};\n    edges.push(edge);\n    updateEdgePosition(edge);\n    updateLists();\n    return edge;\n  }\n\n  function removeEdgeById(edgeId){\n    const ei = edges.findIndex(e=>e.id===edgeId);\n    if(ei>=0){\n      svg.removeChild(edges[ei].line);\n      svg.removeChild(edges[ei].label);\n      edges.splice(ei,1);\n    }\n    updateLists();\n  }\n\n  function getNode(id){ return nodes.find(n=>n.id===id); }\n  function getEdge(id){ return edges.find(e=>e.id===id); }\n\n  function updateEdgePosition(edge){\n    const u = getNode(edge.u), v = getNode(edge.v);\n    if(!u || !v) return;\n    const dx = v.x - u.x, dy = v.y - u.y;\n    const distn = Math.sqrt(dx*dx+dy*dy);\n    // shorten line ends to not overlap circles (radius 26)\n    const r = 26;\n    const ux = u.x + (dx/distn)*r;\n    const uy = u.y + (dy/distn)*r;\n    const vx = v.x - (dx/distn)*r;\n    const vy = v.y - (dy/distn)*r;\n    // create a slight curve\n    const mx = (ux+vx)/2 + (-dy/distn)*20;\n    const my = (uy+vy)/2 + (dx/distn)*12;\n    const d = `M ${ux} ${uy} Q ${mx} ${my} ${vx} ${vy}`;\n    edge.line.setAttribute('d', d);\n    // place label near mid of curve\n    edge.label.setAttribute('x', mx);\n    edge.label.setAttribute('y', my-6);\n    edge.label.textContent = edge.w;\n    // choose correct marker depending on edge.line stroke color classes\n    updateEdgeMarker(edge);\n  }\n\n  function updateEdgeMarker(edge){\n    // choose marker id string based on classes\n    let marker = 'arrow';\n    if(edge.line.classList.contains('highlight-active')) marker = 'arrow-active';\n    else if(edge.line.classList.contains('highlight-success')) marker = 'arrow-success';\n    else if(edge.line.classList.contains('neg-cycle')) marker = 'arrow-danger';\n    edge.line.setAttribute('marker-end', `url(#${marker})`);\n  }\n\n  /* Draggable nodes */\n  function makeDraggable(node){\n    let dragging = false;\n    let offset = {x:0,y:0};\n    const onDown = (e) => {\n      e.preventDefault();\n      dragging = true;\n      const pt = getPoint(e);\n      offset.x = node.x - pt.x;\n      offset.y = node.y - pt.y;\n      selectedNode = node;\n      highlightSelection();\n    };\n    const onMove = (e) => {\n      if(!dragging) return;\n      const pt = getPoint(e);\n      node.x = pt.x + offset.x;\n      node.y = pt.y + offset.y;\n      node.circle.setAttribute('cx', node.x);\n      node.circle.setAttribute('cy', node.y);\n      node.labelText.setAttribute('x', node.x);\n      node.labelText.setAttribute('y', node.y-4);\n      node.distText.setAttribute('x', node.x);\n      node.distText.setAttribute('y', node.y+14);\n      edges.forEach(updateEdgePosition);\n    };\n    const onUp = (e) => { dragging = false; };\n    node.g.addEventListener('mousedown', onDown);\n    window.addEventListener('mousemove', onMove);\n    window.addEventListener('mouseup', onUp);\n    // touch support\n    node.g.addEventListener('touchstart', (ev)=> { onDown(ev.touches[0]); }, {passive:false});\n    window.addEventListener('touchmove', (ev)=> { onMove(ev.touches[0]); }, {passive:false});\n    window.addEventListener('touchend', onUp);\n    // click selection for edge creation\n    node.g.addEventListener('click', (e) => {\n      e.stopPropagation();\n      if(addEdgeMode){\n        if(edgeTmpFrom==null){\n          edgeTmpFrom = node.id;\n          setStatus(`Pick destination node (from ${getNode(edgeTmpFrom).label}).`);\n        } else {\n          const to = node.id;\n          const weight = prompt('Edge weight (integer or decimal):', '1');\n          if(weight!==null && weight.trim()!==''){\n            createEdge(edgeTmpFrom,to,Number(weight));\n            log(`Added edge ${getNode(edgeTmpFrom).label} → ${getNode(to).label} (w=${weight})`);\n          }\n          edgeTmpFrom = null;\n          addEdgeMode = false;\n          document.getElementById('addEdgeModeBtn').classList.remove('active');\n          setStatus('Edge created (if accepted).');\n        }\n      } else {\n        // normal click selects node\n        selectedNode = node;\n        highlightSelection();\n      }\n    });\n  }\n\n  function getPoint(e){\n    const rect = svg.getBoundingClientRect();\n    return {x: e.clientX - rect.left, y: e.clientY - rect.top};\n  }\n\n  /* UI list updates */\n  function updateLists(){\n    // nodes list\n    nodesListDiv.innerHTML = '';\n    nodes.forEach(n=>{\n      const d = document.createElement('div');\n      d.className = 'node-item';\n      d.innerHTML = `<div>${n.label}</div><div style=\"display:flex;gap:6px\"><button class=\"small secondary\" data-id=\"${n.id}\" data-action=\"setSource\">Set as source</button><button class=\"small secondary\" data-id=\"${n.id}\" data-action=\"delNode\">Del</button></div>`;\n      nodesListDiv.appendChild(d);\n    });\n    // edges list\n    edgesListDiv.innerHTML = '';\n    edges.forEach(e=>{\n      const u = getNode(e.u).label, v = getNode(e.v).label;\n      const d = document.createElement('div');\n      d.className = 'edge-item';\n      d.innerHTML = `<div>${u} → ${v} (w=${e.w})</div><div style=\"display:flex;gap:6px\"><button class=\"small secondary\" data-id=\"${e.id}\" data-action=\"delEdge\">Del</button></div>`;\n      edgesListDiv.appendChild(d);\n    });\n\n    // attach handlers\n    nodesListDiv.querySelectorAll('button').forEach(btn=>{\n      btn.addEventListener('click', ()=> {\n        const id = Number(btn.getAttribute('data-id'));\n        const act = btn.getAttribute('data-action');\n        if(act==='setSource'){\n          sourceNode = id;\n          sourceSelect.value = String(id);\n          setStatus(`Source set to ${getNode(id).label}`);\n        } else if(act==='delNode'){\n          removeNode(id);\n        }\n      });\n    });\n    edgesListDiv.querySelectorAll('button').forEach(btn=>{\n      btn.addEventListener('click', ()=> {\n        const id = Number(btn.getAttribute('data-id'));\n        removeEdgeById(id);\n      });\n    });\n\n    // source select\n    sourceSelect.innerHTML = '';\n    nodes.forEach(n=>{\n      const opt = document.createElement('option');\n      opt.value = n.id;\n      opt.textContent = n.label;\n      sourceSelect.appendChild(opt);\n    });\n    if(sourceNode==null && nodes.length>0) { sourceNode = nodes[0].id; }\n    if(sourceNode!=null) sourceSelect.value = sourceNode;\n    sourceSelect.addEventListener('change', ()=> { sourceNode = Number(sourceSelect.value); setStatus('Source changed.'); });\n    refreshNodeDistances();\n  }\n\n  function refreshNodeDistances(){\n    nodes.forEach(n=>{\n      const v = dist.hasOwnProperty(n.id) ? dist[n.id] : Infinity;\n      n.distText.textContent = (v===Infinity) ? '∞' : String(v);\n      n.circle.style.fill = '#021423';\n    });\n  }\n\n  function highlightSelection(){\n    nodes.forEach(n => n.circle.style.stroke = (selectedNode && n.id===selectedNode.id) ? 'var(--accent)' : '#0b1220');\n  }\n\n  /* Controls wiring */\n  document.getElementById('addNodeBtn').addEventListener('click', ()=>{\n    const s = viewSize();\n    const x = 50 + Math.random()*(s.w-100);\n    const y = 50 + Math.random()*(s.h-100);\n    const label = String.fromCharCode(65 + (nodes.length % 26));\n    const node = createNode(x,y,label + (Math.floor(nodes.length/26) ? String(Math.floor(nodes.length/26)) : ''));\n    log(`Node ${node.label} added`);\n  });\n\n  document.getElementById('addEdgeModeBtn').addEventListener('click', (e)=>{\n    addEdgeMode = !addEdgeMode;\n    edgeTmpFrom = null;\n    e.target.classList.toggle('active', addEdgeMode);\n    setStatus(addEdgeMode ? 'Edge creation mode: click source then destination' : 'Edge creation canceled');\n  });\n\n  document.getElementById('removeSelectedBtn').addEventListener('click', ()=>{\n    if(selectedNode){ removeNode(selectedNode.id); selectedNode = null; setStatus('Selected node removed'); }\n    else setStatus('No node selected');\n  });\n\n  document.getElementById('rndGen').addEventListener('click', ()=>{\n    // parse settings\n    const n = Math.max(2, Math.min(20, Number(document.getElementById('rndN').value) || 6));\n    let p = Number(document.getElementById('rndP').value);\n    p = Math.max(0, Math.min(1, isNaN(p)?0.4:p));\n    const range = document.getElementById('rndRange').value.split('..').map(s=>Number(s.trim()));\n    const min = isNaN(range[0]) ? -5 : range[0];\n    const max = isNaN(range[1]) ? 10 : range[1];\n    // clear existing\n    nodes.slice().forEach(nm=> removeNode(nm.id));\n    // create nodes\n    const s = viewSize();\n    for(let i=0;i<n;i++){\n      const x = 60 + (i%(Math.ceil(Math.sqrt(n))))*(80);\n      const y = 60 + Math.floor(i/(Math.ceil(Math.sqrt(n))))*80;\n      createNode(Math.min(s.w-60, x + (Math.random()*40-20)), Math.min(s.h-60, y + (Math.random()*40-20)), String.fromCharCode(65 + i));\n    }\n    // create edges with probability p for each ordered pair\n    for(let i=0;i<n;i++){\n      for(let j=0;j<n;j++){\n        if(i===j) continue;\n        if(Math.random() < p){\n          const w = Math.floor(min + Math.random()*(max-min+1));\n          createEdge(nodes[i].id, nodes[j].id, w);\n        }\n      }\n    }\n    log(`Random graph generated: ${n} nodes, p=${p}, weights ${min}..${max}`);\n  });\n\n  /* Algorithm implementation (stepwise) */\n  function initAlgorithm(){\n    if(nodes.length===0){ alert('No nodes'); return false; }\n    if(edges.length===0){ alert('No edges'); return false; }\n    if(sourceNode==null){ alert('Pick source node'); return false; }\n    // initialize\n    dist = {}; prev = {};\n    nodes.forEach(n=>{ dist[n.id]=Infinity; prev[n.id]=null; });\n    dist[sourceNode]=0;\n    prev[sourceNode]=null;\n    currIter = 1;\n    currEdgeIndex = 0;\n    stepMode = false;\n    algoRunning = true;\n    refreshNodeDistances();\n    setStatus(`Initialized. Starting from ${getNode(sourceNode).label}. Iteration ${currIter} of ${nodes.length-1}`);\n    log(`Algorithm initialized. Source ${getNode(sourceNode).label}`);\n    return true;\n  }\n\n  function startAuto(){\n    if(!initAlgorithm()) return;\n    stepMode = false;\n    document.getElementById('pauseBtn').disabled = false;\n    autoTimer = setTimeout(autoStep, speedRange.value);\n  }\n\n  function autoStep(){\n    if(!algoRunning){ return; }\n    if(currIter > nodes.length - 1){\n      // finished relaxation rounds automatically\n      setStatus('Main relaxations finished. You can detect negative cycles or inspect results.');\n      log('Main relaxations finished (|V|-1 iterations).');\n      algoRunning = false;\n      document.getElementById('pauseBtn').disabled = true;\n      return;\n    }\n    // process one edge\n    if(currEdgeIndex >= edges.length){\n      currIter++;\n      currEdgeIndex = 0;\n      setStatus(`Iteration ${currIter} of ${nodes.length-1}`);\n      log(`--- Iteration ${currIter-1} complete ---`);\n      if(currIter > nodes.length -1){\n        // finished\n        setStatus('Main relaxations finished. You can detect negative cycles or inspect results.');\n        log('Main relaxations finished (|V|-1 iterations).');\n        algoRunning = false;\n        document.getElementById('pauseBtn').disabled = true;\n        return;\n      }\n    } else {\n      relaxEdgeVisual(edges[currEdgeIndex], ()=> {\n        currEdgeIndex++;\n        autoTimer = setTimeout(autoStep, speedRange.value);\n      });\n    }\n  }\n\n  function stepOnce(){\n    if(!algoRunning){\n      // first step: initialize\n      if(!initAlgorithm()) return;\n      stepMode = true;\n      setStatus(`Step mode. Iteration ${currIter} of ${nodes.length-1}, edge 0/${edges.length}`);\n    }\n    if(currIter > nodes.length - 1){\n      setStatus('Main relaxations finished. You can detect negative cycles or inspect results.');\n      log('Main relaxations finished (|V|-1 iterations).');\n      algoRunning = false;\n      return;\n    }\n    if(edges.length===0){\n      setStatus('No edges to process.');\n      algoRunning = false;\n      return;\n    }\n    if(currEdgeIndex >= edges.length){\n      currIter++;\n      currEdgeIndex = 0;\n      log(`--- Iteration ${currIter-1} complete ---`);\n      setStatus(`Iteration ${currIter} of ${nodes.length-1}`);\n      if(currIter > nodes.length -1){\n        setStatus('Main relaxations finished. You can detect negative cycles or inspect results.');\n        log('Main relaxations finished (|V|-1 iterations).');\n        algoRunning = false;\n        return;\n      }\n    } else {\n      relaxEdgeVisual(edges[currEdgeIndex], ()=> {\n        currEdgeIndex++;\n        setStatus(`Iteration ${currIter} of ${nodes.length-1}, edge ${currEdgeIndex}/${edges.length}`);\n      });\n    }\n  }\n\n  function relaxEdgeVisual(edge, cb){\n    // highlight active\n    clearEdgeHighlights();\n    edge.line.classList.add('highlight-active');\n    updateEdgeMarker(edge);\n    const u = edge.u, v = edge.v, w = edge.w;\n    const du = dist[u], dv = dist[v];\n    setStatus(`Relaxing edge ${getNode(u).label}→${getNode(v).label} (w=${w})`);\n    log(`Relaxing edge ${getNode(u).label}→${getNode(v).label} (w=${w}). dist[u]=${du===Infinity?'∞':du}, dist[v]=${dv===Infinity?'∞':dv}`);\n    // simulate evaluation time\n    setTimeout(()=>{\n      // attempt relax\n      if(du !== Infinity && du + w < dv){\n        // success\n        dist[v] = du + w;\n        prev[v] = u;\n        // update node visual\n        const nv = getNode(v);\n        nv.distText.textContent = String(dist[v]);\n        // highlight edge success\n        edge.line.classList.remove('highlight-active');\n        edge.line.classList.add('highlight-success');\n        updateEdgeMarker(edge);\n        log(`Updated dist[${getNode(v).label}] = ${dist[v]} via ${getNode(u).label}`, 'success');\n        // small flash on node\n        nv.circle.style.fill = 'var(--success)';\n        setTimeout(()=> nv.circle.style.fill = '#021423', 350);\n      } else {\n        // no change\n        edge.line.classList.remove('highlight-active');\n        edge.line.classList.add('highlight-fail');\n        updateEdgeMarker(edge);\n        log(`No update for ${getNode(v).label}`);\n      }\n      // cleanup highlight after a bit\n      setTimeout(()=>{\n        edge.line.classList.remove('highlight-success','highlight-fail','highlight-active');\n        updateEdgeMarker(edge);\n      }, Math.max(200, speedRange.value/2));\n      cb && cb();\n    }, Math.max(120, speedRange.value/3));\n  }\n\n  function clearEdgeHighlights(){\n    edges.forEach(e=>{\n      e.line.classList.remove('highlight-active','highlight-success','highlight-fail','neg-cycle');\n      updateEdgeMarker(e);\n    });\n  }\n\n  function resetAlgorithm(){\n    algoRunning = false;\n    stepMode = false;\n    clearTimeout(autoTimer);\n    autoTimer = null;\n    currIter = 1;\n    currEdgeIndex = 0;\n    dist = {};\n    prev = {};\n    nodes.forEach(n=>{ dist[n.id]=Infinity; prev[n.id]=null; n.distText.textContent='∞'; n.circle.style.fill = '#021423'; });\n    clearEdgeHighlights();\n    log('Algorithm reset.');\n    setStatus('Reset complete.');\n    document.getElementById('pauseBtn').disabled = true;\n  }\n\n  function detectNegativeCycle(){\n    if(Object.keys(dist).length===0){ alert('Run algorithm main relaxations first (auto or step).'); return; }\n    // perform one extra pass: any edge that can still relax indicates negative cycle reachable from source\n    let found = false;\n    const negEdges = [];\n    edges.forEach(e=>{\n      const u = e.u, v = e.v, w = e.w;\n      if(dist[u] !== Infinity && dist[u] + w < dist[v]){\n        found = true;\n        negEdges.push(e);\n      }\n    });\n    if(!found){\n      setStatus('No negative-weight cycles detected reachable from the source.');\n      log('No negative-weight cycles detected (reachable from source).', 'success');\n      return;\n    }\n    // highlight all edges part of negative cycle detection\n    negEdges.forEach(e=>{\n      e.line.classList.add('neg-cycle');\n      e.line.classList.remove('highlight-success','highlight-fail','highlight-active');\n      updateEdgeMarker(e);\n    });\n    setStatus('Negative-weight cycle(s) detected (highlighted in red).');\n    log(`Negative-weight cycle detected (or reachable). Highlighting ${negEdges.length} edge(s).`, 'danger');\n  }\n\n  /* Buttons */\n  document.getElementById('startBtn').addEventListener('click', ()=>{\n    if(algoRunning){ setStatus('Algorithm already running. Use Pause or Step.'); return; }\n    startAuto();\n  });\n\n  document.getElementById('pauseBtn').addEventListener('click', ()=>{\n    if(autoTimer){ clearTimeout(autoTimer); autoTimer = null; setStatus('Paused.'); document.getElementById('pauseBtn').disabled = true; }\n    algoRunning = false;\n  });\n\n  document.getElementById('stepBtn').addEventListener('click', ()=>{\n    stepOnce();\n  });\n\n  document.getElementById('resetBtn').addEventListener('click', ()=>{\n    resetAlgorithm();\n  });\n\n  document.getElementById('detectNegBtn').addEventListener('click', ()=>{\n    detectNegativeCycle();\n  });\n\n  // keyboard: Space to step\n  window.addEventListener('keydown', (e)=>{\n    if(e.code === 'Space'){ e.preventDefault(); stepOnce(); }\n  });\n\n  // click on background to deselect or add node\n  svg.addEventListener('click', (e)=>{\n    if(addEdgeMode){\n      // cancel edge creation\n      edgeTmpFrom = null;\n      addEdgeMode = false;\n      document.getElementById('addEdgeModeBtn').classList.remove('active');\n      setStatus('Edge creation canceled.');\n      return;\n    }\n    selectedNode = null;\n    highlightSelection();\n  });\n\n  // initialize canvas with a small sample\n  (function initSample(){\n    const s = viewSize();\n    const A = createNode(120,120,'A');\n    const B = createNode(320,90,'B');\n    const C = createNode(260,260,'C');\n    const D = createNode(480,210,'D');\n    createEdge(A.id,B.id,4);\n    createEdge(A.id,C.id,2);\n    createEdge(C.id,B.id,1);\n    createEdge(B.id,D.id,2);\n    createEdge(C.id,D.id,5);\n    createEdge(D.id,C.id,-7); // negative edge creating negative cycle with C->D->C\n    log('Sample graph loaded. Try Start (auto) or Step through relaxations.');\n    updateLists();\n  })();\n\n  // window resize: adjust edge positions\n  window.addEventListener('resize', ()=> edges.forEach(updateEdgePosition));\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Bellman-Ford Algorithm"
    }
  ],
  "topic": "Bellman-Ford Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}