{
  "id": "e1370ea0-ca58-11f0-b3c1-8750c080fb19",
  "timestamp": "2025-11-25T23:46:35.826Z",
  "model": "gpt-4o-mini",
  "status": "success",
  "question": "Heap (Min/Max)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Heap (Min/Max) Demonstration</title>\n    <style>\n        body { font-family: Arial, sans-serif; padding: 20px; }\n        input[type=\"number\"] { width: 50px; }\n        button { margin-left: 10px; }\n        .heap-visualization { margin-top: 20px; }\n    </style>\n</head>\n<body>\n\n    <h1>Min/Max Heap Visualization</h1>\n    <div>\n        <label for=\"numberInput\">Enter a number:</label>\n        <input type=\"number\" id=\"numberInput\" />\n        <button onclick=\"insertNumber()\">Insert</button>\n        <button onclick=\"removeMin()\">Remove Min</button>\n        <button onclick=\"removeMax()\">Remove Max</button>\n    </div>\n\n    <div class=\"heap-visualization\">\n        <h2>Heap:</h2>\n        <pre id=\"heapOutput\">[]</pre>\n    </div>\n\n    <script>\n        class MinMaxHeap {\n            constructor() {\n                this.values = [];\n                this.size = 0;\n            }\n\n            insert(value) {\n                this.values.push(value);\n                this.size++;\n                this.bubbleUp();\n                this.updateOutput();\n            }\n\n            bubbleUp() {\n                let index = this.size - 1;\n                while (index > 0) {\n                    let parentIndex = Math.floor((index - 1) / 2);\n                    if (this.values[index] < this.values[parentIndex]) {\n                        [this.values[index], this.values[parentIndex]] = [this.values[parentIndex], this.values[index]];\n                        index = parentIndex;\n                    } else {\n                        break;\n                    }\n                }\n            }\n\n            removeMin() {\n                if (this.size === 0) return null;\n                const min = this.values[0];\n                const end = this.values.pop();\n                this.size--;\n                if (this.size > 0) {\n                    this.values[0] = end;\n                    this.bubbleDownMin(0);\n                }\n                this.updateOutput();\n                return min;\n            }\n\n            removeMax() {\n                if (this.size === 0) return null;\n                if (this.size === 1) return this.values.pop();\n                const maxIndex = this.getMaxIndex();\n                const max = this.values[maxIndex];\n                const end = this.values.pop();\n                this.size--;\n                if (maxIndex < this.size) {\n                    this.values[maxIndex] = end;\n                    this.bubbleDownMax(maxIndex);\n                }\n                this.updateOutput();\n                return max;\n            }\n\n            bubbleDownMin(index) {\n                const length = this.size;\n                while (true) {\n                    let leftChildIndex = 2 * index + 1;\n                    let rightChildIndex = 2 * index + 2;\n                    let smallestIndex = index;\n                    \n                    if (leftChildIndex < length && this.values[leftChildIndex] < this.values[smallestIndex]) {\n                        smallestIndex = leftChildIndex;\n                    }\n                    if (rightChildIndex < length && this.values[rightChildIndex] < this.values[smallestIndex]) {\n                        smallestIndex = rightChildIndex;\n                    }\n                    if (smallestIndex === index) break;\n\n                    [this.values[index], this.values[smallestIndex]] = [this.values[smallestIndex], this.values[index]];\n                    index = smallestIndex;\n                }\n            }\n\n            bubbleDownMax(index) {\n                const length = this.size;\n                while (true) {\n                    let leftChildIndex = 2 * index + 1;\n                    let rightChildIndex = 2 * index + 2;\n                    let largestIndex = index;\n\n                    if (leftChildIndex < length && this.values[leftChildIndex] > this.values[largestIndex]) {\n                        largestIndex = leftChildIndex;\n                    }\n                    if (rightChildIndex < length && this.values[rightChildIndex] > this.values[largestIndex]) {\n                        largestIndex = rightChildIndex;\n                    }\n                    if (largestIndex === index) break;\n\n                    [this.values[index], this.values[largestIndex]] = [this.values[largestIndex], this.values[index]];\n                    index = largestIndex;\n                }\n            }\n\n            getMaxIndex() {\n                if (this.size < 3) return this.size - 1;\n                const leftChildIndex = 1; // First child\n                const rightChildIndex = 2; // Second child\n                return this.values[leftChildIndex] > this.values[rightChildIndex] ? leftChildIndex : rightChildIndex;\n            }\n\n            updateOutput() {\n                document.getElementById('heapOutput').textContent = JSON.stringify(this.values, null, 2);\n            }\n        }\n\n        const heap = new MinMaxHeap();\n\n        function insertNumber() {\n            const input = document.getElementById('numberInput');\n            const value = parseInt(input.value);\n            if (!isNaN(value)) {\n                heap.insert(value);\n                input.value = '';\n            }\n        }\n\n        function removeMin() {\n            heap.removeMin();\n        }\n\n        function removeMax() {\n            heap.removeMax();\n        }\n    </script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap (Min/Max)"
    }
  ],
  "topic": "Heap (Min/Max)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}