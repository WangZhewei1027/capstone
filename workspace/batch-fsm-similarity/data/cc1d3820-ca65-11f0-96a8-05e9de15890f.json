{
  "id": "cc1d3820-ca65-11f0-96a8-05e9de15890f",
  "timestamp": "2025-11-26T01:21:18.441Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\"/>\n  <title>Binary Search Tree (BST) Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n  <style>\n    :root { --bg:#f6f8fb; --panel:#ffffff; --accent:#2b79ff; --muted:#6b7280; --good:#10b981; --bad:#ef4444; }\n    body { margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; background:var(--bg); color:#0f172a; }\n    header { padding:16px 20px; display:flex; gap:12px; align-items:center; background:linear-gradient(90deg,#f8fafc,#eef2ff); border-bottom:1px solid #e6eefc; }\n    h1 { margin:0; font-size:18px; font-weight:600; color:#0b1220; }\n    main { display:flex; gap:20px; padding:18px; }\n    .controls { width:360px; background:var(--panel); border-radius:10px; padding:16px; box-shadow:0 6px 18px rgba(11,20,40,0.06); }\n    .visual { flex:1; min-height:520px; background:var(--panel); border-radius:10px; padding:12px; box-shadow:0 6px 18px rgba(11,20,40,0.06); display:flex; flex-direction:column; }\n    label { display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }\n    .row { display:flex; gap:8px; align-items:center; margin-bottom:10px; }\n    input[type=\"number\"], input[type=\"text\"] { padding:8px 10px; border-radius:8px; border:1px solid #e6eefc; background:#fafafa; width:100%; font-size:14px; }\n    button { background:var(--accent); color:white; border:none; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600; }\n    button.secondary { background:#eef2ff; color:var(--accent); box-shadow:none; font-weight:600; }\n    button.warn { background:var(--bad); }\n    .small { padding:6px 8px; font-size:13px; border-radius:8px; }\n    .muted { color:var(--muted); font-size:13px; }\n    .controls .section { margin-bottom:14px; padding-bottom:8px; border-bottom:1px dashed #eef4ff; }\n    .traversals button { margin-right:8px; margin-bottom:8px; }\n    .status { margin-top:12px; font-size:13px; color:var(--muted); }\n    .info { font-size:13px; color:var(--muted); margin-top:8px; }\n    svg { width:100%; height:100%; overflow:visible; }\n    .node { cursor:default; transition:transform .18s ease, fill .2s ease; }\n    .node circle { fill: #ffffff; stroke: #9fb7ff; stroke-width:2; }\n    .node text { font-size:12px; font-weight:700; fill:#0f172a; text-anchor:middle; dominant-baseline:central; }\n    .edge { stroke:#cde0ff; stroke-width:2; }\n    .visited circle { fill:#fff7e6; stroke:#f59e0b; stroke-width:2.5; }\n    .found circle { fill:#ecfeff; stroke:#06b6d4; stroke-width:2.5; }\n    .highlight circle { fill:#edeffd; stroke:#6366f1; stroke-width:2.5; transform:scale(1.07); }\n    .legend { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }\n    .leg-item { display:flex; gap:6px; align-items:center; font-size:12px; color:var(--muted); }\n    .badge { width:14px; height:14px; border-radius:4px; border:1px solid rgba(0,0,0,0.06); }\n    .badge.visit { background:#fff7e6; border-color:#f59e0b; }\n    .badge.found { background:#ecfeff; border-color:#06b6d4; }\n    .badge.highlight { background:#edeffd; border-color:#6366f1; }\n    footer { padding:8px 18px; font-size:13px; color:var(--muted); text-align:center; }\n    .meta { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }\n    .pill { background:#f1f5f9; border-radius:999px; padding:6px 8px; font-size:12px; color:var(--muted); }\n    .result { margin-top:8px; font-size:14px; font-weight:600; color:#0b1220; }\n    .node-count { font-weight:700; color:var(--accent); }\n    .input-row { display:flex; gap:8px; }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Binary Search Tree (BST) — Interactive Visualizer</h1>\n    <div style=\"margin-left:auto; color:var(--muted); font-size:13px;\">Insert / Delete / Search / Traversals • Animated</div>\n  </header>\n\n  <main>\n    <aside class=\"controls\" aria-label=\"controls\">\n      <div class=\"section\">\n        <label>Value (integer)</label>\n        <div class=\"input-row\">\n          <input id=\"valueInput\" type=\"number\" placeholder=\"e.g. 42\" />\n          <button id=\"insertBtn\" class=\"small\">Insert</button>\n          <button id=\"deleteBtn\" class=\"small warn\">Delete</button>\n        </div>\n        <div class=\"input-row\" style=\"margin-top:8px;\">\n          <input id=\"searchInput\" type=\"number\" placeholder=\"Search value\" />\n          <button id=\"searchBtn\" class=\"small secondary\">Search</button>\n        </div>\n        <div class=\"row\" style=\"margin-top:10px;\">\n          <button id=\"randomBtn\" class=\"small\">Random (7)</button>\n          <button id=\"clearBtn\" class=\"small secondary\">Clear</button>\n        </div>\n        <div class=\"status\">\n          Nodes: <span id=\"nodeCount\" class=\"node-count\">0</span> • Height: <span id=\"treeHeight\">0</span>\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <label>Traversals & Animations</label>\n        <div class=\"traversals\">\n          <button id=\"inorderBtn\" class=\"small secondary\">In-order</button>\n          <button id=\"preorderBtn\" class=\"small secondary\">Pre-order</button>\n          <button id=\"postorderBtn\" class=\"small secondary\">Post-order</button>\n          <button id=\"levelBtn\" class=\"small secondary\">Level-order</button>\n        </div>\n        <div class=\"row\" style=\"margin-top:8px;\">\n          <label style=\"margin:0;\">Animation speed</label>\n          <input id=\"speed\" type=\"range\" min=\"50\" max=\"1200\" value=\"350\" style=\"flex:1\" />\n        </div>\n        <div class=\"result\" id=\"traversalResult\">Result: —</div>\n        <div class=\"info\">Tip: Use traversal buttons to animate node visits. Search animates the path taken.</div>\n      </div>\n\n      <div class=\"\">\n        <label>Complexity</label>\n        <div class=\"meta\">\n          <div class=\"pill\">Avg search/insert: O(log n)</div>\n          <div class=\"pill\">Worst-case: O(n)</div>\n          <div class=\"pill\">Space: O(n)</div>\n        </div>\n        <div class=\"legend\">\n          <div class=\"leg-item\"><span class=\"badge visit\"></span> visited</div>\n          <div class=\"leg-item\"><span class=\"badge found\"></span> found</div>\n          <div class=\"leg-item\"><span class=\"badge highlight\"></span> currently exploring</div>\n        </div>\n      </div>\n    </aside>\n\n    <section class=\"visual\" aria-label=\"visualization\">\n      <svg id=\"svgCanvas\" viewBox=\"0 0 1200 600\" preserveAspectRatio=\"xMidYMin meet\"></svg>\n      <div style=\"padding:8px 10px; font-size:13px; color:var(--muted); border-top:1px dashed #eef4ff; margin-top:8px;\">\n        Structure: <span id=\"structureText\">Empty</span>\n      </div>\n    </section>\n  </main>\n\n  <footer>\n    BST operations demonstrated: insert, delete, search, inorder/preorder/postorder/level-order traversal. Duplicates ignored.\n  </footer>\n\n<script>\n(() => {\n  // Basic BST implementation with visualization-friendly methods\n  class Node {\n    constructor(v) { this.v = v; this.left = null; this.right = null; this.x = 0; this.y = 0; }\n  }\n\n  class BST {\n    constructor() { this.root = null; this._size = 0; }\n    get size() { return this._size; }\n    insert(v) {\n      if (this.root === null) { this.root = new Node(v); this._size = 1; return true; }\n      let cur = this.root, parent = null;\n      while (cur) {\n        parent = cur;\n        if (v === cur.v) return false; // ignore duplicates\n        if (v < cur.v) cur = cur.left; else cur = cur.right;\n      }\n      if (v < parent.v) parent.left = new Node(v); else parent.right = new Node(v);\n      this._size++;\n      return true;\n    }\n    find(v) {\n      let cur = this.root, path = [];\n      while (cur) {\n        path.push(cur);\n        if (v === cur.v) return { found: true, path };\n        cur = v < cur.v ? cur.left : cur.right;\n      }\n      return { found: false, path };\n    }\n    delete(v) {\n      // delete node, return whether deleted\n      const deleteRec = (node, v) => {\n        if (!node) return [node, false];\n        if (v < node.v) {\n          let [newLeft, removed] = deleteRec(node.left, v); node.left = newLeft; return [node, removed];\n        } else if (v > node.v) {\n          let [newRight, removed] = deleteRec(node.right, v); node.right = newRight; return [node, removed];\n        } else {\n          // delete this node\n          if (!node.left && !node.right) return [null, true];\n          if (!node.left) return [node.right, true];\n          if (!node.right) return [node.left, true];\n          // two children: replace with inorder successor\n          let succ = node.right; while (succ.left) succ = succ.left;\n          node.v = succ.v;\n          let [newRight] = deleteRec(node.right, succ.v);\n          node.right = newRight;\n          return [node, true];\n        }\n      };\n      const [newRoot, removed] = deleteRec(this.root, v);\n      if (removed) { this.root = newRoot; this._size--; }\n      return removed;\n    }\n    // Traversals: return array of nodes (Node references)\n    inorder(node=this.root, out=[]) { if(!node) return out; this.inorder(node.left,out); out.push(node); this.inorder(node.right,out); return out; }\n    preorder(node=this.root, out=[]) { if(!node) return out; out.push(node); this.preorder(node.left,out); this.preorder(node.right,out); return out; }\n    postorder(node=this.root, out=[]) { if(!node) return out; this.postorder(node.left,out); this.postorder(node.right,out); out.push(node); return out; }\n    levelOrder() {\n      let out = []; if(!this.root) return out;\n      let q = [this.root];\n      while(q.length){ let n = q.shift(); out.push(n); if(n.left) q.push(n.left); if(n.right) q.push(n.right); }\n      return out;\n    }\n    height(node=this.root) {\n      if(!node) return 0;\n      return 1 + Math.max(this.height(node.left), this.height(node.right));\n    }\n    // for visualization, assign x positions using inorder index, and y by depth\n    layout(gapX=70, gapY=80) {\n      let idx = 0;\n      const assignX = (n, depth) => {\n        if(!n) return;\n        assignX(n.left, depth+1);\n        n.x = idx * gapX;\n        n.y = depth * gapY;\n        idx++;\n        assignX(n.right, depth+1);\n      };\n      assignX(this.root, 0);\n      // center x coordinates so tree is centered at middle\n      const all = this.inorder();\n      if(all.length===0) return { width:0, height:0 };\n      const minX = Math.min(...all.map(n=>n.x)), maxX = Math.max(...all.map(n=>n.x));\n      // translate so leftmost has margin 40\n      const margin = 40;\n      const shift = margin - minX;\n      all.forEach(n => n.x += shift);\n      const width = maxX - minX + margin*2 + 80;\n      const height = (Math.max(...all.map(n=>n.y)) || 0) + gapY + 60;\n      return { width, height };\n    }\n    // structure text representation (parentheses)\n    structure(node=this.root) {\n      if(!node) return '';\n      const L = this.structure(node.left), R = this.structure(node.right);\n      if(!L && !R) return `${node.v}`;\n      return `${node.v}(${L||'-'},${R||'-'})`;\n    }\n  }\n\n  // UI & drawing\n  const svg = document.getElementById('svgCanvas');\n  const valueInput = document.getElementById('valueInput');\n  const insertBtn = document.getElementById('insertBtn');\n  const deleteBtn = document.getElementById('deleteBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const searchInput = document.getElementById('searchInput');\n  const searchBtn = document.getElementById('searchBtn');\n\n  const inorderBtn = document.getElementById('inorderBtn');\n  const preorderBtn = document.getElementById('preorderBtn');\n  const postorderBtn = document.getElementById('postorderBtn');\n  const levelBtn = document.getElementById('levelBtn');\n  const traversalResult = document.getElementById('traversalResult');\n  const nodeCountSpan = document.getElementById('nodeCount');\n  const treeHeightSpan = document.getElementById('treeHeight');\n  const structureText = document.getElementById('structureText');\n  const speedInput = document.getElementById('speed');\n\n  const tree = new BST();\n  let animating = false;\n  const nodeR = 20;\n\n  function clearSVG() { while(svg.firstChild) svg.removeChild(svg.firstChild); }\n\n  function draw() {\n    clearSVG();\n    const layout = tree.layout(90, 90);\n    svg.setAttribute('viewBox', `0 0 ${Math.max(100, layout.width)} ${Math.max(200, layout.height)}`);\n    const nodes = tree.inorder(); // all nodes\n    if(nodes.length===0) {\n      structureText.textContent = 'Empty';\n      nodeCountSpan.textContent = '0';\n      treeHeightSpan.textContent = '0';\n      traversalResult.textContent = 'Result: —';\n      return;\n    }\n    // draw edges first\n    const edgesGroup = make('g');\n    svg.appendChild(edgesGroup);\n    const drawEdges = (n) => {\n      if(!n) return;\n      if(n.left) {\n        const line = make('line'); line.setAttribute('x1', n.x); line.setAttribute('y1', n.y); line.setAttribute('x2', n.left.x); line.setAttribute('y2', n.left.y);\n        line.classList.add('edge'); edgesGroup.appendChild(line);\n      }\n      if(n.right) {\n        const line = make('line'); line.setAttribute('x1', n.x); line.setAttribute('y1', n.y); line.setAttribute('x2', n.right.x); line.setAttribute('y2', n.right.y);\n        line.classList.add('edge'); edgesGroup.appendChild(line);\n      }\n      drawEdges(n.left); drawEdges(n.right);\n    };\n    drawEdges(tree.root);\n\n    // draw nodes\n    const nodesGroup = make('g');\n    svg.appendChild(nodesGroup);\n    const drawNodes = (n) => {\n      if(!n) return;\n      const g = make('g'); g.classList.add('node'); g.setAttribute('transform', `translate(${n.x}, ${n.y})`);\n      const circ = make('circle'); circ.setAttribute('r', nodeR); circ.setAttribute('cx', 0); circ.setAttribute('cy', 0);\n      const txt = make('text'); txt.textContent = n.v; g.appendChild(circ); g.appendChild(txt);\n      // store a mapping for quick reference\n      g._nodeRef = n;\n      nodesGroup.appendChild(g);\n      drawNodes(n.left); drawNodes(n.right);\n    };\n    drawNodes(tree.root);\n\n    // place nodes visually a bit lower (y coords are top-based), add little shadow/label\n    // update status\n    nodeCountSpan.textContent = String(tree.size);\n    treeHeightSpan.textContent = String(tree.height());\n    structureText.textContent = tree.structure() || 'Empty';\n  }\n\n  function make(tag){ return document.createElementNS('http://www.w3.org/2000/svg', tag); }\n\n  // Animation helpers\n  function highlightPath(path, found, speed, cb) {\n    if(!path || path.length===0) { cb && cb(); return; }\n    animating = true;\n    disableControls(true);\n    let i = 0;\n    const nodes = Array.from(svg.querySelectorAll('.node'));\n    const resetAll = () => {\n      nodes.forEach(g => { g.classList.remove('visited','found','highlight'); });\n    };\n    resetAll();\n    const step = () => {\n      if(i>0) {\n        // mark previous as visited\n        const prev = path[i-1];\n        const gprev = nodes.find(g => g._nodeRef === prev);\n        if(gprev) { gprev.classList.remove('highlight'); gprev.classList.add('visited'); }\n      }\n      if(i < path.length) {\n        const cur = path[i];\n        const gcur = nodes.find(g => g._nodeRef === cur);\n        if(gcur) { gcur.classList.add('highlight'); }\n        i++;\n        setTimeout(step, speed);\n      } else {\n        // done: mark last\n        const last = path[path.length-1];\n        const glast = nodes.find(g => g._nodeRef === last);\n        if(glast) {\n          if(found) { glast.classList.remove('highlight'); glast.classList.add('found'); }\n          else { glast.classList.remove('highlight'); glast.classList.add('visited'); }\n        }\n        animating = false;\n        disableControls(false);\n        cb && cb();\n      }\n    };\n    step();\n  }\n\n  function animateSequence(nodeArr, speed, cb) {\n    animating = true; disableControls(true);\n    const nodes = Array.from(svg.querySelectorAll('.node'));\n    nodes.forEach(g => { g.classList.remove('visited','found','highlight'); });\n    let i = 0;\n    const step = () => {\n      if(i>0) {\n        const prev = nodeArr[i-1];\n        const gprev = nodes.find(g => g._nodeRef === prev);\n        if(gprev) gprev.classList.remove('highlight'), gprev.classList.add('visited');\n      }\n      if(i < nodeArr.length) {\n        const cur = nodeArr[i];\n        const gcur = nodes.find(g => g._nodeRef === cur);\n        if(gcur) gcur.classList.add('highlight');\n        i++;\n        setTimeout(step, speed);\n      } else {\n        animating = false; disableControls(false); cb && cb();\n      }\n    };\n    step();\n  }\n\n  function disableControls(disable) {\n    const els = [insertBtn, deleteBtn, clearBtn, randomBtn, searchBtn, inorderBtn, preorderBtn, postorderBtn, levelBtn];\n    els.forEach(e => e.disabled = disable);\n    speedInput.disabled = disable;\n    valueInput.disabled = disable;\n    searchInput.disabled = disable;\n  }\n\n  // Event handlers\n  insertBtn.addEventListener('click', () => {\n    const v = parseInt(valueInput.value);\n    if(Number.isNaN(v)) return alert('Enter an integer to insert.');\n    const ok = tree.insert(v);\n    if(!ok) alert('Value already exists in BST (duplicates ignored).');\n    valueInput.value = '';\n    draw();\n  });\n  deleteBtn.addEventListener('click', () => {\n    const v = parseInt(valueInput.value);\n    if(Number.isNaN(v)) return alert('Enter an integer to delete.');\n    const ok = tree.delete(v);\n    if(!ok) alert('Value not found.');\n    valueInput.value = '';\n    draw();\n  });\n  clearBtn.addEventListener('click', () => {\n    if(!confirm('Clear the entire tree?')) return;\n    tree.root = null; tree._size = 0;\n    draw();\n  });\n  randomBtn.addEventListener('click', () => {\n    if(animating) return;\n    // generate 7 unique random integers between 1..99\n    const count = 7;\n    const set = new Set();\n    while(set.size < count) set.add(Math.floor(Math.random()*99)+1);\n    set.forEach(n => tree.insert(n));\n    draw();\n  });\n\n  searchBtn.addEventListener('click', () => {\n    if(animating) return;\n    const v = parseInt(searchInput.value);\n    if(Number.isNaN(v)) return alert('Enter an integer to search.');\n    const {found, path} = tree.find(v);\n    if(path.length===0) { alert('Tree is empty.'); return; }\n    const speed = parseInt(speedInput.value);\n    highlightPath(path, found, speed, () => {\n      if(found) traversalResult.textContent = `Result: Found ${v} (visited ${path.length} nodes)`;\n      else traversalResult.textContent = `Result: Not found (visited ${path.length} nodes)`;\n    });\n  });\n\n  inorderBtn.addEventListener('click', ()=> {\n    if(animating) return;\n    const arr = tree.inorder();\n    if(arr.length===0) { alert('Tree is empty.'); return; }\n    animateSequence(arr, parseInt(speedInput.value), ()=> traversalResult.textContent = 'Result: In-order: ' + arr.map(n=>n.v).join(', '));\n  });\n  preorderBtn.addEventListener('click', ()=> {\n    if(animating) return;\n    const arr = tree.preorder();\n    if(arr.length===0) { alert('Tree is empty.'); return; }\n    animateSequence(arr, parseInt(speedInput.value), ()=> traversalResult.textContent = 'Result: Pre-order: ' + arr.map(n=>n.v).join(', '));\n  });\n  postorderBtn.addEventListener('click', ()=> {\n    if(animating) return;\n    const arr = tree.postorder();\n    if(arr.length===0) { alert('Tree is empty.'); return; }\n    animateSequence(arr, parseInt(speedInput.value), ()=> traversalResult.textContent = 'Result: Post-order: ' + arr.map(n=>n.v).join(', '));\n  });\n  levelBtn.addEventListener('click', ()=> {\n    if(animating) return;\n    const arr = tree.levelOrder();\n    if(arr.length===0) { alert('Tree is empty.'); return; }\n    animateSequence(arr, parseInt(speedInput.value), ()=> traversalResult.textContent = 'Result: Level-order: ' + arr.map(n=>n.v).join(', '));\n  });\n\n  // make clicking on a node prefill the input for quick delete/search\n  svg.addEventListener('click', (ev) => {\n    if(ev.target && ev.target.parentNode && ev.target.parentNode.classList && ev.target.parentNode.classList.contains('node')) {\n      const node = ev.target.parentNode._nodeRef;\n      if(node) {\n        valueInput.value = node.v;\n        searchInput.value = node.v;\n      }\n    }\n  });\n\n  // initial draw (empty)\n  draw();\n\n  // keyboard shortcuts: Enter in value input -> insert\n  valueInput.addEventListener('keypress', (e)=> { if(e.key === 'Enter') insertBtn.click(); });\n  searchInput.addEventListener('keypress', (e)=> { if(e.key === 'Enter') searchBtn.click(); });\n\n  // small helper: allow dragging pan on svg if larger than container (optional)\n  let isDown=false, startX=0, startY=0, viewBox = {x:0,y:0,w:1200,h:600};\n  svg.addEventListener('mousedown', (e) => {\n    if(e.button !== 0) return;\n    isDown = true; startX = e.clientX; startY = e.clientY;\n    const vb = svg.getAttribute('viewBox').split(' ').map(Number); viewBox = {x:vb[0], y:vb[1], w:vb[2], h:vb[3]};\n    svg.style.cursor = 'grabbing';\n  });\n  window.addEventListener('mouseup', ()=> { isDown = false; svg.style.cursor = 'default'; });\n  window.addEventListener('mousemove', (e) => {\n    if(!isDown) return;\n    const dx = (startX - e.clientX), dy = (startY - e.clientY);\n    svg.setAttribute('viewBox', `${viewBox.x + dx} ${viewBox.y + dy} ${viewBox.w} ${viewBox.h}`);\n  });\n\n  // small accessibility: make svg resize on window\n  window.addEventListener('resize', () => draw());\n\n  // expose tree for console debugging (optional)\n  window.__bst = tree;\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}