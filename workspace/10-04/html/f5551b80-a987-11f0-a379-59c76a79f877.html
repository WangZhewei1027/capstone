<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Bubble Sort Interactive Lab</title>
<style>
  :root{
    --bg:#0f1420;
    --panel:#131a28;
    --accent:#5cb3ff;
    --accent2:#ff7e6b;
    --text:#e6edf5;
    --muted:#9fb2c9;
    --good:#4ad97b;
    --warn:#ffc65c;
    --danger:#ff5a7a;
    --bar:#4c6dd8;
    --barAlt:#7ab0ff;
    --sorted:#3cc884;
    --compare:#ffd54d;
    --swap:#ff6f61;
  }
  html, body{
    height:100%;
    margin:0;
    background: radial-gradient(1200px 600px at 70% 0%, #1b2b46 0%, var(--bg) 60%);
    color: var(--text);
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
  .wrap{
    display:grid;
    grid-template-columns: 1.4fr 1fr;
    grid-template-rows:auto auto 1fr;
    gap:16px;
    padding:16px;
    max-width:1400px;
    margin:0 auto;
  }
  .panel{
    background: linear-gradient(180deg, #172132 0%, var(--panel) 100%);
    border-radius:12px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.06);
    border:1px solid rgba(255,255,255,0.06);
  }
  .panel h2{
    font-size:18px;
    margin:0;
    padding:12px 16px;
    border-bottom:1px solid rgba(255,255,255,0.06);
    color:#cde5ff;
    letter-spacing:0.3px;
  }
  .controls{
    display:flex;
    flex-wrap:wrap;
    align-items:center;
    gap:10px 14px;
    padding:12px 16px;
  }
  .controls .group{
    display:flex;
    align-items:center;
    gap:8px;
    padding:8px 12px;
    background: rgba(255,255,255,0.04);
    border:1px solid rgba(255,255,255,0.06);
    border-radius:10px;
  }
  .controls label{
    font-size:12px; color:var(--muted);
  }
  .controls input[type="range"]{ width:160px; }
  .controls select, .controls input[type="text"]{
    background:#0f1728; color:var(--text);
    border:1px solid rgba(255,255,255,0.12);
    padding:6px 8px; border-radius:6px;
  }
  .btn{
    background: linear-gradient(180deg, #2962e2 0%, #204fc0 100%);
    border: none;
    color: white;
    padding:10px 14px;
    border-radius:10px;
    cursor:pointer;
    font-weight:600;
    box-shadow: 0 4px 12px rgba(41,98,226,0.4);
    transition: transform .06s ease, box-shadow .2s ease;
  }
  .btn:active{ transform: translateY(1px); box-shadow: 0 2px 8px rgba(41,98,226,0.35); }
  .btn.secondary{
    background: linear-gradient(180deg, #2b374e 0%, #1c2638 100%);
    color:#cfe3ff; box-shadow:none; border:1px solid rgba(255,255,255,0.08);
  }
  .btn.warn{
    background: linear-gradient(180deg, #ff8a4d 0%, #e06c1c 100%);
    box-shadow: 0 4px 12px rgba(255,138,77,0.4);
  }
  .btn.good{
    background: linear-gradient(180deg, #2cc76a 0%, #1fa85b 100%);
    box-shadow: 0 4px 12px rgba(44,199,106,0.35);
  }
  .viz{
    grid-column: 1 / 3;
    grid-row: 2 / 4;
    display:grid;
    grid-template-columns: 3fr 2fr;
    gap:16px;
  }
  .stage{
    position:relative;
    padding:16px;
    display:flex;
    flex-direction:column;
  }
  .barArea{
    position:relative;
    flex: 1 1 auto;
    margin-top:8px;
    background: radial-gradient(800px 300px at 70% 0%, #10182b 0%, #0c1220 60%);
    border:1px solid rgba(255,255,255,0.06);
    border-radius:12px;
    padding:16px;
    overflow:hidden;
  }
  .bars{
    display:flex; align-items:flex-end; height:100%;
    gap:6px;
  }
  .bar{
    width: calc((100% - 6px * 49) / 50);
    min-width: 12px;
    background: linear-gradient(180deg, var(--barAlt) 0%, var(--bar) 100%);
    border-radius: 6px 6px 2px 2px;
    position:relative;
    transition: filter .2s ease, box-shadow .2s ease;
    box-shadow: 0 2px 8px rgba(0,0,0,0.45);
    will-change: transform;
  }
  .bar .label{
    position:absolute; bottom:4px; left:50%; transform:translateX(-50%);
    font-size:11px; color:#eef5ff; text-shadow: 0 1px 2px rgba(0,0,0,0.6);
    pointer-events:none;
  }
  .bar.compare{ outline: 2px solid var(--compare); filter:brightness(1.2); }
  .bar.swap{ outline: 2px solid var(--swap); filter:brightness(1.25); }
  .bar.sorted{ background: linear-gradient(180deg, #58e2a0 0%, #2fb873 100%); }
  .stageFooter{
    display:flex; gap:12px; align-items:center; justify-content:space-between;
    margin-top:12px;
  }
  .legend{ display:flex; gap:10px; flex-wrap:wrap; padding:4px 8px; background:rgba(255,255,255,0.04); border-radius:8px;border:1px solid rgba(255,255,255,0.06);}
  .legend span{ font-size:12px; color:#cfe3ff; display:flex; align-items:center; gap:6px; }
  .key{ width:14px; height:14px; border-radius:3px; display:inline-block; }
  .key.compare{ background: var(--compare); }
  .key.swap{ background: var(--swap); }
  .key.sorted{ background: var(--sorted); }
  .pointer{
    position:absolute; top:4px; transform: translateX(-50%);
    color:#d7e7ff; font-size:12px; text-align:center; pointer-events:none;
  }
  .pointer .arrow{
    width:0;height:0; border-left:6px solid transparent; border-right:6px solid transparent; border-top:8px solid var(--accent);
    margin:4px auto 0;
  }
  .stats{
    padding:12px 16px; display:grid; grid-template-columns: repeat(2,1fr);
    gap:10px;
  }
  .stat{
    background: rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.06);
    border-radius:10px; padding:10px 12px;
  }
  .stat .big{ font-size:22px; font-weight:700; color:#ffffff; }
  .stat .label{ font-size:12px; color:var(--muted); }
  .explain{
    padding:12px 16px; font-size:14px; color:#e9f2ff;
    border-top:1px solid rgba(255,255,255,0.06);
    min-height: 56px;
  }
  .code{
    padding:0;
    display:flex; flex-direction:column;
  }
  .code pre{
    margin:0; padding:12px 16px; font-size:13px; line-height:1.55;
    color:#cfe3ff; overflow:auto; max-height:260px;
    background: #0e1626;
    border-bottom:1px solid rgba(255,255,255,0.06);
  }
  .code .line{
    display:block; padding:2px 8px; border-radius:6px;
  }
  .code .hl{
    background: rgba(92,179,255,0.16); border-left:3px solid var(--accent);
  }
  .footnotes{
    padding:12px 16px; font-size:13px; color:#b6c6dc;
  }
  .footnotes b{ color:#e9f2ff;}
  .options{
    display:flex; gap:10px; align-items:center; padding:10px 16px; border-top:1px solid rgba(255,255,255,0.06);
  }
  .toggle{
    display:inline-flex; align-items:center; gap:8px; padding:6px 8px;
    border:1px solid rgba(255,255,255,0.12); border-radius:20px; background:#0d172b;
    font-size:12px; color:#cfe3ff; cursor:pointer;
  }
  .toggle input{ accent-color: var(--accent); }
  .small{
    font-size:12px; color:#b8cce6;
  }
  .divider{
    height:1px; background:rgba(255,255,255,0.08); margin:12px 0;
  }
  .note{
    padding:8px 12px; border-left:3px solid var(--accent); background: rgba(92,179,255,0.12);
    border-radius:8px; color:#eaf5ff;
  }
  .title{
    grid-column: 1 / 3;
    padding:16px 20px; display:flex; align-items:center; justify-content:space-between;
  }
  .title h1{ margin:0; font-size:24px; letter-spacing:.2px; color:#daf0ff; }
  .title .sub{ color:#b6c6dc; font-size:13px; }
  @media (max-width: 1100px){
    .viz{ grid-template-columns: 1fr; }
    .wrap{ grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="panel title">
      <div>
        <h1>Bubble Sort Interactive Lab</h1>
        <div class="sub">Explore comparisons, swaps, passes, and the optimized early-exit variant with live animation.</div>
      </div>
      <div>
        <button class="btn" id="playBtn">Play</button>
        <button class="btn secondary" id="stepBtn">Step</button>
        <button class="btn secondary" id="resetBtn">Reset</button>
      </div>
    </div>

    <div class="panel">
      <h2>Dataset & Controls</h2>
      <div class="controls">
        <div class="group">
          <label>Size</label>
          <input type="range" min="5" max="50" value="20" id="sizeRange"/>
          <span id="sizeLabel">20</span>
        </div>
        <div class="group">
          <label>Distribution</label>
          <select id="distribution">
            <option value="random">Random</option>
            <option value="reversed">Reversed</option>
            <option value="nearly">Nearly Sorted</option>
            <option value="few">Few Unique (duplicates)</option>
          </select>
        </div>
        <div class="group" style="flex:1">
          <label>Custom (comma or space-separated)</label>
          <input type="text" id="customInput" placeholder="e.g. 5, 3, 9, 2, 2, 8"/>
        </div>
        <div class="group">
          <button class="btn good" id="generateBtn">Generate</button>
          <button class="btn secondary" id="shuffleBtn">Shuffle</button>
        </div>
        <div class="group">
          <label>Speed</label>
          <input type="range" min="0" max="100" value="55" id="speedRange"/>
          <span id="speedLabel">1.0x</span>
        </div>
        <div class="group">
          <label>Algorithm</label>
          <select id="algoSelect">
            <option value="standard">Standard Bubble Sort</option>
            <option value="optimized">Optimized (early exit)</option>
          </select>
        </div>
      </div>
      <div class="options">
        <label class="toggle"><input type="checkbox" id="showValues" checked/> Show bar values</label>
        <label class="toggle"><input type="checkbox" id="showPointers" checked/> Show loop pointer j</label>
        <label class="toggle"><input type="checkbox" id="autoFocus" checked/> Auto-focus current bars</label>
      </div>
    </div>

    <div class="viz">
      <div class="panel stage">
        <h2>Visualization</h2>
        <div class="barArea">
          <div id="pointerJ" class="pointer" style="display:none;">
            j
            <div class="arrow"></div>
          </div>
          <div class="bars" id="bars"></div>
        </div>
        <div class="stageFooter">
          <div class="legend">
            <span><i class="key compare"></i> Compare</span>
            <span><i class="key swap"></i> Swap</span>
            <span><i class="key sorted"></i> Sorted tail</span>
          </div>
          <div class="small">Tip: Use Step to walk through the algorithm line by line. Speed adjusts animation pacing.</div>
        </div>
      </div>

      <div class="panel">
        <h2>Algorithm Insight</h2>
        <div class="stats">
          <div class="stat">
            <div class="big" id="comparisons">0</div>
            <div class="label">Comparisons</div>
          </div>
          <div class="stat">
            <div class="big" id="swaps">0</div>
            <div class="label">Swaps</div>
          </div>
          <div class="stat">
            <div class="big" id="passNum">0</div>
            <div class="label">Current pass</div>
          </div>
          <div class="stat">
            <div class="big" id="jIndex">—</div>
            <div class="label">Inner index j</div>
          </div>
          <div class="stat">
            <div class="big" id="sortedTail">0</div>
            <div class="label">Sorted tail length</div>
          </div>
          <div class="stat">
            <div class="big" id="elapsed">0.00s</div>
            <div class="label">Elapsed</div>
          </div>
        </div>
        <div class="explain" id="explain">Welcome! Generate a dataset and press Play to watch bubble sort in action.</div>
        <div class="divider"></div>
        <div class="code" id="codePanel">
          <pre id="codeStandard"><code>
<span class="line" data-ln="1">function bubbleSort(A):</span>
<span class="line" data-ln="2">  n = length(A)</span>
<span class="line" data-ln="3">  for pass from 0 to n - 1:</span>
<span class="line" data-ln="4">    for j from 0 to n - 2 - pass:</span>
<span class="line" data-ln="5">      if A[j] > A[j + 1]:</span>
<span class="line" data-ln="6">        swap(A, j, j + 1)</span>
          </code></pre>
          <pre id="codeOptimized" style="display:none;"><code>
<span class="line" data-ln="1">function bubbleSortOptimized(A):</span>
<span class="line" data-ln="2">  n = length(A)</span>
<span class="line" data-ln="3">  for pass from 0 to n - 1:</span>
<span class="line" data-ln="4">    swapped = false</span>
<span class="line" data-ln="5">    for j from 0 to n - 2 - pass:</span>
<span class="line" data-ln="6">      if A[j] > A[j + 1]:</span>
<span class="line" data-ln="7">        swap(A, j, j + 1)</span>
<span class="line" data-ln="8">        swapped = true</span>
<span class="line" data-ln="9">    if not swapped:</span>
<span class="line" data-ln="10">      break</span>
          </code></pre>
          <div class="footnotes">
            <div class="note">Invariant: after each pass k, the last k+1 elements are in final sorted position.</div>
            <div style="margin-top:8px;">
              • Worst / average time: O(n²) comparisons. Best (optimized on sorted input): O(n) with 0 swaps.<br/>
              • Stable? Yes. Bubble sort does not reorder equal elements relative to each other.<br/>
              • Space: O(1) extra space (in-place).
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  const barsEl = document.getElementById('bars');
  const pointerJEl = document.getElementById('pointerJ');

  const sizeRange = document.getElementById('sizeRange');
  const sizeLabel = document.getElementById('sizeLabel');
  const distributionSelect = document.getElementById('distribution');
  const customInput = document.getElementById('customInput');
  const generateBtn = document.getElementById('generateBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const speedRange = document.getElementById('speedRange');
  const speedLabel = document.getElementById('speedLabel');
  const algoSelect = document.getElementById('algoSelect');
  const showValues = document.getElementById('showValues');
  const showPointers = document.getElementById('showPointers');
  const autoFocus = document.getElementById('autoFocus');

  const playBtn = document.getElementById('playBtn');
  const stepBtn = document.getElementById('stepBtn');
  const resetBtn = document.getElementById('resetBtn');

  const comparisonsEl = document.getElementById('comparisons');
  const swapsEl = document.getElementById('swaps');
  const passNumEl = document.getElementById('passNum');
  const jIndexEl = document.getElementById('jIndex');
  const sortedTailEl = document.getElementById('sortedTail');
  const elapsedEl = document.getElementById('elapsed');
  const explainEl = document.getElementById('explain');

  const codeStandard = document.getElementById('codeStandard');
  const codeOptimized = document.getElementById('codeOptimized');
  const codePanel = document.getElementById('codePanel');

  let values = [];
  let initialValues = [];
  let steps = [];
  let isPlaying = false;
  let currentStep = -1;
  let comparisons = 0;
  let swaps = 0;
  let currentPass = 0;
  let sortedTail = 0;
  let t0 = 0;
  let rafTimer = null;

  // Visualization mappings
  let posToEl = []; // position index -> bar element
  let n = 0;

  // Utility
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

  function parseCustom(input) {
    const arr = input.split(/[,\s]+/).map(s=>s.trim()).filter(Boolean).map(Number).filter(n=>Number.isFinite(n));
    return arr.length ? arr : null;
  }

  function makeArray(size, distribution){
    const custom = parseCustom(customInput.value);
    if (custom) {
      return custom.slice();
    }
    let arr = [];
    switch(distribution){
      case 'random':
        for(let i=0;i<size;i++){ arr.push(randInt(5, 100)); }
        break;
      case 'reversed':
        for(let i=1;i<=size;i++){ arr.push(i); }
        arr.reverse();
        break;
      case 'nearly':
        for(let i=1;i<=size;i++){ arr.push(i); }
        // small perturbations
        const swaps = Math.max(1, Math.floor(size*0.15));
        for(let k=0;k<swaps;k++){
          const i = randInt(0, size-2);
          const j = i+1;
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        break;
      case 'few':
        const uniq = Math.max(3, Math.floor(size/6));
        const pool = Array.from({length: uniq}, ()=>randInt(10, 90));
        for(let i=0;i<size;i++){ arr.push(pool[randInt(0, pool.length-1)]); }
        break;
      default:
        for(let i=0;i<size;i++){ arr.push(randInt(5, 100)); }
    }
    return arr;
  }

  function buildSteps(arr, optimized){
    const local = arr.slice();
    const steps = [];
    let n = local.length;
    for(let pass=0; pass<n-1; pass++){
      let swappedThisPass = false;
      for(let j=0; j<n-1-pass; j++){
        steps.push({type:'compare', i:j, j:j+1, pass});
        if(local[j] > local[j+1]){
          [local[j], local[j+1]] = [local[j+1], local[j]];
          steps.push({type:'swap', i:j, j:j+1, pass});
          swappedThisPass = true;
        }
      }
      steps.push({type:'pass_end', sortedStart: n-1-pass, pass, swapped: swappedThisPass});
      if(optimized && !swappedThisPass){
        steps.push({type:'early_exit', pass});
        break;
      }
    }
    return steps;
  }

  function clearBars(){
    barsEl.innerHTML = '';
    posToEl = [];
  }

  function renderBars(arr){
    clearBars();
    n = arr.length;
    // compute scaling
    const maxVal = Math.max(...arr);
    const minVal = Math.min(...arr);
    const minH = 20;
    const padH = 6;
    for(let i=0;i<n;i++){
      const val = arr[i];
      const h = minH + Math.round((val - minVal)/(maxVal - minVal || 1) * (barsEl.clientHeight - 80));
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.style.height = h + 'px';
      bar.style.order = i;
      bar.dataset.value = val;
      bar.dataset.id = i; // identity
      if(showValues.checked){
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = val;
        bar.appendChild(label);
      }
      barsEl.appendChild(bar);
      posToEl[i] = bar;
    }
    updatePointerVisibility();
  }

  function updateBarLabels(){
    for(const bar of posToEl){
      const label = bar.querySelector('.label');
      if(showValues.checked){
        if(!label){
          const lbl = document.createElement('div');
          lbl.className = 'label';
          lbl.textContent = bar.dataset.value;
          bar.appendChild(lbl);
        } else {
          label.textContent = bar.dataset.value;
        }
      } else {
        if(label) label.remove();
      }
    }
  }

  function resetState(){
    isPlaying = false;
    currentStep = -1;
    comparisons = 0;
    swaps = 0;
    currentPass = 0;
    sortedTail = 0;
    t0 = performance.now();
    updateStats();
    explainEl.textContent = 'Ready. Press Play to animate bubble sort, or Step to advance one operation.';
    clearHighlights();
    playBtn.textContent = 'Play';
  }

  function generate(){
    const size = Number(sizeRange.value);
    const dist = distributionSelect.value;
    const arr = makeArray(size, dist);
    values = arr.slice();
    initialValues = arr.slice();
    const optimized = algoSelect.value === 'optimized';
    steps = buildSteps(arr, optimized);
    renderBars(arr);
    markSortedTail(0);
    resetState();
    highlightCodeLine(optimized ? 1 : 1, true); // line 1 header
  }

  function shuffle(){
    if(!initialValues.length) return;
    const arr = initialValues.slice();
    // Fisher-Yates
    for(let i=arr.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    values = arr.slice();
    initialValues = arr.slice();
    const optimized = algoSelect.value === 'optimized';
    steps = buildSteps(arr, optimized);
    renderBars(arr);
    markSortedTail(0);
    resetState();
  }

  function flipSwap(i, j, durationMs){
    const allBars = posToEl.slice();
    const before = new Map();
    allBars.forEach(el => {
      const rect = el.getBoundingClientRect();
      before.set(el, rect.left);
    });

    // swap orders
    const elI = posToEl[i];
    const elJ = posToEl[j];
    elI.style.order = j;
    elJ.style.order = i;
    // update mapping
    [posToEl[i], posToEl[j]] = [posToEl[j], posToEl[i]];

    const after = new Map();
    allBars.forEach(el=>{
      const rect = el.getBoundingClientRect();
      after.set(el, rect.left);
    });

    // animate via FLIP
    const d = durationMs || stepDuration();
    allBars.forEach(el=>{
      const dx = before.get(el) - after.get(el);
      if(Math.abs(dx) > 0.5){
        el.style.transition = 'transform '+ (d/1000)+'s ease';
        el.style.transform = 'translateX('+dx+'px)';
        void el.offsetWidth; // reflow
        el.style.transform = 'translateX(0)';
      } else {
        el.style.transition = '';
        el.style.transform = '';
      }
    });
  }

  function stepDuration(){
    // speedRange 0..100 => 0.3x..2.0x
    const s = Number(speedRange.value);
    const factor = 0.3 + (s/100)*(2.0-0.3);
    // base unit durations in ms
    const base = 550;
    return Math.round(base / factor);
  }

  function setPlayState(play){
    isPlaying = play;
    playBtn.textContent = play ? 'Pause' : 'Play';
    if(play){
      t0 = performance.now() - timeMs;
      runLoop();
    } else {
      if(rafTimer){ clearTimeout(rafTimer); rafTimer = null; }
    }
  }

  let timeMs = 0;
  function updateElapsed(){
    timeMs = performance.now() - t0;
    elapsedEl.textContent = (timeMs/1000).toFixed(2)+'s';
  }

  function runLoop(){
    if(rafTimer){ clearTimeout(rafTimer); rafTimer = null; }
    if(currentStep >= steps.length-1){
      setPlayState(false);
      explainEl.textContent = 'Finished! Array is sorted. You can Reset, Shuffle, or Generate a new dataset.';
      return;
    }
    const d = stepDuration();
    processNextStep();
    updateElapsed();
    rafTimer = setTimeout(()=>runLoop(), d);
  }

  function clearHighlights(){
    posToEl.forEach(el=>{
      el.classList.remove('compare','swap');
    });
    updatePointerVisibility();
    highlightCodeLine(null, false);
  }

  function markSortedTail(len){
    // len is number of elements at end sorted
    const total = posToEl.length;
    for(let idx=0; idx<total; idx++){
      const el = posToEl[idx];
      const isSortedTail = idx >= total - len;
      el.classList.toggle('sorted', isSortedTail);
    }
    sortedTailEl.textContent = len;
  }

  function focusBars(i, j){
    posToEl.forEach(el=>{
      if(autoFocus.checked){
        el.style.opacity = 0.5;
      } else {
        el.style.opacity = 1.0;
      }
    });
    if(i!=null) posToEl[i].style.opacity = 1.0;
    if(j!=null) posToEl[j].style.opacity = 1.0;
  }

  function updatePointer(j){
    if(!showPointers.checked){
      pointerJEl.style.display = 'none';
      return;
    }
    if(j == null){ pointerJEl.style.display = 'none'; return; }
    const bar = posToEl[j];
    if(!bar){ pointerJEl.style.display = 'none'; return; }
    const rect = bar.getBoundingClientRect();
    const containerRect = barsEl.getBoundingClientRect();
    const x = rect.left - containerRect.left + rect.width/2;
    pointerJEl.style.display = 'block';
    pointerJEl.style.left = x+'px';
  }
  function updatePointerVisibility(){
    if(!showPointers.checked){ pointerJEl.style.display = 'none'; }
  }

  function explainStep(step){
    if(!step){
      explainEl.textContent = 'Ready. Generate data and start the animation.';
      return;
    }
    switch(step.type){
      case 'compare':
        explainEl.textContent = `Compare A[${step.i}] and A[${step.j}]. If left > right, swap to push the larger value rightward.`;
        break;
      case 'swap':
        explainEl.textContent = `Swap A[${step.i}] and A[${step.j}] to move the larger element toward the end. Bubble sort repeatedly bubbles the largest of the unsorted region.`;
        break;
      case 'pass_end':
        explainEl.textContent = `Pass ${step.pass} completed. Now the last ${stepsSortedTailFromPass(step.pass)} element(s) are in final position. Next pass focuses on the remaining unsorted prefix.`;
        break;
      case 'early_exit':
        explainEl.textContent = `No swaps in the last pass: array is already sorted. Optimized bubble sort exits early.`;
        break;
      default:
        explainEl.textContent = '';
    }
  }

  function stepsSortedTailFromPass(pass){
    // After pass p, tail length = p + 1
    return Math.min(values.length, pass + 1);
  }

  function highlightCodeLine(ln, focusHeader){
    const optimized = algoSelect.value === 'optimized';
    const pre = optimized ? codeOptimized : codeStandard;
    const other = optimized ? codeStandard : codeOptimized;
    pre.style.display = 'block';
    other.style.display = 'none';
    const lines = pre.querySelectorAll('.line');
    lines.forEach(x=> x.classList.remove('hl'));
    if(ln != null){
      const el = pre.querySelector('.line[data-ln="'+ln+'"]');
      if(el) el.classList.add('hl');
    } else if(focusHeader) {
      const el = pre.querySelector('.line[data-ln="1"]');
      if(el) el.classList.add('hl');
    }
  }

  function mapStepToCode(step){
    const optimized = algoSelect.value === 'optimized';
    if(!step) return null;
    if(!optimized){
      switch(step.type){
        case 'compare': return 5; // if
        case 'swap': return 6; // swap
        case 'pass_end': return 3; // outer loop (end)
        default: return null;
      }
    } else {
      switch(step.type){
        case 'compare': return 6;
        case 'swap': return 7; // swap
        case 'pass_end': return 3;
        case 'early_exit': return 9;
        default: return null;
      }
    }
  }

  function processNextStep(){
    if(currentStep >= steps.length-1) return;
    currentStep++;
    const step = steps[currentStep];
    clearHighlights();

    switch(step.type){
      case 'compare': {
        comparisons++;
        focusBars(step.i, step.j);
        posToEl[step.i].classList.add('compare');
        posToEl[step.j].classList.add('compare');
        updatePointer(step.i);
        currentPass = step.pass;
        jIndexEl.textContent = step.i;
        passNumEl.textContent = step.pass;
        explainStep(step);
        break;
      }
      case 'swap': {
        swaps++;
        focusBars(step.i, step.j);
        posToEl[step.i].classList.add('swap');
        posToEl[step.j].classList.add('swap');
        flipSwap(step.i, step.j, stepDuration());
        updatePointer(step.i);
        currentPass = step.pass;
        jIndexEl.textContent = step.i;
        passNumEl.textContent = step.pass;
        explainStep(step);
        break;
      }
      case 'pass_end': {
        currentPass = step.pass;
        jIndexEl.textContent = '—';
        sortedTail = stepsSortedTailFromPass(step.pass);
        markSortedTail(sortedTail);
        focusBars(null, null);
        updatePointer(null);
        explainStep(step);
        break;
      }
      case 'early_exit': {
        focusBars(null, null);
        updatePointer(null);
        explainStep(step);
        break;
      }
    }
    updateStats();
    const ln = mapStepToCode(step);
    highlightCodeLine(ln, false);
  }

  function updateStats(){
    comparisonsEl.textContent = comparisons;
    swapsEl.textContent = swaps;
    passNumEl.textContent = currentPass;
    sortedTailEl.textContent = sortedTail;
  }

  // Events and UI wiring
  sizeRange.addEventListener('input', ()=>{
    sizeLabel.textContent = sizeRange.value;
  });

  speedRange.addEventListener('input', ()=>{
    const s = Number(speedRange.value);
    const factor = 0.3 + (s/100)*(2.0-0.3);
    speedLabel.textContent = `${factor.toFixed(1)}x`;
  });

  generateBtn.addEventListener('click', ()=>{
    generate();
  });
  shuffleBtn.addEventListener('click', ()=>{
    shuffle();
  });

  showValues.addEventListener('change', updateBarLabels);
  showPointers.addEventListener('change', updatePointerVisibility);
  algoSelect.addEventListener('change', ()=>{
    // rebuild steps but keep current values order
    const arr = [];
    // We need current logical array order equal to current visual order:
    // Build arr from current positions' values.
    for(let i=0;i<posToEl.length;i++){
      arr.push(Number(posToEl[i].dataset.value));
    }
    steps = buildSteps(arr, algoSelect.value === 'optimized');
    resetState();
    highlightCodeLine(1, true);
    // Update code panel visible section is handled in highlight function.
  });

  playBtn.addEventListener('click', ()=>{
    if(!steps.length){ generate(); }
    setPlayState(!isPlaying);
  });

  stepBtn.addEventListener('click', ()=>{
    if(!steps.length){ generate(); }
    if(isPlaying){ setPlayState(false); }
    processNextStep();
    updateElapsed();
  });

  resetBtn.addEventListener('click', ()=>{
    if(!initialValues.length){
      generate();
      return;
    }
    // Reset visual order to match initialValues (unsorted)
    values = initialValues.slice();
    renderBars(values);
    markSortedTail(0);
    const optimized = algoSelect.value === 'optimized';
    steps = buildSteps(values, optimized);
    resetState();
  });

  // Initialize defaults
  generate();

  // Accessibility: space toggles play
  window.addEventListener('keydown', (e)=>{
    if(e.key === ' '){
      e.preventDefault();
      playBtn.click();
    }
    if(e.key === 'ArrowRight'){
      e.preventDefault();
      stepBtn.click();
    }
  });

  // Responsiveness: update pointer on resize
  window.addEventListener('resize', ()=>{
    const current = steps[currentStep];
    if(current && current.type === 'compare'){
      updatePointer(current.i);
    } else {
      updatePointer(null);
    }
  });

})();
</script>
</body>
</html>