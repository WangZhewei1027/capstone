<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bubble Sort Visualization</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f1420;
      --panel: #161b29;
      --text: #e8ecf1;
      --muted: #9aa7b7;
      --accent: #4ac1ff;
      --accent-2: #7cff83;
      --warning: #ffc857;
      --danger: #ff6b6b;
      --bar: #5a76ff;
      --bar-hover: #7d93ff;
    }

    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 600px at 20% 0%, #141a28 0%, #0f1420 40%, #0b101a 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    header {
      padding: 16px 20px 4px;
      display: flex;
      align-items: baseline;
      gap: 12px;
      flex-wrap: wrap;
    }
    header h1 {
      font-size: 1.25rem;
      margin: 0;
      letter-spacing: 0.3px;
    }
    header .subtitle {
      color: var(--muted);
      font-size: 0.95rem;
    }

    .toolbar {
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.07);
      border-radius: 12px;
      margin: 12px 20px;
      padding: 12px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(3, minmax(220px, 1fr));
      gap: 10px;
    }
    .control-group {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.07);
      border-radius: 10px;
      padding: 10px;
    }
    .control-group h3 {
      margin: 0 0 8px 0;
      font-size: 0.9rem;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0.2px;
    }
    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    label {
      font-size: 0.9rem;
      color: var(--text);
    }
    input[type="range"] {
      width: 160px;
    }
    input[type="number"] {
      width: 80px;
      background: #0e1421;
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--text);
      border-radius: 8px;
      padding: 6px 8px;
    }
    select {
      background: #0e1421;
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--text);
      border-radius: 8px;
      padding: 8px;
      min-width: 160px;
    }
    .buttons {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
    }
    button {
      appearance: none;
      background: var(--accent);
      color: #06111a;
      border: none;
      border-radius: 10px;
      font-weight: 700;
      padding: 10px 14px;
      cursor: pointer;
      transition: transform 120ms ease, filter 120ms ease;
    }
    button.secondary {
      background: #26314b;
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.1);
      font-weight: 600;
    }
    button.warning { background: var(--warning); }
    button.danger { background: var(--danger); color: #1b0a0a; }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button:hover { filter: brightness(1.05); transform: translateY(-1px); }

    .viz-wrap {
      margin: 12px 20px;
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.07);
      border-radius: 12px;
      padding: 12px;
    }

    .stats {
      display: flex;
      gap: 18px;
      flex-wrap: wrap;
      padding: 8px 4px 14px;
      border-bottom: 1px dashed rgba(255,255,255,0.1);
      font-size: 0.95rem;
    }
    .stat {
      display: flex;
      gap: 6px;
      align-items: baseline;
    }
    .stat .label { color: var(--muted); }
    .stat .value { font-weight: 700; color: var(--accent-2); }

    .bars {
      position: relative;
      height: 320px;
      display: flex;
      align-items: flex-end;
      gap: 2px;
      padding: 14px 6px 12px;
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      overflow: hidden;
    }
    .bar {
      position: relative;
      flex: 1 1 auto;
      min-width: 4px;
      background: linear-gradient(180deg, var(--bar), #4b61e6);
      border-radius: 5px 5px 0 0;
      transition: height 180ms ease, filter 120ms ease, transform 120ms ease, background 120ms ease;
    }
    .bar:hover {
      filter: brightness(1.12);
      transform: translateY(-2px);
    }
    .bar::after {
      content: attr(data-value);
      position: absolute;
      bottom: -22px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      color: var(--muted);
      opacity: 0.75;
      pointer-events: none;
    }
    .bar.compare {
      background: linear-gradient(180deg, #f6c76e, #e8b249);
      box-shadow: 0 0 0 2px rgba(255, 200, 87, 0.4);
    }
    .bar.swap {
      background: linear-gradient(180deg, #ff6b6b, #f04646);
      box-shadow: 0 0 0 2px rgba(255, 107, 107, 0.4);
    }
    .bar.sorted {
      background: linear-gradient(180deg, #59d987, #3ac16c);
      box-shadow: 0 0 0 1px rgba(92, 217, 135, 0.35);
      opacity: 0.95;
    }
    .bar.equal {
      outline: 1px dashed rgba(255,255,255,0.25);
    }

    .legend {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      padding: 8px 4px 0;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .legend .chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 8px;
    }
    .legend .color {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.2);
    }
    .color.compare { background: #f6c76e; }
    .color.swap { background: #ff6b6b; }
    .color.sorted { background: #3ac16c; }

    details {
      margin: 14px 20px 24px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 12px 14px;
    }
    summary {
      cursor: pointer;
      font-weight: 700;
      color: var(--text);
    }
    .explain {
      color: var(--muted);
      line-height: 1.6;
      margin-top: 8px;
      font-size: 0.95rem;
    }

    .note {
      font-size: 0.9rem;
      color: var(--muted);
      padding-left: 4px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Bubble Sort</h1>
    <div class="subtitle">Interactive visualization with step-by-step actions</div>
  </header>

  <section class="toolbar">
    <div class="controls">
      <div class="control-group">
        <h3>Array</h3>
        <div class="row">
          <label for="size">Size</label>
          <input id="size" type="range" min="5" max="120" value="40" />
          <input id="sizeNumber" type="number" min="5" max="120" value="40" />
        </div>
        <div class="row" style="margin-top: 8px;">
          <label for="dataset">Distribution</label>
          <select id="dataset">
            <option value="random" selected>Random</option>
            <option value="nearly">Nearly sorted</option>
            <option value="reversed">Reversed</option>
            <option value="few-unique">Few unique values (duplicates)</option>
          </select>
        </div>
      </div>

      <div class="control-group">
        <h3>Sorting</h3>
        <div class="row">
          <label for="order">Order</label>
          <select id="order">
            <option value="asc" selected>Ascending</option>
            <option value="desc">Descending</option>
          </select>
        </div>
        <div class="row" style="margin-top: 8px;">
          <label for="speed">Speed</label>
          <input id="speed" type="range" min="0" max="100" value="60" />
          <span class="note" id="speedNote">Medium</span>
        </div>
      </div>

      <div class="control-group">
        <h3>Controls</h3>
        <div class="row">
          <button id="generate" class="secondary">Generate Array</button>
          <button id="start">Start</button>
          <button id="pause" class="warning" disabled>Pause</button>
          <button id="step" class="secondary">Step</button>
          <button id="reset" class="danger">Reset</button>
        </div>
        <div class="row" style="margin-top: 8px;">
          <span class="note">Tip: Use Step to advance one action (compare/swap/mark) at a time.</span>
        </div>
      </div>
    </div>

    <div class="legend">
      <span class="chip"><span class="color compare"></span>Comparing</span>
      <span class="chip"><span class="color swap"></span>Swap</span>
      <span class="chip"><span class="color sorted"></span>Sorted</span>
    </div>
  </section>

  <section class="viz-wrap">
    <div class="stats">
      <div class="stat"><span class="label">Status:</span><span class="value" id="status">Ready</span></div>
      <div class="stat"><span class="label">Pass:</span><span class="value" id="pass">0</span></div>
      <div class="stat"><span class="label">Comparisons:</span><span class="value" id="comparisons">0</span></div>
      <div class="stat"><span class="label">Swaps:</span><span class="value" id="swaps">0</span></div>
      <div class="stat"><span class="label">Array Size:</span><span class="value" id="sizeStat">40</span></div>
      <div class="stat"><span class="label">Complexity:</span><span class="value">O(n^2)</span></div>
      <div class="stat"><span class="label">Stability:</span><span class="value">Stable</span></div>
    </div>
    <div class="bars" id="bars" aria-label="Bubble sort array visualization"></div>
  </section>

  <details>
    <summary>What is Bubble Sort?</summary>
    <div class="explain">
      Bubble Sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. Each pass pushes the largest (or smallest) unsorted element towards its final position, like bubbles rising to the top.
      - Time complexity: Best O(n) (already sorted, with early-exit), Average/Worst O(n^2).
      - Space complexity: O(1) in-place.
      - Stability: Yes — equal elements keep their relative order.
      This demo shows each compare and swap, highlights the sorted boundary after each pass, and allows you to step through the algorithm interactively.
    </div>
  </details>

  <script>
    // Bubble Sort Visualization
    // Core state
    let arr = [];
    let maxValue = 100;
    let playing = false;
    let gen = null;
    let actionTimer = null;
    let comparisons = 0;
    let swaps = 0;
    let passes = 0;
    let ascending = true;

    // Elements
    const barsEl = document.getElementById('bars');
    const sizeRange = document.getElementById('size');
    const sizeNumber = document.getElementById('sizeNumber');
    const datasetSelect = document.getElementById('dataset');
    const orderSelect = document.getElementById('order');
    const speedRange = document.getElementById('speed');
    const speedNote = document.getElementById('speedNote');
    const btnGenerate = document.getElementById('generate');
    const btnStart = document.getElementById('start');
    const btnPause = document.getElementById('pause');
    const btnStep = document.getElementById('step');
    const btnReset = document.getElementById('reset');

    const statusEl = document.getElementById('status');
    const passEl = document.getElementById('pass');
    const compEl = document.getElementById('comparisons');
    const swapsEl = document.getElementById('swaps');
    const sizeStatEl = document.getElementById('sizeStat');

    // Utility: speed mapping
    function getDelayFromSpeed() {
      const v = Number(speedRange.value); // 0..100
      // Map: 0 (instant) to 100 (slow). Use non-linear to give more control in mid range
      if (v === 0) return 0;
      const ms = 10 + Math.pow(v, 1.7) * 0.08; // approx 10.. ~800ms
      return Math.round(ms);
    }
    function updateSpeedNote() {
      const v = Number(speedRange.value);
      let note = 'Instant';
      if (v <= 15) note = 'Very fast';
      else if (v <= 35) note = 'Fast';
      else if (v <= 60) note = 'Medium';
      else if (v <= 80) note = 'Slow';
      else note = 'Very slow';
      speedNote.textContent = note;
    }

    // Data generation
    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function generateArray(size, type = 'random') {
      const a = new Array(size);
      maxValue = Math.max(20, Math.round(size * 2.2)); // scale values with size to keep bar distribution nice
      if (type === 'random') {
        for (let i = 0; i < size; i++) a[i] = randomInt(5, maxValue);
      } else if (type === 'reversed') {
        for (let i = 0; i < size; i++) a[i] = Math.round(((size - i) / size) * maxValue);
      } else if (type === 'nearly') {
        // Start sorted ascending then perform a few random swaps
        for (let i = 0; i < size; i++) a[i] = Math.round(((i + 1) / size) * maxValue);
        const swaps = Math.max(1, Math.round(size * 0.08));
        for (let s = 0; s < swaps; s++) {
          const i = randomInt(0, size - 1);
          const j = randomInt(0, size - 1);
          [a[i], a[j]] = [a[j], a[i]];
        }
      } else if (type === 'few-unique') {
        // Only a handful of unique values to show stability with duplicates
        const uniq = [10, 25, 40, 55, 70, 85, maxValue];
        for (let i = 0; i < size; i++) a[i] = uniq[randomInt(0, uniq.length - 1)];
      } else {
        for (let i = 0; i < size; i++) a[i] = randomInt(5, maxValue);
      }
      return a;
    }

    // Rendering
    function renderBars(array) {
      barsEl.innerHTML = '';
      const n = array.length;
      const max = Math.max(...array, maxValue);
      for (let i = 0; i < n; i++) {
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.style.height = `${Math.round((array[i] / max) * 100)}%`;
        bar.dataset.value = array[i];
        bar.title = `Index ${i} • Value ${array[i]}`;
        barsEl.appendChild(bar);
      }
    }
    function updateBarHeight(index, value) {
      const bar = barsEl.children[index];
      if (!bar) return;
      const max = Math.max(...arr, maxValue);
      bar.style.height = `${Math.round((value / max) * 100)}%`;
      bar.dataset.value = value;
      bar.title = `Index ${index} • Value ${value}`;
    }
    function clearHighlights() {
      for (const el of barsEl.children) {
        el.classList.remove('compare', 'swap', 'equal');
      }
    }
    function markSorted(index) {
      const bar = barsEl.children[index];
      if (bar) bar.classList.add('sorted');
    }
    function clearSorted() {
      for (const el of barsEl.children) el.classList.remove('sorted');
    }

    // Generator for bubble sort steps
    function* bubbleSortGenerator(a, asc = true) {
      const n = a.length;
      if (n <= 1) {
        yield { type: 'done' };
        return;
      }
      for (let i = 0; i < n - 1; i++) {
        let swapped = false;
        for (let j = 0; j < n - 1 - i; j++) {
          const left = a[j], right = a[j + 1];
          yield { type: 'compare', i, j, indices: [j, j + 1], values: [left, right] };
          const inOrder = asc ? left <= right : left >= right;
          if (!inOrder) {
            // swap in data
            [a[j], a[j + 1]] = [a[j + 1], a[j]];
            swapped = true;
            yield { type: 'swap', i, j, indices: [j, j + 1], values: [a[j], a[j + 1]] };
          }
        }
        // pass complete: the boundary at n-1-i is now sorted
        yield { type: 'passComplete', pass: i + 1, boundaryIndex: n - 1 - i };
        yield { type: 'markSorted', index: n - 1 - i };
        if (!swapped) {
          // Already sorted. Mark remaining as sorted and finish.
          for (let k = 0; k < n - 1 - i; k++) {
            yield { type: 'markSorted', index: k };
          }
          break;
        }
      }
      // Ensure all sorted (in case of final element not marked)
      for (let k = 0; k < a.length; k++) {
        yield { type: 'markSorted', index: k };
      }
      yield { type: 'done' };
    }

    // Apply an action to the UI/state
    function applyAction(action, instant = false) {
      const delay = instant ? 0 : getDelayFromSpeed();
      clearHighlights();

      if (action.type === 'compare') {
        comparisons++;
        compEl.textContent = String(comparisons);
        const [i1, i2] = action.indices;
        const b1 = barsEl.children[i1];
        const b2 = barsEl.children[i2];
        if (b1 && b2) {
          b1.classList.add('compare');
          b2.classList.add('compare');
          if (action.values && action.values[0] === action.values[1]) {
            b1.classList.add('equal');
            b2.classList.add('equal');
          }
        }
        statusEl.textContent = `Comparing indices ${i1} and ${i2}`;
      }

      if (action.type === 'swap') {
        swaps++;
        swapsEl.textContent = String(swaps);
        const [i1, i2] = action.indices;
        const [v1, v2] = action.values;
        const b1 = barsEl.children[i1];
        const b2 = barsEl.children[i2];
        if (b1 && b2) {
          b1.classList.add('swap');
          b2.classList.add('swap');
        }
        // Update heights to reflect new values
        updateBarHeight(i1, v1);
        updateBarHeight(i2, v2);
        statusEl.textContent = `Swapped indices ${i1} and ${i2}`;
      }

      if (action.type === 'passComplete') {
        passes = action.pass;
        passEl.textContent = String(passes);
        statusEl.textContent = `Pass ${passes} complete (sorted boundary at index ${action.boundaryIndex})`;
      }

      if (action.type === 'markSorted') {
        markSorted(action.index);
      }

      if (action.type === 'done') {
        playing = false;
        btnPause.disabled = true;
        btnStart.disabled = false;
        btnStep.disabled = false;
        statusEl.textContent = 'Sorted!';
      }

      return new Promise(res => setTimeout(res, delay));
    }

    async function runAuto() {
      if (!gen) gen = bubbleSortGenerator(arr.slice(), ascending);
      playing = true;
      btnStart.disabled = true;
      btnPause.disabled = false;
      btnStep.disabled = true;
      statusEl.textContent = 'Sorting...';
      for (;;) {
        if (!playing) break;
        const { value: action, done } = gen.next();
        if (done || !action) {
          await applyAction({ type: 'done' }, false);
          break;
        }
        await applyAction(action, false);
      }
    }

    async function stepOnce() {
      if (!gen) gen = bubbleSortGenerator(arr.slice(), ascending);
      const { value: action, done } = gen.next();
      if (done || !action) {
        await applyAction({ type: 'done' }, true);
        return;
      }
      await applyAction(action, true);
    }

    // Reset state
    function resetState() {
      playing = false;
      gen = null;
      comparisons = 0;
      swaps = 0;
      passes = 0;
      compEl.textContent = '0';
      swapsEl.textContent = '0';
      passEl.textContent = '0';
      clearHighlights();
      clearSorted();
      statusEl.textContent = 'Ready';
      btnStart.disabled = false;
      btnPause.disabled = true;
      btnStep.disabled = false;
    }

    // Init array
    function initArray() {
      const size = Number(sizeRange.value);
      arr = generateArray(size, datasetSelect.value);
      sizeStatEl.textContent = String(size);
      renderBars(arr);
      clearSorted();
    }

    // Event wiring
    sizeRange.addEventListener('input', () => {
      sizeNumber.value = sizeRange.value;
      sizeStatEl.textContent = sizeRange.value;
    });
    sizeRange.addEventListener('change', () => {
      resetState();
      initArray();
    });
    sizeNumber.addEventListener('change', () => {
      let v = Number(sizeNumber.value);
      v = Math.max(Number(sizeNumber.min), Math.min(Number(sizeNumber.max), v));
      sizeNumber.value = String(v);
      sizeRange.value = String(v);
      sizeStatEl.textContent = String(v);
      resetState();
      initArray();
    });

    datasetSelect.addEventListener('change', () => {
      resetState();
      initArray();
    });

    orderSelect.addEventListener('change', () => {
      ascending = orderSelect.value === 'asc';
      // no automatic sort start; just update state
      statusEl.textContent = `Order: ${ascending ? 'Ascending' : 'Descending'}`;
      // Reset generator to reflect the new order if sorting hasn't started
      gen = null;
    });

    speedRange.addEventListener('input', updateSpeedNote);

    btnGenerate.addEventListener('click', () => {
      resetState();
      initArray();
    });

    btnStart.addEventListener('click', () => {
      if (playing) return;
      runAuto();
    });

    btnPause.addEventListener('click', () => {
      playing = false;
      btnPause.disabled = true;
      btnStart.disabled = false;
      btnStep.disabled = false;
      statusEl.textContent = 'Paused';
    });

    btnStep.addEventListener('click', () => {
      if (playing) return;
      stepOnce();
    });

    btnReset.addEventListener('click', () => {
      resetState();
      initArray();
    });

    // Bootstrap
    updateSpeedNote();
    ascending = orderSelect.value === 'asc';
    initArray();

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === ' ') { // space toggles start/pause
        e.preventDefault();
        if (playing) btnPause.click();
        else btnStart.click();
      } else if (e.key.toLowerCase() === 's') {
        e.preventDefault();
        btnStep.click();
      } else if (e.key.toLowerCase() === 'r') {
        e.preventDefault();
        btnReset.click();
      } else if (e.key.toLowerCase() === 'g') {
        e.preventDefault();
        btnGenerate.click();
      }
    });

    // Accessibility note in status
    statusEl.textContent = 'Ready';
  </script>
</body>
</html>