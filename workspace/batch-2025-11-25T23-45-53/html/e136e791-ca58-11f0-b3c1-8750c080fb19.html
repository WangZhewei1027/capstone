<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red-Black Tree Visualization</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin-top: 20px;
        }
        #tree-container {
            display: flex;
            justify-content: center;
            position: relative;
            width: 100%;
            height: 400px;
            overflow: hidden;
        }
        .node {
            text-align: center;
            border-radius: 50%;
            padding: 10px;
            margin: 5px;
            position: absolute;
        }
        .red {
            background-color: red;
            color: white;
        }
        .black {
            background-color: black;
            color: white;
        }
        .line {
            position: absolute;
            width: 2px;
            background: black;
        }
        input {
            margin: 10px;
        }
    </style>
</head>
<body>

<h1>Red-Black Tree Visualization</h1>
<input type="number" id="valueInput" placeholder="Enter a number" />
<button onclick="insert()">Insert</button>
<div id="tree-container"></div>

<script>
    class Node {
        constructor(data) {
            this.data = data;
            this.color = 'red'; // New nodes are red by default
            this.left = null;
            this.right = null;
            this.parent = null;
        }
    }

    class RedBlackTree {
        constructor() {
            this.root = null;
        }

        insert(data) {
            let newNode = new Node(data);
            if (!this.root) {
                newNode.color = 'black'; // Root should be black
                this.root = newNode;
            } else {
                this._insertNode(this.root, newNode);
                this.fixViolations(newNode);
            }
        }

        _insertNode(root, newNode) {
            if (newNode.data < root.data) {
                if (!root.left) {
                    root.left = newNode;
                    newNode.parent = root;
                } else {
                    this._insertNode(root.left, newNode);
                }
            } else {
                if (!root.right) {
                    root.right = newNode;
                    newNode.parent = root;
                } else {
                    this._insertNode(root.right, newNode);
                }
            }
        }

        fixViolations(node) {
            while (node !== this.root && node.parent.color === 'red') {
                if (node.parent == node.parent.parent.left) {
                    let uncle = node.parent.parent.right;
                    if (uncle && uncle.color === 'red') {
                        node.parent.color = 'black';
                        uncle.color = 'black';
                        node.parent.parent.color = 'red';
                        node = node.parent.parent;
                    } else {
                        if (node == node.parent.right) {
                            node = node.parent;
                            this.rotateLeft(node);
                        }
                        node.parent.color = 'black';
                        node.parent.parent.color = 'red';
                        this.rotateRight(node.parent.parent);
                    }
                } else {
                    let uncle = node.parent.parent.left;
                    if (uncle && uncle.color === 'red') {
                        node.parent.color = 'black';
                        uncle.color = 'black';
                        node.parent.parent.color = 'red';
                        node = node.parent.parent;
                    } else {
                        if (node == node.parent.left) {
                            node = node.parent;
                            this.rotateRight(node);
                        }
                        node.parent.color = 'black';
                        node.parent.parent.color = 'red';
                        this.rotateLeft(node.parent.parent);
                    }
                }
            }
            this.root.color = 'black';
        }

        rotateLeft(node) {
            let rightNode = node.right;
            node.right = rightNode.left;
            if (rightNode.left) rightNode.left.parent = node;

            rightNode.parent = node.parent;
            if (!node.parent) {
                this.root = rightNode;
            } else if (node == node.parent.left) {
                node.parent.left = rightNode;
            } else {
                node.parent.right = rightNode;
            }
            rightNode.left = node;
            node.parent = rightNode;
        }

        rotateRight(node) {
            let leftNode = node.left;
            node.left = leftNode.right;
            if (leftNode.right) leftNode.right.parent = node;

            leftNode.parent = node.parent;
            if (!node.parent) {
                this.root = leftNode;
            } else if (node == node.parent.right) {
                node.parent.right = leftNode;
            } else {
                node.parent.left = leftNode;
            }
            leftNode.right = node;
            node.parent = leftNode;
        }

        display(node, x, y, layer, offset) {
            if (!node) return;

            const nodeElement = document.createElement('div');
            nodeElement.className = `node ${node.color}`;
            nodeElement.innerText = node.data;
            nodeElement.style.left = `${x}px`;
            nodeElement.style.top = `${y}px`;
            document.getElementById('tree-container').appendChild(nodeElement);

            // Draw lines
            if (node.parent) {
                const line = document.createElement('div');
                line.className = 'line';
                line.style.height = '2px';
                line.style.left = `${(x + (node.parent.left ? 0 : offset / 2))}px`;
                line.style.top = `${y + 20}px`;
                line.style.width = `${offset}px`;
                document.getElementById('tree-container').appendChild(line);
            }

            const newLayer = layer + 1;
            const newOffset = offset / 2;
            this.display(node.left, x - newOffset, y + 80, newLayer, newOffset);
            this.display(node.right, x + newOffset, y + 80, newLayer, newOffset);
        }
    }

    const tree = new RedBlackTree();

    function insert() {
        const valueInput = document.getElementById('valueInput');
        const value = parseInt(valueInput.value);
        if (!isNaN(value)) {
            tree.insert(value);
            valueInput.value = '';
            document.getElementById('tree-container').innerHTML = '';
            tree.display(tree.root, window.innerWidth / 2, 20, 0, 200);
        }
    }
</script>

</body>
</html>