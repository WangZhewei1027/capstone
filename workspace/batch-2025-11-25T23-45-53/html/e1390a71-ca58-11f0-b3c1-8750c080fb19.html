<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Nearest Neighbors (KNN) Demo</title>
    <style>
        body { font-family: Arial, sans-serif; }
        #chart { width: 600px; height: 400px; border: 1px solid #ccc; position: relative; }
        .point { position: absolute; border-radius: 50%; cursor: pointer; }
        .point.labelA { background: blue; }
        .point.labelB { background: red; }
        .point.newPoint { border: 2px solid green; }
        .knn { outline: 2px dashed yellow; }
    </style>
</head>
<body>

<h1>K-Nearest Neighbors (KNN) Demonstration</h1>
<p>Click on the chart to add points. The blue points belong to class A and the red points belong to class B. Click on the "Classify New Point" button to classify a new point based on the KNN algorithm.</p>

<div id="chart"></div>
<button onclick="classifyNewPoint()">Classify New Point</button>

<script>
    const points = [];
    let newPoint = null;
    const K = 3;

    const chart = document.getElementById('chart');
    
    chart.addEventListener('click', (event) => {
        const rect = chart.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        const label = points.length % 2 === 0 ? 'A' : 'B';
        addPoint(x, y, label);
    });

    function addPoint(x, y, label) {
        points.push({x, y, label});
        renderPoint(x, y, label);
    }

    function renderPoint(x, y, label) {
        const point = document.createElement('div');
        point.classList.add('point', `label${label}`, `point-(${x}-${y})`);
        point.style.left = `${x}px`;
        point.style.top = `${y}px`;
        point.style.width = '10px';
        point.style.height = '10px';
        chart.appendChild(point);
    }

    function classifyNewPoint() {
        if (!newPoint) {
            // Generate a random new point
            newPoint = {
                x: Math.random() * chart.clientWidth,
                y: Math.random() * chart.clientHeight
            };
            renderPoint(newPoint.x, newPoint.y, 'newPoint');

            // Classify the new point
            const classifiedAs = classify(newPoint);
            alert(`The new point is classified as: ${classifiedAs}`);
        }
    }

    function classify(point) {
        // Calculate distances to all existing points
        const distances = points.map(p => {
            return {
                label: p.label,
                distance: Math.sqrt((p.x - point.x) ** 2 + (p.y - point.y) ** 2)
            };
        });

        // Sort by distance
        distances.sort((a, b) => a.distance - b.distance);

        // Get the labels of the K nearest neighbors
        const nearestNeighbors = distances.slice(0, K);
        
        // Count the votes for each label
        const votes = {};
        nearestNeighbors.forEach(neighbor => {
            votes[neighbor.label] = (votes[neighbor.label] || 0) + 1;
        });

        // Determine the class with the highest votes
        return Object.keys(votes).reduce((a, b) => votes[a] > votes[b] ? a : b);
    }
</script>

</body>
</html>