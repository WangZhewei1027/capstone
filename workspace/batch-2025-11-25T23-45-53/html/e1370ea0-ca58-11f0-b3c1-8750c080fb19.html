<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heap (Min/Max) Demonstration</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        input[type="number"] { width: 50px; }
        button { margin-left: 10px; }
        .heap-visualization { margin-top: 20px; }
    </style>
</head>
<body>

    <h1>Min/Max Heap Visualization</h1>
    <div>
        <label for="numberInput">Enter a number:</label>
        <input type="number" id="numberInput" />
        <button onclick="insertNumber()">Insert</button>
        <button onclick="removeMin()">Remove Min</button>
        <button onclick="removeMax()">Remove Max</button>
    </div>

    <div class="heap-visualization">
        <h2>Heap:</h2>
        <pre id="heapOutput">[]</pre>
    </div>

    <script>
        class MinMaxHeap {
            constructor() {
                this.values = [];
                this.size = 0;
            }

            insert(value) {
                this.values.push(value);
                this.size++;
                this.bubbleUp();
                this.updateOutput();
            }

            bubbleUp() {
                let index = this.size - 1;
                while (index > 0) {
                    let parentIndex = Math.floor((index - 1) / 2);
                    if (this.values[index] < this.values[parentIndex]) {
                        [this.values[index], this.values[parentIndex]] = [this.values[parentIndex], this.values[index]];
                        index = parentIndex;
                    } else {
                        break;
                    }
                }
            }

            removeMin() {
                if (this.size === 0) return null;
                const min = this.values[0];
                const end = this.values.pop();
                this.size--;
                if (this.size > 0) {
                    this.values[0] = end;
                    this.bubbleDownMin(0);
                }
                this.updateOutput();
                return min;
            }

            removeMax() {
                if (this.size === 0) return null;
                if (this.size === 1) return this.values.pop();
                const maxIndex = this.getMaxIndex();
                const max = this.values[maxIndex];
                const end = this.values.pop();
                this.size--;
                if (maxIndex < this.size) {
                    this.values[maxIndex] = end;
                    this.bubbleDownMax(maxIndex);
                }
                this.updateOutput();
                return max;
            }

            bubbleDownMin(index) {
                const length = this.size;
                while (true) {
                    let leftChildIndex = 2 * index + 1;
                    let rightChildIndex = 2 * index + 2;
                    let smallestIndex = index;
                    
                    if (leftChildIndex < length && this.values[leftChildIndex] < this.values[smallestIndex]) {
                        smallestIndex = leftChildIndex;
                    }
                    if (rightChildIndex < length && this.values[rightChildIndex] < this.values[smallestIndex]) {
                        smallestIndex = rightChildIndex;
                    }
                    if (smallestIndex === index) break;

                    [this.values[index], this.values[smallestIndex]] = [this.values[smallestIndex], this.values[index]];
                    index = smallestIndex;
                }
            }

            bubbleDownMax(index) {
                const length = this.size;
                while (true) {
                    let leftChildIndex = 2 * index + 1;
                    let rightChildIndex = 2 * index + 2;
                    let largestIndex = index;

                    if (leftChildIndex < length && this.values[leftChildIndex] > this.values[largestIndex]) {
                        largestIndex = leftChildIndex;
                    }
                    if (rightChildIndex < length && this.values[rightChildIndex] > this.values[largestIndex]) {
                        largestIndex = rightChildIndex;
                    }
                    if (largestIndex === index) break;

                    [this.values[index], this.values[largestIndex]] = [this.values[largestIndex], this.values[index]];
                    index = largestIndex;
                }
            }

            getMaxIndex() {
                if (this.size < 3) return this.size - 1;
                const leftChildIndex = 1; // First child
                const rightChildIndex = 2; // Second child
                return this.values[leftChildIndex] > this.values[rightChildIndex] ? leftChildIndex : rightChildIndex;
            }

            updateOutput() {
                document.getElementById('heapOutput').textContent = JSON.stringify(this.values, null, 2);
            }
        }

        const heap = new MinMaxHeap();

        function insertNumber() {
            const input = document.getElementById('numberInput');
            const value = parseInt(input.value);
            if (!isNaN(value)) {
                heap.insert(value);
                input.value = '';
            }
        }

        function removeMin() {
            heap.removeMin();
        }

        function removeMax() {
            heap.removeMax();
        }
    </script>

</body>
</html>