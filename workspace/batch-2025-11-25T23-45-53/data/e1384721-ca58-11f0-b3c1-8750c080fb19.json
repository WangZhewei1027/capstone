{
  "id": "e1384721-ca58-11f0-b3c1-8750c080fb19",
  "timestamp": "2025-11-25T23:46:45.061Z",
  "model": "gpt-4o-mini",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Prim's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            text-align: center;\n        }\n        canvas {\n            border: 1px solid #000;\n            margin-top: 20px;\n        }\n    </style>\n</head>\n<body>\n    <h1>Prim's Algorithm Visualization</h1>\n    <button id=\"generateGraph\">Generate Random Graph</button>\n    <canvas id=\"graphCanvas\" width=\"600\" height=\"400\"></canvas>\n    \n    <script>\n        const canvas = document.getElementById('graphCanvas');\n        const context = canvas.getContext('2d');\n        let graph = [];\n        const numNodes = 10;\n\n        // Create a random graph\n        function generateGraph() {\n            graph = Array.from({ length: numNodes }, () => []);\n            for (let i = 0; i < numNodes; i++) {\n                for (let j = 0; j < numNodes; j++) {\n                    if (i !== j && Math.random() < 0.4) { // 40% chance to create an edge\n                        const weight = Math.floor(Math.random() * 10) + 1; // random weight between 1 and 10\n                        graph[i].push({ node: j, weight: weight });\n                    }\n                }\n            }\n            drawGraph();\n        }\n\n        function drawGraph() {\n            context.clearRect(0, 0, canvas.width, canvas.height);\n            const angleStep = (2 * Math.PI) / numNodes;\n            const radius = 150;\n\n            // Draw nodes\n            for (let i = 0; i < numNodes; i++) {\n                const x = canvas.width / 2 + radius * Math.cos(i * angleStep);\n                const y = canvas.height / 2 + radius * Math.sin(i * angleStep);\n                context.fillStyle = 'blue';\n                context.beginPath();\n                context.arc(x, y, 15, 0, 2 * Math.PI);\n                context.fill();\n                context.fillStyle = 'white';\n                context.fillText(i, x - 5, y + 5);\n            }\n\n            // Draw edges\n            context.strokeStyle = 'grey';\n            for (let node = 0; node < numNodes; node++) {\n                graph[node].forEach(edge => {\n                    const x1 = canvas.width / 2 + radius * Math.cos(node * angleStep);\n                    const y1 = canvas.height / 2 + radius * Math.sin(node * angleStep);\n                    const x2 = canvas.width / 2 + radius * Math.cos(edge.node * angleStep);\n                    const y2 = canvas.height / 2 + radius * Math.sin(edge.node * angleStep);\n                    context.beginPath();\n                    context.moveTo(x1, y1);\n                    context.lineTo(x2, y2);\n                    context.stroke();\n                });\n            }\n        }\n\n        function prim() {\n            const selected = Array(numNodes).fill(false);\n            const edges = [];\n            const mstEdges = [];\n            let totalCost = 0;\n\n            // Start with the first node\n            selected[0] = true;\n            for (let count = 1; count < numNodes; count++) {\n                let minEdge = { weight: Infinity };\n                let fromNode = -1;\n\n                // Find the minimum edge connecting the selected nodes\n                for (let i = 0; i < numNodes; i++) {\n                    if (selected[i]) {\n                        for (const edge of graph[i]) {\n                            if (!selected[edge.node] && edge.weight < minEdge.weight) {\n                                minEdge = edge;\n                                fromNode = i;\n                            }\n                        }\n                    }\n                }\n\n                selected[minEdge.node] = true;\n                mstEdges.push({ from: fromNode, to: minEdge.node, weight: minEdge.weight });\n                totalCost += minEdge.weight;\n            }\n\n            return { edges: mstEdges, cost: totalCost };\n        }\n\n        function visualizeMST() {\n            const { edges, cost } = prim();\n            context.clearRect(0, 0, canvas.width, canvas.height);\n            drawGraph();\n\n            // Highlight MST edges\n            context.strokeStyle = 'red';\n            edges.forEach(edge => {\n                const x1 = canvas.width / 2 + 150 * Math.cos(edge.from * (2 * Math.PI / numNodes));\n                const y1 = canvas.height / 2 + 150 * Math.sin(edge.from * (2 * Math.PI / numNodes));\n                const x2 = canvas.width / 2 + 150 * Math.cos(edge.to * (2 * Math.PI / numNodes));\n                const y2 = canvas.height / 2 + 150 * Math.sin(edge.to * (2 * Math.PI / numNodes));\n                context.beginPath();\n                context.moveTo(x1, y1);\n                context.lineTo(x2, y2);\n                context.stroke();\n            });\n\n            alert(`Total Cost of Minimum Spanning Tree: ${cost}`);\n        }\n\n        document.getElementById('generateGraph').addEventListener('click', () => {\n            generateGraph();\n            setTimeout(visualizeMST, 1000); // Visualize after generating\n        });\n\n        generateGraph();  // Generate graph initially\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}