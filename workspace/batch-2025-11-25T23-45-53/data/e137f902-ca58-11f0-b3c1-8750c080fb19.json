{
  "id": "e137f902-ca58-11f0-b3c1-8750c080fb19",
  "timestamp": "2025-11-25T23:46:47.988Z",
  "model": "gpt-4o-mini",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Breadth-First Search (BFS) Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            background-color: #f4f4f4;\n            padding: 20px;\n        }\n        canvas {\n            border: 1px solid #333;\n            margin-top: 20px;\n        }\n        input[type=\"text\"] {\n            padding: 10px;\n            width: 300px;\n        }\n        button {\n            padding: 10px 15px;\n            margin-left: 10px;\n        }\n    </style>\n</head>\n<body>\n\n<h1>Breadth-First Search (BFS) Visualization</h1>\n<p>Enter the edges of the graph (e.g., A-B, A-C, B-D):</p>\n<input type=\"text\" id=\"edgesInput\" placeholder=\"Enter edges separated by commas\">\n<button onclick=\"startBFS()\">Start BFS</button>\n<button onclick=\"clearCanvas()\">Clear</button>\n\n<canvas id=\"graphCanvas\" width=\"600\" height=\"400\"></canvas>\n\n<script>\n    const canvas = document.getElementById('graphCanvas');\n    const ctx = canvas.getContext('2d');\n    let edges = [];\n    let nodes = {};\n    \n    function drawGraph() {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        \n        const radius = 20;\n        const nodePositions = {};\n        const angleIncrement = Math.PI * 2 / Object.keys(nodes).length;\n        \n        Object.keys(nodes).forEach((node, index) => {\n            const angle = angleIncrement * index;\n            const x = canvas.width / 2 + Math.cos(angle) * 150;\n            const y = canvas.height / 2 + Math.sin(angle) * 150;\n            nodePositions[node] = { x, y };\n            ctx.beginPath();\n            ctx.arc(x, y, radius, 0, Math.PI * 2);\n            ctx.fillStyle = 'lightgray';\n            ctx.fill();\n            ctx.stroke();\n            ctx.fillStyle = 'black';\n            ctx.fillText(node, x - 5, y + 5);\n        });\n        \n        edges.forEach(edge => {\n            const [node1, node2] = edge.split('-');\n            ctx.beginPath();\n            ctx.moveTo(nodePositions[node1].x, nodePositions[node1].y);\n            ctx.lineTo(nodePositions[node2].x, nodePositions[node2].y);\n            ctx.stroke();\n        });\n    }\n    \n    async function bfs(startNode) {\n        const queue = [startNode];\n        const visited = new Set();\n        visited.add(startNode);\n        \n        while (queue.length > 0) {\n            const currentNode = queue.shift();\n            await new Promise(resolve => setTimeout(resolve, 1000));\n            highlightNode(currentNode);\n            \n            nodes[currentNode].forEach(neighbor => {\n                if (!visited.has(neighbor)) {\n                    visited.add(neighbor);\n                    queue.push(neighbor);\n                }\n            });\n        }\n    }\n    \n    function highlightNode(node) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        drawGraph();\n        \n        // Highlight the current node\n        const radius = 20;\n        const nodePositions = {};\n        const angleIncrement = Math.PI * 2 / Object.keys(nodes).length;\n        \n        Object.keys(nodes).forEach((n, index) => {\n            const angle = angleIncrement * index;\n            const x = canvas.width / 2 + Math.cos(angle) * 150;\n            const y = canvas.height / 2 + Math.sin(angle) * 150;\n            nodePositions[n] = { x, y };\n            \n            ctx.beginPath();\n            ctx.arc(x, y, radius, 0, Math.PI * 2);\n            ctx.fillStyle = (n === node) ? 'yellow' : 'lightgray';\n            ctx.fill();\n            ctx.stroke();\n            ctx.fillStyle = 'black';\n            ctx.fillText(n, x - 5, y + 5);\n        });\n        \n        edges.forEach(edge => {\n            const [node1, node2] = edge.split('-');\n            ctx.beginPath();\n            ctx.moveTo(nodePositions[node1].x, nodePositions[node1].y);\n            ctx.lineTo(nodePositions[node2].x, nodePositions[node2].y);\n            ctx.stroke();\n        });\n    }\n    \n    function startBFS() {\n        const input = document.getElementById('edgesInput').value;\n        edges = input.split(',').map(edge => edge.trim());\n        \n        nodes = edges.reduce((acc, edge) => {\n            const [node1, node2] = edge.split('-');\n            if (!acc[node1]) acc[node1] = [];\n            if (!acc[node2]) acc[node2] = [];\n            acc[node1].push(node2);\n            acc[node2].push(node1);\n            return acc;\n        }, {});\n        \n        drawGraph();\n        const startNode = Object.keys(nodes)[0];\n        bfs(startNode);\n    }\n    \n    function clearCanvas() {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        document.getElementById('edgesInput').value = '';\n        edges = [];\n        nodes = {};\n    }\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}