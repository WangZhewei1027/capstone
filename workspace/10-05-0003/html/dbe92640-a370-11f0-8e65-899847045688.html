<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Linear Regression Playground</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #0f172a;        /* slate-900 */
      --panel: #111827;     /* gray-900 */
      --accent: #22c55e;    /* green-500 */
      --accent2: #3b82f6;   /* blue-500 */
      --accent3: #f43f5e;   /* rose-500 */
      --text: #e5e7eb;      /* gray-200 */
      --muted: #94a3b8;     /* slate-400 */
      --grid: #1f2937;      /* gray-800 */
      --axis: #334155;      /* slate-700 */
      --point: #fb923c;     /* orange-400 */
      --residual: rgba(244,63,94,0.5); /* rose-500 alpha */
    }
    * { box-sizing: border-box }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--axis);
      display: flex;
      align-items: center;
      gap: 16px;
    }
    header h1 {
      margin: 0;
      font-size: 20px;
      letter-spacing: 0.2px;
    }
    header .desc {
      color: var(--muted);
      font-size: 14px;
    }
    main {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 16px;
      padding: 16px;
    }
    .card {
      background: var(--panel);
      border: 1px solid var(--axis);
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 24px rgba(0,0,0,0.25);
    }
    .card-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--axis);
      font-weight: 600;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .card-body {
      padding: 12px;
    }
    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .col {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    label {
      font-size: 12px;
      color: var(--muted);
    }
    input[type="number"], input[type="text"] {
      background: #0b1220;
      border: 1px solid var(--axis);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 8px;
      width: 100%;
      font-size: 13px;
    }
    input[type="range"] {
      width: 160px;
    }
    button {
      background: var(--grid);
      border: 1px solid var(--axis);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.08s ease, background 0.2s ease, border 0.2s ease, opacity 0.2s ease;
      font-size: 13px;
    }
    button:hover { background: #172033 }
    button:active { transform: scale(0.98) }
    button.primary {
      background: #0b3b20;
      border-color: #14532d;
      color: #b1f0c5;
    }
    button.blue {
      background: #0b2c4a;
      border-color: #1e40af;
      color: #cfe3ff;
    }
    button.red {
      background: #3f1020;
      border-color: #7f1d1d;
      color: #ffd0d5;
    }
    button.gray {
      background: #0f1420;
      border-color: #263247;
      color: #cbd5e1;
    }
    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 999px;
      background: #0b182c;
      border: 1px solid var(--axis);
      color: #dbeafe;
    }
    .metrics {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      padding-top: 8px;
    }
    .metric {
      background: #0b1423;
      border: 1px solid var(--axis);
      border-radius: 8px;
      padding: 10px;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }
    .metric .label { font-size: 12px; color: var(--muted) }
    .metric .value { font-size: 16px; font-weight: 700 }
    .hint {
      font-size: 12px;
      color: var(--muted);
    }
    canvas {
      display: block;
      background: #0b1423;
    }
    .legend {
      display: flex;
      gap: 10px;
      padding: 8px 12px;
      border-top: 1px solid var(--axis);
      background: #0c1828;
      font-size: 12px;
      color: var(--muted);
    }
    .legend .item { display: flex; align-items: center; gap: 6px }
    .swatch {
      width: 14px; height: 2px; border-radius: 2px;
    }
    .swatch.dot { height: 10px; width: 10px; border-radius: 50% }
    .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(240px, 1fr));
      gap: 10px;
    }
    .explain {
      font-size: 13px;
      line-height: 1.4;
      color: var(--muted);
    }
    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      user-select: none;
    }
    .toggle input { margin: 0 }
    .footer {
      padding: 10px 16px;
      font-size: 12px;
      color: var(--muted);
      border-top: 1px solid var(--axis);
    }
    @media (max-width: 980px) {
      main { grid-template-columns: 1fr }
    }
  </style>
</head>
<body>
<header>
  <h1>Linear Regression</h1>
  <div class="desc">Fit a line y = a·x + b to data points using Least Squares or Gradient Descent</div>
</header>

<main>
  <section class="card">
    <div class="card-header">
      Interactive plot
      <span class="badge" id="pointCount">0 points</span>
      <label class="toggle" title="Click on the plot to add data points">
        <input type="checkbox" id="addMode">
        Click-to-add
      </label>
      <label class="toggle" title="Show residuals (errors) from each point to the fitted line">
        <input type="checkbox" id="showResiduals" checked>
        Residuals
      </label>
      <div style="margin-left:auto; display:flex; gap:8px;">
        <button class="gray" id="clearPoints">Clear points</button>
      </div>
    </div>
    <div class="card-body">
      <canvas id="plot" width="860" height="480"></canvas>
    </div>
    <div class="legend">
      <div class="item"><span class="swatch dot" style="background: var(--point)"></span> Data points</div>
      <div class="item"><span class="swatch" style="background: var(--accent)"></span> Fitted line</div>
      <div class="item"><span class="swatch" style="background: var(--residual)"></span> Residuals</div>
      <div class="item"><span class="swatch" style="background: var(--axis)"></span> Axes</div>
    </div>
  </section>

  <section class="card">
    <div class="card-header">Controls</div>
    <div class="card-body">
      <div class="grid">
        <div class="col">
          <label>Generate synthetic data</label>
          <div class="row">
            <div class="col" style="min-width:120px">
              <label>Points</label>
              <input type="number" id="genN" min="2" max="500" value="40">
            </div>
            <div class="col" style="min-width:120px">
              <label>Slope (a)</label>
              <input type="number" id="genSlope" step="0.1" value="1.5">
            </div>
            <div class="col" style="min-width:120px">
              <label>Intercept (b)</label>
              <input type="number" id="genIntercept" step="0.1" value="2">
            </div>
          </div>
          <div class="row">
            <div class="col" style="min-width:140px">
              <label>X range [min, max]</label>
              <div class="row" style="gap:6px">
                <input type="number" id="genXMin" value="0" style="width:90px">
                <input type="number" id="genXMax" value="10" style="width:90px">
              </div>
            </div>
            <div class="col" style="min-width:140px">
              <label>Noise (σ)</label>
              <input type="number" id="genNoise" step="0.1" value="1.0">
            </div>
          </div>
          <div class="row">
            <button class="blue" id="btnGenerate">Generate</button>
            <span class="hint">Generates y = a·x + b + Normal(0, σ²)</span>
          </div>
        </div>

        <div class="col">
          <label>Fit the model</label>
          <div class="row">
            <button class="primary" id="btnLeastSquares">Fit (Least Squares)</button>
            <button class="primary" id="btnResetModel">Reset model</button>
          </div>
          <div class="row" style="margin-top:6px">
            <div class="col" style="min-width:140px">
              <label>Learning rate (η)</label>
              <input type="range" id="lr" min="0.0005" max="1.0000" step="0.0005" value="0.030">
              <div class="hint">η = <span id="lrVal">0.03</span></div>
            </div>
            <div class="col" style="min-width:140px">
              <label>Gradient Descent</label>
              <div class="row">
                <button class="blue" id="btnTrain">Start training</button>
                <button class="gray" id="btnStep">Step ×10</button>
                <button class="red" id="btnStop" disabled>Stop</button>
              </div>
              <div class="hint">Batch gradient descent minimizes mean squared error</div>
            </div>
          </div>
        </div>
      </div>

      <div class="metrics">
        <div class="metric">
          <div class="label">Equation</div>
          <div class="value" id="eq">y = a·x + b</div>
        </div>
        <div class="metric">
          <div class="label">Mean Squared Error (MSE)</div>
          <div class="value" id="mse">—</div>
        </div>
        <div class="metric">
          <div class="label">Slope (a)</div>
          <div class="value" id="slope">0</div>
        </div>
        <div class="metric">
          <div class="label">Intercept (b)</div>
          <div class="value" id="intercept">0</div>
        </div>
      </div>

      <div class="explain" style="margin-top:10px">
        Linear Regression finds the line y = a·x + b that minimizes the average squared distance between the line and the data points (residuals).
        Least Squares provides a closed-form solution. Gradient Descent iteratively adjusts a and b to reduce the Mean Squared Error.
      </div>
    </div>
  </section>

  <section class="card">
    <div class="card-header">Training Loss (MSE) over iterations</div>
    <div class="card-body">
      <canvas id="loss" width="860" height="180"></canvas>
      <div class="footer" id="lossInfo">No training yet</div>
    </div>
  </section>
</main>

<script>
(function(){
  // State
  const points = [];
  let model = { a: 0, b: 0 };
  let costHistory = []; // {iter, cost}
  let training = false;
  let iter = 0;
  let trainReq = null;

  // Elements
  const plot = document.getElementById('plot');
  const lossCanvas = document.getElementById('loss');
  const ctx = plot.getContext('2d');
  const lossCtx = lossCanvas.getContext('2d');

  const addMode = document.getElementById('addMode');
  const showResidualsEl = document.getElementById('showResiduals');
  const pointCount = document.getElementById('pointCount');
  const clearPointsBtn = document.getElementById('clearPoints');

  const genN = document.getElementById('genN');
  const genSlope = document.getElementById('genSlope');
  const genIntercept = document.getElementById('genIntercept');
  const genXMin = document.getElementById('genXMin');
  const genXMax = document.getElementById('genXMax');
  const genNoise = document.getElementById('genNoise');
  const btnGenerate = document.getElementById('btnGenerate');

  const btnLeast = document.getElementById('btnLeastSquares');
  const btnResetModel = document.getElementById('btnResetModel');

  const lrInput = document.getElementById('lr');
  const lrVal = document.getElementById('lrVal');
  const btnTrain = document.getElementById('btnTrain');
  const btnStop = document.getElementById('btnStop');
  const btnStep = document.getElementById('btnStep');

  const eqEl = document.getElementById('eq');
  const mseEl = document.getElementById('mse');
  const slopeEl = document.getElementById('slope');
  const interceptEl = document.getElementById('intercept');
  const lossInfo = document.getElementById('lossInfo');

  // Plot config
  const margin = { left: 48, right: 18, top: 20, bottom: 42 };
  const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--grid');
  const axisColor = getComputedStyle(document.documentElement).getPropertyValue('--axis');
  const pointColor = getComputedStyle(document.documentElement).getPropertyValue('--point');
  const lineColor = getComputedStyle(document.documentElement).getPropertyValue('--accent');
  const residualColor = getComputedStyle(document.documentElement).getPropertyValue('--residual');

  function formatNum(x, digits = 4) {
    if (!isFinite(x)) return '—';
    const ax = Math.abs(x);
    if (ax !== 0 && (ax >= 1e4 || ax < 1e-3)) return x.toExponential(2);
    return Number(x).toFixed(digits);
  }

  // Data utilities
  function stats(points) {
    if (points.length === 0) return null;
    let xmin = Infinity, xmax = -Infinity, ymin = Infinity, ymax = -Infinity;
    for (const p of points) {
      if (p.x < xmin) xmin = p.x;
      if (p.x > xmax) xmax = p.x;
      if (p.y < ymin) ymin = p.y;
      if (p.y > ymax) ymax = p.y;
    }
    if (xmin === xmax) { xmin -= 1; xmax += 1; }
    if (ymin === ymax) { ymin -= 1; ymax += 1; }
    const dx = xmax - xmin, dy = ymax - ymin;
    const padX = dx * 0.08 || 1;
    const padY = dy * 0.08 || 1;
    return { xmin: xmin - padX, xmax: xmax + padX, ymin: ymin - padY, ymax: ymax + padY };
  }

  function defaultRange() {
    return { xmin: 0, xmax: 10, ymin: 0, ymax: 10 };
  }

  function getRange() {
    return points.length ? stats(points) : defaultRange();
  }

  function sx(x, r) {
    return margin.left + (x - r.xmin) / (r.xmax - r.xmin) * (plot.width - margin.left - margin.right);
  }
  function sy(y, r) {
    return plot.height - margin.bottom - (y - r.ymin) / (r.ymax - r.ymin) * (plot.height - margin.top - margin.bottom);
  }

  function invCoord(px, py, r) {
    const x = r.xmin + (px - margin.left) / (plot.width - margin.left - margin.right) * (r.xmax - r.xmin);
    const y = r.ymin + (plot.height - margin.bottom - py) / (plot.height - margin.top - margin.bottom) * (r.ymax - r.ymin);
    return { x, y };
  }

  // Drawing
  function drawAxes(r) {
    ctx.save();
    ctx.clearRect(0, 0, plot.width, plot.height);

    // Grid
    ctx.fillStyle = '#0b1423';
    ctx.fillRect(0,0,plot.width,plot.height);

    // Axis rectangles
    ctx.strokeStyle = axisColor;
    ctx.lineWidth = 1;
    ctx.strokeRect(margin.left, margin.top, plot.width - margin.left - margin.right, plot.height - margin.top - margin.bottom);

    // Ticks
    const ticks = 5;
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted');
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';

    for (let i=0;i<=ticks;i++){
      const t = r.xmin + i*(r.xmax - r.xmin)/ticks;
      const px = sx(t, r);
      ctx.strokeStyle = gridColor;
      ctx.beginPath();
      ctx.moveTo(px, margin.top);
      ctx.lineTo(px, plot.height - margin.bottom);
      ctx.stroke();
      ctx.fillText(Number(t).toFixed(2), px, plot.height - margin.bottom + 6);
    }
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for (let i=0;i<=ticks;i++){
      const t = r.ymin + i*(r.ymax - r.ymin)/ticks;
      const py = sy(t, r);
      ctx.strokeStyle = gridColor;
      ctx.beginPath();
      ctx.moveTo(margin.left, py);
      ctx.lineTo(plot.width - margin.right, py);
      ctx.stroke();
      ctx.fillText(Number(t).toFixed(2), margin.left - 6, py);
    }
    ctx.restore();
  }

  function drawPoints(r) {
    ctx.save();
    ctx.fillStyle = pointColor;
    for (const p of points) {
      const px = sx(p.x, r), py = sy(p.y, r);
      ctx.beginPath();
      ctx.arc(px, py, 4, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawResiduals(r) {
    if (!points.length) return;
    ctx.save();
    ctx.strokeStyle = residualColor;
    ctx.lineWidth = 2;
    for (const p of points) {
      const yhat = model.a * p.x + model.b;
      const px = sx(p.x, r);
      const py = sy(p.y, r);
      const pyh = sy(yhat, r);
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(px, pyh);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawLine(r) {
    if (!isFinite(model.a) || !isFinite(model.b)) return;
    ctx.save();
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    const x1 = r.xmin, y1 = model.a * x1 + model.b;
    const x2 = r.xmax, y2 = model.a * x2 + model.b;
    ctx.moveTo(sx(x1, r), sy(y1, r));
    ctx.lineTo(sx(x2, r), sy(y2, r));
    ctx.stroke();
    ctx.restore();
  }

  function drawPlot() {
    const r = getRange();
    drawAxes(r);
    if (showResidualsEl.checked) drawResiduals(r);
    drawLine(r);
    drawPoints(r);
    updateHUD();
  }

  // Loss chart
  function drawLoss() {
    const w = lossCanvas.width, h = lossCanvas.height;
    lossCtx.clearRect(0, 0, w, h);
    lossCtx.fillStyle = '#0b1423';
    lossCtx.fillRect(0, 0, w, h);

    const left = 52, right = 12, top = 14, bottom = 32;

    lossCtx.strokeStyle = axisColor;
    lossCtx.strokeRect(left, top, w - left - right, h - top - bottom);

    if (costHistory.length < 2) {
      lossInfo.textContent = costHistory.length ? `Iter ${costHistory[costHistory.length-1].iter}, MSE ${formatNum(costHistory[costHistory.length-1].cost, 6)}` : 'No training yet';
      return;
    }

    const minIter = costHistory[0].iter;
    const maxIter = costHistory[costHistory.length-1].iter;
    let minCost = Infinity, maxCost = -Infinity;
    for (const c of costHistory) {
      if (c.cost < minCost) minCost = c.cost;
      if (c.cost > maxCost) maxCost = c.cost;
    }
    if (minCost === maxCost) {
      minCost -= 1e-6;
      maxCost += 1e-6;
    }

    const sx = (t)=> left + (t - minIter)/(maxIter - minIter) * (w - left - right);
    const sy = (val)=> h - bottom - (val - minCost)/(maxCost - minCost) * (h - top - bottom);

    // grid
    const ticks = 4;
    lossCtx.strokeStyle = gridColor;
    for (let i=0;i<=ticks;i++){
      const px = left + i*(w - left - right)/ticks;
      lossCtx.beginPath(); lossCtx.moveTo(px, top); lossCtx.lineTo(px, h - bottom); lossCtx.stroke();
    }
    for (let i=0;i<=ticks;i++){
      const py = top + i*(h - top - bottom)/ticks;
      lossCtx.beginPath(); lossCtx.moveTo(left, py); lossCtx.lineTo(w - right, py); lossCtx.stroke();
    }

    // labels
    lossCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted');
    lossCtx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    lossCtx.textAlign = 'center';
    lossCtx.textBaseline = 'top';
    for (let i=0;i<=ticks;i++){
      const t = Math.round(minIter + i*(maxIter - minIter)/ticks);
      const px = left + i*(w - left - right)/ticks;
      lossCtx.fillText(t, px, h - bottom + 6);
    }
    lossCtx.textAlign = 'right';
    lossCtx.textBaseline = 'middle';
    for (let i=0;i<=ticks;i++){
      const val = minCost + i*(maxCost - minCost)/ticks;
      const py = h - bottom - i*(h - top - bottom)/ticks;
      lossCtx.fillText(formatNum(val, 6), left - 6, py);
    }

    // path
    lossCtx.strokeStyle = lineColor;
    lossCtx.lineWidth = 2;
    lossCtx.beginPath();
    for (let i=0;i<costHistory.length;i++){
      const c = costHistory[i];
      const px = sx(c.iter);
      const py = sy(c.cost);
      if (i === 0) lossCtx.moveTo(px, py);
      else lossCtx.lineTo(px, py);
    }
    lossCtx.stroke();

    const last = costHistory[costHistory.length-1];
    lossInfo.textContent = `Iterations ${minIter} – ${maxIter} (n=${costHistory.length}), last MSE ${formatNum(last.cost, 6)}`;
  }

  // Fitting
  function leastSquares(points) {
    const n = points.length;
    if (n < 2) return { a: NaN, b: NaN, mse: NaN };
    let sumX=0, sumY=0;
    for (const p of points) { sumX += p.x; sumY += p.y; }
    const meanX = sumX / n, meanY = sumY / n;
    let sxx = 0, sxy = 0;
    for (const p of points) {
      const dx = p.x - meanX;
      sxx += dx * dx;
      sxy += dx * (p.y - meanY);
    }
    if (sxx === 0) return { a: NaN, b: NaN, mse: NaN }; // vertical line fit not supported
    const a = sxy / sxx;
    const b = meanY - a * meanX;
    const mse = computeMSE(points, { a, b });
    return { a, b, mse };
  }

  function computeMSE(points, model) {
    const n = points.length;
    if (n === 0) return NaN;
    let sum = 0;
    for (const p of points) {
      const err = model.a * p.x + model.b - p.y;
      sum += err * err;
    }
    return sum / n;
  }

  function stepGradientDescent(times = 1) {
    if (points.length === 0) return;
    const lr = parseFloat(lrInput.value);
    for (let t=0; t<times; t++) {
      const n = points.length;
      let gradA = 0, gradB = 0;
      // Gradient of MSE: (2/n) * sum(err * x), (2/n) * sum(err)
      for (const p of points) {
        const err = model.a * p.x + model.b - p.y;
        gradA += err * p.x;
        gradB += err;
      }
      gradA = (2 / n) * gradA;
      gradB = (2 / n) * gradB;

      model.a -= lr * gradA;
      model.b -= lr * gradB;

      iter++;
      const cost = computeMSE(points, model);
      costHistory.push({ iter, cost });
    }
    updateHUD();
    drawPlot();
    drawLoss();
  }

  function startTraining() {
    if (training || points.length === 0) return;
    training = true;
    btnTrain.disabled = true;
    btnStop.disabled = false;
    btnStep.disabled = true;

    const loop = () => {
      if (!training) return;
      stepGradientDescent(1);
      trainReq = requestAnimationFrame(loop);
    };
    trainReq = requestAnimationFrame(loop);
  }

  function stopTraining() {
    training = false;
    btnTrain.disabled = false;
    btnStop.disabled = true;
    btnStep.disabled = false;
    if (trainReq) cancelAnimationFrame(trainReq);
  }

  // HUD
  function updateHUD() {
    const mse = computeMSE(points, model);
    slopeEl.textContent = formatNum(model.a, 4);
    interceptEl.textContent = formatNum(model.b, 4);
    eqEl.textContent = `y = ${formatNum(model.a, 4)} · x + ${formatNum(model.b, 4)}`;
    mseEl.textContent = isFinite(mse) ? formatNum(mse, 6) : '—';
    pointCount.textContent = `${points.length} point${points.length===1?'':'s'}`;
  }

  // Events
  btnGenerate.addEventListener('click', () => {
    const n = Math.max(2, Math.min(2000, parseInt(genN.value || '40', 10)));
    const a = parseFloat(genSlope.value || '1.5');
    const b = parseFloat(genIntercept.value || '2');
    const xmin = parseFloat(genXMin.value || '0');
    const xmax = parseFloat(genXMax.value || '10');
    const sigma = Math.max(0, parseFloat(genNoise.value || '1.0'));

    if (!(xmax > xmin)) {
      alert('X max must be greater than X min.');
      return;
    }

    points.length = 0;
    // Generate x uniformly, and y with noise
    for (let i=0;i<n;i++){
      const x = xmin + Math.random()*(xmax - xmin);
      const noise = gaussian(0, sigma);
      const y = a * x + b + noise;
      points.push({ x, y });
    }
    // Reset model and training
    resetTraining();
    drawPlot();
    drawLoss();
  });

  function gaussian(mu, sigma) {
    // Box-Muller
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    return mu + sigma * z;
  }

  btnLeast.addEventListener('click', () => {
    if (points.length < 2) {
      alert('Add at least two points to fit a line.');
      return;
    }
    const fit = leastSquares(points);
    if (!isFinite(fit.a) || !isFinite(fit.b)) {
      alert('Cannot fit a vertical line with this method (all x are equal). Add varied x values.');
      return;
    }
    model.a = fit.a;
    model.b = fit.b;
    const mse = computeMSE(points, model);
    costHistory.push({ iter: ++iter, cost: mse });
    drawPlot();
    drawLoss();
  });

  btnResetModel.addEventListener('click', () => {
    model.a = 0;
    model.b = 0;
    drawPlot();
  });

  lrInput.addEventListener('input', () => {
    lrVal.textContent = parseFloat(lrInput.value).toFixed(3);
  });

  btnTrain.addEventListener('click', () => {
    if (points.length === 0) {
      alert('Add or generate points to train.');
      return;
    }
    startTraining();
  });

  btnStop.addEventListener('click', stopTraining);

  btnStep.addEventListener('click', () => {
    if (points.length === 0) {
      alert('Add or generate points to train.');
      return;
    }
    stepGradientDescent(10);
  });

  addMode.addEventListener('change', () => {
    plot.style.cursor = addMode.checked ? 'crosshair' : 'default';
  });

  clearPointsBtn.addEventListener('click', () => {
    points.length = 0;
    resetTraining();
    drawPlot();
    drawLoss();
  });

  plot.addEventListener('click', (e) => {
    if (!addMode.checked) return;
    const rect = plot.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    const r = getRange();
    const p = invCoord(px, py, r);
    points.push(p);
    // Keep training consistent
    drawPlot();
  });

  function resetTraining() {
    stopTraining();
    model.a = 0;
    model.b = 0;
    iter = 0;
    costHistory.length = 0;
    updateHUD();
    lossInfo.textContent = 'No training yet';
  }

  // Initial
  lrVal.textContent = parseFloat(lrInput.value).toFixed(3);
  drawPlot();
  drawLoss();

})();
</script>
</body>
</html>