<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Recursion Demonstration</title>
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --accent: #22d3ee;
    --accent2: #a78bfa;
    --text: #e5e7eb;
    --muted: #94a3b8;
    --green: #34d399;
    --yellow: #f59e0b;
    --red: #ef4444;
    --border: #1f2937;
  }
  html, body {
    margin: 0;
    padding: 0;
    background: radial-gradient(1000px 800px at 20% 0%, #0a0f24 0%, #0f172a 33%, #0b1322 100%);
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  }
  header {
    padding: 24px 16px 8px;
    text-align: center;
  }
  header h1 {
    margin: 0;
    font-size: 28px;
    letter-spacing: 0.3px;
  }
  header p {
    margin: 8px auto 0;
    max-width: 900px;
    color: var(--muted);
    font-size: 15px;
  }
  main {
    max-width: 1100px;
    margin: 16px auto 48px;
    padding: 0 12px;
  }
  section {
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.00));
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 18px;
    box-shadow: 0 15px 35px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.05);
  }
  section h2 {
    margin: 0 0 8px 0;
    font-size: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
    margin: 8px 0 12px;
  }
  .control {
    display: inline-flex;
    gap: 8px;
    align-items: center;
    padding: 8px 10px;
    border-radius: 10px;
    background: #0b1223;
    border: 1px solid var(--border);
  }
  label {
    font-size: 13px;
    color: var(--muted);
  }
  input[type="number"], input[type="range"] {
    accent-color: var(--accent);
  }
  input[type="number"] {
    width: 90px;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: #0a1021;
    color: var(--text);
  }
  button {
    padding: 8px 12px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: #0b1223;
    color: var(--text);
    cursor: pointer;
    transition: transform 0.05s ease, background 0.2s ease, border-color 0.2s ease;
  }
  button:hover {
    background: #0e162b;
    border-color: #263248;
  }
  button:active {
    transform: translateY(1px);
  }
  button.primary {
    background: linear-gradient(90deg, rgba(34,211,238,0.15), rgba(167,139,250,0.15));
    border-color: #2a405f;
  }
  .note {
    font-size: 13px;
    color: var(--muted);
    margin-top: 6px;
  }

  /* Trace tree */
  #traceOutput {
    border: 1px dashed #223048;
    border-radius: 10px;
    padding: 12px;
    background: #0a1021;
    max-height: 400px;
    overflow: auto;
  }
  .traceHeader {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    align-items: baseline;
    margin-bottom: 8px;
  }
  .traceHeader .result {
    font-weight: 600;
    color: var(--green);
  }
  .traceHeader .meta {
    color: var(--muted);
    font-size: 13px;
  }
  ul.tree {
    list-style: none;
    margin: 0;
    padding-left: 14px;
    border-left: 1px dashed #253047;
  }
  .tree li {
    margin: 3px 0;
    position: relative;
  }
  .tree li::before {
    content: "";
    position: absolute;
    left: -13px;
    top: 10px;
    width: 12px;
    height: 1px;
    background: #253047;
  }
  .nodeLabel {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    font-size: 13px;
    padding: 2px 6px;
    border-radius: 6px;
    background: #0f1831;
    border: 1px solid #1f2a46;
  }
  .baseCase { color: var(--green); border-color: #23543b; background: #0b1a14; }
  .recursiveCase { color: #8ab4f8; }

  /* Fractal canvas */
  #fractalCanvas {
    width: 100%;
    max-width: 1000px;
    height: 420px;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: radial-gradient(800px 500px at 50% 0%, #0a0f24 0%, #0f162c 50%, #0a1020 100%);
    display: block;
    margin: auto;
  }
  .legend {
    font-size: 12px;
    color: var(--muted);
    text-align: center;
    margin-top: 6px;
  }

  /* Hanoi */
  .pegContainer {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 10px;
    margin-top: 8px;
  }
  .peg {
    position: relative;
    min-height: 220px;
    border: 1px solid var(--border);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.00));
    padding: 8px;
    display: flex;
    align-items: flex-end;
    justify-content: center;
    overflow: hidden;
  }
  .peg::after {
    content: "";
    position: absolute;
    width: 6px;
    height: 150px;
    background: #1a2742;
    bottom: 45px;
    left: 50%;
    transform: translateX(-50%);
    border-radius: 3px;
    box-shadow: inset 0 0 6px rgba(0,0,0,0.5);
  }
  .pegLabel {
    position: absolute;
    top: 6px;
    left: 8px;
    font-weight: 600;
    color: var(--muted);
    font-size: 13px;
  }
  .base {
    position: absolute;
    bottom: 8px;
    left: 10%;
    right: 10%;
    height: 12px;
    background: #1a2742;
    border-radius: 8px;
    box-shadow: inset 0 0 6px rgba(0,0,0,0.6);
  }
  .disk {
    height: 18px;
    border-radius: 10px;
    margin: 2px 0;
    border: 1px solid #213251;
    box-shadow: 0 6px 12px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.08);
  }
  .diskLabel {
    font-size: 11px;
    color: #dbeafe;
    text-shadow: 0 1px 0 rgba(0,0,0,0.4);
    text-align: center;
    line-height: 18px;
  }
  #hanoiMoves {
    max-height: 200px;
    overflow: auto;
    border: 1px dashed #223048;
    border-radius: 10px;
    padding: 10px;
    background: #0a1021;
    margin-top: 8px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    font-size: 13px;
  }
  .warn {
    color: var(--yellow);
  }
  .err {
    color: var(--red);
  }
  .success {
    color: var(--green);
  }
  footer {
    text-align: center;
    color: var(--muted);
    font-size: 13px;
    padding: 18px 12px 30px;
  }
</style>
</head>
<body>
<header>
  <h1>Recursion in JavaScript</h1>
  <p>Recursion is when a function calls itself to break a problem into smaller subproblems. This page demonstrates recursion with numeric traces, a fractal tree, and the Tower of Hanoi algorithm.</p>
</header>
<main>
  <section id="traces">
    <h2>Recursive Functions: Factorial and Fibonacci</h2>
    <div class="controls">
      <div class="control">
        <label for="nInput">n</label>
        <input id="nInput" type="number" min="0" max="20" value="5"/>
      </div>
      <button id="btnFactorial" class="primary">Trace Factorial(n)</button>
      <button id="btnFibonacci">Trace Fibonacci(n)</button>
      <button id="btnClearTrace">Clear</button>
    </div>
    <div class="note">Tip: Fibonacci grows exponentially in calls. For responsiveness, n is limited to 12.</div>
    <div id="traceOutput" aria-live="polite"></div>
  </section>

  <section id="fractal">
    <h2>Fractal Tree: Visual Recursion</h2>
    <div class="controls">
      <div class="control">
        <label for="depthRange">Depth</label>
        <input id="depthRange" type="range" min="0" max="12" value="8"/>
        <span id="depthVal">8</span>
      </div>
      <div class="control">
        <label for="angleRange">Branch Angle</label>
        <input id="angleRange" type="range" min="10" max="60" value="30"/>
        <span id="angleVal">30°</span>
      </div>
      <div class="control">
        <label for="factorRange">Length Factor</label>
        <input id="factorRange" type="range" min="55" max="80" value="67"/>
        <span id="factorVal">0.67</span>
      </div>
      <button id="btnRedraw" class="primary">Redraw Tree</button>
      <button id="btnAnimateTree">Animate Depth</button>
      <button id="btnStopTree">Stop</button>
    </div>
    <canvas id="fractalCanvas" width="1000" height="420"></canvas>
    <div class="legend">Each branch splits into two smaller branches until the depth reaches zero. That branching is a recursive call.</div>
  </section>

  <section id="hanoi">
    <h2>Tower of Hanoi: Recursive Algorithm</h2>
    <div class="controls">
      <div class="control">
        <label for="diskRange">Disks</label>
        <input id="diskRange" type="range" min="1" max="8" value="4"/>
        <span id="diskVal">4</span>
      </div>
      <button id="btnBuildHanoi" class="primary">Setup</button>
      <button id="btnSolveHanoi">Solve (List Moves)</button>
      <button id="btnAnimateHanoi">Animate</button>
      <button id="btnStopHanoi">Stop</button>
    </div>
    <div class="pegContainer">
      <div class="peg" id="pegA"><div class="pegLabel">A</div><div class="base"></div></div>
      <div class="peg" id="pegB"><div class="pegLabel">B</div><div class="base"></div></div>
      <div class="peg" id="pegC"><div class="pegLabel">C</div><div class="base"></div></div>
    </div>
    <div id="hanoiMoves"></div>
    <div class="note">Algorithm: Move n−1 disks from A→B, move the largest from A→C, then move n−1 from B→C. This self-referential step is recursion.</div>
  </section>
</main>

<footer>
  Recursion lets us express complex structures and algorithms elegantly by repeatedly solving smaller instances of the same problem.
</footer>

<script>
  // Utility: create element
  function el(tag, props = {}, children = []) {
    const e = document.createElement(tag);
    Object.entries(props).forEach(([k, v]) => {
      if (k === 'class') e.className = v;
      else if (k === 'text') e.textContent = v;
      else e.setAttribute(k, v);
    });
    children.forEach(c => e.appendChild(c));
    return e;
  }

  // ----- Trace: Factorial & Fibonacci -----
  function traceFactorial(n) {
    const node = { label: `fact(${n})`, value: null, children: [], base: false };
    if (n <= 1) {
      node.value = 1;
      node.base = true;
    } else {
      const child = traceFactorial(n - 1);
      node.children.push(child);
      node.value = n * child.value;
    }
    return node;
  }

  function traceFibonacci(n) {
    const node = { label: `fib(${n})`, value: null, children: [], base: false };
    if (n <= 1) {
      node.value = n;
      node.base = true;
    } else {
      // recursive calls
      const left = traceFibonacci(n - 1);
      const right = traceFibonacci(n - 2);
      node.children.push(left, right);
      node.value = left.value + right.value;
    }
    return node;
  }

  function renderTree(node) {
    const rootUl = el('ul', { class: 'tree' });
    function walk(n) {
      const li = el('li');
      const span = el('span', { class: `nodeLabel ${n.base ? 'baseCase' : 'recursiveCase'}`, title: n.base ? 'Base case' : 'Recursive case' }, []);
      span.textContent = `${n.label} = ${n.value}`;
      li.appendChild(span);
      if (n.children && n.children.length) {
        const ul = el('ul', { class: 'tree' });
        n.children.forEach(c => ul.appendChild(walk(c)));
        li.appendChild(ul);
      }
      return li;
    }
    rootUl.appendChild(walk(node));
    return rootUl;
  }

  function countNodes(node) {
    let c = 1;
    for (const ch of node.children || []) c += countNodes(ch);
    return c;
  }

  const nInput = document.getElementById('nInput');
  const traceOut = document.getElementById('traceOutput');
  const btnFact = document.getElementById('btnFactorial');
  const btnFib = document.getElementById('btnFibonacci');
  const btnClearTrace = document.getElementById('btnClearTrace');

  btnClearTrace.addEventListener('click', () => {
    traceOut.innerHTML = '';
  });

  btnFact.addEventListener('click', () => {
    let n = parseInt(nInput.value, 10) || 0;
    n = Math.max(0, Math.min(n, 20)); // safe upper bound
    const node = traceFactorial(n);
    const header = el('div', { class: 'traceHeader' }, [
      el('div', { class: 'result' }, [el('span', { text: `fact(${n}) = ${node.value}` })]),
      el('div', { class: 'meta' }, [el('span', { text: `recursive calls: ${countNodes(node)}` })]),
      el('div', { class: 'meta' }, [el('span', { text: `base cases: ${n === 0 ? 1 : 1}` })])
    ]);
    traceOut.innerHTML = '';
    traceOut.appendChild(header);
    traceOut.appendChild(renderTree(node));
  });

  btnFib.addEventListener('click', () => {
    let n = parseInt(nInput.value, 10) || 0;
    if (n > 12) {
      n = 12;
      nInput.value = 12;
      const warn = el('div', { class: 'note warn' }, [el('span', { text: 'Fibonacci capped at n = 12 for performance.' })]);
      traceOut.prepend(warn);
      setTimeout(() => warn.remove(), 2500);
    }
    const node = traceFibonacci(n);
    const header = el('div', { class: 'traceHeader' }, [
      el('div', { class: 'result' }, [el('span', { text: `fib(${n}) = ${node.value}` })]),
      el('div', { class: 'meta' }, [el('span', { text: `recursive calls: ${countNodes(node)}` })]),
      el('div', { class: 'meta' }, [el('span', { text: 'base cases: fib(0) and fib(1)' })])
    ]);
    traceOut.innerHTML = '';
    traceOut.appendChild(header);
    traceOut.appendChild(renderTree(node));
  });

  // ----- Fractal Tree -----
  const canvas = document.getElementById('fractalCanvas');
  const ctx = canvas.getContext('2d');

  const depthRange = document.getElementById('depthRange');
  const angleRange = document.getElementById('angleRange');
  const factorRange = document.getElementById('factorRange');
  const depthVal = document.getElementById('depthVal');
  const angleVal = document.getElementById('angleVal');
  const factorVal = document.getElementById('factorVal');

  let treeAnim = null;

  function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  function drawBranch(x1, y1, x2, y2, width, hue) {
    ctx.strokeStyle = `hsl(${hue}, 70%, 70%)`;
    ctx.lineWidth = width;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  function drawTree(x, y, len, angleRad, depth, factor, angleDelta, width = 6, hue = 200) {
    if (depth === 0 || len < 2) return;
    const x2 = x + Math.cos(angleRad) * len;
    const y2 = y - Math.sin(angleRad) * len;
    drawBranch(x, y, x2, y2, width, hue);

    const nextLen = len * factor;
    const nextHue = hue + 2;
    const nextWidth = Math.max(1.2, width * 0.72);

    // Left and Right branches
    drawTree(x2, y2, nextLen, angleRad + angleDelta, depth - 1, factor, angleDelta, nextWidth, nextHue);
    drawTree(x2, y2, nextLen, angleRad - angleDelta, depth - 1, factor, angleDelta, nextWidth, nextHue);
  }

  function renderFractal() {
    const depth = parseInt(depthRange.value, 10);
    const angleDeg = parseInt(angleRange.value, 10);
    const factorPct = parseInt(factorRange.value, 10);
    const factor = factorPct / 100;

    depthVal.textContent = depth;
    angleVal.textContent = angleDeg + '°';
    factorVal.textContent = factor.toFixed(2);

    clearCanvas();
    // Base trunk length scales to canvas width/height
    const trunkLen = Math.min(canvas.height * 0.28, canvas.width * 0.18);
    const startX = canvas.width / 2;
    const startY = canvas.height - 16;
    const angleRad = Math.PI / 2; // upwards
    const angleDelta = angleDeg * Math.PI / 180;

    drawTree(startX, startY, trunkLen, angleRad, depth, factor, angleDelta);
  }

  document.getElementById('btnRedraw').addEventListener('click', renderFractal);
  depthRange.addEventListener('input', renderFractal);
  angleRange.addEventListener('input', renderFractal);
  factorRange.addEventListener('input', renderFractal);

  document.getElementById('btnAnimateTree').addEventListener('click', () => {
    if (treeAnim) return;
    let d = 0;
    const target = parseInt(depthRange.value, 10);
    treeAnim = setInterval(() => {
      depthRange.value = d;
      renderFractal();
      d++;
      if (d > target) {
        clearInterval(treeAnim);
        treeAnim = null;
      }
    }, 120);
  });
  document.getElementById('btnStopTree').addEventListener('click', () => {
    if (treeAnim) {
      clearInterval(treeAnim);
      treeAnim = null;
    }
  });

  // Initial render
  renderFractal();

  // ----- Tower of Hanoi -----
  const diskRange = document.getElementById('diskRange');
  const diskVal = document.getElementById('diskVal');
  const pegA = document.getElementById('pegA');
  const pegB = document.getElementById('pegB');
  const pegC = document.getElementById('pegC');
  const hanoiMovesDiv = document.getElementById('hanoiMoves');

  let pegs = { A: [], B: [], C: [] };
  let hanoiAnim = null;

  function updateDiskVal() {
    diskVal.textContent = diskRange.value;
  }
  diskRange.addEventListener('input', updateDiskVal);
  updateDiskVal();

  function buildInitial(disks) {
    pegs = { A: [], B: [], C: [] };
    // Largest disk is disks, smallest is 1
    for (let i = disks; i >= 1; i--) pegs.A.push(i);
    renderPegs();
    hanoiMovesDiv.innerHTML = `<div class="success">Ready: ${disks} disks on peg A.</div>`;
  }

  function renderPegs() {
    [pegA, pegB, pegC].forEach(peg => {
      // Remove all disks first
      Array.from(peg.querySelectorAll('.disk')).forEach(d => d.remove());
    });
    const maxDisks = Math.max(pegs.A.length, pegs.B.length, pegs.C.length, parseInt(diskRange.value, 10));
    const maxWidth = 220;
    const minWidth = 60;

    function renderPeg(pegEl, arr) {
      // Render bottom to top
      arr.forEach((size, idx) => {
        const t = (size - 1) / Math.max(1, maxDisks - 1);
        const w = Math.round(minWidth + t * (maxWidth - minWidth));
        const disk = el('div', { class: 'disk' });
        disk.style.width = w + 'px';
        // Color gradient by size
        const hue = 200 + Math.round(t * 140);
        disk.style.background = `linear-gradient(90deg, hsl(${hue},60%,42%), hsl(${hue+20},70%,52%))`;
        disk.style.borderColor = `hsl(${hue},50%,32%)`;
        const label = el('div', { class: 'diskLabel', text: `Disk ${size}` });
        disk.appendChild(label);
        pegEl.appendChild(disk);
      });
    }
    renderPeg(pegA, pegs.A);
    renderPeg(pegB, pegs.B);
    renderPeg(pegC, pegs.C);
  }

  function hanoiMoves(n, from, aux, to, list) {
    // Count calls implicitly by list length; but track if needed
    if (n === 1) {
      list.push([from, to]);
    } else {
      hanoiMoves(n - 1, from, to, aux, list);
      list.push([from, to]);
      hanoiMoves(n - 1, aux, from, to, list);
    }
    return list;
  }

  function performMove(from, to) {
    const disk = pegs[from].pop();
    if (disk == null) return false;
    // Simple validity check
    const top = pegs[to][pegs[to].length - 1];
    if (top != null && top < disk) {
      hanoiMovesDiv.appendChild(el('div', { class: 'err' }, [el('span', { text: `Invalid move attempted: ${from} → ${to}` })]));
      // revert
      pegs[from].push(disk);
      return false;
    }
    pegs[to].push(disk);
    renderPegs();
    return true;
  }

  document.getElementById('btnBuildHanoi').addEventListener('click', () => {
    const n = parseInt(diskRange.value, 10);
    stopHanoi();
    buildInitial(n);
  });

  document.getElementById('btnSolveHanoi').addEventListener('click', () => {
    stopHanoi();
    const n = parseInt(diskRange.value, 10);
    if (pegs.A.length !== n || pegs.B.length !== 0 || pegs.C.length !== 0) {
      buildInitial(n);
    }
    const moves = hanoiMoves(n, 'A', 'B', 'C', []);
    const total = moves.length;
    hanoiMovesDiv.innerHTML = '';
    hanoiMovesDiv.appendChild(el('div', { class: 'success' }, [el('span', { text: `Total moves: ${total} (2^${n} - 1)` })]));
    moves.forEach((m, i) => {
      hanoiMovesDiv.appendChild(el('div', {}, [el('span', { text: `${String(i + 1).padStart(3, ' ')}. ${m[0]} → ${m[1]}` })]));
    });
  });

  function stopHanoi() {
    if (hanoiAnim) {
      clearInterval(hanoiAnim);
      hanoiAnim = null;
    }
  }
  document.getElementById('btnStopHanoi').addEventListener('click', stopHanoi);

  document.getElementById('btnAnimateHanoi').addEventListener('click', () => {
    stopHanoi();
    const n = parseInt(diskRange.value, 10);
    if (pegs.A.length !== n || pegs.B.length !== 0 || pegs.C.length !== 0) {
      buildInitial(n);
    }
    const moves = hanoiMoves(n, 'A', 'B', 'C', []);
    hanoiMovesDiv.innerHTML = '';
    hanoiMovesDiv.appendChild(el('div', { class: 'success' }, [el('span', { text: `Animating ${moves.length} moves...` })]));
    let i = 0;
    hanoiAnim = setInterval(() => {
      if (i >= moves.length) {
        clearInterval(hanoiAnim);
        hanoiAnim = null;
        hanoiMovesDiv.appendChild(el('div', { class: 'success' }, [el('span', { text: `Done!` })]));
        return;
      }
      const [from, to] = moves[i++];
      performMove(from, to);
      hanoiMovesDiv.appendChild(el('div', {}, [el('span', { text: `${String(i).padStart(3, ' ')}. ${from} → ${to}` })]));
      hanoiMovesDiv.scrollTop = hanoiMovesDiv.scrollHeight;
    }, Math.max(50, 600 - n * 60));
  });

  // Set up initial states
  buildInitial(parseInt(diskRange.value, 10));
</script>
</body>
</html>