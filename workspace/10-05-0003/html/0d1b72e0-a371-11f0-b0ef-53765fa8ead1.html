<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>K-Nearest Neighbors (KNN) Interactive Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #f7f9fc;
      --panel: #ffffff;
      --text: #222;
      --muted: #6b7280;
      --border: #d1d5db;
      --accent: #0ea5e9;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
      background: var(--bg);
    }
    header {
      padding: 16px 20px 8px 20px;
    }
    h1 {
      font-size: 20px;
      margin: 0 0 6px 0;
    }
    p {
      margin: 0 0 10px 0;
      color: var(--muted);
      font-size: 14px;
    }
    .container {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 12px;
      padding: 0 20px 20px 20px;
    }
    .left, .right {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }
    .controls {
      padding: 12px;
      border-bottom: 1px solid var(--border);
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      align-items: center;
    }
    .controls .row { display: contents; }
    .control {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    .control label {
      color: var(--muted);
      min-width: 110px;
      white-space: nowrap;
    }
    .control input[type="range"] {
      width: 100%;
    }
    .control select, .control button {
      padding: 6px 8px;
      font-size: 14px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #fff;
      color: var(--text);
    }
    .control button {
      cursor: pointer;
    }
    .control button:hover {
      border-color: var(--accent);
    }
    .toggles {
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
      font-size: 14px;
      padding: 8px 12px;
    }
    .legend {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      padding: 8px 12px;
      border-top: 1px solid var(--border);
    }
    .legend .item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
    }
    .swatch {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.15);
      flex: 0 0 auto;
    }
    .canvas-wrap {
      position: relative;
      width: 100%;
      height: 520px;
      background: #fff;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
      background:
        linear-gradient(to right, #f9fafb 1px, transparent 1px) 0 0/20px 20px,
        linear-gradient(to bottom, #f9fafb 1px, transparent 1px) 0 0/20px 20px;
    }
    .hint {
      position: absolute;
      bottom: 8px;
      left: 8px;
      right: 8px;
      font-size: 12px;
      color: var(--muted);
      background: rgba(255,255,255,0.85);
      border: 1px solid var(--border);
      padding: 6px 8px;
      border-radius: 6px;
    }
    .right .panel {
      padding: 12px;
    }
    .panel h2 {
      font-size: 16px;
      margin: 0 0 8px 0;
    }
    .panel .info {
      font-size: 13px;
      color: var(--muted);
      line-height: 1.4;
    }
    .kv {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-size: 12px;
      white-space: pre-wrap;
      color: #111827;
      background: #f9fafb;
      border-radius: 6px;
      padding: 8px;
    }
    .footer {
      padding: 8px 12px;
      border-top: 1px solid var(--border);
      font-size: 12px;
      color: var(--muted);
    }

    /* Colors for classes */
    .c0 { background: #e74c3c; }
    .c1 { background: #3498db; }
    .c2 { background: #2ecc71; }
    .c3 { background: #f39c12; }
    .c4 { background: #9b59b6; }
    .muted {
      opacity: 0.6;
    }
    .inline {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
  </style>
</head>
<body>
  <header>
    <h1>K-Nearest Neighbors (KNN) Interactive Demo</h1>
    <p>Add training points, choose k, and click to classify a test point. Toggle decision boundary to see how KNN partitions the space.</p>
  </header>

  <div class="container">
    <div class="left">
      <div class="controls">
        <div class="control">
          <label for="kRange">K neighbors</label>
          <input id="kRange" type="range" min="1" max="25" step="1" value="5" />
          <span id="kVal">5</span>
        </div>
        <div class="control">
          <label>Distance</label>
          <div class="inline">
            <label class="inline"><input type="radio" name="metric" id="metricEuclidean" value="euclidean" checked /> Euclidean</label>
            <label class="inline"><input type="radio" name="metric" id="metricManhattan" value="manhattan" /> Manhattan</label>
          </div>
        </div>
        <div class="control">
          <label>Weighting</label>
          <label class="inline"><input type="checkbox" id="weightInvDist" /> Inverse-distance</label>
        </div>

        <div class="control">
          <label>Mode</label>
          <div class="inline">
            <label class="inline"><input type="radio" name="mode" id="modeAdd" value="add" checked /> Add points</label>
            <label class="inline"><input type="radio" name="mode" id="modeClassify" value="classify" /> Classify</label>
          </div>
        </div>
        <div class="control">
          <label>Active class</label>
          <select id="classSelect">
            <option value="0">Class 0 (red)</option>
            <option value="1">Class 1 (blue)</option>
            <option value="2">Class 2 (green)</option>
          </select>
        </div>
        <div class="control">
          <label>Actions</label>
          <div class="inline">
            <button id="btnSample">Sample data</button>
            <button id="btnClear">Clear</button>
          </div>
        </div>
      </div>

      <div class="toggles">
        <label class="inline"><input type="checkbox" id="snapOddK" /> Prefer odd K</label>
        <label class="inline"><input type="checkbox" id="showNeighborLines" checked /> Show nearest neighbor lines</label>
        <label class="inline"><input type="checkbox" id="showBoundary" /> Show decision boundary</label>
      </div>

      <div class="legend">
        <div class="item"><span class="swatch c0"></span> Class 0</div>
        <div class="item"><span class="swatch c1"></span> Class 1</div>
        <div class="item"><span class="swatch c2"></span> Class 2</div>
        <div class="item muted">Left-click: add/classify â€¢ Right-click: delete nearest point</div>
      </div>

      <div class="canvas-wrap">
        <canvas id="canvas" width="960" height="600" aria-label="KNN canvas"></canvas>
        <div class="hint">Tip: Toggle "Decision boundary" to see KNN partitions. Inverse-distance weighting lets closer neighbors influence more.</div>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <h2>Classification Details</h2>
        <div class="info" id="infoSummary">
          Click the canvas in Classify mode to predict the label at that point.
        </div>
        <div class="kv" id="infoDetails"></div>
      </div>
      <div class="footer">
        KNN is a lazy, non-parametric method: it stores the dataset and classifies by majority vote among the k nearest training points.
      </div>
    </div>
  </div>

  <script>
    (function() {
      // Colors for up to 5 classes (we use 3 here)
      const CLASS_COLORS = [
        '#e74c3c', // red
        '#3498db', // blue
        '#2ecc71', // green
        '#f39c12', // orange
        '#9b59b6'  // purple
      ];
      const BG_COLOR = '#ffffff';
      const GRID_STEP = 20; // px grid lines
      const POINT_RADIUS = 6;
      const NEIGHBOR_LINE_ALPHA = 0.35;
      const DECISION_ALPHA = 0.16;
      const DELETE_THRESHOLD = 14; // px

      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // Controls
      const kRange = document.getElementById('kRange');
      const kVal = document.getElementById('kVal');
      const metricEuclidean = document.getElementById('metricEuclidean');
      const metricManhattan = document.getElementById('metricManhattan');
      const weightInvDist = document.getElementById('weightInvDist');
      const showBoundary = document.getElementById('showBoundary');
      const showNeighborLines = document.getElementById('showNeighborLines');
      const snapOddK = document.getElementById('snapOddK');
      const classSelect = document.getElementById('classSelect');
      const modeAdd = document.getElementById('modeAdd');
      const modeClassify = document.getElementById('modeClassify');
      const btnSample = document.getElementById('btnSample');
      const btnClear = document.getElementById('btnClear');

      const infoSummary = document.getElementById('infoSummary');
      const infoDetails = document.getElementById('infoDetails');

      // State
      let training = []; // {x, y, label}
      let testPoint = null; // {x, y}
      let lastResult = null; // classification result
      let boundaryDirty = true;

      // Utility to get mouse position
      function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
          x: (evt.clientX - rect.left) * scaleX,
          y: (evt.clientY - rect.top) * scaleY
        };
      }

      function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

      function setKDisplay(val) {
        kVal.textContent = String(val);
      }

      function currentK() {
        let k = parseInt(kRange.value, 10);
        if (snapOddK.checked && k % 2 === 0) {
          // Snap to nearest odd number
          k = (k === parseInt(kRange.max, 10)) ? k - 1 : k + 1;
          kRange.value = String(k);
        }
        setKDisplay(k);
        return k;
      }

      function metric() {
        return metricEuclidean.checked ? 'euclidean' : 'manhattan';
      }

      function dist(a, b) {
        if (metric() === 'euclidean') {
          const dx = a.x - b.x, dy = a.y - b.y;
          return Math.sqrt(dx*dx + dy*dy);
        } else {
          return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }
      }

      function classify(test, k, useInvDist) {
        if (training.length === 0) return null;
        k = Math.min(k, training.length);
        if (k <= 0) return null;

        // Compute all distances
        const arr = training.map((p, idx) => ({ index: idx, label: p.label, d: dist(test, p) }));
        arr.sort((a, b) => a.d - b.d);
        const neighbors = arr.slice(0, k);

        // Weighted or unweighted vote
        const votes = new Map(); // label -> weight
        neighbors.forEach(n => {
          const w = useInvDist ? 1 / (n.d + 1e-9) : 1;
          votes.set(n.label, (votes.get(n.label) || 0) + w);
        });

        // Determine predicted label, handling ties by nearest neighbor
        let bestLabel = null;
        let bestWeight = -Infinity;
        votes.forEach((w, lbl) => {
          if (w > bestWeight) {
            bestWeight = w;
            bestLabel = lbl;
          } else if (w === bestWeight) {
            // tie -> prefer label of nearest among neighbors
            const nearestForLbl = neighbors.find(n => n.label === lbl);
            const nearestForBest = neighbors.find(n => n.label === bestLabel);
            if (nearestForLbl && nearestForBest && nearestForLbl.d < nearestForBest.d) {
              bestLabel = lbl;
            } else if (nearestForLbl && nearestForBest && nearestForLbl.d === nearestForBest.d) {
              // still tie, prefer smaller label id
              if (lbl < bestLabel) bestLabel = lbl;
            }
          }
        });

        return { neighbors, votes, label: bestLabel, kUsed: k };
      }

      function drawPoint(p, color, radius = POINT_RADIUS, outline = true) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        if (outline) {
          ctx.lineWidth = 1.25;
          ctx.strokeStyle = 'rgba(0,0,0,0.45)';
          ctx.stroke();
        }
      }

      function drawCross(p, color, size = 9, width = 2) {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.beginPath();
        ctx.moveTo(-size, 0); ctx.lineTo(size, 0);
        ctx.moveTo(0, -size); ctx.lineTo(0, size);
        ctx.stroke();
        ctx.restore();
      }

      function drawNeighborLinesFromTest(result) {
        if (!result || !testPoint || result.neighbors.length === 0) return;
        ctx.save();
        ctx.lineWidth = 1.5;
        ctx.setLineDash([4, 3]);
        result.neighbors.forEach(n => {
          const p = training[n.index];
          const color = CLASS_COLORS[p.label % CLASS_COLORS.length];
          ctx.strokeStyle = hexToRgba(color, NEIGHBOR_LINE_ALPHA);
          ctx.beginPath();
          ctx.moveTo(testPoint.x, testPoint.y);
          ctx.lineTo(p.x, p.y);
          ctx.stroke();
          // Halo around neighbor point
          ctx.beginPath();
          ctx.arc(p.x, p.y, POINT_RADIUS + 3, 0, Math.PI * 2);
          ctx.strokeStyle = hexToRgba(color, 0.35);
          ctx.setLineDash([]);
          ctx.stroke();
        });
        ctx.restore();
      }

      function hexToRgba(hex, alpha) {
        const c = hex.replace('#','');
        const bigint = parseInt(c, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      function clearCanvas() {
        ctx.fillStyle = BG_COLOR;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        // Background grid drawn by CSS; we keep canvas background clean
      }

      function drawDecisionBoundary() {
        if (!showBoundary.checked) return;
        if (training.length === 0) return;
        const cell = 10; // resolution in pixels
        ctx.save();
        for (let y = cell/2; y < canvas.height; y += cell) {
          for (let x = cell/2; x < canvas.width; x += cell) {
            const res = classify({x, y}, currentK(), weightInvDist.checked);
            if (!res) continue;
            const color = hexToRgba(CLASS_COLORS[res.label % CLASS_COLORS.length], DECISION_ALPHA);
            ctx.fillStyle = color;
            ctx.fillRect(x - cell/2, y - cell/2, cell, cell);
          }
        }
        ctx.restore();
      }

      function drawAll() {
        clearCanvas();
        // Decision boundary first so points overlay on top
        drawDecisionBoundary();
        // Training points
        for (const p of training) {
          const color = CLASS_COLORS[p.label % CLASS_COLORS.length];
          drawPoint(p, color);
        }
        // Neighbor lines
        if (showNeighborLines.checked && lastResult && testPoint) {
          drawNeighborLinesFromTest(lastResult);
        }
        // Test point cross, and emphasized predicted region
        if (testPoint) {
          const color = lastResult ? CLASS_COLORS[lastResult.label % CLASS_COLORS.length] : '#111827';
          drawCross(testPoint, color, 10, 2);
          // small ring to indicate predicted class color
          if (lastResult) {
            ctx.beginPath();
            ctx.arc(testPoint.x, testPoint.y, POINT_RADIUS + 5, 0, Math.PI * 2);
            ctx.strokeStyle = hexToRgba(color, 0.65);
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        }
      }

      function updateInfoPanel() {
        if (!lastResult || !testPoint) {
          infoSummary.textContent = 'Click the canvas in Classify mode to predict the label at that point.';
          infoDetails.textContent = '';
          return;
        }
        const kUsed = lastResult.kUsed;
        const pred = lastResult.label;
        const color = CLASS_COLORS[pred % CLASS_COLORS.length];

        const votesStr = [...lastResult.votes.entries()]
          .sort((a,b) => a[0]-b[0])
          .map(([lbl, w]) => `Class ${lbl}: ${weightInvDist.checked ? w.toFixed(3) : w}`)
          .join('\n');

        const neighborStr = lastResult.neighbors
          .map((n, i) => {
            const p = training[n.index];
            const d = n.d.toFixed(2);
            return `#${i+1}: Class ${p.label} at (${Math.round(p.x)}, ${Math.round(p.y)}) d=${d}`;
          }).join('\n');

        infoSummary.innerHTML = `Predicted class: <span style="color:${color}; font-weight:600;">${pred}</span> using k=${kUsed} (${metric()} distance${weightInvDist.checked ? ', inverse-distance weighting' : ''}).`;
        infoDetails.textContent =
`Votes:
${votesStr}

Nearest ${kUsed} neighbors:
${neighborStr}`;
      }

      function addPoint(pos, label) {
        training.push({ x: clamp(pos.x, 0, canvas.width), y: clamp(pos.y, 0, canvas.height), label });
        boundaryDirty = true;
      }

      function deleteNearest(pos) {
        if (training.length === 0) return false;
        let bestIdx = -1, bestDist = Infinity;
        training.forEach((p, idx) => {
          const d = dist(pos, p);
          if (d < bestDist) {
            bestDist = d; bestIdx = idx;
          }
        });
        if (bestIdx >= 0 && bestDist <= DELETE_THRESHOLD) {
          training.splice(bestIdx, 1);
          boundaryDirty = true;
          return true;
        }
        return false;
      }

      function onCanvasClick(evt) {
        const pos = getMousePos(evt);
        if (modeAdd.checked) {
          addPoint(pos, parseInt(classSelect.value, 10));
          // If a test point exists, update classification to reflect data change
          if (testPoint) {
            lastResult = classify(testPoint, currentK(), weightInvDist.checked);
          }
        } else {
          testPoint = { x: pos.x, y: pos.y };
          lastResult = classify(testPoint, currentK(), weightInvDist.checked);
          updateInfoPanel();
        }
        drawAll();
        evt.preventDefault();
      }

      function onCanvasRightClick(evt) {
        evt.preventDefault();
        const pos = getMousePos(evt);
        const deleted = deleteNearest(pos);
        if (deleted) {
          if (testPoint) lastResult = classify(testPoint, currentK(), weightInvDist.checked);
          updateInfoPanel();
          drawAll();
        }
      }

      function onKChange() {
        const k = currentK();
        if (testPoint) {
          lastResult = classify(testPoint, k, weightInvDist.checked);
          updateInfoPanel();
        }
        drawAll();
      }

      function onOptionChange() {
        if (testPoint) {
          lastResult = classify(testPoint, currentK(), weightInvDist.checked);
          updateInfoPanel();
        }
        drawAll();
      }

      function sampleData() {
        training = [];
        const W = canvas.width, H = canvas.height;
        // Three Gaussian blobs
        const clusters = [
          { cx: W*0.30, cy: H*0.35, label: 0, n: 35, spread: 55 },
          { cx: W*0.65, cy: H*0.40, label: 1, n: 35, spread: 55 },
          { cx: W*0.48, cy: H*0.70, label: 2, n: 30, spread: 60 }
        ];
        for (const c of clusters) {
          for (let i=0; i<c.n; i++) {
            const [dx, dy] = gaussian2D(c.spread);
            addPoint({ x: c.cx + dx, y: c.cy + dy }, c.label);
          }
        }
        // Remove occasional points outside bounds
        training = training.filter(p => p.x >= 0 && p.x <= W && p.y >= 0 && p.y <= H);
        boundaryDirty = true;
        // Auto-place a test point
        testPoint = { x: W*0.50, y: H*0.50 };
        lastResult = classify(testPoint, currentK(), weightInvDist.checked);
        updateInfoPanel();
        drawAll();
      }

      function gaussian2D(spread) {
        // Box-Muller transform
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        const r = Math.sqrt(-2.0 * Math.log(u));
        const theta = 2.0 * Math.PI * v;
        const z0 = r * Math.cos(theta);
        const z1 = r * Math.sin(theta);
        return [z0 * spread, z1 * spread];
      }

      function clearAll() {
        training = [];
        testPoint = null;
        lastResult = null;
        boundaryDirty = true;
        infoSummary.textContent = 'Dataset cleared. Add points, then click Classify.';
        infoDetails.textContent = '';
        drawAll();
      }

      // Event listeners
      canvas.addEventListener('click', onCanvasClick);
      canvas.addEventListener('contextmenu', onCanvasRightClick);
      kRange.addEventListener('input', onKChange);
      snapOddK.addEventListener('change', onKChange);
      metricEuclidean.addEventListener('change', onOptionChange);
      metricManhattan.addEventListener('change', onOptionChange);
      weightInvDist.addEventListener('change', onOptionChange);
      showNeighborLines.addEventListener('change', drawAll);
      showBoundary.addEventListener('change', drawAll);
      classSelect.addEventListener('change', () => {});
      modeAdd.addEventListener('change', () => {
        infoSummary.textContent = 'Add points by left-clicking. Right-click to delete nearest point.';
        infoDetails.textContent = '';
      });
      modeClassify.addEventListener('change', () => {
        infoSummary.textContent = 'Click the canvas to classify that point.';
        infoDetails.textContent = '';
      });
      btnSample.addEventListener('click', sampleData);
      btnClear.addEventListener('click', clearAll);

      // Initial draw
      setKDisplay(parseInt(kRange.value, 10));
      drawAll();

      // Accessibility: keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if (e.key === 'b') {
          showBoundary.checked = !showBoundary.checked;
          drawAll();
        } else if (e.key === 'l') {
          showNeighborLines.checked = !showNeighborLines.checked;
          drawAll();
        } else if (e.key === 'k') {
          let k = parseInt(kRange.value, 10);
          k = clamp(k + (e.shiftKey ? -1 : 1), parseInt(kRange.min, 10), parseInt(kRange.max, 10));
          kRange.value = String(k);
          onKChange();
        }
      });

      // Resize handling to keep crispness; keep fixed internal size and scale with CSS, so we don't need DPR scaling
      window.addEventListener('resize', () => {
        // No-op; CSS scales the canvas view, internal pixels remain constant
      });

    })();
  </script>
</body>
</html>