<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Knapsack Problem Visualizer</title>
<style>
  :root{
    --bg:#0f172a;
    --panel:#111827;
    --muted:#334155;
    --text:#e5e7eb;
    --accent:#22d3ee;
    --accent2:#f59e0b;
    --good:#22c55e;
    --bad:#ef4444;
    --shadow:rgba(0,0,0,0.3);
    --cell:#1f2937;
    --cell2:#0b2239;
    --hilite:#2563eb;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;
    background:linear-gradient(180deg,#0b1222,#0f172a);
    color:var(--text);
    line-height:1.4;
    min-height:100vh;
  }
  header{
    padding:28px 20px 16px;
    text-align:center;
  }
  h1{
    margin:0 0 8px;
    font-size:28px;
    letter-spacing:.3px;
  }
  .sub{
    opacity:.8;
    font-size:14px;
  }
  .container{
    max-width:1200px;
    margin:0 auto;
    padding:16px;
    display:grid;
    grid-template-columns: 1.05fr 1.2fr;
    gap:16px;
  }
  .panel{
    background:linear-gradient(180deg,#101826,#0d1522);
    border:1px solid #1f2a44;
    border-radius:14px;
    box-shadow:0 10px 30px var(--shadow);
    overflow:hidden;
  }
  .panel h2{
    margin:0;
    padding:14px 16px;
    font-size:16px;
    border-bottom:1px solid #1f2a44;
    background:linear-gradient(180deg,#0f1929,#0e1725);
  }
  .section{
    padding:14px 16px 18px;
  }
  .grid{
    display:grid;
    gap:10px;
    grid-template-columns: repeat(12, 1fr);
    align-items:end;
  }
  label{
    font-size:12px;
    opacity:.9;
    display:block;
    margin-bottom:6px;
  }
  select,input[type="number"],input[type="text"]{
    width:100%;
    padding:10px 12px;
    background:#0b1320;
    color:var(--text);
    border:1px solid #1f2a44;
    border-radius:10px;
    outline:none;
    transition:.15s border;
  }
  select:focus, input:focus{
    border-color:#2b78ff;
    box-shadow:0 0 0 3px rgba(43,120,255,0.15);
  }
  .controls{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
  }
  button{
    background:linear-gradient(180deg,#16325a,#132945);
    border:1px solid #264b80;
    color:#dce7ff;
    padding:10px 14px;
    border-radius:10px;
    cursor:pointer;
    transition:.15s transform, .15s filter;
  }
  button:hover{ filter:brightness(1.1) }
  button:active{ transform:translateY(1px) }
  button.secondary{
    background:linear-gradient(180deg,#142035,#101a2b);
    border-color:#263246;
    color:#cdd7ea;
  }
  button.warn{
    background:linear-gradient(180deg,#4a1720,#3b1219);
    border-color:#7a2431;
    color:#ffd9df;
  }
  .row{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
  }
  .items{
    margin-top:8px;
    border:1px solid #1f2a44;
    border-radius:10px;
    overflow:hidden;
  }
  .items header, .items .item{
    display:grid;
    grid-template-columns: 2fr 1fr 1fr 64px;
    gap:8px;
    padding:10px 10px;
    align-items:center;
  }
  .items header{
    background:linear-gradient(180deg,#0f1929,#0e1725);
    font-size:12px;
    opacity:.9;
    border-bottom:1px solid #1f2a44;
  }
  .items .item{
    background:#0a1323;
    border-bottom:1px solid #131f33;
  }
  .items .item:last-child{ border-bottom:none }
  .items .item input{
    width:100%;
    padding:8px 10px;
    background:#07101d;
    border:1px solid #17243a;
    border-radius:8px;
    color:var(--text);
  }
  .del{
    background:linear-gradient(180deg,#2b1a1d,#231417);
    border-color:#5a2a31;
    color:#ffdfe6;
    padding:8px 10px;
  }
  .hint{
    font-size:12px;
    opacity:.8;
    margin-top:6px;
  }
  .badge{
    display:inline-block;
    background:#0c2038;
    border:1px solid #20426e;
    padding:4px 8px;
    border-radius:999px;
    font-size:12px;
    margin-right:6px;
  }
  .out{
    padding:0;
    display:flex;
    flex-direction:column;
    gap:0;
  }
  .out .top{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    padding:12px 14px;
    border-bottom:1px solid #1f2a44;
    align-items:center;
    background:linear-gradient(180deg,#0f1929,#0e1725);
  }
  .stat{
    background:#0b1930;
    border:1px solid #1f2a44;
    padding:8px 10px;
    border-radius:8px;
    font-size:13px;
  }
  .viz{
    padding:14px;
    display:grid;
    grid-template-columns: 1fr;
    gap:14px;
  }
  .canvas{
    background:#081325;
    border:1px solid #1f2a44;
    border-radius:12px;
    padding:12px;
    min-height:180px;
    position:relative;
    overflow:auto;
  }
  .table{
    display:inline-grid;
    grid-auto-rows: 28px;
    grid-template-columns: 120px repeat(var(--cols), 48px);
    border:1px solid #1f2a44;
    border-radius:10px;
    overflow:hidden;
  }
  .cell{
    border-right:1px solid #1b2841;
    border-bottom:1px solid #1b2841;
    background:#0a1628;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:12px;
    min-width:48px;
    color:#cfe2ff;
  }
  .cell.header{
    background:#0d1b32;
    font-weight:600;
  }
  .cell.itemhead{
    justify-content:flex-start;
    padding-left:8px;
  }
  .cell.active{
    outline:2px solid var(--hilite);
    z-index:2;
  }
  .cell.best{
    background:linear-gradient(180deg,#0e203e,#0b1a33);
  }
  .legend{
    font-size:12px;
    opacity:.9;
  }
  .bar{
    display:flex;
    gap:2px;
    height:28px;
    background:#0b1b30;
    border:1px solid #1f2a44;
    border-radius:8px;
    overflow:hidden;
  }
  .seg{
    height:100%;
  }
  .seglabel{
    position:relative;
    top:-2px;
    font-size:11px;
    opacity:.9;
    white-space:nowrap;
  }
  .list{
    display:grid;
    gap:6px;
  }
  .list .rowi{
    display:grid;
    grid-template-columns: 1fr auto auto auto;
    gap:10px;
    padding:8px 10px;
    background:#0a1628;
    border:1px solid #1f2a44;
    border-radius:8px;
    align-items:center;
  }
  .footer{
    padding:12px 14px;
    border-top:1px solid #1f2a44;
    background:linear-gradient(180deg,#0e1725,#0f1929);
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    justify-content:space-between;
    align-items:center;
  }
  .range{
    display:flex;
    align-items:center;
    gap:8px;
  }
  input[type="range"]{ width:160px }
  .note{
    font-size:12px;
    opacity:.8;
  }
  .err{
    color:#ffb4bd;
  }
  .ok{
    color:#a7f3d0;
  }
  .pill{
    padding:3px 8px;
    border-radius:999px;
    border:1px solid #284a7a;
    background:#0b2239;
    font-size:12px;
  }
  @media (max-width: 980px){
    .container{ grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
<header>
  <h1>Knapsack Problem Visualizer</h1>
  <div class="sub">Explore 0/1, Unbounded, and Fractional knapsack with interactive items, dynamic programming tables, and step-by-step animation.</div>
</header>

<div class="container">
  <div class="panel">
    <h2>Setup</h2>
    <div class="section">
      <div class="grid" style="grid-template-columns: repeat(12, 1fr); gap:12px;">
        <div style="grid-column: span 6;">
          <label for="type">Problem type</label>
          <select id="type">
            <option value="01">0/1 Knapsack (each item at most once)</option>
            <option value="unbounded">Unbounded Knapsack (infinite copies)</option>
            <option value="fractional">Fractional Knapsack (greedy, allow fractions)</option>
          </select>
        </div>
        <div style="grid-column: span 3;">
          <label for="capacity">Capacity</label>
          <input type="number" id="capacity" min="0" step="1" value="5" />
        </div>
        <div style="grid-column: span 3;">
          <label>&nbsp;</label>
          <div class="controls">
            <button id="random">Random items</button>
            <button id="clear" class="secondary">Clear items</button>
          </div>
        </div>
      </div>

      <div class="items" id="items">
        <header>
          <div>Name</div>
          <div>Weight</div>
          <div>Value</div>
          <div>Action</div>
        </header>
        <div id="itemsBody"></div>
      </div>

      <div class="row" style="margin-top:10px;">
        <button id="addItem">Add item</button>
        <span class="hint">
          For 0/1 and Unbounded: weights must be non-negative integers. For Fractional: weights can be decimal. Values must be non-negative.
        </span>
      </div>
    </div>

    <h2>Run</h2>
    <div class="section">
      <div class="row">
        <button id="solve">Solve</button>
        <button id="stop" class="warn" disabled>Stop</button>
        <span class="badge" id="algoInfo">Algorithm: DP</span>
      </div>
      <div class="row" style="margin-top:8px;">
        <label class="pill"><input type="checkbox" id="animate" checked style="accent-color:#22d3ee; vertical-align:middle; margin-right:6px;"> Animate</label>
        <div class="range">
          <label for="speed">Speed</label>
          <input type="range" id="speed" min="10" max="800" value="150" />
        </div>
        <div class="note" id="notes"></div>
      </div>
    </div>
  </div>

  <div class="panel out">
    <div class="top">
      <div class="stat" id="bestVal">Best value: -</div>
      <div class="stat" id="usedCap">Used capacity: -</div>
      <div class="stat" id="optSet">Chosen: -</div>
      <div class="stat" id="complexity">Complexity: -</div>
      <div style="flex:1"></div>
      <div class="legend">Legend: <span class="pill">Value</span> <span class="pill">Take decision</span> <span class="pill">Capacity columns</span></div>
    </div>
    <div class="viz">
      <div id="explain" class="note"></div>
      <div class="canvas" id="canvas">
        <!-- dynamic rendering -->
      </div>
      <div id="selectionList" class="list"></div>
    </div>
    <div class="footer">
      <div class="note" id="status">Ready.</div>
      <div class="row">
        <button class="secondary" id="example">Load example</button>
        <button class="secondary" id="tiny">Tiny</button>
        <button class="secondary" id="dense">Many items</button>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const itemsBody = document.getElementById('itemsBody');
  const typeSel = document.getElementById('type');
  const capacityEl = document.getElementById('capacity');
  const addBtn = document.getElementById('addItem');
  const randomBtn = document.getElementById('random');
  const clearBtn = document.getElementById('clear');
  const solveBtn = document.getElementById('solve');
  const stopBtn = document.getElementById('stop');
  const animateChk = document.getElementById('animate');
  const speedEl = document.getElementById('speed');
  const canvas = document.getElementById('canvas');
  const selectionList = document.getElementById('selectionList');
  const statusEl = document.getElementById('status');
  const bestValEl = document.getElementById('bestVal');
  const usedCapEl = document.getElementById('usedCap');
  const optSetEl = document.getElementById('optSet');
  const complexityEl = document.getElementById('complexity');
  const notesEl = document.getElementById('notes');
  const algoInfo = document.getElementById('algoInfo');
  const explainEl = document.getElementById('explain');
  const exampleBtn = document.getElementById('example');
  const tinyBtn = document.getElementById('tiny');
  const denseBtn = document.getElementById('dense');

  let animHandle = null;
  let animQueue = [];
  let animIndex = 0;
  let isAnimating = false;
  let colors = [
    '#60a5fa','#34d399','#f472b6','#f59e0b','#a78bfa','#22d3ee',
    '#ef4444','#10b981','#eab308','#c084fc','#38bdf8','#f43f5e'
  ];
  function colorFor(i){ return colors[i % colors.length]; }

  function addItemRow(name='', weight='', value=''){
    const row = document.createElement('div');
    row.className = 'item';
    row.innerHTML = `
      <input type="text" placeholder="Name" value="${name}"/>
      <input type="number" placeholder="Weight" min="0" step="0.01" value="${weight}"/>
      <input type="number" placeholder="Value" min="0" step="0.01" value="${value}"/>
      <div><button class="del">Remove</button></div>
    `;
    row.querySelector('.del').onclick = () => {
      row.remove();
      updateNote();
    };
    itemsBody.appendChild(row);
  }
  function clearItems(){
    itemsBody.innerHTML = '';
  }
  function getItems(){
    const rows = [...itemsBody.querySelectorAll('.item')];
    const items = [];
    for (let i=0;i<rows.length;i++){
      const [nameEl, wEl, vEl] = rows[i].querySelectorAll('input');
      const name = nameEl.value.trim() || `Item ${i+1}`;
      const w = parseFloat(wEl.value);
      const v = parseFloat(vEl.value);
      if (Number.isFinite(w) && Number.isFinite(v) && w >= 0 && v >= 0){
        items.push({ name, weight: w, value: v, idx: i });
      }
    }
    return items;
  }
  function setStatus(msg, ok=true){
    statusEl.textContent = msg;
    statusEl.className = ok ? 'note ok' : 'note err';
  }
  function setExplain(){
    const t = typeSel.value;
    if (t === '01'){
      explainEl.innerHTML = "0/1 Knapsack: Dynamic programming O(n·W) builds a table of best value using first i items and capacity w. We either skip the item or take it once if weight fits. Backtracking yields chosen items.";
      algoInfo.textContent = "Algorithm: Dynamic Programming (2D)";
      complexityEl.textContent = "Complexity: Time O(n·W), Space O(n·W).";
      notesEl.textContent = "Requires integer capacity and item weights.";
    } else if (t === 'unbounded'){
      explainEl.innerHTML = "Unbounded Knapsack: Dynamic programming O(n·W) with 1D array over capacity. For each capacity, try taking any item again and again.";
      algoInfo.textContent = "Algorithm: Dynamic Programming (1D)";
      complexityEl.textContent = "Complexity: Time O(n·W), Space O(W).";
      notesEl.textContent = "Requires integer capacity and item weights.";
    } else {
      explainEl.innerHTML = "Fractional Knapsack: Greedy O(n log n) by value/weight density. Take highest-density items, possibly fractions, until capacity is full.";
      algoInfo.textContent = "Algorithm: Greedy (sorting by value/weight)";
      complexityEl.textContent = "Complexity: Time O(n log n), Space O(1) or O(n).";
      notesEl.textContent = "Allows decimal weights; exact optimal with fractions.";
    }
  }

  function validate(items, capacity){
    if (!Number.isFinite(capacity) || capacity < 0){
      return "Capacity must be a non-negative number.";
    }
    if (items.length === 0){
      return "Please add at least one item.";
    }
    for (const it of items){
      if (!(Number.isFinite(it.value) && it.value >= 0)) return `Invalid value for ${it.name}.`;
      if (!(Number.isFinite(it.weight) && it.weight >= 0)) return `Invalid weight for ${it.name}.`;
    }
    const t = typeSel.value;
    if (t !== 'fractional'){
      if (!Number.isInteger(capacity)) return "Capacity must be an integer for DP variants.";
      for (const it of items){
        if (!Number.isInteger(it.weight)) return `Weight of ${it.name} must be an integer for DP variants.`;
      }
    }
    return null;
  }

  function resetOutput(){
    bestValEl.textContent = "Best value: -";
    usedCapEl.textContent = "Used capacity: -";
    optSetEl.textContent = "Chosen: -";
    selectionList.innerHTML = "";
    canvas.innerHTML = "";
  }

  function renderSelection(itemsChosen, type, totalValue, totalWeight){
    bestValEl.textContent = `Best value: ${fmt(totalValue)}`;
    usedCapEl.textContent = `Used capacity: ${fmt(totalWeight)}`;
    if (itemsChosen.length === 0){
      optSetEl.textContent = "Chosen: (none)";
    } else {
      const names = itemsChosen.map(c => {
        const qty = type === 'fractional' ? (c.fraction === 1 ? "1" : c.fraction.toFixed(2)) : (c.count ?? 1);
        return `${c.item.name} × ${qty}`;
      });
      optSetEl.textContent = "Chosen: " + names.join(", ");
    }
    selectionList.innerHTML = "";
    if (type === 'fractional'){
      // Bar visualization for fractional fill
      const bar = document.createElement('div');
      bar.className = 'bar';
      let total = itemsChosen.reduce((s,x)=> s + x.weightTaken, 0);
      const cap = parseFloat(capacityEl.value);
      if (cap <= 0) total = 0;
      if (cap > 0){
        for (let i=0;i<itemsChosen.length;i++){
          const c = itemsChosen[i];
          const seg = document.createElement('div');
          const pct = (c.weightTaken / cap) * 100;
          seg.className = 'seg';
          seg.style.width = Math.max(0.0001, pct) + '%';
          seg.style.background = colorFor(c.item.idx);
          bar.appendChild(seg);
        }
        if (total < cap){
          const rem = document.createElement('div');
          rem.className = 'seg';
          rem.style.width = Math.max(0.0001, (100 - (total/cap)*100)) + '%';
          rem.style.background = '#071426';
          bar.appendChild(rem);
        }
      }
      const wrap = document.createElement('div');
      wrap.appendChild(bar);
      wrap.style.marginBottom = "6px";
      canvas.appendChild(wrap);
    }
    // Detailed list
    for (const c of itemsChosen){
      const row = document.createElement('div');
      row.className = 'rowi';
      const dot = document.createElement('div');
      dot.textContent = c.item.name;
      dot.style.display = 'flex';
      dot.style.alignItems = 'center';
      const badge = document.createElement('span');
      badge.style.display = 'inline-block';
      badge.style.width = '10px';
      badge.style.height = '10px';
      badge.style.borderRadius = '50%';
      badge.style.marginRight = '8px';
      badge.style.background = colorFor(c.item.idx);
      dot.prepend(badge);
      const w = document.createElement('div'); w.textContent = `w=${fmt(c.item.weight)}`;
      const v = document.createElement('div'); v.textContent = `v=${fmt(c.item.value)}`;
      const q = document.createElement('div');
      if (type === 'fractional'){
        q.textContent = `fraction=${fmt(c.fraction)} (taken w=${fmt(c.weightTaken)}, v=${fmt(c.valueTaken)})`;
      } else {
        q.textContent = `count=${c.count ?? 1}`;
      }
      row.append(dot, w, v, q);
      selectionList.appendChild(row);
    }
  }

  function fmt(x){
    return Number.isInteger(x) ? x.toString() : (+x.toFixed(4)).toString().replace(/\.?0+$/,'');
  }

  // 0/1 Knapsack DP (2D)
  function solve01(items, W, onStep){
    const n = items.length;
    const dp = Array.from({length: n+1}, ()=> Array(W+1).fill(0));
    const take = Array.from({length: n+1}, ()=> Array(W+1).fill(false));

    const steps = [];
    for (let i=1;i<=n;i++){
      const wt = items[i-1].weight|0;
      const val = items[i-1].value;
      for (let w=0;w<=W;w++){
        const skip = dp[i-1][w];
        let opt = skip;
        let took = false;
        if (wt <= w){
          const cand = dp[i-1][w-wt] + val;
          if (cand > opt){
            opt = cand;
            took = true;
          }
        }
        dp[i][w] = opt;
        take[i][w] = took;
        steps.push({i,w,val:opt,took,iName:items[i-1].name});
        if (onStep) onStep({phase:'fill01', i, w, value: opt, took});
      }
    }
    // Reconstruct
    let w = W;
    const chosen = [];
    for (let i=n;i>=1;i--){
      if (take[i][w]){
        chosen.push(items[i-1]);
        w -= items[i-1].weight;
      }
    }
    const best = dp[n][W];
    const used = chosen.reduce((s,it)=> s+it.weight,0);
    return { dp, take, chosen, best, used, steps };
  }

  // Unbounded Knapsack DP (1D)
  function solveUnbounded(items, W, onStep){
    const dp = Array(W+1).fill(0);
    const choice = Array(W+1).fill(-1); // item idx chosen at capacity c
    const steps = [];
    for (let c=0;c<=W;c++){
      let best = dp[c];
      for (let j=0;j<items.length;j++){
        const it = items[j];
        const wt = it.weight|0;
        if (wt <= c){
          const val = dp[c-wt] + it.value;
          if (val > best){
            best = val;
            choice[c] = j;
          }
          steps.push({c, j, candidate: val, best});
          if (onStep) onStep({phase:'fillUnb', c, j, candidate: val, best});
        }
      }
      dp[c] = best;
    }
    // reconstruct
    let c = W;
    const counts = new Map();
    while (c > 0 && choice[c] !== -1){
      const j = choice[c];
      counts.set(j, (counts.get(j) || 0) + 1);
      c -= items[j].weight|0;
      if (onStep) onStep({phase:'chooseUnb', c, j});
    }
    const chosen = [];
    let used = 0;
    counts.forEach((count,j)=>{
      chosen.push({ item: items[j], count });
      used += items[j].weight * count;
    });
    const best = dp[W];
    return { dp, choice, chosen, best, used, steps };
  }

  // Fractional Knapsack Greedy
  function solveFractional(items, W, onStep){
    let cap = W;
    const sorted = items
      .map((it,i)=> ({...it, density: it.value/(it.weight||1e-9), origIdx:i}))
      .sort((a,b)=> b.density - a.density);
    const chosen = [];
    let totalValue = 0;
    let used = 0;
    for (let k=0;k<sorted.length;k++){
      const it = sorted[k];
      if (cap <= 0) break;
      if (it.weight === 0){
        if (it.value > 0){
          // Zero weight, positive value: take fully but won't change capacity
          chosen.push({ item: it, fraction: 1, weightTaken: 0, valueTaken: it.value });
          totalValue += it.value;
        }
        continue;
      }
      const takeW = Math.min(it.weight, cap);
      const fraction = takeW / it.weight;
      const addVal = it.value * fraction;
      chosen.push({ item: it, fraction, weightTaken: takeW, valueTaken: addVal });
      cap -= takeW;
      used += takeW;
      totalValue += addVal;
      if (onStep) onStep({phase:'greedy', k, item: it, takeW, fraction, totalValue, used});
    }
    // Map back to original items indices for coloring
    const mapped = chosen.map(c => ({
      item: { name: c.item.name, weight: c.item.weight, value: c.item.value, idx: c.item.idx ?? c.item.origIdx },
      fraction: c.fraction, weightTaken: c.weightTaken, valueTaken: c.valueTaken
    }));
    return { chosen: mapped, best: totalValue, used, steps: [] };
  }

  // Rendering functions
  function renderDPTable01(dp, items, active=null){
    // dp is (n+1) x (W+1)
    const n = dp.length - 1;
    const W = dp[0].length - 1;
    canvas.innerHTML = '';
    const table = document.createElement('div');
    table.className = 'table';
    table.style.setProperty('--cols', (W+2).toString());
    // top row headers
    const corner = document.createElement('div');
    corner.className = 'cell header';
    corner.textContent = 'Items/Capacity';
    table.appendChild(corner);
    const itemHdr = document.createElement('div');
    itemHdr.className = 'cell header';
    itemHdr.textContent = 'Item';
    table.appendChild(itemHdr);
    for (let w=0;w<=W;w++){
      const h = document.createElement('div');
      h.className = 'cell header';
      h.textContent = w;
      table.appendChild(h);
    }
    // rows
    for (let i=0;i<=n;i++){
      // item label
      const lbl0 = document.createElement('div');
      lbl0.className = 'cell itemhead';
      lbl0.textContent = i === 0 ? '0 items' : `${i}. ${items[i-1].name} (w=${items[i-1].weight}, v=${items[i-1].value})`;
      lbl0.style.gridColumn = '1 / span 2';
      table.appendChild(lbl0);
      for (let w=0;w<=W;w++){
        const c = document.createElement('div');
        c.className = 'cell';
        c.textContent = dp[i][w];
        c.dataset.i = i; c.dataset.w = w;
        if (active && active.i === i && active.w === w){
          c.classList.add('active');
        }
        table.appendChild(c);
      }
    }
    canvas.appendChild(table);
  }

  function renderDPArrayUnbounded(dp, choice, items, active=null){
    canvas.innerHTML = '';
    const W = dp.length - 1;
    const wrap = document.createElement('div');
    wrap.style.display = 'grid';
    wrap.style.gridTemplateColumns = 'repeat(auto-fit, minmax(48px,1fr))';
    wrap.style.gap = '6px';
    for (let c=0;c<=W;c++){
      const cell = document.createElement('div');
      cell.style.border = '1px solid #1f2a44';
      cell.style.background = '#0a1628';
      cell.style.borderRadius = '8px';
      cell.style.padding = '6px';
      cell.style.textAlign = 'center';
      cell.innerHTML = `<div style="font-size:11px; opacity:.8">c=${c}</div>
                        <div style="font-weight:700; font-size:14px">${dp[c]}</div>
                        <div style="font-size:11px; opacity:.8">${choice[c]!==-1 ? 'take '+items[choice[c]].name : '-'}</div>`;
      if (active && active.c === c){
        cell.style.outline = '2px solid var(--hilite)';
      }
      wrap.appendChild(cell);
    }
    canvas.appendChild(wrap);
  }

  function renderFractionalBar(chosen, capacity){
    canvas.innerHTML = '';
    const title = document.createElement('div');
    title.textContent = 'Capacity fill';
    title.style.marginBottom = '6px';
    canvas.appendChild(title);
    const bar = document.createElement('div');
    bar.className = 'bar';
    const used = chosen.reduce((s,x)=> s+x.weightTaken, 0);
    if (capacity > 0){
      chosen.forEach(c=>{
        const seg = document.createElement('div');
        seg.className='seg';
        seg.style.background = colorFor(c.item.idx);
        seg.style.width = Math.max(0.001, (c.weightTaken/capacity)*100) + '%';
        seg.title = `${c.item.name} (fraction ${fmt(c.fraction)})`;
        bar.appendChild(seg);
      });
      if (used < capacity){
        const rem = document.createElement('div');
        rem.className = 'seg';
        rem.style.background = '#071426';
        rem.style.width = Math.max(0.001, ((capacity-used)/capacity)*100) + '%';
        bar.appendChild(rem);
      }
    }
    canvas.appendChild(bar);
    const detail = document.createElement('div');
    detail.style.marginTop = '8px';
    detail.innerHTML = chosen.map(c => {
      return `<span class="pill" style="border-color:#1d406c;background:#0b2239;"><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${colorFor(c.item.idx)};margin-right:6px;vertical-align:middle;"></span>${c.item.name}: fraction=${fmt(c.fraction)}, w=${fmt(c.weightTaken)}, v=${fmt(c.valueTaken)}</span>`;
    }).join(' ');
    canvas.appendChild(detail);
  }

  function stopAnimation(){
    if (animHandle){
      clearTimeout(animHandle);
      animHandle = null;
    }
    isAnimating = false;
    animQueue = [];
    animIndex = 0;
    stopBtn.disabled = true;
    solveBtn.disabled = false;
  }

  function animateSteps(steps, renderer, done){
    stopAnimation(); // reset
    if (steps.length === 0){
      renderer(null);
      done && done();
      return;
    }
    isAnimating = true;
    stopBtn.disabled = false;
    solveBtn.disabled = true;
    animQueue = steps;
    animIndex = 0;

    const loop = ()=>{
      if (!isAnimating) return;
      const s = animQueue[animIndex];
      renderer(s);
      animIndex++;
      if (animIndex >= animQueue.length){
        stopAnimation();
        done && done();
        return;
      }
      const delay = Math.max(10, +speedEl.value);
      animHandle = setTimeout(loop, delay);
    };
    loop();
  }

  function solve(){
    stopAnimation();
    resetOutput();
    const items = getItems();
    const type = typeSel.value;
    const capacity = type === 'fractional' ? parseFloat(capacityEl.value) : (capacityEl.value|0);
    const err = validate(items, capacity);
    if (err){
      setStatus(err, false);
      return;
    }
    setStatus('Solving...');
    selectionList.innerHTML = '';
    const animate = animateChk.checked;

    if (type === '01'){
      const onStep = null; // We'll animate after building steps array to simplify
      const res = solve01(items, capacity, onStep);
      const render = (s)=>{
        if (!s){
          renderDPTable01(res.dp, items, null);
          return;
        }
        renderDPTable01(res.dp, items, {i:s.i, w:s.w});
      };
      if (animate){
        // Create a synthetic steps array matching cell traversal
        const steps = [];
        for (let i=1;i<res.dp.length;i++){
          for (let w=0;w<res.dp[0].length;w++){
            steps.push({i,w});
          }
        }
        animateSteps(steps, render, ()=>{
          renderDPTable01(res.dp, items, null);
          const chosen = res.chosen.map(it => ({ item: it, count: 1 }));
          renderSelection(chosen, '01', res.best, res.used);
          setStatus('Done.');
        });
      } else {
        renderDPTable01(res.dp, items, null);
        const chosen = res.chosen.map(it => ({ item: it, count: 1 }));
        renderSelection(chosen, '01', res.best, res.used);
        setStatus('Done.');
      }
    } else if (type === 'unbounded'){
      const res = solveUnbounded(items, capacity, null);
      const render = (s)=>{
        renderDPArrayUnbounded(res.dp, res.choice, items, s ? {c: s.c} : null);
      };
      if (animate){
        const steps = [];
        for (let c=0;c<res.dp.length;c++){
          steps.push({c});
        }
        animateSteps(steps, render, ()=>{
          renderDPArrayUnbounded(res.dp, res.choice, items, null);
          renderSelection(res.chosen, 'unbounded', res.best, res.used);
          setStatus('Done.');
        });
      } else {
        renderDPArrayUnbounded(res.dp, res.choice, items, null);
        renderSelection(res.chosen, 'unbounded', res.best, res.used);
        setStatus('Done.');
      }
    } else {
      const res = solveFractional(items, capacity, null);
      if (animate){
        // Animate greedy picks one by one
        const steps = res.chosen.map((c,idx)=> ({idx}));
        animateSteps(steps, (s)=>{
          const partial = res.chosen.slice(0, s.idx+1);
          renderFractionalBar(partial, capacity);
        }, ()=>{
          renderFractionalBar(res.chosen, capacity);
          renderSelection(res.chosen, 'fractional', res.best, res.used);
          setStatus('Done.');
        });
      } else {
        renderFractionalBar(res.chosen, capacity);
        renderSelection(res.chosen, 'fractional', res.best, res.used);
        setStatus('Done.');
      }
    }
  }

  // Examples
  function loadExample(){
    clearItems();
    addItemRow('A', 2, 12);
    addItemRow('B', 1, 10);
    addItemRow('C', 3, 20);
    addItemRow('D', 2, 15);
    capacityEl.value = 5;
  }
  function loadTiny(){
    clearItems();
    addItemRow('Gold', 2, 3);
    addItemRow('Silver', 3, 4);
    capacityEl.value = 3;
  }
  function loadDense(){
    clearItems();
    const n=12;
    for (let i=0;i<n;i++){
      const w = Math.floor(Math.random()*7)+1;
      const v = Math.floor(Math.random()*18)+3;
      addItemRow(`I${i+1}`, w, v);
    }
    capacityEl.value = 25;
  }
  function randomItems(){
    clearItems();
    const n = Math.floor(Math.random()*6)+5;
    for (let i=0;i<n;i++){
      const w = Math.floor(Math.random()*9)+1;
      const v = Math.floor(Math.random()*20)+5;
      addItemRow(`Item ${i+1}`, w, v);
    }
    capacityEl.value = Math.floor(Math.random()*20)+10;
  }

  function updateNote(){
    const items = getItems();
    document.getElementById('optSet').textContent = "Chosen: -";
    if (items.length > 0){
      const sumW = items.reduce((s,it)=> s+it.weight,0);
      const sumV = items.reduce((s,it)=> s+it.value,0);
      notesEl.textContent = `Items: ${items.length}, total weight ${fmt(sumW)}, total value ${fmt(sumV)}`;
    } else {
      notesEl.textContent = '';
    }
  }

  addBtn.onclick = ()=> { addItemRow('', '', ''); updateNote(); };
  randomBtn.onclick = ()=> { randomItems(); resetOutput(); setStatus('Randomized.'); updateNote(); };
  clearBtn.onclick = ()=> { clearItems(); resetOutput(); setStatus('Cleared.'); updateNote(); };
  solveBtn.onclick = solve;
  stopBtn.onclick = ()=> { stopAnimation(); setStatus('Stopped.', false); };
  typeSel.onchange = ()=> { setExplain(); resetOutput(); };
  exampleBtn.onclick = ()=> { loadExample(); resetOutput(); updateNote(); setStatus('Example loaded.'); };
  tinyBtn.onclick = ()=> { loadTiny(); resetOutput(); updateNote(); setStatus('Tiny example loaded.'); };
  denseBtn.onclick = ()=> { loadDense(); resetOutput(); updateNote(); setStatus('Large example loaded.'); };

  // Initialize
  loadExample();
  setExplain();
  updateNote();

  // Accessibility: pressing Enter in inputs triggers solve
  itemsBody.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter'){ solve(); }
  });
})();
</script>
</body>
</html>