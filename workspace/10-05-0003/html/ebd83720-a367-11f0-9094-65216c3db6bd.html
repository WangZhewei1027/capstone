<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Deque (Double-Ended Queue) Interactive Demo</title>
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --accent: #60a5fa;
    --accent2: #34d399;
    --warn: #f59e0b;
    --text: #e5e7eb;
    --muted: #9ca3af;
    --node: #1f2937;
    --border: #374151;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    background: var(--bg);
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
  header {
    padding: 16px 20px;
    border-bottom: 1px solid var(--border);
  }
  h1 {
    margin: 0;
    font-weight: 600;
    font-size: 20px;
  }
  .container {
    padding: 16px 20px 40px;
    max-width: 1100px;
    margin: 0 auto;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-bottom: 12px;
  }
  input[type="text"] {
    background: var(--panel);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 8px 10px;
    border-radius: 8px;
    min-width: 180px;
  }
  button {
    background: var(--panel);
    color: var(--text);
    border: 1px solid var(--border);
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    transition: background .15s, border-color .15s, transform .05s;
  }
  button:hover { background: #1b2433; border-color: #4b5563; }
  button:active { transform: scale(0.98); }
  button.primary { border-color: var(--accent); }
  button.secondary { border-color: var(--accent2); }
  button.warn { border-color: var(--warn); }
  .status {
    display: flex;
    gap: 16px;
    align-items: center;
    margin: 12px 0 18px;
    color: var(--muted);
    font-size: 14px;
    flex-wrap: wrap;
  }
  .status .badge {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 999px;
    padding: 4px 10px;
    color: var(--text);
    font-size: 12px;
  }
  .viz-wrap {
    position: relative;
    border: 1px solid var(--border);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(96,165,250,0.08), transparent 30%), var(--panel);
    padding: 16px;
  }
  .labels {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    color: var(--muted);
    margin-bottom: 10px;
  }
  .deque {
    display: flex;
    align-items: flex-end;
    gap: 8px;
    overflow-x: auto;
    padding-bottom: 8px;
    scrollbar-color: var(--border) transparent;
  }
  .deque::-webkit-scrollbar { height: 8px; }
  .deque::-webkit-scrollbar-thumb { background: var(--border); border-radius: 8px; }
  .node {
    min-width: 60px;
    background: var(--node);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    align-items: center;
    justify-content: center;
    position: relative;
  }
  .node .value { font-weight: 600; font-size: 16px; }
  .node .meta { font-size: 11px; color: var(--muted); }
  .empty { color: var(--muted); font-style: italic; padding: 6px 10px; }
  .pointer {
    position: absolute;
    top: -12px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    pointer-events: none;
    gap: 6px;
  }
  .arrow {
    background: var(--accent);
    color: #03254e;
    font-weight: 700;
    padding: 2px 6px;
    border-radius: 6px;
    font-size: 11px;
  }
  .arrow.back { background: var(--accent2); color: #05381f; }
  .log {
    margin-top: 14px;
    border: 1px solid var(--border);
    border-radius: 10px;
    background: var(--panel);
  }
  .log header {
    padding: 10px 12px;
    border-bottom: 1px solid var(--border);
    font-size: 13px;
    color: var(--muted);
  }
  .log .entries { max-height: 160px; overflow: auto; font-size: 13px; }
  .log .entry { padding: 8px 12px; border-top: 1px solid rgba(55,65,81,.4); }
  .entry .op { font-weight: 600; }
  .entry .time { color: var(--muted); font-size: 12px; margin-left: 8px; }
  .tips { margin-top: 18px; color: var(--muted); font-size: 14px; }
  .kbd {
    background: #0b1220;
    border: 1px solid var(--border);
    border-radius: 6px;
    font-family: ui-monospace, Menlo, Consolas, monospace;
    padding: 2px 6px;
    font-size: 12px;
    color: var(--text);
  }
  .footer { margin-top: 24px; font-size: 12px; color: var(--muted); }
  .small { font-size: 12px; color: var(--muted); }
  .danger { color: #fca5a5; }
</style>
</head>
<body>
  <header>
    <h1>Deque (Double-Ended Queue) Interactive Demo</h1>
  </header>

  <div class="container">
    <div class="controls">
      <input id="valueInput" type="text" placeholder="Value to add (e.g., 42 or 'A')" />
      <button class="primary" id="pushFrontBtn">Push Front</button>
      <button class="primary" id="pushBackBtn">Push Back</button>
      <button class="warn" id="popFrontBtn">Pop Front</button>
      <button class="warn" id="popBackBtn">Pop Back</button>
      <button id="peekFrontBtn">Peek Front</button>
      <button id="peekBackBtn">Peek Back</button>
      <button id="sizeBtn">Size</button>
      <button id="clearBtn">Clear</button>
      <button class="secondary" id="randomOpBtn">Random Operation</button>
      <button id="autoplayBtn">Autoplay</button>
    </div>

    <div class="status">
      <div class="badge">Head index: <span id="headIdx">0</span></div>
      <div class="badge">Tail index: <span id="tailIdx">0</span></div>
      <div class="badge">Size: <span id="size">0</span></div>
      <div class="badge">Empty: <span id="empty">true</span></div>
    </div>

    <div class="viz-wrap">
      <div class="labels">
        <div>Front (pop/peek here)</div>
        <div>Back (pop/peek here)</div>
      </div>
      <div id="dequeView" class="deque"></div>
    </div>

    <div class="log">
      <header>Operation Log</header>
      <div class="entries" id="logEntries"></div>
    </div>

    <div class="tips">
      - A deque supports O(1) additions and removals at both ends: pushFront, pushBack, popFront, popBack.
      - This demo uses a sparse object with head and tail indices to avoid costly array shift/unshift.
      - Keyboard shortcuts: F push front, B push back, J pop front, K pop back, Space random, C clear.
    </div>

    <div class="footer small">
      Try adding values, then remove from either end to see how the indices move. Pointers are logical head/tail positions.
    </div>
  </div>

<script>
class Deque {
  constructor() {
    this._items = {};
    this._head = 0;
    this._tail = 0;
  }
  pushFront(value) {
    this._head--;
    this._items[this._head] = value;
    return this.size();
  }
  pushBack(value) {
    this._items[this._tail] = value;
    this._tail++;
    return this.size();
  }
  popFront() {
    if (this.isEmpty()) return undefined;
    const value = this._items[this._head];
    delete this._items[this._head];
    this._head++;
    return value;
  }
  popBack() {
    if (this.isEmpty()) return undefined;
    this._tail--;
    const value = this._items[this._tail];
    delete this._items[this._tail];
    return value;
  }
  peekFront() {
    return this.isEmpty() ? undefined : this._items[this._head];
  }
  peekBack() {
    return this.isEmpty() ? undefined : this._items[this._tail - 1];
  }
  size() { return this._tail - this._head; }
  isEmpty() { return this.size() === 0; }
  clear() {
    this._items = {};
    this._head = 0;
    this._tail = 0;
  }
  toArray() {
    const arr = [];
    for (let i = this._head; i < this._tail; i++) {
      arr.push(this._items[i]);
    }
    return arr;
  }
  indices() {
    const idx = [];
    for (let i = this._head; i < this._tail; i++) {
      idx.push(i);
    }
    return idx;
  }
  headIndex() { return this._head; }
  tailIndex() { return this._tail; }
}

// UI wiring
const deque = new Deque();
const input = document.getElementById('valueInput');
const dequeView = document.getElementById('dequeView');
const headIdx = document.getElementById('headIdx');
const tailIdx = document.getElementById('tailIdx');
const sizeEl = document.getElementById('size');
const emptyEl = document.getElementById('empty');
const logEntries = document.getElementById('logEntries');

const btns = {
  pushFront: document.getElementById('pushFrontBtn'),
  pushBack: document.getElementById('pushBackBtn'),
  popFront: document.getElementById('popFrontBtn'),
  popBack: document.getElementById('popBackBtn'),
  peekFront: document.getElementById('peekFrontBtn'),
  peekBack: document.getElementById('peekBackBtn'),
  size: document.getElementById('sizeBtn'),
  clear: document.getElementById('clearBtn'),
  random: document.getElementById('randomOpBtn'),
  autoplay: document.getElementById('autoplayBtn'),
};

function render() {
  dequeView.innerHTML = '';
  const values = deque.toArray();
  const indices = deque.indices();

  if (values.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'empty';
    empty.textContent = 'Deque is empty';
    dequeView.appendChild(empty);
  } else {
    values.forEach((val, idx) => {
      const i = indices[idx];
      const node = document.createElement('div');
      node.className = 'node';

      const valDiv = document.createElement('div');
      valDiv.className = 'value';
      valDiv.textContent = formatValue(val);

      const metaDiv = document.createElement('div');
      metaDiv.className = 'meta';
      metaDiv.textContent = 'index ' + i;

      const pointer = document.createElement('div');
      pointer.className = 'pointer';
      const isFront = i === deque.headIndex();
      const isBack = i === deque.tailIndex() - 1;
      if (isFront) {
        const arrowFront = document.createElement('div');
        arrowFront.className = 'arrow';
        arrowFront.textContent = 'Front';
        pointer.appendChild(arrowFront);
      }
      if (isBack) {
        const arrowBack = document.createElement('div');
        arrowBack.className = 'arrow back';
        arrowBack.textContent = 'Back';
        pointer.appendChild(arrowBack);
      }

      node.appendChild(pointer);
      node.appendChild(valDiv);
      node.appendChild(metaDiv);
      dequeView.appendChild(node);
    });
  }

  headIdx.textContent = deque.headIndex();
  tailIdx.textContent = deque.tailIndex();
  sizeEl.textContent = deque.size();
  emptyEl.textContent = String(deque.isEmpty());
}

function formatValue(v) {
  if (typeof v === 'string') return v;
  if (typeof v === 'number') return String(v);
  try { return JSON.stringify(v); } catch { return String(v); }
}

function stringify(v) {
  if (typeof v === 'string') return '"' + v + '"';
  try {
    const s = JSON.stringify(v);
    return s ?? String(v);
  } catch {
    return String(v);
  }
}

function log(op, detail) {
  const row = document.createElement('div');
  row.className = 'entry';
  const ts = new Date().toLocaleTimeString();
  row.innerHTML = '<span class="op">' + op + '</span>' +
                  (detail ? ' â€” ' + escapeHtml(detail) : '') +
                  '<span class="time"> ' + ts + '</span>';
  logEntries.prepend(row);
}

function escapeHtml(str) {
  return String(str).replace(/[&<>"']/g, s => ({
    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
  }[s]));
}

function parseInputValue() {
  const raw = input.value.trim();
  if (raw === '') return undefined;

  if (!isNaN(Number(raw)) && /^[-+]?(\d+(\.\d*)?|\.\d+)$/.test(raw)) {
    return Number(raw);
  }
  try {
    if (/^[\[{"]/.test(raw) || /^(true|false|null)$/i.test(raw)) {
      return JSON.parse(raw);
    }
  } catch {}
  return raw;
}

btns.pushFront.addEventListener('click', () => {
  const val = parseInputValue();
  if (val === undefined) { pulse(input); log('pushFront', 'No value provided'); return; }
  deque.pushFront(val);
  render();
  log('pushFront', 'Added ' + stringify(val));
  input.focus();
});

btns.pushBack.addEventListener('click', () => {
  const val = parseInputValue();
  if (val === undefined) { pulse(input); log('pushBack', 'No value provided'); return; }
  deque.pushBack(val);
  render();
  log('pushBack', 'Added ' + stringify(val));
  input.focus();
});

btns.popFront.addEventListener('click', () => {
  const v = deque.popFront();
  render();
  log('popFront', v === undefined ? 'Deque is empty' : 'Removed ' + stringify(v));
});

btns.popBack.addEventListener('click', () => {
  const v = deque.popBack();
  render();
  log('popBack', v === undefined ? 'Deque is empty' : 'Removed ' + stringify(v));
});

btns.peekFront.addEventListener('click', () => {
  const v = deque.peekFront();
  log('peekFront', v === undefined ? 'Deque is empty' : 'Front = ' + stringify(v));
});

btns.peekBack.addEventListener('click', () => {
  const v = deque.peekBack();
  log('peekBack', v === undefined ? 'Deque is empty' : 'Back = ' + stringify(v));
});

btns.size.addEventListener('click', () => {
  log('size', 'Size = ' + deque.size());
});

btns.clear.addEventListener('click', () => {
  deque.clear();
  render();
  log('clear', 'Deque cleared');
});

btns.random.addEventListener('click', () => {
  randomOp();
});

let autoplayInterval = null;
btns.autoplay.addEventListener('click', () => {
  if (autoplayInterval) stopAutoplay();
  else startAutoplay();
});

function pulse(el) {
  el.style.outline = '2px solid var(--accent)';
  setTimeout(() => { el.style.outline = ''; }, 300);
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.target === input && e.key === 'Enter') {
    const val = parseInputValue();
    if (val === undefined) { pulse(input); log('pushBack', 'No value provided'); return; }
    deque.pushBack(val);
    render();
    log('pushBack', 'Added ' + stringify(val));
    input.select();
    return;
  }
  if (e.ctrlKey || e.metaKey || e.altKey) return;
  const k = e.key.toLowerCase();
  if (k === 'f') { btns.pushFront.click(); e.preventDefault(); }
  else if (k === 'b') { btns.pushBack.click(); e.preventDefault(); }
  else if (k === 'j') { btns.popFront.click(); e.preventDefault(); }
  else if (k === 'k') { btns.popBack.click(); e.preventDefault(); }
  else if (k === ' ') { btns.random.click(); e.preventDefault(); }
  else if (k === 'c') { btns.clear.click(); e.preventDefault(); }
});

// Random operation helper
function randomOp() {
  const ops = ['pushFront', 'pushBack', 'popFront', 'popBack'];
  let op = ops[Math.floor(Math.random() * ops.length)];
  if (deque.isEmpty() && (op === 'popFront' || op === 'popBack')) {
    op = Math.random() < 0.5 ? 'pushFront' : 'pushBack';
  }
  let val = null;
  if (op === 'pushFront' || op === 'pushBack') {
    val = randomValue();
  }
  switch (op) {
    case 'pushFront':
      deque.pushFront(val);
      render();
      log('pushFront', 'Added ' + stringify(val));
      break;
    case 'pushBack':
      deque.pushBack(val);
      render();
      log('pushBack', 'Added ' + stringify(val));
      break;
    case 'popFront':
      const f = deque.popFront();
      render();
      log('popFront', f === undefined ? 'Deque is empty' : 'Removed ' + stringify(f));
      break;
    case 'popBack':
      const b = deque.popBack();
      render();
      log('popBack', b === undefined ? 'Deque is empty' : 'Removed ' + stringify(b));
      break;
  }
}

function randomValue() {
  const choices = [
    () => Math.floor(Math.random() * 100),
    () => ['A', 'B', 'C', 'D', 'E', 'F'][Math.floor(Math.random() * 6)],
    () => ({ id: Math.floor(Math.random() * 1000) }),
    () => [1, 2, 3].slice(0, Math.floor(Math.random() * 3) + 1),
    () => Math.random() < 0.5
  ];
  return choices[Math.floor(Math.random() * choices.length)]();
}

// Autoplay
function startAutoplay() {
  if (autoplayInterval) return;
  btns.autoplay.textContent = 'Stop Autoplay';
  autoplayInterval = setInterval(randomOp, 700);
  log('autoplay', 'Started');
}
function stopAutoplay() {
  if (!autoplayInterval) return;
  clearInterval(autoplayInterval);
  autoplayInterval = null;
  btns.autoplay.textContent = 'Autoplay';
  log('autoplay', 'Stopped');
}

// Initialize with seed data
(function init() {
  ['A', 'B', 'C'].forEach(v => deque.pushBack(v));
  render();
  log('init', 'Seeded deque with "A","B","C"');
})();
</script>
</body>
</html>