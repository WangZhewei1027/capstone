<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Queue Visualizer (FIFO) - JavaScript Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0f172a;
      --panel:#111827;
      --muted:#94a3b8;
      --text:#e5e7eb;
      --accent:#22c55e;
      --accent-2:#3b82f6;
      --warn:#f59e0b;
      --danger:#ef4444;
      --chip:#1f2937;
      --border:#374151;
      --shadow:0 10px 20px rgba(0,0,0,.35), 0 2px 6px rgba(0,0,0,.25);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
      background:linear-gradient(120deg,#0b1226 0%, #0e1730 100%);
      color:var(--text);
    }
    .app{
      max-width:1000px;
      margin:0 auto;
      padding:24px;
    }
    header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:16px;
      margin-bottom:18px;
    }
    h1{
      margin:.2rem 0 .4rem;
      font-weight:800;
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      font-size:.98rem;
      max-width:70ch;
    }
    .panel{
      background:linear-gradient(180deg,#0f172a 0%, #0d1426 100%);
      border:1px solid var(--border);
      border-radius:14px;
      box-shadow:var(--shadow);
    }
    .controls{
      padding:14px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }
    .row{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .select, .input, .btn{
      background:var(--chip);
      border:1px solid var(--border);
      color:var(--text);
      border-radius:10px;
      padding:10px 12px;
      font-size:.95rem;
      transition:.2s ease;
    }
    .select:hover, .input:hover{border-color:#475569}
    .input{min-width:180px}
    .btn{
      display:inline-flex; align-items:center; gap:8px;
      background:#1c2437;
      cursor:pointer;
      user-select:none;
    }
    .btn:hover{filter:brightness(1.1)}
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:linear-gradient(180deg,#16a34a,#15803d); border-color:#14532d}
    .btn.info{background:linear-gradient(180deg,#2563eb,#1d4ed8); border-color:#1e40af}
    .btn.warn{background:linear-gradient(180deg,#ca8a04,#a16207); border-color:#713f12}
    .btn.danger{background:linear-gradient(180deg,#ef4444,#dc2626); border-color:#991b1b}
    .btn.ghost{background:#182030}
    .statbar{
      display:flex; gap:16px; padding:10px 14px; border-top:1px solid var(--border);
      color:var(--muted); font-size:.95rem; flex-wrap:wrap
    }
    .stat{background:#0c1326; border:1px solid var(--border); border-radius:10px; padding:8px 10px}
    .stat b{color:var(--text)}
    .grid{
      display:grid; grid-template-columns:1fr; gap:16px; margin-top:18px;
    }
    .viz{
      padding:18px;
    }
    .viz-head{
      display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;
    }
    .queue-wrap{
      position:relative;
      min-height:110px;
      background:repeating-linear-gradient(90deg, rgba(148,163,184,0.08) 0px, rgba(148,163,184,0.08) 6px, transparent 6px, transparent 12px);
      border:1px dashed #334155;
      border-radius:12px;
      padding:14px;
      overflow:hidden;
    }
    .lane{
      display:flex; gap:10px; align-items:flex-end; flex-wrap:nowrap;
      overflow:auto; padding-bottom:12px;
      scrollbar-width:thin; scrollbar-color:#334155 transparent;
    }
    .lane::-webkit-scrollbar{height:8px}
    .lane::-webkit-scrollbar-thumb{background:#334155; border-radius:8px}
    .queue-item{
      background:linear-gradient(180deg,#1f2937,#111827);
      border:1px solid #334155;
      border-radius:10px;
      min-width:70px;
      max-width:140px;
      padding:12px 10px;
      text-align:center;
      box-shadow:0 6px 12px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.03);
      position:relative;
      transition:transform .18s ease, opacity .18s ease, box-shadow .18s ease;
    }
    .queue-item .val{font-weight:700; font-size:1.05rem}
    .queue-item .meta{font-size:.78rem; color:var(--muted)}
    .queue-item:hover{transform:translateY(-2px); box-shadow:0 10px 14px rgba(0,0,0,.35)}
    .queue-item.new{
      opacity:0; transform:scale(.92) translateY(4px);
      animation:popin .28s ease forwards;
    }
    @keyframes popin{
      to{opacity:1; transform:none}
    }
    .labels{
      position:absolute; inset:8px 12px auto 12px; pointer-events:none; display:flex; justify-content:space-between; align-items:center;
      font-size:.8rem; color:#a5b4fc;
    }
    .label-chip{
      background:#1e293b; border:1px solid #334155; border-radius:999px; padding:4px 8px; color:#c7d2fe
    }
    .empty{
      color:var(--muted); font-style:italic; padding:12px 10px;
    }
    .log{
      padding:14px; max-height:200px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background:#0b1223; border-top:1px solid var(--border); border-bottom-left-radius:14px; border-bottom-right-radius:14px;
    }
    .log .line{color:#cbd5e1; font-size:.9rem; white-space:pre-wrap}
    .log .t{color:#93c5fd}
    .perf{
      padding:14px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      border-top:1px solid var(--border);
    }
    .toast{
      position:fixed; right:16px; bottom:16px; z-index:50;
      background:#0b1223; border:1px solid #334155; border-radius:12px; padding:10px 14px;
      color:var(--text); box-shadow:var(--shadow); min-width:220px; display:none;
    }
    .toast.show{display:block; animation:raise .25s ease both}
    @keyframes raise{from{opacity:0; transform:translateY(8px)} to{opacity:1; transform:none}}
    footer{
      color:var(--muted); font-size:.95rem; margin:22px 0 40px;
    }
    footer .k{color:#a7f3d0}
    .tips{display:flex; flex-wrap:wrap; gap:8px; margin-top:8px}
    .tip{
      background:#0b1223; border:1px solid #334155; color:#cbd5e1; border-radius:10px; padding:8px 10px; font-size:.9rem;
    }
    .impl-note{color:#c7d2fe}
    .badge{
      background:#0b1223; border:1px solid #334155;
      color:#93c5fd; padding:4px 8px; border-radius:999px; font-size:.8rem;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>Queue Visualizer (FIFO)</h1>
        <div class="subtitle">
          A queue is a First-In, First-Out data structure. Enqueue adds to the back; Dequeue removes from the front. Try operations and compare implementations.
        </div>
      </div>
      <div class="badge" id="implBadge">Implementation: Head Index</div>
    </header>

    <section class="panel">
      <div class="controls">
        <div class="row">
          <label for="impl" class="impl-note">Implementation</label>
          <select id="impl" class="select" title="Choose queue implementation">
            <option value="fast">Head Index (Optimized)</option>
            <option value="naive">Array Shift (Naive)</option>
            <option value="twostack">Two Stacks (Amortized)</option>
          </select>
        </div>
        <div class="row">
          <input id="enqueueInput" class="input" placeholder="Value to enqueue (or leave empty for auto)" />
          <button id="enqueueBtn" class="btn primary" title="Add item to the back (enqueue)">
            ‚ûï Enqueue
          </button>
          <button id="dequeueBtn" class="btn danger" title="Remove item from the front (dequeue)">
            ‚ûñ Dequeue
          </button>
          <button id="peekFrontBtn" class="btn ghost" title="View the front item">
            ‚èÆÔ∏è Peek Front
          </button>
          <button id="peekBackBtn" class="btn ghost" title="View the back item">
            ‚è≠Ô∏è Peek Back
          </button>
        </div>
        <div class="row">
          <button id="randomBtn" class="btn info" title="Enqueue a random number">
            üé≤ Random Enqueue
          </button>
          <button id="autoBtn" class="btn warn" title="Toggle auto-run demo">‚ñ∂Ô∏è Auto-run</button>
          <button id="clearBtn" class="btn" title="Clear the queue">üßπ Clear</button>
        </div>
      </div>
      <div class="statbar">
        <div class="stat">Size: <b id="statSize">0</b></div>
        <div class="stat">Empty: <b id="statEmpty">Yes</b></div>
        <div class="stat">Front: <b id="statFront">-</b></div>
        <div class="stat">Back: <b id="statBack">-</b></div>
      </div>
    </section>

    <div class="grid">
      <section class="panel viz">
        <div class="viz-head">
          <div class="subtitle">Visualization</div>
          <div class="badge">FIFO</div>
        </div>
        <div class="queue-wrap">
          <div class="labels"><span class="label-chip">Front</span><span class="label-chip">Back</span></div>
          <div id="lane" class="lane" aria-live="polite"></div>
          <div id="emptyMsg" class="empty" style="display:none">Queue is empty. Enqueue some items!</div>
        </div>
      </section>

      <section class="panel">
        <div class="perf">
          <div class="subtitle">Performance demo (enqueue N then dequeue N)</div>
          <input id="opsInput" class="input" type="number" min="1000" step="1000" value="50000" />
          <button id="perfBtn" class="btn info">Run test</button>
          <span id="perfStatus" class="badge" style="display:none"></span>
        </div>
        <div class="log" id="log" aria-live="polite"></div>
      </section>
    </div>

    <footer>
      <div>
        Concept recap: A queue serves elements in the order they arrive.
        Operations:
        - enqueue(x): add x to back
        - dequeue(): remove and return front
        - peekFront/peekBack: inspect ends
      </div>
      <div class="tips">
        <div class="tip">Naive uses Array.shift(), which is O(n) per dequeue.</div>
        <div class="tip">Head Index keeps a moving start index to make operations O(1) on average.</div>
        <div class="tip">Two Stacks gives amortized O(1) by reversing chunks on demand.</div>
      </div>
    </footer>
  </div>

  <div id="toast" class="toast"></div>

  <script>
    "use strict";

    // Queue implementations
    class NaiveQueue {
      constructor(items = []) { this.arr = items.slice(); }
      enqueue(x) { this.arr.push(x); }
      dequeue() { return this.arr.length ? this.arr.shift() : undefined; }
      peekFront() { return this.arr[0]; }
      peekBack() { return this.arr.length ? this.arr[this.arr.length - 1] : undefined; }
      size() { return this.arr.length; }
      isEmpty() { return this.arr.length === 0; }
      clear() { this.arr.length = 0; }
      toArray() { return this.arr.slice(); }
      name() { return "Array Shift (Naive)"; }
    }

    class FastQueue {
      constructor(items = []) { this.arr = []; this.head = 0; for (const x of items) this.enqueue(x); }
      enqueue(x) { this.arr.push(x); }
      dequeue() {
        if (this.head >= this.arr.length) return undefined;
        const v = this.arr[this.head++];
        // Periodic compaction to keep memory bounded
        if (this.head > 50 && this.head * 2 > this.arr.length) {
          this.arr = this.arr.slice(this.head);
          this.head = 0;
        }
        return v;
      }
      peekFront() { return this.head < this.arr.length ? this.arr[this.head] : undefined; }
      peekBack() { return this.head < this.arr.length ? this.arr[this.arr.length - 1] : undefined; }
      size() { return this.arr.length - this.head; }
      isEmpty() { return this.size() === 0; }
      clear() { this.arr = []; this.head = 0; }
      toArray() { return this.arr.slice(this.head); }
      name() { return "Head Index (Optimized)"; }
    }

    class TwoStackQueue {
      constructor(items = []) { this._in = []; this._out = []; for (const x of items) this.enqueue(x); }
      enqueue(x) { this._in.push(x); }
      _pour() { while (this._in.length) this._out.push(this._in.pop()); }
      dequeue() {
        if (!this._out.length) this._pour();
        return this._out.length ? this._out.pop() : undefined;
      }
      peekFront() {
        if (!this._out.length) this._pour();
        return this._out.length ? this._out[this._out.length - 1] : undefined;
      }
      peekBack() {
        if (this._in.length) return this._in[this._in.length - 1];
        if (this._out.length) return this._out[0];
        return undefined;
      }
      size() { return this._in.length + this._out.length; }
      isEmpty() { return this.size() === 0; }
      clear() { this._in = []; this._out = []; }
      toArray() { return this._out.slice().reverse().concat(this._in); }
      name() { return "Two Stacks (Amortized)"; }
    }

    // UI handling
    const implSelect = document.getElementById("impl");
    const enqueueInput = document.getElementById("enqueueInput");
    const enqueueBtn = document.getElementById("enqueueBtn");
    const dequeueBtn = document.getElementById("dequeueBtn");
    const peekFrontBtn = document.getElementById("peekFrontBtn");
    const peekBackBtn = document.getElementById("peekBackBtn");
    const randomBtn = document.getElementById("randomBtn");
    const clearBtn = document.getElementById("clearBtn");
    const autoBtn = document.getElementById("autoBtn");

    const statSize = document.getElementById("statSize");
    const statEmpty = document.getElementById("statEmpty");
    const statFront = document.getElementById("statFront");
    const statBack = document.getElementById("statBack");
    const implBadge = document.getElementById("implBadge");

    const lane = document.getElementById("lane");
    const emptyMsg = document.getElementById("emptyMsg");
    const logEl = document.getElementById("log");

    const toast = document.getElementById("toast");

    const opsInput = document.getElementById("opsInput");
    const perfBtn = document.getElementById("perfBtn");
    const perfStatus = document.getElementById("perfStatus");

    let nextId = 1;
    let autoInterval = null;
    let queue = makeQueue(implSelect.value);
    let lastRenderLength = 0;

    function makeQueue(mode, seed = []) {
      switch (mode) {
        case "naive": return new NaiveQueue(seed);
        case "twostack": return new TwoStackQueue(seed);
        default: return new FastQueue(seed);
      }
    }

    function updateBadge() {
      implBadge.textContent = "Implementation: " + queue.name();
    }

    function renderQueue({ markNewFromIndex = null } = {}) {
      const items = queue.toArray();
      lane.innerHTML = "";
      if (items.length === 0) {
        emptyMsg.style.display = "";
      } else {
        emptyMsg.style.display = "none";
        items.forEach((v, i) => {
          const d = document.createElement("div");
          d.className = "queue-item";
          if (markNewFromIndex != null && i >= markNewFromIndex) d.classList.add("new");
          const val = document.createElement("div");
          val.className = "val";
          val.textContent = String(v);
          const meta = document.createElement("div");
          meta.className = "meta";
          if (i === 0 && items.length === 1) meta.textContent = "front & back";
          else if (i === 0) meta.textContent = "front";
          else if (i === items.length - 1) meta.textContent = "back";
          else meta.textContent = "idx " + i;
          d.appendChild(val);
          d.appendChild(meta);
          lane.appendChild(d);
        });
      }
      lastRenderLength = items.length;
      updateStats();
    }

    function updateStats() {
      statSize.textContent = String(queue.size());
      statEmpty.textContent = queue.isEmpty() ? "Yes" : "No";
      statFront.textContent = queue.peekFront() !== undefined ? String(queue.peekFront()) : "-";
      statBack.textContent = queue.peekBack() !== undefined ? String(queue.peekBack()) : "-";
    }

    function log(msg) {
      const t = new Date();
      const ts = `${String(t.getHours()).padStart(2,"0")}:${String(t.getMinutes()).padStart(2,"0")}:${String(t.getSeconds()).padStart(2,"0")}`;
      const line = document.createElement("div");
      line.className = "line";
      line.innerHTML = `<span class="t">[${ts}]</span> ${msg}`;
      logEl.prepend(line);
      // keep last 80 lines
      while (logEl.children.length > 80) logEl.removeChild(logEl.lastChild);
    }

    let toastTimer = null;
    function showToast(text, color = null) {
      toast.textContent = text;
      toast.classList.add("show");
      if (color) toast.style.borderColor = color;
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => toast.classList.remove("show"), 1800);
    }

    function enqueue(val) {
      const beforeLen = queue.size();
      queue.enqueue(val);
      renderQueue({ markNewFromIndex: beforeLen });
      log(`enqueue(${formatVal(val)})`);
    }

    function dequeue() {
      const v = queue.dequeue();
      if (v === undefined) {
        log("dequeue() => undefined (empty)");
        showToast("Queue is empty ‚Äî nothing to dequeue.", "#ef4444");
      } else {
        renderQueue();
        log(`dequeue() => ${formatVal(v)}`);
        showToast(`Dequeued: ${v}`, "#f59e0b");
      }
    }

    function formatVal(v) {
      if (typeof v === "string") return JSON.stringify(v);
      return String(v);
    }

    // Event handlers
    enqueueBtn.addEventListener("click", () => {
      let v = enqueueInput.value;
      if (v.trim() === "") v = nextId++;
      enqueue(v);
      enqueueInput.value = "";
      enqueueInput.focus();
    });

    enqueueInput.addEventListener("keydown", e => {
      if (e.key === "Enter") {
        enqueueBtn.click();
      }
    });

    randomBtn.addEventListener("click", () => {
      const r = Math.floor(Math.random() * 90) + 10;
      enqueue(r);
    });

    dequeueBtn.addEventListener("click", () => dequeue());

    peekFrontBtn.addEventListener("click", () => {
      const v = queue.peekFront();
      log(`peekFront() => ${v === undefined ? "undefined" : formatVal(v)}`);
      showToast(`Front: ${v === undefined ? "empty" : v}`, "#3b82f6");
      updateStats();
    });

    peekBackBtn.addEventListener("click", () => {
      const v = queue.peekBack();
      log(`peekBack() => ${v === undefined ? "undefined" : formatVal(v)}`);
      showToast(`Back: ${v === undefined ? "empty" : v}`, "#3b82f6");
      updateStats();
    });

    clearBtn.addEventListener("click", () => {
      queue.clear();
      renderQueue();
      log("clear()");
      showToast("Queue cleared", "#22c55e");
    });

    autoBtn.addEventListener("click", () => {
      if (autoInterval) {
        clearInterval(autoInterval);
        autoInterval = null;
        autoBtn.textContent = "‚ñ∂Ô∏è Auto-run";
        autoBtn.classList.remove("danger");
        autoBtn.classList.add("warn");
        log("auto-run: stopped");
        return;
      }
      log("auto-run: started");
      autoBtn.textContent = "‚èπÔ∏è Stop auto-run";
      autoBtn.classList.remove("warn");
      autoBtn.classList.add("danger");
      autoInterval = setInterval(() => {
        // Keep size in a friendly range by biasing choice
        const size = queue.size();
        const target = 6;
        const bias = size < target ? 0.7 : (size > target + 3 ? 0.2 : 0.5);
        if (Math.random() < bias) {
          enqueue(Math.random() < 0.5 ? nextId++ : Math.floor(Math.random() * 100));
        } else {
          dequeue();
        }
      }, 600);
    });

    implSelect.addEventListener("change", () => {
      const items = queue.toArray();
      queue = makeQueue(implSelect.value, items);
      updateBadge();
      renderQueue();
      log(`switched implementation => ${queue.name()}`);
    });

    // Performance demo
    perfBtn.addEventListener("click", async () => {
      const N = Math.max(1000, Math.min(2_000_000, Number(opsInput.value) || 50000));
      perfStatus.style.display = "";
      perfStatus.textContent = "Running...";
      log(`performance test: N=${N} (enqueue N then dequeue N)`);

      // Allow paint
      await new Promise(r => setTimeout(r, 20));

      const results = [];
      for (const key of ["naive", "fast", "twostack"]) {
        const impl = makeQueue(key);
        const name = impl.name();
        const t0 = performance.now();
        for (let i = 0; i < N; i++) impl.enqueue(i);
        for (let i = 0; i < N; i++) impl.dequeue();
        const t1 = performance.now();
        const ms = Math.round(t1 - t0);
        results.push({ name, ms });
        log(`- ${name}: ${ms} ms`);
        // Yield briefly to avoid total UI lock
        await new Promise(r => setTimeout(r, 10));
      }

      const fastest = results.reduce((a,b)=> a.ms < b.ms ? a : b);
      perfStatus.textContent = `Fastest: ${fastest.name} (${fastest.ms} ms)`;
      showToast(`Performance: ${fastest.name} won (${fastest.ms} ms)`, "#22c55e");
    });

    // Initialize
    updateBadge();
    renderQueue();

    // Seed a few items for illustration
    ["A", "B", "C"].forEach(v => queue.enqueue(v));
    renderQueue({ markNewFromIndex: 0 });
    log("initialized with ['A','B','C']");
  </script>
</body>
</html>