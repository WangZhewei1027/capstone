<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Heap (Min/Max) Interactive Demo</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --accent: #60a5fa;
    --accent2: #34d399;
    --text: #e5e7eb;
    --muted: #94a3b8;
    --danger: #f87171;
    --node: #1f2937;
    --node-border: #374151;
    --highlight: #fbbf24;
  }
  html, body {
    margin: 0; padding: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  }
  header {
    padding: 16px 20px; border-bottom: 1px solid #1f2937; background: #0b1220; position: sticky; top: 0; z-index: 5;
  }
  header h1 { margin: 0; font-size: 18px; font-weight: 600; }
  header small { color: var(--muted); display: block; margin-top: 4px; }
  .container {
    display: grid;
    grid-template-columns: 340px 1fr;
    gap: 16px; padding: 16px 20px;
  }
  .panel {
    background: var(--panel); border: 1px solid #1f2937; border-radius: 10px; padding: 12px;
  }
  .panel h2 { margin: 0 0 10px 0; font-size: 16px; font-weight: 600; }
  .controls { display: grid; grid-template-columns: 1fr; gap: 10px; }
  .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
  .row label { color: var(--muted); }
  .radio-group { display: flex; gap: 8px; align-items: center; }
  input[type="number"], input[type="text"] {
    background: #0b1220; color: var(--text); border: 1px solid #334155; border-radius: 8px; padding: 8px 10px; outline: none; width: 100%;
  }
  input[type="range"] { width: 100%; }
  .btn {
    background: #0b1220; color: var(--text); border: 1px solid #334155; border-radius: 8px; padding: 8px 10px; cursor: pointer;
    transition: border-color .15s ease, transform .05s ease;
  }
  .btn:hover { border-color: #475569; }
  .btn:active { transform: scale(0.98); }
  .btn.primary { background: linear-gradient(180deg, #1f3a8a, #1e293b); border-color: #1e40af; }
  .btn.success { background: linear-gradient(180deg, #065f46, #1e293b); border-color: #10b981; }
  .btn.danger { background: linear-gradient(180deg, #7f1d1d, #1e293b); border-color: #ef4444; }
  .btn:disabled { opacity: 0.6; cursor: not-allowed; }
  .grid {
    display: grid; grid-template-columns: 1fr; gap: 12px;
  }
  /* Array view */
  .array-view {
    display: flex; gap: 8px; flex-wrap: wrap; align-items: flex-start;
    padding: 8px; background: #0b1220; border: 1px dashed #334155; border-radius: 8px; min-height: 56px;
  }
  .item {
    position: relative;
    background: var(--node); border: 1px solid var(--node-border); border-radius: 8px;
    min-width: 44px; min-height: 44px; display: grid; place-items: center; font-weight: 600;
  }
  .item .idx {
    position: absolute; top: -8px; right: -8px; font-size: 11px; background: #0b1220; border: 1px solid #334155; padding: 2px 4px; border-radius: 6px; color: var(--muted);
  }
  .item.root { border-color: var(--accent); box-shadow: 0 0 0 1px inset var(--accent); }
  .item.highlight { border-color: var(--highlight); box-shadow: 0 0 0 2px inset var(--highlight); }
  /* Tree view */
  .tree-container {
    position: relative; height: 460px; overflow: auto; background: #0b1220; border-radius: 10px; border: 1px dashed #334155;
  }
  .tree-inner {
    position: relative; min-width: 800px; min-height: 440px;
  }
  .node {
    position: absolute;
    width: 44px; height: 44px; border-radius: 50%; background: var(--node);
    border: 1px solid var(--node-border); display: grid; place-items: center; font-weight: 700;
    transition: transform .15s ease, border-color .15s ease, box-shadow .15s ease, background .15s ease;
  }
  .node.root { border-color: var(--accent); box-shadow: 0 0 0 2px inset var(--accent); }
  .node.highlight { border-color: var(--highlight); box-shadow: 0 0 0 3px inset var(--highlight); background: #1f2a3b; }
  svg.lines { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }
  .legend { color: var(--muted); font-size: 13px; }
  .log {
    background: #0b1220; border: 1px dashed #334155; border-radius: 10px; padding: 8px; height: 140px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  .log p { margin: 0 0 6px 0; }
  .footer {
    padding: 10px 20px; color: var(--muted);
  }
  .note { color: var(--muted); font-size: 12px; }
</style>
</head>
<body>
<header>
  <h1>Heap (Min/Max) — Interactive Demo</h1>
  <small>Binary heap with min/max toggle. Insert, extract, peek, visualize as array and tree, and see animations.</small>
</header>

<div class="container">
  <div class="panel">
    <h2>Controls</h2>
    <div class="controls">
      <div class="row">
        <label>Heap type:</label>
        <div class="radio-group">
          <label><input type="radio" name="heapType" value="min" checked /> Min-Heap</label>
          <label><input type="radio" name="heapType" value="max" /> Max-Heap</label>
        </div>
      </div>

      <div class="row">
        <label>Animation speed (ms):</label>
      </div>
      <input id="speed" type="range" min="60" max="1000" value="300" />
      <div class="note">Lower is faster. Current: <span id="speedVal">300</span> ms</div>

      <div class="row">
        <input id="valueInput" type="number" placeholder="Enter number…" />
        <button id="insertBtn" class="btn primary">Insert</button>
        <button id="randomBtn" class="btn">Random</button>
      </div>

      <div class="row">
        <button id="extractBtn" class="btn success">Extract Root</button>
        <button id="peekBtn" class="btn">Peek Root</button>
        <button id="clearBtn" class="btn danger">Clear</button>
      </div>

      <div class="row">
        <input id="listInput" type="text" placeholder="Comma-separated list e.g. 7,3,9,1,5" />
        <button id="buildBtn" class="btn primary">Build Heap</button>
        <button id="randBuildBtn" class="btn">Build Random</button>
      </div>

      <div class="row">
        <button id="heapSortBtn" class="btn">Heap Sort (copy)</button>
      </div>

      <div class="legend">
        • Insert: O(log n) • Extract: O(log n) • Peek: O(1) • Build heap: O(n)
      </div>
    </div>
  </div>

  <div class="grid">
    <div class="panel">
      <h2>Array Representation (level-order)</h2>
      <div id="arrayView" class="array-view"></div>
    </div>
    <div class="panel">
      <h2>Tree Visualization</h2>
      <div id="treeContainer" class="tree-container">
        <div id="treeInner" class="tree-inner">
          <svg id="lines" class="lines"></svg>
        </div>
      </div>
      <div class="legend">Binary heap stored in array: parent index p = floor((i - 1) / 2). Children: left = 2p + 1, right = 2p + 2.</div>
    </div>
    <div class="panel">
      <h2>Log</h2>
      <div id="log" class="log"></div>
    </div>
  </div>
</div>

<div class="footer">
  Tip: Toggle Min/Max to see how ordering changes. Heap property holds: root is min or max of all nodes.
</div>

<script>
(function() {
  // Utility
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const byId = (id) => document.getElementById(id);

  class BinaryHeap {
    constructor(isMin = true, onUpdate = null) {
      this.data = [];
      this.isMin = isMin;
      this.onUpdate = onUpdate || (() => {});
      this.busy = false;
      this.animMs = 300;
    }
    comparator(a, b) { return this.isMin ? a < b : a > b; }
    setType(isMin) {
      this.isMin = isMin;
      this.heapify();
      this.onUpdate();
    }
    clear() {
      this.data.length = 0;
      this.onUpdate();
    }
    peek() {
      return this.data.length ? this.data[0] : null;
    }
    async pushAnimated(val) {
      this.data.push(val);
      this.onUpdate({ highlight: [this.data.length - 1] });
      await sleep(this.animMs);
      let i = this.data.length - 1;
      while (i > 0) {
        const p = Math.floor((i - 1) / 2);
        if (this.comparator(this.data[i], this.data[p])) {
          this.swap(i, p);
          this.onUpdate({ highlight: [i, p] });
          await sleep(this.animMs);
          i = p;
        } else break;
      }
      this.onUpdate();
    }
    push(val) {
      this.data.push(val);
      this.bubbleUp(this.data.length - 1);
      this.onUpdate();
    }
    async popAnimated() {
      if (!this.data.length) return null;
      const root = this.data[0];
      const last = this.data.pop();
      if (this.data.length) {
        this.data[0] = last;
        this.onUpdate({ highlight: [0] });
        await sleep(this.animMs);
        await this.bubbleDownAnimated(0);
      }
      this.onUpdate();
      return root;
    }
    pop() {
      if (!this.data.length) return null;
      const root = this.data[0];
      const last = this.data.pop();
      if (this.data.length) {
        this.data[0] = last;
        this.bubbleDown(0);
      }
      this.onUpdate();
      return root;
    }
    swap(i, j) {
      const tmp = this.data[i];
      this.data[i] = this.data[j];
      this.data[j] = tmp;
    }
    bubbleUp(i) {
      while (i > 0) {
        const p = Math.floor((i - 1) / 2);
        if (this.comparator(this.data[i], this.data[p])) {
          this.swap(i, p);
          i = p;
        } else break;
      }
    }
    async bubbleDownAnimated(i) {
      const n = this.data.length;
      while (true) {
        const l = 2 * i + 1, r = 2 * i + 2;
        let best = i;
        if (l < n && this.comparator(this.data[l], this.data[best])) best = l;
        if (r < n && this.comparator(this.data[r], this.data[best])) best = r;
        if (best !== i) {
          this.swap(i, best);
          this.onUpdate({ highlight: [i, best] });
          await sleep(this.animMs);
          i = best;
        } else break;
      }
    }
    bubbleDown(i) {
      const n = this.data.length;
      while (true) {
        const l = 2 * i + 1, r = 2 * i + 2;
        let best = i;
        if (l < n && this.comparator(this.data[l], this.data[best])) best = l;
        if (r < n && this.comparator(this.data[r], this.data[best])) best = r;
        if (best !== i) {
          this.swap(i, best);
          i = best;
        } else break;
      }
    }
    build(arr) {
      this.data = Array.from(arr);
      this.heapify();
      this.onUpdate();
    }
    heapify() {
      const n = this.data.length;
      for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        this.bubbleDown(i);
      }
    }
    toArray() { return Array.from(this.data); }
  }

  // DOM references
  const arrayView = byId('arrayView');
  const treeContainer = byId('treeContainer');
  const treeInner = byId('treeInner');
  const linesSvg = byId('lines');
  const logEl = byId('log');

  const speedInput = byId('speed');
  const speedVal = byId('speedVal');
  const valueInput = byId('valueInput');
  const insertBtn = byId('insertBtn');
  const randomBtn = byId('randomBtn');
  const extractBtn = byId('extractBtn');
  const peekBtn = byId('peekBtn');
  const clearBtn = byId('clearBtn');
  const listInput = byId('listInput');
  const buildBtn = byId('buildBtn');
  const randBuildBtn = byId('randBuildBtn');
  const heapSortBtn = byId('heapSortBtn');

  const typeRadios = Array.from(document.querySelectorAll('input[name="heapType"]'));

  // State & heap
  let highlightIndices = [];
  let busy = false;
  const setBusy = (b) => {
    busy = b;
    [insertBtn, randomBtn, extractBtn, peekBtn, clearBtn, buildBtn, randBuildBtn, heapSortBtn, valueInput, listInput, ...typeRadios].forEach(el => el.disabled = b);
  };
  const log = (msg) => {
    const p = document.createElement('p');
    p.textContent = msg;
    logEl.appendChild(p);
    logEl.scrollTop = logEl.scrollHeight;
  };

  const heap = new BinaryHeap(true, (opts = {}) => {
    highlightIndices = Array.isArray(opts.highlight) ? opts.highlight.slice() : [];
    draw();
  });

  // Draw functions
  function drawArray() {
    arrayView.innerHTML = '';
    const data = heap.data;
    data.forEach((v, i) => {
      const div = document.createElement('div');
      div.className = 'item' + (i === 0 ? ' root' : '') + (highlightIndices.includes(i) ? ' highlight' : '');
      div.textContent = v;
      const idx = document.createElement('div');
      idx.className = 'idx';
      idx.textContent = i;
      div.appendChild(idx);
      arrayView.appendChild(div);
    });
  }

  function drawTree() {
    const data = heap.data;
    const W = Math.max(treeInner.clientWidth, 800);
    const H = Math.max(treeInner.clientHeight, 440);
    const levelGap = 90; // vertical spacing
    const radius = 22; // node radius (half of 44)
    const nodes = [];
    // Clear previous nodes and lines
    treeInner.querySelectorAll('.node').forEach(n => n.remove());
    linesSvg.innerHTML = '';

    // Compute positions
    const levels = {};
    data.forEach((v, i) => {
      const L = Math.floor(Math.log2(i + 1));
      const levelStartIdx = Math.pow(2, L) - 1;
      const posInLevel = i - levelStartIdx;
      const nodesInLevel = Math.pow(2, L);
      const xRatio = (posInLevel + 1) / (nodesInLevel + 1);
      const x = Math.floor(xRatio * (W - 120)) + 60; // padding for edges
      const y = 40 + L * levelGap;
      nodes.push({ i, v, x, y });
      if (!levels[L]) levels[L] = [];
      levels[L].push(i);
    });

    // Lines
    const ns = 'http://www.w3.org/2000/svg';
    nodes.forEach(node => {
      const i = node.i;
      const p = Math.floor((i - 1) / 2);
      if (i > 0 && data[p] !== undefined) {
        const parentNode = nodes[p];
        const line = document.createElementNS(ns, 'line');
        line.setAttribute('x1', parentNode.x);
        line.setAttribute('y1', parentNode.y);
        line.setAttribute('x2', node.x);
        line.setAttribute('y2', node.y);
        line.setAttribute('stroke', '#334155');
        line.setAttribute('stroke-width', '2');
        linesSvg.appendChild(line);
      }
    });

    // Nodes
    nodes.forEach(node => {
      const el = document.createElement('div');
      el.className = 'node' + (node.i === 0 ? ' root' : '') + (highlightIndices.includes(node.i) ? ' highlight' : '');
      el.style.left = (node.x - radius) + 'px';
      el.style.top = (node.y - radius) + 'px';
      el.textContent = node.v;
      treeInner.appendChild(el);
    });
  }

  function draw() {
    drawArray();
    drawTree();
  }

  // Handlers
  function updateTypeFromRadio() {
    const isMin = typeRadios.find(r => r.checked)?.value === 'min';
    heap.setType(isMin);
    log(`Set heap type: ${isMin ? 'Min' : 'Max'}`);
  }

  typeRadios.forEach(r => r.addEventListener('change', updateTypeFromRadio));

  speedInput.addEventListener('input', () => {
    const ms = clamp(parseInt(speedInput.value || '300', 10), 60, 1000);
    heap.animMs = ms;
    speedVal.textContent = ms;
  });

  insertBtn.addEventListener('click', async () => {
    const valStr = valueInput.value.trim();
    let val = valStr === '' ? null : Number(valStr);
    if (val === null || Number.isNaN(val)) {
      log('Please enter a valid number to insert.');
      return;
    }
    setBusy(true);
    log(`Insert ${val}`);
    await heap.pushAnimated(val);
    setBusy(false);
    valueInput.value = '';
  });

  randomBtn.addEventListener('click', async () => {
    const val = randInt(0, 99);
    setBusy(true);
    log(`Insert random ${val}`);
    await heap.pushAnimated(val);
    setBusy(false);
  });

  extractBtn.addEventListener('click', async () => {
    if (!heap.data.length) {
      log('Extract: heap is empty.');
      return;
    }
    setBusy(true);
    const root = await heap.popAnimated();
    log(`Extracted root: ${root}`);
    setBusy(false);
  });

  peekBtn.addEventListener('click', () => {
    const root = heap.peek();
    log(`Peek: ${root === null ? 'heap is empty' : root}`);
  });

  clearBtn.addEventListener('click', () => {
    heap.clear();
    log('Cleared heap.');
  });

  buildBtn.addEventListener('click', () => {
    const text = listInput.value.trim();
    if (!text.length) {
      log('Enter a comma-separated list to build.');
      return;
    }
    const parts = text.split(',').map(s => Number(s.trim())).filter(v => !Number.isNaN(v));
    if (!parts.length) {
      log('List contained no valid numbers.');
      return;
    }
    heap.build(parts);
    log(`Built heap from list (${parts.length} items).`);
  });

  randBuildBtn.addEventListener('click', () => {
    const n = randInt(8, 18);
    const arr = Array.from({ length: n }, () => randInt(0, 99));
    heap.build(arr);
    log(`Built random heap (${n} items).`);
  });

  heapSortBtn.addEventListener('click', () => {
    const copy = new BinaryHeap(heap.isMin);
    copy.build(heap.toArray());
    const sorted = [];
    while (copy.data.length) sorted.push(copy.pop());
    const direction = heap.isMin ? 'ascending' : 'descending';
    log(`Heap sort (${direction}): [${sorted.join(', ')}]`);
    alert(`Heap sort (${direction}) result:\n[${sorted.join(', ')}]`);
  });

  // Resize handling
  const onResize = () => draw();
  window.addEventListener('resize', onResize);

  // Initial
  draw();
  speedVal.textContent = speedInput.value;
  log('Ready. Use controls to interact with the heap.');
})();
</script>
</body>
</html>