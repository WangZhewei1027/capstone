<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Binary Search Tree (BST) Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #0b1224;
      --muted: #94a3b8;
      --text: #e2e8f0;
      --accent: #22d3ee;
      --accent2: #a78bfa;
      --danger: #f43f5e;
      --ok: #34d399;
      --edge: #334155;
      --edge-hi: #64748b;
      --node: #1f2937;
      --node-hi: #0ea5e9;
      --node-found: #38bdf8;
      --node-del: #fb7185;
      --badge: #172554;
      --btn: #1f2937;
      --btn-hover: #374151;
      --btn-active: #111827;
      --input: #0b1224;
      --ring: rgba(34, 211, 238, 0.25);
      --shadow: 0 10px 25px rgba(0,0,0,0.35);
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0; height: 100%; background: var(--bg); color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, Apple Color Emoji, Segoe UI Emoji;
    }
    a { color: var(--accent); text-decoration: none; }
    .app {
      display: grid;
      grid-template-columns: 340px 1fr;
      gap: 16px;
      padding: 16px;
      height: 100%;
    }
    @media (max-width: 980px) {
      .app { grid-template-columns: 1fr; grid-auto-rows: max-content; }
    }
    .panel {
      background: linear-gradient(160deg, rgba(34,211,238,0.08), transparent 20%) , var(--panel);
      border: 1px solid rgba(148,163,184,.15);
      border-radius: 14px;
      padding: 14px 14px 8px 14px;
      box-shadow: var(--shadow);
    }
    .header {
      display: flex; align-items: center; justify-content: space-between;
      margin-bottom: 10px; gap: 12px;
    }
    .title {
      font-size: 20px; font-weight: 700; letter-spacing: .3px; display: flex; align-items: center; gap: 8px;
    }
    .badge {
      font-size: 12px; padding: 2px 8px; border-radius: 999px; background: var(--badge); color: var(--muted);
      border: 1px solid rgba(148,163,184,0.18);
    }
    .controls { display: grid; gap: 10px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    .row > * { flex: 1; min-width: 100px; }
    .input {
      background: var(--input); color: var(--text); border: 1px solid rgba(148,163,184,.22); border-radius: 10px;
      padding: 10px 12px; outline: none;
    }
    .input:focus { border-color: var(--accent); box-shadow: 0 0 0 4px var(--ring); }
    .btn {
      background: var(--btn); color: var(--text); border: 1px solid rgba(148,163,184,.25);
      border-radius: 10px; padding: 10px 12px; cursor: pointer; user-select: none;
      transition: background .15s ease, border-color .15s ease, transform .05s ease;
    }
    .btn:hover { background: var(--btn-hover); }
    .btn:active { transform: translateY(1px); background: var(--btn-active); }
    .btn.accent { background: linear-gradient(120deg, rgba(34,211,238,.18), rgba(167,139,250,.18)); border-color: rgba(167,139,250,.45); }
    .btn.ok { border-color: rgba(52,211,153,.45); }
    .btn.warn { border-color: rgba(244,63,94,.45); }
    .tiny { font-size: 12px; color: var(--muted); }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .stat {
      background: rgba(2,6,23,.45); border: 1px solid rgba(148,163,184,.15); border-radius: 10px; padding: 8px 10px;
    }
    .stat .k { color: var(--muted); font-size: 12px; }
    .stat .v { font-weight: 700; font-size: 16px; }
    .log {
      background: rgba(2,6,23,.45); border: 1px solid rgba(148,163,184,.15); border-radius: 10px; padding: 8px; height: 150px; overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace; font-size: 12px; line-height: 1.35;
    }
    .log .item { color: var(--muted); }
    .pill {
      display: inline-block; padding: 1px 8px; border-radius: 999px; border: 1px solid rgba(148,163,184,.25);
      background: rgba(2,6,23,.5); font-size: 11px; color: var(--muted);
    }
    .viz-panel { display: grid; grid-template-rows: max-content 1fr max-content; gap: 10px; min-height: 0; }
    .viz-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    .legend { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .legend .dot { width: 12px; height: 12px; border-radius: 999px; display: inline-block; }
    .canvas-wrap {
      background: radial-gradient(1200px 600px at 20% -10%, rgba(34,211,238,.08), transparent 40%), radial-gradient(1200px 600px at 80% -10%, rgba(167,139,250,.08), transparent 40%), #020617;
      border: 1px solid rgba(148,163,184,.18);
      border-radius: 12px;
      overflow: auto;
      min-height: 260px;
      max-height: calc(100vh - 220px);
    }
    .svg {
      width: 100%; height: 100%;
      display: block;
      background-image: linear-gradient(transparent 23px, rgba(148,163,184,.08) 24px, transparent 24px), linear-gradient(90deg, transparent 23px, rgba(148,163,184,.08) 24px, transparent 24px);
      background-size: 24px 24px;
    }
    .edge {
      stroke: var(--edge); stroke-width: 2.2px;
    }
    .edge.highlight { stroke: var(--edge-hi); stroke-width: 2.6px; }
    .node {
      fill: var(--node);
      stroke: rgba(148,163,184,.45);
      stroke-width: 1.2px;
      transition: transform .15s ease, fill .15s ease, stroke .15s ease;
      cursor: pointer;
    }
    .node:hover { filter: brightness(1.08); }
    .node.hi { fill: #0b2a38; stroke: var(--node-hi); }
    .node.found { fill: #07202b; stroke: var(--node-found); }
    .node.del { fill: #2a0911; stroke: var(--node-del); }
    .label { fill: #e2e8f0; font-weight: 700; pointer-events: none; font-size: 12px; text-anchor: middle; dominant-baseline: central; }
    .sub-label { fill: var(--muted); font-size: 10px; pointer-events: none; }
    .travs {
      display: grid; gap: 8px; grid-template-columns: 1fr; margin-top: 4px;
    }
    .trav {
      background: rgba(2,6,23,.45); border: 1px solid rgba(148,163,184,.15); border-radius: 10px; padding: 8px;
    }
    .trav .name { color: var(--muted); font-size: 12px; }
    .trav .vals { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace; font-size: 12px; margin-top: 4px; word-break: break-word;}
    .hint { color: var(--muted); font-size: 12px; }
    .hr { height: 1px; background: rgba(148,163,184,.18); margin: 8px 0; }
    .footer {
      display: flex; align-items: center; justify-content: space-between; gap: 8px; flex-wrap: wrap;
    }
    .toggle {
      display: inline-flex; align-items: center; gap: 8px; background: rgba(2,6,23,.45);
      border: 1px solid rgba(148,163,184,.25); border-radius: 999px; padding: 4px 8px; cursor: pointer;
    }
    .toggle input { accent-color: var(--accent); }
    .ghost { opacity: .6; }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <div class="header">
        <div class="title">
          <span>Binary Search Tree</span>
          <span class="badge">BST</span>
        </div>
        <span class="pill">Interactive demo</span>
      </div>

      <div class="controls">
        <div class="row">
          <input id="keyInput" class="input" type="number" step="1" placeholder="Enter integer (e.g., 42)" />
        </div>
        <div class="row">
          <button id="insertBtn" class="btn accent">Insert</button>
          <button id="deleteBtn" class="btn warn">Delete</button>
          <button id="searchBtn" class="btn">Search</button>
        </div>
        <div class="row">
          <button id="rnd1Btn" class="btn">+1 Random</button>
          <button id="rnd5Btn" class="btn">+5 Random</button>
          <button id="rnd10Btn" class="btn">+10 Random</button>
          <button id="clearBtn" class="btn">Clear</button>
        </div>

        <div class="grid-2">
          <div class="stat">
            <div class="k">Size</div>
            <div class="v" id="sizeVal">0</div>
          </div>
          <div class="stat">
            <div class="k">Height (nodes)</div>
            <div class="v" id="heightVal">0</div>
          </div>
          <div class="stat">
            <div class="k">Min</div>
            <div class="v" id="minVal">—</div>
          </div>
          <div class="stat">
            <div class="k">Max</div>
            <div class="v" id="maxVal">—</div>
          </div>
          <div class="stat">
            <div class="k">Valid BST</div>
            <div class="v" id="validVal">Yes</div>
          </div>
          <div class="stat">
            <div class="k">Balanced?</div>
            <div class="v" id="balancedVal">No (not self-balancing)</div>
          </div>
        </div>

        <div class="hr"></div>
        <div class="tiny">
          A Binary Search Tree maintains the invariant: for any node with key k, all keys in its left subtree are less than k, and all keys in its right subtree are greater than k. Duplicate keys are not inserted here.
        </div>
        <div class="hr"></div>

        <div>
          <div class="tiny">Traversals</div>
          <div class="travs">
            <div class="trav">
              <div class="name">Inorder (sorted)</div>
              <div class="vals" id="inorderVals">[]</div>
            </div>
            <div class="trav">
              <div class="name">Preorder</div>
              <div class="vals" id="preorderVals">[]</div>
            </div>
            <div class="trav">
              <div class="name">Postorder</div>
              <div class="vals" id="postorderVals">[]</div>
            </div>
            <div class="trav">
              <div class="name">Level-order</div>
              <div class="vals" id="levelVals">[]</div>
            </div>
          </div>
        </div>

        <div class="hr"></div>
        <div>
          <div class="tiny">Event log</div>
          <div id="log" class="log" aria-live="polite"></div>
        </div>
      </div>
    </div>

    <div class="panel viz-panel">
      <div class="viz-header">
        <div class="title"><span>Tree Visualization</span></div>
        <div class="legend">
          <span class="dot" style="background:#0b2a38;border:1px solid #0ea5e9"></span><span class="tiny">Path</span>
          <span class="dot" style="background:#07202b;border:1px solid #38bdf8"></span><span class="tiny">Found</span>
          <span class="dot" style="background:#2a0911;border:1px solid #fb7185"></span><span class="tiny">Deleted</span>
        </div>
      </div>
      <div id="canvasWrap" class="canvas-wrap">
        <svg id="svg" class="svg" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="BST visualization"></svg>
      </div>
      <div class="footer">
        <div class="hint">Click a node to select its key or highlight the path from root.</div>
        <label class="toggle">
          <input id="animateToggle" type="checkbox" checked />
          <span class="tiny">Animate changes</span>
        </label>
      </div>
    </div>
  </div>

  <script>
    // ======= Data structures =======
    class TreeNode {
      constructor(key) {
        this.key = key;
        this.left = null;
        this.right = null;
      }
    }

    class BST {
      constructor() {
        this.root = null;
        this._size = 0;
      }
      get size() { return this._size; }

      insert(key) {
        const path = [];
        if (this.root === null) {
          this.root = new TreeNode(key);
          this._size = 1;
          return { inserted: true, node: this.root, path };
        }
        let cur = this.root;
        let parent = null;
        while (cur) {
          path.push(cur);
          parent = cur;
          if (key === cur.key) {
            return { inserted: false, node: cur, path };
          } else if (key < cur.key) {
            cur = cur.left;
          } else {
            cur = cur.right;
          }
        }
        const n = new TreeNode(key);
        if (key < parent.key) parent.left = n; else parent.right = n;
        this._size++;
        path.push(n);
        return { inserted: true, node: n, path };
      }

      search(key) {
        const path = [];
        let cur = this.root;
        while (cur) {
          path.push(cur);
          if (key === cur.key) return { found: true, node: cur, path };
          cur = key < cur.key ? cur.left : cur.right;
        }
        return { found: false, node: null, path };
      }

      delete(key) {
        // Collect path to the target (if exists) for highlight
        const s = this.search(key);
        const res = this._deleteRec(this.root, key);
        this.root = res.node;
        if (res.deleted) this._size--;
        return { deleted: res.deleted, path: s.path, key };
      }

      _deleteRec(node, key) {
        if (!node) return { node: null, deleted: false };
        if (key < node.key) {
          const leftRes = this._deleteRec(node.left, key);
          node.left = leftRes.node;
          return { node, deleted: leftRes.deleted };
        } else if (key > node.key) {
          const rightRes = this._deleteRec(node.right, key);
          node.right = rightRes.node;
          return { node, deleted: rightRes.deleted };
        } else {
          // node to delete found
          if (!node.left && !node.right) {
            return { node: null, deleted: true };
          } else if (!node.left) {
            return { node: node.right, deleted: true };
          } else if (!node.right) {
            return { node: node.left, deleted: true };
          } else {
            // Two children: inorder successor
            const succ = this._minNode(node.right);
            node.key = succ.key;
            const r = this._deleteRec(node.right, succ.key);
            node.right = r.node;
            return { node, deleted: true };
          }
        }
      }

      _minNode(node) {
        if (!node) return null;
        while (node.left) node = node.left;
        return node;
      }

      _maxNode(node) {
        if (!node) return null;
        while (node.right) node = node.right;
        return node;
      }

      min() {
        const n = this._minNode(this.root);
        return n ? n.key : null;
      }

      max() {
        const n = this._maxNode(this.root);
        return n ? n.key : null;
      }

      height() {
        const h = (n) => n ? 1 + Math.max(h(n.left), h(n.right)) : 0;
        return h(this.root);
      }

      isValid() {
        const dfs = (n, lo, hi) => {
          if (!n) return true;
          if ((lo !== null && n.key <= lo) || (hi !== null && n.key >= hi)) return false;
          return dfs(n.left, lo, n.key) && dfs(n.right, n.key, hi);
        };
        return dfs(this.root, null, null);
      }

      // Traversals
      inorder() {
        const res = [];
        (function dfs(n){ if (!n) return; dfs(n.left); res.push(n.key); dfs(n.right); })(this.root);
        return res;
      }
      preorder() {
        const res = [];
        (function dfs(n){ if (!n) return; res.push(n.key); dfs(n.left); dfs(n.right); })(this.root);
        return res;
      }
      postorder() {
        const res = [];
        (function dfs(n){ if (!n) return; dfs(n.left); dfs(n.right); res.push(n.key); })(this.root);
        return res;
      }
      levelOrder() {
        const res = [];
        if (!this.root) return res;
        const q = [this.root];
        while (q.length) {
          const n = q.shift();
          res.push(n.key);
          if (n.left) q.push(n.left);
          if (n.right) q.push(n.right);
        }
        return res;
      }
    }

    // ======= App State =======
    const state = {
      bst: new BST(),
      highlightPath: new Set(),
      highlightNodes: new Map(), // node -> className 'hi'|'found'|'del'
      selectedNode: null,
      animate: true,
      lastAction: ''
    };

    // ======= Utilities =======
    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    function now() { return new Date().toLocaleTimeString(); }

    function log(message) {
      const el = document.getElementById('log');
      const item = document.createElement('div');
      item.className = 'item';
      item.textContent = `[${now()}] ${message}`;
      el.appendChild(item);
      el.scrollTop = el.scrollHeight;
    }

    function setInputValue(v) {
      document.getElementById('keyInput').value = v ?? '';
    }

    // ======= Visualization =======
    function computePositions(root) {
      const pos = new Map();
      let xIndex = 0;
      let maxDepth = 0;
      function dfs(n, depth) {
        if (!n) return;
        dfs(n.left, depth + 1);
        pos.set(n, { xIndex: xIndex++, depth });
        if (depth > maxDepth) maxDepth = depth;
        dfs(n.right, depth + 1);
      }
      dfs(root, 0);
      return { pos, maxDepth, count: xIndex };
    }

    function drawTree() {
      const svg = document.getElementById('svg');
      const wrap = document.getElementById('canvasWrap');
      // Clear
      svg.innerHTML = '';

      const { pos, maxDepth, count } = computePositions(state.bst.root);
      // Layout settings
      const levelGap = 90;
      const nodeRadius = 18;
      const xSpacing = 56;
      const marginX = 40;
      const marginY = 40;
      const width = Math.max(wrap.clientWidth, count * xSpacing + marginX * 2);
      const height = Math.max(200, (maxDepth + 1) * levelGap + marginY * 2);

      svg.setAttribute('width', width);
      svg.setAttribute('height', height);

      // To draw edges and nodes, we need to traverse tree preserving parent-child relations.
      function getXY(n) {
        const p = pos.get(n);
        return {
          x: marginX + (p.xIndex + 0.5) * xSpacing,
          y: marginY + p.depth * levelGap
        };
      }

      // Edges
      function drawEdges(n) {
        if (!n) return;
        if (n.left) {
          const { x: x1, y: y1 } = getXY(n);
          const { x: x2, y: y2 } = getXY(n.left);
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', x1);
          line.setAttribute('y1', y1 + nodeRadius);
          line.setAttribute('x2', x2);
          line.setAttribute('y2', y2 - nodeRadius);
          line.setAttribute('class', 'edge' + (state.highlightPath.has(n.left) && state.highlightPath.has(n) ? ' highlight' : ''));
          svg.appendChild(line);
        }
        if (n.right) {
          const { x: x1, y: y1 } = getXY(n);
          const { x: x2, y: y2 } = getXY(n.right);
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', x1);
          line.setAttribute('y1', y1 + nodeRadius);
          line.setAttribute('x2', x2);
          line.setAttribute('y2', y2 - nodeRadius);
          line.setAttribute('class', 'edge' + (state.highlightPath.has(n.right) && state.highlightPath.has(n) ? ' highlight' : ''));
          svg.appendChild(line);
        }
        drawEdges(n.left);
        drawEdges(n.right);
      }

      // Nodes
      function drawNodes(n) {
        if (!n) return;
        drawNodes(n.left);

        const { x, y } = getXY(n);
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${x},${y})`);

        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('r', nodeRadius);
        let nodeClass = 'node';
        const mark = state.highlightNodes.get(n);
        if (state.highlightPath.has(n)) nodeClass += ' hi';
        if (mark === 'found') nodeClass += ' found';
        if (mark === 'del') nodeClass += ' del';
        circle.setAttribute('class', nodeClass);
        if (state.animate) {
          circle.style.transition = 'transform .2s ease';
          circle.style.transformOrigin = 'center';
          circle.style.transform = 'scale(1)';
          // subtle pop-in when rendered with highlights
          if (mark || state.highlightPath.has(n)) {
            circle.animate([{ transform: 'scale(0.7)' }, { transform: 'scale(1)' }], { duration: 180 });
          }
        }

        // Main label
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('class', 'label');
        text.textContent = n.key;

        // Sub-label: show L/R degrees
        const sub = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        sub.setAttribute('class', 'sub-label');
        sub.setAttribute('y', nodeRadius + 14);
        const degL = n.left ? 'L' : '-';
        const degR = n.right ? 'R' : '-';
        sub.textContent = `(${degL} | ${degR})`;

        g.appendChild(circle);
        g.appendChild(text);
        g.appendChild(sub);
        svg.appendChild(g);

        // Interactions
        g.style.cursor = 'pointer';
        g.addEventListener('click', () => {
          setInputValue(n.key);
          // Recompute and highlight path from root to this node
          const s = state.bst.search(n.key);
          setHighlightPath(new Set(s.path));
          markNode(n, 'found');
          announce(`Selected node ${n.key}. Path length ${s.path.length}.`);
          render(false, 1200);
        });

        drawNodes(n.right);
      }

      drawEdges(state.bst.root);
      drawNodes(state.bst.root);
    }

    function setHighlightPath(set) {
      state.highlightPath = set || new Set();
    }

    function clearHighlightNodes() {
      state.highlightNodes = new Map();
    }

    function markNode(node, type) {
      // type: 'hi' (path), 'found', 'del'
      if (!node) return;
      state.highlightNodes.set(node, type);
    }

    // ======= Render =======
    function render(instant = false, clearAfterMs = 800) {
      // stats
      document.getElementById('sizeVal').textContent = state.bst.size;
      document.getElementById('heightVal').textContent = state.bst.height();
      const min = state.bst.min();
      const max = state.bst.max();
      document.getElementById('minVal').textContent = min === null ? '—' : min;
      document.getElementById('maxVal').textContent = max === null ? '—' : max;
      document.getElementById('validVal').textContent = state.bst.isValid() ? 'Yes' : 'No';

      // traversals
      const fmt = (arr) => '[' + arr.join(', ') + ']';
      document.getElementById('inorderVals').textContent = fmt(state.bst.inorder());
      document.getElementById('preorderVals').textContent = fmt(state.bst.preorder());
      document.getElementById('postorderVals').textContent = fmt(state.bst.postorder());
      document.getElementById('levelVals').textContent = fmt(state.bst.levelOrder());

      // draw
      drawTree();

      // Clear highlights after a bit (unless instant)
      if (!instant && clearAfterMs > 0) {
        const myPath = state.highlightPath;
        const myMarks = new Map(state.highlightNodes);
        setTimeout(() => {
          // Only clear if still the same references (avoid clearing newer highlights)
          if (state.highlightPath === myPath) setHighlightPath(new Set());
          if (sameNodeMarkMap(state.highlightNodes, myMarks)) clearHighlightNodes();
          drawTree();
        }, clearAfterMs);
      }
    }

    function sameNodeMarkMap(a, b) {
      if (a.size !== b.size) return false;
      for (const [k, v] of a) {
        if (!b.has(k) || b.get(k) !== v) return false;
      }
      return true;
    }

    function announce(msg) { log(msg); }

    // ======= Event handlers =======
    function getInputKey() {
      const val = document.getElementById('keyInput').value;
      if (val === '' || val === null) return null;
      const num = Number(val);
      if (!Number.isFinite(num) || !Number.isInteger(num)) return null;
      return num;
    }

    function handleInsert() {
      const key = getInputKey();
      if (key === null) { announce('Insert: please enter an integer.'); return; }
      const { inserted, node, path } = state.bst.insert(key);
      setHighlightPath(new Set(path));
      if (inserted) {
        markNode(node, 'found');
        announce(`Inserted ${key}.`);
      } else {
        markNode(node, 'found');
        announce(`Key ${key} already exists. No insertion.`);
      }
      render(false, 1000);
    }

    function handleDelete() {
      const key = getInputKey();
      if (key === null) { announce('Delete: please enter an integer.'); return; }
      const { deleted, path } = state.bst.delete(key);
      setHighlightPath(new Set(path));
      if (deleted) {
        // mark last in path (the deleted node) if present
        const delNode = path.length ? path[path.length - 1] : null;
        if (delNode && delNode.key === key) markNode(delNode, 'del');
        announce(`Deleted ${key}.`);
      } else {
        announce(`Key ${key} not found. Nothing deleted.`);
      }
      render(false, 1000);
    }

    function handleSearch() {
      const key = getInputKey();
      if (key === null) { announce('Search: please enter an integer.'); return; }
      const { found, node, path } = state.bst.search(key);
      setHighlightPath(new Set(path));
      if (found) {
        markNode(node, 'found');
        announce(`Found ${key}. Path length ${path.length}.`);
      } else {
        announce(`Key ${key} not found. Path length ${path.length}.`);
      }
      render(false, 1200);
    }

    function handleRandom(n = 1) {
      let inserted = 0, attempts = 0;
      const maxAttempts = Math.max(20, n * 10);
      while (inserted < n && attempts < maxAttempts) {
        attempts++;
        const x = randInt(-99, 99);
        const res = state.bst.insert(x);
        if (res.inserted) inserted++;
      }
      setHighlightPath(new Set());
      clearHighlightNodes();
      announce(`Inserted ${inserted} random ${inserted === 1 ? 'key' : 'keys'}.`);
      render(true, 0);
    }

    function handleClear() {
      state.bst = new BST();
      setHighlightPath(new Set());
      clearHighlightNodes();
      setInputValue('');
      announce('Tree cleared.');
      render(true, 0);
    }

    // ======= Bootstrap =======
    function bind() {
      document.getElementById('insertBtn').addEventListener('click', handleInsert);
      document.getElementById('deleteBtn').addEventListener('click', handleDelete);
      document.getElementById('searchBtn').addEventListener('click', handleSearch);
      document.getElementById('rnd1Btn').addEventListener('click', () => handleRandom(1));
      document.getElementById('rnd5Btn').addEventListener('click', () => handleRandom(5));
      document.getElementById('rnd10Btn').addEventListener('click', () => handleRandom(10));
      document.getElementById('clearBtn').addEventListener('click', handleClear);
      document.getElementById('animateToggle').addEventListener('change', (e) => {
        state.animate = !!e.target.checked;
      });

      document.getElementById('keyInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          handleInsert();
        }
      });

      // Seed some values
      const seed = [50, 25, 75, 10, 33, 60, 80, 5, 18, 30, 40, 55, 65, 77, 90];
      for (const x of seed) state.bst.insert(x);
      announce('Seeded example tree. Enter a number and click Insert/Delete/Search.');
    }

    window.addEventListener('resize', () => drawTree());

    // Init
    bind();
    render(true, 0);
  </script>
</body>
</html>