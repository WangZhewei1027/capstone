<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Fibonacci Sequence — Interactive Demo</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --accent: #22c55e;
    --accent2: #60a5fa;
    --text: #e5e7eb;
    --muted: #9ca3af;
    --border: #1f2937;
    --warn: #f59e0b;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji", "Segoe UI Symbol";
    color: var(--text); background: radial-gradient(1000px 480px at 20% 0%, #0b1221, #0f172a);
  }
  header {
    padding: 24px 20px; border-bottom: 1px solid var(--border);
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0));
    position: sticky; top: 0; z-index: 3;
    backdrop-filter: blur(6px);
  }
  h1 { margin: 0; font-weight: 700; font-size: 22px; letter-spacing: 0.4px; }
  header p { margin: 8px 0 0; color: var(--muted); font-size: 14px; }
  main {
    padding: 20px; max-width: 1200px; margin: 0 auto;
    display: grid; grid-template-columns: 1fr; gap: 16px;
  }
  @media (min-width: 900px) {
    main { grid-template-columns: 1.05fr 0.95fr; }
  }
  section {
    background: linear-gradient(180deg, #0f182b, #0e1628);
    border: 1px solid var(--border);
    border-radius: 12px; overflow: hidden;
    box-shadow: 0 8px 24px rgba(0,0,0,0.35);
  }
  section header {
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0));
    border-bottom: 1px solid var(--border); position: static;
    padding: 14px 16px;
  }
  section header h2 {
    margin: 0; font-size: 16px; font-weight: 700; letter-spacing: 0.2px;
  }
  section header p { margin: 6px 0 0; color: var(--muted); font-size: 13px; }
  .content { padding: 14px; }
  .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px; }
  .control { background: #101a2d; border: 1px solid var(--border); border-radius: 10px; padding: 10px; }
  .control label { display: flex; justify-content: space-between; align-items: center; font-size: 13px; color: var(--muted); margin-bottom: 8px; }
  .control input[type="range"] { width: 100%; }
  .control input[type="number"] { width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid var(--border); background: #0c1426; color: var(--text); }
  .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
  .btn {
    background: linear-gradient(180deg, #1f2937, #111827); color: var(--text);
    border: 1px solid var(--border); border-radius: 9px; padding: 8px 12px;
    cursor: pointer; font-size: 13px;
  }
  .btn:hover { border-color: #334155; }
  .btn.accent { background: linear-gradient(180deg, #1f8b5f, #136c48); border-color: #1a8a57; }
  .btn.warn { background: linear-gradient(180deg, #925b13, #7a470c); border-color: #b97513; }
  .pill {
    display:inline-block; padding: 2px 8px; border-radius:100px; font-size:12px;
    border: 1px solid var(--border); color: var(--muted);
  }
  .sequence-box {
    background: #0c1527; border: 1px solid var(--border); border-radius: 10px;
    padding: 10px; max-height: 240px; overflow: auto; font-size: 13px; line-height: 1.6;
  }
  .sequence-box b { color: var(--accent); }
  .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 8px; }
  .stat {
    background: #0e172a; border: 1px solid var(--border); border-radius: 10px; padding: 10px;
  }
  .stat .label { color: var(--muted); font-size: 12px; }
  .stat .value { font-weight: 700; margin-top: 6px; font-size: 14px; }
  canvas, svg { display: block; width: 100%; height: 320px; background: #0c1527; border: 1px solid var(--border); border-radius: 10px; }
  .legend { display:flex; gap:10px; align-items:center; margin:10px 0 0; }
  .swatch { width: 12px; height: 12px; border-radius: 2px; display:inline-block; border: 1px solid var(--border); margin-right: 6px; }
  .swatch.green { background: #22c55e; }
  .swatch.blue { background: #60a5fa; }
  .swatch.purple { background: #a78bfa; }
  .note { color: var(--muted); font-size: 12px; margin-top: 8px; }
  .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
  @media (max-width: 700px) { .controls { grid-template-columns: 1fr; } .grid2 { grid-template-columns: 1fr; } }
</style>
</head>
<body>
<header>
  <h1>Fibonacci Sequence — Interactive Demo</h1>
  <p>Explore Fibonacci numbers, algorithms, the golden ratio convergence, and a classic Fibonacci spiral, all in one page.</p>
</header>

<main>
  <!-- Sequence Generator -->
  <section id="seqPanel">
    <header>
      <h2>Sequence Generator</h2>
      <p>Generate the first N Fibonacci numbers using an efficient BigInt algorithm.</p>
    </header>
    <div class="content">
      <div class="controls">
        <div class="control">
          <label>
            Length N
            <span class="pill"><span id="seqNLabel">30</span></span>
          </label>
          <input id="seqN" type="range" min="0" max="300" step="1" value="30">
        </div>
        <div class="control">
          <label>
            Display options
            <span class="pill">Formatting</span>
          </label>
          <div class="row">
            <button id="btnFormatGroup" class="btn">Group digits</button>
            <button id="btnFormatPlain" class="btn">Plain</button>
            <button id="btnCopy" class="btn">Copy list</button>
            <button id="btnAnimate" class="btn accent">Play build</button>
          </div>
        </div>
      </div>

      <div class="sequence-box" id="sequenceBox" aria-live="polite"></div>

      <div class="stats">
        <div class="stat">
          <div class="label">F(N) value</div>
          <div class="value" id="statFn">—</div>
        </div>
        <div class="stat">
          <div class="label">Sum of first N terms</div>
          <div class="value" id="statSum">—</div>
        </div>
        <div class="stat">
          <div class="label">Largest term digits</div>
          <div class="value" id="statDigits">—</div>
        </div>
      </div>
      <div class="note">By convention F(0)=0, F(1)=1. This generator uses constant space arithmetic with BigInt and runs in O(N).</div>
    </div>
  </section>

  <!-- Ratio Convergence -->
  <section id="ratioPanel">
    <header>
      <h2>Golden Ratio Convergence</h2>
      <p>See how F(n+1)/F(n) approaches φ = (1+√5)/2.</p>
    </header>
    <div class="content">
      <div class="controls">
        <div class="control">
          <label>
            Max n for ratio plot
            <span class="pill"><span id="ratioNLabel">30</span></span>
          </label>
          <input id="ratioN" type="range" min="2" max="93" step="1" value="30">
        </div>
        <div class="control">
          <label>
            Options
            <span class="pill">Lines</span>
          </label>
          <div class="row">
            <button id="btnRatioAnimate" class="btn accent">Animate ratios</button>
            <button id="btnRatioReset" class="btn">Reset</button>
          </div>
        </div>
      </div>
      <canvas id="ratioCanvas" width="640" height="320" aria-label="Ratio chart"></canvas>
      <div class="legend">
        <span><span class="swatch green"></span>F(n+1)/F(n)</span>
        <span><span class="swatch blue"></span>Golden ratio φ</span>
      </div>
      <div class="note">Numerical stability: we use safe integers for n ≤ 93. Ratios quickly stabilize near φ ≈ 1.6180339887…</div>
    </div>
  </section>

  <!-- Spiral Visualization -->
  <section id="spiralPanel">
    <header>
      <h2>Fibonacci Spiral</h2>
      <p>Squares sized by Fibonacci numbers arranged in a spiral, with quarter-circle arcs.</p>
    </header>
    <div class="content">
      <div class="controls">
        <div class="control">
          <label>
            Squares count
            <span class="pill"><span id="spiralCountLabel">10</span></span>
          </label>
          <input id="spiralCount" type="range" min="2" max="16" step="1" value="10">
        </div>
        <div class="control">
          <label>
            Styles
            <span class="pill">Visuals</span>
          </label>
          <div class="row">
            <button id="btnSpiralSquares" class="btn">Squares</button>
            <button id="btnSpiralArcs" class="btn accent">Squares + arcs</button>
            <button id="btnSpiralAnimate" class="btn accent">Animate</button>
          </div>
        </div>
      </div>
      <canvas id="spiralCanvas" width="640" height="360" aria-label="Fibonacci spiral"></canvas>
      <div class="legend">
        <span><span class="swatch blue"></span>Squares</span>
        <span><span class="swatch purple"></span>Quarter arcs</span>
      </div>
      <div class="note">To fit the canvas, sizes are scaled. Orientation cycles: right → up → left → down.</div>
    </div>
  </section>

  <!-- Algorithms and Performance -->
  <section id="algoPanel">
    <header>
      <h2>Algorithms & Performance</h2>
      <p>Compare naive recursion with efficient iteration and memoization.</p>
    </header>
    <div class="content">
      <div class="grid2">
        <div class="control">
          <label>
            n for F(n)
            <span class="pill"><span id="algoNLabel">35</span></span>
          </label>
          <input id="algoN" type="range" min="0" max="45" step="1" value="35">
          <div class="row" style="margin-top:10px;">
            <button id="btnRunAll" class="btn accent">Run All</button>
            <button id="btnRunIter" class="btn">Iterative</button>
            <button id="btnRunRec" class="btn warn">Naive recursive</button>
            <button id="btnRunMemo" class="btn">Memoized</button>
          </div>
          <div class="note">Warning: naive recursion is exponential. Keep n ≤ 40–45.</div>
        </div>
        <div class="control">
          <label>
            Results
            <span class="pill">Time & calls</span>
          </label>
          <div id="algoResults" class="sequence-box" style="max-height:180px;"></div>
        </div>
      </div>
    </div>
  </section>
</main>

<script>
/* Utilities */
const phi = (1 + Math.sqrt(5)) / 2;

function fibSequenceBigInt(n) {
  const seq = [];
  let a = 0n, b = 1n;
  for (let i = 0; i <= n; i++) {
    seq.push(a);
    const next = a + b;
    a = b; b = next;
  }
  return seq;
}
function fibNthIterativeBigInt(n) {
  let a = 0n, b = 1n;
  if (n === 0) return a;
  for (let i = 1; i < n; i++) {
    const t = a + b;
    a = b;
    b = t;
  }
  return b;
}
// Numeric versions for ratio and recursion demos
function fibNthIterativeNumber(n) {
  let a = 0, b = 1;
  if (n === 0) return a;
  for (let i = 1; i < n; i++) {
    const t = a + b; a = b; b = t;
  }
  return b;
}
function fibNthRecursiveNumber(n, stats) {
  stats.calls++;
  if (n <= 1) return n;
  return fibNthRecursiveNumber(n - 1, stats) + fibNthRecursiveNumber(n - 2, stats);
}
function fibNthMemoNumber(n, memo, stats) {
  stats.calls++;
  if (memo.has(n)) return memo.get(n);
  const v = n <= 1 ? n : fibNthMemoNumber(n - 1, memo, stats) + fibNthMemoNumber(n - 2, memo, stats);
  memo.set(n, v);
  return v;
}
function bigIntDigits(bi) {
  return bi.toString().length;
}
function formatBigInt(bi, grouped) {
  const s = bi.toString();
  if (!grouped) return s;
  // group in threes for readability
  const neg = s[0] === '-';
  const raw = neg ? s.slice(1) : s;
  let out = '';
  for (let i = 0; i < raw.length; i++) {
    const idx = raw.length - i;
    const ch = raw[i];
    out += ch;
    const left = raw.length - i - 1;
    if (left > 0 && left % 3 === 0) out += ' '; // thin space
  }
  return neg ? '-' + out : out;
}

/* Sequence Panel */
const seqN = document.getElementById('seqN');
const seqNLabel = document.getElementById('seqNLabel');
const sequenceBox = document.getElementById('sequenceBox');
const statFn = document.getElementById('statFn');
const statSum = document.getElementById('statSum');
const statDigits = document.getElementById('statDigits');
const btnFormatGroup = document.getElementById('btnFormatGroup');
const btnFormatPlain = document.getElementById('btnFormatPlain');
const btnCopy = document.getElementById('btnCopy');
const btnAnimate = document.getElementById('btnAnimate');

let seqFormatGrouped = true;
let seqAnimating = false;
let seqAnimationFrame = null;
let seqAnimationIndex = 0;

function updateSequence() {
  const n = parseInt(seqN.value, 10);
  seqNLabel.textContent = n.toString();
  const seq = fibSequenceBigInt(n);
  const formatted = seq.map((v, i) => {
    const label = `F(${i})`;
    return `${label} = ${formatBigInt(v, seqFormatGrouped)}`;
  }).join('\n');
  sequenceBox.textContent = formatted;
  const fn = seq[seq.length - 1] || 0n;
  statFn.textContent = formatBigInt(fn, seqFormatGrouped);
  // Sum of first N terms (including F(0) to F(N)): we have identity Sum F(0..n) = F(n+2) - 1
  const sum = fibNthIterativeBigInt(n + 2) - 1n;
  statSum.textContent = formatBigInt(sum, seqFormatGrouped);
  statDigits.textContent = bigIntDigits(fn).toString();
}
seqN.addEventListener('input', () => {
  if (seqAnimating) stopSeqAnimation();
  updateSequence();
});
btnFormatGroup.addEventListener('click', () => {
  seqFormatGrouped = true; updateSequence();
});
btnFormatPlain.addEventListener('click', () => {
  seqFormatGrouped = false; updateSequence();
});
btnCopy.addEventListener('click', async () => {
  try {
    await navigator.clipboard.writeText(sequenceBox.textContent);
    btnCopy.textContent = 'Copied!';
    setTimeout(() => btnCopy.textContent = 'Copy list', 1200);
  } catch (e) {
    btnCopy.textContent = 'Copy failed';
    setTimeout(() => btnCopy.textContent = 'Copy list', 1200);
  }
});
function startSeqAnimation() {
  if (seqAnimating) return;
  seqAnimating = true;
  btnAnimate.textContent = 'Pause';
  seqAnimationIndex = 0;
  const n = parseInt(seqN.value, 10);
  const seq = fibSequenceBigInt(n);
  const step = () => {
    if (!seqAnimating) return;
    if (seqAnimationIndex > n) { stopSeqAnimation(); return; }
    const lines = [];
    for (let i = 0; i <= seqAnimationIndex; i++) {
      lines.push(`F(${i}) = ${formatBigInt(seq[i], seqFormatGrouped)}`);
    }
    sequenceBox.textContent = lines.join('\n');
    seqAnimationIndex++;
    seqAnimationFrame = requestAnimationFrame(step);
  };
  step();
}
function stopSeqAnimation() {
  seqAnimating = false;
  btnAnimate.textContent = 'Play build';
  if (seqAnimationFrame) cancelAnimationFrame(seqAnimationFrame);
  updateSequence();
}
btnAnimate.addEventListener('click', () => {
  if (seqAnimating) stopSeqAnimation(); else startSeqAnimation();
});

/* Ratio Convergence */
const ratioCanvas = document.getElementById('ratioCanvas');
const rctx = ratioCanvas.getContext('2d');
const ratioN = document.getElementById('ratioN');
const ratioNLabel = document.getElementById('ratioNLabel');
const btnRatioAnimate = document.getElementById('btnRatioAnimate');
const btnRatioReset = document.getElementById('btnRatioReset');
let ratioAnimating = false;
let ratioAnimStep = 2; // start at n=2
function computeRatios(m) {
  const ratios = [];
  for (let n = 1; n <= m; n++) {
    const f1 = fibNthIterativeNumber(n);
    const f2 = fibNthIterativeNumber(n + 1);
    ratios.push(f2 / f1);
  }
  return ratios;
}
function drawRatioChart(maxN, animN = null) {
  const w = ratioCanvas.width, h = ratioCanvas.height;
  rctx.clearRect(0, 0, w, h);
  // padding
  const padL = 40, padB = 28, padT = 18, padR = 16;
  const plotW = w - padL - padR;
  const plotH = h - padT - padB;
  rctx.fillStyle = '#0b1429';
  rctx.fillRect(0,0,w,h);
  rctx.strokeStyle = '#1f2937'; rctx.lineWidth = 1.0;
  // grid
  rctx.beginPath();
  for (let i = 0; i <= 5; i++) {
    const y = padT + i * plotH / 5;
    rctx.moveTo(padL, y); rctx.lineTo(padL + plotW, y);
  }
  for (let i = 0; i <= 10; i++) {
    const x = padL + i * plotW / 10;
    rctx.moveTo(x, padT); rctx.lineTo(x, padT + plotH);
  }
  rctx.stroke();
  // axes labels
  rctx.fillStyle = '#9ca3af'; rctx.font = '12px system-ui, sans-serif';
  rctx.fillText('n', w - padR - 10, h - 8);
  rctx.fillText('ratio', 8, padT + 12);
  // compute ratios
  const m = maxN;
  const ratios = computeRatios(m);
  const maxY = 2.0, minY = 1.0;
  // phi line
  const phiY = padT + (1 - (phi - minY) / (maxY - minY)) * plotH;
  rctx.strokeStyle = '#60a5fa'; rctx.lineWidth = 1.2;
  rctx.beginPath(); rctx.moveTo(padL, phiY); rctx.lineTo(padL + plotW, phiY); rctx.stroke();
  rctx.fillStyle = '#60a5fa';
  rctx.fillText(`φ ≈ ${phi.toFixed(6)}`, padL + 6, phiY - 6);
  // plot ratios
  const xFor = n => padL + (n - 1) * plotW / (m - 1);
  const yFor = val => padT + (1 - (val - minY) / (maxY - minY)) * plotH;
  rctx.strokeStyle = '#22c55e'; rctx.lineWidth = 2.0; rctx.beginPath();
  const Nplot = animN ? Math.min(animN - 1, ratios.length) : ratios.length;
  for (let i = 0; i < Nplot; i++) {
    const x = xFor(i + 1);
    const y = yFor(ratios[i]);
    if (i === 0) rctx.moveTo(x, y); else rctx.lineTo(x, y);
  }
  rctx.stroke();
  // points
  rctx.fillStyle = '#22c55e';
  for (let i = 0; i < Nplot; i++) {
    const x = xFor(i + 1), y = yFor(ratios[i]);
    rctx.beginPath(); rctx.arc(x, y, 2.8, 0, Math.PI * 2); rctx.fill();
  }
}
function updateRatio() {
  const n = parseInt(ratioN.value, 10);
  ratioNLabel.textContent = n.toString();
  drawRatioChart(n);
}
ratioN.addEventListener('input', () => { ratioAnimating = false; btnRatioAnimate.textContent='Animate ratios'; updateRatio(); });
btnRatioReset.addEventListener('click', () => {
  ratioAnimating = false; btnRatioAnimate.textContent='Animate ratios'; ratioAnimStep = 2; updateRatio();
});
function animateRatios() {
  const nMax = parseInt(ratioN.value, 10);
  if (!ratioAnimating) {
    ratioAnimating = true; btnRatioAnimate.textContent='Pause';
    ratioAnimStep = 2;
  } else {
    ratioAnimating = false; btnRatioAnimate.textContent='Animate ratios';
    return;
  }
  const tick = () => {
    if (!ratioAnimating) return;
    drawRatioChart(nMax, ratioAnimStep);
    ratioAnimStep++;
    if (ratioAnimStep > nMax + 1) { ratioAnimating = false; btnRatioAnimate.textContent='Animate ratios'; return; }
    requestAnimationFrame(tick);
  };
  tick();
}
btnRatioAnimate.addEventListener('click', animateRatios);

/* Spiral Visualization */
const spiralCanvas = document.getElementById('spiralCanvas');
const sctx = spiralCanvas.getContext('2d');
const spiralCount = document.getElementById('spiralCount');
const spiralCountLabel = document.getElementById('spiralCountLabel');
const btnSpiralSquares = document.getElementById('btnSpiralSquares');
const btnSpiralArcs = document.getElementById('btnSpiralArcs');
const btnSpiralAnimate = document.getElementById('btnSpiralAnimate');
let spiralShowArcs = true;
let spiralAnimating = false;
let spiralAnimIndex = 0;

function buildSpiralSquares(k) {
  // sizes: F(1)..F(k)
  const sizes = [];
  let a = 1, b = 1;
  sizes.push(a); sizes.push(b);
  for (let i = 3; i <= k; i++) {
    const t = a + b; a = b; b = t; sizes.push(b);
  }
  // positions
  const squares = [];
  // s1 at (0,0), s2 to the right
  squares.push({ size: sizes[0], x: 0, y: 0 });
  squares.push({ size: sizes[1], x: sizes[0], y: 0 });
  // bounding rect
  let rectX = 0, rectY = 0, rectW = sizes[0] + sizes[1], rectH = sizes[1];
  // place s3..k
  for (let i = 3; i <= k; i++) {
    const s = sizes[i - 1];
    const orientIdx = (i - 3) % 4; // 0 up, 1 left, 2 down, 3 right
    if (orientIdx === 0) { // up
      squares.push({ size: s, x: rectX, y: rectY - s });
      rectY -= s; rectH += s;
    } else if (orientIdx === 1) { // left
      squares.push({ size: s, x: rectX - s, y: rectY });
      rectX -= s; rectW += s;
    } else if (orientIdx === 2) { // down
      squares.push({ size: s, x: rectX, y: rectY + rectH });
      rectH += s;
    } else { // right
      squares.push({ size: s, x: rectX + rectW, y: rectY });
      rectW += s;
    }
  }
  return { squares, bounds: { x: rectX, y: rectY, w: rectW, h: rectH } };
}
function drawSpiral(k, stepLimit = null) {
  const w = spiralCanvas.width, h = spiralCanvas.height;
  sctx.clearRect(0, 0, w, h);
  sctx.fillStyle = '#0b1429';
  sctx.fillRect(0, 0, w, h);

  const data = buildSpiralSquares(k);
  const { squares, bounds } = data;
  // scale to fit
  const pad = 16;
  const scale = Math.min((w - 2*pad) / bounds.w, (h - 2*pad) / bounds.h);
  const offsetX = (w - bounds.w * scale) / 2 - bounds.x * scale;
  const offsetY = (h - bounds.h * scale) / 2 - bounds.y * scale;

  const countToDraw = stepLimit ? Math.min(stepLimit, squares.length) : squares.length;
  // draw squares
  sctx.strokeStyle = '#3b82f6'; sctx.lineWidth = 2.0;
  for (let i = 0; i < countToDraw; i++) {
    const sq = squares[i];
    const x = offsetX + sq.x * scale;
    const y = offsetY + sq.y * scale;
    const s = sq.size * scale;
    sctx.strokeRect(x, y, s, s);
  }
  // draw arcs
  if (spiralShowArcs) {
    sctx.strokeStyle = '#a78bfa'; sctx.lineWidth = 2.0;
    for (let i = 0; i < countToDraw; i++) {
      const sq = squares[i];
      const x = offsetX + sq.x * scale;
      const y = offsetY + sq.y * scale;
      const s = sq.size * scale;
      // orientation pattern for arcs: right, up, left, down repeating starting at i=1
      const orientIdx = i % 4; // 0:right,1:up,2:left,3:down
      let cx, cy, start, end;
      if (orientIdx === 0) { // right
        cx = x; cy = y + s; start = -Math.PI/2; end = 0;
      } else if (orientIdx === 1) { // up
        cx = x + s; cy = y + s; start = 0; end = Math.PI/2;
      } else if (orientIdx === 2) { // left
        cx = x + s; cy = y; start = Math.PI/2; end = Math.PI;
      } else { // down
        cx = x; cy = y; start = Math.PI; end = 3*Math.PI/2;
      }
      sctx.beginPath();
      sctx.arc(cx, cy, s, start, end);
      sctx.stroke();
    }
  }
}
function updateSpiral() {
  const k = parseInt(spiralCount.value, 10);
  spiralCountLabel.textContent = k.toString();
  drawSpiral(k);
}
spiralCount.addEventListener('input', () => { spiralAnimating = false; btnSpiralAnimate.textContent = 'Animate'; updateSpiral(); });
btnSpiralSquares.addEventListener('click', () => { spiralShowArcs = false; updateSpiral(); });
btnSpiralArcs.addEventListener('click', () => { spiralShowArcs = true; updateSpiral(); });
btnSpiralAnimate.addEventListener('click', () => {
  const k = parseInt(spiralCount.value, 10);
  if (!spiralAnimating) {
    spiralAnimating = true; btnSpiralAnimate.textContent = 'Pause';
    spiralAnimIndex = 1;
    const tick = () => {
      if (!spiralAnimating) return;
      drawSpiral(k, spiralAnimIndex);
      spiralAnimIndex++;
      if (spiralAnimIndex > k) { spiralAnimating = false; btnSpiralAnimate.textContent = 'Animate'; return; }
      requestAnimationFrame(tick);
    };
    tick();
  } else {
    spiralAnimating = false; btnSpiralAnimate.textContent = 'Animate';
  }
});

/* Algorithms & Performance */
const algoN = document.getElementById('algoN');
const algoNLabel = document.getElementById('algoNLabel');
const btnRunAll = document.getElementById('btnRunAll');
const btnRunIter = document.getElementById('btnRunIter');
const btnRunRec = document.getElementById('btnRunRec');
const btnRunMemo = document.getElementById('btnRunMemo');
const algoResults = document.getElementById('algoResults');

function runIter() {
  const n = parseInt(algoN.value, 10);
  const t0 = performance.now();
  const v = fibNthIterativeBigInt(n);
  const t1 = performance.now();
  logAlgo(`Iterative (BigInt) F(${n})`, formatBigInt(v, true), `${(t1 - t0).toFixed(3)} ms`, '—');
}
function runRec() {
  const n = parseInt(algoN.value, 10);
  const stats = { calls: 0 };
  const t0 = performance.now();
  const v = fibNthRecursiveNumber(n, stats);
  const t1 = performance.now();
  logAlgo(`Naive recursive (Number) F(${n})`, v.toString(), `${(t1 - t0).toFixed(3)} ms`, stats.calls.toLocaleString());
}
function runMemo() {
  const n = parseInt(algoN.value, 10);
  const memo = new Map();
  const stats = { calls: 0 };
  const t0 = performance.now();
  const v = fibNthMemoNumber(n, memo, stats);
  const t1 = performance.now();
  logAlgo(`Memoized recursion (Number) F(${n})`, v.toString(), `${(t1 - t0).toFixed(3)} ms`, stats.calls.toLocaleString());
}
function logAlgo(name, value, time, calls) {
  const line = `${name}\n  Value: ${value}\n  Time: ${time}\n  Calls: ${calls}\n`;
  algoResults.textContent = line + '\n' + algoResults.textContent;
}
algoN.addEventListener('input', () => { algoNLabel.textContent = algoN.value; });
btnRunIter.addEventListener('click', runIter);
btnRunRec.addEventListener('click', runRec);
btnRunMemo.addEventListener('click', runMemo);
btnRunAll.addEventListener('click', () => { runIter(); runMemo(); runRec(); });

/* Initial render */
updateSequence();
updateRatio();
updateSpiral();
</script>
</body>
</html>