<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Longest Common Subsequence (LCS) Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg: #0f172a;
      --panel: #111827;
      --accent: #6366f1;
      --accent-2: #22c55e;
      --accent-3: #f59e0b;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --border: #1f2937;
      --danger: #ef4444;
      --grid-cell: #0b1220;
      --grid-header: #0d1526;
      --current: #fde68a;
      --neighbor: #1f2937;
      --path: #a78bfa;
      --match: #064e3b;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: linear-gradient(120deg, #0b1020, #0f172a 60%, #0b1020);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Segoe UI Emoji", "Apple Color Emoji", sans-serif;
      overflow-y: auto;
    }
    a { color: var(--accent); text-decoration: none; }
    header {
      padding: 16px 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
      background: rgba(17, 24, 39, 0.6);
      backdrop-filter: blur(6px);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    header h1 {
      margin: 0;
      font-size: 20px;
      letter-spacing: 0.5px;
    }
    .container {
      max-width: 1200px;
      margin: 24px auto;
      padding: 0 20px 40px;
    }
    .panel {
      background: rgba(17, 24, 39, 0.65);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.25);
    }
    .row {
      display: grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap: 16px;
    }
    @media (max-width: 960px) {
      .row { grid-template-columns: 1fr; }
    }

    /* Inputs */
    .inputs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 720px) {
      .inputs { grid-template-columns: 1fr; }
    }
    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
      letter-spacing: 0.3px;
    }
    input[type="text"], textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0b1220;
      color: var(--text);
      font-size: 14px;
    }
    textarea { min-height: 52px; resize: vertical; }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-top: 12px;
    }
    .btn {
      background: #0b1220;
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      transition: 0.15s all ease;
    }
    .btn:hover { border-color: #334155; transform: translateY(-1px); }
    .btn.primary {
      background: linear-gradient(135deg, #4338ca, #6366f1);
      border-color: transparent;
    }
    .btn.primary:hover { filter: brightness(1.08); }
    .btn.danger {
      background: linear-gradient(135deg, #be123c, #ef4444);
      border-color: transparent;
    }
    .btn.secondary {
      background: linear-gradient(135deg, #0b1220, #0d1526);
      border-color: #1f2937;
    }
    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px dashed #1f2937;
    }
    .toggle input { transform: translateY(1px); }
    .speed {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px dashed #1f2937;
      color: var(--muted);
      font-size: 13px;
    }
    input[type="range"] {
      width: 140px;
    }
    select {
      background: #0b1220;
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
    }

    /* Result summary */
    .summary {
      display: grid;
      grid-template-columns: 3fr 2fr;
      gap: 16px;
      margin-top: 16px;
    }
    @media (max-width: 960px) {
      .summary { grid-template-columns: 1fr; }
    }
    .lcs-box {
      background: linear-gradient(135deg, rgba(67, 56, 202, 0.22), rgba(99, 102, 241, 0.12));
      border: 1px solid #3730a3;
      border-radius: 12px;
      padding: 14px;
    }
    .lcs-title { font-size: 13px; color: #c7d2fe; }
    .lcs-value {
      font-weight: 700;
      font-size: 18px;
      margin-top: 4px;
      letter-spacing: 0.4px;
    }
    .lcs-length {
      margin-top: 6px;
      font-size: 13px;
      color: #cbd5e1;
    }
    .explain {
      background: #0b1220;
      border: 1px dashed #334155;
      border-radius: 12px;
      padding: 12px;
      min-height: 72px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 14px;
    }
    .explain .line { color: #cbd5e1; }
    .explain .muted { color: var(--muted); }
    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
    }
    .key {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border: 1px dashed #334155;
      border-radius: 8px;
      background: #0b1220;
    }
    .swatch {
      width: 14px; height: 14px; border-radius: 4px; display: inline-block;
    }

    /* Grid */
    .grid-wrapper {
      margin-top: 16px;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #0d1526;
    }
    .grid {
      display: grid;
      grid-auto-rows: 34px;
      grid-auto-columns: 34px;
      justify-content: start;
      align-content: start;
      padding: 10px;
      gap: 2px;
    }
    .cell {
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--grid-cell);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 13px;
      position: relative;
      color: #cbd5e1;
      user-select: none;
    }
    .cell.header {
      background: var(--grid-header);
      color: #93c5fd;
      font-weight: 600;
      border-color: #1e293b;
    }
    .cell.corner {
      background: #0b1220;
    }
    .cell.zero {
      color: #64748b;
    }
    .cell.current {
      background: #fef3c7;
      color: #0f172a;
      border-color: #f59e0b;
      z-index: 2;
    }
    .cell.neighbor {
      outline: 2px dashed #6b7280;
      outline-offset: -3px;
    }
    .cell.match {
      background: #064e3b;
      border-color: #065f46;
      color: #ecfeff;
    }
    .cell.path {
      border-color: #a78bfa;
      box-shadow: 0 0 0 2px rgba(167, 139, 250, 0.6) inset;
    }
    .arrow {
      position: absolute;
      right: 6px;
      bottom: 2px;
      font-size: 16px;
      opacity: 0.9;
    }
    .arrow.diag { color: var(--accent-2); }
    .arrow.up { color: #60a5fa; }
    .arrow.left { color: #fb923c; }

    .notice {
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    footer {
      max-width: 1200px;
      margin: 24px auto 40px;
      color: var(--muted);
      padding: 0 20px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Longest Common Subsequence (LCS) Visualizer</h1>
    <div style="font-size: 12px; color: var(--muted)">Interactive dynamic programming grid with path reconstruction</div>
  </header>

  <div class="container">
    <div class="row">
      <div class="panel">
        <div class="inputs">
          <div>
            <label for="seqA">Sequence A</label>
            <textarea id="seqA" placeholder="Enter first sequence">ABCBDAB</textarea>
          </div>
          <div>
            <label for="seqB">Sequence B</label>
            <textarea id="seqB" placeholder="Enter second sequence">BDCABA</textarea>
          </div>
        </div>

        <div class="controls">
          <button class="btn primary" id="computeBtn">Compute</button>
          <button class="btn secondary" id="resetBtn">Reset</button>
          <button class="btn" id="stepBtn">Step</button>
          <button class="btn" id="playBtn">Play</button>
          <button class="btn" id="pauseBtn" disabled>Pause</button>

          <span class="toggle">
            <input type="checkbox" id="caseToggle" />
            <label for="caseToggle" style="margin: 0">Case sensitive</label>
          </span>
          <span class="toggle">
            <input type="checkbox" id="spaceToggle" />
            <label for="spaceToggle" style="margin: 0">Ignore spaces</label>
          </span>
          <span class="toggle">
            <input type="checkbox" id="pathToggle" checked />
            <label for="pathToggle" style="margin: 0">Show LCS path</label>
          </span>
          <span class="speed">
            Speed
            <input type="range" id="speedRange" min="50" max="800" value="350" />
          </span>
          <select id="examples">
            <option value="">Examples</option>
            <option value="ABCBDAB|BDCABA">ABCBDAB vs BDCABA</option>
            <option value="XMJYAUZ|MZJAWXU">XMJYAUZ vs MZJAWXU</option>
            <option value="AGGTAB|GXTXAYB">AGGTAB vs GXTXAYB</option>
            <option value="BANANA|ATANA">BANANA vs ATANA</option>
            <option value="ABCDGH|AEDFHR">ABCDGH vs AEDFHR</option>
          </select>
          <button class="btn danger" id="randomBtn">Random A/B</button>
        </div>

        <div class="summary">
          <div class="lcs-box">
            <div class="lcs-title">Longest Common Subsequence</div>
            <div class="lcs-value" id="lcsValue">—</div>
            <div class="lcs-length" id="lcsLength">Length: —</div>
          </div>
          <div class="explain" id="explainBox">
            <div class="line">Press Compute to fill the DP table or Step/Play to watch the algorithm.</div>
            <div class="legend">
              <span class="key"><span class="swatch" style="background: var(--accent-2)"></span> match: take diagonal + 1</span>
              <span class="key"><span class="swatch" style="background: #60a5fa"></span> up: take from top</span>
              <span class="key"><span class="swatch" style="background: #fb923c"></span> left: take from left</span>
              <span class="key"><span class="swatch" style="background: var(--path)"></span> LCS path</span>
            </div>
          </div>
        </div>

        <div class="grid-wrapper">
          <div class="grid" id="grid"></div>
        </div>
        <div class="notice" id="notice"></div>
      </div>

      <div class="panel">
        <div style="font-weight: 700; margin-bottom: 8px">How it works</div>
        <ul style="margin: 0 0 10px 18px; line-height: 1.5">
          <li>Dynamic programming builds a (m+1)×(n+1) table where m and n are the lengths of the sequences.</li>
          <li>Base row and column are 0 (empty prefix). For each cell (i, j):
            <ul style="margin: 6px 0 0 18px">
              <li>If A[i−1] = B[j−1], L[i][j] = L[i−1][j−1] + 1 (diagonal step).</li>
              <li>Else, L[i][j] = max(L[i−1][j], L[i][j−1]) (take top or left).</li>
            </ul>
          </li>
          <li>Reconstruct the LCS by following arrows from the bottom-right: diagonal steps collect matched characters.</li>
        </ul>
        <div style="margin-top: 10px; color: var(--muted); font-size: 12px">
          Time complexity: O(m·n), Space: O(m·n) for full reconstruction. Space can be reduced to O(min(m, n)) if only the length is needed.
        </div>
      </div>
    </div>
  </div>

  <footer>
    Tip: Keep sequences up to about 40 characters each to see the full grid clearly. Longer inputs still compute the LCS but skip the grid visualization.
  </footer>

  <script>
    // LCS Visualizer
    (function() {
      const gridEl = document.getElementById('grid');
      const seqAEl = document.getElementById('seqA');
      const seqBEl = document.getElementById('seqB');
      const lcsValueEl = document.getElementById('lcsValue');
      const lcsLengthEl = document.getElementById('lcsLength');
      const explainEl = document.getElementById('explainBox');
      const computeBtn = document.getElementById('computeBtn');
      const resetBtn = document.getElementById('resetBtn');
      const stepBtn = document.getElementById('stepBtn');
      const playBtn = document.getElementById('playBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const caseToggle = document.getElementById('caseToggle');
      const spaceToggle = document.getElementById('spaceToggle');
      const pathToggle = document.getElementById('pathToggle');
      const speedRange = document.getElementById('speedRange');
      const examples = document.getElementById('examples');
      const randomBtn = document.getElementById('randomBtn');
      const noticeEl = document.getElementById('notice');

      const MAX_GRID = 40; // Visualization limit

      let A = '';
      let B = '';
      let dp = [];
      let dir = [];
      let cellRefs = []; // DOM references for dp cells: [i][j]
      let runningTimer = null;
      let stepPos = { i: 1, j: 1 };
      let gridVisible = true;

      function preprocess(s) {
        if (!caseToggle.checked) s = s.toLowerCase();
        if (spaceToggle.checked) s = s.replace(/\s+/g, '');
        return s;
      }

      function clearExplain() {
        explainEl.innerHTML = `
          <div class="line">Press Compute to fill the DP table or Step/Play to watch the algorithm.</div>
          <div class="legend">
            <span class="key"><span class="swatch" style="background: var(--accent-2)"></span> match: take diagonal + 1</span>
            <span class="key"><span class="swatch" style="background: #60a5fa"></span> up: take from top</span>
            <span class="key"><span class="swatch" style="background: #fb923c"></span> left: take from left</span>
            <span class="key"><span class="swatch" style="background: var(--path)"></span> LCS path</span>
          </div>
        `;
      }

      function explainCell(i, j, type, info) {
        // type: 'match' | 'up' | 'left' | 'done'
        let html = '';
        if (type === 'match') {
          html = `
          <div class="line">Comparing A[${i-1}] = '${escapeChar(A[i-1])}' and B[${j-1}] = '${escapeChar(B[j-1])}' → match</div>
          <div class="line">L[${i}][${j}] = L[${i-1}][${j-1}] + 1 = ${info.prev} + 1 = ${info.val}</div>`;
        } else if (type === 'up') {
          html = `
          <div class="line">Comparing A[${i-1}] = '${escapeChar(A[i-1])}' and B[${j-1}] = '${escapeChar(B[j-1])}' → no match</div>
          <div class="line">Take max(top, left): max(L[${i-1}][${j}] = ${info.top}, L[${i}][${j-1}] = ${info.left}) = ${info.val}</div>
          <div class="muted">Chose up (top)</div>`;
        } else if (type === 'left') {
          html = `
          <div class="line">Comparing A[${i-1}] = '${escapeChar(A[i-1])}' and B[${j-1}] = '${escapeChar(B[j-1])}' → no match</div>
          <div class="line">Take max(top, left): max(L[${i-1}][${j}] = ${info.top}, L[${i}][${j-1}] = ${info.left}) = ${info.val}</div>
          <div class="muted">Chose left</div>`;
        } else if (type === 'done') {
          html = `
          <div class="line">Done. Reconstructing path by following arrows from bottom-right.</div>
          <div class="muted">Diagonal moves collect characters in the LCS.</div>`;
        }
        explainEl.innerHTML = html + explainEl.innerHTML.replace(/[\s\S]*<div class="legend">/, '<div class="legend">$&'); // Keep legend
      }

      function escapeChar(ch) {
        if (ch === ' ') return '␠';
        if (ch === '\t') return '␉';
        if (ch === '\n') return '␤';
        return ch;
      }

      function initMatrices(m, n) {
        dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
        dir = Array.from({ length: m + 1 }, () => Array(n + 1).fill(null));
        cellRefs = Array.from({ length: m + 1 }, () => Array(n + 1).fill(null));
      }

      function buildGrid() {
        gridEl.innerHTML = '';
        cellRefs.forEach(row => row.fill(null));

        const m = A.length, n = B.length;
        // Visualization on/off based on size
        gridVisible = (m <= MAX_GRID && n <= MAX_GRID);
        noticeEl.textContent = '';
        if (!gridVisible) {
          noticeEl.textContent = `Grid hidden: sequence lengths m=${m}, n=${n}. Enter ≤ ${MAX_GRID} characters each to show visualization.`;
          return;
        }

        gridEl.style.gridTemplateColumns = `repeat(${n + 2}, 34px)`;
        gridEl.style.gridTemplateRows = `repeat(${m + 2}, 34px)`;

        // Top-left corner
        appendCell('↗', 'cell header corner');

        // Top row: col2 is empty marker for j=0
        appendCell('∅', 'cell header');
        for (let j = 1; j <= n; j++) {
          appendCell(escapeChar(B[j - 1]), 'cell header');
        }

        // Rows
        for (let i = 0; i <= m; i++) {
          // Left header: i=0 shows ∅, else A[i-1]
          if (i === 0) appendCell('∅', 'cell header');
          else appendCell(escapeChar(A[i - 1]), 'cell header');

          // DP row j=0..n
          for (let j = 0; j <= n; j++) {
            const c = document.createElement('div');
            c.className = 'cell zero';
            c.textContent = '0';
            gridEl.appendChild(c);
            cellRefs[i][j] = c;

            // Add arrow holder
            const a = document.createElement('div');
            a.className = 'arrow';
            c.appendChild(a);
          }
        }
      }

      function appendCell(text, className) {
        const c = document.createElement('div');
        c.className = className;
        c.textContent = text;
        gridEl.appendChild(c);
      }

      function resetState() {
        stopPlaying();
        const rawA = seqAEl.value;
        const rawB = seqBEl.value;
        A = preprocess(rawA);
        B = preprocess(rawB);

        const m = A.length, n = B.length;
        initMatrices(m, n);
        buildGrid();
        lcsValueEl.textContent = '—';
        lcsLengthEl.textContent = 'Length: —';
        clearExplain();

        // Step pointers
        stepPos = { i: 1, j: 1 };

        // Render base zeros in grid cells if visible
        if (gridVisible) {
          for (let i = 0; i <= m; i++) {
            for (let j = 0; j <= n; j++) {
              updateCellContent(i, j, 0, null);
              removeClasses(cellRefs[i][j], ['current', 'neighbor', 'match', 'path']);
              cellRefs[i][j].classList.add('zero');
            }
          }
        }
      }

      function computeAll() {
        const m = A.length, n = B.length;
        for (let i = 1; i <= m; i++) {
          for (let j = 1; j <= n; j++) {
            if (A[i - 1] === B[j - 1]) {
              dp[i][j] = dp[i - 1][j - 1] + 1;
              dir[i][j] = 'diag';
            } else {
              const up = dp[i - 1][j];
              const left = dp[i][j - 1];
              if (up >= left) {
                dp[i][j] = up;
                dir[i][j] = 'up';
              } else {
                dp[i][j] = left;
                dir[i][j] = 'left';
              }
            }
            if (gridVisible) {
              updateCellContent(i, j, dp[i][j], dir[i][j], A[i - 1] === B[j - 1]);
            }
          }
        }
        const { lcs, path } = reconstructLCS();
        lcsValueEl.textContent = lcs.length ? lcs : '—';
        lcsLengthEl.textContent = `Length: ${dp[m][n]}`;
        if (gridVisible && pathToggle.checked) highlightPath(path);
        explainCell(m, n, 'done');
      }

      function stepOnce() {
        const m = A.length, n = B.length;
        if (stepPos.i > m) {
          // Already finished
          const { lcs, path } = reconstructLCS();
          lcsValueEl.textContent = lcs.length ? lcs : '—';
          lcsLengthEl.textContent = `Length: ${dp[m][n]}`;
          if (gridVisible && pathToggle.checked) highlightPath(path);
          explainCell(m, n, 'done');
          return false;
        }
        const i = stepPos.i, j = stepPos.j;

        // Clear previous highlights
        clearHighlights();

        // Highlight current and neighbors
        if (gridVisible) {
          cellRefs[i][j].classList.add('current');
          if (i - 1 >= 0) cellRefs[i - 1][j].classList.add('neighbor');
          if (j - 1 >= 0) cellRefs[i][j - 1].classList.add('neighbor');
          if (i - 1 >= 0 && j - 1 >= 0) cellRefs[i - 1][j - 1].classList.add('neighbor');
        }

        if (A[i - 1] === B[j - 1]) {
          dp[i][j] = dp[i - 1][j - 1] + 1;
          dir[i][j] = 'diag';
          if (gridVisible) updateCellContent(i, j, dp[i][j], 'diag', true);
          explainCell(i, j, 'match', { prev: dp[i - 1][j - 1], val: dp[i][j] });
        } else {
          const up = dp[i - 1][j];
          const left = dp[i][j - 1];
          if (up >= left) {
            dp[i][j] = up;
            dir[i][j] = 'up';
            if (gridVisible) updateCellContent(i, j, dp[i][j], 'up', false);
            explainCell(i, j, 'up', { top: up, left, val: dp[i][j] });
          } else {
            dp[i][j] = left;
            dir[i][j] = 'left';
            if (gridVisible) updateCellContent(i, j, dp[i][j], 'left', false);
            explainCell(i, j, 'left', { top: up, left, val: dp[i][j] });
          }
        }

        // Advance
        stepPos.j++;
        if (stepPos.j > n) {
          stepPos.i++;
          stepPos.j = 1;
        }

        // If completed after this step, finalize
        if (stepPos.i > m) {
          const { lcs, path } = reconstructLCS();
          lcsValueEl.textContent = lcs.length ? lcs : '—';
          lcsLengthEl.textContent = `Length: ${dp[m][n]}`;
          if (gridVisible && pathToggle.checked) highlightPath(path);
          explainCell(m, n, 'done');
          return false;
        }
        return true;
      }

      function play() {
        stopPlaying();
        playBtn.disabled = true;
        pauseBtn.disabled = false;
        stepBtn.disabled = true;
        const delay = Number(speedRange.value);
        runningTimer = setInterval(() => {
          const cont = stepOnce();
          if (!cont) stopPlaying();
        }, delay);
      }

      function stopPlaying() {
        if (runningTimer) clearInterval(runningTimer);
        runningTimer = null;
        playBtn.disabled = false;
        pauseBtn.disabled = true;
        stepBtn.disabled = false;
      }

      function updateCellContent(i, j, val, arrow, isMatch=false) {
        if (!gridVisible) return;
        const cell = cellRefs[i][j];
        if (!cell) return;
        cell.textContent = val.toString();
        cell.classList.remove('zero');
        const arr = cell.querySelector('.arrow');
        if (arr) {
          arr.textContent = arrow === 'diag' ? '↖' : arrow === 'up' ? '↑' : arrow === 'left' ? '←' : '';
          arr.className = 'arrow ' + (arrow || '');
        }
        removeClasses(cell, ['match']);
        if (isMatch) cell.classList.add('match');
      }

      function removeClasses(el, classes) {
        classes.forEach(cls => el.classList.remove(cls));
      }

      function clearHighlights() {
        if (!gridVisible) return;
        const m = A.length, n = B.length;
        for (let i = 0; i <= m; i++) {
          for (let j = 0; j <= n; j++) {
            const c = cellRefs[i][j];
            removeClasses(c, ['current', 'neighbor']);
          }
        }
      }

      function reconstructLCS() {
        const m = A.length, n = B.length;
        let i = m, j = n;
        const chars = [];
        const path = [];
        while (i > 0 && j > 0) {
          const d = dir[i][j];
          if (d === 'diag') {
            chars.push(A[i - 1]);
            path.push([i, j]);
            i--; j--;
          } else if (d === 'up') {
            i--;
          } else if (d === 'left') {
            j--;
          } else {
            // Shouldn't happen; safeguard
            i--; j--;
          }
        }
        return { lcs: chars.reverse().join(''), path };
      }

      function highlightPath(path) {
        if (!gridVisible) return;
        const m = A.length, n = B.length;
        // Clear previous path highlights
        for (let i = 0; i <= m; i++) for (let j = 0; j <= n; j++) cellRefs[i][j].classList.remove('path');
        // Apply new path
        path.forEach(([i, j]) => cellRefs[i][j].classList.add('path'));
      }

      // Events
      computeBtn.addEventListener('click', () => {
        resetState();
        computeAll();
      });
      resetBtn.addEventListener('click', () => {
        resetState();
      });
      stepBtn.addEventListener('click', () => {
        if (!dp.length) resetState();
        stepOnce();
      });
      playBtn.addEventListener('click', () => {
        if (!dp.length) resetState();
        play();
      });
      pauseBtn.addEventListener('click', () => {
        stopPlaying();
      });
      caseToggle.addEventListener('change', () => resetState());
      spaceToggle.addEventListener('change', () => resetState());
      pathToggle.addEventListener('change', () => {
        if (!dp.length) return;
        const { path } = reconstructLCS();
        if (pathToggle.checked) highlightPath(path);
        else if (gridVisible) {
          const m = A.length, n = B.length;
          for (let i = 0; i <= m; i++) for (let j = 0; j <= n; j++) cellRefs[i][j].classList.remove('path');
        }
      });
      speedRange.addEventListener('input', () => {
        if (runningTimer) {
          stopPlaying();
          play();
        }
      });
      examples.addEventListener('change', () => {
        const v = examples.value;
        if (!v) return;
        const [a, b] = v.split('|');
        seqAEl.value = a;
        seqBEl.value = b;
        resetState();
        computeAll();
      });
      randomBtn.addEventListener('click', () => {
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const lenA = randInt(6, 14);
        const lenB = randInt(6, 14);
        seqAEl.value = randString(alphabet, lenA);
        seqBEl.value = randString(alphabet, lenB);
        resetState();
        computeAll();
      });

      function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
      function randString(alphabet, len) {
        let s = '';
        for (let i = 0; i < len; i++) s += alphabet[randInt(0, alphabet.length - 1)];
        return s;
      }

      // Initialize
      resetState();
      computeAll();
    })();
  </script>
</body>
</html>