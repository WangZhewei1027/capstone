<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>K-Means Clustering Interactive Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #60a5fa;
      --accent2: #34d399;
      --danger: #ef4444;
      --border: #1f2937;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
      background: radial-gradient(circle at 20% 20%, #0b1023, #0f172a 40%, #0b1225 100%);
      color: var(--text);
    }
    header {
      padding: 16px 24px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 18px;
    }
    header h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
    }
    header .sub {
      color: var(--muted);
      font-size: 13px;
    }
    #wrap {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 16px;
      padding: 16px;
    }
    #controls {
      background: linear-gradient(180deg, rgba(17,24,39,0.9), rgba(17,24,39,0.6));
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px 14px 4px 14px;
      backdrop-filter: blur(6px);
      position: sticky;
      top: 16px;
      height: fit-content;
    }
    #controls h2 {
      margin: 0 0 10px 0;
      font-size: 16px;
      font-weight: 600;
    }
    .group {
      margin: 10px 0 14px 0;
      padding-bottom: 10px;
      border-bottom: 1px dashed var(--border);
    }
    .row {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 10px;
      margin: 8px 0;
    }
    label { font-size: 13px; color: var(--muted); }
    select, input[type="number"], input[type="text"] {
      width: 140px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0b1225;
      color: var(--text);
      outline: none;
    }
    input[type="range"] { width: 140px; }
    .buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
    }
    button {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0b1225;
      color: var(--text);
      cursor: pointer;
      transition: background 0.15s, transform 0.06s, border-color 0.15s;
      font-weight: 600;
    }
    button:hover { background: #0e1530; border-color: #25324d; }
    button:active { transform: translateY(1px); }
    .primary { background: #10254d; border-color: #1e40af; }
    .primary:hover { background: #0f2a5e; }
    .danger { background: #2a0f12; border-color: #4c1d1d; }
    .danger:hover { background: #3b1216; }
    .togglebtn.active { background: #0f3a25; border-color: #14532d; color: #a7f3d0; }
    .small {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }
    .checkrow {
      display: grid;
      grid-template-columns: auto 1fr;
      align-items: center;
      gap: 8px;
      margin: 6px 0;
    }
    .pill {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      background: #13203f;
      border: 1px solid #1f3b74;
      color: #9cc0ff;
      font-size: 12px;
      margin-right: 6px;
    }
    #canvasWrap {
      position: relative;
      background: radial-gradient(1200px 600px at 80% 20%, rgba(30,58,138,0.15), transparent 60%),
                  radial-gradient(600px 600px at 20% 80%, rgba(6,78,59,0.15), transparent 70%);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
    }
    canvas {
      width: 100%;
      height: 72vh;
      display: block;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.03) 0, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 30px),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.03) 0, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 30px);
    }
    #stats {
      position: absolute;
      top: 8px;
      left: 8px;
      background: rgba(10,16,31,0.75);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      color: var(--text);
      backdrop-filter: blur(4px);
      pointer-events: none;
    }
    #legend {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(10,16,31,0.75);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 6px 8px;
      font-size: 12px;
      color: var(--text);
      backdrop-filter: blur(4px);
    }
    .legendRow {
      display: grid;
      grid-template-columns: 22px 1fr;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
    }
    .swatch {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid rgba(255,255,255,0.2);
    }
    footer {
      padding: 10px 16px 18px 16px;
      color: var(--muted);
      font-size: 12px;
      text-align: center;
    }
    a { color: #93c5fd; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <header>
    <h1>K-Means Clustering</h1>
    <div class="sub">Interactive visualization of iterative cluster assignment and centroid update</div>
  </header>

  <div id="wrap">
    <div id="controls">
      <h2>Setup</h2>
      <div class="group">
        <div class="row">
          <label>Points</label>
          <input id="pointsCount" type="number" min="10" max="2000" step="10" value="400">
        </div>
        <div class="row">
          <label>Distribution</label>
          <select id="distSelect">
            <option value="blobs">Gaussian blobs</option>
            <option value="uniform">Uniform random</option>
          </select>
        </div>
        <div class="row">
          <label>K (clusters)</label>
          <input id="kInput" type="number" min="1" max="10" step="1" value="3">
        </div>
        <div class="row">
          <label>Init method</label>
          <select id="initSelect">
            <option value="forgy">Forgy (random points)</option>
            <option value="random">Random positions</option>
            <option value="kpp">K-Means++</option>
          </select>
        </div>
        <div class="row">
          <label>Seed (optional)</label>
          <input id="seedInput" type="text" placeholder="e.g. 42">
        </div>
        <div class="buttons">
          <button id="genBtn">Generate Data</button>
          <button id="initBtn" class="primary">Initialize K-Means</button>
          <button id="iterBtn" class="primary">Run 1 Iteration</button>
          <button id="autoBtn" class="togglebtn">Auto-Run</button>
          <button id="resetBtn" class="danger">Reset</button>
          <button id="clearBtn" class="danger">Clear Points</button>
        </div>
        <div class="small">Tip: Enable "Click to add points" and click the canvas to add custom points.</div>
      </div>

      <h2>Display</h2>
      <div class="group">
        <div class="checkrow">
          <input id="linesChk" type="checkbox" checked>
          <label>Show lines from points to centroids</label>
        </div>
        <div class="checkrow">
          <input id="trailChk" type="checkbox" checked>
          <label>Show centroid trails</label>
        </div>
        <div class="checkrow">
          <input id="addPtsChk" type="checkbox">
          <label>Click to add points</label>
        </div>
        <div class="row">
          <label>Auto-run speed (ms)</label>
          <input id="speedRange" type="range" min="50" max="1000" value="200">
        </div>
      </div>

      <h2>About</h2>
      <div class="group">
        <div class="pill">Assign</div>
        <span class="small">Assign each point to the nearest centroid.</span><br>
        <div class="pill">Update</div>
        <span class="small">Move each centroid to the mean of its assigned points.</span><br>
        <div class="small">Repeat until convergence (centroids stop moving or assignments stop changing).</div>
      </div>
    </div>

    <div id="canvasWrap">
      <canvas id="canvas"></canvas>
      <div id="stats">Iteration: <span id="iterOut">0</span><br>
        SSE (intra-cluster): <span id="sseOut">â€”</span><br>
        Converged: <span id="convOut">No</span>
      </div>
      <div id="legend"></div>
    </div>
  </div>

  <footer>
    Drag a centroid to reposition it. K-Means++ provides smarter initialization for faster convergence.
  </footer>

  <script>
    // ========= Utility: PRNG and math helpers =========
    function makePRNG(seedStr) {
      if (!seedStr) return Math.random;
      let seed = 0;
      for (let i = 0; i < seedStr.length; i++) seed = (seed * 31 + seedStr.charCodeAt(i)) >>> 0;
      let m = 0x80000000, a = 1103515245, c = 12345;
      return function () { seed = (a * seed + c) % m; return seed / m; };
    }
    function randBoxMuller(rnd) {
      let u = 0, v = 0;
      while (u === 0) u = rnd(); // avoid 0
      while (v === 0) v = rnd();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }
    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
    function dist2(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return dx * dx + dy * dy; }

    // ========= Colors =========
    const palette = [
      "#e74c3c", "#3498db", "#2ecc71", "#f1c40f", "#9b59b6",
      "#e67e22", "#1abc9c", "#34495e", "#fd79a8", "#00cec9"
    ];
    function colorFor(i) { return palette[i % palette.length]; }

    // ========= Canvas setup (HiDPI) =========
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      const ratio = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.round(rect.width * ratio);
      canvas.height = Math.round(rect.height * ratio);
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      draw();
    }
    window.addEventListener('resize', resizeCanvas);

    // ========= State =========
    const state = {
      points: [],
      centroids: [],
      centroidHistory: [], // arrays of positions per cluster
      k: 3,
      iteration: 0,
      sse: null,
      converged: false,
      running: false,
      draggingCentroid: null,
      showLines: true,
      showTrails: true,
      addPointsMode: false,
      rnd: Math.random
    };

    // ========= UI refs =========
    const pointsCount = document.getElementById('pointsCount');
    const distSelect = document.getElementById('distSelect');
    const kInput = document.getElementById('kInput');
    const initSelect = document.getElementById('initSelect');
    const seedInput = document.getElementById('seedInput');
    const genBtn = document.getElementById('genBtn');
    const initBtn = document.getElementById('initBtn');
    const iterBtn = document.getElementById('iterBtn');
    const autoBtn = document.getElementById('autoBtn');
    const resetBtn = document.getElementById('resetBtn');
    const clearBtn = document.getElementById('clearBtn');

    const linesChk = document.getElementById('linesChk');
    const trailChk = document.getElementById('trailChk');
    const addPtsChk = document.getElementById('addPtsChk');
    const speedRange = document.getElementById('speedRange');

    const iterOut = document.getElementById('iterOut');
    const sseOut = document.getElementById('sseOut');
    const convOut = document.getElementById('convOut');
    const legend = document.getElementById('legend');

    // ========= Data generation =========
    function genUniform(n) {
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;
      const margin = 20;
      const points = [];
      for (let i = 0; i < n; i++) {
        points.push({ x: margin + state.rnd() * (w - 2 * margin), y: margin + state.rnd() * (h - 2 * margin), c: -1 });
      }
      return points;
    }
    function genBlobs(n, blobCount = 4) {
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;
      const margin = 40;
      const centers = [];
      for (let b = 0; b < blobCount; b++) {
        centers.push({
          x: margin + state.rnd() * (w - 2 * margin),
          y: margin + state.rnd() * (h - 2 * margin),
          r: 20 + state.rnd() * 60
        });
      }
      const points = [];
      for (let i = 0; i < n; i++) {
        const c = centers[Math.floor(state.rnd() * centers.length)];
        const gx = randBoxMuller(state.rnd), gy = randBoxMuller(state.rnd);
        const x = clamp(c.x + gx * c.r, margin, w - margin);
        const y = clamp(c.y + gy * c.r, margin, h - margin);
        points.push({ x, y, c: -1 });
      }
      return points;
    }

    // ========= Initialization methods =========
    function initCentroids(method) {
      const k = state.k;
      state.centroidHistory = [];
      if (state.points.length === 0 || k < 1) return;
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;

      if (method === 'random') {
        state.centroids = [];
        for (let i = 0; i < k; i++) {
          const cx = 20 + state.rnd() * (w - 40);
          const cy = 20 + state.rnd() * (h - 40);
          state.centroids.push({ x: cx, y: cy, color: colorFor(i) });
          state.centroidHistory.push([{ x: cx, y: cy }]);
        }
      } else if (method === 'forgy') {
        state.centroids = [];
        const used = new Set();
        for (let i = 0; i < k; i++) {
          let idx;
          do { idx = Math.floor(state.rnd() * state.points.length); } while (used.has(idx));
          used.add(idx);
          const p = state.points[idx];
          state.centroids.push({ x: p.x, y: p.y, color: colorFor(i) });
          state.centroidHistory.push([{ x: p.x, y: p.y }]);
        }
      } else if (method === 'kpp') {
        // K-Means++ initialization
        state.centroids = [];
        let idx0 = Math.floor(state.rnd() * state.points.length);
        let p0 = state.points[idx0];
        state.centroids.push({ x: p0.x, y: p0.y, color: colorFor(0) });
        state.centroidHistory.push([{ x: p0.x, y: p0.y }]);

        while (state.centroids.length < k) {
          // compute D(x)^2 for each point (distance to nearest chosen centroid)
          let distances = [];
          let sum = 0;
          for (let i = 0; i < state.points.length; i++) {
            const p = state.points[i];
            let dmin = Infinity;
            for (let c = 0; c < state.centroids.length; c++) {
              const cc = state.centroids[c];
              const d = dist2(p.x, p.y, cc.x, cc.y);
              if (d < dmin) dmin = d;
            }
            distances[i] = dmin;
            sum += dmin;
          }
          if (sum === 0) {
            // All points identical; fallback to random
            const rx = 20 + state.rnd() * (w - 40);
            const ry = 20 + state.rnd() * (h - 40);
            const ci = state.centroids.length;
            state.centroids.push({ x: rx, y: ry, color: colorFor(ci) });
            state.centroidHistory.push([{ x: rx, y: ry }]);
            continue;
          }
          // choose next center proportional to D(x)^2
          let r = state.rnd() * sum;
          let cum = 0, chosen = 0;
          for (let i = 0; i < distances.length; i++) {
            cum += distances[i];
            if (cum >= r) { chosen = i; break; }
          }
          const pp = state.points[chosen];
          const ci = state.centroids.length;
          state.centroids.push({ x: pp.x, y: pp.y, color: colorFor(ci) });
          state.centroidHistory.push([{ x: pp.x, y: pp.y }]);
        }
      }
      // reset
      state.iteration = 0;
      state.converged = false;
      for (const p of state.points) p.c = -1;
      updateLegend();
      draw();
    }

    // ========= Algorithm steps =========
    function assignPoints() {
      if (state.centroids.length === 0) return { changed: false, sse: null };
      let changed = false;
      let sse = 0;
      for (let i = 0; i < state.points.length; i++) {
        const p = state.points[i];
        let best = -1, bestD = Infinity;
        for (let c = 0; c < state.centroids.length; c++) {
          const cc = state.centroids[c];
          const d = dist2(p.x, p.y, cc.x, cc.y);
          if (d < bestD) { bestD = d; best = c; }
        }
        if (p.c !== best) { changed = true; p.c = best; }
        sse += bestD;
      }
      state.sse = sse;
      return { changed, sse };
    }

    function updateCentroids() {
      const k = state.centroids.length;
      if (k === 0) return { moved: false, emptyClusters: [] };

      const sumX = new Array(k).fill(0);
      const sumY = new Array(k).fill(0);
      const count = new Array(k).fill(0);

      for (const p of state.points) {
        if (p.c >= 0) {
          sumX[p.c] += p.x;
          sumY[p.c] += p.y;
          count[p.c] += 1;
        }
      }

      const epsilon = 0.01; // movement threshold
      let moved = false;
      const emptyClusters = [];

      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;

      for (let c = 0; c < k; c++) {
        let oldX = state.centroids[c].x;
        let oldY = state.centroids[c].y;

        if (count[c] > 0) {
          const nx = sumX[c] / count[c];
          const ny = sumY[c] / count[c];
          const dx = nx - oldX, dy = ny - oldY;
          if (dx * dx + dy * dy > epsilon * epsilon) moved = true;
          state.centroids[c].x = nx;
          state.centroids[c].y = ny;
        } else {
          // Handle empty cluster: re-seed randomly to encourage recovery
          emptyClusters.push(c);
          const rx = 20 + state.rnd() * (w - 40);
          const ry = 20 + state.rnd() * (h - 40);
          state.centroids[c].x = rx;
          state.centroids[c].y = ry;
          moved = true;
        }
        // Record history
        if (state.centroidHistory[c]) {
          state.centroidHistory[c].push({ x: state.centroids[c].x, y: state.centroids[c].y });
          if (state.centroidHistory[c].length > 64) state.centroidHistory[c].shift();
        }
      }
      return { moved, emptyClusters };
    }

    function runIteration() {
      if (state.centroids.length === 0 || state.points.length === 0) return;
      const assignResult = assignPoints();
      const updateResult = updateCentroids();
      state.iteration += 1;

      // Convergence check: no assignment change and centroids did not move significantly
      state.converged = !assignResult.changed && !updateResult.moved;

      updateStats();
      draw();
      if (state.running && state.converged) {
        toggleAutoRun(false);
      }
    }

    // ========= Drawing =========
    function drawGrid() {
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;
      ctx.clearRect(0, 0, w, h);
      // Subtle axes lines already added via CSS background
    }

    function drawPoints() {
      ctx.lineWidth = 1.2;
      for (const p of state.points) {
        const cidx = p.c;
        const color = cidx >= 0 ? colorFor(cidx) : "rgba(255,255,255,0.6)";
        ctx.fillStyle = color;
        ctx.strokeStyle = "rgba(0,0,0,0.4)";

        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      if (state.showLines && state.centroids.length > 0) {
        ctx.globalAlpha = 0.3;
        for (const p of state.points) {
          if (p.c >= 0) {
            ctx.strokeStyle = colorFor(p.c);
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(state.centroids[p.c].x, state.centroids[p.c].y);
            ctx.stroke();
          }
        }
        ctx.globalAlpha = 1;
      }
    }

    function drawCentroids() {
      for (let i = 0; i < state.centroids.length; i++) {
        const c = state.centroids[i];
        // Trail
        if (state.showTrails && state.centroidHistory[i] && state.centroidHistory[i].length > 1) {
          const trail = state.centroidHistory[i];
          ctx.lineWidth = 2;
          for (let t = 1; t < trail.length; t++) {
            const alpha = 0.1 + 0.6 * (t / trail.length);
            ctx.strokeStyle = hexWithAlpha(c.color, alpha);
            ctx.beginPath();
            ctx.moveTo(trail[t - 1].x, trail[t - 1].y);
            ctx.lineTo(trail[t].x, trail[t].y);
            ctx.stroke();
          }
        }
        // Centroid marker
        ctx.lineWidth = 2.2;
        ctx.fillStyle = c.color;
        ctx.strokeStyle = "#111827";
        ctx.beginPath();
        ctx.arc(c.x, c.y, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Crosshair
        ctx.strokeStyle = "rgba(255,255,255,0.25)";
        ctx.beginPath();
        ctx.moveTo(c.x - 10, c.y);
        ctx.lineTo(c.x + 10, c.y);
        ctx.moveTo(c.x, c.y - 10);
        ctx.lineTo(c.x, c.y + 10);
        ctx.stroke();
      }
    }

    function hexWithAlpha(hex, alpha) {
      // hex like #rrggbb
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    function draw() {
      drawGrid();
      drawPoints();
      drawCentroids();
    }

    function updateStats() {
      iterOut.textContent = state.iteration;
      sseOut.textContent = (state.sse != null ? Math.round(state.sse).toLocaleString() : "â€”");
      convOut.textContent = state.converged ? "Yes" : "No";
      convOut.style.color = state.converged ? "#34d399" : "#e5e7eb";
    }

    function updateLegend() {
      legend.innerHTML = "";
      for (let i = 0; i < state.k; i++) {
        const div = document.createElement('div');
        div.className = 'legendRow';
        const sw = document.createElement('div');
        sw.className = 'swatch';
        sw.style.background = colorFor(i);
        const label = document.createElement('div');
        label.textContent = `Cluster ${i + 1}`;
        div.appendChild(sw);
        div.appendChild(label);
        legend.appendChild(div);
      }
    }

    // ========= Interactivity: drag centroids and add points =========
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      if (state.addPointsMode) {
        state.points.push({ x: mx, y: my, c: -1 });
        state.converged = false;
        state.sse = null;
        draw();
        return;
      }

      // Try to pick a centroid near the click
      let picked = null;
      for (let i = 0; i < state.centroids.length; i++) {
        const c = state.centroids[i];
        if (Math.hypot(mx - c.x, my - c.y) <= 12) { picked = i; break; }
      }
      if (picked != null) {
        state.draggingCentroid = picked;
      }
    });
    canvas.addEventListener('mousemove', (e) => {
      if (state.draggingCentroid == null) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const c = state.centroids[state.draggingCentroid];
      c.x = mx; c.y = my;
      // record in history to show trail
      state.centroidHistory[state.draggingCentroid].push({ x: mx, y: my });
      if (state.centroidHistory[state.draggingCentroid].length > 64) state.centroidHistory[state.draggingCentroid].shift();
      state.converged = false;
      draw();
    });
    window.addEventListener('mouseup', () => {
      if (state.draggingCentroid != null) {
        state.draggingCentroid = null;
        // recompute assignment after manual move
        assignPoints();
        updateStats();
        draw();
      }
    });

    // ========= Auto-run control =========
    let timer = null;
    function toggleAutoRun(forceState) {
      const shouldRun = forceState != null ? forceState : !state.running;
      state.running = shouldRun;
      autoBtn.classList.toggle('active', state.running);
      autoBtn.textContent = state.running ? "Auto-Runningâ€¦" : "Auto-Run";
      if (state.running) {
        const speed = parseInt(speedRange.value);
        if (timer) clearInterval(timer);
        timer = setInterval(() => runIteration(), speed);
      } else {
        if (timer) {
          clearInterval(timer);
          timer = null;
        }
      }
    }

    // ========= Event bindings =========
    genBtn.addEventListener('click', () => {
      state.rnd = makePRNG(seedInput.value.trim());
      const n = parseInt(pointsCount.value);
      state.points = distSelect.value === 'uniform' ? genUniform(n) : genBlobs(n);
      state.iteration = 0; state.sse = null; state.converged = false;
      draw();
    });

    initBtn.addEventListener('click', () => {
      state.k = clamp(parseInt(kInput.value), 1, palette.length);
      initCentroids(initSelect.value);
      // First assignment for visualization clarity
      assignPoints();
      updateStats();
      draw();
    });

    iterBtn.addEventListener('click', () => runIteration());
    autoBtn.addEventListener('click', () => toggleAutoRun());

    resetBtn.addEventListener('click', () => {
      toggleAutoRun(false);
      state.points = [];
      state.centroids = [];
      state.centroidHistory = [];
      state.iteration = 0;
      state.sse = null;
      state.converged = false;
      updateStats();
      draw();
    });

    clearBtn.addEventListener('click', () => {
      for (const p of state.points) p.c = -1;
      state.sse = null;
      state.converged = false;
      state.iteration = 0;
      draw();
    });

    linesChk.addEventListener('change', () => { state.showLines = linesChk.checked; draw(); });
    trailChk.addEventListener('change', () => { state.showTrails = trailChk.checked; draw(); });
    addPtsChk.addEventListener('change', () => { state.addPointsMode = addPtsChk.checked; });

    kInput.addEventListener('change', () => {
      state.k = clamp(parseInt(kInput.value), 1, palette.length);
      updateLegend();
      draw();
    });
    speedRange.addEventListener('input', () => {
      if (state.running) toggleAutoRun(true);
    });

    // ========= Initial boot =========
    function boot() {
      resizeCanvas();
      state.rnd = makePRNG(seedInput.value.trim());
      state.points = genBlobs(parseInt(pointsCount.value));
      state.k = clamp(parseInt(kInput.value), 1, palette.length);
      updateLegend();
      initCentroids(initSelect.value);
      assignPoints();
      updateStats();
      draw();
    }
    boot();
  </script>
</body>
</html>