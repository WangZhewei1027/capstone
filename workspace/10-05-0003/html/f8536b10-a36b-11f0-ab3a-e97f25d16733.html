<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Counting Sort Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --accent: #22c55e;
      --accent2: #60a5fa;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --warn: #f59e0b;
      --error: #ef4444;
      --tile: #1f2937;
      --border: #334155;
      --highlight: #2dd4bf;
      --placed: #22c55e;
      --updated: #f97316;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(1000px 500px at 80% -80%, #0b1226 0%, #0a1224 60%, var(--bg) 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    }
    header {
      padding: 20px 24px 8px;
    }
    h1 {
      margin: 0;
      font-weight: 700;
      letter-spacing: 0.5px;
      font-size: 24px;
    }
    .sub {
      color: var(--muted);
      font-size: 13px;
      margin-top: 6px;
    }
    .container {
      padding: 12px 24px 24px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 12px;
      backdrop-filter: blur(8px);
    }
    .controls {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 12px;
    }
    .field-group {
      display: grid;
      grid-template-columns: 1fr 180px 160px 160px;
      gap: 8px;
      align-items: center;
    }
    .field-group .small {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
    }
    label {
      font-size: 12px;
      color: var(--muted);
    }
    input[type="text"],
    input[type="number"],
    input[type="range"] {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      outline: none;
      background: var(--tile);
      color: var(--text);
    }
    input[type="range"] {
      padding: 0;
      height: 2px;
    }
    .btn-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
    }
    button {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #0b1224;
      color: var(--text);
      cursor: pointer;
      transition: transform 0.1s ease, background 0.2s ease, border 0.2s ease;
      font-weight: 600;
      font-size: 13px;
    }
    button:hover { transform: translateY(-1px); }
    button.primary {
      background: linear-gradient(180deg, rgba(34,197,94,0.25), rgba(34,197,94,0.15));
      border-color: rgba(34,197,94,0.3);
    }
    button.secondary {
      background: linear-gradient(180deg, rgba(96,165,250,0.25), rgba(96,165,250,0.15));
      border-color: rgba(96,165,250,0.3);
    }
    button.warn {
      background: linear-gradient(180deg, rgba(245,158,11,0.25), rgba(245,158,11,0.15));
      border-color: rgba(245,158,11,0.3);
    }
    button.danger {
      background: linear-gradient(180deg, rgba(239,68,68,0.25), rgba(239,68,68,0.15));
      border-color: rgba(239,68,68,0.3);
    }
    .status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--muted);
    }
    .status strong { color: var(--text); }
    .viz {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .row {
      display: grid;
      gap: 8px;
    }
    .row-title {
      font-size: 13px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .array {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: flex-end;
    }
    .cell {
      min-width: 36px;
      height: 36px;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--tile);
      color: var(--text);
      display: grid;
      place-items: center;
      position: relative;
      user-select: none;
    }
    .cell .idx {
      position: absolute;
      top: -12px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: var(--muted);
      opacity: 0.8;
    }
    .cell .bucket {
      position: absolute;
      bottom: -12px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: var(--muted);
      opacity: 0.85;
    }
    .cell.active {
      outline: 2px solid var(--highlight);
      filter: drop-shadow(0 0 8px rgba(45,212,191,0.25));
    }
    .cell.updated {
      outline: 2px dashed var(--updated);
    }
    .cell.placed {
      outline: 2px solid var(--placed);
      filter: drop-shadow(0 0 8px rgba(34,197,94,0.25));
    }
    .legend {
      display: flex;
      gap: 16px;
      font-size: 12px;
      color: var(--muted);
      flex-wrap: wrap;
    }
    .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 6px; vertical-align: middle;}
    .dot.h { background: var(--highlight); }
    .dot.u { background: var(--updated); }
    .dot.p { background: var(--placed); }
    .note {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }
    .footer {
      font-size: 12px;
      color: var(--muted);
      padding: 0 24px 24px;
    }
    .flex {
      display: flex; gap: 12px; align-items: center; flex-wrap: wrap;
    }
    .pill {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 999px;
      padding: 6px 10px;
    }
    @media (min-width: 960px) {
      .container {
        grid-template-columns: 1.3fr 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Counting Sort Visualizer</h1>
    <div class="sub">Step-by-step visualization of counting sort with stable placement</div>
  </header>

  <div class="container">
    <div class="panel">
      <div class="controls">
        <div class="field-group">
          <div>
            <label>Input array (comma-separated integers)</label>
            <input id="inputField" type="text" value="4,2,2,8,3,3,1">
          </div>
          <div class="small">
            <div>
              <label>Length</label>
              <input id="lenField" type="number" min="1" max="60" value="12">
            </div>
            <div>
              <label>Min value</label>
              <input id="minField" type="number" value="0">
            </div>
            <div>
              <label>Max value</label>
              <input id="maxField" type="number" value="9">
            </div>
          </div>
          <div>
            <label>Animation speed</label>
            <input id="speedField" type="range" min="0" max="100" value="55">
          </div>
          <div class="btn-row">
            <button id="exampleBtn" class="secondary">Load example</button>
            <button id="randomBtn" class="secondary">Random</button>
            <button id="runBtn" class="primary">Run</button>
            <button id="pauseBtn">Pause</button>
            <button id="stepBtn" class="warn">Step</button>
            <button id="resetBtn" class="danger">Reset</button>
          </div>
        </div>
      </div>
      <div class="status" id="status">
        <strong>Status:</strong>
        <span id="statusText">Idle</span>
      </div>
      <div class="legend">
        <div><span class="dot h"></span>Active</div>
        <div><span class="dot u"></span>Updated</div>
        <div><span class="dot p"></span>Placed</div>
        <div class="pill">Stable sort: duplicates keep original order (we iterate from right to left when placing)</div>
      </div>
      <div class="note">Counting sort runs in O(n + k) time, where n is the number of elements and k is the range of distinct key values.</div>
    </div>

    <div class="panel">
      <div class="viz">
        <div class="row">
          <div class="row-title">Input array</div>
          <div class="array" id="inputArray"></div>
        </div>
        <div class="row">
          <div class="row-title">
            Count array (buckets) and prefix sums
          </div>
          <div class="array" id="countArray"></div>
        </div>
        <div class="row">
          <div class="row-title">Output array (sorted)</div>
          <div class="array" id="outputArray"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="footer">
    - Counting sort is not comparison-based. It assumes keys are integers in a relatively small range. It can handle negatives by offsetting buckets. It is stable when placement scans input from right to left.
  </div>

  <script>
    const inputArrayEl = document.getElementById('inputArray');
    const countArrayEl = document.getElementById('countArray');
    const outputArrayEl = document.getElementById('outputArray');
    const statusEl = document.getElementById('statusText');

    const inputField = document.getElementById('inputField');
    const lenField = document.getElementById('lenField');
    const minField = document.getElementById('minField');
    const maxField = document.getElementById('maxField');
    const speedField = document.getElementById('speedField');

    const exampleBtn = document.getElementById('exampleBtn');
    const randomBtn = document.getElementById('randomBtn');
    const runBtn = document.getElementById('runBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stepBtn = document.getElementById('stepBtn');
    const resetBtn = document.getElementById('resetBtn');

    const MAX_RANGE_VIS = 100; // Maximum bucket count for visualization

    function setStatus(msg) {
      statusEl.textContent = msg;
    }

    function clearEl(el) {
      while (el.firstChild) el.removeChild(el.firstChild);
    }

    function parseInput() {
      const text = inputField.value.trim();
      if (!text) return [];
      const parts = text.split(/[,\s]+/).filter(Boolean);
      const arr = [];
      for (const p of parts) {
        const v = Number(p);
        if (!Number.isInteger(v)) throw new Error('All values must be integers.');
        arr.push(v);
      }
      return arr;
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function generateRandom(len, minV, maxV) {
      const arr = Array.from({ length: len }, () => randomInt(minV, maxV));
      inputField.value = arr.join(',');
      return arr;
    }

    function colorForValue(v, minV, maxV) {
      // Hash to hue across range
      const range = Math.max(1, maxV - minV);
      const t = (v - minV) / range;
      const hue = Math.round(200 + 120 * t); // blue->green hues
      return `hsl(${hue}, 70%, 45%)`;
    }

    function renderInputArray(arr, minV, maxV) {
      clearEl(inputArrayEl);
      arr.forEach((v, i) => {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.value = String(v);
        cell.dataset.idx = String(i);
        cell.style.borderColor = 'rgba(255,255,255,0.12)';
        cell.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01))';
        const value = document.createElement('div');
        value.textContent = v;
        value.style.color = colorForValue(v, minV, maxV);
        const idxLabel = document.createElement('div');
        idxLabel.className = 'idx';
        idxLabel.textContent = `#${i}`;
        cell.appendChild(value);
        cell.appendChild(idxLabel);
        inputArrayEl.appendChild(cell);
      });
    }

    function renderCountArray(counts, minV) {
      clearEl(countArrayEl);
      counts.forEach((c, i) => {
        const bVal = minV + i;
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.bucketIdx = String(i);
        const val = document.createElement('div');
        val.textContent = c;
        val.style.color = colorForValue(bVal, minV, minV + counts.length - 1);
        const bucketLabel = document.createElement('div');
        bucketLabel.className = 'bucket';
        bucketLabel.textContent = bVal;
        cell.appendChild(val);
        cell.appendChild(bucketLabel);
        countArrayEl.appendChild(cell);
      });
    }

    function renderOutputArray(len) {
      clearEl(outputArrayEl);
      for (let i = 0; i < len; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.outIdx = String(i);
        const val = document.createElement('div');
        val.textContent = '';
        cell.appendChild(val);
        const idxLabel = document.createElement('div');
        idxLabel.className = 'idx';
        idxLabel.textContent = `@${i}`;
        cell.appendChild(idxLabel);
        outputArrayEl.appendChild(cell);
      }
    }

    function updateCountCell(counts, idx, minV) {
      const cell = countArrayEl.querySelector(`.cell[data-bucket-idx="${idx}"]`);
      if (!cell) return;
      cell.classList.add('updated');
      cell.firstChild.textContent = counts[idx];
      setTimeout(() => cell.classList.remove('updated'), 350);
    }

    function highlightInput(i) {
      inputArrayEl.querySelectorAll('.cell').forEach(el => el.classList.remove('active'));
      const cell = inputArrayEl.querySelector(`.cell[data-idx="${i}"]`);
      if (cell) cell.classList.add('active');
    }

    function highlightCountBucket(idx) {
      countArrayEl.querySelectorAll('.cell').forEach(el => el.classList.remove('active'));
      const cell = countArrayEl.querySelector(`.cell[data-bucket-idx="${idx}"]`);
      if (cell) cell.classList.add('active');
    }

    function highlightPrefix(i, j) {
      countArrayEl.querySelectorAll('.cell').forEach(el => el.classList.remove('active'));
      const a = countArrayEl.querySelector(`.cell[data-bucket-idx="${i}"]`);
      const b = countArrayEl.querySelector(`.cell[data-bucket-idx="${j}"]`);
      if (a) a.classList.add('active');
      if (b) b.classList.add('active');
    }

    function placeOutput(position, value, minV, maxV, originIndex) {
      const cell = outputArrayEl.querySelector(`.cell[data-out-idx="${position}"]`);
      if (!cell) return;
      cell.classList.add('placed');
      const valNode = cell.firstChild;
      valNode.textContent = value;
      valNode.style.color = colorForValue(value, minV, maxV);
      const idxLabel = cell.querySelector('.idx');
      idxLabel.textContent = `from #${originIndex}`;
      setTimeout(() => cell.classList.remove('placed'), 350);
    }

    function clearHighlights() {
      document.querySelectorAll('.cell').forEach(el => el.classList.remove('active', 'updated', 'placed'));
    }

    let controller = null;

    function makeController() {
      let paused = false;
      let pendingStepResolve = null;
      return {
        isPaused: () => paused,
        setPaused: (p) => {
          paused = p;
          if (!paused && pendingStepResolve) {
            pendingStepResolve();
            pendingStepResolve = null;
          }
        },
        stepOnce: () => {
          if (pendingStepResolve) {
            pendingStepResolve();
            pendingStepResolve = null;
          }
        },
        wait: () => {
          const speed = Number(speedField.value);
          const delay = Math.round(30 + (100 - speed) * 5); // 30ms..530ms
          if (!paused) {
            return new Promise(res => setTimeout(res, delay));
          } else {
            return new Promise(res => {
              pendingStepResolve = res;
            });
          }
        }
      };
    }

    async function countingSortAnimate(arr) {
      setStatus('Parsing and preparing buckets...');
      const n = arr.length;
      if (n === 0) {
        clearEl(inputArrayEl);
        clearEl(countArrayEl);
        clearEl(outputArrayEl);
        setStatus('Empty input array.');
        return;
      }

      const minV = Math.min(...arr);
      const maxV = Math.max(...arr);
      const range = maxV - minV + 1;

      if (range > MAX_RANGE_VIS) {
        setStatus(`Range too large (${range}). Please keep max-min <= ${MAX_RANGE_VIS} for visualization.`);
        return;
      }

      renderInputArray(arr, minV, maxV);
      renderOutputArray(n);

      // Step 1: Count frequencies
      setStatus('Step 1: Counting occurrences for each key.');
      const counts = Array.from({ length: range }, () => 0);
      renderCountArray(counts, minV);

      for (let i = 0; i < n; i++) {
        highlightInput(i);
        const v = arr[i];
        const idx = v - minV;
        highlightCountBucket(idx);
        counts[idx]++;
        updateCountCell(counts, idx, minV);
        await controller.wait();
      }

      // Step 2: Prefix sums (cumulative counts)
      setStatus('Step 2: Building prefix sums (cumulative counts). counts[i] += counts[i - 1]');
      for (let i = 1; i < counts.length; i++) {
        highlightPrefix(i, i - 1);
        counts[i] = counts[i] + counts[i - 1];
        updateCountCell(counts, i, minV);
        await controller.wait();
      }

      // Step 3: Placement in output (stable)
      setStatus('Step 3: Placing elements into output (stable, scanning input from right to left).');
      clearHighlights();
      for (let i = n - 1; i >= 0; i--) {
        highlightInput(i);
        const v = arr[i];
        const idx = v - minV;
        highlightCountBucket(idx);
        const pos = counts[idx] - 1;
        placeOutput(pos, v, minV, maxV, i);
        counts[idx]--;
        updateCountCell(counts, idx, minV);
        setStatus(`Placing value ${v} at position ${pos}. Remaining in bucket ${v}: ${counts[idx]}.`);
        await controller.wait();
      }

      // Step 4: Done
      clearHighlights();
      setStatus('Done. Output array is sorted.');
    }

    function resetViz() {
      clearEl(inputArrayEl);
      clearEl(countArrayEl);
      clearEl(outputArrayEl);
      setStatus('Idle');
      clearHighlights();
      controller = makeController();
      pauseBtn.textContent = 'Pause';
    }

    // Button handlers
    exampleBtn.addEventListener('click', () => {
      inputField.value = '4,2,2,8,3,3,1';
      setStatus('Loaded example: 4,2,2,8,3,3,1');
    });

    randomBtn.addEventListener('click', () => {
      const len = Math.min(60, Math.max(1, Number(lenField.value) || 12));
      let minV = Number(minField.value);
      let maxV = Number(maxField.value);
      if (!Number.isFinite(minV)) minV = 0;
      if (!Number.isFinite(maxV)) maxV = 9;
      if (minV > maxV) [minV, maxV] = [maxV, minV];
      generateRandom(len, minV, maxV);
      setStatus(`Generated random array of length ${len} in [${minV}, ${maxV}].`);
    });

    runBtn.addEventListener('click', async () => {
      try {
        controller = makeController();
        const arr = parseInput();
        renderInputArray(arr, Math.min(...(arr.length ? arr : [0])), Math.max(...(arr.length ? arr : [0])));
        renderOutputArray(arr.length);
        await countingSortAnimate(arr);
      } catch (e) {
        setStatus('Error: ' + e.message);
      }
    });

    pauseBtn.addEventListener('click', () => {
      if (!controller) return;
      const nowPaused = !controller.isPaused();
      controller.setPaused(nowPaused);
      pauseBtn.textContent = nowPaused ? 'Resume' : 'Pause';
      setStatus(nowPaused ? 'Paused' : 'Running');
    });

    stepBtn.addEventListener('click', () => {
      if (!controller) return;
      controller.setPaused(true);
      pauseBtn.textContent = 'Resume';
      controller.stepOnce();
      setStatus('Stepped one action.');
    });

    resetBtn.addEventListener('click', () => {
      resetViz();
    });

    // Initialize
    resetViz();
    // Auto-render initial input
    (function init() {
      const arr = parseInput();
      const minV = Math.min(...(arr.length ? arr : [0]));
      const maxV = Math.max(...(arr.length ? arr : [0]));
      renderInputArray(arr, minV, maxV);
      renderOutputArray(arr.length);
      renderCountArray(Array.from({ length: Math.max(1, maxV - minV + 1) }, () => 0), minV);
    })();
  </script>
</body>
</html>