<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>JavaScript Set — Interactive Playground</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f1320;
      --panel: #171c2c;
      --panel-2: #1f263d;
      --text: #e9ecf1;
      --muted: #aab2c8;
      --accent: #6cc0ff;
      --accent-2: #b28cff;
      --ok: #6ce27a;
      --warn: #ffd466;
      --bad: #ff7d7d;
      --chip: #283153;
      --chip-hover: #323d67;
      --btn: #2a3356;
      --btn-hover: #334073;
      --input: #1c2340;
      --border: #2b355b;
      --shadow: 0 6px 24px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.03);
      --radius: 12px;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      height: 100%;
      background: radial-gradient(1200px 900px at 10% -10%, #1b2140, transparent),
                  radial-gradient(900px 900px at 110% -20%, #1d1f34, transparent),
                  var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    a { color: var(--accent); text-decoration: none; }
    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 28px 18px 56px;
    }
    header {
      display: grid;
      gap: 8px;
      margin-bottom: 18px;
    }
    h1 {
      margin: 0;
      font-weight: 800;
      font-size: 28px;
      letter-spacing: 0.2px;
      color: #ffffff;
      text-shadow: 0 2px 16px rgba(108,192,255,0.25);
    }
    p.sub {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }
    .facts {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), transparent), var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px 14px;
      color: var(--muted);
      font-size: 14px;
      margin-bottom: 18px;
    }
    .facts ul { padding-left: 18px; margin: 8px 0 0; }
    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: 1fr;
    }
    @media (min-width: 980px) {
      .grid {
        grid-template-columns: 1fr 1fr;
      }
      .grid-3 {
        grid-template-columns: 1fr 1fr 1fr;
      }
    }
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), transparent), var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .panel h2, .panel h3 {
      margin: 0 0 10px 0;
      font-size: 18px;
      font-weight: 700;
      color: #ffffff;
    }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .grow { flex: 1 1 220px; }
    input, textarea, select {
      background: var(--input);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.03);
      outline: none;
      width: 100%;
    }
    textarea { min-height: 72px; resize: vertical; }
    .hint {
      color: var(--muted);
      font-size: 12px;
      margin-top: 6px;
    }
    button {
      background: var(--btn);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
      cursor: pointer;
      transition: 0.15s ease;
    }
    button:hover { background: var(--btn-hover); transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    button.primary {
      background: linear-gradient(180deg, rgba(255,255,255,0.08), transparent), #2a3a74;
      border-color: #3b4c94;
    }
    button.ok { background: #224a36; border-color: #2b6b4b; }
    button.warn { background: #5a4b24; border-color: #80692f; }
    button.bad { background: #5a2b2b; border-color: #7a3a3a; }
    .badge {
      display: inline-flex; align-items: center; justify-content: center;
      min-width: 26px; height: 22px; padding: 0 8px;
      background: #23315a; border: 1px solid var(--border);
      border-radius: 999px; color: #d9e2ff; font-size: 12px;
    }
    .stack { display: grid; gap: 10px; }
    .chips {
      display: flex; flex-wrap: wrap; gap: 8px;
      padding: 10px; border-radius: 10px;
      background: var(--panel-2);
      border: 1px dashed var(--border);
      min-height: 52px;
    }
    .chip {
      display: inline-flex; align-items: center; gap: 8px;
      background: var(--chip); border: 1px solid var(--border);
      color: #e9eeff; padding: 8px 10px; border-radius: 999px;
      font-size: 13px; user-select: none;
      transition: 0.12s ease;
    }
    .chip:hover { background: var(--chip-hover); }
    .chip small {
      color: var(--muted); font-size: 11px; margin-left: 2px;
    }
    .chip button {
      border-radius: 999px; padding: 4px 7px; font-size: 12px;
      background: #3a446e; border-color: #4a578f;
    }
    .flex {
      display: flex; align-items: center; gap: 12px; flex-wrap: wrap;
    }
    .section-title {
      font-size: 20px; font-weight: 800; margin: 22px 0 10px;
      color: #ffffff;
    }
    .results {
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      color: #dfe6ff;
      min-height: 46px;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .legend {
      color: var(--muted); font-size: 12px;
    }
    .log {
      background: #13182c; border: 1px solid var(--border); border-radius: 10px;
      padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px; color: #dfe6ff; height: 200px; overflow: auto;
    }
    .row-slim { display: flex; gap: 8px; align-items: center; }
    .pill {
      display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px;
      background: #222a4a; border: 1px solid var(--border); border-radius: 999px;
      color: var(--muted); font-size: 12px;
    }
    .sep { height: 1px; background: var(--border); margin: 8px 0; }
    footer { margin-top: 24px; color: var(--muted); font-size: 12px; text-align: center; }
    code.kbd {
      background: #252f57; border: 1px solid var(--border);
      border-radius: 6px; padding: 1px 6px; font-size: 12px; color: #e6ecff;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>JavaScript Set — Interactive Playground</h1>
      <p class="sub">Explore Set basics, uniqueness rules, iteration, and common set operations with live examples.</p>
    </header>

    <div class="facts">
      Quick facts:
      <ul>
        <li>Set stores unique values of any type, preserving insertion order.</li>
        <li>Equality uses SameValueZero: NaN equals NaN, -0 is treated as 0, objects compare by reference.</li>
        <li>Common operations: add, has, delete, size, iterate; set algebra via simple helpers (union, intersection, difference).</li>
      </ul>
    </div>

    <div class="grid">
      <div class="panel" id="panelA">
        <h2>Set A <span class="badge" id="sizeA">0</span></h2>
        <div class="stack">
          <div class="row">
            <input class="grow" id="inputA" placeholder='Enter a value: 42, "hi", true, null, [1,2], {"a":1}, NaN, Infinity, 123n, Symbol(tag), date(2020-01-01)' />
            <button class="primary" id="addA">Add</button>
            <button id="hasA">Has?</button>
            <button class="warn" id="delA">Delete</button>
            <button class="bad" id="clearA">Clear</button>
          </div>
          <div class="hint">Tip: Strings need quotes, objects/arrays use JSON. Supports special values: NaN, Infinity, -Infinity, -0, BigInt with n suffix, Symbol(desc), date(ISO).</div>
          <div class="row">
            <textarea class="grow" id="bulkA" placeholder="Bulk add (comma or newline separated). Example: 1,2,2,3,true,&quot;x&quot;,[1,2],NaN"></textarea>
            <button id="bulkAddA">Bulk Add</button>
          </div>
          <div class="legend">Values (click × on a chip to delete that specific value)</div>
          <div class="chips" id="chipsA"></div>
        </div>
      </div>

      <div class="panel" id="panelB">
        <h2>Set B <span class="badge" id="sizeB">0</span></h2>
        <div class="stack">
          <div class="row">
            <input class="grow" id="inputB" placeholder='Enter a value: 42, "hi", true, null, [1,2], {"a":1}, NaN, Infinity, 123n, Symbol(tag), date(2020-01-01)' />
            <button class="primary" id="addB">Add</button>
            <button id="hasB">Has?</button>
            <button class="warn" id="delB">Delete</button>
            <button class="bad" id="clearB">Clear</button>
          </div>
          <div class="hint">Objects compare by reference: two literals {x:1} are different values unless they are the same object.</div>
          <div class="row">
            <textarea class="grow" id="bulkB" placeholder="Bulk add (comma or newline separated). Example: 1,2,3,&quot;a&quot;,&quot;a&quot;,NaN"></textarea>
            <button id="bulkAddB">Bulk Add</button>
          </div>
          <div class="legend">Values</div>
          <div class="chips" id="chipsB"></div>
        </div>
      </div>
    </div>

    <div class="panel" id="ops">
      <h3>Set operations on A and B</h3>
      <div class="row">
        <button id="btnUnion">Union A ∪ B</button>
        <button id="btnInter">Intersection A ∩ B</button>
        <button id="btnDiffAB">Difference A \\ B</button>
        <button id="btnDiffBA">Difference B \\ A</button>
        <button id="btnSymDiff">Symmetric difference A △ B</button>
        <span class="pill">Result size <span class="badge" id="sizeResult">0</span></span>
      </div>
      <div class="results" id="resultArea"></div>
    </div>

    <div class="grid">
      <div class="panel">
        <h3>Deduplicate an array with Set</h3>
        <div class="stack">
          <textarea id="dedupInput" placeholder='Enter an array (JSON) or CSV/newline list. Examples:
[1,1,2,3,"a","a",true,false,true,NaN,NaN]
1,1,2,2,3,3,NaN,NaN,"x","x"'></textarea>
          <div class="row">
            <button class="primary" id="runDedup">Deduplicate</button>
            <button id="copyDedup">Copy result</button>
            <span id="dedupInfo" class="pill">Before: 0 After: 0</span>
          </div>
          <div class="results" id="dedupOut"></div>
        </div>
      </div>

      <div class="panel">
        <h3>Iteration and SameValueZero quirks</h3>
        <div class="stack">
          <div class="row">
            <button id="iterForOf">Iterate A with for...of</button>
            <button id="iterEntries">A.entries()</button>
            <button id="iterForEach">A.forEach()</button>
          </div>
          <div class="row">
            <button id="testSpecial">Test NaN and -0 behavior</button>
            <button id="addObjRefs">Add object refs</button>
          </div>
          <div class="log" id="logArea"></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>Bonus: WeakSet in a nutshell</h3>
      <div class="stack">
        <div class="row-slim">
          <button id="wsDemo">Run WeakSet demo</button>
          <span class="hint">WeakSet holds only objects, not primitives. It is not iterable.</span>
        </div>
        <div class="results" id="wsOut"></div>
      </div>
    </div>

    <footer>
      JavaScript Set Playground. No external libraries. All processing happens locally in this page.
    </footer>
  </div>

  <script>
    // Identity tracking for pretty printing
    const objIds = new WeakMap();
    let nextId = 1;
    function getId(obj) {
      if (obj === null || typeof obj !== 'object') return '';
      if (!objIds.has(obj)) objIds.set(obj, nextId++);
      return objIds.get(obj);
    }

    function isNegZero(n) {
      return typeof n === 'number' && n === 0 && (1 / n) === -Infinity;
    }

    function parseValue(raw) {
      const s = String(raw).trim();
      if (!s.length) return { ok: false, value: undefined, reason: 'empty' };

      // Quoted string (JSON style)
      if ((s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))) {
        try {
          // Normalize single quotes to double for JSON parse
          const normalized = s.startsWith("'") ? '"' + s.slice(1, -1).replace(/"/g, '\\"') + '"' : s;
          return { ok: true, value: JSON.parse(normalized) };
        } catch (e) {
          // fallback to raw without quotes
          return { ok: true, value: s.slice(1, -1) };
        }
      }

      const lower = s.toLowerCase();

      // Special keywords
      if (lower === 'undefined') return { ok: true, value: undefined };
      if (lower === 'null') return { ok: true, value: null };
      if (lower === 'true') return { ok: true, value: true };
      if (lower === 'false') return { ok: true, value: false };
      if (s === 'NaN') return { ok: true, value: NaN };
      if (s === 'Infinity' || s === '+Infinity') return { ok: true, value: Infinity };
      if (s === '-Infinity') return { ok: true, value: -Infinity };
      if (s === '-0') return { ok: true, value: -0 };

      // BigInt
      if (/^[+-]?\d+n$/.test(s)) {
        try {
          return { ok: true, value: BigInt(s.slice(0, -1)) };
        } catch (e) {
          return { ok: false, reason: 'bad bigint' };
        }
      }

      // Symbol(description)
      const symMatch = s.match(/^symbol\((.*)\)$/i);
      if (symMatch) {
        const desc = symMatch[1] === '' ? undefined : symMatch[1];
        return { ok: true, value: Symbol(desc) };
      }

      // date( ... )
      const dateMatch = s.match(/^date\((.*)\)$/i);
      if (dateMatch) {
        const inner = dateMatch[1].trim();
        const d = new Date(inner);
        if (!isNaN(d.getTime())) return { ok: true, value: d };
        return { ok: false, reason: 'bad date' };
      }

      // JSON object/array/primitive
      if (s.startsWith('{') || s.startsWith('[')) {
        try {
          return { ok: true, value: JSON.parse(s) };
        } catch (e) {
          return { ok: false, reason: 'bad json' };
        }
      }

      // Number literal
      // Accept decimal, hex 0x, octal 0o, binary 0b where Number() can parse, but exclude leading zeros issues
      if (/^[-+]?(\d+(\.\d*)?|\.\d+)(e[-+]?\d+)?$/i.test(s) || /^[-+]?0x[0-9a-f]+$/i.test(s) || /^[-+]?0o[0-7]+$/i.test(s) || /^[-+]?0b[01]+$/i.test(s)) {
        const n = Number(s);
        if (!Number.isNaN(n)) return { ok: true, value: n };
      }

      // Fallback: treat as string
      return { ok: true, value: s };
    }

    function describe(value) {
      const t = typeof value;
      if (t === 'number') {
        if (Number.isNaN(value)) return 'NaN';
        if (value === Infinity) return 'Infinity';
        if (value === -Infinity) return '-Infinity';
        if (isNegZero(value)) return '-0';
        return String(value);
      }
      if (t === 'bigint') return String(value) + 'n';
      if (t === 'string') return JSON.stringify(value);
      if (t === 'boolean') return value ? 'true' : 'false';
      if (t === 'undefined') return 'undefined';
      if (t === 'symbol') return value.toString();
      if (t === 'function') return `Function ${value.name || '(anonymous)'}`;
      if (value === null) return 'null';

      // objects
      if (value instanceof Date) return `Date(${value.toISOString()})`;
      if (value instanceof Set) return `Set#${getId(value) || '?'}(size=${value.size})`;

      let tag = Array.isArray(value) ? 'Array' : (value && value.constructor && value.constructor.name ? value.constructor.name : 'Object');
      tag = tag === 'Object' ? 'Object' : tag;
      const id = getId(value);
      const preview = compactPreview(value, 50);
      return `${tag}#${id}${preview ? ' ' + preview : ''}`;
    }

    function compactPreview(value, maxLen = 60) {
      // JSON preview with custom replacer
      try {
        const seen = new WeakMap();
        let seq = 1;
        const s = JSON.stringify(value, (k, v) => {
          const tv = typeof v;
          if (tv === 'bigint') return String(v) + 'n';
          if (tv === 'symbol') return v.toString();
          if (tv === 'function') return `Function ${v.name || '(anonymous)'}`;
          if (tv === 'number') {
            if (Number.isNaN(v)) return 'NaN';
            if (isNegZero(v)) return '-0';
            if (v === Infinity) return 'Infinity';
            if (v === -Infinity) return '-Infinity';
            return v;
          }
          if (v && tv === 'object') {
            if (seen.has(v)) return `[Circular#${seen.get(v)}]`;
            seen.set(v, seq++);
          }
          return v;
        });
        if (!s) return '';
        const trimmed = s.length > maxLen ? s.slice(0, maxLen - 1) + '…' : s;
        return trimmed;
      } catch (e) {
        return '';
      }
    }

    function log(msg, type = 'info') {
      const area = document.getElementById('logArea');
      const time = new Date().toLocaleTimeString();
      const prefix = type === 'warn' ? '⚠' : type === 'err' ? '✖' : '•';
      area.textContent += `[${time}] ${prefix} ${msg}\n`;
      area.scrollTop = area.scrollHeight;
    }

    // Sets
    const setA = new Set();
    const setB = new Set();

    // UI elements
    const refs = {
      inputA: document.getElementById('inputA'),
      inputB: document.getElementById('inputB'),
      addA: document.getElementById('addA'),
      addB: document.getElementById('addB'),
      delA: document.getElementById('delA'),
      delB: document.getElementById('delB'),
      hasA: document.getElementById('hasA'),
      hasB: document.getElementById('hasB'),
      clearA: document.getElementById('clearA'),
      clearB: document.getElementById('clearB'),
      sizeA: document.getElementById('sizeA'),
      sizeB: document.getElementById('sizeB'),
      chipsA: document.getElementById('chipsA'),
      chipsB: document.getElementById('chipsB'),
      bulkA: document.getElementById('bulkA'),
      bulkB: document.getElementById('bulkB'),
      bulkAddA: document.getElementById('bulkAddA'),
      bulkAddB: document.getElementById('bulkAddB'),
      // Ops
      btnUnion: document.getElementById('btnUnion'),
      btnInter: document.getElementById('btnInter'),
      btnDiffAB: document.getElementById('btnDiffAB'),
      btnDiffBA: document.getElementById('btnDiffBA'),
      btnSymDiff: document.getElementById('btnSymDiff'),
      resultArea: document.getElementById('resultArea'),
      sizeResult: document.getElementById('sizeResult'),
      // Dedup
      dedupInput: document.getElementById('dedupInput'),
      runDedup: document.getElementById('runDedup'),
      copyDedup: document.getElementById('copyDedup'),
      dedupOut: document.getElementById('dedupOut'),
      dedupInfo: document.getElementById('dedupInfo'),
      // Iter
      iterForOf: document.getElementById('iterForOf'),
      iterEntries: document.getElementById('iterEntries'),
      iterForEach: document.getElementById('iterForEach'),
      testSpecial: document.getElementById('testSpecial'),
      addObjRefs: document.getElementById('addObjRefs'),
      // WeakSet
      wsDemo: document.getElementById('wsDemo'),
      wsOut: document.getElementById('wsOut'),
    };

    function updateSetView(set, chipsEl, sizeEl) {
      sizeEl.textContent = set.size;
      chipsEl.innerHTML = '';
      for (const val of set) {
        const chip = document.createElement('span');
        chip.className = 'chip';
        chip.title = `typeof ${typeof val}`;
        const label = document.createElement('span');
        label.textContent = describe(val);
        const del = document.createElement('button');
        del.textContent = '×';
        del.title = 'Delete this value';
        del.addEventListener('click', () => {
          set.delete(val);
          chipsEl.removeChild(chip);
          sizeEl.textContent = set.size;
          log(`Deleted ${describe(val)} from ${set === setA ? 'Set A' : 'Set B'}`);
        });
        chip.appendChild(label);
        // type hint
        const hint = document.createElement('small');
        hint.textContent = `(${typeof val})`;
        chip.appendChild(hint);
        chip.appendChild(del);
        chipsEl.appendChild(chip);
      }
    }

    function addInputToSet(inputEl, setName) {
      const s = setName === 'A' ? setA : setB;
      const valueText = inputEl.value;
      const r = parseValue(valueText);
      if (!r.ok) {
        alert('Could not parse value: ' + (r.reason || 'unknown'));
        return;
      }
      const before = s.size;
      s.add(r.value);
      updateSetView(s, setName === 'A' ? refs.chipsA : refs.chipsB, setName === 'A' ? refs.sizeA : refs.sizeB);
      const after = s.size;
      log(`Add to Set ${setName}: ${describe(r.value)}${after === before ? ' (already present)' : ''}`);
    }

    function deleteInputFromSet(inputEl, setName) {
      const s = setName === 'A' ? setA : setB;
      const r = parseValue(inputEl.value);
      if (!r.ok) {
        alert('Could not parse value: ' + (r.reason || 'unknown'));
        return;
      }
      const removed = s.delete(r.value);
      updateSetView(s, setName === 'A' ? refs.chipsA : refs.chipsB, setName === 'A' ? refs.sizeA : refs.sizeB);
      log(`${removed ? 'Deleted' : 'Not found'} in Set ${setName}: ${describe(r.value)}`, removed ? 'info' : 'warn');
    }

    function hasInputInSet(inputEl, setName) {
      const s = setName === 'A' ? setA : setB;
      const r = parseValue(inputEl.value);
      if (!r.ok) {
        alert('Could not parse value: ' + (r.reason || 'unknown'));
        return;
      }
      const exists = s.has(r.value);
      log(`Set ${setName} has ${describe(r.value)}: ${exists ? 'Yes' : 'No'}`, exists ? 'info' : 'warn');
      alert(`Set ${setName} ${exists ? 'contains' : 'does not contain'} ${describe(r.value)}`);
    }

    function bulkAdd(text, targetSetName) {
      const s = targetSetName === 'A' ? setA : setB;
      const tokens = splitValues(text);
      let added = 0, skipped = 0;
      for (const t of tokens) {
        const r = parseValue(t);
        if (r.ok) {
          const before = s.size;
          s.add(r.value);
          if (s.size > before) added++;
          else skipped++;
        } else {
          skipped++;
        }
      }
      updateSetView(s, targetSetName === 'A' ? refs.chipsA : refs.chipsB, targetSetName === 'A' ? refs.sizeA : refs.sizeB);
      log(`Bulk add to Set ${targetSetName}: +${added}, skipped ${skipped}`);
    }

    function splitValues(text) {
      // Split by newlines or commas, ignoring empty parts
      return String(text)
        .split(/\n|,/)
        .map(s => s.trim())
        .filter(Boolean);
    }

    // Set operations
    const setOps = {
      union: (A, B) => new Set([...A, ...B]),
      intersection: (A, B) => new Set([...A].filter(x => B.has(x))),
      difference: (A, B) => new Set([...A].filter(x => !B.has(x))),
      symDiff: (A, B) => {
        const U = new Set([...A, ...B]);
        const I = new Set([...A].filter(x => B.has(x)));
        return new Set([...U].filter(x => !I.has(x)));
      }
    };

    function renderSet(set) {
      const out = [];
      for (const v of set) out.push(describe(v));
      return `{ ${out.join(', ')} }`;
    }

    function runOp(name) {
      let res;
      if (name === 'union') res = setOps.union(setA, setB);
      if (name === 'intersection') res = setOps.intersection(setA, setB);
      if (name === 'differenceAB') res = setOps.difference(setA, setB);
      if (name === 'differenceBA') res = setOps.difference(setB, setA);
      if (name === 'sym') res = setOps.symDiff(setA, setB);
      refs.resultArea.textContent = renderSet(res);
      refs.sizeResult.textContent = res.size;
      log(`Operation ${name}: result size ${res.size}`);
    }

    // Deduplicate
    function parseListOrArray(text) {
      const s = String(text).trim();
      let arr = [];
      if (!s) return arr;
      if (s.startsWith('[') && s.endsWith(']')) {
        try {
          arr = JSON.parse(s);
          return Array.isArray(arr) ? arr : [arr];
        } catch (e) {
          // fall-through to CSV/newline
        }
      }
      // CSV/newlines
      const parts = splitValues(s);
      arr = parts.map(p => {
        const r = parseValue(p);
        return r.ok ? r.value : p;
      });
      return arr;
    }

    function stringifyArrayPreview(arr) {
      return '[' + arr.map(v => describe(v)).join(', ') + ']';
    }

    function runDedup() {
      const input = refs.dedupInput.value;
      const arr = parseListOrArray(input);
      const before = arr.length;
      // Deduplicate preserving SameValueZero semantics
      const deduped = [...new Set(arr)];
      const after = deduped.length;
      refs.dedupOut.textContent = stringifyArrayPreview(deduped);
      refs.dedupInfo.textContent = `Before: ${before} After: ${after}`;
      log(`Dedup: before ${before}, after ${after}`);
      return deduped;
    }

    // Iteration demos
    function iterForOf() {
      let i = 0;
      for (const v of setA) {
        log(`for...of A[${i++}] = ${describe(v)}`);
      }
      if (i === 0) log('for...of: Set A is empty', 'warn');
    }
    function iterEntries() {
      let i = 0;
      for (const [k, v] of setA.entries()) {
        log(`entries A[${i++}] = [${describe(k)}, ${describe(v)}]`);
      }
      if (i === 0) log('entries(): Set A is empty', 'warn');
    }
    function iterForEach() {
      let i = 0;
      setA.forEach((v, k) => {
        log(`forEach A[${i++}] => value=${describe(v)} key=${describe(k)}`);
      });
      if (i === 0) log('forEach(): Set A is empty', 'warn');
    }

    function testSpecialNumbers() {
      setA.clear();
      setA.add(0);
      setA.add(-0);
      setA.add(+0);
      setA.add(NaN);
      setA.add(NaN);
      updateSetView(setA, refs.chipsA, refs.sizeA);
      log('Added 0, -0, +0, NaN, NaN to Set A');
      log(`Set A has 0? ${setA.has(0)} (SameValueZero treats -0 and 0 as the same)`);
      log(`Set A has -0? ${setA.has(-0)} (true)`);
      log(`Set A has NaN? ${setA.has(NaN)} (NaN equals NaN under SameValueZero)`);
      const out = [];
      for (const v of setA) out.push(describe(v));
      log('Iterating Set A yields: ' + out.join(', '));
    }

    function addObjectRefs() {
      const obj1 = { x: 1 };
      const obj2 = { x: 1 };
      const same = obj1;
      setA.add(obj1);
      setA.add(obj2);
      setA.add(same);
      updateSetView(setA, refs.chipsA, refs.sizeA);
      log('Added obj1={x:1}, obj2={x:1}, and same reference again.');
      log('Even though obj1 and obj2 look equal, they are different references, so both appear.');
    }

    // WeakSet demo
    function runWeakSetDemo() {
      const out = [];
      const ws = new WeakSet();
      let a = { name: 'a' };
      let b = { name: 'b' };
      ws.add(a);
      out.push('Created WeakSet, added object a');
      out.push('ws.has(a) => ' + ws.has(a));
      out.push('ws.has(b) before add => ' + ws.has(b));
      ws.add(b);
      out.push('Added object b');
      out.push('ws.has(b) => ' + ws.has(b));
      a = null; // remove strong reference to a (eligible for GC sometime later)
      out.push('a = null (now only weakly referenced; cannot be observed when GC happens).');
      try {
        // Demonstrate non-iterable nature
        // eslint-disable-next-line no-unused-vars
        for (const item of ws) {}
        out.push('This line should not be reachable (WeakSet is not iterable).');
      } catch (e) {
        out.push('WeakSet is not iterable: ' + e);
      }
      document.getElementById('wsOut').textContent = out.join('\n');
    }

    // Wire up events
    refs.addA.addEventListener('click', () => addInputToSet(refs.inputA, 'A'));
    refs.addB.addEventListener('click', () => addInputToSet(refs.inputB, 'B'));
    refs.delA.addEventListener('click', () => deleteInputFromSet(refs.inputA, 'A'));
    refs.delB.addEventListener('click', () => deleteInputFromSet(refs.inputB, 'B'));
    refs.hasA.addEventListener('click', () => hasInputInSet(refs.inputA, 'A'));
    refs.hasB.addEventListener('click', () => hasInputInSet(refs.inputB, 'B'));
    refs.clearA.addEventListener('click', () => { setA.clear(); updateSetView(setA, refs.chipsA, refs.sizeA); log('Cleared Set A', 'warn'); });
    refs.clearB.addEventListener('click', () => { setB.clear(); updateSetView(setB, refs.chipsB, refs.sizeB); log('Cleared Set B', 'warn'); });
    refs.bulkAddA.addEventListener('click', () => bulkAdd(refs.bulkA.value, 'A'));
    refs.bulkAddB.addEventListener('click', () => bulkAdd(refs.bulkB.value, 'B'));

    refs.btnUnion.addEventListener('click', () => runOp('union'));
    refs.btnInter.addEventListener('click', () => runOp('intersection'));
    refs.btnDiffAB.addEventListener('click', () => runOp('differenceAB'));
    refs.btnDiffBA.addEventListener('click', () => runOp('differenceBA'));
    refs.btnSymDiff.addEventListener('click', () => runOp('sym'));

    refs.runDedup.addEventListener('click', runDedup);
    refs.copyDedup.addEventListener('click', () => {
      const text = refs.dedupOut.textContent;
      if (!text.trim()) return;
      navigator.clipboard.writeText(text).then(() => {
        log('Dedup result copied to clipboard');
      });
    });

    refs.iterForOf.addEventListener('click', iterForOf);
    refs.iterEntries.addEventListener('click', iterEntries);
    refs.iterForEach.addEventListener('click', iterForEach);
    refs.testSpecial.addEventListener('click', testSpecialNumbers);
    refs.addObjRefs.addEventListener('click', addObjectRefs);

    refs.wsDemo.addEventListener('click', runWeakSetDemo);

    // Starter examples
    (function seed() {
      const initialA = [1, 2, 2, 'hello', true, NaN, -0, { a: 1 }, [1, 2]];
      const initialB = [2, 3, 'hello', false, NaN, Symbol('s'), 123n];
      initialA.forEach(v => setA.add(v));
      initialB.forEach(v => setB.add(v));
      updateSetView(setA, refs.chipsA, refs.sizeA);
      updateSetView(setB, refs.chipsB, refs.sizeB);
      log('Initialized Set A and Set B with sample values.');
    })();
  </script>
</body>
</html>