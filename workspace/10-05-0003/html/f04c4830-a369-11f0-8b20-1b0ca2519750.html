<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Adjacency Matrix Interactive Demo</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --text: #e5e7eb;
    --muted: #9ca3af;
    --accent: #60a5fa;
    --accent2: #22d3ee;
    --good: #34d399;
    --warn: #f59e0b;
    --bad: #ef4444;
    --grid: #1f2937;
  }
  html, body {
    margin: 0;
    height: 100%;
    background: linear-gradient(120deg, #0b122b, #0a1a24 60%, #101421);
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }
  a { color: var(--accent); text-decoration: none; }
  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px 16px 40px;
  }
  header {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 12px;
    align-items: center;
    margin-bottom: 16px;
  }
  .title {
    display: flex;
    align-items: baseline;
    gap: 12px;
  }
  h1 {
    margin: 0;
    font-weight: 700;
    letter-spacing: 0.5px;
    font-size: clamp(22px, 3vw, 28px);
  }
  .subtitle {
    color: var(--muted);
    font-size: 14px;
  }
  .controls {
    display: grid;
    grid-template-columns: repeat(12, minmax(0, 1fr));
    gap: 10px;
    align-items: center;
    background: rgba(17, 24, 39, 0.7);
    border: 1px solid #1f2937;
    border-radius: 12px;
    padding: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.03);
  }
  .controls > * {
    grid-column: span 3;
  }
  @media (max-width: 900px) {
    .controls { grid-template-columns: repeat(6, 1fr); }
    .controls > * { grid-column: span 3; }
  }
  @media (max-width: 560px) {
    .controls { grid-template-columns: repeat(2, 1fr); }
    .controls > * { grid-column: span 2; }
  }
  .control {
    background: rgba(31, 41, 55, 0.8);
    border: 1px solid #263143;
    border-radius: 8px;
    padding: 8px 10px;
  }
  .control label {
    font-size: 12px;
    color: var(--muted);
    display: block;
    margin-bottom: 4px;
  }
  .row {
    display: flex;
    gap: 8px;
    align-items: center;
    flex-wrap: wrap;
  }
  input[type="number"], input[type="text"], select {
    width: 100%;
    box-sizing: border-box;
    padding: 8px 10px;
    background: #0b1220;
    border: 1px solid #1f2a3a;
    color: var(--text);
    border-radius: 6px;
    outline: none;
  }
  input[type="range"] {
    width: 100%;
  }
  .checkbox {
    display: flex;
    gap: 8px;
    align-items: center;
    cursor: pointer;
  }
  .checkbox input {
    width: 18px; height: 18px;
  }
  .btn {
    background: linear-gradient(180deg, #1f2937, #111827);
    border: 1px solid #334155;
    color: var(--text);
    border-radius: 8px;
    padding: 8px 10px;
    cursor: pointer;
    transition: transform 0.02s ease-in-out, box-shadow 0.2s, border-color 0.2s;
    white-space: nowrap;
  }
  .btn:hover { border-color: #4b5563; box-shadow: 0 4px 14px rgba(0,0,0,0.18); }
  .btn:active { transform: translateY(1px); }
  .btn.primary { background: linear-gradient(180deg, #2563eb, #1e40af); border-color: #1d4ed8; }
  .btn.good { background: linear-gradient(180deg, #10b981, #047857); border-color: #059669; }
  .btn.warn { background: linear-gradient(180deg, #f59e0b, #b45309); border-color: #d97706; color: #0b1020; }
  .btn.bad { background: linear-gradient(180deg, #ef4444, #b91c1c); border-color: #dc2626; }
  .layout {
    display: grid;
    grid-template-columns: 420px 1fr;
    gap: 14px;
    margin-top: 12px;
  }
  @media (max-width: 1024px) {
    .layout { grid-template-columns: 1fr; }
  }
  .panel {
    background: rgba(17, 24, 39, 0.7);
    border: 1px solid #1f2937;
    border-radius: 12px;
    padding: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.03);
  }
  .panel h2 {
    font-size: 16px;
    margin: 0 0 8px 0;
    color: var(--accent);
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .matrix-wrapper {
    overflow: auto;
    border-radius: 8px;
    border: 1px solid #263143;
  }
  table.matrix {
    border-collapse: collapse;
    min-width: 360px;
    width: 100%;
    background: #0b1220;
  }
  table.matrix th, table.matrix td {
    border: 1px solid #233245;
    text-align: center;
    padding: 0;
    position: relative;
  }
  table.matrix th {
    background: #111827;
    color: var(--muted);
    font-weight: 500;
    font-size: 13px;
    padding: 6px 8px;
    position: sticky;
    top: 0;
    z-index: 3;
  }
  table.matrix td {
    height: 34px;
    width: 34px;
    min-width: 34px;
    font-size: 13px;
    color: var(--text);
    background: #0b1220;
    cursor: pointer;
  }
  table.matrix td:hover {
    outline: 2px solid #2563eb66;
    z-index: 2;
  }
  td .cell {
    width: 100%;
    height: 100%;
    display: grid;
    place-items: center;
    user-select: none;
  }
  td.loop-disabled {
    background: #0b1220;
    color: #324256;
    cursor: not-allowed;
  }
  td.active {
    background: #0f1e32;
  }
  .legend {
    font-size: 12px;
    color: var(--muted);
    padding: 8px;
    border-top: 1px dashed #263143;
    margin-top: 8px;
  }
  .legend b { color: var(--text); }
  .graph {
    height: 520px;
    background: #0b1220;
    border-radius: 12px;
    border: 1px solid #263143;
    overflow: hidden;
    position: relative;
  }
  .graph-controls {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin-bottom: 10px;
  }
  .statbar {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
    margin-top: 10px;
  }
  .stat {
    background: rgba(31, 41, 55, 0.8);
    border: 1px solid #263143;
    border-radius: 8px;
    padding: 8px;
    font-size: 13px;
  }
  .stat .value {
    font-weight: 700;
    color: var(--good);
  }
  .footnote {
    margin-top: 10px;
    font-size: 12px;
    color: var(--muted);
  }
  .algos {
    margin-top: 14px;
    display: grid;
    grid-template-columns: 1fr;
    gap: 12px;
  }
  .algo-panel {
    background: rgba(17, 24, 39, 0.7);
    border: 1px solid #1f2937;
    border-radius: 12px;
    padding: 12px;
  }
  .algo-panel h3 {
    margin: 0 0 6px 0;
    font-size: 15px;
    color: var(--accent2);
  }
  .mini-matrix {
    overflow: auto;
    border-radius: 8px;
    border: 1px solid #263143;
    max-height: 260px;
  }
  table.small {
    border-collapse: collapse;
    background: #0b1220;
    min-width: 240px;
  }
  table.small th, table.small td {
    border: 1px solid #233245;
    text-align: center;
    padding: 4px 6px;
    font-size: 12px;
    color: var(--text);
    position: sticky;
  }
  table.small th {
    background: #111827;
    color: var(--muted);
    top: 0;
    z-index: 1;
  }
  .list {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 12px;
    background: #0b1220;
    border: 1px solid #263143;
    border-radius: 8px;
    padding: 10px;
    overflow: auto;
    max-height: 240px;
  }
  .matrix-actions, .io-actions {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin-top: 10px;
  }
  .io {
    margin-top: 8px;
    display: none;
  }
  .io textarea {
    width: 100%;
    min-height: 120px;
    background: #0b1220;
    border: 1px solid #263143;
    color: var(--text);
    border-radius: 8px;
    padding: 8px;
    box-sizing: border-box;
    resize: vertical;
  }
  .badge {
    font-size: 11px;
    background: #111827;
    border: 1px solid #263143;
    color: var(--muted);
    padding: 2px 6px;
    border-radius: 999px;
  }
  .tip {
    font-size: 12px;
    color: var(--muted);
  }
  .weight-editor {
    position: fixed;
    background: #111827;
    border: 1px solid #334155;
    color: var(--text);
    border-radius: 8px;
    padding: 10px;
    z-index: 1000;
    box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    display: none;
    width: 220px;
  }
  .weight-editor .row { justify-content: space-between; }
  .arrow-marker path { fill: #93c5fd; }
  .graph svg { width: 100%; height: 100%; }
  .node {
    fill: #1f6fe0;
    stroke: #8ab6ff;
    stroke-width: 1px;
    cursor: pointer;
  }
  .node:hover { filter: brightness(1.2); }
  .edge {
    stroke: #93c5fd;
    stroke-width: 2;
    opacity: 0.9;
    cursor: pointer;
  }
  .edge:hover { stroke: #e0f2fe; }
  .edge.weighted { stroke-width: 2.5; }
  .label {
    font-size: 12px;
    fill: #e5e7eb;
    pointer-events: none;
  }
  .arrow {
    marker-end: url(#arrowhead);
  }
  .axis-label {
    font-size: 11px;
    color: var(--muted);
  }
  .callout {
    border-left: 3px solid var(--accent);
    background: rgba(37, 99, 235, 0.08);
    padding: 8px 10px;
    border-radius: 6px;
    font-size: 13px;
    color: #cbd5e1;
  }
</style>
</head>
<body>
<div class="container">
  <header>
    <div class="title">
      <h1>Adjacency Matrix</h1>
      <span class="subtitle">Interactive graph builder and matrix explorer</span>
    </div>
    <div class="badge">Single-file HTML + JavaScript demo</div>
  </header>

  <div class="controls">
    <div class="control">
      <label for="vertexCount">Vertices (n)</label>
      <div class="row">
        <input id="vertexCount" type="number" min="1" max="20" value="6" />
        <button class="btn" id="resizeBtn">Resize</button>
      </div>
    </div>
    <div class="control">
      <label>Graph Type</label>
      <div class="row">
        <label class="checkbox"><input type="checkbox" id="directed" /> Directed</label>
        <label class="checkbox"><input type="checkbox" id="weighted" /> Weighted</label>
        <label class="checkbox"><input type="checkbox" id="allowLoops" checked /> Allow self-loops</label>
      </div>
    </div>
    <div class="control">
      <label for="randomDensity">Random density</label>
      <div class="row">
        <input id="randomDensity" type="range" min="0" max="100" value="35" />
      </div>
      <div class="tip">Density p = <span id="densityVal">0.35</span></div>
    </div>
    <div class="control">
      <label for="maxWeight">Max random weight</label>
      <div class="row">
        <input id="maxWeight" type="number" min="1" max="50" value="5" />
      </div>
    </div>
    <div class="control">
      <label>Matrix actions</label>
      <div class="matrix-actions">
        <button class="btn" id="clearBtn">Clear</button>
        <button class="btn good" id="randomBtn">Random</button>
        <button class="btn warn" id="fillCliqueBtn">Make clique</button>
      </div>
    </div>
    <div class="control">
      <label>Import/Export</label>
      <div class="io-actions">
        <button class="btn" id="toggleIOBtn">Show IO</button>
        <button class="btn" id="copyCSVBtn">Copy CSV</button>
        <button class="btn" id="downloadCSVBtn">Download CSV</button>
      </div>
    </div>
    <div class="control">
      <label>Graph layout</label>
      <div class="row">
        <select id="layoutSelect">
          <option value="circle">Circle</option>
          <option value="grid">Grid</option>
        </select>
      </div>
    </div>
    <div class="control">
      <label>Path counts A^k</label>
      <div class="row">
        <input id="powerK" type="number" min="2" max="6" value="2" />
        <button class="btn" id="computePowerBtn">Compute</button>
      </div>
    </div>
    <div class="control">
      <label>Highlight</label>
      <div class="row">
        <input id="highlightIndex" type="number" min="0" max="19" value="0" />
        <button class="btn" id="highlightBtn">Row/Col</button>
      </div>
    </div>
    <div class="control">
      <label>Selection</label>
      <div class="row">
        <button class="btn" id="selectNodeBtn">Select node</button>
        <button class="btn" id="cancelSelectBtn">Cancel</button>
      </div>
      <div class="tip">Click a node, then another to add/remove edge.</div>
    </div>
    <div class="control">
      <label>Info</label>
      <div class="callout">Click a matrix cell to toggle edges. In weighted mode, click an existing edge to edit its weight.</div>
    </div>
  </div>

  <div class="layout">
    <div class="panel">
      <h2>Adjacency Matrix</h2>
      <div class="matrix-wrapper">
        <table class="matrix" id="matrixTable"></table>
      </div>
      <div class="legend">
        For a graph with vertices V = {0..n-1}, the adjacency matrix A is an n×n matrix where A[i][j] is:
        <br>- unweighted: 1 if edge i→j exists, otherwise 0
        <br>- weighted: the weight of edge i→j (0 if no edge)
      </div>
      <div class="io" id="ioPanel">
        <div class="row">
          <span class="badge">CSV Import/Export</span>
        </div>
        <textarea id="csvArea" placeholder="Paste CSV matrix here (rows separated by newlines, values by commas)"></textarea>
        <div class="row" style="margin-top: 6px;">
          <button class="btn good" id="applyCSVBtn">Apply CSV</button>
          <span class="tip">CSV must be n×n. Non-numeric values become 0.</span>
        </div>
      </div>
    </div>

    <div class="panel">
      <h2>Graph Visualization</h2>
      <div class="graph-controls">
        <span class="badge" id="graphStatus">Ready</span>
        <span class="badge">Click edges to toggle/edit</span>
      </div>
      <div class="graph" id="graphArea"></div>

      <div class="statbar">
        <div class="stat">Vertices: <span class="value" id="statN">0</span></div>
        <div class="stat">Edges: <span class="value" id="statM">0</span></div>
        <div class="stat">Density: <span class="value" id="statD">0</span></div>
      </div>

      <div class="algos">
        <div class="algo-panel">
          <h3>Degrees</h3>
          <div class="list" id="degreeList"></div>
          <div class="footnote">Undirected: degree of i is sum of row i (counting loops as 2 if allowed). Directed: out-degree = row sum, in-degree = column sum.</div>
        </div>
        <div class="algo-panel">
          <h3>Adjacency List</h3>
          <div class="list" id="adjacencyList"></div>
          <div class="footnote">Each vertex lists its neighbors. Weighted edges show as neighbor(weight).</div>
        </div>
        <div class="algo-panel">
          <h3>Matrix Power A^k</h3>
          <div class="mini-matrix" id="powerMatrixWrapper">
            <table class="small" id="powerMatrix"></table>
          </div>
          <div class="footnote">For unweighted graphs, (A^k)[i][j] counts walks of length k from i to j. For weighted graphs, entries accumulate weighted walk counts.</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Weight editor overlay -->
<div class="weight-editor" id="weightEditor">
  <div style="margin-bottom: 6px;">Edit weight for edge <span id="weightEdgeText"></span></div>
  <div class="row">
    <input id="weightInput" type="number" min="0" step="1" value="1" />
    <div class="row">
      <button class="btn good" id="weightApplyBtn">Apply</button>
      <button class="btn bad" id="weightDeleteBtn">Delete</button>
      <button class="btn" id="weightCancelBtn">Cancel</button>
    </div>
  </div>
</div>

<script>
(function() {
  // State
  let n = 6;
  let A = createZeroMatrix(n);
  let isDirected = false;
  let isWeighted = false;
  let allowLoops = true;
  let layoutMode = 'circle';
  let selectingNode = null; // selection index for adding edges

  const el = {
    vertexCount: document.getElementById('vertexCount'),
    resizeBtn: document.getElementById('resizeBtn'),
    directed: document.getElementById('directed'),
    weighted: document.getElementById('weighted'),
    allowLoops: document.getElementById('allowLoops'),
    matrixTable: document.getElementById('matrixTable'),
    clearBtn: document.getElementById('clearBtn'),
    randomBtn: document.getElementById('randomBtn'),
    fillCliqueBtn: document.getElementById('fillCliqueBtn'),
    randomDensity: document.getElementById('randomDensity'),
    densityVal: document.getElementById('densityVal'),
    maxWeight: document.getElementById('maxWeight'),
    graphArea: document.getElementById('graphArea'),
    graphStatus: document.getElementById('graphStatus'),
    powerK: document.getElementById('powerK'),
    computePowerBtn: document.getElementById('computePowerBtn'),
    powerMatrix: document.getElementById('powerMatrix'),
    degreeList: document.getElementById('degreeList'),
    adjacencyList: document.getElementById('adjacencyList'),
    toggleIOBtn: document.getElementById('toggleIOBtn'),
    ioPanel: document.getElementById('ioPanel'),
    csvArea: document.getElementById('csvArea'),
    applyCSVBtn: document.getElementById('applyCSVBtn'),
    copyCSVBtn: document.getElementById('copyCSVBtn'),
    downloadCSVBtn: document.getElementById('downloadCSVBtn'),
    layoutSelect: document.getElementById('layoutSelect'),
    statN: document.getElementById('statN'),
    statM: document.getElementById('statM'),
    statD: document.getElementById('statD'),
    highlightIndex: document.getElementById('highlightIndex'),
    highlightBtn: document.getElementById('highlightBtn'),
    selectNodeBtn: document.getElementById('selectNodeBtn'),
    cancelSelectBtn: document.getElementById('cancelSelectBtn'),
    weightEditor: document.getElementById('weightEditor'),
    weightEdgeText: document.getElementById('weightEdgeText'),
    weightInput: document.getElementById('weightInput'),
    weightApplyBtn: document.getElementById('weightApplyBtn'),
    weightDeleteBtn: document.getElementById('weightDeleteBtn'),
    weightCancelBtn: document.getElementById('weightCancelBtn')
  };

  // Initialize
  function init() {
    renderMatrix();
    renderGraph();
    updateStats();
    renderLists();
    renderPower();
    el.vertexCount.value = n;
    el.directed.checked = isDirected;
    el.weighted.checked = isWeighted;
    el.allowLoops.checked = allowLoops;
    el.layoutSelect.value = layoutMode;
    el.densityVal.textContent = Number(el.randomDensity.value / 100).toFixed(2);

    addEventListeners();
  }

  function addEventListeners() {
    el.resizeBtn.addEventListener('click', () => {
      const newN = clamp(parseInt(el.vertexCount.value, 10) || n, 1, 20);
      if (newN !== n) {
        n = newN;
        A = createZeroMatrix(n);
        el.highlightIndex.max = n-1;
        renderMatrix();
        renderGraph();
        updateStats();
        renderLists();
        renderPower();
      }
    });

    el.directed.addEventListener('change', () => {
      isDirected = el.directed.checked;
      if (!isDirected) {
        // Force symmetry for undirected
        symmetrizeMatrix();
      }
      renderMatrix();
      renderGraph();
      updateStats();
      renderLists();
      renderPower();
    });

    el.weighted.addEventListener('change', () => {
      isWeighted = el.weighted.checked;
      renderMatrix();
      renderGraph();
      updateStats();
      renderLists();
      renderPower();
    });

    el.allowLoops.addEventListener('change', () => {
      allowLoops = el.allowLoops.checked;
      if (!allowLoops) {
        // Clear diagonal
        for (let i = 0; i < n; i++) setEdge(i, i, 0);
      }
      renderMatrix();
      renderGraph();
      updateStats();
      renderLists();
      renderPower();
    });

    el.clearBtn.addEventListener('click', () => {
      A = createZeroMatrix(n);
      renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();
      info('Matrix cleared');
    });

    el.fillCliqueBtn.addEventListener('click', () => {
      // Fill complete graph (without loops unless allowed)
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if (!allowLoops && i === j) { setEdge(i, j, 0); continue; }
          const val = isWeighted ? (i === j ? (allowLoops ? 1 : 0) : 1) : 1;
          setEdge(i, j, val);
        }
      }
      if (!isDirected) symmetrizeMatrix();
      renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();
      info('Complete graph created');
    });

    el.randomDensity.addEventListener('input', () => {
      el.densityVal.textContent = Number(el.randomDensity.value / 100).toFixed(2);
    });

    el.randomBtn.addEventListener('click', () => {
      const p = parseInt(el.randomDensity.value, 10) / 100;
      const maxW = clamp(parseInt(el.maxWeight.value, 10) || 5, 1, 100);
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if (!allowLoops && i === j) { setEdge(i, j, 0); continue; }
          const r = Math.random();
          if (r < p) {
            const val = isWeighted ? Math.max(1, Math.round(Math.random() * maxW)) : 1;
            setEdge(i, j, val);
          } else {
            setEdge(i, j, 0);
          }
        }
      }
      if (!isDirected) symmetrizeMatrix();
      renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();
      info('Random graph generated');
    });

    el.computePowerBtn.addEventListener('click', () => {
      renderPower();
    });

    el.toggleIOBtn.addEventListener('click', () => {
      el.ioPanel.style.display = el.ioPanel.style.display === 'none' || el.ioPanel.style.display === '' ? 'block' : 'none';
    });

    el.applyCSVBtn.addEventListener('click', () => {
      const csv = el.csvArea.value.trim();
      if (!csv) return warn('CSV area is empty');
      const rows = csv.split(/\r?\n/).map(r => r.split(/[,\s]+/));
      if (!rows.length) return warn('Invalid CSV');
      const m = rows.length;
      const k = rows[0].length;
      if (m !== k) { return warn('CSV must contain a square matrix'); }
      if (m !== n) {
        // Resize
        n = m;
        el.vertexCount.value = n;
        A = createZeroMatrix(n);
      }
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          const val = toNumber(rows[i][j]);
          setEdge(i, j, clamp(val, 0, 1e9));
        }
      }
      if (!isDirected) symmetrizeMatrix();
      renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();
      info('CSV imported');
    });

    el.copyCSVBtn.addEventListener('click', async () => {
      const csv = matrixToCSV(A);
      try {
        await navigator.clipboard.writeText(csv);
        info('CSV copied to clipboard');
      } catch {
        el.csvArea.value = csv;
        el.ioPanel.style.display = 'block';
        info('Clipboard blocked. CSV placed in textarea.');
      }
    });

    el.downloadCSVBtn.addEventListener('click', () => {
      const csv = matrixToCSV(A);
      downloadFile(csv, `adjacency_matrix_${n}x${n}.csv`, 'text/csv');
    });

    el.layoutSelect.addEventListener('change', () => {
      layoutMode = el.layoutSelect.value;
      renderGraph();
    });

    el.highlightBtn.addEventListener('click', () => {
      const idx = clamp(parseInt(el.highlightIndex.value, 10) || 0, 0, n-1);
      highlightRowCol(idx);
    });

    el.selectNodeBtn.addEventListener('click', () => {
      selectingNode = null;
      el.graphStatus.textContent = 'Select first node in graph (click a node)...';
      el.graphStatus.style.borderColor = '#2563eb';
    });

    el.cancelSelectBtn.addEventListener('click', () => {
      selectingNode = null;
      el.graphStatus.textContent = 'Ready';
      el.graphStatus.style.borderColor = '#263143';
    });

    // Weight editor events
    el.weightApplyBtn.addEventListener('click', () => {
      const value = clamp(parseInt(el.weightInput.value, 10) || 0, 0, 1e9);
      const { i, j } = el.weightEditor.dataset;
      if (i == null || j == null) return closeWeightEditor();
      applyWeight(parseInt(i, 10), parseInt(j, 10), value);
      closeWeightEditor();
    });
    el.weightDeleteBtn.addEventListener('click', () => {
      const { i, j } = el.weightEditor.dataset;
      if (i == null || j == null) return closeWeightEditor();
      applyWeight(parseInt(i, 10), parseInt(j, 10), 0);
      closeWeightEditor();
    });
    el.weightCancelBtn.addEventListener('click', () => {
      closeWeightEditor();
    });

    // Close overlay on Escape
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeWeightEditor();
    });

    // Close overlay if clicking outside
    document.addEventListener('mousedown', (e) => {
      if (el.weightEditor.style.display === 'block') {
        const rect = el.weightEditor.getBoundingClientRect();
        const inside = e.clientX >= rect.left && e.clientX <= rect.right &&
                       e.clientY >= rect.top && e.clientY <= rect.bottom;
        if (!inside) closeWeightEditor();
      }
    });
  }

  // Helpers
  function createZeroMatrix(size) {
    const M = new Array(size);
    for (let i = 0; i < size; i++) {
      M[i] = new Array(size).fill(0);
    }
    return M;
  }

  function setEdge(i, j, val) {
    if (!allowLoops && i === j) val = 0;
    A[i][j] = val;
    if (!isDirected && i !== j) A[j][i] = val;
  }

  function applyWeight(i, j, val) {
    setEdge(i, j, val);
    renderMatrix();
    renderGraph();
    updateStats();
    renderLists();
    renderPower();
  }

  function symmetrizeMatrix() {
    for (let i = 0; i < n; i++) {
      for (let j = i+1; j < n; j++) {
        const v = Math.max(A[i][j], A[j][i]); // prefer existing edge; ensure undirected equivalent
        A[i][j] = v; A[j][i] = v;
      }
    }
  }

  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
  function toNumber(x) {
    const v = Number(x);
    return isFinite(v) ? v : 0;
  }

  function matrixToCSV(M) {
    return M.map(row => row.join(',')).join('\n');
  }

  function downloadFile(content, filename, mime) {
    const blob = new Blob([content], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(url);
    a.remove();
  }

  function info(msg) { el.graphStatus.textContent = msg; el.graphStatus.style.borderColor = '#059669'; }
  function warn(msg) { el.graphStatus.textContent = msg; el.graphStatus.style.borderColor = '#f59e0b'; }

  function renderMatrix() {
    const table = el.matrixTable;
    table.innerHTML = '';
    const thead = document.createElement('thead');
    const trh = document.createElement('tr');
    const corner = document.createElement('th');
    corner.textContent = 'i \\ j';
    trh.appendChild(corner);
    for (let j = 0; j < n; j++) {
      const th = document.createElement('th');
      th.textContent = j;
      trh.appendChild(th);
    }
    thead.appendChild(trh);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    for (let i = 0; i < n; i++) {
      const tr = document.createElement('tr');
      const th = document.createElement('th');
      th.textContent = i;
      tr.appendChild(th);

      for (let j = 0; j < n; j++) {
        const td = document.createElement('td');
        const div = document.createElement('div');
        div.className = 'cell';
        const val = A[i][j];
        div.textContent = val;
        td.appendChild(div);

        if (!allowLoops && i === j) {
          td.classList.add('loop-disabled');
        } else if (val !== 0) {
          td.classList.add('active');
        }

        td.addEventListener('click', (e) => {
          e.preventDefault();
          closeWeightEditor();
          if (!allowLoops && i === j) return;

          if (!isWeighted) {
            const newVal = A[i][j] === 0 ? 1 : 0;
            setEdge(i, j, newVal);
            renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();
          } else {
            if (A[i][j] === 0) {
              setEdge(i, j, 1);
              renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();
            } else {
              openWeightEditorForCell(td, i, j, A[i][j]);
            }
          }
        });

        td.addEventListener('dblclick', (e) => {
          e.preventDefault();
          if (!allowLoops && i === j) return;
          openWeightEditorForCell(td, i, j, A[i][j]);
        });

        tr.appendChild(td);
      }

      tbody.appendChild(tr);
    }

    table.appendChild(tbody);
  }

  function openWeightEditorForCell(cell, i, j, currentVal) {
    const rect = cell.getBoundingClientRect();
    el.weightEditor.style.display = 'block';
    el.weightEditor.style.left = `${rect.left + window.scrollX + rect.width + 6}px`;
    el.weightEditor.style.top = `${rect.top + window.scrollY - 4}px`;
    el.weightInput.value = currentVal || 1;
    el.weightEdgeText.textContent = `${i} → ${j}`;
    el.weightEditor.dataset.i = String(i);
    el.weightEditor.dataset.j = String(j);
  }

  function closeWeightEditor() {
    el.weightEditor.style.display = 'none';
    delete el.weightEditor.dataset.i;
    delete el.weightEditor.dataset.j;
  }

  function renderGraph() {
    el.graphArea.innerHTML = '';
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

    // defs: arrowhead
    const defs = document.createElementNS(svg.namespaceURI, 'defs');
    const marker = document.createElementNS(svg.namespaceURI, 'marker');
    marker.setAttribute('id', 'arrowhead');
    marker.setAttribute('viewBox', '0 0 10 10');
    marker.setAttribute('refX', '10');
    marker.setAttribute('refY', '5');
    marker.setAttribute('markerWidth', '6');
    marker.setAttribute('markerHeight', '6');
    marker.setAttribute('orient', 'auto-start-reverse');
    const path = document.createElementNS(svg.namespaceURI, 'path');
    path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
    path.setAttribute('class', 'arrow-marker');
    marker.appendChild(path);
    defs.appendChild(marker);
    svg.appendChild(defs);

    const width = el.graphArea.clientWidth;
    const height = el.graphArea.clientHeight;

    const positions = computePositions(n, width, height, layoutMode);

    // Draw edges
    const edgesDrawn = new Set();
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        const w = A[i][j];
        if (w === 0) continue;
        if (!isDirected && i > j) continue; // draw undirected edge once
        const [x1, y1] = positions[i];
        const [x2, y2] = positions[j];

        const edge = document.createElementNS(svg.namespaceURI, 'line');
        edge.setAttribute('x1', x1);
        edge.setAttribute('y1', y1);
        edge.setAttribute('x2', x2);
        edge.setAttribute('y2', y2);
        edge.setAttribute('class', 'edge' + (isWeighted ? ' weighted' : '') + (isDirected ? ' arrow' : ''));
        svg.appendChild(edge);

        // Edge label (weight or 1)
        if (isWeighted) {
          const tx = (x1 + x2) / 2;
          const ty = (y1 + y2) / 2;
          const label = document.createElementNS(svg.namespaceURI, 'text');
          label.setAttribute('x', tx);
          label.setAttribute('y', ty);
          label.setAttribute('class', 'label');
          label.textContent = String(w);
          svg.appendChild(label);
        }

        const key = `${i}-${j}`;
        edgesDrawn.add(key);

        edge.addEventListener('click', (e) => {
          e.stopPropagation();
          closeWeightEditor();
          if (!isWeighted) {
            const newVal = A[i][j] === 0 ? 1 : 0;
            setEdge(i, j, newVal);
            renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();
          } else {
            openWeightEditorAtPoint(e.clientX, e.clientY, i, j, A[i][j]);
          }
        });
      }
    }

    // Draw nodes
    for (let i = 0; i < n; i++) {
      const [x, y] = positions[i];

      const node = document.createElementNS(svg.namespaceURI, 'circle');
      node.setAttribute('cx', x);
      node.setAttribute('cy', y);
      node.setAttribute('r', 16);
      node.setAttribute('class', 'node');
      svg.appendChild(node);

      const label = document.createElementNS(svg.namespaceURI, 'text');
      label.setAttribute('x', x);
      label.setAttribute('y', y + 4);
      label.setAttribute('text-anchor', 'middle');
      label.setAttribute('class', 'label');
      label.textContent = String(i);
      svg.appendChild(label);

      node.addEventListener('click', () => {
        closeWeightEditor();
        if (selectingNode == null) {
          selectingNode = i;
          el.graphStatus.textContent = `Selected ${i}. Click another node to toggle edge.`;
          el.graphStatus.style.borderColor = '#2563eb';
        } else {
          const j = i;
          const a = selectingNode;
          selectingNode = null;
          el.graphStatus.textContent = 'Ready';
          el.graphStatus.style.borderColor = '#263143';
          if (!allowLoops && a === j) return;
          // Toggle or set edge between a -> j (and j -> a for undirected)
          if (!isWeighted) {
            const newVal = A[a][j] === 0 ? 1 : 0;
            setEdge(a, j, newVal);
          } else {
            // If no edge, set weight 1, else open editor
            if (A[a][j] === 0) setEdge(a, j, 1);
            else openWeightEditorAtPoint(x, y, a, j, A[a][j], true);
          }
          renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();
        }
      });
    }

    el.graphArea.appendChild(svg);
  }

  function openWeightEditorAtPoint(clientX, clientY, i, j, currentVal, localCoords = false) {
    el.weightEditor.style.display = 'block';
    const offsetX = 12, offsetY = 12;
    if (!localCoords) {
      el.weightEditor.style.left = `${clientX + window.scrollX + offsetX}px`;
      el.weightEditor.style.top = `${clientY + window.scrollY + offsetY}px`;
    } else {
      el.weightEditor.style.left = `${clientX + offsetX}px`;
      el.weightEditor.style.top = `${clientY + offsetY}px`;
    }
    el.weightInput.value = currentVal || 1;
    el.weightEdgeText.textContent = `${i} → ${j}`;
    el.weightEditor.dataset.i = String(i);
    el.weightEditor.dataset.j = String(j);
  }

  function computePositions(n, w, h, mode) {
    const positions = [];
    if (mode === 'circle') {
      const cx = w / 2, cy = h / 2;
      const R = Math.min(w, h) * 0.38;
      for (let i = 0; i < n; i++) {
        const theta = (2 * Math.PI * i) / n - Math.PI / 2;
        const x = cx + R * Math.cos(theta);
        const y = cy + R * Math.sin(theta);
        positions.push([x, y]);
      }
    } else {
      // grid layout
      const cols = Math.ceil(Math.sqrt(n));
      const rows = Math.ceil(n / cols);
      const padX = 30, padY = 30;
      const cellW = (w - padX * 2) / Math.max(cols, 1);
      const cellH = (h - padY * 2) / Math.max(rows, 1);
      for (let i = 0; i < n; i++) {
        const r = Math.floor(i / cols);
        const c = i % cols;
        const x = padX + cellW * (c + 0.5);
        const y = padY + cellH * (r + 0.5);
        positions.push([x, y]);
      }
    }
    return positions;
  }

  function updateStats() {
    el.statN.textContent = String(n);
    const m = countEdges();
    el.statM.textContent = String(m);
    const maxEdges = isDirected ? (allowLoops ? n * n : n * (n - 1)) : (allowLoops ? (n * (n - 1)) / 2 + n : (n * (n - 1)) / 2);
    const density = maxEdges ? (m / maxEdges) : 0;
    el.statD.textContent = density.toFixed(3);
  }

  function countEdges() {
    let m = 0;
    if (isDirected) {
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if (A[i][j] !== 0) m++;
        }
      }
    } else {
      for (let i = 0; i < n; i++) {
        for (let j = i; j < n; j++) {
          if (A[i][j] !== 0) m++;
        }
      }
    }
    return m;
  }

  function renderLists() {
    // Degree list
    let lines = [];
    if (!isDirected) {
      for (let i = 0; i < n; i++) {
        let deg = 0;
        for (let j = 0; j < n; j++) {
          if (A[i][j] !== 0) {
            if (i === j) deg += allowLoops ? 2 : 0;
            else deg += 1;
          }
        }
        lines.push(`deg(${i}) = ${deg}`);
      }
    } else {
      for (let i = 0; i < n; i++) {
        let out = 0, in = 0;
        for (let j = 0; j < n; j++) {
          if (A[i][j] !== 0) out++;
          if (A[j][i] !== 0) in++;
        }
        lines.push(`out(${i}) = ${out}, in(${i}) = ${in}`);
      }
    }
    el.degreeList.textContent = lines.join('\n');

    // Adjacency list
    const adjLines = [];
    for (let i = 0; i < n; i++) {
      const neighbors = [];
      for (let j = 0; j < n; j++) {
        const w = A[i][j];
        if (w !== 0) {
          neighbors.push(isWeighted ? `${j}(${w})` : `${j}`);
        }
      }
      adjLines.push(`${i}: ${neighbors.join(', ')}`);
    }
    el.adjacencyList.textContent = adjLines.join('\n');
  }

  function highlightRowCol(idx) {
    // Matrix: add highlight outline and scroll into view
    const table = el.matrixTable;
    const rows = table.querySelectorAll('tbody tr');
    if (rows[idx]) {
      rows[idx].style.outline = '2px dashed #22d3ee';
      setTimeout(() => { rows[idx].style.outline = ''; }, 1800);
      rows[idx].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
    }
    // Highlight column header
    const headers = table.querySelectorAll('thead th');
    if (headers[idx + 1]) {
      headers[idx + 1].style.outline = '2px dashed #22d3ee';
      setTimeout(() => { headers[idx + 1].style.outline = ''; }, 1800);
    }
    // Graph: flash node
    flashNode(idx);
  }

  function flashNode(idx) {
    const svg = el.graphArea.querySelector('svg');
    if (!svg) return;
    const circles = svg.querySelectorAll('circle');
    if (!circles[idx]) return;
    const node = circles[idx];
    const orig = node.getAttribute('fill');
    node.setAttribute('fill', '#22d3ee');
    setTimeout(() => node.setAttribute('fill', '#1f6fe0'), 700);
  }

  function renderPower() {
    const k = clamp(parseInt(el.powerK.value, 10) || 2, 2, 6);
    const Ak = matrixPower(A, k);
    const table = el.powerMatrix;
    table.innerHTML = '';
    const thead = document.createElement('thead');
    const trh = document.createElement('tr');
    const corner = document.createElement('th');
    corner.textContent = `A^${k}`;
    trh.appendChild(corner);
    for (let j = 0; j < n; j++) {
      const th = document.createElement('th');
      th.textContent = j;
      trh.appendChild(th);
    }
    thead.appendChild(trh);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    for (let i = 0; i < n; i++) {
      const tr = document.createElement('tr');
      const th = document.createElement('th');
      th.textContent = i;
      tr.appendChild(th);
      for (let j = 0; j < n; j++) {
        const td = document.createElement('td');
        td.textContent = String(Ak[i][j]);
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);
  }

  function matrixMultiply(X, Y) {
    const size = X.length;
    const Z = createZeroMatrix(size);
    for (let i = 0; i < size; i++) {
      for (let k = 0; k < size; k++) {
        const xik = X[i][k];
        if (xik === 0) continue;
        for (let j = 0; j < size; j++) {
          const ykj = Y[k][j];
          if (ykj === 0) continue;
          Z[i][j] += xik * ykj;
        }
      }
    }
    return Z;
  }

  function matrixPower(M, k) {
    let R = copyMatrix(M);
    for (let i = 1; i < k; i++) {
      R = matrixMultiply(R, M);
    }
    return R;
  }

  function copyMatrix(M) {
    const size = M.length;
    const C = new Array(size);
    for (let i = 0; i < size; i++) C[i] = M[i].slice();
    return C;
  }

  // Start
  init();

})();
</script>
</body>
</html>