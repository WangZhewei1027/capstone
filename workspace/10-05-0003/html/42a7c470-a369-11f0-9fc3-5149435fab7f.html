<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Red-Black Tree Visualizer</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --accent: #3b82f6;
    --ok: #10b981;
    --warn: #f59e0b;
    --err: #ef4444;
    --text: #e5e7eb;
    --muted: #9ca3af;
  }
  html, body {
    margin: 0; padding: 0; background: var(--bg); color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    height: 100%;
  }
  header {
    padding: 16px 20px;
    border-bottom: 1px solid #1f2937;
    background: linear-gradient(180deg, rgba(59,130,246,0.08), transparent);
  }
  header h1 {
    margin: 0 0 6px 0;
    font-size: 22px;
    letter-spacing: 0.2px;
  }
  header p {
    margin: 0;
    color: var(--muted);
    font-size: 13px;
  }
  .container {
    display: grid;
    grid-template-columns: 360px 1fr;
    gap: 12px;
    height: calc(100% - 72px);
  }
  .side {
    border-right: 1px solid #1f2937;
    padding: 12px;
    overflow: auto;
  }
  .main {
    padding: 10px;
    overflow: auto;
    position: relative;
  }
  .card {
    background: var(--panel);
    border: 1px solid #1f2937;
    border-radius: 10px;
    padding: 12px;
    margin-bottom: 12px;
  }
  .card h2 {
    margin: 0 0 8px 0;
    font-size: 16px;
    color: #d1d5db;
  }
  .row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items: center;
  }
  .row + .row { margin-top: 8px; }
  input[type="number"], input[type="text"] {
    background: #0b1220;
    color: var(--text);
    border: 1px solid #1f2937;
    border-radius: 8px;
    padding: 8px 10px;
    outline: none;
    min-width: 0;
  }
  input[type="number"]:focus, input[type="text"]:focus {
    border-color: var(--accent);
  }
  button {
    background: #111827;
    color: var(--text);
    border: 1px solid #374151;
    border-radius: 8px;
    padding: 8px 12px;
    cursor: pointer;
    transition: 0.15s ease;
  }
  button.primary {
    background: var(--accent);
    border-color: var(--accent);
    color: white;
  }
  button:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.35);
  }
  button:active { transform: translateY(0); }
  .small {
    font-size: 12px;
    color: var(--muted);
    margin-top: 6px;
  }
  .status {
    display: grid;
    grid-template-columns: repeat(2, minmax(0,1fr));
    gap: 8px;
  }
  .badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 8px;
    background: #0b1220;
    border: 1px solid #1f2937;
    border-radius: 8px;
    font-size: 12px;
  }
  .dot {
    width: 8px; height: 8px; border-radius: 50%;
  }
  .ok { background: var(--ok); }
  .warn { background: var(--warn); }
  .err { background: var(--err); }
  .msg {
    padding: 8px 10px;
    border-radius: 8px;
    background: #0b1220;
    border: 1px solid #1f2937;
    min-height: 20px;
    color: var(--muted);
    font-size: 13px;
  }
  .legend {
    display: flex; gap: 12px; align-items: center; color: var(--muted); font-size: 12px;
  }
  .swatch {
    width: 14px; height: 14px; border-radius: 50%; display: inline-block; margin-right: 6px;
    border: 2px solid rgba(255,255,255,0.2);
  }
  .swatch.red { background: #ef4444; }
  .swatch.black { background: #111827; border-color: #4b5563; }
  .toggle {
    display: inline-flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;
  }
  .toggle input { width: 16px; height: 16px; }
  .svg-wrapper {
    background: #0b1220;
    border: 1px solid #1f2937;
    border-radius: 10px;
    overflow: hidden;
    position: relative;
  }
  svg { display: block; width: 100%; height: 600px; }
  .footer {
    padding: 10px 20px; color: var(--muted); font-size: 12px; border-top: 1px solid #1f2937;
  }
  .kbd {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    background: #0b1220; border: 1px solid #1f2937; padding: 1px 5px; border-radius: 6px; color: #cbd5e1; font-size: 12px;
  }
</style>
</head>
<body>
  <header>
    <h1>Red-Black Tree Visualizer</h1>
    <p>Insert, delete, and search keys while the tree maintains balance via rotations and recoloring. Colors: Red nodes, Black nodes.</p>
  </header>

  <div class="container">
    <aside class="side">
      <div class="card">
        <h2>Operations</h2>
        <div class="row">
          <input id="keyInput" type="number" placeholder="Key (number)" />
          <button id="insertBtn" class="primary">Insert</button>
          <button id="deleteBtn">Delete</button>
          <button id="findBtn">Find</button>
        </div>
        <div class="row">
          <button id="randomBtn">Insert Random</button>
          <input id="randomCount" type="number" value="10" min="1" max="200" title="Number of nodes" />
          <button id="buildRandomBtn">Build Random</button>
          <button id="clearBtn">Clear</button>
        </div>
        <div class="row">
          <label class="toggle"><input type="checkbox" id="showNil"> Show NIL leaves</label>
          <label class="toggle"><input type="checkbox" id="autoCheck" checked> Auto-check properties</label>
        </div>
        <div class="small">Tip: Press Enter to insert. Use Delete key to remove the current value.</div>
      </div>

      <div class="card">
        <h2>Status</h2>
        <div class="status" id="statusGrid">
          <!-- Filled by JS -->
        </div>
      </div>

      <div class="card">
        <h2>Messages</h2>
        <div class="msg" id="message">Ready.</div>
      </div>

      <div class="card">
        <h2>About Red-Black Trees</h2>
        <ul class="small">
          <li>Every node is either red or black.</li>
          <li>The root is black.</li>
          <li>All leaves (NIL sentinels) are black.</li>
          <li>Red nodes have black children (no two reds in a row).</li>
          <li>Every path from a node to descendant NIL nodes has the same number of black nodes (equal black-height).</li>
        </ul>
      </div>
    </aside>

    <main class="main">
      <div class="row" style="justify-content: space-between; margin-bottom: 8px;">
        <div class="legend">
          <span><span class="swatch red"></span>Red</span>
          <span><span class="swatch black"></span>Black</span>
          <span style="display:inline-flex;align-items:center;gap:6px;"><span class="swatch" style="background:transparent;border-radius:50%; width:14px; height:14px; border:3px solid #f59e0b;"></span>Highlight</span>
        </div>
        <div class="small">Nodes auto-spaced; zoom with browser. Resize window to fit.</div>
      </div>
      <div class="svg-wrapper">
        <svg id="treeSvg" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet"></svg>
      </div>
    </main>
  </div>

  <div class="footer">
    Keyboard shortcuts: Enter = Insert, Shift+Enter = Find, Delete/Backspace = Delete. Use Tab to focus fields. 
    Example sequence: 10, 5, 15, 1, 7, 12, 18, 0, 2, 6, 8
  </div>

<script>
(function() {
  "use strict";

  // Colors
  const RED = 0;
  const BLACK = 1;

  // Utilities
  const $ = sel => document.querySelector(sel);
  const svgNS = "http://www.w3.org/2000/svg";

  function createSvg(tag, attrs={}) {
    const el = document.createElementNS(svgNS, tag);
    for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
    return el;
  }

  // Red-Black Tree implementation (CLRS-style with a single NIL sentinel)
  let NODE_ID_COUNTER = 1;
  class RBNode {
    constructor(key, color, left, right, parent) {
      this.id = NODE_ID_COUNTER++;
      this.key = key;
      this.color = color;
      this.left = left;
      this.right = right;
      this.parent = parent;
      // layout fields
      this._lw = 0;
      this._rw = 0;
      this._w = 1;
      this._xUnit = 0;
      this._depth = 0;
    }
  }

  class RBTree {
    constructor() {
      this.NIL = new RBNode(null, BLACK, null, null, null);
      this.NIL.left = this.NIL.right = this.NIL.parent = this.NIL;
      this.root = this.NIL;
      this.size = 0;
    }

    leftRotate(x) {
      const y = x.right;
      x.right = y.left;
      if (y.left !== this.NIL) {
        y.left.parent = x;
      }
      y.parent = x.parent;
      if (x.parent === this.NIL) {
        this.root = y;
      } else if (x === x.parent.left) {
        x.parent.left = y;
      } else {
        x.parent.right = y;
      }
      y.left = x;
      x.parent = y;
    }

    rightRotate(x) {
      const y = x.left;
      x.left = y.right;
      if (y.right !== this.NIL) {
        y.right.parent = x;
      }
      y.parent = x.parent;
      if (x.parent === this.NIL) {
        this.root = y;
      } else if (x === x.parent.right) {
        x.parent.right = y;
      } else {
        x.parent.left = y;
      }
      y.right = x;
      x.parent = y;
    }

    insert(key) {
      // Prevent NaN
      if (key == null || Number.isNaN(key)) return { ok: false, reason: "Invalid key." };
      let z = new RBNode(key, RED, this.NIL, this.NIL, this.NIL);
      let y = this.NIL;
      let x = this.root;

      while (x !== this.NIL) {
        y = x;
        if (z.key === x.key) {
          return { ok: false, reason: "Duplicate keys are not allowed." };
        } else if (z.key < x.key) {
          x = x.left;
        } else {
          x = x.right;
        }
      }

      z.parent = y;
      if (y === this.NIL) {
        this.root = z;
      } else if (z.key < y.key) {
        y.left = z;
      } else {
        y.right = z;
      }

      z.left = this.NIL;
      z.right = this.NIL;
      z.color = RED;
      this.size++;
      this.insertFixup(z);
      return { ok: true, node: z };
    }

    insertFixup(z) {
      while (z.parent.color === RED) {
        if (z.parent === z.parent.parent.left) {
          let y = z.parent.parent.right;
          if (y.color === RED) {
            // Case 1
            z.parent.color = BLACK;
            y.color = BLACK;
            z.parent.parent.color = RED;
            z = z.parent.parent;
          } else {
            if (z === z.parent.right) {
              // Case 2
              z = z.parent;
              this.leftRotate(z);
            }
            // Case 3
            z.parent.color = BLACK;
            z.parent.parent.color = RED;
            this.rightRotate(z.parent.parent);
          }
        } else {
          // Mirror cases
          let y = z.parent.parent.left;
          if (y.color === RED) {
            z.parent.color = BLACK;
            y.color = BLACK;
            z.parent.parent.color = RED;
            z = z.parent.parent;
          } else {
            if (z === z.parent.left) {
              z = z.parent;
              this.rightRotate(z);
            }
            z.parent.color = BLACK;
            z.parent.parent.color = RED;
            this.leftRotate(z.parent.parent);
          }
        }
      }
      this.root.color = BLACK;
    }

    transplant(u, v) {
      if (u.parent === this.NIL) {
        this.root = v;
      } else if (u === u.parent.left) {
        u.parent.left = v;
      } else {
        u.parent.right = v;
      }
      v.parent = u.parent;
    }

    treeMinimum(x) {
      while (x.left !== this.NIL) x = x.left;
      return x;
    }

    findNode(key) {
      let x = this.root;
      while (x !== this.NIL) {
        if (key === x.key) return x;
        x = (key < x.key) ? x.left : x.right;
      }
      return this.NIL;
    }

    delete(key) {
      const z = this.findNode(key);
      if (z === this.NIL) return { ok: false, reason: "Key not found." };

      let y = z;
      let yOriginalColor = y.color;
      let x;

      if (z.left === this.NIL) {
        x = z.right;
        this.transplant(z, z.right);
      } else if (z.right === this.NIL) {
        x = z.left;
        this.transplant(z, z.left);
      } else {
        y = this.treeMinimum(z.right);
        yOriginalColor = y.color;
        x = y.right;
        if (y.parent === z) {
          x.parent = y;
        } else {
          this.transplant(y, y.right);
          y.right = z.right;
          y.right.parent = y;
        }
        this.transplant(z, y);
        y.left = z.left;
        y.left.parent = y;
        y.color = z.color;
      }

      if (yOriginalColor === BLACK) {
        this.deleteFixup(x);
      }

      this.size--;
      return { ok: true, removed: z };
    }

    deleteFixup(x) {
      while (x !== this.root && x.color === BLACK) {
        if (x === x.parent.left) {
          let w = x.parent.right;
          if (w.color === RED) {
            w.color = BLACK;
            x.parent.color = RED;
            this.leftRotate(x.parent);
            w = x.parent.right;
          }
          if (w.left.color === BLACK && w.right.color === BLACK) {
            w.color = RED;
            x = x.parent;
          } else {
            if (w.right.color === BLACK) {
              w.left.color = BLACK;
              w.color = RED;
              this.rightRotate(w);
              w = x.parent.right;
            }
            w.color = x.parent.color;
            x.parent.color = BLACK;
            w.right.color = BLACK;
            this.leftRotate(x.parent);
            x = this.root;
          }
        } else {
          let w = x.parent.left;
          if (w.color === RED) {
            w.color = BLACK;
            x.parent.color = RED;
            this.rightRotate(x.parent);
            w = x.parent.left;
          }
          if (w.right.color === BLACK && w.left.color === BLACK) {
            w.color = RED;
            x = x.parent;
          } else {
            if (w.left.color === BLACK) {
              w.right.color = BLACK;
              w.color = RED;
              this.leftRotate(w);
              w = x.parent.left;
            }
            w.color = x.parent.color;
            x.parent.color = BLACK;
            w.left.color = BLACK;
            this.rightRotate(x.parent);
            x = this.root;
          }
        }
      }
      x.color = BLACK;
    }
  }

  // Visualization and UI
  const tree = new RBTree();
  const svg = $("#treeSvg");
  const msg = $("#message");
  const statusGrid = $("#statusGrid");
  const showNilChk = $("#showNil");
  const autoCheckChk = $("#autoCheck");

  let lastHighlightNode = null;

  function setMessage(text, type="info") {
    msg.textContent = text;
    msg.style.color = (type === "error") ? "#fecaca" : (type === "ok" ? "#bbf7d0" : "#9ca3af");
    msg.style.borderColor = (type === "error") ? "#7f1d1d" : (type === "ok" ? "#14532d" : "#1f2937");
  }

  // Layout computation
  function computeWidths(node) {
    if (node === tree.NIL) return 0;
    node._lw = computeWidths(node.left);
    node._rw = computeWidths(node.right);
    node._w = Math.max(1, node._lw + node._rw + 1);
    return node._w;
  }

  function assignPositions(node, depth, xMin) {
    if (node === tree.NIL) return;
    node._depth = depth;
    const x = xMin + node._lw;
    node._xUnit = x;
    assignPositions(node.left, depth + 1, xMin);
    assignPositions(node.right, depth + 1, x + 1);
  }

  function collectNodes(node, arr=[]) {
    if (node === tree.NIL) return arr;
    arr.push(node);
    collectNodes(node.left, arr);
    collectNodes(node.right, arr);
    return arr;
  }

  function render() {
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    if (tree.root === tree.NIL) {
      const t = createSvg("text", { x: 20, y: 30, fill: "#94a3b8", "font-size": "14" });
      t.textContent = "Tree is empty.";
      svg.appendChild(t);
      updateStatus();
      return;
    }

    // Layout
    const units = computeWidths(tree.root);
    assignPositions(tree.root, 0, 0);
    const nodes = collectNodes(tree.root);

    const levelCount = Math.max(...nodes.map(n => n._depth)) + 1;
    const nodeRadius = 16;
    const unitX = 40;     // horizontal spacing per unit
    const levelY = 80;    // vertical spacing per level
    const margin = 30;

    const width = Math.max(600, units * unitX + margin * 2);
    const height = Math.max(200, levelCount * levelY + margin * 2);

    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);

    // Helper to get pixel coords
    function px(n) {
      return {
        x: margin + n._xUnit * unitX,
        y: margin + n._depth * levelY
      };
    }

    // Draw edges first
    function drawEdges(node) {
      if (node === tree.NIL) return;
      const p1 = px(node);
      if (node.left !== tree.NIL) {
        const p2 = px(node.left);
        const line = createSvg("line", {
          x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y,
          stroke: "#4b5563", "stroke-width": 2
        });
        svg.appendChild(line);
      } else if (showNilChk.checked) {
        // draw NIL left
        const p2 = { x: p1.x - unitX/2, y: p1.y + levelY/2 };
        const r = 6;
        const rect = createSvg("rect", {
          x: p2.x - r, y: p2.y - r, width: r*2, height: r*2, rx: 2,
          fill: "#111827", stroke: "#374151", "stroke-width": 1
        });
        const guide = createSvg("line", { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, stroke: "#374151", "stroke-dasharray": "4 3" });
        svg.appendChild(guide);
        svg.appendChild(rect);
      }
      if (node.right !== tree.NIL) {
        const p2 = px(node.right);
        const line = createSvg("line", {
          x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y,
          stroke: "#4b5563", "stroke-width": 2
        });
        svg.appendChild(line);
      } else if (showNilChk.checked) {
        // draw NIL right
        const p2 = { x: p1.x + unitX/2, y: p1.y + levelY/2 };
        const r = 6;
        const rect = createSvg("rect", {
          x: p2.x - r, y: p2.y - r, width: r*2, height: r*2, rx: 2,
          fill: "#111827", stroke: "#374151", "stroke-width": 1
        });
        const guide = createSvg("line", { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, stroke: "#374151", "stroke-dasharray": "4 3" });
        svg.appendChild(guide);
        svg.appendChild(rect);
      }
      drawEdges(node.left);
      drawEdges(node.right);
    }
    drawEdges(tree.root);

    // Draw nodes
    for (const n of nodes) {
      const { x, y } = px(n);

      // Highlight ring (if matches last highlight)
      if (lastHighlightNode && n === lastHighlightNode) {
        const ring = createSvg("circle", {
          cx: x, cy: y, r: nodeRadius + 6,
          fill: "none", stroke: "#f59e0b", "stroke-width": 3
        });
        svg.appendChild(ring);
      }

      const fill = (n.color === RED) ? "#ef4444" : "#111827";
      const stroke = (n.color === RED) ? "#7f1d1d" : "#4b5563";
      const textFill = (n.color === RED) ? "#1f2937" : "#e5e7eb";

      const circle = createSvg("circle", {
        cx: x, cy: y, r: nodeRadius,
        fill, stroke, "stroke-width": 2
      });
      circle.style.cursor = "pointer";
      circle.addEventListener("mouseenter", () => {
        circle.setAttribute("stroke", "#3b82f6");
      });
      circle.addEventListener("mouseleave", () => {
        circle.setAttribute("stroke", stroke);
      });
      circle.addEventListener("click", () => {
        lastHighlightNode = n;
        render();
        setMessage(`Selected node ${n.key} (${n.color === RED ? "RED" : "BLACK"}).`);
      });

      const label = createSvg("text", {
        x, y: y + 4, "text-anchor": "middle", "font-size": "13",
        fill: textFill
      });
      label.textContent = String(n.key);

      svg.appendChild(circle);
      svg.appendChild(label);
    }

    if (autoCheckChk.checked) updateStatus();
  }

  function validateProperties() {
    // BST property
    function isBST(node, min, max) {
      if (node === tree.NIL) return true;
      if (!(node.key > min && node.key < max)) return false;
      return isBST(node.left, min, node.key) && isBST(node.right, node.key, max);
    }

    // Root black
    const rootBlack = (tree.root === tree.NIL) ? true : (tree.root.color === BLACK);

    // Red node has black children
    function redsOk(node) {
      if (node === tree.NIL) return true;
      if (node.color === RED) {
        if (!(node.left.color === BLACK && node.right.color === BLACK)) return false;
      }
      return redsOk(node.left) && redsOk(node.right);
    }

    // Equal black height
    function blackHeights(node) {
      if (node === tree.NIL) return [1]; // NIL counts as black
      const left = blackHeights(node.left);
      const right = blackHeights(node.right);
      const add = (node.color === BLACK) ? 1 : 0;
      const res = [];
      for (const v of left) res.push(v + add);
      for (const v of right) res.push(v + add);
      return res;
    }

    const isBstOk = isBST(tree.root, -Infinity, Infinity);
    const redsAreOk = redsOk(tree.root);
    const bhList = blackHeights(tree.root);
    const bhSet = new Set(bhList);
    const bhOk = bhSet.size <= 1; // All equal
    const bhVal = (bhList.length ? bhList[0] : 0);

    return {
      size: tree.size,
      rootBlack,
      redsAreOk,
      bhOk,
      bhVal,
      isBstOk
    };
  }

  function updateStatus() {
    const s = validateProperties();
    statusGrid.innerHTML = "";

    function addBadge(ok, label, type) {
      const div = document.createElement("div");
      div.className = "badge";
      const dot = document.createElement("span");
      dot.className = "dot " + (ok ? "ok" : (type === "warn" ? "warn" : "err"));
      const txt = document.createElement("span");
      txt.textContent = label + ": " + (ok ? "OK" : "Fail");
      div.appendChild(dot);
      div.appendChild(txt);
      statusGrid.appendChild(div);
    }

    function addInfo(label, value) {
      const div = document.createElement("div");
      div.className = "badge";
      const dot = document.createElement("span");
      dot.className = "dot ok";
      const txt = document.createElement("span");
      txt.textContent = label + ": " + value;
      div.appendChild(dot);
      div.appendChild(txt);
      statusGrid.appendChild(div);
    }

    addInfo("Nodes", s.size);
    addInfo("Black-height", s.bhVal);
    addBadge(s.isBstOk, "BST property");
    addBadge(s.rootBlack, "Root is black");
    addBadge(s.redsAreOk, "No red-red");
    addBadge(s.bhOk, "Equal black-height");
  }

  // UI Handlers
  const keyInput = $("#keyInput");
  const insertBtn = $("#insertBtn");
  const deleteBtn = $("#deleteBtn");
  const findBtn = $("#findBtn");
  const randomBtn = $("#randomBtn");
  const buildRandomBtn = $("#buildRandomBtn");
  const randomCountInput = $("#randomCount");
  const clearBtn = $("#clearBtn");

  function parseKey() {
    const v = keyInput.value.trim();
    if (v === "") return { ok: false, reason: "Enter a number." };
    const n = Number(v);
    if (!Number.isFinite(n)) return { ok: false, reason: "Invalid number." };
    return { ok: true, value: n };
  }

  function doInsert() {
    const p = parseKey();
    if (!p.ok) { setMessage(p.reason, "error"); return; }
    const res = tree.insert(p.value);
    if (res.ok) {
      lastHighlightNode = res.node;
      render();
      setMessage(`Inserted ${p.value}.`, "ok");
    } else {
      setMessage(res.reason || "Insert failed.", "error");
    }
  }

  function doDelete() {
    const p = parseKey();
    if (!p.ok) { setMessage(p.reason, "error"); return; }
    const res = tree.delete(p.value);
    if (res.ok) {
      lastHighlightNode = null;
      render();
      setMessage(`Deleted ${p.value}.`, "ok");
    } else {
      setMessage(res.reason || "Delete failed.", "error");
    }
  }

  function doFind() {
    const p = parseKey();
    if (!p.ok) { setMessage(p.reason, "error"); return; }
    const n = tree.findNode(p.value);
    if (n !== tree.NIL) {
      lastHighlightNode = n;
      render();
      setMessage(`Found ${p.value}.`, "ok");
    } else {
      setMessage(`${p.value} not found.`, "error");
      lastHighlightNode = null;
      render();
    }
  }

  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function insertRandomUnique() {
    let tries = 0;
    let k = 0;
    let res;
    do {
      k = randInt(-99, 99);
      res = tree.insert(k);
      tries++;
      if (tries > 500) break;
    } while (!res.ok);
    if (res.ok) {
      lastHighlightNode = res.node;
      render();
      setMessage(`Inserted random ${k}.`, "ok");
    } else {
      setMessage("Failed to insert random number.", "error");
    }
  }

  function buildRandom() {
    const n = Number(randomCountInput.value || 0);
    if (!(n > 0 && n <= 1000)) {
      setMessage("Enter a random size between 1 and 1000.", "error");
      return;
    }
    // Clear
    tree.root = tree.NIL;
    tree.size = 0;
    lastHighlightNode = null;

    const used = new Set();
    let i = 0, tries = 0;
    while (i < n && tries < n * 10) {
      const k = randInt(-999, 999);
      tries++;
      if (used.has(k)) continue;
      const res = tree.insert(k);
      if (res.ok) {
        used.add(k);
        i++;
      }
    }
    render();
    setMessage(`Built random tree with ${tree.size} nodes.`, "ok");
  }

  function clearTree() {
    tree.root = tree.NIL;
    tree.size = 0;
    lastHighlightNode = null;
    render();
    setMessage("Cleared tree.", "ok");
  }

  // Event listeners
  insertBtn.addEventListener("click", doInsert);
  deleteBtn.addEventListener("click", doDelete);
  findBtn.addEventListener("click", doFind);
  randomBtn.addEventListener("click", insertRandomUnique);
  buildRandomBtn.addEventListener("click", buildRandom);
  clearBtn.addEventListener("click", clearTree);
  showNilChk.addEventListener("change", render);
  autoCheckChk.addEventListener("change", updateStatus);

  keyInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      doInsert();
    } else if (e.key === "Enter" && e.shiftKey) {
      doFind();
    } else if (e.key === "Delete" || e.key === "Backspace") {
      if (keyInput.value.trim() !== "") {
        // Avoid default backspace navigation on empty
        e.preventDefault();
        doDelete();
      }
    }
  });

  // Initial demo
  function seedDemo() {
    const seq = [10, 5, 15, 1, 7, 12, 18, 0, 2, 6, 8];
    for (const k of seq) tree.insert(k);
    lastHighlightNode = tree.findNode(7);
  }

  seedDemo();
  render();
  setMessage("Ready. Insert numbers and observe rotations and recoloring in action.");

})();
</script>
</body>
</html>