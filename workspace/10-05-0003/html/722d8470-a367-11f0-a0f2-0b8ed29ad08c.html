<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Linked List Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-2: #0b1220;
      --muted: #8aa1b4;
      --text: #e5eef6;
      --accent: #4f46e5;
      --accent-2: #22c55e;
      --danger: #ef4444;
      --warn: #eab308;
      --node: #162238;
      --node-border: #2d3b52;
      --node-highlight: #0ea5e9;
      --shadow: rgba(0,0,0,0.25);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(1200px 500px at 20% -20%, #17375a, transparent), var(--bg);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      min-height: 100vh;
      display: grid;
      grid-template-rows: auto 1fr auto;
    }
    header {
      padding: 18px 20px 10px;
    }
    h1 {
      font-size: 20px;
      margin: 0;
      letter-spacing: 0.25px;
      display: flex;
      align-items: center;
      gap: 10px;
      color: #f3f6fb;
    }
    h1 span.badge {
      font-size: 12px;
      font-weight: 600;
      color: #a2b7cc;
      background: #0f1c2f;
      border: 1px solid #1f2d43;
      padding: 2px 8px;
      border-radius: 999px;
    }
    main {
      display: grid;
      grid-template-columns: 340px 1fr;
      gap: 16px;
      padding: 0 16px 16px;
    }
    @media (max-width: 980px) {
      main {
        grid-template-columns: 1fr;
      }
    }
    .panel {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid #1c2740;
      border-radius: 14px;
      box-shadow: 0 20px 40px var(--shadow), inset 0 1px 0 rgba(255,255,255,0.04);
    }
    .controls {
      padding: 16px;
      display: grid;
      gap: 14px;
    }
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .row-3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    input[type="text"], input[type="number"] {
      width: 100%;
      padding: 10px 12px;
      font-size: 14px;
      color: var(--text);
      background: #0d1628;
      border: 1px solid #1b2b48;
      border-radius: 10px;
      outline: none;
      transition: border 0.15s;
    }
    input[type="text"]:focus, input[type="number"]:focus {
      border-color: #2f58a8;
    }
    input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }
    .btn {
      padding: 10px 12px;
      font-size: 14px;
      border: 1px solid #1b2b48;
      background: #0f1a2e;
      color: var(--text);
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.05s ease, border 0.2s, background 0.2s;
      user-select: none;
    }
    .btn:hover { border-color: #2b4a86; background: #0f1d34; }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background: linear-gradient(180deg, #2b38c5, #4f46e5); border-color: transparent; }
    .btn.primary:hover { filter: brightness(1.05); }
    .btn.success { background: linear-gradient(180deg, #119a48, #22c55e); border-color: transparent; color: white; }
    .btn.warn { background: linear-gradient(180deg, #c19106, #eab308); border-color: transparent; color: #0a0f19; }
    .btn.danger { background: linear-gradient(180deg, #b32d2d, #ef4444); border-color: transparent; color: white; }
    .btn.ghost { background: transparent; border-color: #263551; }
    .btn.block { width: 100%; }
    .meta {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }
    .stat {
      background: #0d1628;
      border: 1px solid #1b2b48;
      border-radius: 10px;
      padding: 10px 12px;
    }
    .stat .label { color: var(--muted); font-size: 12px; }
    .stat .value { font-size: 16px; font-weight: 700; margin-top: 4px; }
    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 14px;
      font-size: 12px;
      color: var(--muted);
      padding: 0 16px 12px 16px;
    }
    .key { display: inline-flex; align-items: center; gap: 6px; }
    .swatch {
      width: 12px; height: 12px; border-radius: 3px; border: 1px solid #23334f;
    }
    .swatch.node { background: var(--node); }
    .swatch.highlight { background: var(--node-highlight); border-color: #1f6aa0; }
    .swatch.arrow { background: #2b3d61; }
    .vis-wrap {
      padding: 14px;
      overflow: auto;
    }
    .vis {
      background: radial-gradient(400px 200px at 80% -20%, #1a2e51, transparent), #0b1220;
      border: 1px solid #122038;
      border-radius: 12px;
      min-height: 160px;
      position: relative;
      overflow: auto;
    }
    svg {
      display: block;
      width: 100%;
      height: 100%;
      min-height: 160px;
    }
    .node rect {
      fill: var(--node);
      stroke: var(--node-border);
      stroke-width: 1.5px;
      filter: drop-shadow(0 4px 8px rgba(0,0,0,.35));
    }
    .node text {
      fill: #e9f0f9;
      font-size: 14px;
      font-weight: 600;
    }
    .node .index {
      fill: #8aa1b4;
      font-size: 11px;
      font-weight: 500;
    }
    .node.head rect { stroke: #22c55e; }
    .node.tail rect { stroke: #eab308; }
    .node.highlight rect { stroke: var(--node-highlight); stroke-width: 2.5px; }
    .arrow {
      stroke: #3b4e77;
      stroke-width: 2;
      fill: none;
      marker-end: url(#arrow);
      opacity: 0.9;
    }
    .null-label {
      fill: #93a4ba;
      font-size: 12px;
      font-weight: 600;
      opacity: 0.9;
    }
    .oplog {
      padding: 12px 16px 16px;
      border-top: 1px solid #18243a;
      color: var(--muted);
      font-size: 13px;
      display: grid;
      gap: 8px;
    }
    .oplog .line { color: #c3d3e3; }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: #0e1b2e;
      border: 1px solid #1b2b48;
      color: #bbcae0;
      font-size: 12px;
      font-weight: 600;
    }
    .chip .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--accent); }
    footer {
      color: var(--muted);
      font-size: 12px;
      padding: 10px 16px 18px;
      display: flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .small {
      font-size: 11px;
      color: #8aa1b4;
    }
    .hr {
      height: 1px;
      background: #1a2740;
      margin: 0 16px;
    }
  </style>
</head>
<body>
<header>
  <h1>
    Linked List Visualizer
    <span class="badge">Singly • Head/Tail • O(1) append/prepend</span>
  </h1>
</header>

<main>
  <section class="panel">
    <div class="controls">
      <div class="row">
        <div>
          <label for="valInput">Value</label>
          <input id="valInput" type="text" placeholder="e.g. 42 or Alice" />
        </div>
        <div>
          <label for="idxInput">Index</label>
          <input id="idxInput" type="number" min="0" step="1" placeholder="0-based" />
        </div>
      </div>

      <div class="row-3">
        <button id="prependBtn" class="btn">Prepend</button>
        <button id="appendBtn" class="btn">Append</button>
        <button id="insertBtn" class="btn">Insert at Index</button>
      </div>
      <div class="row-3">
        <button id="removeValBtn" class="btn">Remove Value</button>
        <button id="removeIdxBtn" class="btn">Remove at Index</button>
        <button id="searchBtn" class="btn">Search</button>
      </div>
      <div class="row-3">
        <button id="reverseBtn" class="btn success">Reverse</button>
        <button id="seedBtn" class="btn ghost">Seed Data</button>
        <button id="clearBtn" class="btn danger">Clear</button>
      </div>

      <div class="row">
        <div>
          <label for="speed">Animation Speed (ms between steps)</label>
          <input id="speed" type="range" min="50" max="1000" value="300" />
        </div>
        <div>
          <label>Complexity (last operation)</label>
          <div id="complexity" class="chip">
            <span class="dot"></span>
            <span>—</span>
          </div>
        </div>
      </div>

      <div class="meta">
        <div class="stat">
          <div class="label">Length</div>
          <div class="value" id="lenStat">0</div>
        </div>
        <div class="stat">
          <div class="label">Head</div>
          <div class="value" id="headStat">null</div>
        </div>
        <div class="stat">
          <div class="label">Tail</div>
          <div class="value" id="tailStat">null</div>
        </div>
      </div>
    </div>
    <div class="legend">
      <span class="key"><span class="swatch node"></span> Node</span>
      <span class="key"><span class="swatch highlight"></span> Traversal highlight</span>
      <span class="key"><span class="swatch arrow"></span> Next pointer</span>
    </div>
    <div class="vis-wrap">
      <div id="vis" class="vis">
        <svg id="svg" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#3b4e77"></path>
            </marker>
          </defs>
        </svg>
      </div>
    </div>
    <div class="oplog">
      <div class="line" id="opText">Ready.</div>
      <div class="small">Tip: Use Insert at Index to place a value at a specific position. Index 0 means the head. Append is O(1) thanks to the tail pointer.</div>
    </div>
  </section>

  <section class="panel">
    <div class="controls">
      <div>
        <div class="chip"><span class="dot" style="background: var(--accent-2)"></span>What is a Linked List?</div>
        <p class="small">
          A linked list is a sequence of nodes where each node holds a value and a reference (pointer) to the next node.
          Unlike arrays, linked lists do not require contiguous memory, making insertions/removals efficient at the front (O(1))
          and at known positions if you have a pointer. Random access is not supported; searching and indexing require traversal (O(n)).
        </p>
      </div>
      <div class="hr"></div>
      <div class="row">
        <div class="stat">
          <div class="label">Prepend</div>
          <div class="value">O(1)</div>
        </div>
        <div class="stat">
          <div class="label">Append</div>
          <div class="value">O(1) with tail</div>
        </div>
      </div>
      <div class="row">
        <div class="stat">
          <div class="label">Search / Find</div>
          <div class="value">O(n)</div>
        </div>
        <div class="stat">
          <div class="label">Remove by value</div>
          <div class="value">O(n)</div>
        </div>
      </div>
      <div class="row">
        <div class="stat">
          <div class="label">Insert at index</div>
          <div class="value">O(n)</div>
        </div>
        <div class="stat">
          <div class="label">Remove at index</div>
          <div class="value">O(n)</div>
        </div>
      </div>
      <div class="row">
        <div class="stat">
          <div class="label">Reverse</div>
          <div class="value">O(n) time, O(1) space</div>
        </div>
        <div class="stat">
          <div class="label">Clear</div>
          <div class="value">O(1)</div>
        </div>
      </div>
      <div class="hr"></div>
      <div class="small">
        Implementation details in this demo:
        - Singly linked list, storing head and tail references.
        - Append is constant time using the tail pointer.
        - Values are treated as strings for display.
      </div>
    </div>
  </section>
</main>

<footer>
  <div>Keyboard: Enter on value = append; Shift+Enter = prepend</div>
  <div>Animation speed slider controls traversal delay.</div>
</footer>

<script>
  // Data structures: Node and LinkedList
  class Node {
    constructor(value) {
      this.value = value;
      this.next = null;
    }
  }

  class LinkedList {
    constructor() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }

    isEmpty() {
      return this.length === 0;
    }

    prepend(value) {
      const node = new Node(value);
      if (this.isEmpty()) {
        this.head = this.tail = node;
      } else {
        node.next = this.head;
        this.head = node;
      }
      this.length++;
      return node;
    }

    append(value) {
      const node = new Node(value);
      if (this.isEmpty()) {
        this.head = this.tail = node;
      } else {
        this.tail.next = node;
        this.tail = node;
      }
      this.length++;
      return node;
    }

    insertAt(index, value) {
      if (index < 0 || index > this.length) {
        return { ok: false, reason: "Index out of bounds" };
      }
      if (index === 0) {
        this.prepend(value);
        return { ok: true, where: "head" };
      }
      if (index === this.length) {
        this.append(value);
        return { ok: true, where: "tail" };
      }
      const node = new Node(value);
      let prev = this.head;
      for (let i = 0; i < index - 1; i++) {
        prev = prev.next;
      }
      node.next = prev.next;
      prev.next = node;
      this.length++;
      return { ok: true, where: "middle" };
    }

    remove(value) {
      if (this.isEmpty()) return { ok: false, removed: null };
      // Remove head case
      if (this.head.value == value) {
        const removed = this.head;
        this.head = this.head.next;
        if (!this.head) this.tail = null;
        this.length--;
        return { ok: true, removed, index: 0 };
      }
      let prev = this.head;
      let idx = 0;
      while (prev && prev.next) {
        idx++;
        if (prev.next.value == value) {
          const removed = prev.next;
          prev.next = removed.next;
          if (removed === this.tail) this.tail = prev;
          this.length--;
          return { ok: true, removed, index: idx };
        }
        prev = prev.next;
      }
      return { ok: false, removed: null };
    }

    removeAt(index) {
      if (index < 0 || index >= this.length) return { ok: false, removed: null, reason: "Index out of bounds" };
      if (index === 0) {
        const removed = this.head;
        this.head = this.head.next;
        if (!this.head) this.tail = null;
        this.length--;
        return { ok: true, removed, index: 0 };
      }
      let prev = this.head;
      for (let i = 0; i < index - 1; i++) prev = prev.next;
      const removed = prev.next;
      prev.next = removed.next;
      if (removed === this.tail) this.tail = prev;
      this.length--;
      return { ok: true, removed, index };
    }

    find(value) {
      let cur = this.head;
      let i = 0;
      while (cur) {
        if (cur.value == value) return { ok: true, index: i, node: cur };
        cur = cur.next;
        i++;
      }
      return { ok: false, index: -1, node: null };
    }

    reverse() {
      let prev = null;
      let cur = this.head;
      this.tail = this.head;
      while (cur) {
        const next = cur.next;
        cur.next = prev;
        prev = cur;
        cur = next;
      }
      this.head = prev;
      return true;
    }

    clear() {
      this.head = this.tail = null;
      this.length = 0;
    }

    toArray() {
      const arr = [];
      let cur = this.head;
      while (cur) {
        arr.push(cur.value);
        cur = cur.next;
      }
      return arr;
    }
  }

  // UI/Visualization controller
  const list = new LinkedList();

  const svg = document.getElementById('svg');
  const vis = document.getElementById('vis');
  const valInput = document.getElementById('valInput');
  const idxInput = document.getElementById('idxInput');
  const speedInput = document.getElementById('speed');
  const prependBtn = document.getElementById('prependBtn');
  const appendBtn = document.getElementById('appendBtn');
  const insertBtn = document.getElementById('insertBtn');
  const removeValBtn = document.getElementById('removeValBtn');
  const removeIdxBtn = document.getElementById('removeIdxBtn');
  const searchBtn = document.getElementById('searchBtn');
  const reverseBtn = document.getElementById('reverseBtn');
  const seedBtn = document.getElementById('seedBtn');
  const clearBtn = document.getElementById('clearBtn');

  const lenStat = document.getElementById('lenStat');
  const headStat = document.getElementById('headStat');
  const tailStat = document.getElementById('tailStat');
  const opText = document.getElementById('opText');
  const complexity = document.getElementById('complexity');

  const NODE_W = 90;
  const NODE_H = 44;
  const GAP = 42;
  const MARGIN_X = 24;
  const MARGIN_Y = 30;

  function setOp(text, complexityText) {
    opText.textContent = text;
    complexity.querySelector('span:last-child').textContent = complexityText || '—';
  }

  function updateStats() {
    lenStat.textContent = list.length;
    headStat.textContent = list.head ? stringify(list.head.value) : 'null';
    tailStat.textContent = list.tail ? stringify(list.tail.value) : 'null';
  }

  function stringify(v) {
    return String(v);
  }

  function clearSVG() {
    while (svg.firstChild) {
      svg.removeChild(svg.firstChild);
    }
    // Re-add defs
    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    marker.setAttribute('id', 'arrow');
    marker.setAttribute('viewBox', '0 0 10 10');
    marker.setAttribute('refX', '9');
    marker.setAttribute('refY', '5');
    marker.setAttribute('markerWidth', '8');
    marker.setAttribute('markerHeight', '8');
    marker.setAttribute('orient', 'auto-start-reverse');
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
    path.setAttribute('fill', '#3b4e77');
    marker.appendChild(path);
    defs.appendChild(marker);
    svg.appendChild(defs);
  }

  function render() {
    clearSVG();

    const arr = list.toArray();
    const totalW = arr.length === 0 ? vis.clientWidth : MARGIN_X * 2 + arr.length * NODE_W + Math.max(0, arr.length - 1) * GAP + 60;
    const viewW = Math.max(totalW, vis.clientWidth);
    const viewH = Math.max(160, NODE_H + MARGIN_Y * 2);

    svg.setAttribute('width', viewW);
    svg.setAttribute('height', viewH);

    // Draw nodes and arrows
    for (let i = 0; i < arr.length; i++) {
      const x = MARGIN_X + i * (NODE_W + GAP);
      const y = (viewH - NODE_H) / 2;

      // Group
      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g.classList.add('node');
      g.setAttribute('data-index', String(i));
      if (i === 0) g.classList.add('head');
      if (i === arr.length - 1) g.classList.add('tail');

      // Rect
      const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect.setAttribute('x', x);
      rect.setAttribute('y', y);
      rect.setAttribute('rx', 10);
      rect.setAttribute('ry', 10);
      rect.setAttribute('width', NODE_W);
      rect.setAttribute('height', NODE_H);
      g.appendChild(rect);

      // Value text
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute('x', x + NODE_W / 2);
      text.setAttribute('y', y + NODE_H / 2 + 5);
      text.setAttribute('text-anchor', 'middle');
      text.textContent = stringify(arr[i]);
      g.appendChild(text);

      // Index label
      const idx = document.createElementNS("http://www.w3.org/2000/svg", "text");
      idx.setAttribute('x', x + 8);
      idx.setAttribute('y', y - 8);
      idx.setAttribute('class', 'index');
      idx.textContent = `#${i}`;
      g.appendChild(idx);

      svg.appendChild(g);

      // Arrow to next
      if (i < arr.length - 1) {
        const x1 = x + NODE_W;
        const y1 = y + NODE_H / 2;
        const x2 = x + NODE_W + GAP - 12;
        const y2 = y + NODE_H / 2;

        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute('class', 'arrow');
        const mid = (x1 + x2) / 2;
        const d = `M ${x1} ${y1} C ${mid} ${y1 - 10}, ${mid} ${y2 + 10}, ${x2} ${y2}`;
        path.setAttribute('d', d);
        svg.appendChild(path);
      } else {
        // null label
        const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
        t.setAttribute('class', 'null-label');
        t.setAttribute('x', x + NODE_W + 18);
        t.setAttribute('y', y + NODE_H / 2 + 5);
        t.textContent = 'null';
        svg.appendChild(t);
      }
    }

    updateStats();
  }

  function getNodeElemByIndex(i) {
    return svg.querySelector(`.node[data-index="${i}"]`);
  }

  function delay(ms) {
    return new Promise(res => setTimeout(res, ms));
  }

  function setDisabled(disabled) {
    const controls = [prependBtn, appendBtn, insertBtn, removeValBtn, removeIdxBtn, searchBtn, reverseBtn, seedBtn, clearBtn, valInput, idxInput];
    controls.forEach(el => el.disabled = disabled);
    controls.forEach(el => {
      if (disabled) {
        el.style.opacity = 0.7;
        el.style.cursor = 'not-allowed';
      } else {
        el.style.opacity = 1;
        el.style.cursor = 'pointer';
      }
    });
  }

  async function highlightTraversal(indices, options = {}) {
    const { foundIndex = -1, finalOnly = false } = options;
    const ms = Number(speedInput.value);
    if (finalOnly && foundIndex >= 0) {
      const el = getNodeElemByIndex(foundIndex);
      if (el) {
        el.classList.add('highlight');
        await delay(ms);
        el.classList.remove('highlight');
      }
      return;
    }

    for (let i = 0; i < indices.length; i++) {
      const el = getNodeElemByIndex(indices[i]);
      if (el) el.classList.add('highlight');
      await delay(ms);
      if (el && i !== indices.length - 1) el.classList.remove('highlight');
    }
    // Leave last highlighted briefly
    await delay(ms / 2);
    const last = getNodeElemByIndex(indices[indices.length - 1]);
    if (last) last.classList.remove('highlight');
  }

  // Actions
  prependBtn.addEventListener('click', async () => {
    const v = readValue();
    if (v == null) return;
    setDisabled(true);
    list.prepend(v);
    setOp(`Prepend ${stringify(v)} at head.`, 'O(1)');
    render();
    await highlightTraversal([0], { finalOnly: true });
    setDisabled(false);
  });

  appendBtn.addEventListener('click', async () => {
    const v = readValue();
    if (v == null) return;
    setDisabled(true);
    const oldLen = list.length;
    list.append(v);
    setOp(`Append ${stringify(v)} at tail.`, 'O(1) with tail pointer');
    render();
    await highlightTraversal([oldLen], { finalOnly: true });
    setDisabled(false);
  });

  insertBtn.addEventListener('click', async () => {
    const v = readValue();
    if (v == null) return;
    const idx = readIndexInsert();
    if (idx == null) return;
    setDisabled(true);

    // Animate traversal to index - 1 if middle
    let complexityText = 'O(n)';
    if (idx === 0) complexityText = 'O(1) (insert at head)';
    else if (idx === list.length) complexityText = 'O(1) (insert at tail)';
    setOp(`Insert ${stringify(v)} at index ${idx}.`, complexityText);

    if (idx > 0 && idx < list.length) {
      render();
      const indices = Array.from({ length: idx }, (_, i) => i);
      await highlightTraversal(indices);
    }

    const res = list.insertAt(idx, v);
    if (!res.ok) {
      setOp(`Insert failed: ${res.reason}`, '—');
    }
    render();
    await highlightTraversal([idx], { finalOnly: true });
    setDisabled(false);
  });

  removeValBtn.addEventListener('click', async () => {
    const v = readValue();
    if (v == null) return;
    setDisabled(true);
    setOp(`Remove first occurrence of value ${stringify(v)}.`, 'O(n)');
    // animate traversal until found
    const idx = indexOfValue(v);
    render();
    if (idx >= 0) {
      const indices = Array.from({ length: idx + 1 }, (_, i) => i);
      await highlightTraversal(indices);
      const res = list.remove(v);
      if (res.ok) setOp(`Removed value ${stringify(v)} at index ${res.index}.`, 'O(n)');
    } else {
      await highlightTraversal(Array.from({ length: list.length }, (_, i) => i));
      setOp(`Value ${stringify(v)} not found.`, 'O(n)');
    }
    render();
    setDisabled(false);
  });

  removeIdxBtn.addEventListener('click', async () => {
    const idx = readIndexExisting();
    if (idx == null) return;
    setDisabled(true);
    const complexityText = idx === 0 ? 'O(1) (remove head)' : 'O(n)';
    setOp(`Remove at index ${idx}.`, complexityText);
    // animate traversal to index
    render();
    if (idx > 0) {
      const indices = Array.from({ length: idx + 1 }, (_, i) => i);
      await highlightTraversal(indices);
    } else {
      await highlightTraversal([0], { finalOnly: true });
    }
    const res = list.removeAt(idx);
    if (!res.ok) {
      setOp(`Remove failed: ${res.reason}`, '—');
    } else {
      setOp(`Removed value ${stringify(res.removed.value)} from index ${idx}.`, complexityText);
    }
    render();
    setDisabled(false);
  });

  searchBtn.addEventListener('click', async () => {
    const v = readValue();
    if (v == null) return;
    setDisabled(true);
    setOp(`Search for value ${stringify(v)}.`, 'O(n)');
    render();
    const idx = indexOfValue(v);
    if (idx >= 0) {
      await highlightTraversal(Array.from({ length: idx + 1 }, (_, i) => i));
      setOp(`Found ${stringify(v)} at index ${idx}.`, 'O(n)');
    } else {
      await highlightTraversal(Array.from({ length: list.length }, (_, i) => i));
      setOp(`${stringify(v)} not found.`, 'O(n)');
    }
    setDisabled(false);
  });

  reverseBtn.addEventListener('click', async () => {
    if (list.length <= 1) {
      setOp('Reverse: no effect on empty or single-element list.', 'O(1)');
      return;
    }
    setDisabled(true);
    setOp('Reverse the list in-place using three pointers.', 'O(n) time, O(1) space');
    // simple highlight from head to tail to indicate traversal
    render();
    await highlightTraversal(Array.from({ length: list.length }, (_, i) => i));
    list.reverse();
    render();
    // highlight new head
    await highlightTraversal([0], { finalOnly: true });
    setDisabled(false);
  });

  seedBtn.addEventListener('click', async () => {
    setDisabled(true);
    list.clear();
    const samples = ['A', 'B', 'C', 'D'];
    for (const s of samples) list.append(s);
    render();
    setOp('Seeded list with A → B → C → D', '—');
    setDisabled(false);
  });

  clearBtn.addEventListener('click', async () => {
    setDisabled(true);
    list.clear();
    render();
    setOp('Cleared list (set head and tail to null).', 'O(1)');
    setDisabled(false);
  });

  // Helpers
  function readValue() {
    const v = valInput.value;
    if (v === null || v === undefined || v === '') {
      flashInput(valInput, true);
      setOp('Please enter a value.', '—');
      return null;
    }
    return v;
  }

  function readIndexInsert() {
    const raw = idxInput.value;
    const idx = Number(raw);
    if (!raw.length || Number.isNaN(idx)) {
      flashInput(idxInput, true);
      setOp('Please enter a valid index.', '—');
      return null;
    }
    if (idx < 0 || idx > list.length) {
      flashInput(idxInput, true);
      setOp(`Index must be between 0 and ${list.length}.`, '—');
      return null;
    }
    return idx;
    }

  function readIndexExisting() {
    const raw = idxInput.value;
    const idx = Number(raw);
    if (!raw.length || Number.isNaN(idx)) {
      flashInput(idxInput, true);
      setOp('Please enter a valid index.', '—');
      return null;
    }
    if (idx < 0 || idx >= list.length) {
      flashInput(idxInput, true);
      setOp(`Index must be between 0 and ${Math.max(0, list.length - 1)}.`, '—');
      return null;
    }
    return idx;
  }

  function flashInput(el, danger) {
    const old = el.style.borderColor;
    el.style.borderColor = danger ? '#ef4444' : '#22c55e';
    setTimeout(() => { el.style.borderColor = old || '#1b2b48'; }, 500);
  }

  function indexOfValue(v) {
    let cur = list.head;
    let i = 0;
    while (cur) {
      if (cur.value == v) return i;
      cur = cur.next;
      i++;
    }
    return -1;
  }

  // Keyboard shortcuts
  valInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      appendBtn.click();
    } else if (e.key === 'Enter' && e.shiftKey) {
      prependBtn.click();
    }
  });

  // Initial render with demo data
  (function init() {
    list.append(10);
    list.append(20);
    list.append(30);
    render();
    setOp('Ready. Seeded with 10 → 20 → 30', '—');
  })();

  // Re-render on resize to keep centering/widths decent
  window.addEventListener('resize', () => render());
</script>
</body>
</html>