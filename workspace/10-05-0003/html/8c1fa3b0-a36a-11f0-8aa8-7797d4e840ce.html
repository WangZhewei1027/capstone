<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Priority Queue Demo (Min/Max Heap with Visualization)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --accent: #22c55e;
      --accent2: #60a5fa;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #ef4444;
      --warning: #f59e0b;
      --node: #1f2937;
      --line: #334155;
      --highlight-compare: #38bdf8;
      --highlight-swap: #f472b6;
      --highlight-insert: #22c55e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
      background: radial-gradient(1200px 600px at 10% 10%, #0b1225 0%, var(--bg) 100%);
      color: var(--text);
    }
    header {
      padding: 16px 20px;
      border-bottom: 1px solid #1f2937;
      background: linear-gradient(to right, rgba(34,197,94,0.08), rgba(96,165,250,0.08));
    }
    header h1 {
      margin: 0;
      font-size: 20px;
      letter-spacing: 0.3px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    header h1 span.badge {
      font-size: 12px;
      background: #0b1328;
      border: 1px solid #1d2b50;
      padding: 2px 8px;
      border-radius: 999px;
      color: var(--muted);
    }
    .container {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 16px;
      padding: 16px;
    }
    .card {
      background: var(--panel);
      border: 1px solid #1f2937;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    }
    .card h2 {
      margin: 0;
      font-size: 16px;
      padding: 12px 14px;
      border-bottom: 1px solid #1f2937;
      background: #0b1328;
      color: #cbd5e1;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .card-content {
      padding: 12px 14px;
    }
    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    label {
      font-size: 12px;
      color: var(--muted);
    }
    input[type="text"], input[type="number"] {
      background: #0b1328;
      border: 1px solid #1d2b50;
      color: var(--text);
      padding: 8px 10px;
      border-radius: 8px;
      outline: none;
      min-width: 0;
    }
    input[type="number"] { width: 100px; }
    .btn {
      background: #0b1328;
      border: 1px solid #1d2b50;
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.05s ease, background 0.2s ease, border 0.2s ease;
    }
    .btn:hover { background: #0f1b3a; border-color: #274083; }
    .btn:active { transform: scale(0.98); }
    .btn.primary { background: #0e2b17; border-color: #215834; color: #bfeccb; }
    .btn.primary:hover { background: #134224; }
    .btn.warn { background: #412f0a; border-color: #7a5b1b; color: #ffe7b3; }
    .btn.danger { background: #311013; border-color: #6c1f27; color: #ffb3bd; }
    .toggle {
      display: inline-flex;
      gap: 8px;
      background: #0b1328;
      border: 1px solid #1d2b50;
      padding: 6px;
      border-radius: 999px;
    }
    .toggle button {
      border: none;
      background: transparent;
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 12px;
    }
    .toggle button.active {
      background: #162c58;
      color: #cde3ff;
      border: 1px solid #274083;
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-top: 8px;
    }
    .stats .stat {
      background: #0b1328;
      border: 1px solid #1d2b50;
      border-radius: 8px;
      padding: 10px;
      font-size: 12px;
    }
    .stat strong { color: #cbd5e1; }
    .viz {
      height: 440px;
      background: linear-gradient(to bottom, #0b1328, #0a162a);
      border-top: 1px solid #1f2937;
      position: relative;
    }
    .viz .overlay {
      position: absolute;
      top: 8px;
      left: 8px;
      display: flex;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
      opacity: 0.85;
    }
    .legend {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #0b1328;
      border: 1px solid #1d2b50;
      border-radius: 999px;
      padding: 6px 10px;
    }
    .chip .dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
    }
    svg { width: 100%; height: 100%; }
    .node {
      transition: transform 0.2s ease, filter 0.2s ease;
      cursor: pointer;
    }
    .node:hover { filter: brightness(1.2); }
    .node rect {
      fill: var(--node);
      stroke: #284164;
      stroke-width: 1.2;
      rx: 10;
    }
    .node text {
      fill: #cbd5e1;
      font-size: 12px;
      pointer-events: none;
    }
    .link {
      stroke: var(--line);
      stroke-width: 1.5;
    }
    .node.compare rect { stroke: var(--highlight-compare); filter: drop-shadow(0 0 6px rgba(56,189,248,0.35)); }
    .node.swap rect { stroke: var(--highlight-swap); filter: drop-shadow(0 0 6px rgba(244,114,182,0.35)); }
    .node.insert rect { stroke: var(--highlight-insert); filter: drop-shadow(0 0 6px rgba(34,197,94,0.35)); }
    .queue-list {
      display: grid;
      gap: 8px;
      margin-top: 10px;
    }
    .queue-item {
      background: #0b1328;
      border: 1px solid #1d2b50;
      border-radius: 8px;
      padding: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
    }
    .queue-item .meta {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .queue-item .meta .prio {
      color: #93c5fd;
    }
    .queue-item .actions { display: flex; gap: 6px; }
    .timeline {
      height: 120px;
      background: #0b1328;
      border-top: 1px solid #1d2b50;
      padding: 10px;
      font-size: 12px;
      overflow: auto;
    }
    .timeline .line {
      color: #cbd5e1;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .timeline .line .tag {
      font-size: 11px;
      color: #9ca3af;
      border: 1px solid #1d2b50;
      background: #091024;
      padding: 2px 6px;
      border-radius: 999px;
    }
    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 10px;
      border-top: 1px solid #1f2937;
      background: #0b1328;
    }
    .speed {
      display: flex;
      gap: 6px;
      align-items: center;
      color: var(--muted);
      font-size: 12px;
    }
    input[type="range"] { width: 120px; }
    .note {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }
    .footer {
      padding: 12px 16px;
      font-size: 12px;
      color: var(--muted);
      border-top: 1px solid #1f2937;
    }
    .code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: #93c5fd;
    }
    @media (max-width: 960px) {
      .container { grid-template-columns: 1fr; }
      .stats { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <h1>
      Priority Queue Visualizer
      <span class="badge">Min/Max Heap • Interactive • Animated</span>
    </h1>
  </header>

  <div class="container">
    <!-- Left panel: controls -->
    <div class="card">
      <h2>
        Controls
        <span class="chip">
          <span class="dot" style="background: var(--accent);"></span>
          Complexity: enqueue/dequeue O(log n), peek O(1)
        </span>
      </h2>
      <div class="card-content">
        <div class="row">
          <div style="flex: 1;">
            <label>Item label</label>
            <input id="labelInput" type="text" placeholder="e.g., Fix critical bug" />
          </div>
          <div>
            <label>Priority</label>
            <input id="priorityInput" type="number" placeholder="e.g., 1" />
          </div>
          <button class="btn primary" id="enqueueBtn">Enqueue</button>
        </div>

        <div class="row">
          <div class="toggle" id="modeToggle">
            <button data-mode="min" class="active">Min-Heap (lower number = higher priority)</button>
            <button data-mode="max">Max-Heap (higher number = higher priority)</button>
          </div>
          <button class="btn" id="peekBtn">Peek</button>
          <button class="btn warn" id="dequeueBtn">Dequeue</button>
          <button class="btn danger" id="clearBtn">Clear</button>
          <button class="btn" id="seedBtn">Seed Examples</button>
        </div>

        <div class="stats">
          <div class="stat">
            <strong>Size:</strong> <span id="sizeStat">0</span>
          </div>
          <div class="stat">
            <strong>Top:</strong> <span id="topStat">None</span>
          </div>
        </div>

        <p class="note">
          A priority queue always removes the highest-priority item first. In Min-Heap mode, smaller numbers are higher priority. Ties are stable: earlier insertions win.
        </p>

        <h2>Queue (sorted by priority)</h2>
        <div class="card-content queue-list" id="queueList"></div>
      </div>
    </div>

    <!-- Right panel: visualization and timeline -->
    <div class="card">
      <h2>
        Heap Visualization
        <span class="chip">
          <span class="dot" style="background: var(--accent2);"></span>
          Stable ordering for ties
        </span>
      </h2>
      <div class="viz" id="viz">
        <div class="overlay">
          <div class="legend chip">
            <span class="dot" style="background: var(--highlight-compare);"></span> Compare
          </div>
          <div class="legend chip">
            <span class="dot" style="background: var(--highlight-swap);"></span> Swap
          </div>
          <div class="legend chip">
            <span class="dot" style="background: var(--highlight-insert);"></span> Insert
          </div>
        </div>
        <svg id="heapSvg"></svg>
      </div>
      <div class="controls">
        <button class="btn" id="animateToggle">Animation: On</button>
        <button class="btn" id="pauseBtn" disabled>Pause</button>
        <button class="btn" id="resumeBtn" disabled>Resume</button>
        <button class="btn" id="stepBtn" disabled>Step</button>
        <div class="speed">
          Speed
          <input id="speedRange" type="range" min="100" max="1500" step="50" value="500" />
        </div>
      </div>
      <div class="timeline" id="timeline"></div>
      <div class="footer">
        Implemented using an array-backed binary heap. Parent index i has children at 2i+1 and 2i+2.
        Tie-breaker uses insertion order (stable). Click nodes or list items to change priority or remove.
      </div>
    </div>
  </div>

  <script>
    // PriorityQueue with Min/Max comparator and stable tie-breaker, event snapshots for animation.
    class PriorityQueue {
      constructor({ isMin = true, onEvent = null } = {}) {
        this.heap = [];
        this.isMin = isMin;
        this.seq = 0;
        this.onEvent = onEvent; // function(event)
      }

      _higher(a, b) {
        // Returns true if 'a' has higher priority than 'b'
        if (a.priority !== b.priority) {
          return this.isMin ? a.priority < b.priority : a.priority > b.priority;
        }
        // Stable tie-breaker: earlier insertion (lower seq) wins
        return a.seq < b.seq;
      }

      size() { return this.heap.length; }
      isEmpty() { return this.heap.length === 0; }
      peek() { return this.heap[0] || null; }
      clear() {
        if (this.onEvent) this._emit({ type: 'clear', description: 'Clear the heap' });
        this.heap = [];
      }

      enqueue(label, priority) {
        if (label == null || label === '') label = '(unnamed)';
        const item = { id: genId(), label, priority: Number(priority), seq: this.seq++ };
        this.heap.push(item);
        this._emit({ type: 'insert', indices: [this.heap.length - 1], description: `Insert "${item.label}" priority ${item.priority}` });
        this._bubbleUp(this.heap.length - 1);
        return item;
      }

      dequeue() {
        if (this.heap.length === 0) return null;
        const root = this.heap[0];
        const last = this.heap.pop();
        this._emit({ type: 'remove', indices: [0], description: `Remove top "${root.label}" priority ${root.priority}` });

        if (this.heap.length > 0) {
          this.heap[0] = last;
          this._emit({ type: 'replaceRoot', indices: [0], description: `Move last element to root` });
          this._sinkDown(0);
        }
        return root;
      }

      changePriority(id, newPriority) {
        const idx = this.heap.findIndex(x => x.id === id);
        if (idx === -1) return false;
        const old = this.heap[idx].priority;
        this.heap[idx].priority = Number(newPriority);
        this._emit({ type: 'update', indices: [idx], description: `Change priority of "${this.heap[idx].label}" from ${old} to ${newPriority}` });
        // Re-heapify around idx
        if (idx > 0 && this._higher(this.heap[idx], this.heap[this._parent(idx)])) {
          this._bubbleUp(idx);
        } else {
          this._sinkDown(idx);
        }
        return true;
      }

      removeById(id) {
        const idx = this.heap.findIndex(x => x.id === id);
        if (idx === -1) return false;
        const removing = this.heap[idx];
        const last = this.heap.pop();
        this._emit({ type: 'remove', indices: [idx], description: `Remove "${removing.label}" priority ${removing.priority}` });
        if (idx < this.heap.length) {
          this.heap[idx] = last;
          // Re-heapify around idx
          if (idx > 0 && this._higher(this.heap[idx], this.heap[this._parent(idx)])) {
            this._bubbleUp(idx);
          } else {
            this._sinkDown(idx);
          }
        }
        return true;
      }

      rebuild(isMin) {
        this.isMin = isMin;
        // Heapify from existing items with events
        const items = this.heap.slice();
        this.heap = items;
        this._emit({ type: 'heapify', description: `Heapify for ${isMin ? 'Min-Heap' : 'Max-Heap'} mode` });
        for (let i = Math.floor(this.heap.length / 2) - 1; i >= 0; i--) {
          this._sinkDown(i);
        }
      }

      toArray() { return this.heap.map(x => ({ ...x })); }

      toSortedArray() {
        const arr = this.heap.slice();
        arr.sort((a, b) => {
          if (a.priority !== b.priority) {
            return this.isMin ? a.priority - b.priority : b.priority - a.priority;
          }
          return a.seq - b.seq;
        });
        return arr;
      }

      _parent(i) { return Math.floor((i - 1) / 2); }
      _left(i) { return 2 * i + 1; }
      _right(i) { return 2 * i + 2; }

      _bubbleUp(idx) {
        let i = idx;
        while (i > 0) {
          const p = this._parent(i);
          this._emit({ type: 'compare', indices: [i, p], description: `Compare child at ${i} with parent at ${p}` });
          if (this._higher(this.heap[i], this.heap[p])) {
            this._swap(i, p);
            this._emit({ type: 'swap', indices: [i, p], description: `Swap child (${i}) with parent (${p})` });
            i = p;
          } else break;
        }
      }

      _sinkDown(i) {
        const n = this.heap.length;
        let index = i;
        while (true) {
          const l = this._left(index);
          const r = this._right(index);
          let best = index;

          if (l < n && this._higher(this.heap[l], this.heap[best])) {
            this._emit({ type: 'compare', indices: [l, best], description: `Compare left child (${l}) with current (${best})` });
            best = l;
          }
          if (r < n && this._higher(this.heap[r], this.heap[best])) {
            this._emit({ type: 'compare', indices: [r, best], description: `Compare right child (${r}) with current (${best})` });
            best = r;
          }
          if (best !== index) {
            this._swap(index, best);
            this._emit({ type: 'swap', indices: [index, best], description: `Swap current (${index}) with child (${best})` });
            index = best;
          } else break;
        }
      }

      _swap(a, b) {
        const tmp = this.heap[a];
        this.heap[a] = this.heap[b];
        this.heap[b] = tmp;
      }

      _emit(event) {
        if (!this.onEvent) return;
        // Attach a deep snapshot of heap for animation
        const snapshot = this.heap.map(x => ({ ...x }));
        this.onEvent({ ...event, heap: snapshot });
      }
    }

    // Animator to play event timeline with snapshots
    class Animator {
      constructor({ render, onTimelineUpdate } = {}) {
        this.timeline = [];
        this.index = 0;
        this.playing = false;
        this.speed = 500;
        this.timer = null;
        this.render = render; // function(event)
        this.onTimelineUpdate = onTimelineUpdate || (()=>{});
      }
      setSpeed(ms) { this.speed = ms; }
      setTimeline(events) {
        this.timeline = events.slice();
        this.index = 0;
        this.onTimelineUpdate(this.timeline, this.index);
      }
      clearTimeline() {
        this.timeline = [];
        this.index = 0;
        this.onTimelineUpdate(this.timeline, this.index);
      }
      play() {
        if (this.playing || this.timeline.length === 0) return;
        this.playing = true;
        this._tick();
      }
      _tick() {
        if (!this.playing) return;
        if (this.index >= this.timeline.length) {
          this.playing = false;
          this.onTimelineUpdate(this.timeline, this.index);
          return;
        }
        const ev = this.timeline[this.index];
        this.render(ev);
        this.index++;
        this.onTimelineUpdate(this.timeline, this.index);
        this.timer = setTimeout(() => this._tick(), this.speed);
      }
      pause() {
        this.playing = false;
        if (this.timer) clearTimeout(this.timer);
      }
      resume() {
        if (this.playing) return;
        this.playing = true;
        this._tick();
      }
      step() {
        if (this.index >= this.timeline.length) return;
        const ev = this.timeline[this.index];
        this.render(ev);
        this.index++;
        this.onTimelineUpdate(this.timeline, this.index);
      }
    }

    // Utilities
    let _idCounter = 1;
    function genId() { return 'id_' + (_idCounter++); }

    // UI State
    const state = {
      isMin: true,
      animate: true,
    };

    // Setup
    const pq = new PriorityQueue({
      isMin: state.isMin,
      onEvent: ev => timelineEvents.push(ev)
    });
    const timelineEvents = [];
    const animator = new Animator({
      render: event => {
        renderHeap(event.heap, event.indices || [], event.type);
        appendTimelineLine(event);
      },
      onTimelineUpdate: (events, idx) => {
        updateControlsForTimeline(events, idx);
      }
    });

    // DOM
    const heapSvg = document.getElementById('heapSvg');
    const queueList = document.getElementById('queueList');
    const sizeStat = document.getElementById('sizeStat');
    const topStat = document.getElementById('topStat');
    const enqueueBtn = document.getElementById('enqueueBtn');
    const peekBtn = document.getElementById('peekBtn');
    const dequeueBtn = document.getElementById('dequeueBtn');
    const clearBtn = document.getElementById('clearBtn');
    const seedBtn = document.getElementById('seedBtn');
    const labelInput = document.getElementById('labelInput');
    const priorityInput = document.getElementById('priorityInput');
    const modeToggle = document.getElementById('modeToggle');
    const animateToggle = document.getElementById('animateToggle');
    const pauseBtn = document.getElementById('pauseBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const stepBtn = document.getElementById('stepBtn');
    const speedRange = document.getElementById('speedRange');
    const timelineDiv = document.getElementById('timeline');

    // Event handlers
    enqueueBtn.addEventListener('click', () => {
      const label = labelInput.value.trim();
      const prioStr = priorityInput.value.trim();
      const prio = prioStr === '' ? NaN : Number(prioStr);
      if (isNaN(prio)) {
        alert('Please enter a numeric priority.');
        priorityInput.focus();
        return;
      }
      clearTimeline();
      pq.enqueue(label, prio);
      updateAll(state.animate);
      labelInput.value = '';
      priorityInput.value = '';
    });

    peekBtn.addEventListener('click', () => {
      const top = pq.peek();
      if (!top) {
        alert('Queue is empty.');
        return;
      }
      alert(`Top item:\n"${top.label}" with priority ${top.priority}`);
    });

    dequeueBtn.addEventListener('click', () => {
      clearTimeline();
      const removed = pq.dequeue();
      updateAll(state.animate);
      if (!removed) {
        alert('Queue is empty.');
      } else {
        alert(`Dequeued:\n"${removed.label}" with priority ${removed.priority}`);
      }
    });

    clearBtn.addEventListener('click', () => {
      clearTimeline();
      pq.clear();
      updateAll(false);
    });

    seedBtn.addEventListener('click', () => {
      clearTimeline();
      const examples = [
        ['Fix critical bug', 1],
        ['Code review', 3],
        ['Write documentation', 5],
        ['Respond to emails', 7],
        ['Refactor module', 4],
        ['Add tests', 2],
        ['Plan sprint', 6]
      ];
      examples.forEach(([label, prio]) => pq.enqueue(label, prio));
      updateAll(state.animate);
    });

    modeToggle.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-mode]');
      if (!btn) return;
      const mode = btn.getAttribute('data-mode');
      modeToggle.querySelectorAll('button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      clearTimeline();
      state.isMin = mode === 'min';
      pq.rebuild(state.isMin);
      updateAll(state.animate);
    });

    animateToggle.addEventListener('click', () => {
      state.animate = !state.animate;
      animateToggle.textContent = `Animation: ${state.animate ? 'On' : 'Off'}`;
    });

    speedRange.addEventListener('input', () => {
      animator.setSpeed(Number(speedRange.value));
    });

    pauseBtn.addEventListener('click', () => animator.pause());
    resumeBtn.addEventListener('click', () => animator.resume());
    stepBtn.addEventListener('click', () => animator.step());

    // Render functions
    function updateAll(withAnimation) {
      updateStats();
      renderQueueSorted();
      if (withAnimation && timelineEvents.length > 0) {
        animator.setTimeline(timelineEvents);
        animator.play();
      } else {
        renderHeap(pq.toArray(), [], null);
      }
    }

    function updateStats() {
      sizeStat.textContent = pq.size();
      const top = pq.peek();
      topStat.textContent = top ? `"${top.label}" (p=${top.priority})` : 'None';
    }

    function renderQueueSorted() {
      queueList.innerHTML = '';
      const arr = pq.toSortedArray();
      if (arr.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'note';
        empty.textContent = 'Empty queue.';
        queueList.appendChild(empty);
        return;
      }
      arr.forEach(item => {
        const div = document.createElement('div');
        div.className = 'queue-item';
        const left = document.createElement('div');
        left.className = 'meta';
        const name = document.createElement('div');
        name.textContent = item.label;
        const pr = document.createElement('div');
        pr.className = 'prio';
        pr.textContent = `p=${item.priority}`;
        left.appendChild(name);
        left.appendChild(pr);

        const right = document.createElement('div');
        right.className = 'actions';
        const changeBtn = document.createElement('button');
        changeBtn.className = 'btn';
        changeBtn.textContent = 'Change priority';
        changeBtn.addEventListener('click', () => {
          const val = prompt(`New priority for "${item.label}":`, item.priority);
          if (val === null) return;
          const num = Number(val);
          if (isNaN(num)) {
            alert('Please enter a numeric priority.');
            return;
          }
          clearTimeline();
          pq.changePriority(item.id, num);
          updateAll(state.animate);
        });
        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn danger';
        removeBtn.textContent = 'Remove';
        removeBtn.addEventListener('click', () => {
          clearTimeline();
          pq.removeById(item.id);
          updateAll(state.animate);
        });
        right.appendChild(changeBtn);
        right.appendChild(removeBtn);

        div.appendChild(left);
        div.appendChild(right);
        queueList.appendChild(div);
      });
    }

    function renderHeap(heapArr, highlightIndices = [], eventType = null) {
      heapSvg.innerHTML = '';
      const n = heapArr.length;
      // If empty: draw message
      if (n === 0) {
        const msg = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        msg.setAttribute('x', '50%');
        msg.setAttribute('y', '50%');
        msg.setAttribute('text-anchor', 'middle');
        msg.setAttribute('fill', '#93c5fd');
        msg.setAttribute('font-size', '14');
        msg.textContent = 'Heap is empty.';
        heapSvg.appendChild(msg);
        return;
      }

      const width = heapSvg.clientWidth || heapSvg.parentElement.clientWidth || 800;
      const height = heapSvg.clientHeight || 440;
      const marginX = 26;
      const marginTop = 26;
      const vGap = Math.max(80, Math.min(120, height / (Math.floor(Math.log2(n)) + 3)));
      const nodeW = 150;
      const nodeH = 36;

      // Compute positions by level
      const positions = new Array(n);
      for (let i = 0; i < n; i++) {
        const level = Math.floor(Math.log2(i + 1));
        const firstIdx = Math.pow(2, level) - 1;
        const posInLevel = i - firstIdx;
        const nodesInLevel = Math.pow(2, level);
        const x = marginX + ((posInLevel + 1) * (width - 2 * marginX)) / (nodesInLevel + 1);
        const y = marginTop + level * vGap;
        positions[i] = { x, y, level, posInLevel };
      }

      // Draw links
      for (let i = 0; i < n; i++) {
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        if (left < n) drawLink(positions[i], positions[left]);
        if (right < n) drawLink(positions[i], positions[right]);
      }

      // Draw nodes
      for (let i = 0; i < n; i++) {
        const pos = positions[i];
        const item = heapArr[i];
        const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        nodeGroup.classList.add('node');
        if (highlightIndices.includes(i)) {
          if (eventType === 'compare') nodeGroup.classList.add('compare');
          else if (eventType === 'swap') nodeGroup.classList.add('swap');
          else if (eventType === 'insert' || eventType === 'replaceRoot' || eventType === 'update') nodeGroup.classList.add('insert');
        }

        nodeGroup.setAttribute('transform', `translate(${pos.x - nodeW / 2}, ${pos.y - nodeH / 2})`);
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('width', nodeW);
        rect.setAttribute('height', nodeH);
        nodeGroup.appendChild(rect);

        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', nodeW / 2);
        label.setAttribute('y', nodeH / 2 + 4);
        label.setAttribute('text-anchor', 'middle');
        const short = truncate(item.label, 22);
        label.textContent = `${short}  p=${item.priority}`;
        nodeGroup.appendChild(label);

        // Click interactions
        nodeGroup.addEventListener('click', () => {
          const act = prompt(`Choose action for "${item.label}" (enter: new priority; or type "remove")`, item.priority);
          if (act === null) return;
          if (act.toLowerCase().trim() === 'remove') {
            clearTimeline();
            pq.removeById(item.id);
            updateAll(state.animate);
          } else {
            const val = Number(act);
            if (isNaN(val)) {
              alert('Please enter a numeric priority or "remove".');
            } else {
              clearTimeline();
              pq.changePriority(item.id, val);
              updateAll(state.animate);
            }
          }
        });

        heapSvg.appendChild(nodeGroup);
      }

      function drawLink(a, b) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.classList.add('link');
        const ax = a.x;
        const ay = a.y + (nodeH / 2);
        const bx = b.x;
        const by = b.y - (nodeH / 2);
        line.setAttribute('x1', ax);
        line.setAttribute('y1', ay);
        line.setAttribute('x2', bx);
        line.setAttribute('y2', by);
        heapSvg.appendChild(line);
      }
    }

    function truncate(str, n) {
      if (str.length <= n) return str;
      return str.slice(0, n - 1) + '…';
    }

    function appendTimelineLine(ev) {
      const line = document.createElement('div');
      line.className = 'line';
      const tag = document.createElement('span');
      tag.className = 'tag';
      tag.textContent = ev.type;
      const desc = document.createElement('span');
      desc.textContent = ev.description || '';
      line.appendChild(tag);
      line.appendChild(desc);
      timelineDiv.appendChild(line);
      timelineDiv.scrollTop = timelineDiv.scrollHeight;
    }

    function updateControlsForTimeline(events, idx) {
      const hasEvents = events.length > 0;
      pauseBtn.disabled = !hasEvents;
      resumeBtn.disabled = !hasEvents;
      stepBtn.disabled = !hasEvents;
      // Disable/enable pause/resume accordingly
      // No need to track exact playing state for simplicity here
    }

    function clearTimeline() {
      timelineEvents.length = 0;
      timelineDiv.innerHTML = '';
      animator.clearTimeline();
    }

    // Initial render
    renderHeap(pq.toArray(), [], null);
    renderQueueSorted();
    updateStats();

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') enqueueBtn.click();
      if (e.key.toLowerCase() === 'd') dequeueBtn.click();
      if (e.key.toLowerCase() === 'p') peekBtn.click();
    });

    // Accessibility titles
    enqueueBtn.title = 'Add item to priority queue (Enter)';
    dequeueBtn.title = 'Remove top-priority item (D)';
    peekBtn.title = 'View top-priority item (P)';

  </script>
</body>
</html>