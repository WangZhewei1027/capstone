<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Huffman Coding – Interactive Demo</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #101317;
    --panel: #1a1f24;
    --accent: #4db6ff;
    --accent2: #ffb84d;
    --text: #e6edf3;
    --muted: #9aa4ad;
    --good: #42c876;
    --bad: #ff5f5f;
    --border: #2a3238;
    --code: #0f1720;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    color: var(--text);
    background: linear-gradient(180deg, #0c0f13 0%, var(--bg) 60%, #131821 100%);
  }
  header {
    padding: 16px 20px;
    border-bottom: 1px solid var(--border);
    background: rgba(26,31,36,0.7);
    position: sticky;
    top: 0;
    backdrop-filter: blur(6px);
    z-index: 2;
  }
  header h1 {
    margin: 0;
    font-size: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
    letter-spacing: 0.3px;
  }
  header h1 .chip {
    font-size: 12px;
    color: var(--muted);
    padding: 2px 8px;
    border: 1px solid var(--border);
    border-radius: 999px;
  }
  main {
    padding: 18px;
    max-width: 1200px;
    margin: 0 auto;
    display: grid;
    gap: 14px;
    grid-template-columns: 1.2fr 1fr;
    grid-auto-rows: min-content;
  }
  .panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    overflow: hidden;
  }
  .panel header {
    background: none;
    border: none;
    padding: 12px 14px;
    position: static;
  }
  .panel header h2 {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
  }
  .panel .body {
    padding: 12px;
  }
  .controls {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin-top: 10px;
  }
  textarea {
    width: 100%;
    min-height: 160px;
    resize: vertical;
    color: var(--text);
    background: #0c1116;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 12px;
    line-height: 1.5;
  }
  button, .btn {
    cursor: pointer;
    background: #0c1116;
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 14px;
    transition: background .15s, border-color .15s, transform .02s;
  }
  button.primary {
    background: linear-gradient(180deg, #0e2130 0%, #0c1722 100%);
    border-color: #143047;
    color: #cfe9ff;
  }
  button:hover {
    background: #0f141a;
    border-color: #37424a;
  }
  button.primary:hover { border-color: #1e4b6b; }
  button:active { transform: translateY(1px); }
  .grid {
    display: grid;
    gap: 10px;
  }
  .row { display: flex; align-items: center; gap: 10px; }
  .summary {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
  }
  .summary .stat {
    background: #0c1116;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 10px;
  }
  .stat .label { font-size: 12px; color: var(--muted); }
  .stat .value { font-size: 16px; margin-top: 4px; }
  .mono {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    background: var(--code);
    border-radius: 6px;
    padding: 2px 6px;
  }
  .table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
  }
  .table th, .table td {
    border-bottom: 1px solid var(--border);
    padding: 6px 6px;
    text-align: left;
    vertical-align: top;
  }
  .table th {
    color: var(--muted);
    font-weight: 600;
    background: #0c1116;
    position: sticky;
    top: 0;
    z-index: 1;
  }
  .scroll {
    max-height: 260px;
    overflow: auto;
    border: 1px solid var(--border);
    border-radius: 8px;
  }
  .badge {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 999px;
    border: 1px solid var(--border);
    color: var(--muted);
    font-size: 12px;
    margin-left: 4px;
  }
  .note {
    color: var(--muted);
    font-size: 13px;
  }
  .steps {
    display: grid;
    gap: 8px;
  }
  .step {
    padding: 8px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: #0c1116;
  }
  .step .title {
    font-weight: 600;
    font-size: 13px;
    color: var(--accent);
    margin-bottom: 4px;
  }
  .codes {
    display: grid;
    gap: 6px;
  }
  .code-row {
    display: grid;
    grid-template-columns: 72px 1fr auto;
    gap: 8px;
    align-items: center;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 6px 8px;
    background: #0c1116;
  }
  .char-box {
    display: flex; align-items: center; justify-content: center;
    border: 1px dashed #334;
    border-radius: 6px;
    padding: 6px 8px;
    min-height: 30px;
    color: #d5dee6;
    background: #0a0f14;
  }
  .svg-wrap {
    border: 1px solid var(--border);
    border-radius: 10px;
    overflow: hidden;
    background: #0c1116;
  }
  svg { width: 100%; height: 100%; display: block; }
  .edge-label {
    font-size: 12px; fill: #95a3ad;
    background: rgba(0,0,0,0.5);
  }
  .node circle {
    fill: #14202a;
    stroke: #23323b;
    stroke-width: 1.5;
  }
  .node.leaf circle { fill: #1b2a34; }
  .node text {
    fill: #e6edf3; font-size: 12px; text-anchor: middle; dominant-baseline: central;
  }
  .legend { font-size: 12px; color: var(--muted); }
  .encoded {
    border: 1px solid var(--border);
    border-radius: 8px;
    background: #0c1116;
    padding: 8px;
    font-size: 13px;
  }
  .encoded .bits {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    word-break: break-all;
    background: #0a0f14;
    border-radius: 6px;
    padding: 8px;
    line-height: 1.5;
    max-height: 200px;
    overflow: auto;
    border: 1px solid #223;
  }
  .row-actions { display: flex; gap: 8px; align-items: center; }
  .ok { color: var(--good); }
  .fail { color: var(--bad); }
  .help {
    font-size: 13px;
    color: var(--muted);
    margin-top: 6px;
  }
  .kpi {
    display: inline-flex; align-items: center; gap: 8px;
    padding: 6px 8px; border-radius: 8px; background: #0c1116; border: 1px solid var(--border);
  }
  .small { font-size: 12px; color: var(--muted); }
  .hidden { display: none !important; }
  .footer-note {
    text-align: center; color: var(--muted); padding: 16px; font-size: 12px;
  }
  .toggle {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 4px 6px;
    border: 1px solid var(--border);
    border-radius: 999px;
    color: var(--muted);
    cursor: pointer;
  }
  .toggle input { accent-color: var(--accent); }
</style>
</head>
<body>
  <header>
    <h1>
      Huffman Coding
      <span class="chip">Prefix-free variable-length codes</span>
    </h1>
  </header>

  <main>
    <section class="panel" style="grid-column: 1 / span 2;">
      <header><h2>Input Text</h2></header>
      <div class="body">
        <textarea id="input" placeholder="Type some text to compress using Huffman coding.">this is an example of a huffman tree</textarea>
        <div class="controls">
          <button class="primary" id="buildBtn">Build Huffman & Encode</button>
          <button id="decodeBtn">Decode Encoded Bits</button>
          <button id="randomBtn">Use Sample Text</button>
          <button id="clearBtn">Clear</button>
          <label class="toggle"><input type="checkbox" id="showSteps" checked /> Show build steps</label>
          <label class="toggle"><input type="checkbox" id="showTree" checked /> Show tree</label>
          <label class="toggle"><input type="checkbox" id="canonical" /> Canonical view (sorted codes)</label>
        </div>
        <div class="help">
          Huffman coding assigns shorter bit-codes to more frequent characters and longer bit-codes to less frequent ones. The tree below is built by repeatedly merging the two least frequent nodes.
        </div>
      </div>
    </section>

    <section class="panel">
      <header><h2>Frequencies</h2></header>
      <div class="body">
        <div id="freqSummary" class="summary" aria-live="polite">
          <div class="stat"><div class="label">Unique chars</div><div class="value" id="statUnique">–</div></div>
          <div class="stat"><div class="label">Total chars</div><div class="value" id="statTotal">–</div></div>
          <div class="stat"><div class="label">Entropy bound</div><div class="value" id="statEntropy">–</div></div>
        </div>
        <div class="scroll" style="margin-top:10px;">
          <table class="table" id="freqTable">
            <thead>
              <tr><th>Char</th><th>Count</th><th>Probability</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div class="note">Entropy shown is the theoretical lower bound (bits/char) from −Σp log₂ p.</div>
      </div>
    </section>

    <section class="panel">
      <header><h2>Codes</h2></header>
      <div class="body">
        <div id="codesList" class="codes"></div>
        <div class="note">Huffman codes are prefix-free: no code is the prefix of another.</div>
      </div>
    </section>

    <section class="panel" style="grid-column: 1 / span 2;">
      <header><h2>Huffman Tree</h2></header>
      <div class="body">
        <div id="treeWrap" class="svg-wrap" style="height: 380px;">
          <svg id="treeSvg" viewBox="0 0 800 380" preserveAspectRatio="xMidYMid meet"></svg>
        </div>
        <div class="legend" style="margin-top:8px;">
          Left edge labeled 0, right edge labeled 1. Leaves show character and frequency; internal nodes show combined frequency.
        </div>
      </div>
    </section>

    <section class="panel">
      <header><h2>Encoding</h2></header>
      <div class="body">
        <div class="grid">
          <div class="encoded">
            <div class="row-actions">
              <div class="kpi">
                <div>Encoded length: <span id="encodedBitsLen" class="mono">–</span> bits</div>
              </div>
              <div class="kpi">
                <div>Original: <span id="originalBitsLen" class="mono">–</span> bits</div>
              </div>
              <div class="kpi">
                <div>Avg bits/char: <span id="avgBits" class="mono">–</span></div>
              </div>
              <div class="kpi">
                <div>Compression ratio: <span id="ratio" class="mono">–</span></div>
              </div>
            </div>
            <div class="bits" id="encodedBits"></div>
            <div class="controls">
              <button id="copyBits">Copy Bits</button>
              <button id="toggleBits">Toggle full bits view</button>
            </div>
          </div>
          <div class="note">
            Original size assumes 8 bits per character (typical single-byte encoding). Huffman improves average bits/char toward the entropy bound for this distribution.
          </div>
        </div>
      </div>
    </section>

    <section class="panel">
      <header><h2>Build Steps</h2></header>
      <div class="body">
        <div id="stepsList" class="steps"></div>
      </div>
    </section>

    <section class="panel" style="grid-column: 1 / span 2;">
      <header><h2>Decode</h2></header>
      <div class="body">
        <div class="row">
          <div class="kpi">Decoded matches original: <span id="decodeStatus" class="mono">–</span></div>
        </div>
        <div class="encoded" style="margin-top:10px;">
          <div style="margin-bottom:6px; color: var(--muted);">Decoded text:</div>
          <div id="decodedText" class="bits" style="max-height:120px;"></div>
        </div>
      </div>
    </section>

    <div class="footer-note">This demo builds a Huffman tree from your input, shows the resulting prefix-free codes, encodes the text to a bitstream, and decodes it back using the tree.</div>
  </main>

<script>
(function(){
  // Utility helpers
  const displayChar = ch => {
    if (ch === ' ') return 'space';
    if (ch === '\n') return '↵ newline';
    if (ch === '\t') return '⇥ tab';
    if (ch === '\r') return '␍ CR';
    const code = ch.codePointAt(0);
    const printable = code >= 33 && code <= 126;
    if (printable) return ch;
    return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');
  };
  const formatProb = p => (p === 0 ? '0' : (Math.round(p * 10000) / 10000).toString());
  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));

  // Huffman core
  function getFrequencies(text) {
    const map = new Map();
    for (const ch of text) map.set(ch, (map.get(ch) || 0) + 1);
    return map;
  }
  function entropy(freqMap) {
    let total = 0, H = 0;
    for (const [,count] of freqMap) total += count;
    for (const [,count] of freqMap) {
      const p = count / total;
      H += -p * Math.log2(p);
    }
    return { H, total };
  }
  let NODE_ID = 0, ORDER_ID = 0;
  function nodeId() { return NODE_ID++; }
  function orderId() { return ORDER_ID++; }

  function buildHuffman(text) {
    NODE_ID = 0; ORDER_ID = 0;
    const freqMap = getFrequencies(text);
    const totalChars = text.length;
    const unique = freqMap.size;

    const leaves = [];
    for (const [ch, cnt] of freqMap) {
      leaves.push({ id: nodeId(), order: orderId(), freq: cnt, char: ch, left: null, right: null });
    }

    const steps = [];
    let root = null;
    if (leaves.length === 0) {
      root = null;
    } else if (leaves.length === 1) {
      // Single-char special case: the tree is just one leaf.
      root = leaves[0];
    } else {
      const pq = leaves.slice();
      while (pq.length > 1) {
        pq.sort((a,b)=> (a.freq - b.freq) || (a.order - b.order));
        const left = pq.shift();
        const right = pq.shift();
        const parent = { id: nodeId(), order: orderId(), freq: left.freq + right.freq, char: null, left, right };
        steps.push({ left, right, parent });
        pq.push(parent);
      }
      root = pq[0];
    }

    const codes = {};
    if (root) {
      const traverse = (node, prefix) => {
        if (!node) return;
        if (node.char !== null && node.left === null && node.right === null) {
          // If prefix is empty (single unique char), assign '0'
          codes[node.char] = prefix.length ? prefix : '0';
          return;
        }
        if (node.left) traverse(node.left, prefix + '0');
        if (node.right) traverse(node.right, prefix + '1');
      };
      traverse(root, '');
    }

    const encodedBitsArr = [];
    for (const ch of text) {
      const code = codes[ch];
      if (!code) continue;
      encodedBitsArr.push(code);
    }
    const encodedBits = encodedBitsArr.join('');
    const encodedBitsLen = encodedBits.length;

    return {
      freqMap,
      totalChars,
      unique,
      steps,
      root,
      codes,
      encodedBits,
      encodedBitsLen
    };
  }

  function decodeBits(root, bits, freqMap, originalLen) {
    if (!root) return '';
    // Single-leaf tree:
    if (root.char !== null && !root.left && !root.right) {
      const count = (bits && bits.length) ? bits.length : (freqMap.get(root.char) || originalLen || 0);
      return root.char.repeat(count);
    }
    let out = '';
    let node = root;
    for (let i=0; i<bits.length; i++) {
      const b = bits[i];
      node = (b === '0') ? node.left : node.right;
      if (!node) {
        // invalid bitstream
        return out;
      }
      if (node.char !== null) {
        out += node.char;
        node = root;
      }
    }
    return out;
  }

  // Tree drawing
  function computeDepth(node) {
    if (!node) return 0;
    if (node.char !== null && !node.left && !node.right) return 1;
    return 1 + Math.max(node.left ? computeDepth(node.left) : 0, node.right ? computeDepth(node.right) : 0);
  }
  function assignPositions(node) {
    const nodes = [];
    let xIndex = 0;
    const visit = (n, depth) => {
      if (!n) return;
      const isLeaf = n.char !== null && !n.left && !n.right;
      if (!isLeaf) {
        visit(n.left, depth+1);
        visit(n.right, depth+1);
      }
      if (isLeaf) {
        n._x = xIndex++;
        n._y = depth;
      } else {
        const lx = n.left ? n.left._x : xIndex;
        const rx = n.right ? n.right._x : xIndex;
        n._x = (lx + rx) / 2;
        n._y = depth;
      }
      nodes.push(n);
    };
    visit(node, 0);
    return { nodes, leafCount: Math.max(1, xIndex) };
  }

  function drawTree(root, svgEl) {
    while (svgEl.firstChild) svgEl.removeChild(svgEl.firstChild);
    if (!root) {
      const t = createSvgEl('text', { x: 20, y: 24, fill: '#95a3ad' });
      t.textContent = 'No tree (input is empty).';
      svgEl.appendChild(t);
      return;
    }
    const depth = computeDepth(root);
    const { nodes, leafCount } = assignPositions(root);
    const hGap = clamp(1200 / Math.max(leafCount, 4), 70, 160);
    const vGap = clamp(360 / Math.max(depth, 3), 60, 120);
    const marginX = 30, marginY = 30;
    const width = Math.max(leafCount * hGap + marginX * 2, 600);
    const height = Math.max(depth * vGap + marginY * 2, 300);
    svgEl.setAttribute('viewBox', `0 0 ${width} ${height}`);

    const pos = n => [marginX + n._x * hGap, marginY + n._y * vGap];

    // Edges
    const drawEdge = (from, to, label) => {
      if (!to) return;
      const [x1,y1] = pos(from);
      const [x2,y2] = pos(to);
      const line = createSvgEl('line', { x1, y1, x2, y2, stroke: '#284050', 'stroke-width': 1.5 });
      svgEl.appendChild(line);
      // label
      const mx = (x1 + x2)/2;
      const my = (y1 + y2)/2;
      const lbl = createSvgEl('text', { x: mx, y: my - 4, class: 'edge-label' });
      lbl.textContent = label;
      svgEl.appendChild(lbl);
    };

    const visited = new Set();
    const drawNode = n => {
      if (!n || visited.has(n.id)) return;
      visited.add(n.id);
      if (n.left) drawEdge(n, n.left, '0');
      if (n.right) drawEdge(n, n.right, '1');

      const [x,y] = pos(n);
      const g = createSvgEl('g', { class: 'node' + (n.char !== null && !n.left && !n.right ? ' leaf' : '' ) });
      const circle = createSvgEl('circle', { cx: x, cy: y, r: 16 });
      g.appendChild(circle);
      const text = createSvgEl('text', { x, y });
      if (n.char !== null && !n.left && !n.right) {
        text.textContent = `${displayChar(n.char)} • ${n.freq}`;
      } else {
        text.textContent = `${n.freq}`;
      }
      g.appendChild(text);
      svgEl.appendChild(g);

      drawNode(n.left);
      drawNode(n.right);
    };
    drawNode(root);
  }
  function createSvgEl(tag, attrs) {
    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
    for (const k in attrs) el.setAttribute(k, attrs[k]);
    return el;
  }

  // UI binding
  const els = {
    input: document.getElementById('input'),
    buildBtn: document.getElementById('buildBtn'),
    decodeBtn: document.getElementById('decodeBtn'),
    randomBtn: document.getElementById('randomBtn'),
    clearBtn: document.getElementById('clearBtn'),
    showSteps: document.getElementById('showSteps'),
    showTree: document.getElementById('showTree'),
    canonical: document.getElementById('canonical'),

    statUnique: document.getElementById('statUnique'),
    statTotal: document.getElementById('statTotal'),
    statEntropy: document.getElementById('statEntropy'),

    freqTableBody: document.querySelector('#freqTable tbody'),
    codesList: document.getElementById('codesList'),
    stepsList: document.getElementById('stepsList'),

    treeSvg: document.getElementById('treeSvg'),
    treeWrap: document.getElementById('treeWrap'),

    encodedBits: document.getElementById('encodedBits'),
    encodedBitsLen: document.getElementById('encodedBitsLen'),
    originalBitsLen: document.getElementById('originalBitsLen'),
    avgBits: document.getElementById('avgBits'),
    ratio: document.getElementById('ratio'),
    copyBits: document.getElementById('copyBits'),
    toggleBits: document.getElementById('toggleBits'),

    decodeStatus: document.getElementById('decodeStatus'),
    decodedText: document.getElementById('decodedText'),
  };

  let state = {
    result: null,
    showFullBits: false
  };

  function renderAll() {
    const text = els.input.value || '';
    const result = buildHuffman(text);
    state.result = result;

    // Stats & freq
    const ent = entropy(result.freqMap);
    els.statUnique.textContent = result.unique || '0';
    els.statTotal.textContent = result.totalChars || '0';
    els.statEntropy.textContent = ent.H ? (Math.round(ent.H * 100) / 100) + ' bits/char' : '0';

    // Frequency table
    renderFreqTable(result.freqMap, ent.total);
    // Codes
    renderCodes(result.codes, result.freqMap, !!els.canonical.checked);
    // Tree
    els.treeWrap.classList.toggle('hidden', !els.showTree.checked);
    if (els.showTree.checked) drawTree(result.root, els.treeSvg);
    // Steps
    els.stepsList.parentElement.parentElement.classList.toggle('hidden', !els.showSteps.checked);
    renderSteps(result.steps);

    // Encoding outputs
    const bitsLen = result.encodedBitsLen || 0;
    const origBits = result.totalChars * 8;
    els.encodedBitsLen.textContent = bitsLen;
    els.originalBitsLen.textContent = origBits;
    const avg = result.totalChars ? (bitsLen / result.totalChars) : 0;
    els.avgBits.textContent = result.totalChars ? (Math.round(avg * 100) / 100) : '0';
    const ratio = origBits ? (Math.round((bitsLen / origBits) * 1000) / 1000) : 0;
    els.ratio.textContent = origBits ? (ratio + 'x') : '–';
    renderEncodedBits(result.encodedBits);

    // Reset decode display
    els.decodeStatus.textContent = '–';
    els.decodeStatus.className = 'mono';
    els.decodedText.textContent = '';
  }

  function renderFreqTable(freqMap, total) {
    const tbody = els.freqTableBody;
    tbody.innerHTML = '';
    const rows = [...freqMap.entries()].sort((a,b)=> b[1]-a[1]);
    for (const [ch, cnt] of rows) {
      const tr = document.createElement('tr');
      const tdChar = document.createElement('td');
      tdChar.textContent = displayChar(ch);
      const tdCnt = document.createElement('td');
      tdCnt.textContent = cnt;
      const tdProb = document.createElement('td');
      tdProb.textContent = formatProb(cnt / (total || 1));
      tr.append(tdChar, tdCnt, tdProb);
      tbody.appendChild(tr);
    }
    if (rows.length === 0) {
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 3;
      td.textContent = 'No characters.';
      tr.appendChild(td);
      tbody.appendChild(tr);
    }
  }

  function renderCodes(codes, freqMap, canonical) {
    const container = els.codesList;
    container.innerHTML = '';
    const entries = Object.entries(codes);
    if (entries.length === 0) {
      container.innerHTML = '<div class="note">No codes (empty input).</div>';
      return;
    }
    const items = entries.map(([ch, code]) => {
      const cnt = freqMap.get(ch) || 0;
      return { ch, code, cnt, len: code.length };
    });
    if (canonical) {
      items.sort((a,b)=> (a.len - b.len) || (a.code.localeCompare(b.code)) || (a.ch.localeCompare(b.ch)));
    } else {
      items.sort((a,b)=> b.cnt - a.cnt);
    }
    for (const it of items) {
      const row = document.createElement('div');
      row.className = 'code-row';
      const charBox = document.createElement('div');
      charBox.className = 'char-box';
      charBox.textContent = displayChar(it.ch);
      const codeBox = document.createElement('div');
      codeBox.className = 'mono';
      codeBox.textContent = it.code;
      const meta = document.createElement('div');
      meta.className = 'small';
      meta.textContent = `${it.cnt} × ${it.len} bits = ${it.cnt * it.len} bits`;
      row.append(charBox, codeBox, meta);
      container.appendChild(row);
    }
  }

  function renderSteps(steps) {
    const container = els.stepsList;
    container.innerHTML = '';
    if (!steps || steps.length === 0) {
      container.innerHTML = '<div class="note">No merges (single or empty input).</div>';
      return;
    }
    let i = 1;
    for (const st of steps) {
      const div = document.createElement('div');
      div.className = 'step';
      const title = document.createElement('div');
      title.className = 'title';
      title.textContent = `Step ${i++}: Merge two lowest-frequency nodes`;
      const body = document.createElement('div');
      const leftLabel = st.left.char !== null ? `‘${displayChar(st.left.char)}’ (${st.left.freq})` : `node(${st.left.freq})`;
      const rightLabel = st.right.char !== null ? `‘${displayChar(st.right.char)}’ (${st.right.freq})` : `node(${st.right.freq})`;
      body.textContent = `Merged ${leftLabel} + ${rightLabel} -> node(${st.parent.freq})`;
      div.append(title, body);
      container.appendChild(div);
    }
  }

  function renderEncodedBits(bits) {
    const showFull = state.showFullBits;
    const maxShow = 900;
    if (!bits || bits.length === 0) {
      els.encodedBits.textContent = '(empty)';
      return;
    }
    if (showFull || bits.length <= maxShow) {
      els.encodedBits.textContent = bits;
    } else {
      const head = bits.slice(0, maxShow);
      els.encodedBits.textContent = head + ' … (+' + (bits.length - head.length) + ' bits)';
    }
  }

  // Events
  els.buildBtn.addEventListener('click', renderAll);
  els.decodeBtn.addEventListener('click', () => {
    const res = state.result;
    if (!res) return;
    const decoded = decodeBits(res.root, res.encodedBits, res.freqMap, res.totalChars);
    els.decodedText.textContent = decoded;
    const ok = decoded === (els.input.value || '');
    els.decodeStatus.textContent = ok ? 'OK' : 'Mismatch';
    els.decodeStatus.className = 'mono ' + (ok ? 'ok' : 'fail');
  });
  els.randomBtn.addEventListener('click', () => {
    const samples = [
      'this is an example of a huffman tree',
      'banana bandana',
      'the quick brown fox jumps over the lazy dog',
      'aaaaabcccdde',
      'lorem ipsum dolor sit amet, consectetur adipiscing elit',
      'mississippi river',
      'hello hello hello world'
    ];
    const s = samples[Math.floor(Math.random() * samples.length)];
    els.input.value = s;
    renderAll();
  });
  els.clearBtn.addEventListener('click', () => {
    els.input.value = '';
    renderAll();
  });
  els.showSteps.addEventListener('change', () => {
    renderAll();
  });
  els.showTree.addEventListener('change', () => {
    renderAll();
  });
  els.canonical.addEventListener('change', () => {
    renderAll();
  });
  els.copyBits.addEventListener('click', async () => {
    const res = state.result;
    if (!res || !res.encodedBits) return;
    try {
      await navigator.clipboard.writeText(res.encodedBits);
      els.copyBits.textContent = 'Copied!';
      setTimeout(()=> els.copyBits.textContent = 'Copy Bits', 1000);
    } catch (e) {
      alert('Clipboard copy failed.');
    }
  });
  els.toggleBits.addEventListener('click', () => {
    state.showFullBits = !state.showFullBits;
    renderEncodedBits(state.result ? state.result.encodedBits : '');
    els.toggleBits.textContent = state.showFullBits ? 'Show less' : 'Toggle full bits view';
  });

  // Auto-build on load and on typing
  let typingTimer = null;
  els.input.addEventListener('input', () => {
    clearTimeout(typingTimer);
    typingTimer = setTimeout(renderAll, 150);
  });

  // Initial render
  renderAll();
})();
</script>
</body>
</html>