<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Adjacency List Graph Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-2: #0b1220;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #38bdf8;
      --accent-2: #34d399;
      --danger: #ef4444;
      --warn: #f59e0b;
      --edge: #93c5fd;
      --node: #60a5fa;
      --visited: #a78bfa;
      --queue: #f87171;
      --neighbor: #34d399;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1000px 500px at 10% 10%, #0b1220, var(--bg));
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    header {
      padding: 16px 20px;
      border-bottom: 1px solid #1f2937;
      display: flex;
      align-items: center;
      gap: 16px;
    }
    header h1 {
      margin: 0;
      font-size: 20px;
      letter-spacing: 0.4px;
    }
    header .sub {
      color: var(--muted);
      font-size: 12px;
    }
    main {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 16px;
      padding: 16px;
      height: calc(100% - 66px);
    }
    .panel {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid #1f2937;
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.25);
      overflow: hidden;
    }
    .panel h2 {
      font-size: 14px;
      margin: 8px 0 10px;
      color: var(--muted);
      letter-spacing: 0.3px;
    }
    .controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      overflow-y: auto;
      max-height: calc(100% - 12px);
      padding-right: 4px;
    }
    .group {
      border: 1px dashed #243244;
      border-radius: 10px;
      padding: 10px;
      background: rgba(20, 30, 46, 0.5);
    }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    label {
      font-size: 12px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }
    input, select, button {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #243244;
      background: #0e1524;
      color: var(--text);
      outline: none;
    }
    input::placeholder { color: #6b7280; }
    input[type="number"] { appearance: textfield; }
    .row button { margin-top: 22px; }
    .btn {
      border: 1px solid #243244;
      background: #0e1524;
      cursor: pointer;
      transition: transform 0.05s ease, background 0.2s ease, border 0.2s ease;
    }
    .btn:hover { background: #0b1220; }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background: #0e1a30; border-color: #214b72; }
    .btn.accent { background: #0c2430; border-color: #2563eb; }
    .btn.warn { background: #231a07; border-color: #f59e0b; }
    .btn.danger { background: #2b0d0f; border-color: #ef4444; }
    .inline { display: flex; gap: 8px; align-items: center; }
    .toggle { display: inline-flex; align-items: center; gap: 8px; }
    .toggle input { width: auto; }
    .adj {
      background: #0b1220;
      border-radius: 8px;
      border: 1px solid #243244;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
      white-space: pre;
      overflow: auto;
      max-height: 220px;
    }
    .legend {
      display: flex; gap: 10px; flex-wrap: wrap;
      font-size: 12px; color: var(--muted);
      margin-top: 8px;
    }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; }
    .dot.node { background: var(--node); }
    .dot.edge { background: var(--edge); }
    .dot.visited { background: var(--visited); }
    .dot.queue { background: var(--queue); }
    .dot.neighbor { background: var(--neighbor); }
    #graphPanel {
      position: relative;
      display: grid;
      grid-template-rows: auto 1fr 160px;
      gap: 8px;
      min-height: 480px;
    }
    #svgWrap {
      position: relative;
      border: 1px dashed #243244;
      border-radius: 10px;
      background:
        radial-gradient(600px 200px at 70% 30%, rgba(56,189,248,0.05), transparent),
        linear-gradient(180deg, rgba(18,25,39,0.95), rgba(13,19,31,0.9));
      overflow: hidden;
    }
    svg { width: 100%; height: 100%; display: block; }
    .node {
      cursor: pointer;
      transition: filter 0.2s ease;
    }
    .node circle {
      fill: rgba(96,165,250,0.2);
      stroke: var(--node);
      stroke-width: 2;
    }
    .node text {
      font-size: 12px;
      fill: var(--text);
      pointer-events: none;
      user-select: none;
    }
    .node.highlight circle { stroke: var(--neighbor); fill: rgba(52,211,153,0.15); }
    .node.visited circle { stroke: var(--visited); fill: rgba(167,139,250,0.15); }
    .node.in-queue circle { stroke: var(--queue); fill: rgba(248,113,113,0.12); }
    .edge {
      stroke: var(--edge);
      stroke-width: 2;
      opacity: 0.9;
    }
    .edge.undirected { stroke-dasharray: 2 2; opacity: 0.8; }
    .edge.highlight { stroke: var(--neighbor); }
    .edge.visited { stroke: var(--visited); }
    .weight {
      font-size: 11px;
      fill: #e5e7eb;
      opacity: 0.8;
      pointer-events: none;
      user-select: none;
    }
    .hint {
      font-size: 12px;
      color: var(--muted);
    }
    .bfs {
      display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
    }
    .bpanel {
      border: 1px dashed #243244;
      border-radius: 10px;
      padding: 10px;
      background: rgba(20,30,46,0.5);
    }
    .bpanel h3 {
      margin: 0 0 8px; font-size: 13px; color: var(--muted);
    }
    .bcontent {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
      white-space: pre-wrap;
      line-height: 1.4;
      color: var(--text);
      min-height: 80px;
    }
    .footer {
      font-size: 12px;
      color: var(--muted);
      padding: 6px 10px;
      border-top: 1px solid #1f2937;
    }
    .small { font-size: 11px; color: var(--muted); }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .grid3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
    .inline-hint { font-size: 11px; color: var(--muted); margin-top: 6px; }
  </style>
</head>
<body>
  <header>
    <h1>Adjacency List</h1>
    <div class="sub">Build a graph, see its adjacency list, and watch BFS traverse using it</div>
  </header>

  <main>
    <div class="panel">
      <h2>Graph Builder</h2>
      <div class="controls">
        <div class="group">
          <label>Quick add</label>
          <div class="inline">
            <button id="add3" class="btn">Add 3 nodes</button>
            <button id="add5" class="btn">Add 5 nodes</button>
            <button id="randomGraph" class="btn">Random graph</button>
          </div>
          <div class="inline-hint">Use quick add or create nodes/edges below. Right-click nodes/edges to remove.</div>
        </div>

        <div class="group">
          <div class="row">
            <div>
              <label>Node label</label>
              <input id="nodeLabel" type="text" placeholder="e.g., A" />
            </div>
            <div>
              <button id="addNodeBtn" class="btn primary">Add node</button>
            </div>
          </div>
          <div class="inline small">Nodes get random positions; drag to rearrange.</div>
        </div>

        <div class="group">
          <div class="row">
            <div>
              <label>From</label>
              <select id="edgeFrom"></select>
            </div>
            <div>
              <label>To</label>
              <select id="edgeTo"></select>
            </div>
          </div>
          <div class="grid3" style="margin-top:8px">
            <div class="toggle">
              <input id="edgeDirected" type="checkbox" checked />
              <label for="edgeDirected">Directed</label>
            </div>
            <div>
              <label>Weight (optional)</label>
              <input id="edgeWeight" type="number" min="0" placeholder="e.g., 1" />
            </div>
            <div>
              <button id="addEdgeBtn" class="btn accent">Add edge</button>
            </div>
          </div>
        </div>

        <div class="group">
          <div class="grid2">
            <button id="clearBtn" class="btn danger">Clear graph</button>
            <button id="recenterBtn" class="btn">Recenter nodes</button>
          </div>
          <div class="legend">
            <span><span class="dot node"></span>Node</span>
            <span><span class="dot edge"></span>Edge</span>
            <span><span class="dot neighbor"></span>Neighbors</span>
            <span><span class="dot visited"></span>BFS visited</span>
            <span><span class="dot queue"></span>BFS queue</span>
          </div>
        </div>

        <div class="group">
          <h2>Adjacency List</h2>
          <div id="adjacency" class="adj"></div>
          <div class="inline small">Click a node to highlight its neighbors.</div>
        </div>

        <div class="group">
          <h2>Breadth-First Search (uses adj. list)</h2>
          <div class="grid3">
            <div>
              <label>Start</label>
              <select id="bfsStart"></select>
            </div>
            <div>
              <label>Target (optional)</label>
              <select id="bfsTarget"></select>
            </div>
            <div class="inline">
              <button id="bfsRun" class="btn primary">Run</button>
              <button id="bfsStep" class="btn">Step</button>
              <button id="bfsPlay" class="btn">Auto</button>
            </div>
          </div>
          <div class="bfs" style="margin-top:8px">
            <div class="bpanel">
              <h3>Queue</h3>
              <div id="bfsQueue" class="bcontent"></div>
            </div>
            <div class="bpanel">
              <h3>Visited</h3>
              <div id="bfsVisited" class="bcontent"></div>
            </div>
          </div>
          <div class="bpanel" style="margin-top:8px">
            <h3>Steps</h3>
            <div id="bfsSteps" class="bcontent"></div>
          </div>
        </div>
      </div>
      <div class="footer">Adjacency list stores each node's neighbors, enabling efficient traversal. Directed edges list only forward neighbors; undirected list both ways.</div>
    </div>

    <div id="graphPanel" class="panel">
      <h2>Graph Visualization</h2>
      <div id="svgWrap">
        <svg id="svg" viewBox="0 0 800 520" preserveAspectRatio="xMidYMid meet">
          <defs>
            <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L9,3 L0,6 Z" fill="#93c5fd" />
            </marker>
            <marker id="arrowH" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L9,3 L0,6 Z" fill="#34d399" />
            </marker>
            <marker id="arrowV" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L9,3 L0,6 Z" fill="#a78bfa" />
            </marker>
          </defs>
          <g id="edges"></g>
          <g id="weights"></g>
          <g id="nodes"></g>
        </svg>
      </div>
      <div class="hint">Hints: Drag nodes to reposition. Click a node to highlight its neighbors from the adjacency list. Right-click nodes or edges to delete. Directed edges show arrowheads; undirected edges are dashed.</div>
    </div>
  </main>

  <script>
    // Graph state
    const state = {
      nodes: [], // {id, label, x, y}
      edges: [], // {from, to, weight, directed}
      nextId: 1,
      labelAlphabetIndex: 0,
      adjacency: new Map(), // label -> [{to, weight}]
      dragging: null,
      bfs: {
        steps: [],
        i: 0,
        playing: false,
        timer: null,
      }
    };

    const svg = document.getElementById('svg');
    const gEdges = document.getElementById('edges');
    const gWeights = document.getElementById('weights');
    const gNodes = document.getElementById('nodes');

    const nodeLabelInput = document.getElementById('nodeLabel');
    const addNodeBtn = document.getElementById('addNodeBtn');

    const edgeFrom = document.getElementById('edgeFrom');
    const edgeTo = document.getElementById('edgeTo');
    const edgeDirected = document.getElementById('edgeDirected');
    const edgeWeight = document.getElementById('edgeWeight');
    const addEdgeBtn = document.getElementById('addEdgeBtn');

    const add3Btn = document.getElementById('add3');
    const add5Btn = document.getElementById('add5');
    const randomGraphBtn = document.getElementById('randomGraph');
    const clearBtn = document.getElementById('clearBtn');
    const recenterBtn = document.getElementById('recenterBtn');

    const adjacencyDiv = document.getElementById('adjacency');

    const bfsStartSel = document.getElementById('bfsStart');
    const bfsTargetSel = document.getElementById('bfsTarget');
    const bfsRunBtn = document.getElementById('bfsRun');
    const bfsStepBtn = document.getElementById('bfsStep');
    const bfsPlayBtn = document.getElementById('bfsPlay');
    const bfsQueueDiv = document.getElementById('bfsQueue');
    const bfsVisitedDiv = document.getElementById('bfsVisited');
    const bfsStepsDiv = document.getElementById('bfsSteps');

    // Utility
    const randBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    const idToLabel = new Map();
    const labelToId = new Map();
    const getNodeById = id => state.nodes.find(n => n.id === id);
    const getNodeByLabel = label => getNodeById(labelToId.get(label));
    const ensureUniqueLabel = (base) => {
      let label = (base || nextAlpha()) || nextAlpha();
      let i = 1;
      while (labelToId.has(label)) {
        label = `${base}${i++}`;
      }
      return label;
    };
    function nextAlpha() {
      const i = state.labelAlphabetIndex++;
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const len = letters.length;
      let label = "";
      let n = i;
      do {
        label = letters[n % len] + label;
        n = Math.floor(n / len) - 1;
      } while (n >= 0);
      return label;
    }
    function clamp(val, min, max) { return Math.min(Math.max(val, min), max); }

    // Core: Adjacency list
    function rebuildAdjacency() {
      state.adjacency = new Map();
      for (const n of state.nodes) {
        state.adjacency.set(n.label, []);
      }
      for (const e of state.edges) {
        const fromLabel = idToLabel.get(e.from);
        const toLabel = idToLabel.get(e.to);
        if (!state.adjacency.has(fromLabel)) state.adjacency.set(fromLabel, []);
        state.adjacency.get(fromLabel).push({ to: toLabel, weight: e.weight });

        if (!e.directed) {
          if (!state.adjacency.has(toLabel)) state.adjacency.set(toLabel, []);
          state.adjacency.get(toLabel).push({ to: fromLabel, weight: e.weight });
        }
      }
      renderAdjacency();
      updateNodeSelects();
    }

    function renderAdjacency() {
      let out = [];
      const entries = Array.from(state.adjacency.entries()).sort((a, b) => a[0].localeCompare(b[0]));
      for (const [label, neighbors] of entries) {
        const ns = neighbors
          .map(n => n.weight != null && n.weight !== "" ? `${n.to}(${n.weight})` : n.to)
          .sort((a, b) => a.localeCompare(b))
          .join(", ");
        out.push(`${label}: ${ns || "(none)"}`);
      }
      adjacencyDiv.textContent = out.length ? out.join("\n") : "Adjacency list is empty. Add nodes and edges.";
    }

    // Rendering graph
    function render() {
      // Edges
      gEdges.innerHTML = "";
      gWeights.innerHTML = "";
      for (let i = 0; i < state.edges.length; i++) {
        const e = state.edges[i];
        const a = getNodeById(e.from);
        const b = getNodeById(e.to);
        if (!a || !b) continue;

        const { x: x1, y: y1 } = a;
        const { x: x2, y: y2 } = b;

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x1);
        line.setAttribute("y1", y1);
        line.setAttribute("x2", x2);
        line.setAttribute("y2", y2);
        line.classList.add("edge");
        if (!e.directed) line.classList.add("undirected");
        if (e.directed) line.setAttribute("marker-end", "url(#arrow)");
        line.dataset.index = i;

        // Right-click to delete edge
        line.addEventListener("contextmenu", (ev) => {
          ev.preventDefault();
          state.edges.splice(i, 1);
          rebuildAdjacency();
          render();
        });

        gEdges.appendChild(line);

        // Weight label at midpoint
        if (e.weight != null && e.weight !== "") {
          const mx = (x1 + x2) / 2;
          const my = (y1 + y2) / 2;
          const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
          text.setAttribute("x", mx + 8);
          text.setAttribute("y", my - 4);
          text.classList.add("weight");
          text.textContent = e.weight;
          gWeights.appendChild(text);
        }
      }

      // Nodes
      gNodes.innerHTML = "";
      for (const n of state.nodes) {
        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        group.classList.add("node");
        group.setAttribute("data-id", n.id);
        group.setAttribute("transform", `translate(${n.x}, ${n.y})`);

        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("r", 16);
        circle.setAttribute("cx", 0);
        circle.setAttribute("cy", 0);

        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("text-anchor", "middle");
        label.setAttribute("alignment-baseline", "middle");
        label.textContent = n.label;

        group.appendChild(circle);
        group.appendChild(label);

        // Dragging
        group.addEventListener("mousedown", (ev) => {
          if (ev.button !== 0) return;
          state.dragging = { id: n.id, offsetX: ev.offsetX - n.x, offsetY: ev.offsetY - n.y };
        });
        svg.addEventListener("mousemove", (ev) => {
          if (!state.dragging) return;
          const rect = svg.getBoundingClientRect();
          const x = clamp(ev.clientX - rect.left - state.dragging.offsetX, 16, rect.width - 16);
          const y = clamp(ev.clientY - rect.top - state.dragging.offsetY, 16, rect.height - 16);
          const node = getNodeById(state.dragging.id);
          node.x = x; node.y = y;
          render();
        });
        svg.addEventListener("mouseup", () => { state.dragging = null; });
        svg.addEventListener("mouseleave", () => { state.dragging = null; });

        // Click to highlight neighbors
        group.addEventListener("click", () => {
          highlightNeighbors(n.label);
        });

        // Right-click to delete node
        group.addEventListener("contextmenu", (ev) => {
          ev.preventDefault();
          removeNode(n.id);
        });

        gNodes.appendChild(group);
      }
    }

    function highlightNeighbors(label) {
      const neighbors = (state.adjacency.get(label) || []).map(n => n.to);
      const neighborIds = new Set(neighbors.map(l => labelToId.get(l)));

      // reset classes
      for (const g of Array.from(gNodes.children)) {
        g.classList.remove("highlight");
      }
      for (const edge of Array.from(gEdges.children)) {
        edge.classList.remove("highlight");
        // adjust marker color back to default arrow
        if (edge.getAttribute("marker-end")) edge.setAttribute("marker-end", "url(#arrow)");
      }

      // highlight selected and neighbors
      const selId = labelToId.get(label);
      for (const g of Array.from(gNodes.children)) {
        const id = Number(g.getAttribute("data-id"));
        if (id === selId || neighborIds.has(id)) {
          g.classList.add("highlight");
        }
      }

      // highlight edges from selected to neighbors
      for (let i = 0; i < state.edges.length; i++) {
        const e = state.edges[i];
        if (e.from === selId && neighborIds.has(e.to)) {
          const edgeEl = gEdges.querySelector(`[data-index="${i}"]`);
          if (edgeEl) {
            edgeEl.classList.add("highlight");
            if (e.directed) edgeEl.setAttribute("marker-end", "url(#arrowH)");
          }
        }
        if (!getEdgeDirected(e) && e.to === selId && neighborIds.has(e.from)) {
          const edgeEl = gEdges.querySelector(`[data-index="${i}"]`);
          if (edgeEl) edgeEl.classList.add("highlight");
        }
      }
    }

    // Graph modification
    function addNode(customLabel) {
      const label = ensureUniqueLabel(customLabel && customLabel.trim() ? customLabel.trim().toUpperCase() : nextAlpha());
      const id = state.nextId++;
      // Random position within SVG viewbox
      const rect = svg.getBoundingClientRect();
      const x = randBetween(40, rect.width - 40);
      const y = randBetween(40, rect.height - 180); // leave space for BFS panel
      const node = { id, label, x, y };
      state.nodes.push(node);
      idToLabel.set(id, label);
      labelToId.set(label, id);
      rebuildAdjacency();
      render();
    }

    function removeNode(id) {
      const label = idToLabel.get(id);
      // Remove edges connected
      state.edges = state.edges.filter(e => e.from !== id && e.to !== id);
      // Remove node
      state.nodes = state.nodes.filter(n => n.id !== id);
      idToLabel.delete(id);
      labelToId.delete(label);
      rebuildAdjacency();
      render();
    }

    function addEdge(fromLabel, toLabel, weight, directed) {
      const fromId = labelToId.get(fromLabel);
      const toId = labelToId.get(toLabel);
      if (fromId == null || toId == null) return;
      if (fromId === toId) return; // no self-loop in this simple demo
      // prevent duplicates of exact same directed edge
      const exists = state.edges.some(e => e.from === fromId && e.to === toId && e.directed === directed && e.weight == weight);
      if (exists) return;
      state.edges.push({ from: fromId, to: toId, weight: weight ?? "", directed: !!directed });
      rebuildAdjacency();
      render();
    }

    function getEdgeDirected(e) { return !!e.directed; }

    function populateSelect(sel, labels) {
      sel.innerHTML = "";
      for (const label of labels) {
        const opt = document.createElement("option");
        opt.value = label;
        opt.textContent = label;
        sel.appendChild(opt);
      }
    }

    function updateNodeSelects() {
      const labels = state.nodes.map(n => n.label).sort((a,b) => a.localeCompare(b));
      populateSelect(edgeFrom, labels);
      populateSelect(edgeTo, labels);
      populateSelect(bfsStartSel, labels);
      const targetLabels = ["(none)", ...labels];
      bfsTargetSel.innerHTML = "";
      for (const label of targetLabels) {
        const opt = document.createElement("option");
        opt.value = label === "(none)" ? "" : label;
        opt.textContent = label;
        bfsTargetSel.appendChild(opt);
      }
    }

    function recenterNodes() {
      const rect = svg.getBoundingClientRect();
      const cx = rect.width / 2;
      const cy = rect.height / 2 - 40;
      const r = Math.min(rect.width, rect.height) / 3;
      const N = state.nodes.length;
      state.nodes.forEach((n, i) => {
        const angle = (i / N) * Math.PI * 2;
        n.x = cx + r * Math.cos(angle);
        n.y = cy + r * Math.sin(angle);
      });
      render();
    }

    function randomGraph() {
      clearGraph();
      const count = randBetween(4, 7);
      for (let i = 0; i < count; i++) addNode();
      const labels = state.nodes.map(n => n.label);
      const m = randBetween(count, count * 2);
      for (let i = 0; i < m; i++) {
        const a = labels[randBetween(0, labels.length - 1)];
        let b = labels[randBetween(0, labels.length - 1)];
        if (a === b) continue;
        const directed = Math.random() < 0.6;
        const w = Math.random() < 0.5 ? randBetween(1, 9) : "";
        addEdge(a, b, w, directed);
      }
      recenterNodes();
    }

    function clearGraph() {
      state.nodes = [];
      state.edges = [];
      state.nextId = 1;
      state.labelAlphabetIndex = 0;
      idToLabel.clear();
      labelToId.clear();
      rebuildAdjacency();
      render();
      resetBFS();
    }

    // BFS demonstration using adjacency list
    function bfsBuildSteps(startLabel, targetLabel) {
      if (!startLabel) return [];
      const adj = state.adjacency;
      const visited = new Set();
      const queue = [];
      const parents = new Map();

      queue.push(startLabel);
      visited.add(startLabel);
      const steps = [];
      steps.push({ type: "init", queue: [...queue], visited: [...visited], note: `Start at ${startLabel}` });

      while (queue.length) {
        const current = queue.shift();
        steps.push({ type: "dequeue", node: current, queue: [...queue], visited: [...visited], note: `Dequeue ${current}` });

        if (targetLabel && current === targetLabel) {
          steps.push({ type: "found", node: current, queue: [...queue], visited: [...visited], note: `Found target ${current}` });
          break;
        }

        const neighbors = (adj.get(current) || []).map(n => n.to).sort((a,b) => a.localeCompare(b));
        steps.push({ type: "neighbors", node: current, neighbors, queue: [...queue], visited: [...visited], note: `Neighbors of ${current}: ${neighbors.join(", ") || "(none)"}` });

        for (const nb of neighbors) {
          if (!visited.has(nb)) {
            visited.add(nb);
            parents.set(nb, current);
            queue.push(nb);
            steps.push({ type: "enqueue", node: nb, from: current, queue: [...queue], visited: [...visited], note: `Visit ${nb} (from ${current}) and enqueue` });
          } else {
            steps.push({ type: "skip", node: nb, from: current, queue: [...queue], visited: [...visited], note: `Skip ${nb} (already visited)` });
          }
        }
      }

      if (targetLabel && !steps.some(s => s.type === "found")) {
        steps.push({ type: "notfound", node: targetLabel, note: `Target ${targetLabel} not reachable from ${startLabel}` });
      }

      // Add path reconstruction step if found
      if (steps.some(s => s.type === "found")) {
        const path = [];
        let cur = targetLabel || startLabel;
        while (cur != null) {
          path.unshift(cur);
          cur = parents.get(cur);
          if (cur === startLabel && targetLabel) { path.unshift(cur); break; }
        }
        steps.push({ type: "path", path, note: `Path: ${path.join(" -> ")}` });
      }
      return steps;
    }

    function resetBFS() {
      state.bfs.steps = [];
      state.bfs.i = 0;
      stopAuto();
      bfsQueueDiv.textContent = "";
      bfsVisitedDiv.textContent = "";
      bfsStepsDiv.textContent = "";
      // Clear BFS highlights
      for (const g of Array.from(gNodes.children)) {
        g.classList.remove("visited", "in-queue");
      }
      for (const e of Array.from(gEdges.children)) {
        e.classList.remove("visited");
        if (e.getAttribute("marker-end")) e.setAttribute("marker-end", "url(#arrow)");
      }
    }

    function applyBFSVisual(step) {
      // Update queue/visited text
      bfsQueueDiv.textContent = (step.queue || []).join("  ");
      bfsVisitedDiv.textContent = (step.visited || []).join("  ");
      bfsStepsDiv.textContent += (bfsStepsDiv.textContent ? "\n" : "") + (step.note || "");

      // Visual states for nodes
      const queueSet = new Set(step.queue || []);
      const visitedSet = new Set(step.visited || []);
      for (const g of Array.from(gNodes.children)) {
        const label = idToLabel.get(Number(g.getAttribute("data-id")));
        g.classList.toggle("visited", visitedSet.has(label));
        g.classList.toggle("in-queue", queueSet.has(label));
      }

      // Highlight current dequeue node
      if (step.type === "dequeue" || step.type === "neighbors") {
        const current = step.node;
        const id = labelToId.get(current);
        const g = gNodes.querySelector(`[data-id="${id}"]`);
        if (g) {
          g.classList.add("visited");
        }
      }

      // Highlight edges used when enqueue
      if (step.type === "enqueue" || step.type === "skip") {
        const fromId = labelToId.get(step.from);
        const toId = labelToId.get(step.node);
        for (let i = 0; i < state.edges.length; i++) {
          const e = state.edges[i];
          const edgeEl = gEdges.querySelector(`[data-index="${i}"]`);
          if (!edgeEl) continue;
          if (e.from === fromId && e.to === toId) {
            edgeEl.classList.add("visited");
            edgeEl.setAttribute("marker-end", "url(#arrowV)");
          } else if (!getEdgeDirected(e) && e.to === fromId && e.from === toId) {
            edgeEl.classList.add("visited");
          }
        }
      }
    }

    function runBFS() {
      resetBFS();
      const start = bfsStartSel.value;
      const target = bfsTargetSel.value || "";
      if (!start) return;
      state.bfs.steps = bfsBuildSteps(start, target);
      state.bfs.i = 0;
      if (!state.bfs.steps.length) return;
      const s0 = state.bfs.steps[state.bfs.i++];
      applyBFSVisual(s0);
    }

    function stepBFS() {
      if (!state.bfs.steps.length) return;
      if (state.bfs.i >= state.bfs.steps.length) return;
      const s = state.bfs.steps[state.bfs.i++];
      applyBFSVisual(s);
    }

    function stopAuto() {
      state.bfs.playing = false;
      if (state.bfs.timer) {
        clearInterval(state.bfs.timer);
        state.bfs.timer = null;
      }
      bfsPlayBtn.textContent = "Auto";
    }

    function playBFS() {
      if (!state.bfs.steps.length) return;
      if (state.bfs.playing) {
        stopAuto();
        return;
      }
      state.bfs.playing = true;
      bfsPlayBtn.textContent = "Pause";
      state.bfs.timer = setInterval(() => {
        if (state.bfs.i >= state.bfs.steps.length) {
          stopAuto();
        } else {
          stepBFS();
        }
      }, 700);
    }

    // Event bindings
    addNodeBtn.addEventListener("click", () => {
      addNode(nodeLabelInput.value);
      nodeLabelInput.value = "";
    });
    addEdgeBtn.addEventListener("click", () => {
      const from = edgeFrom.value;
      const to = edgeTo.value;
      const w = edgeWeight.value;
      const directed = edgeDirected.checked;
      addEdge(from, to, w, directed);
    });
    add3Btn.addEventListener("click", () => {
      for (let i = 0; i < 3; i++) addNode();
      recenterNodes();
    });
    add5Btn.addEventListener("click", () => {
      for (let i = 0; i < 5; i++) addNode();
      recenterNodes();
    });
    randomGraphBtn.addEventListener("click", randomGraph);
    clearBtn.addEventListener("click", clearGraph);
    recenterBtn.addEventListener("click", recenterNodes);

    bfsRunBtn.addEventListener("click", runBFS);
    bfsStepBtn.addEventListener("click", stepBFS);
    bfsPlayBtn.addEventListener("click", playBFS);

    // Initialize
    rebuildAdjacency();
    render();

    // Start with a small sample graph
    for (let i = 0; i < 4; i++) addNode();
    addEdge(state.nodes[0].label, state.nodes[1].label, "", true);
    addEdge(state.nodes[0].label, state.nodes[2].label, 2, true);
    addEdge(state.nodes[1].label, state.nodes[3].label, "", false);
    recenterNodes();
  </script>
</body>
</html>