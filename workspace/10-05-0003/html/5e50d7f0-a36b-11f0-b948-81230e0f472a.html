<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Merge Sort Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f172a;
      --panel:#111827;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --accent:#60a5fa;
      --compare:#f59e0b;
      --write:#10b981;
      --left:#a78bfa;
      --right:#22d3ee;
      --stable:#fbbf24;
      --bar:#3b82f6;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background:linear-gradient(180deg, #0b1023 0%, #0f172a 100%);
      color:var(--text);
    }
    header{
      padding:20px 16px 8px;
    }
    h1{
      margin:0 0 6px 0;
      font-size:22px;
      font-weight:700;
      letter-spacing:.2px;
    }
    p.sub{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }
    .container{
      padding:12px 16px 24px;
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
    }
    .controls, .legend, .stats, .explain{
      background:rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.07);
      border-radius:12px;
      padding:12px;
    }
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      align-items:flex-end;
    }
    .controls .group{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width:160px;
    }
    .controls label{
      font-size:12px;
      color:var(--muted);
    }
    .controls input[type="range"]{
      width:220px;
    }
    .controls input[type="text"]{
      width:320px;
      padding:8px 10px;
      background:#0b1222;
      color:var(--text);
      border:1px solid rgba(255,255,255,0.1);
      border-radius:8px;
      font-size:14px;
    }
    .btn-row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    button{
      background:#1f2937;
      color:var(--text);
      border:1px solid rgba(255,255,255,.12);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-size:14px;
      transition:transform .02s ease, background .2s ease, border .2s ease, color .2s ease;
      user-select:none;
    }
    button:hover{ background:#273244; }
    button:active{ transform:translateY(1px) }
    button.primary{
      background:linear-gradient(180deg,#2563eb,#1d4ed8);
      border-color:transparent;
    }
    button.primary:hover{ filter:brightness(1.05) }
    button:disabled{
      opacity:.6;
      cursor:not-allowed;
    }

    .legend{
      display:flex;
      flex-wrap:wrap;
      gap:12px 18px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .dot{
      width:16px;height:10px;border-radius:3px;background:var(--bar);border:1px solid rgba(255,255,255,.15)
    }
    .dot.left{ background:var(--left) }
    .dot.right{ background:var(--right) }
    .dot.compare{ background:var(--compare) }
    .dot.write{ background:var(--write) }
    .dot.stable{ background:var(--stable) }

    .viz-wrap{
      background:rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.07);
      border-radius:14px;
      padding:14px 12px 6px;
    }
    .bars{
      height:340px;
      display:flex;
      align-items:flex-end;
      gap:6px;
      padding:6px 4px 10px;
      overflow-x:auto;
      overflow-y:hidden;
    }
    .bar{
      position:relative;
      flex:1 0 auto;
      min-width:16px;
      background:var(--bar);
      border-radius:6px 6px 4px 4px;
      border:1px solid rgba(255,255,255,0.12);
      transition:height .25s ease, background .15s ease, transform .15s ease, border-color .15s ease, box-shadow .15s ease, opacity .15s ease;
      display:flex;
      align-items:flex-end;
      justify-content:center;
    }
    .bar.leftSeg{ background:var(--left) }
    .bar.rightSeg{ background:var(--right) }
    .bar.compare{
      outline:2px solid var(--compare);
      box-shadow:0 0 0 2px rgba(0,0,0,0), 0 0 14px rgba(245,158,11,.25) inset;
      filter:saturate(1.2);
    }
    .bar.write{
      outline:2px solid var(--write);
      box-shadow:0 0 0 2px rgba(0,0,0,0), 0 0 22px rgba(16,185,129,.3) inset;
      transform:translateY(-2px);
      filter:saturate(1.25);
    }
    .bar.stablePick{
      outline:2px dashed var(--stable);
    }
    .label{
      position:absolute;
      top:-18px;
      font-size:12px;
      color:var(--text);
      background:rgba(0,0,0,.2);
      padding:2px 6px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(2px);
      pointer-events:none;
    }
    .sublabel{
      position:absolute;
      bottom:4px;
      right:4px;
      font-size:11px;
      color:#e2e8f0;
      background:rgba(0,0,0,.25);
      padding:2px 6px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.08);
      pointer-events:none;
    }
    .stats{
      display:flex;flex-wrap:wrap;gap:12px;align-items:center
    }
    .stat{
      background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.07);
      border-radius:10px;
      padding:8px 10px;
      min-width:120px;
    }
    .stat .k{ font-size:11px; color:var(--muted); }
    .stat .v{ font-size:16px; font-weight:700; }
    .explain{
      font-size:14px;
      color:#dce3ee;
    }
    .explain ul{ margin:6px 0 0 20px }
    .explain li{ margin:6px 0 }
    .foot{
      padding:8px 16px 24px;
      font-size:12px;
      color:var(--muted);
      text-align:center;
    }
    @media (min-width: 980px){
      .container{
        grid-template-columns: 1.1fr .9fr;
        grid-template-areas:
          "controls explain"
          "legend explain"
          "viz explain"
          "stats explain";
      }
      .controls{ grid-area:controls }
      .legend{ grid-area:legend }
      .viz-wrap{ grid-area:viz }
      .stats{ grid-area:stats }
      .explain{ grid-area:explain; position:sticky; top:12px; align-self:start; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Merge Sort Visualizer</h1>
    <p class="sub">A stable, divide-and-conquer sorting algorithm with O(n log n) time</p>
  </header>

  <div class="container">
    <div class="controls">
      <div class="group">
        <label for="size">Array size: <span id="sizeVal">20</span></label>
        <input id="size" type="range" min="4" max="100" value="20" />
      </div>
      <div class="group">
        <label for="speed">Speed (ms/step): <span id="speedVal">180</span></label>
        <input id="speed" type="range" min="30" max="900" step="10" value="180" />
      </div>
      <div class="group">
        <label for="range">Value max: <span id="maxVal">99</span></label>
        <input id="range" type="range" min="9" max="999" step="1" value="99" />
      </div>
      <div class="group" style="min-width:340px;">
        <label for="manual">Custom array (comma or space separated)</label>
        <input id="manual" type="text" placeholder="e.g. 8, 3, 5, 4, 7, 6, 1, 2" />
      </div>
      <div class="btn-row">
        <button id="applyInput">Apply Input</button>
        <button id="randomize">Randomize</button>
        <button id="nearly">Nearly Sorted</button>
        <button id="reverse">Reverse</button>
      </div>
      <div class="btn-row">
        <button id="start" class="primary">Start Sort</button>
        <button id="pause">Pause</button>
        <button id="step">Step</button>
        <button id="reset">Reset</button>
      </div>
    </div>

    <div class="legend">
      <div class="chip"><span class="dot"></span> Unmarked</div>
      <div class="chip"><span class="dot left"></span> Left half</div>
      <div class="chip"><span class="dot right"></span> Right half</div>
      <div class="chip"><span class="dot compare"></span> Comparing</div>
      <div class="chip"><span class="dot write"></span> Writing</div>
      <div class="chip"><span class="dot stable"></span> Stable tie pick</div>
    </div>

    <div class="viz-wrap">
      <div id="bars" class="bars" aria-label="Array bars"></div>
    </div>

    <div class="stats">
      <div class="stat">
        <div class="k">Length</div>
        <div class="v" id="statN">0</div>
      </div>
      <div class="stat">
        <div class="k">Comparisons</div>
        <div class="v" id="statC">0</div>
      </div>
      <div class="stat">
        <div class="k">Writes</div>
        <div class="v" id="statW">0</div>
      </div>
      <div class="stat">
        <div class="k">Status</div>
        <div class="v" id="statS">Idle</div>
      </div>
    </div>

    <div class="explain">
      <strong>What is Merge Sort?</strong>
      <ul>
        <li>Divide: Recursively split the array into halves until subarrays have size 1.</li>
        <li>Conquer: Merge adjacent sorted subarrays by repeatedly choosing the smaller front element.</li>
        <li>Stable: When values tie, Merge Sort keeps their original relative order (highlighted as “Stable tie pick”).</li>
        <li>Time complexity: O(n log n) in the best, average, and worst case.</li>
        <li>Space complexity: O(n) extra space for the merging process.</li>
      </ul>
      <br />
      Tips:
      <ul>
        <li>Use the slider to change array size or speed. Try “Nearly Sorted” or “Reverse” to see behavior on different inputs.</li>
        <li>The number in each bar’s pill is the value; the round badge shows the original index so you can verify stability for equal values.</li>
      </ul>
    </div>
  </div>

  <div class="foot">
    Merge Sort visualization — step through the algorithm to see splitting and merging in action.
  </div>

  <script>
    // State
    const state = {
      arr: [],
      original: [],
      steps: null,     // generator iterator
      playing: false,
      timer: null,
      speed: 180,
      maxValue: 99,
      // highlights
      segment: null,   // {l, m, r}
      comparing: new Set(),
      writingIndex: -1,
      stablePickAt: -1,
      // stats
      comps: 0,
      writes: 0,
      done: false
    };

    // DOM elements
    const elBars = document.getElementById('bars');
    const elSize = document.getElementById('size');
    const elSizeVal = document.getElementById('sizeVal');
    const elSpeed = document.getElementById('speed');
    const elSpeedVal = document.getElementById('speedVal');
    const elRange = document.getElementById('range');
    const elMaxVal = document.getElementById('maxVal');
    const elManual = document.getElementById('manual');
    const elApplyInput = document.getElementById('applyInput');
    const elRandomize = document.getElementById('randomize');
    const elNearly = document.getElementById('nearly');
    const elReverse = document.getElementById('reverse');
    const elStart = document.getElementById('start');
    const elPause = document.getElementById('pause');
    const elStep = document.getElementById('step');
    const elReset = document.getElementById('reset');
    const statN = document.getElementById('statN');
    const statC = document.getElementById('statC');
    const statW = document.getElementById('statW');
    const statS = document.getElementById('statS');

    // Helpers
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

    function buildRandom(n, maxVal) {
      const a = Array.from({length: n}, (_, i) => ({ value: randInt(0, maxVal), id: i }));
      return a;
    }
    function buildNearlySorted(n, maxVal) {
      const base = Array.from({length: n}, (_, i) => ({ value: Math.round((i/(n-1||1))*maxVal), id: i }));
      // Introduce small perturbations
      for (let k = 0; k < Math.max(1, Math.floor(n/8)); k++){
        const i = randInt(0, n-1), j = Math.min(n-1, i + randInt(1, 3));
        [base[i], base[j]] = [base[j], base[i]];
      }
      return base;
    }
    function buildReverse(n, maxVal) {
      const base = Array.from({length: n}, (_, i) => ({ value: Math.round((i/(n-1||1))*maxVal), id: i }));
      base.reverse();
      // Keep original id as original position before reverse to show stability effect
      base.forEach((item, idx) => { /* id remains from build; reverse preserved id mapping */ });
      return base;
    }
    function parseManual(str, maxVal){
      const tokens = str.trim().replace(/,/g,' ').split(/\s+/).filter(Boolean);
      if (tokens.length === 0) return null;
      const nums = [];
      for (let i=0;i<tokens.length;i++){
        const v = Number(tokens[i]);
        if (!Number.isFinite(v)) return null;
        const vv = Math.max(0, Math.min(maxVal, Math.round(v)));
        nums.push(vv);
      }
      return nums.map((v,i) => ({ value: v, id: i }));
    }

    // Visualization
    function render() {
      // stats
      statN.textContent = state.arr.length;
      statC.textContent = state.comps;
      statW.textContent = state.writes;
      statS.textContent = state.done ? 'Done' : (state.playing ? 'Running' : 'Paused');

      // compute scale
      let maxVal = 1;
      for (const it of state.arr) maxVal = Math.max(maxVal, it.value);
      // Create bars
      elBars.innerHTML = '';
      const n = state.arr.length;
      const width = Math.max(16, Math.floor( (elBars.clientWidth - (n-1)*6 - 8) / Math.max(1, n) ));
      state.arr.forEach((item, idx) => {
        const hPct = maxVal === 0 ? 0 : (item.value / maxVal);
        const px = Math.round(20 + hPct * 300); // min 20px height for zeros
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.style.height = px + 'px';
        bar.style.minWidth = width + 'px';

        // segment colors
        if (state.segment){
          if (idx >= state.segment.l && idx < state.segment.m) bar.classList.add('leftSeg');
          else if (idx >= state.segment.m && idx < state.segment.r) bar.classList.add('rightSeg');
        }
        if (state.comparing.has(idx)) bar.classList.add('compare');
        if (state.writingIndex === idx) bar.classList.add('write');
        if (state.stablePickAt === idx) bar.classList.add('stablePick');

        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = item.value;

        const sub = document.createElement('div');
        sub.className = 'sublabel';
        sub.title = 'Original index';
        sub.textContent = item.id;

        bar.appendChild(label);
        bar.appendChild(sub);
        elBars.appendChild(bar);
      });
    }

    function clearHighlights() {
      state.segment = null;
      state.comparing.clear();
      state.writingIndex = -1;
      state.stablePickAt = -1;
    }

    // Merge Sort generator (stable)
    function* mergeSortSteps(arr) {
      const aux = new Array(arr.length);
      yield* rec(arr, aux, 0, arr.length);
      yield { type: 'done' };
      function* rec(a, aux, l, r){
        if (r - l <= 1) return;
        const m = (l + r) >> 1;
        yield* rec(a, aux, l, m);
        yield* rec(a, aux, m, r);

        // before merging, show the segments being merged
        yield { type: 'split', l, m, r };

        // copy to aux
        for (let t = l; t < r; t++){
          aux[t] = a[t];
          yield { type: 'copy', index: t };
        }

        let i = l, j = m;
        for (let k = l; k < r; k++){
          if (i >= m){
            a[k] = aux[j++];
            yield { type: 'write', k, from: j-1, side:'right', l, m, r, stable:false };
          } else if (j >= r){
            a[k] = aux[i++];
            yield { type: 'write', k, from: i-1, side:'left', l, m, r, stable:false };
          } else {
            yield { type: 'compare', i, j, l, m, r };
            if (aux[i].value <= aux[j].value){
              const stable = aux[i].value === aux[j].value;
              a[k] = aux[i++];
              yield { type: 'write', k, from: i-1, side:'left', l, m, r, stable };
            } else {
              a[k] = aux[j++];
              yield { type: 'write', k, from: j-1, side:'right', l, m, r, stable:false };
            }
          }
        }
        yield { type: 'merged', l, m, r };
      }
    }

    // Apply one step to state and re-render
    function applyStep(step){
      if (!step) return;
      switch(step.type){
        case 'split':
          state.segment = { l: step.l, m: step.m, r: step.r };
          state.comparing.clear();
          state.writingIndex = -1;
          state.stablePickAt = -1;
          break;
        case 'copy':
          // We don't need to show copy distinctly; could briefly mark index
          // We'll clear writing highlight to avoid confusion
          state.writingIndex = -1;
          break;
        case 'compare':
          state.segment = { l: step.l, m: step.m, r: step.r };
          state.comparing = new Set([step.i, step.j]);
          state.writingIndex = -1;
          state.stablePickAt = -1;
          state.comps++;
          break;
        case 'write':
          state.segment = { l: step.l, m: step.m, r: step.r };
          state.comparing.clear();
          state.writingIndex = step.k;
          state.stablePickAt = step.stable ? step.k : -1;
          state.writes++;
          break;
        case 'merged':
          // merging range finished
          state.comparing.clear();
          state.writingIndex = -1;
          state.stablePickAt = -1;
          // keep last segment momentarily
          break;
        case 'done':
          clearHighlights();
          state.done = true;
          break;
      }
      render();
    }

    // Control flow
    function stopPlaying(){
      state.playing = false;
      if (state.timer){ clearInterval(state.timer); state.timer = null; }
      render();
    }
    function startPlaying(){
      if (state.done) return;
      state.playing = true;
      if (state.timer){ clearInterval(state.timer); }
      state.timer = setInterval(() => {
        const n = state.steps.next();
        if (n.done){
          applyStep({type:'done'});
          stopPlaying();
          return;
        }
        applyStep(n.value);
      }, state.speed);
      render();
    }

    function resetToOriginal(){
      stopPlaying();
      state.arr = state.original.map(o => ({ value: o.value, id: o.id }));
      state.steps = mergeSortSteps(state.arr);
      state.comps = 0;
      state.writes = 0;
      state.done = false;
      clearHighlights();
      render();
    }

    // UI bindings
    elSize.addEventListener('input', () => {
      elSizeVal.textContent = elSize.value;
    });
    elSpeed.addEventListener('input', () => {
      elSpeedVal.textContent = elSpeed.value;
      state.speed = Number(elSpeed.value);
      if (state.playing){
        // restart interval with new speed
        clearInterval(state.timer);
        state.timer = null;
        startPlaying();
      }
    });
    elRange.addEventListener('input', () => {
      elMaxVal.textContent = elRange.value;
      state.maxValue = Number(elRange.value);
    });

    elApplyInput.addEventListener('click', () => {
      const parsed = parseManual(elManual.value, state.maxValue);
      if (!parsed || parsed.length < 1){
        alert('Please enter a valid list of numbers (comma or space separated).');
        return;
      }
      stopPlaying();
      state.arr = parsed;
      state.original = state.arr.map(o => ({ value: o.value, id: o.id }));
      state.steps = mergeSortSteps(state.arr);
      state.comps = 0;
      state.writes = 0;
      state.done = false;
      elSize.value = parsed.length;
      elSizeVal.textContent = parsed.length;
      render();
    });

    elRandomize.addEventListener('click', () => {
      stopPlaying();
      const n = Number(elSize.value);
      state.arr = buildRandom(n, state.maxValue);
      state.original = state.arr.map(o => ({ value: o.value, id: o.id }));
      state.steps = mergeSortSteps(state.arr);
      state.comps = 0;
      state.writes = 0;
      state.done = false;
      render();
    });

    elNearly.addEventListener('click', () => {
      stopPlaying();
      const n = Number(elSize.value);
      state.arr = buildNearlySorted(n, state.maxValue);
      state.original = state.arr.map(o => ({ value: o.value, id: o.id }));
      state.steps = mergeSortSteps(state.arr);
      state.comps = 0;
      state.writes = 0;
      state.done = false;
      render();
    });

    elReverse.addEventListener('click', () => {
      stopPlaying();
      const n = Number(elSize.value);
      state.arr = buildReverse(n, state.maxValue);
      // Important: preserve original ids from the initial order before reverse?
      // For demonstration, id stays as constructed index (0..n-1) in current array.
      // This still demonstrates stability for duplicates across merges.
      state.original = state.arr.map(o => ({ value: o.value, id: o.id }));
      state.steps = mergeSortSteps(state.arr);
      state.comps = 0;
      state.writes = 0;
      state.done = false;
      render();
    });

    elStart.addEventListener('click', () => {
      if (!state.steps) state.steps = mergeSortSteps(state.arr);
      if (!state.playing && !state.done) startPlaying();
    });
    elPause.addEventListener('click', () => {
      stopPlaying();
    });
    elStep.addEventListener('click', () => {
      if (state.done) return;
      stopPlaying();
      if (!state.steps) state.steps = mergeSortSteps(state.arr);
      const n = state.steps.next();
      if (n.done){
        applyStep({type:'done'});
        stopPlaying();
        return;
      }
      applyStep(n.value);
    });
    elReset.addEventListener('click', () => {
      resetToOriginal();
    });

    // Resize handling: re-render to adjust bar widths
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      if (resizeTimer) cancelAnimationFrame(resizeTimer);
      resizeTimer = requestAnimationFrame(render);
    });

    // Initialize
    function init(){
      state.speed = Number(elSpeed.value);
      state.maxValue = Number(elRange.value);
      elSpeedVal.textContent = state.speed;
      elMaxVal.textContent = state.maxValue;
      elSizeVal.textContent = elSize.value;

      state.arr = buildRandom(Number(elSize.value), state.maxValue);
      state.original = state.arr.map(o => ({ value: o.value, id: o.id }));
      state.steps = mergeSortSteps(state.arr);
      state.comps = 0;
      state.writes = 0;
      state.done = false;
      clearHighlights();
      render();
    }
    init();
  </script>
</body>
</html>