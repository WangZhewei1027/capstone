<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>JavaScript Array - Interactive Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 0; line-height: 1.4; }
    header { padding: 16px 20px; background: #2a5; color: #fff; }
    h1 { margin: 0 0 6px 0; font-size: 1.6rem; }
    .container { padding: 16px 20px; max-width: 1100px; margin: 0 auto; }
    .grid { display: grid; gap: 14px; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
    .card { border: 1px solid #ccc; border-radius: 8px; padding: 12px; background: #fff; }
    .card h2 { margin: 0 0 6px 0; font-size: 1.1rem; }
    .card p { margin: 8px 0; }
    .actions { margin: 10px 0; display: flex; gap: 8px; flex-wrap: wrap; }
    button { cursor: pointer; border: 1px solid #999; background: #f5f5f5; padding: 6px 10px; border-radius: 6px; }
    button:hover { background: #eee; }
    pre { background: #111; color: #0f0; padding: 10px; border-radius: 6px; overflow: auto; min-height: 80px; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .note { font-size: 0.9rem; color: #555; }
    .items { display:flex; gap:6px; flex-wrap:wrap; }
    .items .item { padding: 4px 8px; border: 1px solid #aaa; border-radius: 6px; }
    footer { padding: 16px 20px; color: #555; }
  </style>
</head>
<body>
  <header>
    <h1>JavaScript Arrays: Interactive Examples</h1>
    <div class="note">Click the Run button in each card to see the output. This page demonstrates creation, mutation, iteration, search, transformation, flattening, typed arrays, array-like conversions, and more.</div>
  </header>

  <div class="container">
    <div class="grid">

      <section class="card">
        <h2>1) Creation and Basic Access</h2>
        <p>Arrays can hold mixed types and are zero-indexed. Use length and at() (supports negative indices).</p>
        <div class="actions">
          <button class="run" data-id="basics">Run</button>
        </div>
        <pre id="out-basics"></pre>
      </section>

      <section class="card">
        <h2>2) Push/Pop/Shift/Unshift/Slice/Splice</h2>
        <p>Mutate arrays (push/pop/shift/unshift/splice) or copy (slice).</p>
        <div class="actions">
          <button class="run" data-id="mutate">Run</button>
        </div>
        <pre id="out-mutate"></pre>
      </section>

      <section class="card">
        <h2>3) fill() and copyWithin()</h2>
        <p>In-place modification to repeat or copy segments.</p>
        <div class="actions">
          <button class="run" data-id="fillCopyWithin">Run</button>
        </div>
        <pre id="out-fillCopyWithin"></pre>
      </section>

      <section class="card">
        <h2>4) Iteration</h2>
        <p>for, for...of, and forEach for walking arrays.</p>
        <div class="actions">
          <button class="run" data-id="iterate">Run</button>
        </div>
        <pre id="out-iterate"></pre>
      </section>

      <section class="card">
        <h2>5) map/filter/reduce</h2>
        <p>Transform, narrow, and fold arrays into results.</p>
        <div class="actions">
          <button class="run" data-id="mfr">Run</button>
        </div>
        <pre id="out-mfr"></pre>
      </section>

      <section class="card">
        <h2>6) Search: find/indexOf/includes/some/every</h2>
        <p>Locate elements, test membership, or check predicates.</p>
        <div class="actions">
          <button class="run" data-id="search">Run</button>
        </div>
        <pre id="out-search"></pre>
      </section>

      <section class="card">
        <h2>7) concat/spread/flat/flatMap</h2>
        <p>Combine arrays, flatten nesting, and map+flatten in one step.</p>
        <div class="actions">
          <button class="run" data-id="combine">Run</button>
        </div>
        <pre id="out-combine"></pre>
      </section>

      <section class="card">
        <h2>8) Sorting</h2>
        <p>sort() is in-place; provide a comparator for numeric sorting.</p>
        <div class="actions">
          <button class="run" data-id="sort">Run</button>
        </div>
        <pre id="out-sort"></pre>
      </section>

      <section class="card">
        <h2>9) Destructuring & Rest</h2>
        <p>Extract positions, swap values, collect the remainder.</p>
        <div class="actions">
          <button class="run" data-id="destructure">Run</button>
        </div>
        <pre id="out-destructure"></pre>
      </section>

      <section class="card">
        <h2>10) Array.from and Array.of</h2>
        <p>Create arrays from array-like/iterables or specific values.</p>
        <div class="actions">
          <button class="run" data-id="fromOf">Run</button>
        </div>
        <pre id="out-fromOf"></pre>
      </section>

      <section class="card">
        <h2>11) Array-like objects (arguments, NodeList)</h2>
        <p>Convert array-like to true arrays to use array methods.</p>
        <div class="actions">
          <button class="run" data-id="arrayLike">Run</button>
        </div>
        <div class="items" id="dom-items">
          <span class="item">alpha</span>
          <span class="item">beta</span>
          <span class="item">gamma</span>
        </div>
        <pre id="out-arrayLike"></pre>
      </section>

      <section class="card">
        <h2>12) Sparse arrays and holes</h2>
        <p>Arrays can have holes; many methods skip them. Use fill() to set values.</p>
        <div class="actions">
          <button class="run" data-id="sparse">Run</button>
        </div>
        <pre id="out-sparse"></pre>
      </section>

      <section class="card">
        <h2>13) References vs copies</h2>
        <p>Arrays are reference types; copy explicitly with slice/spread.</p>
        <div class="actions">
          <button class="run" data-id="refs">Run</button>
        </div>
        <pre id="out-refs"></pre>
      </section>

      <section class="card">
        <h2>14) Multidimensional arrays</h2>
        <p>Work with nested arrays and flatten deeply.</p>
        <div class="actions">
          <button class="run" data-id="multi">Run</button>
        </div>
        <pre id="out-multi"></pre>
      </section>

      <section class="card">
        <h2>15) Typed Arrays</h2>
        <p>Fixed-length arrays for binary data with numeric types.</p>
        <div class="actions">
          <button class="run" data-id="typed">Run</button>
        </div>
        <pre id="out-typed"></pre>
      </section>

      <section class="card">
        <h2>16) at(), includes(NaN), isArray</h2>
        <p>Handy helpers for indexing, membership, and type checking.</p>
        <div class="actions">
          <button class="run" data-id="helpers">Run</button>
        </div>
        <pre id="out-helpers"></pre>
      </section>

    </div>
  </div>

  <footer class="container">
    Tip: Prefer non-mutating methods (map/filter/reduce/concat/slice/spread) when you want to preserve the original array. Mutating methods (push/pop/shift/unshift/splice/sort/reverse/fill/copyWithin) change the existing array in place.
  </footer>

  <script>
    // Formatting helpers
    function isTypedArray(v) {
      return v && typeof v === 'object' && v.buffer instanceof ArrayBuffer && ArrayBuffer.isView(v);
    }
    function formatValue(v) {
      const t = typeof v;
      if (v === null) return 'null';
      if (t === 'undefined') return 'undefined';
      if (Array.isArray(v)) return describeArray(v);
      if (isTypedArray(v)) return `${v.constructor.name}[${Array.prototype.join.call(v, ', ')}] length=${v.length}`;
      if (t === 'object') {
        try { return JSON.stringify(v); } catch { return '[object (circular)]'; }
      }
      if (t === 'function') return `Function(${v.name || 'anonymous'})`;
      if (t === 'string') return `"${v}"`;
      return String(v);
    }
    function describeArray(arr) {
      const parts = [];
      for (let i = 0; i < arr.length; i++) {
        if (Object.prototype.hasOwnProperty.call(arr, i)) parts.push(`${i}:${formatValue(arr[i])}`);
        else parts.push(`${i}:<hole>`);
      }
      return `[${parts.join(', ')}] length=${arr.length}`;
    }
    function loggerFor(pre) {
      return (...args) => {
        pre.textContent += args.map(formatValue).join(' ') + '\n';
      };
    }
    function clear(pre) { pre.textContent = ''; }

    // Examples
    const examples = {
      basics(log) {
        const arr = [1, 'two', true, { x: 3 }, [9]];
        log('arr =', arr);
        log('length =', arr.length);
        log('arr[0] =', arr[0], 'arr[3].x =', arr[3].x, 'arr[4][0] =', arr[4][0]);
        log('last element via at(-1) =', arr.at(-1));
        arr[6] = 'gap';
        log('after arr[6]="gap":', arr);
        log('has index 5?', Object.prototype.hasOwnProperty.call(arr, 5));
      },

      mutate(log) {
        const a = ['a', 'b', 'c'];
        log('start:', a);
        a.push('d'); log('push("d") ->', a);
        const popped = a.pop(); log('pop() ->', popped, 'array:', a);
        const shifted = a.shift(); log('shift() ->', shifted, 'array:', a);
        a.unshift('z'); log('unshift("z") ->', a);
        a.splice(1, 1, 'B'); log('splice(1,1,"B") ->', a);
        const copy = a.slice(0, 2); log('slice(0,2) ->', copy, 'original unchanged:', a);
      },

      fillCopyWithin(log) {
        const a = [1, 2, 3, 4, 5];
        log('start:', a);
        a.fill(0, 2, 4); log('fill(0,2,4) ->', a);
        a.copyWithin(0, 3); log('copyWithin(0,3) ->', a, '(copy values from index 3 to start)');
      },

      iterate(log) {
        const a = [10, 20, 30];
        log('for loop:');
        for (let i = 0; i < a.length; i++) log(`i=${i}`, a[i]);
        log('for...of:');
        for (const v of a) log(v);
        log('forEach with index:');
        a.forEach((v, i) => log(`i=${i}`, v));
      },

      mfr(log) {
        const a = [1, 2, 3, 4, 5];
        const squares = a.map(x => x * x);
        log('map x^2 ->', squares);
        const evens = a.filter(x => x % 2 === 0);
        log('filter even ->', evens);
        const sum = a.reduce((acc, x) => acc + x, 0);
        log('reduce sum ->', sum);
        const words = ['apple', 'banana', 'apple', 'cherry', 'banana'];
        const freq = words.reduce((acc, w) => (acc[w] = (acc[w] || 0) + 1, acc), {});
        log('reduce frequency ->', freq);
      },

      search(log) {
        const a = [3, 5, 7, 9];
        log('array:', a);
        log('find(x>6) ->', a.find(x => x > 6));
        log('findIndex(x%2===0) ->', a.findIndex(x => x % 2 === 0));
        log('indexOf(7) ->', a.indexOf(7), 'lastIndexOf(7) ->', a.lastIndexOf(7));
        log('includes(5) ->', a.includes(5), 'includes(42) ->', a.includes(42));
        const b = [NaN, 1, 2];
        log('indexOf(NaN) ->', b.indexOf(NaN), 'includes(NaN) ->', b.includes(NaN));
        log('some(x>8) ->', a.some(x => x > 8), 'every(x>0) ->', a.every(x => x > 0));
      },

      combine(log) {
        const a = [1, 2], b = [3, 4];
        log('concat ->', a.concat(b));
        log('spread ->', [...a, ...b]);
        const nested = [1, [2, [3, 4]], 5];
        log('flat(1) ->', nested.flat(1));
        log('flat(2) ->', nested.flat(2));
        const words = ['hi', 'yo'];
        log('flatMap split ->', words.flatMap(w => w.split('')));
      },

      sort(log) {
        const nums = [10, 2, 5, 1];
        log('original nums:', nums);
        nums.sort(); log('sort() default (lexicographic) ->', nums);
        nums.sort((a, b) => a - b); log('sort((a,b)=>a-b) numeric ->', nums);
        const strs = ['z', 'Ã¤', 'a'];
        log('localeCompare (de) ->', strs.slice().sort((a, b) => a.localeCompare(b, 'de')));
        const objs = [{n:3},{n:1},{n:2}];
        objs.sort((a,b)=>a.n-b.n); log('sort by property n ->', objs);
      },

      destructure(log) {
        const [head, ...tail] = [10, 20, 30, 40];
        log('head:', head, 'tail:', tail);
        let x = 1, y = 2; [x, y] = [y, x];
        log('swap -> x:', x, 'y:', y);
        const [a = 'default', b = 'fallback'] = [undefined];
        log('defaults ->', a, b);
      },

      fromOf(log) {
        log('Array.of(1,2,3) ->', Array.of(1,2,3));
        log('Array.from("hello") ->', Array.from('hello'));
        const set = new Set([1,2,2,3]);
        log('Array.from(new Set([1,2,2,3])) ->', Array.from(set));
        const mapped = Array.from({ length: 5 }, (_, i) => i * 2);
        log('Array.from({length:5}, map) ->', mapped);
      },

      arrayLike(log) {
        function demo() {
          log('arguments:', describeArray(arguments));
          const arr1 = Array.from(arguments);
          const arr2 = [...arguments];
          log('Array.from(arguments) ->', arr1);
          log('[...arguments] ->', arr2);
        }
        demo('x', 'y', 'z');
        const nodes = document.querySelectorAll('#dom-items .item');
        log('NodeList length:', nodes.length);
        const texts = Array.from(nodes, n => n.textContent);
        log('Array.from(NodeList, map text) ->', texts);
      },

      sparse(log) {
        const a = [];
        a[3] = 'x';
        log('a with hole:', a);
        log('keys:', Object.keys(a));
        log('forEach skips holes:');
        a.forEach((v,i)=>log(`i=${i}`, v));
        log('map returns same length and skips holes:');
        const m = a.map(v => String(v).toUpperCase());
        log('mapped:', m);
        log('fill holes:');
        a.fill('filled');
        log('after fill("filled") ->', a);
      },

      refs(log) {
        const a = [1,2];
        const b = a; // same reference
        a.push(3);
        log('a after push ->', a, 'b sees change ->', b);
        const c = a.slice(); // shallow copy
        a.push(4);
        log('a ->', a, 'c (copy) unaffected ->', c);
        const imm = [...a, 99];
        log('immutable update via spread ->', imm, 'original ->', a);
      },

      multi(log) {
        const grid = [
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9]
        ];
        log('grid:', grid);
        const diag = [grid[0][0], grid[1][1], grid[2][2]];
        log('diagonal ->', diag);
        const deep = [1, [2, [3, [4]]], 5];
        const flatAll = deep.flat(Infinity);
        log('flat(Infinity) ->', flatAll);
      },

      typed(log) {
        const bytes = new Uint8Array([255, 128, 1]);
        log('typed:', bytes);
        log('buffer bytes:', bytes.buffer.byteLength, 'length:', bytes.length);
        bytes[0] = 42;
        log('after set ->', bytes);
        bytes.fill(0);
        log('fill(0) ->', bytes);
        const doubles = new Float32Array([0.1, 0.2, 0.3]);
        log('float32:', doubles);
      },

      helpers(log) {
        const a = [10, 20, 30];
        log('a.at(-1) ->', a.at(-1));
        log('Array.isArray(a) ->', Array.isArray(a));
        log('Array.isArray({}) ->', Array.isArray({}));
        const b = [NaN, 0];
        log('b.includes(NaN) ->', b.includes(NaN));
        log('b.indexOf(NaN) ->', b.indexOf(NaN), '(indexOf cannot find NaN)');
      },
    };

    // Wire up buttons
    document.querySelectorAll('button.run').forEach(btn => {
      btn.addEventListener('click', () => {
        const id = btn.dataset.id;
        const pre = document.getElementById('out-' + id);
        if (!examples[id] || !pre) return;
        clear(pre);
        examples[id](loggerFor(pre));
      });
    });
  </script>
</body>
</html>