<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Radix Sort Visualizer (LSD, Base 10)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f1222;
      --panel: #171a2f;
      --accent: #6aa1ff;
      --accent-2: #8be9fd;
      --text: #edf2ff;
      --muted: #9aa3b2;
      --danger: #ff6b6b;
      --ok: #2ecc71;
      --warning: #ffb86c;
      --bucket: #1e2140;
      --chip: #23284c;
      --chip2: #2a2f5c;
      --chip-border: #31407a;
      --shadow: 0 10px 25px rgba(0,0,0,0.35), 0 2px 6px rgba(0,0,0,0.2);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: linear-gradient(180deg, #0f1222 0%, #0a0d1a 100%);
      color: var(--text);
    }

    header {
      padding: 24px 20px 10px 20px;
    }

    h1 {
      margin: 0 0 6px 0;
      font-weight: 800;
      letter-spacing: 0.2px;
      font-size: 26px;
      color: #cfe3ff;
      text-shadow: 0 2px 18px rgba(106,161,255,0.25);
    }
    .sub {
      color: var(--muted);
      font-size: 14px;
    }

    .container {
      padding: 12px 20px 28px;
      display: grid;
      gap: 14px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid #222644;
      border-radius: 14px;
      padding: 14px;
      box-shadow: var(--shadow);
    }

    .controls {
      display: grid;
      gap: 10px;
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .controls input[type="text"] {
      flex: 1 1 340px;
      min-width: 200px;
      background: #11142a;
      border: 1px solid #23284a;
      color: var(--text);
      padding: 10px 12px;
      border-radius: 10px;
      outline: none;
      transition: border-color 0.15s ease;
    }
    .controls input[type="text"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(106,161,255,0.15);
    }

    .btn {
      background: linear-gradient(180deg, #2b66ff, #224ddb);
      color: white;
      border: 1px solid #2f54d8;
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.05s ease, filter 0.2s ease, background 0.2s ease;
      user-select: none;
    }
    .btn:hover { filter: brightness(1.05); }
    .btn:active { transform: translateY(1px); }
    .btn.secondary {
      background: #1f2448;
      color: #d7e1ff;
      border-color: #2a2f5c;
    }
    .btn.warning {
      background: linear-gradient(180deg, #ff8c4a, #e07539);
      border-color: #db6b2f;
    }
    .btn.danger {
      background: linear-gradient(180deg, #ff6b6b, #e15b5b);
      border-color: #cd4d4d;
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      filter: none;
    }

    .speed {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 13px;
      padding: 6px 10px;
      background: #12162d;
      border: 1px solid #222644;
      border-radius: 10px;
    }
    .speed input[type="range"] {
      width: 180px;
      accent-color: #689aff;
    }

    .info {
      display: grid;
      gap: 6px;
      font-size: 13px;
      color: #c8d3f5;
    }
    .info-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px 16px;
      align-items: center;
    }
    .badge {
      background: #1e2346;
      border: 1px solid #2a3364;
      border-radius: 999px;
      padding: 6px 10px;
      font-weight: 700;
      font-size: 12px;
      color: #cfe3ff;
    }
    .badge.ok { border-color: #2a6a44; background: #153123; color: #baf3ce; }
    .badge.warn { border-color: #6b532a; background: #2d2414; color: #ffd39a; }

    .stack {
      display: grid;
      gap: 6px;
    }

    .row-title {
      font-size: 13px;
      color: var(--muted);
      padding-left: 4px;
    }

    .array {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 8px;
      background: #12162d;
      border: 1px dashed #2a2f5c;
      border-radius: 12px;
      min-height: 54px;
    }

    .item {
      background: linear-gradient(180deg, var(--chip), var(--chip2));
      border: 1px solid var(--chip-border);
      color: #e6edff;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 700;
      letter-spacing: 0.2px;
      min-width: 42px;
      text-align: center;
      position: relative;
      box-shadow: 0 6px 14px rgba(0,0,0,0.25);
      transition: transform 0.15s ease, box-shadow 0.2s ease;
    }
    .item:hover { transform: translateY(-2px); box-shadow: 0 8px 18px rgba(0,0,0,0.35); }
    .item .subtag {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #0f132d;
      color: #aab5de;
      border: 1px solid #263168;
      padding: 2px 6px;
      font-size: 10px;
      border-radius: 999px;
    }
    .item.phase-neg { border-color: #6b2d2d; }
    .item.phase-pos { border-color: #2a5f2a; }

    .buckets {
      display: grid;
      grid-template-columns: repeat(5,minmax(0,1fr));
      gap: 10px;
    }
    @media (max-width: 800px) {
      .buckets { grid-template-columns: repeat(2, minmax(0,1fr)); }
    }
    .bucket {
      background: var(--bucket);
      border: 1px solid #2a2f5c;
      border-radius: 12px;
      box-shadow: var(--shadow);
      min-height: 100px;
      display: grid;
      grid-template-rows: auto 1fr;
    }
    .bucket-label {
      padding: 8px 10px;
      font-weight: 800;
      color: #b1c6ff;
      border-bottom: 1px solid #2a2f5c;
      background: linear-gradient(180deg, #1b203f, #171c36);
      border-top-left-radius: 12px;
      border-top-right-radius: 12px;
      letter-spacing: 0.5px;
    }
    .bucket-items {
      padding: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-content: flex-start;
      min-height: 70px;
    }

    .footer {
      font-size: 12px;
      color: #9aa3b2;
    }
    .footer a { color: #9bc2ff; text-decoration: none; }
    .footer strong { color: #cfe3ff; }

    .legend {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: #151a36;
      border: 1px solid #293161;
      color: #c7d3ff;
      border-radius: 999px;
      font-size: 12px;
    }
    .dot {
      width: 10px; height: 10px; border-radius: 50%;
      background: #3f7cff; border: 1px solid #2a4fb4;
      box-shadow: 0 0 0 2px rgba(63,124,255,0.15);
    }
    .dot.pos { background: #2ecc71; border-color: #1d8b4a; box-shadow: 0 0 0 2px rgba(46,204,113,0.2); }
    .dot.neg { background: #ff6b6b; border-color: #b84b4b; box-shadow: 0 0 0 2px rgba(255,107,107,0.2); }
    .dot.digit { background: #ffd166; border-color: #b2892f; box-shadow: 0 0 0 2px rgba(255,209,102,0.2); }
  </style>
</head>
<body>
  <header>
    <h1>Radix Sort Visualizer (LSD, Base 10)</h1>
    <div class="sub">Stable, non-comparative sorting by processing digits from least significant to most significant. Supports positives and negatives (negatives sorted by absolute value then reversed).</div>
  </header>

  <div class="container">
    <div class="panel controls">
      <div class="controls-row">
        <input id="inputNumbers" type="text" placeholder="Enter integers separated by commas or spaces (e.g., 170, 45, 75, 90, 802, 24, 2, 66)" />
        <button id="btnRandom" class="btn secondary" title="Generate random numbers">Randomize</button>
        <button id="btnStart" class="btn" title="Start / Restart">Start</button>
        <button id="btnStep" class="btn secondary" title="Step one operation">Step</button>
        <button id="btnPause" class="btn warning" title="Pause / Resume" disabled>Pause</button>
        <button id="btnReset" class="btn danger" title="Reset">Reset</button>
        <span class="speed">
          Speed
          <input id="speedRange" type="range" min="30" max="1000" value="350" />
        </span>
      </div>
      <div class="info">
        <div class="info-row">
          <span id="phaseBadge" class="badge">Phase: Ready</span>
          <span id="stageBadge" class="badge">Stage: —</span>
          <span id="digitBadge" class="badge warn">Digit (10^k): —</span>
          <span id="passBadge" class="badge">Pass: —</span>
          <span id="noteBadge" class="badge">Note: Stable</span>
        </div>
        <div class="info-row">
          <div class="legend">
            <span class="pill"><span class="dot pos"></span> Positive pass</span>
            <span class="pill"><span class="dot neg"></span> Negative pass (abs values)</span>
            <span class="pill"><span class="dot digit"></span> Current digit k (units=0, tens=1, ...)</span>
          </div>
        </div>
      </div>
    </div>

    <div class="panel stack">
      <div class="row-title">Current working array</div>
      <div id="arrayContainer" class="array" aria-live="polite"></div>
    </div>

    <div class="panel stack">
      <div class="row-title">Buckets (0 - 9) for current digit</div>
      <div id="bucketsContainer" class="buckets"></div>
    </div>

    <div class="panel stack">
      <div class="row-title">Final result</div>
      <div id="finalContainer" class="array"></div>
      <div class="footer" style="margin-top: 8px;">
        LSD Radix Sort complexity: O(d * (n + b)), where d is number of digits, n is number of items, and b is the base (10 here). Stable: equal-digit items preserve relative order within each pass.
      </div>
    </div>
  </div>

  <script>
    // Utility helpers
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));
    const byId = (id) => document.getElementById(id);

    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    function maxDigits(arr) {
      let m = 0;
      for (const v of arr) m = Math.max(m, Math.abs(v));
      return Math.max(1, String(Math.floor(m)).length);
    }
    function getDigit(val, k) {
      const e = Math.pow(10, k);
      return Math.floor(Math.abs(val) / e) % 10;
    }
    function parseNumbersInput(text) {
      if (!text) return [];
      const parts = text.split(/[\s,;]+/).filter(Boolean);
      const nums = [];
      for (const p of parts) {
        const v = Number(p);
        if (!Number.isFinite(v)) continue;
        nums.push(Math.trunc(v));
      }
      return nums;
    }
    function numbersToString(arr) {
      return arr.join(", ");
    }

    // DOM creation for buckets
    function createBuckets(container) {
      container.innerHTML = "";
      for (let b = 0; b <= 9; b++) {
        const bucket = document.createElement("div");
        bucket.className = "bucket";
        bucket.dataset.bucket = String(b);

        const label = document.createElement("div");
        label.className = "bucket-label";
        label.textContent = `Bucket ${b}`;

        const items = document.createElement("div");
        items.className = "bucket-items";
        items.id = `bucket-items-${b}`;

        bucket.appendChild(label);
        bucket.appendChild(items);
        container.appendChild(bucket);
      }
    }

    function createItemNode(item, phase) {
      const node = document.createElement("div");
      node.className = "item " + (phase === "negatives" ? "phase-neg" : "phase-pos");
      node.id = `item-${item.uid}`;
      node.dataset.uid = String(item.uid);
      node.textContent = String(item.show);
      const sub = document.createElement("div");
      sub.className = "subtag";
      sub.title = "Original position (stability marker)";
      sub.textContent = `#${item.originIndex}`;
      node.appendChild(sub);
      return node;
    }

    function renderArray(container, items, phase) {
      container.innerHTML = "";
      for (const it of items) {
        const node = createItemNode(it, phase);
        container.appendChild(node);
      }
    }

    function clearBucketsItems() {
      for (let b = 0; b <= 9; b++) {
        const bi = byId(`bucket-items-${b}`);
        if (bi) bi.innerHTML = "";
      }
    }

    // State management
    const state = {
      raw: [],
      positives: [],
      negatives: [],
      sortedPositives: [],
      sortedNegatives: [],

      phase: "ready", // ready | positives | negatives | merge | done
      stage: "distribute", // distribute | collect
      expIndex: 0, // digit index
      maxDigits: 0,
      i: 0, // distribution pointer
      collectBucket: 0,
      currentArray: [], // array of items { uid, value(used for sorting), show(display original), originIndex }
      newOrder: [],

      uidCounter: 1,
      timer: null,
      running: false,
      speed: 350
    };

    function setBadges() {
      const phaseMap = {
        ready: "Phase: Ready",
        positives: "Phase: Positives",
        negatives: "Phase: Negatives (abs)",
        merge: "Phase: Merge",
        done: "Phase: Done"
      };
      byId("phaseBadge").textContent = phaseMap[state.phase] || "Phase: —";

      const stageMap = {
        distribute: "Stage: Distribute into buckets",
        collect: "Stage: Collect in order"
      };
      byId("stageBadge").textContent = state.phase === "ready" || state.phase === "done" ? "Stage: —" : (stageMap[state.stage] || "Stage: —");

      const digitName = (k) => {
        if (k === 0) return "k=0 (units)";
        if (k === 1) return "k=1 (tens)";
        if (k === 2) return "k=2 (hundreds)";
        return `k=${k}`;
      };

      byId("digitBadge").textContent = (state.phase === "positives" || state.phase === "negatives")
        ? `Digit (10^k): ${digitName(state.expIndex)}`
        : "Digit (10^k): —";

      const pass = (state.phase === "positives" || state.phase === "negatives") ? `${state.expIndex + 1} / ${state.maxDigits}` : "—";
      byId("passBadge").textContent = `Pass: ${pass}`;
    }

    function resetVisualization() {
      state.raw = [];
      state.positives = [];
      state.negatives = [];
      state.sortedPositives = [];
      state.sortedNegatives = [];
      state.phase = "ready";
      state.stage = "distribute";
      state.expIndex = 0;
      state.maxDigits = 0;
      state.i = 0;
      state.collectBucket = 0;
      state.currentArray = [];
      state.newOrder = [];
      state.uidCounter = 1;
      clearTimer();

      byId("arrayContainer").innerHTML = "";
      byId("finalContainer").innerHTML = "";
      createBuckets(byId("bucketsContainer"));
      setBadges();

      byId("btnPause").disabled = true;
      byId("btnPause").textContent = "Pause";
    }

    function setupPhase(phase) {
      state.phase = phase;
      state.stage = "distribute";
      state.expIndex = 0;
      state.i = 0;
      state.collectBucket = 0;
      state.newOrder = [];
      clearBucketsItems();

      if (phase === "positives") {
        state.maxDigits = maxDigits(state.positives);
        state.currentArray = state.positives.map((v, idx) => ({
          uid: state.uidCounter++,
          value: v,          // used for digit calc
          show: v,           // display original
          originIndex: v.__originIndex ?? idx
        }));
        renderArray(byId("arrayContainer"), state.currentArray, "positives");
      } else if (phase === "negatives") {
        // Sort by absolute values; display original negatives
        state.maxDigits = maxDigits(state.negatives.map(v => Math.abs(v)));
        state.currentArray = state.negatives.map((v, idx) => ({
          uid: state.uidCounter++,
          value: Math.abs(v),
          show: v,
          originIndex: v.__originIndex ?? idx
        }));
        renderArray(byId("arrayContainer"), state.currentArray, "negatives");
      }
      setBadges();
    }

    function startFromInput(arr) {
      resetVisualization();
      state.raw = arr.slice();

      // tag origin index for stability display
      const withIdx = state.raw.map((v, i) => {
        if (typeof v === "object") return v;
        const val = Number(v);
        val.__originIndex = i;
        return val;
      });

      state.positives = [];
      state.negatives = [];
      withIdx.forEach((v, i) => {
        if (v >= 0) state.positives.push(v);
        else state.negatives.push(v);
      });

      // If nothing entered, seed with random
      if (state.raw.length === 0) {
        state.raw = generateRandomNumbers(12, 0, 999);
        startFromInput(state.raw);
        byId("inputNumbers").value = numbersToString(state.raw);
        return;
      }

      // Begin with positives if any, else negatives, else done
      if (state.positives.length > 0) {
        setupPhase("positives");
      } else if (state.negatives.length > 0) {
        setupPhase("negatives");
      } else {
        state.phase = "done";
        setBadges();
      }
    }

    function nextPhaseOrFinish() {
      if (state.phase === "positives") {
        // Save positive results
        state.sortedPositives = state.currentArray.map(it => it.show);
        if (state.negatives.length > 0) {
          setupPhase("negatives");
          return;
        }
        // No negatives; finalize
        finalizeMerge();
      } else if (state.phase === "negatives") {
        // Save negatives order (by abs ascending). For final ascending order, negatives must be reversed.
        state.sortedNegatives = state.currentArray.map(it => it.show).reverse(); // reverse for ascending negatives
        finalizeMerge();
      }
    }

    function finalizeMerge() {
      clearBucketsItems();
      state.phase = "merge";
      state.stage = "distribute";
      setBadges();

      const final = [...state.sortedNegatives, ...state.sortedPositives];
      renderFinal(final);

      state.phase = "done";
      setBadges();
      stopAuto();
    }

    function renderFinal(arr) {
      const cont = byId("finalContainer");
      cont.innerHTML = "";
      arr.forEach((v, idx) => {
        const node = document.createElement("div");
        node.className = "item";
        node.textContent = String(v);
        const sub = document.createElement("div");
        sub.className = "subtag";
        sub.textContent = String(idx + 1);
        sub.title = "Rank in sorted order";
        node.appendChild(sub);
        cont.appendChild(node);
      });
    }

    function placeOneToBucket() {
      if (state.i >= state.currentArray.length) return false;
      const item = state.currentArray[state.i];
      const d = getDigit(item.value, state.expIndex);
      const bi = byId(`bucket-items-${d}`);
      // Move DOM node
      let node = byId(`item-${item.uid}`);
      if (!node) {
        node = createItemNode(item, state.phase);
      }
      bi.appendChild(node);
      state.i++;
      return true;
    }

    function beginCollectPhase() {
      state.stage = "collect";
      state.collectBucket = 0;
      state.newOrder = [];
      setBadges();
    }

    function collectOneFromBuckets() {
      while (state.collectBucket <= 9) {
        const bi = byId(`bucket-items-${state.collectBucket}`);
        const first = bi.querySelector(".item");
        if (first) {
          // Append to array container in order
          const uid = Number(first.dataset.uid);
          const item = state.currentArray.find(it => it.uid === uid);
          if (item) {
            state.newOrder.push(item);
          }
          byId("arrayContainer").appendChild(first);
          return true; // collected one
        } else {
          state.collectBucket++;
        }
      }
      return false; // no more items
    }

    function finishCollectPhase() {
      state.currentArray = state.newOrder.slice();
      state.stage = "distribute";
      state.i = 0;
      state.collectBucket = 0;
      state.newOrder = [];
      clearBucketsItems();
      state.expIndex++;
      setBadges();

      if (state.expIndex >= state.maxDigits) {
        // Phase complete
        nextPhaseOrFinish();
      }
    }

    function stepOnce() {
      if (!(state.phase === "positives" || state.phase === "negatives")) return false;

      if (state.stage === "distribute") {
        const moved = placeOneToBucket();
        if (!moved) {
          beginCollectPhase();
          return true;
        }
        return true;
      } else if (state.stage === "collect") {
        const got = collectOneFromBuckets();
        if (!got) {
          finishCollectPhase();
          return true;
        }
        return true;
      }
      return false;
    }

    // Auto-run with speed
    function tick() {
      const cont = stepOnce();
      if (!cont || state.phase === "done") {
        stopAuto();
        return;
      }
      scheduleNext();
    }

    function scheduleNext() {
      clearTimer();
      state.timer = setTimeout(tick, clamp(state.speed, 20, 2000));
    }

    function startAuto() {
      if (state.phase === "ready") {
        const arr = parseNumbersInput(byId("inputNumbers").value);
        startFromInput(arr);
      }
      if (!(state.phase === "positives" || state.phase === "negatives")) return;
      state.running = true;
      byId("btnPause").disabled = false;
      scheduleNext();
    }

    function stopAuto() {
      state.running = false;
      clearTimer();
      byId("btnPause").textContent = "Resume";
    }

    function clearTimer() {
      if (state.timer) clearTimeout(state.timer);
      state.timer = null;
    }

    function pauseOrResume() {
      if (state.phase === "done" || state.phase === "ready") return;
      if (state.running) {
        stopAuto();
      } else {
        state.running = true;
        byId("btnPause").textContent = "Pause";
        scheduleNext();
      }
    }

    // UI hookups
    function generateRandomNumbers(count = 12, min = 0, max = 999) {
      const arr = [];
      for (let i = 0; i < count; i++) arr.push(randInt(min, max));
      return arr;
    }

    function onRandomize() {
      // Mix positives and negatives sometimes
      const allowNeg = Math.random() < 0.45;
      const count = randInt(8, 16);
      const arr = [];
      for (let i = 0; i < count; i++) {
        let v = randInt(0, 999);
        if (allowNeg && Math.random() < 0.4) v = -randInt(0, 999);
        arr.push(v);
      }
      byId("inputNumbers").value = numbersToString(arr);
      resetVisualization();
    }

    function onStart() {
      const arr = parseNumbersInput(byId("inputNumbers").value);
      startFromInput(arr);
      startAuto();
    }

    function onStep() {
      if (state.phase === "ready") {
        const arr = parseNumbersInput(byId("inputNumbers").value);
        startFromInput(arr);
      }
      // One step
      stepOnce();
    }

    function onReset() {
      resetVisualization();
      byId("arrayContainer").innerHTML = "";
      byId("finalContainer").innerHTML = "";
    }

    function onSpeedChange(e) {
      state.speed = Number(e.target.value);
      if (state.running) {
        scheduleNext();
      }
    }

    // Initialize
    function init() {
      createBuckets(byId("bucketsContainer"));
      setBadges();

      byId("btnRandom").addEventListener("click", onRandomize);
      byId("btnStart").addEventListener("click", onStart);
      byId("btnStep").addEventListener("click", onStep);
      byId("btnPause").addEventListener("click", pauseOrResume);
      byId("btnReset").addEventListener("click", onReset);
      byId("speedRange").addEventListener("input", onSpeedChange);

      // Seed example
      const example = [170, 45, 75, 90, 802, 24, 2, 66];
      byId("inputNumbers").value = numbersToString(example);

      // Keyboard shortcuts
      window.addEventListener("keydown", (e) => {
        if (e.key === " ") { e.preventDefault(); pauseOrResume(); }
        if (e.key.toLowerCase() === "s") { e.preventDefault(); onStep(); }
        if (e.key.toLowerCase() === "r") { e.preventDefault(); onRandomize(); }
        if (e.key.toLowerCase() === "g") { e.preventDefault(); onStart(); }
      });
    }

    init();
  </script>
</body>
</html>