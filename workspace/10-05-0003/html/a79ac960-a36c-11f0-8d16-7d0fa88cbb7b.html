<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Depth-First Search (DFS) Visualizer</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --text: #e5e7eb;
    --muted: #9ca3af;
    --accent: #3b82f6;
    --accent2: #06b6d4;
    --success: #10b981;
    --warn: #f59e0b;
    --danger: #ef4444;
  }

  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    background: linear-gradient(135deg, #0b1229 0%, #0f172a 40%, #101827 100%);
    color: var(--text);
  }

  header {
    padding: 18px 24px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
    display: flex;
    align-items: center;
    gap: 14px;
  }

  header h1 {
    font-size: 18px;
    margin: 0;
    letter-spacing: 0.3px;
    font-weight: 600;
  }

  header .tag {
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 999px;
    padding: 2px 10px;
    font-size: 12px;
    color: var(--muted);
  }

  .container {
    display: grid;
    grid-template-columns: 1.25fr 0.85fr;
    gap: 12px;
    padding: 12px;
    min-height: calc(100vh - 64px);
  }

  .card {
    background: linear-gradient(180deg, rgba(17,24,39,0.72), rgba(17,24,39,0.62));
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 12px;
    overflow: hidden;
  }

  .card header {
    background: rgba(255,255,255,0.04);
    border-bottom: 1px solid rgba(255,255,255,0.06);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
  }

  .card header h2 {
    margin: 0;
    font-size: 15px;
    font-weight: 600;
    color: var(--text);
  }

  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    padding: 12px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
  }

  .control-group {
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.06);
    padding: 8px;
    border-radius: 8px;
  }

  select, input[type="checkbox"] {
    background: rgba(17,24,39,0.65);
    color: var(--text);
    border: 1px solid rgba(255,255,255,0.14);
    border-radius: 6px;
    padding: 6px 8px;
    font-size: 13px;
    outline: none;
  }

  .btn {
    background: linear-gradient(180deg, rgba(59,130,246,0.2), rgba(59,130,246,0.08));
    border: 1px solid rgba(59,130,246,0.35);
    color: #cfe1ff;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 13px;
    cursor: pointer;
    transition: filter 0.2s ease, transform 0.05s ease;
  }
  .btn:active { transform: scale(0.98); }
  .btn.secondary {
    background: linear-gradient(180deg, rgba(6,182,212,0.2), rgba(6,182,212,0.08));
    border-color: rgba(6,182,212,0.35);
    color: #d8fbff;
  }
  .btn.muted {
    background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
    border-color: rgba(255,255,255,0.18);
    color: var(--muted);
  }
  .btn.warn {
    background: linear-gradient(180deg, rgba(245,158,11,0.18), rgba(245,158,11,0.06));
    border-color: rgba(245,158,11,0.35);
    color: #ffe6b3;
  }
  .btn.danger {
    background: linear-gradient(180deg, rgba(239,68,68,0.18), rgba(239,68,68,0.06));
    border-color: rgba(239,68,68,0.35);
    color: #ffd9d9;
  }

  .board {
    position: relative;
    height: 520px;
  }

  #svg {
    width: 100%;
    height: 100%;
    display: block;
    background:
      radial-gradient(1200px 700px at 70% 0%, rgba(59,130,246,0.08), transparent 45%),
      radial-gradient(900px 900px at 20% 20%, rgba(6,182,212,0.08), transparent 50%),
      linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  }

  .legend {
    display: flex;
    gap: 10px;
    padding: 8px 12px;
    font-size: 12px;
    color: var(--muted);
    border-top: 1px solid rgba(255,255,255,0.06);
    background: rgba(255,255,255,0.03);
  }
  .chip { display: inline-flex; align-items: center; gap: 6px; }
  .chip .dot { width: 10px; height: 3px; border-radius: 2px; display: inline-block; }

  .side {
    display: grid;
    grid-template-rows: auto auto 1fr auto;
    gap: 10px;
  }

  .panel-content {
    padding: 10px 12px;
    font-size: 13px;
    line-height: 1.45;
    color: var(--muted);
  }

  .stack, .order, .adj {
    padding: 10px 12px;
    font-size: 13px;
  }

  .stack-items, .order-items {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .pill {
    background: rgba(59,130,246,0.15);
    border: 1px solid rgba(59,130,246,0.35);
    color: #d6e8ff;
    padding: 4px 8px;
    border-radius: 999px;
    font-size: 12px;
  }
  .pill.green {
    background: rgba(16,185,129,0.15);
    border-color: rgba(16,185,129,0.35);
    color: #cbffe9;
  }
  .pill.orange {
    background: rgba(245,158,11,0.15);
    border-color: rgba(245,158,11,0.35);
    color: #ffe9bf;
  }
  .pill.red {
    background: rgba(239,68,68,0.15);
    border-color: rgba(239,68,68,0.35);
    color: #ffd2d2;
  }

  .info {
    padding: 8px 12px;
    border-top: 1px solid rgba(255,255,255,0.06);
    font-size: 12px;
    color: var(--muted);
    background: rgba(255,255,255,0.03);
  }

  .switch {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-size: 13px;
    color: var(--muted);
  }

  .range {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    color: var(--muted);
    font-size: 12px;
  }
  input[type="range"] {
    width: 140px;
  }

  /* SVG styles */
  .edge {
    stroke: rgba(255,255,255,0.25);
    stroke-width: 2;
  }
  .edge-tree {
    stroke: var(--success) !important;
    stroke-width: 3.5;
    opacity: 0.95;
  }
  .edge-back {
    stroke: var(--danger) !important;
    stroke-width: 3;
    opacity: 0.95;
  }
  .edge-check {
    stroke: var(--warn) !important;
    stroke-width: 3.5;
  }
  .node circle {
    fill: rgba(255,255,255,0.85);
    stroke: rgba(255,255,255,0.15);
    stroke-width: 2;
    filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3));
    transition: fill 0.2s ease, stroke 0.2s ease, transform 0.05s ease;
  }
  .node.visited circle {
    fill: #cfe8ff;
    stroke: rgba(59,130,246,0.75);
  }
  .node.finished circle {
    fill: #9fd0ff;
    stroke: rgba(59,130,246,0.95);
  }
  .node.selected circle {
    stroke: var(--accent2);
    stroke-width: 3;
  }
  .node text {
    pointer-events: none;
    font-weight: 600;
    font-size: 13px;
    fill: #0b1229;
  }
  .node .time {
    pointer-events: none;
    font-size: 10px;
    fill: #334155;
  }

  .hint {
    color: var(--muted);
    font-size: 12px;
  }

  .kbd {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.18);
    border-radius: 6px;
    padding: 2px 6px;
    font-size: 12px;
    color: var(--text);
  }

  .divider {
    height: 1px;
    background: rgba(255,255,255,0.06);
    margin: 8px 0;
  }

  .adj-list {
    font-family: ui-monospace, "SF Mono", Menlo, Consolas, monospace;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 8px;
    padding: 8px;
    color: #cbd5e1;
    font-size: 12px;
    white-space: pre-wrap;
  }
</style>
</head>
<body>
  <header>
    <h1>Depth-First Search (DFS) Visualizer</h1>
    <span class="tag">Interactive demo: recursive and iterative DFS on a graph</span>
  </header>

  <div class="container">
    <div class="card">
      <header>
        <h2>Graph</h2>
        <div class="hint">Click a node to choose the start. Toggle Edit to add/remove edges.</div>
      </header>

      <div class="controls">
        <div class="control-group">
          <label for="start">Start node</label>
          <select id="start"></select>
        </div>

        <div class="control-group">
          <label for="mode">Mode</label>
          <select id="mode">
            <option value="recursive">Recursive</option>
            <option value="iterative">Iterative (explicit stack)</option>
          </select>
        </div>

        <div class="control-group">
          <label class="switch">
            <input type="checkbox" id="directed" checked>
            Directed graph
          </label>
          <label class="switch">
            <input type="checkbox" id="editEdges">
            Edit edges
          </label>
        </div>

        <div class="control-group">
          <button class="btn" id="playBtn">Play</button>
          <button class="btn secondary" id="stepBtn">Step</button>
          <button class="btn muted" id="resetBtn">Reset</button>
        </div>

        <div class="control-group">
          <button class="btn warn" id="randomBtn">Randomize edges</button>
          <button class="btn danger" id="clearBtn">Clear edges</button>
        </div>

        <div class="control-group">
          <span class="range">Speed <input id="speed" type="range" min="0.2" max="3" step="0.1" value="1"><span id="speedVal">1.0x</span></span>
        </div>
      </div>

      <div class="board">
        <svg id="svg" viewBox="0 0 900 520" preserveAspectRatio="xMidYMid meet">
          <defs>
            <marker id="arrow" markerWidth="10" markerHeight="8" refX="10" refY="4" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L10,4 L0,8 Z" fill="rgba(255,255,255,0.6)"></path>
            </marker>
          </defs>
          <g id="edges"></g>
          <g id="nodes"></g>
        </svg>
      </div>

      <div class="legend">
        <div class="chip"><span class="dot" style="background: var(--success)"></span>Tree edge</div>
        <div class="chip"><span class="dot" style="background: var(--danger)"></span>Back edge (directed)</div>
        <div class="chip"><span class="dot" style="background: var(--warn)"></span>Checking edge</div>
      </div>
    </div>

    <div class="side">
      <div class="card">
        <header>
          <h2>DFS Stack</h2>
        </header>
        <div class="stack">
          <div class="stack-items" id="stack"></div>
        </div>
        <div class="info">Recursive: call stack of active DFS calls. Iterative: explicit stack of frames.</div>
      </div>

      <div class="card">
        <header>
          <h2>Visit Order</h2>
        </header>
        <div class="order">
          <div class="order-items" id="order"></div>
        </div>
        <div class="info">Nodes are visited when first discovered (time d[u]). Finish time f[u] is set when leaving the node.</div>
      </div>

      <div class="card">
        <header>
          <h2>Adjacency List</h2>
        </header>
        <div class="adj">
          <div class="adj-list" id="adjList"></div>
        </div>
        <div class="info">Edit mode: click node U then node V to toggle edge U → V. In undirected mode, toggles both directions.</div>
      </div>

      <div class="card">
        <header>
          <h2>Status</h2>
        </header>
        <div class="panel-content" id="status">
          Ready. Choose a start node and press Play or Step.
        </div>
        <div class="info">Tips: You can step through to understand recursion and the stack. Use Randomize to explore different graphs.</div>
      </div>
    </div>
  </div>

<script>
(function() {
  // Core state
  const N = 8; // nodes: 0..7 labeled A..H
  const nodes = [];
  const adjacency = new Map(); // id -> Set of neighbor ids
  const nodeRadius = 22;
  let directed = true;
  let editMode = false;

  // DFS animation state
  let frames = [];
  let frameIndex = 0;
  let playing = false;
  let timer = null;
  let speed = 1.0;

  // Runtime marks (during animation)
  const visited = new Array(N).fill(false);
  const disc = new Array(N).fill(null);
  const finish = new Array(N).fill(null);
  let timeCounter = 0;
  const stackModel = []; // display-only stack
  const orderList = [];
  let lastCheckedEdgeKey = null;

  // UI elements
  const svg = document.getElementById('svg');
  const gEdges = document.getElementById('edges');
  const gNodes = document.getElementById('nodes');
  const startSelect = document.getElementById('start');
  const modeSelect = document.getElementById('mode');
  const directedChk = document.getElementById('directed');
  const editChk = document.getElementById('editEdges');
  const playBtn = document.getElementById('playBtn');
  const stepBtn = document.getElementById('stepBtn');
  const resetBtn = document.getElementById('resetBtn');
  const randomBtn = document.getElementById('randomBtn');
  const clearBtn = document.getElementById('clearBtn');
  const speedRange = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const stackDiv = document.getElementById('stack');
  const orderDiv = document.getElementById('order');
  const adjDiv = document.getElementById('adjList');
  const statusDiv = document.getElementById('status');

  // Edge element map
  const edgeEl = new Map(); // key->SVG line

  // Utilities
  const label = id => String.fromCharCode(65 + id);
  function byId(id) { return nodes.find(n => n.id === id); }

  // Initialize node positions (circle layout)
  function initNodes() {
    nodes.length = 0;
    gNodes.innerHTML = '';
    const cx = 450, cy = 260, R = 200;
    for (let i = 0; i < N; i++) {
      const angle = (Math.PI * 2) * (i / N) - Math.PI / 2;
      const x = cx + Math.cos(angle) * R;
      const y = cy + Math.sin(angle) * R;
      const node = { id: i, x, y, disc: null, finish: null };
      nodes.push(node);
      const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
      group.classList.add('node');
      group.setAttribute('data-id', i);
      group.setAttribute('transform', `translate(${x},${y})`);
      const circ = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circ.setAttribute('r', nodeRadius);
      circ.setAttribute('cx', 0);
      circ.setAttribute('cy', 0);
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute('x', 0);
      text.setAttribute('y', 4);
      text.setAttribute('text-anchor', 'middle');
      text.textContent = label(i);
      const timeText = document.createElementNS("http://www.w3.org/2000/svg", "text");
      timeText.classList.add('time');
      timeText.setAttribute('x', 0);
      timeText.setAttribute('y', 26);
      timeText.setAttribute('text-anchor', 'middle');
      timeText.textContent = '';
      group.appendChild(circ);
      group.appendChild(text);
      group.appendChild(timeText);
      group.addEventListener('click', onNodeClick);
      gNodes.appendChild(group);
      node.group = group;
      node.timeText = timeText;
    }
  }

  function resetRuntime() {
    for (let i = 0; i < N; i++) {
      visited[i] = false;
      disc[i] = null;
      finish[i] = null;
      byId(i).group.classList.remove('visited', 'finished');
      byId(i).timeText.textContent = '';
    }
    stackModel.length = 0;
    orderList.length = 0;
    frameIndex = 0;
    frames.length = 0;
    timeCounter = 0;
    lastCheckedEdgeKey = null;
    stackDiv.innerHTML = '';
    orderDiv.innerHTML = '';
    // Restore edges styling
    edgeEl.forEach(el => {
      el.classList.remove('edge-tree', 'edge-back', 'edge-check');
      el.setAttribute('stroke', 'rgba(255,255,255,0.25)');
      el.setAttribute('stroke-width', '2');
    });
    statusDiv.textContent = 'Reset. Ready to run DFS.';
  }

  function stopPlaying() {
    playing = false;
    if (timer) clearInterval(timer);
    timer = null;
    playBtn.textContent = 'Play';
  }

  function onNodeClick(e) {
    const id = parseInt(e.currentTarget.getAttribute('data-id'), 10);
    if (editMode) {
      handleEditNodeClick(id);
      return;
    }
    if (playing) return;
    startSelect.value = id;
    selectStartNodeUI(id);
  }

  function selectStartNodeUI(id) {
    nodes.forEach(n => n.group.classList.remove('selected'));
    byId(id).group.classList.add('selected');
  }

  function initAdjacencyDefault() {
    adjacency.clear();
    for (let i = 0; i < N; i++) adjacency.set(i, new Set());
    // A..H = 0..7 default directed edges
    addEdge(0,1,true);
    addEdge(0,3,true);
    addEdge(1,2,true);
    addEdge(1,4,true);
    addEdge(2,5,true);
    addEdge(3,4,true);
    addEdge(4,2,true);
    addEdge(4,7,true);
    addEdge(5,6,true);
    addEdge(6,4,true);
    rebuildEdges();
    updateAdjList();
  }

  function addEdge(u, v, forceDirected = null) {
    const dir = (forceDirected === null) ? directed : forceDirected;
    if (u === v) return;
    adjacency.get(u).add(v);
    if (!dir) adjacency.get(v).add(u);
  }

  function removeEdge(u, v, forceDirected = null) {
    const dir = (forceDirected === null) ? directed : forceDirected;
    adjacency.get(u).delete(v);
    if (!dir) adjacency.get(v).delete(u);
  }

  function toggleEdge(u, v) {
    if (u === v) return;
    const dir = directed;
    const has = adjacency.get(u).has(v) || (!dir && adjacency.get(v).has(u));
    if (has) {
      adjacency.get(u).delete(v);
      if (!dir) adjacency.get(v).delete(u);
    } else {
      adjacency.get(u).add(v);
      if (!dir) adjacency.get(v).add(u);
    }
    rebuildEdges();
    updateAdjList();
  }

  function rebuildEdges() {
    gEdges.innerHTML = '';
    edgeEl.clear();
    // Build edge elements
    if (directed) {
      for (let u = 0; u < N; u++) {
        for (const v of adjacency.get(u)) {
          createEdge(u, v, true);
        }
      }
    } else {
      // Undirected: draw unique pair
      const drawn = new Set();
      for (let u = 0; u < N; u++) {
        for (const v of adjacency.get(u)) {
          const a = Math.min(u, v), b = Math.max(u, v);
          const key = `${a}--${b}`;
          if (drawn.has(key)) continue;
          drawn.add(key);
          createEdge(a, b, false);
        }
      }
    }
  }

  function createEdge(u, v, isDirected) {
    const A = byId(u), B = byId(v);
    // compute shortened line endpoints so it touches node border
    const dx = B.x - A.x, dy = B.y - A.y;
    const dist = Math.hypot(dx, dy) || 1;
    const ux = dx / dist, uy = dy / dist;
    const sx = A.x + ux * nodeRadius, sy = A.y + uy * nodeRadius;
    const ex = B.x - ux * nodeRadius, ey = B.y - uy * nodeRadius;
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute('x1', sx); line.setAttribute('y1', sy);
    line.setAttribute('x2', ex); line.setAttribute('y2', ey);
    line.classList.add('edge');
    if (isDirected) line.setAttribute('marker-end', 'url(#arrow)');
    gEdges.appendChild(line);
    const key = isDirected ? `${u}->${v}` : `${u}--${v}`;
    edgeEl.set(key, line);
  }

  function getEdgeKey(u, v) {
    if (directed) return `${u}->${v}`;
    const a = Math.min(u, v), b = Math.max(u, v);
    return `${a}--${b}`;
  }

  // UI adjacency list
  function updateAdjList() {
    const lines = [];
    for (let u = 0; u < N; u++) {
      const arr = Array.from(adjacency.get(u)).sort((a,b) => a - b).map(label);
      lines.push(`${label(u)}: ${arr.join(', ')}`);
    }
    adjDiv.textContent = lines.join('\n');
  }

  // Edit edges mode: click U then V to toggle U->V (undirected toggles both)
  let editFirst = null;
  function handleEditNodeClick(id) {
    if (editFirst === null) {
      editFirst = id;
      statusDiv.textContent = `Edit: selected ${label(id)}. Click another node to toggle edge ${label(id)} → ?.`;
      selectTempNode(id);
    } else {
      const u = editFirst, v = id;
      if (u === v) {
        statusDiv.textContent = `Edit: cannot toggle self-loop. Choose another node.`;
        return;
      }
      toggleEdge(u, v);
      statusDiv.textContent = directed
        ? `Toggled edge ${label(u)} → ${label(v)}`
        : `Toggled edge ${label(u)} — ${label(v)} (undirected)`;
      clearTempSelection();
      editFirst = null;
    }
  }

  function selectTempNode(id) {
    nodes.forEach(n => n.group.classList.remove('selected'));
    byId(id).group.classList.add('selected');
  }
  function clearTempSelection() {
    nodes.forEach(n => n.group.classList.remove('selected'));
  }

  // DFS frame builder
  function buildFrames(startId, mode) {
    frames = [];
    // local simulation arrays for building frames
    const vis = new Array(N).fill(false);
    const discT = new Array(N).fill(null);
    const finT = new Array(N).fill(null);
    let t = 0;

    function neighborsOf(u) {
      return Array.from(adjacency.get(u)).sort((a,b) => a - b);
    }

    function pushFrame(fr) { frames.push(fr); }

    if (mode === 'recursive') {
      function dfs(u) {
        pushFrame({type:'visit', node:u, time: ++t});
        vis[u] = true;
        discT[u] = t;
        const nbrs = neighborsOf(u);
        for (const v of nbrs) {
          let status;
          if (!vis[v]) {
            status = 'tree';
            pushFrame({type:'edge_check', u, v, status});
            pushFrame({type:'tree_edge', u, v});
            dfs(v);
          } else {
            if (directed) {
              status = finT[v] === null ? 'back' : 'visited';
            } else {
              status = 'visited';
            }
            pushFrame({type:'edge_check', u, v, status});
          }
        }
        pushFrame({type:'finish', node:u, time: ++t});
        finT[u] = t;
      }
      dfs(startId);

      // If graph disconnected, offer to continue from remaining nodes (optional). We'll not auto-continue; DFS is from start node only.
    } else if (mode === 'iterative') {
      const stack = [{u: startId, i: 0}];
      let onStack = new Set([startId]);
      while (stack.length) {
        const top = stack[stack.length - 1];
        const u = top.u;
        if (!vis[u]) {
          pushFrame({type:'visit', node:u, time: ++t});
          vis[u] = true;
          discT[u] = t;
        }
        const nbrs = neighborsOf(u);
        if (top.i < nbrs.length) {
          const v = nbrs[top.i++];
          let status;
          if (!vis[v]) {
            status = 'tree';
            pushFrame({type:'edge_check', u, v, status});
            pushFrame({type:'tree_edge', u, v});
            stack.push({u: v, i: 0});
            onStack.add(v);
          } else {
            if (directed) {
              status = finT[v] === null ? 'back' : 'visited';
            } else {
              status = 'visited';
            }
            pushFrame({type:'edge_check', u, v, status});
          }
        } else {
          pushFrame({type:'finish', node:u, time: ++t});
          finT[u] = t;
          onStack.delete(u);
          stack.pop();
        }
      }
    }
  }

  // Apply frames one by one
  function applyFrame(fr) {
    // Clear previous check highlight
    if (lastCheckedEdgeKey) {
      const el = edgeEl.get(lastCheckedEdgeKey);
      if (el && !el.classList.contains('edge-tree') && !el.classList.contains('edge-back')) {
        el.classList.remove('edge-check');
        el.setAttribute('stroke', 'rgba(255,255,255,0.25)');
        el.setAttribute('stroke-width', '2');
      }
      lastCheckedEdgeKey = null;
    }

    switch (fr.type) {
      case 'visit':
        visited[fr.node] = true;
        disc[fr.node] = fr.time;
        timeCounter = fr.time;
        const ng = byId(fr.node).group;
        ng.classList.add('visited');
        byId(fr.node).timeText.textContent = `d=${disc[fr.node]}, f=${finish[fr.node] ?? '-'}`;
        stackModel.push(fr.node);
        renderStack();
        orderList.push(fr.node);
        renderOrder();
        statusDiv.textContent = `Visit ${label(fr.node)} (discover time d=${disc[fr.node]})`;
        break;
      case 'edge_check':
        {
          const key = getEdgeKey(fr.u, fr.v);
          lastCheckedEdgeKey = key;
          const el = edgeEl.get(key);
          if (el) {
            el.classList.add('edge-check');
            el.setAttribute('stroke', 'var(--warn)');
            el.setAttribute('stroke-width', '3.5');
          }
          let msg = `Check edge ${label(fr.u)} → ${label(fr.v)}: `;
          if (fr.status === 'tree') {
            msg += 'unvisited, take it (tree edge).';
          } else if (fr.status === 'back') {
            msg += 'back edge to ancestor (cycle).';
            if (el) el.classList.add('edge-back');
          } else {
            msg += 'already visited, skip.';
          }
          statusDiv.textContent = msg;
        }
        break;
      case 'tree_edge':
        {
          const key = getEdgeKey(fr.u, fr.v);
          const el = edgeEl.get(key);
          if (el) {
            el.classList.remove('edge-check');
            el.classList.add('edge-tree');
            el.setAttribute('stroke', 'var(--success)');
            el.setAttribute('stroke-width', '3.5');
          }
        }
        break;
      case 'finish':
        finish[fr.node] = fr.time;
        timeCounter = fr.time;
        const ng2 = byId(fr.node).group;
        ng2.classList.add('finished');
        byId(fr.node).timeText.textContent = `d=${disc[fr.node]}, f=${finish[fr.node]}`;
        // Pop from stack
        const idx = stackModel.lastIndexOf(fr.node);
        if (idx !== -1) stackModel.splice(idx, 1);
        renderStack();
        statusDiv.textContent = `Finish ${label(fr.node)} (finish time f=${finish[fr.node]})`;
        break;
    }
  }

  function renderStack() {
    stackDiv.innerHTML = '';
    for (const id of stackModel) {
      const pill = document.createElement('span');
      pill.className = 'pill';
      pill.textContent = label(id);
      stackDiv.appendChild(pill);
    }
  }

  function renderOrder() {
    orderDiv.innerHTML = '';
    for (let i = 0; i < orderList.length; i++) {
      const id = orderList[i];
      const pill = document.createElement('span');
      pill.className = 'pill green';
      pill.textContent = `${i+1}. ${label(id)}`;
      orderDiv.appendChild(pill);
    }
  }

  function stepOnce() {
    if (!frames.length || frameIndex >= frames.length) {
      statusDiv.textContent = 'No frames to play. Build DFS first (Play or Step).';
      return;
    }
    const fr = frames[frameIndex++];
    applyFrame(fr);
    if (frameIndex >= frames.length) {
      statusDiv.textContent = 'DFS complete.';
      stopPlaying();
    }
  }

  function play() {
    if (!playing) {
      if (!frames.length || frameIndex >= frames.length) {
        // Build frames from current configuration
        resetRuntime();
        const startId = parseInt(startSelect.value, 10);
        selectStartNodeUI(startId);
        buildFrames(startId, modeSelect.value);
        statusDiv.textContent = `Running ${modeSelect.value === 'recursive' ? 'recursive' : 'iterative'} DFS from ${label(startId)}...`;
      }
      playing = true;
      playBtn.textContent = 'Pause';
      const interval = Math.max(80, 500 / speed);
      timer = setInterval(() => {
        stepOnce();
        if (!playing || frameIndex >= frames.length) {
          stopPlaying();
        }
      }, interval);
    } else {
      stopPlaying();
    }
  }

  // UI events
  playBtn.addEventListener('click', play);
  stepBtn.addEventListener('click', () => {
    if (!frames.length || frameIndex >= frames.length) {
      resetRuntime();
      const startId = parseInt(startSelect.value, 10);
      selectStartNodeUI(startId);
      buildFrames(startId, modeSelect.value);
      statusDiv.textContent = `Stepping ${modeSelect.value === 'recursive' ? 'recursive' : 'iterative'} DFS from ${label(startId)}...`;
    }
    stepOnce();
  });
  resetBtn.addEventListener('click', () => {
    stopPlaying();
    resetRuntime();
  });
  randomBtn.addEventListener('click', () => {
    stopPlaying();
    resetRuntime();
    adjacency.clear();
    for (let i = 0; i < N; i++) adjacency.set(i, new Set());
    const p = directed ? 0.22 : 0.28;
    for (let u = 0; u < N; u++) {
      for (let v = 0; v < N; v++) {
        if (u === v) continue;
        if (Math.random() < p) {
          addEdge(u, v);
        }
      }
    }
    rebuildEdges();
    updateAdjList();
    statusDiv.textContent = 'Randomized edges. Select start and run DFS.';
  });
  clearBtn.addEventListener('click', () => {
    stopPlaying();
    resetRuntime();
    adjacency.clear();
    for (let i = 0; i < N; i++) adjacency.set(i, new Set());
    rebuildEdges();
    updateAdjList();
    statusDiv.textContent = 'Cleared all edges.';
  });

  directedChk.addEventListener('change', () => {
    directed = directedChk.checked;
    stopPlaying();
    resetRuntime();
    rebuildEdges();
    updateAdjList();
    statusDiv.textContent = directed ? 'Directed graph mode.' : 'Undirected graph mode.';
  });

  editChk.addEventListener('change', () => {
    editMode = editChk.checked;
    if (editMode) {
      stopPlaying();
      statusDiv.textContent = 'Edit mode: click U then V to toggle edge.';
    } else {
      editFirst = null;
      clearTempSelection();
      statusDiv.textContent = 'Edit mode off.';
    }
  });

  speedRange.addEventListener('input', () => {
    speed = parseFloat(speedRange.value);
    speedVal.textContent = `${speed.toFixed(1)}x`;
    if (playing) {
      stopPlaying();
      play();
    }
  });

  startSelect.addEventListener('change', () => {
    const id = parseInt(startSelect.value, 10);
    selectStartNodeUI(id);
  });

  modeSelect.addEventListener('change', () => {
    stopPlaying();
    resetRuntime();
  });

  // Bootstrap
  function initStartDropdown() {
    startSelect.innerHTML = '';
    for (let i = 0; i < N; i++) {
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = label(i);
      startSelect.appendChild(opt);
    }
    startSelect.value = 0;
    selectStartNodeUI(0);
  }

  initNodes();
  initStartDropdown();
  initAdjacencyDefault();
  resetRuntime();
})();
</script>
</body>
</html>