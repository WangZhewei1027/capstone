<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Breadth-First Search (BFS) Visualizer</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --text: #e5e7eb;
    --muted: #94a3b8;
    --accent: #60a5fa;
    --accent-2: #22c55e;
    --warn: #f59e0b;
    --border: #1f2937;
    --node: #cbd5e1;
    --edge: #475569;
  }
  html, body {
    background: var(--bg);
    color: var(--text);
    margin: 0; padding: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial;
  }
  header {
    padding: 18px;
    border-bottom: 1px solid var(--border);
    display: flex; align-items: center; gap: 16px; flex-wrap: wrap;
  }
  header h1 {
    margin: 0;
    font-size: 22px;
    letter-spacing: 0.2px;
  }
  header .desc {
    color: var(--muted);
    font-size: 14px;
  }
  main {
    display: grid;
    grid-template-columns: 320px 1fr;
    gap: 12px;
    padding: 12px;
  }
  @media (max-width: 900px) {
    main { grid-template-columns: 1fr; }
  }
  .panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 14px;
  }
  .panel h2 {
    margin: 0 0 10px;
    font-size: 16px;
    color: var(--text);
  }
  .controls label {
    display: block;
    font-size: 13px;
    color: var(--muted);
    margin-bottom: 6px;
  }
  .controls select, .controls input[type="range"] {
    width: 100%;
    padding: 8px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: #0b1220;
    color: var(--text);
    margin-bottom: 10px;
  }
  .btn-row {
    display: flex; flex-wrap: wrap; gap: 8px; margin-top: 6px;
  }
  button {
    background: #0b1220;
    border: 1px solid var(--border);
    color: var(--text);
    padding: 8px 10px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
  }
  button.primary { background: var(--accent); color: #0b1220; border-color: transparent; }
  button.warn { background: var(--warn); color: #0b1220; border-color: transparent; }
  button:disabled { opacity: 0.5; cursor: default; }
  .legend {
    display: grid; grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 8px; margin-top: 8px;
    font-size: 13px;
  }
  .legend div {
    display: flex; align-items: center; gap: 8px;
  }
  .swatch {
    width: 18px; height: 18px; border-radius: 50%;
    border: 2px solid var(--edge);
  }
  .swatch.unvisited { background: var(--node); }
  .swatch.visited { background: #2563eb; }
  .swatch.queue { background: #0b1220; border-color: #60a5fa; }
  .swatch.current { background: var(--warn); }
  .swatch.start { background: #0b1220; border-color: #22c55e; }
  .graph-panel {
    position: relative;
    min-height: 420px;
  }
  .graph-wrapper {
    position: relative;
    width: 100%;
    height: 520px;
    border-radius: 12px;
    overflow: hidden;
    background: #0b1220;
    border: 1px solid var(--border);
  }
  svg {
    width: 100%; height: 100%;
  }
  .edge {
    stroke: var(--edge);
    stroke-width: 2;
    opacity: 0.75;
  }
  .node circle {
    fill: var(--node);
    stroke: var(--edge);
    stroke-width: 2;
    transition: transform 0.06s ease-in-out;
  }
  .node text {
    fill: #0b1220;
    font-weight: 600;
    font-size: 13px;
    pointer-events: none;
  }
  .node .dist {
    fill: var(--muted);
    font-size: 11px;
  }
  .node.visited circle { fill: #2563eb; stroke: #1e40af; }
  .node.queue circle { stroke: #60a5fa; stroke-width: 3; }
  .node.current circle { fill: #f59e0b; stroke: #b45309; }
  .node.start circle { stroke: #22c55e; stroke-width: 3; }
  .node:hover circle { transform: scale(1.06); }
  .hint {
    font-size: 12px; color: var(--muted);
    margin-top: 6px;
  }
  .code {
    background: #0b1220;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 10px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 13px;
    line-height: 1.5;
    color: var(--text);
    white-space: pre;
  }
  .code .hl { background: rgba(96,165,250,0.15); border-left: 3px solid var(--accent); padding-left: 6px; }
  .status {
    display: grid; grid-template-columns: 1fr 1fr; gap: 12px;
    margin-top: 10px;
  }
  .queue, .visited-list {
    background: #0b1220; border: 1px solid var(--border); border-radius: 8px; padding: 8px;
    min-height: 44px;
  }
  .queue .title, .visited-list .title {
    color: var(--muted); font-size: 12px; margin-bottom: 6px;
  }
  .queue-items {
    display: flex; gap: 6px; flex-wrap: wrap;
  }
  .q-item {
    background: #0b1220;
    border: 1px solid #60a5fa;
    color: #60a5fa;
    padding: 6px 8px;
    border-radius: 6px;
    font-weight: 600;
    font-size: 13px;
  }
  .visited-items {
    display: flex; gap: 6px; flex-wrap: wrap;
  }
  .v-item {
    background: #111827;
    border: 1px solid #1e40af;
    color: #93c5fd;
    padding: 6px 8px;
    border-radius: 6px;
    font-weight: 600;
    font-size: 13px;
  }
  .log {
    background: #0b1220; border: 1px solid var(--border); border-radius: 8px; padding: 8px;
    margin-top: 10px;
    min-height: 42px;
    font-size: 13px;
    color: var(--muted);
  }
  .footer-hint {
    padding: 12px;
    color: var(--muted);
    font-size: 12px;
  }
  .speed-row {
    display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center;
  }
  .speed-value {
    font-size: 12px; color: var(--muted);
  }
</style>
</head>
<body>
<header>
  <h1>Breadth-First Search (BFS)</h1>
  <div class="desc">Interactive visualization of BFS on an undirected graph. Click a node to choose a start, then step through or play.</div>
</header>

<main>
  <section class="panel controls">
    <h2>Controls</h2>
    <label for="startNode">Start node</label>
    <select id="startNode"></select>

    <div class="btn-row">
      <button id="setStartBtn">Set Start</button>
      <button id="resetBtn">Reset</button>
    </div>

    <div class="btn-row">
      <button id="stepBtn" class="primary">Next Step</button>
      <button id="playBtn" class="primary">Play</button>
      <button id="pauseBtn">Pause</button>
    </div>

    <div class="speed-row" style="margin-top: 8px;">
      <input type="range" id="speed" min="100" max="1500" step="50" value="600" />
      <div class="speed-value">Speed: <span id="speedVal">600ms</span></div>
    </div>

    <div class="legend">
      <div><span class="swatch unvisited"></span>Unvisited</div>
      <div><span class="swatch visited"></span>Visited</div>
      <div><span class="swatch queue"></span>In Queue</div>
      <div><span class="swatch current"></span>Current</div>
      <div><span class="swatch start"></span>Start</div>
    </div>

    <div class="hint">Tip: You can drag nodes to rearrange the graph.</div>

    <h2 style="margin-top: 14px;">BFS Pseudocode</h2>
    <div id="code" class="code"></div>
  </section>

  <section class="graph-panel panel">
    <h2>Graph</h2>
    <div class="graph-wrapper">
      <svg id="graph" viewBox="0 0 900 520" preserveAspectRatio="xMidYMid meet"></svg>
    </div>

    <div class="status">
      <div class="queue">
        <div class="title">Queue (FIFO)</div>
        <div id="queueItems" class="queue-items"></div>
      </div>
      <div class="visited-list">
        <div class="title">Visited</div>
        <div id="visitedItems" class="visited-items"></div>
      </div>
    </div>

    <div id="log" class="log">Choose a start node to begin.</div>
  </section>
</main>

<div class="footer-hint">BFS explores neighbors level by level using a queue. It guarantees shortest path distances in terms of edge count on unweighted graphs.</div>

<script>
(function() {
  // Graph definition
  const nodes = [
    { id: 'A', x: 120, y: 120 },
    { id: 'B', x: 280, y: 90 },
    { id: 'C', x: 260, y: 220 },
    { id: 'D', x: 420, y: 80 },
    { id: 'E', x: 420, y: 180 },
    { id: 'F', x: 420, y: 280 },
    { id: 'G', x: 580, y: 160 },
    { id: 'H', x: 560, y: 300 },
    { id: 'I', x: 740, y: 230 },
  ];
  const edges = [
    ['A','B'], ['A','C'], ['B','D'], ['B','E'],
    ['C','F'], ['C','D'], ['E','G'], ['D','G'],
    ['F','H'], ['H','I'], ['G','I'], ['E','F']
  ]; // undirected

  const adj = buildAdjacency(nodes, edges);

  // DOM references
  const svg = document.getElementById('graph');
  const startSelect = document.getElementById('startNode');
  const setStartBtn = document.getElementById('setStartBtn');
  const resetBtn = document.getElementById('resetBtn');
  const stepBtn = document.getElementById('stepBtn');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const speedRange = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const queueItemsEl = document.getElementById('queueItems');
  const visitedItemsEl = document.getElementById('visitedItems');
  const logEl = document.getElementById('log');
  const codeEl = document.getElementById('code');

  speedVal.textContent = speedRange.value + 'ms';

  // Render UI components
  populateStartSelect();
  renderCode();
  const { nodeElements, edgeElements } = renderGraph();

  // BFS state
  let bfs = null;
  let startNodeId = nodes[0].id;
  let playingTimer = null;

  // Initialize
  setStart(startNodeId);
  reset();

  // Event listeners
  startSelect.addEventListener('change', () => {
    setStart(startSelect.value);
    reset();
  });
  setStartBtn.addEventListener('click', () => {
    log('Click a node to set it as start.');
    highlightCode(); // clear
    // next click will set start (handled in node click)
    awaitingStartClick = true;
  });
  resetBtn.addEventListener('click', reset);
  stepBtn.addEventListener('click', () => {
    step();
  });
  playBtn.addEventListener('click', () => {
    if (!bfs || bfs.stage === 'done') reset();
    autoPlay();
  });
  pauseBtn.addEventListener('click', pause);
  speedRange.addEventListener('input', () => {
    speedVal.textContent = speedRange.value + 'ms';
    if (playingTimer) { autoPlay(true); } // update timer
  });

  let awaitingStartClick = false;

  // Node interactions: click to set start, drag to move
  nodes.forEach(n => {
    const g = nodeElements[n.id];
    g.addEventListener('click', () => {
      if (awaitingStartClick) {
        awaitingStartClick = false;
        setStart(n.id);
        reset();
        log(`Start set to ${n.id}. Press Next Step or Play.`);
        return;
      }
      setStart(n.id);
      reset();
      log(`Start set to ${n.id}. Press Next Step or Play.`);
    });
    makeDraggable(n.id);
  });

  // Core functions

  function buildAdjacency(nodes, edges) {
    const adj = {};
    nodes.forEach(n => adj[n.id] = new Set());
    edges.forEach(([u,v]) => {
      adj[u].add(v);
      adj[v].add(u); // undirected
    });
    // Convert to sorted arrays for stable traversal
    Object.keys(adj).forEach(k => adj[k] = Array.from(adj[k]).sort());
    return adj;
  }

  function populateStartSelect() {
    startSelect.innerHTML = '';
    nodes.forEach(n => {
      const opt = document.createElement('option');
      opt.value = n.id;
      opt.textContent = n.id;
      startSelect.appendChild(opt);
    });
  }

  function renderGraph() {
    // Clear svg
    svg.innerHTML = '';
    const edgeElements = [];
    edges.forEach(([u,v]) => {
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.classList.add('edge');
      const nu = nodes.find(x => x.id === u);
      const nv = nodes.find(x => x.id === v);
      line.setAttribute('x1', nu.x); line.setAttribute('y1', nu.y);
      line.setAttribute('x2', nv.x); line.setAttribute('y2', nv.y);
      line.dataset.u = u; line.dataset.v = v;
      svg.appendChild(line);
      edgeElements.push(line);
    });

    const nodeElements = {};
    nodes.forEach(n => {
      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.classList.add('node');
      g.dataset.id = n.id;
      g.setAttribute('transform', `translate(${n.x},${n.y})`);

      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('r', 22);
      circle.setAttribute('cx', 0);
      circle.setAttribute('cy', 0);

      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', 0); label.setAttribute('y', 4);
      label.setAttribute('text-anchor', 'middle');
      label.textContent = n.id;

      const dist = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      dist.setAttribute('x', 0); dist.setAttribute('y', 22);
      dist.setAttribute('text-anchor', 'middle');
      dist.classList.add('dist');
      dist.textContent = '';

      g.appendChild(circle);
      g.appendChild(label);
      g.appendChild(dist);
      svg.appendChild(g);
      nodeElements[n.id] = g;
    });

    return { nodeElements, edgeElements };
  }

  function updateEdges() {
    edgeElements.forEach(line => {
      const u = nodes.find(n => n.id === line.dataset.u);
      const v = nodes.find(n => n.id === line.dataset.v);
      line.setAttribute('x1', u.x); line.setAttribute('y1', u.y);
      line.setAttribute('x2', v.x); line.setAttribute('y2', v.y);
    });
  }

  function setStart(id) {
    startNodeId = id;
    startSelect.value = id;
    // update node classes
    nodes.forEach(n => {
      const el = nodeElements[n.id];
      el.classList.remove('start');
      if (n.id === id) el.classList.add('start');
    });
  }

  function reset() {
    pause();
    bfs = {
      queue: [],
      visited: new Set(),
      dist: {},
      parent: {},
      current: null,
      neighborIndex: 0,
      stage: 'init'
    };
    nodes.forEach(n => {
      const el = nodeElements[n.id];
      el.classList.remove('visited','queue','current');
      const distEl = el.querySelector('.dist');
      distEl.textContent = '';
      const label = el.querySelector('text');
      label.textContent = n.id;
    });
    renderQueue();
    renderVisited();
    highlightCode(); // clear
    log(`Ready. Start node: ${startNodeId}. Press Next Step or Play.`);
  }

  function renderQueue() {
    queueItemsEl.innerHTML = '';
    bfs.queue.forEach(id => {
      const div = document.createElement('div');
      div.className = 'q-item';
      div.textContent = id;
      queueItemsEl.appendChild(div);
    });
    // update node queue class
    nodes.forEach(n => {
      const el = nodeElements[n.id];
      if (bfs.queue.includes(n.id)) el.classList.add('queue');
      else el.classList.remove('queue');
    });
  }

  function renderVisited() {
    visitedItemsEl.innerHTML = '';
    Array.from(bfs.visited).forEach(id => {
      const div = document.createElement('div');
      div.className = 'v-item';
      const d = bfs.dist[id];
      div.textContent = d !== undefined ? `${id} (d=${d})` : id;
      visitedItemsEl.appendChild(div);
    });
  }

  function setNodeVisited(id, visited=true) {
    const el = nodeElements[id];
    if (visited) el.classList.add('visited');
    else el.classList.remove('visited');
    renderVisited();
    const distEl = el.querySelector('.dist');
    const labelEl = el.querySelector('text');
    const d = bfs.dist[id];
    distEl.textContent = (d !== undefined) ? `d=${d}` : '';
    labelEl.textContent = id;
  }

  function setNodeCurrent(id, current=true) {
    nodes.forEach(n => nodeElements[n.id].classList.remove('current'));
    if (id && current) nodeElements[id].classList.add('current');
  }

  function step() {
    if (!bfs) reset();
    if (bfs.stage === 'done') {
      log('BFS complete. Reset to run again.');
      highlightCode(); // clear
      return;
    }

    if (bfs.stage === 'init') {
      // enqueue start, visited[start]=true, dist[start]=0
      bfs.queue.push(startNodeId);
      bfs.visited.add(startNodeId);
      bfs.dist[startNodeId] = 0;
      setNodeVisited(startNodeId, true);
      renderQueue();
      renderVisited();
      setNodeCurrent(null);
      log(`Initialize: enqueue ${startNodeId}, mark visited, dist=0.`);
      highlightCode(1);
      bfs.stage = 'loop';
      return;
    }

    if (bfs.stage === 'loop') {
      highlightCode(2);
      if (bfs.queue.length === 0) {
        bfs.stage = 'done';
        setNodeCurrent(null);
        log('Queue empty: BFS finished.');
        highlightCode(); // clear
        renderQueue();
        renderVisited();
        return;
      }
      // dequeue
      bfs.current = bfs.queue.shift();
      bfs.neighborIndex = 0;
      setNodeCurrent(bfs.current, true);
      renderQueue();
      log(`Dequeue ${bfs.current}. Explore its neighbors.`);
      highlightCode(3);
      bfs.stage = 'neighbors';
      return;
    }

    if (bfs.stage === 'neighbors') {
      const u = bfs.current;
      const neighbors = adj[u] || [];
      if (bfs.neighborIndex >= neighbors.length) {
        // done with neighbors, continue loop
        setNodeCurrent(null);
        log(`Done exploring neighbors of ${u}.`);
        highlightCode(2);
        bfs.current = null;
        bfs.stage = 'loop';
        return;
      }
      const v = neighbors[bfs.neighborIndex++];
      highlightCode(4);

      if (bfs.visited.has(v)) {
        log(`Neighbor ${v} already visited. Skip.`);
        highlightCode(5);
        // brief visual emphasis
        flashNode(v, '#94a3b8');
        return;
      }

      // visit v
      bfs.visited.add(v);
      bfs.parent[v] = u;
      bfs.dist[v] = bfs.dist[u] + 1;
      bfs.queue.push(v);
      setNodeVisited(v, true);
      renderQueue();
      renderVisited();
      log(`Visit ${v}: set dist=${bfs.dist[v]} (from ${u}), enqueue ${v}.`);
      highlightCode([5,6,7,8]);
      return;
    }
  }

  function autoPlay(restartTimer=false) {
    if (restartTimer && playingTimer) {
      clearInterval(playingTimer);
      playingTimer = null;
    }
    const interval = parseInt(speedRange.value, 10);
    if (!playingTimer) {
      playingTimer = setInterval(() => {
        step();
        if (bfs.stage === 'done') pause();
      }, interval);
      log('Auto-play started.');
    }
  }

  function pause() {
    if (playingTimer) {
      clearInterval(playingTimer);
      playingTimer = null;
      log('Paused.');
    }
  }

  function flashNode(id, color='#f472b6') {
    const el = nodeElements[id].querySelector('circle');
    const prev = el.getAttribute('stroke');
    const prevW = el.getAttribute('stroke-width');
    el.setAttribute('stroke', color);
    el.setAttribute('stroke-width', 4);
    setTimeout(() => {
      el.setAttribute('stroke', prev || 'var(--edge)');
      el.setAttribute('stroke-width', prevW || 2);
    }, 350);
  }

  function log(msg) {
    logEl.textContent = msg;
  }

  function renderCode() {
    const lines = [
      'enqueue(start); visited[start] = true; dist[start] = 0;',
      'while queue is not empty:',
      '    u = dequeue();',
      '    for each v in neighbors[u]:',
      '        if not visited[v]:',
      '            visited[v] = true;',
      '            dist[v] = dist[u] + 1;',
      '            enqueue(v);'
    ];
    codeEl.innerHTML = lines.map((l, i) => `<div data-line="${i+1}">${l}</div>`).join('\n');
  }

  function highlightCode(lineOrLines) {
    Array.from(codeEl.children).forEach(ch => ch.classList.remove('hl'));
    if (!lineOrLines) return;
    if (Array.isArray(lineOrLines)) {
      lineOrLines.forEach(n => {
        const el = codeEl.querySelector(`[data-line="${n}"]`);
        if (el) el.classList.add('hl');
      });
    } else {
      const el = codeEl.querySelector(`[data-line="${lineOrLines}"]`);
      if (el) el.classList.add('hl');
    }
  }

  // Dragging nodes
  function makeDraggable(id) {
    const g = nodeElements[id];
    let dragging = false;
    let start = null;

    g.addEventListener('mousedown', (e) => {
      dragging = true;
      start = { x: e.clientX, y: e.clientY };
      e.preventDefault();
    });
    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const dx = e.clientX - start.x;
      const dy = e.clientY - start.y;
      start = { x: e.clientX, y: e.clientY };
      const n = nodes.find(nn => nn.id === id);
      n.x += dx; n.y += dy;
      g.setAttribute('transform', `translate(${n.x},${n.y})`);
      updateEdges();
    });
    window.addEventListener('mouseup', () => {
      dragging = false;
    });
    // touch
    g.addEventListener('touchstart', (e) => {
      dragging = true;
      const t = e.touches[0];
      start = { x: t.clientX, y: t.clientY };
      e.preventDefault();
    }, { passive: false });
    window.addEventListener('touchmove', (e) => {
      if (!dragging) return;
      const t = e.touches[0];
      const dx = t.clientX - start.x;
      const dy = t.clientY - start.y;
      start = { x: t.clientX, y: t.clientY };
      const n = nodes.find(nn => nn.id === id);
      n.x += dx; n.y += dy;
      g.setAttribute('transform', `translate(${n.x},${n.y})`);
      updateEdges();
    }, { passive: false });
    window.addEventListener('touchend', () => { dragging = false; });
  }

})();
</script>
</body>
</html>