<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Two Pointers Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0f1320;
      --panel:#171b2b;
      --accent:#6bc1ff;
      --accent2:#ffc36b;
      --green:#6bff88;
      --red:#ff6b6b;
      --yellow:#ffd86b;
      --text:#e8ebf2;
      --muted:#a9b1c7;
      --border:#2a3048;
      --purple:#b28aff;
      --pink:#ff9ad1;
      --cyan:#8cf0ff;
    }

    *{ box-sizing: border-box; }
    body{
      margin:0;
      background: radial-gradient(1200px 600px at 10% 0%, #151b30 0%, #0f1320 60%, #0b0f1a 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      line-height: 1.4;
    }

    header{
      padding: 20px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(0deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      position: sticky;
      top:0;
      z-index: 5;
    }

    h1{
      margin:0 0 6px 0;
      font-size: 22px;
      letter-spacing: 0.2px;
    }
    .subtitle{
      font-size: 13px;
      color: var(--muted);
    }

    .container{
      padding: 16px 20px 26px;
    }

    .controls{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    @media (min-width: 900px){
      .controls{
        grid-template-columns: 1.2fr 1fr 1fr;
      }
    }

    .control-block{
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      background: rgba(255,255,255,0.02);
    }
    .control-block h3{
      margin: 0 0 8px 0;
      font-size: 14px;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    .row{ display:flex; gap:8px; flex-wrap: wrap; align-items: center; }
    label{ font-size: 12px; color: var(--muted); }
    input[type="text"], input[type="number"], select{
      width: 100%;
      padding: 8px 10px;
      background: #0f1426;
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 8px;
      outline: none;
    }
    input[type="checkbox"]{ transform: translateY(2px); }
    .small{ font-size: 12px; color: var(--muted); }
    .btn{
      padding: 8px 12px;
      border-radius: 8px;
      background: #122040;
      border: 1px solid #1e2a4d;
      color: var(--text);
      cursor: pointer;
      font-size: 13px;
    }
    .btn:hover{ filter: brightness(1.1); }
    .btn.primary{ background: #17305c; border-color: #274b84; }
    .btn.danger{ background:#32101a; border-color:#601a2b; }
    .btn:disabled{ opacity:0.5; cursor:not-allowed; }

    .viz-wrap{
      margin-top: 14px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
    }

    .legend{
      display:flex; gap:16px; flex-wrap: wrap;
      font-size: 12px; color: var(--muted); margin-bottom:8px;
    }
    .legend .swatch{
      width: 10px; height: 10px; border-radius: 50%; display:inline-block; margin-right:6px; position: relative; top:1px;
      border:1px solid rgba(255,255,255,0.15);
    }

    .array-scroll{
      overflow-x: auto;
      padding-bottom: 8px;
    }

    .array{
      display:flex; gap: 8px; padding: 6px; min-height: 88px;
    }
    .cell{
      position: relative;
      min-width: 56px;
      height: 64px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #0f1426;
      display:flex; align-items:center; justify-content:center;
      font-size: 16px; font-weight: 600;
      color: var(--text);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
    }
    .cell.muted{ color: #7f8aa8; }
    .cell.found{ border-color: var(--green); box-shadow: 0 0 10px rgba(107,255,136,0.3); }
    .cell.swap{ animation: pulse 400ms ease; }
    .cell.compare{ animation: pulse2 400ms ease; }
    @keyframes pulse{
      0%{ box-shadow: 0 0 0 rgba(255,255,255,0.0); }
      50%{ box-shadow: 0 0 14px rgba(107,193,255,0.3); }
      100%{ box-shadow: 0 0 0 rgba(255,255,255,0.0); }
    }
    @keyframes pulse2{
      0%{ box-shadow: 0 0 0 rgba(255,255,255,0.0); }
      50%{ box-shadow: 0 0 14px rgba(255,216,107,0.3); }
      100%{ box-shadow: 0 0 0 rgba(255,255,255,0.0); }
    }

    .index{
      position: absolute; bottom: 4px; right: 6px;
      font-size: 11px; color: var(--muted);
    }
    .badge{
      position: absolute;
      top: -10px; left: 50%; transform: translateX(-50%);
      background: #19243d;
      border: 1px solid #2a3f68;
      color: var(--text);
      padding: 3px 6px;
      border-radius: 12px;
      font-size: 11px;
      white-space: nowrap;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .badge.bottom{ top: auto; bottom: -10px; }
    .badge.l{ background: #142f47; border-color: #2a5f84; }
    .badge.r{ background: #3a243f; border-color: #7a4a84; }
    .badge.slow{ background: #143824; border-color: #2a6f48; }
    .badge.fast{ background: #443014; border-color: #8a5f2a; }
    .badge.mid{ background: #2a152a; border-color: #6a3a6a; }
    .badge.k{ background:#152a2a; border-color:#3a6a6a; }

    .status{
      margin-top: 10px;
      font-size: 13px;
      color: var(--muted);
      display:flex; gap:8px; flex-wrap: wrap;
    }
    .status .pill{
      padding: 4px 8px;
      border:1px solid var(--border);
      border-radius: 999px;
      background: rgba(255,255,255,0.02);
      color: var(--text);
    }

    .invariant{
      margin-top: 8px;
      font-size: 13px;
      color: var(--muted);
      border-left: 3px solid #2a3f68;
      padding-left: 10px;
    }

    .log{
      margin-top: 12px;
      background: #0e1629;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      max-height: 180px;
      overflow: auto;
      font-size: 12px;
    }
    .log .entry{
      padding: 6px 8px;
      border-radius: 8px;
      margin-bottom: 6px;
      background: rgba(255,255,255,0.03);
    }

    .footer{
      padding: 10px 20px 30px;
      color: var(--muted);
      font-size: 12px;
      text-align: center;
    }

    .examples{
      display:flex; gap:8px; flex-wrap: wrap;
    }
    .example{
      padding: 6px 8px;
      border-radius: 8px;
      background: #10182b;
      border: 1px solid var(--border);
      font-size: 12px;
      cursor: pointer;
      color: var(--text);
    }
    .example:hover{ filter: brightness(1.1); }
  </style>
</head>
<body>
<header>
  <h1>Two Pointers Visualizer</h1>
  <div class="subtitle">Interactively step through classic two-pointer algorithms on arrays.</div>
</header>

<div class="container">
  <div class="controls">
    <div class="control-block">
      <h3>Algorithm</h3>
      <div class="row">
        <select id="algoSelect">
          <option value="twoSum">Two Sum (sorted)</option>
          <option value="reverse">Reverse Array</option>
          <option value="removeDup">Remove Duplicates (sorted)</option>
          <option value="moveZeroes">Move Zeroes</option>
          <option value="partitionParity">Partition Even/Odd</option>
        </select>
      </div>
      <div class="row" id="algoExtraRow" style="margin-top:8px; display:none;">
        <label for="targetInput">Target</label>
        <input id="targetInput" type="number" placeholder="Enter target sum" />
      </div>
      <div class="row" style="margin-top:8px;">
        <label><input type="checkbox" id="sortInputChk" /> Sort input where needed</label>
      </div>
      <div class="small" id="algoHint">Hint: Select an algorithm to see its invariant.</div>
    </div>

    <div class="control-block">
      <h3>Array</h3>
      <div class="row">
        <input id="arrayInput" type="text" placeholder="e.g., 1,2,2,3,4,5" />
      </div>
      <div class="row">
        <button class="btn" id="btnRandom">Random</button>
        <input id="randLen" type="number" min="2" max="40" value="12" style="max-width:90px;" />
        <input id="randMin" type="number" value="0" style="max-width:90px;" />
        <input id="randMax" type="number" value="20" style="max-width:90px;" />
      </div>
      <div class="examples" style="margin-top:6px;">
        <div class="example" data-arr="1,2,3,4,7,9,11">Sorted example</div>
        <div class="example" data-arr="0,1,0,3,12,0,5">Zeros example</div>
        <div class="example" data-arr="1,1,2,2,3,3,4">Duplicates example</div>
        <div class="example" data-arr="9,2,5,8,1,6,3,4">Mixed example</div>
      </div>
    </div>

    <div class="control-block">
      <h3>Run</h3>
      <div class="row">
        <button class="btn primary" id="btnInit">Initialize</button>
        <button class="btn" id="btnStep" disabled>Next Step</button>
        <button class="btn" id="btnAuto" disabled>Auto Play</button>
        <button class="btn danger" id="btnReset" disabled>Reset</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <label for="speedRange">Speed</label>
        <input id="speedRange" type="range" min="100" max="1500" value="600" />
        <span class="small" id="speedLabel">600 ms</span>
      </div>
    </div>
  </div>

  <div class="viz-wrap">
    <div class="legend">
      <div><span class="swatch" style="background: #142f47;"></span> Left/L</div>
      <div><span class="swatch" style="background: #3a243f;"></span> Right/R</div>
      <div><span class="swatch" style="background: #143824;"></span> Slow</div>
      <div><span class="swatch" style="background: #443014;"></span> Fast</div>
      <div><span class="swatch" style="background: #2a152a;"></span> Mid/K</div>
    </div>
    <div class="array-scroll">
      <div class="array" id="arrayView"></div>
    </div>
    <div class="status" id="statusBar"></div>
    <div class="invariant" id="invariantText"></div>
    <div class="log" id="log"></div>
  </div>

  <div class="footer">
    Two pointers is a technique where you maintain indices moving through a structure under invariants that ensure linear-time solutions. Step through to see decisions and pointer movements.
  </div>
</div>

<script>
  // Utility Functions
  function parseArrayInput(str){
    if(!str) return [];
    return str
      .split(/[\s,;]+/)
      .map(s => s.trim())
      .filter(s => s.length>0)
      .map(Number)
      .filter(n => Number.isFinite(n));
  }
  function randomArray(len=10, min=0, max=20){
    const arr = [];
    for(let i=0;i<len;i++){
      arr.push(Math.floor(Math.random()*(max-min+1))+min);
    }
    return arr;
  }
  function clone(arr){ return arr.slice(); }

  // Algorithms Definition
  const ALGORITHMS = {
    twoSum: {
      name: "Two Sum (sorted)",
      requiresSorted: true,
      inputs: ["target"],
      invariant: "Array must be sorted. Compare a[L] + a[R] with target: if sum < target, move L++; if sum > target, move R--; else found.",
      init(array, options){
        const arr = options.sort ? clone(array).sort((a,b)=>a-b) : clone(array);
        const target = Number(options.target ?? 0);
        return {
          array: arr,
          left: 0,
          right: arr.length - 1,
          target,
          found: null,
          done: false,
          lastOp: null
        };
      },
      pointers(state){
        const p = [];
        if(state.left>=0 && state.left < state.array.length){
          p.push({index: state.left, label: "L", class: "l", side: "top"});
        }
        if(state.right>=0 && state.right < state.array.length){
          p.push({index: state.right, label: "R", class: "r", side: "top"});
        }
        return p;
      },
      step(state){
        if(state.done) return {status:"done", msg:"Finished"};
        const {array, left, right, target} = state;
        if(array.length===0) { state.done=true; return {status:"done", msg:"Empty array"}; }
        if(left >= right){
          state.done = true;
          state.lastOp = {type:"final", indices:[left,right], msg:"Pointers crossed: no pair found"};
          return {status:"done", msg:"Pointers crossed: no pair found"};
        }
        const sum = array[left] + array[right];
        let msg = `Compare a[L=${left}]=${array[left]} + a[R=${right}]=${array[right]} = ${sum}`;
        if(sum === target){
          state.found = [left,right];
          state.done = true;
          state.lastOp = {type:"found", indices:[left,right], msg: msg + ` equals target ${target}. Pair found!`};
          return {status:"done", msg: state.lastOp.msg};
        } else if(sum < target){
          state.lastOp = {type:"compare", indices:[left,right], msg: msg + ` < target ${target}. Move L++`};
          state.left++;
          return {status:"continue", msg: state.lastOp.msg};
        } else {
          state.lastOp = {type:"compare", indices:[left,right], msg: msg + ` > target ${target}. Move R--`};
          state.right--;
          return {status:"continue", msg: state.lastOp.msg};
        }
      },
      result(state){
        if(state.found) {
          const [l,r] = state.found;
          return `Found indices L=${l}, R=${r} -> ${state.array[l]} + ${state.array[r]} = ${state.target}`;
        }
        return "No pair sums to target.";
      }
    },

    reverse: {
      name: "Reverse Array",
      requiresSorted: false,
      inputs: [],
      invariant: "Elements before L and after R are in their final reversed positions. Swap a[L] and a[R], then move L++, R--.",
      init(array){
        return { array: clone(array), left: 0, right: array.length-1, done: false, lastOp: null };
      },
      pointers(state){
        const p = [];
        if(state.left>=0 && state.left<state.array.length) p.push({index: state.left, label: "L", class:"l", side:"top"});
        if(state.right>=0 && state.right<state.array.length) p.push({index: state.right, label: "R", class:"r", side:"top"});
        return p;
      },
      step(state){
        if(state.done) return {status:"done", msg:"Finished"};
        if(state.left >= state.right){
          state.done = true;
          state.lastOp = {type:"final", indices:[state.left,state.right], msg:"Pointers met/crossed. Reversal complete."};
          return {status:"done", msg: state.lastOp.msg};
        }
        const i = state.left, j = state.right;
        const ai = state.array[i], aj = state.array[j];
        [state.array[i], state.array[j]] = [state.array[j], state.array[i]];
        state.lastOp = {type:"swap", indices:[i,j], msg:`Swap a[L=${i}]=${ai} with a[R=${j}]=${aj}. Move L++, R--.`};
        state.left++; state.right--;
        return {status:"continue", msg: state.lastOp.msg};
      },
      result(state){
        return `Reversed array: [${state.array.join(", ")}]`;
      }
    },

    removeDup: {
      name: "Remove Duplicates (sorted)",
      requiresSorted: true,
      inputs: [],
      invariant: "All elements in [0..slow] are unique. Fast scans forward; on a[fast] != a[slow], increment slow and copy a[fast] to a[slow].",
      init(array, options){
        const arr = options.sort ? clone(array).sort((a,b)=>a-b) : clone(array);
        return { array: arr, slow: 0, fast: arr.length>0 ? 1 : 0, done:false, lastOp:null };
      },
      pointers(state){
        const p = [];
        if(state.array.length>0){
          p.push({index: state.slow, label:"slow", class:"slow", side:"top"});
          if(state.fast < state.array.length) p.push({index: state.fast, label:"fast", class:"fast", side:"top"});
        }
        return p;
      },
      step(state){
        const n = state.array.length;
        if(n===0){ state.done=true; return {status:"done", msg:"Empty array"}; }
        if(state.done) return {status:"done", msg:"Finished"};
        if(state.fast >= n){
          state.done = true;
          const k = state.slow + 1;
          state.lastOp = {type:"final", indices:[state.slow], msg:`Done. Unique count = ${k}. First ${k} elements are deduplicated.`};
          return {status:"done", msg: state.lastOp.msg};
        }
        const s = state.slow, f = state.fast;
        const msgBase = `Compare a[fast=${f}]=${state.array[f]} with a[slow=${s}]=${state.array[s]}`;
        if(state.array[f] !== state.array[s]){
          state.slow++;
          const prev = state.array[state.slow];
          state.array[state.slow] = state.array[f];
          state.lastOp = {type:"write", indices:[state.slow,f], msg:`${msgBase} -> different. slow++ to ${state.slow}, write a[slow]=a[fast]=${state.array[f]}`};
        } else {
          state.lastOp = {type:"compare", indices:[s,f], msg:`${msgBase} -> equal. Keep slow at ${s}.`};
        }
        state.fast++;
        return {status:"continue", msg: state.lastOp.msg};
      },
      result(state){
        const k = state.array.length ? state.slow + 1 : 0;
        return `Unique length: ${k}. Deduplicated prefix: [${state.array.slice(0,k).join(", ")}]`;
      }
    },

    moveZeroes: {
      name: "Move Zeroes",
      requiresSorted: false,
      inputs: [],
      invariant: "All elements before slow are non-zero. Fast iterates; when a[fast] != 0, swap with a[slow] and advance slow.",
      init(array){
        return { array: clone(array), slow: 0, fast: 0, done:false, lastOp:null };
      },
      pointers(state){
        const p = [];
        if(state.array.length>0){
          p.push({index: Math.min(state.slow,state.array.length-1), label:"slow", class:"slow", side:"top"});
          if(state.fast < state.array.length) p.push({index: state.fast, label:"fast", class:"fast", side:"top"});
        }
        return p;
      },
      step(state){
        const n = state.array.length;
        if(state.done) return {status:"done", msg:"Finished"};
        if(state.fast >= n){
          state.done = true;
          state.lastOp = {type:"final", indices:[state.slow,state.fast-1], msg:"Completed. All non-zero elements moved to front; zeros pushed to end."};
          return {status:"done", msg: state.lastOp.msg};
        }
        const f = state.fast, s = state.slow;
        const val = state.array[f];
        if(val !== 0){
          if(s !== f){
            const beforeS = state.array[s], beforeF = state.array[f];
            [state.array[s], state.array[f]] = [state.array[f], state.array[s]];
            state.lastOp = {type:"swap", indices:[s,f], msg:`a[fast=${f}]=${beforeF} != 0 -> swap with a[slow=${s}]=${beforeS}; slow++`};
          } else {
            state.lastOp = {type:"write", indices:[s,f], msg:`a[fast=${f}]=${val} != 0 & slow==fast -> keep, slow++`};
          }
          state.slow++;
        } else {
          state.lastOp = {type:"compare", indices:[s,f], msg:`a[fast=${f}]=0 -> do nothing; just advance fast`};
        }
        state.fast++;
        return {status:"continue", msg: state.lastOp.msg};
      },
      result(state){
        return `Result: [${state.array.join(", ")}] (zeros at the end)`;
      }
    },

    partitionParity: {
      name: "Partition Even/Odd",
      requiresSorted: false,
      inputs: [],
      invariant: "All elements left of L are even; all right of R are odd. Move L right over evens and R left over odds; swap when L < R and both mis-placed.",
      init(array){
        return { array: clone(array), left: 0, right: array.length-1, done:false, lastOp:null };
      },
      pointers(state){
        const p=[];
        if(state.array.length>0){
          if(state.left>=0 && state.left<state.array.length) p.push({index: state.left, label:"L", class:"l", side:"top"});
          if(state.right>=0 && state.right<state.array.length) p.push({index: state.right, label:"R", class:"r", side:"top"});
        }
        return p;
      },
      step(state){
        if(state.done) return {status:"done", msg:"Finished"};
        const arr = state.array;
        let i = state.left, j = state.right;
        const n = arr.length;
        if(n===0){ state.done=true; return {status:"done", msg:"Empty array"}; }

        let moved = [];
        while(i < n && arr[i] % 2 === 0){ i++; moved.push(`L->${i}`); }
        while(j >= 0 && arr[j] % 2 === 1){ j--; moved.push(`R->${j}`); }

        const moveMsg = moved.length ? `Advance pointers: ${moved.join(", ")}` : "Pointers at candidates";
        state.left = i; state.right = j;

        if(i >= j){
          state.done = true;
          state.lastOp = {type:"final", indices:[i,j], msg:`${moveMsg}. Pointers met/crossed; partition complete.`};
          return {status:"done", msg: state.lastOp.msg};
        }

        const ai = arr[i], aj = arr[j];
        if(ai % 2 === 1 && aj % 2 === 0){
          [arr[i], arr[j]] = [arr[j], arr[i]];
          state.lastOp = {type:"swap", indices:[i,j], msg:`Swap odd a[L=${i}]=${ai} with even a[R=${j}]=${aj}.`};
          return {status:"continue", msg: `${moveMsg}. ` + state.lastOp.msg};
        } else {
          // Rare: if they already in correct parity, just move one step to avoid infinite loop.
          if(ai % 2 === 0) state.left++;
          if(aj % 2 === 1) state.right--;
          state.lastOp = {type:"compare", indices:[i,j], msg:`No swap needed here. Adjust pointers.`};
          return {status:"continue", msg: `${moveMsg}. ` + state.lastOp.msg};
        }
      },
      result(state){
        return `Partitioned array: [${state.array.join(", ")}] (evens left, odds right)`;
      }
    }
  };

  // UI State
  const ui = {
    algoSelect: document.getElementById("algoSelect"),
    arrayInput: document.getElementById("arrayInput"),
    sortChk: document.getElementById("sortInputChk"),
    targetInput: document.getElementById("targetInput"),
    algoExtraRow: document.getElementById("algoExtraRow"),
    algoHint: document.getElementById("algoHint"),
    btnRandom: document.getElementById("btnRandom"),
    randLen: document.getElementById("randLen"),
    randMin: document.getElementById("randMin"),
    randMax: document.getElementById("randMax"),
    examples: document.querySelectorAll(".example"),
    btnInit: document.getElementById("btnInit"),
    btnStep: document.getElementById("btnStep"),
    btnAuto: document.getElementById("btnAuto"),
    btnReset: document.getElementById("btnReset"),
    speedRange: document.getElementById("speedRange"),
    speedLabel: document.getElementById("speedLabel"),
    arrayView: document.getElementById("arrayView"),
    statusBar: document.getElementById("statusBar"),
    invariantText: document.getElementById("invariantText"),
    log: document.getElementById("log")
  };

  let runtime = {
    algoId: ui.algoSelect.value,
    state: null,
    autoTimer: null,
    speed: Number(ui.speedRange.value),
    lastHighlights: { swap:[], compare:[], found:[] }
  };

  // Rendering
  function render(){
    renderArray();
    renderStatus();
    renderInvariant();
  }

  function renderArray(){
    const arr = runtime.state ? runtime.state.array : parseArrayInput(ui.arrayInput.value);
    const arrayView = ui.arrayView;
    arrayView.innerHTML = "";

    const pointers = runtime.state ? getPointers(runtime.algoId, runtime.state) : [];
    const highlights = runtime.lastHighlights;

    arr.forEach((val, idx) => {
      const cell = document.createElement("div");
      cell.className = "cell";
      // Highlights based on last operation
      if(highlights.swap.includes(idx)) cell.classList.add("swap");
      if(highlights.compare.includes(idx)) cell.classList.add("compare");
      if(highlights.found.includes(idx)) cell.classList.add("found");

      cell.textContent = String(val);
      const index = document.createElement("div");
      index.className = "index";
      index.textContent = idx;
      cell.appendChild(index);

      // Attach pointer badges
      const atIdx = pointers.filter(p => p.index === idx);
      atIdx.forEach((p, k) => {
        const badge = document.createElement("div");
        badge.className = `badge ${p.class} ${p.side === "bottom" ? "bottom" : ""}`;
        badge.textContent = p.label;
        badge.style.top = p.side === "bottom" ? "" : (-10 - 16*k) + "px";
        if(p.side === "bottom"){
          badge.style.bottom = (-10 - 16*k) + "px";
        }
        cell.appendChild(badge);
      });

      arrayView.appendChild(cell);
    });
  }

  function renderStatus(){
    const statusBar = ui.statusBar;
    statusBar.innerHTML = "";

    const algo = ALGORITHMS[runtime.algoId];
    const pills = [];

    pills.push(`Algorithm: ${algo.name}`);

    const arr = runtime.state ? runtime.state.array : parseArrayInput(ui.arrayInput.value);
    pills.push(`Array length: ${arr.length}`);

    if(runtime.algoId === "twoSum"){
      const t = runtime.state ? runtime.state.target : Number(ui.targetInput.value || 0);
      pills.push(`Target: ${t}`);
    }

    if(runtime.state){
      const ls = document.createElement("div");
      ls.className = "pill";
      ls.textContent = runtime.state.lastOp ? runtime.state.lastOp.msg : "Initialized";
      statusBar.appendChild(ls);
    }

    pills.forEach(p => {
      const pill = document.createElement("div");
      pill.className = "pill";
      pill.textContent = p;
      statusBar.appendChild(pill);
    });

    // Log last op
    if(runtime.state && runtime.state.lastOp){
      appendLog(runtime.state.lastOp.msg);
    }
  }

  function renderInvariant(){
    const algo = ALGORITHMS[runtime.algoId];
    ui.invariantText.textContent = algo.invariant;
  }

  function appendLog(msg){
    if(!msg) return;
    const entry = document.createElement("div");
    entry.className = "entry";
    entry.textContent = msg;
    ui.log.appendChild(entry);
    ui.log.scrollTop = ui.log.scrollHeight;
  }

  function getPointers(algoId, state){
    try{
      return ALGORITHMS[algoId].pointers(state);
    }catch(e){
      return [];
    }
  }

  function clearHighlights(){
    runtime.lastHighlights = { swap:[], compare:[], found:[] };
  }
  function applyHighlightsFromLastOp(){
    clearHighlights();
    if(!runtime.state || !runtime.state.lastOp) return;
    const op = runtime.state.lastOp;
    const idxs = op.indices || [];
    if(op.type === "swap" || op.type === "write"){
      runtime.lastHighlights.swap = idxs;
    } else if(op.type === "compare"){
      runtime.lastHighlights.compare = idxs;
    } else if(op.type === "found"){
      runtime.lastHighlights.found = idxs;
    }
  }

  // Interaction
  function initRun(){
    const algoId = ui.algoSelect.value;
    runtime.algoId = algoId;
    const algo = ALGORITHMS[algoId];

    const array = parseArrayInput(ui.arrayInput.value);
    if(array.length === 0){
      alert("Please provide a non-empty array input.");
      return;
    }

    const options = {
      sort: !!ui.sortChk.checked,
      target: ui.targetInput.value
    };

    // Warn if requires sorted and not sorted, unless sort checked
    if(algo.requiresSorted && !options.sort){
      if(!isSorted(array)){
        if(!confirm("This algorithm expects a sorted array. Continue without sorting?")) return;
      }
    }

    runtime.state = algo.init(array, options);
    ui.btnStep.disabled = false;
    ui.btnAuto.disabled = false;
    ui.btnReset.disabled = false;
    appendLog(`Initialized: ${algo.name}`);
    clearHighlights();
    render();
  }

  function stepRun(){
    if(!runtime.state){
      alert("Initialize first.");
      return;
    }
    const algo = ALGORITHMS[runtime.algoId];
    const res = algo.step(runtime.state);
    applyHighlightsFromLastOp();
    render();
    if(res.status === "done"){
      stopAuto();
      const summary = algo.result(runtime.state);
      appendLog(summary);
      ui.btnStep.disabled = true;
      ui.btnAuto.disabled = true;
    }
  }

  function autoRun(){
    if(!runtime.state){
      alert("Initialize first.");
      return;
    }
    if(runtime.autoTimer){
      stopAuto();
      return;
    }
    ui.btnAuto.textContent = "Stop";
    ui.btnStep.disabled = true;
    runtime.autoTimer = setInterval(() => {
      const algo = ALGORITHMS[runtime.algoId];
      const res = algo.step(runtime.state);
      applyHighlightsFromLastOp();
      render();
      if(res.status === "done"){
        stopAuto();
        const summary = algo.result(runtime.state);
        appendLog(summary);
        ui.btnStep.disabled = true;
        ui.btnAuto.disabled = true;
      }
    }, runtime.speed);
  }

  function stopAuto(){
    if(runtime.autoTimer){
      clearInterval(runtime.autoTimer);
      runtime.autoTimer = null;
      ui.btnAuto.textContent = "Auto Play";
      ui.btnStep.disabled = false;
    }
  }

  function resetRun(){
    stopAuto();
    runtime.state = null;
    clearHighlights();
    ui.btnStep.disabled = true;
    ui.btnAuto.disabled = true;
    ui.btnReset.disabled = true;
    ui.log.innerHTML = "";
    render();
  }

  function updateAlgoUI(){
    const algoId = ui.algoSelect.value;
    const algo = ALGORITHMS[algoId];
    ui.algoHint.textContent = algo.invariant;

    ui.algoExtraRow.style.display = algo.inputs && algo.inputs.includes("target") ? "flex" : "none";
    ui.sortChk.checked = algo.requiresSorted;

    render();
  }

  function isSorted(arr){
    for(let i=1;i<arr.length;i++){
      if(arr[i] < arr[i-1]) return false;
    }
    return true;
  }

  // Events
  ui.algoSelect.addEventListener("change", updateAlgoUI);

  ui.btnRandom.addEventListener("click", () => {
    let len = Number(ui.randLen.value);
    let min = Number(ui.randMin.value);
    let max = Number(ui.randMax.value);
    if(!Number.isFinite(len) || len<2) len = 10;
    if(min > max){ const t=min; min=max; max=t; }
    const arr = randomArray(len, min, max);
    ui.arrayInput.value = arr.join(",");
    render();
  });

  ui.examples.forEach(el => {
    el.addEventListener("click", () => {
      const arr = el.getAttribute("data-arr");
      ui.arrayInput.value = arr;
      render();
    });
  });

  ui.btnInit.addEventListener("click", initRun);
  ui.btnStep.addEventListener("click", stepRun);
  ui.btnAuto.addEventListener("click", autoRun);
  ui.btnReset.addEventListener("click", resetRun);

  ui.speedRange.addEventListener("input", () => {
    runtime.speed = Number(ui.speedRange.value);
    ui.speedLabel.textContent = `${runtime.speed} ms`;
    if(runtime.autoTimer){
      stopAuto();
      autoRun();
    }
  });

  ui.arrayInput.addEventListener("input", () => { if(!runtime.state) render(); });
  ui.targetInput.addEventListener("input", () => { if(!runtime.state) render(); });
  ui.sortChk.addEventListener("change", () => { if(!runtime.state) render(); });

  // Initial render
  updateAlgoUI();
  render();

  // Prefill with a helpful example
  ui.arrayInput.value = "1,2,3,4,7,9,11";
  ui.targetInput.value = "13";
  ui.sortChk.checked = true;
  render();
</script>
</body>
</html>