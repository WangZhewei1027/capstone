<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Topological Sort Visualizer (Kahn's Algorithm)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --panel2: #0b1220;
    --text: #e5e7eb;
    --muted: #9ca3af;
    --accent: #34d399;
    --accent2: #60a5fa;
    --warn: #fbbf24;
    --danger: #f87171;
    --edge: #64748b;
    --edge-faded: #334155;
  }
  html, body {
    margin: 0;
    height: 100%;
    color: var(--text);
    background: linear-gradient(180deg, #0b1220 0%, #0f172a 100%);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }
  .container {
    display: grid;
    grid-template-columns: 340px 1fr;
    gap: 16px;
    height: 100%;
    padding: 16px;
    box-sizing: border-box;
  }
  .panel {
    background: radial-gradient(120% 140% at 0% 0%, var(--panel) 0%, var(--panel2) 70%);
    border: 1px solid #1f2937;
    border-radius: 12px;
    box-shadow: 0 4px 30px rgba(0,0,0,0.35);
  }
  .left {
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    min-height: 0;
  }
  .title {
    font-weight: 700;
    font-size: 18px;
    letter-spacing: 0.2px;
  }
  .subtitle {
    color: var(--muted);
    font-size: 12px;
    line-height: 1.4;
  }
  textarea {
    width: 100%;
    min-height: 140px;
    resize: vertical;
    border-radius: 10px;
    border: 1px solid #1f2937;
    background: #0b1220;
    color: var(--text);
    padding: 10px 12px;
    box-sizing: border-box;
    outline: none;
  }
  textarea::placeholder {
    color: #60708d;
  }
  .btn-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }
  button {
    background: #0b1220;
    border: 1px solid #1f2937;
    color: var(--text);
    border-radius: 10px;
    padding: 8px 12px;
    cursor: pointer;
    transition: all 0.15s ease;
    font-weight: 600;
  }
  button:hover {
    border-color: #334155;
    transform: translateY(-1px);
  }
  .btn-primary {
    background: linear-gradient(180deg, #0ea5e9 0%, #0284c7 100%);
    border: none;
    color: white;
  }
  .btn-accent {
    background: linear-gradient(180deg, #10b981 0%, #059669 100%);
    border: none;
    color: white;
  }
  .btn-danger {
    background: linear-gradient(180deg, #ef4444 0%, #dc2626 100%);
    border: none;
    color: white;
  }
  .controls {
    padding: 12px 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .chips {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }
  .chip {
    padding: 6px 10px;
    border-radius: 999px;
    font-weight: 700;
    font-size: 12px;
    border: 1px solid #1f2937;
    background: #0b1220;
    color: var(--text);
  }
  .chip.queue {
    background: rgba(16,185,129,0.12);
    border-color: rgba(16,185,129,0.35);
    color: #a7f3d0;
  }
  .chip.done {
    background: rgba(96,165,250,0.14);
    border-color: rgba(96,165,250,0.35);
    color: #bfdbfe;
  }
  .chip.warn {
    background: rgba(234,179,8,0.12);
    border-color: rgba(234,179,8,0.35);
    color: #fde68a;
  }
  .legend {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    color: var(--muted);
    font-size: 12px;
  }
  .legend .dot {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 6px;
    vertical-align: -1px;
  }
  .dot-ready { background: #10b981; }
  .dot-processed { background: #60a5fa; }
  .dot-pending { background: #64748b; }
  .dot-cyclic { background: #f87171; }
  .right {
    display: grid;
    grid-template-rows: auto 1fr auto;
    overflow: hidden;
  }
  .canvas-wrap {
    position: relative;
    padding: 12px;
    min-height: 380px;
  }
  svg {
    width: 100%;
    height: 100%;
    min-height: 420px;
    display: block;
    border-radius: 12px;
    background:
      radial-gradient(120% 120% at 0% 0%, rgba(45, 212, 191, 0.04) 0%, transparent 50%) no-repeat,
      radial-gradient(140% 140% at 100% 0%, rgba(99, 102, 241, 0.04) 0%, transparent 50%) no-repeat,
      radial-gradient(200% 200% at 50% 100%, rgba(14, 165, 233, 0.05) 0%, transparent 60%) no-repeat,
      #0b1220;
    border: 1px solid #1f2937;
  }
  .edge {
    stroke: var(--edge);
    stroke-width: 2;
    opacity: 0.95;
  }
  .edge.faded {
    stroke: var(--edge-faded);
    opacity: 0.4;
  }
  .edge.cyclic {
    stroke: var(--danger);
    opacity: 0.9;
  }
  .node {
    cursor: grab;
  }
  .node:active {
    cursor: grabbing;
  }
  .node circle {
    fill: #0b1220;
    stroke: #334155;
    stroke-width: 2px;
    transition: all 0.2s ease;
  }
  .node text {
    fill: #cbd5e1;
    font-weight: 800;
    pointer-events: none;
    text-shadow: 0 1px 0 rgba(0,0,0,0.3);
  }
  .node.pending circle {
    stroke: #334155;
  }
  .node.ready circle {
    stroke: #10b981;
    filter: drop-shadow(0 0 8px rgba(16,185,129,0.4));
  }
  .node.processed circle {
    stroke: #60a5fa;
    filter: drop-shadow(0 0 10px rgba(96,165,250,0.35));
  }
  .node.cyclic circle {
    stroke: #f87171;
    filter: drop-shadow(0 0 10px rgba(248,113,113,0.5));
  }
  .top-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px 4px 16px;
  }
  .top-bar .controls-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .slider {
    display: flex;
    align-items: center;
    gap: 8px;
    color: var(--muted);
    font-size: 12px;
  }
  input[type=range] {
    width: 160px;
  }
  .status {
    padding: 10px 16px 16px 16px;
    color: var(--muted);
    font-size: 13px;
  }
  .status strong {
    color: var(--text);
  }
  .footer {
    padding: 10px 16px 16px 16px;
    color: var(--muted);
    font-size: 12px;
    display: flex;
    justify-content: space-between;
  }
  .info {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
  }
  .info .panel {
    padding: 12px;
  }
  .mono {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
</style>
</head>
<body>
<div class="container">
  <div class="panel left">
    <div class="title">Topological Sort</div>
    <div class="subtitle">
      Visualize Kahn's algorithm for topological sorting on a directed graph (DAG).
      Enter edges below, one per line. Supported formats:
      A->B, A B, A,B, or a single node per line to include isolated nodes.
    </div>
    <textarea id="edgesInput" placeholder="Examples:
A->B
A->C
B->D
C->D

Or include isolated nodes:
X
Y

Also accepted: A B or A,B
"></textarea>
    <div class="btn-row">
      <button id="btnParse" class="btn-primary">Build Graph</button>
      <button id="btnRandom">Random DAG</button>
      <button id="btnSample1">Chain</button>
      <button id="btnSample2">Diamond</button>
      <button id="btnSample3">Course Prereqs</button>
      <button id="btnSample4" class="btn-danger">Cycle Example</button>
    </div>
    <div class="panel controls">
      <div class="legend">
        <span><span class="dot dot-ready"></span>Ready (indegree 0)</span>
        <span><span class="dot dot-processed"></span>Processed</span>
        <span><span class="dot dot-pending"></span>Pending</span>
        <span><span class="dot dot-cyclic"></span>Cyclic/Unresolved</span>
      </div>
      <div class="info">
        <div class="panel">
          <div style="font-weight:700;margin-bottom:6px;">Queue (Zero Indegree)</div>
          <div id="queueView" class="chips"></div>
        </div>
        <div class="panel">
          <div style="font-weight:700;margin-bottom:6px;">Topological Order</div>
          <div id="orderView" class="chips"></div>
        </div>
      </div>
    </div>
    <div class="subtitle mono" style="opacity:0.85">
      Tips:
      - Click Build Graph after editing edges.
      - Step to advance one node at a time.
      - Play to animate. Drag nodes to reposition them.
      - If a cycle exists, the algorithm will stop when the queue is empty.
    </div>
  </div>
  <div class="right panel">
    <div class="top-bar">
      <div class="controls-row">
        <button id="btnStep">Step</button>
        <button id="btnPlay" class="btn-accent">Play</button>
        <button id="btnReset">Reset</button>
      </div>
      <div class="controls-row">
        <div class="slider">
          Speed
          <input id="speed" type="range" min="100" max="1500" step="50" value="650" />
        </div>
      </div>
    </div>
    <div class="canvas-wrap">
      <svg id="svg" viewBox="0 0 1000 620" preserveAspectRatio="xMidYMid meet">
        <defs>
          <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5"
                  markerWidth="8" markerHeight="8" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#64748b"></path>
          </marker>
          <marker id="arrowFaded" viewBox="0 0 10 10" refX="10" refY="5"
                  markerWidth="8" markerHeight="8" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#334155"></path>
          </marker>
          <marker id="arrowDanger" viewBox="0 0 10 10" refX="10" refY="5"
                  markerWidth="8" markerHeight="8" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#f87171"></path>
          </marker>
        </defs>
        <g id="edgesLayer"></g>
        <g id="nodesLayer"></g>
      </svg>
    </div>
    <div class="status" id="status">
      Provide a directed acyclic graph (DAG) and press Build Graph. Then Step or Play to see Kahn's algorithm:
      - Start with all nodes of indegree 0 in the queue.
      - Repeatedly remove one, append to the order, and decrement indegrees of its neighbors.
      - If the queue becomes empty before all nodes are processed, a cycle exists.
    </div>
    <div class="footer">
      <div>
        Algorithm: Kahn's algorithm
      </div>
      <div>
        Drag nodes to rearrange. Edges fade when removed.
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const svg = document.getElementById('svg');
  const edgesLayer = document.getElementById('edgesLayer');
  const nodesLayer = document.getElementById('nodesLayer');

  const input = document.getElementById('edgesInput');
  const btnParse = document.getElementById('btnParse');
  const btnRandom = document.getElementById('btnRandom');
  const btnSample1 = document.getElementById('btnSample1');
  const btnSample2 = document.getElementById('btnSample2');
  const btnSample3 = document.getElementById('btnSample3');
  const btnSample4 = document.getElementById('btnSample4');
  const btnStep = document.getElementById('btnStep');
  const btnPlay = document.getElementById('btnPlay');
  const btnReset = document.getElementById('btnReset');
  const queueView = document.getElementById('queueView');
  const orderView = document.getElementById('orderView');
  const statusEl = document.getElementById('status');
  const speed = document.getElementById('speed');

  const NODE_RADIUS = 22;

  let graph = {
    nodes: [],           // array of node ids (labels)
    edges: [],           // array of {from, to}
    adj: new Map(),      // label -> array of neighbors
    indegree0: new Map(),// label -> indegree (initial)
    positions: new Map(),// label -> {x,y}
    edgeIds: new Set(),  // keep unique edges
  };

  let run = {
    indegree: new Map(), // current indegrees
    queue: [],           // nodes with zero indegree
    processed: new Set(),
    order: [],
    edgesRemoved: new Set(), // edge signature "from->to"
    playing: false,
    timer: null,
    cycleDetected: false
  };

  function resetRunState() {
    run.indegree = new Map(graph.indegree0);
    run.queue = zeroIndegreeList(run.indegree);
    run.processed = new Set();
    run.order = [];
    run.edgesRemoved = new Set();
    run.playing = false;
    run.cycleDetected = false;
    clearInterval(run.timer);
    run.timer = null;
    btnPlay.textContent = 'Play';
    updateUI();
    updateStyles();
  }

  function zeroIndegreeList(ind) {
    const arr = [];
    for (const [k, v] of ind.entries()) if (v === 0) arr.push(k);
    arr.sort(lexCmp);
    return arr;
  }

  function lexCmp(a, b) {
    const sA = a.toString(), sB = b.toString();
    return sA.localeCompare(sB, undefined, {numeric: true, sensitivity: 'base'});
  }

  function parseInput(text) {
    const nodes = new Set();
    const edgesSet = new Set();
    const edges = [];
    const lines = (text || '').split(/\r?\n/);

    function parseLine(line) {
      let l = line.trim();
      if (!l) return;
      // Accept comments after '#'
      const hash = l.indexOf('#');
      if (hash >= 0) l = l.substring(0, hash).trim();
      if (!l) return;
      let tokens = l.split(/->|=>|,|:|\s+/).filter(Boolean);
      if (tokens.length === 1) {
        nodes.add(tokens[0]);
        return;
      }
      if (tokens.length >= 2) {
        const from = tokens[0];
        const to = tokens[1];
        nodes.add(from);
        nodes.add(to);
        const sig = from + '->' + to;
        if (!edgesSet.has(sig)) {
          edgesSet.add(sig);
          edges.push({from, to});
        }
      }
    }

    for (const line of lines) parseLine(line);

    return {nodes: Array.from(nodes), edges};
  }

  function buildGraphFromInput() {
    const {nodes, edges} = parseInput(input.value);
    if (nodes.length === 0 && edges.length === 0) {
      setStatus('No nodes found. Enter edges or node names and press Build Graph.');
      return;
    }
    buildGraph(nodes, edges);
    resetRunState();
    layoutCircular();
    drawGraph();
    setStatus('Graph built. Nodes: ' + graph.nodes.length + ', Edges: ' + graph.edges.length + '. Press Step or Play.');
  }

  function buildGraph(nodesList, edgesList) {
    graph.nodes = [...nodesList].sort(lexCmp);
    graph.edges = [];
    graph.adj = new Map();
    graph.indegree0 = new Map();
    graph.positions = new Map();
    graph.edgeIds = new Set();

    for (const n of graph.nodes) {
      graph.adj.set(n, []);
      graph.indegree0.set(n, 0);
    }
    for (const e of edgesList) {
      const {from, to} = e;
      if (!graph.adj.has(from)) {
        graph.adj.set(from, []);
        graph.indegree0.set(from, 0);
        graph.nodes.push(from);
      }
      if (!graph.adj.has(to)) {
        graph.adj.set(to, []);
        graph.indegree0.set(to, 0);
        graph.nodes.push(to);
      }
      const sig = from + '->' + to;
      if (!graph.edgeIds.has(sig)) {
        graph.edges.push({from, to});
        graph.edgeIds.add(sig);
        graph.adj.get(from).push(to);
        graph.indegree0.set(to, graph.indegree0.get(to) + 1);
      }
    }
    graph.nodes.sort(lexCmp);
  }

  function layoutCircular() {
    // Arrange nodes on a circle; center & radius based on viewBox.
    // viewBox 0 0 1000 620
    const W = 1000, H = 620;
    const cx = W / 2, cy = H / 2;
    const n = graph.nodes.length;
    const R = Math.max(120, Math.min(cx, cy) - 60);
    for (let i = 0; i < n; i++) {
      const angle = 2 * Math.PI * (i / n) - Math.PI / 2;
      const x = cx + R * Math.cos(angle);
      const y = cy + R * Math.sin(angle);
      graph.positions.set(graph.nodes[i], {x, y});
    }
  }

  function drawGraph() {
    // Clear layers
    edgesLayer.innerHTML = '';
    nodesLayer.innerHTML = '';

    // Draw edges
    for (const e of graph.edges) {
      const id = edgeId(e.from, e.to);
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('id', id);
      line.classList.add('edge');
      line.setAttribute('marker-end', 'url(#arrow)');
      edgesLayer.appendChild(line);
    }

    // Draw nodes
    for (const node of graph.nodes) {
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('id', nodeId(node));
      g.classList.add('node', 'pending');
      g.dataset.label = node;

      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('r', NODE_RADIUS);
      circle.setAttribute('cx', 0);
      circle.setAttribute('cy', 0);

      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('x', 0);
      text.setAttribute('y', 5);
      text.setAttribute('text-anchor', 'middle');
      const label = node.toString();
      const fontSize = label.length > 8 ? 10 : (label.length > 5 ? 12 : 14);
      text.setAttribute('font-size', fontSize);
      text.textContent = label;

      // indegree badge
      const badge = document.createElementNS('http://www.w3.org/2000/svg','text');
      badge.setAttribute('x', NODE_RADIUS + 12);
      badge.setAttribute('y', -NODE_RADIUS + 4);
      badge.setAttribute('text-anchor', 'start');
      badge.setAttribute('font-size', 11);
      badge.setAttribute('fill', '#93c5fd');
      badge.setAttribute('class', 'indegree');
      badge.textContent = 'deg: 0';

      g.appendChild(circle);
      g.appendChild(text);
      g.appendChild(badge);

      nodesLayer.appendChild(g);

      // Set initial position
      const pos = graph.positions.get(node) || {x: 100, y: 100};
      g.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);

      enableDrag(g);
    }

    updateEdgesPositions();
    updateStyles();
    updateUI();
  }

  function updateEdgesPositions() {
    for (const e of graph.edges) {
      const line = document.getElementById(edgeId(e.from, e.to));
      if (!line) continue;
      const A = graph.positions.get(e.from);
      const B = graph.positions.get(e.to);
      if (!A || !B) continue;
      const pts = edgeEndpoints(A, B, NODE_RADIUS);
      line.setAttribute('x1', pts.x1);
      line.setAttribute('y1', pts.y1);
      line.setAttribute('x2', pts.x2);
      line.setAttribute('y2', pts.y2);
    }
  }

  function updateStyles() {
    // Node styles: ready, processed, pending, cyclic
    for (const n of graph.nodes) {
      const g = document.getElementById(nodeId(n));
      if (!g) continue;
      g.classList.remove('ready','processed','pending','cyclic');
      if (run.processed.has(n)) {
        g.classList.add('processed');
      } else if (run.cycleDetected && !run.processed.has(n)) {
        g.classList.add('cyclic');
      } else if (run.queue.includes(n)) {
        g.classList.add('ready');
      } else {
        g.classList.add('pending');
      }
      const badge = g.querySelector('.indegree');
      const deg = run.indegree.get(n) ?? 0;
      badge.textContent = 'deg: ' + deg;
    }
    // Edge styles: faded if removed; cyclic if cycle left
    for (const e of graph.edges) {
      const line = document.getElementById(edgeId(e.from, e.to));
      if (!line) continue;
      line.classList.remove('faded','cyclic');
      if (run.edgesRemoved.has(edgeSig(e.from, e.to))) {
        line.classList.add('faded');
        line.setAttribute('marker-end', 'url(#arrowFaded)');
      } else if (run.cycleDetected) {
        // If either endpoint is unresolved, mark potential cycle region red
        const unresolved = !(run.processed.has(e.from) && run.processed.has(e.to));
        if (unresolved) {
          line.classList.add('cyclic');
          line.setAttribute('marker-end', 'url(#arrowDanger)');
        } else {
          line.setAttribute('marker-end', 'url(#arrow)');
        }
      } else {
        line.setAttribute('marker-end', 'url(#arrow)');
      }
    }
  }

  function updateUI() {
    // Queue chips
    queueView.innerHTML = '';
    for (const q of run.queue) {
      const c = document.createElement('div');
      c.className = 'chip queue';
      c.textContent = q;
      queueView.appendChild(c);
    }
    // Order chips
    orderView.innerHTML = '';
    for (let i = 0; i < run.order.length; i++) {
      const c = document.createElement('div');
      c.className = 'chip done';
      c.textContent = (i+1) + '. ' + run.order[i];
      orderView.appendChild(c);
    }
    if (run.cycleDetected) {
      setStatus('Cycle detected. Queue is empty but ' + (graph.nodes.length - run.processed.size) + ' node(s) remain unresolved. No topological order exists for this graph.');
    } else if (run.order.length === graph.nodes.length && graph.nodes.length > 0) {
      setStatus('Topological sort complete. Order length: ' + run.order.length + '.');
    } else {
      setStatus('Processed: ' + run.order.length + ' / ' + graph.nodes.length + '. Queue size: ' + run.queue.length + '.');
    }
  }

  function setStatus(text) {
    statusEl.textContent = text;
  }

  function stepOnce() {
    if (run.cycleDetected || run.order.length === graph.nodes.length) {
      updateUI();
      updateStyles();
      return;
    }
    if (run.queue.length === 0) {
      run.cycleDetected = true;
      updateUI();
      updateStyles();
      return;
    }
    const u = run.queue.shift(); // choose a ready node
    if (!u) return;

    run.processed.add(u);
    run.order.push(u);

    // remove outgoing edges from u
    const nbrs = graph.adj.get(u) || [];
    for (const v of nbrs) {
      if (run.processed.has(v)) continue;
      const sig = edgeSig(u, v);
      run.edgesRemoved.add(sig);
      const cur = run.indegree.get(v) ?? 0;
      const next = Math.max(0, cur - 1);
      run.indegree.set(v, next);
      if (next === 0 && !run.queue.includes(v)) {
        run.queue.push(v);
      }
    }
    run.queue.sort(lexCmp);

    // Animate hint: briefly scale processed node
    pulseNode(u);

    updateUI();
    updateStyles();

    // If after step we have no queue and not done, it's a cycle
    if (run.queue.length === 0 && run.order.length < graph.nodes.length) {
      // But allow next tick to show final state
      // Mark cycle now
      run.cycleDetected = true;
      updateUI();
      updateStyles();
    }
  }

  function pulseNode(label) {
    const g = document.getElementById(nodeId(label));
    if (!g) return;
    g.style.transition = 'transform 0.18s ease';
    const pos = graph.positions.get(label);
    g.setAttribute('transform', `translate(${pos.x}, ${pos.y}) scale(1.08)`);
    setTimeout(() => {
      g.setAttribute('transform', `translate(${pos.x}, ${pos.y}) scale(1)`);
      setTimeout(() => {
        g.style.transition = '';
      }, 200);
    }, 160);
  }

  function playToggle() {
    if (run.playing) {
      pause();
      return;
    }
    run.playing = true;
    btnPlay.textContent = 'Pause';
    const tick = () => {
      if (run.cycleDetected || run.order.length === graph.nodes.length) {
        pause();
        return;
      }
      stepOnce();
    };
    // Start interval
    const ms = parseInt(speed.value, 10) || 650;
    run.timer = setInterval(tick, ms);
  }

  function pause() {
    run.playing = false;
    btnPlay.textContent = 'Play';
    clearInterval(run.timer);
    run.timer = null;
  }

  function edgeEndpoints(A, B, r) {
    const dx = B.x - A.x;
    const dy = B.y - A.y;
    const d = Math.hypot(dx, dy) || 1;
    const ux = dx / d;
    const uy = dy / d;
    const x1 = A.x + ux * r;
    const y1 = A.y + uy * r;
    const x2 = B.x - ux * (r + 4); // add a bit for arrowhead
    const y2 = B.y - uy * (r + 4);
    return {x1, y1, x2, y2};
  }

  function nodeId(label) {
    return 'node-' + label.replace(/[^a-zA-Z0-9_-]/g, '_');
  }
  function edgeId(from, to) {
    return 'edge-' + from.replace(/[^a-zA-Z0-9_-]/g, '_') + '--' + to.replace(/[^a-zA-Z0-9_-]/g, '_');
  }
  function edgeSig(from, to) {
    return from + '->' + to;
  }

  function enableDrag(g) {
    let dragging = false;
    let start = {x: 0, y: 0};
    let nodeLabel = g.dataset.label;

    const onMouseDown = (e) => {
      dragging = true;
      g.style.pointerEvents = 'all';
      const pt = clientToSVG(e.clientX, e.clientY);
      start.x = pt.x;
      start.y = pt.y;
      e.preventDefault();
    };
    const onMouseMove = (e) => {
      if (!dragging) return;
      const pt = clientToSVG(e.clientX, e.clientY);
      const dx = pt.x - start.x;
      const dy = pt.y - start.y;
      start.x = pt.x;
      start.y = pt.y;
      const pos = graph.positions.get(nodeLabel);
      const nx = pos.x + dx;
      const ny = pos.y + dy;
      graph.positions.set(nodeLabel, {x: nx, y: ny});
      g.setAttribute('transform', `translate(${nx}, ${ny})`);
      updateEdgesPositions();
    };
    const onMouseUp = () => {
      dragging = false;
    };

    g.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);

    // Touch
    g.addEventListener('touchstart', (e) => {
      dragging = true;
      const t = e.touches[0];
      const pt = clientToSVG(t.clientX, t.clientY);
      start.x = pt.x;
      start.y = pt.y;
      e.preventDefault();
    }, {passive: false});
    window.addEventListener('touchmove', (e) => {
      if (!dragging) return;
      const t = e.touches[0];
      const pt = clientToSVG(t.clientX, t.clientY);
      const dx = pt.x - start.x;
      const dy = pt.y - start.y;
      start.x = pt.x;
      start.y = pt.y;
      const pos = graph.positions.get(nodeLabel);
      const nx = pos.x + dx;
      const ny = pos.y + dy;
      graph.positions.set(nodeLabel, {x: nx, y: ny});
      g.setAttribute('transform', `translate(${nx}, ${ny})`);
      updateEdgesPositions();
      e.preventDefault();
    }, {passive: false});
    window.addEventListener('touchend', () => {
      dragging = false;
    });
  }

  function clientToSVG(clientX, clientY) {
    const pt = svg.createSVGPoint();
    pt.x = clientX;
    pt.y = clientY;
    const ctm = svg.getScreenCTM().inverse();
    return pt.matrixTransform(ctm);
  }

  // Samples
  function sampleChain() {
    input.value = `A->B
B->C
C->D`;
    buildGraphFromInput();
  }
  function sampleDiamond() {
    input.value = `A->B
A->C
B->D
C->D
D->E`;
    buildGraphFromInput();
  }
  function sampleCourses() {
    input.value = `Math->Physics
Math->CS
CS->AI
CS->Compilers
Physics->Robotics
AI->Robotics
Compilers->Robotics
Design
`;
    buildGraphFromInput();
  }
  function sampleCycle() {
    input.value = `A->B
B->C
C->A
C->D`;
    buildGraphFromInput();
  }
  function randomDAG() {
    const n = Math.floor(5 + Math.random()*5); // 5..9 nodes
    const labels = [];
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const used = new Set();
    while (labels.length < n) {
      const c = alphabet[ Math.floor(Math.random()*alphabet.length) ];
      if (!used.has(c)) { used.add(c); labels.push(c); }
    }
    // To ensure DAG, choose a random permutation and only create edges from lower index to higher index
    const perm = [...labels];
    perm.sort(() => Math.random()-0.5);
    const edges = [];
    const density = 0.3 + Math.random()*0.4; // 0.3..0.7
    for (let i = 0; i < perm.length; i++) {
      for (let j = i+1; j < perm.length; j++) {
        if (Math.random() < density) {
          edges.push(perm[i] + '->' + perm[j]);
        }
      }
    }
    if (edges.length === 0 && perm.length >= 2) {
      edges.push(perm[0] + '->' + perm[1]);
    }
    input.value = edges.join('\n');
    buildGraphFromInput();
  }

  // Events
  btnParse.addEventListener('click', buildGraphFromInput);
  btnRandom.addEventListener('click', randomDAG);
  btnSample1.addEventListener('click', sampleChain);
  btnSample2.addEventListener('click', sampleDiamond);
  btnSample3.addEventListener('click', sampleCourses);
  btnSample4.addEventListener('click', sampleCycle);

  btnStep.addEventListener('click', () => {
    if (run.playing) pause();
    stepOnce();
  });
  btnPlay.addEventListener('click', playToggle);
  btnReset.addEventListener('click', () => {
    if (graph.nodes.length === 0) {
      setStatus('Nothing to reset. Build a graph first.');
      return;
    }
    resetRunState();
    updateStyles();
  });
  speed.addEventListener('change', () => {
    if (run.playing) {
      pause();
      playToggle();
    }
  });

  // Initialize with a simple graph
  sampleDiamond();

})();
</script>
</body>
</html>