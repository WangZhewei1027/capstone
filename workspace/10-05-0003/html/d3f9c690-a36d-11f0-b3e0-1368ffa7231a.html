<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Prim’s Algorithm Visualizer (Minimum Spanning Tree)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --accent: #22c55e;
    --accent2: #60a5fa;
    --text: #e5e7eb;
    --muted: #94a3b8;
    --danger: #ef4444;
    --edge: #64748b;
    --visited: #124e17;
    --start: #f59e0b;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    background: radial-gradient(1200px 600px at 75% 0%, #0b1229 0%, var(--bg) 60%), var(--bg);
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", sans-serif;
  }
  header {
    padding: 18px 20px;
    display: flex;
    align-items: center;
    gap: 16px;
    border-bottom: 1px solid #1f2937;
    position: sticky;
    top: 0;
    background: rgba(15, 23, 42, 0.7);
    backdrop-filter: blur(6px);
    z-index: 10;
  }
  header h1 {
    font-size: 20px;
    margin: 0;
    letter-spacing: 0.2px;
  }
  header .sub {
    font-size: 14px;
    color: var(--muted);
  }
  .container {
    display: grid;
    grid-template-columns: 320px 1fr;
    gap: 12px;
    padding: 12px;
  }
  .panel {
    background: rgba(17, 24, 39, .8);
    border: 1px solid #1f2937;
    border-radius: 10px;
    padding: 14px;
  }
  .panel h2 {
    font-size: 16px;
    color: var(--muted);
    margin: 0 0 8px 0;
    font-weight: 600;
  }
  .controls .row {
    display: grid;
    grid-template-columns: 1fr 90px;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
  }
  .controls label {
    font-size: 13px;
    color: var(--muted);
  }
  input[type="number"], input[type="range"], select {
    width: 100%;
  }
  input[type="number"], select {
    background: #0b1228;
    border: 1px solid #1f2937;
    color: var(--text);
    padding: 6px 8px;
    border-radius: 8px;
  }
  input[type="range"] {
    accent-color: var(--accent2);
  }
  .buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
  }
  button {
    background: #0b1228;
    border: 1px solid #1f2937;
    color: var(--text);
    padding: 8px 10px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 13px;
  }
  button.primary {
    background: linear-gradient(180deg, #16a34a 0%, #22c55e 100%);
    border: none;
    color: #06290e;
    font-weight: 600;
  }
  button.warn {
    background: linear-gradient(180deg, #ef4444 0%, #b91c1c 100%);
    border: none;
    color: #fff;
    font-weight: 600;
  }
  button:disabled { opacity: 0.5; cursor: not-allowed; }
  .legend {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
    margin-top: 10px;
    font-size: 12px;
    color: var(--muted);
  }
  .chip { display: inline-flex; align-items: center; gap: 6px; padding: 6px 8px; border-radius: 999px; border: 1px dashed #334155; background: #0b1228; }
  .swatch { width: 14px; height: 14px; border-radius: 50%; }
  .sw-edge { width: 18px; height: 3px; border-radius: 2px; }
  .sw-mst { background: var(--accent); }
  .sw-frontier { background: var(--accent2); }
  .sw-last { background: var(--danger); }
  .sw-default { background: var(--edge); }
  .sw-visited { background: var(--visited); }
  .sw-start { background: var(--start); }
  .canvas-wrap {
    position: relative;
    height: calc(100vh - 170px);
    min-height: 420px;
  }
  canvas {
    width: 100%;
    height: 100%;
    display: block;
    border-radius: 10px;
    background:
      radial-gradient(900px 500px at 20% 0%, rgba(96, 165, 250, 0.09) 0%, rgba(0,0,0,0) 60%),
      radial-gradient(900px 500px at 80% 100%, rgba(34, 197, 94, 0.09) 0%, rgba(0,0,0,0) 60%),
      #0b1228;
    border: 1px solid #1f2937;
  }
  .stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-top: 10px;
    font-size: 13px;
  }
  .stats .item {
    background: #0b1228;
    border: 1px solid #1f2937;
    border-radius: 8px;
    padding: 8px;
  }
  .stats .label { color: var(--muted); }
  .stats .value { font-weight: 600; }
  .pseudo {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 12px;
    background: #0b1228;
    border: 1px solid #1f2937;
    border-radius: 8px;
    padding: 8px;
    color: #cbd5e1;
    line-height: 1.4;
    white-space: pre-wrap;
  }
  .notice {
    font-size: 12px;
    color: var(--muted);
    margin-top: 8px;
  }
  a {
    color: #a5b4fc;
    text-decoration: none;
  }
  a:hover { text-decoration: underline; }
  .kbd {
    padding: 2px 6px; background: #0b1228; border: 1px solid #1f2937; border-radius: 6px; font-size: 12px;
  }
  @media (max-width: 980px) {
    .container {
      grid-template-columns: 1fr;
    }
    header { position: static; }
    .canvas-wrap { height: 60vh; }
  }
</style>
</head>
<body>
<header>
  <h1>Prim’s Algorithm</h1>
  <div class="sub">Interactive Minimum Spanning Tree builder for an undirected weighted graph</div>
</header>

<div class="container">
  <div class="panel controls">
    <h2>Graph Controls</h2>

    <div class="row">
      <label>Nodes</label>
      <input id="nodesCount" type="number" min="3" max="60" step="1" value="12" />
    </div>
    <div class="row">
      <label>Extra edge probability</label>
      <input id="edgeProb" type="range" min="0" max="1" step="0.02" value="0.28" />
    </div>
    <div class="row">
      <label>Weights</label>
      <select id="weightMode">
        <option value="random">Random 1..20</option>
        <option value="distance">Euclidean distance</option>
      </select>
    </div>
    <div class="row">
      <label>Auto-run speed (steps/sec)</label>
      <input id="speed" type="range" min="0.5" max="10" step="0.5" value="2.5" />
    </div>

    <div class="buttons">
      <button id="genBtn">Generate Graph</button>
      <button id="resetBtn">Reset Algorithm</button>
      <button id="stepBtn">Step</button>
      <button id="startBtn" class="primary">Start Auto</button>
      <button id="pauseBtn">Pause</button>
      <button id="runAllBtn">Run to End</button>
    </div>

    <div class="legend">
      <div class="chip"><div class="sw-edge sw-default"></div> Edge</div>
      <div class="chip"><div class="sw-edge sw-mst"></div> In MST</div>
      <div class="chip"><div class="sw-edge sw-frontier"></div> Frontier</div>
      <div class="chip"><div class="sw-edge sw-last"></div> Chosen edge</div>
      <div class="chip"><div class="swatch sw-visited"></div> Visited node</div>
      <div class="chip"><div class="swatch sw-start"></div> Start node</div>
    </div>

    <div class="stats">
      <div class="item">
        <div class="label">Status</div>
        <div class="value" id="status">Ready</div>
      </div>
      <div class="item">
        <div class="label">MST total weight</div>
        <div class="value" id="mstWeight">0</div>
      </div>
      <div class="item">
        <div class="label">Visited nodes</div>
        <div class="value" id="visitedCount">0</div>
      </div>
      <div class="item">
        <div class="label">Frontier edges</div>
        <div class="value" id="frontierCount">0</div>
      </div>
    </div>

    <h2 style="margin-top:14px;">How it works</h2>
    <div class="pseudo">
Start with any node (click a node to choose the start).
Visited = {start}
Frontier = edges that connect Visited to Unvisited

Repeat until all nodes are visited:
  - Pick the minimum-weight edge from Frontier
    that connects to an Unvisited node
  - Add that edge to MST
  - Add the new node to Visited
  - Update Frontier

Result: MST contains N-1 edges with minimum total weight
for the connected graph.
    </div>
    <div class="notice">
      Tip: Click a node to set the start. Use Step to see choices, or Start Auto to watch it run. Press Pause anytime.
      Keyboard: <span class="kbd">Space</span> = Step, <span class="kbd">Enter</span> = Start/Pause.
    </div>
  </div>

  <div class="panel">
    <h2>Graph (click a node to choose start)</h2>
    <div class="canvas-wrap">
      <canvas id="canvas"></canvas>
    </div>
  </div>
</div>

<script>
(function() {
  // Canvas setup
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawing to CSS pixels
    draw();
  }
  window.addEventListener('resize', () => {
    resizeCanvas();
  });

  // UI elements
  const nodesCountEl = document.getElementById('nodesCount');
  const edgeProbEl = document.getElementById('edgeProb');
  const weightModeEl = document.getElementById('weightMode');
  const speedEl = document.getElementById('speed');

  const genBtn = document.getElementById('genBtn');
  const resetBtn = document.getElementById('resetBtn');
  const stepBtn = document.getElementById('stepBtn');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const runAllBtn = document.getElementById('runAllBtn');

  const statusEl = document.getElementById('status');
  const mstWeightEl = document.getElementById('mstWeight');
  const visitedCountEl = document.getElementById('visitedCount');
  const frontierCountEl = document.getElementById('frontierCount');

  // Graph + algorithm state
  let nodes = [];          // {id, x, y}
  let edges = [];          // {u, v, w, key}
  let adj = new Map();     // id -> [{to, w}]
  let edgeByKey = new Map();

  let startNode = 0;
  let visited = new Set();
  let mstEdges = [];       // array of edges
  let frontierKeys = new Set();
  let lastChosenKey = null;
  let stepCount = 0;
  let running = false;
  let rafTimer = null;     // for auto-run via rAF
  let nextStepTime = 0;

  // Utility
  function keyFor(u, v) {
    return u < v ? `${u}-${v}` : `${v}-${u}`;
  }
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  function clamp(x, a, b) {
    return Math.max(a, Math.min(b, x));
  }

  function updateStats() {
    mstWeightEl.textContent = mstEdges.reduce((s,e)=>s+e.w,0);
    visitedCountEl.textContent = visited.size + ' / ' + nodes.length;
    frontierCountEl.textContent = frontierKeys.size;
    const done = visited.size === nodes.length;
    statusEl.textContent = done ? 'Done (MST complete)' : (running ? 'Auto-running...' : 'Ready');
  }

  // Graph generation: produce a connected undirected weighted graph
  function generateGraph(n, prob, mode) {
    // Layout: random positions with padding
    nodes = [];
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;
    const pad = 30;
    for (let i = 0; i < n; i++) {
      const x = randInt(pad, W - pad);
      const y = randInt(pad, H - pad);
      nodes.push({ id: i, x, y });
    }

    edges = [];
    edgeByKey.clear();
    adj = new Map();
    nodes.forEach(node => adj.set(node.id, []));

    // Ensure connectivity by building a random spanning tree first
    for (let i = 1; i < n; i++) {
      const j = randInt(0, i - 1);
      addEdge(i, j, mode);
    }
    // Add extra random edges with probability
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        const k = keyFor(i, j);
        if (!edgeByKey.has(k) && Math.random() < prob) {
          addEdge(i, j, mode);
        }
      }
    }

    // Choose default start
    startNode = 0;
    resetAlgorithm(false);
  }

  function addEdge(u, v, mode) {
    const k = keyFor(u, v);
    if (edgeByKey.has(k)) return;
    const a = nodes[u], b = nodes[v];
    const dist = Math.hypot(a.x - b.x, a.y - b.y);
    let w;
    if (mode === 'distance') {
      // Scale distance to a reasonable integer weight
      const scale = Math.max(canvas.getBoundingClientRect().width, canvas.getBoundingClientRect().height);
      const factor = scale / 20; // tune for typical weights ~ 1..40
      w = Math.max(1, Math.round(dist / (factor / 10)));
    } else {
      w = randInt(1, 20);
    }
    const e = { u, v, w, key: k };
    edges.push(e);
    edgeByKey.set(k, e);
    adj.get(u).push({ to: v, w });
    adj.get(v).push({ to: u, w });
  }

  // Prim's algorithm helpers
  function recomputeFrontier() {
    frontierKeys.clear();
    for (const e of edges) {
      const vu = visited.has(e.u);
      const vv = visited.has(e.v);
      if (vu ^ vv) {
        frontierKeys.add(e.key);
      }
    }
  }

  function stepPrim() {
    // If complete or invalid, stop
    if (!nodes.length || !edges.length) return false;
    if (visited.size === nodes.length) return false;

    // Initialize: add start to visited
    if (visited.size === 0) {
      visited.add(startNode);
      recomputeFrontier();
    }

    // Pick minimum crossing edge
    let minEdge = null;
    for (const key of frontierKeys) {
      const e = edgeByKey.get(key);
      if (!e) continue;
      const vu = visited.has(e.u);
      const vv = visited.has(e.v);
      if (vu ^ vv) {
        if (!minEdge || e.w < minEdge.w) {
          minEdge = e;
        }
      }
    }
    if (!minEdge) {
      // Graph might be disconnected (shouldn't with our generator), or we are done
      return false;
    }

    // Add the chosen edge to MST and its new vertex to visited
    mstEdges.push(minEdge);
    lastChosenKey = minEdge.key;
    const newVertex = visited.has(minEdge.u) ? minEdge.v : minEdge.u;
    visited.add(newVertex);

    // Update frontier
    recomputeFrontier();

    stepCount++;
    updateStats();
    draw();
    return true;
  }

  function resetAlgorithm(clearMST = true) {
    visited = new Set();
    frontierKeys = new Set();
    lastChosenKey = null;
    stepCount = 0;
    if (clearMST) mstEdges = [];
    stopAutoRun();
    updateStats();
    draw();
  }

  // Auto-run loop using requestAnimationFrame for smooth timing
  function startAutoRun() {
    if (running) return;
    running = true;
    statusEl.textContent = 'Auto-running...';
    const stepsPerSec = parseFloat(speedEl.value);
    const intervalMs = 1000 / clamp(stepsPerSec, 0.5, 10);
    let lastTS = performance.now();
    nextStepTime = lastTS + intervalMs;

    function tick(ts) {
      if (!running) return;
      if (ts >= nextStepTime) {
        const didStep = stepPrim();
        nextStepTime += intervalMs;
        if (!didStep) {
          stopAutoRun();
          statusEl.textContent = 'Done (MST complete)';
          return;
        }
      }
      rafTimer = requestAnimationFrame(tick);
    }
    rafTimer = requestAnimationFrame(tick);
  }

  function stopAutoRun() {
    running = false;
    if (rafTimer) cancelAnimationFrame(rafTimer);
    rafTimer = null;
    updateStats();
  }

  // Drawing
  function draw() {
    if (!ctx) return;
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0, 0, rect.width, rect.height);

    // Draw edges
    ctx.lineCap = 'round';
    for (const e of edges) {
      const a = nodes[e.u], b = nodes[e.v];
      let color = '#64748b';
      let width = 2;
      let dash = [];

      const inMST = mstEdges.find(me => me.key === e.key);
      const inFrontier = frontierKeys.has(e.key);
      const isLast = (lastChosenKey === e.key);

      if (inMST) { color = '#22c55e'; width = 3.2; }
      if (inFrontier) { color = '#60a5fa'; dash = [8, 6]; width = Math.max(width, 2.4); }
      if (isLast) { color = '#ef4444'; width = 4; dash = []; }

      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.setLineDash(dash);
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
      ctx.setLineDash([]);

      // Weight label near midpoint
      const mx = (a.x + b.x) / 2;
      const my = (a.y + b.y) / 2;
      const label = String(e.w);
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial';
      const tw = ctx.measureText(label).width;
      const pad = 3;
      // draw background rounded rect
      const bgx = mx - tw/2 - pad, bgy = my - 9, bgw = tw + pad*2, bgh = 16;
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      roundRect(ctx, bgx, bgy, bgw, bgh, 5);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.lineWidth = 1;
      ctx.stroke();
      // text
      ctx.fillStyle = '#e5e7eb';
      ctx.fillText(label, mx - tw/2, my + 4);
    }

    // Draw nodes
    for (const n of nodes) {
      const r = 13;
      const isVisited = visited.has(n.id);
      const isStart = (n.id === startNode);

      // Node fill
      ctx.beginPath();
      ctx.arc(n.x, n.y, r, 0, Math.PI*2);
      ctx.fillStyle = isVisited ? '#124e17' : '#0b1228';
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#1f2937';
      ctx.stroke();

      // Start ring
      if (isStart) {
        ctx.beginPath();
        ctx.arc(n.x, n.y, r+4, 0, Math.PI*2);
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Node label
      const label = String(n.id);
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial';
      const tw = ctx.measureText(label).width;
      ctx.fillStyle = '#e5e7eb';
      ctx.fillText(label, n.x - tw/2, n.y + 4);
    }
  }

  function roundRect(ctx, x, y, w, h, r) {
    const radius = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
  }

  // Canvas interactions: select start node by click
  canvas.addEventListener('click', (ev) => {
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    let clicked = null;
    for (const n of nodes) {
      const d = Math.hypot(n.x - x, n.y - y);
      if (d <= 14) { clicked = n.id; break; }
    }
    if (clicked != null) {
      if (running) return; // ignore during auto run
      startNode = clicked;
      resetAlgorithm(true);
      draw();
    }
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', (ev) => {
    if (ev.key === ' ') {
      ev.preventDefault();
      if (!running) stepPrim();
    } else if (ev.key === 'Enter') {
      ev.preventDefault();
      if (running) {
        stopAutoRun();
      } else {
        startAutoRun();
      }
    }
  });

  // Controls events
  genBtn.addEventListener('click', () => {
    const n = clamp(parseInt(nodesCountEl.value || '12', 10), 3, 60);
    const p = clamp(parseFloat(edgeProbEl.value || '0.28'), 0, 1);
    const mode = weightModeEl.value;
    generateGraph(n, p, mode);
  });
  resetBtn.addEventListener('click', () => resetAlgorithm(true));
  stepBtn.addEventListener('click', () => {
    if (!running) stepPrim();
  });
  startBtn.addEventListener('click', () => startAutoRun());
  pauseBtn.addEventListener('click', () => stopAutoRun());
  runAllBtn.addEventListener('click', () => {
    stopAutoRun();
    let guard = 0;
    while (visited.size < nodes.length) {
      if (!stepPrim()) break;
      if (++guard > 10000) break; // safety
    }
  });

  speedEl.addEventListener('input', () => {
    // If running, restart with new speed
    if (running) {
      stopAutoRun();
      startAutoRun();
    }
  });

  // Initial graph
  resizeCanvas();
  generateGraph(parseInt(nodesCountEl.value,10), parseFloat(edgeProbEl.value), weightModeEl.value);
})();
</script>
</body>
</html>