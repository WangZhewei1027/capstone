<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Union-Find (Disjoint Set) Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0e1116;
      --panel: #161b22;
      --accent: #3ea6ff;
      --accent2: #7ce38b;
      --text: #e6edf3;
      --muted: #a6b3c3;
      --danger: #ff6b6b;
      --warn: #ffcc66;
      --line: #8091a3;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
    }
    .app {
      display: grid;
      grid-template-rows: auto 1fr auto;
      height: 100%;
    }
    header {
      padding: 12px 16px;
      background: var(--panel);
      border-bottom: 1px solid #222a34;
    }
    header h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 0.3px;
    }
    header p {
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 13px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 12px 16px;
      background: #12161c;
      border-bottom: 1px solid #222a34;
      align-items: center;
    }
    .controls .group {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      background: #0f1318;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #1e2631;
    }
    label {
      font-size: 12px;
      color: var(--muted);
    }
    input[type="number"], input[type="text"], select {
      background: #0b0f14;
      border: 1px solid #1e2631;
      color: var(--text);
      padding: 6px 8px;
      border-radius: 6px;
      outline: none;
      font-size: 13px;
      width: 80px;
    }
    input[type="checkbox"] {
      accent-color: var(--accent);
      transform: translateY(1px);
    }
    button {
      background: #182131;
      border: 1px solid #28405e;
      color: var(--text);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
    }
    button:hover { filter: brightness(1.1); }
    button.primary {
      background: #18364b;
      border-color: #3ea6ff;
      color: #cbe7ff;
    }
    button.danger {
      background: #2e1414;
      border-color: #803737;
      color: #ffb3b3;
    }
    button.secondary {
      background: #1e2a21;
      border-color: #355c3b;
      color: #cfeedd;
    }
    .legend {
      margin-left: auto;
      font-size: 12px;
      color: var(--muted);
    }

    .stage {
      position: relative;
      overflow: hidden;
      background: #0b0f14;
    }
    .svg-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .node-layer {
      position: absolute;
      inset: 0;
    }
    .node {
      position: absolute;
      width: 44px;
      height: 44px;
      border-radius: 999px;
      border: 2px solid #334153;
      background: #0f141a;
      color: var(--text);
      display: grid;
      place-items: center;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: box-shadow 120ms ease, border-color 120ms ease, transform 120ms ease, background 120ms ease;
      user-select: none;
    }
    .node:hover {
      box-shadow: 0 0 0 2px rgba(62, 166, 255, 0.25);
      transform: translateY(-1px);
    }
    .node.root {
      border-color: var(--accent2);
      box-shadow: 0 0 0 2px rgba(124, 227, 139, 0.2);
    }
    .node.selected {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(62, 166, 255, 0.35);
    }
    .node .sub {
      position: absolute;
      bottom: -18px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      color: var(--muted);
      white-space: nowrap;
    }
    .node .badge {
      position: absolute;
      top: -10px;
      right: -10px;
      background: #15202b;
      border: 1px solid #243648;
      color: #c3d6e7;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 10px;
      letter-spacing: 0.2px;
    }
    .line {
      stroke: var(--line);
      stroke-width: 2;
      opacity: 0.9;
    }
    .line.highlight {
      stroke: var(--accent);
      stroke-width: 4;
      opacity: 1;
      filter: drop-shadow(0 0 3px rgba(62, 166, 255, 0.5));
    }
    .note {
      font-size: 12px;
      color: var(--muted);
      padding: 8px 16px;
      border-top: 1px solid #222a34;
      background: #11161c;
    }
    .log {
      padding: 12px 16px;
      border-top: 1px solid #222a34;
      background: #0f1319;
      max-height: 140px;
      overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      line-height: 1.5;
    }
    .log div {
      color: #cbd5e1;
    }
    .log .ok { color: #a7f3d0; }
    .log .warn { color: #fde68a; }
    .log .err { color: #fecaca; }
    .footer {
      font-size: 12px;
      color: var(--muted);
      padding: 10px 16px;
      background: var(--panel);
      border-top: 1px solid #222a34;
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
    }
    .mode-toggle {
      display: inline-flex;
      border: 1px solid #28405e;
      border-radius: 8px;
      overflow: hidden;
    }
    .mode-toggle button {
      border: none;
      background: #142033;
      padding: 6px 10px;
    }
    .mode-toggle button.active {
      background: #1b2a42;
      color: #cbe7ff;
      outline: 1px solid #3ea6ff;
    }
    .color-dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 6px;
      border: 1px solid #243648;
      vertical-align: -1px;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Union-Find (Disjoint Set) Visualizer</h1>
      <p>Interactively explore union by size and path compression. Click nodes to select, run Union/Find/Connected, and watch parent pointers update.</p>
    </header>

    <div class="controls">
      <div class="group">
        <label for="nodeCount">Nodes</label>
        <input id="nodeCount" type="number" min="2" max="200" value="12" />
        <button id="resetBtn" class="primary">Reset</button>
        <button id="shuffleBtn">Shuffle Layout</button>
        <label>
          <input id="compressionToggle" type="checkbox" checked />
          Path Compression
        </label>
      </div>

      <div class="group">
        <div class="mode-toggle" role="tablist" aria-label="Operation mode">
          <button id="modeUnion" class="active" aria-selected="true">Union</button>
          <button id="modeFind">Find</button>
          <button id="modeConnected">Connected</button>
        </div>
        <span id="modeHint" class="legend">Select 2 nodes for Union</span>
      </div>

      <div class="group">
        <label>Manual</label>
        <input id="inputA" type="number" placeholder="a" min="0" />
        <input id="inputB" type="number" placeholder="b" min="0" />
        <button id="btnUnion">Union(a,b)</button>
        <button id="btnFind">Find(a)</button>
        <button id="btnConnected">Connected(a,b)</button>
      </div>

      <div class="group">
        <button id="btnRandomUnion" class="secondary">Random Union</button>
        <button id="btnRandomOps">Random Ops</button>
        <button id="btnClearLog">Clear Log</button>
      </div>

      <div class="legend">
        Roots are highlighted. Color indicates set (by root). Indexing is 0-based.
      </div>
    </div>

    <div class="stage" id="stage">
      <svg class="svg-layer" id="svg" xmlns="http://www.w3.org/2000/svg"></svg>
      <div class="node-layer" id="nodes"></div>
    </div>

    <div class="note">
      Tips:
      - Union by size attaches the smaller tree to the larger one, keeping the forest shallow.
      - Path compression flattens the tree during find operations by making nodes point directly to the root.
      - Click nodes to select; in Union mode, selecting any 2 runs a union. In Find mode, selecting 1 runs a find with compression visualization.
    </div>

    <div class="log" id="log" aria-live="polite"></div>

    <div class="footer">
      Visualization shows parent pointers as lines to their parent. Roots have no outgoing line. Colors are assigned per root. Resize the window to re-layout.
      <span style="margin-left:auto">Built-in: Union by size + optional path compression</span>
    </div>
  </div>

  <script>
    // Disjoint Set Union (Union-Find) with union by size and optional path compression
    class DisjointSet {
      constructor(n = 0, compress = true) {
        this.compressEnabled = compress;
        this.make(n);
      }
      make(n) {
        this.n = n;
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.size = Array.from({ length: n }, () => 1);
      }
      // Standard find with optional path compression
      find(x) {
        let root = x;
        // Find root
        while (this.parent[root] !== root) root = this.parent[root];
        if (!this.compressEnabled) return root;
        // Path compression
        while (x !== root) {
          const p = this.parent[x];
          this.parent[x] = root;
          x = p;
        }
        return root;
      }
      // Find without modifying structure, returning path for visualization
      probeFind(x) {
        const path = [];
        let cur = x;
        path.push(cur);
        while (this.parent[cur] !== cur) {
          cur = this.parent[cur];
          path.push(cur);
        }
        return { root: cur, path };
      }
      compressPath(path, root) {
        // Make every node in path point directly to root
        for (const node of path) {
          this.parent[node] = root;
        }
      }
      union(a, b) {
        if (!this.valid(a) || !this.valid(b)) return { merged: false, reason: 'invalid' };
        let ra = this.find(a);
        let rb = this.find(b);
        if (ra === rb) return { merged: false, reason: 'same', root: ra };
        // attach smaller to larger
        if (this.size[ra] < this.size[rb]) {
          const tmp = ra; ra = rb; rb = tmp;
        }
        this.parent[rb] = ra;
        this.size[ra] += this.size[rb];
        return { merged: true, aRoot: ra, bRoot: rb, newRoot: ra, sizes: { [ra]: this.size[ra] } };
      }
      connected(a, b) {
        if (!this.valid(a) || !this.valid(b)) return { connected: false, reason: 'invalid' };
        const ra = this.find(a), rb = this.find(b);
        return { connected: ra === rb, ra, rb };
      }
      valid(x) { return Number.isInteger(x) && x >= 0 && x < this.n; }
      // non-destructive root for rendering color
      rootOfNoCompress(x) {
        while (this.parent[x] !== x) x = this.parent[x];
        return x;
      }
    }

    // UI / Visualization
    const stage = document.getElementById('stage');
    const svg = document.getElementById('svg');
    const nodesLayer = document.getElementById('nodes');
    const logEl = document.getElementById('log');
    const nodeCountInput = document.getElementById('nodeCount');
    const resetBtn = document.getElementById('resetBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const compressionToggle = document.getElementById('compressionToggle');
    const inputA = document.getElementById('inputA');
    const inputB = document.getElementById('inputB');
    const btnUnion = document.getElementById('btnUnion');
    const btnFind = document.getElementById('btnFind');
    const btnConnected = document.getElementById('btnConnected');
    const btnRandomUnion = document.getElementById('btnRandomUnion');
    const btnRandomOps = document.getElementById('btnRandomOps');
    const btnClearLog = document.getElementById('btnClearLog');
    const modeUnionBtn = document.getElementById('modeUnion');
    const modeFindBtn = document.getElementById('modeFind');
    const modeConnectedBtn = document.getElementById('modeConnected');
    const modeHint = document.getElementById('modeHint');

    let dsu = new DisjointSet(12, true);
    let nodePositions = [];
    let nodeEls = [];
    let selected = new Set();
    let opMode = 'Union'; // 'Union' | 'Find' | 'Connected'
    let colorByRoot = new Map();

    function setMode(mode) {
      opMode = mode;
      modeUnionBtn.classList.toggle('active', mode === 'Union');
      modeFindBtn.classList.toggle('active', mode === 'Find');
      modeConnectedBtn.classList.toggle('active', mode === 'Connected');
      modeHint.textContent =
        mode === 'Union' ? 'Select 2 nodes for Union' :
        mode === 'Find' ? 'Select 1 node for Find (visualized)' :
        'Select 2 nodes for Connected';
      clearSelection();
    }

    modeUnionBtn.addEventListener('click', () => setMode('Union'));
    modeFindBtn.addEventListener('click', () => setMode('Find'));
    modeConnectedBtn.addEventListener('click', () => setMode('Connected'));

    function log(msg, type = '') {
      const div = document.createElement('div');
      if (type) div.className = type;
      div.textContent = msg;
      logEl.appendChild(div);
      logEl.scrollTop = logEl.scrollHeight;
    }
    function clearLog() { logEl.textContent = ''; }

    function init(n) {
      dsu.make(n);
      dsu.compressEnabled = compressionToggle.checked;
      nodesLayer.innerHTML = '';
      svg.innerHTML = '';
      nodeEls = [];
      nodePositions = layoutCircle(n);
      for (let i = 0; i < n; i++) {
        const el = document.createElement('div');
        el.className = 'node';
        el.dataset.index = i;
        el.style.left = (nodePositions[i].x - 22) + 'px';
        el.style.top = (nodePositions[i].y - 22) + 'px';
        el.textContent = String(i);
        const sub = document.createElement('div');
        sub.className = 'sub';
        sub.textContent = '';
        el.appendChild(sub);
        const badge = document.createElement('div');
        badge.className = 'badge';
        badge.textContent = '';
        el.appendChild(badge);
        el.addEventListener('click', onNodeClick);
        nodesLayer.appendChild(el);
        nodeEls.push(el);
      }
      selected.clear();
      render();
      clearLog();
      log(`Initialized ${n} nodes. All sets are singletons.`);
    }

    function layoutCircle(n) {
      const rect = stage.getBoundingClientRect();
      const cx = rect.width / 2;
      const cy = rect.height / 2;
      const R = Math.max(80, Math.min(cx, cy) - 40);
      const pos = [];
      for (let i = 0; i < n; i++) {
        const t = (i / n) * Math.PI * 2;
        pos.push({ x: cx + R * Math.cos(t), y: cy + R * Math.sin(t) });
      }
      return pos;
    }

    function shuffleLayout() {
      // small random jitter
      const rect = stage.getBoundingClientRect();
      for (let i = 0; i < nodePositions.length; i++) {
        const jitter = 40;
        const x = Math.min(rect.width - 22, Math.max(22, nodePositions[i].x + (Math.random() * jitter - jitter/2)));
        const y = Math.min(rect.height - 22, Math.max(22, nodePositions[i].y + (Math.random() * jitter - jitter/2)));
        nodePositions[i] = { x, y };
        nodeEls[i].style.left = (x - 22) + 'px';
        nodeEls[i].style.top = (y - 22) + 'px';
      }
      renderLines();
    }

    function onNodeClick(e) {
      const i = Number(e.currentTarget.dataset.index);
      if (selected.has(i)) {
        selected.delete(i);
      } else {
        selected.add(i);
      }
      updateSelectionStyles();
      // Auto-run based on mode
      if (opMode === 'Union' && selected.size >= 2) {
        const [a, b] = Array.from(selected).slice(0, 2);
        runUnion(a, b);
        clearSelection();
      } else if (opMode === 'Find' && selected.size >= 1) {
        const [a] = Array.from(selected);
        runFindVisual(a);
        clearSelection();
      } else if (opMode === 'Connected' && selected.size >= 2) {
        const [a, b] = Array.from(selected).slice(0, 2);
        runConnected(a, b);
        clearSelection();
      }
    }

    function updateSelectionStyles() {
      for (let i = 0; i < nodeEls.length; i++) {
        nodeEls[i].classList.toggle('selected', selected.has(i));
      }
    }
    function clearSelection() {
      selected.clear();
      updateSelectionStyles();
    }

    function computeColors() {
      colorByRoot.clear();
      const roots = [];
      for (let i = 0; i < dsu.n; i++) {
        if (dsu.parent[i] === i) roots.push(i);
      }
      roots.sort((a, b) => a - b);
      const m = roots.length;
      for (let idx = 0; idx < m; idx++) {
        const r = roots[idx];
        const hue = Math.round((360 * idx) / Math.max(1, m));
        colorByRoot.set(r, `hsl(${hue}, 60%, 55%)`);
      }
    }

    function render() {
      // Avoid find() during render; use parent[] directly
      computeColors();
      // Update nodes
      for (let i = 0; i < dsu.n; i++) {
        const el = nodeEls[i];
        const isRoot = dsu.parent[i] === i;
        el.classList.toggle('root', isRoot);
        const root = dsu.rootOfNoCompress(i);
        const color = colorByRoot.get(root) || '#6b7280';
        el.style.background = 'linear-gradient(180deg, #0e141b 0%, #0b1016 100%)';
        el.style.borderColor = isRoot ? 'var(--accent2)' : '#334153';
        el.style.boxShadow = isRoot ? '0 0 0 2px rgba(124, 227, 139, 0.2)' : 'none';
        el.querySelector('.sub').textContent = isRoot ? `size=${dsu.size[i]}` : '';
        el.querySelector('.badge').textContent = '';
        el.style.outline = `2px solid ${color}22`;
      }
      renderLines();
    }

    function getCenter(i) {
      const el = nodeEls[i];
      const rect = el.getBoundingClientRect();
      const stageRect = stage.getBoundingClientRect();
      return { x: rect.left - stageRect.left + rect.width / 2, y: rect.top - stageRect.top + rect.height / 2 };
    }

    function renderLines(highlightPairs = []) {
      svg.setAttribute('width', stage.clientWidth);
      svg.setAttribute('height', stage.clientHeight);
      svg.innerHTML = '';
      const toHighlight = new Set(highlightPairs.map(p => `${p[0]}-${p[1]}`));
      for (let i = 0; i < dsu.n; i++) {
        if (dsu.parent[i] !== i) {
          const a = getCenter(i);
          const b = getCenter(dsu.parent[i]);
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', a.x);
          line.setAttribute('y1', a.y);
          line.setAttribute('x2', b.x);
          line.setAttribute('y2', b.y);
          line.setAttribute('class', 'line');
          const pairKey = `${i}-${dsu.parent[i]}`;
          if (toHighlight.has(pairKey)) line.classList.add('highlight');
          svg.appendChild(line);
        }
      }
    }

    function runUnion(a, b) {
      if (!dsu.valid(a) || !dsu.valid(b)) {
        log(`Union(${a}, ${b}) -> invalid indices`, 'err');
        return;
      }
      const beforeRA = dsu.rootOfNoCompress(a);
      const beforeRB = dsu.rootOfNoCompress(b);
      const res = dsu.union(a, b);
      if (!res.merged) {
        if (res.reason === 'same') {
          log(`Union(${a}, ${b}) -> already in same set (root=${res.root})`, 'warn');
        } else {
          log(`Union(${a}, ${b}) -> failed`, 'err');
        }
      } else {
        log(`Union(${a}, ${b}) -> attach smaller to larger; new root=${res.newRoot}, sizes: size[${res.newRoot}]=${dsu.size[res.newRoot]}`, 'ok');
      }
      render();
    }

    function runFindVisual(a) {
      if (!dsu.valid(a)) {
        log(`Find(${a}) -> invalid index`, 'err');
        return;
      }
      const { root, path } = dsu.probeFind(a);
      // Highlight path edges
      const pairs = [];
      for (let i = 0; i < path.length - 1; i++) {
        pairs.push([path[i], path[i + 1]]);
      }
      // Highlight nodes briefly
      for (const i of path) nodeEls[i].classList.add('selected');
      renderLines(pairs);
      log(`Find(${a}) -> path: [${path.join(' -> ')}], root=${root}`);
      // Compress if enabled
      if (compressionToggle.checked) {
        setTimeout(() => {
          dsu.compressEnabled = true; // ensure compression setting sync
          dsu.compressPath(path, root);
          log(`Path compression applied: parent[x]=${root} for x in path`);
          for (const i of path) nodeEls[i].classList.remove('selected');
          render();
        }, 600);
      } else {
        // Remove highlights without compression
        setTimeout(() => {
          for (const i of path) nodeEls[i].classList.remove('selected');
          renderLines(); // remove highlight
        }, 600);
      }
    }

    function runConnected(a, b) {
      if (!dsu.valid(a) || !dsu.valid(b)) {
        log(`Connected(${a}, ${b}) -> invalid indices`, 'err');
        return;
      }
      const res = dsu.connected(a, b);
      log(`Connected(${a}, ${b}) -> ${res.connected ? 'true' : 'false'} (roots: ${res.ra}, ${res.rb})`, res.connected ? 'ok' : 'warn');
      render();
    }

    // Random helpers
    function randInt(n) { return Math.floor(Math.random() * n); }
    function randomUnion() {
      const a = randInt(dsu.n), b = randInt(dsu.n);
      if (a === b) return randomUnion();
      runUnion(a, b);
    }
    function randomOps(count = 8) {
      for (let k = 0; k < count; k++) {
        const choice = Math.random();
        if (choice < 0.5) randomUnion();
        else {
          const a = randInt(dsu.n);
          runFindVisual(a);
        }
      }
    }

    // Wire controls
    resetBtn.addEventListener('click', () => {
      const n = Number(nodeCountInput.value);
      if (!Number.isInteger(n) || n < 2 || n > 500) {
        log(`Reset -> invalid node count: ${nodeCountInput.value}`, 'err');
        return;
      }
      init(n);
    });
    shuffleBtn.addEventListener('click', shuffleLayout);
    compressionToggle.addEventListener('change', () => {
      dsu.compressEnabled = compressionToggle.checked;
      log(`Path compression ${dsu.compressEnabled ? 'enabled' : 'disabled'} for find operations`);
    });
    btnUnion.addEventListener('click', () => {
      const a = Number(inputA.value), b = Number(inputB.value);
      runUnion(a, b);
    });
    btnFind.addEventListener('click', () => {
      const a = Number(inputA.value);
      runFindVisual(a);
    });
    btnConnected.addEventListener('click', () => {
      const a = Number(inputA.value), b = Number(inputB.value);
      runConnected(a, b);
    });
    btnRandomUnion.addEventListener('click', randomUnion);
    btnRandomOps.addEventListener('click', () => randomOps(6));
    btnClearLog.addEventListener('click', clearLog);

    window.addEventListener('resize', () => {
      // re-layout circle to fit new size, keep order
      nodePositions = layoutCircle(dsu.n);
      for (let i = 0; i < dsu.n; i++) {
        nodeEls[i].style.left = (nodePositions[i].x - 22) + 'px';
        nodeEls[i].style.top = (nodePositions[i].y - 22) + 'px';
      }
      render();
    });

    // Start
    init(12);
  </script>
</body>
</html>