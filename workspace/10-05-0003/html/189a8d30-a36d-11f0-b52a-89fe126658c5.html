<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Dijkstra’s Algorithm Visualizer</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root {
    --bg: #11161b;
    --panel: #182028;
    --accent: #5cc8ff;
    --accent2: #ffa447;
    --ok: #64d36d;
    --warn: #ffce57;
    --danger: #ff6b6b;
    --text: #e6edf3;
    --muted: #9aa5b1;
    --edge: #7d8ea3;
    --path: #b37aff;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    background: linear-gradient(120deg, #0d1217, #141b22);
    color: var(--text);
  }
  header {
    padding: 14px 16px;
    border-bottom: 1px solid #253243;
    background: #12171d;
    position: sticky;
    top: 0;
    z-index: 5;
  }
  header h1 {
    margin: 0;
    font-size: 20px;
    letter-spacing: 0.2px;
  }
  header p {
    margin: 6px 0 0;
    color: var(--muted);
    font-size: 13px;
  }
  .container {
    display: grid;
    grid-template-columns: 1fr 320px;
    gap: 8px;
    padding: 10px;
    height: calc(100vh - 82px);
  }
  .left, .right {
    background: var(--panel);
    border: 1px solid #263243;
    border-radius: 10px;
    overflow: hidden;
  }
  .controls {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr 1fr;
    gap: 8px;
    padding: 10px;
    border-bottom: 1px solid #263243;
    background: #151d25;
  }
  .controls .group {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .controls label {
    font-size: 12px;
    color: var(--muted);
  }
  select, input[type="number"], input[type="text"] {
    background: #0f141a;
    color: var(--text);
    border: 1px solid #2b394c;
    border-radius: 6px;
    padding: 6px 8px;
    font-size: 13px;
  }
  .modebar, .runbar, .graphbar {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
  }
  button, .toggle {
    background: #0f141a;
    color: var(--text);
    border: 1px solid #2b394c;
    border-radius: 8px;
    padding: 8px 10px;
    font-size: 13px;
    cursor: pointer;
    transition: all .15s ease;
    user-select: none;
  }
  button:hover { border-color: #3a4d66; transform: translateY(-1px); }
  button.primary { background: #1b2836; border-color: #3a4d66; color: #d8e6f5; }
  button.danger { border-color: #583446; color: #ffc7c7; }
  button.secondary { color: #b7cde7; }
  button.active { outline: 2px solid var(--accent); }
  .speedbar { display: flex; align-items: center; gap: 6px; }
  input[type="range"] { width: 100%; }
  .canvas-wrap {
    position: relative;
    height: calc(100% - 122px);
    background: #0c1218;
  }
  canvas {
    width: 100%;
    height: 100%;
    display: block;
    background-image: radial-gradient(rgba(255,255,255,.04) 1px, transparent 1px);
    background-size: 16px 16px;
  }
  .hint {
    position: absolute;
    left: 12px;
    bottom: 8px;
    font-size: 12px;
    color: var(--muted);
    background: rgba(0,0,0,.35);
    padding: 6px 8px;
    border: 1px solid #263243;
    border-radius: 8px;
    backdrop-filter: blur(4px);
  }
  .right {
    display: grid;
    grid-template-rows: auto auto 1fr;
  }
  .legend {
    padding: 10px;
    border-bottom: 1px solid #263243;
    background: #151d25;
    font-size: 13px;
  }
  .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 10px 14px;
  }
  .legend .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 6px; }
  .dot.source { background: #3ca3ff; }
  .dot.settled { background: var(--ok); }
  .dot.frontier { background: var(--warn); }
  .dot.current { background: var(--danger); }
  .dot.path { background: var(--path); }
  .sidebar {
    padding: 10px;
    overflow: auto;
  }
  .panel {
    border: 1px solid #273545;
    border-radius: 8px;
    padding: 8px;
    margin-bottom: 10px;
    background: #10161d;
  }
  .panel h3 { margin: 0 0 6px; font-size: 14px; color: #bcd2ea; }
  .queue, .dist, .log {
    font-family: ui-monospace, Menlo, Consolas, monospace;
    font-size: 12px;
    color: #c9d7e3;
    white-space: pre-wrap;
  }
  .badge {
    display: inline-flex;
    gap: 6px;
    align-items: center;
    padding: 6px 8px;
    border-radius: 999px;
    background: #0f141a;
    border: 1px solid #2b394c;
  }
  .badge .key { color: var(--muted); }
  .badge .val { color: #e6edf3; font-weight: 600; }
  .small { font-size: 12px; color: var(--muted); }
  .footnote {
    padding: 10px;
    border-top: 1px solid #263243;
    font-size: 12px;
    color: var(--muted);
    background: #151d25;
  }
  /* Tooltip-like overlay values on nodes */
  .value-pill {
    position: absolute;
    transform: translate(-50%, -100%);
    background: rgba(18,23,29,.8);
    border: 1px solid #2b394c;
    color: #dbe7f4;
    padding: 2px 6px;
    border-radius: 6px;
    font-size: 11px;
    pointer-events: none;
  }
</style>
</head>
<body>
<header>
  <h1>Dijkstra’s Algorithm Visualizer</h1>
  <p>Build a weighted graph and watch Dijkstra’s algorithm find shortest paths. Non-negative edge weights only.</p>
</header>

<div class="container">
  <div class="left">
    <div class="controls">
      <div class="group">
        <label>Mode</label>
        <div class="modebar">
          <button id="modeSelect" class="active">Select/Move</button>
          <button id="modeAddNode">Add Node</button>
          <button id="modeAddEdge">Add Edge</button>
          <button id="modeDelete" class="danger">Delete</button>
        </div>
      </div>

      <div class="group">
        <label>Source & Target</label>
        <div class="graphbar">
          <select id="sourceSelect"></select>
          <select id="targetSelect"></select>
          <button id="clearTarget" class="secondary">Clear Target</button>
        </div>
      </div>

      <div class="group">
        <label>Run Controls</label>
        <div class="runbar">
          <button id="runBtn" class="primary">Run</button>
          <button id="stepBtn">Step</button>
          <button id="pauseBtn">Pause</button>
          <button id="resetBtn" class="secondary">Reset</button>
        </div>
      </div>

      <div class="group">
        <label>Speed</label>
        <div class="speedbar">
          <input id="speedRange" type="range" min="0" max="1000" value="350">
          <span id="speedLabel" class="small">350 ms</span>
        </div>
      </div>
    </div>

    <div class="canvas-wrap">
      <canvas id="canvas"></canvas>
      <div id="hint" class="hint">Click “Run” to animate. In Add Edge mode, click two nodes and set weight (>= 0). Drag nodes in Select/Move mode.</div>
    </div>

    <div class="controls" style="border-top: 1px solid #263243;">
      <div class="group">
        <label>Graph</label>
        <div class="graphbar">
          <button id="randomBtn">Random Graph</button>
          <button id="clearBtn" class="danger">Clear Graph</button>
          <button id="sampleBtn">Load Sample</button>
        </div>
      </div>
      <div class="group">
        <label>Edge Options</label>
        <div class="graphbar">
          <span class="badge"><span class="key">Type</span><span class="val">Undirected</span></span>
          <span class="badge"><span class="key">Weights</span><span class="val">Non-negative</span></span>
        </div>
      </div>
      <div class="group">
        <label>About Dijkstra</label>
        <div class="graphbar">
          <span class="small">Finds shortest paths from source to all nodes in graphs with non-negative weights. Settles the closest node, relaxes its edges, and repeats.</span>
        </div>
      </div>
      <div class="group">
        <label>Export</label>
        <div class="graphbar">
          <button id="exportBtn" class="secondary">Export JSON</button>
          <button id="importBtn" class="secondary">Import JSON</button>
        </div>
      </div>
    </div>
  </div>

  <div class="right">
    <div class="legend">
      <div class="items">
        <div><span class="dot source"></span>Source</div>
        <div><span class="dot settled"></span>Settled</div>
        <div><span class="dot frontier"></span>Frontier</div>
        <div><span class="dot current"></span>Current</div>
        <div><span class="dot path"></span>Shortest Path</div>
      </div>
    </div>
    <div class="sidebar">
      <div class="panel">
        <h3>Priority Queue (Unsettled)</h3>
        <div id="queueView" class="queue"></div>
      </div>
      <div class="panel">
        <h3>Distances</h3>
        <div id="distView" class="dist"></div>
      </div>
      <div class="panel">
        <h3>Log</h3>
        <div id="logView" class="log"></div>
      </div>
    </div>
    <div class="footnote">
      Tip: The algorithm stops early when the target node is settled. Without a target, it computes all shortest paths from the source.
    </div>
  </div>
</div>

<script>
(function() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let W = 0, H = 0;
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    W = Math.floor(rect.width);
    H = Math.floor(rect.height);
    canvas.width = W * window.devicePixelRatio;
    canvas.height = H * window.devicePixelRatio;
    ctx.setTransform(window.devicePixelRatio,0,0,window.devicePixelRatio,0,0);
    draw();
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  const modeBtns = {
    select: document.getElementById('modeSelect'),
    addNode: document.getElementById('modeAddNode'),
    addEdge: document.getElementById('modeAddEdge'),
    delete: document.getElementById('modeDelete')
  };
  const runBtn = document.getElementById('runBtn');
  const stepBtn = document.getElementById('stepBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const randomBtn = document.getElementById('randomBtn');
  const clearBtn = document.getElementById('clearBtn');
  const sampleBtn = document.getElementById('sampleBtn');
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');
  const sourceSelect = document.getElementById('sourceSelect');
  const targetSelect = document.getElementById('targetSelect');
  const clearTargetBtn = document.getElementById('clearTarget');
  const speedRange = document.getElementById('speedRange');
  const speedLabel = document.getElementById('speedLabel');
  const queueView = document.getElementById('queueView');
  const distView = document.getElementById('distView');
  const logView = document.getElementById('logView');
  const hint = document.getElementById('hint');

  const state = {
    mode: 'select',
    graph: { nodes: [], edges: [], adjacency: new Map() },
    nextEdgeId: 1,
    nextNodeId: 0, // used to generate labels if needed
    dragging: { nodeId: null, dx: 0, dy: 0 },
    addEdgeTemp: { from: null },
    algo: {
      running: false,
      timer: null,
      speed: 350,
      settled: new Set(),
      dist: new Map(),
      prev: new Map(),
      current: null,
      neighborQueue: [],
      finished: false,
      relaxingEdgeId: null,
      source: null,
      target: null,
      pathEdges: new Set(),
      stepCount: 0
    }
  };

  // Label generator: A, B, C ... Z, A2, B2 ...
  function nextLabel() {
    const n = state.graph.nodes.length;
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const index = n % alphabet.length;
    const cycle = Math.floor(n / alphabet.length);
    return cycle === 0 ? alphabet[index] : alphabet[index] + (cycle + 1);
  }

  function addNode(x, y, label) {
    const id = label || nextLabel();
    state.graph.nodes.push({ id, x, y, r: 18 });
    rebuildAdjacency();
    refreshNodeSelects();
    return id;
  }
  function addEdge(a, b, w) {
    if (a === b) return;
    // prevent duplicate undirected edge
    const exists = state.graph.edges.some(e => (e.a === a && e.b === b) || (e.a === b && e.b === a));
    if (exists) return;
    const id = state.nextEdgeId++;
    state.graph.edges.push({ id, a, b, w: Number(w) });
    rebuildAdjacency();
  }
  function deleteNode(id) {
    state.graph.edges = state.graph.edges.filter(e => e.a !== id && e.b !== id);
    state.graph.nodes = state.graph.nodes.filter(n => n.id !== id);
    rebuildAdjacency();
    refreshNodeSelects();
  }
  function deleteEdgeById(id) {
    state.graph.edges = state.graph.edges.filter(e => e.id !== id);
    rebuildAdjacency();
  }
  function rebuildAdjacency() {
    const adj = new Map();
    state.graph.nodes.forEach(n => adj.set(n.id, []));
    state.graph.edges.forEach(e => {
      if (!adj.has(e.a) || !adj.has(e.b)) return;
      adj.get(e.a).push({ to: e.b, w: e.w, edgeId: e.id });
      adj.get(e.b).push({ to: e.a, w: e.w, edgeId: e.id });
    });
    state.graph.adjacency = adj;
    draw();
  }

  function refreshNodeSelects() {
    const nodes = state.graph.nodes.map(n => n.id);
    const fillSelect = (sel, allowEmpty) => {
      const prev = sel.value;
      sel.innerHTML = '';
      if (allowEmpty) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = '(none)';
        sel.appendChild(opt);
      }
      nodes.forEach(id => {
        const opt = document.createElement('option');
        opt.value = id;
        opt.textContent = id;
        sel.appendChild(opt);
      });
      // try restore previous selection if still present
      if (nodes.includes(prev)) sel.value = prev;
      else sel.value = allowEmpty ? '' : (nodes[0] || '');
    };
    fillSelect(sourceSelect, false);
    fillSelect(targetSelect, true);

    // update algo source/target
    state.algo.source = sourceSelect.value || null;
    state.algo.target = targetSelect.value || null;
    resetAlgo(false);
  }

  // Dijkstra algorithm control
  function initAlgo() {
    const source = sourceSelect.value;
    if (!source || !state.graph.nodes.find(n => n.id === source)) return false;
    state.algo.source = source;
    state.algo.target = targetSelect.value || null;
    state.algo.settled = new Set();
    state.algo.dist = new Map();
    state.algo.prev = new Map();
    state.algo.current = null;
    state.algo.neighborQueue = [];
    state.algo.finished = false;
    state.algo.relaxingEdgeId = null;
    state.algo.pathEdges = new Set();
    state.algo.stepCount = 0;
    state.graph.nodes.forEach(n => {
      state.algo.dist.set(n.id, Infinity);
      state.algo.prev.set(n.id, null);
    });
    state.algo.dist.set(source, 0);
    log(`Initialized. dist(${source}) = 0`);
    draw();
    updateSidebar();
    return true;
  }
  function selectNextCurrent() {
    // pick unsettled node with smallest dist
    let best = null;
    let bestDist = Infinity;
    for (const n of state.graph.nodes) {
      if (state.algo.settled.has(n.id)) continue;
      const d = state.algo.dist.get(n.id);
      if (d < bestDist) {
        bestDist = d;
        best = n.id;
      }
    }
    if (best === null) {
      state.algo.finished = true;
      log('Finished. No reachable unsettled nodes remain.');
      finalizePathIfPossible();
      return false;
    }
    if (bestDist === Infinity) {
      state.algo.finished = true;
      log('Finished. Remaining unsettled nodes are unreachable (distance = ∞).');
      finalizePathIfPossible();
      return false;
    }
    state.algo.current = best;
    const neighbors = state.graph.adjacency.get(best) || [];
    state.algo.neighborQueue = neighbors.slice(); // shallow copy
    state.algo.relaxingEdgeId = null;
    log(`Select next with min distance: ${best} (d=${fmtDist(bestDist)}).`);
    return true;
  }
  function stepAlgo() {
    if (state.algo.finished) return;
    if (!state.algo.source) {
      alert('Select a source node first.');
      return;
    }
    if (state.algo.current === null) {
      const chosen = selectNextCurrent();
      if (!chosen) return;
      draw(); updateSidebar();
      return;
    }
    // process one neighbor relaxation
    if (state.algo.neighborQueue.length > 0) {
      const nbr = state.algo.neighborQueue.shift();
      const u = state.algo.current;
      const v = nbr.to;
      const w = nbr.w;
      const du = state.algo.dist.get(u);
      const dv = state.algo.dist.get(v);
      const alt = du + w;
      state.algo.relaxingEdgeId = nbr.edgeId;
      state.algo.stepCount++;
      if (alt < dv) {
        state.algo.dist.set(v, alt);
        state.algo.prev.set(v, u);
        log(`Relax edge ${u}–${v} (w=${w}): Update dist(${v}) from ${fmtDist(dv)} to ${fmtDist(alt)}; prev(${v}) = ${u}.`);
      } else {
        log(`Relax edge ${u}–${v} (w=${w}): No update (current dist(${v})=${fmtDist(dv)}, alt=${fmtDist(alt)}).`);
      }
      draw(); updateSidebar();
      return;
    }
    // neighbors exhausted: settle current
    const justSettled = state.algo.current;
    state.algo.settled.add(justSettled);
    log(`Settle ${justSettled}.`);
    // If target specified and settled, we can finish now
    if (state.algo.target && justSettled === state.algo.target) {
      state.algo.finished = true;
      log(`Target ${justSettled} settled. Algorithm finished early.`);
      finalizePathIfPossible();
    }
    state.algo.current = null;
    state.algo.relaxingEdgeId = null;
    draw(); updateSidebar();
  }
  function runAlgo() {
    if (!state.algo.running) {
      if (!state.algo.source) {
        alert('Select a source node first.');
        return;
      }
      if (state.algo.dist.size === 0 || state.algo.prev.size === 0) {
        if (!initAlgo()) return;
      }
      state.algo.running = true;
      runBtn.textContent = 'Running...';
      runBtn.disabled = true;
      stepBtn.disabled = true;
      resetBtn.disabled = true;
      pauseBtn.disabled = false;
      state.algo.timer = setInterval(() => {
        if (state.algo.finished) {
          pauseAlgo();
          runBtn.textContent = 'Run';
          runBtn.disabled = false;
          stepBtn.disabled = false;
          resetBtn.disabled = false;
          draw(); updateSidebar();
          return;
        }
        stepAlgo();
      }, Math.max(50, state.algo.speed));
    }
  }
  function pauseAlgo() {
    if (state.algo.timer) clearInterval(state.algo.timer);
    state.algo.timer = null;
    state.algo.running = false;
    runBtn.textContent = 'Run';
    runBtn.disabled = false;
    stepBtn.disabled = false;
    resetBtn.disabled = false;
    pauseBtn.disabled = true;
  }
  function resetAlgo(fullInit = true) {
    // Preserve graph; reset algorithm state
    state.algo.running = false;
    if (state.algo.timer) clearInterval(state.algo.timer);
    state.algo.timer = null;
    state.algo.settled = new Set();
    state.algo.dist = new Map();
    state.algo.prev = new Map();
    state.algo.current = null;
    state.algo.neighborQueue = [];
    state.algo.finished = false;
    state.algo.relaxingEdgeId = null;
    state.algo.pathEdges = new Set();
    state.algo.stepCount = 0;
    if (fullInit && state.algo.source) {
      initAlgo();
    } else {
      draw(); updateSidebar();
    }
    runBtn.textContent = 'Run';
    runBtn.disabled = false;
    stepBtn.disabled = false;
    pauseBtn.disabled = true;
    resetBtn.disabled = false;
  }
  function finalizePathIfPossible() {
    state.algo.pathEdges.clear();
    if (!state.algo.target || !state.algo.source) return;
    const target = state.algo.target;
    if (!state.graph.nodes.find(n => n.id === target)) return;
    if (!state.algo.settled.has(target) && state.algo.dist.get(target) === Infinity) return;
    // reconstruct path edges
    let pathNodes = [];
    let cur = target;
    let guard = 0;
    while (cur && guard++ < 1000) {
      pathNodes.push(cur);
      cur = state.algo.prev.get(cur);
    }
    pathNodes = pathNodes.reverse();
    // mark edges in path
    for (let i = 0; i < pathNodes.length - 1; i++) {
      const a = pathNodes[i], b = pathNodes[i+1];
      const edge = state.graph.edges.find(e => (e.a === a && e.b === b) || (e.a === b && e.b === a));
      if (edge) state.algo.pathEdges.add(edge.id);
    }
    if (pathNodes.length > 1) {
      log(`Shortest path ${state.algo.source} → ${state.algo.target}: ${pathNodes.join(' → ')} (length = ${fmtDist(state.algo.dist.get(target))}).`);
    } else {
      log(`No path from ${state.algo.source} to ${state.algo.target}.`);
    }
    draw(); updateSidebar();
  }

  // UI helpers
  function fmtDist(d) { return (d === Infinity ? '∞' : (Math.round(d*100)/100)); }
  function log(msg) {
    const timestamp = new Date().toLocaleTimeString();
    logView.textContent = `[${timestamp}] ${msg}\n` + logView.textContent;
  }

  // Drawing
  function draw() {
    ctx.clearRect(0,0,W,H);
    // draw edges
    for (const e of state.graph.edges) {
      const na = getNode(e.a), nb = getNode(e.b);
      if (!na || !nb) continue;
      const isPath = state.algo.pathEdges.has(e.id);
      const isRelaxing = state.algo.relaxingEdgeId === e.id;
      const color = isPath ? '#b37aff' : (isRelaxing ? '#ffa447' : '#7d8ea3');
      const width = isPath ? 5 : (isRelaxing ? 3 : 2);
      drawEdge(na, nb, color, width, e.w);
    }
    // draw nodes
    for (const n of state.graph.nodes) {
      drawNode(n);
    }
    // draw distance pills
    drawDistancePills();
  }
  function drawEdge(na, nb, color, width, weight) {
    const { x: x1, y: y1 } = na;
    const { x: x2, y: y2 } = nb;
    ctx.save();
    ctx.lineWidth = width;
    ctx.strokeStyle = color;
    // Avoid edge touching node interiors for better aesthetics
    const v = { x: x2 - x1, y: y2 - y1 };
    const len = Math.hypot(v.x, v.y) || 1;
    const ux = v.x / len, uy = v.y / len;
    const r1 = na.r, r2 = nb.r;
    const sx = x1 + ux * r1, sy = y1 + uy * r1;
    const tx = x2 - ux * r2, ty = y2 - uy * r2;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(tx, ty);
    ctx.stroke();
    // weight label at midpoint
    const mx = (sx + tx) / 2;
    const my = (sy + ty) / 2;
    const pad = 3;
    const text = String(weight);
    ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
    ctx.fillStyle = '#0e141a';
    ctx.strokeStyle = '#2b394c';
    const m = ctx.measureText(text);
    const tw = m.width + pad*2;
    const th = 16;
    ctx.lineWidth = 1.25;
    roundRect(ctx, mx - tw/2, my - th/2, tw, th, 4);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = '#c9d7e3';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    ctx.fillText(text, mx, my);
    ctx.restore();
  }
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }
  function drawNode(n) {
    const isSource = (n.id === state.algo.source);
    const isCurrent = (n.id === state.algo.current);
    const settled = state.algo.settled.has(n.id);
    const frontier = (!settled && state.algo.dist.get(n.id) !== undefined && state.algo.dist.get(n.id) !== Infinity);
    const base = '#e6edf3';
    let fill = '#1a2430', stroke = '#2b3c51';
    if (isCurrent) { fill = '#321a1d'; stroke = '#ff6b6b'; }
    else if (settled) { fill = '#15261a'; stroke = '#64d36d'; }
    else if (isSource) { fill = '#152135'; stroke = '#3ca3ff'; }
    else if (frontier) { fill = '#2b2512'; stroke = '#ffce57'; }

    ctx.save();
    ctx.lineWidth = 2;
    ctx.fillStyle = fill;
    ctx.strokeStyle = stroke;
    ctx.beginPath();
    ctx.arc(n.x, n.y, n.r, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    ctx.font = '13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillStyle = base;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(n.id, n.x, n.y);
    ctx.restore();
  }

  function drawDistancePills() {
    // Clear existing pills
    document.querySelectorAll('.value-pill').forEach(el => el.remove());
    for (const n of state.graph.nodes) {
      const d = state.algo.dist.get(n.id);
      if (d === undefined) continue;
      const pill = document.createElement('div');
      pill.className = 'value-pill';
      pill.textContent = 'd=' + fmtDist(d);
      pill.style.left = n.x + 'px';
      pill.style.top = (n.y - n.r - 6) + 'px';
      canvas.parentElement.appendChild(pill);
      // Remove pill before next draw frame
      setTimeout(() => pill.remove(), 0);
    }
  }

  function getNode(id) {
    return state.graph.nodes.find(n => n.id === id);
  }

  // Sidebar views
  function updateSidebar() {
    // Queue: unsettled nodes sorted by distance
    const unsettled = state.graph.nodes
      .filter(n => !state.algo.settled.has(n.id))
      .map(n => ({ id: n.id, d: state.algo.dist.get(n.id) ?? Infinity }))
      .sort((a, b) => (a.d === b.d) ? a.id.localeCompare(b.id) : a.d - b.d);
    queueView.textContent = unsettled.map(({id, d}) => `${id.padEnd(3)}  d=${fmtDist(d)}`).join('\n');

    // Distances and predecessors
    const lines = state.graph.nodes.map(n => {
      const d = state.algo.dist.get(n.id);
      const p = state.algo.prev.get(n.id);
      return `${n.id.padEnd(3)}  dist=${fmtDist(d)}  prev=${p ?? '∅'}`;
    });
    distView.textContent = lines.join('\n');
  }

  // Interaction
  function setMode(next) {
    state.mode = next;
    for (const [k, btn] of Object.entries(modeBtns)) {
      btn.classList.toggle('active', k === next);
    }
    hint.textContent = (
      next === 'select' ? 'Drag nodes to rearrange. Click a node to select.' :
      next === 'addNode' ? 'Click anywhere on the canvas to add a node.' :
      next === 'addEdge' ? 'Click first node, then second node. Enter non-negative weight.' :
      next === 'delete' ? 'Click a node or edge to delete it.' : ''
    );
  }
  modeBtns.select.addEventListener('click', () => setMode('select'));
  modeBtns.addNode.addEventListener('click', () => setMode('addNode'));
  modeBtns.addEdge.addEventListener('click', () => setMode('addEdge'));
  modeBtns.delete.addEventListener('click', () => setMode('delete'));

  // Mouse utils
  function nodeAt(x, y) {
    for (let i = state.graph.nodes.length - 1; i >= 0; i--) {
      const n = state.graph.nodes[i];
      if (Math.hypot(n.x - x, n.y - y) <= n.r + 2) return n;
    }
    return null;
  }
  function edgeAt(x, y, tol = 6) {
    const hitEdges = [];
    for (const e of state.graph.edges) {
      const na = getNode(e.a), nb = getNode(e.b);
      if (!na || !nb) continue;
      const p = {x, y};
      const d = distToSegment(p, na, nb);
      if (d <= tol) hitEdges.push(e);
    }
    return hitEdges[0] || null;
  }
  function distToSegment(p, a, b) {
    const vx = b.x - a.x, vy = b.y - a.y;
    const wx = p.x - a.x, wy = p.y - a.y;
    const c1 = vx*wx + vy*wy;
    if (c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
    const c2 = vx*vx + vy*vy;
    if (c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
    const t = c1 / c2;
    const projx = a.x + t * vx, projy = a.y + t * vy;
    return Math.hypot(p.x - projx, p.y - projy);
  }

  canvas.addEventListener('mousedown', (ev) => {
    const pos = getMousePos(ev);
    if (state.mode === 'select') {
      const n = nodeAt(pos.x, pos.y);
      if (n) {
        state.dragging.nodeId = n.id;
        state.dragging.dx = pos.x - n.x;
        state.dragging.dy = pos.y - n.y;
      }
    }
  });
  canvas.addEventListener('mousemove', (ev) => {
    const pos = getMousePos(ev);
    if (state.dragging.nodeId) {
      const n = getNode(state.dragging.nodeId);
      if (n) {
        n.x = clamp(pos.x - state.dragging.dx, 20, W - 20);
        n.y = clamp(pos.y - state.dragging.dy, 20, H - 20);
        rebuildAdjacency();
      }
    }
  });
  canvas.addEventListener('mouseup', () => {
    state.dragging.nodeId = null;
  });
  canvas.addEventListener('mouseleave', () => {
    state.dragging.nodeId = null;
  });
  canvas.addEventListener('click', (ev) => {
    const pos = getMousePos(ev);
    if (state.mode === 'addNode') {
      const id = addNode(pos.x, pos.y);
      log(`Added node ${id} at (${Math.round(pos.x)}, ${Math.round(pos.y)}).`);
      draw(); updateSidebar();
    } else if (state.mode === 'addEdge') {
      const n = nodeAt(pos.x, pos.y);
      if (!n) return;
      if (!state.addEdgeTemp.from) {
        state.addEdgeTemp.from = n.id;
        log(`Selected first node ${n.id}. Choose second node.`);
      } else {
        const a = state.addEdgeTemp.from, b = n.id;
        if (a === b) {
          log('Cannot connect a node to itself.');
          state.addEdgeTemp.from = null;
          return;
        }
        let w = prompt(`Enter non-negative weight for edge ${a}–${b}:`, '1');
        if (w === null) { state.addEdgeTemp.from = null; return; }
        w = Number(w);
        if (isNaN(w) || w < 0) {
          alert('Weight must be a non-negative number.');
          state.addEdgeTemp.from = null;
          return;
        }
        addEdge(a, b, w);
        state.addEdgeTemp.from = null;
        log(`Added edge ${a}–${b} with weight ${w}.`);
        draw(); updateSidebar();
      }
    } else if (state.mode === 'delete') {
      const n = nodeAt(pos.x, pos.y);
      if (n) {
        deleteNode(n.id);
        log(`Deleted node ${n.id} and its edges.`);
        draw(); updateSidebar();
        return;
      }
      const e = edgeAt(pos.x, pos.y);
      if (e) {
        deleteEdgeById(e.id);
        log(`Deleted edge ${e.a}–${e.b}.`);
        draw(); updateSidebar();
      }
    }
  });

  function getMousePos(ev) {
    const rect = canvas.getBoundingClientRect();
    return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
  }
  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

  // Controls
  runBtn.addEventListener('click', () => {
    // initialize if needed
    if (state.algo.dist.size === 0) {
      if (!initAlgo()) {
        alert('Add nodes and select a source node.');
        return;
      }
    }
    runAlgo();
  });
  pauseBtn.addEventListener('click', () => pauseAlgo());
  stepBtn.addEventListener('click', () => {
    if (state.algo.dist.size === 0) {
      if (!initAlgo()) {
        alert('Add nodes and select a source node.');
        return;
      }
    }
    stepAlgo();
  });
  resetBtn.addEventListener('click', () => resetAlgo(true));

  speedRange.addEventListener('input', () => {
    state.algo.speed = Number(speedRange.value);
    speedLabel.textContent = `${state.algo.speed} ms`;
    if (state.algo.running) {
      pauseAlgo();
      runAlgo();
    }
  });

  sourceSelect.addEventListener('change', () => {
    state.algo.source = sourceSelect.value || null;
    resetAlgo(true);
    draw(); updateSidebar();
  });
  targetSelect.addEventListener('change', () => {
    state.algo.target = targetSelect.value || null;
    finalizePathIfPossible();
  });
  clearTargetBtn.addEventListener('click', () => {
    targetSelect.value = '';
    state.algo.target = null;
    state.algo.pathEdges.clear();
    draw(); updateSidebar();
  });

  randomBtn.addEventListener('click', () => {
    randomGraph();
    log('Generated random graph.');
    refreshNodeSelects();
    resetAlgo(true);
  });
  clearBtn.addEventListener('click', () => {
    if (!confirm('Clear all nodes and edges?')) return;
    state.graph.nodes = [];
    state.graph.edges = [];
    state.nextEdgeId = 1;
    rebuildAdjacency();
    refreshNodeSelects();
    resetAlgo(false);
    log('Cleared graph.');
  });
  sampleBtn.addEventListener('click', () => {
    loadSampleGraph();
    log('Loaded sample graph.');
    refreshNodeSelects();
    resetAlgo(true);
  });

  exportBtn.addEventListener('click', () => {
    const data = JSON.stringify({ nodes: state.graph.nodes, edges: state.graph.edges }, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'graph.json';
    a.click();
    URL.revokeObjectURL(url);
  });
  importBtn.addEventListener('click', async () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'application/json';
    input.onchange = async () => {
      const file = input.files[0];
      if (!file) return;
      const text = await file.text();
      try {
        const obj = JSON.parse(text);
        if (!Array.isArray(obj.nodes) || !Array.isArray(obj.edges)) throw new Error('Invalid format');
        state.graph.nodes = obj.nodes.map(n => ({ id: n.id, x: n.x, y: n.y, r: 18 }));
        state.graph.edges = obj.edges.map(e => ({ id: e.id, a: e.a, b: e.b, w: e.w }));
        state.nextEdgeId = (state.graph.edges.reduce((m, e) => Math.max(m, e.id), 0) || 0) + 1;
        rebuildAdjacency();
        refreshNodeSelects();
        resetAlgo(true);
        log('Imported graph from JSON.');
      } catch (err) {
        alert('Failed to import JSON: ' + err.message);
      }
    };
    input.click();
  });

  // Sample and random graph builders
  function loadSampleGraph() {
    const cx = W/2, cy = H/2;
    const radius = Math.min(W, H) * 0.35;
    const labels = ['A','B','C','D','E','F','G','H'];
    state.graph.nodes = labels.map((id, i) => {
      const ang = (i / labels.length) * Math.PI * 2;
      return { id, x: cx + radius * Math.cos(ang), y: cy + radius * Math.sin(ang), r: 18 };
    });
    const E = [];
    const w = (a,b,c)=>E.push({a,b,w:c});
    w('A','B',4); w('A','C',2);
    w('B','C',1); w('B','D',5); w('B','E',3);
    w('C','D',8); w('C','E',10);
    w('D','E',2); w('D','F',6);
    w('E','F',3); w('E','G',4);
    w('F','G',1); w('F','H',7);
    w('G','H',2);
    state.graph.edges = E.map((e,i)=>({ id: i+1, ...e }));
    state.nextEdgeId = state.graph.edges.length + 1;
    rebuildAdjacency();
    // Default source/target
    sourceSelect.value = 'A';
    targetSelect.value = 'H';
    state.algo.source = 'A';
    state.algo.target = 'H';
  }

  function randomGraph(n = 7) {
    // clear
    state.graph.nodes = [];
    state.graph.edges = [];
    state.nextEdgeId = 1;
    // place nodes with padding
    const padX = 40, padY = 40;
    for (let i = 0; i < n; i++) {
      const x = padX + Math.random() * (W - padX*2);
      const y = padY + Math.random() * (H - padY*2 - 140); // avoid controls area
      addNode(x, y, nextLabel());
    }
    // connect: ensure connected by building a random tree first
    const ids = state.graph.nodes.map(n => n.id);
    const shuffled = ids.slice().sort(()=>Math.random()-0.5);
    for (let i = 1; i < shuffled.length; i++) {
      const a = shuffled[i];
      const b = shuffled[Math.floor(Math.random() * i)];
      addEdge(a, b, 1 + Math.floor(Math.random()*9));
    }
    // add some extra edges
    let extra = Math.floor(n * 1.2);
    while (extra-- > 0) {
      const a = ids[Math.floor(Math.random()*ids.length)];
      const b = ids[Math.floor(Math.random()*ids.length)];
      if (a === b) continue;
      const exists = state.graph.edges.some(e => (e.a===a && e.b===b) || (e.a===b && e.b===a));
      if (exists) continue;
      addEdge(a, b, 1 + Math.floor(Math.random()*9));
    }
    rebuildAdjacency();
    sourceSelect.value = ids[0];
    targetSelect.value = ids[ids.length-1];
    state.algo.source = sourceSelect.value;
    state.algo.target = targetSelect.value;
  }

  // Initialize with sample
  loadSampleGraph();
  refreshNodeSelects();
  resetAlgo(true);

  // Utility for keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if (e.key === ' ') { e.preventDefault(); if (state.algo.running) pauseAlgo(); else runAlgo(); }
    if (e.key.toLowerCase() === 'r') { resetAlgo(true); }
    if (e.key.toLowerCase() === 's') { stepAlgo(); }
    if (e.key.toLowerCase() === 'a') { setMode('addNode'); }
    if (e.key.toLowerCase() === 'e') { setMode('addEdge'); }
    if (e.key.toLowerCase() === 'm') { setMode('select'); }
    if (e.key.toLowerCase() === 'd') { setMode('delete'); }
  });

})();
</script>
</body>
</html>