<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Bellman-Ford Algorithm Visualizer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --accent: #38bdf8;
    --accent2: #22c55e;
    --warn: #f59e0b;
    --danger: #ef4444;
    --text: #e5e7eb;
    --muted: #9ca3af;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    background: linear-gradient(180deg, #0b1225, #0f172a);
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial;
    overflow: hidden;
  }
  header {
    padding: 12px 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    border-bottom: 1px solid #1f2937;
    background: rgba(17, 24, 39, 0.5);
    backdrop-filter: blur(6px);
  }
  header h1 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    letter-spacing: 0.2px;
  }
  .container {
    display: grid;
    grid-template-columns: minmax(500px, 1fr) 420px;
    height: calc(100vh - 56px);
  }
  .left {
    position: relative;
  }
  canvas {
    width: 100%;
    height: 100%;
    display: block;
    background:
      radial-gradient(ellipse at center, rgba(56, 189, 248, 0.04) 0%, rgba(0,0,0,0) 60%),
      linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    cursor: default;
  }
  .right {
    border-left: 1px solid #1f2937;
    background: rgba(17, 24, 39, 0.6);
    backdrop-filter: blur(6px);
    padding: 12px;
    overflow: auto;
  }
  .section {
    border: 1px solid #1f2937;
    border-radius: 10px;
    padding: 10px;
    margin-bottom: 10px;
    background: #0b1324;
  }
  .section h2 {
    font-size: 15px;
    margin: 0 0 8px;
    color: #cbd5e1;
  }
  .row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items: center;
    margin: 6px 0;
  }
  button, select, input[type="number"], input[type="text"] {
    background: #0b1427;
    border: 1px solid #1f2937;
    color: var(--text);
    border-radius: 8px;
    padding: 8px 10px;
    font-size: 13px;
    outline: none;
  }
  button {
    cursor: pointer;
  }
  button.primary {
    background: #0b1c36;
    border-color: #0ea5e9;
    color: #93c5fd;
  }
  button.green {
    background: #0b1c32;
    border-color: #22c55e;
    color: #a7f3d0;
  }
  button.orange {
    background: #1b160b;
    border-color: #f59e0b;
    color: #fde68a;
  }
  button.red {
    background: #1b0b0b;
    border-color: #ef4444;
    color: #fecaca;
  }
  button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  .tiny {
    font-size: 12px;
    color: var(--muted);
    margin-top: 4px;
  }
  .table {
    width: 100%;
    border: 1px solid #1f2937;
    border-radius: 8px;
    overflow: hidden;
  }
  .table .thead, .table .rowdata {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
  }
  .table .thead {
    background: #0f192f;
    font-weight: 600;
    color: #cbd5e1;
    padding: 8px;
    border-bottom: 1px solid #1f2937;
  }
  .table .rowdata {
    padding: 8px;
    border-bottom: 1px solid #1f2937;
  }
  .table .rowdata.changed {
    background: rgba(34, 197, 94, 0.1);
  }
  .log {
    height: 180px;
    overflow: auto;
    border: 1px solid #1f2937;
    border-radius: 8px;
    padding: 8px;
    background: #0b1324;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    font-size: 12px;
    line-height: 1.4;
  }
  .badge {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 999px;
    font-size: 11px;
    border: 1px solid #334155;
    color: #cbd5e1;
    background: #0f192f;
    margin-right: 6px;
  }
  .legend {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
  }
  .legend .item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--muted);
  }
  .legend .swatch {
    width: 20px;
    height: 6px;
    border-radius: 3px;
  }
  .swatch.edge { background: #63728b; }
  .swatch.relax { background: #f59e0b; }
  .swatch.pred { background: #22c55e; }
  .swatch.cycle { background: #ef4444; }
  .help {
    font-size: 12px;
    color: #94a3b8;
    line-height: 1.45;
  }
  .kbd {
    display: inline-block;
    border: 1px solid #334155;
    background: #0f192f;
    border-radius: 6px;
    padding: 2px 6px;
    font-size: 11px;
    color: #cbd5e1;
    margin: 0 2px;
  }
  .flex-grow { flex: 1; }
  .status {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    align-items: center;
  }
  .status .value {
    font-weight: 600;
    color: #e2e8f0;
  }
  .hr {
    height: 1px;
    background: #1f2937;
    margin: 8px 0;
  }
</style>
</head>
<body>
<header>
  <h1>Bellman-Ford Algorithm Visualizer</h1>
  <span class="badge">Directed graph</span>
  <span class="badge">Supports negative weights</span>
  <span class="badge">Detects negative cycles</span>
</header>
<div class="container">
  <div class="left">
    <canvas id="canvas"></canvas>
  </div>
  <div class="right">
    <div class="section">
      <h2>Build Graph</h2>
      <div class="row">
        <button id="modeMove" class="primary">Select/Move</button>
        <button id="modeAddNode">Add Node</button>
        <button id="modeAddEdge">Add Edge</button>
        <button id="deleteSelected" class="red">Delete Selected</button>
        <button id="clearGraph" class="red">Clear Graph</button>
      </div>
      <div class="row">
        <div class="flex-grow help">
          - Click canvas in "Add Node" mode to place a node. Drag nodes in "Select/Move" mode.
          - In "Add Edge" mode: click source node, then target node; set weight (negative allowed).
        </div>
      </div>
      <div class="hr"></div>
      <div class="row">
        <button id="example1" class="green">Load Example: No Negative Cycle</button>
        <button id="example2" class="orange">Load Example: Negative Cycle</button>
        <button id="example3">Load Small Random</button>
      </div>
    </div>

    <div class="section">
      <h2>Run Bellman-Ford</h2>
      <div class="row">
        <label for="sourceSelect">Source:</label>
        <select id="sourceSelect"></select>
        <button id="initBF" class="primary">Initialize</button>
        <button id="resetBF">Reset</button>
      </div>
      <div class="row">
        <button id="stepBtn">Next Relaxation</button>
        <button id="nextIterBtn">Next Iteration</button>
        <button id="runAllBtn" class="green">Run to Completion</button>
        <button id="autoBtn">Auto-run</button>
        <label>Speed:<input id="speedRange" type="range" min="10" max="500" value="120" /></label>
      </div>
      <div class="row status">
        <span>Iterations:</span> <span id="iterVal" class="value">0</span> / <span id="iterMax" class="value">0</span>
        <span>Edges this iteration:</span> <span id="edgeIdx" class="value">0</span> / <span id="edgeMax" class="value">0</span>
        <span>Negative Cycle:</span> <span id="negStatus" class="value">unknown</span>
      </div>
      <div class="legend" style="margin-top:8px;">
        <div class="item"><span class="swatch edge"></span>Edge</div>
        <div class="item"><span class="swatch relax"></span>Last relaxed</div>
        <div class="item"><span class="swatch pred"></span>Predecessor edges</div>
        <div class="item"><span class="swatch cycle"></span>Negative cycle</div>
      </div>
      <div class="tiny">Bellman-Ford does V-1 iterations of relaxing all edges. One extra pass checks for a negative-weight cycle.</div>
    </div>

    <div class="section">
      <h2>Distances</h2>
      <div id="distTable" class="table">
        <div class="thead"><div>Node</div><div>Distance</div><div>Predecessor</div></div>
        <div id="distRows"></div>
      </div>
    </div>

    <div class="section">
      <h2>Log</h2>
      <div id="log" class="log"></div>
    </div>

    <div class="section">
      <h2>Tips</h2>
      <div class="help">
        - If any distance still improves after V-1 iterations, the graph has a negative-weight cycle reachable from the source.<br>
        - Relaxation tries to improve dist[to] with dist[from] + weight.<br>
        - You can edit an edge's weight by selecting it and pressing <span class="kbd">E</span>, or delete with <span class="kbd">Delete</span>.
      </div>
    </div>
  </div>
</div>

<script>
(function() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Resize canvas to device pixels
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    draw();
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Graph state
  let nodes = []; // {id, x, y}
  let edges = []; // {id, from, to, weight}
  let nextNodeId = 0;
  let nextEdgeId = 0;

  // UI modes
  const Mode = { Move: 'move', AddNode: 'addNode', AddEdge: 'addEdge' };
  let mode = Mode.Move;
  let selectedNodeId = null;
  let selectedEdgeId = null;
  let draggingNodeId = null;
  let dragOffset = {x:0, y:0};
  let pendingEdge = { from: null, to: null };
  let hoverNodeId = null;
  let hoverEdgeId = null;

  // Algorithm state
  let bf = {
    running: false,
    source: null,
    dist: [],
    prev: [],
    iter: 0,
    edgeIdx: 0,
    iterMax: 0,
    lastRelaxedEdge: null,
    changedInIter: new Set(),
    doneRelaxations: false,
    negativeCycle: null,
    cycleVertices: [],
    cycleEdges: new Set(),
    autoTimer: null
  };

  // DOM elements
  const modeMoveBtn = document.getElementById('modeMove');
  const modeAddNodeBtn = document.getElementById('modeAddNode');
  const modeAddEdgeBtn = document.getElementById('modeAddEdge');
  const deleteSelBtn = document.getElementById('deleteSelected');
  const clearGraphBtn = document.getElementById('clearGraph');

  const example1Btn = document.getElementById('example1');
  const example2Btn = document.getElementById('example2');
  const example3Btn = document.getElementById('example3');

  const sourceSelect = document.getElementById('sourceSelect');
  const initBFBtn = document.getElementById('initBF');
  const resetBFBtn = document.getElementById('resetBF');

  const stepBtn = document.getElementById('stepBtn');
  const nextIterBtn = document.getElementById('nextIterBtn');
  const runAllBtn = document.getElementById('runAllBtn');
  const autoBtn = document.getElementById('autoBtn');
  const speedRange = document.getElementById('speedRange');

  const distRows = document.getElementById('distRows');
  const logEl = document.getElementById('log');
  const iterValEl = document.getElementById('iterVal');
  const iterMaxEl = document.getElementById('iterMax');
  const edgeIdxEl = document.getElementById('edgeIdx');
  const edgeMaxEl = document.getElementById('edgeMax');
  const negStatusEl = document.getElementById('negStatus');

  // Helpers
  function addLog(msg) {
    const time = new Date().toLocaleTimeString();
    const line = document.createElement('div');
    line.textContent = `[${time}] ${msg}`;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
    // Cap log length
    const maxLines = 400;
    while (logEl.childNodes.length > maxLines) {
      logEl.removeChild(logEl.firstChild);
    }
  }

  function formatDist(d) {
    if (d === Infinity) return '∞';
    return Number.isFinite(d) ? d : '∞';
  }

  function nodeLabel(id) {
    // Use 0..9 A..Z fallback
    return String(id);
  }

  function rebuildSourceSelect() {
    sourceSelect.innerHTML = '';
    nodes.forEach(n => {
      const opt = document.createElement('option');
      opt.value = String(n.id);
      opt.textContent = nodeLabel(n.id);
      sourceSelect.appendChild(opt);
    });
    if (bf.source != null) {
      sourceSelect.value = String(bf.source);
    }
  }

  function resetSelection() {
    selectedNodeId = null;
    selectedEdgeId = null;
    pendingEdge.from = null;
    pendingEdge.to = null;
  }

  function clearGraph() {
    nodes = [];
    edges = [];
    nextNodeId = 0;
    nextEdgeId = 0;
    stopAuto();
    resetBF();
    resetSelection();
    rebuildSourceSelect();
    addLog('Graph cleared.');
    draw();
    renderDistTable();
  }

  function deleteSelected() {
    if (selectedNodeId != null) {
      const nid = selectedNodeId;
      nodes = nodes.filter(n => n.id !== nid);
      edges = edges.filter(e => e.from !== nid && e.to !== nid);
      stopAuto();
      resetBF();
      addLog(`Deleted node ${nodeLabel(nid)} and its edges.`);
      selectedNodeId = null;
      rebuildSourceSelect();
      draw();
      renderDistTable();
      return;
    }
    if (selectedEdgeId != null) {
      const eid = selectedEdgeId;
      edges = edges.filter(e => e.id !== eid);
      stopAuto();
      resetBF();
      addLog(`Deleted edge ${eid}.`);
      selectedEdgeId = null;
      draw();
      renderDistTable();
      return;
    }
    addLog('Nothing selected to delete.');
  }

  function setMode(m) {
    mode = m;
    modeMoveBtn.classList.toggle('primary', mode === Mode.Move);
    modeAddNodeBtn.classList.toggle('primary', mode === Mode.AddNode);
    modeAddEdgeBtn.classList.toggle('primary', mode === Mode.AddEdge);
    resetSelection();
    draw();
  }

  // Canvas interaction
  function distanceSquared(x1, y1, x2, y2) {
    const dx = x1 - x2, dy = y1 - y2;
    return dx*dx + dy*dy;
  }

  function findNodeAt(x, y) {
    const r = 18;
    let best = null, bestD = Infinity;
    for (const n of nodes) {
      const d = distanceSquared(x, y, n.x, n.y);
      if (d <= r*r && d < bestD) {
        best = n;
        bestD = d;
      }
    }
    return best;
  }

  function pointSegmentDistance(px, py, x1, y1, x2, y2) {
    // Distance from point P to segment AB
    const vx = x2 - x1, vy = y2 - y1;
    const wx = px - x1, wy = py - y1;
    const c1 = vx*wx + vy*wy;
    if (c1 <= 0) return Math.hypot(px - x1, py - y1);
    const c2 = vx*vx + vy*vy;
    if (c2 <= c1) return Math.hypot(px - x2, py - y2);
    const b = c1 / c2;
    const bx = x1 + b*vx, by = y1 + b*vy;
    return Math.hypot(px - bx, py - by);
  }

  function findEdgeAt(x, y) {
    const thresh = 6;
    let best = null, bestD = Infinity;
    for (const e of edges) {
      const a = nodeById(e.from);
      const b = nodeById(e.to);
      if (!a || !b) continue;
      const d = pointSegmentDistance(x, y, a.x, a.y, b.x, b.y);
      if (d < thresh && d < bestD) {
        best = e;
        bestD = d;
      }
    }
    return best;
  }

  function nodeById(id) {
    return nodes.find(n => n.id === id) || null;
  }

  function edgeById(id) {
    return edges.find(e => e.id === id) || null;
  }

  function createNode(x, y) {
    const id = nextNodeId++;
    nodes.push({ id, x, y });
    rebuildSourceSelect();
    addLog(`Added node ${nodeLabel(id)} at (${Math.round(x)}, ${Math.round(y)}).`);
    draw();
    return id;
  }

  function createEdge(from, to, weight) {
    const id = nextEdgeId++;
    edges.push({ id, from, to, weight });
    addLog(`Added edge ${nodeLabel(from)} → ${nodeLabel(to)} with weight ${weight}.`);
    draw();
    return id;
  }

  // Edge weight prompt UI
  function promptEdgeWeight(defaultVal = 1) {
    let w = prompt("Enter edge weight (negative allowed):", String(defaultVal));
    if (w == null) return null;
    w = w.trim();
    if (!w) return null;
    const val = Number(w);
    if (!Number.isFinite(val)) {
      alert("Invalid weight.");
      return null;
    }
    return val;
  }

  // Drawing
  function draw() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.clearRect(0, 0, w, h);

    // Draw edges
    for (const e of edges) {
      const a = nodeById(e.from);
      const b = nodeById(e.to);
      if (!a || !b) continue;
      let color = '#63728b';
      let width = 2;

      if (bf.cycleEdges.has(e.id)) {
        color = '#ef4444';
        width = 3.5;
      } else if (bf.lastRelaxedEdge === e.id) {
        color = '#f59e0b';
        width = 3.5;
      } else if (bf.running && bf.prev[e.to] === e.from) {
        color = '#22c55e';
        width = 3;
      }

      if (selectedEdgeId === e.id) {
        width += 1.2;
      }

      drawArrow(a.x, a.y, b.x, b.y, color, width);

      // Edge weight label
      const midx = (a.x + b.x)/2;
      const midy = (a.y + b.y)/2;
      const nx = b.x - a.x, ny = b.y - a.y;
      const len = Math.max(1, Math.hypot(nx, ny));
      const ox = -ny / len * 12, oy = nx / len * 12; // normal offset
      const text = String(e.weight);
      drawLabel(midx + ox, midy + oy, text, color);
    }

    // Pending edge temp line
    if (mode === Mode.AddEdge && pendingEdge.from != null && hoverNodeId != null) {
      const a = nodeById(pendingEdge.from);
      const b = nodeById(hoverNodeId);
      if (a && b) {
        drawArrow(a.x, a.y, b.x, b.y, '#f59e0b', 1.5, true);
      }
    }

    // Draw nodes
    for (const n of nodes) {
      drawNode(n);
    }
  }

  function drawNode(n) {
    const r = 16;
    const isSelected = selectedNodeId === n.id;
    const isHover = hoverNodeId === n.id;
    ctx.save();
    ctx.beginPath();
    ctx.arc(n.x, n.y, r, 0, Math.PI*2);
    const grad = ctx.createRadialGradient(n.x, n.y, 3, n.x, n.y, r);
    grad.addColorStop(0, '#11366b');
    grad.addColorStop(1, '#0b162b');
    ctx.fillStyle = grad;
    ctx.fill();

    ctx.lineWidth = 2;
    ctx.strokeStyle = isSelected ? '#f59e0b' : (isHover ? '#38bdf8' : '#1f2937');
    ctx.stroke();

    // Label
    ctx.fillStyle = '#cbd5e1';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(nodeLabel(n.id), n.x, n.y);
    ctx.restore();
  }

  function drawArrow(x1,y1,x2,y2,color='#63728b',width=2, dashed=false) {
    ctx.save();
    ctx.lineWidth = width;
    ctx.strokeStyle = color;
    if (dashed) ctx.setLineDash([6, 6]);

    // Shorten to avoid overlapping node circles
    const r = 16;
    const vx = x2 - x1, vy = y2 - y1;
    const L = Math.hypot(vx, vy);
    if (L < 1) { ctx.restore(); return; }
    const ux = vx / L, uy = vy / L;
    const ax = x1 + ux * r;
    const ay = y1 + uy * r;
    const bx = x2 - ux * (r + 6);
    const by = y2 - uy * (r + 6);

    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(bx, by);
    ctx.stroke();

    // Arrowhead
    const size = 8;
    const angle = Math.atan2(vy, vx);
    const hx = x2 - ux * r;
    const hy = y2 - uy * r;
    ctx.beginPath();
    ctx.moveTo(hx, hy);
    ctx.lineTo(hx - size * Math.cos(angle - Math.PI/6), hy - size * Math.sin(angle - Math.PI/6));
    ctx.lineTo(hx - size * Math.cos(angle + Math.PI/6), hy - size * Math.sin(angle + Math.PI/6));
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();

    ctx.restore();
  }

  function drawLabel(x, y, text, color='#94a3b8') {
    ctx.save();
    ctx.font = '11px ui-monospace';
    const metrics = ctx.measureText(text);
    const pad = 4;
    const w = metrics.width + pad*2;
    const h = 13 + pad*2;
    ctx.fillStyle = 'rgba(17, 24, 39, 0.9)';
    ctx.strokeStyle = '#1f2937';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(x - w/2, y - h/2, w, h, 6);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  // Distances table
  function renderDistTable(changedSet = new Set()) {
    distRows.innerHTML = '';
    const sorted = [...nodes].sort((a,b) => a.id - b.id);
    for (const n of sorted) {
      const row = document.createElement('div');
      row.className = 'rowdata' + (changedSet.has(n.id) ? ' changed' : '');
      const dCell = document.createElement('div');
      const distVal = bf.dist[n.id] ?? Infinity;
      dCell.textContent = formatDist(distVal);

      const pCell = document.createElement('div');
      const pred = bf.prev[n.id];
      pCell.textContent = pred != null ? nodeLabel(pred) : '-';

      const nCell = document.createElement('div');
      nCell.textContent = nodeLabel(n.id);

      row.appendChild(nCell);
      row.appendChild(dCell);
      row.appendChild(pCell);
      distRows.appendChild(row);
    }
    iterValEl.textContent = bf.iter;
    iterMaxEl.textContent = bf.iterMax;
    edgeIdxEl.textContent = bf.edgeIdx;
    edgeMaxEl.textContent = edges.length;
    negStatusEl.textContent = bf.negativeCycle == null ? 'unknown' : (bf.negativeCycle ? 'present' : 'none');
  }

  // Algorithm functions
  function initBF() {
    if (nodes.length === 0) {
      alert("Add some nodes first.");
      return;
    }
    if (edges.length === 0) {
      alert("Add some edges first.");
      return;
    }
    bf.source = Number(sourceSelect.value);
    bf.dist = [];
    bf.prev = [];
    const n = nodes.length;
    for (const node of nodes) {
      bf.dist[node.id] = Infinity;
      bf.prev[node.id] = null;
    }
    bf.dist[bf.source] = 0;
    bf.iter = 0;
    bf.edgeIdx = 0;
    bf.iterMax = Math.max(0, n - 1);
    bf.lastRelaxedEdge = null;
    bf.changedInIter = new Set();
    bf.doneRelaxations = false;
    bf.negativeCycle = null;
    bf.cycleVertices = [];
    bf.cycleEdges = new Set();
    bf.running = true;
    addLog(`Initialized Bellman-Ford with source ${nodeLabel(bf.source)}. Will perform ${bf.iterMax} iterations.`);
    renderDistTable();
    draw();
    disableEditingWhileRunning(true);
  }

  function resetBF() {
    bf.running = false;
    bf.source = null;
    bf.dist = [];
    bf.prev = [];
    bf.iter = 0;
    bf.edgeIdx = 0;
    bf.iterMax = 0;
    bf.lastRelaxedEdge = null;
    bf.changedInIter = new Set();
    bf.doneRelaxations = false;
    bf.negativeCycle = null;
    bf.cycleVertices = [];
    bf.cycleEdges = new Set();
    stopAuto();
    renderDistTable();
    draw();
    disableEditingWhileRunning(false);
    addLog('Algorithm reset.');
  }

  function stepRelaxation() {
    if (!bf.running) {
      addLog('Initialize the algorithm first.');
      return;
    }
    if (bf.doneRelaxations) {
      // Already did V-1 iterations; run detection
      detectNegativeCycle();
      return;
    }
    if (bf.iter >= bf.iterMax) {
      bf.doneRelaxations = true;
      addLog('Completed V-1 iterations. Ready to detect negative cycle.');
      renderDistTable(bf.changedInIter);
      draw();
      return;
    }
    if (edges.length === 0) {
      addLog('No edges to relax.');
      return;
    }

    const e = edges[bf.edgeIdx];
    bf.lastRelaxedEdge = e.id;

    const du = bf.dist[e.from];
    const dv = bf.dist[e.to];
    const w = e.weight;
    let improved = false;

    if (du + w < dv) {
      bf.dist[e.to] = du + w;
      bf.prev[e.to] = e.from;
      bf.changedInIter.add(e.to);
      improved = true;
      addLog(`Relaxed edge ${nodeLabel(e.from)} → ${nodeLabel(e.to)}: dist[${nodeLabel(e.to)}] = ${formatDist(du)} + ${w} = ${bf.dist[e.to]}`);
    } else {
      addLog(`Checked edge ${nodeLabel(e.from)} → ${nodeLabel(e.to)}: no improvement.`);
    }

    bf.edgeIdx++;
    if (bf.edgeIdx >= edges.length) {
      bf.edgeIdx = 0;
      bf.iter++;
      addLog(`Iteration ${bf.iter} completed. Changed nodes: ${[...bf.changedInIter].map(nodeLabel).join(', ') || 'none'}.`);
      // Reset changed set for next iteration visualization
      renderDistTable(bf.changedInIter);
      bf.changedInIter.clear();
    } else {
      renderDistTable(bf.changedInIter);
    }

    draw();

    if (bf.iter >= bf.iterMax) {
      bf.doneRelaxations = true;
      addLog('Completed V-1 iterations. Ready to detect negative cycle.');
      renderDistTable(bf.changedInIter);
    }
  }

  function nextIteration() {
    if (!bf.running) { addLog('Initialize first.'); return; }
    if (bf.doneRelaxations) { detectNegativeCycle(); return; }
    const targetIter = Math.min(bf.iter + 1, bf.iterMax);
    while (bf.iter < targetIter) {
      stepRelaxation();
    }
  }

  function runToCompletion() {
    if (!bf.running) { addLog('Initialize first.'); return; }
    while (!bf.doneRelaxations) {
      stepRelaxation();
      // prevent UI freeze on massive graphs (but we keep simple)
    }
    detectNegativeCycle();
  }

  function stopAuto() {
    if (bf.autoTimer) {
      clearInterval(bf.autoTimer);
      bf.autoTimer = null;
      autoBtn.textContent = 'Auto-run';
      addLog('Auto-run stopped.');
    }
  }

  function autoRun() {
    if (!bf.running) { addLog('Initialize first.'); return; }
    if (bf.autoTimer) { stopAuto(); return; }
    autoBtn.textContent = 'Stop Auto';
    addLog('Auto-run started.');
    const tick = () => {
      if (!bf.running) { stopAuto(); return; }
      if (!bf.doneRelaxations) {
        stepRelaxation();
      } else {
        detectNegativeCycle();
        stopAuto();
      }
    };
    bf.autoTimer = setInterval(tick, Number(speedRange.value));
  }

  function detectNegativeCycle() {
    if (bf.negativeCycle != null) {
      addLog('Negative cycle detection already performed.');
      return;
    }
    let found = false;
    let witnessVertex = null;
    for (const e of edges) {
      const du = bf.dist[e.from];
      const dv = bf.dist[e.to];
      if (du + e.weight < dv) {
        found = true;
        witnessVertex = e.to;
        bf.lastRelaxedEdge = e.id;
        addLog(`Extra pass: edge ${nodeLabel(e.from)} → ${nodeLabel(e.to)} can still improve: ${formatDist(du)} + ${e.weight} < ${formatDist(dv)}.`);
        break;
      }
    }
    bf.negativeCycle = found;
    if (!found) {
      addLog('No negative-weight cycle detected.');
      negStatusEl.textContent = 'none';
      renderDistTable();
      draw();
      return;
    }

    negStatusEl.textContent = 'present';
    // Find a vertex in the cycle by following prev pointers V times
    const n = nodes.length;
    let y = witnessVertex;
    for (let i = 0; i < n; i++) {
      y = bf.prev[y] != null ? bf.prev[y] : y;
    }
    // Collect cycle vertices
    const cycle = [];
    let cur = y;
    const seen = new Set();
    while (!seen.has(cur)) {
      seen.add(cur);
      cycle.push(cur);
      cur = bf.prev[cur];
      if (cur == null) break; // safety
      if (cycle.length > n + 5) break;
    }
    // Close cycle up to where it repeats
    if (cur != null && seen.has(cur)) {
      const startIdx = cycle.indexOf(cur);
      const cycleVertices = cycle.slice(startIdx);
      bf.cycleVertices = cycleVertices;
      // Mark cycle edges
      bf.cycleEdges.clear();
      for (const v of cycleVertices) {
        const u = bf.prev[v];
        if (u == null) continue;
        const e = edges.find(E => E.from === u && E.to === v);
        if (e) bf.cycleEdges.add(e.id);
      }
      addLog(`Negative cycle found: ${cycleVertices.map(nodeLabel).join(' → ')} → ${nodeLabel(cycleVertices[0])}`);
    } else {
      addLog('Negative cycle indicated, but could not reconstruct cycle edges.');
    }
    renderDistTable();
    draw();
  }

  // Editing lock when running
  function disableEditingWhileRunning(running) {
    modeMoveBtn.disabled = running ? false : false; // allow moving while running? Let's lock editing modes except move
    modeAddNodeBtn.disabled = running;
    modeAddEdgeBtn.disabled = running;
    deleteSelBtn.disabled = running;
    clearGraphBtn.disabled = running;
    example1Btn.disabled = running;
    example2Btn.disabled = running;
    example3Btn.disabled = running;
  }

  // Examples
  function loadExample1() {
    clearGraph();
    // Classic graph with negative edges but no negative cycle
    const positions = [
      {x: 150, y: 100},
      {x: 350, y: 80},
      {x: 360, y: 240},
      {x: 170, y: 250},
      {x: 80, y: 180}
    ];
    for (const p of positions) createNode(p.x, p.y);
    // Edges (CLRS-style)
    addEdgeSafe(0,1,6);
    addEdgeSafe(0,3,7);
    addEdgeSafe(1,2,5);
    addEdgeSafe(1,3,8);
    addEdgeSafe(1,4,-4);
    addEdgeSafe(2,1,-2);
    addEdgeSafe(3,2,-3);
    addEdgeSafe(3,4,9);
    addEdgeSafe(4,0,2);
    addEdgeSafe(4,2,7);
    rebuildSourceSelect();
    sourceSelect.value = '0';
    addLog('Example 1 loaded (no negative cycle).');
    draw();
  }

  function loadExample2() {
    clearGraph();
    const positions = [
      {x: 140, y: 120}, // 0
      {x: 320, y: 80},  // 1
      {x: 460, y: 180}, // 2
      {x: 300, y: 280}, // 3
      {x: 140, y: 240}  // 4
    ];
    for (const p of positions) createNode(p.x, p.y);
    addEdgeSafe(0,1,1);
    addEdgeSafe(1,2,1);
    addEdgeSafe(2,3,1);
    addEdgeSafe(3,1,-4); // cycle 1->2->3->1 with total -2
    addEdgeSafe(0,4,2);
    addEdgeSafe(4,3,2);
    rebuildSourceSelect();
    sourceSelect.value = '0';
    addLog('Example 2 loaded (includes negative cycle).');
    draw();
  }

  function loadRandomSmall() {
    clearGraph();
    const count = 5;
    // Place nodes roughly in a circle
    const cx = canvas.clientWidth/2, cy = canvas.clientHeight/2, R = Math.min(cx, cy) - 120;
    for (let i = 0; i < count; i++) {
      const a = i / count * Math.PI * 2;
      const x = cx + Math.cos(a) * R;
      const y = cy + Math.sin(a) * R;
      createNode(x, y);
    }
    // Random directed edges
    const rand = (min, max) => Math.floor(Math.random()*(max-min+1))+min;
    const edgesToMake = rand(6, 8);
    for (let k = 0; k < edgesToMake; k++) {
      let u = rand(0, count-1);
      let v = rand(0, count-1);
      if (u === v) { k--; continue; }
      const w = rand(-5, 9);
      // Avoid duplicates
      if (edges.some(e => e.from === u && e.to === v)) { k--; continue; }
      addEdgeSafe(u, v, w);
    }
    rebuildSourceSelect();
    sourceSelect.value = '0';
    addLog('Random small example loaded.');
    draw();
  }

  function addEdgeSafe(u, v, w) {
    createEdge(u, v, w);
  }

  // Event handlers
  modeMoveBtn.addEventListener('click', () => setMode(Mode.Move));
  modeAddNodeBtn.addEventListener('click', () => setMode(Mode.AddNode));
  modeAddEdgeBtn.addEventListener('click', () => setMode(Mode.AddEdge));
  deleteSelBtn.addEventListener('click', deleteSelected);
  clearGraphBtn.addEventListener('click', clearGraph);

  example1Btn.addEventListener('click', loadExample1);
  example2Btn.addEventListener('click', loadExample2);
  example3Btn.addEventListener('click', loadRandomSmall);

  initBFBtn.addEventListener('click', initBF);
  resetBFBtn.addEventListener('click', resetBF);

  stepBtn.addEventListener('click', stepRelaxation);
  nextIterBtn.addEventListener('click', nextIteration);
  runAllBtn.addEventListener('click', runToCompletion);
  autoBtn.addEventListener('click', autoRun);

  // Canvas mouse interactions
  let isMouseDown = false;
  canvas.addEventListener('mousedown', (e) => {
    const pos = getMousePos(e);
    isMouseDown = true;
    const hitNode = findNodeAt(pos.x, pos.y);
    const hitEdge = hitNode ? null : findEdgeAt(pos.x, pos.y);
    if (mode === Mode.Move) {
      if (hitNode) {
        selectedNodeId = hitNode.id;
        draggingNodeId = hitNode.id;
        dragOffset.x = pos.x - hitNode.x;
        dragOffset.y = pos.y - hitNode.y;
      } else if (hitEdge) {
        selectedEdgeId = hitEdge.id;
      } else {
        resetSelection();
      }
    } else if (mode === Mode.AddNode) {
      createNode(pos.x, pos.y);
      selectedNodeId = nextNodeId - 1;
    } else if (mode === Mode.AddEdge) {
      if (pendingEdge.from == null) {
        if (hitNode) {
          pendingEdge.from = hitNode.id;
          selectedNodeId = hitNode.id;
        }
      } else {
        if (hitNode) {
          pendingEdge.to = hitNode.id;
          if (pendingEdge.to === pendingEdge.from) {
            addLog('Cannot create self-loop edge in this demo.');
          } else {
            const w = promptEdgeWeight(1);
            if (w != null) createEdge(pendingEdge.from, pendingEdge.to, w);
          }
          pendingEdge.from = null;
          pendingEdge.to = null;
          selectedNodeId = null;
        }
      }
    }
    draw();
  });

  canvas.addEventListener('mousemove', (e) => {
    const pos = getMousePos(e);
    hoverNodeId = null;
    hoverEdgeId = null;

    const hitNode = findNodeAt(pos.x, pos.y);
    const hitEdge = hitNode ? null : findEdgeAt(pos.x, pos.y);
    if (hitNode) hoverNodeId = hitNode.id;
    else if (hitEdge) hoverEdgeId = hitEdge.id;

    if (isMouseDown && draggingNodeId != null && mode === Mode.Move) {
      const n = nodeById(draggingNodeId);
      if (n) {
        n.x = pos.x - dragOffset.x;
        n.y = pos.y - dragOffset.y;
        draw();
      }
    } else {
      draw();
    }
  });

  canvas.addEventListener('mouseup', () => {
    isMouseDown = false;
    draggingNodeId = null;
  });

  canvas.addEventListener('mouseleave', () => {
    isMouseDown = false;
    draggingNodeId = null;
    hoverNodeId = null;
    hoverEdgeId = null;
    draw();
  });

  // Keyboard shortcuts for edge edit/delete
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Delete') {
      deleteSelected();
    }
    if (e.key.toLowerCase() === 'e') {
      if (selectedEdgeId != null) {
        const edge = edgeById(selectedEdgeId);
        if (!edge) return;
        const w = promptEdgeWeight(edge.weight);
        if (w != null) {
          edge.weight = w;
          addLog(`Updated edge weight: ${nodeLabel(edge.from)} → ${nodeLabel(edge.to)} = ${w}`);
          stopAuto();
          resetBF();
          draw();
        }
      }
    }
  });

  function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = evt.clientX - rect.left;
    const y = evt.clientY - rect.top;
    return { x, y };
  }

  // Initial load with example 1
  loadExample1();

  // Ensure source select updates on changes
  sourceSelect.addEventListener('change', () => {
    bf.source = Number(sourceSelect.value);
  });

  // Polyfill for roundRect if needed
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
      if (w < 2 * r) r = w / 2;
      if (h < 2 * r) r = h / 2;
      this.beginPath();
      this.moveTo(x + r, y);
      this.arcTo(x + w, y, x + w, y + h, r);
      this.arcTo(x + w, y + h, x, y + h, r);
      this.arcTo(x, y + h, x, y, r);
      this.arcTo(x, y, x + w, y, r);
      this.closePath();
      return this;
    }
  }
})();
</script>
</body>
</html>