[
  {
    "id": "4000f950-a367-11f0-ae30-3f06d99bedcc",
    "timestamp": "2025-10-07T10:20:29.925Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Array",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>JavaScript Array - Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root { color-scheme: light dark; }\n    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 0; line-height: 1.4; }\n    header { padding: 16px 20px; background: #2a5; color: #fff; }\n    h1 { margin: 0 0 6px 0; font-size: 1.6rem; }\n    .container { padding: 16px 20px; max-width: 1100px; margin: 0 auto; }\n    .grid { display: grid; gap: 14px; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }\n    .card { border: 1px solid #ccc; border-radius: 8px; padding: 12px; background: #fff; }\n    .card h2 { margin: 0 0 6px 0; font-size: 1.1rem; }\n    .card p { margin: 8px 0; }\n    .actions { margin: 10px 0; display: flex; gap: 8px; flex-wrap: wrap; }\n    button { cursor: pointer; border: 1px solid #999; background: #f5f5f5; padding: 6px 10px; border-radius: 6px; }\n    button:hover { background: #eee; }\n    pre { background: #111; color: #0f0; padding: 10px; border-radius: 6px; overflow: auto; min-height: 80px; }\n    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", monospace; }\n    .note { font-size: 0.9rem; color: #555; }\n    .items { display:flex; gap:6px; flex-wrap:wrap; }\n    .items .item { padding: 4px 8px; border: 1px solid #aaa; border-radius: 6px; }\n    footer { padding: 16px 20px; color: #555; }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>JavaScript Arrays: Interactive Examples</h1>\n    <div class=\"note\">Click the Run button in each card to see the output. This page demonstrates creation, mutation, iteration, search, transformation, flattening, typed arrays, array-like conversions, and more.</div>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"grid\">\n\n      <section class=\"card\">\n        <h2>1) Creation and Basic Access</h2>\n        <p>Arrays can hold mixed types and are zero-indexed. Use length and at() (supports negative indices).</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"basics\">Run</button>\n        </div>\n        <pre id=\"out-basics\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>2) Push/Pop/Shift/Unshift/Slice/Splice</h2>\n        <p>Mutate arrays (push/pop/shift/unshift/splice) or copy (slice).</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"mutate\">Run</button>\n        </div>\n        <pre id=\"out-mutate\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>3) fill() and copyWithin()</h2>\n        <p>In-place modification to repeat or copy segments.</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"fillCopyWithin\">Run</button>\n        </div>\n        <pre id=\"out-fillCopyWithin\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>4) Iteration</h2>\n        <p>for, for...of, and forEach for walking arrays.</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"iterate\">Run</button>\n        </div>\n        <pre id=\"out-iterate\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>5) map/filter/reduce</h2>\n        <p>Transform, narrow, and fold arrays into results.</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"mfr\">Run</button>\n        </div>\n        <pre id=\"out-mfr\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>6) Search: find/indexOf/includes/some/every</h2>\n        <p>Locate elements, test membership, or check predicates.</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"search\">Run</button>\n        </div>\n        <pre id=\"out-search\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>7) concat/spread/flat/flatMap</h2>\n        <p>Combine arrays, flatten nesting, and map+flatten in one step.</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"combine\">Run</button>\n        </div>\n        <pre id=\"out-combine\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>8) Sorting</h2>\n        <p>sort() is in-place; provide a comparator for numeric sorting.</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"sort\">Run</button>\n        </div>\n        <pre id=\"out-sort\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>9) Destructuring & Rest</h2>\n        <p>Extract positions, swap values, collect the remainder.</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"destructure\">Run</button>\n        </div>\n        <pre id=\"out-destructure\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>10) Array.from and Array.of</h2>\n        <p>Create arrays from array-like/iterables or specific values.</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"fromOf\">Run</button>\n        </div>\n        <pre id=\"out-fromOf\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>11) Array-like objects (arguments, NodeList)</h2>\n        <p>Convert array-like to true arrays to use array methods.</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"arrayLike\">Run</button>\n        </div>\n        <div class=\"items\" id=\"dom-items\">\n          <span class=\"item\">alpha</span>\n          <span class=\"item\">beta</span>\n          <span class=\"item\">gamma</span>\n        </div>\n        <pre id=\"out-arrayLike\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>12) Sparse arrays and holes</h2>\n        <p>Arrays can have holes; many methods skip them. Use fill() to set values.</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"sparse\">Run</button>\n        </div>\n        <pre id=\"out-sparse\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>13) References vs copies</h2>\n        <p>Arrays are reference types; copy explicitly with slice/spread.</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"refs\">Run</button>\n        </div>\n        <pre id=\"out-refs\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>14) Multidimensional arrays</h2>\n        <p>Work with nested arrays and flatten deeply.</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"multi\">Run</button>\n        </div>\n        <pre id=\"out-multi\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>15) Typed Arrays</h2>\n        <p>Fixed-length arrays for binary data with numeric types.</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"typed\">Run</button>\n        </div>\n        <pre id=\"out-typed\"></pre>\n      </section>\n\n      <section class=\"card\">\n        <h2>16) at(), includes(NaN), isArray</h2>\n        <p>Handy helpers for indexing, membership, and type checking.</p>\n        <div class=\"actions\">\n          <button class=\"run\" data-id=\"helpers\">Run</button>\n        </div>\n        <pre id=\"out-helpers\"></pre>\n      </section>\n\n    </div>\n  </div>\n\n  <footer class=\"container\">\n    Tip: Prefer non-mutating methods (map/filter/reduce/concat/slice/spread) when you want to preserve the original array. Mutating methods (push/pop/shift/unshift/splice/sort/reverse/fill/copyWithin) change the existing array in place.\n  </footer>\n\n  <script>\n    // Formatting helpers\n    function isTypedArray(v) {\n      return v && typeof v === 'object' && v.buffer instanceof ArrayBuffer && ArrayBuffer.isView(v);\n    }\n    function formatValue(v) {\n      const t = typeof v;\n      if (v === null) return 'null';\n      if (t === 'undefined') return 'undefined';\n      if (Array.isArray(v)) return describeArray(v);\n      if (isTypedArray(v)) return `${v.constructor.name}[${Array.prototype.join.call(v, ', ')}] length=${v.length}`;\n      if (t === 'object') {\n        try { return JSON.stringify(v); } catch { return '[object (circular)]'; }\n      }\n      if (t === 'function') return `Function(${v.name || 'anonymous'})`;\n      if (t === 'string') return `\"${v}\"`;\n      return String(v);\n    }\n    function describeArray(arr) {\n      const parts = [];\n      for (let i = 0; i < arr.length; i++) {\n        if (Object.prototype.hasOwnProperty.call(arr, i)) parts.push(`${i}:${formatValue(arr[i])}`);\n        else parts.push(`${i}:<hole>`);\n      }\n      return `[${parts.join(', ')}] length=${arr.length}`;\n    }\n    function loggerFor(pre) {\n      return (...args) => {\n        pre.textContent += args.map(formatValue).join(' ') + '\\n';\n      };\n    }\n    function clear(pre) { pre.textContent = ''; }\n\n    // Examples\n    const examples = {\n      basics(log) {\n        const arr = [1, 'two', true, { x: 3 }, [9]];\n        log('arr =', arr);\n        log('length =', arr.length);\n        log('arr[0] =', arr[0], 'arr[3].x =', arr[3].x, 'arr[4][0] =', arr[4][0]);\n        log('last element via at(-1) =', arr.at(-1));\n        arr[6] = 'gap';\n        log('after arr[6]=\"gap\":', arr);\n        log('has index 5?', Object.prototype.hasOwnProperty.call(arr, 5));\n      },\n\n      mutate(log) {\n        const a = ['a', 'b', 'c'];\n        log('start:', a);\n        a.push('d'); log('push(\"d\") ->', a);\n        const popped = a.pop(); log('pop() ->', popped, 'array:', a);\n        const shifted = a.shift(); log('shift() ->', shifted, 'array:', a);\n        a.unshift('z'); log('unshift(\"z\") ->', a);\n        a.splice(1, 1, 'B'); log('splice(1,1,\"B\") ->', a);\n        const copy = a.slice(0, 2); log('slice(0,2) ->', copy, 'original unchanged:', a);\n      },\n\n      fillCopyWithin(log) {\n        const a = [1, 2, 3, 4, 5];\n        log('start:', a);\n        a.fill(0, 2, 4); log('fill(0,2,4) ->', a);\n        a.copyWithin(0, 3); log('copyWithin(0,3) ->', a, '(copy values from index 3 to start)');\n      },\n\n      iterate(log) {\n        const a = [10, 20, 30];\n        log('for loop:');\n        for (let i = 0; i < a.length; i++) log(`i=${i}`, a[i]);\n        log('for...of:');\n        for (const v of a) log(v);\n        log('forEach with index:');\n        a.forEach((v, i) => log(`i=${i}`, v));\n      },\n\n      mfr(log) {\n        const a = [1, 2, 3, 4, 5];\n        const squares = a.map(x => x * x);\n        log('map x^2 ->', squares);\n        const evens = a.filter(x => x % 2 === 0);\n        log('filter even ->', evens);\n        const sum = a.reduce((acc, x) => acc + x, 0);\n        log('reduce sum ->', sum);\n        const words = ['apple', 'banana', 'apple', 'cherry', 'banana'];\n        const freq = words.reduce((acc, w) => (acc[w] = (acc[w] || 0) + 1, acc), {});\n        log('reduce frequency ->', freq);\n      },\n\n      search(log) {\n        const a = [3, 5, 7, 9];\n        log('array:', a);\n        log('find(x>6) ->', a.find(x => x > 6));\n        log('findIndex(x%2===0) ->', a.findIndex(x => x % 2 === 0));\n        log('indexOf(7) ->', a.indexOf(7), 'lastIndexOf(7) ->', a.lastIndexOf(7));\n        log('includes(5) ->', a.includes(5), 'includes(42) ->', a.includes(42));\n        const b = [NaN, 1, 2];\n        log('indexOf(NaN) ->', b.indexOf(NaN), 'includes(NaN) ->', b.includes(NaN));\n        log('some(x>8) ->', a.some(x => x > 8), 'every(x>0) ->', a.every(x => x > 0));\n      },\n\n      combine(log) {\n        const a = [1, 2], b = [3, 4];\n        log('concat ->', a.concat(b));\n        log('spread ->', [...a, ...b]);\n        const nested = [1, [2, [3, 4]], 5];\n        log('flat(1) ->', nested.flat(1));\n        log('flat(2) ->', nested.flat(2));\n        const words = ['hi', 'yo'];\n        log('flatMap split ->', words.flatMap(w => w.split('')));\n      },\n\n      sort(log) {\n        const nums = [10, 2, 5, 1];\n        log('original nums:', nums);\n        nums.sort(); log('sort() default (lexicographic) ->', nums);\n        nums.sort((a, b) => a - b); log('sort((a,b)=>a-b) numeric ->', nums);\n        const strs = ['z', 'ä', 'a'];\n        log('localeCompare (de) ->', strs.slice().sort((a, b) => a.localeCompare(b, 'de')));\n        const objs = [{n:3},{n:1},{n:2}];\n        objs.sort((a,b)=>a.n-b.n); log('sort by property n ->', objs);\n      },\n\n      destructure(log) {\n        const [head, ...tail] = [10, 20, 30, 40];\n        log('head:', head, 'tail:', tail);\n        let x = 1, y = 2; [x, y] = [y, x];\n        log('swap -> x:', x, 'y:', y);\n        const [a = 'default', b = 'fallback'] = [undefined];\n        log('defaults ->', a, b);\n      },\n\n      fromOf(log) {\n        log('Array.of(1,2,3) ->', Array.of(1,2,3));\n        log('Array.from(\"hello\") ->', Array.from('hello'));\n        const set = new Set([1,2,2,3]);\n        log('Array.from(new Set([1,2,2,3])) ->', Array.from(set));\n        const mapped = Array.from({ length: 5 }, (_, i) => i * 2);\n        log('Array.from({length:5}, map) ->', mapped);\n      },\n\n      arrayLike(log) {\n        function demo() {\n          log('arguments:', describeArray(arguments));\n          const arr1 = Array.from(arguments);\n          const arr2 = [...arguments];\n          log('Array.from(arguments) ->', arr1);\n          log('[...arguments] ->', arr2);\n        }\n        demo('x', 'y', 'z');\n        const nodes = document.querySelectorAll('#dom-items .item');\n        log('NodeList length:', nodes.length);\n        const texts = Array.from(nodes, n => n.textContent);\n        log('Array.from(NodeList, map text) ->', texts);\n      },\n\n      sparse(log) {\n        const a = [];\n        a[3] = 'x';\n        log('a with hole:', a);\n        log('keys:', Object.keys(a));\n        log('forEach skips holes:');\n        a.forEach((v,i)=>log(`i=${i}`, v));\n        log('map returns same length and skips holes:');\n        const m = a.map(v => String(v).toUpperCase());\n        log('mapped:', m);\n        log('fill holes:');\n        a.fill('filled');\n        log('after fill(\"filled\") ->', a);\n      },\n\n      refs(log) {\n        const a = [1,2];\n        const b = a; // same reference\n        a.push(3);\n        log('a after push ->', a, 'b sees change ->', b);\n        const c = a.slice(); // shallow copy\n        a.push(4);\n        log('a ->', a, 'c (copy) unaffected ->', c);\n        const imm = [...a, 99];\n        log('immutable update via spread ->', imm, 'original ->', a);\n      },\n\n      multi(log) {\n        const grid = [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9]\n        ];\n        log('grid:', grid);\n        const diag = [grid[0][0], grid[1][1], grid[2][2]];\n        log('diagonal ->', diag);\n        const deep = [1, [2, [3, [4]]], 5];\n        const flatAll = deep.flat(Infinity);\n        log('flat(Infinity) ->', flatAll);\n      },\n\n      typed(log) {\n        const bytes = new Uint8Array([255, 128, 1]);\n        log('typed:', bytes);\n        log('buffer bytes:', bytes.buffer.byteLength, 'length:', bytes.length);\n        bytes[0] = 42;\n        log('after set ->', bytes);\n        bytes.fill(0);\n        log('fill(0) ->', bytes);\n        const doubles = new Float32Array([0.1, 0.2, 0.3]);\n        log('float32:', doubles);\n      },\n\n      helpers(log) {\n        const a = [10, 20, 30];\n        log('a.at(-1) ->', a.at(-1));\n        log('Array.isArray(a) ->', Array.isArray(a));\n        log('Array.isArray({}) ->', Array.isArray({}));\n        const b = [NaN, 0];\n        log('b.includes(NaN) ->', b.includes(NaN));\n        log('b.indexOf(NaN) ->', b.indexOf(NaN), '(indexOf cannot find NaN)');\n      },\n    };\n\n    // Wire up buttons\n    document.querySelectorAll('button.run').forEach(btn => {\n      btn.addEventListener('click', () => {\n        const id = btn.dataset.id;\n        const pre = document.getElementById('out-' + id);\n        if (!examples[id] || !pre) return;\n        clear(pre);\n        examples[id](loggerFor(pre));\n      });\n    });\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Array"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "722d8470-a367-11f0-a0f2-0b8ed29ad08c",
    "timestamp": "2025-10-07T10:21:54.103Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Linked List",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Linked List Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f172a;\n      --panel: #111827;\n      --panel-2: #0b1220;\n      --muted: #8aa1b4;\n      --text: #e5eef6;\n      --accent: #4f46e5;\n      --accent-2: #22c55e;\n      --danger: #ef4444;\n      --warn: #eab308;\n      --node: #162238;\n      --node-border: #2d3b52;\n      --node-highlight: #0ea5e9;\n      --shadow: rgba(0,0,0,0.25);\n    }\n    * { box-sizing: border-box; }\n    body {\n      margin: 0;\n      background: radial-gradient(1200px 500px at 20% -20%, #17375a, transparent), var(--bg);\n      color: var(--text);\n      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n      min-height: 100vh;\n      display: grid;\n      grid-template-rows: auto 1fr auto;\n    }\n    header {\n      padding: 18px 20px 10px;\n    }\n    h1 {\n      font-size: 20px;\n      margin: 0;\n      letter-spacing: 0.25px;\n      display: flex;\n      align-items: center;\n      gap: 10px;\n      color: #f3f6fb;\n    }\n    h1 span.badge {\n      font-size: 12px;\n      font-weight: 600;\n      color: #a2b7cc;\n      background: #0f1c2f;\n      border: 1px solid #1f2d43;\n      padding: 2px 8px;\n      border-radius: 999px;\n    }\n    main {\n      display: grid;\n      grid-template-columns: 340px 1fr;\n      gap: 16px;\n      padding: 0 16px 16px;\n    }\n    @media (max-width: 980px) {\n      main {\n        grid-template-columns: 1fr;\n      }\n    }\n    .panel {\n      background: linear-gradient(180deg, var(--panel), var(--panel-2));\n      border: 1px solid #1c2740;\n      border-radius: 14px;\n      box-shadow: 0 20px 40px var(--shadow), inset 0 1px 0 rgba(255,255,255,0.04);\n    }\n    .controls {\n      padding: 16px;\n      display: grid;\n      gap: 14px;\n    }\n    .row {\n      display: grid;\n      grid-template-columns: 1fr 1fr;\n      gap: 10px;\n    }\n    .row-3 {\n      display: grid;\n      grid-template-columns: 1fr 1fr 1fr;\n      gap: 10px;\n    }\n    label {\n      display: block;\n      font-size: 12px;\n      color: var(--muted);\n      margin-bottom: 6px;\n    }\n    input[type=\"text\"], input[type=\"number\"] {\n      width: 100%;\n      padding: 10px 12px;\n      font-size: 14px;\n      color: var(--text);\n      background: #0d1628;\n      border: 1px solid #1b2b48;\n      border-radius: 10px;\n      outline: none;\n      transition: border 0.15s;\n    }\n    input[type=\"text\"]:focus, input[type=\"number\"]:focus {\n      border-color: #2f58a8;\n    }\n    input[type=\"range\"] {\n      width: 100%;\n      accent-color: var(--accent);\n    }\n    .btn {\n      padding: 10px 12px;\n      font-size: 14px;\n      border: 1px solid #1b2b48;\n      background: #0f1a2e;\n      color: var(--text);\n      border-radius: 10px;\n      cursor: pointer;\n      transition: transform 0.05s ease, border 0.2s, background 0.2s;\n      user-select: none;\n    }\n    .btn:hover { border-color: #2b4a86; background: #0f1d34; }\n    .btn:active { transform: translateY(1px); }\n    .btn.primary { background: linear-gradient(180deg, #2b38c5, #4f46e5); border-color: transparent; }\n    .btn.primary:hover { filter: brightness(1.05); }\n    .btn.success { background: linear-gradient(180deg, #119a48, #22c55e); border-color: transparent; color: white; }\n    .btn.warn { background: linear-gradient(180deg, #c19106, #eab308); border-color: transparent; color: #0a0f19; }\n    .btn.danger { background: linear-gradient(180deg, #b32d2d, #ef4444); border-color: transparent; color: white; }\n    .btn.ghost { background: transparent; border-color: #263551; }\n    .btn.block { width: 100%; }\n    .meta {\n      display: grid;\n      grid-template-columns: repeat(3, 1fr);\n      gap: 10px;\n    }\n    .stat {\n      background: #0d1628;\n      border: 1px solid #1b2b48;\n      border-radius: 10px;\n      padding: 10px 12px;\n    }\n    .stat .label { color: var(--muted); font-size: 12px; }\n    .stat .value { font-size: 16px; font-weight: 700; margin-top: 4px; }\n    .legend {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 8px 14px;\n      font-size: 12px;\n      color: var(--muted);\n      padding: 0 16px 12px 16px;\n    }\n    .key { display: inline-flex; align-items: center; gap: 6px; }\n    .swatch {\n      width: 12px; height: 12px; border-radius: 3px; border: 1px solid #23334f;\n    }\n    .swatch.node { background: var(--node); }\n    .swatch.highlight { background: var(--node-highlight); border-color: #1f6aa0; }\n    .swatch.arrow { background: #2b3d61; }\n    .vis-wrap {\n      padding: 14px;\n      overflow: auto;\n    }\n    .vis {\n      background: radial-gradient(400px 200px at 80% -20%, #1a2e51, transparent), #0b1220;\n      border: 1px solid #122038;\n      border-radius: 12px;\n      min-height: 160px;\n      position: relative;\n      overflow: auto;\n    }\n    svg {\n      display: block;\n      width: 100%;\n      height: 100%;\n      min-height: 160px;\n    }\n    .node rect {\n      fill: var(--node);\n      stroke: var(--node-border);\n      stroke-width: 1.5px;\n      filter: drop-shadow(0 4px 8px rgba(0,0,0,.35));\n    }\n    .node text {\n      fill: #e9f0f9;\n      font-size: 14px;\n      font-weight: 600;\n    }\n    .node .index {\n      fill: #8aa1b4;\n      font-size: 11px;\n      font-weight: 500;\n    }\n    .node.head rect { stroke: #22c55e; }\n    .node.tail rect { stroke: #eab308; }\n    .node.highlight rect { stroke: var(--node-highlight); stroke-width: 2.5px; }\n    .arrow {\n      stroke: #3b4e77;\n      stroke-width: 2;\n      fill: none;\n      marker-end: url(#arrow);\n      opacity: 0.9;\n    }\n    .null-label {\n      fill: #93a4ba;\n      font-size: 12px;\n      font-weight: 600;\n      opacity: 0.9;\n    }\n    .oplog {\n      padding: 12px 16px 16px;\n      border-top: 1px solid #18243a;\n      color: var(--muted);\n      font-size: 13px;\n      display: grid;\n      gap: 8px;\n    }\n    .oplog .line { color: #c3d3e3; }\n    .chip {\n      display: inline-flex;\n      align-items: center;\n      gap: 6px;\n      padding: 4px 8px;\n      border-radius: 999px;\n      background: #0e1b2e;\n      border: 1px solid #1b2b48;\n      color: #bbcae0;\n      font-size: 12px;\n      font-weight: 600;\n    }\n    .chip .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--accent); }\n    footer {\n      color: var(--muted);\n      font-size: 12px;\n      padding: 10px 16px 18px;\n      display: flex;\n      justify-content: space-between;\n      gap: 10px;\n      flex-wrap: wrap;\n    }\n    .small {\n      font-size: 11px;\n      color: #8aa1b4;\n    }\n    .hr {\n      height: 1px;\n      background: #1a2740;\n      margin: 0 16px;\n    }\n  </style>\n</head>\n<body>\n<header>\n  <h1>\n    Linked List Visualizer\n    <span class=\"badge\">Singly • Head/Tail • O(1) append/prepend</span>\n  </h1>\n</header>\n\n<main>\n  <section class=\"panel\">\n    <div class=\"controls\">\n      <div class=\"row\">\n        <div>\n          <label for=\"valInput\">Value</label>\n          <input id=\"valInput\" type=\"text\" placeholder=\"e.g. 42 or Alice\" />\n        </div>\n        <div>\n          <label for=\"idxInput\">Index</label>\n          <input id=\"idxInput\" type=\"number\" min=\"0\" step=\"1\" placeholder=\"0-based\" />\n        </div>\n      </div>\n\n      <div class=\"row-3\">\n        <button id=\"prependBtn\" class=\"btn\">Prepend</button>\n        <button id=\"appendBtn\" class=\"btn\">Append</button>\n        <button id=\"insertBtn\" class=\"btn\">Insert at Index</button>\n      </div>\n      <div class=\"row-3\">\n        <button id=\"removeValBtn\" class=\"btn\">Remove Value</button>\n        <button id=\"removeIdxBtn\" class=\"btn\">Remove at Index</button>\n        <button id=\"searchBtn\" class=\"btn\">Search</button>\n      </div>\n      <div class=\"row-3\">\n        <button id=\"reverseBtn\" class=\"btn success\">Reverse</button>\n        <button id=\"seedBtn\" class=\"btn ghost\">Seed Data</button>\n        <button id=\"clearBtn\" class=\"btn danger\">Clear</button>\n      </div>\n\n      <div class=\"row\">\n        <div>\n          <label for=\"speed\">Animation Speed (ms between steps)</label>\n          <input id=\"speed\" type=\"range\" min=\"50\" max=\"1000\" value=\"300\" />\n        </div>\n        <div>\n          <label>Complexity (last operation)</label>\n          <div id=\"complexity\" class=\"chip\">\n            <span class=\"dot\"></span>\n            <span>—</span>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"meta\">\n        <div class=\"stat\">\n          <div class=\"label\">Length</div>\n          <div class=\"value\" id=\"lenStat\">0</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"label\">Head</div>\n          <div class=\"value\" id=\"headStat\">null</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"label\">Tail</div>\n          <div class=\"value\" id=\"tailStat\">null</div>\n        </div>\n      </div>\n    </div>\n    <div class=\"legend\">\n      <span class=\"key\"><span class=\"swatch node\"></span> Node</span>\n      <span class=\"key\"><span class=\"swatch highlight\"></span> Traversal highlight</span>\n      <span class=\"key\"><span class=\"swatch arrow\"></span> Next pointer</span>\n    </div>\n    <div class=\"vis-wrap\">\n      <div id=\"vis\" class=\"vis\">\n        <svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\">\n          <defs>\n            <marker id=\"arrow\" viewBox=\"0 0 10 10\" refX=\"9\" refY=\"5\" markerWidth=\"8\" markerHeight=\"8\" orient=\"auto-start-reverse\">\n              <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#3b4e77\"></path>\n            </marker>\n          </defs>\n        </svg>\n      </div>\n    </div>\n    <div class=\"oplog\">\n      <div class=\"line\" id=\"opText\">Ready.</div>\n      <div class=\"small\">Tip: Use Insert at Index to place a value at a specific position. Index 0 means the head. Append is O(1) thanks to the tail pointer.</div>\n    </div>\n  </section>\n\n  <section class=\"panel\">\n    <div class=\"controls\">\n      <div>\n        <div class=\"chip\"><span class=\"dot\" style=\"background: var(--accent-2)\"></span>What is a Linked List?</div>\n        <p class=\"small\">\n          A linked list is a sequence of nodes where each node holds a value and a reference (pointer) to the next node.\n          Unlike arrays, linked lists do not require contiguous memory, making insertions/removals efficient at the front (O(1))\n          and at known positions if you have a pointer. Random access is not supported; searching and indexing require traversal (O(n)).\n        </p>\n      </div>\n      <div class=\"hr\"></div>\n      <div class=\"row\">\n        <div class=\"stat\">\n          <div class=\"label\">Prepend</div>\n          <div class=\"value\">O(1)</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"label\">Append</div>\n          <div class=\"value\">O(1) with tail</div>\n        </div>\n      </div>\n      <div class=\"row\">\n        <div class=\"stat\">\n          <div class=\"label\">Search / Find</div>\n          <div class=\"value\">O(n)</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"label\">Remove by value</div>\n          <div class=\"value\">O(n)</div>\n        </div>\n      </div>\n      <div class=\"row\">\n        <div class=\"stat\">\n          <div class=\"label\">Insert at index</div>\n          <div class=\"value\">O(n)</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"label\">Remove at index</div>\n          <div class=\"value\">O(n)</div>\n        </div>\n      </div>\n      <div class=\"row\">\n        <div class=\"stat\">\n          <div class=\"label\">Reverse</div>\n          <div class=\"value\">O(n) time, O(1) space</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"label\">Clear</div>\n          <div class=\"value\">O(1)</div>\n        </div>\n      </div>\n      <div class=\"hr\"></div>\n      <div class=\"small\">\n        Implementation details in this demo:\n        - Singly linked list, storing head and tail references.\n        - Append is constant time using the tail pointer.\n        - Values are treated as strings for display.\n      </div>\n    </div>\n  </section>\n</main>\n\n<footer>\n  <div>Keyboard: Enter on value = append; Shift+Enter = prepend</div>\n  <div>Animation speed slider controls traversal delay.</div>\n</footer>\n\n<script>\n  // Data structures: Node and LinkedList\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  class LinkedList {\n    constructor() {\n      this.head = null;\n      this.tail = null;\n      this.length = 0;\n    }\n\n    isEmpty() {\n      return this.length === 0;\n    }\n\n    prepend(value) {\n      const node = new Node(value);\n      if (this.isEmpty()) {\n        this.head = this.tail = node;\n      } else {\n        node.next = this.head;\n        this.head = node;\n      }\n      this.length++;\n      return node;\n    }\n\n    append(value) {\n      const node = new Node(value);\n      if (this.isEmpty()) {\n        this.head = this.tail = node;\n      } else {\n        this.tail.next = node;\n        this.tail = node;\n      }\n      this.length++;\n      return node;\n    }\n\n    insertAt(index, value) {\n      if (index < 0 || index > this.length) {\n        return { ok: false, reason: \"Index out of bounds\" };\n      }\n      if (index === 0) {\n        this.prepend(value);\n        return { ok: true, where: \"head\" };\n      }\n      if (index === this.length) {\n        this.append(value);\n        return { ok: true, where: \"tail\" };\n      }\n      const node = new Node(value);\n      let prev = this.head;\n      for (let i = 0; i < index - 1; i++) {\n        prev = prev.next;\n      }\n      node.next = prev.next;\n      prev.next = node;\n      this.length++;\n      return { ok: true, where: \"middle\" };\n    }\n\n    remove(value) {\n      if (this.isEmpty()) return { ok: false, removed: null };\n      // Remove head case\n      if (this.head.value == value) {\n        const removed = this.head;\n        this.head = this.head.next;\n        if (!this.head) this.tail = null;\n        this.length--;\n        return { ok: true, removed, index: 0 };\n      }\n      let prev = this.head;\n      let idx = 0;\n      while (prev && prev.next) {\n        idx++;\n        if (prev.next.value == value) {\n          const removed = prev.next;\n          prev.next = removed.next;\n          if (removed === this.tail) this.tail = prev;\n          this.length--;\n          return { ok: true, removed, index: idx };\n        }\n        prev = prev.next;\n      }\n      return { ok: false, removed: null };\n    }\n\n    removeAt(index) {\n      if (index < 0 || index >= this.length) return { ok: false, removed: null, reason: \"Index out of bounds\" };\n      if (index === 0) {\n        const removed = this.head;\n        this.head = this.head.next;\n        if (!this.head) this.tail = null;\n        this.length--;\n        return { ok: true, removed, index: 0 };\n      }\n      let prev = this.head;\n      for (let i = 0; i < index - 1; i++) prev = prev.next;\n      const removed = prev.next;\n      prev.next = removed.next;\n      if (removed === this.tail) this.tail = prev;\n      this.length--;\n      return { ok: true, removed, index };\n    }\n\n    find(value) {\n      let cur = this.head;\n      let i = 0;\n      while (cur) {\n        if (cur.value == value) return { ok: true, index: i, node: cur };\n        cur = cur.next;\n        i++;\n      }\n      return { ok: false, index: -1, node: null };\n    }\n\n    reverse() {\n      let prev = null;\n      let cur = this.head;\n      this.tail = this.head;\n      while (cur) {\n        const next = cur.next;\n        cur.next = prev;\n        prev = cur;\n        cur = next;\n      }\n      this.head = prev;\n      return true;\n    }\n\n    clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n\n    toArray() {\n      const arr = [];\n      let cur = this.head;\n      while (cur) {\n        arr.push(cur.value);\n        cur = cur.next;\n      }\n      return arr;\n    }\n  }\n\n  // UI/Visualization controller\n  const list = new LinkedList();\n\n  const svg = document.getElementById('svg');\n  const vis = document.getElementById('vis');\n  const valInput = document.getElementById('valInput');\n  const idxInput = document.getElementById('idxInput');\n  const speedInput = document.getElementById('speed');\n  const prependBtn = document.getElementById('prependBtn');\n  const appendBtn = document.getElementById('appendBtn');\n  const insertBtn = document.getElementById('insertBtn');\n  const removeValBtn = document.getElementById('removeValBtn');\n  const removeIdxBtn = document.getElementById('removeIdxBtn');\n  const searchBtn = document.getElementById('searchBtn');\n  const reverseBtn = document.getElementById('reverseBtn');\n  const seedBtn = document.getElementById('seedBtn');\n  const clearBtn = document.getElementById('clearBtn');\n\n  const lenStat = document.getElementById('lenStat');\n  const headStat = document.getElementById('headStat');\n  const tailStat = document.getElementById('tailStat');\n  const opText = document.getElementById('opText');\n  const complexity = document.getElementById('complexity');\n\n  const NODE_W = 90;\n  const NODE_H = 44;\n  const GAP = 42;\n  const MARGIN_X = 24;\n  const MARGIN_Y = 30;\n\n  function setOp(text, complexityText) {\n    opText.textContent = text;\n    complexity.querySelector('span:last-child').textContent = complexityText || '—';\n  }\n\n  function updateStats() {\n    lenStat.textContent = list.length;\n    headStat.textContent = list.head ? stringify(list.head.value) : 'null';\n    tailStat.textContent = list.tail ? stringify(list.tail.value) : 'null';\n  }\n\n  function stringify(v) {\n    return String(v);\n  }\n\n  function clearSVG() {\n    while (svg.firstChild) {\n      svg.removeChild(svg.firstChild);\n    }\n    // Re-add defs\n    const defs = document.createElementNS(\"http://www.w3.org/2000/svg\", \"defs\");\n    const marker = document.createElementNS(\"http://www.w3.org/2000/svg\", \"marker\");\n    marker.setAttribute('id', 'arrow');\n    marker.setAttribute('viewBox', '0 0 10 10');\n    marker.setAttribute('refX', '9');\n    marker.setAttribute('refY', '5');\n    marker.setAttribute('markerWidth', '8');\n    marker.setAttribute('markerHeight', '8');\n    marker.setAttribute('orient', 'auto-start-reverse');\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');\n    path.setAttribute('fill', '#3b4e77');\n    marker.appendChild(path);\n    defs.appendChild(marker);\n    svg.appendChild(defs);\n  }\n\n  function render() {\n    clearSVG();\n\n    const arr = list.toArray();\n    const totalW = arr.length === 0 ? vis.clientWidth : MARGIN_X * 2 + arr.length * NODE_W + Math.max(0, arr.length - 1) * GAP + 60;\n    const viewW = Math.max(totalW, vis.clientWidth);\n    const viewH = Math.max(160, NODE_H + MARGIN_Y * 2);\n\n    svg.setAttribute('width', viewW);\n    svg.setAttribute('height', viewH);\n\n    // Draw nodes and arrows\n    for (let i = 0; i < arr.length; i++) {\n      const x = MARGIN_X + i * (NODE_W + GAP);\n      const y = (viewH - NODE_H) / 2;\n\n      // Group\n      const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      g.classList.add('node');\n      g.setAttribute('data-index', String(i));\n      if (i === 0) g.classList.add('head');\n      if (i === arr.length - 1) g.classList.add('tail');\n\n      // Rect\n      const rect = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n      rect.setAttribute('x', x);\n      rect.setAttribute('y', y);\n      rect.setAttribute('rx', 10);\n      rect.setAttribute('ry', 10);\n      rect.setAttribute('width', NODE_W);\n      rect.setAttribute('height', NODE_H);\n      g.appendChild(rect);\n\n      // Value text\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      text.setAttribute('x', x + NODE_W / 2);\n      text.setAttribute('y', y + NODE_H / 2 + 5);\n      text.setAttribute('text-anchor', 'middle');\n      text.textContent = stringify(arr[i]);\n      g.appendChild(text);\n\n      // Index label\n      const idx = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      idx.setAttribute('x', x + 8);\n      idx.setAttribute('y', y - 8);\n      idx.setAttribute('class', 'index');\n      idx.textContent = `#${i}`;\n      g.appendChild(idx);\n\n      svg.appendChild(g);\n\n      // Arrow to next\n      if (i < arr.length - 1) {\n        const x1 = x + NODE_W;\n        const y1 = y + NODE_H / 2;\n        const x2 = x + NODE_W + GAP - 12;\n        const y2 = y + NODE_H / 2;\n\n        const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute('class', 'arrow');\n        const mid = (x1 + x2) / 2;\n        const d = `M ${x1} ${y1} C ${mid} ${y1 - 10}, ${mid} ${y2 + 10}, ${x2} ${y2}`;\n        path.setAttribute('d', d);\n        svg.appendChild(path);\n      } else {\n        // null label\n        const t = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n        t.setAttribute('class', 'null-label');\n        t.setAttribute('x', x + NODE_W + 18);\n        t.setAttribute('y', y + NODE_H / 2 + 5);\n        t.textContent = 'null';\n        svg.appendChild(t);\n      }\n    }\n\n    updateStats();\n  }\n\n  function getNodeElemByIndex(i) {\n    return svg.querySelector(`.node[data-index=\"${i}\"]`);\n  }\n\n  function delay(ms) {\n    return new Promise(res => setTimeout(res, ms));\n  }\n\n  function setDisabled(disabled) {\n    const controls = [prependBtn, appendBtn, insertBtn, removeValBtn, removeIdxBtn, searchBtn, reverseBtn, seedBtn, clearBtn, valInput, idxInput];\n    controls.forEach(el => el.disabled = disabled);\n    controls.forEach(el => {\n      if (disabled) {\n        el.style.opacity = 0.7;\n        el.style.cursor = 'not-allowed';\n      } else {\n        el.style.opacity = 1;\n        el.style.cursor = 'pointer';\n      }\n    });\n  }\n\n  async function highlightTraversal(indices, options = {}) {\n    const { foundIndex = -1, finalOnly = false } = options;\n    const ms = Number(speedInput.value);\n    if (finalOnly && foundIndex >= 0) {\n      const el = getNodeElemByIndex(foundIndex);\n      if (el) {\n        el.classList.add('highlight');\n        await delay(ms);\n        el.classList.remove('highlight');\n      }\n      return;\n    }\n\n    for (let i = 0; i < indices.length; i++) {\n      const el = getNodeElemByIndex(indices[i]);\n      if (el) el.classList.add('highlight');\n      await delay(ms);\n      if (el && i !== indices.length - 1) el.classList.remove('highlight');\n    }\n    // Leave last highlighted briefly\n    await delay(ms / 2);\n    const last = getNodeElemByIndex(indices[indices.length - 1]);\n    if (last) last.classList.remove('highlight');\n  }\n\n  // Actions\n  prependBtn.addEventListener('click', async () => {\n    const v = readValue();\n    if (v == null) return;\n    setDisabled(true);\n    list.prepend(v);\n    setOp(`Prepend ${stringify(v)} at head.`, 'O(1)');\n    render();\n    await highlightTraversal([0], { finalOnly: true });\n    setDisabled(false);\n  });\n\n  appendBtn.addEventListener('click', async () => {\n    const v = readValue();\n    if (v == null) return;\n    setDisabled(true);\n    const oldLen = list.length;\n    list.append(v);\n    setOp(`Append ${stringify(v)} at tail.`, 'O(1) with tail pointer');\n    render();\n    await highlightTraversal([oldLen], { finalOnly: true });\n    setDisabled(false);\n  });\n\n  insertBtn.addEventListener('click', async () => {\n    const v = readValue();\n    if (v == null) return;\n    const idx = readIndexInsert();\n    if (idx == null) return;\n    setDisabled(true);\n\n    // Animate traversal to index - 1 if middle\n    let complexityText = 'O(n)';\n    if (idx === 0) complexityText = 'O(1) (insert at head)';\n    else if (idx === list.length) complexityText = 'O(1) (insert at tail)';\n    setOp(`Insert ${stringify(v)} at index ${idx}.`, complexityText);\n\n    if (idx > 0 && idx < list.length) {\n      render();\n      const indices = Array.from({ length: idx }, (_, i) => i);\n      await highlightTraversal(indices);\n    }\n\n    const res = list.insertAt(idx, v);\n    if (!res.ok) {\n      setOp(`Insert failed: ${res.reason}`, '—');\n    }\n    render();\n    await highlightTraversal([idx], { finalOnly: true });\n    setDisabled(false);\n  });\n\n  removeValBtn.addEventListener('click', async () => {\n    const v = readValue();\n    if (v == null) return;\n    setDisabled(true);\n    setOp(`Remove first occurrence of value ${stringify(v)}.`, 'O(n)');\n    // animate traversal until found\n    const idx = indexOfValue(v);\n    render();\n    if (idx >= 0) {\n      const indices = Array.from({ length: idx + 1 }, (_, i) => i);\n      await highlightTraversal(indices);\n      const res = list.remove(v);\n      if (res.ok) setOp(`Removed value ${stringify(v)} at index ${res.index}.`, 'O(n)');\n    } else {\n      await highlightTraversal(Array.from({ length: list.length }, (_, i) => i));\n      setOp(`Value ${stringify(v)} not found.`, 'O(n)');\n    }\n    render();\n    setDisabled(false);\n  });\n\n  removeIdxBtn.addEventListener('click', async () => {\n    const idx = readIndexExisting();\n    if (idx == null) return;\n    setDisabled(true);\n    const complexityText = idx === 0 ? 'O(1) (remove head)' : 'O(n)';\n    setOp(`Remove at index ${idx}.`, complexityText);\n    // animate traversal to index\n    render();\n    if (idx > 0) {\n      const indices = Array.from({ length: idx + 1 }, (_, i) => i);\n      await highlightTraversal(indices);\n    } else {\n      await highlightTraversal([0], { finalOnly: true });\n    }\n    const res = list.removeAt(idx);\n    if (!res.ok) {\n      setOp(`Remove failed: ${res.reason}`, '—');\n    } else {\n      setOp(`Removed value ${stringify(res.removed.value)} from index ${idx}.`, complexityText);\n    }\n    render();\n    setDisabled(false);\n  });\n\n  searchBtn.addEventListener('click', async () => {\n    const v = readValue();\n    if (v == null) return;\n    setDisabled(true);\n    setOp(`Search for value ${stringify(v)}.`, 'O(n)');\n    render();\n    const idx = indexOfValue(v);\n    if (idx >= 0) {\n      await highlightTraversal(Array.from({ length: idx + 1 }, (_, i) => i));\n      setOp(`Found ${stringify(v)} at index ${idx}.`, 'O(n)');\n    } else {\n      await highlightTraversal(Array.from({ length: list.length }, (_, i) => i));\n      setOp(`${stringify(v)} not found.`, 'O(n)');\n    }\n    setDisabled(false);\n  });\n\n  reverseBtn.addEventListener('click', async () => {\n    if (list.length <= 1) {\n      setOp('Reverse: no effect on empty or single-element list.', 'O(1)');\n      return;\n    }\n    setDisabled(true);\n    setOp('Reverse the list in-place using three pointers.', 'O(n) time, O(1) space');\n    // simple highlight from head to tail to indicate traversal\n    render();\n    await highlightTraversal(Array.from({ length: list.length }, (_, i) => i));\n    list.reverse();\n    render();\n    // highlight new head\n    await highlightTraversal([0], { finalOnly: true });\n    setDisabled(false);\n  });\n\n  seedBtn.addEventListener('click', async () => {\n    setDisabled(true);\n    list.clear();\n    const samples = ['A', 'B', 'C', 'D'];\n    for (const s of samples) list.append(s);\n    render();\n    setOp('Seeded list with A → B → C → D', '—');\n    setDisabled(false);\n  });\n\n  clearBtn.addEventListener('click', async () => {\n    setDisabled(true);\n    list.clear();\n    render();\n    setOp('Cleared list (set head and tail to null).', 'O(1)');\n    setDisabled(false);\n  });\n\n  // Helpers\n  function readValue() {\n    const v = valInput.value;\n    if (v === null || v === undefined || v === '') {\n      flashInput(valInput, true);\n      setOp('Please enter a value.', '—');\n      return null;\n    }\n    return v;\n  }\n\n  function readIndexInsert() {\n    const raw = idxInput.value;\n    const idx = Number(raw);\n    if (!raw.length || Number.isNaN(idx)) {\n      flashInput(idxInput, true);\n      setOp('Please enter a valid index.', '—');\n      return null;\n    }\n    if (idx < 0 || idx > list.length) {\n      flashInput(idxInput, true);\n      setOp(`Index must be between 0 and ${list.length}.`, '—');\n      return null;\n    }\n    return idx;\n    }\n\n  function readIndexExisting() {\n    const raw = idxInput.value;\n    const idx = Number(raw);\n    if (!raw.length || Number.isNaN(idx)) {\n      flashInput(idxInput, true);\n      setOp('Please enter a valid index.', '—');\n      return null;\n    }\n    if (idx < 0 || idx >= list.length) {\n      flashInput(idxInput, true);\n      setOp(`Index must be between 0 and ${Math.max(0, list.length - 1)}.`, '—');\n      return null;\n    }\n    return idx;\n  }\n\n  function flashInput(el, danger) {\n    const old = el.style.borderColor;\n    el.style.borderColor = danger ? '#ef4444' : '#22c55e';\n    setTimeout(() => { el.style.borderColor = old || '#1b2b48'; }, 500);\n  }\n\n  function indexOfValue(v) {\n    let cur = list.head;\n    let i = 0;\n    while (cur) {\n      if (cur.value == v) return i;\n      cur = cur.next;\n      i++;\n    }\n    return -1;\n  }\n\n  // Keyboard shortcuts\n  valInput.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      appendBtn.click();\n    } else if (e.key === 'Enter' && e.shiftKey) {\n      prependBtn.click();\n    }\n  });\n\n  // Initial render with demo data\n  (function init() {\n    list.append(10);\n    list.append(20);\n    list.append(30);\n    render();\n    setOp('Ready. Seeded with 10 → 20 → 30', '—');\n  })();\n\n  // Re-render on resize to keep centering/widths decent\n  window.addEventListener('resize', () => render());\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Linked List"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "96ec4170-a367-11f0-92cf-a34e6c34a8cb",
    "timestamp": "2025-10-07T10:22:55.751Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Stack",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<title>Stack (LIFO) Interactive Demo</title>\n<style>\n  :root{\n    --bg:#0f1320;\n    --panel:#141a2b;\n    --accent:#4cc9f0;\n    --accent2:#ffafcc;\n    --text:#e6eef7;\n    --muted:#99a4b3;\n    --danger:#ff6b6b;\n    --success:#80ffdb;\n    --item:#1d2540;\n    --itemBorder:#2a355e;\n    --green:#3bd671;\n    --yellow:#ffd166;\n  }\n  *{box-sizing:border-box}\n  html,body{height:100%}\n  body{\n    margin:0;\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\",\"Segoe UI Emoji\";\n    color:var(--text);\n    background: radial-gradient(80% 120% at 100% 0%, #0b1020 0%, var(--bg) 45%, #0c1222 100%);\n  }\n  a{color:var(--accent)}\n  .app{\n    max-width:1100px;\n    margin:0 auto;\n    padding:24px;\n  }\n  header{\n    display:flex;\n    align-items:flex-start;\n    gap:16px;\n    margin-bottom:18px;\n  }\n  h1{\n    font-size:28px;\n    margin:0;\n    letter-spacing:.2px;\n  }\n  .subtitle{\n    color:var(--muted);\n    font-size:14px;\n    max-width:800px;\n    line-height:1.4;\n  }\n\n  .grid{\n    display:grid;\n    grid-template-columns: 1.1fr .9fr;\n    gap:20px;\n  }\n  .card{\n    background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n    border:1px solid #1e2644;\n    border-radius:14px;\n    padding:16px;\n    box-shadow: 0 10px 20px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);\n  }\n  .card h2{\n    margin:0 0 10px 0;\n    font-size:18px;\n  }\n\n  /* Controls */\n  .controls{\n    display:flex;\n    gap:8px;\n    flex-wrap:wrap;\n    align-items:center;\n    margin-bottom:12px;\n  }\n  .controls input{\n    background:var(--panel);\n    border:1px solid #243057;\n    color:var(--text);\n    padding:10px 12px;\n    border-radius:10px;\n    min-width:180px;\n    outline:none;\n  }\n  .btn{\n    border:1px solid #243057;\n    background:linear-gradient(180deg, #1b2340, #151b31);\n    color:var(--text);\n    padding:10px 12px;\n    border-radius:10px;\n    cursor:pointer;\n    transition:transform .08s ease, box-shadow .08s ease, background .2s ease;\n    user-select:none;\n    font-weight:600;\n    font-size:14px;\n  }\n  .btn:hover{transform:translateY(-1px)}\n  .btn:active{transform:translateY(0)}\n  .btn.primary{\n    border-color:#275b7a;\n    background:linear-gradient(180deg, #1b3143, #152233);\n    color:#dff7ff;\n  }\n  .btn.danger{\n    border-color:#64333a;\n    background:linear-gradient(180deg, #2b1920, #1c1217);\n    color:#ffe9ed;\n  }\n  .btn.ghost{\n    background:transparent;\n  }\n  .mini{\n    font-size:12px;\n    padding:6px 9px;\n    border-radius:8px;\n  }\n\n  /* Stack visualization */\n  .stackWrap{\n    display:grid;\n    grid-template-columns: 1fr 220px;\n    gap:14px;\n  }\n  .stack{\n    position:relative;\n    height:380px;\n    border:1px dashed #2a355e;\n    border-radius:14px;\n    background:\n      repeating-linear-gradient(180deg, rgba(255,255,255,0.03) 0, rgba(255,255,255,0.03) 2px, transparent 2px, transparent 26px),\n      linear-gradient(180deg, rgba(76,201,240,0.06), rgba(0,0,0,0));\n    padding:14px;\n    overflow:hidden;\n  }\n  .stackInner{\n    height:100%;\n    display:flex;\n    flex-direction:column-reverse; /* Latest appended shown at top */\n    align-items:center;\n    gap:8px;\n  }\n  .item{\n    width:75%;\n    max-width:360px;\n    min-height:40px;\n    background:linear-gradient(180deg, var(--item), #131a32);\n    border:1px solid var(--itemBorder);\n    border-radius:10px;\n    display:flex;\n    align-items:center;\n    justify-content:center;\n    color:#d9e6ff;\n    font-weight:700;\n    letter-spacing:.2px;\n    box-shadow: 0 6px 12px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.04);\n    transition: transform .22s cubic-bezier(.2,.8,.2,1), opacity .22s ease, box-shadow .22s ease;\n  }\n  .item.enter{\n    transform: translateY(-24px) scale(.96);\n    opacity:0;\n  }\n  .item.leave{\n    transform: translateY(-30px) scale(.94);\n    opacity:0;\n  }\n  .item.peek{\n    box-shadow: 0 0 0 2px var(--accent), 0 10px 20px rgba(76,201,240,.25), inset 0 1px 0 rgba(255,255,255,.08);\n  }\n\n  .labels{\n    position:absolute;\n    left:12px;\n    right:12px;\n    pointer-events:none;\n  }\n  .labels .top{\n    position:absolute;\n    top:4px;\n    left:4px;\n    display:flex;\n    align-items:center;\n    gap:6px;\n    color:#cdefff;\n    font-size:12px;\n    background:rgba(76,201,240,.08);\n    border:1px solid rgba(76,201,240,.3);\n    border-radius:8px;\n    padding:4px 8px;\n  }\n  .labels .bottom{\n    position:absolute;\n    bottom:6px;\n    left:4px;\n    display:inline-block;\n    color:#fcefff;\n    font-size:12px;\n    background:rgba(255,175,204,.08);\n    border:1px solid rgba(255,175,204,.3);\n    border-radius:8px;\n    padding:4px 8px;\n  }\n  .emptyMsg{\n    position:absolute;\n    inset:0;\n    display:flex;\n    align-items:center;\n    justify-content:center;\n    color:var(--muted);\n    font-size:14px;\n    opacity:.8;\n    pointer-events:none;\n  }\n\n  /* Side panel */\n  .stats{\n    display:grid;\n    gap:10px;\n  }\n  .kv{\n    display:flex;\n    justify-content:space-between;\n    padding:8px 10px;\n    border:1px solid #223059;\n    border-radius:10px;\n    background:linear-gradient(180deg, #131a2b, #101524);\n    font-size:13px;\n  }\n  .kv .value{font-weight:700;color:#cfe8ff}\n  .bigO{\n    display:grid;\n    gap:6px;\n    font-size:13px;\n  }\n  .bigO .row{\n    display:flex;\n    justify-content:space-between;\n    padding:6px 10px;\n    border:1px dashed #263254;\n    border-radius:8px;\n    color:#cfe8ff;\n    background:rgba(255,255,255,.02);\n  }\n  .row .op{color:#a9c4ff}\n  .row .o{color:#80ffdb;font-weight:700}\n\n  /* Log */\n  .log{\n    list-style:none;\n    margin:10px 0 0 0;\n    padding:0;\n    max-height:140px;\n    overflow:auto;\n    border:1px solid #223059;\n    border-radius:10px;\n    background:linear-gradient(180deg, #0f1528, #0d1220);\n  }\n  .log li{\n    display:flex;\n    justify-content:space-between;\n    gap:8px;\n    padding:8px 10px;\n    border-bottom:1px solid rgba(255,255,255,.05);\n    font-size:12px;\n    color:#cfe3ff;\n  }\n  .log li:last-child{border-bottom:none}\n  .log .time{color:#7fa3d1}\n  .log .desc{font-weight:600}\n\n  /* Examples */\n  .examples{\n    display:grid;\n    grid-template-columns: 1fr 1fr;\n    gap:16px;\n  }\n  .exBox .controls{\n    margin:8px 0 0 0;\n  }\n  .result{\n    margin-top:8px;\n    background:linear-gradient(180deg,#12182c,#0f1424);\n    border:1px solid #223059;\n    border-radius:10px;\n    padding:10px;\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n    font-size:13px;\n    color:#d9edff;\n    min-height:38px;\n    word-break:break-word;\n  }\n\n  /* Toast */\n  .toast{\n    position:fixed;\n    bottom:16px;\n    left:50%;\n    transform:translateX(-50%);\n    background:#162038;\n    color:#d9edff;\n    border:1px solid #2a355e;\n    border-radius:10px;\n    box-shadow: 0 10px 20px rgba(0,0,0,.4);\n    padding:10px 14px;\n    opacity:0;\n    pointer-events:none;\n    transition: opacity .2s ease, transform .2s ease;\n  }\n  .toast.show{\n    opacity:1;\n    transform:translateX(-50%) translateY(-4px);\n  }\n\n  @media (max-width: 980px){\n    .grid{grid-template-columns: 1fr}\n    .stackWrap{grid-template-columns: 1fr}\n    .examples{grid-template-columns: 1fr}\n  }\n</style>\n</head>\n<body>\n<div class=\"app\">\n  <header>\n    <div>\n      <h1>Stack (LIFO) Interactive Demo</h1>\n      <div class=\"subtitle\">\n        A stack is a Last-In, First-Out structure. You push values onto the top and pop them off from the top. This page lets you interact with a stack, visualize operations, and see two classic applications: reversing a string and checking balanced parentheses.\n      </div>\n    </div>\n  </header>\n\n  <div class=\"grid\">\n\n    <section class=\"card\">\n      <h2>Play with the Stack</h2>\n      <div class=\"controls\">\n        <input id=\"valueInput\" type=\"text\" placeholder=\"Enter a value to push\">\n        <button class=\"btn primary\" id=\"pushBtn\">Push</button>\n        <button class=\"btn\" id=\"popBtn\">Pop</button>\n        <button class=\"btn\" id=\"peekBtn\">Peek</button>\n        <button class=\"btn ghost mini\" id=\"randBtn\">Push random</button>\n        <button class=\"btn danger mini\" id=\"clearBtn\">Clear</button>\n      </div>\n\n      <div class=\"stackWrap\">\n        <div class=\"stack\">\n          <div class=\"labels\">\n            <div class=\"top\">Top</div>\n            <div class=\"bottom\">Bottom</div>\n          </div>\n          <div class=\"emptyMsg\" id=\"emptyMsg\">Stack is empty</div>\n          <div class=\"stackInner\" id=\"stackItems\"></div>\n        </div>\n\n        <div class=\"stats\">\n          <div class=\"kv\"><div>Size</div><div class=\"value\" id=\"sizeVal\">0</div></div>\n          <div class=\"kv\"><div>Top element</div><div class=\"value\" id=\"topVal\">None</div></div>\n\n          <div class=\"bigO\">\n            <div class=\"row\"><div class=\"op\">push</div><div class=\"o\">O(1)</div></div>\n            <div class=\"row\"><div class=\"op\">pop</div><div class=\"o\">O(1)</div></div>\n            <div class=\"row\"><div class=\"op\">peek</div><div class=\"o\">O(1)</div></div>\n            <div class=\"row\"><div class=\"op\">search</div><div class=\"o\">O(n)</div></div>\n          </div>\n\n          <h3 style=\"margin:8px 0 6px 0;font-size:14px;\">Operation log</h3>\n          <ul class=\"log\" id=\"logList\"></ul>\n        </div>\n      </div>\n    </section>\n\n    <section class=\"card\">\n      <h2>Examples Using a Stack</h2>\n      <div class=\"examples\">\n\n        <div class=\"exBox\">\n          <h3 style=\"margin:0 0 6px 0;font-size:15px;\">Reverse a string</h3>\n          <div class=\"subtitle\" style=\"font-size:12px;margin-bottom:6px;\">\n            Push each character, then pop to build the reversed output.\n          </div>\n          <div class=\"controls\">\n            <input id=\"revInput\" type=\"text\" placeholder=\"Type text to reverse\">\n            <button class=\"btn primary\" id=\"revBtn\">Reverse using stack</button>\n          </div>\n          <div class=\"result\" id=\"revResult\"></div>\n        </div>\n\n        <div class=\"exBox\">\n          <h3 style=\"margin:0 0 6px 0;font-size:15px;\">Balanced parentheses</h3>\n          <div class=\"subtitle\" style=\"font-size:12px;margin-bottom:6px;\">\n            Use a stack to ensure every closing bracket matches the most recent opening bracket.\n          </div>\n          <div class=\"controls\">\n            <input id=\"balInput\" type=\"text\" placeholder=\"e.g. (a+[b*c]-{d/3})\">\n            <button class=\"btn primary\" id=\"balBtn\">Check balance</button>\n          </div>\n          <div class=\"result\" id=\"balResult\"></div>\n        </div>\n\n      </div>\n    </section>\n  </div>\n</div>\n\n<div class=\"toast\" id=\"toast\"></div>\n\n<script>\n  // Stack implementation\n  class Stack {\n    constructor(){ this._arr = []; }\n    push(x){ this._arr.push(x); return x; }\n    pop(){ return this._arr.pop(); }\n    peek(){ return this._arr[this._arr.length - 1]; }\n    size(){ return this._arr.length; }\n    isEmpty(){ return this._arr.length === 0; }\n    clear(){ this._arr.length = 0; }\n    toArray(){ return [...this._arr]; }\n  }\n\n  const stack = new Stack();\n\n  // DOM elements\n  const itemsEl = document.getElementById('stackItems');\n  const sizeEl = document.getElementById('sizeVal');\n  const topEl = document.getElementById('topVal');\n  const emptyMsgEl = document.getElementById('emptyMsg');\n\n  const inputEl = document.getElementById('valueInput');\n  const pushBtn = document.getElementById('pushBtn');\n  const popBtn = document.getElementById('popBtn');\n  const peekBtn = document.getElementById('peekBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const randBtn = document.getElementById('randBtn');\n\n  const logEl = document.getElementById('logList');\n  const toastEl = document.getElementById('toast');\n\n  // Examples\n  const revInput = document.getElementById('revInput');\n  const revBtn = document.getElementById('revBtn');\n  const revResult = document.getElementById('revResult');\n\n  const balInput = document.getElementById('balInput');\n  const balBtn = document.getElementById('balBtn');\n  const balResult = document.getElementById('balResult');\n\n  // Helpers\n  const nowTime = () => new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});\n  function log(action){\n    const li = document.createElement('li');\n    li.innerHTML = `<span class=\"time\">${nowTime()}</span><span class=\"desc\">${action}</span>`;\n    logEl.prepend(li); // newest on top\n  }\n  let toastTimer;\n  function toast(msg){\n    clearTimeout(toastTimer);\n    toastEl.textContent = msg;\n    toastEl.classList.add('show');\n    toastTimer = setTimeout(()=> toastEl.classList.remove('show'), 2000);\n  }\n\n  function updateInfo(){\n    sizeEl.textContent = stack.size();\n    topEl.textContent = stack.isEmpty() ? 'None' : String(stack.peek());\n    emptyMsgEl.style.display = stack.isEmpty() ? 'flex' : 'none';\n  }\n\n  function createItemEl(text){\n    const el = document.createElement('div');\n    el.className = 'item enter';\n    el.textContent = text;\n    return el;\n  }\n\n  // Render initial\n  updateInfo();\n\n  // Actions\n  function pushValue(val){\n    if (val == null) return;\n    const str = String(val).trim();\n    if (!str){\n      toast('Enter a value to push.');\n      inputEl.focus();\n      return;\n    }\n    stack.push(str);\n    const node = createItemEl(str);\n    itemsEl.appendChild(node);\n    requestAnimationFrame(()=> node.classList.remove('enter'));\n    updateInfo();\n    log(`push(\"${str}\")`);\n    inputEl.value = '';\n    inputEl.focus();\n  }\n\n  function popValue(){\n    if (stack.isEmpty()){\n      toast('Stack is already empty.');\n      return;\n    }\n    const removed = stack.pop();\n    const topNode = itemsEl.lastElementChild;\n    if (topNode){\n      topNode.classList.add('leave');\n      topNode.addEventListener('transitionend', ()=> { topNode.remove(); updateInfo(); }, {once:true});\n    } else {\n      updateInfo();\n    }\n    log(`pop() -> \"${removed}\"`);\n  }\n\n  function peekValue(){\n    if (stack.isEmpty()){\n      toast('Nothing to peek.');\n      return;\n    }\n    const topNode = itemsEl.lastElementChild;\n    topNode.classList.add('peek');\n    setTimeout(()=> topNode.classList.remove('peek'), 700);\n    log(`peek() -> \"${stack.peek()}\"`);\n    updateInfo();\n  }\n\n  function clearStack(){\n    if (stack.isEmpty()){\n      toast('Stack is already clear.');\n      return;\n    }\n    stack.clear();\n    const children = Array.from(itemsEl.children);\n    let delay = 0;\n    children.reverse().forEach((node, i)=>{\n      setTimeout(()=> {\n        node.classList.add('leave');\n        node.addEventListener('transitionend', ()=> node.remove(), {once:true});\n      }, delay);\n      delay += 40;\n    });\n    setTimeout(updateInfo, delay + 200);\n    log('clear()');\n  }\n\n  function pushRandom(){\n    const rand = Math.random();\n    const val = Math.random() < .33\n      ? Math.floor(rand * 100)\n      : Math.random() < .66\n        ? ['alpha','beta','gamma','delta','omega'][Math.floor(rand*5)]\n        : '#' + Math.floor(rand * 0xFFFFFF).toString(16).padStart(6,'0');\n    pushValue(val);\n  }\n\n  // Bindings\n  pushBtn.addEventListener('click', ()=> pushValue(inputEl.value));\n  inputEl.addEventListener('keydown', (e)=>{\n    if (e.key === 'Enter') pushValue(inputEl.value);\n  });\n  popBtn.addEventListener('click', popValue);\n  peekBtn.addEventListener('click', peekValue);\n  clearBtn.addEventListener('click', clearStack);\n  randBtn.addEventListener('click', pushRandom);\n\n  // Example: reverse string using a stack\n  function reverseUsingStack(text){\n    const s = new Stack();\n    for (const ch of text) s.push(ch);\n    let out = '';\n    while(!s.isEmpty()) out += s.pop();\n    return out;\n  }\n  revBtn.addEventListener('click', ()=>{\n    const t = String(revInput.value ?? '');\n    if (!t.length){ toast('Type text to reverse.'); revInput.focus(); return; }\n    const out = reverseUsingStack(t);\n    revResult.textContent = out;\n  });\n  revInput.addEventListener('keydown', e=>{\n    if (e.key === 'Enter') revBtn.click();\n  });\n\n  // Example: balanced parentheses using a stack\n  function isBalanced(expr){\n    const s = new Stack();\n    const pairs = {')':'(',']':'[','}':'{'};\n    for (const ch of expr){\n      if (ch === '(' || ch === '[' || ch === '{'){\n        s.push(ch);\n      } else if (ch === ')' || ch === ']' || ch === '}'){\n        const top = s.pop();\n        if (top !== pairs[ch]) return false;\n      }\n    }\n    return s.isEmpty();\n  }\n  balBtn.addEventListener('click', ()=>{\n    const t = String(balInput.value ?? '');\n    if (!t.length){ toast('Enter an expression to check.'); balInput.focus(); return; }\n    const ok = isBalanced(t);\n    balResult.textContent = ok ? 'Balanced ✓' : 'Not balanced ✕';\n    balResult.style.color = ok ? 'var(--green)' : 'var(--danger)';\n  });\n  balInput.addEventListener('keydown', e=>{\n    if (e.key === 'Enter') balBtn.click();\n  });\n\n  // Seed with a few values for visual interest\n  ['A','B','C'].forEach(v=>{\n    stack.push(v);\n    const node = createItemEl(v);\n    itemsEl.appendChild(node);\n    requestAnimationFrame(()=> node.classList.remove('enter'));\n  });\n  updateInfo();\n  log('Initialized stack with [\"A\",\"B\",\"C\"]');\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Stack"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "c81edc30-a367-11f0-b7ae-63ed23369749",
    "timestamp": "2025-10-07T10:24:18.291Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Queue",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Queue Visualizer (FIFO) - JavaScript Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f172a;\n      --panel:#111827;\n      --muted:#94a3b8;\n      --text:#e5e7eb;\n      --accent:#22c55e;\n      --accent-2:#3b82f6;\n      --warn:#f59e0b;\n      --danger:#ef4444;\n      --chip:#1f2937;\n      --border:#374151;\n      --shadow:0 10px 20px rgba(0,0,0,.35), 0 2px 6px rgba(0,0,0,.25);\n    }\n    *{box-sizing:border-box}\n    html,body{height:100%}\n    body{\n      margin:0;\n      font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,\"Apple Color Emoji\",\"Segoe UI Emoji\";\n      background:linear-gradient(120deg,#0b1226 0%, #0e1730 100%);\n      color:var(--text);\n    }\n    .app{\n      max-width:1000px;\n      margin:0 auto;\n      padding:24px;\n    }\n    header{\n      display:flex;\n      align-items:flex-start;\n      justify-content:space-between;\n      gap:16px;\n      margin-bottom:18px;\n    }\n    h1{\n      margin:.2rem 0 .4rem;\n      font-weight:800;\n      letter-spacing:.2px;\n    }\n    .subtitle{\n      color:var(--muted);\n      font-size:.98rem;\n      max-width:70ch;\n    }\n    .panel{\n      background:linear-gradient(180deg,#0f172a 0%, #0d1426 100%);\n      border:1px solid var(--border);\n      border-radius:14px;\n      box-shadow:var(--shadow);\n    }\n    .controls{\n      padding:14px;\n      display:flex;\n      flex-wrap:wrap;\n      gap:10px;\n      align-items:center;\n    }\n    .row{\n      display:flex; gap:10px; align-items:center; flex-wrap:wrap;\n    }\n    .select, .input, .btn{\n      background:var(--chip);\n      border:1px solid var(--border);\n      color:var(--text);\n      border-radius:10px;\n      padding:10px 12px;\n      font-size:.95rem;\n      transition:.2s ease;\n    }\n    .select:hover, .input:hover{border-color:#475569}\n    .input{min-width:180px}\n    .btn{\n      display:inline-flex; align-items:center; gap:8px;\n      background:#1c2437;\n      cursor:pointer;\n      user-select:none;\n    }\n    .btn:hover{filter:brightness(1.1)}\n    .btn:active{transform:translateY(1px)}\n    .btn.primary{background:linear-gradient(180deg,#16a34a,#15803d); border-color:#14532d}\n    .btn.info{background:linear-gradient(180deg,#2563eb,#1d4ed8); border-color:#1e40af}\n    .btn.warn{background:linear-gradient(180deg,#ca8a04,#a16207); border-color:#713f12}\n    .btn.danger{background:linear-gradient(180deg,#ef4444,#dc2626); border-color:#991b1b}\n    .btn.ghost{background:#182030}\n    .statbar{\n      display:flex; gap:16px; padding:10px 14px; border-top:1px solid var(--border);\n      color:var(--muted); font-size:.95rem; flex-wrap:wrap\n    }\n    .stat{background:#0c1326; border:1px solid var(--border); border-radius:10px; padding:8px 10px}\n    .stat b{color:var(--text)}\n    .grid{\n      display:grid; grid-template-columns:1fr; gap:16px; margin-top:18px;\n    }\n    .viz{\n      padding:18px;\n    }\n    .viz-head{\n      display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;\n    }\n    .queue-wrap{\n      position:relative;\n      min-height:110px;\n      background:repeating-linear-gradient(90deg, rgba(148,163,184,0.08) 0px, rgba(148,163,184,0.08) 6px, transparent 6px, transparent 12px);\n      border:1px dashed #334155;\n      border-radius:12px;\n      padding:14px;\n      overflow:hidden;\n    }\n    .lane{\n      display:flex; gap:10px; align-items:flex-end; flex-wrap:nowrap;\n      overflow:auto; padding-bottom:12px;\n      scrollbar-width:thin; scrollbar-color:#334155 transparent;\n    }\n    .lane::-webkit-scrollbar{height:8px}\n    .lane::-webkit-scrollbar-thumb{background:#334155; border-radius:8px}\n    .queue-item{\n      background:linear-gradient(180deg,#1f2937,#111827);\n      border:1px solid #334155;\n      border-radius:10px;\n      min-width:70px;\n      max-width:140px;\n      padding:12px 10px;\n      text-align:center;\n      box-shadow:0 6px 12px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.03);\n      position:relative;\n      transition:transform .18s ease, opacity .18s ease, box-shadow .18s ease;\n    }\n    .queue-item .val{font-weight:700; font-size:1.05rem}\n    .queue-item .meta{font-size:.78rem; color:var(--muted)}\n    .queue-item:hover{transform:translateY(-2px); box-shadow:0 10px 14px rgba(0,0,0,.35)}\n    .queue-item.new{\n      opacity:0; transform:scale(.92) translateY(4px);\n      animation:popin .28s ease forwards;\n    }\n    @keyframes popin{\n      to{opacity:1; transform:none}\n    }\n    .labels{\n      position:absolute; inset:8px 12px auto 12px; pointer-events:none; display:flex; justify-content:space-between; align-items:center;\n      font-size:.8rem; color:#a5b4fc;\n    }\n    .label-chip{\n      background:#1e293b; border:1px solid #334155; border-radius:999px; padding:4px 8px; color:#c7d2fe\n    }\n    .empty{\n      color:var(--muted); font-style:italic; padding:12px 10px;\n    }\n    .log{\n      padding:14px; max-height:200px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n      background:#0b1223; border-top:1px solid var(--border); border-bottom-left-radius:14px; border-bottom-right-radius:14px;\n    }\n    .log .line{color:#cbd5e1; font-size:.9rem; white-space:pre-wrap}\n    .log .t{color:#93c5fd}\n    .perf{\n      padding:14px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;\n      border-top:1px solid var(--border);\n    }\n    .toast{\n      position:fixed; right:16px; bottom:16px; z-index:50;\n      background:#0b1223; border:1px solid #334155; border-radius:12px; padding:10px 14px;\n      color:var(--text); box-shadow:var(--shadow); min-width:220px; display:none;\n    }\n    .toast.show{display:block; animation:raise .25s ease both}\n    @keyframes raise{from{opacity:0; transform:translateY(8px)} to{opacity:1; transform:none}}\n    footer{\n      color:var(--muted); font-size:.95rem; margin:22px 0 40px;\n    }\n    footer .k{color:#a7f3d0}\n    .tips{display:flex; flex-wrap:wrap; gap:8px; margin-top:8px}\n    .tip{\n      background:#0b1223; border:1px solid #334155; color:#cbd5e1; border-radius:10px; padding:8px 10px; font-size:.9rem;\n    }\n    .impl-note{color:#c7d2fe}\n    .badge{\n      background:#0b1223; border:1px solid #334155;\n      color:#93c5fd; padding:4px 8px; border-radius:999px; font-size:.8rem;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <header>\n      <div>\n        <h1>Queue Visualizer (FIFO)</h1>\n        <div class=\"subtitle\">\n          A queue is a First-In, First-Out data structure. Enqueue adds to the back; Dequeue removes from the front. Try operations and compare implementations.\n        </div>\n      </div>\n      <div class=\"badge\" id=\"implBadge\">Implementation: Head Index</div>\n    </header>\n\n    <section class=\"panel\">\n      <div class=\"controls\">\n        <div class=\"row\">\n          <label for=\"impl\" class=\"impl-note\">Implementation</label>\n          <select id=\"impl\" class=\"select\" title=\"Choose queue implementation\">\n            <option value=\"fast\">Head Index (Optimized)</option>\n            <option value=\"naive\">Array Shift (Naive)</option>\n            <option value=\"twostack\">Two Stacks (Amortized)</option>\n          </select>\n        </div>\n        <div class=\"row\">\n          <input id=\"enqueueInput\" class=\"input\" placeholder=\"Value to enqueue (or leave empty for auto)\" />\n          <button id=\"enqueueBtn\" class=\"btn primary\" title=\"Add item to the back (enqueue)\">\n            ➕ Enqueue\n          </button>\n          <button id=\"dequeueBtn\" class=\"btn danger\" title=\"Remove item from the front (dequeue)\">\n            ➖ Dequeue\n          </button>\n          <button id=\"peekFrontBtn\" class=\"btn ghost\" title=\"View the front item\">\n            ⏮️ Peek Front\n          </button>\n          <button id=\"peekBackBtn\" class=\"btn ghost\" title=\"View the back item\">\n            ⏭️ Peek Back\n          </button>\n        </div>\n        <div class=\"row\">\n          <button id=\"randomBtn\" class=\"btn info\" title=\"Enqueue a random number\">\n            🎲 Random Enqueue\n          </button>\n          <button id=\"autoBtn\" class=\"btn warn\" title=\"Toggle auto-run demo\">▶️ Auto-run</button>\n          <button id=\"clearBtn\" class=\"btn\" title=\"Clear the queue\">🧹 Clear</button>\n        </div>\n      </div>\n      <div class=\"statbar\">\n        <div class=\"stat\">Size: <b id=\"statSize\">0</b></div>\n        <div class=\"stat\">Empty: <b id=\"statEmpty\">Yes</b></div>\n        <div class=\"stat\">Front: <b id=\"statFront\">-</b></div>\n        <div class=\"stat\">Back: <b id=\"statBack\">-</b></div>\n      </div>\n    </section>\n\n    <div class=\"grid\">\n      <section class=\"panel viz\">\n        <div class=\"viz-head\">\n          <div class=\"subtitle\">Visualization</div>\n          <div class=\"badge\">FIFO</div>\n        </div>\n        <div class=\"queue-wrap\">\n          <div class=\"labels\"><span class=\"label-chip\">Front</span><span class=\"label-chip\">Back</span></div>\n          <div id=\"lane\" class=\"lane\" aria-live=\"polite\"></div>\n          <div id=\"emptyMsg\" class=\"empty\" style=\"display:none\">Queue is empty. Enqueue some items!</div>\n        </div>\n      </section>\n\n      <section class=\"panel\">\n        <div class=\"perf\">\n          <div class=\"subtitle\">Performance demo (enqueue N then dequeue N)</div>\n          <input id=\"opsInput\" class=\"input\" type=\"number\" min=\"1000\" step=\"1000\" value=\"50000\" />\n          <button id=\"perfBtn\" class=\"btn info\">Run test</button>\n          <span id=\"perfStatus\" class=\"badge\" style=\"display:none\"></span>\n        </div>\n        <div class=\"log\" id=\"log\" aria-live=\"polite\"></div>\n      </section>\n    </div>\n\n    <footer>\n      <div>\n        Concept recap: A queue serves elements in the order they arrive.\n        Operations:\n        - enqueue(x): add x to back\n        - dequeue(): remove and return front\n        - peekFront/peekBack: inspect ends\n      </div>\n      <div class=\"tips\">\n        <div class=\"tip\">Naive uses Array.shift(), which is O(n) per dequeue.</div>\n        <div class=\"tip\">Head Index keeps a moving start index to make operations O(1) on average.</div>\n        <div class=\"tip\">Two Stacks gives amortized O(1) by reversing chunks on demand.</div>\n      </div>\n    </footer>\n  </div>\n\n  <div id=\"toast\" class=\"toast\"></div>\n\n  <script>\n    \"use strict\";\n\n    // Queue implementations\n    class NaiveQueue {\n      constructor(items = []) { this.arr = items.slice(); }\n      enqueue(x) { this.arr.push(x); }\n      dequeue() { return this.arr.length ? this.arr.shift() : undefined; }\n      peekFront() { return this.arr[0]; }\n      peekBack() { return this.arr.length ? this.arr[this.arr.length - 1] : undefined; }\n      size() { return this.arr.length; }\n      isEmpty() { return this.arr.length === 0; }\n      clear() { this.arr.length = 0; }\n      toArray() { return this.arr.slice(); }\n      name() { return \"Array Shift (Naive)\"; }\n    }\n\n    class FastQueue {\n      constructor(items = []) { this.arr = []; this.head = 0; for (const x of items) this.enqueue(x); }\n      enqueue(x) { this.arr.push(x); }\n      dequeue() {\n        if (this.head >= this.arr.length) return undefined;\n        const v = this.arr[this.head++];\n        // Periodic compaction to keep memory bounded\n        if (this.head > 50 && this.head * 2 > this.arr.length) {\n          this.arr = this.arr.slice(this.head);\n          this.head = 0;\n        }\n        return v;\n      }\n      peekFront() { return this.head < this.arr.length ? this.arr[this.head] : undefined; }\n      peekBack() { return this.head < this.arr.length ? this.arr[this.arr.length - 1] : undefined; }\n      size() { return this.arr.length - this.head; }\n      isEmpty() { return this.size() === 0; }\n      clear() { this.arr = []; this.head = 0; }\n      toArray() { return this.arr.slice(this.head); }\n      name() { return \"Head Index (Optimized)\"; }\n    }\n\n    class TwoStackQueue {\n      constructor(items = []) { this._in = []; this._out = []; for (const x of items) this.enqueue(x); }\n      enqueue(x) { this._in.push(x); }\n      _pour() { while (this._in.length) this._out.push(this._in.pop()); }\n      dequeue() {\n        if (!this._out.length) this._pour();\n        return this._out.length ? this._out.pop() : undefined;\n      }\n      peekFront() {\n        if (!this._out.length) this._pour();\n        return this._out.length ? this._out[this._out.length - 1] : undefined;\n      }\n      peekBack() {\n        if (this._in.length) return this._in[this._in.length - 1];\n        if (this._out.length) return this._out[0];\n        return undefined;\n      }\n      size() { return this._in.length + this._out.length; }\n      isEmpty() { return this.size() === 0; }\n      clear() { this._in = []; this._out = []; }\n      toArray() { return this._out.slice().reverse().concat(this._in); }\n      name() { return \"Two Stacks (Amortized)\"; }\n    }\n\n    // UI handling\n    const implSelect = document.getElementById(\"impl\");\n    const enqueueInput = document.getElementById(\"enqueueInput\");\n    const enqueueBtn = document.getElementById(\"enqueueBtn\");\n    const dequeueBtn = document.getElementById(\"dequeueBtn\");\n    const peekFrontBtn = document.getElementById(\"peekFrontBtn\");\n    const peekBackBtn = document.getElementById(\"peekBackBtn\");\n    const randomBtn = document.getElementById(\"randomBtn\");\n    const clearBtn = document.getElementById(\"clearBtn\");\n    const autoBtn = document.getElementById(\"autoBtn\");\n\n    const statSize = document.getElementById(\"statSize\");\n    const statEmpty = document.getElementById(\"statEmpty\");\n    const statFront = document.getElementById(\"statFront\");\n    const statBack = document.getElementById(\"statBack\");\n    const implBadge = document.getElementById(\"implBadge\");\n\n    const lane = document.getElementById(\"lane\");\n    const emptyMsg = document.getElementById(\"emptyMsg\");\n    const logEl = document.getElementById(\"log\");\n\n    const toast = document.getElementById(\"toast\");\n\n    const opsInput = document.getElementById(\"opsInput\");\n    const perfBtn = document.getElementById(\"perfBtn\");\n    const perfStatus = document.getElementById(\"perfStatus\");\n\n    let nextId = 1;\n    let autoInterval = null;\n    let queue = makeQueue(implSelect.value);\n    let lastRenderLength = 0;\n\n    function makeQueue(mode, seed = []) {\n      switch (mode) {\n        case \"naive\": return new NaiveQueue(seed);\n        case \"twostack\": return new TwoStackQueue(seed);\n        default: return new FastQueue(seed);\n      }\n    }\n\n    function updateBadge() {\n      implBadge.textContent = \"Implementation: \" + queue.name();\n    }\n\n    function renderQueue({ markNewFromIndex = null } = {}) {\n      const items = queue.toArray();\n      lane.innerHTML = \"\";\n      if (items.length === 0) {\n        emptyMsg.style.display = \"\";\n      } else {\n        emptyMsg.style.display = \"none\";\n        items.forEach((v, i) => {\n          const d = document.createElement(\"div\");\n          d.className = \"queue-item\";\n          if (markNewFromIndex != null && i >= markNewFromIndex) d.classList.add(\"new\");\n          const val = document.createElement(\"div\");\n          val.className = \"val\";\n          val.textContent = String(v);\n          const meta = document.createElement(\"div\");\n          meta.className = \"meta\";\n          if (i === 0 && items.length === 1) meta.textContent = \"front & back\";\n          else if (i === 0) meta.textContent = \"front\";\n          else if (i === items.length - 1) meta.textContent = \"back\";\n          else meta.textContent = \"idx \" + i;\n          d.appendChild(val);\n          d.appendChild(meta);\n          lane.appendChild(d);\n        });\n      }\n      lastRenderLength = items.length;\n      updateStats();\n    }\n\n    function updateStats() {\n      statSize.textContent = String(queue.size());\n      statEmpty.textContent = queue.isEmpty() ? \"Yes\" : \"No\";\n      statFront.textContent = queue.peekFront() !== undefined ? String(queue.peekFront()) : \"-\";\n      statBack.textContent = queue.peekBack() !== undefined ? String(queue.peekBack()) : \"-\";\n    }\n\n    function log(msg) {\n      const t = new Date();\n      const ts = `${String(t.getHours()).padStart(2,\"0\")}:${String(t.getMinutes()).padStart(2,\"0\")}:${String(t.getSeconds()).padStart(2,\"0\")}`;\n      const line = document.createElement(\"div\");\n      line.className = \"line\";\n      line.innerHTML = `<span class=\"t\">[${ts}]</span> ${msg}`;\n      logEl.prepend(line);\n      // keep last 80 lines\n      while (logEl.children.length > 80) logEl.removeChild(logEl.lastChild);\n    }\n\n    let toastTimer = null;\n    function showToast(text, color = null) {\n      toast.textContent = text;\n      toast.classList.add(\"show\");\n      if (color) toast.style.borderColor = color;\n      clearTimeout(toastTimer);\n      toastTimer = setTimeout(() => toast.classList.remove(\"show\"), 1800);\n    }\n\n    function enqueue(val) {\n      const beforeLen = queue.size();\n      queue.enqueue(val);\n      renderQueue({ markNewFromIndex: beforeLen });\n      log(`enqueue(${formatVal(val)})`);\n    }\n\n    function dequeue() {\n      const v = queue.dequeue();\n      if (v === undefined) {\n        log(\"dequeue() => undefined (empty)\");\n        showToast(\"Queue is empty — nothing to dequeue.\", \"#ef4444\");\n      } else {\n        renderQueue();\n        log(`dequeue() => ${formatVal(v)}`);\n        showToast(`Dequeued: ${v}`, \"#f59e0b\");\n      }\n    }\n\n    function formatVal(v) {\n      if (typeof v === \"string\") return JSON.stringify(v);\n      return String(v);\n    }\n\n    // Event handlers\n    enqueueBtn.addEventListener(\"click\", () => {\n      let v = enqueueInput.value;\n      if (v.trim() === \"\") v = nextId++;\n      enqueue(v);\n      enqueueInput.value = \"\";\n      enqueueInput.focus();\n    });\n\n    enqueueInput.addEventListener(\"keydown\", e => {\n      if (e.key === \"Enter\") {\n        enqueueBtn.click();\n      }\n    });\n\n    randomBtn.addEventListener(\"click\", () => {\n      const r = Math.floor(Math.random() * 90) + 10;\n      enqueue(r);\n    });\n\n    dequeueBtn.addEventListener(\"click\", () => dequeue());\n\n    peekFrontBtn.addEventListener(\"click\", () => {\n      const v = queue.peekFront();\n      log(`peekFront() => ${v === undefined ? \"undefined\" : formatVal(v)}`);\n      showToast(`Front: ${v === undefined ? \"empty\" : v}`, \"#3b82f6\");\n      updateStats();\n    });\n\n    peekBackBtn.addEventListener(\"click\", () => {\n      const v = queue.peekBack();\n      log(`peekBack() => ${v === undefined ? \"undefined\" : formatVal(v)}`);\n      showToast(`Back: ${v === undefined ? \"empty\" : v}`, \"#3b82f6\");\n      updateStats();\n    });\n\n    clearBtn.addEventListener(\"click\", () => {\n      queue.clear();\n      renderQueue();\n      log(\"clear()\");\n      showToast(\"Queue cleared\", \"#22c55e\");\n    });\n\n    autoBtn.addEventListener(\"click\", () => {\n      if (autoInterval) {\n        clearInterval(autoInterval);\n        autoInterval = null;\n        autoBtn.textContent = \"▶️ Auto-run\";\n        autoBtn.classList.remove(\"danger\");\n        autoBtn.classList.add(\"warn\");\n        log(\"auto-run: stopped\");\n        return;\n      }\n      log(\"auto-run: started\");\n      autoBtn.textContent = \"⏹️ Stop auto-run\";\n      autoBtn.classList.remove(\"warn\");\n      autoBtn.classList.add(\"danger\");\n      autoInterval = setInterval(() => {\n        // Keep size in a friendly range by biasing choice\n        const size = queue.size();\n        const target = 6;\n        const bias = size < target ? 0.7 : (size > target + 3 ? 0.2 : 0.5);\n        if (Math.random() < bias) {\n          enqueue(Math.random() < 0.5 ? nextId++ : Math.floor(Math.random() * 100));\n        } else {\n          dequeue();\n        }\n      }, 600);\n    });\n\n    implSelect.addEventListener(\"change\", () => {\n      const items = queue.toArray();\n      queue = makeQueue(implSelect.value, items);\n      updateBadge();\n      renderQueue();\n      log(`switched implementation => ${queue.name()}`);\n    });\n\n    // Performance demo\n    perfBtn.addEventListener(\"click\", async () => {\n      const N = Math.max(1000, Math.min(2_000_000, Number(opsInput.value) || 50000));\n      perfStatus.style.display = \"\";\n      perfStatus.textContent = \"Running...\";\n      log(`performance test: N=${N} (enqueue N then dequeue N)`);\n\n      // Allow paint\n      await new Promise(r => setTimeout(r, 20));\n\n      const results = [];\n      for (const key of [\"naive\", \"fast\", \"twostack\"]) {\n        const impl = makeQueue(key);\n        const name = impl.name();\n        const t0 = performance.now();\n        for (let i = 0; i < N; i++) impl.enqueue(i);\n        for (let i = 0; i < N; i++) impl.dequeue();\n        const t1 = performance.now();\n        const ms = Math.round(t1 - t0);\n        results.push({ name, ms });\n        log(`- ${name}: ${ms} ms`);\n        // Yield briefly to avoid total UI lock\n        await new Promise(r => setTimeout(r, 10));\n      }\n\n      const fastest = results.reduce((a,b)=> a.ms < b.ms ? a : b);\n      perfStatus.textContent = `Fastest: ${fastest.name} (${fastest.ms} ms)`;\n      showToast(`Performance: ${fastest.name} won (${fastest.ms} ms)`, \"#22c55e\");\n    });\n\n    // Initialize\n    updateBadge();\n    renderQueue();\n\n    // Seed a few items for illustration\n    [\"A\", \"B\", \"C\"].forEach(v => queue.enqueue(v));\n    renderQueue({ markNewFromIndex: 0 });\n    log(\"initialized with ['A','B','C']\");\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Queue"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "ebd83720-a367-11f0-9094-65216c3db6bd",
    "timestamp": "2025-10-07T10:25:18.226Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Deque",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<title>Deque (Double-Ended Queue) Interactive Demo</title>\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --accent: #60a5fa;\n    --accent2: #34d399;\n    --warn: #f59e0b;\n    --text: #e5e7eb;\n    --muted: #9ca3af;\n    --node: #1f2937;\n    --border: #374151;\n  }\n  * { box-sizing: border-box; }\n  body {\n    margin: 0;\n    background: var(--bg);\n    color: var(--text);\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;\n  }\n  header {\n    padding: 16px 20px;\n    border-bottom: 1px solid var(--border);\n  }\n  h1 {\n    margin: 0;\n    font-weight: 600;\n    font-size: 20px;\n  }\n  .container {\n    padding: 16px 20px 40px;\n    max-width: 1100px;\n    margin: 0 auto;\n  }\n  .controls {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 8px;\n    align-items: center;\n    margin-bottom: 12px;\n  }\n  input[type=\"text\"] {\n    background: var(--panel);\n    border: 1px solid var(--border);\n    color: var(--text);\n    padding: 8px 10px;\n    border-radius: 8px;\n    min-width: 180px;\n  }\n  button {\n    background: var(--panel);\n    color: var(--text);\n    border: 1px solid var(--border);\n    padding: 8px 12px;\n    border-radius: 8px;\n    cursor: pointer;\n    transition: background .15s, border-color .15s, transform .05s;\n  }\n  button:hover { background: #1b2433; border-color: #4b5563; }\n  button:active { transform: scale(0.98); }\n  button.primary { border-color: var(--accent); }\n  button.secondary { border-color: var(--accent2); }\n  button.warn { border-color: var(--warn); }\n  .status {\n    display: flex;\n    gap: 16px;\n    align-items: center;\n    margin: 12px 0 18px;\n    color: var(--muted);\n    font-size: 14px;\n    flex-wrap: wrap;\n  }\n  .status .badge {\n    background: var(--panel);\n    border: 1px solid var(--border);\n    border-radius: 999px;\n    padding: 4px 10px;\n    color: var(--text);\n    font-size: 12px;\n  }\n  .viz-wrap {\n    position: relative;\n    border: 1px solid var(--border);\n    border-radius: 12px;\n    background: linear-gradient(180deg, rgba(96,165,250,0.08), transparent 30%), var(--panel);\n    padding: 16px;\n  }\n  .labels {\n    display: flex;\n    justify-content: space-between;\n    font-size: 12px;\n    color: var(--muted);\n    margin-bottom: 10px;\n  }\n  .deque {\n    display: flex;\n    align-items: flex-end;\n    gap: 8px;\n    overflow-x: auto;\n    padding-bottom: 8px;\n    scrollbar-color: var(--border) transparent;\n  }\n  .deque::-webkit-scrollbar { height: 8px; }\n  .deque::-webkit-scrollbar-thumb { background: var(--border); border-radius: 8px; }\n  .node {\n    min-width: 60px;\n    background: var(--node);\n    border: 1px solid var(--border);\n    border-radius: 10px;\n    padding: 10px;\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    align-items: center;\n    justify-content: center;\n    position: relative;\n  }\n  .node .value { font-weight: 600; font-size: 16px; }\n  .node .meta { font-size: 11px; color: var(--muted); }\n  .empty { color: var(--muted); font-style: italic; padding: 6px 10px; }\n  .pointer {\n    position: absolute;\n    top: -12px;\n    left: 0;\n    right: 0;\n    display: flex;\n    justify-content: center;\n    pointer-events: none;\n    gap: 6px;\n  }\n  .arrow {\n    background: var(--accent);\n    color: #03254e;\n    font-weight: 700;\n    padding: 2px 6px;\n    border-radius: 6px;\n    font-size: 11px;\n  }\n  .arrow.back { background: var(--accent2); color: #05381f; }\n  .log {\n    margin-top: 14px;\n    border: 1px solid var(--border);\n    border-radius: 10px;\n    background: var(--panel);\n  }\n  .log header {\n    padding: 10px 12px;\n    border-bottom: 1px solid var(--border);\n    font-size: 13px;\n    color: var(--muted);\n  }\n  .log .entries { max-height: 160px; overflow: auto; font-size: 13px; }\n  .log .entry { padding: 8px 12px; border-top: 1px solid rgba(55,65,81,.4); }\n  .entry .op { font-weight: 600; }\n  .entry .time { color: var(--muted); font-size: 12px; margin-left: 8px; }\n  .tips { margin-top: 18px; color: var(--muted); font-size: 14px; }\n  .kbd {\n    background: #0b1220;\n    border: 1px solid var(--border);\n    border-radius: 6px;\n    font-family: ui-monospace, Menlo, Consolas, monospace;\n    padding: 2px 6px;\n    font-size: 12px;\n    color: var(--text);\n  }\n  .footer { margin-top: 24px; font-size: 12px; color: var(--muted); }\n  .small { font-size: 12px; color: var(--muted); }\n  .danger { color: #fca5a5; }\n</style>\n</head>\n<body>\n  <header>\n    <h1>Deque (Double-Ended Queue) Interactive Demo</h1>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"controls\">\n      <input id=\"valueInput\" type=\"text\" placeholder=\"Value to add (e.g., 42 or 'A')\" />\n      <button class=\"primary\" id=\"pushFrontBtn\">Push Front</button>\n      <button class=\"primary\" id=\"pushBackBtn\">Push Back</button>\n      <button class=\"warn\" id=\"popFrontBtn\">Pop Front</button>\n      <button class=\"warn\" id=\"popBackBtn\">Pop Back</button>\n      <button id=\"peekFrontBtn\">Peek Front</button>\n      <button id=\"peekBackBtn\">Peek Back</button>\n      <button id=\"sizeBtn\">Size</button>\n      <button id=\"clearBtn\">Clear</button>\n      <button class=\"secondary\" id=\"randomOpBtn\">Random Operation</button>\n      <button id=\"autoplayBtn\">Autoplay</button>\n    </div>\n\n    <div class=\"status\">\n      <div class=\"badge\">Head index: <span id=\"headIdx\">0</span></div>\n      <div class=\"badge\">Tail index: <span id=\"tailIdx\">0</span></div>\n      <div class=\"badge\">Size: <span id=\"size\">0</span></div>\n      <div class=\"badge\">Empty: <span id=\"empty\">true</span></div>\n    </div>\n\n    <div class=\"viz-wrap\">\n      <div class=\"labels\">\n        <div>Front (pop/peek here)</div>\n        <div>Back (pop/peek here)</div>\n      </div>\n      <div id=\"dequeView\" class=\"deque\"></div>\n    </div>\n\n    <div class=\"log\">\n      <header>Operation Log</header>\n      <div class=\"entries\" id=\"logEntries\"></div>\n    </div>\n\n    <div class=\"tips\">\n      - A deque supports O(1) additions and removals at both ends: pushFront, pushBack, popFront, popBack.\n      - This demo uses a sparse object with head and tail indices to avoid costly array shift/unshift.\n      - Keyboard shortcuts: F push front, B push back, J pop front, K pop back, Space random, C clear.\n    </div>\n\n    <div class=\"footer small\">\n      Try adding values, then remove from either end to see how the indices move. Pointers are logical head/tail positions.\n    </div>\n  </div>\n\n<script>\nclass Deque {\n  constructor() {\n    this._items = {};\n    this._head = 0;\n    this._tail = 0;\n  }\n  pushFront(value) {\n    this._head--;\n    this._items[this._head] = value;\n    return this.size();\n  }\n  pushBack(value) {\n    this._items[this._tail] = value;\n    this._tail++;\n    return this.size();\n  }\n  popFront() {\n    if (this.isEmpty()) return undefined;\n    const value = this._items[this._head];\n    delete this._items[this._head];\n    this._head++;\n    return value;\n  }\n  popBack() {\n    if (this.isEmpty()) return undefined;\n    this._tail--;\n    const value = this._items[this._tail];\n    delete this._items[this._tail];\n    return value;\n  }\n  peekFront() {\n    return this.isEmpty() ? undefined : this._items[this._head];\n  }\n  peekBack() {\n    return this.isEmpty() ? undefined : this._items[this._tail - 1];\n  }\n  size() { return this._tail - this._head; }\n  isEmpty() { return this.size() === 0; }\n  clear() {\n    this._items = {};\n    this._head = 0;\n    this._tail = 0;\n  }\n  toArray() {\n    const arr = [];\n    for (let i = this._head; i < this._tail; i++) {\n      arr.push(this._items[i]);\n    }\n    return arr;\n  }\n  indices() {\n    const idx = [];\n    for (let i = this._head; i < this._tail; i++) {\n      idx.push(i);\n    }\n    return idx;\n  }\n  headIndex() { return this._head; }\n  tailIndex() { return this._tail; }\n}\n\n// UI wiring\nconst deque = new Deque();\nconst input = document.getElementById('valueInput');\nconst dequeView = document.getElementById('dequeView');\nconst headIdx = document.getElementById('headIdx');\nconst tailIdx = document.getElementById('tailIdx');\nconst sizeEl = document.getElementById('size');\nconst emptyEl = document.getElementById('empty');\nconst logEntries = document.getElementById('logEntries');\n\nconst btns = {\n  pushFront: document.getElementById('pushFrontBtn'),\n  pushBack: document.getElementById('pushBackBtn'),\n  popFront: document.getElementById('popFrontBtn'),\n  popBack: document.getElementById('popBackBtn'),\n  peekFront: document.getElementById('peekFrontBtn'),\n  peekBack: document.getElementById('peekBackBtn'),\n  size: document.getElementById('sizeBtn'),\n  clear: document.getElementById('clearBtn'),\n  random: document.getElementById('randomOpBtn'),\n  autoplay: document.getElementById('autoplayBtn'),\n};\n\nfunction render() {\n  dequeView.innerHTML = '';\n  const values = deque.toArray();\n  const indices = deque.indices();\n\n  if (values.length === 0) {\n    const empty = document.createElement('div');\n    empty.className = 'empty';\n    empty.textContent = 'Deque is empty';\n    dequeView.appendChild(empty);\n  } else {\n    values.forEach((val, idx) => {\n      const i = indices[idx];\n      const node = document.createElement('div');\n      node.className = 'node';\n\n      const valDiv = document.createElement('div');\n      valDiv.className = 'value';\n      valDiv.textContent = formatValue(val);\n\n      const metaDiv = document.createElement('div');\n      metaDiv.className = 'meta';\n      metaDiv.textContent = 'index ' + i;\n\n      const pointer = document.createElement('div');\n      pointer.className = 'pointer';\n      const isFront = i === deque.headIndex();\n      const isBack = i === deque.tailIndex() - 1;\n      if (isFront) {\n        const arrowFront = document.createElement('div');\n        arrowFront.className = 'arrow';\n        arrowFront.textContent = 'Front';\n        pointer.appendChild(arrowFront);\n      }\n      if (isBack) {\n        const arrowBack = document.createElement('div');\n        arrowBack.className = 'arrow back';\n        arrowBack.textContent = 'Back';\n        pointer.appendChild(arrowBack);\n      }\n\n      node.appendChild(pointer);\n      node.appendChild(valDiv);\n      node.appendChild(metaDiv);\n      dequeView.appendChild(node);\n    });\n  }\n\n  headIdx.textContent = deque.headIndex();\n  tailIdx.textContent = deque.tailIndex();\n  sizeEl.textContent = deque.size();\n  emptyEl.textContent = String(deque.isEmpty());\n}\n\nfunction formatValue(v) {\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number') return String(v);\n  try { return JSON.stringify(v); } catch { return String(v); }\n}\n\nfunction stringify(v) {\n  if (typeof v === 'string') return '\"' + v + '\"';\n  try {\n    const s = JSON.stringify(v);\n    return s ?? String(v);\n  } catch {\n    return String(v);\n  }\n}\n\nfunction log(op, detail) {\n  const row = document.createElement('div');\n  row.className = 'entry';\n  const ts = new Date().toLocaleTimeString();\n  row.innerHTML = '<span class=\"op\">' + op + '</span>' +\n                  (detail ? ' — ' + escapeHtml(detail) : '') +\n                  '<span class=\"time\"> ' + ts + '</span>';\n  logEntries.prepend(row);\n}\n\nfunction escapeHtml(str) {\n  return String(str).replace(/[&<>\"']/g, s => ({\n    '&': '&amp;', '<': '&lt;', '>': '&gt;', '\"': '&quot;', \"'\": '&#39;'\n  }[s]));\n}\n\nfunction parseInputValue() {\n  const raw = input.value.trim();\n  if (raw === '') return undefined;\n\n  if (!isNaN(Number(raw)) && /^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)$/.test(raw)) {\n    return Number(raw);\n  }\n  try {\n    if (/^[\\[{\"]/.test(raw) || /^(true|false|null)$/i.test(raw)) {\n      return JSON.parse(raw);\n    }\n  } catch {}\n  return raw;\n}\n\nbtns.pushFront.addEventListener('click', () => {\n  const val = parseInputValue();\n  if (val === undefined) { pulse(input); log('pushFront', 'No value provided'); return; }\n  deque.pushFront(val);\n  render();\n  log('pushFront', 'Added ' + stringify(val));\n  input.focus();\n});\n\nbtns.pushBack.addEventListener('click', () => {\n  const val = parseInputValue();\n  if (val === undefined) { pulse(input); log('pushBack', 'No value provided'); return; }\n  deque.pushBack(val);\n  render();\n  log('pushBack', 'Added ' + stringify(val));\n  input.focus();\n});\n\nbtns.popFront.addEventListener('click', () => {\n  const v = deque.popFront();\n  render();\n  log('popFront', v === undefined ? 'Deque is empty' : 'Removed ' + stringify(v));\n});\n\nbtns.popBack.addEventListener('click', () => {\n  const v = deque.popBack();\n  render();\n  log('popBack', v === undefined ? 'Deque is empty' : 'Removed ' + stringify(v));\n});\n\nbtns.peekFront.addEventListener('click', () => {\n  const v = deque.peekFront();\n  log('peekFront', v === undefined ? 'Deque is empty' : 'Front = ' + stringify(v));\n});\n\nbtns.peekBack.addEventListener('click', () => {\n  const v = deque.peekBack();\n  log('peekBack', v === undefined ? 'Deque is empty' : 'Back = ' + stringify(v));\n});\n\nbtns.size.addEventListener('click', () => {\n  log('size', 'Size = ' + deque.size());\n});\n\nbtns.clear.addEventListener('click', () => {\n  deque.clear();\n  render();\n  log('clear', 'Deque cleared');\n});\n\nbtns.random.addEventListener('click', () => {\n  randomOp();\n});\n\nlet autoplayInterval = null;\nbtns.autoplay.addEventListener('click', () => {\n  if (autoplayInterval) stopAutoplay();\n  else startAutoplay();\n});\n\nfunction pulse(el) {\n  el.style.outline = '2px solid var(--accent)';\n  setTimeout(() => { el.style.outline = ''; }, 300);\n}\n\n// Keyboard shortcuts\ndocument.addEventListener('keydown', (e) => {\n  if (e.target === input && e.key === 'Enter') {\n    const val = parseInputValue();\n    if (val === undefined) { pulse(input); log('pushBack', 'No value provided'); return; }\n    deque.pushBack(val);\n    render();\n    log('pushBack', 'Added ' + stringify(val));\n    input.select();\n    return;\n  }\n  if (e.ctrlKey || e.metaKey || e.altKey) return;\n  const k = e.key.toLowerCase();\n  if (k === 'f') { btns.pushFront.click(); e.preventDefault(); }\n  else if (k === 'b') { btns.pushBack.click(); e.preventDefault(); }\n  else if (k === 'j') { btns.popFront.click(); e.preventDefault(); }\n  else if (k === 'k') { btns.popBack.click(); e.preventDefault(); }\n  else if (k === ' ') { btns.random.click(); e.preventDefault(); }\n  else if (k === 'c') { btns.clear.click(); e.preventDefault(); }\n});\n\n// Random operation helper\nfunction randomOp() {\n  const ops = ['pushFront', 'pushBack', 'popFront', 'popBack'];\n  let op = ops[Math.floor(Math.random() * ops.length)];\n  if (deque.isEmpty() && (op === 'popFront' || op === 'popBack')) {\n    op = Math.random() < 0.5 ? 'pushFront' : 'pushBack';\n  }\n  let val = null;\n  if (op === 'pushFront' || op === 'pushBack') {\n    val = randomValue();\n  }\n  switch (op) {\n    case 'pushFront':\n      deque.pushFront(val);\n      render();\n      log('pushFront', 'Added ' + stringify(val));\n      break;\n    case 'pushBack':\n      deque.pushBack(val);\n      render();\n      log('pushBack', 'Added ' + stringify(val));\n      break;\n    case 'popFront':\n      const f = deque.popFront();\n      render();\n      log('popFront', f === undefined ? 'Deque is empty' : 'Removed ' + stringify(f));\n      break;\n    case 'popBack':\n      const b = deque.popBack();\n      render();\n      log('popBack', b === undefined ? 'Deque is empty' : 'Removed ' + stringify(b));\n      break;\n  }\n}\n\nfunction randomValue() {\n  const choices = [\n    () => Math.floor(Math.random() * 100),\n    () => ['A', 'B', 'C', 'D', 'E', 'F'][Math.floor(Math.random() * 6)],\n    () => ({ id: Math.floor(Math.random() * 1000) }),\n    () => [1, 2, 3].slice(0, Math.floor(Math.random() * 3) + 1),\n    () => Math.random() < 0.5\n  ];\n  return choices[Math.floor(Math.random() * choices.length)]();\n}\n\n// Autoplay\nfunction startAutoplay() {\n  if (autoplayInterval) return;\n  btns.autoplay.textContent = 'Stop Autoplay';\n  autoplayInterval = setInterval(randomOp, 700);\n  log('autoplay', 'Started');\n}\nfunction stopAutoplay() {\n  if (!autoplayInterval) return;\n  clearInterval(autoplayInterval);\n  autoplayInterval = null;\n  btns.autoplay.textContent = 'Autoplay';\n  log('autoplay', 'Stopped');\n}\n\n// Initialize with seed data\n(function init() {\n  ['A', 'B', 'C'].forEach(v => deque.pushBack(v));\n  render();\n  log('init', 'Seeded deque with \"A\",\"B\",\"C\"');\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Deque"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "1d794b20-a368-11f0-a370-f55791a58010",
    "timestamp": "2025-10-07T10:26:41.491Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Hash Table",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n<title>Hash Table Visualizer</title>\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --text: #e5e7eb;\n    --muted: #9ca3af;\n    --accent: #22d3ee;\n    --accent2: #4ade80;\n    --warn: #f59e0b;\n    --danger: #ef4444;\n    --probe: #fde68a;\n    --hit: #86efac;\n    --collision: #fca5a5;\n    --tomb: #6b7280;\n    --border: rgba(255,255,255,0.08);\n  }\n  * { box-sizing: border-box; }\n  html, body { height: 100%; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial; }\n  a { color: var(--accent); }\n  h1, h2, h3 { margin: 0; }\n  .container { max-width: 1100px; margin: 0 auto; padding: 16px; }\n  .header { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 8px; }\n  .header h1 { font-size: 22px; }\n  .subtitle { font-size: 13px; color: var(--muted); }\n  .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 10px; padding: 12px; }\n  .controls { display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px; align-items: end; }\n  .control { grid-column: span 3; }\n  .control.wide { grid-column: span 6; }\n  .control.full { grid-column: 1 / -1; }\n  label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }\n  input[type=\"text\"], input[type=\"number\"], select {\n    width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid var(--border);\n    background: #0b1220; color: var(--text);\n  }\n  input[type=\"range\"] { width: 100%; }\n  .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }\n  .btn {\n    padding: 8px 12px; border-radius: 8px; border: 1px solid var(--border);\n    background: #0b1220; color: var(--text); cursor: pointer; transition: transform 0.02s ease;\n  }\n  .btn:hover { filter: brightness(1.1); }\n  .btn:active { transform: scale(0.98); }\n  .btn.primary { background: #0b2545; border-color: #113a63; color: #bfe2ff; }\n  .btn.warn { background: #3b1d06; border-color: #7a3b0c; color: #f8be6c; }\n  .btn.danger { background: #3a0d0d; border-color: #7a1e1e; color: #ffb3b3; }\n  .switch { display: inline-flex; gap: 8px; align-items: center; font-size: 13px; color: var(--muted); }\n  .metrics { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 12px; }\n  .metric { background: #0b1220; border: 1px solid var(--border); border-radius: 8px; padding: 10px; }\n  .metric .big { font-size: 18px; font-weight: 600; color: var(--accent2); }\n  .metric .label { font-size: 12px; color: var(--muted); }\n  .grid-wrap { margin-top: 14px; }\n  .grid {\n    display: grid; gap: 8px;\n    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));\n  }\n  .bucket {\n    background: #0b1220; border: 1px solid var(--border);\n    border-radius: 10px; padding: 8px; position: relative; min-height: 56px;\n  }\n  .bucket .index {\n    position: absolute; top: 6px; right: 8px;\n    font-size: 11px; color: var(--muted);\n  }\n  .bucket .title { font-size: 13px; color: var(--muted); margin-bottom: 6px; }\n  .entries { display: flex; flex-wrap: wrap; gap: 6px; }\n  .entry {\n    font-size: 12px; border-radius: 6px; padding: 4px 6px; border: 1px solid var(--border);\n    background: #10192b; color: #d1eaff;\n  }\n  .entry .kv { opacity: 0.9; }\n  .slot-empty { font-size: 12px; color: var(--muted); opacity: 0.7; }\n  .tomb { background: #1f2937; color: #b0b7c3; border-color: #2b3644; }\n  .highlight-probe { outline: 2px dashed var(--warn); outline-offset: -2px; animation: pulse 0.6s ease-in-out; }\n  .highlight-hit { outline: 2px solid var(--accent2); outline-offset: -2px; }\n  .highlight-collision { outline: 2px solid var(--danger); outline-offset: -2px; }\n  @keyframes pulse {\n    0% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.5); }\n    100% { box-shadow: 0 0 0 10px rgba(245, 158, 11, 0); }\n  }\n  .log { margin-top: 10px; max-height: 160px; overflow: auto; background: #0b1220; border: 1px solid var(--border); border-radius: 8px; padding: 8px; font-size: 12px; }\n  .log-entry { margin-bottom: 4px; }\n  .legend { display: flex; gap: 12px; align-items: center; font-size: 12px; color: var(--muted); margin-top: 6px; }\n  .dot { width: 10px; height: 10px; border-radius: 999px; display: inline-block; margin-right: 6px; }\n  .dot.probe { background: var(--warn); }\n  .dot.hit { background: var(--accent2); }\n  .dot.collision { background: var(--danger); }\n  .dot.tomb { background: var(--tomb); }\n  .desc { margin-bottom: 10px; font-size: 13px; color: var(--muted); }\n  .sep { height: 1px; background: var(--border); margin: 12px 0; }\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <div class=\"header\">\n    <div>\n      <h1>Hash Table Visualizer</h1>\n      <div class=\"subtitle\">Insert, search, delete; observe hashing, collisions, load factor, and resizing.</div>\n    </div>\n    <button class=\"btn\" id=\"btnTryCollision\">Try collision pair (Aa & BB)</button>\n  </div>\n\n  <div class=\"panel\">\n    <div class=\"desc\">\n      A hash table stores key-value pairs and uses a hash function to map keys to bucket indices. Collisions occur when multiple keys hash to the same bucket;\n      different collision resolution strategies like separate chaining or open addressing handle them. Load factor indicates how full the table is and influences performance.\n    </div>\n    <div class=\"controls\">\n      <div class=\"control\">\n        <label>Collision Resolution</label>\n        <select id=\"modeSelect\">\n          <option value=\"chaining\">Separate Chaining (linked buckets)</option>\n          <option value=\"linear\">Open Addressing (Linear Probing)</option>\n        </select>\n      </div>\n      <div class=\"control\">\n        <label>Hash Function</label>\n        <select id=\"hashSelect\">\n          <option value=\"polynomial31\">Polynomial rolling (base 31)</option>\n          <option value=\"fnv1a\">FNV-1a (simplified)</option>\n          <option value=\"sum\">Sum of char codes</option>\n        </select>\n      </div>\n      <div class=\"control\">\n        <label>Number of buckets</label>\n        <input type=\"number\" id=\"bucketInput\" min=\"4\" max=\"128\" step=\"1\" value=\"16\"/>\n      </div>\n      <div class=\"control\">\n        <label>Auto-resize threshold (load factor)</label>\n        <input type=\"range\" id=\"lfSlider\" min=\"0.45\" max=\"0.95\" step=\"0.05\" value=\"0.75\"/>\n        <div class=\"row\" style=\"justify-content: space-between;\">\n          <span class=\"subtitle\">Resize when size/buckets ≥ <span id=\"lfVal\">0.75</span></span>\n          <label class=\"switch\"><input type=\"checkbox\" id=\"autoResize\" checked/> auto-resize</label>\n        </div>\n      </div>\n\n      <div class=\"control wide\">\n        <label>Key</label>\n        <input type=\"text\" id=\"keyInput\" placeholder=\"e.g., user42 or Aa or 123\"/>\n        <div class=\"row\" style=\"margin-top: 6px;\">\n          <label class=\"switch\"><input type=\"checkbox\" id=\"parseNumber\"/> parse numeric keys as numbers</label>\n        </div>\n      </div>\n      <div class=\"control wide\">\n        <label>Value (optional)</label>\n        <input type=\"text\" id=\"valInput\" placeholder=\"e.g., Alice\"/>\n      </div>\n\n      <div class=\"control full\">\n        <div class=\"row\">\n          <button class=\"btn primary\" id=\"btnInsert\">Insert / Upsert</button>\n          <button class=\"btn\" id=\"btnSearch\">Search</button>\n          <button class=\"btn warn\" id=\"btnDelete\">Delete</button>\n          <button class=\"btn\" id=\"btnRandom\">Insert 10 random keys</button>\n          <button class=\"btn danger\" id=\"btnClear\">Clear Table</button>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"metrics\">\n      <div class=\"metric\">\n        <div class=\"label\">Elements</div>\n        <div class=\"big\" id=\"mSize\">0</div>\n      </div>\n      <div class=\"metric\">\n        <div class=\"label\">Buckets</div>\n        <div class=\"big\" id=\"mBuckets\">16</div>\n      </div>\n      <div class=\"metric\">\n        <div class=\"label\">Load Factor</div>\n        <div class=\"big\" id=\"mLF\">0.00</div>\n      </div>\n      <div class=\"metric\">\n        <div class=\"label\">Collisions (cumulative)</div>\n        <div class=\"big\" id=\"mCollisions\">0</div>\n      </div>\n    </div>\n\n    <div class=\"legend\">\n      <span><span class=\"dot probe\"></span>probe path</span>\n      <span><span class=\"dot hit\"></span>hit / final slot</span>\n      <span><span class=\"dot collision\"></span>collision</span>\n      <span><span class=\"dot tomb\"></span>tombstone</span>\n    </div>\n\n    <div class=\"grid-wrap\">\n      <div class=\"grid\" id=\"grid\"></div>\n    </div>\n\n    <div class=\"sep\"></div>\n    <div class=\"log\" id=\"log\"></div>\n  </div>\n</div>\n\n<script>\n/* Hash Functions */\nfunction hashPolynomial31(str) {\n  let h = 0 >>> 0;\n  for (let i = 0; i < str.length; i++) {\n    h = (Math.imul(h, 31) + str.charCodeAt(i)) >>> 0;\n  }\n  return h >>> 0;\n}\nfunction hashSum(str) {\n  let h = 0;\n  for (let i = 0; i < str.length; i++) h += str.charCodeAt(i);\n  return h >>> 0;\n}\nfunction hashFNV1a(str) {\n  let h = 2166136261 >>> 0;\n  for (let i = 0; i < str.length; i++) {\n    h ^= str.charCodeAt(i);\n    h = Math.imul(h, 16777619) >>> 0;\n  }\n  return h >>> 0;\n}\n\nconst HASHES = {\n  polynomial31: hashPolynomial31,\n  sum: hashSum,\n  fnv1a: hashFNV1a\n};\n\nfunction isNumberLike(s) {\n  return /^-?\\d+(\\.\\d+)?$/.test(s.trim());\n}\n\nfunction nextBucketCount(n) {\n  // simple grow strategy; not necessarily prime\n  return Math.min(128, Math.max(4, n * 2));\n}\n\n/* Hash Table class */\nclass HashTable {\n  constructor(bucketCount = 16, mode = 'chaining', hashName = 'polynomial31') {\n    this.bucketCount = bucketCount;\n    this.mode = mode; // 'chaining' | 'linear'\n    this.hashName = hashName;\n    this.resetBuckets();\n    this.size = 0;\n    this.tombstones = 0;\n    this.collisionsTotal = 0;\n    this.lastOpInfo = null;\n    this.autoResize = true;\n    this.resizeThreshold = 0.75;\n  }\n\n  resetBuckets() {\n    if (this.mode === 'chaining') {\n      this.buckets = Array.from({ length: this.bucketCount }, () => []);\n    } else {\n      this.buckets = Array.from({ length: this.bucketCount }, () => null);\n    }\n  }\n\n  rawHash(key) {\n    if (typeof key === 'number') {\n      const v = Math.floor(key);\n      return (v < 0 ? -v : v) >>> 0;\n    }\n    const s = String(key);\n    const f = HASHES[this.hashName] || HASHES.polynomial31;\n    return f(s) >>> 0;\n  }\n\n  indexForKey(key) {\n    return this.rawHash(key) % this.bucketCount;\n  }\n\n  setMode(mode) {\n    if (this.mode === mode) return;\n    this.mode = mode;\n    this.rehash(this.bucketCount);\n  }\n\n  setHash(hashName) {\n    this.hashName = hashName;\n    this.rehash(this.bucketCount);\n  }\n\n  setBucketCount(n) {\n    const newN = Math.max(4, Math.min(128, Math.floor(n)));\n    if (newN === this.bucketCount) return;\n    this.rehash(newN);\n  }\n\n  setAutoResize(enabled, threshold) {\n    this.autoResize = enabled;\n    this.resizeThreshold = threshold ?? this.resizeThreshold;\n    this.maybeResize();\n  }\n\n  maybeResize() {\n    const load = this.size / this.bucketCount;\n    if (this.autoResize && load >= this.resizeThreshold) {\n      this.rehash(nextBucketCount(this.bucketCount));\n      return true;\n    }\n    // Special case for linear probing: too many tombstones degrade probing\n    if (this.mode === 'linear' && this.tombstones > this.bucketCount * 0.25) {\n      this.rehash(this.bucketCount);\n      return true;\n    }\n    return false;\n  }\n\n  rehash(newBucketCount) {\n    const oldEntries = this.entries();\n    this.bucketCount = Math.max(4, Math.min(128, Math.floor(newBucketCount)));\n    this.resetBuckets();\n    this.size = 0;\n    this.tombstones = 0;\n    this.collisionsTotal = 0;\n    for (const { key, value } of oldEntries) {\n      this._insertInternal(key, value);\n    }\n    this.lastOpInfo = { action: 'rehash', bucketCount: this.bucketCount };\n  }\n\n  entries() {\n    const out = [];\n    if (this.mode === 'chaining') {\n      for (const chain of this.buckets) {\n        for (const e of chain) out.push({ key: e.key, value: e.value });\n      }\n    } else {\n      for (const e of this.buckets) {\n        if (e && !e.deleted) out.push({ key: e.key, value: e.value });\n      }\n    }\n    return out;\n  }\n\n  insert(key, value) {\n    const info = this._insertInternal(key, value);\n    this.lastOpInfo = info;\n    this.maybeResize();\n    return info;\n  }\n\n  _insertInternal(key, value) {\n    if (this.mode === 'chaining') {\n      const idx = this.indexForKey(key);\n      const chain = this.buckets[idx];\n      let collisions = chain.length > 0 ? chain.length : 0;\n      let updated = false;\n      let chainPos = -1;\n      for (let i = 0; i < chain.length; i++) {\n        if (this.keysEqual(chain[i].key, key)) {\n          chain[i].value = value;\n          updated = true;\n          chainPos = i;\n          collisions = Math.max(0, chain.length - 1);\n          break;\n        }\n      }\n      if (!updated) {\n        chain.push({ key, value });\n        this.size++;\n        chainPos = chain.length - 1;\n      }\n      if (collisions > 0) this.collisionsTotal += collisions;\n      return {\n        action: updated ? 'upsert' : 'insert', mode: 'chaining',\n        index: idx, chainPos, collisions, key, value,\n        hash: this.rawHash(key), path: [idx]\n      };\n    } else {\n      // linear probing\n      const start = this.indexForKey(key);\n      let firstTombstone = -1;\n      let steps = 0;\n      let updated = false;\n      let finalIndex = -1;\n      const path = [];\n      for (let i = 0; i < this.bucketCount; i++) {\n        const probe = (start + i) % this.bucketCount;\n        path.push(probe);\n        const entry = this.buckets[probe];\n        if (entry == null) {\n          // empty slot\n          finalIndex = (firstTombstone !== -1) ? firstTombstone : probe;\n          if (firstTombstone !== -1) {\n            this.buckets[finalIndex] = { key, value, deleted: false };\n            this.tombstones--;\n          } else {\n            this.buckets[finalIndex] = { key, value, deleted: false };\n          }\n          this.size++;\n          steps = path.length - 1;\n          break;\n        } else if (entry.deleted) {\n          if (firstTombstone === -1) firstTombstone = probe;\n        } else if (this.keysEqual(entry.key, key)) {\n          entry.value = value;\n          updated = true;\n          finalIndex = probe;\n          steps = path.length - 1;\n          break;\n        } else {\n          // collision\n        }\n      }\n      if (finalIndex === -1) {\n        // table is full; try to grow and retry once\n        const grew = this.maybeResize();\n        if (grew) {\n          return this._insertInternal(key, value);\n        } else {\n          return { action: 'insert-failed', mode: 'linear', reason: 'table-full', key, value };\n        }\n      }\n      if (steps > 0) this.collisionsTotal += steps;\n      return {\n        action: updated ? 'upsert' : 'insert', mode: 'linear',\n        startIndex: start, index: finalIndex, collisions: steps, key, value,\n        hash: this.rawHash(key), path\n      };\n    }\n  }\n\n  search(key) {\n    if (this.mode === 'chaining') {\n      const idx = this.indexForKey(key);\n      const chain = this.buckets[idx];\n      let found = false, value = undefined, chainPos = -1;\n      for (let i = 0; i < chain.length; i++) {\n        if (this.keysEqual(chain[i].key, key)) {\n          found = true; value = chain[i].value; chainPos = i; break;\n        }\n      }\n      const info = {\n        action: 'search', mode: 'chaining',\n        index: idx, chainPos, found, value, key,\n        hash: this.rawHash(key), path: [idx]\n      };\n      this.lastOpInfo = info;\n      return info;\n    } else {\n      const start = this.indexForKey(key);\n      const path = [];\n      let found = false, value = undefined, finalIndex = -1;\n      for (let i = 0; i < this.bucketCount; i++) {\n        const probe = (start + i) % this.bucketCount;\n        path.push(probe);\n        const entry = this.buckets[probe];\n        if (entry == null) {\n          // empty slot: stop\n          break;\n        } else if (!entry.deleted && this.keysEqual(entry.key, key)) {\n          found = true; value = entry.value; finalIndex = probe; break;\n        } else {\n          // continue\n        }\n      }\n      const info = {\n        action: 'search', mode: 'linear',\n        startIndex: start, index: finalIndex, found, value, key,\n        hash: this.rawHash(key), path\n      };\n      this.lastOpInfo = info;\n      return info;\n    }\n  }\n\n  delete(key) {\n    if (this.mode === 'chaining') {\n      const idx = this.indexForKey(key);\n      const chain = this.buckets[idx];\n      let deleted = false, chainPos = -1;\n      for (let i = 0; i < chain.length; i++) {\n        if (this.keysEqual(chain[i].key, key)) {\n          chain.splice(i, 1);\n          deleted = true; chainPos = i;\n          this.size--;\n          break;\n        }\n      }\n      const info = {\n        action: 'delete', mode: 'chaining',\n        index: idx, chainPos, deleted, key,\n        hash: this.rawHash(key), path: [idx]\n      };\n      this.lastOpInfo = info;\n      return info;\n    } else {\n      const start = this.indexForKey(key);\n      const path = [];\n      let deleted = false, finalIndex = -1;\n      for (let i = 0; i < this.bucketCount; i++) {\n        const probe = (start + i) % this.bucketCount;\n        path.push(probe);\n        const entry = this.buckets[probe];\n        if (entry == null) {\n          // not found\n          break;\n        } else if (!entry.deleted && this.keysEqual(entry.key, key)) {\n          entry.deleted = true;\n          this.size--;\n          this.tombstones++;\n          deleted = true; finalIndex = probe;\n          break;\n        } else {\n          // continue\n        }\n      }\n      const info = {\n        action: 'delete', mode: 'linear',\n        startIndex: start, index: finalIndex, deleted, key,\n        hash: this.rawHash(key), path\n      };\n      this.lastOpInfo = info;\n      this.maybeResize();\n      return info;\n    }\n  }\n\n  keysEqual(a, b) {\n    // handle number vs string equality consistently\n    if (typeof a === 'number' && typeof b === 'number') return Object.is(a, b);\n    return String(a) === String(b);\n  }\n}\n\n/* UI + Rendering */\nconst state = {\n  table: new HashTable(16, 'chaining', 'polynomial31')\n};\n\nconst el = {\n  grid: document.getElementById('grid'),\n  mSize: document.getElementById('mSize'),\n  mBuckets: document.getElementById('mBuckets'),\n  mLF: document.getElementById('mLF'),\n  mCollisions: document.getElementById('mCollisions'),\n  modeSelect: document.getElementById('modeSelect'),\n  hashSelect: document.getElementById('hashSelect'),\n  bucketInput: document.getElementById('bucketInput'),\n  lfSlider: document.getElementById('lfSlider'),\n  lfVal: document.getElementById('lfVal'),\n  autoResize: document.getElementById('autoResize'),\n  keyInput: document.getElementById('keyInput'),\n  valInput: document.getElementById('valInput'),\n  parseNumber: document.getElementById('parseNumber'),\n  btnInsert: document.getElementById('btnInsert'),\n  btnSearch: document.getElementById('btnSearch'),\n  btnDelete: document.getElementById('btnDelete'),\n  btnRandom: document.getElementById('btnRandom'),\n  btnClear: document.getElementById('btnClear'),\n  btnTryCollision: document.getElementById('btnTryCollision'),\n  log: document.getElementById('log')\n};\n\nfunction render() {\n  // Metrics\n  el.mSize.textContent = String(state.table.size);\n  el.mBuckets.textContent = String(state.table.bucketCount);\n  const lf = state.table.size / state.table.bucketCount;\n  el.mLF.textContent = lf.toFixed(2);\n  el.mCollisions.textContent = String(state.table.collisionsTotal);\n\n  // Grid\n  el.grid.innerHTML = '';\n  if (state.table.mode === 'chaining') {\n    state.table.buckets.forEach((chain, idx) => {\n      const bucket = document.createElement('div');\n      bucket.className = 'bucket';\n      bucket.dataset.index = idx;\n      const title = document.createElement('div');\n      title.className = 'title';\n      title.textContent = chain.length ? `Chain length: ${chain.length}` : 'Empty';\n      const index = document.createElement('div');\n      index.className = 'index';\n      index.textContent = `#${idx}`;\n      const entries = document.createElement('div');\n      entries.className = 'entries';\n      if (!chain.length) {\n        const empty = document.createElement('div');\n        empty.className = 'slot-empty';\n        empty.textContent = '—';\n        entries.appendChild(empty);\n      } else {\n        chain.forEach(e => {\n          const chip = document.createElement('div');\n          chip.className = 'entry';\n          chip.innerHTML = `<span class=\"kv\">${escapeHtml(String(e.key))} → ${escapeHtml(String(e.value ?? ''))}</span>`;\n          entries.appendChild(chip);\n        });\n      }\n      bucket.appendChild(title);\n      bucket.appendChild(index);\n      bucket.appendChild(entries);\n      el.grid.appendChild(bucket);\n    });\n  } else {\n    state.table.buckets.forEach((e, idx) => {\n      const bucket = document.createElement('div');\n      bucket.className = 'bucket';\n      bucket.dataset.index = idx;\n      const title = document.createElement('div');\n      title.className = 'title';\n      title.textContent = e == null ? 'Empty' : (e.deleted ? 'Tombstone' : 'Occupied');\n      const index = document.createElement('div');\n      index.className = 'index';\n      index.textContent = `#${idx}`;\n      const entries = document.createElement('div');\n      entries.className = 'entries';\n      if (e == null) {\n        const empty = document.createElement('div');\n        empty.className = 'slot-empty';\n        empty.textContent = '—';\n        entries.appendChild(empty);\n      } else {\n        const chip = document.createElement('div');\n        chip.className = 'entry' + (e.deleted ? ' tomb' : '');\n        chip.innerHTML = e.deleted\n          ? `<span class=\"kv\">✝ tombstone</span>`\n          : `<span class=\"kv\">${escapeHtml(String(e.key))} → ${escapeHtml(String(e.value ?? ''))}</span>`;\n        entries.appendChild(chip);\n      }\n      bucket.appendChild(title);\n      bucket.appendChild(index);\n      bucket.appendChild(entries);\n      el.grid.appendChild(bucket);\n    });\n  }\n}\n\nfunction escapeHtml(s) {\n  return s.replace(/[&<>\"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c]));\n}\n\nfunction log(msg) {\n  const div = document.createElement('div');\n  div.className = 'log-entry';\n  div.innerHTML = msg;\n  el.log.prepend(div);\n}\n\nfunction fmtHashInfo(info) {\n  if (!info) return '';\n  const base = `<span style=\"color:${info.action==='search'?'#9ae6b4':'#93c5fd'}\">${info.action}</span>`;\n  const hashStr = (info.hash !== undefined) ? ` hash=${info.hash}` : '';\n  const idxStr = (info.index !== undefined) ? ` index=${info.index}` : (info.startIndex !== undefined ? ` start=${info.startIndex}` : '');\n  const pathStr = info.path ? ` path=[${info.path.join(', ')}]` : '';\n  let tail = '';\n  if (info.action === 'insert' || info.action === 'upsert') {\n    tail = ` collisions=${info.collisions ?? 0}`;\n  } else if (info.action === 'delete') {\n    tail = ` deleted=${info.deleted}`;\n  } else if (info.action === 'search') {\n    tail = ` found=${info.found}${info.found ? ` value=${escapeHtml(String(info.value))}` : ''}`;\n  } else if (info.action === 'rehash') {\n    tail = ` → buckets=${info.bucketCount}`;\n  }\n  return `${base}${hashStr}${idxStr}${pathStr}${tail} key=${escapeHtml(String(info.key ?? ''))}`;\n}\n\nfunction animatePath(info) {\n  // Remove prior highlights\n  document.querySelectorAll('.bucket').forEach(b => {\n    b.classList.remove('highlight-probe', 'highlight-hit', 'highlight-collision');\n  });\n  const path = info && info.path ? info.path : [];\n  let delay = 0;\n  for (let i = 0; i < path.length; i++) {\n    const idx = path[i];\n    const bucketEl = el.grid.querySelector(`.bucket[data-index=\"${idx}\"]`);\n    if (!bucketEl) continue;\n    setTimeout(() => {\n      bucketEl.classList.add('highlight-probe');\n      setTimeout(() => bucketEl.classList.remove('highlight-probe'), 420);\n    }, delay);\n    delay += 160;\n  }\n  // Final hit or collision markers\n  if (info && (info.index !== undefined || info.path?.length)) {\n    const lastIndex = info.index ?? info.path[info.path.length - 1];\n    const lastBucket = el.grid.querySelector(`.bucket[data-index=\"${lastIndex}\"]`);\n    if (lastBucket) {\n      setTimeout(() => {\n        lastBucket.classList.add('highlight-hit');\n        setTimeout(() => lastBucket.classList.remove('highlight-hit'), 650);\n      }, delay + 120);\n    }\n  }\n  // Collision marker for chaining\n  if (info && info.mode === 'chaining' && (info.collisions ?? 0) > 0) {\n    const bucketEl = el.grid.querySelector(`.bucket[data-index=\"${info.index}\"]`);\n    if (bucketEl) {\n      setTimeout(() => {\n        bucketEl.classList.add('highlight-collision');\n        setTimeout(() => bucketEl.classList.remove('highlight-collision'), 700);\n      }, delay + 80);\n    }\n  }\n}\n\nfunction getKeyFromInput() {\n  const raw = el.keyInput.value.trim();\n  if (!raw) return null;\n  if (el.parseNumber.checked && isNumberLike(raw)) return Number(raw);\n  return raw;\n}\n\nfunction handleInsert() {\n  const key = getKeyFromInput();\n  if (key == null) { alert('Enter a key'); return; }\n  const value = el.valInput.value;\n  const info = state.table.insert(key, value);\n  render();\n  animatePath(info);\n  log(fmtHashInfo(info));\n}\n\nfunction handleSearch() {\n  const key = getKeyFromInput();\n  if (key == null) { alert('Enter a key'); return; }\n  const info = state.table.search(key);\n  render();\n  animatePath(info);\n  log(fmtHashInfo(info));\n}\n\nfunction handleDelete() {\n  const key = getKeyFromInput();\n  if (key == null) { alert('Enter a key'); return; }\n  const info = state.table.delete(key);\n  render();\n  animatePath(info);\n  log(fmtHashInfo(info));\n}\n\nfunction handleRandomInsert() {\n  const samples = [];\n  for (let i = 0; i < 10; i++) {\n    const s = randomKey();\n    samples.push(s);\n    state.table.insert(s, randomValue());\n  }\n  render();\n  animatePath(state.table.lastOpInfo);\n  log(`Inserted random keys: ${samples.map(s => escapeHtml(String(s))).join(', ')}`);\n}\n\nfunction randomKey() {\n  // Mix of numbers and strings\n  const r = Math.random();\n  if (r < 0.4) {\n    // number\n    return Math.floor(Math.random() * 1000);\n  } else {\n    const len = 3 + Math.floor(Math.random() * 3);\n    let s = '';\n    for (let i = 0; i < len; i++) {\n      const ch = 97 + Math.floor(Math.random() * 26);\n      s += String.fromCharCode(ch);\n    }\n    return s;\n  }\n}\nfunction randomValue() {\n  const animals = ['cat', 'dog', 'owl', 'fox', 'cow', 'ant', 'bee', 'yak', 'emu', 'eel'];\n  return animals[Math.floor(Math.random() * animals.length)];\n}\n\nfunction handleClear() {\n  state.table.resetBuckets();\n  state.table.size = 0;\n  state.table.tombstones = 0;\n  state.table.collisionsTotal = 0;\n  state.table.lastOpInfo = { action: 'clear' };\n  render();\n  log('Cleared table');\n}\n\nfunction handleTryCollision() {\n  // Known collision pair for polynomial 31 hash: \"Aa\" and \"BB\"\n  el.hashSelect.value = 'polynomial31';\n  state.table.setHash('polynomial31');\n  // For demo, keep current bucket count. Insert both keys.\n  const info1 = state.table.insert('Aa', 'first');\n  const info2 = state.table.insert('BB', 'second');\n  render();\n  animatePath(info2);\n  log('Inserted known collision pair \"Aa\" and \"BB\" (Java-style polynomial31) — they produce same raw hash value.');\n  log(fmtHashInfo(info1));\n  log(fmtHashInfo(info2));\n}\n\n/* Event bindings */\nel.modeSelect.addEventListener('change', () => {\n  const mode = el.modeSelect.value;\n  state.table.setMode(mode);\n  render();\n  log(`Switched mode to ${mode}`);\n});\nel.hashSelect.addEventListener('change', () => {\n  const hn = el.hashSelect.value;\n  state.table.setHash(hn);\n  render();\n  log(`Using hash function: ${hn}`);\n});\nel.bucketInput.addEventListener('change', () => {\n  const n = Number(el.bucketInput.value);\n  state.table.setBucketCount(n);\n  render();\n  log(`Bucket count set to ${state.table.bucketCount}`);\n});\nel.lfSlider.addEventListener('input', () => {\n  const v = Number(el.lfSlider.value);\n  el.lfVal.textContent = v.toFixed(2);\n  state.table.setAutoResize(el.autoResize.checked, v);\n  render();\n});\nel.autoResize.addEventListener('change', () => {\n  state.table.setAutoResize(el.autoResize.checked, Number(el.lfSlider.value));\n  render();\n  log(`Auto-resize ${el.autoResize.checked ? 'enabled' : 'disabled'} (threshold ${Number(el.lfSlider.value).toFixed(2)})`);\n});\n\nel.btnInsert.addEventListener('click', handleInsert);\nel.btnSearch.addEventListener('click', handleSearch);\nel.btnDelete.addEventListener('click', handleDelete);\nel.btnRandom.addEventListener('click', handleRandomInsert);\nel.btnClear.addEventListener('click', handleClear);\nel.btnTryCollision.addEventListener('click', handleTryCollision);\n\n/* Initial render */\nrender();\nlog('Ready. Choose a collision strategy, hash function, and start inserting keys.');\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Hash Table"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "5eeea5f0-a368-11f0-a27a-0b39cb2c75e0",
    "timestamp": "2025-10-07T10:28:31.311Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Hash Map",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Hash Map Visualizer (Separate Chaining)</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f172a;\n      --panel:#111827;\n      --panel-2:#0b1220;\n      --text:#e5e7eb;\n      --muted:#94a3b8;\n      --accent:#22d3ee;\n      --accent-2:#a78bfa;\n      --good:#34d399;\n      --warn:#fbbf24;\n      --bad:#f87171;\n      --chip:#1f2937;\n      --chip-border:#2b364a;\n      --shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px rgba(255,255,255,.03);\n    }\n    * { box-sizing: border-box; }\n    html,body { height:100%; }\n    body {\n      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\",\"Segoe UI Emoji\";\n      background: radial-gradient(1200px 700px at 10% -10%, #18213a 0%, #0f172a 55%) no-repeat, var(--bg);\n      color: var(--text);\n    }\n    header {\n      padding: 16px 20px;\n      display:flex; gap:16px; align-items:center; justify-content:space-between; flex-wrap:wrap;\n      border-bottom: 1px solid rgba(255,255,255,.06);\n      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0));\n      position: sticky; top: 0; z-index: 5;\n    }\n    .brand {\n      display:flex; align-items:center; gap:12px; font-weight:700; letter-spacing:.3px;\n    }\n    .brand .logo {\n      width: 36px; height: 36px; border-radius: 9px; background:\n        radial-gradient(circle at 30% 30%, #22d3ee66, transparent 40%),\n        radial-gradient(circle at 70% 70%, #a78bfa66, transparent 40%),\n        linear-gradient(135deg, #0ea5e9 0%, #8b5cf6 100%);\n      box-shadow: var(--shadow);\n    }\n    .brand small { color: var(--muted); font-weight:500; opacity:.8; }\n    .controls {\n      display:flex; gap:14px; align-items:flex-end; flex-wrap: wrap;\n      padding: 10px 20px 16px 20px;\n    }\n    .control {\n      display:flex; flex-direction:column; gap:8px; min-width: 160px;\n    }\n    .control label { font-size: 12px; color: var(--muted); }\n    input[type=text], input[type=number], select {\n      background: var(--panel);\n      border: 1px solid rgba(255,255,255,.08);\n      color: var(--text);\n      padding: 10px 12px; border-radius: 10px; outline:none;\n      box-shadow: var(--shadow);\n    }\n    input[type=range] { width: 220px; }\n    .btn {\n      background: linear-gradient(180deg, #1f2937, #0b1220);\n      border: 1px solid rgba(255,255,255,.08);\n      color: var(--text); padding: 10px 12px; border-radius: 10px;\n      cursor: pointer; transition: .15s transform ease, .2s background ease;\n      box-shadow: var(--shadow);\n      user-select:none;\n    }\n    .btn:hover { transform: translateY(-1px); }\n    .btn:active { transform: translateY(0); }\n    .btn.primary { background: linear-gradient(180deg, #2563eb22, #7c3aed22); border-color:#3b82f622; }\n    .btn.good    { background: linear-gradient(180deg, #10b98122, #0ea5e922); border-color:#34d39933; }\n    .btn.warn    { background: linear-gradient(180deg, #f59e0b22, #f9731622); border-color:#f59e0b33; }\n    .btn.bad     { background: linear-gradient(180deg, #ef444422, #b91c1c22); border-color:#ef444422; }\n\n    .layout {\n      display:grid; grid-template-columns: 1.5fr 1fr; gap: 18px;\n      padding: 0 20px 24px 20px;\n    }\n    @media (max-width: 1100px){ .layout{ grid-template-columns: 1fr; } }\n\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0));\n      border: 1px solid rgba(255,255,255,.06);\n      border-radius: 14px; box-shadow: var(--shadow);\n    }\n    .section-title {\n      padding: 12px 14px; color: var(--muted); font-size: 13px;\n      border-bottom: 1px solid rgba(255,255,255,.06);\n    }\n\n    /* Buckets grid */\n    #buckets {\n      padding: 12px; display:grid;\n      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));\n      gap: 12px;\n    }\n    .bucket {\n      background: var(--panel-2);\n      border: 1px solid rgba(255,255,255,.06);\n      border-radius: 12px; overflow:hidden; display:flex; flex-direction:column;\n      min-height: 82px;\n    }\n    .bucket header {\n      position: relative; top:0; border:none; background:none; box-shadow:none;\n      padding: 8px 10px; display:flex; align-items:center; gap:8px; justify-content:space-between;\n    }\n    .bucket header .idx { font-weight:700; color:#a5b4fc; font-size: 12px; }\n    .bucket header .count { font-size: 12px; color: var(--muted); }\n    .bucket .entries {\n      display:flex; flex-wrap: wrap; gap:8px; padding: 8px 10px 12px 10px; align-items:flex-start;\n      min-height: 48px;\n    }\n    .chip {\n      display:inline-flex; align-items:center; gap:6px; border-radius: 999px;\n      padding: 5px 8px; font-size: 12px; background: var(--chip);\n      border: 1px solid var(--chip-border);\n      color: var(--text); opacity:.95;\n      transition: box-shadow .15s ease, transform .15s ease, opacity .2s ease;\n      box-shadow: 0 1px rgba(255,255,255,.05) inset;\n      max-width: 100%;\n    }\n    .chip .key { font-weight: 600; }\n    .chip .val { color: var(--muted); }\n    .chip .dot { width:10px; height:10px; border-radius:50%; box-shadow: 0 0 0 2px rgba(255,255,255,.05) inset; flex: 0 0 auto; }\n    .chip.glow { box-shadow: 0 0 0 2px rgba(34,211,238,.4), 0 0 20px rgba(34,211,238,.15); transform: translateY(-1px); }\n    .chip.found { box-shadow: 0 0 0 2px rgba(52,211,153,.5), 0 0 20px rgba(52,211,153,.2); }\n    .chip.miss { opacity:.5; }\n    .bucket.highlight { outline: 2px solid rgba(34,211,238,.35); }\n    .bucket.pulse { animation: pulse 0.8s ease; }\n    @keyframes pulse {\n      0%{ box-shadow: 0 0 0 rgba(34,211,238,.0); }\n      50%{ box-shadow: 0 0 0 10px rgba(34,211,238,.15); }\n      100%{ box-shadow: 0 0 0 rgba(34,211,238,.0); }\n    }\n\n    /* Sidebar */\n    .stats, .hash, .log {\n      padding: 10px 12px 12px 12px;\n    }\n    .stat-grid {\n      display:grid; grid-template-columns: repeat(2, 1fr); gap: 10px;\n    }\n    .stat {\n      background: var(--panel-2); border: 1px solid rgba(255,255,255,.06);\n      border-radius: 10px; padding: 10px;\n    }\n    .stat .label { color: var(--muted); font-size: 12px; }\n    .stat .value { font-size: 18px; font-weight: 700; margin-top: 6px; }\n\n    .bar {\n      height: 8px; background: #0f172a; border-radius: 6px;\n      border: 1px solid rgba(255,255,255,.06); overflow:hidden;\n    }\n    .bar .fill {\n      height:100%; background: linear-gradient(90deg, #22d3ee, #a78bfa);\n      width: 0%;\n      transition: width .25s ease;\n    }\n\n    .hash-steps {\n      margin-top: 8px; max-height: 220px; overflow:auto; padding-right:4px;\n      border-radius: 8px; border: 1px solid rgba(255,255,255,.06);\n      background: var(--panel-2);\n    }\n    .hash-steps .row {\n      display:flex; gap:10px; padding: 6px 8px; border-bottom: 1px dashed rgba(255,255,255,.05);\n      font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace;\n      font-size: 12px;\n    }\n    .hash-steps .row:last-child { border-bottom: none; }\n    .hash-steps .row .i { width: 36px; color: var(--muted); }\n    .hash-steps .row .ch { width: 36px; }\n    .hash-steps .row .code { width: 60px; color: #a5b4fc; }\n    .hash-steps .row .acc { color: #93c5fd; }\n    .hash-summary { margin-top:8px; font-size: 12px; color: var(--muted); }\n\n    .log-list {\n      max-height: 260px; overflow:auto; padding-right:4px; display:flex; flex-direction:column; gap:6px;\n    }\n    .log-item {\n      font-size: 13px; color: #cbd5e1; background: var(--panel-2); border: 1px solid rgba(255,255,255,.06);\n      border-radius: 10px; padding: 8px 10px; display:flex; gap:8px; align-items:flex-start;\n    }\n    .log-item .t { color: var(--muted); font-size: 11px; margin-left:auto; }\n    .badge { font-size: 11px; padding: 2px 6px; border-radius: 999px; border: 1px solid rgba(255,255,255,.06);\n      background: #0b1220; color: var(--muted);\n    }\n    .row-controls { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }\n    .mini { padding: 6px 8px; font-size: 12px; border-radius: 8px; }\n\n    footer {\n      padding: 14px 20px; color: var(--muted); border-top: 1px solid rgba(255,255,255,.06);\n      font-size: 12px;\n    }\n    .inline { display:inline-flex; gap: 6px; align-items:center; }\n    .note { color: var(--muted); font-size: 12px; }\n    .toggle { display:flex; align-items:center; gap:8px; }\n    .toggle input { transform: translateY(1px); }\n    .hint { color: var(--muted); font-size: 12px; }\n\n    .subtle {\n      color: var(--muted); font-size: 12px;\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <div class=\"brand\">\n      <div class=\"logo\" aria-hidden=\"true\"></div>\n      <div>\n        Hash Map Visualizer\n        <div><small>Separate chaining • interactive demo</small></div>\n      </div>\n    </div>\n    <div class=\"row-controls\">\n      <div class=\"toggle\">\n        <input type=\"checkbox\" id=\"autoResize\" checked>\n        <label for=\"autoResize\" class=\"subtle\">Auto-resize</label>\n      </div>\n      <div class=\"inline subtle\">\n        Load factor\n        <input type=\"range\" id=\"lfRange\" min=\"0.50\" max=\"0.95\" step=\"0.05\" value=\"0.75\" />\n        <span id=\"lfLabel\">0.75</span>\n      </div>\n      <div class=\"inline subtle\">\n        Hash\n        <select id=\"hashSelect\">\n          <option value=\"djb2\">djb2</option>\n          <option value=\"poly31\">Polynomial (x*31+c)</option>\n          <option value=\"sum\">Sum of char codes</option>\n        </select>\n      </div>\n      <button class=\"btn mini\" id=\"btnRehash\">Rehash now</button>\n    </div>\n  </header>\n\n  <div class=\"controls\">\n    <div class=\"control\" style=\"min-width:200px;flex:1\">\n      <label for=\"keyInput\">Key</label>\n      <input type=\"text\" id=\"keyInput\" placeholder=\"e.g., username, foo, 42\" />\n    </div>\n    <div class=\"control\" style=\"min-width:200px;flex:1\">\n      <label for=\"valInput\">Value</label>\n      <input type=\"text\" id=\"valInput\" placeholder=\"e.g., Alice, bar, any text\" />\n    </div>\n    <div class=\"control\" style=\"min-width:140px\">\n      <label>&nbsp;</label>\n      <div class=\"row-controls\">\n        <button class=\"btn primary\" id=\"btnSet\">Put</button>\n        <button class=\"btn\" id=\"btnGet\">Get</button>\n        <button class=\"btn warn\" id=\"btnHas\">Has</button>\n        <button class=\"btn bad\" id=\"btnDel\">Delete</button>\n      </div>\n    </div>\n    <div class=\"control\" style=\"min-width:220px; max-width: 360px; flex:1\">\n      <label>Quick actions</label>\n      <div class=\"row-controls\">\n        <button class=\"btn good\" id=\"btnRandom\">Insert random</button>\n        <button class=\"btn\" id=\"btnBulk50\">Bulk 50</button>\n        <button class=\"btn\" id=\"btnCollide\">Insert colliding keys</button>\n        <button class=\"btn\" id=\"btnReset\">Reset</button>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"layout\">\n    <div class=\"panel\">\n      <div class=\"section-title\">Buckets</div>\n      <div id=\"buckets\"></div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"section-title\">Inspector & stats</div>\n      <div class=\"stats\">\n        <div class=\"stat-grid\">\n          <div class=\"stat\">\n            <div class=\"label\">Capacity (buckets)</div>\n            <div class=\"value\" id=\"statCapacity\">-</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"label\">Size (entries)</div>\n            <div class=\"value\" id=\"statSize\">-</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"label inline\">Load factor\n              <span class=\"badge\" id=\"statLFThresh\">-</span>\n            </div>\n            <div>\n              <div class=\"bar\"><div class=\"fill\" id=\"lfFill\"></div></div>\n              <div class=\"hint\" id=\"lfText\">-</div>\n            </div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"label\">Used buckets</div>\n            <div class=\"value\" id=\"statUsed\">-</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"label\">Max chain length</div>\n            <div class=\"value\" id=\"statMaxChain\">-</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"label\">Collisions (insert)</div>\n            <div class=\"value\" id=\"statCollisions\">-</div>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"hash\">\n        <div class=\"inline\" style=\"gap:10px; margin-bottom:6px;\">\n          <div class=\"subtle\">Hash explorer</div>\n        </div>\n        <div class=\"row-controls\" style=\"margin-bottom:8px;\">\n          <input id=\"inspectInput\" type=\"text\" placeholder=\"Type a key to hash...\" style=\"flex:1; min-width:200px;\">\n          <button class=\"btn mini\" id=\"btnCompute\">Compute hash</button>\n          <span class=\"badge\" id=\"inspectIndexBadge\" title=\"Bucket index\"></span>\n        </div>\n        <div class=\"hash-steps\" id=\"hashSteps\"></div>\n        <div class=\"hash-summary\" id=\"hashSummary\"></div>\n      </div>\n\n      <div class=\"log\">\n        <div class=\"inline\" style=\"gap:10px; margin-bottom:6px;\">\n          <div class=\"subtle\">Operation log</div>\n          <button class=\"btn mini\" id=\"btnClearLog\" title=\"Clear log\">Clear</button>\n        </div>\n        <div class=\"log-list\" id=\"logList\"></div>\n      </div>\n    </div>\n  </div>\n\n  <footer>\n    This interactive demo shows a hash map using separate chaining:\n    keys are hashed to an index and each bucket stores a chain (list) of entries with the same index.\n    Use Put/Get/Delete and watch collisions and chains evolve. Toggle auto-resize and change the hash function to see how distribution changes.\n  </footer>\n\n  <script>\n    // Utility: colors, randoms, time\n    const Utils = {\n      toUInt32(x){ return x >>> 0; },\n      clamp(v, a, b){ return Math.max(a, Math.min(b, v)); },\n      time(){ const d=new Date(); return d.toLocaleTimeString(); },\n      nextPow2(n){\n        n = Math.max(1, n|0);\n        n--;\n        n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16;\n        return (n+1) >>> 0;\n      },\n      colorFromHash(h){\n        // derive a pleasant color from hash bits\n        const r = (h & 0xFF);\n        const g = (h >>> 8) & 0xFF;\n        const b = (h >>> 16) & 0xFF;\n        const lighten = 0.6; // mix with 255 for lighter chips\n        const rr = Math.floor(r*lighten + 255*(1-lighten));\n        const gg = Math.floor(g*lighten + 255*(1-lighten));\n        const bb = Math.floor(b*lighten + 255*(1-lighten));\n        return `rgb(${rr}, ${gg}, ${bb})`;\n      },\n      randWord(){\n        const syll = [\"ka\",\"zu\",\"mi\",\"ra\",\"to\",\"ne\",\"li\",\"so\",\"va\",\"qu\",\"re\",\"do\",\"pa\",\"xi\",\"no\",\"fa\",\"jo\",\"yu\",\"ti\",\"mo\",\"sa\",\"lu\",\"be\",\"di\"];\n        const n = 2 + Math.floor(Math.random()*3);\n        let s=\"\"; for(let i=0;i<n;i++){ s+= syll[Math.floor(Math.random()*syll.length)]; }\n        return s;\n      },\n      randKV(){\n        const k = `${Utils.randWord()}-${Math.floor(Math.random()*999)}`;\n        const v = [\"alpha\",\"bravo\",\"charlie\",\"delta\",\"echo\",\"foxtrot\",\"golf\",\"hotel\",\"india\"][Math.floor(Math.random()*9)] + \" \" + Utils.randWord();\n        return [k,v];\n      },\n      collidingKeys(hashName, count, base=\"X\"){\n        // Try to generate strings that collide for simple hash functions.\n        // Works well for \"sum\" and passable for \"poly31\" by using anagrams.\n        // For djb2, this is probabilistic; we'll bias by repeating same key with numeric suffix.\n        const keys=[];\n        if(hashName === \"sum\"){\n          // Same sum: keep sum of char codes constant\n          // Start with a base and vary pairs that keep sum constant (e.g., 'A'(65) <-> 'B'(66) and 'a'(97) <-> '`'(96))\n          let seed = \"AAAA\"; // sum = 260\n          keys.push(seed);\n          const options = [[\"A\",\"B\",\"`\",\"a\"], [\"C\",\"D\",\"e\",\"f\"], [\"M\",\"N\",\"o\",\"p\"], [\"X\",\"Y\",\"{\",\"|\"]];\n          let made=1;\n          while(made < count){\n            let s = seed.split(\"\");\n            const idx = Math.floor(Math.random()*s.length);\n            const pair = options[Math.floor(Math.random()*options.length)];\n            // Replace two chars to keep sum same\n            s[idx] = pair[0]; // +1\n            const j = (idx+1) % s.length;\n            s[j] = pair[2]; // -1 counterpart\n            keys.push(s.join(\"\"));\n            made++;\n          }\n        } else if(hashName === \"poly31\"){\n          // Anagrams often collide less here, but for small strings, anagrams differ.\n          // We'll enforce same characters with different order and hope for some collisions in small capacity.\n          const baseChars = (base + \"abcd\").split(\"\");\n          for(let i=0;i<count;i++){\n            keys.push(baseChars.sort(()=>Math.random()-.5).join(\"\") + i);\n          }\n        } else {\n          // djb2: fallback to same prefix + varying padding that often hit same bucket for small capacities\n          const prefix = base + \"-dj\";\n          for(let i=0;i<count;i++){\n            keys.push(prefix + ((i%3===0)?\"!!!!\":\"\") + i);\n          }\n        }\n        return keys;\n      }\n    };\n\n    // Hash functions + step recorders\n    const Hashers = {\n      sum(key, withSteps=false){\n        let acc = 0>>>0; const steps=[];\n        for(let i=0;i<key.length;i++){\n          const code = key.charCodeAt(i) >>> 0;\n          acc = Utils.toUInt32((acc + code) | 0);\n          if(withSteps) steps.push({i, ch:key[i], code, acc});\n        }\n        return withSteps ? {hash:acc>>>0, steps} : acc>>>0;\n      },\n      poly31(key, withSteps=false){\n        let acc = 0|0; const steps=[];\n        for(let i=0;i<key.length;i++){\n          const code = key.charCodeAt(i) >>> 0;\n          acc = (Math.imul(acc,31) + code) | 0;\n          const u = acc>>>0;\n          if(withSteps) steps.push({i, ch:key[i], code, acc:u});\n        }\n        return withSteps ? {hash:acc>>>0, steps} : acc>>>0;\n      },\n      djb2(key, withSteps=false){\n        let acc = 5381|0; const steps=[];\n        for(let i=0;i<key.length;i++){\n          const code = key.charCodeAt(i) >>> 0;\n          acc = (((acc << 5) + acc) + code) | 0; // acc*33 + code\n          const u = acc>>>0;\n          if(withSteps) steps.push({i, ch:key[i], code, acc:u});\n        }\n        const u = acc>>>0;\n        return withSteps ? {hash:u, steps} : u;\n      },\n      withSteps(name, key){\n        if(name===\"sum\")   return Hashers.sum(key,true);\n        if(name===\"poly31\")return Hashers.poly31(key,true);\n        return Hashers.djb2(key,true);\n      },\n      run(name, key){\n        if(name===\"sum\")   return Hashers.sum(key,false);\n        if(name===\"poly31\")return Hashers.poly31(key,false);\n        return Hashers.djb2(key,false);\n      }\n    };\n\n    // HashMap with separate chaining\n    class HashMapChaining {\n      constructor({capacity=8, loadFactor=0.75, hashName=\"djb2\", autoResize=true}={}){\n        this.capacity = Math.max(4, Utils.nextPow2(capacity|0));\n        this.buckets = Array.from({length:this.capacity}, ()=>[]);\n        this.size = 0;\n        this.loadFactor = loadFactor;\n        this.hashName = hashName;\n        this.collisionCount = 0;\n        this.autoResize = autoResize;\n      }\n      setHash(name){ this.hashName = name; }\n      setLoadFactor(lf){ this.loadFactor = lf; }\n      setAutoResize(ar){ this.autoResize = !!ar; }\n      _hash(key){ return Hashers.run(this.hashName, key); }\n      _index(hash){ return hash % this.capacity; }\n      clear(){\n        this.buckets = Array.from({length:this.capacity}, ()=>[]);\n        this.size = 0;\n        this.collisionCount = 0;\n      }\n      has(key){\n        key = String(key);\n        const h = this._hash(key);\n        const idx = this._index(h);\n        const bucket = this.buckets[idx];\n        for(const e of bucket){\n          if(e.key === key) return true;\n        }\n        return false;\n      }\n      get(key){\n        key = String(key);\n        const h = this._hash(key);\n        const idx = this._index(h);\n        const bucket = this.buckets[idx];\n        for(let i=0;i<bucket.length;i++){\n          const e = bucket[i];\n          if(e.key === key){\n            return {value:e.value, bucketIndex: idx, entryIndex: i, found: true, hash:h};\n          }\n        }\n        return {value:undefined, bucketIndex: idx, entryIndex: -1, found: false, hash:h};\n      }\n      set(key, value){\n        key = String(key);\n        const h = this._hash(key);\n        const idx = this._index(h);\n        const bucket = this.buckets[idx];\n        // Update if exists\n        for(let i=0;i<bucket.length;i++){\n          const e = bucket[i];\n          if(e.key === key){\n            e.value = value;\n            return {updated:true, inserted:false, bucketIndex:idx, entryIndex:i, hash:h, collision:false};\n          }\n        }\n        // Insert\n        const collision = bucket.length > 0;\n        if(collision) this.collisionCount++;\n        bucket.push({hash:h, key, value});\n        this.size++;\n        // Resize if needed\n        let resized = false, oldCap = this.capacity;\n        if(this.autoResize && (this.size / this.capacity) > this.loadFactor){\n          this._resize(this.capacity * 2);\n          resized = true;\n        }\n        const entryIndex = this.buckets[resized? this._index(h) : idx].length - 1;\n        const newIdx = resized ? this._index(h) : idx;\n        return {updated:false, inserted:true, bucketIndex:newIdx, entryIndex, hash:h, collision, resized, oldCap, newCap:this.capacity};\n      }\n      delete(key){\n        key = String(key);\n        const h = this._hash(key);\n        const idx = this._index(h);\n        const bucket = this.buckets[idx];\n        for(let i=0;i<bucket.length;i++){\n          if(bucket[i].key === key){\n            const removed = bucket.splice(i,1)[0];\n            this.size--;\n            return {removed:true, bucketIndex:idx, entryIndex:i, hash:h, value:removed.value};\n          }\n        }\n        return {removed:false, bucketIndex:idx, entryIndex:-1, hash:h};\n      }\n      entries(){\n        const out = [];\n        for(const bucket of this.buckets){\n          for(const e of bucket) out.push([e.key, e.value]);\n        }\n        return out;\n      }\n      _resize(newCap){\n        newCap = Math.max(4, Utils.nextPow2(newCap|0));\n        const old = this.buckets;\n        this.buckets = Array.from({length:newCap}, ()=>[]);\n        this.capacity = newCap;\n        // Rehash\n        for(const b of old){\n          for(const e of b){\n            const idx = this._index(e.hash);\n            this.buckets[idx].push(e);\n          }\n        }\n      }\n      stats(){\n        let used = 0, maxChain = 0;\n        for(const b of this.buckets){\n          if(b.length>0) used++;\n          if(b.length>maxChain) maxChain = b.length;\n        }\n        return {\n          capacity: this.capacity,\n          size: this.size,\n          usedBuckets: used,\n          maxChain,\n          load: this.size / this.capacity,\n          collisions: this.collisionCount\n        };\n      }\n    }\n\n    // App state\n    const state = {\n      map: new HashMapChaining({capacity:8, loadFactor:0.75, hashName:\"djb2\", autoResize:true}),\n      highlight: null, // {bucketIndex, entryIndex, mode: 'set'|'get'|'del', found, pathLength}\n      logs: []\n    };\n\n    // DOM refs\n    const el = {\n      buckets: document.getElementById(\"buckets\"),\n      statCapacity: document.getElementById(\"statCapacity\"),\n      statSize: document.getElementById(\"statSize\"),\n      statUsed: document.getElementById(\"statUsed\"),\n      statMaxChain: document.getElementById(\"statMaxChain\"),\n      statCollisions: document.getElementById(\"statCollisions\"),\n      lfFill: document.getElementById(\"lfFill\"),\n      lfText: document.getElementById(\"lfText\"),\n      lfRange: document.getElementById(\"lfRange\"),\n      lfLabel: document.getElementById(\"lfLabel\"),\n      statLFThresh: document.getElementById(\"statLFThresh\"),\n      keyInput: document.getElementById(\"keyInput\"),\n      valInput: document.getElementById(\"valInput\"),\n\n      btnSet: document.getElementById(\"btnSet\"),\n      btnGet: document.getElementById(\"btnGet\"),\n      btnDel: document.getElementById(\"btnDel\"),\n      btnHas: document.getElementById(\"btnHas\"),\n      btnRandom: document.getElementById(\"btnRandom\"),\n      btnBulk50: document.getElementById(\"btnBulk50\"),\n      btnReset: document.getElementById(\"btnReset\"),\n      btnCollide: document.getElementById(\"btnCollide\"),\n\n      autoResize: document.getElementById(\"autoResize\"),\n      btnRehash: document.getElementById(\"btnRehash\"),\n      hashSelect: document.getElementById(\"hashSelect\"),\n\n      inspectInput: document.getElementById(\"inspectInput\"),\n      inspectIndexBadge: document.getElementById(\"inspectIndexBadge\"),\n      btnCompute: document.getElementById(\"btnCompute\"),\n      hashSteps: document.getElementById(\"hashSteps\"),\n      hashSummary: document.getElementById(\"hashSummary\"),\n\n      logList: document.getElementById(\"logList\"),\n      btnClearLog: document.getElementById(\"btnClearLog\"),\n    };\n\n    function render(){\n      renderBuckets();\n      renderStats();\n      renderLog();\n    }\n\n    function renderBuckets(){\n      const {buckets} = state.map;\n      const h = state.highlight;\n      el.buckets.innerHTML = \"\";\n      for(let i=0;i<buckets.length;i++){\n        const bucket = buckets[i];\n        const wrap = document.createElement(\"div\");\n        wrap.className = \"bucket\" + (h && h.bucketIndex===i ? \" highlight pulse\" : \"\");\n        const header = document.createElement(\"header\");\n        header.innerHTML = `\n          <div class=\"idx\">Bucket ${i}</div>\n          <div class=\"count\">${bucket.length} entr${bucket.length===1?'y':'ies'}</div>\n        `;\n        const entries = document.createElement(\"div\");\n        entries.className = \"entries\";\n        for(let j=0;j<bucket.length;j++){\n          const e = bucket[j];\n          const chip = document.createElement(\"div\");\n          chip.className = \"chip\";\n          chip.title = `key=\"${e.key}\" value=\"${e.value}\"\\nhash=0x${e.hash.toString(16)} • idx=${i} • pos=${j}`;\n          const dot = document.createElement(\"span\");\n          dot.className = \"dot\";\n          dot.style.background = Utils.colorFromHash(e.hash);\n          const key = document.createElement(\"span\");\n          key.className = \"key\";\n          key.textContent = e.key.length>16 ? e.key.slice(0,16)+\"…\" : e.key;\n          const val = document.createElement(\"span\");\n          val.className = \"val\";\n          val.textContent = String(e.value).length>14 ? String(e.value).slice(0,14)+\"…\" : String(e.value);\n          chip.append(dot, key, val);\n\n          // highlight path for last op\n          if(h && h.bucketIndex === i){\n            if(h.mode === 'get' || h.mode === 'del'){\n              if(j <= (h.entryIndex < 0 ? bucket.length-1 : h.entryIndex)){\n                chip.classList.add(\"glow\");\n              }\n              if(h.entryIndex === j && h.found){\n                chip.classList.add(\"found\");\n              }\n              if(!h.found && j === bucket.length-1){\n                chip.classList.add(\"miss\");\n              }\n            } else if(h.mode === 'set'){\n              if(h.entryIndex === j) chip.classList.add(\"found\");\n              if(h.collision && j < h.entryIndex) chip.classList.add(\"glow\");\n            }\n          }\n\n          entries.appendChild(chip);\n        }\n        // empty hint\n        if(bucket.length===0){\n          const empty = document.createElement(\"div\");\n          empty.className = \"hint\";\n          empty.style.padding = \"8px 10px 12px 10px\";\n          empty.textContent = \"empty\";\n          entries.appendChild(empty);\n        }\n\n        wrap.append(header, entries);\n        el.buckets.appendChild(wrap);\n      }\n    }\n\n    function renderStats(){\n      const s = state.map.stats();\n      el.statCapacity.textContent = s.capacity;\n      el.statSize.textContent = s.size;\n      el.statUsed.textContent = s.usedBuckets;\n      el.statMaxChain.textContent = s.maxChain;\n      el.statCollisions.textContent = s.collisions;\n      const thresh = state.map.loadFactor;\n      const pct = Math.min(100, (s.load / thresh) * 100);\n      el.lfFill.style.width = `${pct}%`;\n      el.lfText.textContent = `${(s.load).toFixed(3)} = size/capacity = ${s.size}/${s.capacity}`;\n      el.statLFThresh.textContent = `threshold ${thresh}`;\n      el.inspectIndexBadge.textContent = \"\";\n    }\n\n    function log(message, kind=\"info\"){\n      const icon = kind===\"good\" ? \"✅\" : kind===\"warn\" ? \"⚠️\" : kind===\"bad\" ? \"🗑️\" : kind===\"hash\" ? \"🔢\" : \"ℹ️\";\n      state.logs.unshift({t:Utils.time(), msg: `${icon} ${message}`});\n      if(state.logs.length > 120) state.logs.pop();\n      renderLog();\n    }\n\n    function renderLog(){\n      el.logList.innerHTML = \"\";\n      for(const item of state.logs){\n        const div = document.createElement(\"div\");\n        div.className = \"log-item\";\n        const spanMsg = document.createElement(\"div\");\n        spanMsg.textContent = item.msg;\n        const spanTime = document.createElement(\"div\");\n        spanTime.className = \"t\";\n        spanTime.textContent = item.t;\n        div.append(spanMsg, spanTime);\n        el.logList.appendChild(div);\n      }\n    }\n\n    // Actions\n    function doSet(){\n      const k = el.keyInput.value.trim();\n      const v = el.valInput.value;\n      if(!k){ shake(el.keyInput); return; }\n      const res = state.map.set(k, v);\n      state.highlight = {\n        bucketIndex: res.bucketIndex, entryIndex: res.entryIndex,\n        mode: 'set', found: true, collision: res.collision\n      };\n      if(res.updated){\n        log(`Put: updated key=\"${k}\" at bucket ${res.bucketIndex}, entry ${res.entryIndex}`, \"good\");\n      } else {\n        log(`Put: inserted key=\"${k}\" at bucket ${res.bucketIndex}, entry ${res.entryIndex}` + (res.collision?\" (collision)\":\"\"));\n      }\n      if(res.resized){\n        log(`Auto-resize: capacity ${res.oldCap} → ${res.newCap}`, \"warn\");\n      }\n      render();\n    }\n\n    function doGet(){\n      const k = el.keyInput.value.trim();\n      if(!k){ shake(el.keyInput); return; }\n      const res = state.map.get(k);\n      state.highlight = {\n        bucketIndex: res.bucketIndex, entryIndex: res.entryIndex,\n        mode: 'get', found: res.found\n      };\n      if(res.found){\n        log(`Get: key=\"${k}\" found at bucket ${res.bucketIndex}, entry ${res.entryIndex}, value=\"${res.value}\"`, \"good\");\n        el.valInput.value = String(res.value);\n      } else {\n        log(`Get: key=\"${k}\" not found (bucket ${res.bucketIndex})`, \"bad\");\n      }\n      render();\n    }\n\n    function doHas(){\n      const k = el.keyInput.value.trim();\n      if(!k){ shake(el.keyInput); return; }\n      const r = state.map.get(k);\n      state.highlight = {\n        bucketIndex: r.bucketIndex, entryIndex: r.entryIndex,\n        mode: 'get', found: r.found\n      };\n      log(`Has: key=\"${k}\" = ${r.found ? \"true\" : \"false\"} (bucket ${r.bucketIndex})`, r.found ? \"good\" : \"bad\");\n      render();\n    }\n\n    function doDel(){\n      const k = el.keyInput.value.trim();\n      if(!k){ shake(el.keyInput); return; }\n      const res = state.map.delete(k);\n      state.highlight = {\n        bucketIndex: res.bucketIndex, entryIndex: res.entryIndex,\n        mode: 'del', found: res.removed\n      };\n      if(res.removed){\n        log(`Delete: key=\"${k}\" removed from bucket ${res.bucketIndex}, entry ${res.entryIndex}`, \"bad\");\n      } else {\n        log(`Delete: key=\"${k}\" not found (bucket ${res.bucketIndex})`, \"warn\");\n      }\n      render();\n    }\n\n    function doRandom(){\n      const [k,v] = Utils.randKV();\n      el.keyInput.value = k;\n      el.valInput.value = v;\n      doSet();\n    }\n\n    function doBulk(n=50){\n      for(let i=0;i<n;i++){\n        const [k,v] = Utils.randKV();\n        state.map.set(k, v);\n      }\n      state.highlight = null;\n      log(`Inserted ${n} random entries`, \"good\");\n      render();\n    }\n\n    function doCollide(){\n      const list = Utils.collidingKeys(state.map.hashName, 10, \"C\");\n      for(const k of list){\n        state.map.set(k, k.toUpperCase());\n      }\n      state.highlight = null;\n      log(`Inserted ${list.length} keys designed to collide (hash=${state.map.hashName})`, \"warn\");\n      render();\n    }\n\n    function doReset(){\n      const cap = state.map.capacity;\n      state.map = new HashMapChaining({\n        capacity: cap, loadFactor: state.map.loadFactor,\n        hashName: state.map.hashName, autoResize: state.map.autoResize\n      });\n      state.highlight = null;\n      log(\"Reset: cleared all entries\", \"warn\");\n      render();\n    }\n\n    function doRehash(){\n      // Rehash at current capacity to redistribute after hash function change\n      const entries = state.map.entries();\n      state.map.clear();\n      for(const [k,v] of entries){\n        state.map.set(k, v);\n      }\n      state.highlight = null;\n      log(\"Rehashed all entries with current hash function\", \"hash\");\n      render();\n    }\n\n    function shake(input){\n      input.style.transition = \"transform .1s ease\";\n      input.style.transform = \"translateX(4px)\";\n      setTimeout(()=> input.style.transform=\"translateX(-4px)\", 60);\n      setTimeout(()=> input.style.transform=\"\", 120);\n    }\n\n    // Hash explorer\n    function computeHashSteps(){\n      const k = el.inspectInput.value;\n      const {hash, steps} = Hashers.withSteps(state.map.hashName, k);\n      const idx = (hash % state.map.capacity) >>> 0;\n      el.hashSteps.innerHTML = \"\";\n      if(k.length === 0){\n        el.hashSummary.textContent = \"Type a key to see how the hash evolves\";\n        el.inspectIndexBadge.textContent = \"\";\n        return;\n      }\n      for(const s of steps){\n        const row = document.createElement(\"div\");\n        row.className = \"row\";\n        row.innerHTML = `\n          <div class=\"i\">#${s.i}</div>\n          <div class=\"ch\">${s.ch || \"␀\"}</div>\n          <div class=\"code\">${s.code}</div>\n          <div class=\"acc\">acc = ${s.acc}</div>\n        `;\n        el.hashSteps.appendChild(row);\n      }\n      el.hashSummary.textContent = `final hash = ${hash} (0x${hash.toString(16)}), bucket index = hash % capacity = ${hash} % ${state.map.capacity} = ${idx}`;\n      el.inspectIndexBadge.textContent = `→ bucket ${idx}`;\n    }\n\n    // Bind events\n    el.btnSet.addEventListener(\"click\", doSet);\n    el.btnGet.addEventListener(\"click\", doGet);\n    el.btnDel.addEventListener(\"click\", doDel);\n    el.btnHas.addEventListener(\"click\", doHas);\n\n    el.btnRandom.addEventListener(\"click\", doRandom);\n    el.btnBulk50.addEventListener(\"click\", ()=>doBulk(50));\n    el.btnReset.addEventListener(\"click\", doReset);\n    el.btnCollide.addEventListener(\"click\", doCollide);\n\n    el.lfRange.addEventListener(\"input\", (e)=>{\n      const v = parseFloat(e.target.value);\n      state.map.setLoadFactor(v);\n      el.lfLabel.textContent = v.toFixed(2);\n      renderStats();\n    });\n\n    el.autoResize.addEventListener(\"change\", (e)=>{\n      state.map.setAutoResize(e.target.checked);\n      log(`Auto-resize ${e.target.checked ? \"enabled\" : \"disabled\"}`);\n    });\n\n    el.hashSelect.addEventListener(\"change\", (e)=>{\n      state.map.setHash(e.target.value);\n      log(`Hash function set to \"${e.target.value}\"`, \"hash\");\n      // Update inspector view if open\n      computeHashSteps();\n      render();\n    });\n\n    el.btnRehash.addEventListener(\"click\", doRehash);\n\n    el.btnCompute.addEventListener(\"click\", computeHashSteps);\n    el.inspectInput.addEventListener(\"keydown\", (e)=>{\n      if(e.key === \"Enter\") computeHashSteps();\n    });\n\n    el.keyInput.addEventListener(\"keydown\", (e)=>{\n      if(e.key === \"Enter\") doSet();\n    });\n    el.valInput.addEventListener(\"keydown\", (e)=>{\n      if(e.key === \"Enter\") doSet();\n    });\n\n    el.btnClearLog.addEventListener(\"click\", ()=>{\n      state.logs = [];\n      renderLog();\n    });\n\n    // Initial render\n    render();\n    log(\"Ready. Insert keys with Put, then Get/Delete/Has. Change hash function or load factor to observe distribution.\");\n\n    // Example seed data\n    (function seed(){\n      const items = [[\"user\",\"Alice\"],[\"lang\",\"TypeScript\"],[\"color\",\"teal\"],[\"mode\",\"chaining\"],[\"pi\",\"3.14159\"]];\n      for(const [k,v] of items) state.map.set(k,v);\n      render();\n    })();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Hash Map"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "a589c080-a368-11f0-82df-11dbdef9a8f8",
    "timestamp": "2025-10-07T10:30:29.768Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Set",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>JavaScript Set — Interactive Playground</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f1320;\n      --panel: #171c2c;\n      --panel-2: #1f263d;\n      --text: #e9ecf1;\n      --muted: #aab2c8;\n      --accent: #6cc0ff;\n      --accent-2: #b28cff;\n      --ok: #6ce27a;\n      --warn: #ffd466;\n      --bad: #ff7d7d;\n      --chip: #283153;\n      --chip-hover: #323d67;\n      --btn: #2a3356;\n      --btn-hover: #334073;\n      --input: #1c2340;\n      --border: #2b355b;\n      --shadow: 0 6px 24px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.03);\n      --radius: 12px;\n    }\n    * { box-sizing: border-box; }\n    html, body {\n      margin: 0;\n      height: 100%;\n      background: radial-gradient(1200px 900px at 10% -10%, #1b2140, transparent),\n                  radial-gradient(900px 900px at 110% -20%, #1d1f34, transparent),\n                  var(--bg);\n      color: var(--text);\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n    }\n    a { color: var(--accent); text-decoration: none; }\n    .wrap {\n      max-width: 1200px;\n      margin: 0 auto;\n      padding: 28px 18px 56px;\n    }\n    header {\n      display: grid;\n      gap: 8px;\n      margin-bottom: 18px;\n    }\n    h1 {\n      margin: 0;\n      font-weight: 800;\n      font-size: 28px;\n      letter-spacing: 0.2px;\n      color: #ffffff;\n      text-shadow: 0 2px 16px rgba(108,192,255,0.25);\n    }\n    p.sub {\n      margin: 0;\n      color: var(--muted);\n      font-size: 14px;\n    }\n    .facts {\n      background: linear-gradient(180deg, rgba(255,255,255,0.03), transparent), var(--panel);\n      border: 1px solid var(--border);\n      border-radius: var(--radius);\n      box-shadow: var(--shadow);\n      padding: 12px 14px;\n      color: var(--muted);\n      font-size: 14px;\n      margin-bottom: 18px;\n    }\n    .facts ul { padding-left: 18px; margin: 8px 0 0; }\n    .grid {\n      display: grid;\n      gap: 16px;\n      grid-template-columns: 1fr;\n    }\n    @media (min-width: 980px) {\n      .grid {\n        grid-template-columns: 1fr 1fr;\n      }\n      .grid-3 {\n        grid-template-columns: 1fr 1fr 1fr;\n      }\n    }\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.03), transparent), var(--panel);\n      border: 1px solid var(--border);\n      border-radius: var(--radius);\n      box-shadow: var(--shadow);\n      padding: 14px;\n    }\n    .panel h2, .panel h3 {\n      margin: 0 0 10px 0;\n      font-size: 18px;\n      font-weight: 700;\n      color: #ffffff;\n    }\n    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }\n    .grow { flex: 1 1 220px; }\n    input, textarea, select {\n      background: var(--input);\n      color: var(--text);\n      border: 1px solid var(--border);\n      border-radius: 10px;\n      padding: 10px 12px;\n      box-shadow: inset 0 1px 0 rgba(255,255,255,0.03);\n      outline: none;\n      width: 100%;\n    }\n    textarea { min-height: 72px; resize: vertical; }\n    .hint {\n      color: var(--muted);\n      font-size: 12px;\n      margin-top: 6px;\n    }\n    button {\n      background: var(--btn);\n      color: var(--text);\n      border: 1px solid var(--border);\n      border-radius: 10px;\n      padding: 10px 12px;\n      cursor: pointer;\n      transition: 0.15s ease;\n    }\n    button:hover { background: var(--btn-hover); transform: translateY(-1px); }\n    button:active { transform: translateY(0); }\n    button.primary {\n      background: linear-gradient(180deg, rgba(255,255,255,0.08), transparent), #2a3a74;\n      border-color: #3b4c94;\n    }\n    button.ok { background: #224a36; border-color: #2b6b4b; }\n    button.warn { background: #5a4b24; border-color: #80692f; }\n    button.bad { background: #5a2b2b; border-color: #7a3a3a; }\n    .badge {\n      display: inline-flex; align-items: center; justify-content: center;\n      min-width: 26px; height: 22px; padding: 0 8px;\n      background: #23315a; border: 1px solid var(--border);\n      border-radius: 999px; color: #d9e2ff; font-size: 12px;\n    }\n    .stack { display: grid; gap: 10px; }\n    .chips {\n      display: flex; flex-wrap: wrap; gap: 8px;\n      padding: 10px; border-radius: 10px;\n      background: var(--panel-2);\n      border: 1px dashed var(--border);\n      min-height: 52px;\n    }\n    .chip {\n      display: inline-flex; align-items: center; gap: 8px;\n      background: var(--chip); border: 1px solid var(--border);\n      color: #e9eeff; padding: 8px 10px; border-radius: 999px;\n      font-size: 13px; user-select: none;\n      transition: 0.12s ease;\n    }\n    .chip:hover { background: var(--chip-hover); }\n    .chip small {\n      color: var(--muted); font-size: 11px; margin-left: 2px;\n    }\n    .chip button {\n      border-radius: 999px; padding: 4px 7px; font-size: 12px;\n      background: #3a446e; border-color: #4a578f;\n    }\n    .flex {\n      display: flex; align-items: center; gap: 12px; flex-wrap: wrap;\n    }\n    .section-title {\n      font-size: 20px; font-weight: 800; margin: 22px 0 10px;\n      color: #ffffff;\n    }\n    .results {\n      background: var(--panel-2);\n      border: 1px solid var(--border);\n      border-radius: 10px;\n      padding: 10px;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, \"Liberation Mono\", monospace;\n      font-size: 13px;\n      color: #dfe6ff;\n      min-height: 46px;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n    .legend {\n      color: var(--muted); font-size: 12px;\n    }\n    .log {\n      background: #13182c; border: 1px solid var(--border); border-radius: 10px;\n      padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, \"Liberation Mono\", monospace;\n      font-size: 12px; color: #dfe6ff; height: 200px; overflow: auto;\n    }\n    .row-slim { display: flex; gap: 8px; align-items: center; }\n    .pill {\n      display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px;\n      background: #222a4a; border: 1px solid var(--border); border-radius: 999px;\n      color: var(--muted); font-size: 12px;\n    }\n    .sep { height: 1px; background: var(--border); margin: 8px 0; }\n    footer { margin-top: 24px; color: var(--muted); font-size: 12px; text-align: center; }\n    code.kbd {\n      background: #252f57; border: 1px solid var(--border);\n      border-radius: 6px; padding: 1px 6px; font-size: 12px; color: #e6ecff;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <header>\n      <h1>JavaScript Set — Interactive Playground</h1>\n      <p class=\"sub\">Explore Set basics, uniqueness rules, iteration, and common set operations with live examples.</p>\n    </header>\n\n    <div class=\"facts\">\n      Quick facts:\n      <ul>\n        <li>Set stores unique values of any type, preserving insertion order.</li>\n        <li>Equality uses SameValueZero: NaN equals NaN, -0 is treated as 0, objects compare by reference.</li>\n        <li>Common operations: add, has, delete, size, iterate; set algebra via simple helpers (union, intersection, difference).</li>\n      </ul>\n    </div>\n\n    <div class=\"grid\">\n      <div class=\"panel\" id=\"panelA\">\n        <h2>Set A <span class=\"badge\" id=\"sizeA\">0</span></h2>\n        <div class=\"stack\">\n          <div class=\"row\">\n            <input class=\"grow\" id=\"inputA\" placeholder='Enter a value: 42, \"hi\", true, null, [1,2], {\"a\":1}, NaN, Infinity, 123n, Symbol(tag), date(2020-01-01)' />\n            <button class=\"primary\" id=\"addA\">Add</button>\n            <button id=\"hasA\">Has?</button>\n            <button class=\"warn\" id=\"delA\">Delete</button>\n            <button class=\"bad\" id=\"clearA\">Clear</button>\n          </div>\n          <div class=\"hint\">Tip: Strings need quotes, objects/arrays use JSON. Supports special values: NaN, Infinity, -Infinity, -0, BigInt with n suffix, Symbol(desc), date(ISO).</div>\n          <div class=\"row\">\n            <textarea class=\"grow\" id=\"bulkA\" placeholder=\"Bulk add (comma or newline separated). Example: 1,2,2,3,true,&quot;x&quot;,[1,2],NaN\"></textarea>\n            <button id=\"bulkAddA\">Bulk Add</button>\n          </div>\n          <div class=\"legend\">Values (click × on a chip to delete that specific value)</div>\n          <div class=\"chips\" id=\"chipsA\"></div>\n        </div>\n      </div>\n\n      <div class=\"panel\" id=\"panelB\">\n        <h2>Set B <span class=\"badge\" id=\"sizeB\">0</span></h2>\n        <div class=\"stack\">\n          <div class=\"row\">\n            <input class=\"grow\" id=\"inputB\" placeholder='Enter a value: 42, \"hi\", true, null, [1,2], {\"a\":1}, NaN, Infinity, 123n, Symbol(tag), date(2020-01-01)' />\n            <button class=\"primary\" id=\"addB\">Add</button>\n            <button id=\"hasB\">Has?</button>\n            <button class=\"warn\" id=\"delB\">Delete</button>\n            <button class=\"bad\" id=\"clearB\">Clear</button>\n          </div>\n          <div class=\"hint\">Objects compare by reference: two literals {x:1} are different values unless they are the same object.</div>\n          <div class=\"row\">\n            <textarea class=\"grow\" id=\"bulkB\" placeholder=\"Bulk add (comma or newline separated). Example: 1,2,3,&quot;a&quot;,&quot;a&quot;,NaN\"></textarea>\n            <button id=\"bulkAddB\">Bulk Add</button>\n          </div>\n          <div class=\"legend\">Values</div>\n          <div class=\"chips\" id=\"chipsB\"></div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel\" id=\"ops\">\n      <h3>Set operations on A and B</h3>\n      <div class=\"row\">\n        <button id=\"btnUnion\">Union A ∪ B</button>\n        <button id=\"btnInter\">Intersection A ∩ B</button>\n        <button id=\"btnDiffAB\">Difference A \\\\ B</button>\n        <button id=\"btnDiffBA\">Difference B \\\\ A</button>\n        <button id=\"btnSymDiff\">Symmetric difference A △ B</button>\n        <span class=\"pill\">Result size <span class=\"badge\" id=\"sizeResult\">0</span></span>\n      </div>\n      <div class=\"results\" id=\"resultArea\"></div>\n    </div>\n\n    <div class=\"grid\">\n      <div class=\"panel\">\n        <h3>Deduplicate an array with Set</h3>\n        <div class=\"stack\">\n          <textarea id=\"dedupInput\" placeholder='Enter an array (JSON) or CSV/newline list. Examples:\n[1,1,2,3,\"a\",\"a\",true,false,true,NaN,NaN]\n1,1,2,2,3,3,NaN,NaN,\"x\",\"x\"'></textarea>\n          <div class=\"row\">\n            <button class=\"primary\" id=\"runDedup\">Deduplicate</button>\n            <button id=\"copyDedup\">Copy result</button>\n            <span id=\"dedupInfo\" class=\"pill\">Before: 0 After: 0</span>\n          </div>\n          <div class=\"results\" id=\"dedupOut\"></div>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <h3>Iteration and SameValueZero quirks</h3>\n        <div class=\"stack\">\n          <div class=\"row\">\n            <button id=\"iterForOf\">Iterate A with for...of</button>\n            <button id=\"iterEntries\">A.entries()</button>\n            <button id=\"iterForEach\">A.forEach()</button>\n          </div>\n          <div class=\"row\">\n            <button id=\"testSpecial\">Test NaN and -0 behavior</button>\n            <button id=\"addObjRefs\">Add object refs</button>\n          </div>\n          <div class=\"log\" id=\"logArea\"></div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <h3>Bonus: WeakSet in a nutshell</h3>\n      <div class=\"stack\">\n        <div class=\"row-slim\">\n          <button id=\"wsDemo\">Run WeakSet demo</button>\n          <span class=\"hint\">WeakSet holds only objects, not primitives. It is not iterable.</span>\n        </div>\n        <div class=\"results\" id=\"wsOut\"></div>\n      </div>\n    </div>\n\n    <footer>\n      JavaScript Set Playground. No external libraries. All processing happens locally in this page.\n    </footer>\n  </div>\n\n  <script>\n    // Identity tracking for pretty printing\n    const objIds = new WeakMap();\n    let nextId = 1;\n    function getId(obj) {\n      if (obj === null || typeof obj !== 'object') return '';\n      if (!objIds.has(obj)) objIds.set(obj, nextId++);\n      return objIds.get(obj);\n    }\n\n    function isNegZero(n) {\n      return typeof n === 'number' && n === 0 && (1 / n) === -Infinity;\n    }\n\n    function parseValue(raw) {\n      const s = String(raw).trim();\n      if (!s.length) return { ok: false, value: undefined, reason: 'empty' };\n\n      // Quoted string (JSON style)\n      if ((s.startsWith('\"') && s.endsWith('\"')) || (s.startsWith(\"'\") && s.endsWith(\"'\"))) {\n        try {\n          // Normalize single quotes to double for JSON parse\n          const normalized = s.startsWith(\"'\") ? '\"' + s.slice(1, -1).replace(/\"/g, '\\\\\"') + '\"' : s;\n          return { ok: true, value: JSON.parse(normalized) };\n        } catch (e) {\n          // fallback to raw without quotes\n          return { ok: true, value: s.slice(1, -1) };\n        }\n      }\n\n      const lower = s.toLowerCase();\n\n      // Special keywords\n      if (lower === 'undefined') return { ok: true, value: undefined };\n      if (lower === 'null') return { ok: true, value: null };\n      if (lower === 'true') return { ok: true, value: true };\n      if (lower === 'false') return { ok: true, value: false };\n      if (s === 'NaN') return { ok: true, value: NaN };\n      if (s === 'Infinity' || s === '+Infinity') return { ok: true, value: Infinity };\n      if (s === '-Infinity') return { ok: true, value: -Infinity };\n      if (s === '-0') return { ok: true, value: -0 };\n\n      // BigInt\n      if (/^[+-]?\\d+n$/.test(s)) {\n        try {\n          return { ok: true, value: BigInt(s.slice(0, -1)) };\n        } catch (e) {\n          return { ok: false, reason: 'bad bigint' };\n        }\n      }\n\n      // Symbol(description)\n      const symMatch = s.match(/^symbol\\((.*)\\)$/i);\n      if (symMatch) {\n        const desc = symMatch[1] === '' ? undefined : symMatch[1];\n        return { ok: true, value: Symbol(desc) };\n      }\n\n      // date( ... )\n      const dateMatch = s.match(/^date\\((.*)\\)$/i);\n      if (dateMatch) {\n        const inner = dateMatch[1].trim();\n        const d = new Date(inner);\n        if (!isNaN(d.getTime())) return { ok: true, value: d };\n        return { ok: false, reason: 'bad date' };\n      }\n\n      // JSON object/array/primitive\n      if (s.startsWith('{') || s.startsWith('[')) {\n        try {\n          return { ok: true, value: JSON.parse(s) };\n        } catch (e) {\n          return { ok: false, reason: 'bad json' };\n        }\n      }\n\n      // Number literal\n      // Accept decimal, hex 0x, octal 0o, binary 0b where Number() can parse, but exclude leading zeros issues\n      if (/^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/i.test(s) || /^[-+]?0x[0-9a-f]+$/i.test(s) || /^[-+]?0o[0-7]+$/i.test(s) || /^[-+]?0b[01]+$/i.test(s)) {\n        const n = Number(s);\n        if (!Number.isNaN(n)) return { ok: true, value: n };\n      }\n\n      // Fallback: treat as string\n      return { ok: true, value: s };\n    }\n\n    function describe(value) {\n      const t = typeof value;\n      if (t === 'number') {\n        if (Number.isNaN(value)) return 'NaN';\n        if (value === Infinity) return 'Infinity';\n        if (value === -Infinity) return '-Infinity';\n        if (isNegZero(value)) return '-0';\n        return String(value);\n      }\n      if (t === 'bigint') return String(value) + 'n';\n      if (t === 'string') return JSON.stringify(value);\n      if (t === 'boolean') return value ? 'true' : 'false';\n      if (t === 'undefined') return 'undefined';\n      if (t === 'symbol') return value.toString();\n      if (t === 'function') return `Function ${value.name || '(anonymous)'}`;\n      if (value === null) return 'null';\n\n      // objects\n      if (value instanceof Date) return `Date(${value.toISOString()})`;\n      if (value instanceof Set) return `Set#${getId(value) || '?'}(size=${value.size})`;\n\n      let tag = Array.isArray(value) ? 'Array' : (value && value.constructor && value.constructor.name ? value.constructor.name : 'Object');\n      tag = tag === 'Object' ? 'Object' : tag;\n      const id = getId(value);\n      const preview = compactPreview(value, 50);\n      return `${tag}#${id}${preview ? ' ' + preview : ''}`;\n    }\n\n    function compactPreview(value, maxLen = 60) {\n      // JSON preview with custom replacer\n      try {\n        const seen = new WeakMap();\n        let seq = 1;\n        const s = JSON.stringify(value, (k, v) => {\n          const tv = typeof v;\n          if (tv === 'bigint') return String(v) + 'n';\n          if (tv === 'symbol') return v.toString();\n          if (tv === 'function') return `Function ${v.name || '(anonymous)'}`;\n          if (tv === 'number') {\n            if (Number.isNaN(v)) return 'NaN';\n            if (isNegZero(v)) return '-0';\n            if (v === Infinity) return 'Infinity';\n            if (v === -Infinity) return '-Infinity';\n            return v;\n          }\n          if (v && tv === 'object') {\n            if (seen.has(v)) return `[Circular#${seen.get(v)}]`;\n            seen.set(v, seq++);\n          }\n          return v;\n        });\n        if (!s) return '';\n        const trimmed = s.length > maxLen ? s.slice(0, maxLen - 1) + '…' : s;\n        return trimmed;\n      } catch (e) {\n        return '';\n      }\n    }\n\n    function log(msg, type = 'info') {\n      const area = document.getElementById('logArea');\n      const time = new Date().toLocaleTimeString();\n      const prefix = type === 'warn' ? '⚠' : type === 'err' ? '✖' : '•';\n      area.textContent += `[${time}] ${prefix} ${msg}\\n`;\n      area.scrollTop = area.scrollHeight;\n    }\n\n    // Sets\n    const setA = new Set();\n    const setB = new Set();\n\n    // UI elements\n    const refs = {\n      inputA: document.getElementById('inputA'),\n      inputB: document.getElementById('inputB'),\n      addA: document.getElementById('addA'),\n      addB: document.getElementById('addB'),\n      delA: document.getElementById('delA'),\n      delB: document.getElementById('delB'),\n      hasA: document.getElementById('hasA'),\n      hasB: document.getElementById('hasB'),\n      clearA: document.getElementById('clearA'),\n      clearB: document.getElementById('clearB'),\n      sizeA: document.getElementById('sizeA'),\n      sizeB: document.getElementById('sizeB'),\n      chipsA: document.getElementById('chipsA'),\n      chipsB: document.getElementById('chipsB'),\n      bulkA: document.getElementById('bulkA'),\n      bulkB: document.getElementById('bulkB'),\n      bulkAddA: document.getElementById('bulkAddA'),\n      bulkAddB: document.getElementById('bulkAddB'),\n      // Ops\n      btnUnion: document.getElementById('btnUnion'),\n      btnInter: document.getElementById('btnInter'),\n      btnDiffAB: document.getElementById('btnDiffAB'),\n      btnDiffBA: document.getElementById('btnDiffBA'),\n      btnSymDiff: document.getElementById('btnSymDiff'),\n      resultArea: document.getElementById('resultArea'),\n      sizeResult: document.getElementById('sizeResult'),\n      // Dedup\n      dedupInput: document.getElementById('dedupInput'),\n      runDedup: document.getElementById('runDedup'),\n      copyDedup: document.getElementById('copyDedup'),\n      dedupOut: document.getElementById('dedupOut'),\n      dedupInfo: document.getElementById('dedupInfo'),\n      // Iter\n      iterForOf: document.getElementById('iterForOf'),\n      iterEntries: document.getElementById('iterEntries'),\n      iterForEach: document.getElementById('iterForEach'),\n      testSpecial: document.getElementById('testSpecial'),\n      addObjRefs: document.getElementById('addObjRefs'),\n      // WeakSet\n      wsDemo: document.getElementById('wsDemo'),\n      wsOut: document.getElementById('wsOut'),\n    };\n\n    function updateSetView(set, chipsEl, sizeEl) {\n      sizeEl.textContent = set.size;\n      chipsEl.innerHTML = '';\n      for (const val of set) {\n        const chip = document.createElement('span');\n        chip.className = 'chip';\n        chip.title = `typeof ${typeof val}`;\n        const label = document.createElement('span');\n        label.textContent = describe(val);\n        const del = document.createElement('button');\n        del.textContent = '×';\n        del.title = 'Delete this value';\n        del.addEventListener('click', () => {\n          set.delete(val);\n          chipsEl.removeChild(chip);\n          sizeEl.textContent = set.size;\n          log(`Deleted ${describe(val)} from ${set === setA ? 'Set A' : 'Set B'}`);\n        });\n        chip.appendChild(label);\n        // type hint\n        const hint = document.createElement('small');\n        hint.textContent = `(${typeof val})`;\n        chip.appendChild(hint);\n        chip.appendChild(del);\n        chipsEl.appendChild(chip);\n      }\n    }\n\n    function addInputToSet(inputEl, setName) {\n      const s = setName === 'A' ? setA : setB;\n      const valueText = inputEl.value;\n      const r = parseValue(valueText);\n      if (!r.ok) {\n        alert('Could not parse value: ' + (r.reason || 'unknown'));\n        return;\n      }\n      const before = s.size;\n      s.add(r.value);\n      updateSetView(s, setName === 'A' ? refs.chipsA : refs.chipsB, setName === 'A' ? refs.sizeA : refs.sizeB);\n      const after = s.size;\n      log(`Add to Set ${setName}: ${describe(r.value)}${after === before ? ' (already present)' : ''}`);\n    }\n\n    function deleteInputFromSet(inputEl, setName) {\n      const s = setName === 'A' ? setA : setB;\n      const r = parseValue(inputEl.value);\n      if (!r.ok) {\n        alert('Could not parse value: ' + (r.reason || 'unknown'));\n        return;\n      }\n      const removed = s.delete(r.value);\n      updateSetView(s, setName === 'A' ? refs.chipsA : refs.chipsB, setName === 'A' ? refs.sizeA : refs.sizeB);\n      log(`${removed ? 'Deleted' : 'Not found'} in Set ${setName}: ${describe(r.value)}`, removed ? 'info' : 'warn');\n    }\n\n    function hasInputInSet(inputEl, setName) {\n      const s = setName === 'A' ? setA : setB;\n      const r = parseValue(inputEl.value);\n      if (!r.ok) {\n        alert('Could not parse value: ' + (r.reason || 'unknown'));\n        return;\n      }\n      const exists = s.has(r.value);\n      log(`Set ${setName} has ${describe(r.value)}: ${exists ? 'Yes' : 'No'}`, exists ? 'info' : 'warn');\n      alert(`Set ${setName} ${exists ? 'contains' : 'does not contain'} ${describe(r.value)}`);\n    }\n\n    function bulkAdd(text, targetSetName) {\n      const s = targetSetName === 'A' ? setA : setB;\n      const tokens = splitValues(text);\n      let added = 0, skipped = 0;\n      for (const t of tokens) {\n        const r = parseValue(t);\n        if (r.ok) {\n          const before = s.size;\n          s.add(r.value);\n          if (s.size > before) added++;\n          else skipped++;\n        } else {\n          skipped++;\n        }\n      }\n      updateSetView(s, targetSetName === 'A' ? refs.chipsA : refs.chipsB, targetSetName === 'A' ? refs.sizeA : refs.sizeB);\n      log(`Bulk add to Set ${targetSetName}: +${added}, skipped ${skipped}`);\n    }\n\n    function splitValues(text) {\n      // Split by newlines or commas, ignoring empty parts\n      return String(text)\n        .split(/\\n|,/)\n        .map(s => s.trim())\n        .filter(Boolean);\n    }\n\n    // Set operations\n    const setOps = {\n      union: (A, B) => new Set([...A, ...B]),\n      intersection: (A, B) => new Set([...A].filter(x => B.has(x))),\n      difference: (A, B) => new Set([...A].filter(x => !B.has(x))),\n      symDiff: (A, B) => {\n        const U = new Set([...A, ...B]);\n        const I = new Set([...A].filter(x => B.has(x)));\n        return new Set([...U].filter(x => !I.has(x)));\n      }\n    };\n\n    function renderSet(set) {\n      const out = [];\n      for (const v of set) out.push(describe(v));\n      return `{ ${out.join(', ')} }`;\n    }\n\n    function runOp(name) {\n      let res;\n      if (name === 'union') res = setOps.union(setA, setB);\n      if (name === 'intersection') res = setOps.intersection(setA, setB);\n      if (name === 'differenceAB') res = setOps.difference(setA, setB);\n      if (name === 'differenceBA') res = setOps.difference(setB, setA);\n      if (name === 'sym') res = setOps.symDiff(setA, setB);\n      refs.resultArea.textContent = renderSet(res);\n      refs.sizeResult.textContent = res.size;\n      log(`Operation ${name}: result size ${res.size}`);\n    }\n\n    // Deduplicate\n    function parseListOrArray(text) {\n      const s = String(text).trim();\n      let arr = [];\n      if (!s) return arr;\n      if (s.startsWith('[') && s.endsWith(']')) {\n        try {\n          arr = JSON.parse(s);\n          return Array.isArray(arr) ? arr : [arr];\n        } catch (e) {\n          // fall-through to CSV/newline\n        }\n      }\n      // CSV/newlines\n      const parts = splitValues(s);\n      arr = parts.map(p => {\n        const r = parseValue(p);\n        return r.ok ? r.value : p;\n      });\n      return arr;\n    }\n\n    function stringifyArrayPreview(arr) {\n      return '[' + arr.map(v => describe(v)).join(', ') + ']';\n    }\n\n    function runDedup() {\n      const input = refs.dedupInput.value;\n      const arr = parseListOrArray(input);\n      const before = arr.length;\n      // Deduplicate preserving SameValueZero semantics\n      const deduped = [...new Set(arr)];\n      const after = deduped.length;\n      refs.dedupOut.textContent = stringifyArrayPreview(deduped);\n      refs.dedupInfo.textContent = `Before: ${before} After: ${after}`;\n      log(`Dedup: before ${before}, after ${after}`);\n      return deduped;\n    }\n\n    // Iteration demos\n    function iterForOf() {\n      let i = 0;\n      for (const v of setA) {\n        log(`for...of A[${i++}] = ${describe(v)}`);\n      }\n      if (i === 0) log('for...of: Set A is empty', 'warn');\n    }\n    function iterEntries() {\n      let i = 0;\n      for (const [k, v] of setA.entries()) {\n        log(`entries A[${i++}] = [${describe(k)}, ${describe(v)}]`);\n      }\n      if (i === 0) log('entries(): Set A is empty', 'warn');\n    }\n    function iterForEach() {\n      let i = 0;\n      setA.forEach((v, k) => {\n        log(`forEach A[${i++}] => value=${describe(v)} key=${describe(k)}`);\n      });\n      if (i === 0) log('forEach(): Set A is empty', 'warn');\n    }\n\n    function testSpecialNumbers() {\n      setA.clear();\n      setA.add(0);\n      setA.add(-0);\n      setA.add(+0);\n      setA.add(NaN);\n      setA.add(NaN);\n      updateSetView(setA, refs.chipsA, refs.sizeA);\n      log('Added 0, -0, +0, NaN, NaN to Set A');\n      log(`Set A has 0? ${setA.has(0)} (SameValueZero treats -0 and 0 as the same)`);\n      log(`Set A has -0? ${setA.has(-0)} (true)`);\n      log(`Set A has NaN? ${setA.has(NaN)} (NaN equals NaN under SameValueZero)`);\n      const out = [];\n      for (const v of setA) out.push(describe(v));\n      log('Iterating Set A yields: ' + out.join(', '));\n    }\n\n    function addObjectRefs() {\n      const obj1 = { x: 1 };\n      const obj2 = { x: 1 };\n      const same = obj1;\n      setA.add(obj1);\n      setA.add(obj2);\n      setA.add(same);\n      updateSetView(setA, refs.chipsA, refs.sizeA);\n      log('Added obj1={x:1}, obj2={x:1}, and same reference again.');\n      log('Even though obj1 and obj2 look equal, they are different references, so both appear.');\n    }\n\n    // WeakSet demo\n    function runWeakSetDemo() {\n      const out = [];\n      const ws = new WeakSet();\n      let a = { name: 'a' };\n      let b = { name: 'b' };\n      ws.add(a);\n      out.push('Created WeakSet, added object a');\n      out.push('ws.has(a) => ' + ws.has(a));\n      out.push('ws.has(b) before add => ' + ws.has(b));\n      ws.add(b);\n      out.push('Added object b');\n      out.push('ws.has(b) => ' + ws.has(b));\n      a = null; // remove strong reference to a (eligible for GC sometime later)\n      out.push('a = null (now only weakly referenced; cannot be observed when GC happens).');\n      try {\n        // Demonstrate non-iterable nature\n        // eslint-disable-next-line no-unused-vars\n        for (const item of ws) {}\n        out.push('This line should not be reachable (WeakSet is not iterable).');\n      } catch (e) {\n        out.push('WeakSet is not iterable: ' + e);\n      }\n      document.getElementById('wsOut').textContent = out.join('\\n');\n    }\n\n    // Wire up events\n    refs.addA.addEventListener('click', () => addInputToSet(refs.inputA, 'A'));\n    refs.addB.addEventListener('click', () => addInputToSet(refs.inputB, 'B'));\n    refs.delA.addEventListener('click', () => deleteInputFromSet(refs.inputA, 'A'));\n    refs.delB.addEventListener('click', () => deleteInputFromSet(refs.inputB, 'B'));\n    refs.hasA.addEventListener('click', () => hasInputInSet(refs.inputA, 'A'));\n    refs.hasB.addEventListener('click', () => hasInputInSet(refs.inputB, 'B'));\n    refs.clearA.addEventListener('click', () => { setA.clear(); updateSetView(setA, refs.chipsA, refs.sizeA); log('Cleared Set A', 'warn'); });\n    refs.clearB.addEventListener('click', () => { setB.clear(); updateSetView(setB, refs.chipsB, refs.sizeB); log('Cleared Set B', 'warn'); });\n    refs.bulkAddA.addEventListener('click', () => bulkAdd(refs.bulkA.value, 'A'));\n    refs.bulkAddB.addEventListener('click', () => bulkAdd(refs.bulkB.value, 'B'));\n\n    refs.btnUnion.addEventListener('click', () => runOp('union'));\n    refs.btnInter.addEventListener('click', () => runOp('intersection'));\n    refs.btnDiffAB.addEventListener('click', () => runOp('differenceAB'));\n    refs.btnDiffBA.addEventListener('click', () => runOp('differenceBA'));\n    refs.btnSymDiff.addEventListener('click', () => runOp('sym'));\n\n    refs.runDedup.addEventListener('click', runDedup);\n    refs.copyDedup.addEventListener('click', () => {\n      const text = refs.dedupOut.textContent;\n      if (!text.trim()) return;\n      navigator.clipboard.writeText(text).then(() => {\n        log('Dedup result copied to clipboard');\n      });\n    });\n\n    refs.iterForOf.addEventListener('click', iterForOf);\n    refs.iterEntries.addEventListener('click', iterEntries);\n    refs.iterForEach.addEventListener('click', iterForEach);\n    refs.testSpecial.addEventListener('click', testSpecialNumbers);\n    refs.addObjRefs.addEventListener('click', addObjectRefs);\n\n    refs.wsDemo.addEventListener('click', runWeakSetDemo);\n\n    // Starter examples\n    (function seed() {\n      const initialA = [1, 2, 2, 'hello', true, NaN, -0, { a: 1 }, [1, 2]];\n      const initialB = [2, 3, 'hello', false, NaN, Symbol('s'), 123n];\n      initialA.forEach(v => setA.add(v));\n      initialB.forEach(v => setB.add(v));\n      updateSetView(setA, refs.chipsA, refs.sizeA);\n      updateSetView(setB, refs.chipsB, refs.sizeB);\n      log('Initialized Set A and Set B with sample values.');\n    })();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Set"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "d18cfe90-a368-11f0-bd1d-0f1018005550",
    "timestamp": "2025-10-07T10:31:43.609Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Binary Tree",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n<title>Binary Tree (BST) Visualizer</title>\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --text: #e5e7eb;\n    --muted: #9ca3af;\n    --accent: #38bdf8;\n    --accent-2: #34d399;\n    --accent-3: #f59e0b;\n    --danger: #ef4444;\n    --edge: #64748b;\n  }\n  * { box-sizing: border-box; }\n  body {\n    margin: 0;\n    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n    background: linear-gradient(180deg, #0b1225 0%, #0f172a 100%);\n    color: var(--text);\n  }\n  .container {\n    max-width: 1200px;\n    margin: 24px auto 48px;\n    padding: 0 16px;\n  }\n  header {\n    margin-bottom: 12px;\n  }\n  h1 {\n    margin: 0;\n    font-size: 28px;\n    letter-spacing: 0.3px;\n  }\n  .subtitle {\n    color: var(--muted);\n    font-size: 14px;\n    margin-top: 6px;\n  }\n  .panel {\n    background: rgba(17, 24, 39, 0.7);\n    border: 1px solid rgba(148, 163, 184, 0.18);\n    border-radius: 12px;\n    padding: 14px;\n    backdrop-filter: blur(4px);\n  }\n  .controls {\n    display: grid;\n    grid-template-columns: 1fr;\n    gap: 10px;\n  }\n  .row {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 10px;\n    align-items: center;\n  }\n  .row label {\n    color: var(--muted);\n    font-size: 13px;\n    margin-right: 4px;\n  }\n  input[type=\"text\"], input[type=\"number\"] {\n    background: #0b1225;\n    color: var(--text);\n    border: 1px solid rgba(148, 163, 184, 0.18);\n    border-radius: 8px;\n    outline: none;\n    padding: 8px 10px;\n    min-width: 160px;\n  }\n  input[type=\"range\"] {\n    width: 180px;\n  }\n  button {\n    background: linear-gradient(180deg, #0ea5e9, #0284c7);\n    border: 1px solid rgba(255,255,255,0.08);\n    color: white;\n    border-radius: 8px;\n    padding: 8px 12px;\n    cursor: pointer;\n    transition: transform 0.05s ease, filter 0.15s ease;\n  }\n  button.secondary {\n    background: linear-gradient(180deg, #374151, #1f2937);\n  }\n  button.danger {\n    background: linear-gradient(180deg, #ef4444, #b91c1c);\n  }\n  button:disabled {\n    filter: grayscale(0.5) brightness(0.7);\n    cursor: not-allowed;\n  }\n  button:hover:not(:disabled) { filter: brightness(1.08); }\n  button:active:not(:disabled) { transform: translateY(1px); }\n\n  .svg-wrap {\n    margin-top: 14px;\n    background: rgba(15, 23, 42, 0.7);\n    border: 1px solid rgba(148, 163, 184, 0.18);\n    border-radius: 12px;\n    padding: 10px;\n  }\n  svg {\n    width: 100%;\n    height: 580px;\n    display: block;\n    background: radial-gradient(1000px 450px at 20% 0%, rgba(30, 58, 138, 0.25), transparent 70%),\n                radial-gradient(800px 350px at 100% 0%, rgba(8, 145, 178, 0.18), transparent 70%),\n                linear-gradient(180deg, rgba(17, 24, 39, 0.6), rgba(17, 24, 39, 0.6));\n    border-radius: 10px;\n  }\n  .legend {\n    margin-top: 10px;\n    font-size: 13px;\n    color: var(--muted);\n  }\n  .stats {\n    display: flex;\n    gap: 16px;\n    flex-wrap: wrap;\n    margin-top: 8px;\n    font-size: 13px;\n    color: var(--muted);\n  }\n  .stat-chip {\n    background: rgba(2, 6, 23, 0.6);\n    border: 1px solid rgba(148, 163, 184, 0.18);\n    padding: 6px 10px;\n    border-radius: 8px;\n    color: var(--text);\n  }\n  .output {\n    margin-top: 14px;\n    background: rgba(2, 6, 23, 0.6);\n    border: 1px solid rgba(148, 163, 184, 0.18);\n    border-radius: 12px;\n    padding: 10px;\n    min-height: 52px;\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n    overflow: auto;\n    white-space: pre-wrap;\n  }\n\n  /* Tree drawing */\n  .edge {\n    stroke: var(--edge);\n    stroke-width: 2;\n    opacity: 0.9;\n  }\n  .tree-node circle {\n    fill: #3b82f6;\n    stroke: rgba(255, 255, 255, 0.6);\n    stroke-width: 2;\n    filter: drop-shadow(0 2px 3px rgba(0,0,0,0.35));\n    transition: fill 0.2s ease, stroke 0.2s ease, transform 0.1s ease;\n  }\n  .tree-node text {\n    font-size: 13px;\n    font-weight: 600;\n    fill: #fefefe;\n    pointer-events: none;\n  }\n  .tree-node:hover circle {\n    transform: translateY(-1px);\n  }\n\n  /* Animation states */\n  .visited circle { fill: #60a5fa; }\n  .highlight circle { fill: #f59e0b; }\n  .found circle { fill: #34d399; }\n  .notfound circle { fill: #ef4444; }\n  .path-edge {\n    stroke: #f59e0b;\n    stroke-width: 3.5;\n  }\n\n  .empty-text {\n    font-size: 14px;\n    fill: var(--muted);\n  }\n\n  .footer-note {\n    margin-top: 8px;\n    font-size: 12px;\n    color: var(--muted);\n  }\n\n  @media (max-width: 640px) {\n    h1 { font-size: 22px; }\n    svg { height: 520px; }\n  }\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <header>\n    <h1>Binary Tree (BST) Visualizer</h1>\n    <div class=\"subtitle\">Insert, search, delete, and traverse a Binary Search Tree with animated visualization. Uses inorder layout for neat spacing.</div>\n  </header>\n\n  <div class=\"panel controls\">\n    <div class=\"row\">\n      <label for=\"insertInput\">Insert values</label>\n      <input type=\"text\" id=\"insertInput\" placeholder=\"e.g. 50, 25, 75, 10 60 90\"/>\n      <button id=\"insertBtn\">Insert</button>\n\n      <label for=\"randomCount\">Random</label>\n      <input type=\"number\" id=\"randomCount\" min=\"1\" max=\"30\" value=\"10\" />\n      <button id=\"randomBtn\" class=\"secondary\">Insert Random</button>\n\n      <button id=\"clearBtn\" class=\"danger\">Clear Tree</button>\n    </div>\n\n    <div class=\"row\">\n      <label for=\"searchInput\">Search</label>\n      <input type=\"text\" id=\"searchInput\" placeholder=\"value\"/>\n      <button id=\"searchBtn\">Search</button>\n\n      <label for=\"deleteInput\">Delete</label>\n      <input type=\"text\" id=\"deleteInput\" placeholder=\"value\"/>\n      <button id=\"deleteBtn\" class=\"secondary\">Delete</button>\n    </div>\n\n    <div class=\"row\">\n      <button id=\"inorderBtn\">Inorder</button>\n      <button id=\"preorderBtn\">Preorder</button>\n      <button id=\"postorderBtn\">Postorder</button>\n      <button id=\"levelorderBtn\" class=\"secondary\">Level-order (BFS)</button>\n\n      <label for=\"speedRange\">Speed</label>\n      <input id=\"speedRange\" type=\"range\" min=\"80\" max=\"1200\" value=\"380\"/>\n      <span id=\"speedLabel\" class=\"stat-chip\">380 ms/step</span>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"stat-chip\">Nodes: <span id=\"statNodes\">0</span></div>\n      <div class=\"stat-chip\">Height: <span id=\"statHeight\">0</span></div>\n      <div class=\"stat-chip\">Min: <span id=\"statMin\">—</span></div>\n      <div class=\"stat-chip\">Max: <span id=\"statMax\">—</span></div>\n    </div>\n  </div>\n\n  <div class=\"svg-wrap\">\n    <svg id=\"treeSvg\"></svg>\n    <div class=\"legend\">Legend: orange = current step, green = found, red = not found, blue = visited</div>\n  </div>\n\n  <div class=\"panel output\" id=\"output\"></div>\n  <div class=\"footer-note\">Tip: You can insert multiple values separated by spaces or commas. Duplicates go to the right subtree.</div>\n</div>\n\n<script>\n  // Node and BST classes\n  let NODE_ID_COUNTER = 1;\n\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n      this.id = NODE_ID_COUNTER++;\n      // layout properties\n      this.x = 0; this.y = 0; this.depth = 0;\n    }\n  }\n\n  class BST {\n    constructor() { this.root = null; }\n\n    insert(value) {\n      if (this.root === null) {\n        this.root = new Node(value);\n        return this.root;\n      }\n      let cur = this.root;\n      while (true) {\n        if (value < cur.value) {\n          if (cur.left) cur = cur.left;\n          else { cur.left = new Node(value); return cur.left; }\n        } else {\n          if (cur.right) cur = cur.right;\n          else { cur.right = new Node(value); return cur.right; }\n        }\n      }\n    }\n\n    minNode(node = this.root) {\n      if (!node) return null;\n      while (node.left) node = node.left;\n      return node;\n    }\n    maxNode(node = this.root) {\n      if (!node) return null;\n      while (node.right) node = node.right;\n      return node;\n    }\n\n    searchPath(value) {\n      let path = [];\n      let cur = this.root;\n      while (cur) {\n        path.push(cur);\n        if (value === cur.value) break;\n        cur = value < cur.value ? cur.left : cur.right;\n      }\n      return path;\n    }\n\n    delete(value) {\n      const del = (node, value) => {\n        if (!node) return null;\n        if (value < node.value) {\n          node.left = del(node.left, value);\n          return node;\n        } else if (value > node.value) {\n          node.right = del(node.right, value);\n          return node;\n        } else {\n          // found\n          if (!node.left) return node.right;\n          if (!node.right) return node.left;\n          // two children: replace with inorder successor\n          let succ = node.right;\n          while (succ.left) succ = succ.left;\n          node.value = succ.value;\n          node.right = del(node.right, succ.value);\n          return node;\n        }\n      };\n      this.root = del(this.root, value);\n    }\n\n    inorder() {\n      const arr = [];\n      const dfs = (node) => {\n        if (!node) return;\n        dfs(node.left);\n        arr.push(node);\n        dfs(node.right);\n      };\n      dfs(this.root);\n      return arr;\n    }\n    preorder() {\n      const arr = [];\n      const dfs = (node) => {\n        if (!node) return;\n        arr.push(node);\n        dfs(node.left);\n        dfs(node.right);\n      };\n      dfs(this.root);\n      return arr;\n    }\n    postorder() {\n      const arr = [];\n      const dfs = (node) => {\n        if (!node) return;\n        dfs(node.left);\n        dfs(node.right);\n        arr.push(node);\n      };\n      dfs(this.root);\n      return arr;\n    }\n    levelorder() {\n      const arr = [];\n      const q = [];\n      if (this.root) q.push(this.root);\n      while (q.length) {\n        const n = q.shift();\n        arr.push(n);\n        if (n.left) q.push(n.left);\n        if (n.right) q.push(n.right);\n      }\n      return arr;\n    }\n\n    height(node = this.root) {\n      const h = (n) => n ? 1 + Math.max(h(n.left), h(n.right)) : 0;\n      return h(node);\n    }\n\n    count(node = this.root) {\n      const c = (n) => n ? 1 + c(n.left) + c(n.right) : 0;\n      return c(node);\n    }\n  }\n\n  // Global state\n  const bst = new BST();\n  const svg = document.getElementById('treeSvg');\n  const outputEl = document.getElementById('output');\n  const statNodes = document.getElementById('statNodes');\n  const statHeight = document.getElementById('statHeight');\n  const statMin = document.getElementById('statMin');\n  const statMax = document.getElementById('statMax');\n  const speedRange = document.getElementById('speedRange');\n  const speedLabel = document.getElementById('speedLabel');\n\n  const buttons = {\n    insert: document.getElementById('insertBtn'),\n    random: document.getElementById('randomBtn'),\n    clear: document.getElementById('clearBtn'),\n    search: document.getElementById('searchBtn'),\n    delete: document.getElementById('deleteBtn'),\n    inorder: document.getElementById('inorderBtn'),\n    preorder: document.getElementById('preorderBtn'),\n    postorder: document.getElementById('postorderBtn'),\n    levelorder: document.getElementById('levelorderBtn')\n  };\n\n  const inputs = {\n    insert: document.getElementById('insertInput'),\n    randomCount: document.getElementById('randomCount'),\n    search: document.getElementById('searchInput'),\n    delete: document.getElementById('deleteInput')\n  };\n\n  let animating = false;\n  function setControlsDisabled(disabled) {\n    animating = disabled;\n    Object.values(buttons).forEach(b => b.disabled = disabled);\n    inputs.insert.disabled = disabled;\n    inputs.randomCount.disabled = disabled;\n    inputs.search.disabled = disabled;\n    inputs.delete.disabled = disabled;\n    speedRange.disabled = disabled;\n  }\n\n  // Parsing helpers\n  function parseValues(text) {\n    const matches = (text || '').match(/-?\\d+/g);\n    if (!matches) return [];\n    return matches.map(x => parseInt(x, 10)).filter(v => Number.isFinite(v));\n  }\n  function parseSingleValue(text) {\n    const vals = parseValues(text);\n    return vals.length ? vals[0] : null;\n  }\n\n  // Layout computation using inorder x-spacing and depth y-spacing\n  function computeLayout() {\n    const width = svg.clientWidth || 900;\n    const height = svg.clientHeight || 580;\n\n    const marginX = 40;\n    const marginY = 50;\n\n    const levels = Math.max(1, bst.height());\n    const levelGap = (height - marginY * 2) / levels;\n\n    // Gather inorder and set depth during traversal\n    const inorderNodes = [];\n    const traverse = (node, depth) => {\n      if (!node) return;\n      traverse(node.left, depth + 1);\n      node.depth = depth;\n      inorderNodes.push(node);\n      traverse(node.right, depth + 1);\n    };\n    traverse(bst.root, 0);\n\n    const stepX = inorderNodes.length ? (width - marginX * 2) / (inorderNodes.length + 1) : 0;\n    inorderNodes.forEach((node, i) => {\n      node.x = marginX + stepX * (i + 1);\n      node.y = marginY + node.depth * levelGap;\n    });\n\n    return inorderNodes;\n  }\n\n  // Rendering\n  function clearSvg() {\n    while (svg.firstChild) svg.removeChild(svg.firstChild);\n  }\n\n  function drawTree() {\n    clearSvg();\n\n    if (!bst.root) {\n      const emptyText = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      emptyText.setAttribute(\"x\", \"50%\");\n      emptyText.setAttribute(\"y\", \"50%\");\n      emptyText.setAttribute(\"text-anchor\", \"middle\");\n      emptyText.classList.add('empty-text');\n      emptyText.textContent = \"Tree is empty. Insert values to begin.\";\n      svg.appendChild(emptyText);\n      updateStats();\n      return;\n    }\n\n    const nodes = computeLayout();\n    // draw edges first\n    const nodeMap = new Map(nodes.map(n => [n.id, n])); // id -> node\n\n    nodes.forEach(node => {\n      if (node.left) drawEdge(node, node.left);\n      if (node.right) drawEdge(node, node.right);\n    });\n\n    // draw nodes\n    nodes.forEach(node => drawNode(node));\n\n    updateStats();\n  }\n\n  function drawEdge(parent, child) {\n    const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    line.setAttribute(\"x1\", parent.x);\n    line.setAttribute(\"y1\", parent.y);\n    line.setAttribute(\"x2\", child.x);\n    line.setAttribute(\"y2\", child.y);\n    line.classList.add('edge');\n    line.id = `edge-${parent.id}-${child.id}`;\n    svg.appendChild(line);\n  }\n\n  function drawNode(node) {\n    const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    g.classList.add('tree-node');\n    g.setAttribute('transform', `translate(${node.x}, ${node.y})`);\n    g.id = `node-${node.id}`;\n\n    const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    circle.setAttribute('r', 18);\n    circle.setAttribute('cx', 0);\n    circle.setAttribute('cy', 0);\n    circle.id = `circle-${node.id}`;\n\n    const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    text.setAttribute('x', 0);\n    text.setAttribute('y', 4);\n    text.setAttribute('text-anchor', 'middle');\n    text.textContent = String(node.value);\n\n    g.appendChild(circle);\n    g.appendChild(text);\n\n    g.addEventListener('click', () => {\n      if (animating) return;\n      log(`Node ${node.value} (id ${node.id}) depth=${node.depth}`);\n      pulseNode(node.id);\n    });\n\n    svg.appendChild(g);\n  }\n\n  function pulseNode(nodeId) {\n    const circle = document.getElementById(`circle-${nodeId}`);\n    if (!circle) return;\n    circle.style.transition = 'transform 0.12s ease';\n    circle.style.transform = 'scale(1.12)';\n    setTimeout(() => { circle.style.transform = 'scale(1)'; }, 110);\n  }\n\n  function updateStats() {\n    const count = bst.count();\n    const height = bst.height();\n    const minNode = bst.minNode();\n    const maxNode = bst.maxNode();\n    statNodes.textContent = count;\n    statHeight.textContent = height;\n    statMin.textContent = minNode ? minNode.value : '—';\n    statMax.textContent = maxNode ? maxNode.value : '—';\n  }\n\n  // Animation helpers\n  function highlightNodeState(nodeId, stateClass) {\n    const g = document.getElementById(`node-${nodeId}`);\n    if (!g) return;\n    g.classList.remove('highlight', 'found', 'notfound');\n    if (stateClass) g.classList.add(stateClass);\n  }\n  function markVisited(nodeId) {\n    const g = document.getElementById(`node-${nodeId}`);\n    if (!g) return;\n    g.classList.add('visited');\n  }\n  function clearAllHighlights() {\n    const nodes = svg.querySelectorAll('.tree-node');\n    nodes.forEach(g => g.classList.remove('highlight', 'found', 'notfound', 'visited'));\n    const edges = svg.querySelectorAll('.edge');\n    edges.forEach(e => e.classList.remove('path-edge'));\n  }\n\n  function animateSequence(nodesArr, stepMs, stepCallback, doneCallback) {\n    if (!nodesArr || nodesArr.length === 0) {\n      if (doneCallback) doneCallback();\n      return;\n    }\n    setControlsDisabled(true);\n    clearAllHighlights();\n\n    let i = 0;\n    const timer = setInterval(() => {\n      const node = nodesArr[i];\n      highlightNodeState(node.id, 'highlight');\n      markVisited(node.id);\n      if (stepCallback) stepCallback(node, i);\n      i++;\n      if (i >= nodesArr.length) {\n        clearInterval(timer);\n        setTimeout(() => {\n          setControlsDisabled(false);\n          if (doneCallback) doneCallback();\n        }, 60);\n      }\n    }, stepMs);\n  }\n\n  function animateSearch(path, target, stepMs) {\n    if (!path || path.length === 0) {\n      log(\"Search: Tree is empty.\");\n      return;\n    }\n    setControlsDisabled(true);\n    clearAllHighlights();\n\n    let i = 0;\n    const timer = setInterval(() => {\n      const node = path[i];\n      // mark path edges thicker\n      const prev = i > 0 ? path[i - 1] : null;\n      if (prev) {\n        const eId = `edge-${prev.id}-${node.id}`;\n        const e = document.getElementById(eId);\n        if (e) e.classList.add('path-edge');\n      }\n      highlightNodeState(node.id, 'highlight');\n      markVisited(node.id);\n      i++;\n      if (i >= path.length) {\n        clearInterval(timer);\n        const last = path[path.length - 1];\n        if (last.value === target) {\n          highlightNodeState(last.id, 'found');\n          log(`Search ${target}: Found at node id=${last.id}.`);\n        } else {\n          highlightNodeState(last.id, 'notfound');\n          log(`Search ${target}: Not found.`);\n        }\n        setTimeout(() => setControlsDisabled(false), 120);\n      }\n    }, stepMs);\n  }\n\n  // Logging\n  function log(text) {\n    const now = new Date();\n    const time = now.toLocaleTimeString();\n    outputEl.textContent += `[${time}] ${text}\\n`;\n    outputEl.scrollTop = outputEl.scrollHeight;\n  }\n\n  // Event handlers\n  buttons.insert.addEventListener('click', () => {\n    if (animating) return;\n    const values = parseValues(inputs.insert.value);\n    if (!values.length) {\n      log(\"Insert: No values parsed.\");\n      return;\n    }\n    values.forEach(v => { bst.insert(v); });\n    drawTree();\n    log(`Inserted: ${values.join(', ')}`);\n    inputs.insert.value = '';\n  });\n\n  buttons.random.addEventListener('click', () => {\n    if (animating) return;\n    let n = parseInt(inputs.randomCount.value, 10);\n    if (!Number.isFinite(n) || n < 1) n = 10;\n    n = Math.min(30, Math.max(1, n));\n    const vals = [];\n    for (let i = 0; i < n; i++) {\n      vals.push(Math.floor(Math.random() * 99)); // 0..98\n    }\n    vals.forEach(v => bst.insert(v));\n    drawTree();\n    log(`Inserted random (${n}): ${vals.join(', ')}`);\n  });\n\n  buttons.clear.addEventListener('click', () => {\n    if (animating) return;\n    bst.root = null;\n    drawTree();\n    clearAllHighlights();\n    outputEl.textContent = '';\n    log(\"Cleared tree.\");\n  });\n\n  buttons.search.addEventListener('click', () => {\n    if (animating) return;\n    const v = parseSingleValue(inputs.search.value);\n    if (v === null) {\n      log(\"Search: Please enter a number.\");\n      return;\n    }\n    const path = bst.searchPath(v);\n    if (!path.length) {\n      log(\"Search: Tree is empty.\");\n      return;\n    }\n    animateSearch(path, v, parseInt(speedRange.value, 10));\n  });\n\n  buttons.delete.addEventListener('click', () => {\n    if (animating) return;\n    const v = parseSingleValue(inputs.delete.value);\n    if (v === null) {\n      log(\"Delete: Please enter a number.\");\n      return;\n    }\n    const beforeCount = bst.count();\n    bst.delete(v);\n    const afterCount = bst.count();\n    drawTree();\n    log(`Delete ${v}: ${beforeCount === afterCount ? \"Value not found.\" : \"Deleted.\"}`);\n  });\n\n  function runTraversal(kind) {\n    if (animating) return;\n    if (!bst.root) { log(`${kind} traversal: Tree is empty.`); return; }\n    let seq;\n    switch (kind) {\n      case 'Inorder': seq = bst.inorder(); break;\n      case 'Preorder': seq = bst.preorder(); break;\n      case 'Postorder': seq = bst.postorder(); break;\n      case 'Level-order': seq = bst.levelorder(); break;\n      default: seq = [];\n    }\n    const speed = parseInt(speedRange.value, 10);\n    const acc = [];\n    animateSequence(seq, speed, (node) => {\n      acc.push(node.value);\n      // Update output live\n      outputEl.textContent = `${kind}: ${acc.join(' ')}\\n`;\n    }, () => {\n      log(`${kind} traversal complete: ${acc.join(' ')}`);\n    });\n  }\n\n  buttons.inorder.addEventListener('click', () => runTraversal('Inorder'));\n  buttons.preorder.addEventListener('click', () => runTraversal('Preorder'));\n  buttons.postorder.addEventListener('click', () => runTraversal('Postorder'));\n  buttons.levelorder.addEventListener('click', () => runTraversal('Level-order'));\n\n  // Speed label binding\n  speedRange.addEventListener('input', () => {\n    speedLabel.textContent = `${speedRange.value} ms/step`;\n  });\n\n  // Initial render and resize handling\n  function initialDemo() {\n    // Optional: preload a few values\n    const sample = [50, 25, 75, 10, 33, 60, 85, 4, 12, 29, 41, 58, 65, 80, 92];\n    sample.forEach(v => bst.insert(v));\n    drawTree();\n    log(\"Demo tree populated with sample values.\");\n  }\n\n  window.addEventListener('resize', () => {\n    if (!animating) drawTree();\n  });\n\n  // Bootstrap\n  initialDemo();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Binary Tree"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "feb69430-a368-11f0-91c8-993b3d87b74f",
    "timestamp": "2025-10-07T10:32:59.379Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Binary Search Tree (BST)",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Binary Search Tree (BST) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f172a;\n      --panel: #0b1224;\n      --muted: #94a3b8;\n      --text: #e2e8f0;\n      --accent: #22d3ee;\n      --accent2: #a78bfa;\n      --danger: #f43f5e;\n      --ok: #34d399;\n      --edge: #334155;\n      --edge-hi: #64748b;\n      --node: #1f2937;\n      --node-hi: #0ea5e9;\n      --node-found: #38bdf8;\n      --node-del: #fb7185;\n      --badge: #172554;\n      --btn: #1f2937;\n      --btn-hover: #374151;\n      --btn-active: #111827;\n      --input: #0b1224;\n      --ring: rgba(34, 211, 238, 0.25);\n      --shadow: 0 10px 25px rgba(0,0,0,0.35);\n    }\n    * { box-sizing: border-box; }\n    html, body {\n      margin: 0; padding: 0; height: 100%; background: var(--bg); color: var(--text);\n      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, Apple Color Emoji, Segoe UI Emoji;\n    }\n    a { color: var(--accent); text-decoration: none; }\n    .app {\n      display: grid;\n      grid-template-columns: 340px 1fr;\n      gap: 16px;\n      padding: 16px;\n      height: 100%;\n    }\n    @media (max-width: 980px) {\n      .app { grid-template-columns: 1fr; grid-auto-rows: max-content; }\n    }\n    .panel {\n      background: linear-gradient(160deg, rgba(34,211,238,0.08), transparent 20%) , var(--panel);\n      border: 1px solid rgba(148,163,184,.15);\n      border-radius: 14px;\n      padding: 14px 14px 8px 14px;\n      box-shadow: var(--shadow);\n    }\n    .header {\n      display: flex; align-items: center; justify-content: space-between;\n      margin-bottom: 10px; gap: 12px;\n    }\n    .title {\n      font-size: 20px; font-weight: 700; letter-spacing: .3px; display: flex; align-items: center; gap: 8px;\n    }\n    .badge {\n      font-size: 12px; padding: 2px 8px; border-radius: 999px; background: var(--badge); color: var(--muted);\n      border: 1px solid rgba(148,163,184,0.18);\n    }\n    .controls { display: grid; gap: 10px; }\n    .row { display: flex; gap: 8px; flex-wrap: wrap; }\n    .row > * { flex: 1; min-width: 100px; }\n    .input {\n      background: var(--input); color: var(--text); border: 1px solid rgba(148,163,184,.22); border-radius: 10px;\n      padding: 10px 12px; outline: none;\n    }\n    .input:focus { border-color: var(--accent); box-shadow: 0 0 0 4px var(--ring); }\n    .btn {\n      background: var(--btn); color: var(--text); border: 1px solid rgba(148,163,184,.25);\n      border-radius: 10px; padding: 10px 12px; cursor: pointer; user-select: none;\n      transition: background .15s ease, border-color .15s ease, transform .05s ease;\n    }\n    .btn:hover { background: var(--btn-hover); }\n    .btn:active { transform: translateY(1px); background: var(--btn-active); }\n    .btn.accent { background: linear-gradient(120deg, rgba(34,211,238,.18), rgba(167,139,250,.18)); border-color: rgba(167,139,250,.45); }\n    .btn.ok { border-color: rgba(52,211,153,.45); }\n    .btn.warn { border-color: rgba(244,63,94,.45); }\n    .tiny { font-size: 12px; color: var(--muted); }\n    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }\n    .stat {\n      background: rgba(2,6,23,.45); border: 1px solid rgba(148,163,184,.15); border-radius: 10px; padding: 8px 10px;\n    }\n    .stat .k { color: var(--muted); font-size: 12px; }\n    .stat .v { font-weight: 700; font-size: 16px; }\n    .log {\n      background: rgba(2,6,23,.45); border: 1px solid rgba(148,163,184,.15); border-radius: 10px; padding: 8px; height: 150px; overflow: auto;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace; font-size: 12px; line-height: 1.35;\n    }\n    .log .item { color: var(--muted); }\n    .pill {\n      display: inline-block; padding: 1px 8px; border-radius: 999px; border: 1px solid rgba(148,163,184,.25);\n      background: rgba(2,6,23,.5); font-size: 11px; color: var(--muted);\n    }\n    .viz-panel { display: grid; grid-template-rows: max-content 1fr max-content; gap: 10px; min-height: 0; }\n    .viz-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; }\n    .legend { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }\n    .legend .dot { width: 12px; height: 12px; border-radius: 999px; display: inline-block; }\n    .canvas-wrap {\n      background: radial-gradient(1200px 600px at 20% -10%, rgba(34,211,238,.08), transparent 40%), radial-gradient(1200px 600px at 80% -10%, rgba(167,139,250,.08), transparent 40%), #020617;\n      border: 1px solid rgba(148,163,184,.18);\n      border-radius: 12px;\n      overflow: auto;\n      min-height: 260px;\n      max-height: calc(100vh - 220px);\n    }\n    .svg {\n      width: 100%; height: 100%;\n      display: block;\n      background-image: linear-gradient(transparent 23px, rgba(148,163,184,.08) 24px, transparent 24px), linear-gradient(90deg, transparent 23px, rgba(148,163,184,.08) 24px, transparent 24px);\n      background-size: 24px 24px;\n    }\n    .edge {\n      stroke: var(--edge); stroke-width: 2.2px;\n    }\n    .edge.highlight { stroke: var(--edge-hi); stroke-width: 2.6px; }\n    .node {\n      fill: var(--node);\n      stroke: rgba(148,163,184,.45);\n      stroke-width: 1.2px;\n      transition: transform .15s ease, fill .15s ease, stroke .15s ease;\n      cursor: pointer;\n    }\n    .node:hover { filter: brightness(1.08); }\n    .node.hi { fill: #0b2a38; stroke: var(--node-hi); }\n    .node.found { fill: #07202b; stroke: var(--node-found); }\n    .node.del { fill: #2a0911; stroke: var(--node-del); }\n    .label { fill: #e2e8f0; font-weight: 700; pointer-events: none; font-size: 12px; text-anchor: middle; dominant-baseline: central; }\n    .sub-label { fill: var(--muted); font-size: 10px; pointer-events: none; }\n    .travs {\n      display: grid; gap: 8px; grid-template-columns: 1fr; margin-top: 4px;\n    }\n    .trav {\n      background: rgba(2,6,23,.45); border: 1px solid rgba(148,163,184,.15); border-radius: 10px; padding: 8px;\n    }\n    .trav .name { color: var(--muted); font-size: 12px; }\n    .trav .vals { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace; font-size: 12px; margin-top: 4px; word-break: break-word;}\n    .hint { color: var(--muted); font-size: 12px; }\n    .hr { height: 1px; background: rgba(148,163,184,.18); margin: 8px 0; }\n    .footer {\n      display: flex; align-items: center; justify-content: space-between; gap: 8px; flex-wrap: wrap;\n    }\n    .toggle {\n      display: inline-flex; align-items: center; gap: 8px; background: rgba(2,6,23,.45);\n      border: 1px solid rgba(148,163,184,.25); border-radius: 999px; padding: 4px 8px; cursor: pointer;\n    }\n    .toggle input { accent-color: var(--accent); }\n    .ghost { opacity: .6; }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"panel\">\n      <div class=\"header\">\n        <div class=\"title\">\n          <span>Binary Search Tree</span>\n          <span class=\"badge\">BST</span>\n        </div>\n        <span class=\"pill\">Interactive demo</span>\n      </div>\n\n      <div class=\"controls\">\n        <div class=\"row\">\n          <input id=\"keyInput\" class=\"input\" type=\"number\" step=\"1\" placeholder=\"Enter integer (e.g., 42)\" />\n        </div>\n        <div class=\"row\">\n          <button id=\"insertBtn\" class=\"btn accent\">Insert</button>\n          <button id=\"deleteBtn\" class=\"btn warn\">Delete</button>\n          <button id=\"searchBtn\" class=\"btn\">Search</button>\n        </div>\n        <div class=\"row\">\n          <button id=\"rnd1Btn\" class=\"btn\">+1 Random</button>\n          <button id=\"rnd5Btn\" class=\"btn\">+5 Random</button>\n          <button id=\"rnd10Btn\" class=\"btn\">+10 Random</button>\n          <button id=\"clearBtn\" class=\"btn\">Clear</button>\n        </div>\n\n        <div class=\"grid-2\">\n          <div class=\"stat\">\n            <div class=\"k\">Size</div>\n            <div class=\"v\" id=\"sizeVal\">0</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"k\">Height (nodes)</div>\n            <div class=\"v\" id=\"heightVal\">0</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"k\">Min</div>\n            <div class=\"v\" id=\"minVal\">—</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"k\">Max</div>\n            <div class=\"v\" id=\"maxVal\">—</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"k\">Valid BST</div>\n            <div class=\"v\" id=\"validVal\">Yes</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"k\">Balanced?</div>\n            <div class=\"v\" id=\"balancedVal\">No (not self-balancing)</div>\n          </div>\n        </div>\n\n        <div class=\"hr\"></div>\n        <div class=\"tiny\">\n          A Binary Search Tree maintains the invariant: for any node with key k, all keys in its left subtree are less than k, and all keys in its right subtree are greater than k. Duplicate keys are not inserted here.\n        </div>\n        <div class=\"hr\"></div>\n\n        <div>\n          <div class=\"tiny\">Traversals</div>\n          <div class=\"travs\">\n            <div class=\"trav\">\n              <div class=\"name\">Inorder (sorted)</div>\n              <div class=\"vals\" id=\"inorderVals\">[]</div>\n            </div>\n            <div class=\"trav\">\n              <div class=\"name\">Preorder</div>\n              <div class=\"vals\" id=\"preorderVals\">[]</div>\n            </div>\n            <div class=\"trav\">\n              <div class=\"name\">Postorder</div>\n              <div class=\"vals\" id=\"postorderVals\">[]</div>\n            </div>\n            <div class=\"trav\">\n              <div class=\"name\">Level-order</div>\n              <div class=\"vals\" id=\"levelVals\">[]</div>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"hr\"></div>\n        <div>\n          <div class=\"tiny\">Event log</div>\n          <div id=\"log\" class=\"log\" aria-live=\"polite\"></div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel viz-panel\">\n      <div class=\"viz-header\">\n        <div class=\"title\"><span>Tree Visualization</span></div>\n        <div class=\"legend\">\n          <span class=\"dot\" style=\"background:#0b2a38;border:1px solid #0ea5e9\"></span><span class=\"tiny\">Path</span>\n          <span class=\"dot\" style=\"background:#07202b;border:1px solid #38bdf8\"></span><span class=\"tiny\">Found</span>\n          <span class=\"dot\" style=\"background:#2a0911;border:1px solid #fb7185\"></span><span class=\"tiny\">Deleted</span>\n        </div>\n      </div>\n      <div id=\"canvasWrap\" class=\"canvas-wrap\">\n        <svg id=\"svg\" class=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" role=\"img\" aria-label=\"BST visualization\"></svg>\n      </div>\n      <div class=\"footer\">\n        <div class=\"hint\">Click a node to select its key or highlight the path from root.</div>\n        <label class=\"toggle\">\n          <input id=\"animateToggle\" type=\"checkbox\" checked />\n          <span class=\"tiny\">Animate changes</span>\n        </label>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // ======= Data structures =======\n    class TreeNode {\n      constructor(key) {\n        this.key = key;\n        this.left = null;\n        this.right = null;\n      }\n    }\n\n    class BST {\n      constructor() {\n        this.root = null;\n        this._size = 0;\n      }\n      get size() { return this._size; }\n\n      insert(key) {\n        const path = [];\n        if (this.root === null) {\n          this.root = new TreeNode(key);\n          this._size = 1;\n          return { inserted: true, node: this.root, path };\n        }\n        let cur = this.root;\n        let parent = null;\n        while (cur) {\n          path.push(cur);\n          parent = cur;\n          if (key === cur.key) {\n            return { inserted: false, node: cur, path };\n          } else if (key < cur.key) {\n            cur = cur.left;\n          } else {\n            cur = cur.right;\n          }\n        }\n        const n = new TreeNode(key);\n        if (key < parent.key) parent.left = n; else parent.right = n;\n        this._size++;\n        path.push(n);\n        return { inserted: true, node: n, path };\n      }\n\n      search(key) {\n        const path = [];\n        let cur = this.root;\n        while (cur) {\n          path.push(cur);\n          if (key === cur.key) return { found: true, node: cur, path };\n          cur = key < cur.key ? cur.left : cur.right;\n        }\n        return { found: false, node: null, path };\n      }\n\n      delete(key) {\n        // Collect path to the target (if exists) for highlight\n        const s = this.search(key);\n        const res = this._deleteRec(this.root, key);\n        this.root = res.node;\n        if (res.deleted) this._size--;\n        return { deleted: res.deleted, path: s.path, key };\n      }\n\n      _deleteRec(node, key) {\n        if (!node) return { node: null, deleted: false };\n        if (key < node.key) {\n          const leftRes = this._deleteRec(node.left, key);\n          node.left = leftRes.node;\n          return { node, deleted: leftRes.deleted };\n        } else if (key > node.key) {\n          const rightRes = this._deleteRec(node.right, key);\n          node.right = rightRes.node;\n          return { node, deleted: rightRes.deleted };\n        } else {\n          // node to delete found\n          if (!node.left && !node.right) {\n            return { node: null, deleted: true };\n          } else if (!node.left) {\n            return { node: node.right, deleted: true };\n          } else if (!node.right) {\n            return { node: node.left, deleted: true };\n          } else {\n            // Two children: inorder successor\n            const succ = this._minNode(node.right);\n            node.key = succ.key;\n            const r = this._deleteRec(node.right, succ.key);\n            node.right = r.node;\n            return { node, deleted: true };\n          }\n        }\n      }\n\n      _minNode(node) {\n        if (!node) return null;\n        while (node.left) node = node.left;\n        return node;\n      }\n\n      _maxNode(node) {\n        if (!node) return null;\n        while (node.right) node = node.right;\n        return node;\n      }\n\n      min() {\n        const n = this._minNode(this.root);\n        return n ? n.key : null;\n      }\n\n      max() {\n        const n = this._maxNode(this.root);\n        return n ? n.key : null;\n      }\n\n      height() {\n        const h = (n) => n ? 1 + Math.max(h(n.left), h(n.right)) : 0;\n        return h(this.root);\n      }\n\n      isValid() {\n        const dfs = (n, lo, hi) => {\n          if (!n) return true;\n          if ((lo !== null && n.key <= lo) || (hi !== null && n.key >= hi)) return false;\n          return dfs(n.left, lo, n.key) && dfs(n.right, n.key, hi);\n        };\n        return dfs(this.root, null, null);\n      }\n\n      // Traversals\n      inorder() {\n        const res = [];\n        (function dfs(n){ if (!n) return; dfs(n.left); res.push(n.key); dfs(n.right); })(this.root);\n        return res;\n      }\n      preorder() {\n        const res = [];\n        (function dfs(n){ if (!n) return; res.push(n.key); dfs(n.left); dfs(n.right); })(this.root);\n        return res;\n      }\n      postorder() {\n        const res = [];\n        (function dfs(n){ if (!n) return; dfs(n.left); dfs(n.right); res.push(n.key); })(this.root);\n        return res;\n      }\n      levelOrder() {\n        const res = [];\n        if (!this.root) return res;\n        const q = [this.root];\n        while (q.length) {\n          const n = q.shift();\n          res.push(n.key);\n          if (n.left) q.push(n.left);\n          if (n.right) q.push(n.right);\n        }\n        return res;\n      }\n    }\n\n    // ======= App State =======\n    const state = {\n      bst: new BST(),\n      highlightPath: new Set(),\n      highlightNodes: new Map(), // node -> className 'hi'|'found'|'del'\n      selectedNode: null,\n      animate: true,\n      lastAction: ''\n    };\n\n    // ======= Utilities =======\n    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }\n    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n    function now() { return new Date().toLocaleTimeString(); }\n\n    function log(message) {\n      const el = document.getElementById('log');\n      const item = document.createElement('div');\n      item.className = 'item';\n      item.textContent = `[${now()}] ${message}`;\n      el.appendChild(item);\n      el.scrollTop = el.scrollHeight;\n    }\n\n    function setInputValue(v) {\n      document.getElementById('keyInput').value = v ?? '';\n    }\n\n    // ======= Visualization =======\n    function computePositions(root) {\n      const pos = new Map();\n      let xIndex = 0;\n      let maxDepth = 0;\n      function dfs(n, depth) {\n        if (!n) return;\n        dfs(n.left, depth + 1);\n        pos.set(n, { xIndex: xIndex++, depth });\n        if (depth > maxDepth) maxDepth = depth;\n        dfs(n.right, depth + 1);\n      }\n      dfs(root, 0);\n      return { pos, maxDepth, count: xIndex };\n    }\n\n    function drawTree() {\n      const svg = document.getElementById('svg');\n      const wrap = document.getElementById('canvasWrap');\n      // Clear\n      svg.innerHTML = '';\n\n      const { pos, maxDepth, count } = computePositions(state.bst.root);\n      // Layout settings\n      const levelGap = 90;\n      const nodeRadius = 18;\n      const xSpacing = 56;\n      const marginX = 40;\n      const marginY = 40;\n      const width = Math.max(wrap.clientWidth, count * xSpacing + marginX * 2);\n      const height = Math.max(200, (maxDepth + 1) * levelGap + marginY * 2);\n\n      svg.setAttribute('width', width);\n      svg.setAttribute('height', height);\n\n      // To draw edges and nodes, we need to traverse tree preserving parent-child relations.\n      function getXY(n) {\n        const p = pos.get(n);\n        return {\n          x: marginX + (p.xIndex + 0.5) * xSpacing,\n          y: marginY + p.depth * levelGap\n        };\n      }\n\n      // Edges\n      function drawEdges(n) {\n        if (!n) return;\n        if (n.left) {\n          const { x: x1, y: y1 } = getXY(n);\n          const { x: x2, y: y2 } = getXY(n.left);\n          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n          line.setAttribute('x1', x1);\n          line.setAttribute('y1', y1 + nodeRadius);\n          line.setAttribute('x2', x2);\n          line.setAttribute('y2', y2 - nodeRadius);\n          line.setAttribute('class', 'edge' + (state.highlightPath.has(n.left) && state.highlightPath.has(n) ? ' highlight' : ''));\n          svg.appendChild(line);\n        }\n        if (n.right) {\n          const { x: x1, y: y1 } = getXY(n);\n          const { x: x2, y: y2 } = getXY(n.right);\n          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n          line.setAttribute('x1', x1);\n          line.setAttribute('y1', y1 + nodeRadius);\n          line.setAttribute('x2', x2);\n          line.setAttribute('y2', y2 - nodeRadius);\n          line.setAttribute('class', 'edge' + (state.highlightPath.has(n.right) && state.highlightPath.has(n) ? ' highlight' : ''));\n          svg.appendChild(line);\n        }\n        drawEdges(n.left);\n        drawEdges(n.right);\n      }\n\n      // Nodes\n      function drawNodes(n) {\n        if (!n) return;\n        drawNodes(n.left);\n\n        const { x, y } = getXY(n);\n        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        g.setAttribute('transform', `translate(${x},${y})`);\n\n        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n        circle.setAttribute('r', nodeRadius);\n        let nodeClass = 'node';\n        const mark = state.highlightNodes.get(n);\n        if (state.highlightPath.has(n)) nodeClass += ' hi';\n        if (mark === 'found') nodeClass += ' found';\n        if (mark === 'del') nodeClass += ' del';\n        circle.setAttribute('class', nodeClass);\n        if (state.animate) {\n          circle.style.transition = 'transform .2s ease';\n          circle.style.transformOrigin = 'center';\n          circle.style.transform = 'scale(1)';\n          // subtle pop-in when rendered with highlights\n          if (mark || state.highlightPath.has(n)) {\n            circle.animate([{ transform: 'scale(0.7)' }, { transform: 'scale(1)' }], { duration: 180 });\n          }\n        }\n\n        // Main label\n        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        text.setAttribute('class', 'label');\n        text.textContent = n.key;\n\n        // Sub-label: show L/R degrees\n        const sub = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        sub.setAttribute('class', 'sub-label');\n        sub.setAttribute('y', nodeRadius + 14);\n        const degL = n.left ? 'L' : '-';\n        const degR = n.right ? 'R' : '-';\n        sub.textContent = `(${degL} | ${degR})`;\n\n        g.appendChild(circle);\n        g.appendChild(text);\n        g.appendChild(sub);\n        svg.appendChild(g);\n\n        // Interactions\n        g.style.cursor = 'pointer';\n        g.addEventListener('click', () => {\n          setInputValue(n.key);\n          // Recompute and highlight path from root to this node\n          const s = state.bst.search(n.key);\n          setHighlightPath(new Set(s.path));\n          markNode(n, 'found');\n          announce(`Selected node ${n.key}. Path length ${s.path.length}.`);\n          render(false, 1200);\n        });\n\n        drawNodes(n.right);\n      }\n\n      drawEdges(state.bst.root);\n      drawNodes(state.bst.root);\n    }\n\n    function setHighlightPath(set) {\n      state.highlightPath = set || new Set();\n    }\n\n    function clearHighlightNodes() {\n      state.highlightNodes = new Map();\n    }\n\n    function markNode(node, type) {\n      // type: 'hi' (path), 'found', 'del'\n      if (!node) return;\n      state.highlightNodes.set(node, type);\n    }\n\n    // ======= Render =======\n    function render(instant = false, clearAfterMs = 800) {\n      // stats\n      document.getElementById('sizeVal').textContent = state.bst.size;\n      document.getElementById('heightVal').textContent = state.bst.height();\n      const min = state.bst.min();\n      const max = state.bst.max();\n      document.getElementById('minVal').textContent = min === null ? '—' : min;\n      document.getElementById('maxVal').textContent = max === null ? '—' : max;\n      document.getElementById('validVal').textContent = state.bst.isValid() ? 'Yes' : 'No';\n\n      // traversals\n      const fmt = (arr) => '[' + arr.join(', ') + ']';\n      document.getElementById('inorderVals').textContent = fmt(state.bst.inorder());\n      document.getElementById('preorderVals').textContent = fmt(state.bst.preorder());\n      document.getElementById('postorderVals').textContent = fmt(state.bst.postorder());\n      document.getElementById('levelVals').textContent = fmt(state.bst.levelOrder());\n\n      // draw\n      drawTree();\n\n      // Clear highlights after a bit (unless instant)\n      if (!instant && clearAfterMs > 0) {\n        const myPath = state.highlightPath;\n        const myMarks = new Map(state.highlightNodes);\n        setTimeout(() => {\n          // Only clear if still the same references (avoid clearing newer highlights)\n          if (state.highlightPath === myPath) setHighlightPath(new Set());\n          if (sameNodeMarkMap(state.highlightNodes, myMarks)) clearHighlightNodes();\n          drawTree();\n        }, clearAfterMs);\n      }\n    }\n\n    function sameNodeMarkMap(a, b) {\n      if (a.size !== b.size) return false;\n      for (const [k, v] of a) {\n        if (!b.has(k) || b.get(k) !== v) return false;\n      }\n      return true;\n    }\n\n    function announce(msg) { log(msg); }\n\n    // ======= Event handlers =======\n    function getInputKey() {\n      const val = document.getElementById('keyInput').value;\n      if (val === '' || val === null) return null;\n      const num = Number(val);\n      if (!Number.isFinite(num) || !Number.isInteger(num)) return null;\n      return num;\n    }\n\n    function handleInsert() {\n      const key = getInputKey();\n      if (key === null) { announce('Insert: please enter an integer.'); return; }\n      const { inserted, node, path } = state.bst.insert(key);\n      setHighlightPath(new Set(path));\n      if (inserted) {\n        markNode(node, 'found');\n        announce(`Inserted ${key}.`);\n      } else {\n        markNode(node, 'found');\n        announce(`Key ${key} already exists. No insertion.`);\n      }\n      render(false, 1000);\n    }\n\n    function handleDelete() {\n      const key = getInputKey();\n      if (key === null) { announce('Delete: please enter an integer.'); return; }\n      const { deleted, path } = state.bst.delete(key);\n      setHighlightPath(new Set(path));\n      if (deleted) {\n        // mark last in path (the deleted node) if present\n        const delNode = path.length ? path[path.length - 1] : null;\n        if (delNode && delNode.key === key) markNode(delNode, 'del');\n        announce(`Deleted ${key}.`);\n      } else {\n        announce(`Key ${key} not found. Nothing deleted.`);\n      }\n      render(false, 1000);\n    }\n\n    function handleSearch() {\n      const key = getInputKey();\n      if (key === null) { announce('Search: please enter an integer.'); return; }\n      const { found, node, path } = state.bst.search(key);\n      setHighlightPath(new Set(path));\n      if (found) {\n        markNode(node, 'found');\n        announce(`Found ${key}. Path length ${path.length}.`);\n      } else {\n        announce(`Key ${key} not found. Path length ${path.length}.`);\n      }\n      render(false, 1200);\n    }\n\n    function handleRandom(n = 1) {\n      let inserted = 0, attempts = 0;\n      const maxAttempts = Math.max(20, n * 10);\n      while (inserted < n && attempts < maxAttempts) {\n        attempts++;\n        const x = randInt(-99, 99);\n        const res = state.bst.insert(x);\n        if (res.inserted) inserted++;\n      }\n      setHighlightPath(new Set());\n      clearHighlightNodes();\n      announce(`Inserted ${inserted} random ${inserted === 1 ? 'key' : 'keys'}.`);\n      render(true, 0);\n    }\n\n    function handleClear() {\n      state.bst = new BST();\n      setHighlightPath(new Set());\n      clearHighlightNodes();\n      setInputValue('');\n      announce('Tree cleared.');\n      render(true, 0);\n    }\n\n    // ======= Bootstrap =======\n    function bind() {\n      document.getElementById('insertBtn').addEventListener('click', handleInsert);\n      document.getElementById('deleteBtn').addEventListener('click', handleDelete);\n      document.getElementById('searchBtn').addEventListener('click', handleSearch);\n      document.getElementById('rnd1Btn').addEventListener('click', () => handleRandom(1));\n      document.getElementById('rnd5Btn').addEventListener('click', () => handleRandom(5));\n      document.getElementById('rnd10Btn').addEventListener('click', () => handleRandom(10));\n      document.getElementById('clearBtn').addEventListener('click', handleClear);\n      document.getElementById('animateToggle').addEventListener('change', (e) => {\n        state.animate = !!e.target.checked;\n      });\n\n      document.getElementById('keyInput').addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n          handleInsert();\n        }\n      });\n\n      // Seed some values\n      const seed = [50, 25, 75, 10, 33, 60, 80, 5, 18, 30, 40, 55, 65, 77, 90];\n      for (const x of seed) state.bst.insert(x);\n      announce('Seeded example tree. Enter a number and click Insert/Delete/Search.');\n    }\n\n    window.addEventListener('resize', () => drawTree());\n\n    // Init\n    bind();\n    render(true, 0);\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Binary Search Tree (BST)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "42a7c470-a369-11f0-9fc3-5149435fab7f",
    "timestamp": "2025-10-07T10:34:53.368Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Red-Black Tree",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<title>Red-Black Tree Visualizer</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --accent: #3b82f6;\n    --ok: #10b981;\n    --warn: #f59e0b;\n    --err: #ef4444;\n    --text: #e5e7eb;\n    --muted: #9ca3af;\n  }\n  html, body {\n    margin: 0; padding: 0; background: var(--bg); color: var(--text);\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n    height: 100%;\n  }\n  header {\n    padding: 16px 20px;\n    border-bottom: 1px solid #1f2937;\n    background: linear-gradient(180deg, rgba(59,130,246,0.08), transparent);\n  }\n  header h1 {\n    margin: 0 0 6px 0;\n    font-size: 22px;\n    letter-spacing: 0.2px;\n  }\n  header p {\n    margin: 0;\n    color: var(--muted);\n    font-size: 13px;\n  }\n  .container {\n    display: grid;\n    grid-template-columns: 360px 1fr;\n    gap: 12px;\n    height: calc(100% - 72px);\n  }\n  .side {\n    border-right: 1px solid #1f2937;\n    padding: 12px;\n    overflow: auto;\n  }\n  .main {\n    padding: 10px;\n    overflow: auto;\n    position: relative;\n  }\n  .card {\n    background: var(--panel);\n    border: 1px solid #1f2937;\n    border-radius: 10px;\n    padding: 12px;\n    margin-bottom: 12px;\n  }\n  .card h2 {\n    margin: 0 0 8px 0;\n    font-size: 16px;\n    color: #d1d5db;\n  }\n  .row {\n    display: flex;\n    gap: 8px;\n    flex-wrap: wrap;\n    align-items: center;\n  }\n  .row + .row { margin-top: 8px; }\n  input[type=\"number\"], input[type=\"text\"] {\n    background: #0b1220;\n    color: var(--text);\n    border: 1px solid #1f2937;\n    border-radius: 8px;\n    padding: 8px 10px;\n    outline: none;\n    min-width: 0;\n  }\n  input[type=\"number\"]:focus, input[type=\"text\"]:focus {\n    border-color: var(--accent);\n  }\n  button {\n    background: #111827;\n    color: var(--text);\n    border: 1px solid #374151;\n    border-radius: 8px;\n    padding: 8px 12px;\n    cursor: pointer;\n    transition: 0.15s ease;\n  }\n  button.primary {\n    background: var(--accent);\n    border-color: var(--accent);\n    color: white;\n  }\n  button:hover {\n    transform: translateY(-1px);\n    box-shadow: 0 4px 12px rgba(0,0,0,0.35);\n  }\n  button:active { transform: translateY(0); }\n  .small {\n    font-size: 12px;\n    color: var(--muted);\n    margin-top: 6px;\n  }\n  .status {\n    display: grid;\n    grid-template-columns: repeat(2, minmax(0,1fr));\n    gap: 8px;\n  }\n  .badge {\n    display: inline-flex;\n    align-items: center;\n    gap: 6px;\n    padding: 6px 8px;\n    background: #0b1220;\n    border: 1px solid #1f2937;\n    border-radius: 8px;\n    font-size: 12px;\n  }\n  .dot {\n    width: 8px; height: 8px; border-radius: 50%;\n  }\n  .ok { background: var(--ok); }\n  .warn { background: var(--warn); }\n  .err { background: var(--err); }\n  .msg {\n    padding: 8px 10px;\n    border-radius: 8px;\n    background: #0b1220;\n    border: 1px solid #1f2937;\n    min-height: 20px;\n    color: var(--muted);\n    font-size: 13px;\n  }\n  .legend {\n    display: flex; gap: 12px; align-items: center; color: var(--muted); font-size: 12px;\n  }\n  .swatch {\n    width: 14px; height: 14px; border-radius: 50%; display: inline-block; margin-right: 6px;\n    border: 2px solid rgba(255,255,255,0.2);\n  }\n  .swatch.red { background: #ef4444; }\n  .swatch.black { background: #111827; border-color: #4b5563; }\n  .toggle {\n    display: inline-flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;\n  }\n  .toggle input { width: 16px; height: 16px; }\n  .svg-wrapper {\n    background: #0b1220;\n    border: 1px solid #1f2937;\n    border-radius: 10px;\n    overflow: hidden;\n    position: relative;\n  }\n  svg { display: block; width: 100%; height: 600px; }\n  .footer {\n    padding: 10px 20px; color: var(--muted); font-size: 12px; border-top: 1px solid #1f2937;\n  }\n  .kbd {\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n    background: #0b1220; border: 1px solid #1f2937; padding: 1px 5px; border-radius: 6px; color: #cbd5e1; font-size: 12px;\n  }\n</style>\n</head>\n<body>\n  <header>\n    <h1>Red-Black Tree Visualizer</h1>\n    <p>Insert, delete, and search keys while the tree maintains balance via rotations and recoloring. Colors: Red nodes, Black nodes.</p>\n  </header>\n\n  <div class=\"container\">\n    <aside class=\"side\">\n      <div class=\"card\">\n        <h2>Operations</h2>\n        <div class=\"row\">\n          <input id=\"keyInput\" type=\"number\" placeholder=\"Key (number)\" />\n          <button id=\"insertBtn\" class=\"primary\">Insert</button>\n          <button id=\"deleteBtn\">Delete</button>\n          <button id=\"findBtn\">Find</button>\n        </div>\n        <div class=\"row\">\n          <button id=\"randomBtn\">Insert Random</button>\n          <input id=\"randomCount\" type=\"number\" value=\"10\" min=\"1\" max=\"200\" title=\"Number of nodes\" />\n          <button id=\"buildRandomBtn\">Build Random</button>\n          <button id=\"clearBtn\">Clear</button>\n        </div>\n        <div class=\"row\">\n          <label class=\"toggle\"><input type=\"checkbox\" id=\"showNil\"> Show NIL leaves</label>\n          <label class=\"toggle\"><input type=\"checkbox\" id=\"autoCheck\" checked> Auto-check properties</label>\n        </div>\n        <div class=\"small\">Tip: Press Enter to insert. Use Delete key to remove the current value.</div>\n      </div>\n\n      <div class=\"card\">\n        <h2>Status</h2>\n        <div class=\"status\" id=\"statusGrid\">\n          <!-- Filled by JS -->\n        </div>\n      </div>\n\n      <div class=\"card\">\n        <h2>Messages</h2>\n        <div class=\"msg\" id=\"message\">Ready.</div>\n      </div>\n\n      <div class=\"card\">\n        <h2>About Red-Black Trees</h2>\n        <ul class=\"small\">\n          <li>Every node is either red or black.</li>\n          <li>The root is black.</li>\n          <li>All leaves (NIL sentinels) are black.</li>\n          <li>Red nodes have black children (no two reds in a row).</li>\n          <li>Every path from a node to descendant NIL nodes has the same number of black nodes (equal black-height).</li>\n        </ul>\n      </div>\n    </aside>\n\n    <main class=\"main\">\n      <div class=\"row\" style=\"justify-content: space-between; margin-bottom: 8px;\">\n        <div class=\"legend\">\n          <span><span class=\"swatch red\"></span>Red</span>\n          <span><span class=\"swatch black\"></span>Black</span>\n          <span style=\"display:inline-flex;align-items:center;gap:6px;\"><span class=\"swatch\" style=\"background:transparent;border-radius:50%; width:14px; height:14px; border:3px solid #f59e0b;\"></span>Highlight</span>\n        </div>\n        <div class=\"small\">Nodes auto-spaced; zoom with browser. Resize window to fit.</div>\n      </div>\n      <div class=\"svg-wrapper\">\n        <svg id=\"treeSvg\" viewBox=\"0 0 800 600\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n      </div>\n    </main>\n  </div>\n\n  <div class=\"footer\">\n    Keyboard shortcuts: Enter = Insert, Shift+Enter = Find, Delete/Backspace = Delete. Use Tab to focus fields. \n    Example sequence: 10, 5, 15, 1, 7, 12, 18, 0, 2, 6, 8\n  </div>\n\n<script>\n(function() {\n  \"use strict\";\n\n  // Colors\n  const RED = 0;\n  const BLACK = 1;\n\n  // Utilities\n  const $ = sel => document.querySelector(sel);\n  const svgNS = \"http://www.w3.org/2000/svg\";\n\n  function createSvg(tag, attrs={}) {\n    const el = document.createElementNS(svgNS, tag);\n    for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);\n    return el;\n  }\n\n  // Red-Black Tree implementation (CLRS-style with a single NIL sentinel)\n  let NODE_ID_COUNTER = 1;\n  class RBNode {\n    constructor(key, color, left, right, parent) {\n      this.id = NODE_ID_COUNTER++;\n      this.key = key;\n      this.color = color;\n      this.left = left;\n      this.right = right;\n      this.parent = parent;\n      // layout fields\n      this._lw = 0;\n      this._rw = 0;\n      this._w = 1;\n      this._xUnit = 0;\n      this._depth = 0;\n    }\n  }\n\n  class RBTree {\n    constructor() {\n      this.NIL = new RBNode(null, BLACK, null, null, null);\n      this.NIL.left = this.NIL.right = this.NIL.parent = this.NIL;\n      this.root = this.NIL;\n      this.size = 0;\n    }\n\n    leftRotate(x) {\n      const y = x.right;\n      x.right = y.left;\n      if (y.left !== this.NIL) {\n        y.left.parent = x;\n      }\n      y.parent = x.parent;\n      if (x.parent === this.NIL) {\n        this.root = y;\n      } else if (x === x.parent.left) {\n        x.parent.left = y;\n      } else {\n        x.parent.right = y;\n      }\n      y.left = x;\n      x.parent = y;\n    }\n\n    rightRotate(x) {\n      const y = x.left;\n      x.left = y.right;\n      if (y.right !== this.NIL) {\n        y.right.parent = x;\n      }\n      y.parent = x.parent;\n      if (x.parent === this.NIL) {\n        this.root = y;\n      } else if (x === x.parent.right) {\n        x.parent.right = y;\n      } else {\n        x.parent.left = y;\n      }\n      y.right = x;\n      x.parent = y;\n    }\n\n    insert(key) {\n      // Prevent NaN\n      if (key == null || Number.isNaN(key)) return { ok: false, reason: \"Invalid key.\" };\n      let z = new RBNode(key, RED, this.NIL, this.NIL, this.NIL);\n      let y = this.NIL;\n      let x = this.root;\n\n      while (x !== this.NIL) {\n        y = x;\n        if (z.key === x.key) {\n          return { ok: false, reason: \"Duplicate keys are not allowed.\" };\n        } else if (z.key < x.key) {\n          x = x.left;\n        } else {\n          x = x.right;\n        }\n      }\n\n      z.parent = y;\n      if (y === this.NIL) {\n        this.root = z;\n      } else if (z.key < y.key) {\n        y.left = z;\n      } else {\n        y.right = z;\n      }\n\n      z.left = this.NIL;\n      z.right = this.NIL;\n      z.color = RED;\n      this.size++;\n      this.insertFixup(z);\n      return { ok: true, node: z };\n    }\n\n    insertFixup(z) {\n      while (z.parent.color === RED) {\n        if (z.parent === z.parent.parent.left) {\n          let y = z.parent.parent.right;\n          if (y.color === RED) {\n            // Case 1\n            z.parent.color = BLACK;\n            y.color = BLACK;\n            z.parent.parent.color = RED;\n            z = z.parent.parent;\n          } else {\n            if (z === z.parent.right) {\n              // Case 2\n              z = z.parent;\n              this.leftRotate(z);\n            }\n            // Case 3\n            z.parent.color = BLACK;\n            z.parent.parent.color = RED;\n            this.rightRotate(z.parent.parent);\n          }\n        } else {\n          // Mirror cases\n          let y = z.parent.parent.left;\n          if (y.color === RED) {\n            z.parent.color = BLACK;\n            y.color = BLACK;\n            z.parent.parent.color = RED;\n            z = z.parent.parent;\n          } else {\n            if (z === z.parent.left) {\n              z = z.parent;\n              this.rightRotate(z);\n            }\n            z.parent.color = BLACK;\n            z.parent.parent.color = RED;\n            this.leftRotate(z.parent.parent);\n          }\n        }\n      }\n      this.root.color = BLACK;\n    }\n\n    transplant(u, v) {\n      if (u.parent === this.NIL) {\n        this.root = v;\n      } else if (u === u.parent.left) {\n        u.parent.left = v;\n      } else {\n        u.parent.right = v;\n      }\n      v.parent = u.parent;\n    }\n\n    treeMinimum(x) {\n      while (x.left !== this.NIL) x = x.left;\n      return x;\n    }\n\n    findNode(key) {\n      let x = this.root;\n      while (x !== this.NIL) {\n        if (key === x.key) return x;\n        x = (key < x.key) ? x.left : x.right;\n      }\n      return this.NIL;\n    }\n\n    delete(key) {\n      const z = this.findNode(key);\n      if (z === this.NIL) return { ok: false, reason: \"Key not found.\" };\n\n      let y = z;\n      let yOriginalColor = y.color;\n      let x;\n\n      if (z.left === this.NIL) {\n        x = z.right;\n        this.transplant(z, z.right);\n      } else if (z.right === this.NIL) {\n        x = z.left;\n        this.transplant(z, z.left);\n      } else {\n        y = this.treeMinimum(z.right);\n        yOriginalColor = y.color;\n        x = y.right;\n        if (y.parent === z) {\n          x.parent = y;\n        } else {\n          this.transplant(y, y.right);\n          y.right = z.right;\n          y.right.parent = y;\n        }\n        this.transplant(z, y);\n        y.left = z.left;\n        y.left.parent = y;\n        y.color = z.color;\n      }\n\n      if (yOriginalColor === BLACK) {\n        this.deleteFixup(x);\n      }\n\n      this.size--;\n      return { ok: true, removed: z };\n    }\n\n    deleteFixup(x) {\n      while (x !== this.root && x.color === BLACK) {\n        if (x === x.parent.left) {\n          let w = x.parent.right;\n          if (w.color === RED) {\n            w.color = BLACK;\n            x.parent.color = RED;\n            this.leftRotate(x.parent);\n            w = x.parent.right;\n          }\n          if (w.left.color === BLACK && w.right.color === BLACK) {\n            w.color = RED;\n            x = x.parent;\n          } else {\n            if (w.right.color === BLACK) {\n              w.left.color = BLACK;\n              w.color = RED;\n              this.rightRotate(w);\n              w = x.parent.right;\n            }\n            w.color = x.parent.color;\n            x.parent.color = BLACK;\n            w.right.color = BLACK;\n            this.leftRotate(x.parent);\n            x = this.root;\n          }\n        } else {\n          let w = x.parent.left;\n          if (w.color === RED) {\n            w.color = BLACK;\n            x.parent.color = RED;\n            this.rightRotate(x.parent);\n            w = x.parent.left;\n          }\n          if (w.right.color === BLACK && w.left.color === BLACK) {\n            w.color = RED;\n            x = x.parent;\n          } else {\n            if (w.left.color === BLACK) {\n              w.right.color = BLACK;\n              w.color = RED;\n              this.leftRotate(w);\n              w = x.parent.left;\n            }\n            w.color = x.parent.color;\n            x.parent.color = BLACK;\n            w.left.color = BLACK;\n            this.rightRotate(x.parent);\n            x = this.root;\n          }\n        }\n      }\n      x.color = BLACK;\n    }\n  }\n\n  // Visualization and UI\n  const tree = new RBTree();\n  const svg = $(\"#treeSvg\");\n  const msg = $(\"#message\");\n  const statusGrid = $(\"#statusGrid\");\n  const showNilChk = $(\"#showNil\");\n  const autoCheckChk = $(\"#autoCheck\");\n\n  let lastHighlightNode = null;\n\n  function setMessage(text, type=\"info\") {\n    msg.textContent = text;\n    msg.style.color = (type === \"error\") ? \"#fecaca\" : (type === \"ok\" ? \"#bbf7d0\" : \"#9ca3af\");\n    msg.style.borderColor = (type === \"error\") ? \"#7f1d1d\" : (type === \"ok\" ? \"#14532d\" : \"#1f2937\");\n  }\n\n  // Layout computation\n  function computeWidths(node) {\n    if (node === tree.NIL) return 0;\n    node._lw = computeWidths(node.left);\n    node._rw = computeWidths(node.right);\n    node._w = Math.max(1, node._lw + node._rw + 1);\n    return node._w;\n  }\n\n  function assignPositions(node, depth, xMin) {\n    if (node === tree.NIL) return;\n    node._depth = depth;\n    const x = xMin + node._lw;\n    node._xUnit = x;\n    assignPositions(node.left, depth + 1, xMin);\n    assignPositions(node.right, depth + 1, x + 1);\n  }\n\n  function collectNodes(node, arr=[]) {\n    if (node === tree.NIL) return arr;\n    arr.push(node);\n    collectNodes(node.left, arr);\n    collectNodes(node.right, arr);\n    return arr;\n  }\n\n  function render() {\n    while (svg.firstChild) svg.removeChild(svg.firstChild);\n\n    if (tree.root === tree.NIL) {\n      const t = createSvg(\"text\", { x: 20, y: 30, fill: \"#94a3b8\", \"font-size\": \"14\" });\n      t.textContent = \"Tree is empty.\";\n      svg.appendChild(t);\n      updateStatus();\n      return;\n    }\n\n    // Layout\n    const units = computeWidths(tree.root);\n    assignPositions(tree.root, 0, 0);\n    const nodes = collectNodes(tree.root);\n\n    const levelCount = Math.max(...nodes.map(n => n._depth)) + 1;\n    const nodeRadius = 16;\n    const unitX = 40;     // horizontal spacing per unit\n    const levelY = 80;    // vertical spacing per level\n    const margin = 30;\n\n    const width = Math.max(600, units * unitX + margin * 2);\n    const height = Math.max(200, levelCount * levelY + margin * 2);\n\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n\n    // Helper to get pixel coords\n    function px(n) {\n      return {\n        x: margin + n._xUnit * unitX,\n        y: margin + n._depth * levelY\n      };\n    }\n\n    // Draw edges first\n    function drawEdges(node) {\n      if (node === tree.NIL) return;\n      const p1 = px(node);\n      if (node.left !== tree.NIL) {\n        const p2 = px(node.left);\n        const line = createSvg(\"line\", {\n          x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y,\n          stroke: \"#4b5563\", \"stroke-width\": 2\n        });\n        svg.appendChild(line);\n      } else if (showNilChk.checked) {\n        // draw NIL left\n        const p2 = { x: p1.x - unitX/2, y: p1.y + levelY/2 };\n        const r = 6;\n        const rect = createSvg(\"rect\", {\n          x: p2.x - r, y: p2.y - r, width: r*2, height: r*2, rx: 2,\n          fill: \"#111827\", stroke: \"#374151\", \"stroke-width\": 1\n        });\n        const guide = createSvg(\"line\", { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, stroke: \"#374151\", \"stroke-dasharray\": \"4 3\" });\n        svg.appendChild(guide);\n        svg.appendChild(rect);\n      }\n      if (node.right !== tree.NIL) {\n        const p2 = px(node.right);\n        const line = createSvg(\"line\", {\n          x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y,\n          stroke: \"#4b5563\", \"stroke-width\": 2\n        });\n        svg.appendChild(line);\n      } else if (showNilChk.checked) {\n        // draw NIL right\n        const p2 = { x: p1.x + unitX/2, y: p1.y + levelY/2 };\n        const r = 6;\n        const rect = createSvg(\"rect\", {\n          x: p2.x - r, y: p2.y - r, width: r*2, height: r*2, rx: 2,\n          fill: \"#111827\", stroke: \"#374151\", \"stroke-width\": 1\n        });\n        const guide = createSvg(\"line\", { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, stroke: \"#374151\", \"stroke-dasharray\": \"4 3\" });\n        svg.appendChild(guide);\n        svg.appendChild(rect);\n      }\n      drawEdges(node.left);\n      drawEdges(node.right);\n    }\n    drawEdges(tree.root);\n\n    // Draw nodes\n    for (const n of nodes) {\n      const { x, y } = px(n);\n\n      // Highlight ring (if matches last highlight)\n      if (lastHighlightNode && n === lastHighlightNode) {\n        const ring = createSvg(\"circle\", {\n          cx: x, cy: y, r: nodeRadius + 6,\n          fill: \"none\", stroke: \"#f59e0b\", \"stroke-width\": 3\n        });\n        svg.appendChild(ring);\n      }\n\n      const fill = (n.color === RED) ? \"#ef4444\" : \"#111827\";\n      const stroke = (n.color === RED) ? \"#7f1d1d\" : \"#4b5563\";\n      const textFill = (n.color === RED) ? \"#1f2937\" : \"#e5e7eb\";\n\n      const circle = createSvg(\"circle\", {\n        cx: x, cy: y, r: nodeRadius,\n        fill, stroke, \"stroke-width\": 2\n      });\n      circle.style.cursor = \"pointer\";\n      circle.addEventListener(\"mouseenter\", () => {\n        circle.setAttribute(\"stroke\", \"#3b82f6\");\n      });\n      circle.addEventListener(\"mouseleave\", () => {\n        circle.setAttribute(\"stroke\", stroke);\n      });\n      circle.addEventListener(\"click\", () => {\n        lastHighlightNode = n;\n        render();\n        setMessage(`Selected node ${n.key} (${n.color === RED ? \"RED\" : \"BLACK\"}).`);\n      });\n\n      const label = createSvg(\"text\", {\n        x, y: y + 4, \"text-anchor\": \"middle\", \"font-size\": \"13\",\n        fill: textFill\n      });\n      label.textContent = String(n.key);\n\n      svg.appendChild(circle);\n      svg.appendChild(label);\n    }\n\n    if (autoCheckChk.checked) updateStatus();\n  }\n\n  function validateProperties() {\n    // BST property\n    function isBST(node, min, max) {\n      if (node === tree.NIL) return true;\n      if (!(node.key > min && node.key < max)) return false;\n      return isBST(node.left, min, node.key) && isBST(node.right, node.key, max);\n    }\n\n    // Root black\n    const rootBlack = (tree.root === tree.NIL) ? true : (tree.root.color === BLACK);\n\n    // Red node has black children\n    function redsOk(node) {\n      if (node === tree.NIL) return true;\n      if (node.color === RED) {\n        if (!(node.left.color === BLACK && node.right.color === BLACK)) return false;\n      }\n      return redsOk(node.left) && redsOk(node.right);\n    }\n\n    // Equal black height\n    function blackHeights(node) {\n      if (node === tree.NIL) return [1]; // NIL counts as black\n      const left = blackHeights(node.left);\n      const right = blackHeights(node.right);\n      const add = (node.color === BLACK) ? 1 : 0;\n      const res = [];\n      for (const v of left) res.push(v + add);\n      for (const v of right) res.push(v + add);\n      return res;\n    }\n\n    const isBstOk = isBST(tree.root, -Infinity, Infinity);\n    const redsAreOk = redsOk(tree.root);\n    const bhList = blackHeights(tree.root);\n    const bhSet = new Set(bhList);\n    const bhOk = bhSet.size <= 1; // All equal\n    const bhVal = (bhList.length ? bhList[0] : 0);\n\n    return {\n      size: tree.size,\n      rootBlack,\n      redsAreOk,\n      bhOk,\n      bhVal,\n      isBstOk\n    };\n  }\n\n  function updateStatus() {\n    const s = validateProperties();\n    statusGrid.innerHTML = \"\";\n\n    function addBadge(ok, label, type) {\n      const div = document.createElement(\"div\");\n      div.className = \"badge\";\n      const dot = document.createElement(\"span\");\n      dot.className = \"dot \" + (ok ? \"ok\" : (type === \"warn\" ? \"warn\" : \"err\"));\n      const txt = document.createElement(\"span\");\n      txt.textContent = label + \": \" + (ok ? \"OK\" : \"Fail\");\n      div.appendChild(dot);\n      div.appendChild(txt);\n      statusGrid.appendChild(div);\n    }\n\n    function addInfo(label, value) {\n      const div = document.createElement(\"div\");\n      div.className = \"badge\";\n      const dot = document.createElement(\"span\");\n      dot.className = \"dot ok\";\n      const txt = document.createElement(\"span\");\n      txt.textContent = label + \": \" + value;\n      div.appendChild(dot);\n      div.appendChild(txt);\n      statusGrid.appendChild(div);\n    }\n\n    addInfo(\"Nodes\", s.size);\n    addInfo(\"Black-height\", s.bhVal);\n    addBadge(s.isBstOk, \"BST property\");\n    addBadge(s.rootBlack, \"Root is black\");\n    addBadge(s.redsAreOk, \"No red-red\");\n    addBadge(s.bhOk, \"Equal black-height\");\n  }\n\n  // UI Handlers\n  const keyInput = $(\"#keyInput\");\n  const insertBtn = $(\"#insertBtn\");\n  const deleteBtn = $(\"#deleteBtn\");\n  const findBtn = $(\"#findBtn\");\n  const randomBtn = $(\"#randomBtn\");\n  const buildRandomBtn = $(\"#buildRandomBtn\");\n  const randomCountInput = $(\"#randomCount\");\n  const clearBtn = $(\"#clearBtn\");\n\n  function parseKey() {\n    const v = keyInput.value.trim();\n    if (v === \"\") return { ok: false, reason: \"Enter a number.\" };\n    const n = Number(v);\n    if (!Number.isFinite(n)) return { ok: false, reason: \"Invalid number.\" };\n    return { ok: true, value: n };\n  }\n\n  function doInsert() {\n    const p = parseKey();\n    if (!p.ok) { setMessage(p.reason, \"error\"); return; }\n    const res = tree.insert(p.value);\n    if (res.ok) {\n      lastHighlightNode = res.node;\n      render();\n      setMessage(`Inserted ${p.value}.`, \"ok\");\n    } else {\n      setMessage(res.reason || \"Insert failed.\", \"error\");\n    }\n  }\n\n  function doDelete() {\n    const p = parseKey();\n    if (!p.ok) { setMessage(p.reason, \"error\"); return; }\n    const res = tree.delete(p.value);\n    if (res.ok) {\n      lastHighlightNode = null;\n      render();\n      setMessage(`Deleted ${p.value}.`, \"ok\");\n    } else {\n      setMessage(res.reason || \"Delete failed.\", \"error\");\n    }\n  }\n\n  function doFind() {\n    const p = parseKey();\n    if (!p.ok) { setMessage(p.reason, \"error\"); return; }\n    const n = tree.findNode(p.value);\n    if (n !== tree.NIL) {\n      lastHighlightNode = n;\n      render();\n      setMessage(`Found ${p.value}.`, \"ok\");\n    } else {\n      setMessage(`${p.value} not found.`, \"error\");\n      lastHighlightNode = null;\n      render();\n    }\n  }\n\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function insertRandomUnique() {\n    let tries = 0;\n    let k = 0;\n    let res;\n    do {\n      k = randInt(-99, 99);\n      res = tree.insert(k);\n      tries++;\n      if (tries > 500) break;\n    } while (!res.ok);\n    if (res.ok) {\n      lastHighlightNode = res.node;\n      render();\n      setMessage(`Inserted random ${k}.`, \"ok\");\n    } else {\n      setMessage(\"Failed to insert random number.\", \"error\");\n    }\n  }\n\n  function buildRandom() {\n    const n = Number(randomCountInput.value || 0);\n    if (!(n > 0 && n <= 1000)) {\n      setMessage(\"Enter a random size between 1 and 1000.\", \"error\");\n      return;\n    }\n    // Clear\n    tree.root = tree.NIL;\n    tree.size = 0;\n    lastHighlightNode = null;\n\n    const used = new Set();\n    let i = 0, tries = 0;\n    while (i < n && tries < n * 10) {\n      const k = randInt(-999, 999);\n      tries++;\n      if (used.has(k)) continue;\n      const res = tree.insert(k);\n      if (res.ok) {\n        used.add(k);\n        i++;\n      }\n    }\n    render();\n    setMessage(`Built random tree with ${tree.size} nodes.`, \"ok\");\n  }\n\n  function clearTree() {\n    tree.root = tree.NIL;\n    tree.size = 0;\n    lastHighlightNode = null;\n    render();\n    setMessage(\"Cleared tree.\", \"ok\");\n  }\n\n  // Event listeners\n  insertBtn.addEventListener(\"click\", doInsert);\n  deleteBtn.addEventListener(\"click\", doDelete);\n  findBtn.addEventListener(\"click\", doFind);\n  randomBtn.addEventListener(\"click\", insertRandomUnique);\n  buildRandomBtn.addEventListener(\"click\", buildRandom);\n  clearBtn.addEventListener(\"click\", clearTree);\n  showNilChk.addEventListener(\"change\", render);\n  autoCheckChk.addEventListener(\"change\", updateStatus);\n\n  keyInput.addEventListener(\"keydown\", (e) => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      doInsert();\n    } else if (e.key === \"Enter\" && e.shiftKey) {\n      doFind();\n    } else if (e.key === \"Delete\" || e.key === \"Backspace\") {\n      if (keyInput.value.trim() !== \"\") {\n        // Avoid default backspace navigation on empty\n        e.preventDefault();\n        doDelete();\n      }\n    }\n  });\n\n  // Initial demo\n  function seedDemo() {\n    const seq = [10, 5, 15, 1, 7, 12, 18, 0, 2, 6, 8];\n    for (const k of seq) tree.insert(k);\n    lastHighlightNode = tree.findNode(7);\n  }\n\n  seedDemo();\n  render();\n  setMessage(\"Ready. Insert numbers and observe rotations and recoloring in action.\");\n\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Red-Black Tree"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "61c947c0-a369-11f0-adf4-d5a9b2698fce",
    "timestamp": "2025-10-07T10:35:45.596Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Heap (Min/Max)",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<title>Heap (Min/Max) Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --accent: #60a5fa;\n    --accent2: #34d399;\n    --text: #e5e7eb;\n    --muted: #94a3b8;\n    --danger: #f87171;\n    --node: #1f2937;\n    --node-border: #374151;\n    --highlight: #fbbf24;\n  }\n  html, body {\n    margin: 0; padding: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n  }\n  header {\n    padding: 16px 20px; border-bottom: 1px solid #1f2937; background: #0b1220; position: sticky; top: 0; z-index: 5;\n  }\n  header h1 { margin: 0; font-size: 18px; font-weight: 600; }\n  header small { color: var(--muted); display: block; margin-top: 4px; }\n  .container {\n    display: grid;\n    grid-template-columns: 340px 1fr;\n    gap: 16px; padding: 16px 20px;\n  }\n  .panel {\n    background: var(--panel); border: 1px solid #1f2937; border-radius: 10px; padding: 12px;\n  }\n  .panel h2 { margin: 0 0 10px 0; font-size: 16px; font-weight: 600; }\n  .controls { display: grid; grid-template-columns: 1fr; gap: 10px; }\n  .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }\n  .row label { color: var(--muted); }\n  .radio-group { display: flex; gap: 8px; align-items: center; }\n  input[type=\"number\"], input[type=\"text\"] {\n    background: #0b1220; color: var(--text); border: 1px solid #334155; border-radius: 8px; padding: 8px 10px; outline: none; width: 100%;\n  }\n  input[type=\"range\"] { width: 100%; }\n  .btn {\n    background: #0b1220; color: var(--text); border: 1px solid #334155; border-radius: 8px; padding: 8px 10px; cursor: pointer;\n    transition: border-color .15s ease, transform .05s ease;\n  }\n  .btn:hover { border-color: #475569; }\n  .btn:active { transform: scale(0.98); }\n  .btn.primary { background: linear-gradient(180deg, #1f3a8a, #1e293b); border-color: #1e40af; }\n  .btn.success { background: linear-gradient(180deg, #065f46, #1e293b); border-color: #10b981; }\n  .btn.danger { background: linear-gradient(180deg, #7f1d1d, #1e293b); border-color: #ef4444; }\n  .btn:disabled { opacity: 0.6; cursor: not-allowed; }\n  .grid {\n    display: grid; grid-template-columns: 1fr; gap: 12px;\n  }\n  /* Array view */\n  .array-view {\n    display: flex; gap: 8px; flex-wrap: wrap; align-items: flex-start;\n    padding: 8px; background: #0b1220; border: 1px dashed #334155; border-radius: 8px; min-height: 56px;\n  }\n  .item {\n    position: relative;\n    background: var(--node); border: 1px solid var(--node-border); border-radius: 8px;\n    min-width: 44px; min-height: 44px; display: grid; place-items: center; font-weight: 600;\n  }\n  .item .idx {\n    position: absolute; top: -8px; right: -8px; font-size: 11px; background: #0b1220; border: 1px solid #334155; padding: 2px 4px; border-radius: 6px; color: var(--muted);\n  }\n  .item.root { border-color: var(--accent); box-shadow: 0 0 0 1px inset var(--accent); }\n  .item.highlight { border-color: var(--highlight); box-shadow: 0 0 0 2px inset var(--highlight); }\n  /* Tree view */\n  .tree-container {\n    position: relative; height: 460px; overflow: auto; background: #0b1220; border-radius: 10px; border: 1px dashed #334155;\n  }\n  .tree-inner {\n    position: relative; min-width: 800px; min-height: 440px;\n  }\n  .node {\n    position: absolute;\n    width: 44px; height: 44px; border-radius: 50%; background: var(--node);\n    border: 1px solid var(--node-border); display: grid; place-items: center; font-weight: 700;\n    transition: transform .15s ease, border-color .15s ease, box-shadow .15s ease, background .15s ease;\n  }\n  .node.root { border-color: var(--accent); box-shadow: 0 0 0 2px inset var(--accent); }\n  .node.highlight { border-color: var(--highlight); box-shadow: 0 0 0 3px inset var(--highlight); background: #1f2a3b; }\n  svg.lines { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }\n  .legend { color: var(--muted); font-size: 13px; }\n  .log {\n    background: #0b1220; border: 1px dashed #334155; border-radius: 10px; padding: 8px; height: 140px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  }\n  .log p { margin: 0 0 6px 0; }\n  .footer {\n    padding: 10px 20px; color: var(--muted);\n  }\n  .note { color: var(--muted); font-size: 12px; }\n</style>\n</head>\n<body>\n<header>\n  <h1>Heap (Min/Max) — Interactive Demo</h1>\n  <small>Binary heap with min/max toggle. Insert, extract, peek, visualize as array and tree, and see animations.</small>\n</header>\n\n<div class=\"container\">\n  <div class=\"panel\">\n    <h2>Controls</h2>\n    <div class=\"controls\">\n      <div class=\"row\">\n        <label>Heap type:</label>\n        <div class=\"radio-group\">\n          <label><input type=\"radio\" name=\"heapType\" value=\"min\" checked /> Min-Heap</label>\n          <label><input type=\"radio\" name=\"heapType\" value=\"max\" /> Max-Heap</label>\n        </div>\n      </div>\n\n      <div class=\"row\">\n        <label>Animation speed (ms):</label>\n      </div>\n      <input id=\"speed\" type=\"range\" min=\"60\" max=\"1000\" value=\"300\" />\n      <div class=\"note\">Lower is faster. Current: <span id=\"speedVal\">300</span> ms</div>\n\n      <div class=\"row\">\n        <input id=\"valueInput\" type=\"number\" placeholder=\"Enter number…\" />\n        <button id=\"insertBtn\" class=\"btn primary\">Insert</button>\n        <button id=\"randomBtn\" class=\"btn\">Random</button>\n      </div>\n\n      <div class=\"row\">\n        <button id=\"extractBtn\" class=\"btn success\">Extract Root</button>\n        <button id=\"peekBtn\" class=\"btn\">Peek Root</button>\n        <button id=\"clearBtn\" class=\"btn danger\">Clear</button>\n      </div>\n\n      <div class=\"row\">\n        <input id=\"listInput\" type=\"text\" placeholder=\"Comma-separated list e.g. 7,3,9,1,5\" />\n        <button id=\"buildBtn\" class=\"btn primary\">Build Heap</button>\n        <button id=\"randBuildBtn\" class=\"btn\">Build Random</button>\n      </div>\n\n      <div class=\"row\">\n        <button id=\"heapSortBtn\" class=\"btn\">Heap Sort (copy)</button>\n      </div>\n\n      <div class=\"legend\">\n        • Insert: O(log n) • Extract: O(log n) • Peek: O(1) • Build heap: O(n)\n      </div>\n    </div>\n  </div>\n\n  <div class=\"grid\">\n    <div class=\"panel\">\n      <h2>Array Representation (level-order)</h2>\n      <div id=\"arrayView\" class=\"array-view\"></div>\n    </div>\n    <div class=\"panel\">\n      <h2>Tree Visualization</h2>\n      <div id=\"treeContainer\" class=\"tree-container\">\n        <div id=\"treeInner\" class=\"tree-inner\">\n          <svg id=\"lines\" class=\"lines\"></svg>\n        </div>\n      </div>\n      <div class=\"legend\">Binary heap stored in array: parent index p = floor((i - 1) / 2). Children: left = 2p + 1, right = 2p + 2.</div>\n    </div>\n    <div class=\"panel\">\n      <h2>Log</h2>\n      <div id=\"log\" class=\"log\"></div>\n    </div>\n  </div>\n</div>\n\n<div class=\"footer\">\n  Tip: Toggle Min/Max to see how ordering changes. Heap property holds: root is min or max of all nodes.\n</div>\n\n<script>\n(function() {\n  // Utility\n  const sleep = (ms) => new Promise(res => setTimeout(res, ms));\n  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));\n  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n  const byId = (id) => document.getElementById(id);\n\n  class BinaryHeap {\n    constructor(isMin = true, onUpdate = null) {\n      this.data = [];\n      this.isMin = isMin;\n      this.onUpdate = onUpdate || (() => {});\n      this.busy = false;\n      this.animMs = 300;\n    }\n    comparator(a, b) { return this.isMin ? a < b : a > b; }\n    setType(isMin) {\n      this.isMin = isMin;\n      this.heapify();\n      this.onUpdate();\n    }\n    clear() {\n      this.data.length = 0;\n      this.onUpdate();\n    }\n    peek() {\n      return this.data.length ? this.data[0] : null;\n    }\n    async pushAnimated(val) {\n      this.data.push(val);\n      this.onUpdate({ highlight: [this.data.length - 1] });\n      await sleep(this.animMs);\n      let i = this.data.length - 1;\n      while (i > 0) {\n        const p = Math.floor((i - 1) / 2);\n        if (this.comparator(this.data[i], this.data[p])) {\n          this.swap(i, p);\n          this.onUpdate({ highlight: [i, p] });\n          await sleep(this.animMs);\n          i = p;\n        } else break;\n      }\n      this.onUpdate();\n    }\n    push(val) {\n      this.data.push(val);\n      this.bubbleUp(this.data.length - 1);\n      this.onUpdate();\n    }\n    async popAnimated() {\n      if (!this.data.length) return null;\n      const root = this.data[0];\n      const last = this.data.pop();\n      if (this.data.length) {\n        this.data[0] = last;\n        this.onUpdate({ highlight: [0] });\n        await sleep(this.animMs);\n        await this.bubbleDownAnimated(0);\n      }\n      this.onUpdate();\n      return root;\n    }\n    pop() {\n      if (!this.data.length) return null;\n      const root = this.data[0];\n      const last = this.data.pop();\n      if (this.data.length) {\n        this.data[0] = last;\n        this.bubbleDown(0);\n      }\n      this.onUpdate();\n      return root;\n    }\n    swap(i, j) {\n      const tmp = this.data[i];\n      this.data[i] = this.data[j];\n      this.data[j] = tmp;\n    }\n    bubbleUp(i) {\n      while (i > 0) {\n        const p = Math.floor((i - 1) / 2);\n        if (this.comparator(this.data[i], this.data[p])) {\n          this.swap(i, p);\n          i = p;\n        } else break;\n      }\n    }\n    async bubbleDownAnimated(i) {\n      const n = this.data.length;\n      while (true) {\n        const l = 2 * i + 1, r = 2 * i + 2;\n        let best = i;\n        if (l < n && this.comparator(this.data[l], this.data[best])) best = l;\n        if (r < n && this.comparator(this.data[r], this.data[best])) best = r;\n        if (best !== i) {\n          this.swap(i, best);\n          this.onUpdate({ highlight: [i, best] });\n          await sleep(this.animMs);\n          i = best;\n        } else break;\n      }\n    }\n    bubbleDown(i) {\n      const n = this.data.length;\n      while (true) {\n        const l = 2 * i + 1, r = 2 * i + 2;\n        let best = i;\n        if (l < n && this.comparator(this.data[l], this.data[best])) best = l;\n        if (r < n && this.comparator(this.data[r], this.data[best])) best = r;\n        if (best !== i) {\n          this.swap(i, best);\n          i = best;\n        } else break;\n      }\n    }\n    build(arr) {\n      this.data = Array.from(arr);\n      this.heapify();\n      this.onUpdate();\n    }\n    heapify() {\n      const n = this.data.length;\n      for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n        this.bubbleDown(i);\n      }\n    }\n    toArray() { return Array.from(this.data); }\n  }\n\n  // DOM references\n  const arrayView = byId('arrayView');\n  const treeContainer = byId('treeContainer');\n  const treeInner = byId('treeInner');\n  const linesSvg = byId('lines');\n  const logEl = byId('log');\n\n  const speedInput = byId('speed');\n  const speedVal = byId('speedVal');\n  const valueInput = byId('valueInput');\n  const insertBtn = byId('insertBtn');\n  const randomBtn = byId('randomBtn');\n  const extractBtn = byId('extractBtn');\n  const peekBtn = byId('peekBtn');\n  const clearBtn = byId('clearBtn');\n  const listInput = byId('listInput');\n  const buildBtn = byId('buildBtn');\n  const randBuildBtn = byId('randBuildBtn');\n  const heapSortBtn = byId('heapSortBtn');\n\n  const typeRadios = Array.from(document.querySelectorAll('input[name=\"heapType\"]'));\n\n  // State & heap\n  let highlightIndices = [];\n  let busy = false;\n  const setBusy = (b) => {\n    busy = b;\n    [insertBtn, randomBtn, extractBtn, peekBtn, clearBtn, buildBtn, randBuildBtn, heapSortBtn, valueInput, listInput, ...typeRadios].forEach(el => el.disabled = b);\n  };\n  const log = (msg) => {\n    const p = document.createElement('p');\n    p.textContent = msg;\n    logEl.appendChild(p);\n    logEl.scrollTop = logEl.scrollHeight;\n  };\n\n  const heap = new BinaryHeap(true, (opts = {}) => {\n    highlightIndices = Array.isArray(opts.highlight) ? opts.highlight.slice() : [];\n    draw();\n  });\n\n  // Draw functions\n  function drawArray() {\n    arrayView.innerHTML = '';\n    const data = heap.data;\n    data.forEach((v, i) => {\n      const div = document.createElement('div');\n      div.className = 'item' + (i === 0 ? ' root' : '') + (highlightIndices.includes(i) ? ' highlight' : '');\n      div.textContent = v;\n      const idx = document.createElement('div');\n      idx.className = 'idx';\n      idx.textContent = i;\n      div.appendChild(idx);\n      arrayView.appendChild(div);\n    });\n  }\n\n  function drawTree() {\n    const data = heap.data;\n    const W = Math.max(treeInner.clientWidth, 800);\n    const H = Math.max(treeInner.clientHeight, 440);\n    const levelGap = 90; // vertical spacing\n    const radius = 22; // node radius (half of 44)\n    const nodes = [];\n    // Clear previous nodes and lines\n    treeInner.querySelectorAll('.node').forEach(n => n.remove());\n    linesSvg.innerHTML = '';\n\n    // Compute positions\n    const levels = {};\n    data.forEach((v, i) => {\n      const L = Math.floor(Math.log2(i + 1));\n      const levelStartIdx = Math.pow(2, L) - 1;\n      const posInLevel = i - levelStartIdx;\n      const nodesInLevel = Math.pow(2, L);\n      const xRatio = (posInLevel + 1) / (nodesInLevel + 1);\n      const x = Math.floor(xRatio * (W - 120)) + 60; // padding for edges\n      const y = 40 + L * levelGap;\n      nodes.push({ i, v, x, y });\n      if (!levels[L]) levels[L] = [];\n      levels[L].push(i);\n    });\n\n    // Lines\n    const ns = 'http://www.w3.org/2000/svg';\n    nodes.forEach(node => {\n      const i = node.i;\n      const p = Math.floor((i - 1) / 2);\n      if (i > 0 && data[p] !== undefined) {\n        const parentNode = nodes[p];\n        const line = document.createElementNS(ns, 'line');\n        line.setAttribute('x1', parentNode.x);\n        line.setAttribute('y1', parentNode.y);\n        line.setAttribute('x2', node.x);\n        line.setAttribute('y2', node.y);\n        line.setAttribute('stroke', '#334155');\n        line.setAttribute('stroke-width', '2');\n        linesSvg.appendChild(line);\n      }\n    });\n\n    // Nodes\n    nodes.forEach(node => {\n      const el = document.createElement('div');\n      el.className = 'node' + (node.i === 0 ? ' root' : '') + (highlightIndices.includes(node.i) ? ' highlight' : '');\n      el.style.left = (node.x - radius) + 'px';\n      el.style.top = (node.y - radius) + 'px';\n      el.textContent = node.v;\n      treeInner.appendChild(el);\n    });\n  }\n\n  function draw() {\n    drawArray();\n    drawTree();\n  }\n\n  // Handlers\n  function updateTypeFromRadio() {\n    const isMin = typeRadios.find(r => r.checked)?.value === 'min';\n    heap.setType(isMin);\n    log(`Set heap type: ${isMin ? 'Min' : 'Max'}`);\n  }\n\n  typeRadios.forEach(r => r.addEventListener('change', updateTypeFromRadio));\n\n  speedInput.addEventListener('input', () => {\n    const ms = clamp(parseInt(speedInput.value || '300', 10), 60, 1000);\n    heap.animMs = ms;\n    speedVal.textContent = ms;\n  });\n\n  insertBtn.addEventListener('click', async () => {\n    const valStr = valueInput.value.trim();\n    let val = valStr === '' ? null : Number(valStr);\n    if (val === null || Number.isNaN(val)) {\n      log('Please enter a valid number to insert.');\n      return;\n    }\n    setBusy(true);\n    log(`Insert ${val}`);\n    await heap.pushAnimated(val);\n    setBusy(false);\n    valueInput.value = '';\n  });\n\n  randomBtn.addEventListener('click', async () => {\n    const val = randInt(0, 99);\n    setBusy(true);\n    log(`Insert random ${val}`);\n    await heap.pushAnimated(val);\n    setBusy(false);\n  });\n\n  extractBtn.addEventListener('click', async () => {\n    if (!heap.data.length) {\n      log('Extract: heap is empty.');\n      return;\n    }\n    setBusy(true);\n    const root = await heap.popAnimated();\n    log(`Extracted root: ${root}`);\n    setBusy(false);\n  });\n\n  peekBtn.addEventListener('click', () => {\n    const root = heap.peek();\n    log(`Peek: ${root === null ? 'heap is empty' : root}`);\n  });\n\n  clearBtn.addEventListener('click', () => {\n    heap.clear();\n    log('Cleared heap.');\n  });\n\n  buildBtn.addEventListener('click', () => {\n    const text = listInput.value.trim();\n    if (!text.length) {\n      log('Enter a comma-separated list to build.');\n      return;\n    }\n    const parts = text.split(',').map(s => Number(s.trim())).filter(v => !Number.isNaN(v));\n    if (!parts.length) {\n      log('List contained no valid numbers.');\n      return;\n    }\n    heap.build(parts);\n    log(`Built heap from list (${parts.length} items).`);\n  });\n\n  randBuildBtn.addEventListener('click', () => {\n    const n = randInt(8, 18);\n    const arr = Array.from({ length: n }, () => randInt(0, 99));\n    heap.build(arr);\n    log(`Built random heap (${n} items).`);\n  });\n\n  heapSortBtn.addEventListener('click', () => {\n    const copy = new BinaryHeap(heap.isMin);\n    copy.build(heap.toArray());\n    const sorted = [];\n    while (copy.data.length) sorted.push(copy.pop());\n    const direction = heap.isMin ? 'ascending' : 'descending';\n    log(`Heap sort (${direction}): [${sorted.join(', ')}]`);\n    alert(`Heap sort (${direction}) result:\\n[${sorted.join(', ')}]`);\n  });\n\n  // Resize handling\n  const onResize = () => draw();\n  window.addEventListener('resize', onResize);\n\n  // Initial\n  draw();\n  speedVal.textContent = speedInput.value;\n  log('Ready. Use controls to interact with the heap.');\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Heap (Min/Max)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "91040a20-a369-11f0-92c6-2b14e8ef2cdd",
    "timestamp": "2025-10-07T10:37:04.834Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Graph (Directed/Undirected)",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Graph Demo: Directed vs Undirected</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --accent: #60a5fa;\n    --accent2: #34d399;\n    --text: #e5e7eb;\n    --muted: #9ca3af;\n    --danger: #ef4444;\n    --node: #f59e0b;\n    --edge: #93c5fd;\n    --selected: #f472b6;\n    --visited: #10b981;\n  }\n  * { box-sizing: border-box; }\n  html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Apple Color Emoji\", \"Segoe UI Emoji\"; }\n  a { color: var(--accent); }\n  .app {\n    display: grid;\n    grid-template-columns: 340px 1fr;\n    grid-template-rows: auto 1fr;\n    gap: 12px;\n    height: 100%;\n    padding: 12px;\n  }\n  header {\n    grid-column: 1 / -1;\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    background: var(--panel);\n    border-radius: 12px;\n    padding: 10px 12px;\n    box-shadow: 0 6px 12px rgba(0,0,0,.25);\n  }\n  header h1 {\n    margin: 0;\n    font-size: 18px;\n    letter-spacing: .2px;\n  }\n  header .subtitle {\n    font-size: 13px;\n    color: var(--muted);\n  }\n  .controls {\n    display: grid;\n    grid-template-columns: 1fr;\n    gap: 12px;\n    background: var(--panel);\n    border-radius: 12px;\n    padding: 12px;\n    box-shadow: 0 6px 12px rgba(0,0,0,.25);\n    overflow: auto;\n  }\n  .section {\n    border: 1px solid #1f2937;\n    border-radius: 10px;\n    padding: 10px;\n  }\n  .section h3 {\n    margin: 0 0 8px 0;\n    font-size: 14px;\n    color: var(--muted);\n    letter-spacing: .2px;\n  }\n  .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }\n  .btn {\n    appearance: none;\n    background: #1f2937;\n    color: var(--text);\n    border: 1px solid #374151;\n    border-radius: 8px;\n    padding: 8px 10px;\n    font-size: 13px;\n    cursor: pointer;\n    transition: .15s ease all;\n  }\n  .btn:hover { border-color: var(--accent); color: #fff; }\n  .btn.primary { background: #2563eb; border-color: #1d4ed8; }\n  .btn.primary:hover { background: #1d4ed8; }\n  .btn.danger { background: #7f1d1d; border-color: #991b1b; }\n  .btn.danger:hover { background: #991b1b; }\n  .pill {\n    display: inline-flex; align-items: center; gap: 8px;\n    background: #0b1220; border: 1px solid #253055; border-radius: 999px;\n    padding: 6px 10px; font-size: 12px; color: var(--muted);\n  }\n  label { font-size: 13px; color: var(--text); }\n  input[type=\"radio\"] { accent-color: #60a5fa; }\n  select, input[type=\"number\"] {\n    background: #0b1220; color: var(--text); border: 1px solid #334155;\n    border-radius: 6px; padding: 6px 8px; font-size: 13px; min-width: 140px;\n  }\n  .canvas-wrap {\n    position: relative;\n    background: #0b1220;\n    border: 1px solid #1f2937;\n    border-radius: 12px;\n    box-shadow: 0 6px 12px rgba(0,0,0,.25);\n    overflow: hidden;\n  }\n  canvas { display: block; width: 100%; height: 100%; }\n  .hint {\n    font-size: 12px;\n    color: var(--muted);\n    line-height: 1.45;\n  }\n  .stats {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 6px;\n  }\n  .stat {\n    background: #0b1220;\n    border: 1px solid #253055;\n    border-radius: 8px;\n    padding: 8px;\n    font-size: 12px;\n  }\n  .stat .label { color: var(--muted); }\n  .adj {\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n    font-size: 12px; white-space: pre-wrap;\n    background: #0b1220; border: 1px solid #253055; border-radius: 8px; padding: 8px;\n    max-height: 240px; overflow: auto;\n  }\n  .legend { display: flex; gap: 8px; flex-wrap: wrap; font-size: 12px; }\n  .legend .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; }\n  .legend .ln { width: 20px; height: 2px; display: inline-block; background: var(--edge); }\n  .kbd {\n    font-family: ui-monospace, Menlo, Monaco, Consolas, monospace;\n    background: #0b1220; border: 1px solid #334155; padding: 2px 6px; border-radius: 6px;\n    font-size: 12px; color: var(--muted);\n  }\n</style>\n</head>\n<body>\n<div class=\"app\">\n  <header>\n    <div>\n      <h1>Graph (Directed / Undirected)</h1>\n      <div class=\"subtitle\">Interactive visualization with edge creation, dragging, and BFS/DFS traversal</div>\n    </div>\n    <div class=\"pill\" style=\"margin-left:auto\" id=\"modePill\">\n      Mode: <strong id=\"modeLabel\">Directed</strong>\n    </div>\n  </header>\n\n  <div class=\"controls\">\n    <div class=\"section\">\n      <h3>Graph Type</h3>\n      <div class=\"row\">\n        <label><input type=\"radio\" name=\"mode\" value=\"directed\" checked> Directed (edges have arrows)</label>\n        <label><input type=\"radio\" name=\"mode\" value=\"undirected\"> Undirected (edges are two-way)</label>\n      </div>\n      <div class=\"legend\" style=\"margin-top:8px;\">\n        <span><span class=\"dot\" style=\"background: var(--node)\"></span> Node</span>\n        <span><span class=\"ln\"></span> Edge</span>\n        <span><span class=\"dot\" style=\"background: var(--selected)\"></span> Selected</span>\n        <span><span class=\"dot\" style=\"background: var(--visited)\"></span> Visited (traversal)</span>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <h3>Actions</h3>\n      <div class=\"row\">\n        <button class=\"btn primary\" id=\"sampleBtn\">Load Sample</button>\n        <button class=\"btn\" id=\"undoBtn\" title=\"Undo last add/remove\">Undo</button>\n        <button class=\"btn danger\" id=\"clearBtn\">Clear</button>\n      </div>\n      <div class=\"hint\" style=\"margin-top:8px;\">\n        - Click empty space to add a node. Drag nodes to reposition.<br>\n        - Click a node, then another node to add an edge (uses current mode).<br>\n        - Alt+Click a node to delete it and its incident edges.<br>\n        - Press Esc to clear selection. Shift+Drag to pan.\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <h3>Traversal (BFS / DFS)</h3>\n      <div class=\"row\">\n        <label for=\"startSel\">Start node</label>\n        <select id=\"startSel\"></select>\n      </div>\n      <div class=\"row\" style=\"margin-top:8px;\">\n        <label><input type=\"radio\" name=\"traversal\" value=\"bfs\" checked> BFS</label>\n        <label><input type=\"radio\" name=\"traversal\" value=\"dfs\"> DFS</label>\n      </div>\n      <div class=\"row\" style=\"margin-top:8px;\">\n        <button class=\"btn\" id=\"runBtn\">Run</button>\n        <button class=\"btn\" id=\"stopBtn\">Stop</button>\n        <button class=\"btn\" id=\"resetHighlightBtn\">Reset Highlight</button>\n      </div>\n      <div class=\"adj\" id=\"orderBox\" style=\"margin-top:8px;\">Order: [ ]</div>\n    </div>\n\n    <div class=\"section\">\n      <h3>Adjacency & Degrees</h3>\n      <div class=\"stats\">\n        <div class=\"stat\"><div class=\"label\">Nodes</div><div id=\"nodeCount\">0</div></div>\n        <div class=\"stat\"><div class=\"label\">Edges</div><div id=\"edgeCount\">0</div></div>\n      </div>\n      <div class=\"adj\" id=\"adjBox\" style=\"margin-top:8px;\"></div>\n    </div>\n  </div>\n\n  <div class=\"canvas-wrap\" id=\"canvasWrap\">\n    <canvas id=\"canvas\" width=\"1200\" height=\"800\" aria-label=\"Graph canvas\"></canvas>\n  </div>\n</div>\n\n<script>\n(function(){\n  const canvas = document.getElementById('canvas');\n  const wrap = document.getElementById('canvasWrap');\n  const ctx = canvas.getContext('2d');\n\n  const R = 20; // node radius\n  const ARROW_LEN = 12;\n  const ARROW_W = 10;\n\n  const state = {\n    nodes: [],             // {id, x, y}\n    edges: [],             // {u, v} directional pairs\n    nextId: 1,\n    selected: null,\n    hovering: null,\n    dragging: null,\n    dragOff: {x:0, y:0},\n    pan: {x:0, y:0},\n    isPanning: false,\n    lastMouse: {x:0, y:0},\n    history: [],           // for undo\n    directedMode: true,\n    anim: null,\n    visited: new Set(),\n    order: [],\n  };\n\n  // DPI scale for crisp canvas\n  function resizeCanvas() {\n    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));\n    const rect = wrap.getBoundingClientRect();\n    canvas.width = rect.width * dpr;\n    canvas.height = rect.height * dpr;\n    canvas.style.width = rect.width + 'px';\n    canvas.style.height = rect.height + 'px';\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    draw();\n  }\n  window.addEventListener('resize', resizeCanvas);\n\n  // UI elements\n  const modeRadios = [...document.querySelectorAll('input[name=\"mode\"]')];\n  const modeLabel = document.getElementById('modeLabel');\n  const nodeCountEl = document.getElementById('nodeCount');\n  const edgeCountEl = document.getElementById('edgeCount');\n  const adjBox = document.getElementById('adjBox');\n  const startSel = document.getElementById('startSel');\n  const orderBox = document.getElementById('orderBox');\n  const sampleBtn = document.getElementById('sampleBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const undoBtn = document.getElementById('undoBtn');\n  const runBtn = document.getElementById('runBtn');\n  const stopBtn = document.getElementById('stopBtn');\n  const resetHighlightBtn = document.getElementById('resetHighlightBtn');\n\n  modeRadios.forEach(r => r.addEventListener('change', () => {\n    const val = document.querySelector('input[name=\"mode\"]:checked').value;\n    state.directedMode = (val === 'directed');\n    modeLabel.textContent = state.directedMode ? 'Directed' : 'Undirected';\n    draw();\n    refreshInfo();\n  }));\n\n  sampleBtn.addEventListener('click', loadSample);\n  clearBtn.addEventListener('click', () => {\n    pushHistory();\n    state.nodes = [];\n    state.edges = [];\n    state.nextId = 1;\n    state.selected = null;\n    state.visited.clear();\n    state.order.length = 0;\n    stopAnim();\n    draw();\n    refreshInfo();\n  });\n\n  undoBtn.addEventListener('click', undo);\n\n  runBtn.addEventListener('click', runTraversal);\n  stopBtn.addEventListener('click', stopAnim);\n  resetHighlightBtn.addEventListener('click', () => {\n    state.visited.clear();\n    state.order.length = 0;\n    stopAnim();\n    draw();\n    refreshInfo();\n  });\n\n  document.addEventListener('keydown', (e) => {\n    if (e.key === 'Escape') {\n      state.selected = null;\n      draw();\n    }\n  });\n\n  // Canvas interaction\n  canvas.addEventListener('mousemove', onMouseMove);\n  canvas.addEventListener('mousedown', onMouseDown);\n  canvas.addEventListener('mouseup', onMouseUp);\n  canvas.addEventListener('mouseleave', onMouseLeave);\n  canvas.addEventListener('click', onClick);\n\n  function toLocal(x, y) {\n    return { x: x - state.pan.x, y: y - state.pan.y };\n  }\n\n  function onMouseMove(e) {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    const {x, y} = toLocal(mx, my);\n    state.lastMouse = { x: mx, y: my };\n\n    if (state.isPanning) {\n      state.pan.x += mx - state.pan.lastX;\n      state.pan.y += my - state.pan.lastY;\n      state.pan.lastX = mx;\n      state.pan.lastY = my;\n      draw();\n      return;\n    }\n\n    if (state.dragging != null) {\n      const n = getNode(state.dragging);\n      if (!n) return;\n      n.x = x - state.dragOff.x;\n      n.y = y - state.dragOff.y;\n      draw();\n      return;\n    }\n\n    state.hovering = pickNode(x, y);\n    draw();\n  }\n\n  function onMouseDown(e) {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    const local = toLocal(mx, my);\n\n    if (e.shiftKey) {\n      state.isPanning = true;\n      state.pan.lastX = mx;\n      state.pan.lastY = my;\n      return;\n    }\n\n    const id = pickNode(local.x, local.y);\n    if (id != null) {\n      const n = getNode(id);\n      state.dragging = id;\n      state.dragOff.x = local.x - n.x;\n      state.dragOff.y = local.y - n.y;\n    }\n  }\n\n  function onMouseUp() {\n    state.isPanning = false;\n    state.dragging = null;\n  }\n\n  function onMouseLeave() {\n    state.isPanning = false;\n    state.dragging = null;\n    state.hovering = null;\n    draw();\n  }\n\n  function onClick(e) {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    const local = toLocal(mx, my);\n\n    const clickedId = pickNode(local.x, local.y);\n\n    if (e.altKey) {\n      if (clickedId != null) {\n        pushHistory();\n        removeNode(clickedId);\n        state.selected = null;\n        draw();\n        refreshInfo();\n      }\n      return;\n    }\n\n    if (clickedId == null) {\n      // Add new node\n      pushHistory();\n      addNode(local.x, local.y);\n      draw();\n      refreshInfo();\n    } else {\n      // Edge creation: select then connect\n      if (state.selected == null) {\n        state.selected = clickedId;\n      } else if (state.selected === clickedId) {\n        state.selected = null;\n      } else {\n        pushHistory();\n        if (state.directedMode) {\n          addEdge(state.selected, clickedId);\n        } else {\n          addEdgeUndirected(state.selected, clickedId);\n        }\n        state.selected = null;\n        draw();\n        refreshInfo();\n      }\n    }\n  }\n\n  // Core operations\n  function addNode(x, y) {\n    const id = state.nextId++;\n    state.nodes.push({ id, x, y });\n    updateStartSelect();\n  }\n\n  function removeNode(id) {\n    state.nodes = state.nodes.filter(n => n.id !== id);\n    state.edges = state.edges.filter(e => e.u !== id && e.v !== id);\n    state.visited.delete(id);\n    state.order = state.order.filter(x => x !== id);\n    updateStartSelect();\n  }\n\n  function addEdge(u, v) {\n    if (u === v) return;\n    if (state.edges.some(e => e.u === u && e.v === v)) return;\n    state.edges.push({ u, v });\n  }\n\n  function addEdgeUndirected(a, b) {\n    if (a === b) return;\n    // Prevent duplicates in either orientation\n    if (state.edges.some(e => (e.u === a && e.v === b) || (e.u === b && e.v === a))) return;\n    // We still store a single oriented pair; rendering/adjacency will treat it undirected\n    state.edges.push({ u: a, v: b });\n  }\n\n  function getNode(id) {\n    return state.nodes.find(n => n.id === id);\n  }\n\n  function pickNode(x, y) {\n    // Return node id within radius\n    for (let i = state.nodes.length - 1; i >= 0; i--) {\n      const n = state.nodes[i];\n      const dx = x - n.x, dy = y - n.y;\n      if (dx*dx + dy*dy <= R*R) return n.id;\n    }\n    return null;\n  }\n\n  // Drawing\n  function draw() {\n    const rect = canvas.getBoundingClientRect();\n    ctx.clearRect(0, 0, rect.width, rect.height);\n    ctx.save();\n    ctx.translate(state.pan.x, state.pan.y);\n\n    // Edges\n    if (state.directedMode) {\n      for (const e of state.edges) {\n        const a = getNode(e.u), b = getNode(e.v);\n        if (!a || !b) continue;\n        drawArrowEdge(a, b, e);\n      }\n    } else {\n      // Dedup by unordered pair\n      const drawn = new Set();\n      for (const e of state.edges) {\n        const key = e.u < e.v ? `${e.u}|${e.v}` : `${e.v}|${e.u}`;\n        if (drawn.has(key)) continue;\n        drawn.add(key);\n        const a = getNode(e.u), b = getNode(e.v);\n        if (!a || !b) continue;\n        drawLineEdge(a, b);\n      }\n    }\n\n    // Nodes\n    for (const n of state.nodes) {\n      drawNode(n);\n    }\n\n    // Hover highlight overlay\n    if (state.hovering != null) {\n      const h = getNode(state.hovering);\n      if (h) {\n        ctx.beginPath();\n        ctx.arc(h.x, h.y, R + 4, 0, Math.PI*2);\n        ctx.strokeStyle = '#ffffff22';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n      }\n    }\n\n    ctx.restore();\n  }\n\n  function drawNode(n) {\n    const isSelected = state.selected === n.id;\n    const isVisited = state.visited.has(n.id);\n\n    ctx.beginPath();\n    ctx.arc(n.x, n.y, R, 0, Math.PI*2);\n    const grad = ctx.createRadialGradient(n.x, n.y, 3, n.x, n.y, R);\n    const base = isVisited ? '#10b981' : '#f59e0b';\n    grad.addColorStop(0, shade(base, 1.0));\n    grad.addColorStop(1, shade(base, 0.75));\n    ctx.fillStyle = grad;\n    ctx.fill();\n\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = isSelected ? '#f472b6' : '#334155';\n    ctx.stroke();\n\n    ctx.fillStyle = '#0b1220';\n    ctx.font = '12px ui-monospace';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(n.id), n.x, n.y);\n\n    // For directed mode show in/out degree; undirected show degree\n    const deg = computeDegrees();\n    const label = state.directedMode\n      ? `d+:${deg.out[n.id]||0} d-:${deg.in[n.id]||0}`\n      : `deg:${deg.undirected[n.id]||0}`;\n    ctx.fillStyle = '#cbd5e1';\n    ctx.font = '10px system-ui, sans-serif';\n    ctx.fillText(label, n.x, n.y + R + 10);\n  }\n\n  function drawArrowEdge(a, b, e) {\n    const dx = b.x - a.x, dy = b.y - a.y;\n    const dist = Math.hypot(dx, dy);\n    if (dist < 1) return;\n    const ux = dx / dist, uy = dy / dist;\n\n    const sx = a.x + ux * R;\n    const sy = a.y + uy * R;\n    const tx = b.x - ux * R;\n    const ty = b.y - uy * R;\n\n    // main line\n    ctx.beginPath();\n    ctx.moveTo(sx, sy);\n    ctx.lineTo(tx, ty);\n    ctx.strokeStyle = '#93c5fd';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // arrowhead\n    const hx = tx, hy = ty;\n    const backX = hx - ux * ARROW_LEN;\n    const backY = hy - uy * ARROW_LEN;\n\n    // Perp vector\n    const px = -uy, py = ux;\n    const leftX = backX + px * (ARROW_W/2);\n    const leftY = backY + py * (ARROW_W/2);\n    const rightX = backX - px * (ARROW_W/2);\n    const rightY = backY - py * (ARROW_W/2);\n\n    ctx.beginPath();\n    ctx.moveTo(hx, hy);\n    ctx.lineTo(leftX, leftY);\n    ctx.lineTo(rightX, rightY);\n    ctx.closePath();\n    ctx.fillStyle = '#93c5fd';\n    ctx.fill();\n  }\n\n  function drawLineEdge(a, b) {\n    const dx = b.x - a.x, dy = b.y - a.y;\n    const dist = Math.hypot(dx, dy);\n    if (dist < 1) return;\n    const ux = dx / dist, uy = dy / dist;\n\n    const sx = a.x + ux * R;\n    const sy = a.y + uy * R;\n    const tx = b.x - ux * R;\n    const ty = b.y - uy * R;\n\n    ctx.beginPath();\n    ctx.moveTo(sx, sy);\n    ctx.lineTo(tx, ty);\n    ctx.strokeStyle = '#93c5fd';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n  }\n\n  function shade(hex, amt) {\n    // simple shade: blend with white by amt\n    const c = hex.replace('#','');\n    const r = parseInt(c.substring(0,2),16);\n    const g = parseInt(c.substring(2,4),16);\n    const b = parseInt(c.substring(4,6),16);\n    const nr = Math.round(r*amt + 255*(1-amt));\n    const ng = Math.round(g*amt + 255*(1-amt));\n    const nb = Math.round(b*amt + 255*(1-amt));\n    return `rgb(${nr},${ng},${nb})`;\n  }\n\n  // Info and adjacency\n  function refreshInfo() {\n    nodeCountEl.textContent = String(state.nodes.length);\n    if (state.directedMode) {\n      edgeCountEl.textContent = String(state.edges.length);\n    } else {\n      // dedup unordered\n      const s = new Set();\n      for (const e of state.edges) {\n        s.add(e.u < e.v ? `${e.u}|${e.v}` : `${e.v}|${e.u}`);\n      }\n      edgeCountEl.textContent = String(s.size);\n    }\n\n    const adj = computeAdjacency();\n    const deg = computeDegrees();\n    let text = '';\n    for (const n of state.nodes) {\n      const neighbors = adj[n.id] || [];\n      if (state.directedMode) {\n        const indeg = deg.in[n.id] || 0;\n        const outdeg = deg.out[n.id] || 0;\n        text += `${n.id} -> { ${neighbors.join(', ')} }    d-:${indeg} d+:${outdeg}\\n`;\n      } else {\n        const d = deg.undirected[n.id] || 0;\n        text += `${n.id} : { ${neighbors.join(', ')} }    deg:${d}\\n`;\n      }\n    }\n    adjBox.textContent = text.trim();\n\n    orderBox.textContent = `Order: [ ${state.order.join(', ')} ]`;\n    updateStartSelect();\n  }\n\n  function computeAdjacency() {\n    const adj = {};\n    for (const n of state.nodes) adj[n.id] = [];\n    if (state.directedMode) {\n      for (const e of state.edges) {\n        if (!adj[e.u]) adj[e.u] = [];\n        adj[e.u].push(e.v);\n      }\n    } else {\n      // undirected: neighbors both ways, dedup\n      const seen = new Set();\n      for (const e of state.edges) {\n        const a = e.u, b = e.v;\n        const key = a < b ? `${a}|${b}` : `${b}|${a}`;\n        if (seen.has(key)) continue;\n        seen.add(key);\n        adj[a].push(b);\n        adj[b].push(a);\n      }\n      // sort neighbors for consistency\n      for (const k in adj) adj[k].sort((x,y)=>x-y);\n    }\n    return adj;\n  }\n\n  function computeDegrees() {\n    const inDeg = {}, outDeg = {}, undeg = {};\n    for (const n of state.nodes) { inDeg[n.id]=0; outDeg[n.id]=0; undeg[n.id]=0; }\n    if (state.directedMode) {\n      for (const e of state.edges) {\n        outDeg[e.u] = (outDeg[e.u]||0)+1;\n        inDeg[e.v] = (inDeg[e.v]||0)+1;\n      }\n    } else {\n      const s = new Set();\n      for (const e of state.edges) {\n        const key = e.u < e.v ? `${e.u}|${e.v}` : `${e.v}|${e.u}`;\n        if (s.has(key)) continue;\n        s.add(key);\n        undeg[e.u] = (undeg[e.u]||0)+1;\n        undeg[e.v] = (undeg[e.v]||0)+1;\n      }\n    }\n    return { in: inDeg, out: outDeg, undirected: undeg };\n  }\n\n  // Traversal\n  function runTraversal() {\n    if (state.anim) stopAnim();\n\n    const start = Number(startSel.value);\n    if (!start || !getNode(start)) return;\n\n    const kind = document.querySelector('input[name=\"traversal\"]:checked').value;\n    const adj = computeAdjacency();\n\n    state.visited.clear();\n    state.order = [];\n    draw();\n    refreshInfo();\n\n    const delay = 500;\n\n    if (kind === 'bfs') {\n      const q = [start];\n      const seen = new Set([start]);\n      state.anim = setInterval(() => {\n        if (q.length === 0) { stopAnim(); return; }\n        const u = q.shift();\n        state.visited.add(u);\n        state.order.push(u);\n        for (const v of adj[u] || []) {\n          if (!seen.has(v)) { seen.add(v); q.push(v); }\n        }\n        draw();\n        refreshInfo();\n      }, delay);\n    } else {\n      // DFS iterative\n      const stack = [start];\n      const seen = new Set();\n      state.anim = setInterval(() => {\n        if (stack.length === 0) { stopAnim(); return; }\n        const u = stack.pop();\n        if (seen.has(u)) return;\n        seen.add(u);\n        state.visited.add(u);\n        state.order.push(u);\n        const neigh = (adj[u]||[]).slice().reverse(); // mimic recursive push order\n        for (const v of neigh) {\n          if (!seen.has(v)) stack.push(v);\n        }\n        draw();\n        refreshInfo();\n      }, delay);\n    }\n  }\n\n  function stopAnim() {\n    if (state.anim) {\n      clearInterval(state.anim);\n      state.anim = null;\n    }\n  }\n\n  // Start select\n  function updateStartSelect() {\n    const prev = Number(startSel.value) || null;\n    startSel.innerHTML = '';\n    for (const n of state.nodes) {\n      const opt = document.createElement('option');\n      opt.value = String(n.id);\n      opt.textContent = `Node ${n.id}`;\n      startSel.appendChild(opt);\n    }\n    if (prev && getNode(prev)) {\n      startSel.value = String(prev);\n    }\n  }\n\n  // History for undo\n  function pushHistory() {\n    const snapshot = {\n      nodes: state.nodes.map(n => ({...n})),\n      edges: state.edges.map(e => ({...e})),\n      nextId: state.nextId,\n      selected: state.selected,\n      pan: {...state.pan},\n      directedMode: state.directedMode,\n      visited: Array.from(state.visited),\n      order: state.order.slice(),\n    };\n    state.history.push(snapshot);\n    if (state.history.length > 50) state.history.shift();\n  }\n\n  function undo() {\n    const snap = state.history.pop();\n    if (!snap) return;\n    stopAnim();\n    state.nodes = snap.nodes;\n    state.edges = snap.edges;\n    state.nextId = snap.nextId;\n    state.selected = snap.selected;\n    state.pan = snap.pan;\n    state.directedMode = snap.directedMode;\n    state.visited = new Set(snap.visited);\n    state.order = snap.order;\n    document.querySelector(`input[name=\"mode\"][value=\"${state.directedMode ? 'directed':'undirected'}\"]`).checked = true;\n    modeLabel.textContent = state.directedMode ? 'Directed' : 'Undirected';\n    draw();\n    refreshInfo();\n  }\n\n  // Sample graph\n  function loadSample() {\n    pushHistory();\n    state.nodes = [];\n    state.edges = [];\n    state.nextId = 1;\n    state.selected = null;\n    state.pan = {x:0, y:0};\n\n    const cx = wrap.clientWidth / 2;\n    const cy = wrap.clientHeight / 2;\n    const r = Math.min(cx, cy) * 0.6;\n    const count = 8;\n    for (let i=0;i<count;i++){\n      const angle = (i / count) * Math.PI*2;\n      const x = cx + Math.cos(angle) * r;\n      const y = cy + Math.sin(angle) * r;\n      addNode(x, y);\n    }\n    // Directed sample edges (some cycle, some branch)\n    addEdge(1,2); addEdge(2,3); addEdge(3,4); addEdge(4,2); // cycle 2-3-4\n    addEdge(1,5); addEdge(5,6); addEdge(6,7);\n    addEdge(7,8);\n    addEdge(3,7);\n    addEdge(8,4);\n\n    // Reset highlights\n    state.visited.clear();\n    state.order = [];\n    draw();\n    refreshInfo();\n  }\n\n  // Initial setup\n  resizeCanvas();\n  loadSample();\n\n  // Utility: ensure wrap takes remaining height\n  function sizeWrap() {\n    const appRect = document.querySelector('.app').getBoundingClientRect();\n    const headerRect = document.querySelector('header').getBoundingClientRect();\n    const controlsRect = document.querySelector('.controls').getBoundingClientRect();\n    const totalH = window.innerHeight;\n    const avail = totalH - headerRect.height - 24; // padding/gap\n    wrap.style.height = Math.max(300, avail) + 'px';\n    resizeCanvas();\n  }\n  sizeWrap();\n  window.addEventListener('resize', sizeWrap);\n\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Graph (Directed/Undirected)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "bb04e880-a369-11f0-9b3a-49ca6d2ff1f2",
    "timestamp": "2025-10-07T10:38:15.304Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Weighted Graph",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Weighted Graph Visualizer</title>\n  <style>\n    :root {\n      --bg: #0f172a;\n      --panel: #111827;\n      --text: #e5e7eb;\n      --muted: #9ca3af;\n      --accent: #60a5fa;\n      --accent2: #34d399;\n      --warn: #fbbf24;\n      --error: #f87171;\n      --edge: #93c5fd;\n      --node: #f472b6;\n    }\n    html, body {\n      height: 100%;\n      margin: 0;\n      background: var(--bg);\n      color: var(--text);\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\",\"Segoe UI Emoji\";\n    }\n    h1 {\n      margin: 0;\n      padding: 16px 20px 4px;\n      font-size: 22px;\n      font-weight: 700;\n      letter-spacing: 0.3px;\n    }\n    #desc {\n      padding: 0 20px 12px;\n      color: var(--muted);\n      font-size: 14px;\n    }\n    #layout {\n      display: grid;\n      grid-template-columns: 320px 1fr 340px;\n      gap: 14px;\n      padding: 14px 20px 20px;\n      height: calc(100% - 80px);\n      box-sizing: border-box;\n    }\n    #left, #right {\n      background: var(--panel);\n      border-radius: 10px;\n      padding: 12px;\n      box-shadow: 0 1px 0 rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.03);\n    }\n    #center {\n      background: #0b1220;\n      border-radius: 10px;\n      position: relative;\n      overflow: hidden;\n      box-shadow: 0 1px 0 rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.03);\n    }\n    #controls h2, #info h2 {\n      margin: 0 0 10px;\n      font-size: 16px;\n      color: var(--muted);\n      font-weight: 600;\n    }\n    .row {\n      display: flex;\n      gap: 8px;\n      flex-wrap: wrap;\n      margin-bottom: 8px;\n    }\n    button, .btn {\n      appearance: none;\n      border: none;\n      border-radius: 8px;\n      padding: 8px 10px;\n      background: #1f2937;\n      color: var(--text);\n      font-size: 13px;\n      cursor: pointer;\n      transition: transform 0.05s ease, background 0.15s ease, box-shadow 0.15s ease;\n      box-shadow: 0 0 0 1px rgba(255,255,255,0.06) inset;\n    }\n    button:hover { background: #243041; }\n    button:active { transform: translateY(1px); }\n    button.primary { background: #2563eb; }\n    button.primary:hover { background: #1d4ed8; }\n    button.success { background: #10b981; }\n    button.success:hover { background: #059669; }\n    button.warn { background: #f59e0b; }\n    button.warn:hover { background: #d97706; }\n    button.destructive { background: #ef4444; }\n    button.destructive:hover { background: #dc2626; }\n    button.toggle.active {\n      background: #334155;\n      box-shadow: 0 0 0 2px var(--accent) inset;\n    }\n    .small {\n      font-size: 12px;\n      padding: 6px 9px;\n    }\n    #status {\n      margin-top: 8px;\n      background: #0d1726;\n      border-radius: 8px;\n      padding: 8px;\n      color: var(--muted);\n      font-size: 12px;\n      min-height: 18px;\n      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);\n    }\n    #legend {\n      margin-top: 8px;\n      font-size: 12px;\n      color: var(--muted);\n    }\n    #legend .swatch {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      vertical-align: middle;\n      border-radius: 2px;\n      margin-right: 4px;\n    }\n    #graph {\n      width: 100%;\n      height: 100%;\n      background: radial-gradient(1000px 400px at 30% 20%, rgba(96,165,250,0.06), transparent 60%),\n                  radial-gradient(800px 300px at 70% 60%, rgba(52,211,153,0.07), transparent 60%),\n                  #0b1220;\n    }\n    .edge {\n      stroke: var(--edge);\n      stroke-width: 2;\n      opacity: 0.8;\n      transition: stroke 0.2s ease, opacity 0.2s ease;\n    }\n    .edge.highlight {\n      stroke: var(--accent2);\n      stroke-width: 4;\n      opacity: 1.0;\n      filter: drop-shadow(0 0 3px rgba(52,211,153,0.6));\n    }\n    .edgeLabel {\n      fill: #bfdbfe;\n      font-size: 12px;\n      user-select: none;\n      pointer-events: none;\n      paint-order: stroke;\n      stroke: rgba(11,18,32,0.7);\n      stroke-width: 3px;\n    }\n    .node {\n      cursor: grab;\n    }\n    .node circle {\n      fill: var(--node);\n      stroke: #fff;\n      stroke-opacity: 0.15;\n      stroke-width: 2;\n      filter: drop-shadow(0 2px 6px rgba(244,114,182,0.35));\n      transition: fill 0.2s ease, transform 0.05s ease, stroke 0.2s ease;\n    }\n    .node:hover circle {\n      fill: #fb7185;\n    }\n    .node.dragging circle {\n      cursor: grabbing;\n      transform: scale(1.04);\n    }\n    .nodeLabel {\n      fill: #fdf2f8;\n      font-weight: 700;\n      font-size: 13px;\n      text-anchor: middle;\n      dominant-baseline: middle;\n      pointer-events: none;\n      paint-order: stroke;\n      stroke: rgba(11,18,32,0.7);\n      stroke-width: 3px;\n    }\n    .node.selected circle {\n      stroke: var(--accent);\n      stroke-width: 3;\n    }\n    .node.start circle {\n      stroke: var(--accent2);\n      stroke-width: 3;\n    }\n    .node.end circle {\n      stroke: var(--warn);\n      stroke-width: 3;\n    }\n    #infoContent {\n      height: calc(100% - 20px);\n      overflow: auto;\n      font-size: 13px;\n      color: var(--muted);\n    }\n    #distances {\n      margin-top: 8px;\n      padding: 8px;\n      background: #0d1726;\n      border-radius: 8px;\n      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);\n    }\n    .distRow {\n      display: flex;\n      justify-content: space-between;\n      padding: 4px 0;\n      color: #cbd5e1;\n    }\n    .sep {\n      height: 1px;\n      background: rgba(255,255,255,0.08);\n      margin: 8px 0;\n    }\n    .tip {\n      font-size: 12px;\n      color: #9ca3af;\n      margin-top: 6px;\n    }\n  </style>\n</head>\n<body>\n  <h1>Weighted Graph Visualizer</h1>\n  <div id=\"desc\">\n    - Add nodes and weighted edges (costs) and drag to arrange. \n    - Select a start and end node, then run Dijkstra to find the minimum-cost path. \n    - Edge weights must be non-negative for Dijkstra. \n    - Use the sample graph for a quick demonstration.\n  </div>\n  <div id=\"layout\">\n    <div id=\"left\">\n      <div id=\"controls\">\n        <h2>Build</h2>\n        <div class=\"row\">\n          <button id=\"modeAddNode\" class=\"toggle\">Add Node</button>\n          <button id=\"modeAddEdge\" class=\"toggle\">Add Edge</button>\n          <button id=\"modeSelectPath\" class=\"toggle\">Select Start/End</button>\n          <button id=\"clearSelections\" class=\"small\">Clear Selections</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"runDijkstra\" class=\"primary\">Run Dijkstra</button>\n          <button id=\"clearHighlights\" class=\"small\">Clear Highlights</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"sampleGraph\" class=\"success\">Load Sample Graph</button>\n          <button id=\"randomGraph\" class=\"small\">Random Graph</button>\n          <button id=\"resetGraph\" class=\"destructive small\">Reset</button>\n        </div>\n\n        <div id=\"legend\">\n          <div><span class=\"swatch\" style=\"background: var(--accent2)\"></span>Shortest path edges</div>\n          <div><span class=\"swatch\" style=\"background: var(--accent)\"></span>Start node</div>\n          <div><span class=\"swatch\" style=\"background: var(--warn)\"></span>End node</div>\n          <div class=\"tip\">Tip: In \"Add Node\" mode, click empty space in the canvas. In \"Add Edge\" mode, click two nodes.</div>\n        </div>\n\n        <div id=\"status\">Ready.</div>\n      </div>\n    </div>\n\n    <div id=\"center\">\n      <svg id=\"graph\" viewBox=\"0 0 1000 700\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n    </div>\n\n    <div id=\"right\">\n      <div id=\"info\">\n        <h2>Info</h2>\n        <div id=\"infoContent\">\n          Weighted Graph\n          - Nodes represent points; edges represent connections with costs (weights).\n          - Dijkstra's algorithm computes the minimum total weight from a start node to all others (non-negative edges).\n\n          Current Selection\n          - Start: None\n          - End: None\n\n          Distances (from Start)\n          <div id=\"distances\"></div>\n\n          <div class=\"sep\"></div>\n          Algorithm Notes\n          - Dijkstra uses a greedy approach.\n          - It maintains tentative distances and explores the closest unreached node.\n          - Negative edge weights are not supported.\n\n          <div class=\"sep\"></div>\n          Controls Summary\n          - Add Node: click canvas to place a node.\n          - Add Edge: click two nodes; enter a non-negative weight.\n          - Select Start/End: click first for start, second for end.\n          - Run Dijkstra: compute and highlight the shortest path.\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    (function() {\n      const svg = document.getElementById('graph');\n      const status = document.getElementById('status');\n      const distancesPanel = document.getElementById('distances');\n\n      const modeButtons = {\n        addNode: document.getElementById('modeAddNode'),\n        addEdge: document.getElementById('modeAddEdge'),\n        selectPath: document.getElementById('modeSelectPath')\n      };\n\n      const controls = {\n        runDijkstra: document.getElementById('runDijkstra'),\n        clearHighlights: document.getElementById('clearHighlights'),\n        clearSelections: document.getElementById('clearSelections'),\n        sampleGraph: document.getElementById('sampleGraph'),\n        randomGraph: document.getElementById('randomGraph'),\n        resetGraph: document.getElementById('resetGraph')\n      };\n\n      function setStatus(msg, type = 'info') {\n        status.textContent = msg;\n        if (type === 'error') {\n          status.style.color = 'var(--error)';\n        } else if (type === 'warn') {\n          status.style.color = 'var(--warn)';\n        } else {\n          status.style.color = 'var(--muted)';\n        }\n      }\n\n      function idToLabel(id) {\n        // Spreadsheet-style labels: 0->A, 25->Z, 26->AA, 27->AB...\n        let n = id + 1;\n        let s = '';\n        while (n > 0) {\n          const r = (n - 1) % 26;\n          s = String.fromCharCode(65 + r) + s;\n          n = Math.floor((n - 1) / 26);\n        }\n        return s;\n      }\n\n      function midpoint(ax, ay, bx, by) { return [(ax + bx) / 2, (ay + by) / 2]; }\n      function perpOffset(ax, ay, bx, by, d = 14) {\n        const dx = bx - ax, dy = by - ay;\n        const len = Math.hypot(dx, dy) || 1;\n        const nx = -dy / len, ny = dx / len;\n        return [nx * d, ny * d];\n      }\n\n      class GraphModel {\n        constructor() {\n          this.nodes = []; // {id, x, y, label, g, circle, text}\n          this.edges = []; // {id, a, b, weight, line, labelText}\n          this.adj = new Map(); // id -> [{to, weight, edgeId}]\n          this.nextNodeId = 0;\n          this.nextEdgeId = 0;\n          this.startId = null;\n          this.endId = null;\n        }\n\n        reset() {\n          this.nodes.forEach(n => n.g.remove());\n          this.edges.forEach(e => {\n            e.line.remove();\n            e.labelText.remove();\n          });\n          this.nodes = [];\n          this.edges = [];\n          this.adj.clear();\n          this.nextNodeId = 0;\n          this.nextEdgeId = 0;\n          this.startId = null;\n          this.endId = null;\n          distancesPanel.innerHTML = '';\n          setStatus('Graph reset.');\n          updateInfoSelections(null, null);\n        }\n\n        addNode(x, y) {\n          const id = this.nextNodeId++;\n          const label = idToLabel(id);\n\n          const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n          g.classList.add('node');\n          g.dataset.id = id;\n\n          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n          circle.setAttribute('r', 18);\n          circle.setAttribute('cx', x);\n          circle.setAttribute('cy', y);\n\n          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n          text.classList.add('nodeLabel');\n          text.setAttribute('x', x);\n          text.setAttribute('y', y + 1);\n          text.textContent = label;\n\n          g.appendChild(circle);\n          g.appendChild(text);\n          svg.appendChild(g);\n\n          const node = { id, x, y, label, g, circle, text };\n          this.nodes.push(node);\n          this.adj.set(id, []);\n\n          this._attachNodeEvents(node);\n          return node;\n        }\n\n        _attachNodeEvents(node) {\n          let dragging = false;\n          let lastPt = null;\n\n          const onPointerDown = (e) => {\n            dragging = true;\n            node.g.classList.add('dragging');\n            lastPt = getSVGPoint(e);\n            node.g.setPointerCapture(e.pointerId);\n          };\n          const onPointerMove = (e) => {\n            if (!dragging) return;\n            const pt = getSVGPoint(e);\n            const dx = pt.x - lastPt.x;\n            const dy = pt.y - lastPt.y;\n            lastPt = pt;\n            this.moveNode(node.id, node.x + dx, node.y + dy);\n          };\n          const onPointerUp = (e) => {\n            dragging = false;\n            node.g.classList.remove('dragging');\n            node.g.releasePointerCapture(e.pointerId);\n          };\n\n          // Clicks for selection depend on current mode\n          const onClick = (e) => {\n            e.stopPropagation();\n            if (currentMode === 'addEdge') {\n              this._handleAddEdgeClick(node.id);\n            } else if (currentMode === 'selectPath') {\n              this._handleSelectPathClick(node.id);\n            }\n          };\n\n          node.g.addEventListener('pointerdown', onPointerDown);\n          node.g.addEventListener('pointermove', onPointerMove);\n          node.g.addEventListener('pointerup', onPointerUp);\n          node.g.addEventListener('click', onClick);\n        }\n\n        moveNode(id, x, y) {\n          const node = this.nodes.find(n => n.id === id);\n          if (!node) return;\n          node.x = x; node.y = y;\n          node.circle.setAttribute('cx', x);\n          node.circle.setAttribute('cy', y);\n          node.text.setAttribute('x', x);\n          node.text.setAttribute('y', y + 1);\n\n          // Update connected edges\n          for (const e of this.edges) {\n            if (e.a === id || e.b === id) {\n              const a = this.nodes.find(n => n.id === e.a);\n              const b = this.nodes.find(n => n.id === e.b);\n              e.line.setAttribute('x1', a.x);\n              e.line.setAttribute('y1', a.y);\n              e.line.setAttribute('x2', b.x);\n              e.line.setAttribute('y2', b.y);\n\n              const [mx, my] = midpoint(a.x, a.y, b.x, b.y);\n              const [ox, oy] = perpOffset(a.x, a.y, b.x, b.y, 14);\n              e.labelText.setAttribute('x', mx + ox);\n              e.labelText.setAttribute('y', my + oy);\n            }\n          }\n        }\n\n        addEdge(aId, bId, weight) {\n          if (aId === bId) { setStatus('Cannot add edge from a node to itself.', 'error'); return null; }\n          const exists = this.edges.find(e => (e.a === aId && e.b === bId) || (e.a === bId && e.b === aId));\n          if (exists) { setStatus('Edge already exists between selected nodes.', 'warn'); return null; }\n          if (isNaN(weight) || weight < 0) { setStatus('Weight must be a non-negative number.', 'error'); return null; }\n\n          const a = this.nodes.find(n => n.id === aId);\n          const b = this.nodes.find(n => n.id === bId);\n          if (!a || !b) { setStatus('Invalid nodes for edge.', 'error'); return null; }\n\n          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n          line.classList.add('edge');\n          line.setAttribute('x1', a.x);\n          line.setAttribute('y1', a.y);\n          line.setAttribute('x2', b.x);\n          line.setAttribute('y2', b.y);\n\n          const [mx, my] = midpoint(a.x, a.y, b.x, b.y);\n          const [ox, oy] = perpOffset(a.x, a.y, b.x, b.y, 14);\n          const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n          labelText.classList.add('edgeLabel');\n          labelText.setAttribute('x', mx + ox);\n          labelText.setAttribute('y', my + oy);\n          labelText.textContent = formatWeight(weight);\n\n          // Insert lines beneath nodes for layering: place before first node group\n          const firstNodeGroup = this.nodes.length ? this.nodes[0].g : null;\n          if (firstNodeGroup) {\n            svg.insertBefore(line, firstNodeGroup);\n            svg.insertBefore(labelText, firstNodeGroup);\n          } else {\n            svg.appendChild(line);\n            svg.appendChild(labelText);\n          }\n\n          const id = this.nextEdgeId++;\n          const edge = { id, a: aId, b: bId, weight, line, labelText };\n          this.edges.push(edge);\n\n          // Undirected adjacency\n          this.adj.get(aId).push({ to: bId, weight, edgeId: id });\n          this.adj.get(bId).push({ to: aId, weight, edgeId: id });\n          setStatus(`Edge ${a.label} - ${b.label} (w=${weight}) added.`);\n          return edge;\n        }\n\n        clearHighlights() {\n          for (const e of this.edges) {\n            e.line.classList.remove('highlight');\n          }\n          for (const n of this.nodes) {\n            n.g.classList.remove('selected');\n          }\n          setStatus('Highlights cleared.');\n        }\n\n        clearSelections() {\n          this.startId = null;\n          this.endId = null;\n          for (const n of this.nodes) {\n            n.g.classList.remove('start');\n            n.g.classList.remove('end');\n          }\n          distancesPanel.innerHTML = '';\n          updateInfoSelections(null, null);\n          setStatus('Start/End selection cleared.');\n        }\n\n        _handleAddEdgeClick(nodeId) {\n          selectionForEdge.push(nodeId);\n          const node = this.nodes.find(n => n.id === nodeId);\n          node.g.classList.add('selected');\n\n          if (selectionForEdge.length === 2) {\n            const [aId, bId] = selectionForEdge;\n            selectionForEdge = [];\n            this.nodes.forEach(n => n.g.classList.remove('selected'));\n            const input = prompt('Enter edge weight (non-negative number):', '1');\n            if (input === null) { setStatus('Edge creation canceled.', 'warn'); return; }\n            const w = parseFloat(input);\n            this.addEdge(aId, bId, w);\n          } else {\n            setStatus('Select the second node to connect.');\n          }\n        }\n\n        _handleSelectPathClick(nodeId) {\n          if (this.startId === null) {\n            this.startId = nodeId;\n            const node = this.nodes.find(n => n.id === nodeId);\n            node.g.classList.add('start');\n            updateInfoSelections(this.startId, this.endId);\n            setStatus(`Start set to ${node.label}. Select an end node.`);\n          } else if (this.endId === null && nodeId !== this.startId) {\n            this.endId = nodeId;\n            const node = this.nodes.find(n => n.id === nodeId);\n            node.g.classList.add('end');\n            updateInfoSelections(this.startId, this.endId);\n            setStatus(`End set to ${node.label}. Click \"Run Dijkstra\".`);\n          } else if (nodeId === this.startId) {\n            setStatus('End must be different from start.', 'warn');\n          }\n        }\n\n        runDijkstra() {\n          if (this.startId === null) { setStatus('Select a start node first.', 'warn'); return; }\n          const startLabel = this.nodes.find(n => n.id === this.startId)?.label || '?';\n          const { dist, prev } = dijkstra(this.adj, this.nodes.map(n => n.id), this.startId);\n          renderDistances(this.nodes, dist, this.startId);\n\n          if (this.endId !== null) {\n            const path = reconstructPath(prev, this.startId, this.endId);\n            if (!path || path.length === 0) {\n              setStatus(`No path from ${startLabel} to ${this.nodes.find(n => n.id === this.endId).label}.`, 'warn');\n              return;\n            }\n            // Highlight path edges\n            this.clearHighlights();\n            for (let i = 0; i < path.length - 1; i++) {\n              const a = path[i], b = path[i+1];\n              const edge = this.edges.find(e => (e.a === a && e.b === b) || (e.a === b && e.b === a));\n              if (edge) edge.line.classList.add('highlight');\n            }\n            const total = dist.get(this.endId);\n            setStatus(`Shortest path cost: ${formatWeight(total)}. Path: ${path.map(i => this.nodes.find(n => n.id === i).label).join(' → ')}`);\n          } else {\n            setStatus(`Computed distances from ${startLabel}. Select an end node for a path highlight.`);\n          }\n        }\n      }\n\n      // Utility to get SVG coordinates from event\n      function getSVGPoint(evt) {\n        const pt = svg.createSVGPoint();\n        pt.x = evt.clientX;\n        pt.y = evt.clientY;\n        const screenCTM = svg.getScreenCTM();\n        const inv = screenCTM.inverse();\n        const loc = pt.matrixTransform(inv);\n        return { x: loc.x, y: loc.y };\n      }\n\n      function formatWeight(w) {\n        if (Math.abs(w - Math.round(w)) < 1e-9) return String(Math.round(w));\n        return Number(w.toFixed(2)).toString();\n      }\n\n      function renderDistances(nodes, dist, startId) {\n        distancesPanel.innerHTML = '';\n        const startLabel = nodes.find(n => n.id === startId)?.label || '?';\n        const header = document.createElement('div');\n        header.style.marginBottom = '6px';\n        header.style.color = '#e5e7eb';\n        header.textContent = `From ${startLabel}:`;\n        distancesPanel.appendChild(header);\n\n        const sorted = [...nodes].sort((a, b) => a.label.localeCompare(b.label));\n        for (const n of sorted) {\n          const row = document.createElement('div');\n          row.classList.add('distRow');\n          const l = document.createElement('div');\n          l.textContent = n.label;\n          const r = document.createElement('div');\n          const d = dist.get(n.id);\n          r.textContent = (d === Infinity) ? '∞' : formatWeight(d);\n          distancesPanel.appendChild(row);\n          row.appendChild(l);\n          row.appendChild(r);\n        }\n      }\n\n      function updateInfoSelections(startId, endId) {\n        // This updates the little sentences in the right panel (simple method: replace text nodes)\n        // We keep it minimal: rebuild the \"Current Selection\" block by manipulating innerHTML\n        const info = document.getElementById('infoContent');\n        const nodesTextStart = (() => {\n          if (startId === null) return 'None';\n          const node = graph.nodes.find(n => n.id === startId);\n          return node ? node.label : 'None';\n        })();\n        const nodesTextEnd = (() => {\n          if (endId === null) return 'None';\n          const node = graph.nodes.find(n => n.id === endId);\n          return node ? node.label : 'None';\n        })();\n\n        // Keep the first section text intact but update the lines in place\n        // Simple approach: find the two \"Current Selection\" lines by regenerating the block carefully\n        const template =\n          'Weighted Graph\\n' +\n          '          - Nodes represent points; edges represent connections with costs (weights).\\n' +\n          '          - Dijkstra\\'s algorithm computes the minimum total weight from a start node to all others (non-negative edges).\\n\\n' +\n          '          Current Selection\\n' +\n          `          - Start: ${nodesTextStart}\\n` +\n          `          - End: ${nodesTextEnd}\\n\\n` +\n          '          Distances (from Start)';\n        const idx = info.innerHTML.indexOf('Distances (from Start)');\n        // Replace only the \"Current Selection\" section text by rewriting the top chunk\n        // To avoid over-complication, we simply reset the initial text up to \"Distances (from Start)\" once.\n        const top = template;\n        info.innerHTML = top + info.innerHTML.substring(idx);\n      }\n\n      // Dijkstra (simple O(V^2 + E)) priority selection by scanning\n      function dijkstra(adj, nodesIds, startId) {\n        const dist = new Map();\n        const prev = new Map();\n        const visited = new Set();\n\n        for (const id of nodesIds) {\n          dist.set(id, Infinity);\n          prev.set(id, null);\n        }\n        dist.set(startId, 0);\n\n        while (visited.size < nodesIds.length) {\n          // Select unvisited with minimal distance\n          let u = null;\n          let minDist = Infinity;\n          for (const id of nodesIds) {\n            if (!visited.has(id) && dist.get(id) < minDist) {\n              minDist = dist.get(id);\n              u = id;\n            }\n          }\n          if (u === null) break; // remaining are unreachable\n          visited.add(u);\n          const neighbors = adj.get(u) || [];\n          for (const { to, weight } of neighbors) {\n            if (visited.has(to)) continue;\n            const alt = dist.get(u) + weight;\n            if (alt < dist.get(to)) {\n              dist.set(to, alt);\n              prev.set(to, u);\n            }\n          }\n        }\n        return { dist, prev };\n      }\n\n      function reconstructPath(prev, startId, endId) {\n        const path = [];\n        let u = endId;\n        if (prev.get(u) === null && u !== startId) return []; // unreachable\n        while (u !== null) {\n          path.unshift(u);\n          if (u === startId) break;\n          u = prev.get(u);\n        }\n        return path;\n      }\n\n      // Modes and interactions\n      let currentMode = null;\n      let selectionForEdge = [];\n      const graph = new GraphModel();\n\n      function setMode(mode) {\n        currentMode = mode;\n        for (const key of Object.keys(modeButtons)) {\n          modeButtons[key].classList.remove('active');\n        }\n        if (mode === 'addNode') modeButtons.addNode.classList.add('active');\n        else if (mode === 'addEdge') modeButtons.addEdge.classList.add('active');\n        else if (mode === 'selectPath') modeButtons.selectPath.classList.add('active');\n\n        if (mode === 'addNode') {\n          setStatus('Add Node: click on empty canvas to place a node.');\n        } else if (mode === 'addEdge') {\n          setStatus('Add Edge: click two nodes to connect them, then enter a weight.');\n          selectionForEdge = [];\n          graph.nodes.forEach(n => n.g.classList.remove('selected'));\n        } else if (mode === 'selectPath') {\n          setStatus('Select Start/End: click a start node, then an end node.');\n        } else {\n          setStatus('Ready.');\n        }\n      }\n\n      // Canvas click for adding nodes\n      svg.addEventListener('click', (e) => {\n        if (currentMode !== 'addNode') return;\n        // Avoid creating node when clicking on existing node groups or labels (stopPropagation handles that mostly)\n        const targetName = e.target.tagName.toLowerCase();\n        if (['circle', 'text', 'line', 'g'].includes(targetName)) return;\n\n        const pt = getSVGPoint(e);\n        const node = graph.addNode(pt.x, pt.y);\n        setStatus(`Node ${node.label} added at (${Math.round(pt.x)}, ${Math.round(pt.y)}).`);\n      });\n\n      // Controls\n      modeButtons.addNode.addEventListener('click', () => setMode('addNode'));\n      modeButtons.addEdge.addEventListener('click', () => setMode('addEdge'));\n      modeButtons.selectPath.addEventListener('click', () => setMode('selectPath'));\n      controls.clearHighlights.addEventListener('click', () => graph.clearHighlights());\n      controls.clearSelections.addEventListener('click', () => graph.clearSelections());\n      controls.runDijkstra.addEventListener('click', () => graph.runDijkstra());\n      controls.resetGraph.addEventListener('click', () => graph.reset());\n\n      controls.sampleGraph.addEventListener('click', () => {\n        graph.reset();\n        const w = 1000, h = 700;\n        const positions = [\n          [w*0.18, h*0.25], [w*0.35, h*0.18], [w*0.52, h*0.22], [w*0.72, h*0.30],\n          [w*0.20, h*0.60], [w*0.38, h*0.52], [w*0.56, h*0.55], [w*0.78, h*0.62]\n        ];\n        positions.forEach(([x, y]) => graph.addNode(x, y));\n        const edges = [\n          [0,1,2], [1,2,4], [2,3,6],\n          [0,4,7], [1,5,5], [2,6,3], [3,7,1],\n          [4,5,2], [5,6,2], [6,7,4],\n          [1,4,9], [2,5,8]\n        ];\n        for (const [a,b,wgt] of edges) graph.addEdge(a,b,wgt);\n\n        setMode('selectPath');\n        graph.startId = 0; graph.nodes[0].g.classList.add('start');\n        graph.endId = 7; graph.nodes[7].g.classList.add('end');\n        updateInfoSelections(graph.startId, graph.endId);\n        setStatus('Sample graph loaded. Start=A, End=H. Click \"Run Dijkstra\" to see shortest path.');\n      });\n\n      controls.randomGraph.addEventListener('click', () => {\n        graph.reset();\n        const w = 1000, h = 700;\n        const N = 8 + Math.floor(Math.random()*4); // 8-11 nodes\n        for (let i = 0; i < N; i++) {\n          const x = 80 + Math.random()*(w - 160);\n          const y = 80 + Math.random()*(h - 160);\n          graph.addNode(x, y);\n        }\n        // Ensure connectivity by making a random spanning tree\n        const order = [...Array(N).keys()].sort(() => Math.random() - 0.5);\n        for (let i = 1; i < N; i++) {\n          const a = order[i];\n          const b = order[Math.floor(Math.random()*i)];\n          const wgt = 1 + Math.floor(Math.random()*9);\n          graph.addEdge(a, b, wgt);\n        }\n        // Add a few extra random edges\n        const extra = Math.floor(N * 1.2);\n        for (let k = 0; k < extra; k++) {\n          const a = Math.floor(Math.random()*N);\n          let b = Math.floor(Math.random()*N);\n          if (b === a) b = (b+1) % N;\n          const wgt = 1 + Math.floor(Math.random()*9);\n          graph.addEdge(a, b, wgt);\n        }\n        setMode('selectPath');\n        setStatus('Random connected graph generated. Select start/end and run Dijkstra.');\n      });\n\n      // Initialize with sample graph for convenience\n      controls.sampleGraph.click();\n\n      // Helper: keep viewBox responsive to container size\n      function fitViewBox() {\n        const rect = svg.getBoundingClientRect();\n        svg.setAttribute('viewBox', `0 0 1000 700`);\n      }\n      window.addEventListener('resize', fitViewBox);\n      fitViewBox();\n    })();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Weighted Graph"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "f04c4830-a369-11f0-8b20-1b0ca2519750",
    "timestamp": "2025-10-07T10:39:44.692Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Adjacency Matrix",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<title>Adjacency Matrix Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --text: #e5e7eb;\n    --muted: #9ca3af;\n    --accent: #60a5fa;\n    --accent2: #22d3ee;\n    --good: #34d399;\n    --warn: #f59e0b;\n    --bad: #ef4444;\n    --grid: #1f2937;\n  }\n  html, body {\n    margin: 0;\n    height: 100%;\n    background: linear-gradient(120deg, #0b122b, #0a1a24 60%, #101421);\n    color: var(--text);\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n  }\n  a { color: var(--accent); text-decoration: none; }\n  .container {\n    max-width: 1200px;\n    margin: 0 auto;\n    padding: 20px 16px 40px;\n  }\n  header {\n    display: grid;\n    grid-template-columns: 1fr auto;\n    gap: 12px;\n    align-items: center;\n    margin-bottom: 16px;\n  }\n  .title {\n    display: flex;\n    align-items: baseline;\n    gap: 12px;\n  }\n  h1 {\n    margin: 0;\n    font-weight: 700;\n    letter-spacing: 0.5px;\n    font-size: clamp(22px, 3vw, 28px);\n  }\n  .subtitle {\n    color: var(--muted);\n    font-size: 14px;\n  }\n  .controls {\n    display: grid;\n    grid-template-columns: repeat(12, minmax(0, 1fr));\n    gap: 10px;\n    align-items: center;\n    background: rgba(17, 24, 39, 0.7);\n    border: 1px solid #1f2937;\n    border-radius: 12px;\n    padding: 12px;\n    box-shadow: 0 10px 30px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.03);\n  }\n  .controls > * {\n    grid-column: span 3;\n  }\n  @media (max-width: 900px) {\n    .controls { grid-template-columns: repeat(6, 1fr); }\n    .controls > * { grid-column: span 3; }\n  }\n  @media (max-width: 560px) {\n    .controls { grid-template-columns: repeat(2, 1fr); }\n    .controls > * { grid-column: span 2; }\n  }\n  .control {\n    background: rgba(31, 41, 55, 0.8);\n    border: 1px solid #263143;\n    border-radius: 8px;\n    padding: 8px 10px;\n  }\n  .control label {\n    font-size: 12px;\n    color: var(--muted);\n    display: block;\n    margin-bottom: 4px;\n  }\n  .row {\n    display: flex;\n    gap: 8px;\n    align-items: center;\n    flex-wrap: wrap;\n  }\n  input[type=\"number\"], input[type=\"text\"], select {\n    width: 100%;\n    box-sizing: border-box;\n    padding: 8px 10px;\n    background: #0b1220;\n    border: 1px solid #1f2a3a;\n    color: var(--text);\n    border-radius: 6px;\n    outline: none;\n  }\n  input[type=\"range\"] {\n    width: 100%;\n  }\n  .checkbox {\n    display: flex;\n    gap: 8px;\n    align-items: center;\n    cursor: pointer;\n  }\n  .checkbox input {\n    width: 18px; height: 18px;\n  }\n  .btn {\n    background: linear-gradient(180deg, #1f2937, #111827);\n    border: 1px solid #334155;\n    color: var(--text);\n    border-radius: 8px;\n    padding: 8px 10px;\n    cursor: pointer;\n    transition: transform 0.02s ease-in-out, box-shadow 0.2s, border-color 0.2s;\n    white-space: nowrap;\n  }\n  .btn:hover { border-color: #4b5563; box-shadow: 0 4px 14px rgba(0,0,0,0.18); }\n  .btn:active { transform: translateY(1px); }\n  .btn.primary { background: linear-gradient(180deg, #2563eb, #1e40af); border-color: #1d4ed8; }\n  .btn.good { background: linear-gradient(180deg, #10b981, #047857); border-color: #059669; }\n  .btn.warn { background: linear-gradient(180deg, #f59e0b, #b45309); border-color: #d97706; color: #0b1020; }\n  .btn.bad { background: linear-gradient(180deg, #ef4444, #b91c1c); border-color: #dc2626; }\n  .layout {\n    display: grid;\n    grid-template-columns: 420px 1fr;\n    gap: 14px;\n    margin-top: 12px;\n  }\n  @media (max-width: 1024px) {\n    .layout { grid-template-columns: 1fr; }\n  }\n  .panel {\n    background: rgba(17, 24, 39, 0.7);\n    border: 1px solid #1f2937;\n    border-radius: 12px;\n    padding: 12px;\n    box-shadow: 0 10px 30px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.03);\n  }\n  .panel h2 {\n    font-size: 16px;\n    margin: 0 0 8px 0;\n    color: var(--accent);\n    display: flex;\n    align-items: center;\n    gap: 8px;\n  }\n  .matrix-wrapper {\n    overflow: auto;\n    border-radius: 8px;\n    border: 1px solid #263143;\n  }\n  table.matrix {\n    border-collapse: collapse;\n    min-width: 360px;\n    width: 100%;\n    background: #0b1220;\n  }\n  table.matrix th, table.matrix td {\n    border: 1px solid #233245;\n    text-align: center;\n    padding: 0;\n    position: relative;\n  }\n  table.matrix th {\n    background: #111827;\n    color: var(--muted);\n    font-weight: 500;\n    font-size: 13px;\n    padding: 6px 8px;\n    position: sticky;\n    top: 0;\n    z-index: 3;\n  }\n  table.matrix td {\n    height: 34px;\n    width: 34px;\n    min-width: 34px;\n    font-size: 13px;\n    color: var(--text);\n    background: #0b1220;\n    cursor: pointer;\n  }\n  table.matrix td:hover {\n    outline: 2px solid #2563eb66;\n    z-index: 2;\n  }\n  td .cell {\n    width: 100%;\n    height: 100%;\n    display: grid;\n    place-items: center;\n    user-select: none;\n  }\n  td.loop-disabled {\n    background: #0b1220;\n    color: #324256;\n    cursor: not-allowed;\n  }\n  td.active {\n    background: #0f1e32;\n  }\n  .legend {\n    font-size: 12px;\n    color: var(--muted);\n    padding: 8px;\n    border-top: 1px dashed #263143;\n    margin-top: 8px;\n  }\n  .legend b { color: var(--text); }\n  .graph {\n    height: 520px;\n    background: #0b1220;\n    border-radius: 12px;\n    border: 1px solid #263143;\n    overflow: hidden;\n    position: relative;\n  }\n  .graph-controls {\n    display: flex;\n    gap: 8px;\n    flex-wrap: wrap;\n    margin-bottom: 10px;\n  }\n  .statbar {\n    display: grid;\n    grid-template-columns: repeat(3, 1fr);\n    gap: 8px;\n    margin-top: 10px;\n  }\n  .stat {\n    background: rgba(31, 41, 55, 0.8);\n    border: 1px solid #263143;\n    border-radius: 8px;\n    padding: 8px;\n    font-size: 13px;\n  }\n  .stat .value {\n    font-weight: 700;\n    color: var(--good);\n  }\n  .footnote {\n    margin-top: 10px;\n    font-size: 12px;\n    color: var(--muted);\n  }\n  .algos {\n    margin-top: 14px;\n    display: grid;\n    grid-template-columns: 1fr;\n    gap: 12px;\n  }\n  .algo-panel {\n    background: rgba(17, 24, 39, 0.7);\n    border: 1px solid #1f2937;\n    border-radius: 12px;\n    padding: 12px;\n  }\n  .algo-panel h3 {\n    margin: 0 0 6px 0;\n    font-size: 15px;\n    color: var(--accent2);\n  }\n  .mini-matrix {\n    overflow: auto;\n    border-radius: 8px;\n    border: 1px solid #263143;\n    max-height: 260px;\n  }\n  table.small {\n    border-collapse: collapse;\n    background: #0b1220;\n    min-width: 240px;\n  }\n  table.small th, table.small td {\n    border: 1px solid #233245;\n    text-align: center;\n    padding: 4px 6px;\n    font-size: 12px;\n    color: var(--text);\n    position: sticky;\n  }\n  table.small th {\n    background: #111827;\n    color: var(--muted);\n    top: 0;\n    z-index: 1;\n  }\n  .list {\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n    font-size: 12px;\n    background: #0b1220;\n    border: 1px solid #263143;\n    border-radius: 8px;\n    padding: 10px;\n    overflow: auto;\n    max-height: 240px;\n  }\n  .matrix-actions, .io-actions {\n    display: flex;\n    gap: 8px;\n    flex-wrap: wrap;\n    margin-top: 10px;\n  }\n  .io {\n    margin-top: 8px;\n    display: none;\n  }\n  .io textarea {\n    width: 100%;\n    min-height: 120px;\n    background: #0b1220;\n    border: 1px solid #263143;\n    color: var(--text);\n    border-radius: 8px;\n    padding: 8px;\n    box-sizing: border-box;\n    resize: vertical;\n  }\n  .badge {\n    font-size: 11px;\n    background: #111827;\n    border: 1px solid #263143;\n    color: var(--muted);\n    padding: 2px 6px;\n    border-radius: 999px;\n  }\n  .tip {\n    font-size: 12px;\n    color: var(--muted);\n  }\n  .weight-editor {\n    position: fixed;\n    background: #111827;\n    border: 1px solid #334155;\n    color: var(--text);\n    border-radius: 8px;\n    padding: 10px;\n    z-index: 1000;\n    box-shadow: 0 10px 30px rgba(0,0,0,0.35);\n    display: none;\n    width: 220px;\n  }\n  .weight-editor .row { justify-content: space-between; }\n  .arrow-marker path { fill: #93c5fd; }\n  .graph svg { width: 100%; height: 100%; }\n  .node {\n    fill: #1f6fe0;\n    stroke: #8ab6ff;\n    stroke-width: 1px;\n    cursor: pointer;\n  }\n  .node:hover { filter: brightness(1.2); }\n  .edge {\n    stroke: #93c5fd;\n    stroke-width: 2;\n    opacity: 0.9;\n    cursor: pointer;\n  }\n  .edge:hover { stroke: #e0f2fe; }\n  .edge.weighted { stroke-width: 2.5; }\n  .label {\n    font-size: 12px;\n    fill: #e5e7eb;\n    pointer-events: none;\n  }\n  .arrow {\n    marker-end: url(#arrowhead);\n  }\n  .axis-label {\n    font-size: 11px;\n    color: var(--muted);\n  }\n  .callout {\n    border-left: 3px solid var(--accent);\n    background: rgba(37, 99, 235, 0.08);\n    padding: 8px 10px;\n    border-radius: 6px;\n    font-size: 13px;\n    color: #cbd5e1;\n  }\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <header>\n    <div class=\"title\">\n      <h1>Adjacency Matrix</h1>\n      <span class=\"subtitle\">Interactive graph builder and matrix explorer</span>\n    </div>\n    <div class=\"badge\">Single-file HTML + JavaScript demo</div>\n  </header>\n\n  <div class=\"controls\">\n    <div class=\"control\">\n      <label for=\"vertexCount\">Vertices (n)</label>\n      <div class=\"row\">\n        <input id=\"vertexCount\" type=\"number\" min=\"1\" max=\"20\" value=\"6\" />\n        <button class=\"btn\" id=\"resizeBtn\">Resize</button>\n      </div>\n    </div>\n    <div class=\"control\">\n      <label>Graph Type</label>\n      <div class=\"row\">\n        <label class=\"checkbox\"><input type=\"checkbox\" id=\"directed\" /> Directed</label>\n        <label class=\"checkbox\"><input type=\"checkbox\" id=\"weighted\" /> Weighted</label>\n        <label class=\"checkbox\"><input type=\"checkbox\" id=\"allowLoops\" checked /> Allow self-loops</label>\n      </div>\n    </div>\n    <div class=\"control\">\n      <label for=\"randomDensity\">Random density</label>\n      <div class=\"row\">\n        <input id=\"randomDensity\" type=\"range\" min=\"0\" max=\"100\" value=\"35\" />\n      </div>\n      <div class=\"tip\">Density p = <span id=\"densityVal\">0.35</span></div>\n    </div>\n    <div class=\"control\">\n      <label for=\"maxWeight\">Max random weight</label>\n      <div class=\"row\">\n        <input id=\"maxWeight\" type=\"number\" min=\"1\" max=\"50\" value=\"5\" />\n      </div>\n    </div>\n    <div class=\"control\">\n      <label>Matrix actions</label>\n      <div class=\"matrix-actions\">\n        <button class=\"btn\" id=\"clearBtn\">Clear</button>\n        <button class=\"btn good\" id=\"randomBtn\">Random</button>\n        <button class=\"btn warn\" id=\"fillCliqueBtn\">Make clique</button>\n      </div>\n    </div>\n    <div class=\"control\">\n      <label>Import/Export</label>\n      <div class=\"io-actions\">\n        <button class=\"btn\" id=\"toggleIOBtn\">Show IO</button>\n        <button class=\"btn\" id=\"copyCSVBtn\">Copy CSV</button>\n        <button class=\"btn\" id=\"downloadCSVBtn\">Download CSV</button>\n      </div>\n    </div>\n    <div class=\"control\">\n      <label>Graph layout</label>\n      <div class=\"row\">\n        <select id=\"layoutSelect\">\n          <option value=\"circle\">Circle</option>\n          <option value=\"grid\">Grid</option>\n        </select>\n      </div>\n    </div>\n    <div class=\"control\">\n      <label>Path counts A^k</label>\n      <div class=\"row\">\n        <input id=\"powerK\" type=\"number\" min=\"2\" max=\"6\" value=\"2\" />\n        <button class=\"btn\" id=\"computePowerBtn\">Compute</button>\n      </div>\n    </div>\n    <div class=\"control\">\n      <label>Highlight</label>\n      <div class=\"row\">\n        <input id=\"highlightIndex\" type=\"number\" min=\"0\" max=\"19\" value=\"0\" />\n        <button class=\"btn\" id=\"highlightBtn\">Row/Col</button>\n      </div>\n    </div>\n    <div class=\"control\">\n      <label>Selection</label>\n      <div class=\"row\">\n        <button class=\"btn\" id=\"selectNodeBtn\">Select node</button>\n        <button class=\"btn\" id=\"cancelSelectBtn\">Cancel</button>\n      </div>\n      <div class=\"tip\">Click a node, then another to add/remove edge.</div>\n    </div>\n    <div class=\"control\">\n      <label>Info</label>\n      <div class=\"callout\">Click a matrix cell to toggle edges. In weighted mode, click an existing edge to edit its weight.</div>\n    </div>\n  </div>\n\n  <div class=\"layout\">\n    <div class=\"panel\">\n      <h2>Adjacency Matrix</h2>\n      <div class=\"matrix-wrapper\">\n        <table class=\"matrix\" id=\"matrixTable\"></table>\n      </div>\n      <div class=\"legend\">\n        For a graph with vertices V = {0..n-1}, the adjacency matrix A is an n×n matrix where A[i][j] is:\n        <br>- unweighted: 1 if edge i→j exists, otherwise 0\n        <br>- weighted: the weight of edge i→j (0 if no edge)\n      </div>\n      <div class=\"io\" id=\"ioPanel\">\n        <div class=\"row\">\n          <span class=\"badge\">CSV Import/Export</span>\n        </div>\n        <textarea id=\"csvArea\" placeholder=\"Paste CSV matrix here (rows separated by newlines, values by commas)\"></textarea>\n        <div class=\"row\" style=\"margin-top: 6px;\">\n          <button class=\"btn good\" id=\"applyCSVBtn\">Apply CSV</button>\n          <span class=\"tip\">CSV must be n×n. Non-numeric values become 0.</span>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <h2>Graph Visualization</h2>\n      <div class=\"graph-controls\">\n        <span class=\"badge\" id=\"graphStatus\">Ready</span>\n        <span class=\"badge\">Click edges to toggle/edit</span>\n      </div>\n      <div class=\"graph\" id=\"graphArea\"></div>\n\n      <div class=\"statbar\">\n        <div class=\"stat\">Vertices: <span class=\"value\" id=\"statN\">0</span></div>\n        <div class=\"stat\">Edges: <span class=\"value\" id=\"statM\">0</span></div>\n        <div class=\"stat\">Density: <span class=\"value\" id=\"statD\">0</span></div>\n      </div>\n\n      <div class=\"algos\">\n        <div class=\"algo-panel\">\n          <h3>Degrees</h3>\n          <div class=\"list\" id=\"degreeList\"></div>\n          <div class=\"footnote\">Undirected: degree of i is sum of row i (counting loops as 2 if allowed). Directed: out-degree = row sum, in-degree = column sum.</div>\n        </div>\n        <div class=\"algo-panel\">\n          <h3>Adjacency List</h3>\n          <div class=\"list\" id=\"adjacencyList\"></div>\n          <div class=\"footnote\">Each vertex lists its neighbors. Weighted edges show as neighbor(weight).</div>\n        </div>\n        <div class=\"algo-panel\">\n          <h3>Matrix Power A^k</h3>\n          <div class=\"mini-matrix\" id=\"powerMatrixWrapper\">\n            <table class=\"small\" id=\"powerMatrix\"></table>\n          </div>\n          <div class=\"footnote\">For unweighted graphs, (A^k)[i][j] counts walks of length k from i to j. For weighted graphs, entries accumulate weighted walk counts.</div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<!-- Weight editor overlay -->\n<div class=\"weight-editor\" id=\"weightEditor\">\n  <div style=\"margin-bottom: 6px;\">Edit weight for edge <span id=\"weightEdgeText\"></span></div>\n  <div class=\"row\">\n    <input id=\"weightInput\" type=\"number\" min=\"0\" step=\"1\" value=\"1\" />\n    <div class=\"row\">\n      <button class=\"btn good\" id=\"weightApplyBtn\">Apply</button>\n      <button class=\"btn bad\" id=\"weightDeleteBtn\">Delete</button>\n      <button class=\"btn\" id=\"weightCancelBtn\">Cancel</button>\n    </div>\n  </div>\n</div>\n\n<script>\n(function() {\n  // State\n  let n = 6;\n  let A = createZeroMatrix(n);\n  let isDirected = false;\n  let isWeighted = false;\n  let allowLoops = true;\n  let layoutMode = 'circle';\n  let selectingNode = null; // selection index for adding edges\n\n  const el = {\n    vertexCount: document.getElementById('vertexCount'),\n    resizeBtn: document.getElementById('resizeBtn'),\n    directed: document.getElementById('directed'),\n    weighted: document.getElementById('weighted'),\n    allowLoops: document.getElementById('allowLoops'),\n    matrixTable: document.getElementById('matrixTable'),\n    clearBtn: document.getElementById('clearBtn'),\n    randomBtn: document.getElementById('randomBtn'),\n    fillCliqueBtn: document.getElementById('fillCliqueBtn'),\n    randomDensity: document.getElementById('randomDensity'),\n    densityVal: document.getElementById('densityVal'),\n    maxWeight: document.getElementById('maxWeight'),\n    graphArea: document.getElementById('graphArea'),\n    graphStatus: document.getElementById('graphStatus'),\n    powerK: document.getElementById('powerK'),\n    computePowerBtn: document.getElementById('computePowerBtn'),\n    powerMatrix: document.getElementById('powerMatrix'),\n    degreeList: document.getElementById('degreeList'),\n    adjacencyList: document.getElementById('adjacencyList'),\n    toggleIOBtn: document.getElementById('toggleIOBtn'),\n    ioPanel: document.getElementById('ioPanel'),\n    csvArea: document.getElementById('csvArea'),\n    applyCSVBtn: document.getElementById('applyCSVBtn'),\n    copyCSVBtn: document.getElementById('copyCSVBtn'),\n    downloadCSVBtn: document.getElementById('downloadCSVBtn'),\n    layoutSelect: document.getElementById('layoutSelect'),\n    statN: document.getElementById('statN'),\n    statM: document.getElementById('statM'),\n    statD: document.getElementById('statD'),\n    highlightIndex: document.getElementById('highlightIndex'),\n    highlightBtn: document.getElementById('highlightBtn'),\n    selectNodeBtn: document.getElementById('selectNodeBtn'),\n    cancelSelectBtn: document.getElementById('cancelSelectBtn'),\n    weightEditor: document.getElementById('weightEditor'),\n    weightEdgeText: document.getElementById('weightEdgeText'),\n    weightInput: document.getElementById('weightInput'),\n    weightApplyBtn: document.getElementById('weightApplyBtn'),\n    weightDeleteBtn: document.getElementById('weightDeleteBtn'),\n    weightCancelBtn: document.getElementById('weightCancelBtn')\n  };\n\n  // Initialize\n  function init() {\n    renderMatrix();\n    renderGraph();\n    updateStats();\n    renderLists();\n    renderPower();\n    el.vertexCount.value = n;\n    el.directed.checked = isDirected;\n    el.weighted.checked = isWeighted;\n    el.allowLoops.checked = allowLoops;\n    el.layoutSelect.value = layoutMode;\n    el.densityVal.textContent = Number(el.randomDensity.value / 100).toFixed(2);\n\n    addEventListeners();\n  }\n\n  function addEventListeners() {\n    el.resizeBtn.addEventListener('click', () => {\n      const newN = clamp(parseInt(el.vertexCount.value, 10) || n, 1, 20);\n      if (newN !== n) {\n        n = newN;\n        A = createZeroMatrix(n);\n        el.highlightIndex.max = n-1;\n        renderMatrix();\n        renderGraph();\n        updateStats();\n        renderLists();\n        renderPower();\n      }\n    });\n\n    el.directed.addEventListener('change', () => {\n      isDirected = el.directed.checked;\n      if (!isDirected) {\n        // Force symmetry for undirected\n        symmetrizeMatrix();\n      }\n      renderMatrix();\n      renderGraph();\n      updateStats();\n      renderLists();\n      renderPower();\n    });\n\n    el.weighted.addEventListener('change', () => {\n      isWeighted = el.weighted.checked;\n      renderMatrix();\n      renderGraph();\n      updateStats();\n      renderLists();\n      renderPower();\n    });\n\n    el.allowLoops.addEventListener('change', () => {\n      allowLoops = el.allowLoops.checked;\n      if (!allowLoops) {\n        // Clear diagonal\n        for (let i = 0; i < n; i++) setEdge(i, i, 0);\n      }\n      renderMatrix();\n      renderGraph();\n      updateStats();\n      renderLists();\n      renderPower();\n    });\n\n    el.clearBtn.addEventListener('click', () => {\n      A = createZeroMatrix(n);\n      renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();\n      info('Matrix cleared');\n    });\n\n    el.fillCliqueBtn.addEventListener('click', () => {\n      // Fill complete graph (without loops unless allowed)\n      for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n          if (!allowLoops && i === j) { setEdge(i, j, 0); continue; }\n          const val = isWeighted ? (i === j ? (allowLoops ? 1 : 0) : 1) : 1;\n          setEdge(i, j, val);\n        }\n      }\n      if (!isDirected) symmetrizeMatrix();\n      renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();\n      info('Complete graph created');\n    });\n\n    el.randomDensity.addEventListener('input', () => {\n      el.densityVal.textContent = Number(el.randomDensity.value / 100).toFixed(2);\n    });\n\n    el.randomBtn.addEventListener('click', () => {\n      const p = parseInt(el.randomDensity.value, 10) / 100;\n      const maxW = clamp(parseInt(el.maxWeight.value, 10) || 5, 1, 100);\n      for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n          if (!allowLoops && i === j) { setEdge(i, j, 0); continue; }\n          const r = Math.random();\n          if (r < p) {\n            const val = isWeighted ? Math.max(1, Math.round(Math.random() * maxW)) : 1;\n            setEdge(i, j, val);\n          } else {\n            setEdge(i, j, 0);\n          }\n        }\n      }\n      if (!isDirected) symmetrizeMatrix();\n      renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();\n      info('Random graph generated');\n    });\n\n    el.computePowerBtn.addEventListener('click', () => {\n      renderPower();\n    });\n\n    el.toggleIOBtn.addEventListener('click', () => {\n      el.ioPanel.style.display = el.ioPanel.style.display === 'none' || el.ioPanel.style.display === '' ? 'block' : 'none';\n    });\n\n    el.applyCSVBtn.addEventListener('click', () => {\n      const csv = el.csvArea.value.trim();\n      if (!csv) return warn('CSV area is empty');\n      const rows = csv.split(/\\r?\\n/).map(r => r.split(/[,\\s]+/));\n      if (!rows.length) return warn('Invalid CSV');\n      const m = rows.length;\n      const k = rows[0].length;\n      if (m !== k) { return warn('CSV must contain a square matrix'); }\n      if (m !== n) {\n        // Resize\n        n = m;\n        el.vertexCount.value = n;\n        A = createZeroMatrix(n);\n      }\n      for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n          const val = toNumber(rows[i][j]);\n          setEdge(i, j, clamp(val, 0, 1e9));\n        }\n      }\n      if (!isDirected) symmetrizeMatrix();\n      renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();\n      info('CSV imported');\n    });\n\n    el.copyCSVBtn.addEventListener('click', async () => {\n      const csv = matrixToCSV(A);\n      try {\n        await navigator.clipboard.writeText(csv);\n        info('CSV copied to clipboard');\n      } catch {\n        el.csvArea.value = csv;\n        el.ioPanel.style.display = 'block';\n        info('Clipboard blocked. CSV placed in textarea.');\n      }\n    });\n\n    el.downloadCSVBtn.addEventListener('click', () => {\n      const csv = matrixToCSV(A);\n      downloadFile(csv, `adjacency_matrix_${n}x${n}.csv`, 'text/csv');\n    });\n\n    el.layoutSelect.addEventListener('change', () => {\n      layoutMode = el.layoutSelect.value;\n      renderGraph();\n    });\n\n    el.highlightBtn.addEventListener('click', () => {\n      const idx = clamp(parseInt(el.highlightIndex.value, 10) || 0, 0, n-1);\n      highlightRowCol(idx);\n    });\n\n    el.selectNodeBtn.addEventListener('click', () => {\n      selectingNode = null;\n      el.graphStatus.textContent = 'Select first node in graph (click a node)...';\n      el.graphStatus.style.borderColor = '#2563eb';\n    });\n\n    el.cancelSelectBtn.addEventListener('click', () => {\n      selectingNode = null;\n      el.graphStatus.textContent = 'Ready';\n      el.graphStatus.style.borderColor = '#263143';\n    });\n\n    // Weight editor events\n    el.weightApplyBtn.addEventListener('click', () => {\n      const value = clamp(parseInt(el.weightInput.value, 10) || 0, 0, 1e9);\n      const { i, j } = el.weightEditor.dataset;\n      if (i == null || j == null) return closeWeightEditor();\n      applyWeight(parseInt(i, 10), parseInt(j, 10), value);\n      closeWeightEditor();\n    });\n    el.weightDeleteBtn.addEventListener('click', () => {\n      const { i, j } = el.weightEditor.dataset;\n      if (i == null || j == null) return closeWeightEditor();\n      applyWeight(parseInt(i, 10), parseInt(j, 10), 0);\n      closeWeightEditor();\n    });\n    el.weightCancelBtn.addEventListener('click', () => {\n      closeWeightEditor();\n    });\n\n    // Close overlay on Escape\n    window.addEventListener('keydown', (e) => {\n      if (e.key === 'Escape') closeWeightEditor();\n    });\n\n    // Close overlay if clicking outside\n    document.addEventListener('mousedown', (e) => {\n      if (el.weightEditor.style.display === 'block') {\n        const rect = el.weightEditor.getBoundingClientRect();\n        const inside = e.clientX >= rect.left && e.clientX <= rect.right &&\n                       e.clientY >= rect.top && e.clientY <= rect.bottom;\n        if (!inside) closeWeightEditor();\n      }\n    });\n  }\n\n  // Helpers\n  function createZeroMatrix(size) {\n    const M = new Array(size);\n    for (let i = 0; i < size; i++) {\n      M[i] = new Array(size).fill(0);\n    }\n    return M;\n  }\n\n  function setEdge(i, j, val) {\n    if (!allowLoops && i === j) val = 0;\n    A[i][j] = val;\n    if (!isDirected && i !== j) A[j][i] = val;\n  }\n\n  function applyWeight(i, j, val) {\n    setEdge(i, j, val);\n    renderMatrix();\n    renderGraph();\n    updateStats();\n    renderLists();\n    renderPower();\n  }\n\n  function symmetrizeMatrix() {\n    for (let i = 0; i < n; i++) {\n      for (let j = i+1; j < n; j++) {\n        const v = Math.max(A[i][j], A[j][i]); // prefer existing edge; ensure undirected equivalent\n        A[i][j] = v; A[j][i] = v;\n      }\n    }\n  }\n\n  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }\n  function toNumber(x) {\n    const v = Number(x);\n    return isFinite(v) ? v : 0;\n  }\n\n  function matrixToCSV(M) {\n    return M.map(row => row.join(',')).join('\\n');\n  }\n\n  function downloadFile(content, filename, mime) {\n    const blob = new Blob([content], { type: mime });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url; a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    URL.revokeObjectURL(url);\n    a.remove();\n  }\n\n  function info(msg) { el.graphStatus.textContent = msg; el.graphStatus.style.borderColor = '#059669'; }\n  function warn(msg) { el.graphStatus.textContent = msg; el.graphStatus.style.borderColor = '#f59e0b'; }\n\n  function renderMatrix() {\n    const table = el.matrixTable;\n    table.innerHTML = '';\n    const thead = document.createElement('thead');\n    const trh = document.createElement('tr');\n    const corner = document.createElement('th');\n    corner.textContent = 'i \\\\ j';\n    trh.appendChild(corner);\n    for (let j = 0; j < n; j++) {\n      const th = document.createElement('th');\n      th.textContent = j;\n      trh.appendChild(th);\n    }\n    thead.appendChild(trh);\n    table.appendChild(thead);\n\n    const tbody = document.createElement('tbody');\n    for (let i = 0; i < n; i++) {\n      const tr = document.createElement('tr');\n      const th = document.createElement('th');\n      th.textContent = i;\n      tr.appendChild(th);\n\n      for (let j = 0; j < n; j++) {\n        const td = document.createElement('td');\n        const div = document.createElement('div');\n        div.className = 'cell';\n        const val = A[i][j];\n        div.textContent = val;\n        td.appendChild(div);\n\n        if (!allowLoops && i === j) {\n          td.classList.add('loop-disabled');\n        } else if (val !== 0) {\n          td.classList.add('active');\n        }\n\n        td.addEventListener('click', (e) => {\n          e.preventDefault();\n          closeWeightEditor();\n          if (!allowLoops && i === j) return;\n\n          if (!isWeighted) {\n            const newVal = A[i][j] === 0 ? 1 : 0;\n            setEdge(i, j, newVal);\n            renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();\n          } else {\n            if (A[i][j] === 0) {\n              setEdge(i, j, 1);\n              renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();\n            } else {\n              openWeightEditorForCell(td, i, j, A[i][j]);\n            }\n          }\n        });\n\n        td.addEventListener('dblclick', (e) => {\n          e.preventDefault();\n          if (!allowLoops && i === j) return;\n          openWeightEditorForCell(td, i, j, A[i][j]);\n        });\n\n        tr.appendChild(td);\n      }\n\n      tbody.appendChild(tr);\n    }\n\n    table.appendChild(tbody);\n  }\n\n  function openWeightEditorForCell(cell, i, j, currentVal) {\n    const rect = cell.getBoundingClientRect();\n    el.weightEditor.style.display = 'block';\n    el.weightEditor.style.left = `${rect.left + window.scrollX + rect.width + 6}px`;\n    el.weightEditor.style.top = `${rect.top + window.scrollY - 4}px`;\n    el.weightInput.value = currentVal || 1;\n    el.weightEdgeText.textContent = `${i} → ${j}`;\n    el.weightEditor.dataset.i = String(i);\n    el.weightEditor.dataset.j = String(j);\n  }\n\n  function closeWeightEditor() {\n    el.weightEditor.style.display = 'none';\n    delete el.weightEditor.dataset.i;\n    delete el.weightEditor.dataset.j;\n  }\n\n  function renderGraph() {\n    el.graphArea.innerHTML = '';\n    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n    // defs: arrowhead\n    const defs = document.createElementNS(svg.namespaceURI, 'defs');\n    const marker = document.createElementNS(svg.namespaceURI, 'marker');\n    marker.setAttribute('id', 'arrowhead');\n    marker.setAttribute('viewBox', '0 0 10 10');\n    marker.setAttribute('refX', '10');\n    marker.setAttribute('refY', '5');\n    marker.setAttribute('markerWidth', '6');\n    marker.setAttribute('markerHeight', '6');\n    marker.setAttribute('orient', 'auto-start-reverse');\n    const path = document.createElementNS(svg.namespaceURI, 'path');\n    path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');\n    path.setAttribute('class', 'arrow-marker');\n    marker.appendChild(path);\n    defs.appendChild(marker);\n    svg.appendChild(defs);\n\n    const width = el.graphArea.clientWidth;\n    const height = el.graphArea.clientHeight;\n\n    const positions = computePositions(n, width, height, layoutMode);\n\n    // Draw edges\n    const edgesDrawn = new Set();\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n        const w = A[i][j];\n        if (w === 0) continue;\n        if (!isDirected && i > j) continue; // draw undirected edge once\n        const [x1, y1] = positions[i];\n        const [x2, y2] = positions[j];\n\n        const edge = document.createElementNS(svg.namespaceURI, 'line');\n        edge.setAttribute('x1', x1);\n        edge.setAttribute('y1', y1);\n        edge.setAttribute('x2', x2);\n        edge.setAttribute('y2', y2);\n        edge.setAttribute('class', 'edge' + (isWeighted ? ' weighted' : '') + (isDirected ? ' arrow' : ''));\n        svg.appendChild(edge);\n\n        // Edge label (weight or 1)\n        if (isWeighted) {\n          const tx = (x1 + x2) / 2;\n          const ty = (y1 + y2) / 2;\n          const label = document.createElementNS(svg.namespaceURI, 'text');\n          label.setAttribute('x', tx);\n          label.setAttribute('y', ty);\n          label.setAttribute('class', 'label');\n          label.textContent = String(w);\n          svg.appendChild(label);\n        }\n\n        const key = `${i}-${j}`;\n        edgesDrawn.add(key);\n\n        edge.addEventListener('click', (e) => {\n          e.stopPropagation();\n          closeWeightEditor();\n          if (!isWeighted) {\n            const newVal = A[i][j] === 0 ? 1 : 0;\n            setEdge(i, j, newVal);\n            renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();\n          } else {\n            openWeightEditorAtPoint(e.clientX, e.clientY, i, j, A[i][j]);\n          }\n        });\n      }\n    }\n\n    // Draw nodes\n    for (let i = 0; i < n; i++) {\n      const [x, y] = positions[i];\n\n      const node = document.createElementNS(svg.namespaceURI, 'circle');\n      node.setAttribute('cx', x);\n      node.setAttribute('cy', y);\n      node.setAttribute('r', 16);\n      node.setAttribute('class', 'node');\n      svg.appendChild(node);\n\n      const label = document.createElementNS(svg.namespaceURI, 'text');\n      label.setAttribute('x', x);\n      label.setAttribute('y', y + 4);\n      label.setAttribute('text-anchor', 'middle');\n      label.setAttribute('class', 'label');\n      label.textContent = String(i);\n      svg.appendChild(label);\n\n      node.addEventListener('click', () => {\n        closeWeightEditor();\n        if (selectingNode == null) {\n          selectingNode = i;\n          el.graphStatus.textContent = `Selected ${i}. Click another node to toggle edge.`;\n          el.graphStatus.style.borderColor = '#2563eb';\n        } else {\n          const j = i;\n          const a = selectingNode;\n          selectingNode = null;\n          el.graphStatus.textContent = 'Ready';\n          el.graphStatus.style.borderColor = '#263143';\n          if (!allowLoops && a === j) return;\n          // Toggle or set edge between a -> j (and j -> a for undirected)\n          if (!isWeighted) {\n            const newVal = A[a][j] === 0 ? 1 : 0;\n            setEdge(a, j, newVal);\n          } else {\n            // If no edge, set weight 1, else open editor\n            if (A[a][j] === 0) setEdge(a, j, 1);\n            else openWeightEditorAtPoint(x, y, a, j, A[a][j], true);\n          }\n          renderMatrix(); renderGraph(); updateStats(); renderLists(); renderPower();\n        }\n      });\n    }\n\n    el.graphArea.appendChild(svg);\n  }\n\n  function openWeightEditorAtPoint(clientX, clientY, i, j, currentVal, localCoords = false) {\n    el.weightEditor.style.display = 'block';\n    const offsetX = 12, offsetY = 12;\n    if (!localCoords) {\n      el.weightEditor.style.left = `${clientX + window.scrollX + offsetX}px`;\n      el.weightEditor.style.top = `${clientY + window.scrollY + offsetY}px`;\n    } else {\n      el.weightEditor.style.left = `${clientX + offsetX}px`;\n      el.weightEditor.style.top = `${clientY + offsetY}px`;\n    }\n    el.weightInput.value = currentVal || 1;\n    el.weightEdgeText.textContent = `${i} → ${j}`;\n    el.weightEditor.dataset.i = String(i);\n    el.weightEditor.dataset.j = String(j);\n  }\n\n  function computePositions(n, w, h, mode) {\n    const positions = [];\n    if (mode === 'circle') {\n      const cx = w / 2, cy = h / 2;\n      const R = Math.min(w, h) * 0.38;\n      for (let i = 0; i < n; i++) {\n        const theta = (2 * Math.PI * i) / n - Math.PI / 2;\n        const x = cx + R * Math.cos(theta);\n        const y = cy + R * Math.sin(theta);\n        positions.push([x, y]);\n      }\n    } else {\n      // grid layout\n      const cols = Math.ceil(Math.sqrt(n));\n      const rows = Math.ceil(n / cols);\n      const padX = 30, padY = 30;\n      const cellW = (w - padX * 2) / Math.max(cols, 1);\n      const cellH = (h - padY * 2) / Math.max(rows, 1);\n      for (let i = 0; i < n; i++) {\n        const r = Math.floor(i / cols);\n        const c = i % cols;\n        const x = padX + cellW * (c + 0.5);\n        const y = padY + cellH * (r + 0.5);\n        positions.push([x, y]);\n      }\n    }\n    return positions;\n  }\n\n  function updateStats() {\n    el.statN.textContent = String(n);\n    const m = countEdges();\n    el.statM.textContent = String(m);\n    const maxEdges = isDirected ? (allowLoops ? n * n : n * (n - 1)) : (allowLoops ? (n * (n - 1)) / 2 + n : (n * (n - 1)) / 2);\n    const density = maxEdges ? (m / maxEdges) : 0;\n    el.statD.textContent = density.toFixed(3);\n  }\n\n  function countEdges() {\n    let m = 0;\n    if (isDirected) {\n      for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n          if (A[i][j] !== 0) m++;\n        }\n      }\n    } else {\n      for (let i = 0; i < n; i++) {\n        for (let j = i; j < n; j++) {\n          if (A[i][j] !== 0) m++;\n        }\n      }\n    }\n    return m;\n  }\n\n  function renderLists() {\n    // Degree list\n    let lines = [];\n    if (!isDirected) {\n      for (let i = 0; i < n; i++) {\n        let deg = 0;\n        for (let j = 0; j < n; j++) {\n          if (A[i][j] !== 0) {\n            if (i === j) deg += allowLoops ? 2 : 0;\n            else deg += 1;\n          }\n        }\n        lines.push(`deg(${i}) = ${deg}`);\n      }\n    } else {\n      for (let i = 0; i < n; i++) {\n        let out = 0, in = 0;\n        for (let j = 0; j < n; j++) {\n          if (A[i][j] !== 0) out++;\n          if (A[j][i] !== 0) in++;\n        }\n        lines.push(`out(${i}) = ${out}, in(${i}) = ${in}`);\n      }\n    }\n    el.degreeList.textContent = lines.join('\\n');\n\n    // Adjacency list\n    const adjLines = [];\n    for (let i = 0; i < n; i++) {\n      const neighbors = [];\n      for (let j = 0; j < n; j++) {\n        const w = A[i][j];\n        if (w !== 0) {\n          neighbors.push(isWeighted ? `${j}(${w})` : `${j}`);\n        }\n      }\n      adjLines.push(`${i}: ${neighbors.join(', ')}`);\n    }\n    el.adjacencyList.textContent = adjLines.join('\\n');\n  }\n\n  function highlightRowCol(idx) {\n    // Matrix: add highlight outline and scroll into view\n    const table = el.matrixTable;\n    const rows = table.querySelectorAll('tbody tr');\n    if (rows[idx]) {\n      rows[idx].style.outline = '2px dashed #22d3ee';\n      setTimeout(() => { rows[idx].style.outline = ''; }, 1800);\n      rows[idx].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });\n    }\n    // Highlight column header\n    const headers = table.querySelectorAll('thead th');\n    if (headers[idx + 1]) {\n      headers[idx + 1].style.outline = '2px dashed #22d3ee';\n      setTimeout(() => { headers[idx + 1].style.outline = ''; }, 1800);\n    }\n    // Graph: flash node\n    flashNode(idx);\n  }\n\n  function flashNode(idx) {\n    const svg = el.graphArea.querySelector('svg');\n    if (!svg) return;\n    const circles = svg.querySelectorAll('circle');\n    if (!circles[idx]) return;\n    const node = circles[idx];\n    const orig = node.getAttribute('fill');\n    node.setAttribute('fill', '#22d3ee');\n    setTimeout(() => node.setAttribute('fill', '#1f6fe0'), 700);\n  }\n\n  function renderPower() {\n    const k = clamp(parseInt(el.powerK.value, 10) || 2, 2, 6);\n    const Ak = matrixPower(A, k);\n    const table = el.powerMatrix;\n    table.innerHTML = '';\n    const thead = document.createElement('thead');\n    const trh = document.createElement('tr');\n    const corner = document.createElement('th');\n    corner.textContent = `A^${k}`;\n    trh.appendChild(corner);\n    for (let j = 0; j < n; j++) {\n      const th = document.createElement('th');\n      th.textContent = j;\n      trh.appendChild(th);\n    }\n    thead.appendChild(trh);\n    table.appendChild(thead);\n\n    const tbody = document.createElement('tbody');\n    for (let i = 0; i < n; i++) {\n      const tr = document.createElement('tr');\n      const th = document.createElement('th');\n      th.textContent = i;\n      tr.appendChild(th);\n      for (let j = 0; j < n; j++) {\n        const td = document.createElement('td');\n        td.textContent = String(Ak[i][j]);\n        tr.appendChild(td);\n      }\n      tbody.appendChild(tr);\n    }\n    table.appendChild(tbody);\n  }\n\n  function matrixMultiply(X, Y) {\n    const size = X.length;\n    const Z = createZeroMatrix(size);\n    for (let i = 0; i < size; i++) {\n      for (let k = 0; k < size; k++) {\n        const xik = X[i][k];\n        if (xik === 0) continue;\n        for (let j = 0; j < size; j++) {\n          const ykj = Y[k][j];\n          if (ykj === 0) continue;\n          Z[i][j] += xik * ykj;\n        }\n      }\n    }\n    return Z;\n  }\n\n  function matrixPower(M, k) {\n    let R = copyMatrix(M);\n    for (let i = 1; i < k; i++) {\n      R = matrixMultiply(R, M);\n    }\n    return R;\n  }\n\n  function copyMatrix(M) {\n    const size = M.length;\n    const C = new Array(size);\n    for (let i = 0; i < size; i++) C[i] = M[i].slice();\n    return C;\n  }\n\n  // Start\n  init();\n\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Adjacency Matrix"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "1c7c89b0-a36a-11f0-8f6d-87f23e3be7c6",
    "timestamp": "2025-10-07T10:40:58.827Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Adjacency List",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Adjacency List Graph Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f172a;\n      --panel: #111827;\n      --panel-2: #0b1220;\n      --text: #e5e7eb;\n      --muted: #9ca3af;\n      --accent: #38bdf8;\n      --accent-2: #34d399;\n      --danger: #ef4444;\n      --warn: #f59e0b;\n      --edge: #93c5fd;\n      --node: #60a5fa;\n      --visited: #a78bfa;\n      --queue: #f87171;\n      --neighbor: #34d399;\n    }\n    * { box-sizing: border-box; }\n    html, body {\n      height: 100%;\n      margin: 0;\n      background: radial-gradient(1000px 500px at 10% 10%, #0b1220, var(--bg));\n      color: var(--text);\n      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;\n    }\n    header {\n      padding: 16px 20px;\n      border-bottom: 1px solid #1f2937;\n      display: flex;\n      align-items: center;\n      gap: 16px;\n    }\n    header h1 {\n      margin: 0;\n      font-size: 20px;\n      letter-spacing: 0.4px;\n    }\n    header .sub {\n      color: var(--muted);\n      font-size: 12px;\n    }\n    main {\n      display: grid;\n      grid-template-columns: 360px 1fr;\n      gap: 16px;\n      padding: 16px;\n      height: calc(100% - 66px);\n    }\n    .panel {\n      background: linear-gradient(180deg, var(--panel), var(--panel-2));\n      border: 1px solid #1f2937;\n      border-radius: 12px;\n      padding: 12px;\n      box-shadow: 0 20px 60px rgba(0,0,0,0.25);\n      overflow: hidden;\n    }\n    .panel h2 {\n      font-size: 14px;\n      margin: 8px 0 10px;\n      color: var(--muted);\n      letter-spacing: 0.3px;\n    }\n    .controls {\n      display: grid;\n      grid-template-columns: 1fr;\n      gap: 12px;\n      overflow-y: auto;\n      max-height: calc(100% - 12px);\n      padding-right: 4px;\n    }\n    .group {\n      border: 1px dashed #243244;\n      border-radius: 10px;\n      padding: 10px;\n      background: rgba(20, 30, 46, 0.5);\n    }\n    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }\n    label {\n      font-size: 12px;\n      color: var(--muted);\n      display: block;\n      margin-bottom: 6px;\n    }\n    input, select, button {\n      width: 100%;\n      padding: 8px 10px;\n      border-radius: 8px;\n      border: 1px solid #243244;\n      background: #0e1524;\n      color: var(--text);\n      outline: none;\n    }\n    input::placeholder { color: #6b7280; }\n    input[type=\"number\"] { appearance: textfield; }\n    .row button { margin-top: 22px; }\n    .btn {\n      border: 1px solid #243244;\n      background: #0e1524;\n      cursor: pointer;\n      transition: transform 0.05s ease, background 0.2s ease, border 0.2s ease;\n    }\n    .btn:hover { background: #0b1220; }\n    .btn:active { transform: translateY(1px); }\n    .btn.primary { background: #0e1a30; border-color: #214b72; }\n    .btn.accent { background: #0c2430; border-color: #2563eb; }\n    .btn.warn { background: #231a07; border-color: #f59e0b; }\n    .btn.danger { background: #2b0d0f; border-color: #ef4444; }\n    .inline { display: flex; gap: 8px; align-items: center; }\n    .toggle { display: inline-flex; align-items: center; gap: 8px; }\n    .toggle input { width: auto; }\n    .adj {\n      background: #0b1220;\n      border-radius: 8px;\n      border: 1px solid #243244;\n      padding: 10px;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;\n      font-size: 12px;\n      white-space: pre;\n      overflow: auto;\n      max-height: 220px;\n    }\n    .legend {\n      display: flex; gap: 10px; flex-wrap: wrap;\n      font-size: 12px; color: var(--muted);\n      margin-top: 8px;\n    }\n    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; }\n    .dot.node { background: var(--node); }\n    .dot.edge { background: var(--edge); }\n    .dot.visited { background: var(--visited); }\n    .dot.queue { background: var(--queue); }\n    .dot.neighbor { background: var(--neighbor); }\n    #graphPanel {\n      position: relative;\n      display: grid;\n      grid-template-rows: auto 1fr 160px;\n      gap: 8px;\n      min-height: 480px;\n    }\n    #svgWrap {\n      position: relative;\n      border: 1px dashed #243244;\n      border-radius: 10px;\n      background:\n        radial-gradient(600px 200px at 70% 30%, rgba(56,189,248,0.05), transparent),\n        linear-gradient(180deg, rgba(18,25,39,0.95), rgba(13,19,31,0.9));\n      overflow: hidden;\n    }\n    svg { width: 100%; height: 100%; display: block; }\n    .node {\n      cursor: pointer;\n      transition: filter 0.2s ease;\n    }\n    .node circle {\n      fill: rgba(96,165,250,0.2);\n      stroke: var(--node);\n      stroke-width: 2;\n    }\n    .node text {\n      font-size: 12px;\n      fill: var(--text);\n      pointer-events: none;\n      user-select: none;\n    }\n    .node.highlight circle { stroke: var(--neighbor); fill: rgba(52,211,153,0.15); }\n    .node.visited circle { stroke: var(--visited); fill: rgba(167,139,250,0.15); }\n    .node.in-queue circle { stroke: var(--queue); fill: rgba(248,113,113,0.12); }\n    .edge {\n      stroke: var(--edge);\n      stroke-width: 2;\n      opacity: 0.9;\n    }\n    .edge.undirected { stroke-dasharray: 2 2; opacity: 0.8; }\n    .edge.highlight { stroke: var(--neighbor); }\n    .edge.visited { stroke: var(--visited); }\n    .weight {\n      font-size: 11px;\n      fill: #e5e7eb;\n      opacity: 0.8;\n      pointer-events: none;\n      user-select: none;\n    }\n    .hint {\n      font-size: 12px;\n      color: var(--muted);\n    }\n    .bfs {\n      display: grid; grid-template-columns: 1fr 1fr; gap: 8px;\n    }\n    .bpanel {\n      border: 1px dashed #243244;\n      border-radius: 10px;\n      padding: 10px;\n      background: rgba(20,30,46,0.5);\n    }\n    .bpanel h3 {\n      margin: 0 0 8px; font-size: 13px; color: var(--muted);\n    }\n    .bcontent {\n      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;\n      font-size: 12px;\n      white-space: pre-wrap;\n      line-height: 1.4;\n      color: var(--text);\n      min-height: 80px;\n    }\n    .footer {\n      font-size: 12px;\n      color: var(--muted);\n      padding: 6px 10px;\n      border-top: 1px solid #1f2937;\n    }\n    .small { font-size: 11px; color: var(--muted); }\n    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }\n    .grid3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }\n    .inline-hint { font-size: 11px; color: var(--muted); margin-top: 6px; }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Adjacency List</h1>\n    <div class=\"sub\">Build a graph, see its adjacency list, and watch BFS traverse using it</div>\n  </header>\n\n  <main>\n    <div class=\"panel\">\n      <h2>Graph Builder</h2>\n      <div class=\"controls\">\n        <div class=\"group\">\n          <label>Quick add</label>\n          <div class=\"inline\">\n            <button id=\"add3\" class=\"btn\">Add 3 nodes</button>\n            <button id=\"add5\" class=\"btn\">Add 5 nodes</button>\n            <button id=\"randomGraph\" class=\"btn\">Random graph</button>\n          </div>\n          <div class=\"inline-hint\">Use quick add or create nodes/edges below. Right-click nodes/edges to remove.</div>\n        </div>\n\n        <div class=\"group\">\n          <div class=\"row\">\n            <div>\n              <label>Node label</label>\n              <input id=\"nodeLabel\" type=\"text\" placeholder=\"e.g., A\" />\n            </div>\n            <div>\n              <button id=\"addNodeBtn\" class=\"btn primary\">Add node</button>\n            </div>\n          </div>\n          <div class=\"inline small\">Nodes get random positions; drag to rearrange.</div>\n        </div>\n\n        <div class=\"group\">\n          <div class=\"row\">\n            <div>\n              <label>From</label>\n              <select id=\"edgeFrom\"></select>\n            </div>\n            <div>\n              <label>To</label>\n              <select id=\"edgeTo\"></select>\n            </div>\n          </div>\n          <div class=\"grid3\" style=\"margin-top:8px\">\n            <div class=\"toggle\">\n              <input id=\"edgeDirected\" type=\"checkbox\" checked />\n              <label for=\"edgeDirected\">Directed</label>\n            </div>\n            <div>\n              <label>Weight (optional)</label>\n              <input id=\"edgeWeight\" type=\"number\" min=\"0\" placeholder=\"e.g., 1\" />\n            </div>\n            <div>\n              <button id=\"addEdgeBtn\" class=\"btn accent\">Add edge</button>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"group\">\n          <div class=\"grid2\">\n            <button id=\"clearBtn\" class=\"btn danger\">Clear graph</button>\n            <button id=\"recenterBtn\" class=\"btn\">Recenter nodes</button>\n          </div>\n          <div class=\"legend\">\n            <span><span class=\"dot node\"></span>Node</span>\n            <span><span class=\"dot edge\"></span>Edge</span>\n            <span><span class=\"dot neighbor\"></span>Neighbors</span>\n            <span><span class=\"dot visited\"></span>BFS visited</span>\n            <span><span class=\"dot queue\"></span>BFS queue</span>\n          </div>\n        </div>\n\n        <div class=\"group\">\n          <h2>Adjacency List</h2>\n          <div id=\"adjacency\" class=\"adj\"></div>\n          <div class=\"inline small\">Click a node to highlight its neighbors.</div>\n        </div>\n\n        <div class=\"group\">\n          <h2>Breadth-First Search (uses adj. list)</h2>\n          <div class=\"grid3\">\n            <div>\n              <label>Start</label>\n              <select id=\"bfsStart\"></select>\n            </div>\n            <div>\n              <label>Target (optional)</label>\n              <select id=\"bfsTarget\"></select>\n            </div>\n            <div class=\"inline\">\n              <button id=\"bfsRun\" class=\"btn primary\">Run</button>\n              <button id=\"bfsStep\" class=\"btn\">Step</button>\n              <button id=\"bfsPlay\" class=\"btn\">Auto</button>\n            </div>\n          </div>\n          <div class=\"bfs\" style=\"margin-top:8px\">\n            <div class=\"bpanel\">\n              <h3>Queue</h3>\n              <div id=\"bfsQueue\" class=\"bcontent\"></div>\n            </div>\n            <div class=\"bpanel\">\n              <h3>Visited</h3>\n              <div id=\"bfsVisited\" class=\"bcontent\"></div>\n            </div>\n          </div>\n          <div class=\"bpanel\" style=\"margin-top:8px\">\n            <h3>Steps</h3>\n            <div id=\"bfsSteps\" class=\"bcontent\"></div>\n          </div>\n        </div>\n      </div>\n      <div class=\"footer\">Adjacency list stores each node's neighbors, enabling efficient traversal. Directed edges list only forward neighbors; undirected list both ways.</div>\n    </div>\n\n    <div id=\"graphPanel\" class=\"panel\">\n      <h2>Graph Visualization</h2>\n      <div id=\"svgWrap\">\n        <svg id=\"svg\" viewBox=\"0 0 800 520\" preserveAspectRatio=\"xMidYMid meet\">\n          <defs>\n            <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"8\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\">\n              <path d=\"M0,0 L9,3 L0,6 Z\" fill=\"#93c5fd\" />\n            </marker>\n            <marker id=\"arrowH\" markerWidth=\"10\" markerHeight=\"10\" refX=\"8\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\">\n              <path d=\"M0,0 L9,3 L0,6 Z\" fill=\"#34d399\" />\n            </marker>\n            <marker id=\"arrowV\" markerWidth=\"10\" markerHeight=\"10\" refX=\"8\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\">\n              <path d=\"M0,0 L9,3 L0,6 Z\" fill=\"#a78bfa\" />\n            </marker>\n          </defs>\n          <g id=\"edges\"></g>\n          <g id=\"weights\"></g>\n          <g id=\"nodes\"></g>\n        </svg>\n      </div>\n      <div class=\"hint\">Hints: Drag nodes to reposition. Click a node to highlight its neighbors from the adjacency list. Right-click nodes or edges to delete. Directed edges show arrowheads; undirected edges are dashed.</div>\n    </div>\n  </main>\n\n  <script>\n    // Graph state\n    const state = {\n      nodes: [], // {id, label, x, y}\n      edges: [], // {from, to, weight, directed}\n      nextId: 1,\n      labelAlphabetIndex: 0,\n      adjacency: new Map(), // label -> [{to, weight}]\n      dragging: null,\n      bfs: {\n        steps: [],\n        i: 0,\n        playing: false,\n        timer: null,\n      }\n    };\n\n    const svg = document.getElementById('svg');\n    const gEdges = document.getElementById('edges');\n    const gWeights = document.getElementById('weights');\n    const gNodes = document.getElementById('nodes');\n\n    const nodeLabelInput = document.getElementById('nodeLabel');\n    const addNodeBtn = document.getElementById('addNodeBtn');\n\n    const edgeFrom = document.getElementById('edgeFrom');\n    const edgeTo = document.getElementById('edgeTo');\n    const edgeDirected = document.getElementById('edgeDirected');\n    const edgeWeight = document.getElementById('edgeWeight');\n    const addEdgeBtn = document.getElementById('addEdgeBtn');\n\n    const add3Btn = document.getElementById('add3');\n    const add5Btn = document.getElementById('add5');\n    const randomGraphBtn = document.getElementById('randomGraph');\n    const clearBtn = document.getElementById('clearBtn');\n    const recenterBtn = document.getElementById('recenterBtn');\n\n    const adjacencyDiv = document.getElementById('adjacency');\n\n    const bfsStartSel = document.getElementById('bfsStart');\n    const bfsTargetSel = document.getElementById('bfsTarget');\n    const bfsRunBtn = document.getElementById('bfsRun');\n    const bfsStepBtn = document.getElementById('bfsStep');\n    const bfsPlayBtn = document.getElementById('bfsPlay');\n    const bfsQueueDiv = document.getElementById('bfsQueue');\n    const bfsVisitedDiv = document.getElementById('bfsVisited');\n    const bfsStepsDiv = document.getElementById('bfsSteps');\n\n    // Utility\n    const randBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n    const idToLabel = new Map();\n    const labelToId = new Map();\n    const getNodeById = id => state.nodes.find(n => n.id === id);\n    const getNodeByLabel = label => getNodeById(labelToId.get(label));\n    const ensureUniqueLabel = (base) => {\n      let label = (base || nextAlpha()) || nextAlpha();\n      let i = 1;\n      while (labelToId.has(label)) {\n        label = `${base}${i++}`;\n      }\n      return label;\n    };\n    function nextAlpha() {\n      const i = state.labelAlphabetIndex++;\n      const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n      const len = letters.length;\n      let label = \"\";\n      let n = i;\n      do {\n        label = letters[n % len] + label;\n        n = Math.floor(n / len) - 1;\n      } while (n >= 0);\n      return label;\n    }\n    function clamp(val, min, max) { return Math.min(Math.max(val, min), max); }\n\n    // Core: Adjacency list\n    function rebuildAdjacency() {\n      state.adjacency = new Map();\n      for (const n of state.nodes) {\n        state.adjacency.set(n.label, []);\n      }\n      for (const e of state.edges) {\n        const fromLabel = idToLabel.get(e.from);\n        const toLabel = idToLabel.get(e.to);\n        if (!state.adjacency.has(fromLabel)) state.adjacency.set(fromLabel, []);\n        state.adjacency.get(fromLabel).push({ to: toLabel, weight: e.weight });\n\n        if (!e.directed) {\n          if (!state.adjacency.has(toLabel)) state.adjacency.set(toLabel, []);\n          state.adjacency.get(toLabel).push({ to: fromLabel, weight: e.weight });\n        }\n      }\n      renderAdjacency();\n      updateNodeSelects();\n    }\n\n    function renderAdjacency() {\n      let out = [];\n      const entries = Array.from(state.adjacency.entries()).sort((a, b) => a[0].localeCompare(b[0]));\n      for (const [label, neighbors] of entries) {\n        const ns = neighbors\n          .map(n => n.weight != null && n.weight !== \"\" ? `${n.to}(${n.weight})` : n.to)\n          .sort((a, b) => a.localeCompare(b))\n          .join(\", \");\n        out.push(`${label}: ${ns || \"(none)\"}`);\n      }\n      adjacencyDiv.textContent = out.length ? out.join(\"\\n\") : \"Adjacency list is empty. Add nodes and edges.\";\n    }\n\n    // Rendering graph\n    function render() {\n      // Edges\n      gEdges.innerHTML = \"\";\n      gWeights.innerHTML = \"\";\n      for (let i = 0; i < state.edges.length; i++) {\n        const e = state.edges[i];\n        const a = getNodeById(e.from);\n        const b = getNodeById(e.to);\n        if (!a || !b) continue;\n\n        const { x: x1, y: y1 } = a;\n        const { x: x2, y: y2 } = b;\n\n        const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n        line.setAttribute(\"x1\", x1);\n        line.setAttribute(\"y1\", y1);\n        line.setAttribute(\"x2\", x2);\n        line.setAttribute(\"y2\", y2);\n        line.classList.add(\"edge\");\n        if (!e.directed) line.classList.add(\"undirected\");\n        if (e.directed) line.setAttribute(\"marker-end\", \"url(#arrow)\");\n        line.dataset.index = i;\n\n        // Right-click to delete edge\n        line.addEventListener(\"contextmenu\", (ev) => {\n          ev.preventDefault();\n          state.edges.splice(i, 1);\n          rebuildAdjacency();\n          render();\n        });\n\n        gEdges.appendChild(line);\n\n        // Weight label at midpoint\n        if (e.weight != null && e.weight !== \"\") {\n          const mx = (x1 + x2) / 2;\n          const my = (y1 + y2) / 2;\n          const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n          text.setAttribute(\"x\", mx + 8);\n          text.setAttribute(\"y\", my - 4);\n          text.classList.add(\"weight\");\n          text.textContent = e.weight;\n          gWeights.appendChild(text);\n        }\n      }\n\n      // Nodes\n      gNodes.innerHTML = \"\";\n      for (const n of state.nodes) {\n        const group = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n        group.classList.add(\"node\");\n        group.setAttribute(\"data-id\", n.id);\n        group.setAttribute(\"transform\", `translate(${n.x}, ${n.y})`);\n\n        const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n        circle.setAttribute(\"r\", 16);\n        circle.setAttribute(\"cx\", 0);\n        circle.setAttribute(\"cy\", 0);\n\n        const label = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n        label.setAttribute(\"text-anchor\", \"middle\");\n        label.setAttribute(\"alignment-baseline\", \"middle\");\n        label.textContent = n.label;\n\n        group.appendChild(circle);\n        group.appendChild(label);\n\n        // Dragging\n        group.addEventListener(\"mousedown\", (ev) => {\n          if (ev.button !== 0) return;\n          state.dragging = { id: n.id, offsetX: ev.offsetX - n.x, offsetY: ev.offsetY - n.y };\n        });\n        svg.addEventListener(\"mousemove\", (ev) => {\n          if (!state.dragging) return;\n          const rect = svg.getBoundingClientRect();\n          const x = clamp(ev.clientX - rect.left - state.dragging.offsetX, 16, rect.width - 16);\n          const y = clamp(ev.clientY - rect.top - state.dragging.offsetY, 16, rect.height - 16);\n          const node = getNodeById(state.dragging.id);\n          node.x = x; node.y = y;\n          render();\n        });\n        svg.addEventListener(\"mouseup\", () => { state.dragging = null; });\n        svg.addEventListener(\"mouseleave\", () => { state.dragging = null; });\n\n        // Click to highlight neighbors\n        group.addEventListener(\"click\", () => {\n          highlightNeighbors(n.label);\n        });\n\n        // Right-click to delete node\n        group.addEventListener(\"contextmenu\", (ev) => {\n          ev.preventDefault();\n          removeNode(n.id);\n        });\n\n        gNodes.appendChild(group);\n      }\n    }\n\n    function highlightNeighbors(label) {\n      const neighbors = (state.adjacency.get(label) || []).map(n => n.to);\n      const neighborIds = new Set(neighbors.map(l => labelToId.get(l)));\n\n      // reset classes\n      for (const g of Array.from(gNodes.children)) {\n        g.classList.remove(\"highlight\");\n      }\n      for (const edge of Array.from(gEdges.children)) {\n        edge.classList.remove(\"highlight\");\n        // adjust marker color back to default arrow\n        if (edge.getAttribute(\"marker-end\")) edge.setAttribute(\"marker-end\", \"url(#arrow)\");\n      }\n\n      // highlight selected and neighbors\n      const selId = labelToId.get(label);\n      for (const g of Array.from(gNodes.children)) {\n        const id = Number(g.getAttribute(\"data-id\"));\n        if (id === selId || neighborIds.has(id)) {\n          g.classList.add(\"highlight\");\n        }\n      }\n\n      // highlight edges from selected to neighbors\n      for (let i = 0; i < state.edges.length; i++) {\n        const e = state.edges[i];\n        if (e.from === selId && neighborIds.has(e.to)) {\n          const edgeEl = gEdges.querySelector(`[data-index=\"${i}\"]`);\n          if (edgeEl) {\n            edgeEl.classList.add(\"highlight\");\n            if (e.directed) edgeEl.setAttribute(\"marker-end\", \"url(#arrowH)\");\n          }\n        }\n        if (!getEdgeDirected(e) && e.to === selId && neighborIds.has(e.from)) {\n          const edgeEl = gEdges.querySelector(`[data-index=\"${i}\"]`);\n          if (edgeEl) edgeEl.classList.add(\"highlight\");\n        }\n      }\n    }\n\n    // Graph modification\n    function addNode(customLabel) {\n      const label = ensureUniqueLabel(customLabel && customLabel.trim() ? customLabel.trim().toUpperCase() : nextAlpha());\n      const id = state.nextId++;\n      // Random position within SVG viewbox\n      const rect = svg.getBoundingClientRect();\n      const x = randBetween(40, rect.width - 40);\n      const y = randBetween(40, rect.height - 180); // leave space for BFS panel\n      const node = { id, label, x, y };\n      state.nodes.push(node);\n      idToLabel.set(id, label);\n      labelToId.set(label, id);\n      rebuildAdjacency();\n      render();\n    }\n\n    function removeNode(id) {\n      const label = idToLabel.get(id);\n      // Remove edges connected\n      state.edges = state.edges.filter(e => e.from !== id && e.to !== id);\n      // Remove node\n      state.nodes = state.nodes.filter(n => n.id !== id);\n      idToLabel.delete(id);\n      labelToId.delete(label);\n      rebuildAdjacency();\n      render();\n    }\n\n    function addEdge(fromLabel, toLabel, weight, directed) {\n      const fromId = labelToId.get(fromLabel);\n      const toId = labelToId.get(toLabel);\n      if (fromId == null || toId == null) return;\n      if (fromId === toId) return; // no self-loop in this simple demo\n      // prevent duplicates of exact same directed edge\n      const exists = state.edges.some(e => e.from === fromId && e.to === toId && e.directed === directed && e.weight == weight);\n      if (exists) return;\n      state.edges.push({ from: fromId, to: toId, weight: weight ?? \"\", directed: !!directed });\n      rebuildAdjacency();\n      render();\n    }\n\n    function getEdgeDirected(e) { return !!e.directed; }\n\n    function populateSelect(sel, labels) {\n      sel.innerHTML = \"\";\n      for (const label of labels) {\n        const opt = document.createElement(\"option\");\n        opt.value = label;\n        opt.textContent = label;\n        sel.appendChild(opt);\n      }\n    }\n\n    function updateNodeSelects() {\n      const labels = state.nodes.map(n => n.label).sort((a,b) => a.localeCompare(b));\n      populateSelect(edgeFrom, labels);\n      populateSelect(edgeTo, labels);\n      populateSelect(bfsStartSel, labels);\n      const targetLabels = [\"(none)\", ...labels];\n      bfsTargetSel.innerHTML = \"\";\n      for (const label of targetLabels) {\n        const opt = document.createElement(\"option\");\n        opt.value = label === \"(none)\" ? \"\" : label;\n        opt.textContent = label;\n        bfsTargetSel.appendChild(opt);\n      }\n    }\n\n    function recenterNodes() {\n      const rect = svg.getBoundingClientRect();\n      const cx = rect.width / 2;\n      const cy = rect.height / 2 - 40;\n      const r = Math.min(rect.width, rect.height) / 3;\n      const N = state.nodes.length;\n      state.nodes.forEach((n, i) => {\n        const angle = (i / N) * Math.PI * 2;\n        n.x = cx + r * Math.cos(angle);\n        n.y = cy + r * Math.sin(angle);\n      });\n      render();\n    }\n\n    function randomGraph() {\n      clearGraph();\n      const count = randBetween(4, 7);\n      for (let i = 0; i < count; i++) addNode();\n      const labels = state.nodes.map(n => n.label);\n      const m = randBetween(count, count * 2);\n      for (let i = 0; i < m; i++) {\n        const a = labels[randBetween(0, labels.length - 1)];\n        let b = labels[randBetween(0, labels.length - 1)];\n        if (a === b) continue;\n        const directed = Math.random() < 0.6;\n        const w = Math.random() < 0.5 ? randBetween(1, 9) : \"\";\n        addEdge(a, b, w, directed);\n      }\n      recenterNodes();\n    }\n\n    function clearGraph() {\n      state.nodes = [];\n      state.edges = [];\n      state.nextId = 1;\n      state.labelAlphabetIndex = 0;\n      idToLabel.clear();\n      labelToId.clear();\n      rebuildAdjacency();\n      render();\n      resetBFS();\n    }\n\n    // BFS demonstration using adjacency list\n    function bfsBuildSteps(startLabel, targetLabel) {\n      if (!startLabel) return [];\n      const adj = state.adjacency;\n      const visited = new Set();\n      const queue = [];\n      const parents = new Map();\n\n      queue.push(startLabel);\n      visited.add(startLabel);\n      const steps = [];\n      steps.push({ type: \"init\", queue: [...queue], visited: [...visited], note: `Start at ${startLabel}` });\n\n      while (queue.length) {\n        const current = queue.shift();\n        steps.push({ type: \"dequeue\", node: current, queue: [...queue], visited: [...visited], note: `Dequeue ${current}` });\n\n        if (targetLabel && current === targetLabel) {\n          steps.push({ type: \"found\", node: current, queue: [...queue], visited: [...visited], note: `Found target ${current}` });\n          break;\n        }\n\n        const neighbors = (adj.get(current) || []).map(n => n.to).sort((a,b) => a.localeCompare(b));\n        steps.push({ type: \"neighbors\", node: current, neighbors, queue: [...queue], visited: [...visited], note: `Neighbors of ${current}: ${neighbors.join(\", \") || \"(none)\"}` });\n\n        for (const nb of neighbors) {\n          if (!visited.has(nb)) {\n            visited.add(nb);\n            parents.set(nb, current);\n            queue.push(nb);\n            steps.push({ type: \"enqueue\", node: nb, from: current, queue: [...queue], visited: [...visited], note: `Visit ${nb} (from ${current}) and enqueue` });\n          } else {\n            steps.push({ type: \"skip\", node: nb, from: current, queue: [...queue], visited: [...visited], note: `Skip ${nb} (already visited)` });\n          }\n        }\n      }\n\n      if (targetLabel && !steps.some(s => s.type === \"found\")) {\n        steps.push({ type: \"notfound\", node: targetLabel, note: `Target ${targetLabel} not reachable from ${startLabel}` });\n      }\n\n      // Add path reconstruction step if found\n      if (steps.some(s => s.type === \"found\")) {\n        const path = [];\n        let cur = targetLabel || startLabel;\n        while (cur != null) {\n          path.unshift(cur);\n          cur = parents.get(cur);\n          if (cur === startLabel && targetLabel) { path.unshift(cur); break; }\n        }\n        steps.push({ type: \"path\", path, note: `Path: ${path.join(\" -> \")}` });\n      }\n      return steps;\n    }\n\n    function resetBFS() {\n      state.bfs.steps = [];\n      state.bfs.i = 0;\n      stopAuto();\n      bfsQueueDiv.textContent = \"\";\n      bfsVisitedDiv.textContent = \"\";\n      bfsStepsDiv.textContent = \"\";\n      // Clear BFS highlights\n      for (const g of Array.from(gNodes.children)) {\n        g.classList.remove(\"visited\", \"in-queue\");\n      }\n      for (const e of Array.from(gEdges.children)) {\n        e.classList.remove(\"visited\");\n        if (e.getAttribute(\"marker-end\")) e.setAttribute(\"marker-end\", \"url(#arrow)\");\n      }\n    }\n\n    function applyBFSVisual(step) {\n      // Update queue/visited text\n      bfsQueueDiv.textContent = (step.queue || []).join(\"  \");\n      bfsVisitedDiv.textContent = (step.visited || []).join(\"  \");\n      bfsStepsDiv.textContent += (bfsStepsDiv.textContent ? \"\\n\" : \"\") + (step.note || \"\");\n\n      // Visual states for nodes\n      const queueSet = new Set(step.queue || []);\n      const visitedSet = new Set(step.visited || []);\n      for (const g of Array.from(gNodes.children)) {\n        const label = idToLabel.get(Number(g.getAttribute(\"data-id\")));\n        g.classList.toggle(\"visited\", visitedSet.has(label));\n        g.classList.toggle(\"in-queue\", queueSet.has(label));\n      }\n\n      // Highlight current dequeue node\n      if (step.type === \"dequeue\" || step.type === \"neighbors\") {\n        const current = step.node;\n        const id = labelToId.get(current);\n        const g = gNodes.querySelector(`[data-id=\"${id}\"]`);\n        if (g) {\n          g.classList.add(\"visited\");\n        }\n      }\n\n      // Highlight edges used when enqueue\n      if (step.type === \"enqueue\" || step.type === \"skip\") {\n        const fromId = labelToId.get(step.from);\n        const toId = labelToId.get(step.node);\n        for (let i = 0; i < state.edges.length; i++) {\n          const e = state.edges[i];\n          const edgeEl = gEdges.querySelector(`[data-index=\"${i}\"]`);\n          if (!edgeEl) continue;\n          if (e.from === fromId && e.to === toId) {\n            edgeEl.classList.add(\"visited\");\n            edgeEl.setAttribute(\"marker-end\", \"url(#arrowV)\");\n          } else if (!getEdgeDirected(e) && e.to === fromId && e.from === toId) {\n            edgeEl.classList.add(\"visited\");\n          }\n        }\n      }\n    }\n\n    function runBFS() {\n      resetBFS();\n      const start = bfsStartSel.value;\n      const target = bfsTargetSel.value || \"\";\n      if (!start) return;\n      state.bfs.steps = bfsBuildSteps(start, target);\n      state.bfs.i = 0;\n      if (!state.bfs.steps.length) return;\n      const s0 = state.bfs.steps[state.bfs.i++];\n      applyBFSVisual(s0);\n    }\n\n    function stepBFS() {\n      if (!state.bfs.steps.length) return;\n      if (state.bfs.i >= state.bfs.steps.length) return;\n      const s = state.bfs.steps[state.bfs.i++];\n      applyBFSVisual(s);\n    }\n\n    function stopAuto() {\n      state.bfs.playing = false;\n      if (state.bfs.timer) {\n        clearInterval(state.bfs.timer);\n        state.bfs.timer = null;\n      }\n      bfsPlayBtn.textContent = \"Auto\";\n    }\n\n    function playBFS() {\n      if (!state.bfs.steps.length) return;\n      if (state.bfs.playing) {\n        stopAuto();\n        return;\n      }\n      state.bfs.playing = true;\n      bfsPlayBtn.textContent = \"Pause\";\n      state.bfs.timer = setInterval(() => {\n        if (state.bfs.i >= state.bfs.steps.length) {\n          stopAuto();\n        } else {\n          stepBFS();\n        }\n      }, 700);\n    }\n\n    // Event bindings\n    addNodeBtn.addEventListener(\"click\", () => {\n      addNode(nodeLabelInput.value);\n      nodeLabelInput.value = \"\";\n    });\n    addEdgeBtn.addEventListener(\"click\", () => {\n      const from = edgeFrom.value;\n      const to = edgeTo.value;\n      const w = edgeWeight.value;\n      const directed = edgeDirected.checked;\n      addEdge(from, to, w, directed);\n    });\n    add3Btn.addEventListener(\"click\", () => {\n      for (let i = 0; i < 3; i++) addNode();\n      recenterNodes();\n    });\n    add5Btn.addEventListener(\"click\", () => {\n      for (let i = 0; i < 5; i++) addNode();\n      recenterNodes();\n    });\n    randomGraphBtn.addEventListener(\"click\", randomGraph);\n    clearBtn.addEventListener(\"click\", clearGraph);\n    recenterBtn.addEventListener(\"click\", recenterNodes);\n\n    bfsRunBtn.addEventListener(\"click\", runBFS);\n    bfsStepBtn.addEventListener(\"click\", stepBFS);\n    bfsPlayBtn.addEventListener(\"click\", playBFS);\n\n    // Initialize\n    rebuildAdjacency();\n    render();\n\n    // Start with a small sample graph\n    for (let i = 0; i < 4; i++) addNode();\n    addEdge(state.nodes[0].label, state.nodes[1].label, \"\", true);\n    addEdge(state.nodes[0].label, state.nodes[2].label, 2, true);\n    addEdge(state.nodes[1].label, state.nodes[3].label, \"\", false);\n    recenterNodes();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Adjacency List"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "5dab8cb0-a36a-11f0-8d43-3dc39d4b951b",
    "timestamp": "2025-10-07T10:42:48.187Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Union-Find (Disjoint Set)",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Union-Find (Disjoint Set) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0e1116;\n      --panel: #161b22;\n      --accent: #3ea6ff;\n      --accent2: #7ce38b;\n      --text: #e6edf3;\n      --muted: #a6b3c3;\n      --danger: #ff6b6b;\n      --warn: #ffcc66;\n      --line: #8091a3;\n    }\n    * { box-sizing: border-box; }\n    html, body {\n      margin: 0;\n      height: 100%;\n      background: var(--bg);\n      color: var(--text);\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", sans-serif;\n    }\n    .app {\n      display: grid;\n      grid-template-rows: auto 1fr auto;\n      height: 100%;\n    }\n    header {\n      padding: 12px 16px;\n      background: var(--panel);\n      border-bottom: 1px solid #222a34;\n    }\n    header h1 {\n      margin: 0;\n      font-size: 18px;\n      font-weight: 600;\n      letter-spacing: 0.3px;\n    }\n    header p {\n      margin: 6px 0 0;\n      color: var(--muted);\n      font-size: 13px;\n    }\n    .controls {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 8px;\n      padding: 12px 16px;\n      background: #12161c;\n      border-bottom: 1px solid #222a34;\n      align-items: center;\n    }\n    .controls .group {\n      display: flex;\n      gap: 8px;\n      align-items: center;\n      flex-wrap: wrap;\n      background: #0f1318;\n      padding: 8px;\n      border-radius: 8px;\n      border: 1px solid #1e2631;\n    }\n    label {\n      font-size: 12px;\n      color: var(--muted);\n    }\n    input[type=\"number\"], input[type=\"text\"], select {\n      background: #0b0f14;\n      border: 1px solid #1e2631;\n      color: var(--text);\n      padding: 6px 8px;\n      border-radius: 6px;\n      outline: none;\n      font-size: 13px;\n      width: 80px;\n    }\n    input[type=\"checkbox\"] {\n      accent-color: var(--accent);\n      transform: translateY(1px);\n    }\n    button {\n      background: #182131;\n      border: 1px solid #28405e;\n      color: var(--text);\n      padding: 6px 10px;\n      border-radius: 8px;\n      cursor: pointer;\n      font-size: 13px;\n    }\n    button:hover { filter: brightness(1.1); }\n    button.primary {\n      background: #18364b;\n      border-color: #3ea6ff;\n      color: #cbe7ff;\n    }\n    button.danger {\n      background: #2e1414;\n      border-color: #803737;\n      color: #ffb3b3;\n    }\n    button.secondary {\n      background: #1e2a21;\n      border-color: #355c3b;\n      color: #cfeedd;\n    }\n    .legend {\n      margin-left: auto;\n      font-size: 12px;\n      color: var(--muted);\n    }\n\n    .stage {\n      position: relative;\n      overflow: hidden;\n      background: #0b0f14;\n    }\n    .svg-layer {\n      position: absolute;\n      inset: 0;\n      pointer-events: none;\n    }\n    .node-layer {\n      position: absolute;\n      inset: 0;\n    }\n    .node {\n      position: absolute;\n      width: 44px;\n      height: 44px;\n      border-radius: 999px;\n      border: 2px solid #334153;\n      background: #0f141a;\n      color: var(--text);\n      display: grid;\n      place-items: center;\n      font-weight: 600;\n      font-size: 14px;\n      cursor: pointer;\n      transition: box-shadow 120ms ease, border-color 120ms ease, transform 120ms ease, background 120ms ease;\n      user-select: none;\n    }\n    .node:hover {\n      box-shadow: 0 0 0 2px rgba(62, 166, 255, 0.25);\n      transform: translateY(-1px);\n    }\n    .node.root {\n      border-color: var(--accent2);\n      box-shadow: 0 0 0 2px rgba(124, 227, 139, 0.2);\n    }\n    .node.selected {\n      border-color: var(--accent);\n      box-shadow: 0 0 0 3px rgba(62, 166, 255, 0.35);\n    }\n    .node .sub {\n      position: absolute;\n      bottom: -18px;\n      left: 50%;\n      transform: translateX(-50%);\n      font-size: 11px;\n      color: var(--muted);\n      white-space: nowrap;\n    }\n    .node .badge {\n      position: absolute;\n      top: -10px;\n      right: -10px;\n      background: #15202b;\n      border: 1px solid #243648;\n      color: #c3d6e7;\n      padding: 2px 6px;\n      border-radius: 999px;\n      font-size: 10px;\n      letter-spacing: 0.2px;\n    }\n    .line {\n      stroke: var(--line);\n      stroke-width: 2;\n      opacity: 0.9;\n    }\n    .line.highlight {\n      stroke: var(--accent);\n      stroke-width: 4;\n      opacity: 1;\n      filter: drop-shadow(0 0 3px rgba(62, 166, 255, 0.5));\n    }\n    .note {\n      font-size: 12px;\n      color: var(--muted);\n      padding: 8px 16px;\n      border-top: 1px solid #222a34;\n      background: #11161c;\n    }\n    .log {\n      padding: 12px 16px;\n      border-top: 1px solid #222a34;\n      background: #0f1319;\n      max-height: 140px;\n      overflow: auto;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n      font-size: 12px;\n      line-height: 1.5;\n    }\n    .log div {\n      color: #cbd5e1;\n    }\n    .log .ok { color: #a7f3d0; }\n    .log .warn { color: #fde68a; }\n    .log .err { color: #fecaca; }\n    .footer {\n      font-size: 12px;\n      color: var(--muted);\n      padding: 10px 16px;\n      background: var(--panel);\n      border-top: 1px solid #222a34;\n      display: flex;\n      gap: 16px;\n      align-items: center;\n      flex-wrap: wrap;\n    }\n    .mode-toggle {\n      display: inline-flex;\n      border: 1px solid #28405e;\n      border-radius: 8px;\n      overflow: hidden;\n    }\n    .mode-toggle button {\n      border: none;\n      background: #142033;\n      padding: 6px 10px;\n    }\n    .mode-toggle button.active {\n      background: #1b2a42;\n      color: #cbe7ff;\n      outline: 1px solid #3ea6ff;\n    }\n    .color-dot {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      border-radius: 50%;\n      margin-right: 6px;\n      border: 1px solid #243648;\n      vertical-align: -1px;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <header>\n      <h1>Union-Find (Disjoint Set) Visualizer</h1>\n      <p>Interactively explore union by size and path compression. Click nodes to select, run Union/Find/Connected, and watch parent pointers update.</p>\n    </header>\n\n    <div class=\"controls\">\n      <div class=\"group\">\n        <label for=\"nodeCount\">Nodes</label>\n        <input id=\"nodeCount\" type=\"number\" min=\"2\" max=\"200\" value=\"12\" />\n        <button id=\"resetBtn\" class=\"primary\">Reset</button>\n        <button id=\"shuffleBtn\">Shuffle Layout</button>\n        <label>\n          <input id=\"compressionToggle\" type=\"checkbox\" checked />\n          Path Compression\n        </label>\n      </div>\n\n      <div class=\"group\">\n        <div class=\"mode-toggle\" role=\"tablist\" aria-label=\"Operation mode\">\n          <button id=\"modeUnion\" class=\"active\" aria-selected=\"true\">Union</button>\n          <button id=\"modeFind\">Find</button>\n          <button id=\"modeConnected\">Connected</button>\n        </div>\n        <span id=\"modeHint\" class=\"legend\">Select 2 nodes for Union</span>\n      </div>\n\n      <div class=\"group\">\n        <label>Manual</label>\n        <input id=\"inputA\" type=\"number\" placeholder=\"a\" min=\"0\" />\n        <input id=\"inputB\" type=\"number\" placeholder=\"b\" min=\"0\" />\n        <button id=\"btnUnion\">Union(a,b)</button>\n        <button id=\"btnFind\">Find(a)</button>\n        <button id=\"btnConnected\">Connected(a,b)</button>\n      </div>\n\n      <div class=\"group\">\n        <button id=\"btnRandomUnion\" class=\"secondary\">Random Union</button>\n        <button id=\"btnRandomOps\">Random Ops</button>\n        <button id=\"btnClearLog\">Clear Log</button>\n      </div>\n\n      <div class=\"legend\">\n        Roots are highlighted. Color indicates set (by root). Indexing is 0-based.\n      </div>\n    </div>\n\n    <div class=\"stage\" id=\"stage\">\n      <svg class=\"svg-layer\" id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\"></svg>\n      <div class=\"node-layer\" id=\"nodes\"></div>\n    </div>\n\n    <div class=\"note\">\n      Tips:\n      - Union by size attaches the smaller tree to the larger one, keeping the forest shallow.\n      - Path compression flattens the tree during find operations by making nodes point directly to the root.\n      - Click nodes to select; in Union mode, selecting any 2 runs a union. In Find mode, selecting 1 runs a find with compression visualization.\n    </div>\n\n    <div class=\"log\" id=\"log\" aria-live=\"polite\"></div>\n\n    <div class=\"footer\">\n      Visualization shows parent pointers as lines to their parent. Roots have no outgoing line. Colors are assigned per root. Resize the window to re-layout.\n      <span style=\"margin-left:auto\">Built-in: Union by size + optional path compression</span>\n    </div>\n  </div>\n\n  <script>\n    // Disjoint Set Union (Union-Find) with union by size and optional path compression\n    class DisjointSet {\n      constructor(n = 0, compress = true) {\n        this.compressEnabled = compress;\n        this.make(n);\n      }\n      make(n) {\n        this.n = n;\n        this.parent = Array.from({ length: n }, (_, i) => i);\n        this.size = Array.from({ length: n }, () => 1);\n      }\n      // Standard find with optional path compression\n      find(x) {\n        let root = x;\n        // Find root\n        while (this.parent[root] !== root) root = this.parent[root];\n        if (!this.compressEnabled) return root;\n        // Path compression\n        while (x !== root) {\n          const p = this.parent[x];\n          this.parent[x] = root;\n          x = p;\n        }\n        return root;\n      }\n      // Find without modifying structure, returning path for visualization\n      probeFind(x) {\n        const path = [];\n        let cur = x;\n        path.push(cur);\n        while (this.parent[cur] !== cur) {\n          cur = this.parent[cur];\n          path.push(cur);\n        }\n        return { root: cur, path };\n      }\n      compressPath(path, root) {\n        // Make every node in path point directly to root\n        for (const node of path) {\n          this.parent[node] = root;\n        }\n      }\n      union(a, b) {\n        if (!this.valid(a) || !this.valid(b)) return { merged: false, reason: 'invalid' };\n        let ra = this.find(a);\n        let rb = this.find(b);\n        if (ra === rb) return { merged: false, reason: 'same', root: ra };\n        // attach smaller to larger\n        if (this.size[ra] < this.size[rb]) {\n          const tmp = ra; ra = rb; rb = tmp;\n        }\n        this.parent[rb] = ra;\n        this.size[ra] += this.size[rb];\n        return { merged: true, aRoot: ra, bRoot: rb, newRoot: ra, sizes: { [ra]: this.size[ra] } };\n      }\n      connected(a, b) {\n        if (!this.valid(a) || !this.valid(b)) return { connected: false, reason: 'invalid' };\n        const ra = this.find(a), rb = this.find(b);\n        return { connected: ra === rb, ra, rb };\n      }\n      valid(x) { return Number.isInteger(x) && x >= 0 && x < this.n; }\n      // non-destructive root for rendering color\n      rootOfNoCompress(x) {\n        while (this.parent[x] !== x) x = this.parent[x];\n        return x;\n      }\n    }\n\n    // UI / Visualization\n    const stage = document.getElementById('stage');\n    const svg = document.getElementById('svg');\n    const nodesLayer = document.getElementById('nodes');\n    const logEl = document.getElementById('log');\n    const nodeCountInput = document.getElementById('nodeCount');\n    const resetBtn = document.getElementById('resetBtn');\n    const shuffleBtn = document.getElementById('shuffleBtn');\n    const compressionToggle = document.getElementById('compressionToggle');\n    const inputA = document.getElementById('inputA');\n    const inputB = document.getElementById('inputB');\n    const btnUnion = document.getElementById('btnUnion');\n    const btnFind = document.getElementById('btnFind');\n    const btnConnected = document.getElementById('btnConnected');\n    const btnRandomUnion = document.getElementById('btnRandomUnion');\n    const btnRandomOps = document.getElementById('btnRandomOps');\n    const btnClearLog = document.getElementById('btnClearLog');\n    const modeUnionBtn = document.getElementById('modeUnion');\n    const modeFindBtn = document.getElementById('modeFind');\n    const modeConnectedBtn = document.getElementById('modeConnected');\n    const modeHint = document.getElementById('modeHint');\n\n    let dsu = new DisjointSet(12, true);\n    let nodePositions = [];\n    let nodeEls = [];\n    let selected = new Set();\n    let opMode = 'Union'; // 'Union' | 'Find' | 'Connected'\n    let colorByRoot = new Map();\n\n    function setMode(mode) {\n      opMode = mode;\n      modeUnionBtn.classList.toggle('active', mode === 'Union');\n      modeFindBtn.classList.toggle('active', mode === 'Find');\n      modeConnectedBtn.classList.toggle('active', mode === 'Connected');\n      modeHint.textContent =\n        mode === 'Union' ? 'Select 2 nodes for Union' :\n        mode === 'Find' ? 'Select 1 node for Find (visualized)' :\n        'Select 2 nodes for Connected';\n      clearSelection();\n    }\n\n    modeUnionBtn.addEventListener('click', () => setMode('Union'));\n    modeFindBtn.addEventListener('click', () => setMode('Find'));\n    modeConnectedBtn.addEventListener('click', () => setMode('Connected'));\n\n    function log(msg, type = '') {\n      const div = document.createElement('div');\n      if (type) div.className = type;\n      div.textContent = msg;\n      logEl.appendChild(div);\n      logEl.scrollTop = logEl.scrollHeight;\n    }\n    function clearLog() { logEl.textContent = ''; }\n\n    function init(n) {\n      dsu.make(n);\n      dsu.compressEnabled = compressionToggle.checked;\n      nodesLayer.innerHTML = '';\n      svg.innerHTML = '';\n      nodeEls = [];\n      nodePositions = layoutCircle(n);\n      for (let i = 0; i < n; i++) {\n        const el = document.createElement('div');\n        el.className = 'node';\n        el.dataset.index = i;\n        el.style.left = (nodePositions[i].x - 22) + 'px';\n        el.style.top = (nodePositions[i].y - 22) + 'px';\n        el.textContent = String(i);\n        const sub = document.createElement('div');\n        sub.className = 'sub';\n        sub.textContent = '';\n        el.appendChild(sub);\n        const badge = document.createElement('div');\n        badge.className = 'badge';\n        badge.textContent = '';\n        el.appendChild(badge);\n        el.addEventListener('click', onNodeClick);\n        nodesLayer.appendChild(el);\n        nodeEls.push(el);\n      }\n      selected.clear();\n      render();\n      clearLog();\n      log(`Initialized ${n} nodes. All sets are singletons.`);\n    }\n\n    function layoutCircle(n) {\n      const rect = stage.getBoundingClientRect();\n      const cx = rect.width / 2;\n      const cy = rect.height / 2;\n      const R = Math.max(80, Math.min(cx, cy) - 40);\n      const pos = [];\n      for (let i = 0; i < n; i++) {\n        const t = (i / n) * Math.PI * 2;\n        pos.push({ x: cx + R * Math.cos(t), y: cy + R * Math.sin(t) });\n      }\n      return pos;\n    }\n\n    function shuffleLayout() {\n      // small random jitter\n      const rect = stage.getBoundingClientRect();\n      for (let i = 0; i < nodePositions.length; i++) {\n        const jitter = 40;\n        const x = Math.min(rect.width - 22, Math.max(22, nodePositions[i].x + (Math.random() * jitter - jitter/2)));\n        const y = Math.min(rect.height - 22, Math.max(22, nodePositions[i].y + (Math.random() * jitter - jitter/2)));\n        nodePositions[i] = { x, y };\n        nodeEls[i].style.left = (x - 22) + 'px';\n        nodeEls[i].style.top = (y - 22) + 'px';\n      }\n      renderLines();\n    }\n\n    function onNodeClick(e) {\n      const i = Number(e.currentTarget.dataset.index);\n      if (selected.has(i)) {\n        selected.delete(i);\n      } else {\n        selected.add(i);\n      }\n      updateSelectionStyles();\n      // Auto-run based on mode\n      if (opMode === 'Union' && selected.size >= 2) {\n        const [a, b] = Array.from(selected).slice(0, 2);\n        runUnion(a, b);\n        clearSelection();\n      } else if (opMode === 'Find' && selected.size >= 1) {\n        const [a] = Array.from(selected);\n        runFindVisual(a);\n        clearSelection();\n      } else if (opMode === 'Connected' && selected.size >= 2) {\n        const [a, b] = Array.from(selected).slice(0, 2);\n        runConnected(a, b);\n        clearSelection();\n      }\n    }\n\n    function updateSelectionStyles() {\n      for (let i = 0; i < nodeEls.length; i++) {\n        nodeEls[i].classList.toggle('selected', selected.has(i));\n      }\n    }\n    function clearSelection() {\n      selected.clear();\n      updateSelectionStyles();\n    }\n\n    function computeColors() {\n      colorByRoot.clear();\n      const roots = [];\n      for (let i = 0; i < dsu.n; i++) {\n        if (dsu.parent[i] === i) roots.push(i);\n      }\n      roots.sort((a, b) => a - b);\n      const m = roots.length;\n      for (let idx = 0; idx < m; idx++) {\n        const r = roots[idx];\n        const hue = Math.round((360 * idx) / Math.max(1, m));\n        colorByRoot.set(r, `hsl(${hue}, 60%, 55%)`);\n      }\n    }\n\n    function render() {\n      // Avoid find() during render; use parent[] directly\n      computeColors();\n      // Update nodes\n      for (let i = 0; i < dsu.n; i++) {\n        const el = nodeEls[i];\n        const isRoot = dsu.parent[i] === i;\n        el.classList.toggle('root', isRoot);\n        const root = dsu.rootOfNoCompress(i);\n        const color = colorByRoot.get(root) || '#6b7280';\n        el.style.background = 'linear-gradient(180deg, #0e141b 0%, #0b1016 100%)';\n        el.style.borderColor = isRoot ? 'var(--accent2)' : '#334153';\n        el.style.boxShadow = isRoot ? '0 0 0 2px rgba(124, 227, 139, 0.2)' : 'none';\n        el.querySelector('.sub').textContent = isRoot ? `size=${dsu.size[i]}` : '';\n        el.querySelector('.badge').textContent = '';\n        el.style.outline = `2px solid ${color}22`;\n      }\n      renderLines();\n    }\n\n    function getCenter(i) {\n      const el = nodeEls[i];\n      const rect = el.getBoundingClientRect();\n      const stageRect = stage.getBoundingClientRect();\n      return { x: rect.left - stageRect.left + rect.width / 2, y: rect.top - stageRect.top + rect.height / 2 };\n    }\n\n    function renderLines(highlightPairs = []) {\n      svg.setAttribute('width', stage.clientWidth);\n      svg.setAttribute('height', stage.clientHeight);\n      svg.innerHTML = '';\n      const toHighlight = new Set(highlightPairs.map(p => `${p[0]}-${p[1]}`));\n      for (let i = 0; i < dsu.n; i++) {\n        if (dsu.parent[i] !== i) {\n          const a = getCenter(i);\n          const b = getCenter(dsu.parent[i]);\n          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n          line.setAttribute('x1', a.x);\n          line.setAttribute('y1', a.y);\n          line.setAttribute('x2', b.x);\n          line.setAttribute('y2', b.y);\n          line.setAttribute('class', 'line');\n          const pairKey = `${i}-${dsu.parent[i]}`;\n          if (toHighlight.has(pairKey)) line.classList.add('highlight');\n          svg.appendChild(line);\n        }\n      }\n    }\n\n    function runUnion(a, b) {\n      if (!dsu.valid(a) || !dsu.valid(b)) {\n        log(`Union(${a}, ${b}) -> invalid indices`, 'err');\n        return;\n      }\n      const beforeRA = dsu.rootOfNoCompress(a);\n      const beforeRB = dsu.rootOfNoCompress(b);\n      const res = dsu.union(a, b);\n      if (!res.merged) {\n        if (res.reason === 'same') {\n          log(`Union(${a}, ${b}) -> already in same set (root=${res.root})`, 'warn');\n        } else {\n          log(`Union(${a}, ${b}) -> failed`, 'err');\n        }\n      } else {\n        log(`Union(${a}, ${b}) -> attach smaller to larger; new root=${res.newRoot}, sizes: size[${res.newRoot}]=${dsu.size[res.newRoot]}`, 'ok');\n      }\n      render();\n    }\n\n    function runFindVisual(a) {\n      if (!dsu.valid(a)) {\n        log(`Find(${a}) -> invalid index`, 'err');\n        return;\n      }\n      const { root, path } = dsu.probeFind(a);\n      // Highlight path edges\n      const pairs = [];\n      for (let i = 0; i < path.length - 1; i++) {\n        pairs.push([path[i], path[i + 1]]);\n      }\n      // Highlight nodes briefly\n      for (const i of path) nodeEls[i].classList.add('selected');\n      renderLines(pairs);\n      log(`Find(${a}) -> path: [${path.join(' -> ')}], root=${root}`);\n      // Compress if enabled\n      if (compressionToggle.checked) {\n        setTimeout(() => {\n          dsu.compressEnabled = true; // ensure compression setting sync\n          dsu.compressPath(path, root);\n          log(`Path compression applied: parent[x]=${root} for x in path`);\n          for (const i of path) nodeEls[i].classList.remove('selected');\n          render();\n        }, 600);\n      } else {\n        // Remove highlights without compression\n        setTimeout(() => {\n          for (const i of path) nodeEls[i].classList.remove('selected');\n          renderLines(); // remove highlight\n        }, 600);\n      }\n    }\n\n    function runConnected(a, b) {\n      if (!dsu.valid(a) || !dsu.valid(b)) {\n        log(`Connected(${a}, ${b}) -> invalid indices`, 'err');\n        return;\n      }\n      const res = dsu.connected(a, b);\n      log(`Connected(${a}, ${b}) -> ${res.connected ? 'true' : 'false'} (roots: ${res.ra}, ${res.rb})`, res.connected ? 'ok' : 'warn');\n      render();\n    }\n\n    // Random helpers\n    function randInt(n) { return Math.floor(Math.random() * n); }\n    function randomUnion() {\n      const a = randInt(dsu.n), b = randInt(dsu.n);\n      if (a === b) return randomUnion();\n      runUnion(a, b);\n    }\n    function randomOps(count = 8) {\n      for (let k = 0; k < count; k++) {\n        const choice = Math.random();\n        if (choice < 0.5) randomUnion();\n        else {\n          const a = randInt(dsu.n);\n          runFindVisual(a);\n        }\n      }\n    }\n\n    // Wire controls\n    resetBtn.addEventListener('click', () => {\n      const n = Number(nodeCountInput.value);\n      if (!Number.isInteger(n) || n < 2 || n > 500) {\n        log(`Reset -> invalid node count: ${nodeCountInput.value}`, 'err');\n        return;\n      }\n      init(n);\n    });\n    shuffleBtn.addEventListener('click', shuffleLayout);\n    compressionToggle.addEventListener('change', () => {\n      dsu.compressEnabled = compressionToggle.checked;\n      log(`Path compression ${dsu.compressEnabled ? 'enabled' : 'disabled'} for find operations`);\n    });\n    btnUnion.addEventListener('click', () => {\n      const a = Number(inputA.value), b = Number(inputB.value);\n      runUnion(a, b);\n    });\n    btnFind.addEventListener('click', () => {\n      const a = Number(inputA.value);\n      runFindVisual(a);\n    });\n    btnConnected.addEventListener('click', () => {\n      const a = Number(inputA.value), b = Number(inputB.value);\n      runConnected(a, b);\n    });\n    btnRandomUnion.addEventListener('click', randomUnion);\n    btnRandomOps.addEventListener('click', () => randomOps(6));\n    btnClearLog.addEventListener('click', clearLog);\n\n    window.addEventListener('resize', () => {\n      // re-layout circle to fit new size, keep order\n      nodePositions = layoutCircle(dsu.n);\n      for (let i = 0; i < dsu.n; i++) {\n        nodeEls[i].style.left = (nodePositions[i].x - 22) + 'px';\n        nodeEls[i].style.top = (nodePositions[i].y - 22) + 'px';\n      }\n      render();\n    });\n\n    // Start\n    init(12);\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Union-Find (Disjoint Set)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "8c1fa3b0-a36a-11f0-8aa8-7797d4e840ce",
    "timestamp": "2025-10-07T10:44:06.123Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Priority Queue",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Priority Queue Demo (Min/Max Heap with Visualization)</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f172a;\n      --panel: #111827;\n      --accent: #22c55e;\n      --accent2: #60a5fa;\n      --text: #e5e7eb;\n      --muted: #9ca3af;\n      --danger: #ef4444;\n      --warning: #f59e0b;\n      --node: #1f2937;\n      --line: #334155;\n      --highlight-compare: #38bdf8;\n      --highlight-swap: #f472b6;\n      --highlight-insert: #22c55e;\n    }\n    * { box-sizing: border-box; }\n    body {\n      margin: 0;\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial;\n      background: radial-gradient(1200px 600px at 10% 10%, #0b1225 0%, var(--bg) 100%);\n      color: var(--text);\n    }\n    header {\n      padding: 16px 20px;\n      border-bottom: 1px solid #1f2937;\n      background: linear-gradient(to right, rgba(34,197,94,0.08), rgba(96,165,250,0.08));\n    }\n    header h1 {\n      margin: 0;\n      font-size: 20px;\n      letter-spacing: 0.3px;\n      display: flex;\n      align-items: center;\n      gap: 10px;\n    }\n    header h1 span.badge {\n      font-size: 12px;\n      background: #0b1328;\n      border: 1px solid #1d2b50;\n      padding: 2px 8px;\n      border-radius: 999px;\n      color: var(--muted);\n    }\n    .container {\n      display: grid;\n      grid-template-columns: 320px 1fr;\n      gap: 16px;\n      padding: 16px;\n    }\n    .card {\n      background: var(--panel);\n      border: 1px solid #1f2937;\n      border-radius: 12px;\n      overflow: hidden;\n      box-shadow: 0 8px 24px rgba(0,0,0,0.25);\n    }\n    .card h2 {\n      margin: 0;\n      font-size: 16px;\n      padding: 12px 14px;\n      border-bottom: 1px solid #1f2937;\n      background: #0b1328;\n      color: #cbd5e1;\n      display: flex;\n      align-items: center;\n      justify-content: space-between;\n    }\n    .card-content {\n      padding: 12px 14px;\n    }\n    .row {\n      display: flex;\n      gap: 8px;\n      align-items: center;\n      margin-bottom: 10px;\n      flex-wrap: wrap;\n    }\n    label {\n      font-size: 12px;\n      color: var(--muted);\n    }\n    input[type=\"text\"], input[type=\"number\"] {\n      background: #0b1328;\n      border: 1px solid #1d2b50;\n      color: var(--text);\n      padding: 8px 10px;\n      border-radius: 8px;\n      outline: none;\n      min-width: 0;\n    }\n    input[type=\"number\"] { width: 100px; }\n    .btn {\n      background: #0b1328;\n      border: 1px solid #1d2b50;\n      color: var(--text);\n      padding: 8px 12px;\n      border-radius: 8px;\n      cursor: pointer;\n      transition: transform 0.05s ease, background 0.2s ease, border 0.2s ease;\n    }\n    .btn:hover { background: #0f1b3a; border-color: #274083; }\n    .btn:active { transform: scale(0.98); }\n    .btn.primary { background: #0e2b17; border-color: #215834; color: #bfeccb; }\n    .btn.primary:hover { background: #134224; }\n    .btn.warn { background: #412f0a; border-color: #7a5b1b; color: #ffe7b3; }\n    .btn.danger { background: #311013; border-color: #6c1f27; color: #ffb3bd; }\n    .toggle {\n      display: inline-flex;\n      gap: 8px;\n      background: #0b1328;\n      border: 1px solid #1d2b50;\n      padding: 6px;\n      border-radius: 999px;\n    }\n    .toggle button {\n      border: none;\n      background: transparent;\n      color: var(--muted);\n      padding: 6px 10px;\n      border-radius: 999px;\n      cursor: pointer;\n      font-size: 12px;\n    }\n    .toggle button.active {\n      background: #162c58;\n      color: #cde3ff;\n      border: 1px solid #274083;\n    }\n    .stats {\n      display: grid;\n      grid-template-columns: repeat(2, 1fr);\n      gap: 8px;\n      margin-top: 8px;\n    }\n    .stats .stat {\n      background: #0b1328;\n      border: 1px solid #1d2b50;\n      border-radius: 8px;\n      padding: 10px;\n      font-size: 12px;\n    }\n    .stat strong { color: #cbd5e1; }\n    .viz {\n      height: 440px;\n      background: linear-gradient(to bottom, #0b1328, #0a162a);\n      border-top: 1px solid #1f2937;\n      position: relative;\n    }\n    .viz .overlay {\n      position: absolute;\n      top: 8px;\n      left: 8px;\n      display: flex;\n      gap: 8px;\n      font-size: 12px;\n      color: var(--muted);\n      opacity: 0.85;\n    }\n    .legend {\n      display: flex;\n      gap: 8px;\n      align-items: center;\n    }\n    .chip {\n      display: inline-flex;\n      align-items: center;\n      gap: 6px;\n      background: #0b1328;\n      border: 1px solid #1d2b50;\n      border-radius: 999px;\n      padding: 6px 10px;\n    }\n    .chip .dot {\n      width: 10px;\n      height: 10px;\n      border-radius: 999px;\n    }\n    svg { width: 100%; height: 100%; }\n    .node {\n      transition: transform 0.2s ease, filter 0.2s ease;\n      cursor: pointer;\n    }\n    .node:hover { filter: brightness(1.2); }\n    .node rect {\n      fill: var(--node);\n      stroke: #284164;\n      stroke-width: 1.2;\n      rx: 10;\n    }\n    .node text {\n      fill: #cbd5e1;\n      font-size: 12px;\n      pointer-events: none;\n    }\n    .link {\n      stroke: var(--line);\n      stroke-width: 1.5;\n    }\n    .node.compare rect { stroke: var(--highlight-compare); filter: drop-shadow(0 0 6px rgba(56,189,248,0.35)); }\n    .node.swap rect { stroke: var(--highlight-swap); filter: drop-shadow(0 0 6px rgba(244,114,182,0.35)); }\n    .node.insert rect { stroke: var(--highlight-insert); filter: drop-shadow(0 0 6px rgba(34,197,94,0.35)); }\n    .queue-list {\n      display: grid;\n      gap: 8px;\n      margin-top: 10px;\n    }\n    .queue-item {\n      background: #0b1328;\n      border: 1px solid #1d2b50;\n      border-radius: 8px;\n      padding: 8px;\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      font-size: 12px;\n    }\n    .queue-item .meta {\n      display: flex;\n      gap: 10px;\n      align-items: center;\n    }\n    .queue-item .meta .prio {\n      color: #93c5fd;\n    }\n    .queue-item .actions { display: flex; gap: 6px; }\n    .timeline {\n      height: 120px;\n      background: #0b1328;\n      border-top: 1px solid #1d2b50;\n      padding: 10px;\n      font-size: 12px;\n      overflow: auto;\n    }\n    .timeline .line {\n      color: #cbd5e1;\n      margin-bottom: 6px;\n      display: flex;\n      align-items: center;\n      gap: 6px;\n    }\n    .timeline .line .tag {\n      font-size: 11px;\n      color: #9ca3af;\n      border: 1px solid #1d2b50;\n      background: #091024;\n      padding: 2px 6px;\n      border-radius: 999px;\n    }\n    .controls {\n      display: flex;\n      gap: 8px;\n      align-items: center;\n      padding: 10px;\n      border-top: 1px solid #1f2937;\n      background: #0b1328;\n    }\n    .speed {\n      display: flex;\n      gap: 6px;\n      align-items: center;\n      color: var(--muted);\n      font-size: 12px;\n    }\n    input[type=\"range\"] { width: 120px; }\n    .note {\n      font-size: 12px;\n      color: var(--muted);\n      margin-top: 6px;\n    }\n    .footer {\n      padding: 12px 16px;\n      font-size: 12px;\n      color: var(--muted);\n      border-top: 1px solid #1f2937;\n    }\n    .code {\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n      color: #93c5fd;\n    }\n    @media (max-width: 960px) {\n      .container { grid-template-columns: 1fr; }\n      .stats { grid-template-columns: 1fr 1fr; }\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>\n      Priority Queue Visualizer\n      <span class=\"badge\">Min/Max Heap • Interactive • Animated</span>\n    </h1>\n  </header>\n\n  <div class=\"container\">\n    <!-- Left panel: controls -->\n    <div class=\"card\">\n      <h2>\n        Controls\n        <span class=\"chip\">\n          <span class=\"dot\" style=\"background: var(--accent);\"></span>\n          Complexity: enqueue/dequeue O(log n), peek O(1)\n        </span>\n      </h2>\n      <div class=\"card-content\">\n        <div class=\"row\">\n          <div style=\"flex: 1;\">\n            <label>Item label</label>\n            <input id=\"labelInput\" type=\"text\" placeholder=\"e.g., Fix critical bug\" />\n          </div>\n          <div>\n            <label>Priority</label>\n            <input id=\"priorityInput\" type=\"number\" placeholder=\"e.g., 1\" />\n          </div>\n          <button class=\"btn primary\" id=\"enqueueBtn\">Enqueue</button>\n        </div>\n\n        <div class=\"row\">\n          <div class=\"toggle\" id=\"modeToggle\">\n            <button data-mode=\"min\" class=\"active\">Min-Heap (lower number = higher priority)</button>\n            <button data-mode=\"max\">Max-Heap (higher number = higher priority)</button>\n          </div>\n          <button class=\"btn\" id=\"peekBtn\">Peek</button>\n          <button class=\"btn warn\" id=\"dequeueBtn\">Dequeue</button>\n          <button class=\"btn danger\" id=\"clearBtn\">Clear</button>\n          <button class=\"btn\" id=\"seedBtn\">Seed Examples</button>\n        </div>\n\n        <div class=\"stats\">\n          <div class=\"stat\">\n            <strong>Size:</strong> <span id=\"sizeStat\">0</span>\n          </div>\n          <div class=\"stat\">\n            <strong>Top:</strong> <span id=\"topStat\">None</span>\n          </div>\n        </div>\n\n        <p class=\"note\">\n          A priority queue always removes the highest-priority item first. In Min-Heap mode, smaller numbers are higher priority. Ties are stable: earlier insertions win.\n        </p>\n\n        <h2>Queue (sorted by priority)</h2>\n        <div class=\"card-content queue-list\" id=\"queueList\"></div>\n      </div>\n    </div>\n\n    <!-- Right panel: visualization and timeline -->\n    <div class=\"card\">\n      <h2>\n        Heap Visualization\n        <span class=\"chip\">\n          <span class=\"dot\" style=\"background: var(--accent2);\"></span>\n          Stable ordering for ties\n        </span>\n      </h2>\n      <div class=\"viz\" id=\"viz\">\n        <div class=\"overlay\">\n          <div class=\"legend chip\">\n            <span class=\"dot\" style=\"background: var(--highlight-compare);\"></span> Compare\n          </div>\n          <div class=\"legend chip\">\n            <span class=\"dot\" style=\"background: var(--highlight-swap);\"></span> Swap\n          </div>\n          <div class=\"legend chip\">\n            <span class=\"dot\" style=\"background: var(--highlight-insert);\"></span> Insert\n          </div>\n        </div>\n        <svg id=\"heapSvg\"></svg>\n      </div>\n      <div class=\"controls\">\n        <button class=\"btn\" id=\"animateToggle\">Animation: On</button>\n        <button class=\"btn\" id=\"pauseBtn\" disabled>Pause</button>\n        <button class=\"btn\" id=\"resumeBtn\" disabled>Resume</button>\n        <button class=\"btn\" id=\"stepBtn\" disabled>Step</button>\n        <div class=\"speed\">\n          Speed\n          <input id=\"speedRange\" type=\"range\" min=\"100\" max=\"1500\" step=\"50\" value=\"500\" />\n        </div>\n      </div>\n      <div class=\"timeline\" id=\"timeline\"></div>\n      <div class=\"footer\">\n        Implemented using an array-backed binary heap. Parent index i has children at 2i+1 and 2i+2.\n        Tie-breaker uses insertion order (stable). Click nodes or list items to change priority or remove.\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // PriorityQueue with Min/Max comparator and stable tie-breaker, event snapshots for animation.\n    class PriorityQueue {\n      constructor({ isMin = true, onEvent = null } = {}) {\n        this.heap = [];\n        this.isMin = isMin;\n        this.seq = 0;\n        this.onEvent = onEvent; // function(event)\n      }\n\n      _higher(a, b) {\n        // Returns true if 'a' has higher priority than 'b'\n        if (a.priority !== b.priority) {\n          return this.isMin ? a.priority < b.priority : a.priority > b.priority;\n        }\n        // Stable tie-breaker: earlier insertion (lower seq) wins\n        return a.seq < b.seq;\n      }\n\n      size() { return this.heap.length; }\n      isEmpty() { return this.heap.length === 0; }\n      peek() { return this.heap[0] || null; }\n      clear() {\n        if (this.onEvent) this._emit({ type: 'clear', description: 'Clear the heap' });\n        this.heap = [];\n      }\n\n      enqueue(label, priority) {\n        if (label == null || label === '') label = '(unnamed)';\n        const item = { id: genId(), label, priority: Number(priority), seq: this.seq++ };\n        this.heap.push(item);\n        this._emit({ type: 'insert', indices: [this.heap.length - 1], description: `Insert \"${item.label}\" priority ${item.priority}` });\n        this._bubbleUp(this.heap.length - 1);\n        return item;\n      }\n\n      dequeue() {\n        if (this.heap.length === 0) return null;\n        const root = this.heap[0];\n        const last = this.heap.pop();\n        this._emit({ type: 'remove', indices: [0], description: `Remove top \"${root.label}\" priority ${root.priority}` });\n\n        if (this.heap.length > 0) {\n          this.heap[0] = last;\n          this._emit({ type: 'replaceRoot', indices: [0], description: `Move last element to root` });\n          this._sinkDown(0);\n        }\n        return root;\n      }\n\n      changePriority(id, newPriority) {\n        const idx = this.heap.findIndex(x => x.id === id);\n        if (idx === -1) return false;\n        const old = this.heap[idx].priority;\n        this.heap[idx].priority = Number(newPriority);\n        this._emit({ type: 'update', indices: [idx], description: `Change priority of \"${this.heap[idx].label}\" from ${old} to ${newPriority}` });\n        // Re-heapify around idx\n        if (idx > 0 && this._higher(this.heap[idx], this.heap[this._parent(idx)])) {\n          this._bubbleUp(idx);\n        } else {\n          this._sinkDown(idx);\n        }\n        return true;\n      }\n\n      removeById(id) {\n        const idx = this.heap.findIndex(x => x.id === id);\n        if (idx === -1) return false;\n        const removing = this.heap[idx];\n        const last = this.heap.pop();\n        this._emit({ type: 'remove', indices: [idx], description: `Remove \"${removing.label}\" priority ${removing.priority}` });\n        if (idx < this.heap.length) {\n          this.heap[idx] = last;\n          // Re-heapify around idx\n          if (idx > 0 && this._higher(this.heap[idx], this.heap[this._parent(idx)])) {\n            this._bubbleUp(idx);\n          } else {\n            this._sinkDown(idx);\n          }\n        }\n        return true;\n      }\n\n      rebuild(isMin) {\n        this.isMin = isMin;\n        // Heapify from existing items with events\n        const items = this.heap.slice();\n        this.heap = items;\n        this._emit({ type: 'heapify', description: `Heapify for ${isMin ? 'Min-Heap' : 'Max-Heap'} mode` });\n        for (let i = Math.floor(this.heap.length / 2) - 1; i >= 0; i--) {\n          this._sinkDown(i);\n        }\n      }\n\n      toArray() { return this.heap.map(x => ({ ...x })); }\n\n      toSortedArray() {\n        const arr = this.heap.slice();\n        arr.sort((a, b) => {\n          if (a.priority !== b.priority) {\n            return this.isMin ? a.priority - b.priority : b.priority - a.priority;\n          }\n          return a.seq - b.seq;\n        });\n        return arr;\n      }\n\n      _parent(i) { return Math.floor((i - 1) / 2); }\n      _left(i) { return 2 * i + 1; }\n      _right(i) { return 2 * i + 2; }\n\n      _bubbleUp(idx) {\n        let i = idx;\n        while (i > 0) {\n          const p = this._parent(i);\n          this._emit({ type: 'compare', indices: [i, p], description: `Compare child at ${i} with parent at ${p}` });\n          if (this._higher(this.heap[i], this.heap[p])) {\n            this._swap(i, p);\n            this._emit({ type: 'swap', indices: [i, p], description: `Swap child (${i}) with parent (${p})` });\n            i = p;\n          } else break;\n        }\n      }\n\n      _sinkDown(i) {\n        const n = this.heap.length;\n        let index = i;\n        while (true) {\n          const l = this._left(index);\n          const r = this._right(index);\n          let best = index;\n\n          if (l < n && this._higher(this.heap[l], this.heap[best])) {\n            this._emit({ type: 'compare', indices: [l, best], description: `Compare left child (${l}) with current (${best})` });\n            best = l;\n          }\n          if (r < n && this._higher(this.heap[r], this.heap[best])) {\n            this._emit({ type: 'compare', indices: [r, best], description: `Compare right child (${r}) with current (${best})` });\n            best = r;\n          }\n          if (best !== index) {\n            this._swap(index, best);\n            this._emit({ type: 'swap', indices: [index, best], description: `Swap current (${index}) with child (${best})` });\n            index = best;\n          } else break;\n        }\n      }\n\n      _swap(a, b) {\n        const tmp = this.heap[a];\n        this.heap[a] = this.heap[b];\n        this.heap[b] = tmp;\n      }\n\n      _emit(event) {\n        if (!this.onEvent) return;\n        // Attach a deep snapshot of heap for animation\n        const snapshot = this.heap.map(x => ({ ...x }));\n        this.onEvent({ ...event, heap: snapshot });\n      }\n    }\n\n    // Animator to play event timeline with snapshots\n    class Animator {\n      constructor({ render, onTimelineUpdate } = {}) {\n        this.timeline = [];\n        this.index = 0;\n        this.playing = false;\n        this.speed = 500;\n        this.timer = null;\n        this.render = render; // function(event)\n        this.onTimelineUpdate = onTimelineUpdate || (()=>{});\n      }\n      setSpeed(ms) { this.speed = ms; }\n      setTimeline(events) {\n        this.timeline = events.slice();\n        this.index = 0;\n        this.onTimelineUpdate(this.timeline, this.index);\n      }\n      clearTimeline() {\n        this.timeline = [];\n        this.index = 0;\n        this.onTimelineUpdate(this.timeline, this.index);\n      }\n      play() {\n        if (this.playing || this.timeline.length === 0) return;\n        this.playing = true;\n        this._tick();\n      }\n      _tick() {\n        if (!this.playing) return;\n        if (this.index >= this.timeline.length) {\n          this.playing = false;\n          this.onTimelineUpdate(this.timeline, this.index);\n          return;\n        }\n        const ev = this.timeline[this.index];\n        this.render(ev);\n        this.index++;\n        this.onTimelineUpdate(this.timeline, this.index);\n        this.timer = setTimeout(() => this._tick(), this.speed);\n      }\n      pause() {\n        this.playing = false;\n        if (this.timer) clearTimeout(this.timer);\n      }\n      resume() {\n        if (this.playing) return;\n        this.playing = true;\n        this._tick();\n      }\n      step() {\n        if (this.index >= this.timeline.length) return;\n        const ev = this.timeline[this.index];\n        this.render(ev);\n        this.index++;\n        this.onTimelineUpdate(this.timeline, this.index);\n      }\n    }\n\n    // Utilities\n    let _idCounter = 1;\n    function genId() { return 'id_' + (_idCounter++); }\n\n    // UI State\n    const state = {\n      isMin: true,\n      animate: true,\n    };\n\n    // Setup\n    const pq = new PriorityQueue({\n      isMin: state.isMin,\n      onEvent: ev => timelineEvents.push(ev)\n    });\n    const timelineEvents = [];\n    const animator = new Animator({\n      render: event => {\n        renderHeap(event.heap, event.indices || [], event.type);\n        appendTimelineLine(event);\n      },\n      onTimelineUpdate: (events, idx) => {\n        updateControlsForTimeline(events, idx);\n      }\n    });\n\n    // DOM\n    const heapSvg = document.getElementById('heapSvg');\n    const queueList = document.getElementById('queueList');\n    const sizeStat = document.getElementById('sizeStat');\n    const topStat = document.getElementById('topStat');\n    const enqueueBtn = document.getElementById('enqueueBtn');\n    const peekBtn = document.getElementById('peekBtn');\n    const dequeueBtn = document.getElementById('dequeueBtn');\n    const clearBtn = document.getElementById('clearBtn');\n    const seedBtn = document.getElementById('seedBtn');\n    const labelInput = document.getElementById('labelInput');\n    const priorityInput = document.getElementById('priorityInput');\n    const modeToggle = document.getElementById('modeToggle');\n    const animateToggle = document.getElementById('animateToggle');\n    const pauseBtn = document.getElementById('pauseBtn');\n    const resumeBtn = document.getElementById('resumeBtn');\n    const stepBtn = document.getElementById('stepBtn');\n    const speedRange = document.getElementById('speedRange');\n    const timelineDiv = document.getElementById('timeline');\n\n    // Event handlers\n    enqueueBtn.addEventListener('click', () => {\n      const label = labelInput.value.trim();\n      const prioStr = priorityInput.value.trim();\n      const prio = prioStr === '' ? NaN : Number(prioStr);\n      if (isNaN(prio)) {\n        alert('Please enter a numeric priority.');\n        priorityInput.focus();\n        return;\n      }\n      clearTimeline();\n      pq.enqueue(label, prio);\n      updateAll(state.animate);\n      labelInput.value = '';\n      priorityInput.value = '';\n    });\n\n    peekBtn.addEventListener('click', () => {\n      const top = pq.peek();\n      if (!top) {\n        alert('Queue is empty.');\n        return;\n      }\n      alert(`Top item:\\n\"${top.label}\" with priority ${top.priority}`);\n    });\n\n    dequeueBtn.addEventListener('click', () => {\n      clearTimeline();\n      const removed = pq.dequeue();\n      updateAll(state.animate);\n      if (!removed) {\n        alert('Queue is empty.');\n      } else {\n        alert(`Dequeued:\\n\"${removed.label}\" with priority ${removed.priority}`);\n      }\n    });\n\n    clearBtn.addEventListener('click', () => {\n      clearTimeline();\n      pq.clear();\n      updateAll(false);\n    });\n\n    seedBtn.addEventListener('click', () => {\n      clearTimeline();\n      const examples = [\n        ['Fix critical bug', 1],\n        ['Code review', 3],\n        ['Write documentation', 5],\n        ['Respond to emails', 7],\n        ['Refactor module', 4],\n        ['Add tests', 2],\n        ['Plan sprint', 6]\n      ];\n      examples.forEach(([label, prio]) => pq.enqueue(label, prio));\n      updateAll(state.animate);\n    });\n\n    modeToggle.addEventListener('click', (e) => {\n      const btn = e.target.closest('button[data-mode]');\n      if (!btn) return;\n      const mode = btn.getAttribute('data-mode');\n      modeToggle.querySelectorAll('button').forEach(b => b.classList.remove('active'));\n      btn.classList.add('active');\n      clearTimeline();\n      state.isMin = mode === 'min';\n      pq.rebuild(state.isMin);\n      updateAll(state.animate);\n    });\n\n    animateToggle.addEventListener('click', () => {\n      state.animate = !state.animate;\n      animateToggle.textContent = `Animation: ${state.animate ? 'On' : 'Off'}`;\n    });\n\n    speedRange.addEventListener('input', () => {\n      animator.setSpeed(Number(speedRange.value));\n    });\n\n    pauseBtn.addEventListener('click', () => animator.pause());\n    resumeBtn.addEventListener('click', () => animator.resume());\n    stepBtn.addEventListener('click', () => animator.step());\n\n    // Render functions\n    function updateAll(withAnimation) {\n      updateStats();\n      renderQueueSorted();\n      if (withAnimation && timelineEvents.length > 0) {\n        animator.setTimeline(timelineEvents);\n        animator.play();\n      } else {\n        renderHeap(pq.toArray(), [], null);\n      }\n    }\n\n    function updateStats() {\n      sizeStat.textContent = pq.size();\n      const top = pq.peek();\n      topStat.textContent = top ? `\"${top.label}\" (p=${top.priority})` : 'None';\n    }\n\n    function renderQueueSorted() {\n      queueList.innerHTML = '';\n      const arr = pq.toSortedArray();\n      if (arr.length === 0) {\n        const empty = document.createElement('div');\n        empty.className = 'note';\n        empty.textContent = 'Empty queue.';\n        queueList.appendChild(empty);\n        return;\n      }\n      arr.forEach(item => {\n        const div = document.createElement('div');\n        div.className = 'queue-item';\n        const left = document.createElement('div');\n        left.className = 'meta';\n        const name = document.createElement('div');\n        name.textContent = item.label;\n        const pr = document.createElement('div');\n        pr.className = 'prio';\n        pr.textContent = `p=${item.priority}`;\n        left.appendChild(name);\n        left.appendChild(pr);\n\n        const right = document.createElement('div');\n        right.className = 'actions';\n        const changeBtn = document.createElement('button');\n        changeBtn.className = 'btn';\n        changeBtn.textContent = 'Change priority';\n        changeBtn.addEventListener('click', () => {\n          const val = prompt(`New priority for \"${item.label}\":`, item.priority);\n          if (val === null) return;\n          const num = Number(val);\n          if (isNaN(num)) {\n            alert('Please enter a numeric priority.');\n            return;\n          }\n          clearTimeline();\n          pq.changePriority(item.id, num);\n          updateAll(state.animate);\n        });\n        const removeBtn = document.createElement('button');\n        removeBtn.className = 'btn danger';\n        removeBtn.textContent = 'Remove';\n        removeBtn.addEventListener('click', () => {\n          clearTimeline();\n          pq.removeById(item.id);\n          updateAll(state.animate);\n        });\n        right.appendChild(changeBtn);\n        right.appendChild(removeBtn);\n\n        div.appendChild(left);\n        div.appendChild(right);\n        queueList.appendChild(div);\n      });\n    }\n\n    function renderHeap(heapArr, highlightIndices = [], eventType = null) {\n      heapSvg.innerHTML = '';\n      const n = heapArr.length;\n      // If empty: draw message\n      if (n === 0) {\n        const msg = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        msg.setAttribute('x', '50%');\n        msg.setAttribute('y', '50%');\n        msg.setAttribute('text-anchor', 'middle');\n        msg.setAttribute('fill', '#93c5fd');\n        msg.setAttribute('font-size', '14');\n        msg.textContent = 'Heap is empty.';\n        heapSvg.appendChild(msg);\n        return;\n      }\n\n      const width = heapSvg.clientWidth || heapSvg.parentElement.clientWidth || 800;\n      const height = heapSvg.clientHeight || 440;\n      const marginX = 26;\n      const marginTop = 26;\n      const vGap = Math.max(80, Math.min(120, height / (Math.floor(Math.log2(n)) + 3)));\n      const nodeW = 150;\n      const nodeH = 36;\n\n      // Compute positions by level\n      const positions = new Array(n);\n      for (let i = 0; i < n; i++) {\n        const level = Math.floor(Math.log2(i + 1));\n        const firstIdx = Math.pow(2, level) - 1;\n        const posInLevel = i - firstIdx;\n        const nodesInLevel = Math.pow(2, level);\n        const x = marginX + ((posInLevel + 1) * (width - 2 * marginX)) / (nodesInLevel + 1);\n        const y = marginTop + level * vGap;\n        positions[i] = { x, y, level, posInLevel };\n      }\n\n      // Draw links\n      for (let i = 0; i < n; i++) {\n        const left = 2 * i + 1;\n        const right = 2 * i + 2;\n        if (left < n) drawLink(positions[i], positions[left]);\n        if (right < n) drawLink(positions[i], positions[right]);\n      }\n\n      // Draw nodes\n      for (let i = 0; i < n; i++) {\n        const pos = positions[i];\n        const item = heapArr[i];\n        const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        nodeGroup.classList.add('node');\n        if (highlightIndices.includes(i)) {\n          if (eventType === 'compare') nodeGroup.classList.add('compare');\n          else if (eventType === 'swap') nodeGroup.classList.add('swap');\n          else if (eventType === 'insert' || eventType === 'replaceRoot' || eventType === 'update') nodeGroup.classList.add('insert');\n        }\n\n        nodeGroup.setAttribute('transform', `translate(${pos.x - nodeW / 2}, ${pos.y - nodeH / 2})`);\n        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        rect.setAttribute('width', nodeW);\n        rect.setAttribute('height', nodeH);\n        nodeGroup.appendChild(rect);\n\n        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        label.setAttribute('x', nodeW / 2);\n        label.setAttribute('y', nodeH / 2 + 4);\n        label.setAttribute('text-anchor', 'middle');\n        const short = truncate(item.label, 22);\n        label.textContent = `${short}  p=${item.priority}`;\n        nodeGroup.appendChild(label);\n\n        // Click interactions\n        nodeGroup.addEventListener('click', () => {\n          const act = prompt(`Choose action for \"${item.label}\" (enter: new priority; or type \"remove\")`, item.priority);\n          if (act === null) return;\n          if (act.toLowerCase().trim() === 'remove') {\n            clearTimeline();\n            pq.removeById(item.id);\n            updateAll(state.animate);\n          } else {\n            const val = Number(act);\n            if (isNaN(val)) {\n              alert('Please enter a numeric priority or \"remove\".');\n            } else {\n              clearTimeline();\n              pq.changePriority(item.id, val);\n              updateAll(state.animate);\n            }\n          }\n        });\n\n        heapSvg.appendChild(nodeGroup);\n      }\n\n      function drawLink(a, b) {\n        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n        line.classList.add('link');\n        const ax = a.x;\n        const ay = a.y + (nodeH / 2);\n        const bx = b.x;\n        const by = b.y - (nodeH / 2);\n        line.setAttribute('x1', ax);\n        line.setAttribute('y1', ay);\n        line.setAttribute('x2', bx);\n        line.setAttribute('y2', by);\n        heapSvg.appendChild(line);\n      }\n    }\n\n    function truncate(str, n) {\n      if (str.length <= n) return str;\n      return str.slice(0, n - 1) + '…';\n    }\n\n    function appendTimelineLine(ev) {\n      const line = document.createElement('div');\n      line.className = 'line';\n      const tag = document.createElement('span');\n      tag.className = 'tag';\n      tag.textContent = ev.type;\n      const desc = document.createElement('span');\n      desc.textContent = ev.description || '';\n      line.appendChild(tag);\n      line.appendChild(desc);\n      timelineDiv.appendChild(line);\n      timelineDiv.scrollTop = timelineDiv.scrollHeight;\n    }\n\n    function updateControlsForTimeline(events, idx) {\n      const hasEvents = events.length > 0;\n      pauseBtn.disabled = !hasEvents;\n      resumeBtn.disabled = !hasEvents;\n      stepBtn.disabled = !hasEvents;\n      // Disable/enable pause/resume accordingly\n      // No need to track exact playing state for simplicity here\n    }\n\n    function clearTimeline() {\n      timelineEvents.length = 0;\n      timelineDiv.innerHTML = '';\n      animator.clearTimeline();\n    }\n\n    // Initial render\n    renderHeap(pq.toArray(), [], null);\n    renderQueueSorted();\n    updateStats();\n\n    // Keyboard shortcuts\n    document.addEventListener('keydown', (e) => {\n      if (e.key === 'Enter') enqueueBtn.click();\n      if (e.key.toLowerCase() === 'd') dequeueBtn.click();\n      if (e.key.toLowerCase() === 'p') peekBtn.click();\n    });\n\n    // Accessibility titles\n    enqueueBtn.title = 'Add item to priority queue (Enter)';\n    dequeueBtn.title = 'Remove top-priority item (D)';\n    peekBtn.title = 'View top-priority item (P)';\n\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Priority Queue"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "d23fe8f0-a36a-11f0-a786-f359cc38ad58",
    "timestamp": "2025-10-07T10:46:03.775Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Bubble Sort",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Bubble Sort Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f172a;\n      --panel: #111827;\n      --text: #e5e7eb;\n      --muted: #9ca3af;\n      --accent: #60a5fa;\n      --accent-2: #34d399;\n      --danger: #f87171;\n      --warn: #f59e0b;\n      --bar: #60a5fa;\n      --bar-compare: #f59e0b;\n      --bar-swap: #f43f5e;\n      --bar-sorted: #34d399;\n      --btn: #1f2937;\n      --btn-border: #374151;\n      --code-bg: #0b1220;\n      --code-active: #1e293b;\n      --focus: #7dd3fc;\n    }\n    * { box-sizing: border-box; }\n    html, body { margin: 0; height: 100%; }\n    body {\n      background: radial-gradient(1200px 600px at 80% -10%, rgba(96,165,250,0.18), transparent 70%) no-repeat,\n                  radial-gradient(1000px 700px at -20% 30%, rgba(52,211,153,0.12), transparent 60%) no-repeat,\n                  linear-gradient(180deg, #0b1023, #0f172a 30% 70%, #0b1023);\n      color: var(--text);\n      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n      line-height: 1.45;\n      padding: 24px;\n    }\n    header {\n      display: flex;\n      align-items: baseline;\n      justify-content: space-between;\n      gap: 16px;\n      flex-wrap: wrap;\n      margin-bottom: 16px;\n    }\n    h1 {\n      margin: 0;\n      font-size: 28px;\n      letter-spacing: 0.2px;\n      display: flex;\n      align-items: center;\n      gap: 10px;\n    }\n    .badge {\n      font-size: 12px;\n      color: var(--muted);\n      border: 1px solid var(--btn-border);\n      padding: 2px 8px;\n      border-radius: 999px;\n      background: rgba(255,255,255,0.02);\n    }\n\n    .container {\n      display: grid;\n      grid-template-columns: 1.5fr 1fr;\n      gap: 16px;\n      align-items: start;\n    }\n    @media (max-width: 1000px) {\n      .container {\n        grid-template-columns: 1fr;\n      }\n    }\n\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));\n      border: 1px solid rgba(148,163,184,0.15);\n      border-radius: 14px;\n      padding: 14px;\n      box-shadow: 0 10px 30px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.03);\n    }\n\n    .controls {\n      display: grid;\n      grid-template-columns: 1fr;\n      gap: 12px;\n      margin-bottom: 10px;\n    }\n    .row {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 10px 14px;\n      align-items: center;\n    }\n    .row > .group {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      background: rgba(255,255,255,0.02);\n      border: 1px solid var(--btn-border);\n      padding: 10px;\n      border-radius: 10px;\n    }\n    .group label {\n      font-size: 12px;\n      color: var(--muted);\n      text-transform: uppercase;\n      letter-spacing: 0.08em;\n    }\n    input[type=\"range\"] {\n      appearance: none;\n      height: 4px;\n      background: #1f2937;\n      border-radius: 999px;\n      outline: none;\n      width: 180px;\n    }\n    input[type=\"range\"]::-webkit-slider-thumb {\n      appearance: none;\n      width: 16px; height: 16px;\n      background: linear-gradient(180deg, #93c5fd, #60a5fa);\n      border-radius: 50%;\n      border: 1px solid rgba(255,255,255,0.4);\n      box-shadow: 0 2px 6px rgba(96,165,250,0.35);\n    }\n    .val {\n      min-width: 36px;\n      text-align: right;\n      font-variant-numeric: tabular-nums;\n      color: var(--text);\n    }\n    .btn {\n      background: linear-gradient(180deg, #0f172a, #0b1220);\n      color: var(--text);\n      border: 1px solid var(--btn-border);\n      padding: 10px 12px;\n      border-radius: 10px;\n      cursor: pointer;\n      user-select: none;\n      display: inline-flex;\n      align-items: center;\n      gap: 8px;\n      transition: transform 0.05s ease, background 0.2s ease, border-color 0.2s ease;\n    }\n    .btn:hover { border-color: #4b5563; }\n    .btn:active { transform: translateY(1px); }\n    .btn.primary {\n      background: linear-gradient(180deg, #1e293b, #0f172a);\n      border-color: #334155;\n    }\n    .btn.soft {\n      background: rgba(96,165,250,0.1);\n      border-color: rgba(96,165,250,0.4);\n    }\n    .btn.warn {\n      background: rgba(245,158,11,0.1);\n      border-color: rgba(245,158,11,0.4);\n    }\n    .btn.danger {\n      background: rgba(244,63,94,0.08);\n      border-color: rgba(244,63,94,0.35);\n    }\n    .btn:disabled {\n      opacity: 0.5;\n      cursor: not-allowed;\n    }\n    .spacer { flex: 1; }\n\n    .toggle {\n      display: inline-flex;\n      align-items: center;\n      gap: 8px;\n      padding: 8px 10px;\n      border-radius: 10px;\n      border: 1px solid var(--btn-border);\n      background: rgba(255,255,255,0.02);\n      cursor: pointer;\n      user-select: none;\n    }\n    .toggle input { accent-color: var(--accent); width: 16px; height: 16px; }\n\n    .stats {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 10px;\n    }\n    .stat {\n      background: rgba(255,255,255,0.02);\n      border: 1px solid var(--btn-border);\n      border-radius: 10px;\n      padding: 10px 12px;\n      min-width: 110px;\n    }\n    .stat .k { font-size: 11px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.08em; }\n    .stat .v { font-size: 18px; font-variant-numeric: tabular-nums; }\n\n    .viz {\n      height: 360px;\n      border-radius: 14px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(148,163,184,0.15);\n      padding: 14px;\n      display: flex;\n      align-items: end;\n      overflow: hidden;\n      position: relative;\n    }\n    .bars {\n      position: absolute;\n      inset: 14px;\n      display: flex;\n      align-items: end;\n      gap: 2px;\n    }\n    .bar {\n      flex: 1 1 0;\n      height: 10px;\n      background: linear-gradient(180deg, #93c5fd, #60a5fa);\n      border-radius: 4px 4px 0 0;\n      box-shadow: inset 0 1px 0 rgba(255,255,255,0.5);\n      transition: height 140ms ease, background 120ms ease, transform 120ms ease, opacity 120ms ease;\n      position: relative;\n    }\n    .bar::after {\n      content: attr(data-val);\n      position: absolute;\n      bottom: -20px;\n      left: 50%;\n      transform: translateX(-50%);\n      font-size: 10px;\n      color: var(--muted);\n      opacity: 0.0;\n      transition: opacity 0.2s ease;\n      pointer-events: none;\n    }\n    .viz:hover .bar::after {\n      opacity: 0.85;\n    }\n    .bar.comparing {\n      background: linear-gradient(180deg, #fcd34d, #f59e0b);\n      box-shadow: 0 0 0 1px rgba(245,158,11,0.3), inset 0 1px 0 rgba(255,255,255,0.4);\n    }\n    .bar.swapping {\n      background: linear-gradient(180deg, #fb7185, #f43f5e);\n      box-shadow: 0 0 0 1px rgba(244,63,94,0.35), inset 0 1px 0 rgba(255,255,255,0.4);\n      transform: translateY(-2px);\n    }\n    .bar.sorted {\n      background: linear-gradient(180deg, #6ee7b7, #34d399);\n      box-shadow: inset 0 1px 0 rgba(255,255,255,0.5);\n      opacity: 0.95;\n    }\n\n    .legend {\n      display: flex;\n      gap: 10px;\n      align-items: center;\n      flex-wrap: wrap;\n      margin-top: 8px;\n    }\n    .legend .dot {\n      width: 14px; height: 14px; border-radius: 3px;\n      border: 1px solid rgba(148,163,184,0.35);\n    }\n    .legend .dot.compare { background: linear-gradient(180deg, #fcd34d, #f59e0b); }\n    .legend .dot.swap { background: linear-gradient(180deg, #fb7185, #f43f5e); }\n    .legend .dot.sorted { background: linear-gradient(180deg, #6ee7b7, #34d399); }\n    .legend span { color: var(--muted); font-size: 12px; }\n\n    .code {\n      background: var(--code-bg);\n      border-radius: 12px;\n      border: 1px solid rgba(148,163,184,0.18);\n      overflow: hidden;\n    }\n    .code header {\n      padding: 10px 12px;\n      border-bottom: 1px solid rgba(148,163,184,0.18);\n      display: flex;\n      align-items: baseline;\n      justify-content: space-between;\n    }\n    .code header .title { font-size: 14px; color: var(--muted); }\n    .code pre {\n      margin: 0; padding: 12px;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n      font-size: 13px;\n      color: #d1d5db;\n      white-space: pre;\n    }\n    .line { padding: 4px 8px; border-left: 3px solid transparent; }\n    .line .ln { color: #64748b; width: 24px; display: inline-block; }\n    .line.active {\n      background: var(--code-active);\n      border-left-color: var(--accent);\n      color: #e5e7eb;\n    }\n    .desc {\n      font-size: 14px;\n      color: var(--muted);\n      margin-top: 10px;\n    }\n    .input-row {\n      display: flex;\n      gap: 8px;\n      flex-wrap: wrap;\n      align-items: stretch;\n    }\n    .input-row input[type=\"text\"] {\n      flex: 1 1 240px;\n      min-width: 150px;\n      padding: 10px 12px;\n      border-radius: 10px;\n      border: 1px solid var(--btn-border);\n      background: rgba(255,255,255,0.02);\n      color: var(--text);\n      outline: none;\n    }\n    .input-row input[type=\"text\"]:focus {\n      border-color: var(--focus);\n      box-shadow: 0 0 0 3px rgba(125, 211, 252, 0.15);\n    }\n    .hint { color: var(--muted); font-size: 12px; }\n    .footer-note {\n      margin-top: 8px;\n      color: var(--muted);\n      font-size: 12px;\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>\n      Bubble Sort Visualizer\n      <span class=\"badge\">Adjacent swaps • Stable • O(n^2)</span>\n    </h1>\n  </header>\n\n  <div class=\"container\">\n    <section class=\"panel\">\n      <div class=\"controls\">\n        <div class=\"row\">\n          <div class=\"group\">\n            <label>Size</label>\n            <input id=\"size\" type=\"range\" min=\"5\" max=\"120\" value=\"30\" />\n            <div id=\"sizeVal\" class=\"val\">30</div>\n          </div>\n          <div class=\"group\">\n            <label>Speed (ms/step)</label>\n            <input id=\"speed\" type=\"range\" min=\"20\" max=\"1200\" value=\"200\" />\n            <div id=\"speedVal\" class=\"val\">200</div>\n          </div>\n          <label class=\"toggle\" title=\"Stop early if a pass makes no swaps\">\n            <input id=\"opt\" type=\"checkbox\" checked />\n            Early exit optimization\n          </label>\n          <div class=\"spacer\"></div>\n          <button id=\"shuffle\" class=\"btn soft\" title=\"Generate a new random array\">\n            Randomize\n          </button>\n          <button id=\"start\" class=\"btn primary\">\n            Start\n          </button>\n          <button id=\"pause\" class=\"btn warn\" disabled>\n            Pause\n          </button>\n          <button id=\"step\" class=\"btn\" title=\"Advance one algorithm step\">\n            Step\n          </button>\n          <button id=\"reset\" class=\"btn danger\" title=\"Restore the initial array\">\n            Reset\n          </button>\n        </div>\n\n        <div class=\"row\">\n          - Custom values (comma-separated):\n        </div>\n        <div class=\"input-row\">\n          <input id=\"custom\" type=\"text\" placeholder=\"Example: 5, 1, 4, 2, 8\" />\n          <button id=\"applyCustom\" class=\"btn\">Apply</button>\n          <span class=\"hint\">Values are normalized and scaled to bar heights. Up to 200 numbers.</span>\n        </div>\n\n        <div class=\"stats\">\n          <div class=\"stat\">\n            <div class=\"k\">Comparisons</div>\n            <div id=\"cmp\" class=\"v\">0</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"k\">Swaps</div>\n            <div id=\"swp\" class=\"v\">0</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"k\">Passes</div>\n            <div id=\"pas\" class=\"v\">0</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"k\">Status</div>\n            <div id=\"status\" class=\"v\">Ready</div>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"viz\">\n        <div id=\"bars\" class=\"bars\" aria-label=\"Bars visualization\"></div>\n      </div>\n      <div class=\"legend\">\n        <span class=\"dot compare\"></span><span>Compare</span>\n        <span class=\"dot swap\"></span><span>Swap</span>\n        <span class=\"dot sorted\"></span><span>Sorted</span>\n      </div>\n      <div class=\"desc\">\n        Bubble sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. After each pass, the largest remaining element “bubbles” to its final position at the end.\n      </div>\n      <div class=\"footer-note\">\n        Tip: Use Step to advance one comparison/swap at a time, or Start/Pause to animate. Early exit stops when a full pass makes no swaps.\n      </div>\n    </section>\n\n    <section class=\"panel code\">\n      <header>\n        <div class=\"title\">Bubble Sort pseudocode</div>\n      </header>\n      <pre id=\"code\">\n<span class=\"line\" data-ln=\"1\"><span class=\"ln\">1</span> for i from 0 to n - 2:</span>\n<span class=\"line\" data-ln=\"2\"><span class=\"ln\">2</span>   swapped = false</span>\n<span class=\"line\" data-ln=\"3\"><span class=\"ln\">3</span>   for j from 0 to n - 2 - i:</span>\n<span class=\"line\" data-ln=\"4\"><span class=\"ln\">4</span>     if a[j] > a[j + 1]:</span>\n<span class=\"line\" data-ln=\"5\"><span class=\"ln\">5</span>       swap(a[j], a[j + 1]); swapped = true</span>\n<span class=\"line\" data-ln=\"6\"><span class=\"ln\">6</span>   if not swapped: break  // early exit</span>\n      </pre>\n    </section>\n  </div>\n\n  <script>\n    // State\n    let arr = [];\n    let initialArr = [];\n    let maxVal = 100;\n    let generator = null;\n    let running = false;\n    let speed = 200;\n    let stats = { cmp: 0, swp: 0, pas: 0 };\n    let sortedUntil = null; // track last sorted index from end\n    let lastCompared = null;\n\n    // Elements\n    const barsEl = document.getElementById('bars');\n    const sizeEl = document.getElementById('size');\n    const speedEl = document.getElementById('speed');\n    const sizeValEl = document.getElementById('sizeVal');\n    const speedValEl = document.getElementById('speedVal');\n    const optEl = document.getElementById('opt');\n    const shuffleBtn = document.getElementById('shuffle');\n    const startBtn = document.getElementById('start');\n    const pauseBtn = document.getElementById('pause');\n    const stepBtn = document.getElementById('step');\n    const resetBtn = document.getElementById('reset');\n    const cmpEl = document.getElementById('cmp');\n    const swpEl = document.getElementById('swp');\n    const pasEl = document.getElementById('pas');\n    const statusEl = document.getElementById('status');\n    const customEl = document.getElementById('custom');\n    const applyCustomBtn = document.getElementById('applyCustom');\n\n    const codeEl = document.getElementById('code');\n    const codeLines = [...codeEl.querySelectorAll('.line')];\n\n    function randInt(min, max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }\n\n    function setStatus(text) { statusEl.textContent = text; }\n\n    function resetStats() {\n      stats = { cmp: 0, swp: 0, pas: 0 };\n      cmpEl.textContent = '0';\n      swpEl.textContent = '0';\n      pasEl.textContent = '0';\n    }\n\n    function highlightLines(lines) {\n      codeLines.forEach(l => l.classList.remove('active'));\n      if (!lines) return;\n      lines.forEach(ln => {\n        const el = codeEl.querySelector(`.line[data-ln=\"${ln}\"]`);\n        if (el) el.classList.add('active');\n      });\n    }\n\n    function generateRandom(size) {\n      const out = new Array(size).fill(0).map(() => randInt(5, 100));\n      return out;\n    }\n\n    function cloneArray(a) { return a.slice(); }\n\n    function computeMaxVal(a) {\n      const m = Math.max(...a);\n      return Math.max(m, 1);\n    }\n\n    function renderBars() {\n      barsEl.innerHTML = '';\n      const n = arr.length;\n      for (let i = 0; i < n; i++) {\n        const bar = document.createElement('div');\n        bar.className = 'bar';\n        bar.style.height = `${Math.round((arr[i] / maxVal) * 100)}%`;\n        bar.dataset.val = arr[i];\n        bar.title = String(arr[i]);\n        barsEl.appendChild(bar);\n      }\n    }\n\n    function updateBar(i) {\n      const bar = barsEl.children[i];\n      if (!bar) return;\n      bar.style.height = `${Math.round((arr[i] / maxVal) * 100)}%`;\n      bar.dataset.val = arr[i];\n      bar.title = String(arr[i]);\n    }\n\n    function clearHighlights() {\n      [...barsEl.children].forEach(b => {\n        b.classList.remove('comparing', 'swapping');\n      });\n    }\n\n    function clearSortedMarks() {\n      [...barsEl.children].forEach(b => b.classList.remove('sorted'));\n      sortedUntil = null;\n    }\n\n    function markSortedIndex(index) {\n      const bar = barsEl.children[index];\n      if (bar) bar.classList.add('sorted');\n    }\n\n    function markAllSorted() {\n      [...barsEl.children].forEach(b => {\n        b.classList.remove('comparing', 'swapping');\n        b.classList.add('sorted');\n      });\n    }\n\n    function disableDuringRun(disabled) {\n      sizeEl.disabled = disabled;\n      customEl.disabled = disabled;\n      applyCustomBtn.disabled = disabled;\n      shuffleBtn.disabled = disabled;\n    }\n\n    function newGenerator() {\n      generator = bubbleSort(arr, optEl.checked);\n    }\n\n    function* bubbleSort(a, earlyExit) {\n      const n = a.length;\n      if (n <= 1) { yield { type: 'done' }; return; }\n      for (let i = 0; i < n - 1; i++) {\n        let swapped = false;\n        yield { type: 'outer', i };\n        for (let j = 0; j < n - 1 - i; j++) {\n          yield { type: 'inner', i, j };\n          yield { type: 'compare', j, j1: j + 1, i };\n          if (a[j] > a[j + 1]) {\n            const tmp = a[j]; a[j] = a[j + 1]; a[j + 1] = tmp;\n            swapped = true;\n            yield { type: 'swap', j, j1: j + 1, i };\n          }\n        }\n        yield { type: 'pass-end', i, swapped };\n        if (earlyExit && !swapped) {\n          yield { type: 'no-swap-break', i };\n          break;\n        }\n      }\n      yield { type: 'done' };\n    }\n\n    function updateStats(ev) {\n      if (ev.type === 'compare') {\n        stats.cmp++; cmpEl.textContent = String(stats.cmp);\n      } else if (ev.type === 'swap') {\n        stats.swp++; swpEl.textContent = String(stats.swp);\n      } else if (ev.type === 'pass-end') {\n        stats.pas++; pasEl.textContent = String(stats.pas);\n      }\n    }\n\n    function highlightForEvent(ev) {\n      switch (ev.type) {\n        case 'outer': highlightLines([1,2]); break;\n        case 'inner': highlightLines([3]); break;\n        case 'compare': highlightLines([4]); break;\n        case 'swap': highlightLines([5]); break;\n        case 'pass-end':\n        case 'no-swap-break': highlightLines([6]); break;\n        case 'done': highlightLines([]); break;\n        default: break;\n      }\n    }\n\n    function handleEvent(ev) {\n      updateStats(ev);\n      highlightForEvent(ev);\n      switch (ev.type) {\n        case 'outer': {\n          setStatus(`Pass ${ev.i + 1} / ${arr.length - 1}`);\n          // could clear comparison highlights at new pass\n          clearHighlights();\n          break;\n        }\n        case 'inner': {\n          // nothing visual here beyond code highlight\n          break;\n        }\n        case 'compare': {\n          clearHighlights();\n          const b1 = barsEl.children[ev.j];\n          const b2 = barsEl.children[ev.j1];\n          if (b1 && b2) {\n            b1.classList.add('comparing');\n            b2.classList.add('comparing');\n          }\n          lastCompared = [ev.j, ev.j1];\n          break;\n        }\n        case 'swap': {\n          const b1 = barsEl.children[ev.j];\n          const b2 = barsEl.children[ev.j1];\n          if (b1 && b2) {\n            b1.classList.remove('comparing');\n            b2.classList.remove('comparing');\n            b1.classList.add('swapping');\n            b2.classList.add('swapping');\n          }\n          // update bar heights to reflect swap in arr\n          updateBar(ev.j);\n          updateBar(ev.j1);\n          break;\n        }\n        case 'pass-end': {\n          // mark the largest element bubbled to its final position\n          const idx = arr.length - 1 - ev.i;\n          markSortedIndex(idx);\n          clearHighlights();\n          if (!ev.swapped && optEl.checked) {\n            setStatus('No swaps this pass: early exit');\n          }\n          break;\n        }\n        case 'no-swap-break': {\n          // Mark all as sorted since array is sorted early\n          markAllSorted();\n          break;\n        }\n        case 'done': {\n          setStatus('Sorted');\n          // Make sure everything is marked sorted\n          markAllSorted();\n          break;\n        }\n      }\n    }\n\n    async function doOneStep() {\n      if (!generator) newGenerator();\n      const { value, done } = generator.next();\n      if (done) {\n        handleEvent({ type: 'done' }); // ensure UI shows done\n        running = false;\n        startBtn.textContent = 'Start';\n        pauseBtn.disabled = true;\n        disableDuringRun(false);\n        return false;\n      }\n      handleEvent(value);\n      return true;\n    }\n\n    async function run() {\n      if (running) return;\n      running = true;\n      startBtn.textContent = 'Running...';\n      pauseBtn.disabled = false;\n      disableDuringRun(true);\n      while (running) {\n        const cont = await doOneStep();\n        if (!cont) break;\n        await sleep(speed);\n      }\n    }\n\n    function pause() {\n      running = false;\n      pauseBtn.disabled = true;\n      startBtn.textContent = 'Resume';\n      disableDuringRun(false);\n      setStatus('Paused');\n    }\n\n    function resetToInitial() {\n      running = false;\n      pauseBtn.disabled = true;\n      startBtn.textContent = 'Start';\n      disableDuringRun(false);\n      arr = cloneArray(initialArr);\n      maxVal = computeMaxVal(arr);\n      resetStats();\n      renderBars();\n      clearSortedMarks();\n      highlightLines([]);\n      generator = null;\n      setStatus('Reset');\n    }\n\n    function applyNewArray(newArr) {\n      running = false;\n      pauseBtn.disabled = true;\n      startBtn.textContent = 'Start';\n      disableDuringRun(false);\n      arr = newArr.slice();\n      initialArr = newArr.slice();\n      maxVal = computeMaxVal(arr);\n      resetStats();\n      renderBars();\n      clearSortedMarks();\n      highlightLines([]);\n      generator = null;\n      setStatus('Ready');\n    }\n\n    function parseCustomInput(text) {\n      if (!text) return null;\n      // Split on commas, spaces, or semicolons\n      const tokens = text.split(/[\\s,;]+/).filter(Boolean);\n      if (tokens.length === 0) return null;\n      const nums = [];\n      for (let i = 0; i < tokens.length && nums.length < 200; i++) {\n        const v = Number(tokens[i]);\n        if (!isFinite(v)) continue;\n        nums.push(v);\n      }\n      if (nums.length === 0) return null;\n      // Normalize: If numbers vary a lot, just keep their values; we scale by maxVal later\n      return nums;\n    }\n\n    // Event bindings\n    sizeEl.addEventListener('input', () => {\n      sizeValEl.textContent = sizeEl.value;\n    });\n    sizeEl.addEventListener('change', () => {\n      const size = Number(sizeEl.value);\n      const a = generateRandom(size);\n      applyNewArray(a);\n    });\n\n    speedEl.addEventListener('input', () => {\n      speed = Number(speedEl.value);\n      speedValEl.textContent = String(speed);\n    });\n\n    shuffleBtn.addEventListener('click', () => {\n      const size = Number(sizeEl.value);\n      applyNewArray(generateRandom(size));\n    });\n\n    startBtn.addEventListener('click', () => {\n      run();\n    });\n    pauseBtn.addEventListener('click', () => {\n      pause();\n    });\n    stepBtn.addEventListener('click', async () => {\n      if (running) return; // prevent double stepping while running\n      const cont = await doOneStep();\n      if (cont) {\n        setStatus('Stepped');\n      }\n    });\n    resetBtn.addEventListener('click', () => {\n      resetToInitial();\n    });\n\n    applyCustomBtn.addEventListener('click', () => {\n      const parsed = parseCustomInput(customEl.value);\n      if (!parsed) {\n        setStatus('Invalid input');\n        return;\n      }\n      sizeEl.value = String(parsed.length);\n      sizeValEl.textContent = String(parsed.length);\n      applyNewArray(parsed);\n    });\n\n    // Initialize\n    (function init() {\n      sizeValEl.textContent = sizeEl.value;\n      speedValEl.textContent = speedEl.value;\n      speed = Number(speedEl.value);\n      const initial = generateRandom(Number(sizeEl.value));\n      applyNewArray(initial);\n    })();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Bubble Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "01c3e950-a36b-11f0-88cb-cb1f64d46d24",
    "timestamp": "2025-10-07T10:47:23.493Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Selection Sort",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n<title>Selection Sort Visualizer</title>\n<style>\n  :root {\n    --bg: #0f1420;\n    --panel: #151d2c;\n    --accent: #4db5ff;\n    --text: #e6edf3;\n    --muted: #9fb0c3;\n    --sorted: #4caf50;\n    --current: #1976d2;\n    --min: #e53935;\n    --scan: #fb8c00;\n    --bar: #90a4ae;\n    --swap: #ff5370;\n  }\n  * { box-sizing: border-box; }\n  body {\n    margin: 0; padding: 16px;\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Apple Color Emoji\",\"Segoe UI Emoji\";\n    background: linear-gradient(180deg, #0d1220, #0f1420);\n    color: var(--text);\n  }\n  h1 {\n    font-weight: 700; letter-spacing: 0.2px; margin: 0 0 8px 0;\n  }\n  .sub {\n    color: var(--muted); margin-bottom: 16px; font-size: 14px;\n  }\n  .container {\n    display: grid; gap: 12px;\n    grid-template-columns: 1fr;\n    max-width: 1000px; margin: 0 auto;\n  }\n  .panel {\n    background: var(--panel);\n    border: 1px solid #1f2a42;\n    border-radius: 12px;\n    padding: 12px;\n  }\n  .controls {\n    display: grid; gap: 8px;\n    grid-template-columns: repeat(12, 1fr);\n    align-items: center;\n  }\n  .controls .wide { grid-column: span 12; }\n  .controls .half { grid-column: span 6; }\n  .controls .third { grid-column: span 4; }\n  .controls .two { grid-column: span 2; }\n  .controls .three { grid-column: span 3; }\n  .controls label {\n    font-size: 12px; color: var(--muted);\n  }\n  input[type=\"text\"], input[type=\"number\"], input[type=\"range\"], select {\n    width: 100%; padding: 8px; border-radius: 8px;\n    border: 1px solid #27324a; background: #0f1626; color: var(--text);\n  }\n  .btn {\n    width: 100%; padding: 10px 12px; border-radius: 10px; border: none;\n    background: #203555; color: var(--text); cursor: pointer;\n    transition: transform 0.05s ease, filter 0.1s ease;\n  }\n  .btn:hover { filter: brightness(1.15); }\n  .btn:active { transform: scale(0.98); }\n  .btn.primary { background: #2563eb; }\n  .btn.warn { background: #e53935; }\n  .btn.secondary { background: #11519c; }\n  .row { display: flex; gap: 8px; align-items: center; }\n  .stats {\n    display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;\n  }\n  .stat {\n    background: #0f1626; border: 1px solid #27324a; border-radius: 10px;\n    padding: 10px;\n  }\n  .stat .k { font-size: 12px; color: var(--muted); }\n  .stat .v { font-size: 16px; font-weight: 700; }\n  .viz-wrap {\n    display: grid; grid-template-columns: 1fr; gap: 12px;\n  }\n  .bar-legend { display: flex; gap: 12px; flex-wrap: wrap; font-size: 12px; color: var(--muted); }\n  .legend-item { display: inline-flex; align-items: center; gap: 6px; }\n  .dot { width: 14px; height: 14px; border-radius: 4px; display: inline-block; }\n  .bars {\n    position: relative;\n    height: 300px;\n    background: #0c1322;\n    border: 1px solid #1f2a42;\n    border-radius: 12px;\n    overflow: hidden;\n    padding: 8px;\n    display: flex;\n    align-items: flex-end;\n    gap: 4px;\n  }\n  .bar {\n    flex: 1 1 auto;\n    min-width: 16px;\n    display: flex; align-items: flex-end; justify-content: center;\n    position: relative;\n    transition: transform 0.2s ease;\n  }\n  .bar-rect {\n    width: 100%;\n    border-radius: 6px 6px 0 0;\n    background: var(--bar);\n    transition: height 0.25s ease, background 0.15s ease, filter 0.1s ease, transform 0.2s ease;\n  }\n  .bar-label {\n    position: absolute; bottom: 0; transform: translateY(100%);\n    font-size: 12px; color: var(--muted);\n    background: rgba(0,0,0,0.25); padding: 2px 6px; border-radius: 8px;\n  }\n  .bar.sorted .bar-rect { background: var(--sorted); }\n  .bar.i .bar-rect { background: var(--current); }\n  .bar.min .bar-rect { background: var(--min); }\n  .bar.j .bar-rect { background: var(--scan); }\n  .bar.swap .bar-rect { background: var(--swap); }\n  .explain {\n    font-size: 13px; color: var(--muted);\n  }\n  .explain ul { margin: 8px 0 0 18px; }\n  .code {\n    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, \"Liberation Mono\", monospace;\n    background: #0c1322; border: 1px solid #1f2a42; border-radius: 12px;\n    padding: 10px; font-size: 12px; color: #cbd5e1;\n    white-space: pre;\n  }\n  .code .hl { background: rgba(66, 165, 245, 0.2); border-left: 3px solid #42a5f5; padding-left: 6px; }\n  .footer {\n    font-size: 12px; color: var(--muted); text-align: center; margin-top: 8px;\n  }\n  @media (max-width: 700px) {\n    .controls .half, .controls .third, .controls .two, .controls .three { grid-column: span 12; }\n    .stats { grid-template-columns: repeat(2, 1fr); }\n  }\n</style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"panel\">\n      <h1>Selection Sort</h1>\n      <div class=\"sub\">Visual demonstration of the Selection Sort algorithm with step-by-step controls.</div>\n      <div class=\"controls\">\n        <div class=\"wide\">\n          <label for=\"arrayInput\">Array (comma or space separated)</label>\n          <input id=\"arrayInput\" type=\"text\" placeholder=\"e.g. 64, 25, 12, 22, 11\"/>\n        </div>\n        <div class=\"three\">\n          <label for=\"sizeInput\">Size</label>\n          <input id=\"sizeInput\" type=\"number\" min=\"3\" max=\"50\" value=\"12\"/>\n        </div>\n        <div class=\"three\">\n          <label for=\"rangeInput\">Max value</label>\n          <input id=\"rangeInput\" type=\"number\" min=\"10\" max=\"999\" value=\"99\"/>\n        </div>\n        <div class=\"three\">\n          <label>&nbsp;</label>\n          <button id=\"randomBtn\" class=\"btn\">Random</button>\n        </div>\n        <div class=\"three\">\n          <label>&nbsp;</label>\n          <button id=\"setBtn\" class=\"btn secondary\">Set Array</button>\n        </div>\n        <div class=\"three\">\n          <label for=\"speed\">Speed</label>\n          <input id=\"speed\" type=\"range\" min=\"0\" max=\"100\" value=\"50\"/>\n        </div>\n        <div class=\"three\">\n          <label>&nbsp;</label>\n          <button id=\"playPauseBtn\" class=\"btn primary\">Play</button>\n        </div>\n        <div class=\"three\">\n          <label>&nbsp;</label>\n          <button id=\"stepBtn\" class=\"btn\">Step</button>\n        </div>\n        <div class=\"three\">\n          <label>&nbsp;</label>\n          <button id=\"resetBtn\" class=\"btn warn\">Reset</button>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"stats\">\n        <div class=\"stat\">\n          <div class=\"k\">Outer pass (i)</div>\n          <div class=\"v\" id=\"statI\">0</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"k\">Current scan (j)</div>\n          <div class=\"v\" id=\"statJ\">—</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"k\">Min index</div>\n          <div class=\"v\" id=\"statMin\">—</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"k\">Phase</div>\n          <div class=\"v\" id=\"statPhase\">idle</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"k\">Comparisons</div>\n          <div class=\"v\" id=\"statCmp\">0</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"k\">Swaps</div>\n          <div class=\"v\" id=\"statSwp\">0</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"k\">Array length</div>\n          <div class=\"v\" id=\"statN\">0</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"k\">Done</div>\n          <div class=\"v\" id=\"statDone\">no</div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel viz-wrap\">\n      <div class=\"bar-legend\">\n        <span class=\"legend-item\"><span class=\"dot\" style=\"background: var(--sorted)\"></span> Sorted</span>\n        <span class=\"legend-item\"><span class=\"dot\" style=\"background: var(--current)\"></span> Position i</span>\n        <span class=\"legend-item\"><span class=\"dot\" style=\"background: var(--min)\"></span> Current min</span>\n        <span class=\"legend-item\"><span class=\"dot\" style=\"background: var(--scan)\"></span> Scanning j</span>\n        <span class=\"legend-item\"><span class=\"dot\" style=\"background: var(--swap)\"></span> Swapping</span>\n      </div>\n      <div id=\"bars\" class=\"bars\" aria-label=\"Bars visualization\"></div>\n      <div class=\"explain\">\n        Selection Sort repeatedly selects the smallest remaining element and places it at the front.\n        <ul>\n          <li>Maintain position i where the next smallest element should go.</li>\n          <li>Scan the unsorted tail [i+1..n-1] to find the minimum.</li>\n          <li>Swap the found minimum with position i.</li>\n          <li>Time complexity: O(n²), Space complexity: O(1), Not stable.</li>\n        </ul>\n      </div>\n      <div class=\"code\" id=\"code\">\nfor i = 0 .. n-1:\n    min = i\n    for j = i+1 .. n-1:\n        if A[j] < A[min]:\n            min = j\n    swap A[i], A[min]\n      </div>\n      <div class=\"footer\">Tip: Edit the array, click Set Array or generate random, then Play or Step to watch the algorithm.</div>\n    </div>\n  </div>\n\n<script>\n(function(){\n  \"use strict\";\n\n  // State and configuration\n  let initialArr = [];\n  let arr = [];\n  let playing = false;\n  let timer = null;\n  let speedMs = 250;\n  const minDelay = 30, maxDelay = 900;\n\n  const state = {\n    i: 0,\n    j: null,\n    minIndex: null,\n    phase: \"idle\", // idle | initPass | scan | updateMin | swap | done\n    comparisons: 0,\n    swaps: 0,\n    done: false,\n    lastActionSwapPair: null, // [i, minIndex] when swapping\n  };\n\n  // DOM elements\n  const el = {\n    arrayInput: document.getElementById(\"arrayInput\"),\n    sizeInput: document.getElementById(\"sizeInput\"),\n    rangeInput: document.getElementById(\"rangeInput\"),\n    randomBtn: document.getElementById(\"randomBtn\"),\n    setBtn: document.getElementById(\"setBtn\"),\n    playPauseBtn: document.getElementById(\"playPauseBtn\"),\n    stepBtn: document.getElementById(\"stepBtn\"),\n    resetBtn: document.getElementById(\"resetBtn\"),\n    speed: document.getElementById(\"speed\"),\n    bars: document.getElementById(\"bars\"),\n    statI: document.getElementById(\"statI\"),\n    statJ: document.getElementById(\"statJ\"),\n    statMin: document.getElementById(\"statMin\"),\n    statPhase: document.getElementById(\"statPhase\"),\n    statCmp: document.getElementById(\"statCmp\"),\n    statSwp: document.getElementById(\"statSwp\"),\n    statN: document.getElementById(\"statN\"),\n    statDone: document.getElementById(\"statDone\"),\n    code: document.getElementById(\"code\"),\n  };\n\n  // Utility\n  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }\n  function randInt(a, b){ return a + Math.floor(Math.random() * (b - a + 1)); }\n  function parseArray(str) {\n    const parts = str.split(/[, \\t\\n]+/).filter(Boolean);\n    const nums = parts.map(p => Number(p)).filter(n => Number.isFinite(n));\n    return nums;\n  }\n  function resetState() {\n    state.i = 0;\n    state.j = null;\n    state.minIndex = null;\n    state.phase = arr.length <= 1 ? \"done\" : \"idle\";\n    state.comparisons = 0;\n    state.swaps = 0;\n    state.done = arr.length <= 1;\n    state.lastActionSwapPair = null;\n    updateStats();\n    render();\n  }\n\n  // Visualization\n  function render() {\n    el.bars.innerHTML = \"\";\n    const n = arr.length, maxVal = Math.max(...arr, 1);\n    const minHeight = 6;\n    const containerH = el.bars.clientHeight || 300;\n\n    for (let idx = 0; idx < n; idx++) {\n      const h = Math.round((arr[idx] / maxVal) * (containerH - 30)) + minHeight;\n\n      const bar = document.createElement(\"div\");\n      bar.className = \"bar\";\n      const rect = document.createElement(\"div\");\n      rect.className = \"bar-rect\";\n      rect.style.height = h + \"px\";\n      const label = document.createElement(\"div\");\n      label.className = \"bar-label\";\n      label.textContent = arr[idx];\n\n      // Color coding\n      const classes = [];\n      if (state.phase === \"swap\" && state.lastActionSwapPair &&\n          (idx === state.lastActionSwapPair[0] || idx === state.lastActionSwapPair[1])) {\n        classes.push(\"swap\");\n      } else {\n        if (state.done || state.i >= arr.length - 1) {\n          classes.push(\"sorted\");\n        } else {\n          if (idx < state.i) classes.push(\"sorted\");\n          if (idx === state.i) classes.push(\"i\");\n          if (idx === state.minIndex) classes.push(\"min\");\n          if (idx === state.j) classes.push(\"j\");\n        }\n      }\n\n      bar.className += \" \" + classes.join(\" \");\n      bar.appendChild(rect);\n      bar.appendChild(label);\n      el.bars.appendChild(bar);\n    }\n\n    updateStats();\n    highlightCode();\n  }\n\n  function updateStats() {\n    el.statI.textContent = state.i ?? 0;\n    el.statJ.textContent = state.j ?? \"—\";\n    el.statMin.textContent = state.minIndex ?? \"—\";\n    el.statPhase.textContent = state.phase;\n    el.statCmp.textContent = state.comparisons;\n    el.statSwp.textContent = state.swaps;\n    el.statN.textContent = arr.length;\n    el.statDone.textContent = state.done ? \"yes\" : \"no\";\n  }\n\n  function highlightCode() {\n    // Simple heuristic: wrap lines with spans and mark one or two lines as highlighted based on phase.\n    // Build content once and then adjust classes.\n    if (!el.code.dataset.enhanced) {\n      const lines = el.code.textContent.split(\"\\n\");\n      el.code.innerHTML = lines.map((ln, i) => `<div data-l=\"${i+1}\">${ln || \"&nbsp;\"}</div>`).join(\"\");\n      el.code.dataset.enhanced = \"1\";\n    }\n    const children = Array.from(el.code.children);\n    children.forEach(ch => ch.classList.remove(\"hl\"));\n\n    const mapPhaseToLines = () => {\n      // Lines:\n      // 1: for i = 0 .. n-1:\n      // 2:     min = i\n      // 3:     for j = i+1 .. n-1:\n      // 4:         if A[j] < A[min]:\n      // 5:             min = j\n      // 6:     swap A[i], A[min]\n      switch (state.phase) {\n        case \"idle\": return [1];\n        case \"initPass\": return [1,2];\n        case \"scan\": return [3,4];\n        case \"updateMin\": return [5];\n        case \"swap\": return [6];\n        case \"done\": return [1];\n        default: return [1];\n      }\n    };\n    const lines = mapPhaseToLines();\n    lines.forEach(l => {\n      const node = children.find(ch => ch.dataset.l == String(l));\n      if (node) node.classList.add(\"hl\");\n    });\n  }\n\n  // Selection sort step engine\n  function startPass() {\n    if (state.i >= arr.length - 1) {\n      state.done = true;\n      state.phase = \"done\";\n      state.j = null;\n      state.minIndex = null;\n      return;\n    }\n    state.minIndex = state.i;\n    state.j = state.i + 1;\n    state.phase = \"initPass\";\n  }\n\n  function step() {\n    if (state.done) return false;\n\n    // If idle, initialize first pass\n    if (state.phase === \"idle\") {\n      startPass();\n      render();\n      return true;\n    }\n\n    // After initPass, move to scanning\n    if (state.phase === \"initPass\") {\n      state.phase = \"scan\";\n      render();\n      return true;\n    }\n\n    // Scan phase: compare A[j] with A[minIndex]\n    if (state.phase === \"scan\") {\n      if (state.j >= arr.length) {\n        state.phase = \"swap\";\n        state.lastActionSwapPair = [state.i, state.minIndex];\n        render();\n        return true;\n      } else {\n        // do one comparison\n        state.comparisons++;\n        if (arr[state.j] < arr[state.minIndex]) {\n          state.minIndex = state.j;\n          state.phase = \"updateMin\";\n          render();\n          return true;\n        } else {\n          state.j++;\n          render();\n          return true;\n        }\n      }\n    }\n\n    // Update min step is a visualization beat\n    if (state.phase === \"updateMin\") {\n      // After showing min update, continue scanning\n      state.j++;\n      state.phase = \"scan\";\n      render();\n      return true;\n    }\n\n    // Swap phase\n    if (state.phase === \"swap\") {\n      if (state.minIndex !== state.i) {\n        // perform swap\n        const t = arr[state.i];\n        arr[state.i] = arr[state.minIndex];\n        arr[state.minIndex] = t;\n        state.swaps++;\n      }\n      // progress i\n      state.i++;\n      state.phase = \"initPass\";\n      state.lastActionSwapPair = null;\n\n      if (state.i >= arr.length - 1) {\n        state.done = true;\n        state.phase = \"done\";\n        state.j = null;\n        state.minIndex = null;\n      } else {\n        state.j = state.i + 1;\n        state.minIndex = state.i;\n      }\n\n      render();\n      return true;\n    }\n\n    return false;\n  }\n\n  // Controls\n  function updateSpeedFromSlider() {\n    const v = Number(el.speed.value); // 0..100\n    // Map to delay (ms): faster towards 0\n    const t = Math.round(maxDelay - (v/100)*(maxDelay - minDelay));\n    speedMs = clamp(t, minDelay, maxDelay);\n  }\n\n  function play() {\n    if (playing || state.done) return;\n    playing = true;\n    el.playPauseBtn.textContent = \"Pause\";\n    tickLoop();\n  }\n  function pause() {\n    playing = false;\n    el.playPauseBtn.textContent = \"Play\";\n    if (timer) { clearTimeout(timer); timer = null; }\n  }\n  function tickLoop() {\n    if (!playing) return;\n    const haveMore = step();\n    if (!haveMore || state.done) {\n      pause();\n      render();\n      return;\n    }\n    timer = setTimeout(tickLoop, speedMs);\n  }\n  function stepOnce() {\n    pause();\n    step();\n  }\n\n  function setArray(a) {\n    initialArr = a.slice();\n    arr = a.slice();\n    resetState();\n  }\n\n  function randomArray(n, maxV) {\n    const out = [];\n    for (let i = 0; i < n; i++) {\n      out.push(randInt(1, maxV));\n    }\n    return out;\n  }\n\n  function resetToInitial() {\n    arr = initialArr.slice();\n    pause();\n    resetState();\n  }\n\n  // Wire events\n  el.randomBtn.addEventListener(\"click\", () => {\n    const n = clamp(Number(el.sizeInput.value) || 12, 3, 50);\n    const maxV = clamp(Number(el.rangeInput.value) || 99, 10, 999);\n    const a = randomArray(n, maxV);\n    el.arrayInput.value = a.join(\", \");\n    setArray(a);\n  });\n\n  el.setBtn.addEventListener(\"click\", () => {\n    const nums = parseArray(el.arrayInput.value);\n    if (!nums.length) {\n      alert(\"Please enter at least one number.\");\n      return;\n    }\n    setArray(nums);\n  });\n\n  el.playPauseBtn.addEventListener(\"click\", () => {\n    if (playing) pause(); else play();\n  });\n\n  el.stepBtn.addEventListener(\"click\", () => stepOnce());\n\n  el.resetBtn.addEventListener(\"click\", () => resetToInitial());\n\n  el.speed.addEventListener(\"input\", () => {\n    updateSpeedFromSlider();\n  });\n\n  // Init demo\n  function initDemo() {\n    updateSpeedFromSlider();\n    const demo = [64, 25, 12, 22, 11, 90, 3, 78, 45, 19, 5, 37];\n    el.arrayInput.value = demo.join(\", \");\n    setArray(demo);\n  }\n\n  // Start\n  initDemo();\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Selection Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "2b3d2120-a36b-11f0-86c6-afabd77374e5",
    "timestamp": "2025-10-07T10:48:33.075Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Insertion Sort",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<title>Insertion Sort Visualizer</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<style>\n  :root{\n    --bg:#0f172a;\n    --panel:#111827;\n    --accent:#60a5fa;\n    --accent-2:#34d399;\n    --accent-3:#f59e0b;\n    --accent-4:#ef4444;\n    --text:#e5e7eb;\n    --muted:#9ca3af;\n  }\n  * { box-sizing: border-box; }\n  body {\n    margin: 0;\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Liberation Sans\", sans-serif;\n    background: linear-gradient(120deg, #0b1023, #0f172a 40%, #0b1023);\n    color: var(--text);\n  }\n  header {\n    padding: 20px;\n    text-align: center;\n  }\n  header h1 {\n    margin: 0 0 6px 0;\n    font-weight: 700;\n    letter-spacing: 0.5px;\n  }\n  header p {\n    margin: 0;\n    color: var(--muted);\n    font-size: 14px;\n  }\n\n  .container {\n    max-width: 1100px;\n    margin: 0 auto;\n    padding: 12px 16px 40px;\n  }\n\n  .controls {\n    display: grid;\n    grid-template-columns: 1fr 1fr 1fr 2fr;\n    gap: 12px;\n    align-items: center;\n    background: rgba(17, 24, 39, 0.65);\n    border: 1px solid rgba(255,255,255,0.06);\n    border-radius: 12px;\n    padding: 12px;\n    backdrop-filter: blur(6px);\n  }\n\n  .control-group {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    flex-wrap: wrap;\n  }\n  .control-group label {\n    font-size: 13px;\n    color: var(--muted);\n  }\n  .control-group input[type=\"range\"] {\n    width: 160px;\n  }\n  .select {\n    display: flex;\n    gap: 8px;\n  }\n  select, button {\n    border-radius: 8px;\n    border: 1px solid rgba(255,255,255,0.12);\n    background: #0b1220;\n    color: var(--text);\n    padding: 8px 10px;\n    font-size: 14px;\n    outline: none;\n  }\n  button {\n    cursor: pointer;\n    transition: background 0.2s ease, transform 0.04s ease;\n  }\n  button:hover { background: #0e1527; }\n  button:active { transform: translateY(1px); }\n  button.primary {\n    background: #0b2a4f;\n    border-color: rgba(96,165,250,0.3);\n  }\n  button.primary:hover { background: #0d315c; }\n  button.danger {\n    background: #3a0e0e;\n    border-color: rgba(239,68,68,0.3);\n  }\n  button.danger:hover { background: #4a1313; }\n  button.secondary {\n    background: #0b1120;\n  }\n  .controls .buttons {\n    display: flex;\n    gap: 8px;\n    flex-wrap: wrap;\n    justify-content: flex-end;\n  }\n\n  .stage {\n    margin-top: 14px;\n    display: grid;\n    grid-template-columns: 3fr 2fr;\n    gap: 14px;\n  }\n\n  .pane {\n    background: rgba(17, 24, 39, 0.65);\n    border: 1px solid rgba(255,255,255,0.06);\n    border-radius: 12px;\n    padding: 12px;\n    min-height: 80px;\n    position: relative;\n    backdrop-filter: blur(6px);\n  }\n\n  .bars {\n    position: relative;\n    height: 280px;\n    display: flex;\n    align-items: flex-end;\n    gap: 6px;\n    padding: 12px 12px 20px 12px;\n    isolation: isolate;\n  }\n\n  .bar {\n    flex: 1 1 0;\n    background: linear-gradient(180deg, rgba(96,165,250,0.35), rgba(96,165,250,0.65));\n    border-radius: 6px 6px 2px 2px;\n    min-width: 12px;\n    position: relative;\n    transition: height 280ms ease, background 180ms ease, transform 100ms ease, box-shadow 200ms ease;\n    height: 40px;\n    box-shadow: 0 1px 0 rgba(255,255,255,0.04) inset, 0 8px 18px rgba(0,0,0,0.25);\n  }\n  .bar::after {\n    content: attr(data-value);\n    position: absolute;\n    bottom: -22px;\n    left: 50%;\n    transform: translateX(-50%);\n    font-size: 12px;\n    color: var(--muted);\n  }\n  .bar.sorted {\n    background: linear-gradient(180deg, rgba(52,211,153,0.35), rgba(52,211,153,0.75));\n    box-shadow: 0 1px 0 rgba(255,255,255,0.04) inset, 0 8px 18px rgba(52,211,153,0.25);\n  }\n  .bar.compare {\n    background: linear-gradient(180deg, rgba(245,158,11,0.35), rgba(245,158,11,0.75));\n    transform: translateY(-3px);\n    box-shadow: 0 10px 22px rgba(245,158,11,0.25);\n  }\n  .bar.shift {\n    outline: 2px dashed rgba(245,158,11,0.5);\n    outline-offset: -2px;\n  }\n  .bar.gap {\n    background: repeating-linear-gradient(45deg, rgba(255,255,255,0.06), rgba(255,255,255,0.06) 6px, rgba(255,255,255,0.02) 6px, rgba(255,255,255,0.02) 12px);\n    box-shadow: none;\n    filter: saturate(0.7) brightness(0.9);\n  }\n  .bar.focus {\n    outline: 2px solid rgba(96,165,250,0.65);\n    outline-offset: -2px;\n  }\n\n  .key-chip {\n    position: absolute;\n    bottom: 100%;\n    transform: translate(-50%, -10px);\n    background: #0b2a4f;\n    border: 1px solid rgba(96,165,250,0.3);\n    color: var(--text);\n    padding: 6px 10px;\n    border-radius: 999px;\n    font-size: 13px;\n    white-space: nowrap;\n    box-shadow: 0 10px 18px rgba(0,0,0,0.3);\n    pointer-events: none;\n    transition: left 250ms ease, opacity 150ms ease;\n    opacity: 1;\n    z-index: 3;\n  }\n  .key-chip.hidden { opacity: 0; }\n\n  .legend {\n    display: flex;\n    gap: 12px;\n    flex-wrap: wrap;\n    font-size: 13px;\n    color: var(--muted);\n    margin-top: 6px;\n  }\n  .legend .item {\n    display: inline-flex;\n    align-items: center;\n    gap: 6px;\n  }\n  .swatch {\n    width: 18px; height: 10px; border-radius: 3px;\n    box-shadow: 0 1px 0 rgba(255,255,255,0.06) inset;\n  }\n  .swatch.sorted { background: rgba(52,211,153,0.65); }\n  .swatch.compare { background: rgba(245,158,11,0.75); }\n  .swatch.key { background: rgba(96,165,250,0.6); }\n  .swatch.gap { background: rgba(255,255,255,0.1); border: 1px dashed rgba(255,255,255,0.25); }\n\n  .metrics {\n    display: grid;\n    grid-template-columns: repeat(3,1fr);\n    gap: 8px;\n    margin-top: 10px;\n  }\n  .metric {\n    background: rgba(10, 15, 30, 0.6);\n    border: 1px solid rgba(255,255,255,0.06);\n    border-radius: 10px;\n    padding: 8px;\n  }\n  .metric .label { font-size: 12px; color: var(--muted); }\n  .metric .value { font-size: 18px; font-weight: 600; margin-top: 4px; }\n\n  .code {\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n    font-size: 13px;\n    line-height: 1.5;\n    background: #0a0f20;\n    border: 1px solid rgba(255,255,255,0.06);\n    border-radius: 10px;\n    overflow: hidden;\n  }\n  .code .line {\n    padding: 6px 10px;\n    border-bottom: 1px solid rgba(255,255,255,0.04);\n    color: #cbd5e1;\n  }\n  .code .line:last-child { border-bottom: none; }\n  .code .line .num { display: inline-block; width: 22px; color: #64748b; }\n  .code .line.hl {\n    background: rgba(96,165,250,0.10);\n    border-left: 3px solid rgba(96,165,250,0.65);\n  }\n\n  .info {\n    font-size: 13px;\n    color: var(--muted);\n    display: grid;\n    grid-template-columns: 1fr;\n    gap: 10px;\n  }\n  .info .badge {\n    display: inline-block;\n    padding: 2px 8px;\n    border-radius: 999px;\n    border: 1px solid rgba(255,255,255,0.1);\n    background: rgba(255,255,255,0.03);\n    color: #d1d5db;\n    margin-right: 6px;\n  }\n\n  .footer {\n    margin-top: 24px;\n    color: var(--muted);\n    font-size: 12px;\n    text-align: center;\n  }\n\n  @media (max-width: 900px) {\n    .controls { grid-template-columns: 1fr; }\n    .stage { grid-template-columns: 1fr; }\n    .metrics { grid-template-columns: 1fr 1fr; }\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Insertion Sort Visualizer</h1>\n  <p>Step through or animate the in-place, stable sorting algorithm.</p>\n</header>\n\n<div class=\"container\">\n  <div class=\"controls\">\n    <div class=\"control-group\">\n      <label for=\"size\">Array size</label>\n      <input id=\"size\" type=\"range\" min=\"5\" max=\"60\" value=\"20\" />\n      <span id=\"sizeLbl\">20</span>\n    </div>\n\n    <div class=\"control-group\">\n      <label for=\"speed\">Speed</label>\n      <input id=\"speed\" type=\"range\" min=\"0.2\" max=\"3\" step=\"0.1\" value=\"1\" />\n      <span id=\"speedLbl\">1.0x</span>\n    </div>\n\n    <div class=\"control-group\">\n      <label for=\"pattern\">Pattern</label>\n      <div class=\"select\">\n        <select id=\"pattern\">\n          <option value=\"random\">Random</option>\n          <option value=\"nearly\">Nearly sorted</option>\n          <option value=\"reversed\">Reversed</option>\n          <option value=\"few-unique\">Few unique</option>\n        </select>\n        <button id=\"shuffle\" title=\"Generate new array\">Randomize</button>\n      </div>\n    </div>\n\n    <div class=\"buttons\">\n      <button id=\"start\" class=\"primary\">Start</button>\n      <button id=\"step\">Step</button>\n      <button id=\"pause\" class=\"secondary\" disabled>Pause</button>\n      <button id=\"reset\" class=\"danger\">Reset</button>\n    </div>\n  </div>\n\n  <div class=\"pane\">\n    <div class=\"bars\" id=\"bars\"></div>\n    <div id=\"legend\" class=\"legend\">\n      <div class=\"item\"><span class=\"swatch sorted\"></span> sorted region</div>\n      <div class=\"item\"><span class=\"swatch compare\"></span> comparing j with key</div>\n      <div class=\"item\"><span class=\"swatch gap\"></span> gap position (key removed)</div>\n      <div class=\"item\"><span class=\"swatch key\"></span> key value</div>\n    </div>\n    <div class=\"metrics\">\n      <div class=\"metric\">\n        <div class=\"label\">Comparisons</div>\n        <div class=\"value\" id=\"mComparisons\">0</div>\n      </div>\n      <div class=\"metric\">\n        <div class=\"label\">Shifts</div>\n        <div class=\"value\" id=\"mShifts\">0</div>\n      </div>\n      <div class=\"metric\">\n        <div class=\"label\">Writes</div>\n        <div class=\"value\" id=\"mWrites\">0</div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"stage\">\n    <div class=\"pane\">\n      <div class=\"code\" id=\"code\">\n        <div class=\"line\" data-line=\"1\"><span class=\"num\">1</span> for i = 1 to n - 1</div>\n        <div class=\"line\" data-line=\"2\"><span class=\"num\">2</span>   key = A[i]</div>\n        <div class=\"line\" data-line=\"3\"><span class=\"num\">3</span>   j = i - 1</div>\n        <div class=\"line\" data-line=\"4\"><span class=\"num\">4</span>   while j >= 0 and A[j] > key</div>\n        <div class=\"line\" data-line=\"5\"><span class=\"num\">5</span>     A[j + 1] = A[j]</div>\n        <div class=\"line\" data-line=\"6\"><span class=\"num\">6</span>     j = j - 1</div>\n        <div class=\"line\" data-line=\"7\"><span class=\"num\">7</span>   A[j + 1] = key</div>\n      </div>\n    </div>\n    <div class=\"pane info\">\n      <div>\n        <span class=\"badge\">Stable</span>\n        <span class=\"badge\">In-place</span>\n        <span class=\"badge\">Adaptive</span>\n      </div>\n      <div>\n        Insertion sort builds a sorted region by inserting each element (the key) into its correct position.\n        It performs well on small or nearly sorted arrays and requires no extra memory beyond a constant amount.\n      </div>\n      <div>\n        Time complexity:\n        - Best: O(n) when nearly sorted (minimal shifts)\n        - Average: O(n^2)\n        - Worst: O(n^2) e.g., reversed input\n        Space: O(1)\n      </div>\n      <div id=\"status\">Status: Ready</div>\n    </div>\n  </div>\n\n  <div class=\"footer\">\n    Tip: Try \"Nearly sorted\" or \"Reversed\" to see best vs worst-case behavior.\n  </div>\n</div>\n\n<script>\n(function(){\n  // DOM elements\n  const barsEl = document.getElementById('bars');\n  const sizeEl = document.getElementById('size');\n  const sizeLbl = document.getElementById('sizeLbl');\n  const speedEl = document.getElementById('speed');\n  const speedLbl = document.getElementById('speedLbl');\n  const patternEl = document.getElementById('pattern');\n  const shuffleBtn = document.getElementById('shuffle');\n  const startBtn = document.getElementById('start');\n  const stepBtn = document.getElementById('step');\n  const pauseBtn = document.getElementById('pause');\n  const resetBtn = document.getElementById('reset');\n  const statusEl = document.getElementById('status');\n  const mComparisonsEl = document.getElementById('mComparisons');\n  const mShiftsEl = document.getElementById('mShifts');\n  const mWritesEl = document.getElementById('mWrites');\n  const codeEl = document.getElementById('code');\n\n  // Visual helpers\n  const keyChip = document.createElement('div');\n  keyChip.className = 'key-chip hidden';\n  keyChip.id = 'keyChip';\n  barsEl.appendChild(keyChip);\n\n  // State\n  let arr = [];\n  let bars = [];\n  let running = false;\n  let finished = false;\n  let baseInterval = 520; // ms\n  let speed = parseFloat(speedEl.value);\n  let size = parseInt(sizeEl.value, 10);\n  let metrics = { comparisons: 0, shifts: 0, writes: 0 };\n  let i = 1, j = 0, key = null, gapIndex = null;\n  let stage = 'idle'; // 'outer-init', 'while-check', 'shift', 'insert', 'outer-next', 'idle'\n  let tickHandle = null;\n\n  // Utility: random and patterns\n  function randInt(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }\n\n  function genArray(n, pattern='random'){\n    let a = new Array(n);\n    switch(pattern){\n      case 'random':\n        for(let k=0;k<n;k++) a[k] = randInt(10, 99);\n        break;\n      case 'nearly':\n        // Start sorted then apply small perturbations\n        a = Array.from({length:n}, (_,k)=> 10 + Math.round((k/(n-1))*89));\n        for(let t=0;t<Math.max(1, Math.floor(n*0.1)); t++){\n          const p = randInt(0, n-2);\n          // small swap neighbor\n          [a[p], a[p+1]] = [a[p+1], a[p]];\n        }\n        break;\n      case 'reversed':\n        a = Array.from({length:n}, (_,k)=> 10 + Math.round(((n-1-k)/(n-1))*89));\n        break;\n      case 'few-unique':\n        const candidates = [12, 26, 39, 53, 67, 81, 95];\n        for(let k=0;k<n;k++) a[k] = candidates[randInt(0, candidates.length-1)];\n        break;\n      default:\n        for(let k=0;k<n;k++) a[k] = randInt(10, 99);\n    }\n    return a;\n  }\n\n  // Rendering\n  function renderBars(){\n    barsEl.innerHTML = '';\n    bars = [];\n    const maxVal = Math.max(...arr);\n    const minVal = Math.min(...arr);\n    const usableHeight = 240;\n    for(let idx=0; idx<arr.length; idx++){\n      const b = document.createElement('div');\n      b.className = 'bar';\n      b.dataset.index = idx;\n      b.dataset.value = arr[idx];\n      const h = minVal === maxVal ? usableHeight/2 : Math.max(10, Math.round((arr[idx]-minVal)/(maxVal-minVal) * usableHeight) + 20);\n      b.style.height = h + 'px';\n      barsEl.appendChild(b);\n      bars.push(b);\n    }\n    barsEl.appendChild(keyChip);\n  }\n\n  function updateBars(){\n    const maxVal = Math.max(...arr);\n    const minVal = Math.min(...arr);\n    const usableHeight = 240;\n    for(let idx=0; idx<bars.length; idx++){\n      const b = bars[idx];\n      b.dataset.value = arr[idx];\n      const h = minVal === maxVal ? usableHeight/2 : Math.max(10, Math.round((arr[idx]-minVal)/(maxVal-minVal) * usableHeight) + 20);\n      b.style.height = h + 'px';\n    }\n  }\n\n  function clearClasses(){\n    bars.forEach(b=>{\n      b.classList.remove('sorted','compare','shift','gap','focus');\n    });\n  }\n\n  function markSortedRegion(sortedEndIdx){\n    for(let idx=0; idx<bars.length; idx++){\n      if(idx <= sortedEndIdx) bars[idx].classList.add('sorted');\n      else bars[idx].classList.remove('sorted');\n    }\n  }\n\n  function positionKeyChip(){\n    if(gapIndex == null || gapIndex < 0 || gapIndex >= bars.length) return;\n    const bar = bars[gapIndex];\n    const parentRect = barsEl.getBoundingClientRect();\n    const rect = bar.getBoundingClientRect();\n    const x = rect.left - parentRect.left + rect.width/2;\n    keyChip.style.left = x + 'px';\n  }\n\n  function showKeyChip(v){\n    keyChip.textContent = 'key = ' + v;\n    keyChip.classList.remove('hidden');\n    positionKeyChip();\n  }\n  function hideKeyChip(){\n    keyChip.classList.add('hidden');\n  }\n\n  function highlightCode(lines){\n    // remove previous highlights\n    [...codeEl.querySelectorAll('.line')].forEach(el=> el.classList.remove('hl'));\n    lines.forEach(n=>{\n      const ln = codeEl.querySelector(`.line[data-line=\"${n}\"]`);\n      if(ln) ln.classList.add('hl');\n    });\n  }\n\n  function setStatus(txt){ statusEl.textContent = 'Status: ' + txt; }\n\n  function updateMetrics(){\n    mComparisonsEl.textContent = metrics.comparisons;\n    mShiftsEl.textContent = metrics.shifts;\n    mWritesEl.textContent = metrics.writes;\n  }\n\n  // Sort control\n  function resetSortState(){\n    running = false;\n    finished = false;\n    metrics = { comparisons: 0, shifts: 0, writes: 0 };\n    i = 1; j = 0; key = null; gapIndex = null;\n    stage = 'idle';\n    updateMetrics();\n    clearClasses();\n    markSortedRegion(0);\n    hideKeyChip();\n    highlightCode([]); // none\n    setStatus('Ready');\n    pauseBtn.disabled = true;\n    startBtn.disabled = false;\n    stepBtn.disabled = false;\n  }\n\n  function prepareSort(){\n    i = 1;\n    j = 0;\n    key = null;\n    gapIndex = null;\n    stage = 'outer-init';\n    setStatus('Initialized (i = 1)');\n    markSortedRegion(0);\n  }\n\n  function stepSort(){\n    if(finished) return true;\n    switch(stage){\n      case 'outer-init': {\n        clearClasses();\n        highlightCode([1,2,3]);\n        if(i >= arr.length){\n          finished = true;\n          markSortedRegion(arr.length-1);\n          setStatus('Done');\n          hideKeyChip();\n          pauseBtn.disabled = true;\n          startBtn.disabled = true;\n          stepBtn.disabled = true;\n          return true;\n        }\n        key = arr[i];\n        j = i - 1;\n        gapIndex = i;\n        bars[i].classList.add('gap','focus');\n        showKeyChip(key);\n        positionKeyChip();\n        setStatus(`Pick key = ${key} at i = ${i}, j = ${j}`);\n        stage = 'while-check';\n        return false;\n      }\n      case 'while-check': {\n        highlightCode([4]);\n        clearClasses();\n        markSortedRegion(i-1);\n        if(gapIndex != null && gapIndex >= 0) bars[gapIndex].classList.add('gap');\n        if(j >= 0) bars[j].classList.add('compare');\n        metrics.comparisons++;\n        updateMetrics();\n        const cond = (j >= 0 && arr[j] > key);\n        setStatus(cond ? `Compare A[${j}] = ${arr[j]} > key ${key} ⇒ shift` : `Compare A[${j}] ${j>=0?('= '+arr[j]):''} with key ${key} ⇒ insert`);\n        stage = cond ? 'shift' : 'insert';\n        return false;\n      }\n      case 'shift': {\n        highlightCode([5,6]);\n        clearClasses();\n        markSortedRegion(i-1);\n        // Perform shift: arr[j+1] = arr[j]; gap moves left to j\n        arr[j+1] = arr[j];\n        metrics.shifts++;\n        updateMetrics();\n        updateBars();\n        bars[j+1].classList.add('shift');\n        gapIndex = j;\n        if(gapIndex >= 0) bars[gapIndex].classList.add('gap');\n        positionKeyChip();\n        j--;\n        stage = 'while-check';\n        return false;\n      }\n      case 'insert': {\n        highlightCode([7]);\n        clearClasses();\n        markSortedRegion(i-1);\n        // Insert key at j+1\n        arr[j+1] = key;\n        metrics.writes++;\n        updateMetrics();\n        updateBars();\n        bars[j+1].classList.add('focus');\n        hideKeyChip();\n        gapIndex = null;\n        setStatus(`Insert key ${key} at position ${j+1}`);\n        stage = 'outer-next';\n        return false;\n      }\n      case 'outer-next': {\n        // After insertion, sorted region extends to i\n        markSortedRegion(i);\n        i++;\n        stage = 'outer-init';\n        return false;\n      }\n      default:\n        return false;\n    }\n  }\n\n  function play(){\n    if(finished) return;\n    running = true;\n    startBtn.disabled = true;\n    pauseBtn.disabled = false;\n    stepBtn.disabled = true;\n    setStatus('Running');\n    const interval = baseInterval / speed;\n    if(tickHandle) clearTimeout(tickHandle);\n    const tick = ()=>{\n      if(!running) return;\n      const done = stepSort();\n      if(done){\n        running = false;\n        pauseBtn.disabled = true;\n        startBtn.disabled = true;\n        stepBtn.disabled = true;\n        setStatus('Done');\n        return;\n      }\n      tickHandle = setTimeout(tick, interval);\n    };\n    tick();\n  }\n\n  function pause(){\n    running = false;\n    pauseBtn.disabled = true;\n    startBtn.disabled = finished;\n    stepBtn.disabled = finished;\n    setStatus(finished ? 'Done' : 'Paused');\n  }\n\n  function stepOnce(){\n    if(finished) return;\n    if(stage === 'idle') prepareSort();\n    const done = stepSort();\n    if(done){\n      startBtn.disabled = true;\n      pauseBtn.disabled = true;\n      stepBtn.disabled = true;\n    }\n  }\n\n  // Init\n  function refresh(){\n    size = parseInt(sizeEl.value, 10);\n    sizeLbl.textContent = size;\n    arr = genArray(size, patternEl.value);\n    renderBars();\n    resetSortState();\n  }\n\n  // Events\n  shuffleBtn.addEventListener('click', ()=>{\n    arr = genArray(size, patternEl.value);\n    renderBars();\n    resetSortState();\n  });\n\n  patternEl.addEventListener('change', ()=>{\n    arr = genArray(size, patternEl.value);\n    renderBars();\n    resetSortState();\n  });\n\n  sizeEl.addEventListener('input', ()=>{\n    size = parseInt(sizeEl.value, 10);\n    sizeLbl.textContent = size;\n  });\n  sizeEl.addEventListener('change', refresh);\n\n  speedEl.addEventListener('input', ()=>{\n    speed = parseFloat(speedEl.value);\n    speedLbl.textContent = speed.toFixed(1) + 'x';\n  });\n\n  startBtn.addEventListener('click', ()=>{\n    if(stage === 'idle') prepareSort();\n    play();\n  });\n\n  pauseBtn.addEventListener('click', pause);\n\n  stepBtn.addEventListener('click', stepOnce);\n\n  resetBtn.addEventListener('click', ()=>{\n    renderBars();\n    resetSortState();\n  });\n\n  window.addEventListener('resize', ()=>{\n    positionKeyChip();\n  });\n\n  // Kick off\n  refresh();\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Insertion Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "5e50d7f0-a36b-11f0-b948-81230e0f472a",
    "timestamp": "2025-10-07T10:49:58.768Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Merge Sort",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Merge Sort Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f172a;\n      --panel:#111827;\n      --text:#e5e7eb;\n      --muted:#9ca3af;\n      --accent:#60a5fa;\n      --compare:#f59e0b;\n      --write:#10b981;\n      --left:#a78bfa;\n      --right:#22d3ee;\n      --stable:#fbbf24;\n      --bar:#3b82f6;\n    }\n    *{box-sizing:border-box}\n    body{\n      margin:0;\n      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n      background:linear-gradient(180deg, #0b1023 0%, #0f172a 100%);\n      color:var(--text);\n    }\n    header{\n      padding:20px 16px 8px;\n    }\n    h1{\n      margin:0 0 6px 0;\n      font-size:22px;\n      font-weight:700;\n      letter-spacing:.2px;\n    }\n    p.sub{\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .container{\n      padding:12px 16px 24px;\n      display:grid;\n      grid-template-columns: 1fr;\n      gap:14px;\n    }\n    .controls, .legend, .stats, .explain{\n      background:rgba(255,255,255,0.03);\n      border:1px solid rgba(255,255,255,0.07);\n      border-radius:12px;\n      padding:12px;\n    }\n    .controls{\n      display:flex;\n      flex-wrap:wrap;\n      gap:12px;\n      align-items:flex-end;\n    }\n    .controls .group{\n      display:flex;\n      flex-direction:column;\n      gap:6px;\n      min-width:160px;\n    }\n    .controls label{\n      font-size:12px;\n      color:var(--muted);\n    }\n    .controls input[type=\"range\"]{\n      width:220px;\n    }\n    .controls input[type=\"text\"]{\n      width:320px;\n      padding:8px 10px;\n      background:#0b1222;\n      color:var(--text);\n      border:1px solid rgba(255,255,255,0.1);\n      border-radius:8px;\n      font-size:14px;\n    }\n    .btn-row{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n    }\n    button{\n      background:#1f2937;\n      color:var(--text);\n      border:1px solid rgba(255,255,255,.12);\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-size:14px;\n      transition:transform .02s ease, background .2s ease, border .2s ease, color .2s ease;\n      user-select:none;\n    }\n    button:hover{ background:#273244; }\n    button:active{ transform:translateY(1px) }\n    button.primary{\n      background:linear-gradient(180deg,#2563eb,#1d4ed8);\n      border-color:transparent;\n    }\n    button.primary:hover{ filter:brightness(1.05) }\n    button:disabled{\n      opacity:.6;\n      cursor:not-allowed;\n    }\n\n    .legend{\n      display:flex;\n      flex-wrap:wrap;\n      gap:12px 18px;\n      align-items:center;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .chip{\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n    }\n    .dot{\n      width:16px;height:10px;border-radius:3px;background:var(--bar);border:1px solid rgba(255,255,255,.15)\n    }\n    .dot.left{ background:var(--left) }\n    .dot.right{ background:var(--right) }\n    .dot.compare{ background:var(--compare) }\n    .dot.write{ background:var(--write) }\n    .dot.stable{ background:var(--stable) }\n\n    .viz-wrap{\n      background:rgba(255,255,255,0.03);\n      border:1px solid rgba(255,255,255,0.07);\n      border-radius:14px;\n      padding:14px 12px 6px;\n    }\n    .bars{\n      height:340px;\n      display:flex;\n      align-items:flex-end;\n      gap:6px;\n      padding:6px 4px 10px;\n      overflow-x:auto;\n      overflow-y:hidden;\n    }\n    .bar{\n      position:relative;\n      flex:1 0 auto;\n      min-width:16px;\n      background:var(--bar);\n      border-radius:6px 6px 4px 4px;\n      border:1px solid rgba(255,255,255,0.12);\n      transition:height .25s ease, background .15s ease, transform .15s ease, border-color .15s ease, box-shadow .15s ease, opacity .15s ease;\n      display:flex;\n      align-items:flex-end;\n      justify-content:center;\n    }\n    .bar.leftSeg{ background:var(--left) }\n    .bar.rightSeg{ background:var(--right) }\n    .bar.compare{\n      outline:2px solid var(--compare);\n      box-shadow:0 0 0 2px rgba(0,0,0,0), 0 0 14px rgba(245,158,11,.25) inset;\n      filter:saturate(1.2);\n    }\n    .bar.write{\n      outline:2px solid var(--write);\n      box-shadow:0 0 0 2px rgba(0,0,0,0), 0 0 22px rgba(16,185,129,.3) inset;\n      transform:translateY(-2px);\n      filter:saturate(1.25);\n    }\n    .bar.stablePick{\n      outline:2px dashed var(--stable);\n    }\n    .label{\n      position:absolute;\n      top:-18px;\n      font-size:12px;\n      color:var(--text);\n      background:rgba(0,0,0,.2);\n      padding:2px 6px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,.08);\n      backdrop-filter: blur(2px);\n      pointer-events:none;\n    }\n    .sublabel{\n      position:absolute;\n      bottom:4px;\n      right:4px;\n      font-size:11px;\n      color:#e2e8f0;\n      background:rgba(0,0,0,.25);\n      padding:2px 6px;\n      border-radius:999px;\n      border:1px solid rgba(255,255,255,.08);\n      pointer-events:none;\n    }\n    .stats{\n      display:flex;flex-wrap:wrap;gap:12px;align-items:center\n    }\n    .stat{\n      background:rgba(255,255,255,.03);\n      border:1px solid rgba(255,255,255,.07);\n      border-radius:10px;\n      padding:8px 10px;\n      min-width:120px;\n    }\n    .stat .k{ font-size:11px; color:var(--muted); }\n    .stat .v{ font-size:16px; font-weight:700; }\n    .explain{\n      font-size:14px;\n      color:#dce3ee;\n    }\n    .explain ul{ margin:6px 0 0 20px }\n    .explain li{ margin:6px 0 }\n    .foot{\n      padding:8px 16px 24px;\n      font-size:12px;\n      color:var(--muted);\n      text-align:center;\n    }\n    @media (min-width: 980px){\n      .container{\n        grid-template-columns: 1.1fr .9fr;\n        grid-template-areas:\n          \"controls explain\"\n          \"legend explain\"\n          \"viz explain\"\n          \"stats explain\";\n      }\n      .controls{ grid-area:controls }\n      .legend{ grid-area:legend }\n      .viz-wrap{ grid-area:viz }\n      .stats{ grid-area:stats }\n      .explain{ grid-area:explain; position:sticky; top:12px; align-self:start; }\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Merge Sort Visualizer</h1>\n    <p class=\"sub\">A stable, divide-and-conquer sorting algorithm with O(n log n) time</p>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"controls\">\n      <div class=\"group\">\n        <label for=\"size\">Array size: <span id=\"sizeVal\">20</span></label>\n        <input id=\"size\" type=\"range\" min=\"4\" max=\"100\" value=\"20\" />\n      </div>\n      <div class=\"group\">\n        <label for=\"speed\">Speed (ms/step): <span id=\"speedVal\">180</span></label>\n        <input id=\"speed\" type=\"range\" min=\"30\" max=\"900\" step=\"10\" value=\"180\" />\n      </div>\n      <div class=\"group\">\n        <label for=\"range\">Value max: <span id=\"maxVal\">99</span></label>\n        <input id=\"range\" type=\"range\" min=\"9\" max=\"999\" step=\"1\" value=\"99\" />\n      </div>\n      <div class=\"group\" style=\"min-width:340px;\">\n        <label for=\"manual\">Custom array (comma or space separated)</label>\n        <input id=\"manual\" type=\"text\" placeholder=\"e.g. 8, 3, 5, 4, 7, 6, 1, 2\" />\n      </div>\n      <div class=\"btn-row\">\n        <button id=\"applyInput\">Apply Input</button>\n        <button id=\"randomize\">Randomize</button>\n        <button id=\"nearly\">Nearly Sorted</button>\n        <button id=\"reverse\">Reverse</button>\n      </div>\n      <div class=\"btn-row\">\n        <button id=\"start\" class=\"primary\">Start Sort</button>\n        <button id=\"pause\">Pause</button>\n        <button id=\"step\">Step</button>\n        <button id=\"reset\">Reset</button>\n      </div>\n    </div>\n\n    <div class=\"legend\">\n      <div class=\"chip\"><span class=\"dot\"></span> Unmarked</div>\n      <div class=\"chip\"><span class=\"dot left\"></span> Left half</div>\n      <div class=\"chip\"><span class=\"dot right\"></span> Right half</div>\n      <div class=\"chip\"><span class=\"dot compare\"></span> Comparing</div>\n      <div class=\"chip\"><span class=\"dot write\"></span> Writing</div>\n      <div class=\"chip\"><span class=\"dot stable\"></span> Stable tie pick</div>\n    </div>\n\n    <div class=\"viz-wrap\">\n      <div id=\"bars\" class=\"bars\" aria-label=\"Array bars\"></div>\n    </div>\n\n    <div class=\"stats\">\n      <div class=\"stat\">\n        <div class=\"k\">Length</div>\n        <div class=\"v\" id=\"statN\">0</div>\n      </div>\n      <div class=\"stat\">\n        <div class=\"k\">Comparisons</div>\n        <div class=\"v\" id=\"statC\">0</div>\n      </div>\n      <div class=\"stat\">\n        <div class=\"k\">Writes</div>\n        <div class=\"v\" id=\"statW\">0</div>\n      </div>\n      <div class=\"stat\">\n        <div class=\"k\">Status</div>\n        <div class=\"v\" id=\"statS\">Idle</div>\n      </div>\n    </div>\n\n    <div class=\"explain\">\n      <strong>What is Merge Sort?</strong>\n      <ul>\n        <li>Divide: Recursively split the array into halves until subarrays have size 1.</li>\n        <li>Conquer: Merge adjacent sorted subarrays by repeatedly choosing the smaller front element.</li>\n        <li>Stable: When values tie, Merge Sort keeps their original relative order (highlighted as “Stable tie pick”).</li>\n        <li>Time complexity: O(n log n) in the best, average, and worst case.</li>\n        <li>Space complexity: O(n) extra space for the merging process.</li>\n      </ul>\n      <br />\n      Tips:\n      <ul>\n        <li>Use the slider to change array size or speed. Try “Nearly Sorted” or “Reverse” to see behavior on different inputs.</li>\n        <li>The number in each bar’s pill is the value; the round badge shows the original index so you can verify stability for equal values.</li>\n      </ul>\n    </div>\n  </div>\n\n  <div class=\"foot\">\n    Merge Sort visualization — step through the algorithm to see splitting and merging in action.\n  </div>\n\n  <script>\n    // State\n    const state = {\n      arr: [],\n      original: [],\n      steps: null,     // generator iterator\n      playing: false,\n      timer: null,\n      speed: 180,\n      maxValue: 99,\n      // highlights\n      segment: null,   // {l, m, r}\n      comparing: new Set(),\n      writingIndex: -1,\n      stablePickAt: -1,\n      // stats\n      comps: 0,\n      writes: 0,\n      done: false\n    };\n\n    // DOM elements\n    const elBars = document.getElementById('bars');\n    const elSize = document.getElementById('size');\n    const elSizeVal = document.getElementById('sizeVal');\n    const elSpeed = document.getElementById('speed');\n    const elSpeedVal = document.getElementById('speedVal');\n    const elRange = document.getElementById('range');\n    const elMaxVal = document.getElementById('maxVal');\n    const elManual = document.getElementById('manual');\n    const elApplyInput = document.getElementById('applyInput');\n    const elRandomize = document.getElementById('randomize');\n    const elNearly = document.getElementById('nearly');\n    const elReverse = document.getElementById('reverse');\n    const elStart = document.getElementById('start');\n    const elPause = document.getElementById('pause');\n    const elStep = document.getElementById('step');\n    const elReset = document.getElementById('reset');\n    const statN = document.getElementById('statN');\n    const statC = document.getElementById('statC');\n    const statW = document.getElementById('statW');\n    const statS = document.getElementById('statS');\n\n    // Helpers\n    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n\n    function buildRandom(n, maxVal) {\n      const a = Array.from({length: n}, (_, i) => ({ value: randInt(0, maxVal), id: i }));\n      return a;\n    }\n    function buildNearlySorted(n, maxVal) {\n      const base = Array.from({length: n}, (_, i) => ({ value: Math.round((i/(n-1||1))*maxVal), id: i }));\n      // Introduce small perturbations\n      for (let k = 0; k < Math.max(1, Math.floor(n/8)); k++){\n        const i = randInt(0, n-1), j = Math.min(n-1, i + randInt(1, 3));\n        [base[i], base[j]] = [base[j], base[i]];\n      }\n      return base;\n    }\n    function buildReverse(n, maxVal) {\n      const base = Array.from({length: n}, (_, i) => ({ value: Math.round((i/(n-1||1))*maxVal), id: i }));\n      base.reverse();\n      // Keep original id as original position before reverse to show stability effect\n      base.forEach((item, idx) => { /* id remains from build; reverse preserved id mapping */ });\n      return base;\n    }\n    function parseManual(str, maxVal){\n      const tokens = str.trim().replace(/,/g,' ').split(/\\s+/).filter(Boolean);\n      if (tokens.length === 0) return null;\n      const nums = [];\n      for (let i=0;i<tokens.length;i++){\n        const v = Number(tokens[i]);\n        if (!Number.isFinite(v)) return null;\n        const vv = Math.max(0, Math.min(maxVal, Math.round(v)));\n        nums.push(vv);\n      }\n      return nums.map((v,i) => ({ value: v, id: i }));\n    }\n\n    // Visualization\n    function render() {\n      // stats\n      statN.textContent = state.arr.length;\n      statC.textContent = state.comps;\n      statW.textContent = state.writes;\n      statS.textContent = state.done ? 'Done' : (state.playing ? 'Running' : 'Paused');\n\n      // compute scale\n      let maxVal = 1;\n      for (const it of state.arr) maxVal = Math.max(maxVal, it.value);\n      // Create bars\n      elBars.innerHTML = '';\n      const n = state.arr.length;\n      const width = Math.max(16, Math.floor( (elBars.clientWidth - (n-1)*6 - 8) / Math.max(1, n) ));\n      state.arr.forEach((item, idx) => {\n        const hPct = maxVal === 0 ? 0 : (item.value / maxVal);\n        const px = Math.round(20 + hPct * 300); // min 20px height for zeros\n        const bar = document.createElement('div');\n        bar.className = 'bar';\n        bar.style.height = px + 'px';\n        bar.style.minWidth = width + 'px';\n\n        // segment colors\n        if (state.segment){\n          if (idx >= state.segment.l && idx < state.segment.m) bar.classList.add('leftSeg');\n          else if (idx >= state.segment.m && idx < state.segment.r) bar.classList.add('rightSeg');\n        }\n        if (state.comparing.has(idx)) bar.classList.add('compare');\n        if (state.writingIndex === idx) bar.classList.add('write');\n        if (state.stablePickAt === idx) bar.classList.add('stablePick');\n\n        const label = document.createElement('div');\n        label.className = 'label';\n        label.textContent = item.value;\n\n        const sub = document.createElement('div');\n        sub.className = 'sublabel';\n        sub.title = 'Original index';\n        sub.textContent = item.id;\n\n        bar.appendChild(label);\n        bar.appendChild(sub);\n        elBars.appendChild(bar);\n      });\n    }\n\n    function clearHighlights() {\n      state.segment = null;\n      state.comparing.clear();\n      state.writingIndex = -1;\n      state.stablePickAt = -1;\n    }\n\n    // Merge Sort generator (stable)\n    function* mergeSortSteps(arr) {\n      const aux = new Array(arr.length);\n      yield* rec(arr, aux, 0, arr.length);\n      yield { type: 'done' };\n      function* rec(a, aux, l, r){\n        if (r - l <= 1) return;\n        const m = (l + r) >> 1;\n        yield* rec(a, aux, l, m);\n        yield* rec(a, aux, m, r);\n\n        // before merging, show the segments being merged\n        yield { type: 'split', l, m, r };\n\n        // copy to aux\n        for (let t = l; t < r; t++){\n          aux[t] = a[t];\n          yield { type: 'copy', index: t };\n        }\n\n        let i = l, j = m;\n        for (let k = l; k < r; k++){\n          if (i >= m){\n            a[k] = aux[j++];\n            yield { type: 'write', k, from: j-1, side:'right', l, m, r, stable:false };\n          } else if (j >= r){\n            a[k] = aux[i++];\n            yield { type: 'write', k, from: i-1, side:'left', l, m, r, stable:false };\n          } else {\n            yield { type: 'compare', i, j, l, m, r };\n            if (aux[i].value <= aux[j].value){\n              const stable = aux[i].value === aux[j].value;\n              a[k] = aux[i++];\n              yield { type: 'write', k, from: i-1, side:'left', l, m, r, stable };\n            } else {\n              a[k] = aux[j++];\n              yield { type: 'write', k, from: j-1, side:'right', l, m, r, stable:false };\n            }\n          }\n        }\n        yield { type: 'merged', l, m, r };\n      }\n    }\n\n    // Apply one step to state and re-render\n    function applyStep(step){\n      if (!step) return;\n      switch(step.type){\n        case 'split':\n          state.segment = { l: step.l, m: step.m, r: step.r };\n          state.comparing.clear();\n          state.writingIndex = -1;\n          state.stablePickAt = -1;\n          break;\n        case 'copy':\n          // We don't need to show copy distinctly; could briefly mark index\n          // We'll clear writing highlight to avoid confusion\n          state.writingIndex = -1;\n          break;\n        case 'compare':\n          state.segment = { l: step.l, m: step.m, r: step.r };\n          state.comparing = new Set([step.i, step.j]);\n          state.writingIndex = -1;\n          state.stablePickAt = -1;\n          state.comps++;\n          break;\n        case 'write':\n          state.segment = { l: step.l, m: step.m, r: step.r };\n          state.comparing.clear();\n          state.writingIndex = step.k;\n          state.stablePickAt = step.stable ? step.k : -1;\n          state.writes++;\n          break;\n        case 'merged':\n          // merging range finished\n          state.comparing.clear();\n          state.writingIndex = -1;\n          state.stablePickAt = -1;\n          // keep last segment momentarily\n          break;\n        case 'done':\n          clearHighlights();\n          state.done = true;\n          break;\n      }\n      render();\n    }\n\n    // Control flow\n    function stopPlaying(){\n      state.playing = false;\n      if (state.timer){ clearInterval(state.timer); state.timer = null; }\n      render();\n    }\n    function startPlaying(){\n      if (state.done) return;\n      state.playing = true;\n      if (state.timer){ clearInterval(state.timer); }\n      state.timer = setInterval(() => {\n        const n = state.steps.next();\n        if (n.done){\n          applyStep({type:'done'});\n          stopPlaying();\n          return;\n        }\n        applyStep(n.value);\n      }, state.speed);\n      render();\n    }\n\n    function resetToOriginal(){\n      stopPlaying();\n      state.arr = state.original.map(o => ({ value: o.value, id: o.id }));\n      state.steps = mergeSortSteps(state.arr);\n      state.comps = 0;\n      state.writes = 0;\n      state.done = false;\n      clearHighlights();\n      render();\n    }\n\n    // UI bindings\n    elSize.addEventListener('input', () => {\n      elSizeVal.textContent = elSize.value;\n    });\n    elSpeed.addEventListener('input', () => {\n      elSpeedVal.textContent = elSpeed.value;\n      state.speed = Number(elSpeed.value);\n      if (state.playing){\n        // restart interval with new speed\n        clearInterval(state.timer);\n        state.timer = null;\n        startPlaying();\n      }\n    });\n    elRange.addEventListener('input', () => {\n      elMaxVal.textContent = elRange.value;\n      state.maxValue = Number(elRange.value);\n    });\n\n    elApplyInput.addEventListener('click', () => {\n      const parsed = parseManual(elManual.value, state.maxValue);\n      if (!parsed || parsed.length < 1){\n        alert('Please enter a valid list of numbers (comma or space separated).');\n        return;\n      }\n      stopPlaying();\n      state.arr = parsed;\n      state.original = state.arr.map(o => ({ value: o.value, id: o.id }));\n      state.steps = mergeSortSteps(state.arr);\n      state.comps = 0;\n      state.writes = 0;\n      state.done = false;\n      elSize.value = parsed.length;\n      elSizeVal.textContent = parsed.length;\n      render();\n    });\n\n    elRandomize.addEventListener('click', () => {\n      stopPlaying();\n      const n = Number(elSize.value);\n      state.arr = buildRandom(n, state.maxValue);\n      state.original = state.arr.map(o => ({ value: o.value, id: o.id }));\n      state.steps = mergeSortSteps(state.arr);\n      state.comps = 0;\n      state.writes = 0;\n      state.done = false;\n      render();\n    });\n\n    elNearly.addEventListener('click', () => {\n      stopPlaying();\n      const n = Number(elSize.value);\n      state.arr = buildNearlySorted(n, state.maxValue);\n      state.original = state.arr.map(o => ({ value: o.value, id: o.id }));\n      state.steps = mergeSortSteps(state.arr);\n      state.comps = 0;\n      state.writes = 0;\n      state.done = false;\n      render();\n    });\n\n    elReverse.addEventListener('click', () => {\n      stopPlaying();\n      const n = Number(elSize.value);\n      state.arr = buildReverse(n, state.maxValue);\n      // Important: preserve original ids from the initial order before reverse?\n      // For demonstration, id stays as constructed index (0..n-1) in current array.\n      // This still demonstrates stability for duplicates across merges.\n      state.original = state.arr.map(o => ({ value: o.value, id: o.id }));\n      state.steps = mergeSortSteps(state.arr);\n      state.comps = 0;\n      state.writes = 0;\n      state.done = false;\n      render();\n    });\n\n    elStart.addEventListener('click', () => {\n      if (!state.steps) state.steps = mergeSortSteps(state.arr);\n      if (!state.playing && !state.done) startPlaying();\n    });\n    elPause.addEventListener('click', () => {\n      stopPlaying();\n    });\n    elStep.addEventListener('click', () => {\n      if (state.done) return;\n      stopPlaying();\n      if (!state.steps) state.steps = mergeSortSteps(state.arr);\n      const n = state.steps.next();\n      if (n.done){\n        applyStep({type:'done'});\n        stopPlaying();\n        return;\n      }\n      applyStep(n.value);\n    });\n    elReset.addEventListener('click', () => {\n      resetToOriginal();\n    });\n\n    // Resize handling: re-render to adjust bar widths\n    let resizeTimer = null;\n    window.addEventListener('resize', () => {\n      if (resizeTimer) cancelAnimationFrame(resizeTimer);\n      resizeTimer = requestAnimationFrame(render);\n    });\n\n    // Initialize\n    function init(){\n      state.speed = Number(elSpeed.value);\n      state.maxValue = Number(elRange.value);\n      elSpeedVal.textContent = state.speed;\n      elMaxVal.textContent = state.maxValue;\n      elSizeVal.textContent = elSize.value;\n\n      state.arr = buildRandom(Number(elSize.value), state.maxValue);\n      state.original = state.arr.map(o => ({ value: o.value, id: o.id }));\n      state.steps = mergeSortSteps(state.arr);\n      state.comps = 0;\n      state.writes = 0;\n      state.done = false;\n      clearHighlights();\n      render();\n    }\n    init();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Merge Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "97765c30-a36b-11f0-8967-c73dd726dac0",
    "timestamp": "2025-10-07T10:51:34.643Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Quick Sort",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<title>Quick Sort Visualizer</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --muted: #6b7280;\n    --accent: #4e79a7;\n    --pivot: #f28e2b;\n    --swap: #e15759;\n    --sorted: #59a14f;\n    --i: #76b7b2;\n    --j: #b07aa1;\n    --faded: 0.2;\n  }\n  html, body {\n    margin: 0;\n    padding: 0;\n    background: linear-gradient(180deg, #0b1021, #0e1222);\n    color: #e5e7eb;\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Apple Color Emoji\", \"Segoe UI Emoji\";\n  }\n  .app {\n    max-width: 1100px;\n    margin: 24px auto;\n    padding: 0 16px 40px;\n  }\n  header h1 {\n    margin: 0 0 6px;\n    font-weight: 700;\n    letter-spacing: 0.2px;\n  }\n  header p {\n    margin: 0 0 16px;\n    color: var(--muted);\n  }\n  .controls {\n    display: grid;\n    grid-template-columns: 1fr 1fr 1fr;\n    gap: 12px;\n    margin-bottom: 16px;\n  }\n  .panel {\n    background: rgba(17, 24, 39, 0.7);\n    border: 1px solid rgba(255,255,255,0.06);\n    border-radius: 10px;\n    padding: 12px;\n    backdrop-filter: blur(4px);\n  }\n  .panel h3 {\n    margin: 0 0 10px;\n    font-size: 15px;\n    color: #cbd5e1;\n  }\n  .row {\n    display: flex;\n    gap: 10px;\n    align-items: center;\n    flex-wrap: wrap;\n  }\n  label {\n    font-size: 13px;\n    color: #cbd5e1;\n  }\n  input[type=\"text\"] {\n    flex: 1;\n    min-width: 220px;\n    background: #0b1220;\n    border: 1px solid rgba(255,255,255,0.12);\n    color: #e5e7eb;\n    border-radius: 8px;\n    padding: 8px 10px;\n    outline: none;\n  }\n  input[type=\"number\"] {\n    width: 90px;\n    background: #0b1220;\n    border: 1px solid rgba(255,255,255,0.12);\n    color: #e5e7eb;\n    border-radius: 8px;\n    padding: 7px 10px;\n    outline: none;\n  }\n  select, input[type=\"range\"] {\n    background: #0b1220;\n    border: 1px solid rgba(255,255,255,0.12);\n    color: #e5e7eb;\n    border-radius: 8px;\n    padding: 6px 10px;\n    outline: none;\n  }\n  .btn {\n    appearance: none;\n    background: linear-gradient(180deg, #0f1c34, #0c1528);\n    border: 1px solid rgba(255,255,255,0.12);\n    color: #e5e7eb;\n    border-radius: 8px;\n    padding: 8px 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: transform 120ms ease, box-shadow 120ms ease, background 200ms ease;\n  }\n  .btn:hover {\n    transform: translateY(-1px);\n    box-shadow: 0 6px 14px rgba(0,0,0,0.25);\n  }\n  .btn.primary {\n    background: linear-gradient(180deg, #215a98, #174574);\n    border-color: rgba(78,121,167,0.8);\n  }\n  .btn.warn {\n    background: linear-gradient(180deg, #8c2c2d, #6c2122);\n    border-color: rgba(225,87,89,0.8);\n  }\n  .btn.success {\n    background: linear-gradient(180deg, #2c7f45, #226238);\n    border-color: rgba(89,161,79,0.8);\n  }\n  .chart-wrapper {\n    background: rgba(17, 24, 39, 0.7);\n    border: 1px solid rgba(255,255,255,0.06);\n    border-radius: 10px;\n    padding: 12px 12px 6px;\n    margin-bottom: 16px;\n  }\n  .chart-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: baseline;\n    padding: 2px 4px 8px;\n  }\n  .chart-header .title {\n    font-size: 15px;\n    color: #cbd5e1;\n  }\n  .chart-header .meta {\n    font-size: 12px;\n    color: var(--muted);\n  }\n  #chart {\n    position: relative;\n    height: 320px;\n    width: 100%;\n    background: radial-gradient(circle at 30% 20%, rgba(78,121,167,0.08), rgba(255,255,255,0.02));\n    border-radius: 8px;\n    overflow: hidden;\n  }\n  .bar {\n    position: absolute;\n    bottom: 0;\n    width: 20px;\n    border-radius: 6px 6px 0 0;\n    background: var(--accent);\n    box-shadow: 0 2px 8px rgba(78,121,167,0.35);\n    transition: left 280ms ease, height 260ms ease, background-color 180ms ease, transform 120ms ease, opacity 180ms ease, border-color 180ms ease;\n    border: 2px solid transparent;\n  }\n  .bar .label {\n    position: absolute;\n    bottom: 100%;\n    left: 50%;\n    transform: translateX(-50%);\n    font-size: 11px;\n    color: #cbd5e1;\n    white-space: nowrap;\n    background: rgba(2,6,23,0.6);\n    border: 1px solid rgba(255,255,255,0.08);\n    border-radius: 6px;\n    padding: 2px 4px;\n    pointer-events: none;\n    opacity: 0.9;\n  }\n  .bar.pivot {\n    background: var(--pivot);\n    border-color: rgba(242,142,43,0.7);\n    box-shadow: 0 2px 12px rgba(242,142,43,0.45);\n  }\n  .bar.i {\n    outline: 2px dashed rgba(118,183,178,0.9);\n    box-shadow: 0 2px 10px rgba(118,183,178,0.5);\n  }\n  .bar.j {\n    outline: 2px dashed rgba(176,122,161,0.9);\n    box-shadow: 0 2px 10px rgba(176,122,161,0.5);\n  }\n  .bar.swap {\n    animation: pulse 300ms ease-in-out;\n    border-color: rgba(225,87,89,0.9);\n    background: var(--swap);\n    box-shadow: 0 2px 12px rgba(225,87,89,0.6);\n  }\n  .bar.sorted {\n    background: var(--sorted);\n    border-color: rgba(89,161,79,0.8);\n    box-shadow: 0 2px 12px rgba(89,161,79,0.55);\n  }\n  .bar.faded {\n    opacity: var(--faded);\n    filter: saturate(0.6);\n  }\n  @keyframes pulse {\n    0% { transform: scale(1); }\n    50% { transform: scale(1.05); }\n    100% { transform: scale(1); }\n  }\n  .legend {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 8px 16px;\n    align-items: center;\n    font-size: 12px;\n    color: #cbd5e1;\n    margin: 6px 4px 6px;\n  }\n  .legend .key {\n    display: inline-flex;\n    align-items: center;\n    gap: 6px;\n  }\n  .legend .dot {\n    width: 14px; height: 14px; border-radius: 4px;\n    display: inline-block;\n    border: 2px solid transparent;\n  }\n  .dot.p { background: var(--pivot); border-color: rgba(242,142,43,0.7); }\n  .dot.i { background: #0b1220; border-color: rgba(118,183,178,0.9); }\n  .dot.j { background: #0b1220; border-color: rgba(176,122,161,0.9); }\n  .dot.s { background: var(--sorted); border-color: rgba(89,161,79,0.8); }\n  .dot.sw { background: var(--swap); border-color: rgba(225,87,89,0.9); }\n  .stats {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 12px;\n  }\n  .stat-panel {\n    background: rgba(17, 24, 39, 0.7);\n    border: 1px solid rgba(255,255,255,0.06);\n    border-radius: 10px;\n    padding: 12px;\n  }\n  .stat-grid {\n    display: grid;\n    grid-template-columns: repeat(3, minmax(0, 1fr));\n    gap: 10px;\n    font-size: 13px;\n    color: #cbd5e1;\n  }\n  .value {\n    font-weight: 700;\n    color: #e5e7eb;\n  }\n  .code {\n    background: #0a0f1f;\n    border: 1px solid rgba(255,255,255,0.08);\n    border-radius: 10px;\n    padding: 10px;\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #cbd5e1;\n    overflow: auto;\n    max-height: 240px;\n  }\n  .code .hl {\n    background: rgba(78,121,167,0.18);\n    border-left: 3px solid rgba(78,121,167,0.7);\n    padding-left: 6px;\n    margin-left: -6px;\n  }\n  .footer {\n    font-size: 12px;\n    color: var(--muted);\n    text-align: center;\n    margin-top: 18px;\n  }\n</style>\n</head>\n<body>\n  <div class=\"app\">\n    <header>\n      <h1>Quick Sort Visualizer</h1>\n      <p>Interactively step through the Quick Sort algorithm (Lomuto partition) with pivot strategies and adjustable speed.</p>\n    </header>\n\n    <section class=\"controls\">\n      <div class=\"panel\">\n        <h3>Input</h3>\n        <div class=\"row\" style=\"margin-bottom:8px\">\n          <input id=\"inputArray\" type=\"text\" placeholder=\"Enter numbers separated by commas (e.g., 5, 3, 8, 2, 9)\" />\n        </div>\n        <div class=\"row\">\n          <label for=\"randCount\">Random size</label>\n          <input id=\"randCount\" type=\"number\" min=\"5\" max=\"60\" value=\"20\" />\n          <button id=\"btnRandom\" class=\"btn\">Generate Random</button>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <h3>Settings</h3>\n        <div class=\"row\">\n          <label for=\"pivotSelect\">Pivot strategy</label>\n          <select id=\"pivotSelect\">\n            <option value=\"last\">Last element (Lomuto)</option>\n            <option value=\"random\">Random pivot</option>\n          </select>\n        </div>\n        <div class=\"row\">\n          <label for=\"speedRange\">Speed</label>\n          <input id=\"speedRange\" type=\"range\" min=\"0.25\" max=\"5\" step=\"0.25\" value=\"2\" />\n          <span id=\"speedLabel\">2.0x</span>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <h3>Actions</h3>\n        <div class=\"row\">\n          <button id=\"btnSort\" class=\"btn primary\">Build Steps</button>\n          <button id=\"btnPlay\" class=\"btn success\">Play</button>\n          <button id=\"btnStep\" class=\"btn\">Step</button>\n          <button id=\"btnReset\" class=\"btn warn\">Reset</button>\n        </div>\n      </div>\n    </section>\n\n    <section class=\"chart-wrapper\">\n      <div class=\"chart-header\">\n        <div class=\"title\">Array Visualization</div>\n        <div class=\"meta\"><span id=\"stepInfo\">Step 0 / 0</span> • <span id=\"rangeInfo\">Range: —</span> • <span id=\"pointerInfo\">i: —, j: —, pivot: —</span></div>\n      </div>\n      <div id=\"chart\" aria-label=\"Bars represent array values\"></div>\n      <div class=\"legend\">\n        <span class=\"key\"><span class=\"dot p\"></span> Pivot</span>\n        <span class=\"key\"><span class=\"dot i\"></span> i pointer</span>\n        <span class=\"key\"><span class=\"dot j\"></span> j pointer</span>\n        <span class=\"key\"><span class=\"dot sw\"></span> Swap</span>\n        <span class=\"key\"><span class=\"dot s\"></span> Sorted (final position)</span>\n      </div>\n    </section>\n\n    <section class=\"stats\">\n      <div class=\"stat-panel\">\n        <h3>Run Stats</h3>\n        <div class=\"stat-grid\">\n          <div>Comparisons<br><span class=\"value\" id=\"cmpCount\">0</span></div>\n          <div>Swaps<br><span class=\"value\" id=\"swapCount\">0</span></div>\n          <div>Size<br><span class=\"value\" id=\"sizeInfo\">0</span></div>\n        </div>\n      </div>\n      <div class=\"stat-panel\">\n        <h3>Algorithm (Lomuto Partition)</h3>\n        <pre class=\"code\" id=\"codeBlock\"><code>\nfunction quickSort(A, low, high) {\n  if (low &lt; high) {          // 1\n    let p = partition(A, low, high); // 2\n    quickSort(A, low, p - 1);        // 3\n    quickSort(A, p + 1, high);       // 4\n  }\n}\n\nfunction partition(A, low, high) {\n  let pivot = A[high];       // 5\n  let i = low;               // 6\n  for (let j = low; j &lt; high; j++) { // 7\n    if (A[j] &lt;= pivot) {     // 8\n      swap(A, i, j);         // 9\n      i++;                   // 10\n    }\n  }\n  swap(A, i, high);          // 11\n  return i;                  // 12\n}\n        </code></pre>\n      </div>\n    </section>\n\n    <div class=\"footer\">Tip: Click \"Generate Random\", then \"Build Steps\", then \"Play\" or \"Step\" through the sort. Resize the window to reflow bars.</div>\n  </div>\n\n<script>\n(function() {\n  const chart = document.getElementById('chart');\n  const inputArrayEl = document.getElementById('inputArray');\n  const randCountEl = document.getElementById('randCount');\n  const btnRandom = document.getElementById('btnRandom');\n  const btnSort = document.getElementById('btnSort');\n  const btnPlay = document.getElementById('btnPlay');\n  const btnStep = document.getElementById('btnStep');\n  const btnReset = document.getElementById('btnReset');\n  const pivotSelect = document.getElementById('pivotSelect');\n  const speedRange = document.getElementById('speedRange');\n  const speedLabel = document.getElementById('speedLabel');\n\n  const stepInfo = document.getElementById('stepInfo');\n  const rangeInfo = document.getElementById('rangeInfo');\n  const pointerInfo = document.getElementById('pointerInfo');\n  const cmpCountEl = document.getElementById('cmpCount');\n  const swapCountEl = document.getElementById('swapCount');\n  const sizeInfoEl = document.getElementById('sizeInfo');\n  const codeBlock = document.getElementById('codeBlock');\n\n  const app = {\n    initialValues: [],\n    objects: [],     // [{id, value}]\n    state: [],       // working array of objects\n    idMap: new Map(),// id => element\n    steps: [],\n    stepIndex: 0,\n    playing: false,\n    timer: null,\n    speed: 2,\n    pivotStrategy: 'last',\n    layout: {gap: 6, step: 30, barWidth: 20, height: 320, minH: 16},\n    counters: {comparisons: 0, swaps: 0},\n    pointers: {i: null, j: null, pivot: null, range: null},\n    minVal: 0,\n    maxVal: 0\n  };\n\n  function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }\n  function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }\n\n  function parseInput(str) {\n    const parts = str.split(/[, \\t\\r\\n]+/).filter(Boolean);\n    const vals = [];\n    for (const p of parts) {\n      const num = Number(p);\n      if (!Number.isFinite(num)) continue;\n      vals.push(num);\n    }\n    return vals;\n  }\n\n  function generateRandom(count) {\n    const n = clamp(Number(count) || 20, 5, 60);\n    const vals = [];\n    // allow duplicates; values range roughly 1..100\n    for (let i = 0; i < n; i++) {\n      vals.push(randInt(1, 100));\n    }\n    return vals;\n  }\n\n  function init(values) {\n    stop();\n    app.initialValues = values.slice();\n    app.objects = values.map((v, idx) => ({ id: idx + 1, value: v }));\n    app.state = app.objects.map(o => ({ id: o.id, value: o.value }));\n    app.counters.comparisons = 0;\n    app.counters.swaps = 0;\n    app.steps = [];\n    app.stepIndex = 0;\n    app.pointers = {i: null, j: null, pivot: null, range: null};\n    app.minVal = Math.min(...values);\n    app.maxVal = Math.max(...values);\n    sizeInfoEl.textContent = String(values.length);\n    setupBars();\n    updateUI();\n    highlightCode(null);\n  }\n\n  function setupBars() {\n    chart.innerHTML = '';\n    app.idMap.clear();\n    updateLayout();\n    for (let idx = 0; idx < app.state.length; idx++) {\n      const obj = app.state[idx];\n      const bar = document.createElement('div');\n      bar.className = 'bar';\n      bar.dataset.id = String(obj.id);\n\n      const label = document.createElement('div');\n      label.className = 'label';\n      label.textContent = String(obj.value);\n      bar.appendChild(label);\n\n      chart.appendChild(bar);\n      app.idMap.set(obj.id, bar);\n    }\n    updateBarsPos(true);\n  }\n\n  function updateLayout() {\n    const w = chart.clientWidth;\n    const n = Math.max(1, app.state.length);\n    const gap = app.layout.gap;\n    const step = w / n;\n    const barWidth = clamp(step - gap, 8, 40);\n    app.layout.step = step;\n    app.layout.barWidth = barWidth;\n    app.layout.height = chart.clientHeight || 320;\n    applyBarSize();\n  }\n\n  function applyBarSize() {\n    for (let idx = 0; idx < app.state.length; idx++) {\n      const obj = app.state[idx];\n      const el = app.idMap.get(obj.id);\n      if (!el) continue;\n      el.style.width = app.layout.barWidth + 'px';\n    }\n    updateBarsPos(false);\n  }\n\n  function valueToHeight(v) {\n    const pad = 24;\n    const H = app.layout.height - pad;\n    const minV = app.minVal;\n    const maxV = app.maxVal;\n    const range = Math.max(1, maxV - minV);\n    const norm = (v - minV) / range;\n    return Math.max(app.layout.minH, Math.round(norm * H) + 8);\n  }\n\n  function updateBarsPos(initial = false) {\n    for (let idx = 0; idx < app.state.length; idx++) {\n      const obj = app.state[idx];\n      const el = app.idMap.get(obj.id);\n      if (!el) continue;\n      const left = Math.round(idx * app.layout.step + (app.layout.step - app.layout.barWidth) / 2);\n      el.style.left = left + 'px';\n      el.style.height = valueToHeight(obj.value) + 'px';\n      const label = el.querySelector('.label');\n      if (label) label.textContent = String(obj.value);\n      if (initial) {\n        el.classList.remove('pivot','i','j','swap','sorted','faded');\n      }\n    }\n  }\n\n  function clearTransientHighlights() {\n    for (const el of app.idMap.values()) {\n      el.classList.remove('pivot','i','j','swap');\n    }\n  }\n\n  function applyRangeShading() {\n    const range = app.pointers.range;\n    for (let idx = 0; idx < app.state.length; idx++) {\n      const el = app.idMap.get(app.state[idx].id);\n      if (!el) continue;\n      if (range && (idx < range[0] || idx > range[1])) {\n        el.classList.add('faded');\n      } else {\n        el.classList.remove('faded');\n      }\n    }\n  }\n\n  function markSortedIndex(index) {\n    const obj = app.state[index];\n    if (!obj) return;\n    const el = app.idMap.get(obj.id);\n    if (el) {\n      el.classList.add('sorted');\n      el.classList.remove('pivot','i','j','swap');\n    }\n  }\n\n  function swapStateIndices(a, b) {\n    if (a === b) return;\n    const tmp = app.state[a];\n    app.state[a] = app.state[b];\n    app.state[b] = tmp;\n    updateBarsPos(false);\n  }\n\n  function buildQuickSortSteps(values, pivotStrategy) {\n    const arr = values.slice();\n    const steps = [];\n\n    function quickSort(low, high) {\n      if (low >= high) {\n        // Range of length 0 or 1 is trivially sorted; optionally mark\n        if (low === high) steps.push({ type: 'sortedRange', low, high });\n        return;\n      }\n      steps.push({ type: 'subrange', low, high });\n\n      let pivotIndex = high;\n      if (pivotStrategy === 'random') {\n        const r = randInt(low, high);\n        steps.push({ type: 'choosePivot', index: r });\n        if (r !== high) {\n          steps.push({ type: 'swap', a: r, b: high });\n          const t = arr[r]; arr[r] = arr[high]; arr[high] = t;\n        }\n        pivotIndex = high;\n      } else {\n        steps.push({ type: 'choosePivot', index: pivotIndex });\n      }\n\n      const pivotVal = arr[pivotIndex];\n      let i = low;\n      steps.push({ type: 'iSet', index: i, origin: 'init' });\n      for (let j = low; j < high; j++) {\n        steps.push({ type: 'compare', j, pivotIndex });\n        if (arr[j] <= pivotVal) {\n          if (i !== j) {\n            steps.push({ type: 'swap', a: i, b: j });\n            const t = arr[i]; arr[i] = arr[j]; arr[j] = t;\n          } else {\n            steps.push({ type: 'touch', index: j });\n          }\n          i++;\n          steps.push({ type: 'iSet', index: i, origin: 'inc' });\n        }\n      }\n      steps.push({ type: 'finalSwap', a: i, b: high });\n      const t2 = arr[i]; arr[i] = arr[high]; arr[high] = t2;\n      steps.push({ type: 'pivotPlaced', index: i });\n\n      quickSort(low, i - 1);\n      quickSort(i + 1, high);\n    }\n\n    quickSort(0, arr.length - 1);\n    steps.push({ type: 'done' });\n\n    return steps;\n  }\n\n  function updateUI() {\n    stepInfo.textContent = `Step ${app.stepIndex} / ${app.steps.length}`;\n    rangeInfo.textContent = app.pointers.range ? `Range: [${app.pointers.range[0]}, ${app.pointers.range[1]}]` : 'Range: —';\n    const p = app.pointers;\n    pointerInfo.textContent = `i: ${p.i ?? '—'}, j: ${p.j ?? '—'}, pivot: ${p.pivot ?? '—'}`;\n    cmpCountEl.textContent = String(app.counters.comparisons);\n    swapCountEl.textContent = String(app.counters.swaps);\n    btnPlay.textContent = app.playing ? 'Pause' : 'Play';\n    btnStep.disabled = app.steps.length === 0 || app.stepIndex >= app.steps.length;\n    btnPlay.disabled = app.steps.length === 0 || app.stepIndex >= app.steps.length;\n  }\n\n  function highlightCode(step) {\n    // Remove previous highlights\n    const lines = codeBlock.querySelectorAll('code');\n    if (!lines.length) return;\n    // We'll reconstruct by scanning text nodes; simpler: wrap based on indices known\n    // Instead, we'll apply highlights by innerHTML manipulation once then use CSS classes.\n    // To keep simple, we mark by replacing patterns each call. But avoid intense DOM work.\n    // We'll maintain a map of line numbers to content. For brevity, we re-render once.\n  }\n\n  // Efficient code highlighting: pre-split lines once\n  const codeLines = [\n    'function quickSort(A, low, high) {',\n    '  if (low < high) {          // 1',\n    '    let p = partition(A, low, high); // 2',\n    '    quickSort(A, low, p - 1);        // 3',\n    '    quickSort(A, p + 1, high);       // 4',\n    '  }',\n    '}',\n    '',\n    'function partition(A, low, high) {',\n    '  let pivot = A[high];       // 5',\n    '  let i = low;               // 6',\n    '  for (let j = low; j < high; j++) { // 7',\n    '    if (A[j] <= pivot) {     // 8',\n    '      swap(A, i, j);         // 9',\n    '      i++;                   // 10',\n    '    }',\n    '  }',\n    '  swap(A, i, high);          // 11',\n    '  return i;                  // 12',\n    '}'\n  ];\n  function renderCode(stepType) {\n    const highlight = new Set();\n    switch (stepType) {\n      case 'subrange': highlight.add(1); break; // \"if (low < high)\"\n      case 'choosePivot': highlight.add(9); highlight.add(10); break; // pivot and i init soon\n      case 'iSet': highlight.add(10); break;\n      case 'compare': highlight.add(11); highlight.add(12); break; // for and if\n      case 'swap': highlight.add(13); break; // swap(A, i, j)\n      case 'finalSwap': highlight.add(17); break; // swap(A, i, high)\n      case 'pivotPlaced': highlight.add(2); break; // partition returns -> p\n      case 'done': break;\n      default: break;\n    }\n    const html = codeLines.map((ln, idx) => {\n      const lineNo = idx + 1;\n      return `<div class=\"${highlight.has(lineNo) ? 'hl' : ''}\">${ln.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</div>`;\n    }).join('');\n    codeBlock.innerHTML = `<code>${html}</code>`;\n  }\n\n  function applyStep(step) {\n    clearTransientHighlights();\n    switch (step.type) {\n      case 'subrange': {\n        app.pointers.range = [step.low, step.high];\n        applyRangeShading();\n        app.pointers.i = null;\n        app.pointers.j = null;\n        app.pointers.pivot = null;\n        renderCode('subrange');\n        break;\n      }\n      case 'choosePivot': {\n        app.pointers.pivot = step.index;\n        const el = app.idMap.get(app.state[step.index].id);\n        if (el) el.classList.add('pivot');\n        renderCode('choosePivot');\n        break;\n      }\n      case 'iSet': {\n        app.pointers.i = step.index;\n        const el = app.idMap.get(app.state[step.index]?.id);\n        if (el) el.classList.add('i');\n        renderCode('iSet');\n        break;\n      }\n      case 'compare': {\n        app.pointers.j = step.j;\n        app.pointers.pivot = step.pivotIndex;\n        app.counters.comparisons++;\n        const jEl = app.idMap.get(app.state[step.j].id);\n        if (jEl) jEl.classList.add('j');\n        const pEl = app.idMap.get(app.state[step.pivotIndex].id);\n        if (pEl) pEl.classList.add('pivot');\n        renderCode('compare');\n        break;\n      }\n      case 'swap': {\n        app.counters.swaps++;\n        swapStateIndices(step.a, step.b);\n        const aEl = app.idMap.get(app.state[step.a].id);\n        const bEl = app.idMap.get(app.state[step.b].id);\n        if (aEl) aEl.classList.add('swap');\n        if (bEl) bEl.classList.add('swap');\n        renderCode('swap');\n        break;\n      }\n      case 'finalSwap': {\n        app.counters.swaps++;\n        swapStateIndices(step.a, step.b);\n        const aEl = app.idMap.get(app.state[step.a].id);\n        const bEl = app.idMap.get(app.state[step.b].id);\n        if (aEl) aEl.classList.add('swap');\n        if (bEl) bEl.classList.add('swap');\n        renderCode('finalSwap');\n        break;\n      }\n      case 'pivotPlaced': {\n        app.pointers.pivot = step.index;\n        markSortedIndex(step.index);\n        renderCode('pivotPlaced');\n        break;\n      }\n      case 'sortedRange': {\n        // If range length is 1, mark it sorted\n        for (let idx = step.low; idx <= step.high; idx++) {\n          markSortedIndex(idx);\n        }\n        break;\n      }\n      case 'touch': {\n        // no-op, but highlight j\n        const el = app.idMap.get(app.state[step.index]?.id);\n        if (el) el.classList.add('j');\n        break;\n      }\n      case 'done': {\n        for (let i = 0; i < app.state.length; i++) {\n          markSortedIndex(i);\n        }\n        stop();\n        renderCode('done');\n        break;\n      }\n      default:\n        break;\n    }\n    app.stepIndex++;\n    updateUI();\n  }\n\n  function nextStep() {\n    if (!app.steps.length || app.stepIndex >= app.steps.length) {\n      stop();\n      return;\n    }\n    const step = app.steps[app.stepIndex];\n    applyStep(step);\n  }\n\n  function play() {\n    if (!app.steps.length || app.stepIndex >= app.steps.length) return;\n    if (app.playing) return;\n    app.playing = true;\n    updateUI();\n    const interval = Math.max(60, Math.round(1000 / app.speed));\n    app.timer = setInterval(() => {\n      if (app.stepIndex >= app.steps.length) {\n        stop();\n        return;\n      }\n      nextStep();\n    }, interval);\n  }\n\n  function stop() {\n    app.playing = false;\n    if (app.timer) {\n      clearInterval(app.timer);\n      app.timer = null;\n    }\n    updateUI();\n  }\n\n  function reset() {\n    stop();\n    init(app.initialValues.slice());\n    highlightCode(null);\n    renderCode(null);\n  }\n\n  // Event bindings\n  btnRandom.addEventListener('click', () => {\n    const n = clamp(Number(randCountEl.value) || 20, 5, 60);\n    const vals = generateRandom(n);\n    inputArrayEl.value = vals.join(', ');\n    init(vals);\n  });\n\n  btnSort.addEventListener('click', () => {\n    const values = parseInput(inputArrayEl.value);\n    if (!values.length) {\n      alert('Please enter at least one valid number.');\n      return;\n    }\n    init(values);\n    app.pivotStrategy = pivotSelect.value;\n    app.steps = buildQuickSortSteps(values, app.pivotStrategy);\n    app.stepIndex = 0;\n    updateUI();\n    renderCode(null);\n  });\n\n  btnPlay.addEventListener('click', () => {\n    if (app.playing) {\n      stop();\n    } else {\n      play();\n    }\n  });\n\n  btnStep.addEventListener('click', () => {\n    stop();\n    nextStep();\n  });\n\n  btnReset.addEventListener('click', () => {\n    reset();\n  });\n\n  pivotSelect.addEventListener('change', () => {\n    app.pivotStrategy = pivotSelect.value;\n    if (app.initialValues.length) {\n      // Rebuild steps for current initial values (not current state)\n      app.steps = buildQuickSortSteps(app.initialValues.slice(), app.pivotStrategy);\n      app.stepIndex = 0;\n      app.state = app.initialValues.map((v, idx) => ({ id: idx + 1, value: v }));\n      updateBarsPos(true);\n      app.counters.comparisons = 0;\n      app.counters.swaps = 0;\n      app.pointers = {i: null, j: null, pivot: null, range: null};\n      applyRangeShading();\n      updateUI();\n    }\n  });\n\n  speedRange.addEventListener('input', () => {\n    app.speed = Number(speedRange.value);\n    speedLabel.textContent = `${app.speed.toFixed(2)}x`;\n    if (app.playing) {\n      stop();\n      play();\n    }\n  });\n\n  window.addEventListener('resize', () => {\n    updateLayout();\n  });\n\n  // Bootstrap with an initial random array\n  const initialVals = generateRandom(randCountEl.value);\n  inputArrayEl.value = initialVals.join(', ');\n  init(initialVals);\n\n  // Build initial steps (optional)\n  app.steps = buildQuickSortSteps(initialVals, app.pivotStrategy);\n  updateUI();\n  renderCode(null);\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Quick Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "c5d98340-a36b-11f0-87d8-19d3e4ae3a1e",
    "timestamp": "2025-10-07T10:52:52.468Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Heap Sort",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Heap Sort Visualization (Single File)</title>\n<style>\n  :root{\n    --bg: #0f172a;          /* slate-900 */\n    --panel: #111827;       /* gray-900 */\n    --panel-2: #0b1222;     /* dark bluish */\n    --text: #e5e7eb;        /* gray-200 */\n    --muted: #9ca3af;       /* gray-400 */\n    --primary: #60a5fa;     /* blue-400 */\n    --accent: #f59e0b;      /* amber-500 */\n    --danger: #f87171;      /* red-400 */\n    --success: #34d399;     /* emerald-400 */\n    --outline: #334155;     /* slate-600 */\n    --swap: #ef4444;        /* red-500 */\n    --compare: #f59e0b;     /* amber-500 */\n    --heap: #60a5fa;        /* blue-400 */\n    --out: #334155;         /* slate-600 */\n    --focus: #a78bfa;       /* violet-400 */\n  }\n  * { box-sizing: border-box; }\n  html, body {\n    height: 100%;\n    background: radial-gradient(1200px 600px at 20% -10%, #1e293b 0%, #0f172a 60%);\n    color: var(--text);\n    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n    margin: 0;\n  }\n  .app {\n    max-width: 1100px;\n    margin: 0 auto;\n    padding: 18px 14px 30px;\n  }\n  h1 {\n    font-weight: 700;\n    font-size: 1.6rem;\n    letter-spacing: 0.2px;\n    margin: 6px 0 14px 0;\n    display: flex;\n    align-items: center;\n    gap: 10px;\n  }\n  h1 .badge {\n    font-size: 0.74rem;\n    background: linear-gradient(180deg, #1f2937, #0f172a);\n    border: 1px solid var(--outline);\n    color: var(--muted);\n    border-radius: 999px;\n    padding: 4px 8px;\n  }\n  .panel {\n    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.18));\n    border: 1px solid rgba(148,163,184,0.15);\n    border-radius: 14px;\n    box-shadow: 0 8px 30px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.04);\n  }\n  .controls {\n    display: grid;\n    grid-template-columns: 1.1fr 1fr 1fr 1.6fr;\n    gap: 10px;\n    padding: 12px;\n  }\n  @media (max-width: 880px){\n    .controls { grid-template-columns: 1fr 1fr; }\n  }\n  @media (max-width: 520px){\n    .controls { grid-template-columns: 1fr; }\n  }\n\n  .field {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    padding: 10px;\n    border-radius: 12px;\n    background: rgba(2,6,23,0.35);\n    border: 1px solid rgba(148,163,184,0.12);\n  }\n  .field label {\n    font-size: 0.78rem;\n    color: var(--muted);\n    display: flex;\n    align-items: center;\n    gap: 8px;\n  }\n  .row {\n    display: flex;\n    gap: 8px;\n    align-items: center;\n    flex-wrap: wrap;\n  }\n  input[type=\"text\"]{\n    width: 100%;\n    background: rgba(2,6,23,0.5);\n    color: var(--text);\n    border: 1px solid rgba(148,163,184,0.18);\n    border-radius: 10px;\n    padding: 10px 12px;\n    outline: none;\n    transition: border-color .15s, box-shadow .15s;\n  }\n  input[type=\"text\"]:focus{\n    border-color: var(--focus);\n    box-shadow: 0 0 0 3px rgba(167,139,250,.15);\n  }\n  .chip {\n    display: inline-flex;\n    align-items: center;\n    gap: 6px;\n    padding: 6px 10px;\n    border-radius: 999px;\n    font-size: 0.78rem;\n    color: var(--muted);\n    border: 1px dashed rgba(148,163,184,0.28);\n    background: rgba(2,6,23,0.35);\n  }\n  input[type=\"range\"]{\n    width: 100%;\n    accent-color: var(--primary);\n  }\n  .btn {\n    appearance: none;\n    border: 1px solid rgba(148,163,184,0.2);\n    background: linear-gradient(180deg, rgba(59,130,246,0.18), rgba(59,130,246,0.08));\n    color: #e6f1ff;\n    padding: 10px 12px;\n    border-radius: 10px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: transform .05s ease, background .15s ease, border-color .15s ease, box-shadow .15s;\n    user-select: none;\n  }\n  .btn.secondary{\n    background: linear-gradient(180deg, rgba(2,6,23,0.35), rgba(2,6,23,0.2));\n    color: var(--text);\n  }\n  .btn.danger{\n    background: linear-gradient(180deg, rgba(248,113,113,0.22), rgba(248,113,113,0.08));\n    border-color: rgba(248,113,113,0.35);\n  }\n  .btn:active{ transform: translateY(1px); }\n  .btn[disabled]{ opacity: 0.55; cursor: not-allowed; }\n\n  .status {\n    margin-top: 12px;\n    padding: 12px 14px;\n    display: flex;\n    gap: 10px;\n    align-items: center;\n    flex-wrap: wrap;\n  }\n  .status .message {\n    flex: 1 1 auto;\n    background: rgba(2,6,23,0.45);\n    border: 1px solid rgba(148,163,184,0.16);\n    padding: 10px 12px;\n    border-radius: 10px;\n    min-height: 40px;\n    display: flex;\n    align-items: center;\n  }\n  .pill {\n    padding: 8px 10px;\n    border-radius: 999px;\n    border: 1px solid rgba(148,163,184,0.2);\n    background: rgba(2,6,23,0.45);\n    font-size: 0.84rem;\n    color: var(--muted);\n  }\n\n  .viz {\n    margin-top: 16px;\n    padding: 14px 10px 18px;\n  }\n  .bars {\n    height: 340px;\n    display: flex;\n    align-items: flex-end;\n    gap: 4px;\n    padding: 10px;\n    border-radius: 12px;\n    border: 1px solid rgba(148,163,184,0.14);\n    background: linear-gradient(180deg, rgba(2,6,23,0.35), rgba(2,6,23,0.1));\n    position: relative;\n    overflow: hidden;\n  }\n  .bars::after{\n    content:\"\";\n    position:absolute;\n    inset:0;\n    background: radial-gradient(800px 300px at 80% -20%, rgba(96,165,250,0.10), transparent 60%),\n                radial-gradient(600px 240px at 10% -20%, rgba(79,70,229,0.09), transparent 60%);\n    pointer-events: none;\n  }\n  .bar {\n    flex: 1 1 0;\n    min-width: 8px;\n    position: relative;\n    border-radius: 8px 8px 2px 2px;\n    background: linear-gradient(180deg, rgba(37,99,235,0.85), rgba(37,99,235,0.55));\n    border: 1px solid rgba(59,130,246,0.45);\n    transition: height .25s ease, background .15s ease, border-color .15s ease, transform .2s ease, opacity .2s ease;\n    display: flex;\n    align-items: flex-end;\n    justify-content: center;\n  }\n  .bar .val {\n    position: absolute;\n    bottom: 6px;\n    font-size: 11px;\n    color: #e6f1ff;\n    text-shadow: 0 1px 0 rgba(0,0,0,0.25);\n    opacity: 0.85;\n    user-select: none;\n    pointer-events: none;\n  }\n  .bar .idx {\n    position: absolute;\n    bottom: -18px;\n    color: var(--muted);\n    font-size: 10px;\n    user-select: none;\n    pointer-events: none;\n  }\n  .bar.compare {\n    background: linear-gradient(180deg, rgba(245,158,11,0.9), rgba(245,158,11,0.6));\n    border-color: rgba(245,158,11,0.6);\n    box-shadow: 0 0 0 2px rgba(245,158,11,0.18);\n  }\n  .bar.swap {\n    background: linear-gradient(180deg, rgba(239,68,68,0.95), rgba(239,68,68,0.7));\n    border-color: rgba(239,68,68,0.6);\n    box-shadow: 0 0 0 2px rgba(239,68,68,0.18);\n    transform: translateY(-4px);\n  }\n  .bar.sorted {\n    background: linear-gradient(180deg, rgba(16,185,129,0.95), rgba(16,185,129,0.6));\n    border-color: rgba(16,185,129,0.55);\n  }\n  .bar.out {\n    background: linear-gradient(180deg, rgba(100,116,139,0.5), rgba(51,65,85,0.35));\n    border-color: rgba(100,116,139,0.35);\n    opacity: 0.7;\n  }\n  .legend {\n    margin-top: 10px;\n    display: flex;\n    gap: 8px;\n    flex-wrap: wrap;\n    padding: 10px;\n  }\n  .legend .k {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    padding: 6px 10px;\n    background: rgba(2,6,23,0.45);\n    border: 1px solid rgba(148,163,184,0.18);\n    border-radius: 999px;\n    font-size: 12px;\n    color: var(--muted);\n  }\n  .dot {\n    width: 14px;\n    height: 14px;\n    border-radius: 4px;\n    display: inline-block;\n  }\n  .dot.heap { background: linear-gradient(180deg, rgba(37,99,235,0.85), rgba(37,99,235,0.55)); border: 1px solid rgba(59,130,246,0.45); }\n  .dot.compare { background: linear-gradient(180deg, rgba(245,158,11,0.9), rgba(245,158,11,0.6)); border: 1px solid rgba(245,158,11,0.6); }\n  .dot.swap { background: linear-gradient(180deg, rgba(239,68,68,0.95), rgba(239,68,68,0.7)); border: 1px solid rgba(239,68,68,0.6); }\n  .dot.sorted { background: linear-gradient(180deg, rgba(16,185,129,0.95), rgba(16,185,129,0.6)); border: 1px solid rgba(16,185,129,0.55); }\n  .dot.out { background: linear-gradient(180deg, rgba(100,116,139,0.5), rgba(51,65,85,0.35)); border: 1px solid rgba(100,116,139,0.35); }\n\n  details.explain {\n    margin-top: 14px;\n    padding: 10px 12px;\n  }\n  details.explain summary {\n    cursor: pointer;\n    list-style: none;\n  }\n  details.explain summary::-webkit-details-marker { display: none; }\n  .explain .content {\n    color: var(--muted);\n    font-size: 0.95rem;\n    line-height: 1.45;\n    margin-top: 8px;\n  }\n\n  .footer {\n    margin-top: 18px;\n    color: var(--muted);\n    font-size: 12px;\n    text-align: center;\n  }\n</style>\n</head>\n<body>\n  <div class=\"app\">\n    <h1>\n      Heap Sort Visualizer\n      <span class=\"badge\">In-place, O(n log n)</span>\n    </h1>\n\n    <div class=\"panel controls\">\n      <div class=\"field\" style=\"grid-column: span 2;\">\n        <label>\n          Custom array (comma or space separated)\n          <span class=\"chip\">Example: 5, 1, 9, 3, 7</span>\n        </label>\n        <div class=\"row\">\n          <input id=\"customInput\" type=\"text\" placeholder=\"Enter numbers, e.g., 12, 7, 3, 19, 2\" />\n          <button id=\"applyCustom\" class=\"btn secondary\">Apply</button>\n        </div>\n      </div>\n\n      <div class=\"field\">\n        <label>\n          Size\n          <span class=\"chip\"><span id=\"sizeOut\">20</span></span>\n        </label>\n        <input id=\"size\" type=\"range\" min=\"5\" max=\"80\" value=\"20\" />\n        <div class=\"row\">\n          <button id=\"randomize\" class=\"btn\">Randomize</button>\n          <button id=\"shuffle\" class=\"btn secondary\">Shuffle</button>\n        </div>\n      </div>\n\n      <div class=\"field\">\n        <label>\n          Speed\n          <span class=\"chip\"><span id=\"speedOut\">1.0x</span></span>\n        </label>\n        <input id=\"speed\" type=\"range\" min=\"0\" max=\"100\" value=\"60\" />\n        <div class=\"row\">\n          <label style=\"font-size: 0.76rem; color: var(--muted);\">Show values\n            <input id=\"showValues\" type=\"checkbox\" style=\"margin-left:8px\" checked />\n          </label>\n        </div>\n      </div>\n\n      <div class=\"field\">\n        <label>Controls</label>\n        <div class=\"row\">\n          <button id=\"start\" class=\"btn\">Start</button>\n          <button id=\"step\" class=\"btn secondary\">Step</button>\n          <button id=\"pause\" class=\"btn secondary\">Pause</button>\n          <button id=\"reset\" class=\"btn danger\">Reset</button>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel status\">\n      <div class=\"message\" id=\"message\">Ready. Generate data or start sorting.</div>\n      <div class=\"pill\">Heap size: <span id=\"heapSizeOut\" style=\"margin-left:6px; color:#fff;\">0</span></div>\n      <div class=\"pill\">Comparisons: <span id=\"compOut\" style=\"margin-left:6px; color:#fff;\">0</span></div>\n      <div class=\"pill\">Swaps: <span id=\"swapOut\" style=\"margin-left:6px; color:#fff;\">0</span></div>\n    </div>\n\n    <div class=\"panel viz\">\n      <div id=\"bars\" class=\"bars\"></div>\n      <div class=\"legend\">\n        <span class=\"k\"><span class=\"dot heap\"></span> In-heap</span>\n        <span class=\"k\"><span class=\"dot out\"></span> Out of heap</span>\n        <span class=\"k\"><span class=\"dot compare\"></span> Comparing</span>\n        <span class=\"k\"><span class=\"dot swap\"></span> Swapping</span>\n        <span class=\"k\"><span class=\"dot sorted\"></span> Sorted</span>\n      </div>\n    </div>\n\n    <details class=\"panel explain\">\n      <summary><strong>What is Heap Sort?</strong></summary>\n      <div class=\"content\">\n        Heap Sort is a comparison-based sorting algorithm that turns the array into a max-heap, then repeatedly extracts the maximum element (the root) to the end of the array, shrinking the heap each time. It runs in O(n log n) time and sorts in place with O(1) extra space.\n        Steps:\n        - Build a max-heap from the array (siftDown from the last parent to the root).\n        - Swap the root (maximum) with the last element of the heap; mark it sorted (out of the heap).\n        - Restore heap property by sifting the new root down.\n        - Repeat until the heap size is 1.\n      </div>\n    </details>\n\n    <div class=\"footer\">\n      Tip: Use Step to advance one operation at a time, or Start to animate automatically. Adjust Speed for faster or slower animations.\n    </div>\n  </div>\n\n<script>\n(function(){\n  // State\n  const state = {\n    array: [],\n    original: [],\n    gen: null,\n    playing: false,\n    delayMs: 300,\n    sorted: new Set(),\n    heapSize: 0,\n    highlights: { compare: null, swap: null },\n    message: 'Ready.',\n    comparisons: 0,\n    swaps: 0,\n    showValues: true,\n    runningToken: 0\n  };\n\n  // Elements\n  const el = {\n    bars: document.getElementById('bars'),\n    message: document.getElementById('message'),\n    heapSizeOut: document.getElementById('heapSizeOut'),\n    compOut: document.getElementById('compOut'),\n    swapOut: document.getElementById('swapOut'),\n    size: document.getElementById('size'),\n    sizeOut: document.getElementById('sizeOut'),\n    speed: document.getElementById('speed'),\n    speedOut: document.getElementById('speedOut'),\n    showValues: document.getElementById('showValues'),\n    randomize: document.getElementById('randomize'),\n    shuffle: document.getElementById('shuffle'),\n    start: document.getElementById('start'),\n    step: document.getElementById('step'),\n    pause: document.getElementById('pause'),\n    reset: document.getElementById('reset'),\n    customInput: document.getElementById('customInput'),\n    applyCustom: document.getElementById('applyCustom'),\n  };\n\n  // Utilities\n  function randInt(min, max){\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n  function generateRandomArray(n){\n    const arr = new Array(n);\n    for (let i=0;i<n;i++) arr[i] = randInt(5, 100);\n    return arr;\n  }\n  function shuffleArray(arr){\n    for (let i=arr.length-1; i>0; i--){\n      const j = Math.floor(Math.random() * (i+1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n  function sleep(ms){\n    return new Promise(res=>setTimeout(res, ms));\n  }\n  function setMessage(msg){\n    state.message = msg;\n    el.message.textContent = msg;\n  }\n  function setDelayFromSpeedSlider(){\n    // Map slider 0..100 to delay 800ms..20ms (exponential-ish curve)\n    const v = Number(el.speed.value);\n    const t = v/100; // 0..1\n    // Use an exponential mapping for better control at high speeds\n    const min = 20, max = 800;\n    const k = 4; // curvature\n    const factor = Math.pow(1 - t, k);\n    const delay = Math.round(min + (max - min) * factor);\n    state.delayMs = delay;\n    const speedFactor = (max / delay).toFixed(1);\n    el.speedOut.textContent = speedFactor + 'x';\n  }\n\n  // Visualization\n  function render(){\n    const arr = state.array;\n    const n = arr.length;\n    const maxVal = Math.max(100, ...arr, 1);\n    const heapSize = state.heapSize ?? n;\n\n    // Build bars\n    el.bars.innerHTML = '';\n    for (let i=0;i<n;i++){\n      const v = arr[i];\n      const bar = document.createElement('div');\n      bar.className = 'bar';\n      const heightPct = (v / maxVal) * 100;\n      bar.style.height = Math.max(4, heightPct) + '%';\n\n      // Classes\n      const isSorted = state.sorted.has(i);\n      const inHeap = i < heapSize && !isSorted;\n      if (isSorted) {\n        bar.classList.add('sorted');\n      } else if (!inHeap) {\n        bar.classList.add('out');\n      }\n      if (state.highlights.compare && (i === state.highlights.compare[0] || i === state.highlights.compare[1])){\n        bar.classList.remove('out');\n        bar.classList.add('compare');\n      }\n      if (state.highlights.swap && (i === state.highlights.swap[0] || i === state.highlights.swap[1])){\n        bar.classList.remove('out');\n        bar.classList.add('swap');\n      }\n\n      // Labels\n      if (state.showValues){\n        const val = document.createElement('div');\n        val.className = 'val';\n        val.textContent = v;\n        bar.appendChild(val);\n      }\n      const idx = document.createElement('div');\n      idx.className = 'idx';\n      idx.textContent = i;\n      bar.appendChild(idx);\n\n      el.bars.appendChild(bar);\n    }\n\n    // Status\n    el.heapSizeOut.textContent = String(heapSize);\n    el.compOut.textContent = String(state.comparisons);\n    el.swapOut.textContent = String(state.swaps);\n  }\n\n  // Heap Sort step generator\n  function* heapifySteps(arr, heapSize, i){\n    while (true){\n      let largest = i;\n      const left = 2*i + 1;\n      const right = 2*i + 2;\n\n      if (left < heapSize){\n        yield { type: 'compare', i: largest, j: left, heapSize, message: `Compare parent (${i}) and left child (${left})` };\n        if (arr[left] > arr[largest]) largest = left;\n      }\n      if (right < heapSize){\n        yield { type: 'compare', i: largest, j: right, heapSize, message: `Compare current largest (${largest}) and right child (${right})` };\n        if (arr[right] > arr[largest]) largest = right;\n      }\n      if (largest !== i){\n        yield { type: 'swap', i, j: largest, heapSize, message: `Swap to restore heap property: ${i} ⇄ ${largest}` };\n        [arr[i], arr[largest]] = [arr[largest], arr[i]];\n        i = largest;\n      } else {\n        break;\n      }\n    }\n    yield { type: 'heapifyDone', heapSize, message: `Heapify path complete` };\n  }\n\n  function* heapSortSteps(arr){\n    const n = arr.length;\n    yield { type: 'info', heapSize: n, message: 'Build max heap' };\n    for (let i = Math.floor(n/2) - 1; i >= 0; i--){\n      yield { type: 'heapifyStart', idx: i, heapSize: n, message: `Sift down from index ${i}` };\n      yield* heapifySteps(arr, n, i);\n    }\n    yield { type: 'info', heapSize: n, message: 'Max heap built. Extract max and sort.' };\n\n    for (let end = n - 1; end > 0; end--){\n      yield { type: 'swap', i: 0, j: end, heapSize: end + 1, message: `Swap max at root (0) with end (${end})` };\n      [arr[0], arr[end]] = [arr[end], arr[0]];\n      yield { type: 'markSorted', index: end, heapSize: end, message: `Position ${end} fixed (sorted)` };\n      yield* heapifySteps(arr, end, 0);\n    }\n    if (n > 0){\n      yield { type: 'markSorted', index: 0, heapSize: 0, message: `All done` };\n    }\n    yield { type: 'done', heapSize: 0, message: 'Array is sorted.' };\n  }\n\n  // Step handling\n  function clearHighlights(){\n    state.highlights.compare = null;\n    state.highlights.swap = null;\n  }\n  function applyStep(step){\n    clearHighlights();\n\n    if (typeof step.heapSize === 'number'){\n      state.heapSize = step.heapSize;\n    }\n\n    switch(step.type){\n      case 'info':\n        setMessage(step.message);\n        break;\n      case 'heapifyStart':\n        setMessage(step.message);\n        break;\n      case 'compare':\n        state.comparisons++;\n        state.highlights.compare = [step.i, step.j];\n        setMessage(step.message);\n        break;\n      case 'swap':\n        state.swaps++;\n        state.highlights.swap = [step.i, step.j];\n        setMessage(step.message);\n        break;\n      case 'markSorted':\n        state.sorted.add(step.index);\n        setMessage(step.message || 'Marked sorted');\n        break;\n      case 'heapifyDone':\n        setMessage(step.message);\n        break;\n      case 'done':\n        setMessage(step.message);\n        break;\n    }\n\n    render();\n  }\n\n  async function runGeneratorAuto(){\n    const token = ++state.runningToken;\n    state.playing = true;\n    updateButtons();\n\n    while (state.playing && state.gen){\n      const { value, done } = state.gen.next();\n      if (token !== state.runningToken) return; // superseded\n      if (done){\n        state.playing = false;\n        updateButtons();\n        setMessage('Array is sorted.');\n        state.heapSize = 0;\n        render();\n        break;\n      }\n      applyStep(value);\n\n      // Delay\n      let d = state.delayMs;\n      if (value.type === 'swap') d = Math.round(state.delayMs * 1.25);\n      await sleep(d);\n\n      // While paused, wait loop\n      while (!state.playing){\n        if (token !== state.runningToken) return;\n        await sleep(60);\n      }\n    }\n  }\n\n  function stepOnce(){\n    if (!state.gen) {\n      state.gen = heapSortSteps(state.array);\n      state.runningToken++;\n      state.sorted.clear();\n      state.comparisons = 0;\n      state.swaps = 0;\n      state.heapSize = state.array.length;\n    }\n    const { value, done } = state.gen.next();\n    if (done){\n      setMessage('Array is sorted.');\n      state.heapSize = 0;\n      render();\n      state.playing = false;\n      updateButtons();\n      return;\n    }\n    applyStep(value);\n  }\n\n  // Buttons and inputs\n  function updateButtons(){\n    el.pause.textContent = state.playing ? 'Pause' : 'Resume';\n    el.start.disabled = state.playing;\n    el.step.disabled = state.playing;\n    el.randomize.disabled = state.playing;\n    el.shuffle.disabled = state.playing;\n    el.applyCustom.disabled = state.playing;\n    el.customInput.disabled = state.playing;\n    el.size.disabled = state.playing;\n  }\n\n  function setArray(arr){\n    state.array = arr.slice();\n    state.original = arr.slice();\n    state.gen = null;\n    state.playing = false;\n    state.sorted.clear();\n    state.heapSize = arr.length;\n    state.comparisons = 0;\n    state.swaps = 0;\n    clearHighlights();\n    setMessage('Ready.');\n    updateButtons();\n    render();\n  }\n\n  function parseCustomInput(str){\n    // Accept commas and/or spaces\n    const parts = str.split(/[\\s,]+/).map(s=>s.trim()).filter(Boolean);\n    if (parts.length === 0) return null;\n    const nums = parts.map(x => Number(x));\n    if (nums.some(n => !Number.isFinite(n))) return null;\n    return nums;\n  }\n\n  // Initial setup\n  function init(){\n    el.sizeOut.textContent = el.size.value;\n    el.size.addEventListener('input', ()=>{\n      el.sizeOut.textContent = el.size.value;\n    });\n    el.randomize.addEventListener('click', ()=>{\n      const n = Number(el.size.value);\n      const arr = generateRandomArray(n);\n      setArray(arr);\n    });\n    el.shuffle.addEventListener('click', ()=>{\n      const arr = state.array.slice();\n      shuffleArray(arr);\n      setArray(arr);\n    });\n    el.applyCustom.addEventListener('click', ()=>{\n      const nums = parseCustomInput(el.customInput.value);\n      if (!nums || nums.length === 0){\n        setMessage('Invalid input. Please enter numbers separated by commas or spaces.');\n        return;\n      }\n      setArray(nums);\n      el.size.value = Math.min(Math.max(nums.length, Number(el.size.min)), Number(el.size.max));\n      el.sizeOut.textContent = el.size.value;\n    });\n    el.speed.addEventListener('input', setDelayFromSpeedSlider);\n    el.showValues.addEventListener('change', ()=>{\n      state.showValues = el.showValues.checked;\n      render();\n    });\n\n    el.start.addEventListener('click', ()=>{\n      if (!state.gen){\n        state.gen = heapSortSteps(state.array);\n        state.sorted.clear();\n        state.comparisons = 0;\n        state.swaps = 0;\n        state.heapSize = state.array.length;\n        clearHighlights();\n      }\n      state.playing = true;\n      runGeneratorAuto();\n      updateButtons();\n    });\n    el.step.addEventListener('click', ()=>{\n      state.playing = false;\n      updateButtons();\n      stepOnce();\n    });\n    el.pause.addEventListener('click', ()=>{\n      if (!state.gen){\n        // If not started, start paused -> single step\n        state.gen = heapSortSteps(state.array);\n        state.heapSize = state.array.length;\n      }\n      state.playing = !state.playing;\n      updateButtons();\n      if (state.playing){\n        runGeneratorAuto();\n      }\n    });\n    el.reset.addEventListener('click', ()=>{\n      setArray(state.original);\n    });\n\n    // Defaults\n    setDelayFromSpeedSlider();\n    const defaultArr = generateRandomArray(Number(el.size.value));\n    setArray(defaultArr);\n  }\n\n  init();\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Heap Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "f8536b10-a36b-11f0-ab3a-e97f25d16733",
    "timestamp": "2025-10-07T10:54:17.153Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Counting Sort",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Counting Sort Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <style>\n    :root {\n      --bg: #0f172a;\n      --panel: #111827;\n      --accent: #22c55e;\n      --accent2: #60a5fa;\n      --text: #e5e7eb;\n      --muted: #94a3b8;\n      --warn: #f59e0b;\n      --error: #ef4444;\n      --tile: #1f2937;\n      --border: #334155;\n      --highlight: #2dd4bf;\n      --placed: #22c55e;\n      --updated: #f97316;\n    }\n    * { box-sizing: border-box; }\n    body {\n      margin: 0;\n      background: radial-gradient(1000px 500px at 80% -80%, #0b1226 0%, #0a1224 60%, var(--bg) 100%);\n      color: var(--text);\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n    }\n    header {\n      padding: 20px 24px 8px;\n    }\n    h1 {\n      margin: 0;\n      font-weight: 700;\n      letter-spacing: 0.5px;\n      font-size: 24px;\n    }\n    .sub {\n      color: var(--muted);\n      font-size: 13px;\n      margin-top: 6px;\n    }\n    .container {\n      padding: 12px 24px 24px;\n      display: grid;\n      grid-template-columns: 1fr;\n      gap: 16px;\n    }\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.08);\n      border-radius: 12px;\n      padding: 12px;\n      backdrop-filter: blur(8px);\n    }\n    .controls {\n      display: grid;\n      grid-template-columns: 1fr auto;\n      gap: 12px;\n    }\n    .field-group {\n      display: grid;\n      grid-template-columns: 1fr 180px 160px 160px;\n      gap: 8px;\n      align-items: center;\n    }\n    .field-group .small {\n      display: grid;\n      grid-template-columns: 1fr 1fr 1fr;\n      gap: 8px;\n    }\n    label {\n      font-size: 12px;\n      color: var(--muted);\n    }\n    input[type=\"text\"],\n    input[type=\"number\"],\n    input[type=\"range\"] {\n      width: 100%;\n      padding: 8px 10px;\n      border-radius: 8px;\n      border: 1px solid var(--border);\n      outline: none;\n      background: var(--tile);\n      color: var(--text);\n    }\n    input[type=\"range\"] {\n      padding: 0;\n      height: 2px;\n    }\n    .btn-row {\n      display: flex;\n      gap: 8px;\n      flex-wrap: wrap;\n      align-items: center;\n      justify-content: flex-end;\n    }\n    button {\n      padding: 8px 12px;\n      border-radius: 8px;\n      border: 1px solid var(--border);\n      background: #0b1224;\n      color: var(--text);\n      cursor: pointer;\n      transition: transform 0.1s ease, background 0.2s ease, border 0.2s ease;\n      font-weight: 600;\n      font-size: 13px;\n    }\n    button:hover { transform: translateY(-1px); }\n    button.primary {\n      background: linear-gradient(180deg, rgba(34,197,94,0.25), rgba(34,197,94,0.15));\n      border-color: rgba(34,197,94,0.3);\n    }\n    button.secondary {\n      background: linear-gradient(180deg, rgba(96,165,250,0.25), rgba(96,165,250,0.15));\n      border-color: rgba(96,165,250,0.3);\n    }\n    button.warn {\n      background: linear-gradient(180deg, rgba(245,158,11,0.25), rgba(245,158,11,0.15));\n      border-color: rgba(245,158,11,0.3);\n    }\n    button.danger {\n      background: linear-gradient(180deg, rgba(239,68,68,0.25), rgba(239,68,68,0.15));\n      border-color: rgba(239,68,68,0.3);\n    }\n    .status {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      font-size: 13px;\n      color: var(--muted);\n    }\n    .status strong { color: var(--text); }\n    .viz {\n      display: grid;\n      grid-template-columns: 1fr;\n      gap: 12px;\n    }\n    .row {\n      display: grid;\n      gap: 8px;\n    }\n    .row-title {\n      font-size: 13px;\n      color: var(--muted);\n      display: flex;\n      align-items: center;\n      gap: 8px;\n    }\n    .array {\n      display: flex;\n      gap: 8px;\n      flex-wrap: wrap;\n      align-items: flex-end;\n    }\n    .cell {\n      min-width: 36px;\n      height: 36px;\n      padding: 2px 6px;\n      border-radius: 6px;\n      border: 1px solid var(--border);\n      background: var(--tile);\n      color: var(--text);\n      display: grid;\n      place-items: center;\n      position: relative;\n      user-select: none;\n    }\n    .cell .idx {\n      position: absolute;\n      top: -12px;\n      left: 50%;\n      transform: translateX(-50%);\n      font-size: 10px;\n      color: var(--muted);\n      opacity: 0.8;\n    }\n    .cell .bucket {\n      position: absolute;\n      bottom: -12px;\n      left: 50%;\n      transform: translateX(-50%);\n      font-size: 10px;\n      color: var(--muted);\n      opacity: 0.85;\n    }\n    .cell.active {\n      outline: 2px solid var(--highlight);\n      filter: drop-shadow(0 0 8px rgba(45,212,191,0.25));\n    }\n    .cell.updated {\n      outline: 2px dashed var(--updated);\n    }\n    .cell.placed {\n      outline: 2px solid var(--placed);\n      filter: drop-shadow(0 0 8px rgba(34,197,94,0.25));\n    }\n    .legend {\n      display: flex;\n      gap: 16px;\n      font-size: 12px;\n      color: var(--muted);\n      flex-wrap: wrap;\n    }\n    .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 6px; vertical-align: middle;}\n    .dot.h { background: var(--highlight); }\n    .dot.u { background: var(--updated); }\n    .dot.p { background: var(--placed); }\n    .note {\n      font-size: 12px;\n      color: var(--muted);\n      margin-top: 6px;\n    }\n    .footer {\n      font-size: 12px;\n      color: var(--muted);\n      padding: 0 24px 24px;\n    }\n    .flex {\n      display: flex; gap: 12px; align-items: center; flex-wrap: wrap;\n    }\n    .pill {\n      background: rgba(255,255,255,0.06);\n      border: 1px solid rgba(255,255,255,0.1);\n      border-radius: 999px;\n      padding: 6px 10px;\n    }\n    @media (min-width: 960px) {\n      .container {\n        grid-template-columns: 1.3fr 1fr;\n      }\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Counting Sort Visualizer</h1>\n    <div class=\"sub\">Step-by-step visualization of counting sort with stable placement</div>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"panel\">\n      <div class=\"controls\">\n        <div class=\"field-group\">\n          <div>\n            <label>Input array (comma-separated integers)</label>\n            <input id=\"inputField\" type=\"text\" value=\"4,2,2,8,3,3,1\">\n          </div>\n          <div class=\"small\">\n            <div>\n              <label>Length</label>\n              <input id=\"lenField\" type=\"number\" min=\"1\" max=\"60\" value=\"12\">\n            </div>\n            <div>\n              <label>Min value</label>\n              <input id=\"minField\" type=\"number\" value=\"0\">\n            </div>\n            <div>\n              <label>Max value</label>\n              <input id=\"maxField\" type=\"number\" value=\"9\">\n            </div>\n          </div>\n          <div>\n            <label>Animation speed</label>\n            <input id=\"speedField\" type=\"range\" min=\"0\" max=\"100\" value=\"55\">\n          </div>\n          <div class=\"btn-row\">\n            <button id=\"exampleBtn\" class=\"secondary\">Load example</button>\n            <button id=\"randomBtn\" class=\"secondary\">Random</button>\n            <button id=\"runBtn\" class=\"primary\">Run</button>\n            <button id=\"pauseBtn\">Pause</button>\n            <button id=\"stepBtn\" class=\"warn\">Step</button>\n            <button id=\"resetBtn\" class=\"danger\">Reset</button>\n          </div>\n        </div>\n      </div>\n      <div class=\"status\" id=\"status\">\n        <strong>Status:</strong>\n        <span id=\"statusText\">Idle</span>\n      </div>\n      <div class=\"legend\">\n        <div><span class=\"dot h\"></span>Active</div>\n        <div><span class=\"dot u\"></span>Updated</div>\n        <div><span class=\"dot p\"></span>Placed</div>\n        <div class=\"pill\">Stable sort: duplicates keep original order (we iterate from right to left when placing)</div>\n      </div>\n      <div class=\"note\">Counting sort runs in O(n + k) time, where n is the number of elements and k is the range of distinct key values.</div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"viz\">\n        <div class=\"row\">\n          <div class=\"row-title\">Input array</div>\n          <div class=\"array\" id=\"inputArray\"></div>\n        </div>\n        <div class=\"row\">\n          <div class=\"row-title\">\n            Count array (buckets) and prefix sums\n          </div>\n          <div class=\"array\" id=\"countArray\"></div>\n        </div>\n        <div class=\"row\">\n          <div class=\"row-title\">Output array (sorted)</div>\n          <div class=\"array\" id=\"outputArray\"></div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"footer\">\n    - Counting sort is not comparison-based. It assumes keys are integers in a relatively small range. It can handle negatives by offsetting buckets. It is stable when placement scans input from right to left.\n  </div>\n\n  <script>\n    const inputArrayEl = document.getElementById('inputArray');\n    const countArrayEl = document.getElementById('countArray');\n    const outputArrayEl = document.getElementById('outputArray');\n    const statusEl = document.getElementById('statusText');\n\n    const inputField = document.getElementById('inputField');\n    const lenField = document.getElementById('lenField');\n    const minField = document.getElementById('minField');\n    const maxField = document.getElementById('maxField');\n    const speedField = document.getElementById('speedField');\n\n    const exampleBtn = document.getElementById('exampleBtn');\n    const randomBtn = document.getElementById('randomBtn');\n    const runBtn = document.getElementById('runBtn');\n    const pauseBtn = document.getElementById('pauseBtn');\n    const stepBtn = document.getElementById('stepBtn');\n    const resetBtn = document.getElementById('resetBtn');\n\n    const MAX_RANGE_VIS = 100; // Maximum bucket count for visualization\n\n    function setStatus(msg) {\n      statusEl.textContent = msg;\n    }\n\n    function clearEl(el) {\n      while (el.firstChild) el.removeChild(el.firstChild);\n    }\n\n    function parseInput() {\n      const text = inputField.value.trim();\n      if (!text) return [];\n      const parts = text.split(/[,\\s]+/).filter(Boolean);\n      const arr = [];\n      for (const p of parts) {\n        const v = Number(p);\n        if (!Number.isInteger(v)) throw new Error('All values must be integers.');\n        arr.push(v);\n      }\n      return arr;\n    }\n\n    function randomInt(min, max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n\n    function generateRandom(len, minV, maxV) {\n      const arr = Array.from({ length: len }, () => randomInt(minV, maxV));\n      inputField.value = arr.join(',');\n      return arr;\n    }\n\n    function colorForValue(v, minV, maxV) {\n      // Hash to hue across range\n      const range = Math.max(1, maxV - minV);\n      const t = (v - minV) / range;\n      const hue = Math.round(200 + 120 * t); // blue->green hues\n      return `hsl(${hue}, 70%, 45%)`;\n    }\n\n    function renderInputArray(arr, minV, maxV) {\n      clearEl(inputArrayEl);\n      arr.forEach((v, i) => {\n        const cell = document.createElement('div');\n        cell.className = 'cell';\n        cell.dataset.value = String(v);\n        cell.dataset.idx = String(i);\n        cell.style.borderColor = 'rgba(255,255,255,0.12)';\n        cell.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01))';\n        const value = document.createElement('div');\n        value.textContent = v;\n        value.style.color = colorForValue(v, minV, maxV);\n        const idxLabel = document.createElement('div');\n        idxLabel.className = 'idx';\n        idxLabel.textContent = `#${i}`;\n        cell.appendChild(value);\n        cell.appendChild(idxLabel);\n        inputArrayEl.appendChild(cell);\n      });\n    }\n\n    function renderCountArray(counts, minV) {\n      clearEl(countArrayEl);\n      counts.forEach((c, i) => {\n        const bVal = minV + i;\n        const cell = document.createElement('div');\n        cell.className = 'cell';\n        cell.dataset.bucketIdx = String(i);\n        const val = document.createElement('div');\n        val.textContent = c;\n        val.style.color = colorForValue(bVal, minV, minV + counts.length - 1);\n        const bucketLabel = document.createElement('div');\n        bucketLabel.className = 'bucket';\n        bucketLabel.textContent = bVal;\n        cell.appendChild(val);\n        cell.appendChild(bucketLabel);\n        countArrayEl.appendChild(cell);\n      });\n    }\n\n    function renderOutputArray(len) {\n      clearEl(outputArrayEl);\n      for (let i = 0; i < len; i++) {\n        const cell = document.createElement('div');\n        cell.className = 'cell';\n        cell.dataset.outIdx = String(i);\n        const val = document.createElement('div');\n        val.textContent = '';\n        cell.appendChild(val);\n        const idxLabel = document.createElement('div');\n        idxLabel.className = 'idx';\n        idxLabel.textContent = `@${i}`;\n        cell.appendChild(idxLabel);\n        outputArrayEl.appendChild(cell);\n      }\n    }\n\n    function updateCountCell(counts, idx, minV) {\n      const cell = countArrayEl.querySelector(`.cell[data-bucket-idx=\"${idx}\"]`);\n      if (!cell) return;\n      cell.classList.add('updated');\n      cell.firstChild.textContent = counts[idx];\n      setTimeout(() => cell.classList.remove('updated'), 350);\n    }\n\n    function highlightInput(i) {\n      inputArrayEl.querySelectorAll('.cell').forEach(el => el.classList.remove('active'));\n      const cell = inputArrayEl.querySelector(`.cell[data-idx=\"${i}\"]`);\n      if (cell) cell.classList.add('active');\n    }\n\n    function highlightCountBucket(idx) {\n      countArrayEl.querySelectorAll('.cell').forEach(el => el.classList.remove('active'));\n      const cell = countArrayEl.querySelector(`.cell[data-bucket-idx=\"${idx}\"]`);\n      if (cell) cell.classList.add('active');\n    }\n\n    function highlightPrefix(i, j) {\n      countArrayEl.querySelectorAll('.cell').forEach(el => el.classList.remove('active'));\n      const a = countArrayEl.querySelector(`.cell[data-bucket-idx=\"${i}\"]`);\n      const b = countArrayEl.querySelector(`.cell[data-bucket-idx=\"${j}\"]`);\n      if (a) a.classList.add('active');\n      if (b) b.classList.add('active');\n    }\n\n    function placeOutput(position, value, minV, maxV, originIndex) {\n      const cell = outputArrayEl.querySelector(`.cell[data-out-idx=\"${position}\"]`);\n      if (!cell) return;\n      cell.classList.add('placed');\n      const valNode = cell.firstChild;\n      valNode.textContent = value;\n      valNode.style.color = colorForValue(value, minV, maxV);\n      const idxLabel = cell.querySelector('.idx');\n      idxLabel.textContent = `from #${originIndex}`;\n      setTimeout(() => cell.classList.remove('placed'), 350);\n    }\n\n    function clearHighlights() {\n      document.querySelectorAll('.cell').forEach(el => el.classList.remove('active', 'updated', 'placed'));\n    }\n\n    let controller = null;\n\n    function makeController() {\n      let paused = false;\n      let pendingStepResolve = null;\n      return {\n        isPaused: () => paused,\n        setPaused: (p) => {\n          paused = p;\n          if (!paused && pendingStepResolve) {\n            pendingStepResolve();\n            pendingStepResolve = null;\n          }\n        },\n        stepOnce: () => {\n          if (pendingStepResolve) {\n            pendingStepResolve();\n            pendingStepResolve = null;\n          }\n        },\n        wait: () => {\n          const speed = Number(speedField.value);\n          const delay = Math.round(30 + (100 - speed) * 5); // 30ms..530ms\n          if (!paused) {\n            return new Promise(res => setTimeout(res, delay));\n          } else {\n            return new Promise(res => {\n              pendingStepResolve = res;\n            });\n          }\n        }\n      };\n    }\n\n    async function countingSortAnimate(arr) {\n      setStatus('Parsing and preparing buckets...');\n      const n = arr.length;\n      if (n === 0) {\n        clearEl(inputArrayEl);\n        clearEl(countArrayEl);\n        clearEl(outputArrayEl);\n        setStatus('Empty input array.');\n        return;\n      }\n\n      const minV = Math.min(...arr);\n      const maxV = Math.max(...arr);\n      const range = maxV - minV + 1;\n\n      if (range > MAX_RANGE_VIS) {\n        setStatus(`Range too large (${range}). Please keep max-min <= ${MAX_RANGE_VIS} for visualization.`);\n        return;\n      }\n\n      renderInputArray(arr, minV, maxV);\n      renderOutputArray(n);\n\n      // Step 1: Count frequencies\n      setStatus('Step 1: Counting occurrences for each key.');\n      const counts = Array.from({ length: range }, () => 0);\n      renderCountArray(counts, minV);\n\n      for (let i = 0; i < n; i++) {\n        highlightInput(i);\n        const v = arr[i];\n        const idx = v - minV;\n        highlightCountBucket(idx);\n        counts[idx]++;\n        updateCountCell(counts, idx, minV);\n        await controller.wait();\n      }\n\n      // Step 2: Prefix sums (cumulative counts)\n      setStatus('Step 2: Building prefix sums (cumulative counts). counts[i] += counts[i - 1]');\n      for (let i = 1; i < counts.length; i++) {\n        highlightPrefix(i, i - 1);\n        counts[i] = counts[i] + counts[i - 1];\n        updateCountCell(counts, i, minV);\n        await controller.wait();\n      }\n\n      // Step 3: Placement in output (stable)\n      setStatus('Step 3: Placing elements into output (stable, scanning input from right to left).');\n      clearHighlights();\n      for (let i = n - 1; i >= 0; i--) {\n        highlightInput(i);\n        const v = arr[i];\n        const idx = v - minV;\n        highlightCountBucket(idx);\n        const pos = counts[idx] - 1;\n        placeOutput(pos, v, minV, maxV, i);\n        counts[idx]--;\n        updateCountCell(counts, idx, minV);\n        setStatus(`Placing value ${v} at position ${pos}. Remaining in bucket ${v}: ${counts[idx]}.`);\n        await controller.wait();\n      }\n\n      // Step 4: Done\n      clearHighlights();\n      setStatus('Done. Output array is sorted.');\n    }\n\n    function resetViz() {\n      clearEl(inputArrayEl);\n      clearEl(countArrayEl);\n      clearEl(outputArrayEl);\n      setStatus('Idle');\n      clearHighlights();\n      controller = makeController();\n      pauseBtn.textContent = 'Pause';\n    }\n\n    // Button handlers\n    exampleBtn.addEventListener('click', () => {\n      inputField.value = '4,2,2,8,3,3,1';\n      setStatus('Loaded example: 4,2,2,8,3,3,1');\n    });\n\n    randomBtn.addEventListener('click', () => {\n      const len = Math.min(60, Math.max(1, Number(lenField.value) || 12));\n      let minV = Number(minField.value);\n      let maxV = Number(maxField.value);\n      if (!Number.isFinite(minV)) minV = 0;\n      if (!Number.isFinite(maxV)) maxV = 9;\n      if (minV > maxV) [minV, maxV] = [maxV, minV];\n      generateRandom(len, minV, maxV);\n      setStatus(`Generated random array of length ${len} in [${minV}, ${maxV}].`);\n    });\n\n    runBtn.addEventListener('click', async () => {\n      try {\n        controller = makeController();\n        const arr = parseInput();\n        renderInputArray(arr, Math.min(...(arr.length ? arr : [0])), Math.max(...(arr.length ? arr : [0])));\n        renderOutputArray(arr.length);\n        await countingSortAnimate(arr);\n      } catch (e) {\n        setStatus('Error: ' + e.message);\n      }\n    });\n\n    pauseBtn.addEventListener('click', () => {\n      if (!controller) return;\n      const nowPaused = !controller.isPaused();\n      controller.setPaused(nowPaused);\n      pauseBtn.textContent = nowPaused ? 'Resume' : 'Pause';\n      setStatus(nowPaused ? 'Paused' : 'Running');\n    });\n\n    stepBtn.addEventListener('click', () => {\n      if (!controller) return;\n      controller.setPaused(true);\n      pauseBtn.textContent = 'Resume';\n      controller.stepOnce();\n      setStatus('Stepped one action.');\n    });\n\n    resetBtn.addEventListener('click', () => {\n      resetViz();\n    });\n\n    // Initialize\n    resetViz();\n    // Auto-render initial input\n    (function init() {\n      const arr = parseInput();\n      const minV = Math.min(...(arr.length ? arr : [0]));\n      const maxV = Math.max(...(arr.length ? arr : [0]));\n      renderInputArray(arr, minV, maxV);\n      renderOutputArray(arr.length);\n      renderCountArray(Array.from({ length: Math.max(1, maxV - minV + 1) }, () => 0), minV);\n    })();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Counting Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "34afb050-a36c-11f0-a130-1d2ca38a44f0",
    "timestamp": "2025-10-07T10:55:58.421Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Radix Sort",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Radix Sort Visualizer (LSD, Base 10)</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f1222;\n      --panel: #171a2f;\n      --accent: #6aa1ff;\n      --accent-2: #8be9fd;\n      --text: #edf2ff;\n      --muted: #9aa3b2;\n      --danger: #ff6b6b;\n      --ok: #2ecc71;\n      --warning: #ffb86c;\n      --bucket: #1e2140;\n      --chip: #23284c;\n      --chip2: #2a2f5c;\n      --chip-border: #31407a;\n      --shadow: 0 10px 25px rgba(0,0,0,0.35), 0 2px 6px rgba(0,0,0,0.2);\n    }\n\n    * { box-sizing: border-box; }\n\n    body {\n      margin: 0;\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\",\"Segoe UI Emoji\";\n      background: linear-gradient(180deg, #0f1222 0%, #0a0d1a 100%);\n      color: var(--text);\n    }\n\n    header {\n      padding: 24px 20px 10px 20px;\n    }\n\n    h1 {\n      margin: 0 0 6px 0;\n      font-weight: 800;\n      letter-spacing: 0.2px;\n      font-size: 26px;\n      color: #cfe3ff;\n      text-shadow: 0 2px 18px rgba(106,161,255,0.25);\n    }\n    .sub {\n      color: var(--muted);\n      font-size: 14px;\n    }\n\n    .container {\n      padding: 12px 20px 28px;\n      display: grid;\n      gap: 14px;\n    }\n\n    .panel {\n      background: var(--panel);\n      border: 1px solid #222644;\n      border-radius: 14px;\n      padding: 14px;\n      box-shadow: var(--shadow);\n    }\n\n    .controls {\n      display: grid;\n      gap: 10px;\n    }\n\n    .controls-row {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 8px;\n      align-items: center;\n    }\n\n    .controls input[type=\"text\"] {\n      flex: 1 1 340px;\n      min-width: 200px;\n      background: #11142a;\n      border: 1px solid #23284a;\n      color: var(--text);\n      padding: 10px 12px;\n      border-radius: 10px;\n      outline: none;\n      transition: border-color 0.15s ease;\n    }\n    .controls input[type=\"text\"]:focus {\n      border-color: var(--accent);\n      box-shadow: 0 0 0 2px rgba(106,161,255,0.15);\n    }\n\n    .btn {\n      background: linear-gradient(180deg, #2b66ff, #224ddb);\n      color: white;\n      border: 1px solid #2f54d8;\n      padding: 10px 14px;\n      border-radius: 10px;\n      font-weight: 600;\n      cursor: pointer;\n      transition: transform 0.05s ease, filter 0.2s ease, background 0.2s ease;\n      user-select: none;\n    }\n    .btn:hover { filter: brightness(1.05); }\n    .btn:active { transform: translateY(1px); }\n    .btn.secondary {\n      background: #1f2448;\n      color: #d7e1ff;\n      border-color: #2a2f5c;\n    }\n    .btn.warning {\n      background: linear-gradient(180deg, #ff8c4a, #e07539);\n      border-color: #db6b2f;\n    }\n    .btn.danger {\n      background: linear-gradient(180deg, #ff6b6b, #e15b5b);\n      border-color: #cd4d4d;\n    }\n    .btn:disabled {\n      opacity: 0.5;\n      cursor: not-allowed;\n      filter: none;\n    }\n\n    .speed {\n      display: inline-flex;\n      align-items: center;\n      gap: 8px;\n      color: var(--muted);\n      font-size: 13px;\n      padding: 6px 10px;\n      background: #12162d;\n      border: 1px solid #222644;\n      border-radius: 10px;\n    }\n    .speed input[type=\"range\"] {\n      width: 180px;\n      accent-color: #689aff;\n    }\n\n    .info {\n      display: grid;\n      gap: 6px;\n      font-size: 13px;\n      color: #c8d3f5;\n    }\n    .info-row {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 10px 16px;\n      align-items: center;\n    }\n    .badge {\n      background: #1e2346;\n      border: 1px solid #2a3364;\n      border-radius: 999px;\n      padding: 6px 10px;\n      font-weight: 700;\n      font-size: 12px;\n      color: #cfe3ff;\n    }\n    .badge.ok { border-color: #2a6a44; background: #153123; color: #baf3ce; }\n    .badge.warn { border-color: #6b532a; background: #2d2414; color: #ffd39a; }\n\n    .stack {\n      display: grid;\n      gap: 6px;\n    }\n\n    .row-title {\n      font-size: 13px;\n      color: var(--muted);\n      padding-left: 4px;\n    }\n\n    .array {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 8px;\n      padding: 8px;\n      background: #12162d;\n      border: 1px dashed #2a2f5c;\n      border-radius: 12px;\n      min-height: 54px;\n    }\n\n    .item {\n      background: linear-gradient(180deg, var(--chip), var(--chip2));\n      border: 1px solid var(--chip-border);\n      color: #e6edff;\n      padding: 10px 12px;\n      border-radius: 12px;\n      font-weight: 700;\n      letter-spacing: 0.2px;\n      min-width: 42px;\n      text-align: center;\n      position: relative;\n      box-shadow: 0 6px 14px rgba(0,0,0,0.25);\n      transition: transform 0.15s ease, box-shadow 0.2s ease;\n    }\n    .item:hover { transform: translateY(-2px); box-shadow: 0 8px 18px rgba(0,0,0,0.35); }\n    .item .subtag {\n      position: absolute;\n      top: -8px;\n      right: -8px;\n      background: #0f132d;\n      color: #aab5de;\n      border: 1px solid #263168;\n      padding: 2px 6px;\n      font-size: 10px;\n      border-radius: 999px;\n    }\n    .item.phase-neg { border-color: #6b2d2d; }\n    .item.phase-pos { border-color: #2a5f2a; }\n\n    .buckets {\n      display: grid;\n      grid-template-columns: repeat(5,minmax(0,1fr));\n      gap: 10px;\n    }\n    @media (max-width: 800px) {\n      .buckets { grid-template-columns: repeat(2, minmax(0,1fr)); }\n    }\n    .bucket {\n      background: var(--bucket);\n      border: 1px solid #2a2f5c;\n      border-radius: 12px;\n      box-shadow: var(--shadow);\n      min-height: 100px;\n      display: grid;\n      grid-template-rows: auto 1fr;\n    }\n    .bucket-label {\n      padding: 8px 10px;\n      font-weight: 800;\n      color: #b1c6ff;\n      border-bottom: 1px solid #2a2f5c;\n      background: linear-gradient(180deg, #1b203f, #171c36);\n      border-top-left-radius: 12px;\n      border-top-right-radius: 12px;\n      letter-spacing: 0.5px;\n    }\n    .bucket-items {\n      padding: 10px;\n      display: flex;\n      flex-wrap: wrap;\n      gap: 8px;\n      align-content: flex-start;\n      min-height: 70px;\n    }\n\n    .footer {\n      font-size: 12px;\n      color: #9aa3b2;\n    }\n    .footer a { color: #9bc2ff; text-decoration: none; }\n    .footer strong { color: #cfe3ff; }\n\n    .legend {\n      display: inline-flex;\n      gap: 8px;\n      align-items: center;\n      flex-wrap: wrap;\n    }\n    .pill {\n      display: inline-flex;\n      align-items: center;\n      gap: 6px;\n      padding: 6px 10px;\n      background: #151a36;\n      border: 1px solid #293161;\n      color: #c7d3ff;\n      border-radius: 999px;\n      font-size: 12px;\n    }\n    .dot {\n      width: 10px; height: 10px; border-radius: 50%;\n      background: #3f7cff; border: 1px solid #2a4fb4;\n      box-shadow: 0 0 0 2px rgba(63,124,255,0.15);\n    }\n    .dot.pos { background: #2ecc71; border-color: #1d8b4a; box-shadow: 0 0 0 2px rgba(46,204,113,0.2); }\n    .dot.neg { background: #ff6b6b; border-color: #b84b4b; box-shadow: 0 0 0 2px rgba(255,107,107,0.2); }\n    .dot.digit { background: #ffd166; border-color: #b2892f; box-shadow: 0 0 0 2px rgba(255,209,102,0.2); }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Radix Sort Visualizer (LSD, Base 10)</h1>\n    <div class=\"sub\">Stable, non-comparative sorting by processing digits from least significant to most significant. Supports positives and negatives (negatives sorted by absolute value then reversed).</div>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"panel controls\">\n      <div class=\"controls-row\">\n        <input id=\"inputNumbers\" type=\"text\" placeholder=\"Enter integers separated by commas or spaces (e.g., 170, 45, 75, 90, 802, 24, 2, 66)\" />\n        <button id=\"btnRandom\" class=\"btn secondary\" title=\"Generate random numbers\">Randomize</button>\n        <button id=\"btnStart\" class=\"btn\" title=\"Start / Restart\">Start</button>\n        <button id=\"btnStep\" class=\"btn secondary\" title=\"Step one operation\">Step</button>\n        <button id=\"btnPause\" class=\"btn warning\" title=\"Pause / Resume\" disabled>Pause</button>\n        <button id=\"btnReset\" class=\"btn danger\" title=\"Reset\">Reset</button>\n        <span class=\"speed\">\n          Speed\n          <input id=\"speedRange\" type=\"range\" min=\"30\" max=\"1000\" value=\"350\" />\n        </span>\n      </div>\n      <div class=\"info\">\n        <div class=\"info-row\">\n          <span id=\"phaseBadge\" class=\"badge\">Phase: Ready</span>\n          <span id=\"stageBadge\" class=\"badge\">Stage: —</span>\n          <span id=\"digitBadge\" class=\"badge warn\">Digit (10^k): —</span>\n          <span id=\"passBadge\" class=\"badge\">Pass: —</span>\n          <span id=\"noteBadge\" class=\"badge\">Note: Stable</span>\n        </div>\n        <div class=\"info-row\">\n          <div class=\"legend\">\n            <span class=\"pill\"><span class=\"dot pos\"></span> Positive pass</span>\n            <span class=\"pill\"><span class=\"dot neg\"></span> Negative pass (abs values)</span>\n            <span class=\"pill\"><span class=\"dot digit\"></span> Current digit k (units=0, tens=1, ...)</span>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel stack\">\n      <div class=\"row-title\">Current working array</div>\n      <div id=\"arrayContainer\" class=\"array\" aria-live=\"polite\"></div>\n    </div>\n\n    <div class=\"panel stack\">\n      <div class=\"row-title\">Buckets (0 - 9) for current digit</div>\n      <div id=\"bucketsContainer\" class=\"buckets\"></div>\n    </div>\n\n    <div class=\"panel stack\">\n      <div class=\"row-title\">Final result</div>\n      <div id=\"finalContainer\" class=\"array\"></div>\n      <div class=\"footer\" style=\"margin-top: 8px;\">\n        LSD Radix Sort complexity: O(d * (n + b)), where d is number of digits, n is number of items, and b is the base (10 here). Stable: equal-digit items preserve relative order within each pass.\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Utility helpers\n    const $ = (sel) => document.querySelector(sel);\n    const $$ = (sel) => Array.from(document.querySelectorAll(sel));\n    const byId = (id) => document.getElementById(id);\n\n    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }\n    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n    function maxDigits(arr) {\n      let m = 0;\n      for (const v of arr) m = Math.max(m, Math.abs(v));\n      return Math.max(1, String(Math.floor(m)).length);\n    }\n    function getDigit(val, k) {\n      const e = Math.pow(10, k);\n      return Math.floor(Math.abs(val) / e) % 10;\n    }\n    function parseNumbersInput(text) {\n      if (!text) return [];\n      const parts = text.split(/[\\s,;]+/).filter(Boolean);\n      const nums = [];\n      for (const p of parts) {\n        const v = Number(p);\n        if (!Number.isFinite(v)) continue;\n        nums.push(Math.trunc(v));\n      }\n      return nums;\n    }\n    function numbersToString(arr) {\n      return arr.join(\", \");\n    }\n\n    // DOM creation for buckets\n    function createBuckets(container) {\n      container.innerHTML = \"\";\n      for (let b = 0; b <= 9; b++) {\n        const bucket = document.createElement(\"div\");\n        bucket.className = \"bucket\";\n        bucket.dataset.bucket = String(b);\n\n        const label = document.createElement(\"div\");\n        label.className = \"bucket-label\";\n        label.textContent = `Bucket ${b}`;\n\n        const items = document.createElement(\"div\");\n        items.className = \"bucket-items\";\n        items.id = `bucket-items-${b}`;\n\n        bucket.appendChild(label);\n        bucket.appendChild(items);\n        container.appendChild(bucket);\n      }\n    }\n\n    function createItemNode(item, phase) {\n      const node = document.createElement(\"div\");\n      node.className = \"item \" + (phase === \"negatives\" ? \"phase-neg\" : \"phase-pos\");\n      node.id = `item-${item.uid}`;\n      node.dataset.uid = String(item.uid);\n      node.textContent = String(item.show);\n      const sub = document.createElement(\"div\");\n      sub.className = \"subtag\";\n      sub.title = \"Original position (stability marker)\";\n      sub.textContent = `#${item.originIndex}`;\n      node.appendChild(sub);\n      return node;\n    }\n\n    function renderArray(container, items, phase) {\n      container.innerHTML = \"\";\n      for (const it of items) {\n        const node = createItemNode(it, phase);\n        container.appendChild(node);\n      }\n    }\n\n    function clearBucketsItems() {\n      for (let b = 0; b <= 9; b++) {\n        const bi = byId(`bucket-items-${b}`);\n        if (bi) bi.innerHTML = \"\";\n      }\n    }\n\n    // State management\n    const state = {\n      raw: [],\n      positives: [],\n      negatives: [],\n      sortedPositives: [],\n      sortedNegatives: [],\n\n      phase: \"ready\", // ready | positives | negatives | merge | done\n      stage: \"distribute\", // distribute | collect\n      expIndex: 0, // digit index\n      maxDigits: 0,\n      i: 0, // distribution pointer\n      collectBucket: 0,\n      currentArray: [], // array of items { uid, value(used for sorting), show(display original), originIndex }\n      newOrder: [],\n\n      uidCounter: 1,\n      timer: null,\n      running: false,\n      speed: 350\n    };\n\n    function setBadges() {\n      const phaseMap = {\n        ready: \"Phase: Ready\",\n        positives: \"Phase: Positives\",\n        negatives: \"Phase: Negatives (abs)\",\n        merge: \"Phase: Merge\",\n        done: \"Phase: Done\"\n      };\n      byId(\"phaseBadge\").textContent = phaseMap[state.phase] || \"Phase: —\";\n\n      const stageMap = {\n        distribute: \"Stage: Distribute into buckets\",\n        collect: \"Stage: Collect in order\"\n      };\n      byId(\"stageBadge\").textContent = state.phase === \"ready\" || state.phase === \"done\" ? \"Stage: —\" : (stageMap[state.stage] || \"Stage: —\");\n\n      const digitName = (k) => {\n        if (k === 0) return \"k=0 (units)\";\n        if (k === 1) return \"k=1 (tens)\";\n        if (k === 2) return \"k=2 (hundreds)\";\n        return `k=${k}`;\n      };\n\n      byId(\"digitBadge\").textContent = (state.phase === \"positives\" || state.phase === \"negatives\")\n        ? `Digit (10^k): ${digitName(state.expIndex)}`\n        : \"Digit (10^k): —\";\n\n      const pass = (state.phase === \"positives\" || state.phase === \"negatives\") ? `${state.expIndex + 1} / ${state.maxDigits}` : \"—\";\n      byId(\"passBadge\").textContent = `Pass: ${pass}`;\n    }\n\n    function resetVisualization() {\n      state.raw = [];\n      state.positives = [];\n      state.negatives = [];\n      state.sortedPositives = [];\n      state.sortedNegatives = [];\n      state.phase = \"ready\";\n      state.stage = \"distribute\";\n      state.expIndex = 0;\n      state.maxDigits = 0;\n      state.i = 0;\n      state.collectBucket = 0;\n      state.currentArray = [];\n      state.newOrder = [];\n      state.uidCounter = 1;\n      clearTimer();\n\n      byId(\"arrayContainer\").innerHTML = \"\";\n      byId(\"finalContainer\").innerHTML = \"\";\n      createBuckets(byId(\"bucketsContainer\"));\n      setBadges();\n\n      byId(\"btnPause\").disabled = true;\n      byId(\"btnPause\").textContent = \"Pause\";\n    }\n\n    function setupPhase(phase) {\n      state.phase = phase;\n      state.stage = \"distribute\";\n      state.expIndex = 0;\n      state.i = 0;\n      state.collectBucket = 0;\n      state.newOrder = [];\n      clearBucketsItems();\n\n      if (phase === \"positives\") {\n        state.maxDigits = maxDigits(state.positives);\n        state.currentArray = state.positives.map((v, idx) => ({\n          uid: state.uidCounter++,\n          value: v,          // used for digit calc\n          show: v,           // display original\n          originIndex: v.__originIndex ?? idx\n        }));\n        renderArray(byId(\"arrayContainer\"), state.currentArray, \"positives\");\n      } else if (phase === \"negatives\") {\n        // Sort by absolute values; display original negatives\n        state.maxDigits = maxDigits(state.negatives.map(v => Math.abs(v)));\n        state.currentArray = state.negatives.map((v, idx) => ({\n          uid: state.uidCounter++,\n          value: Math.abs(v),\n          show: v,\n          originIndex: v.__originIndex ?? idx\n        }));\n        renderArray(byId(\"arrayContainer\"), state.currentArray, \"negatives\");\n      }\n      setBadges();\n    }\n\n    function startFromInput(arr) {\n      resetVisualization();\n      state.raw = arr.slice();\n\n      // tag origin index for stability display\n      const withIdx = state.raw.map((v, i) => {\n        if (typeof v === \"object\") return v;\n        const val = Number(v);\n        val.__originIndex = i;\n        return val;\n      });\n\n      state.positives = [];\n      state.negatives = [];\n      withIdx.forEach((v, i) => {\n        if (v >= 0) state.positives.push(v);\n        else state.negatives.push(v);\n      });\n\n      // If nothing entered, seed with random\n      if (state.raw.length === 0) {\n        state.raw = generateRandomNumbers(12, 0, 999);\n        startFromInput(state.raw);\n        byId(\"inputNumbers\").value = numbersToString(state.raw);\n        return;\n      }\n\n      // Begin with positives if any, else negatives, else done\n      if (state.positives.length > 0) {\n        setupPhase(\"positives\");\n      } else if (state.negatives.length > 0) {\n        setupPhase(\"negatives\");\n      } else {\n        state.phase = \"done\";\n        setBadges();\n      }\n    }\n\n    function nextPhaseOrFinish() {\n      if (state.phase === \"positives\") {\n        // Save positive results\n        state.sortedPositives = state.currentArray.map(it => it.show);\n        if (state.negatives.length > 0) {\n          setupPhase(\"negatives\");\n          return;\n        }\n        // No negatives; finalize\n        finalizeMerge();\n      } else if (state.phase === \"negatives\") {\n        // Save negatives order (by abs ascending). For final ascending order, negatives must be reversed.\n        state.sortedNegatives = state.currentArray.map(it => it.show).reverse(); // reverse for ascending negatives\n        finalizeMerge();\n      }\n    }\n\n    function finalizeMerge() {\n      clearBucketsItems();\n      state.phase = \"merge\";\n      state.stage = \"distribute\";\n      setBadges();\n\n      const final = [...state.sortedNegatives, ...state.sortedPositives];\n      renderFinal(final);\n\n      state.phase = \"done\";\n      setBadges();\n      stopAuto();\n    }\n\n    function renderFinal(arr) {\n      const cont = byId(\"finalContainer\");\n      cont.innerHTML = \"\";\n      arr.forEach((v, idx) => {\n        const node = document.createElement(\"div\");\n        node.className = \"item\";\n        node.textContent = String(v);\n        const sub = document.createElement(\"div\");\n        sub.className = \"subtag\";\n        sub.textContent = String(idx + 1);\n        sub.title = \"Rank in sorted order\";\n        node.appendChild(sub);\n        cont.appendChild(node);\n      });\n    }\n\n    function placeOneToBucket() {\n      if (state.i >= state.currentArray.length) return false;\n      const item = state.currentArray[state.i];\n      const d = getDigit(item.value, state.expIndex);\n      const bi = byId(`bucket-items-${d}`);\n      // Move DOM node\n      let node = byId(`item-${item.uid}`);\n      if (!node) {\n        node = createItemNode(item, state.phase);\n      }\n      bi.appendChild(node);\n      state.i++;\n      return true;\n    }\n\n    function beginCollectPhase() {\n      state.stage = \"collect\";\n      state.collectBucket = 0;\n      state.newOrder = [];\n      setBadges();\n    }\n\n    function collectOneFromBuckets() {\n      while (state.collectBucket <= 9) {\n        const bi = byId(`bucket-items-${state.collectBucket}`);\n        const first = bi.querySelector(\".item\");\n        if (first) {\n          // Append to array container in order\n          const uid = Number(first.dataset.uid);\n          const item = state.currentArray.find(it => it.uid === uid);\n          if (item) {\n            state.newOrder.push(item);\n          }\n          byId(\"arrayContainer\").appendChild(first);\n          return true; // collected one\n        } else {\n          state.collectBucket++;\n        }\n      }\n      return false; // no more items\n    }\n\n    function finishCollectPhase() {\n      state.currentArray = state.newOrder.slice();\n      state.stage = \"distribute\";\n      state.i = 0;\n      state.collectBucket = 0;\n      state.newOrder = [];\n      clearBucketsItems();\n      state.expIndex++;\n      setBadges();\n\n      if (state.expIndex >= state.maxDigits) {\n        // Phase complete\n        nextPhaseOrFinish();\n      }\n    }\n\n    function stepOnce() {\n      if (!(state.phase === \"positives\" || state.phase === \"negatives\")) return false;\n\n      if (state.stage === \"distribute\") {\n        const moved = placeOneToBucket();\n        if (!moved) {\n          beginCollectPhase();\n          return true;\n        }\n        return true;\n      } else if (state.stage === \"collect\") {\n        const got = collectOneFromBuckets();\n        if (!got) {\n          finishCollectPhase();\n          return true;\n        }\n        return true;\n      }\n      return false;\n    }\n\n    // Auto-run with speed\n    function tick() {\n      const cont = stepOnce();\n      if (!cont || state.phase === \"done\") {\n        stopAuto();\n        return;\n      }\n      scheduleNext();\n    }\n\n    function scheduleNext() {\n      clearTimer();\n      state.timer = setTimeout(tick, clamp(state.speed, 20, 2000));\n    }\n\n    function startAuto() {\n      if (state.phase === \"ready\") {\n        const arr = parseNumbersInput(byId(\"inputNumbers\").value);\n        startFromInput(arr);\n      }\n      if (!(state.phase === \"positives\" || state.phase === \"negatives\")) return;\n      state.running = true;\n      byId(\"btnPause\").disabled = false;\n      scheduleNext();\n    }\n\n    function stopAuto() {\n      state.running = false;\n      clearTimer();\n      byId(\"btnPause\").textContent = \"Resume\";\n    }\n\n    function clearTimer() {\n      if (state.timer) clearTimeout(state.timer);\n      state.timer = null;\n    }\n\n    function pauseOrResume() {\n      if (state.phase === \"done\" || state.phase === \"ready\") return;\n      if (state.running) {\n        stopAuto();\n      } else {\n        state.running = true;\n        byId(\"btnPause\").textContent = \"Pause\";\n        scheduleNext();\n      }\n    }\n\n    // UI hookups\n    function generateRandomNumbers(count = 12, min = 0, max = 999) {\n      const arr = [];\n      for (let i = 0; i < count; i++) arr.push(randInt(min, max));\n      return arr;\n    }\n\n    function onRandomize() {\n      // Mix positives and negatives sometimes\n      const allowNeg = Math.random() < 0.45;\n      const count = randInt(8, 16);\n      const arr = [];\n      for (let i = 0; i < count; i++) {\n        let v = randInt(0, 999);\n        if (allowNeg && Math.random() < 0.4) v = -randInt(0, 999);\n        arr.push(v);\n      }\n      byId(\"inputNumbers\").value = numbersToString(arr);\n      resetVisualization();\n    }\n\n    function onStart() {\n      const arr = parseNumbersInput(byId(\"inputNumbers\").value);\n      startFromInput(arr);\n      startAuto();\n    }\n\n    function onStep() {\n      if (state.phase === \"ready\") {\n        const arr = parseNumbersInput(byId(\"inputNumbers\").value);\n        startFromInput(arr);\n      }\n      // One step\n      stepOnce();\n    }\n\n    function onReset() {\n      resetVisualization();\n      byId(\"arrayContainer\").innerHTML = \"\";\n      byId(\"finalContainer\").innerHTML = \"\";\n    }\n\n    function onSpeedChange(e) {\n      state.speed = Number(e.target.value);\n      if (state.running) {\n        scheduleNext();\n      }\n    }\n\n    // Initialize\n    function init() {\n      createBuckets(byId(\"bucketsContainer\"));\n      setBadges();\n\n      byId(\"btnRandom\").addEventListener(\"click\", onRandomize);\n      byId(\"btnStart\").addEventListener(\"click\", onStart);\n      byId(\"btnStep\").addEventListener(\"click\", onStep);\n      byId(\"btnPause\").addEventListener(\"click\", pauseOrResume);\n      byId(\"btnReset\").addEventListener(\"click\", onReset);\n      byId(\"speedRange\").addEventListener(\"input\", onSpeedChange);\n\n      // Seed example\n      const example = [170, 45, 75, 90, 802, 24, 2, 66];\n      byId(\"inputNumbers\").value = numbersToString(example);\n\n      // Keyboard shortcuts\n      window.addEventListener(\"keydown\", (e) => {\n        if (e.key === \" \") { e.preventDefault(); pauseOrResume(); }\n        if (e.key.toLowerCase() === \"s\") { e.preventDefault(); onStep(); }\n        if (e.key.toLowerCase() === \"r\") { e.preventDefault(); onRandomize(); }\n        if (e.key.toLowerCase() === \"g\") { e.preventDefault(); onStart(); }\n      });\n    }\n\n    init();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Radix Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "490f2490-a36c-11f0-bd3f-6187c8baa226",
    "timestamp": "2025-10-07T10:56:32.601Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Linear Search",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Linear Search — Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root {\n      --accent: #2563eb;\n      --accent-2: #10b981;\n      --warn: #ef4444;\n      --text: #111827;\n      --muted: #6b7280;\n      --bg: #f8fafc;\n      --card: #ffffff;\n      --border: #e5e7eb;\n      --current: #fde68a;\n      --checked: #e5e7eb;\n      --found: #bbf7d0;\n    }\n    * { box-sizing: border-box; }\n    body {\n      margin: 0; padding: 24px; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n      background: var(--bg); color: var(--text);\n    }\n    h1 { margin: 0 0 12px; font-size: 22px; }\n    p { margin: 8px 0; color: var(--muted); }\n    .card {\n      background: var(--card);\n      border: 1px solid var(--border);\n      border-radius: 12px;\n      padding: 16px;\n      margin-top: 16px;\n    }\n    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }\n    label { font-size: 14px; color: var(--text); }\n    input[type=\"text\"], input[type=\"number\"] {\n      width: 280px; max-width: 90vw;\n      padding: 10px 12px; border-radius: 8px; border: 1px solid var(--border);\n      outline: none;\n    }\n    input[type=\"text\"]:focus, input[type=\"number\"]:focus { border-color: var(--accent); }\n    .btn {\n      appearance: none; border: none; background: var(--accent); color: white; padding: 10px 14px; border-radius: 8px;\n      cursor: pointer; font-weight: 600; font-size: 14px;\n    }\n    .btn.secondary { background: #374151; }\n    .btn.ghost { background: transparent; color: var(--text); border: 1px solid var(--border); }\n    .btn[disabled] { opacity: 0.5; cursor: not-allowed; }\n    .array-visual {\n      display: flex; flex-wrap: wrap; gap: 8px; padding: 12px; border: 1px dashed var(--border); border-radius: 12px; background: #fafafa;\n      min-height: 64px;\n    }\n    .box {\n      min-width: 48px; text-align: center; padding: 12px 10px; border-radius: 10px; border: 2px solid #e5e7eb; background: white;\n      font-weight: 600; color: #111827; position: relative; transition: transform 0.15s ease, background 0.2s ease, border-color 0.2s ease;\n    }\n    .box .index {\n      position: absolute; top: -10px; left: 6px; color: var(--muted); font-size: 11px; background: #fff; padding: 0 4px; border-radius: 4px; border: 1px solid var(--border);\n    }\n    .box.current {\n      background: var(--current); border-color: #f59e0b; transform: translateY(-3px);\n    }\n    .box.checked { background: var(--checked); }\n    .box.found { background: var(--found); border-color: var(--accent-2); transform: translateY(-5px); }\n    .box.target {\n      outline: 2px dashed var(--accent); outline-offset: 2px;\n    }\n    .status {\n      display: grid; grid-template-columns: repeat(3, minmax(140px, 1fr)); gap: 12px; margin-top: 10px;\n    }\n    .stat {\n      background: #fff; border: 1px solid var(--border); border-radius: 10px; padding: 10px;\n    }\n    .stat .label { color: var(--muted); font-size: 12px; }\n    .stat .value { font-size: 18px; font-weight: 700; }\n    .log {\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n      background: #0b1020; color: #c8e1ff; border-radius: 10px; padding: 10px; height: 140px; overflow: auto; margin-top: 12px;\n    }\n    .legend { display: flex; gap: 16px; align-items: center; font-size: 13px; color: var(--muted); }\n    .swatch { width: 14px; height: 14px; border-radius: 3px; border: 1px solid var(--border); display: inline-block; vertical-align: middle; margin-right: 6px; }\n    .swatch.current { background: var(--current); border-color: #f59e0b; }\n    .swatch.checked { background: var(--checked); }\n    .swatch.found { background: var(--found); border-color: var(--accent-2); }\n    .swatch.target { background: #fff; border: 2px dashed var(--accent); }\n    .error { color: var(--warn); font-size: 13px; }\n    .controls { display: flex; gap: 8px; flex-wrap: wrap; }\n    .speed {\n      display: flex; align-items: center; gap: 8px;\n    }\n    .code {\n      background: #111827; color: #e5e7eb; border-radius: 10px; padding: 10px; font-family: ui-monospace, monospace; font-size: 13px; overflow: auto;\n    }\n  </style>\n</head>\n<body>\n  <h1>Linear Search</h1>\n  <p>Linear search scans a list from left to right, comparing each element to the target until it finds a match or reaches the end.</p>\n\n  <div class=\"card\">\n    <div class=\"row\" style=\"gap:16px; align-items:flex-end;\">\n      <div>\n        <label for=\"arrayInput\">Array (comma-separated numbers)</label><br />\n        <input id=\"arrayInput\" type=\"text\" value=\"4, 2, 7, 1, 9, 3, 7\" />\n      </div>\n      <div>\n        <label for=\"targetInput\">Target</label><br />\n        <input id=\"targetInput\" type=\"number\" value=\"7\" />\n      </div>\n      <div class=\"controls\">\n        <button id=\"randomBtn\" class=\"btn ghost\" title=\"Generate a random array\">Randomize</button>\n        <button id=\"resetBtn\" class=\"btn ghost\" title=\"Reset to initial state\">Reset</button>\n      </div>\n    </div>\n\n    <div class=\"row\" style=\"margin-top:12px;\">\n      <div class=\"controls\">\n        <button id=\"stepBtn\" class=\"btn\">Step</button>\n        <button id=\"autoBtn\" class=\"btn\">Search (Auto)</button>\n        <button id=\"pauseBtn\" class=\"btn secondary\" disabled>Pause</button>\n      </div>\n      <div class=\"speed\">\n        <label for=\"speedRange\">Speed</label>\n        <input id=\"speedRange\" type=\"range\" min=\"100\" max=\"2000\" step=\"100\" value=\"700\" />\n        <span id=\"speedLabel\" style=\"color:var(--muted); font-size:12px;\">700 ms/step</span>\n      </div>\n    </div>\n\n    <div id=\"error\" class=\"error\" role=\"alert\" aria-live=\"polite\" style=\"min-height:18px; margin-top:8px;\"></div>\n\n    <div class=\"legend\" style=\"margin-top:8px;\">\n      <span><span class=\"swatch current\"></span>Current check</span>\n      <span><span class=\"swatch checked\"></span>Checked (no match)</span>\n      <span><span class=\"swatch found\"></span>Found</span>\n      <span><span class=\"swatch target\"></span>Target value</span>\n    </div>\n\n    <div id=\"arrayVis\" class=\"array-visual\" aria-label=\"Array visualization\" style=\"margin-top:8px;\"></div>\n\n    <div class=\"status\">\n      <div class=\"stat\">\n        <div class=\"label\">Result index</div>\n        <div id=\"resultIndex\" class=\"value\">—</div>\n      </div>\n      <div class=\"stat\">\n        <div class=\"label\">Comparisons</div>\n        <div id=\"comparisons\" class=\"value\">0</div>\n      </div>\n      <div class=\"stat\">\n        <div class=\"label\">Complexity</div>\n        <div id=\"complexity\" class=\"value\">Best O(1), Worst O(n)</div>\n      </div>\n    </div>\n\n    <div id=\"log\" class=\"log\" aria-live=\"polite\"></div>\n  </div>\n\n  <div class=\"card\">\n    <div style=\"font-weight:700; margin-bottom:8px;\">Pseudocode</div>\n    <div class=\"code\"><pre style=\"margin:0;\">function linearSearch(arr, x):\n  for i from 0 to length(arr) - 1:\n    if arr[i] == x:\n      return i\n  return -1</pre></div>\n    <p style=\"margin-top:8px;\">\n      - Stops immediately when a match is found (best case).<br />\n      - If the item is not present, it checks every element (worst case).<br />\n      - Works on unsorted lists; simple but not optimal for large datasets.\n    </p>\n  </div>\n\n  <script>\n    // State\n    const state = {\n      arr: [],\n      target: null,\n      i: 0,\n      comparisons: 0,\n      foundIndex: null,\n      running: false,\n      timer: null,\n      lastHighlighted: null,\n    };\n\n    // Elements\n    const arrayInput = document.getElementById('arrayInput');\n    const targetInput = document.getElementById('targetInput');\n    const randomBtn = document.getElementById('randomBtn');\n    const resetBtn = document.getElementById('resetBtn');\n    const stepBtn = document.getElementById('stepBtn');\n    const autoBtn = document.getElementById('autoBtn');\n    const pauseBtn = document.getElementById('pauseBtn');\n    const speedRange = document.getElementById('speedRange');\n    const speedLabel = document.getElementById('speedLabel');\n    const arrayVis = document.getElementById('arrayVis');\n    const resultIndexEl = document.getElementById('resultIndex');\n    const comparisonsEl = document.getElementById('comparisons');\n    const complexityEl = document.getElementById('complexity');\n    const errorEl = document.getElementById('error');\n    const logEl = document.getElementById('log');\n\n    // Utility\n    function log(msg) {\n      const t = new Date().toLocaleTimeString();\n      logEl.textContent += `[${t}] ${msg}\\n`;\n      logEl.scrollTop = logEl.scrollHeight;\n    }\n\n    function showError(msg) {\n      errorEl.textContent = msg || '';\n    }\n\n    function parseArray(str) {\n      const parts = str.split(/[, ]+/).filter(Boolean);\n      if (parts.length === 0) return { ok: false, error: 'Please enter at least one number.' };\n      const nums = parts.map(p => Number(p));\n      const bad = nums.find(n => Number.isNaN(n));\n      if (bad !== undefined) return { ok: false, error: 'Array must contain only numbers (use commas or spaces).' };\n      return { ok: true, value: nums };\n    }\n\n    function renderArray(arr, target) {\n      arrayVis.innerHTML = '';\n      arr.forEach((val, idx) => {\n        const box = document.createElement('div');\n        box.className = 'box';\n        box.dataset.index = idx;\n        box.textContent = String(val);\n        const indexTag = document.createElement('div');\n        indexTag.className = 'index';\n        indexTag.textContent = idx;\n        box.appendChild(indexTag);\n        if (val === target) {\n          box.classList.add('target');\n        }\n        arrayVis.appendChild(box);\n      });\n    }\n\n    function clearHighlights() {\n      Array.from(arrayVis.children).forEach(box => {\n        box.classList.remove('current', 'checked', 'found');\n      });\n    }\n\n    function setUIRunning(running) {\n      state.running = running;\n      autoBtn.disabled = running;\n      stepBtn.disabled = running;\n      pauseBtn.disabled = !running;\n      arrayInput.disabled = running;\n      targetInput.disabled = running;\n      randomBtn.disabled = running;\n    }\n\n    function updateStats() {\n      comparisonsEl.textContent = state.comparisons;\n      resultIndexEl.textContent = state.foundIndex === null ? '—' : state.foundIndex;\n    }\n\n    function resetSearch(keepInputs = true) {\n      if (state.timer) clearInterval(state.timer);\n      state.timer = null;\n      setUIRunning(false);\n      state.i = 0;\n      state.comparisons = 0;\n      state.foundIndex = null;\n      state.lastHighlighted = null;\n      updateStats();\n      showError('');\n      log('Reset.');\n      // Re-render based on current inputs if keepInputs\n      const arrParse = parseArray(arrayInput.value);\n      if (!arrParse.ok) {\n        showError(arrParse.error);\n        arrayVis.innerHTML = '';\n        return;\n      }\n      const targetVal = Number(targetInput.value);\n      if (Number.isNaN(targetVal)) {\n        showError('Target must be a number.');\n        arrayVis.innerHTML = '';\n        return;\n      }\n      state.arr = arrParse.value;\n      state.target = targetVal;\n      renderArray(state.arr, state.target);\n    }\n\n    function initFromInputs() {\n      const arrParse = parseArray(arrayInput.value);\n      if (!arrParse.ok) {\n        showError(arrParse.error);\n        return false;\n      }\n      const targetVal = Number(targetInput.value);\n      if (Number.isNaN(targetVal)) {\n        showError('Target must be a number.');\n        return false;\n      }\n      showError('');\n      state.arr = arrParse.value;\n      state.target = targetVal;\n      state.i = 0;\n      state.comparisons = 0;\n      state.foundIndex = null;\n      state.lastHighlighted = null;\n      updateStats();\n      renderArray(state.arr, state.target);\n      log(`Initialized search for target ${state.target} in [${state.arr.join(', ')}].`);\n      return true;\n    }\n\n    function highlightIndex(i, status) {\n      const boxes = Array.from(arrayVis.children);\n      boxes.forEach(b => b.classList.remove('current'));\n      if (state.lastHighlighted !== null && state.lastHighlighted < boxes.length) {\n        const prev = boxes[state.lastHighlighted];\n        if (prev && prev.classList.contains('current')) prev.classList.remove('current');\n        // If it wasn't found, mark it as checked\n        if (status !== 'found') prev && prev.classList.add('checked');\n      }\n      if (i >= 0 && i < boxes.length) {\n        const box = boxes[i];\n        box.classList.add('current');\n        if (status === 'found') {\n          box.classList.add('found');\n        }\n      }\n      state.lastHighlighted = i;\n    }\n\n    function stepOnce() {\n      const n = state.arr.length;\n      if (state.foundIndex !== null || state.i >= n) {\n        // Already done\n        if (state.running) {\n          clearInterval(state.timer);\n          state.timer = null;\n          setUIRunning(false);\n          log('Search complete.');\n        }\n        return;\n      }\n\n      highlightIndex(state.i, 'checking');\n      const val = state.arr[state.i];\n      state.comparisons++;\n      updateStats();\n\n      log(`Compare arr[${state.i}] = ${val} with target ${state.target} ... ${val === state.target ? 'match!' : 'no match'}`);\n\n      if (val === state.target) {\n        state.foundIndex = state.i;\n        highlightIndex(state.i, 'found');\n        updateStats();\n        log(`Found at index ${state.i}. Comparisons: ${state.comparisons}.`);\n        if (state.running) {\n          clearInterval(state.timer);\n          state.timer = null;\n          setUIRunning(false);\n        }\n        return;\n      } else {\n        // Move to next index\n        state.i++;\n        if (state.i >= n) {\n          log(`Target not found. Comparisons: ${state.comparisons}.`);\n          resultIndexEl.textContent = -1;\n          if (state.running) {\n            clearInterval(state.timer);\n            state.timer = null;\n            setUIRunning(false);\n          }\n          return;\n        }\n      }\n    }\n\n    // Events\n    stepBtn.addEventListener('click', () => {\n      if (!state.arr.length || state.foundIndex !== null || state.i === 0) {\n        // Initialize if needed\n        if (!initFromInputs()) return;\n      }\n      stepOnce();\n    });\n\n    autoBtn.addEventListener('click', () => {\n      if (!initFromInputs()) return;\n      const interval = Number(speedRange.value);\n      setUIRunning(true);\n      state.timer = setInterval(stepOnce, interval);\n    });\n\n    pauseBtn.addEventListener('click', () => {\n      if (state.running) {\n        clearInterval(state.timer);\n        state.timer = null;\n        setUIRunning(false);\n        log('Paused.');\n      }\n    });\n\n    resetBtn.addEventListener('click', () => resetSearch(true));\n\n    randomBtn.addEventListener('click', () => {\n      const len = Math.floor(Math.random() * 8) + 7; // 7..14\n      const arr = Array.from({ length: len }, () => Math.floor(Math.random() * 99));\n      const target = arr[Math.floor(Math.random() * arr.length)];\n      arrayInput.value = arr.join(', ');\n      targetInput.value = target;\n      resetSearch(true);\n      log(`Randomized array and target (target=${target}).`);\n    });\n\n    arrayInput.addEventListener('input', () => {\n      // Lightweight validation feedback\n      const res = parseArray(arrayInput.value);\n      showError(res.ok ? '' : res.error);\n    });\n\n    targetInput.addEventListener('input', () => {\n      const t = Number(targetInput.value);\n      showError(Number.isNaN(t) ? 'Target must be a number.' : '');\n    });\n\n    speedRange.addEventListener('input', () => {\n      speedLabel.textContent = `${speedRange.value} ms/step`;\n      if (state.running && state.timer) {\n        clearInterval(state.timer);\n        state.timer = setInterval(stepOnce, Number(speedRange.value));\n      }\n    });\n\n    // Initialize on load\n    resetSearch(true);\n    log('Ready. Enter an array and target, then Step or Search (Auto).');\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Linear Search"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "68ef8b10-a36c-11f0-b396-1b943c1d97da",
    "timestamp": "2025-10-07T10:57:26.082Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Binary Search",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Binary Search Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f172a;\n      --panel: #111827;\n      --text: #e5e7eb;\n      --muted: #94a3b8;\n      --accent: #60a5fa;\n      --accent2: #22c55e;\n      --warn: #f59e0b;\n      --danger: #ef4444;\n      --range: #1f2937;\n      --out: #0b1020;\n    }\n    * { box-sizing: border-box; }\n    body {\n      margin: 0;\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, \"Helvetica Neue\", Arial;\n      background: linear-gradient(180deg, #0b1225, var(--bg));\n      color: var(--text);\n    }\n    header {\n      padding: 20px 16px;\n      text-align: center;\n      border-bottom: 1px solid #1f2937;\n      background: #0b1225ad;\n      position: sticky;\n      top: 0;\n      backdrop-filter: blur(6px);\n    }\n    header h1 {\n      margin: 0;\n      font-size: 24px;\n      letter-spacing: 0.5px;\n    }\n    header p {\n      margin: 6px 0 0;\n      color: var(--muted);\n      font-size: 14px;\n    }\n    .container {\n      max-width: 1000px;\n      margin: 0 auto;\n      padding: 20px 16px 40px;\n    }\n    .card {\n      background: var(--panel);\n      border: 1px solid #1f2937;\n      border-radius: 12px;\n      padding: 16px;\n      margin-bottom: 16px;\n      box-shadow: 0 10px 20px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.03);\n    }\n    .row {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 12px;\n      align-items: center;\n    }\n    .row .field {\n      flex: 1 1 220px;\n      min-width: 200px;\n    }\n    label {\n      display: block;\n      font-size: 12px;\n      color: var(--muted);\n      margin-bottom: 6px;\n      letter-spacing: 0.2px;\n    }\n    input[type=\"text\"], input[type=\"number\"] {\n      width: 100%;\n      padding: 10px 12px;\n      border-radius: 8px;\n      border: 1px solid #334155;\n      background: #0b1020;\n      color: var(--text);\n      outline: none;\n      transition: border-color 0.15s ease;\n    }\n    input[type=\"text\"]:focus, input[type=\"number\"]:focus {\n      border-color: var(--accent);\n    }\n    .options {\n      display: flex;\n      gap: 14px;\n      align-items: center;\n      flex-wrap: wrap;\n      margin-top: 6px;\n    }\n    .checkbox {\n      display: inline-flex;\n      align-items: center;\n      gap: 8px;\n      color: var(--muted);\n      font-size: 13px;\n      cursor: pointer;\n    }\n    .controls {\n      display: flex;\n      gap: 8px;\n      flex-wrap: wrap;\n      margin-top: 10px;\n    }\n    button {\n      border: 1px solid #334155;\n      background: #0b1020;\n      color: var(--text);\n      padding: 8px 12px;\n      border-radius: 10px;\n      cursor: pointer;\n      transition: transform 0.05s ease, border-color 0.15s ease, background 0.15s ease;\n      user-select: none;\n    }\n    button:hover { border-color: var(--accent); }\n    button:active { transform: translateY(1px); }\n    button.primary {\n      background: linear-gradient(180deg, #1e3a8a, #0b2d63);\n      border-color: #1d4ed8;\n    }\n    button.success {\n      background: linear-gradient(180deg, #166534, #124c2b);\n      border-color: #16a34a;\n    }\n    button.warn {\n      background: linear-gradient(180deg, #92400e, #6b2f0a);\n      border-color: #f59e0b;\n    }\n    button.danger {\n      background: linear-gradient(180deg, #7f1d1d, #5b1212);\n      border-color: #ef4444;\n    }\n    button:disabled {\n      opacity: 0.5;\n      cursor: not-allowed;\n    }\n    .speed {\n      display: inline-flex;\n      align-items: center;\n      gap: 8px;\n      color: var(--muted);\n      font-size: 12px;\n      margin-left: auto;\n    }\n    input[type=\"range\"] {\n      width: 180px;\n    }\n\n    /* Visualizer */\n    .array-wrap {\n      overflow-x: auto;\n      padding-bottom: 10px;\n    }\n    .array {\n      display: grid;\n      grid-auto-flow: column;\n      grid-auto-columns: minmax(56px, 1fr);\n      gap: 10px;\n      align-items: end;\n      margin-top: 8px;\n      padding: 12px;\n      border-radius: 14px;\n      background: linear-gradient(180deg, #0b1020, #0d1224);\n      border: 1px solid #1f2937;\n    }\n    .cell {\n      position: relative;\n      border-radius: 10px;\n      padding: 10px 8px 18px;\n      text-align: center;\n      color: var(--text);\n      background: var(--range);\n      border: 2px solid transparent;\n      transition: background 0.15s ease, transform 0.15s ease, border-color 0.1s ease, opacity 0.15s ease;\n      min-height: 58px;\n    }\n    .cell .val {\n      font-weight: 600;\n      font-size: 16px;\n    }\n    .cell .idx {\n      position: absolute;\n      bottom: 4px;\n      left: 0;\n      right: 0;\n      font-size: 11px;\n      color: var(--muted);\n    }\n    .cell.out {\n      background: var(--out);\n      opacity: 0.5;\n    }\n    .cell.low::before, .cell.high::before {\n      content: attr(data-flag);\n      position: absolute;\n      top: -10px;\n      left: 50%;\n      transform: translateX(-50%);\n      font-size: 10px;\n      color: var(--accent);\n      background: #0b1020;\n      border: 1px solid #1f2937;\n      padding: 2px 6px;\n      border-radius: 10px;\n    }\n    .cell.low { border-color: #1d4ed8aa; }\n    .cell.high { border-color: #1d4ed8aa; }\n    .cell.mid {\n      border-color: #22c55e;\n      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.35);\n      transform: translateY(-2px);\n    }\n    .cell.found {\n      background: #064e3b;\n      border-color: var(--accent2);\n      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.6);\n      transform: translateY(-4px) scale(1.03);\n    }\n    .legend {\n      display: flex;\n      gap: 16px;\n      flex-wrap: wrap;\n      margin-top: 10px;\n      color: var(--muted);\n      font-size: 12px;\n    }\n    .legend .dot {\n      width: 10px; height: 10px; border-radius: 50%;\n      display: inline-block; margin-right: 6px; vertical-align: middle;\n    }\n    .dot-range { background: #1f2937; }\n    .dot-out { background: #0b1020; }\n    .dot-mid { background: #22c55e; }\n    .dot-found { background: #16a34a; }\n\n    /* Status and logs */\n    .status {\n      display: grid;\n      grid-template-columns: repeat(5, 1fr);\n      gap: 10px;\n      margin-top: 12px;\n    }\n    .status .item {\n      background: #0b1020;\n      border: 1px solid #1f2937;\n      border-radius: 10px;\n      padding: 10px;\n      min-height: 56px;\n    }\n    .status .item .label {\n      font-size: 11px;\n      color: var(--muted);\n    }\n    .status .item .value {\n      margin-top: 6px;\n      font-size: 16px;\n      font-weight: 600;\n    }\n    .log {\n      max-height: 220px;\n      overflow: auto;\n      background: #0b1020;\n      border: 1px solid #1f2937;\n      border-radius: 10px;\n      padding: 8px 10px;\n      font-size: 13px;\n    }\n    .log p {\n      margin: 6px 0;\n      color: #cbd5e1;\n    }\n    .log .ok { color: #86efac; }\n    .log .warn { color: #fbbf24; }\n    .log .bad { color: #fca5a5; }\n\n    .footer {\n      color: var(--muted);\n      font-size: 12px;\n      margin-top: 8px;\n    }\n    .code {\n      background: #0b1020;\n      border: 1px solid #1f2937;\n      border-radius: 10px;\n      padding: 10px;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n      font-size: 12px;\n      overflow: auto;\n      max-height: 240px;\n    }\n    .inline-hint {\n      color: var(--muted);\n      font-size: 12px;\n      margin-left: 6px;\n    }\n    .small {\n      font-size: 12px;\n      color: var(--muted);\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Binary Search Visualizer</h1>\n    <p>Step through the classic O(log n) search on a sorted array. Enter numbers and a target, then watch how low, high, and mid change.</p>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"card\">\n      <div class=\"row\">\n        <div class=\"field\" style=\"flex: 2 1 420px;\">\n          <label>Array (comma or space separated numbers)</label>\n          <input id=\"arrayInput\" type=\"text\" placeholder=\"Example: 1, 4, 7, 9, 12, 20\" />\n          <div class=\"options\">\n            <label class=\"checkbox\"><input id=\"sortChk\" type=\"checkbox\" checked /> Sort ascending automatically</label>\n            <label class=\"checkbox\"><input id=\"uniqueChk\" type=\"checkbox\" /> Enforce unique values</label>\n            <span class=\"inline-hint\">Binary search requires a sorted array.</span>\n          </div>\n        </div>\n        <div class=\"field\">\n          <label>Target</label>\n          <input id=\"targetInput\" type=\"number\" placeholder=\"Enter a number (e.g., 12)\" />\n        </div>\n      </div>\n\n      <div class=\"controls\">\n        <button id=\"randomBtn\" class=\"warn\">Randomize</button>\n        <button id=\"buildBtn\" class=\"primary\">Build Array</button>\n        <button id=\"startBtn\" class=\"success\">Start</button>\n        <button id=\"stepBtn\">Step</button>\n        <button id=\"pauseBtn\">Pause</button>\n        <button id=\"resetBtn\" class=\"danger\">Reset</button>\n        <span class=\"speed\">\n          Speed\n          <input id=\"speedRange\" type=\"range\" min=\"100\" max=\"1500\" step=\"50\" value=\"600\" />\n        </span>\n      </div>\n    </div>\n\n    <div class=\"card\">\n      <div class=\"array-wrap\">\n        <div id=\"arrayView\" class=\"array\" aria-label=\"Array visualization\"></div>\n      </div>\n\n      <div class=\"legend\">\n        <div><span class=\"dot dot-range\"></span> Active search range</div>\n        <div><span class=\"dot dot-out\"></span> Discarded</div>\n        <div><span class=\"dot dot-mid\" style=\"box-shadow: 0 0 0 2px rgba(34,197,94,.5)\"></span> Mid</div>\n        <div><span class=\"dot dot-found\"></span> Found</div>\n      </div>\n\n      <div class=\"status\">\n        <div class=\"item\"><div class=\"label\">low index</div><div id=\"lowVal\" class=\"value\">-</div></div>\n        <div class=\"item\"><div class=\"label\">high index</div><div id=\"highVal\" class=\"value\">-</div></div>\n        <div class=\"item\"><div class=\"label\">mid index</div><div id=\"midVal\" class=\"value\">-</div></div>\n        <div class=\"item\"><div class=\"label\">mid value</div><div id=\"midValue\" class=\"value\">-</div></div>\n        <div class=\"item\"><div class=\"label\">steps</div><div id=\"stepsVal\" class=\"value\">0</div></div>\n      </div>\n    </div>\n\n    <div class=\"card\">\n      <div class=\"row\" style=\"align-items:flex-start;\">\n        <div class=\"field\" style=\"flex: 2 1 520px;\">\n          <label>Search Log</label>\n          <div id=\"logView\" class=\"log\" aria-live=\"polite\"></div>\n        </div>\n        <div class=\"field\" style=\"flex: 1 1 320px;\">\n          <label>Binary Search (JavaScript)</label>\n          <pre class=\"code\">// Iterative binary search (ascending array)\nfunction binarySearch(arr, target) {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    // Safe mid calculation\n    const mid = low + Math.floor((high - low) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) low = mid + 1;\n    else high = mid - 1;\n  }\n  return -1;\n}\n\n// Complexity\n// Time: O(log n)\n// Space: O(1)</pre>\n          <div class=\"footer\">Tip: Binary search halves the range each step. If the array isn't sorted, the result is undefined.</div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"small\">Keyboard: Enter to Build, Space to Start/Pause, Right Arrow to Step.</div>\n  </div>\n\n  <script>\n    (function(){\n      const el = id => document.getElementById(id);\n\n      const state = {\n        arr: [],\n        target: null,\n        low: null,\n        high: null,\n        mid: null,\n        steps: 0,\n        running: false,\n        timer: null,\n        speed: 600,\n        foundIndex: -1,\n        built: false\n      };\n\n      const arrayInput = el('arrayInput');\n      const targetInput = el('targetInput');\n      const sortChk = el('sortChk');\n      const uniqueChk = el('uniqueChk');\n\n      const arrayView = el('arrayView');\n      const logView = el('logView');\n\n      const lowVal = el('lowVal');\n      const highVal = el('highVal');\n      const midVal = el('midVal');\n      const midValue = el('midValue');\n      const stepsVal = el('stepsVal');\n\n      const randomBtn = el('randomBtn');\n      const buildBtn = el('buildBtn');\n      const startBtn = el('startBtn');\n      const stepBtn = el('stepBtn');\n      const pauseBtn = el('pauseBtn');\n      const resetBtn = el('resetBtn');\n      const speedRange = el('speedRange');\n\n      // Utility functions\n      function parseArrayInput(text) {\n        if (!text) return [];\n        const parts = text.split(/[,\\s]+/).filter(Boolean);\n        const nums = [];\n        for (const p of parts) {\n          const n = Number(p);\n          if (!Number.isFinite(n)) continue;\n          nums.push(n);\n        }\n        return nums;\n      }\n\n      function uniqueSorted(arr) {\n        const set = new Set(arr);\n        return Array.from(set).sort((a,b)=>a-b);\n      }\n\n      function ensureSorted(arr) {\n        return arr.slice().sort((a,b)=>a-b);\n      }\n\n      function renderArray() {\n        arrayView.innerHTML = '';\n        if (!state.arr.length) {\n          const emptyMsg = document.createElement('div');\n          emptyMsg.style.color = '#94a3b8';\n          emptyMsg.style.padding = '12px';\n          emptyMsg.textContent = 'No array built yet. Enter numbers above and press Build Array or Randomize.';\n          arrayView.appendChild(emptyMsg);\n          return;\n        }\n        state.arr.forEach((val, idx) => {\n          const cell = document.createElement('div');\n          cell.className = 'cell';\n          cell.dataset.index = String(idx);\n          cell.innerHTML = `\n            <div class=\"val\">${val}</div>\n            <div class=\"idx\">index ${idx}</div>\n          `;\n          arrayView.appendChild(cell);\n        });\n        updateRangeHighlights();\n      }\n\n      function updateRangeHighlights() {\n        const cells = [...arrayView.children].filter(c => c.classList.contains('cell'));\n        cells.forEach((cell, idx) => {\n          cell.classList.remove('out', 'low', 'high', 'mid', 'found');\n          cell.removeAttribute('data-flag');\n          // Out of range\n          if (state.low == null || state.high == null || idx < state.low || idx > state.high) {\n            cell.classList.add('out');\n          }\n          // low/high flags inside range\n          if (state.low != null && idx === state.low) {\n            cell.classList.add('low');\n            cell.setAttribute('data-flag', 'low');\n          }\n          if (state.high != null && idx === state.high) {\n            cell.classList.add('high');\n            cell.setAttribute('data-flag', 'high');\n          }\n          if (state.mid != null && idx === state.mid) {\n            cell.classList.add('mid');\n          }\n          if (state.foundIndex !== -1 && idx === state.foundIndex) {\n            cell.classList.add('found');\n          }\n        });\n\n        lowVal.textContent = state.low == null ? '-' : String(state.low);\n        highVal.textContent = state.high == null ? '-' : String(state.high);\n        midVal.textContent = state.mid == null ? '-' : String(state.mid);\n        midValue.textContent = (state.mid == null || state.mid < 0 || state.mid >= state.arr.length) ? '-' : String(state.arr[state.mid]);\n        stepsVal.textContent = String(state.steps);\n      }\n\n      function log(msg, cls) {\n        const p = document.createElement('p');\n        if (cls) p.classList.add(cls);\n        p.textContent = msg;\n        logView.appendChild(p);\n        logView.scrollTop = logView.scrollHeight;\n      }\n\n      // Binary search step\n      function nextStep() {\n        if (!state.arr.length || state.target == null) {\n          log('Provide an array and a target first.', 'bad');\n          return;\n        }\n        if (state.foundIndex !== -1) {\n          log(`Search already finished: found ${state.target} at index ${state.foundIndex}.`, 'ok');\n          stopRunning();\n          return;\n        }\n        if (state.low > state.high) {\n          log(`Stopped: low (${state.low}) > high (${state.high}). Target ${state.target} not found.`, 'bad');\n          stopRunning();\n          return;\n        }\n\n        state.mid = state.low + Math.floor((state.high - state.low) / 2);\n        const midVal = state.arr[state.mid];\n        state.steps += 1;\n        updateRangeHighlights();\n\n        if (midVal === state.target) {\n          log(`Step ${state.steps}: mid=${state.mid} value=${midVal} → FOUND!`, 'ok');\n          state.foundIndex = state.mid;\n          updateRangeHighlights();\n          stopRunning();\n          return;\n        }\n\n        if (midVal < state.target) {\n          log(`Step ${state.steps}: mid=${state.mid} value=${midVal} < target=${state.target} → discard left half (low=mid+1).`, 'warn');\n          state.low = state.mid + 1;\n        } else {\n          log(`Step ${state.steps}: mid=${state.mid} value=${midVal} > target=${state.target} → discard right half (high=mid-1).`, 'warn');\n          state.high = state.mid - 1;\n        }\n\n        updateRangeHighlights();\n\n        if (state.low > state.high) {\n          log(`Now low (${state.low}) > high (${state.high}). Target ${state.target} not found.`, 'bad');\n          stopRunning();\n        }\n      }\n\n      // Controls\n      function startRunning() {\n        if (state.running) return;\n        if (!state.arr.length) {\n          log('Build an array before starting.', 'bad');\n          return;\n        }\n        if (state.target == null || !Number.isFinite(state.target)) {\n          log('Enter a valid numeric target.', 'bad');\n          return;\n        }\n        state.running = true;\n        updateButtons();\n        state.timer = setInterval(() => {\n          nextStep();\n          if (state.foundIndex !== -1 || state.low > state.high) {\n            stopRunning();\n          }\n        }, state.speed);\n      }\n\n      function stopRunning() {\n        state.running = false;\n        if (state.timer) {\n          clearInterval(state.timer);\n          state.timer = null;\n        }\n        updateButtons();\n      }\n\n      function resetAll(hard=false) {\n        stopRunning();\n        state.low = null;\n        state.high = null;\n        state.mid = null;\n        state.steps = 0;\n        state.foundIndex = -1;\n        if (hard) {\n          state.arr = [];\n          state.target = null;\n          arrayInput.value = '';\n          targetInput.value = '';\n          state.built = false;\n        }\n        renderArray();\n        logView.innerHTML = '';\n        updateButtons();\n      }\n\n      function buildFromInputs() {\n        const nums = parseArrayInput(arrayInput.value);\n        if (!nums.length) {\n          log('Please enter at least one valid number.', 'bad');\n          return;\n        }\n        let arr = nums.slice();\n        if (uniqueChk.checked) arr = uniqueSorted(arr);\n        if (sortChk.checked) arr = ensureSorted(arr);\n\n        // Initialize search bounds\n        state.arr = arr;\n        state.low = 0;\n        state.high = arr.length - 1;\n        state.mid = null;\n        state.steps = 0;\n        state.foundIndex = -1;\n        state.built = true;\n        renderArray();\n\n        // Parse target\n        const tgt = Number(targetInput.value);\n        state.target = Number.isFinite(tgt) ? tgt : null;\n\n        logView.innerHTML = '';\n        log(`Array built: [${state.arr.join(', ')}]`, 'ok');\n        if (state.target != null) {\n          log(`Target set to ${state.target}. Press Start or Step.`, 'ok');\n        } else {\n          log('No target yet. Enter a target number and press Start or Step.', 'warn');\n        }\n        updateButtons();\n      }\n\n      function randomize() {\n        stopRunning();\n        const len = Math.floor(Math.random() * 9) + 7; // 7..15\n        const base = Math.floor(Math.random() * 20);\n        const stepMin = 1;\n        const stepMax = 12;\n        // Build strictly increasing sequence\n        const arr = [];\n        let curr = base;\n        for (let i = 0; i < len; i++) {\n          curr += Math.floor(Math.random() * (stepMax - stepMin + 1)) + stepMin;\n          arr.push(curr);\n        }\n        arrayInput.value = arr.join(', ');\n        // Choose a target that is sometimes in array and sometimes not\n        const chooseExisting = Math.random() < 0.7;\n        const target = chooseExisting ? arr[Math.floor(Math.random() * arr.length)]\n                                      : arr[0] - 1 + Math.floor(Math.random()*20);\n        targetInput.value = target;\n        sortChk.checked = true;\n        uniqueChk.checked = true;\n\n        buildFromInputs();\n      }\n\n      function updateButtons() {\n        startBtn.disabled = !state.built || state.running || state.foundIndex !== -1 || (state.low != null && state.low > state.high);\n        stepBtn.disabled  = !state.built || state.running || state.foundIndex !== -1 || (state.low != null && state.low > state.high);\n        pauseBtn.disabled = !state.running;\n      }\n\n      // Event bindings\n      randomBtn.addEventListener('click', randomize);\n      buildBtn.addEventListener('click', buildFromInputs);\n\n      startBtn.addEventListener('click', startRunning);\n      stepBtn.addEventListener('click', nextStep);\n      pauseBtn.addEventListener('click', stopRunning);\n      resetBtn.addEventListener('click', () => resetAll(true));\n\n      speedRange.addEventListener('input', () => {\n        state.speed = Number(speedRange.value);\n        if (state.running) {\n          stopRunning();\n          startRunning();\n        }\n      });\n\n      arrayInput.addEventListener('input', () => { state.built = false; updateButtons(); });\n      targetInput.addEventListener('input', () => {\n        const t = Number(targetInput.value);\n        state.target = Number.isFinite(t) ? t : null;\n      });\n\n      // Keyboard shortcuts\n      document.addEventListener('keydown', (e) => {\n        const tag = e.target.tagName.toLowerCase();\n        const typing = tag === 'input' || tag === 'textarea';\n        if (e.key === 'Enter' && !typing) {\n          e.preventDefault();\n          buildFromInputs();\n        } else if (e.key === ' ' && !typing) {\n          e.preventDefault();\n          if (state.running) stopRunning(); else startRunning();\n        } else if (e.key === 'ArrowRight' && !typing) {\n          e.preventDefault();\n          nextStep();\n        }\n      });\n\n      // Initialize with a demo array\n      function initDemo() {\n        const demo = [2, 5, 7, 11, 14, 18, 21, 24, 30, 33, 39];\n        arrayInput.value = demo.join(', ');\n        targetInput.value = 24;\n        sortChk.checked = true;\n        uniqueChk.checked = true;\n        buildFromInputs();\n      }\n      initDemo();\n    })();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Binary Search"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "a79ac960-a36c-11f0-8d16-7d0fa88cbb7b",
    "timestamp": "2025-10-07T10:59:11.222Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Depth-First Search (DFS)",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<title>Depth-First Search (DFS) Visualizer</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --text: #e5e7eb;\n    --muted: #9ca3af;\n    --accent: #3b82f6;\n    --accent2: #06b6d4;\n    --success: #10b981;\n    --warn: #f59e0b;\n    --danger: #ef4444;\n  }\n\n  body {\n    margin: 0;\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n    background: linear-gradient(135deg, #0b1229 0%, #0f172a 40%, #101827 100%);\n    color: var(--text);\n  }\n\n  header {\n    padding: 18px 24px;\n    border-bottom: 1px solid rgba(255,255,255,0.06);\n    display: flex;\n    align-items: center;\n    gap: 14px;\n  }\n\n  header h1 {\n    font-size: 18px;\n    margin: 0;\n    letter-spacing: 0.3px;\n    font-weight: 600;\n  }\n\n  header .tag {\n    border: 1px solid rgba(255,255,255,0.12);\n    border-radius: 999px;\n    padding: 2px 10px;\n    font-size: 12px;\n    color: var(--muted);\n  }\n\n  .container {\n    display: grid;\n    grid-template-columns: 1.25fr 0.85fr;\n    gap: 12px;\n    padding: 12px;\n    min-height: calc(100vh - 64px);\n  }\n\n  .card {\n    background: linear-gradient(180deg, rgba(17,24,39,0.72), rgba(17,24,39,0.62));\n    border: 1px solid rgba(255,255,255,0.06);\n    border-radius: 12px;\n    overflow: hidden;\n  }\n\n  .card header {\n    background: rgba(255,255,255,0.04);\n    border-bottom: 1px solid rgba(255,255,255,0.06);\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: 12px 16px;\n  }\n\n  .card header h2 {\n    margin: 0;\n    font-size: 15px;\n    font-weight: 600;\n    color: var(--text);\n  }\n\n  .controls {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 8px;\n    padding: 12px;\n    border-bottom: 1px solid rgba(255,255,255,0.06);\n  }\n\n  .control-group {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    background: rgba(255,255,255,0.04);\n    border: 1px solid rgba(255,255,255,0.06);\n    padding: 8px;\n    border-radius: 8px;\n  }\n\n  select, input[type=\"checkbox\"] {\n    background: rgba(17,24,39,0.65);\n    color: var(--text);\n    border: 1px solid rgba(255,255,255,0.14);\n    border-radius: 6px;\n    padding: 6px 8px;\n    font-size: 13px;\n    outline: none;\n  }\n\n  .btn {\n    background: linear-gradient(180deg, rgba(59,130,246,0.2), rgba(59,130,246,0.08));\n    border: 1px solid rgba(59,130,246,0.35);\n    color: #cfe1ff;\n    padding: 8px 12px;\n    border-radius: 8px;\n    font-size: 13px;\n    cursor: pointer;\n    transition: filter 0.2s ease, transform 0.05s ease;\n  }\n  .btn:active { transform: scale(0.98); }\n  .btn.secondary {\n    background: linear-gradient(180deg, rgba(6,182,212,0.2), rgba(6,182,212,0.08));\n    border-color: rgba(6,182,212,0.35);\n    color: #d8fbff;\n  }\n  .btn.muted {\n    background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));\n    border-color: rgba(255,255,255,0.18);\n    color: var(--muted);\n  }\n  .btn.warn {\n    background: linear-gradient(180deg, rgba(245,158,11,0.18), rgba(245,158,11,0.06));\n    border-color: rgba(245,158,11,0.35);\n    color: #ffe6b3;\n  }\n  .btn.danger {\n    background: linear-gradient(180deg, rgba(239,68,68,0.18), rgba(239,68,68,0.06));\n    border-color: rgba(239,68,68,0.35);\n    color: #ffd9d9;\n  }\n\n  .board {\n    position: relative;\n    height: 520px;\n  }\n\n  #svg {\n    width: 100%;\n    height: 100%;\n    display: block;\n    background:\n      radial-gradient(1200px 700px at 70% 0%, rgba(59,130,246,0.08), transparent 45%),\n      radial-gradient(900px 900px at 20% 20%, rgba(6,182,212,0.08), transparent 50%),\n      linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n  }\n\n  .legend {\n    display: flex;\n    gap: 10px;\n    padding: 8px 12px;\n    font-size: 12px;\n    color: var(--muted);\n    border-top: 1px solid rgba(255,255,255,0.06);\n    background: rgba(255,255,255,0.03);\n  }\n  .chip { display: inline-flex; align-items: center; gap: 6px; }\n  .chip .dot { width: 10px; height: 3px; border-radius: 2px; display: inline-block; }\n\n  .side {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    gap: 10px;\n  }\n\n  .panel-content {\n    padding: 10px 12px;\n    font-size: 13px;\n    line-height: 1.45;\n    color: var(--muted);\n  }\n\n  .stack, .order, .adj {\n    padding: 10px 12px;\n    font-size: 13px;\n  }\n\n  .stack-items, .order-items {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 6px;\n  }\n\n  .pill {\n    background: rgba(59,130,246,0.15);\n    border: 1px solid rgba(59,130,246,0.35);\n    color: #d6e8ff;\n    padding: 4px 8px;\n    border-radius: 999px;\n    font-size: 12px;\n  }\n  .pill.green {\n    background: rgba(16,185,129,0.15);\n    border-color: rgba(16,185,129,0.35);\n    color: #cbffe9;\n  }\n  .pill.orange {\n    background: rgba(245,158,11,0.15);\n    border-color: rgba(245,158,11,0.35);\n    color: #ffe9bf;\n  }\n  .pill.red {\n    background: rgba(239,68,68,0.15);\n    border-color: rgba(239,68,68,0.35);\n    color: #ffd2d2;\n  }\n\n  .info {\n    padding: 8px 12px;\n    border-top: 1px solid rgba(255,255,255,0.06);\n    font-size: 12px;\n    color: var(--muted);\n    background: rgba(255,255,255,0.03);\n  }\n\n  .switch {\n    display: inline-flex;\n    align-items: center;\n    gap: 6px;\n    font-size: 13px;\n    color: var(--muted);\n  }\n\n  .range {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    color: var(--muted);\n    font-size: 12px;\n  }\n  input[type=\"range\"] {\n    width: 140px;\n  }\n\n  /* SVG styles */\n  .edge {\n    stroke: rgba(255,255,255,0.25);\n    stroke-width: 2;\n  }\n  .edge-tree {\n    stroke: var(--success) !important;\n    stroke-width: 3.5;\n    opacity: 0.95;\n  }\n  .edge-back {\n    stroke: var(--danger) !important;\n    stroke-width: 3;\n    opacity: 0.95;\n  }\n  .edge-check {\n    stroke: var(--warn) !important;\n    stroke-width: 3.5;\n  }\n  .node circle {\n    fill: rgba(255,255,255,0.85);\n    stroke: rgba(255,255,255,0.15);\n    stroke-width: 2;\n    filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3));\n    transition: fill 0.2s ease, stroke 0.2s ease, transform 0.05s ease;\n  }\n  .node.visited circle {\n    fill: #cfe8ff;\n    stroke: rgba(59,130,246,0.75);\n  }\n  .node.finished circle {\n    fill: #9fd0ff;\n    stroke: rgba(59,130,246,0.95);\n  }\n  .node.selected circle {\n    stroke: var(--accent2);\n    stroke-width: 3;\n  }\n  .node text {\n    pointer-events: none;\n    font-weight: 600;\n    font-size: 13px;\n    fill: #0b1229;\n  }\n  .node .time {\n    pointer-events: none;\n    font-size: 10px;\n    fill: #334155;\n  }\n\n  .hint {\n    color: var(--muted);\n    font-size: 12px;\n  }\n\n  .kbd {\n    background: rgba(255,255,255,0.08);\n    border: 1px solid rgba(255,255,255,0.18);\n    border-radius: 6px;\n    padding: 2px 6px;\n    font-size: 12px;\n    color: var(--text);\n  }\n\n  .divider {\n    height: 1px;\n    background: rgba(255,255,255,0.06);\n    margin: 8px 0;\n  }\n\n  .adj-list {\n    font-family: ui-monospace, \"SF Mono\", Menlo, Consolas, monospace;\n    background: rgba(255,255,255,0.04);\n    border: 1px solid rgba(255,255,255,0.06);\n    border-radius: 8px;\n    padding: 8px;\n    color: #cbd5e1;\n    font-size: 12px;\n    white-space: pre-wrap;\n  }\n</style>\n</head>\n<body>\n  <header>\n    <h1>Depth-First Search (DFS) Visualizer</h1>\n    <span class=\"tag\">Interactive demo: recursive and iterative DFS on a graph</span>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"card\">\n      <header>\n        <h2>Graph</h2>\n        <div class=\"hint\">Click a node to choose the start. Toggle Edit to add/remove edges.</div>\n      </header>\n\n      <div class=\"controls\">\n        <div class=\"control-group\">\n          <label for=\"start\">Start node</label>\n          <select id=\"start\"></select>\n        </div>\n\n        <div class=\"control-group\">\n          <label for=\"mode\">Mode</label>\n          <select id=\"mode\">\n            <option value=\"recursive\">Recursive</option>\n            <option value=\"iterative\">Iterative (explicit stack)</option>\n          </select>\n        </div>\n\n        <div class=\"control-group\">\n          <label class=\"switch\">\n            <input type=\"checkbox\" id=\"directed\" checked>\n            Directed graph\n          </label>\n          <label class=\"switch\">\n            <input type=\"checkbox\" id=\"editEdges\">\n            Edit edges\n          </label>\n        </div>\n\n        <div class=\"control-group\">\n          <button class=\"btn\" id=\"playBtn\">Play</button>\n          <button class=\"btn secondary\" id=\"stepBtn\">Step</button>\n          <button class=\"btn muted\" id=\"resetBtn\">Reset</button>\n        </div>\n\n        <div class=\"control-group\">\n          <button class=\"btn warn\" id=\"randomBtn\">Randomize edges</button>\n          <button class=\"btn danger\" id=\"clearBtn\">Clear edges</button>\n        </div>\n\n        <div class=\"control-group\">\n          <span class=\"range\">Speed <input id=\"speed\" type=\"range\" min=\"0.2\" max=\"3\" step=\"0.1\" value=\"1\"><span id=\"speedVal\">1.0x</span></span>\n        </div>\n      </div>\n\n      <div class=\"board\">\n        <svg id=\"svg\" viewBox=\"0 0 900 520\" preserveAspectRatio=\"xMidYMid meet\">\n          <defs>\n            <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"8\" refX=\"10\" refY=\"4\" orient=\"auto\" markerUnits=\"strokeWidth\">\n              <path d=\"M0,0 L10,4 L0,8 Z\" fill=\"rgba(255,255,255,0.6)\"></path>\n            </marker>\n          </defs>\n          <g id=\"edges\"></g>\n          <g id=\"nodes\"></g>\n        </svg>\n      </div>\n\n      <div class=\"legend\">\n        <div class=\"chip\"><span class=\"dot\" style=\"background: var(--success)\"></span>Tree edge</div>\n        <div class=\"chip\"><span class=\"dot\" style=\"background: var(--danger)\"></span>Back edge (directed)</div>\n        <div class=\"chip\"><span class=\"dot\" style=\"background: var(--warn)\"></span>Checking edge</div>\n      </div>\n    </div>\n\n    <div class=\"side\">\n      <div class=\"card\">\n        <header>\n          <h2>DFS Stack</h2>\n        </header>\n        <div class=\"stack\">\n          <div class=\"stack-items\" id=\"stack\"></div>\n        </div>\n        <div class=\"info\">Recursive: call stack of active DFS calls. Iterative: explicit stack of frames.</div>\n      </div>\n\n      <div class=\"card\">\n        <header>\n          <h2>Visit Order</h2>\n        </header>\n        <div class=\"order\">\n          <div class=\"order-items\" id=\"order\"></div>\n        </div>\n        <div class=\"info\">Nodes are visited when first discovered (time d[u]). Finish time f[u] is set when leaving the node.</div>\n      </div>\n\n      <div class=\"card\">\n        <header>\n          <h2>Adjacency List</h2>\n        </header>\n        <div class=\"adj\">\n          <div class=\"adj-list\" id=\"adjList\"></div>\n        </div>\n        <div class=\"info\">Edit mode: click node U then node V to toggle edge U → V. In undirected mode, toggles both directions.</div>\n      </div>\n\n      <div class=\"card\">\n        <header>\n          <h2>Status</h2>\n        </header>\n        <div class=\"panel-content\" id=\"status\">\n          Ready. Choose a start node and press Play or Step.\n        </div>\n        <div class=\"info\">Tips: You can step through to understand recursion and the stack. Use Randomize to explore different graphs.</div>\n      </div>\n    </div>\n  </div>\n\n<script>\n(function() {\n  // Core state\n  const N = 8; // nodes: 0..7 labeled A..H\n  const nodes = [];\n  const adjacency = new Map(); // id -> Set of neighbor ids\n  const nodeRadius = 22;\n  let directed = true;\n  let editMode = false;\n\n  // DFS animation state\n  let frames = [];\n  let frameIndex = 0;\n  let playing = false;\n  let timer = null;\n  let speed = 1.0;\n\n  // Runtime marks (during animation)\n  const visited = new Array(N).fill(false);\n  const disc = new Array(N).fill(null);\n  const finish = new Array(N).fill(null);\n  let timeCounter = 0;\n  const stackModel = []; // display-only stack\n  const orderList = [];\n  let lastCheckedEdgeKey = null;\n\n  // UI elements\n  const svg = document.getElementById('svg');\n  const gEdges = document.getElementById('edges');\n  const gNodes = document.getElementById('nodes');\n  const startSelect = document.getElementById('start');\n  const modeSelect = document.getElementById('mode');\n  const directedChk = document.getElementById('directed');\n  const editChk = document.getElementById('editEdges');\n  const playBtn = document.getElementById('playBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const speedRange = document.getElementById('speed');\n  const speedVal = document.getElementById('speedVal');\n  const stackDiv = document.getElementById('stack');\n  const orderDiv = document.getElementById('order');\n  const adjDiv = document.getElementById('adjList');\n  const statusDiv = document.getElementById('status');\n\n  // Edge element map\n  const edgeEl = new Map(); // key->SVG line\n\n  // Utilities\n  const label = id => String.fromCharCode(65 + id);\n  function byId(id) { return nodes.find(n => n.id === id); }\n\n  // Initialize node positions (circle layout)\n  function initNodes() {\n    nodes.length = 0;\n    gNodes.innerHTML = '';\n    const cx = 450, cy = 260, R = 200;\n    for (let i = 0; i < N; i++) {\n      const angle = (Math.PI * 2) * (i / N) - Math.PI / 2;\n      const x = cx + Math.cos(angle) * R;\n      const y = cy + Math.sin(angle) * R;\n      const node = { id: i, x, y, disc: null, finish: null };\n      nodes.push(node);\n      const group = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      group.classList.add('node');\n      group.setAttribute('data-id', i);\n      group.setAttribute('transform', `translate(${x},${y})`);\n      const circ = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n      circ.setAttribute('r', nodeRadius);\n      circ.setAttribute('cx', 0);\n      circ.setAttribute('cy', 0);\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      text.setAttribute('x', 0);\n      text.setAttribute('y', 4);\n      text.setAttribute('text-anchor', 'middle');\n      text.textContent = label(i);\n      const timeText = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      timeText.classList.add('time');\n      timeText.setAttribute('x', 0);\n      timeText.setAttribute('y', 26);\n      timeText.setAttribute('text-anchor', 'middle');\n      timeText.textContent = '';\n      group.appendChild(circ);\n      group.appendChild(text);\n      group.appendChild(timeText);\n      group.addEventListener('click', onNodeClick);\n      gNodes.appendChild(group);\n      node.group = group;\n      node.timeText = timeText;\n    }\n  }\n\n  function resetRuntime() {\n    for (let i = 0; i < N; i++) {\n      visited[i] = false;\n      disc[i] = null;\n      finish[i] = null;\n      byId(i).group.classList.remove('visited', 'finished');\n      byId(i).timeText.textContent = '';\n    }\n    stackModel.length = 0;\n    orderList.length = 0;\n    frameIndex = 0;\n    frames.length = 0;\n    timeCounter = 0;\n    lastCheckedEdgeKey = null;\n    stackDiv.innerHTML = '';\n    orderDiv.innerHTML = '';\n    // Restore edges styling\n    edgeEl.forEach(el => {\n      el.classList.remove('edge-tree', 'edge-back', 'edge-check');\n      el.setAttribute('stroke', 'rgba(255,255,255,0.25)');\n      el.setAttribute('stroke-width', '2');\n    });\n    statusDiv.textContent = 'Reset. Ready to run DFS.';\n  }\n\n  function stopPlaying() {\n    playing = false;\n    if (timer) clearInterval(timer);\n    timer = null;\n    playBtn.textContent = 'Play';\n  }\n\n  function onNodeClick(e) {\n    const id = parseInt(e.currentTarget.getAttribute('data-id'), 10);\n    if (editMode) {\n      handleEditNodeClick(id);\n      return;\n    }\n    if (playing) return;\n    startSelect.value = id;\n    selectStartNodeUI(id);\n  }\n\n  function selectStartNodeUI(id) {\n    nodes.forEach(n => n.group.classList.remove('selected'));\n    byId(id).group.classList.add('selected');\n  }\n\n  function initAdjacencyDefault() {\n    adjacency.clear();\n    for (let i = 0; i < N; i++) adjacency.set(i, new Set());\n    // A..H = 0..7 default directed edges\n    addEdge(0,1,true);\n    addEdge(0,3,true);\n    addEdge(1,2,true);\n    addEdge(1,4,true);\n    addEdge(2,5,true);\n    addEdge(3,4,true);\n    addEdge(4,2,true);\n    addEdge(4,7,true);\n    addEdge(5,6,true);\n    addEdge(6,4,true);\n    rebuildEdges();\n    updateAdjList();\n  }\n\n  function addEdge(u, v, forceDirected = null) {\n    const dir = (forceDirected === null) ? directed : forceDirected;\n    if (u === v) return;\n    adjacency.get(u).add(v);\n    if (!dir) adjacency.get(v).add(u);\n  }\n\n  function removeEdge(u, v, forceDirected = null) {\n    const dir = (forceDirected === null) ? directed : forceDirected;\n    adjacency.get(u).delete(v);\n    if (!dir) adjacency.get(v).delete(u);\n  }\n\n  function toggleEdge(u, v) {\n    if (u === v) return;\n    const dir = directed;\n    const has = adjacency.get(u).has(v) || (!dir && adjacency.get(v).has(u));\n    if (has) {\n      adjacency.get(u).delete(v);\n      if (!dir) adjacency.get(v).delete(u);\n    } else {\n      adjacency.get(u).add(v);\n      if (!dir) adjacency.get(v).add(u);\n    }\n    rebuildEdges();\n    updateAdjList();\n  }\n\n  function rebuildEdges() {\n    gEdges.innerHTML = '';\n    edgeEl.clear();\n    // Build edge elements\n    if (directed) {\n      for (let u = 0; u < N; u++) {\n        for (const v of adjacency.get(u)) {\n          createEdge(u, v, true);\n        }\n      }\n    } else {\n      // Undirected: draw unique pair\n      const drawn = new Set();\n      for (let u = 0; u < N; u++) {\n        for (const v of adjacency.get(u)) {\n          const a = Math.min(u, v), b = Math.max(u, v);\n          const key = `${a}--${b}`;\n          if (drawn.has(key)) continue;\n          drawn.add(key);\n          createEdge(a, b, false);\n        }\n      }\n    }\n  }\n\n  function createEdge(u, v, isDirected) {\n    const A = byId(u), B = byId(v);\n    // compute shortened line endpoints so it touches node border\n    const dx = B.x - A.x, dy = B.y - A.y;\n    const dist = Math.hypot(dx, dy) || 1;\n    const ux = dx / dist, uy = dy / dist;\n    const sx = A.x + ux * nodeRadius, sy = A.y + uy * nodeRadius;\n    const ex = B.x - ux * nodeRadius, ey = B.y - uy * nodeRadius;\n    const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    line.setAttribute('x1', sx); line.setAttribute('y1', sy);\n    line.setAttribute('x2', ex); line.setAttribute('y2', ey);\n    line.classList.add('edge');\n    if (isDirected) line.setAttribute('marker-end', 'url(#arrow)');\n    gEdges.appendChild(line);\n    const key = isDirected ? `${u}->${v}` : `${u}--${v}`;\n    edgeEl.set(key, line);\n  }\n\n  function getEdgeKey(u, v) {\n    if (directed) return `${u}->${v}`;\n    const a = Math.min(u, v), b = Math.max(u, v);\n    return `${a}--${b}`;\n  }\n\n  // UI adjacency list\n  function updateAdjList() {\n    const lines = [];\n    for (let u = 0; u < N; u++) {\n      const arr = Array.from(adjacency.get(u)).sort((a,b) => a - b).map(label);\n      lines.push(`${label(u)}: ${arr.join(', ')}`);\n    }\n    adjDiv.textContent = lines.join('\\n');\n  }\n\n  // Edit edges mode: click U then V to toggle U->V (undirected toggles both)\n  let editFirst = null;\n  function handleEditNodeClick(id) {\n    if (editFirst === null) {\n      editFirst = id;\n      statusDiv.textContent = `Edit: selected ${label(id)}. Click another node to toggle edge ${label(id)} → ?.`;\n      selectTempNode(id);\n    } else {\n      const u = editFirst, v = id;\n      if (u === v) {\n        statusDiv.textContent = `Edit: cannot toggle self-loop. Choose another node.`;\n        return;\n      }\n      toggleEdge(u, v);\n      statusDiv.textContent = directed\n        ? `Toggled edge ${label(u)} → ${label(v)}`\n        : `Toggled edge ${label(u)} — ${label(v)} (undirected)`;\n      clearTempSelection();\n      editFirst = null;\n    }\n  }\n\n  function selectTempNode(id) {\n    nodes.forEach(n => n.group.classList.remove('selected'));\n    byId(id).group.classList.add('selected');\n  }\n  function clearTempSelection() {\n    nodes.forEach(n => n.group.classList.remove('selected'));\n  }\n\n  // DFS frame builder\n  function buildFrames(startId, mode) {\n    frames = [];\n    // local simulation arrays for building frames\n    const vis = new Array(N).fill(false);\n    const discT = new Array(N).fill(null);\n    const finT = new Array(N).fill(null);\n    let t = 0;\n\n    function neighborsOf(u) {\n      return Array.from(adjacency.get(u)).sort((a,b) => a - b);\n    }\n\n    function pushFrame(fr) { frames.push(fr); }\n\n    if (mode === 'recursive') {\n      function dfs(u) {\n        pushFrame({type:'visit', node:u, time: ++t});\n        vis[u] = true;\n        discT[u] = t;\n        const nbrs = neighborsOf(u);\n        for (const v of nbrs) {\n          let status;\n          if (!vis[v]) {\n            status = 'tree';\n            pushFrame({type:'edge_check', u, v, status});\n            pushFrame({type:'tree_edge', u, v});\n            dfs(v);\n          } else {\n            if (directed) {\n              status = finT[v] === null ? 'back' : 'visited';\n            } else {\n              status = 'visited';\n            }\n            pushFrame({type:'edge_check', u, v, status});\n          }\n        }\n        pushFrame({type:'finish', node:u, time: ++t});\n        finT[u] = t;\n      }\n      dfs(startId);\n\n      // If graph disconnected, offer to continue from remaining nodes (optional). We'll not auto-continue; DFS is from start node only.\n    } else if (mode === 'iterative') {\n      const stack = [{u: startId, i: 0}];\n      let onStack = new Set([startId]);\n      while (stack.length) {\n        const top = stack[stack.length - 1];\n        const u = top.u;\n        if (!vis[u]) {\n          pushFrame({type:'visit', node:u, time: ++t});\n          vis[u] = true;\n          discT[u] = t;\n        }\n        const nbrs = neighborsOf(u);\n        if (top.i < nbrs.length) {\n          const v = nbrs[top.i++];\n          let status;\n          if (!vis[v]) {\n            status = 'tree';\n            pushFrame({type:'edge_check', u, v, status});\n            pushFrame({type:'tree_edge', u, v});\n            stack.push({u: v, i: 0});\n            onStack.add(v);\n          } else {\n            if (directed) {\n              status = finT[v] === null ? 'back' : 'visited';\n            } else {\n              status = 'visited';\n            }\n            pushFrame({type:'edge_check', u, v, status});\n          }\n        } else {\n          pushFrame({type:'finish', node:u, time: ++t});\n          finT[u] = t;\n          onStack.delete(u);\n          stack.pop();\n        }\n      }\n    }\n  }\n\n  // Apply frames one by one\n  function applyFrame(fr) {\n    // Clear previous check highlight\n    if (lastCheckedEdgeKey) {\n      const el = edgeEl.get(lastCheckedEdgeKey);\n      if (el && !el.classList.contains('edge-tree') && !el.classList.contains('edge-back')) {\n        el.classList.remove('edge-check');\n        el.setAttribute('stroke', 'rgba(255,255,255,0.25)');\n        el.setAttribute('stroke-width', '2');\n      }\n      lastCheckedEdgeKey = null;\n    }\n\n    switch (fr.type) {\n      case 'visit':\n        visited[fr.node] = true;\n        disc[fr.node] = fr.time;\n        timeCounter = fr.time;\n        const ng = byId(fr.node).group;\n        ng.classList.add('visited');\n        byId(fr.node).timeText.textContent = `d=${disc[fr.node]}, f=${finish[fr.node] ?? '-'}`;\n        stackModel.push(fr.node);\n        renderStack();\n        orderList.push(fr.node);\n        renderOrder();\n        statusDiv.textContent = `Visit ${label(fr.node)} (discover time d=${disc[fr.node]})`;\n        break;\n      case 'edge_check':\n        {\n          const key = getEdgeKey(fr.u, fr.v);\n          lastCheckedEdgeKey = key;\n          const el = edgeEl.get(key);\n          if (el) {\n            el.classList.add('edge-check');\n            el.setAttribute('stroke', 'var(--warn)');\n            el.setAttribute('stroke-width', '3.5');\n          }\n          let msg = `Check edge ${label(fr.u)} → ${label(fr.v)}: `;\n          if (fr.status === 'tree') {\n            msg += 'unvisited, take it (tree edge).';\n          } else if (fr.status === 'back') {\n            msg += 'back edge to ancestor (cycle).';\n            if (el) el.classList.add('edge-back');\n          } else {\n            msg += 'already visited, skip.';\n          }\n          statusDiv.textContent = msg;\n        }\n        break;\n      case 'tree_edge':\n        {\n          const key = getEdgeKey(fr.u, fr.v);\n          const el = edgeEl.get(key);\n          if (el) {\n            el.classList.remove('edge-check');\n            el.classList.add('edge-tree');\n            el.setAttribute('stroke', 'var(--success)');\n            el.setAttribute('stroke-width', '3.5');\n          }\n        }\n        break;\n      case 'finish':\n        finish[fr.node] = fr.time;\n        timeCounter = fr.time;\n        const ng2 = byId(fr.node).group;\n        ng2.classList.add('finished');\n        byId(fr.node).timeText.textContent = `d=${disc[fr.node]}, f=${finish[fr.node]}`;\n        // Pop from stack\n        const idx = stackModel.lastIndexOf(fr.node);\n        if (idx !== -1) stackModel.splice(idx, 1);\n        renderStack();\n        statusDiv.textContent = `Finish ${label(fr.node)} (finish time f=${finish[fr.node]})`;\n        break;\n    }\n  }\n\n  function renderStack() {\n    stackDiv.innerHTML = '';\n    for (const id of stackModel) {\n      const pill = document.createElement('span');\n      pill.className = 'pill';\n      pill.textContent = label(id);\n      stackDiv.appendChild(pill);\n    }\n  }\n\n  function renderOrder() {\n    orderDiv.innerHTML = '';\n    for (let i = 0; i < orderList.length; i++) {\n      const id = orderList[i];\n      const pill = document.createElement('span');\n      pill.className = 'pill green';\n      pill.textContent = `${i+1}. ${label(id)}`;\n      orderDiv.appendChild(pill);\n    }\n  }\n\n  function stepOnce() {\n    if (!frames.length || frameIndex >= frames.length) {\n      statusDiv.textContent = 'No frames to play. Build DFS first (Play or Step).';\n      return;\n    }\n    const fr = frames[frameIndex++];\n    applyFrame(fr);\n    if (frameIndex >= frames.length) {\n      statusDiv.textContent = 'DFS complete.';\n      stopPlaying();\n    }\n  }\n\n  function play() {\n    if (!playing) {\n      if (!frames.length || frameIndex >= frames.length) {\n        // Build frames from current configuration\n        resetRuntime();\n        const startId = parseInt(startSelect.value, 10);\n        selectStartNodeUI(startId);\n        buildFrames(startId, modeSelect.value);\n        statusDiv.textContent = `Running ${modeSelect.value === 'recursive' ? 'recursive' : 'iterative'} DFS from ${label(startId)}...`;\n      }\n      playing = true;\n      playBtn.textContent = 'Pause';\n      const interval = Math.max(80, 500 / speed);\n      timer = setInterval(() => {\n        stepOnce();\n        if (!playing || frameIndex >= frames.length) {\n          stopPlaying();\n        }\n      }, interval);\n    } else {\n      stopPlaying();\n    }\n  }\n\n  // UI events\n  playBtn.addEventListener('click', play);\n  stepBtn.addEventListener('click', () => {\n    if (!frames.length || frameIndex >= frames.length) {\n      resetRuntime();\n      const startId = parseInt(startSelect.value, 10);\n      selectStartNodeUI(startId);\n      buildFrames(startId, modeSelect.value);\n      statusDiv.textContent = `Stepping ${modeSelect.value === 'recursive' ? 'recursive' : 'iterative'} DFS from ${label(startId)}...`;\n    }\n    stepOnce();\n  });\n  resetBtn.addEventListener('click', () => {\n    stopPlaying();\n    resetRuntime();\n  });\n  randomBtn.addEventListener('click', () => {\n    stopPlaying();\n    resetRuntime();\n    adjacency.clear();\n    for (let i = 0; i < N; i++) adjacency.set(i, new Set());\n    const p = directed ? 0.22 : 0.28;\n    for (let u = 0; u < N; u++) {\n      for (let v = 0; v < N; v++) {\n        if (u === v) continue;\n        if (Math.random() < p) {\n          addEdge(u, v);\n        }\n      }\n    }\n    rebuildEdges();\n    updateAdjList();\n    statusDiv.textContent = 'Randomized edges. Select start and run DFS.';\n  });\n  clearBtn.addEventListener('click', () => {\n    stopPlaying();\n    resetRuntime();\n    adjacency.clear();\n    for (let i = 0; i < N; i++) adjacency.set(i, new Set());\n    rebuildEdges();\n    updateAdjList();\n    statusDiv.textContent = 'Cleared all edges.';\n  });\n\n  directedChk.addEventListener('change', () => {\n    directed = directedChk.checked;\n    stopPlaying();\n    resetRuntime();\n    rebuildEdges();\n    updateAdjList();\n    statusDiv.textContent = directed ? 'Directed graph mode.' : 'Undirected graph mode.';\n  });\n\n  editChk.addEventListener('change', () => {\n    editMode = editChk.checked;\n    if (editMode) {\n      stopPlaying();\n      statusDiv.textContent = 'Edit mode: click U then V to toggle edge.';\n    } else {\n      editFirst = null;\n      clearTempSelection();\n      statusDiv.textContent = 'Edit mode off.';\n    }\n  });\n\n  speedRange.addEventListener('input', () => {\n    speed = parseFloat(speedRange.value);\n    speedVal.textContent = `${speed.toFixed(1)}x`;\n    if (playing) {\n      stopPlaying();\n      play();\n    }\n  });\n\n  startSelect.addEventListener('change', () => {\n    const id = parseInt(startSelect.value, 10);\n    selectStartNodeUI(id);\n  });\n\n  modeSelect.addEventListener('change', () => {\n    stopPlaying();\n    resetRuntime();\n  });\n\n  // Bootstrap\n  function initStartDropdown() {\n    startSelect.innerHTML = '';\n    for (let i = 0; i < N; i++) {\n      const opt = document.createElement('option');\n      opt.value = i;\n      opt.textContent = label(i);\n      startSelect.appendChild(opt);\n    }\n    startSelect.value = 0;\n    selectStartNodeUI(0);\n  }\n\n  initNodes();\n  initStartDropdown();\n  initAdjacencyDefault();\n  resetRuntime();\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Depth-First Search (DFS)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "ddded890-a36c-11f0-9649-2554350028ba",
    "timestamp": "2025-10-07T11:00:42.266Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Breadth-First Search (BFS)",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<title>Breadth-First Search (BFS) Visualizer</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --text: #e5e7eb;\n    --muted: #94a3b8;\n    --accent: #60a5fa;\n    --accent-2: #22c55e;\n    --warn: #f59e0b;\n    --border: #1f2937;\n    --node: #cbd5e1;\n    --edge: #475569;\n  }\n  html, body {\n    background: var(--bg);\n    color: var(--text);\n    margin: 0; padding: 0;\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial;\n  }\n  header {\n    padding: 18px;\n    border-bottom: 1px solid var(--border);\n    display: flex; align-items: center; gap: 16px; flex-wrap: wrap;\n  }\n  header h1 {\n    margin: 0;\n    font-size: 22px;\n    letter-spacing: 0.2px;\n  }\n  header .desc {\n    color: var(--muted);\n    font-size: 14px;\n  }\n  main {\n    display: grid;\n    grid-template-columns: 320px 1fr;\n    gap: 12px;\n    padding: 12px;\n  }\n  @media (max-width: 900px) {\n    main { grid-template-columns: 1fr; }\n  }\n  .panel {\n    background: var(--panel);\n    border: 1px solid var(--border);\n    border-radius: 12px;\n    padding: 14px;\n  }\n  .panel h2 {\n    margin: 0 0 10px;\n    font-size: 16px;\n    color: var(--text);\n  }\n  .controls label {\n    display: block;\n    font-size: 13px;\n    color: var(--muted);\n    margin-bottom: 6px;\n  }\n  .controls select, .controls input[type=\"range\"] {\n    width: 100%;\n    padding: 8px;\n    border: 1px solid var(--border);\n    border-radius: 8px;\n    background: #0b1220;\n    color: var(--text);\n    margin-bottom: 10px;\n  }\n  .btn-row {\n    display: flex; flex-wrap: wrap; gap: 8px; margin-top: 6px;\n  }\n  button {\n    background: #0b1220;\n    border: 1px solid var(--border);\n    color: var(--text);\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 14px;\n  }\n  button.primary { background: var(--accent); color: #0b1220; border-color: transparent; }\n  button.warn { background: var(--warn); color: #0b1220; border-color: transparent; }\n  button:disabled { opacity: 0.5; cursor: default; }\n  .legend {\n    display: grid; grid-template-columns: repeat(2, minmax(0, 1fr));\n    gap: 8px; margin-top: 8px;\n    font-size: 13px;\n  }\n  .legend div {\n    display: flex; align-items: center; gap: 8px;\n  }\n  .swatch {\n    width: 18px; height: 18px; border-radius: 50%;\n    border: 2px solid var(--edge);\n  }\n  .swatch.unvisited { background: var(--node); }\n  .swatch.visited { background: #2563eb; }\n  .swatch.queue { background: #0b1220; border-color: #60a5fa; }\n  .swatch.current { background: var(--warn); }\n  .swatch.start { background: #0b1220; border-color: #22c55e; }\n  .graph-panel {\n    position: relative;\n    min-height: 420px;\n  }\n  .graph-wrapper {\n    position: relative;\n    width: 100%;\n    height: 520px;\n    border-radius: 12px;\n    overflow: hidden;\n    background: #0b1220;\n    border: 1px solid var(--border);\n  }\n  svg {\n    width: 100%; height: 100%;\n  }\n  .edge {\n    stroke: var(--edge);\n    stroke-width: 2;\n    opacity: 0.75;\n  }\n  .node circle {\n    fill: var(--node);\n    stroke: var(--edge);\n    stroke-width: 2;\n    transition: transform 0.06s ease-in-out;\n  }\n  .node text {\n    fill: #0b1220;\n    font-weight: 600;\n    font-size: 13px;\n    pointer-events: none;\n  }\n  .node .dist {\n    fill: var(--muted);\n    font-size: 11px;\n  }\n  .node.visited circle { fill: #2563eb; stroke: #1e40af; }\n  .node.queue circle { stroke: #60a5fa; stroke-width: 3; }\n  .node.current circle { fill: #f59e0b; stroke: #b45309; }\n  .node.start circle { stroke: #22c55e; stroke-width: 3; }\n  .node:hover circle { transform: scale(1.06); }\n  .hint {\n    font-size: 12px; color: var(--muted);\n    margin-top: 6px;\n  }\n  .code {\n    background: #0b1220;\n    border: 1px solid var(--border);\n    border-radius: 8px;\n    padding: 8px 10px;\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n    font-size: 13px;\n    line-height: 1.5;\n    color: var(--text);\n    white-space: pre;\n  }\n  .code .hl { background: rgba(96,165,250,0.15); border-left: 3px solid var(--accent); padding-left: 6px; }\n  .status {\n    display: grid; grid-template-columns: 1fr 1fr; gap: 12px;\n    margin-top: 10px;\n  }\n  .queue, .visited-list {\n    background: #0b1220; border: 1px solid var(--border); border-radius: 8px; padding: 8px;\n    min-height: 44px;\n  }\n  .queue .title, .visited-list .title {\n    color: var(--muted); font-size: 12px; margin-bottom: 6px;\n  }\n  .queue-items {\n    display: flex; gap: 6px; flex-wrap: wrap;\n  }\n  .q-item {\n    background: #0b1220;\n    border: 1px solid #60a5fa;\n    color: #60a5fa;\n    padding: 6px 8px;\n    border-radius: 6px;\n    font-weight: 600;\n    font-size: 13px;\n  }\n  .visited-items {\n    display: flex; gap: 6px; flex-wrap: wrap;\n  }\n  .v-item {\n    background: #111827;\n    border: 1px solid #1e40af;\n    color: #93c5fd;\n    padding: 6px 8px;\n    border-radius: 6px;\n    font-weight: 600;\n    font-size: 13px;\n  }\n  .log {\n    background: #0b1220; border: 1px solid var(--border); border-radius: 8px; padding: 8px;\n    margin-top: 10px;\n    min-height: 42px;\n    font-size: 13px;\n    color: var(--muted);\n  }\n  .footer-hint {\n    padding: 12px;\n    color: var(--muted);\n    font-size: 12px;\n  }\n  .speed-row {\n    display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center;\n  }\n  .speed-value {\n    font-size: 12px; color: var(--muted);\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Breadth-First Search (BFS)</h1>\n  <div class=\"desc\">Interactive visualization of BFS on an undirected graph. Click a node to choose a start, then step through or play.</div>\n</header>\n\n<main>\n  <section class=\"panel controls\">\n    <h2>Controls</h2>\n    <label for=\"startNode\">Start node</label>\n    <select id=\"startNode\"></select>\n\n    <div class=\"btn-row\">\n      <button id=\"setStartBtn\">Set Start</button>\n      <button id=\"resetBtn\">Reset</button>\n    </div>\n\n    <div class=\"btn-row\">\n      <button id=\"stepBtn\" class=\"primary\">Next Step</button>\n      <button id=\"playBtn\" class=\"primary\">Play</button>\n      <button id=\"pauseBtn\">Pause</button>\n    </div>\n\n    <div class=\"speed-row\" style=\"margin-top: 8px;\">\n      <input type=\"range\" id=\"speed\" min=\"100\" max=\"1500\" step=\"50\" value=\"600\" />\n      <div class=\"speed-value\">Speed: <span id=\"speedVal\">600ms</span></div>\n    </div>\n\n    <div class=\"legend\">\n      <div><span class=\"swatch unvisited\"></span>Unvisited</div>\n      <div><span class=\"swatch visited\"></span>Visited</div>\n      <div><span class=\"swatch queue\"></span>In Queue</div>\n      <div><span class=\"swatch current\"></span>Current</div>\n      <div><span class=\"swatch start\"></span>Start</div>\n    </div>\n\n    <div class=\"hint\">Tip: You can drag nodes to rearrange the graph.</div>\n\n    <h2 style=\"margin-top: 14px;\">BFS Pseudocode</h2>\n    <div id=\"code\" class=\"code\"></div>\n  </section>\n\n  <section class=\"graph-panel panel\">\n    <h2>Graph</h2>\n    <div class=\"graph-wrapper\">\n      <svg id=\"graph\" viewBox=\"0 0 900 520\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n    </div>\n\n    <div class=\"status\">\n      <div class=\"queue\">\n        <div class=\"title\">Queue (FIFO)</div>\n        <div id=\"queueItems\" class=\"queue-items\"></div>\n      </div>\n      <div class=\"visited-list\">\n        <div class=\"title\">Visited</div>\n        <div id=\"visitedItems\" class=\"visited-items\"></div>\n      </div>\n    </div>\n\n    <div id=\"log\" class=\"log\">Choose a start node to begin.</div>\n  </section>\n</main>\n\n<div class=\"footer-hint\">BFS explores neighbors level by level using a queue. It guarantees shortest path distances in terms of edge count on unweighted graphs.</div>\n\n<script>\n(function() {\n  // Graph definition\n  const nodes = [\n    { id: 'A', x: 120, y: 120 },\n    { id: 'B', x: 280, y: 90 },\n    { id: 'C', x: 260, y: 220 },\n    { id: 'D', x: 420, y: 80 },\n    { id: 'E', x: 420, y: 180 },\n    { id: 'F', x: 420, y: 280 },\n    { id: 'G', x: 580, y: 160 },\n    { id: 'H', x: 560, y: 300 },\n    { id: 'I', x: 740, y: 230 },\n  ];\n  const edges = [\n    ['A','B'], ['A','C'], ['B','D'], ['B','E'],\n    ['C','F'], ['C','D'], ['E','G'], ['D','G'],\n    ['F','H'], ['H','I'], ['G','I'], ['E','F']\n  ]; // undirected\n\n  const adj = buildAdjacency(nodes, edges);\n\n  // DOM references\n  const svg = document.getElementById('graph');\n  const startSelect = document.getElementById('startNode');\n  const setStartBtn = document.getElementById('setStartBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const playBtn = document.getElementById('playBtn');\n  const pauseBtn = document.getElementById('pauseBtn');\n  const speedRange = document.getElementById('speed');\n  const speedVal = document.getElementById('speedVal');\n  const queueItemsEl = document.getElementById('queueItems');\n  const visitedItemsEl = document.getElementById('visitedItems');\n  const logEl = document.getElementById('log');\n  const codeEl = document.getElementById('code');\n\n  speedVal.textContent = speedRange.value + 'ms';\n\n  // Render UI components\n  populateStartSelect();\n  renderCode();\n  const { nodeElements, edgeElements } = renderGraph();\n\n  // BFS state\n  let bfs = null;\n  let startNodeId = nodes[0].id;\n  let playingTimer = null;\n\n  // Initialize\n  setStart(startNodeId);\n  reset();\n\n  // Event listeners\n  startSelect.addEventListener('change', () => {\n    setStart(startSelect.value);\n    reset();\n  });\n  setStartBtn.addEventListener('click', () => {\n    log('Click a node to set it as start.');\n    highlightCode(); // clear\n    // next click will set start (handled in node click)\n    awaitingStartClick = true;\n  });\n  resetBtn.addEventListener('click', reset);\n  stepBtn.addEventListener('click', () => {\n    step();\n  });\n  playBtn.addEventListener('click', () => {\n    if (!bfs || bfs.stage === 'done') reset();\n    autoPlay();\n  });\n  pauseBtn.addEventListener('click', pause);\n  speedRange.addEventListener('input', () => {\n    speedVal.textContent = speedRange.value + 'ms';\n    if (playingTimer) { autoPlay(true); } // update timer\n  });\n\n  let awaitingStartClick = false;\n\n  // Node interactions: click to set start, drag to move\n  nodes.forEach(n => {\n    const g = nodeElements[n.id];\n    g.addEventListener('click', () => {\n      if (awaitingStartClick) {\n        awaitingStartClick = false;\n        setStart(n.id);\n        reset();\n        log(`Start set to ${n.id}. Press Next Step or Play.`);\n        return;\n      }\n      setStart(n.id);\n      reset();\n      log(`Start set to ${n.id}. Press Next Step or Play.`);\n    });\n    makeDraggable(n.id);\n  });\n\n  // Core functions\n\n  function buildAdjacency(nodes, edges) {\n    const adj = {};\n    nodes.forEach(n => adj[n.id] = new Set());\n    edges.forEach(([u,v]) => {\n      adj[u].add(v);\n      adj[v].add(u); // undirected\n    });\n    // Convert to sorted arrays for stable traversal\n    Object.keys(adj).forEach(k => adj[k] = Array.from(adj[k]).sort());\n    return adj;\n  }\n\n  function populateStartSelect() {\n    startSelect.innerHTML = '';\n    nodes.forEach(n => {\n      const opt = document.createElement('option');\n      opt.value = n.id;\n      opt.textContent = n.id;\n      startSelect.appendChild(opt);\n    });\n  }\n\n  function renderGraph() {\n    // Clear svg\n    svg.innerHTML = '';\n    const edgeElements = [];\n    edges.forEach(([u,v]) => {\n      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n      line.classList.add('edge');\n      const nu = nodes.find(x => x.id === u);\n      const nv = nodes.find(x => x.id === v);\n      line.setAttribute('x1', nu.x); line.setAttribute('y1', nu.y);\n      line.setAttribute('x2', nv.x); line.setAttribute('y2', nv.y);\n      line.dataset.u = u; line.dataset.v = v;\n      svg.appendChild(line);\n      edgeElements.push(line);\n    });\n\n    const nodeElements = {};\n    nodes.forEach(n => {\n      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n      g.classList.add('node');\n      g.dataset.id = n.id;\n      g.setAttribute('transform', `translate(${n.x},${n.y})`);\n\n      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n      circle.setAttribute('r', 22);\n      circle.setAttribute('cx', 0);\n      circle.setAttribute('cy', 0);\n\n      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      label.setAttribute('x', 0); label.setAttribute('y', 4);\n      label.setAttribute('text-anchor', 'middle');\n      label.textContent = n.id;\n\n      const dist = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      dist.setAttribute('x', 0); dist.setAttribute('y', 22);\n      dist.setAttribute('text-anchor', 'middle');\n      dist.classList.add('dist');\n      dist.textContent = '';\n\n      g.appendChild(circle);\n      g.appendChild(label);\n      g.appendChild(dist);\n      svg.appendChild(g);\n      nodeElements[n.id] = g;\n    });\n\n    return { nodeElements, edgeElements };\n  }\n\n  function updateEdges() {\n    edgeElements.forEach(line => {\n      const u = nodes.find(n => n.id === line.dataset.u);\n      const v = nodes.find(n => n.id === line.dataset.v);\n      line.setAttribute('x1', u.x); line.setAttribute('y1', u.y);\n      line.setAttribute('x2', v.x); line.setAttribute('y2', v.y);\n    });\n  }\n\n  function setStart(id) {\n    startNodeId = id;\n    startSelect.value = id;\n    // update node classes\n    nodes.forEach(n => {\n      const el = nodeElements[n.id];\n      el.classList.remove('start');\n      if (n.id === id) el.classList.add('start');\n    });\n  }\n\n  function reset() {\n    pause();\n    bfs = {\n      queue: [],\n      visited: new Set(),\n      dist: {},\n      parent: {},\n      current: null,\n      neighborIndex: 0,\n      stage: 'init'\n    };\n    nodes.forEach(n => {\n      const el = nodeElements[n.id];\n      el.classList.remove('visited','queue','current');\n      const distEl = el.querySelector('.dist');\n      distEl.textContent = '';\n      const label = el.querySelector('text');\n      label.textContent = n.id;\n    });\n    renderQueue();\n    renderVisited();\n    highlightCode(); // clear\n    log(`Ready. Start node: ${startNodeId}. Press Next Step or Play.`);\n  }\n\n  function renderQueue() {\n    queueItemsEl.innerHTML = '';\n    bfs.queue.forEach(id => {\n      const div = document.createElement('div');\n      div.className = 'q-item';\n      div.textContent = id;\n      queueItemsEl.appendChild(div);\n    });\n    // update node queue class\n    nodes.forEach(n => {\n      const el = nodeElements[n.id];\n      if (bfs.queue.includes(n.id)) el.classList.add('queue');\n      else el.classList.remove('queue');\n    });\n  }\n\n  function renderVisited() {\n    visitedItemsEl.innerHTML = '';\n    Array.from(bfs.visited).forEach(id => {\n      const div = document.createElement('div');\n      div.className = 'v-item';\n      const d = bfs.dist[id];\n      div.textContent = d !== undefined ? `${id} (d=${d})` : id;\n      visitedItemsEl.appendChild(div);\n    });\n  }\n\n  function setNodeVisited(id, visited=true) {\n    const el = nodeElements[id];\n    if (visited) el.classList.add('visited');\n    else el.classList.remove('visited');\n    renderVisited();\n    const distEl = el.querySelector('.dist');\n    const labelEl = el.querySelector('text');\n    const d = bfs.dist[id];\n    distEl.textContent = (d !== undefined) ? `d=${d}` : '';\n    labelEl.textContent = id;\n  }\n\n  function setNodeCurrent(id, current=true) {\n    nodes.forEach(n => nodeElements[n.id].classList.remove('current'));\n    if (id && current) nodeElements[id].classList.add('current');\n  }\n\n  function step() {\n    if (!bfs) reset();\n    if (bfs.stage === 'done') {\n      log('BFS complete. Reset to run again.');\n      highlightCode(); // clear\n      return;\n    }\n\n    if (bfs.stage === 'init') {\n      // enqueue start, visited[start]=true, dist[start]=0\n      bfs.queue.push(startNodeId);\n      bfs.visited.add(startNodeId);\n      bfs.dist[startNodeId] = 0;\n      setNodeVisited(startNodeId, true);\n      renderQueue();\n      renderVisited();\n      setNodeCurrent(null);\n      log(`Initialize: enqueue ${startNodeId}, mark visited, dist=0.`);\n      highlightCode(1);\n      bfs.stage = 'loop';\n      return;\n    }\n\n    if (bfs.stage === 'loop') {\n      highlightCode(2);\n      if (bfs.queue.length === 0) {\n        bfs.stage = 'done';\n        setNodeCurrent(null);\n        log('Queue empty: BFS finished.');\n        highlightCode(); // clear\n        renderQueue();\n        renderVisited();\n        return;\n      }\n      // dequeue\n      bfs.current = bfs.queue.shift();\n      bfs.neighborIndex = 0;\n      setNodeCurrent(bfs.current, true);\n      renderQueue();\n      log(`Dequeue ${bfs.current}. Explore its neighbors.`);\n      highlightCode(3);\n      bfs.stage = 'neighbors';\n      return;\n    }\n\n    if (bfs.stage === 'neighbors') {\n      const u = bfs.current;\n      const neighbors = adj[u] || [];\n      if (bfs.neighborIndex >= neighbors.length) {\n        // done with neighbors, continue loop\n        setNodeCurrent(null);\n        log(`Done exploring neighbors of ${u}.`);\n        highlightCode(2);\n        bfs.current = null;\n        bfs.stage = 'loop';\n        return;\n      }\n      const v = neighbors[bfs.neighborIndex++];\n      highlightCode(4);\n\n      if (bfs.visited.has(v)) {\n        log(`Neighbor ${v} already visited. Skip.`);\n        highlightCode(5);\n        // brief visual emphasis\n        flashNode(v, '#94a3b8');\n        return;\n      }\n\n      // visit v\n      bfs.visited.add(v);\n      bfs.parent[v] = u;\n      bfs.dist[v] = bfs.dist[u] + 1;\n      bfs.queue.push(v);\n      setNodeVisited(v, true);\n      renderQueue();\n      renderVisited();\n      log(`Visit ${v}: set dist=${bfs.dist[v]} (from ${u}), enqueue ${v}.`);\n      highlightCode([5,6,7,8]);\n      return;\n    }\n  }\n\n  function autoPlay(restartTimer=false) {\n    if (restartTimer && playingTimer) {\n      clearInterval(playingTimer);\n      playingTimer = null;\n    }\n    const interval = parseInt(speedRange.value, 10);\n    if (!playingTimer) {\n      playingTimer = setInterval(() => {\n        step();\n        if (bfs.stage === 'done') pause();\n      }, interval);\n      log('Auto-play started.');\n    }\n  }\n\n  function pause() {\n    if (playingTimer) {\n      clearInterval(playingTimer);\n      playingTimer = null;\n      log('Paused.');\n    }\n  }\n\n  function flashNode(id, color='#f472b6') {\n    const el = nodeElements[id].querySelector('circle');\n    const prev = el.getAttribute('stroke');\n    const prevW = el.getAttribute('stroke-width');\n    el.setAttribute('stroke', color);\n    el.setAttribute('stroke-width', 4);\n    setTimeout(() => {\n      el.setAttribute('stroke', prev || 'var(--edge)');\n      el.setAttribute('stroke-width', prevW || 2);\n    }, 350);\n  }\n\n  function log(msg) {\n    logEl.textContent = msg;\n  }\n\n  function renderCode() {\n    const lines = [\n      'enqueue(start); visited[start] = true; dist[start] = 0;',\n      'while queue is not empty:',\n      '    u = dequeue();',\n      '    for each v in neighbors[u]:',\n      '        if not visited[v]:',\n      '            visited[v] = true;',\n      '            dist[v] = dist[u] + 1;',\n      '            enqueue(v);'\n    ];\n    codeEl.innerHTML = lines.map((l, i) => `<div data-line=\"${i+1}\">${l}</div>`).join('\\n');\n  }\n\n  function highlightCode(lineOrLines) {\n    Array.from(codeEl.children).forEach(ch => ch.classList.remove('hl'));\n    if (!lineOrLines) return;\n    if (Array.isArray(lineOrLines)) {\n      lineOrLines.forEach(n => {\n        const el = codeEl.querySelector(`[data-line=\"${n}\"]`);\n        if (el) el.classList.add('hl');\n      });\n    } else {\n      const el = codeEl.querySelector(`[data-line=\"${lineOrLines}\"]`);\n      if (el) el.classList.add('hl');\n    }\n  }\n\n  // Dragging nodes\n  function makeDraggable(id) {\n    const g = nodeElements[id];\n    let dragging = false;\n    let start = null;\n\n    g.addEventListener('mousedown', (e) => {\n      dragging = true;\n      start = { x: e.clientX, y: e.clientY };\n      e.preventDefault();\n    });\n    window.addEventListener('mousemove', (e) => {\n      if (!dragging) return;\n      const dx = e.clientX - start.x;\n      const dy = e.clientY - start.y;\n      start = { x: e.clientX, y: e.clientY };\n      const n = nodes.find(nn => nn.id === id);\n      n.x += dx; n.y += dy;\n      g.setAttribute('transform', `translate(${n.x},${n.y})`);\n      updateEdges();\n    });\n    window.addEventListener('mouseup', () => {\n      dragging = false;\n    });\n    // touch\n    g.addEventListener('touchstart', (e) => {\n      dragging = true;\n      const t = e.touches[0];\n      start = { x: t.clientX, y: t.clientY };\n      e.preventDefault();\n    }, { passive: false });\n    window.addEventListener('touchmove', (e) => {\n      if (!dragging) return;\n      const t = e.touches[0];\n      const dx = t.clientX - start.x;\n      const dy = t.clientY - start.y;\n      start = { x: t.clientX, y: t.clientY };\n      const n = nodes.find(nn => nn.id === id);\n      n.x += dx; n.y += dy;\n      g.setAttribute('transform', `translate(${n.x},${n.y})`);\n      updateEdges();\n    }, { passive: false });\n    window.addEventListener('touchend', () => { dragging = false; });\n  }\n\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Breadth-First Search (BFS)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "189a8d30-a36d-11f0-b52a-89fe126658c5",
    "timestamp": "2025-10-07T11:02:20.804Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Dijkstra’s Algorithm",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<title>Dijkstra’s Algorithm Visualizer</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<style>\n  :root {\n    --bg: #11161b;\n    --panel: #182028;\n    --accent: #5cc8ff;\n    --accent2: #ffa447;\n    --ok: #64d36d;\n    --warn: #ffce57;\n    --danger: #ff6b6b;\n    --text: #e6edf3;\n    --muted: #9aa5b1;\n    --edge: #7d8ea3;\n    --path: #b37aff;\n  }\n  * { box-sizing: border-box; }\n  body {\n    margin: 0;\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\",\"Segoe UI Emoji\";\n    background: linear-gradient(120deg, #0d1217, #141b22);\n    color: var(--text);\n  }\n  header {\n    padding: 14px 16px;\n    border-bottom: 1px solid #253243;\n    background: #12171d;\n    position: sticky;\n    top: 0;\n    z-index: 5;\n  }\n  header h1 {\n    margin: 0;\n    font-size: 20px;\n    letter-spacing: 0.2px;\n  }\n  header p {\n    margin: 6px 0 0;\n    color: var(--muted);\n    font-size: 13px;\n  }\n  .container {\n    display: grid;\n    grid-template-columns: 1fr 320px;\n    gap: 8px;\n    padding: 10px;\n    height: calc(100vh - 82px);\n  }\n  .left, .right {\n    background: var(--panel);\n    border: 1px solid #263243;\n    border-radius: 10px;\n    overflow: hidden;\n  }\n  .controls {\n    display: grid;\n    grid-template-columns: 1fr 1fr 1fr 1fr;\n    gap: 8px;\n    padding: 10px;\n    border-bottom: 1px solid #263243;\n    background: #151d25;\n  }\n  .controls .group {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n  }\n  .controls label {\n    font-size: 12px;\n    color: var(--muted);\n  }\n  select, input[type=\"number\"], input[type=\"text\"] {\n    background: #0f141a;\n    color: var(--text);\n    border: 1px solid #2b394c;\n    border-radius: 6px;\n    padding: 6px 8px;\n    font-size: 13px;\n  }\n  .modebar, .runbar, .graphbar {\n    display: flex;\n    gap: 6px;\n    flex-wrap: wrap;\n  }\n  button, .toggle {\n    background: #0f141a;\n    color: var(--text);\n    border: 1px solid #2b394c;\n    border-radius: 8px;\n    padding: 8px 10px;\n    font-size: 13px;\n    cursor: pointer;\n    transition: all .15s ease;\n    user-select: none;\n  }\n  button:hover { border-color: #3a4d66; transform: translateY(-1px); }\n  button.primary { background: #1b2836; border-color: #3a4d66; color: #d8e6f5; }\n  button.danger { border-color: #583446; color: #ffc7c7; }\n  button.secondary { color: #b7cde7; }\n  button.active { outline: 2px solid var(--accent); }\n  .speedbar { display: flex; align-items: center; gap: 6px; }\n  input[type=\"range\"] { width: 100%; }\n  .canvas-wrap {\n    position: relative;\n    height: calc(100% - 122px);\n    background: #0c1218;\n  }\n  canvas {\n    width: 100%;\n    height: 100%;\n    display: block;\n    background-image: radial-gradient(rgba(255,255,255,.04) 1px, transparent 1px);\n    background-size: 16px 16px;\n  }\n  .hint {\n    position: absolute;\n    left: 12px;\n    bottom: 8px;\n    font-size: 12px;\n    color: var(--muted);\n    background: rgba(0,0,0,.35);\n    padding: 6px 8px;\n    border: 1px solid #263243;\n    border-radius: 8px;\n    backdrop-filter: blur(4px);\n  }\n  .right {\n    display: grid;\n    grid-template-rows: auto auto 1fr;\n  }\n  .legend {\n    padding: 10px;\n    border-bottom: 1px solid #263243;\n    background: #151d25;\n    font-size: 13px;\n  }\n  .legend .items {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 10px 14px;\n  }\n  .legend .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 6px; }\n  .dot.source { background: #3ca3ff; }\n  .dot.settled { background: var(--ok); }\n  .dot.frontier { background: var(--warn); }\n  .dot.current { background: var(--danger); }\n  .dot.path { background: var(--path); }\n  .sidebar {\n    padding: 10px;\n    overflow: auto;\n  }\n  .panel {\n    border: 1px solid #273545;\n    border-radius: 8px;\n    padding: 8px;\n    margin-bottom: 10px;\n    background: #10161d;\n  }\n  .panel h3 { margin: 0 0 6px; font-size: 14px; color: #bcd2ea; }\n  .queue, .dist, .log {\n    font-family: ui-monospace, Menlo, Consolas, monospace;\n    font-size: 12px;\n    color: #c9d7e3;\n    white-space: pre-wrap;\n  }\n  .badge {\n    display: inline-flex;\n    gap: 6px;\n    align-items: center;\n    padding: 6px 8px;\n    border-radius: 999px;\n    background: #0f141a;\n    border: 1px solid #2b394c;\n  }\n  .badge .key { color: var(--muted); }\n  .badge .val { color: #e6edf3; font-weight: 600; }\n  .small { font-size: 12px; color: var(--muted); }\n  .footnote {\n    padding: 10px;\n    border-top: 1px solid #263243;\n    font-size: 12px;\n    color: var(--muted);\n    background: #151d25;\n  }\n  /* Tooltip-like overlay values on nodes */\n  .value-pill {\n    position: absolute;\n    transform: translate(-50%, -100%);\n    background: rgba(18,23,29,.8);\n    border: 1px solid #2b394c;\n    color: #dbe7f4;\n    padding: 2px 6px;\n    border-radius: 6px;\n    font-size: 11px;\n    pointer-events: none;\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Dijkstra’s Algorithm Visualizer</h1>\n  <p>Build a weighted graph and watch Dijkstra’s algorithm find shortest paths. Non-negative edge weights only.</p>\n</header>\n\n<div class=\"container\">\n  <div class=\"left\">\n    <div class=\"controls\">\n      <div class=\"group\">\n        <label>Mode</label>\n        <div class=\"modebar\">\n          <button id=\"modeSelect\" class=\"active\">Select/Move</button>\n          <button id=\"modeAddNode\">Add Node</button>\n          <button id=\"modeAddEdge\">Add Edge</button>\n          <button id=\"modeDelete\" class=\"danger\">Delete</button>\n        </div>\n      </div>\n\n      <div class=\"group\">\n        <label>Source & Target</label>\n        <div class=\"graphbar\">\n          <select id=\"sourceSelect\"></select>\n          <select id=\"targetSelect\"></select>\n          <button id=\"clearTarget\" class=\"secondary\">Clear Target</button>\n        </div>\n      </div>\n\n      <div class=\"group\">\n        <label>Run Controls</label>\n        <div class=\"runbar\">\n          <button id=\"runBtn\" class=\"primary\">Run</button>\n          <button id=\"stepBtn\">Step</button>\n          <button id=\"pauseBtn\">Pause</button>\n          <button id=\"resetBtn\" class=\"secondary\">Reset</button>\n        </div>\n      </div>\n\n      <div class=\"group\">\n        <label>Speed</label>\n        <div class=\"speedbar\">\n          <input id=\"speedRange\" type=\"range\" min=\"0\" max=\"1000\" value=\"350\">\n          <span id=\"speedLabel\" class=\"small\">350 ms</span>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"canvas-wrap\">\n      <canvas id=\"canvas\"></canvas>\n      <div id=\"hint\" class=\"hint\">Click “Run” to animate. In Add Edge mode, click two nodes and set weight (>= 0). Drag nodes in Select/Move mode.</div>\n    </div>\n\n    <div class=\"controls\" style=\"border-top: 1px solid #263243;\">\n      <div class=\"group\">\n        <label>Graph</label>\n        <div class=\"graphbar\">\n          <button id=\"randomBtn\">Random Graph</button>\n          <button id=\"clearBtn\" class=\"danger\">Clear Graph</button>\n          <button id=\"sampleBtn\">Load Sample</button>\n        </div>\n      </div>\n      <div class=\"group\">\n        <label>Edge Options</label>\n        <div class=\"graphbar\">\n          <span class=\"badge\"><span class=\"key\">Type</span><span class=\"val\">Undirected</span></span>\n          <span class=\"badge\"><span class=\"key\">Weights</span><span class=\"val\">Non-negative</span></span>\n        </div>\n      </div>\n      <div class=\"group\">\n        <label>About Dijkstra</label>\n        <div class=\"graphbar\">\n          <span class=\"small\">Finds shortest paths from source to all nodes in graphs with non-negative weights. Settles the closest node, relaxes its edges, and repeats.</span>\n        </div>\n      </div>\n      <div class=\"group\">\n        <label>Export</label>\n        <div class=\"graphbar\">\n          <button id=\"exportBtn\" class=\"secondary\">Export JSON</button>\n          <button id=\"importBtn\" class=\"secondary\">Import JSON</button>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"right\">\n    <div class=\"legend\">\n      <div class=\"items\">\n        <div><span class=\"dot source\"></span>Source</div>\n        <div><span class=\"dot settled\"></span>Settled</div>\n        <div><span class=\"dot frontier\"></span>Frontier</div>\n        <div><span class=\"dot current\"></span>Current</div>\n        <div><span class=\"dot path\"></span>Shortest Path</div>\n      </div>\n    </div>\n    <div class=\"sidebar\">\n      <div class=\"panel\">\n        <h3>Priority Queue (Unsettled)</h3>\n        <div id=\"queueView\" class=\"queue\"></div>\n      </div>\n      <div class=\"panel\">\n        <h3>Distances</h3>\n        <div id=\"distView\" class=\"dist\"></div>\n      </div>\n      <div class=\"panel\">\n        <h3>Log</h3>\n        <div id=\"logView\" class=\"log\"></div>\n      </div>\n    </div>\n    <div class=\"footnote\">\n      Tip: The algorithm stops early when the target node is settled. Without a target, it computes all shortest paths from the source.\n    </div>\n  </div>\n</div>\n\n<script>\n(function() {\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  let W = 0, H = 0;\n  function resizeCanvas() {\n    const rect = canvas.getBoundingClientRect();\n    W = Math.floor(rect.width);\n    H = Math.floor(rect.height);\n    canvas.width = W * window.devicePixelRatio;\n    canvas.height = H * window.devicePixelRatio;\n    ctx.setTransform(window.devicePixelRatio,0,0,window.devicePixelRatio,0,0);\n    draw();\n  }\n  window.addEventListener('resize', resizeCanvas);\n  resizeCanvas();\n\n  const modeBtns = {\n    select: document.getElementById('modeSelect'),\n    addNode: document.getElementById('modeAddNode'),\n    addEdge: document.getElementById('modeAddEdge'),\n    delete: document.getElementById('modeDelete')\n  };\n  const runBtn = document.getElementById('runBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const pauseBtn = document.getElementById('pauseBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const sampleBtn = document.getElementById('sampleBtn');\n  const exportBtn = document.getElementById('exportBtn');\n  const importBtn = document.getElementById('importBtn');\n  const sourceSelect = document.getElementById('sourceSelect');\n  const targetSelect = document.getElementById('targetSelect');\n  const clearTargetBtn = document.getElementById('clearTarget');\n  const speedRange = document.getElementById('speedRange');\n  const speedLabel = document.getElementById('speedLabel');\n  const queueView = document.getElementById('queueView');\n  const distView = document.getElementById('distView');\n  const logView = document.getElementById('logView');\n  const hint = document.getElementById('hint');\n\n  const state = {\n    mode: 'select',\n    graph: { nodes: [], edges: [], adjacency: new Map() },\n    nextEdgeId: 1,\n    nextNodeId: 0, // used to generate labels if needed\n    dragging: { nodeId: null, dx: 0, dy: 0 },\n    addEdgeTemp: { from: null },\n    algo: {\n      running: false,\n      timer: null,\n      speed: 350,\n      settled: new Set(),\n      dist: new Map(),\n      prev: new Map(),\n      current: null,\n      neighborQueue: [],\n      finished: false,\n      relaxingEdgeId: null,\n      source: null,\n      target: null,\n      pathEdges: new Set(),\n      stepCount: 0\n    }\n  };\n\n  // Label generator: A, B, C ... Z, A2, B2 ...\n  function nextLabel() {\n    const n = state.graph.nodes.length;\n    const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    const index = n % alphabet.length;\n    const cycle = Math.floor(n / alphabet.length);\n    return cycle === 0 ? alphabet[index] : alphabet[index] + (cycle + 1);\n  }\n\n  function addNode(x, y, label) {\n    const id = label || nextLabel();\n    state.graph.nodes.push({ id, x, y, r: 18 });\n    rebuildAdjacency();\n    refreshNodeSelects();\n    return id;\n  }\n  function addEdge(a, b, w) {\n    if (a === b) return;\n    // prevent duplicate undirected edge\n    const exists = state.graph.edges.some(e => (e.a === a && e.b === b) || (e.a === b && e.b === a));\n    if (exists) return;\n    const id = state.nextEdgeId++;\n    state.graph.edges.push({ id, a, b, w: Number(w) });\n    rebuildAdjacency();\n  }\n  function deleteNode(id) {\n    state.graph.edges = state.graph.edges.filter(e => e.a !== id && e.b !== id);\n    state.graph.nodes = state.graph.nodes.filter(n => n.id !== id);\n    rebuildAdjacency();\n    refreshNodeSelects();\n  }\n  function deleteEdgeById(id) {\n    state.graph.edges = state.graph.edges.filter(e => e.id !== id);\n    rebuildAdjacency();\n  }\n  function rebuildAdjacency() {\n    const adj = new Map();\n    state.graph.nodes.forEach(n => adj.set(n.id, []));\n    state.graph.edges.forEach(e => {\n      if (!adj.has(e.a) || !adj.has(e.b)) return;\n      adj.get(e.a).push({ to: e.b, w: e.w, edgeId: e.id });\n      adj.get(e.b).push({ to: e.a, w: e.w, edgeId: e.id });\n    });\n    state.graph.adjacency = adj;\n    draw();\n  }\n\n  function refreshNodeSelects() {\n    const nodes = state.graph.nodes.map(n => n.id);\n    const fillSelect = (sel, allowEmpty) => {\n      const prev = sel.value;\n      sel.innerHTML = '';\n      if (allowEmpty) {\n        const opt = document.createElement('option');\n        opt.value = '';\n        opt.textContent = '(none)';\n        sel.appendChild(opt);\n      }\n      nodes.forEach(id => {\n        const opt = document.createElement('option');\n        opt.value = id;\n        opt.textContent = id;\n        sel.appendChild(opt);\n      });\n      // try restore previous selection if still present\n      if (nodes.includes(prev)) sel.value = prev;\n      else sel.value = allowEmpty ? '' : (nodes[0] || '');\n    };\n    fillSelect(sourceSelect, false);\n    fillSelect(targetSelect, true);\n\n    // update algo source/target\n    state.algo.source = sourceSelect.value || null;\n    state.algo.target = targetSelect.value || null;\n    resetAlgo(false);\n  }\n\n  // Dijkstra algorithm control\n  function initAlgo() {\n    const source = sourceSelect.value;\n    if (!source || !state.graph.nodes.find(n => n.id === source)) return false;\n    state.algo.source = source;\n    state.algo.target = targetSelect.value || null;\n    state.algo.settled = new Set();\n    state.algo.dist = new Map();\n    state.algo.prev = new Map();\n    state.algo.current = null;\n    state.algo.neighborQueue = [];\n    state.algo.finished = false;\n    state.algo.relaxingEdgeId = null;\n    state.algo.pathEdges = new Set();\n    state.algo.stepCount = 0;\n    state.graph.nodes.forEach(n => {\n      state.algo.dist.set(n.id, Infinity);\n      state.algo.prev.set(n.id, null);\n    });\n    state.algo.dist.set(source, 0);\n    log(`Initialized. dist(${source}) = 0`);\n    draw();\n    updateSidebar();\n    return true;\n  }\n  function selectNextCurrent() {\n    // pick unsettled node with smallest dist\n    let best = null;\n    let bestDist = Infinity;\n    for (const n of state.graph.nodes) {\n      if (state.algo.settled.has(n.id)) continue;\n      const d = state.algo.dist.get(n.id);\n      if (d < bestDist) {\n        bestDist = d;\n        best = n.id;\n      }\n    }\n    if (best === null) {\n      state.algo.finished = true;\n      log('Finished. No reachable unsettled nodes remain.');\n      finalizePathIfPossible();\n      return false;\n    }\n    if (bestDist === Infinity) {\n      state.algo.finished = true;\n      log('Finished. Remaining unsettled nodes are unreachable (distance = ∞).');\n      finalizePathIfPossible();\n      return false;\n    }\n    state.algo.current = best;\n    const neighbors = state.graph.adjacency.get(best) || [];\n    state.algo.neighborQueue = neighbors.slice(); // shallow copy\n    state.algo.relaxingEdgeId = null;\n    log(`Select next with min distance: ${best} (d=${fmtDist(bestDist)}).`);\n    return true;\n  }\n  function stepAlgo() {\n    if (state.algo.finished) return;\n    if (!state.algo.source) {\n      alert('Select a source node first.');\n      return;\n    }\n    if (state.algo.current === null) {\n      const chosen = selectNextCurrent();\n      if (!chosen) return;\n      draw(); updateSidebar();\n      return;\n    }\n    // process one neighbor relaxation\n    if (state.algo.neighborQueue.length > 0) {\n      const nbr = state.algo.neighborQueue.shift();\n      const u = state.algo.current;\n      const v = nbr.to;\n      const w = nbr.w;\n      const du = state.algo.dist.get(u);\n      const dv = state.algo.dist.get(v);\n      const alt = du + w;\n      state.algo.relaxingEdgeId = nbr.edgeId;\n      state.algo.stepCount++;\n      if (alt < dv) {\n        state.algo.dist.set(v, alt);\n        state.algo.prev.set(v, u);\n        log(`Relax edge ${u}–${v} (w=${w}): Update dist(${v}) from ${fmtDist(dv)} to ${fmtDist(alt)}; prev(${v}) = ${u}.`);\n      } else {\n        log(`Relax edge ${u}–${v} (w=${w}): No update (current dist(${v})=${fmtDist(dv)}, alt=${fmtDist(alt)}).`);\n      }\n      draw(); updateSidebar();\n      return;\n    }\n    // neighbors exhausted: settle current\n    const justSettled = state.algo.current;\n    state.algo.settled.add(justSettled);\n    log(`Settle ${justSettled}.`);\n    // If target specified and settled, we can finish now\n    if (state.algo.target && justSettled === state.algo.target) {\n      state.algo.finished = true;\n      log(`Target ${justSettled} settled. Algorithm finished early.`);\n      finalizePathIfPossible();\n    }\n    state.algo.current = null;\n    state.algo.relaxingEdgeId = null;\n    draw(); updateSidebar();\n  }\n  function runAlgo() {\n    if (!state.algo.running) {\n      if (!state.algo.source) {\n        alert('Select a source node first.');\n        return;\n      }\n      if (state.algo.dist.size === 0 || state.algo.prev.size === 0) {\n        if (!initAlgo()) return;\n      }\n      state.algo.running = true;\n      runBtn.textContent = 'Running...';\n      runBtn.disabled = true;\n      stepBtn.disabled = true;\n      resetBtn.disabled = true;\n      pauseBtn.disabled = false;\n      state.algo.timer = setInterval(() => {\n        if (state.algo.finished) {\n          pauseAlgo();\n          runBtn.textContent = 'Run';\n          runBtn.disabled = false;\n          stepBtn.disabled = false;\n          resetBtn.disabled = false;\n          draw(); updateSidebar();\n          return;\n        }\n        stepAlgo();\n      }, Math.max(50, state.algo.speed));\n    }\n  }\n  function pauseAlgo() {\n    if (state.algo.timer) clearInterval(state.algo.timer);\n    state.algo.timer = null;\n    state.algo.running = false;\n    runBtn.textContent = 'Run';\n    runBtn.disabled = false;\n    stepBtn.disabled = false;\n    resetBtn.disabled = false;\n    pauseBtn.disabled = true;\n  }\n  function resetAlgo(fullInit = true) {\n    // Preserve graph; reset algorithm state\n    state.algo.running = false;\n    if (state.algo.timer) clearInterval(state.algo.timer);\n    state.algo.timer = null;\n    state.algo.settled = new Set();\n    state.algo.dist = new Map();\n    state.algo.prev = new Map();\n    state.algo.current = null;\n    state.algo.neighborQueue = [];\n    state.algo.finished = false;\n    state.algo.relaxingEdgeId = null;\n    state.algo.pathEdges = new Set();\n    state.algo.stepCount = 0;\n    if (fullInit && state.algo.source) {\n      initAlgo();\n    } else {\n      draw(); updateSidebar();\n    }\n    runBtn.textContent = 'Run';\n    runBtn.disabled = false;\n    stepBtn.disabled = false;\n    pauseBtn.disabled = true;\n    resetBtn.disabled = false;\n  }\n  function finalizePathIfPossible() {\n    state.algo.pathEdges.clear();\n    if (!state.algo.target || !state.algo.source) return;\n    const target = state.algo.target;\n    if (!state.graph.nodes.find(n => n.id === target)) return;\n    if (!state.algo.settled.has(target) && state.algo.dist.get(target) === Infinity) return;\n    // reconstruct path edges\n    let pathNodes = [];\n    let cur = target;\n    let guard = 0;\n    while (cur && guard++ < 1000) {\n      pathNodes.push(cur);\n      cur = state.algo.prev.get(cur);\n    }\n    pathNodes = pathNodes.reverse();\n    // mark edges in path\n    for (let i = 0; i < pathNodes.length - 1; i++) {\n      const a = pathNodes[i], b = pathNodes[i+1];\n      const edge = state.graph.edges.find(e => (e.a === a && e.b === b) || (e.a === b && e.b === a));\n      if (edge) state.algo.pathEdges.add(edge.id);\n    }\n    if (pathNodes.length > 1) {\n      log(`Shortest path ${state.algo.source} → ${state.algo.target}: ${pathNodes.join(' → ')} (length = ${fmtDist(state.algo.dist.get(target))}).`);\n    } else {\n      log(`No path from ${state.algo.source} to ${state.algo.target}.`);\n    }\n    draw(); updateSidebar();\n  }\n\n  // UI helpers\n  function fmtDist(d) { return (d === Infinity ? '∞' : (Math.round(d*100)/100)); }\n  function log(msg) {\n    const timestamp = new Date().toLocaleTimeString();\n    logView.textContent = `[${timestamp}] ${msg}\\n` + logView.textContent;\n  }\n\n  // Drawing\n  function draw() {\n    ctx.clearRect(0,0,W,H);\n    // draw edges\n    for (const e of state.graph.edges) {\n      const na = getNode(e.a), nb = getNode(e.b);\n      if (!na || !nb) continue;\n      const isPath = state.algo.pathEdges.has(e.id);\n      const isRelaxing = state.algo.relaxingEdgeId === e.id;\n      const color = isPath ? '#b37aff' : (isRelaxing ? '#ffa447' : '#7d8ea3');\n      const width = isPath ? 5 : (isRelaxing ? 3 : 2);\n      drawEdge(na, nb, color, width, e.w);\n    }\n    // draw nodes\n    for (const n of state.graph.nodes) {\n      drawNode(n);\n    }\n    // draw distance pills\n    drawDistancePills();\n  }\n  function drawEdge(na, nb, color, width, weight) {\n    const { x: x1, y: y1 } = na;\n    const { x: x2, y: y2 } = nb;\n    ctx.save();\n    ctx.lineWidth = width;\n    ctx.strokeStyle = color;\n    // Avoid edge touching node interiors for better aesthetics\n    const v = { x: x2 - x1, y: y2 - y1 };\n    const len = Math.hypot(v.x, v.y) || 1;\n    const ux = v.x / len, uy = v.y / len;\n    const r1 = na.r, r2 = nb.r;\n    const sx = x1 + ux * r1, sy = y1 + uy * r1;\n    const tx = x2 - ux * r2, ty = y2 - uy * r2;\n    ctx.beginPath();\n    ctx.moveTo(sx, sy);\n    ctx.lineTo(tx, ty);\n    ctx.stroke();\n    // weight label at midpoint\n    const mx = (sx + tx) / 2;\n    const my = (sy + ty) / 2;\n    const pad = 3;\n    const text = String(weight);\n    ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';\n    ctx.fillStyle = '#0e141a';\n    ctx.strokeStyle = '#2b394c';\n    const m = ctx.measureText(text);\n    const tw = m.width + pad*2;\n    const th = 16;\n    ctx.lineWidth = 1.25;\n    roundRect(ctx, mx - tw/2, my - th/2, tw, th, 4);\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#c9d7e3';\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = 'center';\n    ctx.fillText(text, mx, my);\n    ctx.restore();\n  }\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x+r, y);\n    ctx.arcTo(x+w, y, x+w, y+h, r);\n    ctx.arcTo(x+w, y+h, x, y+h, r);\n    ctx.arcTo(x, y+h, x, y, r);\n    ctx.arcTo(x, y, x+w, y, r);\n    ctx.closePath();\n  }\n  function drawNode(n) {\n    const isSource = (n.id === state.algo.source);\n    const isCurrent = (n.id === state.algo.current);\n    const settled = state.algo.settled.has(n.id);\n    const frontier = (!settled && state.algo.dist.get(n.id) !== undefined && state.algo.dist.get(n.id) !== Infinity);\n    const base = '#e6edf3';\n    let fill = '#1a2430', stroke = '#2b3c51';\n    if (isCurrent) { fill = '#321a1d'; stroke = '#ff6b6b'; }\n    else if (settled) { fill = '#15261a'; stroke = '#64d36d'; }\n    else if (isSource) { fill = '#152135'; stroke = '#3ca3ff'; }\n    else if (frontier) { fill = '#2b2512'; stroke = '#ffce57'; }\n\n    ctx.save();\n    ctx.lineWidth = 2;\n    ctx.fillStyle = fill;\n    ctx.strokeStyle = stroke;\n    ctx.beginPath();\n    ctx.arc(n.x, n.y, n.r, 0, Math.PI*2);\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.font = '13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';\n    ctx.fillStyle = base;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(n.id, n.x, n.y);\n    ctx.restore();\n  }\n\n  function drawDistancePills() {\n    // Clear existing pills\n    document.querySelectorAll('.value-pill').forEach(el => el.remove());\n    for (const n of state.graph.nodes) {\n      const d = state.algo.dist.get(n.id);\n      if (d === undefined) continue;\n      const pill = document.createElement('div');\n      pill.className = 'value-pill';\n      pill.textContent = 'd=' + fmtDist(d);\n      pill.style.left = n.x + 'px';\n      pill.style.top = (n.y - n.r - 6) + 'px';\n      canvas.parentElement.appendChild(pill);\n      // Remove pill before next draw frame\n      setTimeout(() => pill.remove(), 0);\n    }\n  }\n\n  function getNode(id) {\n    return state.graph.nodes.find(n => n.id === id);\n  }\n\n  // Sidebar views\n  function updateSidebar() {\n    // Queue: unsettled nodes sorted by distance\n    const unsettled = state.graph.nodes\n      .filter(n => !state.algo.settled.has(n.id))\n      .map(n => ({ id: n.id, d: state.algo.dist.get(n.id) ?? Infinity }))\n      .sort((a, b) => (a.d === b.d) ? a.id.localeCompare(b.id) : a.d - b.d);\n    queueView.textContent = unsettled.map(({id, d}) => `${id.padEnd(3)}  d=${fmtDist(d)}`).join('\\n');\n\n    // Distances and predecessors\n    const lines = state.graph.nodes.map(n => {\n      const d = state.algo.dist.get(n.id);\n      const p = state.algo.prev.get(n.id);\n      return `${n.id.padEnd(3)}  dist=${fmtDist(d)}  prev=${p ?? '∅'}`;\n    });\n    distView.textContent = lines.join('\\n');\n  }\n\n  // Interaction\n  function setMode(next) {\n    state.mode = next;\n    for (const [k, btn] of Object.entries(modeBtns)) {\n      btn.classList.toggle('active', k === next);\n    }\n    hint.textContent = (\n      next === 'select' ? 'Drag nodes to rearrange. Click a node to select.' :\n      next === 'addNode' ? 'Click anywhere on the canvas to add a node.' :\n      next === 'addEdge' ? 'Click first node, then second node. Enter non-negative weight.' :\n      next === 'delete' ? 'Click a node or edge to delete it.' : ''\n    );\n  }\n  modeBtns.select.addEventListener('click', () => setMode('select'));\n  modeBtns.addNode.addEventListener('click', () => setMode('addNode'));\n  modeBtns.addEdge.addEventListener('click', () => setMode('addEdge'));\n  modeBtns.delete.addEventListener('click', () => setMode('delete'));\n\n  // Mouse utils\n  function nodeAt(x, y) {\n    for (let i = state.graph.nodes.length - 1; i >= 0; i--) {\n      const n = state.graph.nodes[i];\n      if (Math.hypot(n.x - x, n.y - y) <= n.r + 2) return n;\n    }\n    return null;\n  }\n  function edgeAt(x, y, tol = 6) {\n    const hitEdges = [];\n    for (const e of state.graph.edges) {\n      const na = getNode(e.a), nb = getNode(e.b);\n      if (!na || !nb) continue;\n      const p = {x, y};\n      const d = distToSegment(p, na, nb);\n      if (d <= tol) hitEdges.push(e);\n    }\n    return hitEdges[0] || null;\n  }\n  function distToSegment(p, a, b) {\n    const vx = b.x - a.x, vy = b.y - a.y;\n    const wx = p.x - a.x, wy = p.y - a.y;\n    const c1 = vx*wx + vy*wy;\n    if (c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);\n    const c2 = vx*vx + vy*vy;\n    if (c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);\n    const t = c1 / c2;\n    const projx = a.x + t * vx, projy = a.y + t * vy;\n    return Math.hypot(p.x - projx, p.y - projy);\n  }\n\n  canvas.addEventListener('mousedown', (ev) => {\n    const pos = getMousePos(ev);\n    if (state.mode === 'select') {\n      const n = nodeAt(pos.x, pos.y);\n      if (n) {\n        state.dragging.nodeId = n.id;\n        state.dragging.dx = pos.x - n.x;\n        state.dragging.dy = pos.y - n.y;\n      }\n    }\n  });\n  canvas.addEventListener('mousemove', (ev) => {\n    const pos = getMousePos(ev);\n    if (state.dragging.nodeId) {\n      const n = getNode(state.dragging.nodeId);\n      if (n) {\n        n.x = clamp(pos.x - state.dragging.dx, 20, W - 20);\n        n.y = clamp(pos.y - state.dragging.dy, 20, H - 20);\n        rebuildAdjacency();\n      }\n    }\n  });\n  canvas.addEventListener('mouseup', () => {\n    state.dragging.nodeId = null;\n  });\n  canvas.addEventListener('mouseleave', () => {\n    state.dragging.nodeId = null;\n  });\n  canvas.addEventListener('click', (ev) => {\n    const pos = getMousePos(ev);\n    if (state.mode === 'addNode') {\n      const id = addNode(pos.x, pos.y);\n      log(`Added node ${id} at (${Math.round(pos.x)}, ${Math.round(pos.y)}).`);\n      draw(); updateSidebar();\n    } else if (state.mode === 'addEdge') {\n      const n = nodeAt(pos.x, pos.y);\n      if (!n) return;\n      if (!state.addEdgeTemp.from) {\n        state.addEdgeTemp.from = n.id;\n        log(`Selected first node ${n.id}. Choose second node.`);\n      } else {\n        const a = state.addEdgeTemp.from, b = n.id;\n        if (a === b) {\n          log('Cannot connect a node to itself.');\n          state.addEdgeTemp.from = null;\n          return;\n        }\n        let w = prompt(`Enter non-negative weight for edge ${a}–${b}:`, '1');\n        if (w === null) { state.addEdgeTemp.from = null; return; }\n        w = Number(w);\n        if (isNaN(w) || w < 0) {\n          alert('Weight must be a non-negative number.');\n          state.addEdgeTemp.from = null;\n          return;\n        }\n        addEdge(a, b, w);\n        state.addEdgeTemp.from = null;\n        log(`Added edge ${a}–${b} with weight ${w}.`);\n        draw(); updateSidebar();\n      }\n    } else if (state.mode === 'delete') {\n      const n = nodeAt(pos.x, pos.y);\n      if (n) {\n        deleteNode(n.id);\n        log(`Deleted node ${n.id} and its edges.`);\n        draw(); updateSidebar();\n        return;\n      }\n      const e = edgeAt(pos.x, pos.y);\n      if (e) {\n        deleteEdgeById(e.id);\n        log(`Deleted edge ${e.a}–${e.b}.`);\n        draw(); updateSidebar();\n      }\n    }\n  });\n\n  function getMousePos(ev) {\n    const rect = canvas.getBoundingClientRect();\n    return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };\n  }\n  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }\n\n  // Controls\n  runBtn.addEventListener('click', () => {\n    // initialize if needed\n    if (state.algo.dist.size === 0) {\n      if (!initAlgo()) {\n        alert('Add nodes and select a source node.');\n        return;\n      }\n    }\n    runAlgo();\n  });\n  pauseBtn.addEventListener('click', () => pauseAlgo());\n  stepBtn.addEventListener('click', () => {\n    if (state.algo.dist.size === 0) {\n      if (!initAlgo()) {\n        alert('Add nodes and select a source node.');\n        return;\n      }\n    }\n    stepAlgo();\n  });\n  resetBtn.addEventListener('click', () => resetAlgo(true));\n\n  speedRange.addEventListener('input', () => {\n    state.algo.speed = Number(speedRange.value);\n    speedLabel.textContent = `${state.algo.speed} ms`;\n    if (state.algo.running) {\n      pauseAlgo();\n      runAlgo();\n    }\n  });\n\n  sourceSelect.addEventListener('change', () => {\n    state.algo.source = sourceSelect.value || null;\n    resetAlgo(true);\n    draw(); updateSidebar();\n  });\n  targetSelect.addEventListener('change', () => {\n    state.algo.target = targetSelect.value || null;\n    finalizePathIfPossible();\n  });\n  clearTargetBtn.addEventListener('click', () => {\n    targetSelect.value = '';\n    state.algo.target = null;\n    state.algo.pathEdges.clear();\n    draw(); updateSidebar();\n  });\n\n  randomBtn.addEventListener('click', () => {\n    randomGraph();\n    log('Generated random graph.');\n    refreshNodeSelects();\n    resetAlgo(true);\n  });\n  clearBtn.addEventListener('click', () => {\n    if (!confirm('Clear all nodes and edges?')) return;\n    state.graph.nodes = [];\n    state.graph.edges = [];\n    state.nextEdgeId = 1;\n    rebuildAdjacency();\n    refreshNodeSelects();\n    resetAlgo(false);\n    log('Cleared graph.');\n  });\n  sampleBtn.addEventListener('click', () => {\n    loadSampleGraph();\n    log('Loaded sample graph.');\n    refreshNodeSelects();\n    resetAlgo(true);\n  });\n\n  exportBtn.addEventListener('click', () => {\n    const data = JSON.stringify({ nodes: state.graph.nodes, edges: state.graph.edges }, null, 2);\n    const blob = new Blob([data], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = 'graph.json';\n    a.click();\n    URL.revokeObjectURL(url);\n  });\n  importBtn.addEventListener('click', async () => {\n    const input = document.createElement('input');\n    input.type = 'file';\n    input.accept = 'application/json';\n    input.onchange = async () => {\n      const file = input.files[0];\n      if (!file) return;\n      const text = await file.text();\n      try {\n        const obj = JSON.parse(text);\n        if (!Array.isArray(obj.nodes) || !Array.isArray(obj.edges)) throw new Error('Invalid format');\n        state.graph.nodes = obj.nodes.map(n => ({ id: n.id, x: n.x, y: n.y, r: 18 }));\n        state.graph.edges = obj.edges.map(e => ({ id: e.id, a: e.a, b: e.b, w: e.w }));\n        state.nextEdgeId = (state.graph.edges.reduce((m, e) => Math.max(m, e.id), 0) || 0) + 1;\n        rebuildAdjacency();\n        refreshNodeSelects();\n        resetAlgo(true);\n        log('Imported graph from JSON.');\n      } catch (err) {\n        alert('Failed to import JSON: ' + err.message);\n      }\n    };\n    input.click();\n  });\n\n  // Sample and random graph builders\n  function loadSampleGraph() {\n    const cx = W/2, cy = H/2;\n    const radius = Math.min(W, H) * 0.35;\n    const labels = ['A','B','C','D','E','F','G','H'];\n    state.graph.nodes = labels.map((id, i) => {\n      const ang = (i / labels.length) * Math.PI * 2;\n      return { id, x: cx + radius * Math.cos(ang), y: cy + radius * Math.sin(ang), r: 18 };\n    });\n    const E = [];\n    const w = (a,b,c)=>E.push({a,b,w:c});\n    w('A','B',4); w('A','C',2);\n    w('B','C',1); w('B','D',5); w('B','E',3);\n    w('C','D',8); w('C','E',10);\n    w('D','E',2); w('D','F',6);\n    w('E','F',3); w('E','G',4);\n    w('F','G',1); w('F','H',7);\n    w('G','H',2);\n    state.graph.edges = E.map((e,i)=>({ id: i+1, ...e }));\n    state.nextEdgeId = state.graph.edges.length + 1;\n    rebuildAdjacency();\n    // Default source/target\n    sourceSelect.value = 'A';\n    targetSelect.value = 'H';\n    state.algo.source = 'A';\n    state.algo.target = 'H';\n  }\n\n  function randomGraph(n = 7) {\n    // clear\n    state.graph.nodes = [];\n    state.graph.edges = [];\n    state.nextEdgeId = 1;\n    // place nodes with padding\n    const padX = 40, padY = 40;\n    for (let i = 0; i < n; i++) {\n      const x = padX + Math.random() * (W - padX*2);\n      const y = padY + Math.random() * (H - padY*2 - 140); // avoid controls area\n      addNode(x, y, nextLabel());\n    }\n    // connect: ensure connected by building a random tree first\n    const ids = state.graph.nodes.map(n => n.id);\n    const shuffled = ids.slice().sort(()=>Math.random()-0.5);\n    for (let i = 1; i < shuffled.length; i++) {\n      const a = shuffled[i];\n      const b = shuffled[Math.floor(Math.random() * i)];\n      addEdge(a, b, 1 + Math.floor(Math.random()*9));\n    }\n    // add some extra edges\n    let extra = Math.floor(n * 1.2);\n    while (extra-- > 0) {\n      const a = ids[Math.floor(Math.random()*ids.length)];\n      const b = ids[Math.floor(Math.random()*ids.length)];\n      if (a === b) continue;\n      const exists = state.graph.edges.some(e => (e.a===a && e.b===b) || (e.a===b && e.b===a));\n      if (exists) continue;\n      addEdge(a, b, 1 + Math.floor(Math.random()*9));\n    }\n    rebuildAdjacency();\n    sourceSelect.value = ids[0];\n    targetSelect.value = ids[ids.length-1];\n    state.algo.source = sourceSelect.value;\n    state.algo.target = targetSelect.value;\n  }\n\n  // Initialize with sample\n  loadSampleGraph();\n  refreshNodeSelects();\n  resetAlgo(true);\n\n  // Utility for keyboard shortcuts\n  window.addEventListener('keydown', (e) => {\n    if (e.key === ' ') { e.preventDefault(); if (state.algo.running) pauseAlgo(); else runAlgo(); }\n    if (e.key.toLowerCase() === 'r') { resetAlgo(true); }\n    if (e.key.toLowerCase() === 's') { stepAlgo(); }\n    if (e.key.toLowerCase() === 'a') { setMode('addNode'); }\n    if (e.key.toLowerCase() === 'e') { setMode('addEdge'); }\n    if (e.key.toLowerCase() === 'm') { setMode('select'); }\n    if (e.key.toLowerCase() === 'd') { setMode('delete'); }\n  });\n\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Dijkstra’s Algorithm"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "4c352740-a36d-11f0-953b-21b015f79743",
    "timestamp": "2025-10-07T11:03:47.380Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Bellman-Ford Algorithm",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<title>Bellman-Ford Algorithm Visualizer</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --accent: #38bdf8;\n    --accent2: #22c55e;\n    --warn: #f59e0b;\n    --danger: #ef4444;\n    --text: #e5e7eb;\n    --muted: #9ca3af;\n  }\n  * { box-sizing: border-box; }\n  body {\n    margin: 0;\n    background: linear-gradient(180deg, #0b1225, #0f172a);\n    color: var(--text);\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, \"Helvetica Neue\", Arial;\n    overflow: hidden;\n  }\n  header {\n    padding: 12px 16px;\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    border-bottom: 1px solid #1f2937;\n    background: rgba(17, 24, 39, 0.5);\n    backdrop-filter: blur(6px);\n  }\n  header h1 {\n    margin: 0;\n    font-size: 18px;\n    font-weight: 600;\n    letter-spacing: 0.2px;\n  }\n  .container {\n    display: grid;\n    grid-template-columns: minmax(500px, 1fr) 420px;\n    height: calc(100vh - 56px);\n  }\n  .left {\n    position: relative;\n  }\n  canvas {\n    width: 100%;\n    height: 100%;\n    display: block;\n    background:\n      radial-gradient(ellipse at center, rgba(56, 189, 248, 0.04) 0%, rgba(0,0,0,0) 60%),\n      linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n    cursor: default;\n  }\n  .right {\n    border-left: 1px solid #1f2937;\n    background: rgba(17, 24, 39, 0.6);\n    backdrop-filter: blur(6px);\n    padding: 12px;\n    overflow: auto;\n  }\n  .section {\n    border: 1px solid #1f2937;\n    border-radius: 10px;\n    padding: 10px;\n    margin-bottom: 10px;\n    background: #0b1324;\n  }\n  .section h2 {\n    font-size: 15px;\n    margin: 0 0 8px;\n    color: #cbd5e1;\n  }\n  .row {\n    display: flex;\n    gap: 8px;\n    flex-wrap: wrap;\n    align-items: center;\n    margin: 6px 0;\n  }\n  button, select, input[type=\"number\"], input[type=\"text\"] {\n    background: #0b1427;\n    border: 1px solid #1f2937;\n    color: var(--text);\n    border-radius: 8px;\n    padding: 8px 10px;\n    font-size: 13px;\n    outline: none;\n  }\n  button {\n    cursor: pointer;\n  }\n  button.primary {\n    background: #0b1c36;\n    border-color: #0ea5e9;\n    color: #93c5fd;\n  }\n  button.green {\n    background: #0b1c32;\n    border-color: #22c55e;\n    color: #a7f3d0;\n  }\n  button.orange {\n    background: #1b160b;\n    border-color: #f59e0b;\n    color: #fde68a;\n  }\n  button.red {\n    background: #1b0b0b;\n    border-color: #ef4444;\n    color: #fecaca;\n  }\n  button:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n  }\n  .tiny {\n    font-size: 12px;\n    color: var(--muted);\n    margin-top: 4px;\n  }\n  .table {\n    width: 100%;\n    border: 1px solid #1f2937;\n    border-radius: 8px;\n    overflow: hidden;\n  }\n  .table .thead, .table .rowdata {\n    display: grid;\n    grid-template-columns: 1fr 1fr 1fr;\n  }\n  .table .thead {\n    background: #0f192f;\n    font-weight: 600;\n    color: #cbd5e1;\n    padding: 8px;\n    border-bottom: 1px solid #1f2937;\n  }\n  .table .rowdata {\n    padding: 8px;\n    border-bottom: 1px solid #1f2937;\n  }\n  .table .rowdata.changed {\n    background: rgba(34, 197, 94, 0.1);\n  }\n  .log {\n    height: 180px;\n    overflow: auto;\n    border: 1px solid #1f2937;\n    border-radius: 8px;\n    padding: 8px;\n    background: #0b1324;\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", monospace;\n    font-size: 12px;\n    line-height: 1.4;\n  }\n  .badge {\n    display: inline-block;\n    padding: 2px 6px;\n    border-radius: 999px;\n    font-size: 11px;\n    border: 1px solid #334155;\n    color: #cbd5e1;\n    background: #0f192f;\n    margin-right: 6px;\n  }\n  .legend {\n    display: flex;\n    gap: 6px;\n    flex-wrap: wrap;\n  }\n  .legend .item {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-size: 12px;\n    color: var(--muted);\n  }\n  .legend .swatch {\n    width: 20px;\n    height: 6px;\n    border-radius: 3px;\n  }\n  .swatch.edge { background: #63728b; }\n  .swatch.relax { background: #f59e0b; }\n  .swatch.pred { background: #22c55e; }\n  .swatch.cycle { background: #ef4444; }\n  .help {\n    font-size: 12px;\n    color: #94a3b8;\n    line-height: 1.45;\n  }\n  .kbd {\n    display: inline-block;\n    border: 1px solid #334155;\n    background: #0f192f;\n    border-radius: 6px;\n    padding: 2px 6px;\n    font-size: 11px;\n    color: #cbd5e1;\n    margin: 0 2px;\n  }\n  .flex-grow { flex: 1; }\n  .status {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 6px;\n    align-items: center;\n  }\n  .status .value {\n    font-weight: 600;\n    color: #e2e8f0;\n  }\n  .hr {\n    height: 1px;\n    background: #1f2937;\n    margin: 8px 0;\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Bellman-Ford Algorithm Visualizer</h1>\n  <span class=\"badge\">Directed graph</span>\n  <span class=\"badge\">Supports negative weights</span>\n  <span class=\"badge\">Detects negative cycles</span>\n</header>\n<div class=\"container\">\n  <div class=\"left\">\n    <canvas id=\"canvas\"></canvas>\n  </div>\n  <div class=\"right\">\n    <div class=\"section\">\n      <h2>Build Graph</h2>\n      <div class=\"row\">\n        <button id=\"modeMove\" class=\"primary\">Select/Move</button>\n        <button id=\"modeAddNode\">Add Node</button>\n        <button id=\"modeAddEdge\">Add Edge</button>\n        <button id=\"deleteSelected\" class=\"red\">Delete Selected</button>\n        <button id=\"clearGraph\" class=\"red\">Clear Graph</button>\n      </div>\n      <div class=\"row\">\n        <div class=\"flex-grow help\">\n          - Click canvas in \"Add Node\" mode to place a node. Drag nodes in \"Select/Move\" mode.\n          - In \"Add Edge\" mode: click source node, then target node; set weight (negative allowed).\n        </div>\n      </div>\n      <div class=\"hr\"></div>\n      <div class=\"row\">\n        <button id=\"example1\" class=\"green\">Load Example: No Negative Cycle</button>\n        <button id=\"example2\" class=\"orange\">Load Example: Negative Cycle</button>\n        <button id=\"example3\">Load Small Random</button>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <h2>Run Bellman-Ford</h2>\n      <div class=\"row\">\n        <label for=\"sourceSelect\">Source:</label>\n        <select id=\"sourceSelect\"></select>\n        <button id=\"initBF\" class=\"primary\">Initialize</button>\n        <button id=\"resetBF\">Reset</button>\n      </div>\n      <div class=\"row\">\n        <button id=\"stepBtn\">Next Relaxation</button>\n        <button id=\"nextIterBtn\">Next Iteration</button>\n        <button id=\"runAllBtn\" class=\"green\">Run to Completion</button>\n        <button id=\"autoBtn\">Auto-run</button>\n        <label>Speed:<input id=\"speedRange\" type=\"range\" min=\"10\" max=\"500\" value=\"120\" /></label>\n      </div>\n      <div class=\"row status\">\n        <span>Iterations:</span> <span id=\"iterVal\" class=\"value\">0</span> / <span id=\"iterMax\" class=\"value\">0</span>\n        <span>Edges this iteration:</span> <span id=\"edgeIdx\" class=\"value\">0</span> / <span id=\"edgeMax\" class=\"value\">0</span>\n        <span>Negative Cycle:</span> <span id=\"negStatus\" class=\"value\">unknown</span>\n      </div>\n      <div class=\"legend\" style=\"margin-top:8px;\">\n        <div class=\"item\"><span class=\"swatch edge\"></span>Edge</div>\n        <div class=\"item\"><span class=\"swatch relax\"></span>Last relaxed</div>\n        <div class=\"item\"><span class=\"swatch pred\"></span>Predecessor edges</div>\n        <div class=\"item\"><span class=\"swatch cycle\"></span>Negative cycle</div>\n      </div>\n      <div class=\"tiny\">Bellman-Ford does V-1 iterations of relaxing all edges. One extra pass checks for a negative-weight cycle.</div>\n    </div>\n\n    <div class=\"section\">\n      <h2>Distances</h2>\n      <div id=\"distTable\" class=\"table\">\n        <div class=\"thead\"><div>Node</div><div>Distance</div><div>Predecessor</div></div>\n        <div id=\"distRows\"></div>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <h2>Log</h2>\n      <div id=\"log\" class=\"log\"></div>\n    </div>\n\n    <div class=\"section\">\n      <h2>Tips</h2>\n      <div class=\"help\">\n        - If any distance still improves after V-1 iterations, the graph has a negative-weight cycle reachable from the source.<br>\n        - Relaxation tries to improve dist[to] with dist[from] + weight.<br>\n        - You can edit an edge's weight by selecting it and pressing <span class=\"kbd\">E</span>, or delete with <span class=\"kbd\">Delete</span>.\n      </div>\n    </div>\n  </div>\n</div>\n\n<script>\n(function() {\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n\n  // Resize canvas to device pixels\n  function resizeCanvas() {\n    const rect = canvas.getBoundingClientRect();\n    const dpr = Math.max(1, window.devicePixelRatio || 1);\n    canvas.width = Math.floor(rect.width * dpr);\n    canvas.height = Math.floor(rect.height * dpr);\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    draw();\n  }\n  window.addEventListener('resize', resizeCanvas);\n  resizeCanvas();\n\n  // Graph state\n  let nodes = []; // {id, x, y}\n  let edges = []; // {id, from, to, weight}\n  let nextNodeId = 0;\n  let nextEdgeId = 0;\n\n  // UI modes\n  const Mode = { Move: 'move', AddNode: 'addNode', AddEdge: 'addEdge' };\n  let mode = Mode.Move;\n  let selectedNodeId = null;\n  let selectedEdgeId = null;\n  let draggingNodeId = null;\n  let dragOffset = {x:0, y:0};\n  let pendingEdge = { from: null, to: null };\n  let hoverNodeId = null;\n  let hoverEdgeId = null;\n\n  // Algorithm state\n  let bf = {\n    running: false,\n    source: null,\n    dist: [],\n    prev: [],\n    iter: 0,\n    edgeIdx: 0,\n    iterMax: 0,\n    lastRelaxedEdge: null,\n    changedInIter: new Set(),\n    doneRelaxations: false,\n    negativeCycle: null,\n    cycleVertices: [],\n    cycleEdges: new Set(),\n    autoTimer: null\n  };\n\n  // DOM elements\n  const modeMoveBtn = document.getElementById('modeMove');\n  const modeAddNodeBtn = document.getElementById('modeAddNode');\n  const modeAddEdgeBtn = document.getElementById('modeAddEdge');\n  const deleteSelBtn = document.getElementById('deleteSelected');\n  const clearGraphBtn = document.getElementById('clearGraph');\n\n  const example1Btn = document.getElementById('example1');\n  const example2Btn = document.getElementById('example2');\n  const example3Btn = document.getElementById('example3');\n\n  const sourceSelect = document.getElementById('sourceSelect');\n  const initBFBtn = document.getElementById('initBF');\n  const resetBFBtn = document.getElementById('resetBF');\n\n  const stepBtn = document.getElementById('stepBtn');\n  const nextIterBtn = document.getElementById('nextIterBtn');\n  const runAllBtn = document.getElementById('runAllBtn');\n  const autoBtn = document.getElementById('autoBtn');\n  const speedRange = document.getElementById('speedRange');\n\n  const distRows = document.getElementById('distRows');\n  const logEl = document.getElementById('log');\n  const iterValEl = document.getElementById('iterVal');\n  const iterMaxEl = document.getElementById('iterMax');\n  const edgeIdxEl = document.getElementById('edgeIdx');\n  const edgeMaxEl = document.getElementById('edgeMax');\n  const negStatusEl = document.getElementById('negStatus');\n\n  // Helpers\n  function addLog(msg) {\n    const time = new Date().toLocaleTimeString();\n    const line = document.createElement('div');\n    line.textContent = `[${time}] ${msg}`;\n    logEl.appendChild(line);\n    logEl.scrollTop = logEl.scrollHeight;\n    // Cap log length\n    const maxLines = 400;\n    while (logEl.childNodes.length > maxLines) {\n      logEl.removeChild(logEl.firstChild);\n    }\n  }\n\n  function formatDist(d) {\n    if (d === Infinity) return '∞';\n    return Number.isFinite(d) ? d : '∞';\n  }\n\n  function nodeLabel(id) {\n    // Use 0..9 A..Z fallback\n    return String(id);\n  }\n\n  function rebuildSourceSelect() {\n    sourceSelect.innerHTML = '';\n    nodes.forEach(n => {\n      const opt = document.createElement('option');\n      opt.value = String(n.id);\n      opt.textContent = nodeLabel(n.id);\n      sourceSelect.appendChild(opt);\n    });\n    if (bf.source != null) {\n      sourceSelect.value = String(bf.source);\n    }\n  }\n\n  function resetSelection() {\n    selectedNodeId = null;\n    selectedEdgeId = null;\n    pendingEdge.from = null;\n    pendingEdge.to = null;\n  }\n\n  function clearGraph() {\n    nodes = [];\n    edges = [];\n    nextNodeId = 0;\n    nextEdgeId = 0;\n    stopAuto();\n    resetBF();\n    resetSelection();\n    rebuildSourceSelect();\n    addLog('Graph cleared.');\n    draw();\n    renderDistTable();\n  }\n\n  function deleteSelected() {\n    if (selectedNodeId != null) {\n      const nid = selectedNodeId;\n      nodes = nodes.filter(n => n.id !== nid);\n      edges = edges.filter(e => e.from !== nid && e.to !== nid);\n      stopAuto();\n      resetBF();\n      addLog(`Deleted node ${nodeLabel(nid)} and its edges.`);\n      selectedNodeId = null;\n      rebuildSourceSelect();\n      draw();\n      renderDistTable();\n      return;\n    }\n    if (selectedEdgeId != null) {\n      const eid = selectedEdgeId;\n      edges = edges.filter(e => e.id !== eid);\n      stopAuto();\n      resetBF();\n      addLog(`Deleted edge ${eid}.`);\n      selectedEdgeId = null;\n      draw();\n      renderDistTable();\n      return;\n    }\n    addLog('Nothing selected to delete.');\n  }\n\n  function setMode(m) {\n    mode = m;\n    modeMoveBtn.classList.toggle('primary', mode === Mode.Move);\n    modeAddNodeBtn.classList.toggle('primary', mode === Mode.AddNode);\n    modeAddEdgeBtn.classList.toggle('primary', mode === Mode.AddEdge);\n    resetSelection();\n    draw();\n  }\n\n  // Canvas interaction\n  function distanceSquared(x1, y1, x2, y2) {\n    const dx = x1 - x2, dy = y1 - y2;\n    return dx*dx + dy*dy;\n  }\n\n  function findNodeAt(x, y) {\n    const r = 18;\n    let best = null, bestD = Infinity;\n    for (const n of nodes) {\n      const d = distanceSquared(x, y, n.x, n.y);\n      if (d <= r*r && d < bestD) {\n        best = n;\n        bestD = d;\n      }\n    }\n    return best;\n  }\n\n  function pointSegmentDistance(px, py, x1, y1, x2, y2) {\n    // Distance from point P to segment AB\n    const vx = x2 - x1, vy = y2 - y1;\n    const wx = px - x1, wy = py - y1;\n    const c1 = vx*wx + vy*wy;\n    if (c1 <= 0) return Math.hypot(px - x1, py - y1);\n    const c2 = vx*vx + vy*vy;\n    if (c2 <= c1) return Math.hypot(px - x2, py - y2);\n    const b = c1 / c2;\n    const bx = x1 + b*vx, by = y1 + b*vy;\n    return Math.hypot(px - bx, py - by);\n  }\n\n  function findEdgeAt(x, y) {\n    const thresh = 6;\n    let best = null, bestD = Infinity;\n    for (const e of edges) {\n      const a = nodeById(e.from);\n      const b = nodeById(e.to);\n      if (!a || !b) continue;\n      const d = pointSegmentDistance(x, y, a.x, a.y, b.x, b.y);\n      if (d < thresh && d < bestD) {\n        best = e;\n        bestD = d;\n      }\n    }\n    return best;\n  }\n\n  function nodeById(id) {\n    return nodes.find(n => n.id === id) || null;\n  }\n\n  function edgeById(id) {\n    return edges.find(e => e.id === id) || null;\n  }\n\n  function createNode(x, y) {\n    const id = nextNodeId++;\n    nodes.push({ id, x, y });\n    rebuildSourceSelect();\n    addLog(`Added node ${nodeLabel(id)} at (${Math.round(x)}, ${Math.round(y)}).`);\n    draw();\n    return id;\n  }\n\n  function createEdge(from, to, weight) {\n    const id = nextEdgeId++;\n    edges.push({ id, from, to, weight });\n    addLog(`Added edge ${nodeLabel(from)} → ${nodeLabel(to)} with weight ${weight}.`);\n    draw();\n    return id;\n  }\n\n  // Edge weight prompt UI\n  function promptEdgeWeight(defaultVal = 1) {\n    let w = prompt(\"Enter edge weight (negative allowed):\", String(defaultVal));\n    if (w == null) return null;\n    w = w.trim();\n    if (!w) return null;\n    const val = Number(w);\n    if (!Number.isFinite(val)) {\n      alert(\"Invalid weight.\");\n      return null;\n    }\n    return val;\n  }\n\n  // Drawing\n  function draw() {\n    const w = canvas.clientWidth;\n    const h = canvas.clientHeight;\n    ctx.clearRect(0, 0, w, h);\n\n    // Draw edges\n    for (const e of edges) {\n      const a = nodeById(e.from);\n      const b = nodeById(e.to);\n      if (!a || !b) continue;\n      let color = '#63728b';\n      let width = 2;\n\n      if (bf.cycleEdges.has(e.id)) {\n        color = '#ef4444';\n        width = 3.5;\n      } else if (bf.lastRelaxedEdge === e.id) {\n        color = '#f59e0b';\n        width = 3.5;\n      } else if (bf.running && bf.prev[e.to] === e.from) {\n        color = '#22c55e';\n        width = 3;\n      }\n\n      if (selectedEdgeId === e.id) {\n        width += 1.2;\n      }\n\n      drawArrow(a.x, a.y, b.x, b.y, color, width);\n\n      // Edge weight label\n      const midx = (a.x + b.x)/2;\n      const midy = (a.y + b.y)/2;\n      const nx = b.x - a.x, ny = b.y - a.y;\n      const len = Math.max(1, Math.hypot(nx, ny));\n      const ox = -ny / len * 12, oy = nx / len * 12; // normal offset\n      const text = String(e.weight);\n      drawLabel(midx + ox, midy + oy, text, color);\n    }\n\n    // Pending edge temp line\n    if (mode === Mode.AddEdge && pendingEdge.from != null && hoverNodeId != null) {\n      const a = nodeById(pendingEdge.from);\n      const b = nodeById(hoverNodeId);\n      if (a && b) {\n        drawArrow(a.x, a.y, b.x, b.y, '#f59e0b', 1.5, true);\n      }\n    }\n\n    // Draw nodes\n    for (const n of nodes) {\n      drawNode(n);\n    }\n  }\n\n  function drawNode(n) {\n    const r = 16;\n    const isSelected = selectedNodeId === n.id;\n    const isHover = hoverNodeId === n.id;\n    ctx.save();\n    ctx.beginPath();\n    ctx.arc(n.x, n.y, r, 0, Math.PI*2);\n    const grad = ctx.createRadialGradient(n.x, n.y, 3, n.x, n.y, r);\n    grad.addColorStop(0, '#11366b');\n    grad.addColorStop(1, '#0b162b');\n    ctx.fillStyle = grad;\n    ctx.fill();\n\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = isSelected ? '#f59e0b' : (isHover ? '#38bdf8' : '#1f2937');\n    ctx.stroke();\n\n    // Label\n    ctx.fillStyle = '#cbd5e1';\n    ctx.font = '12px system-ui';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(nodeLabel(n.id), n.x, n.y);\n    ctx.restore();\n  }\n\n  function drawArrow(x1,y1,x2,y2,color='#63728b',width=2, dashed=false) {\n    ctx.save();\n    ctx.lineWidth = width;\n    ctx.strokeStyle = color;\n    if (dashed) ctx.setLineDash([6, 6]);\n\n    // Shorten to avoid overlapping node circles\n    const r = 16;\n    const vx = x2 - x1, vy = y2 - y1;\n    const L = Math.hypot(vx, vy);\n    if (L < 1) { ctx.restore(); return; }\n    const ux = vx / L, uy = vy / L;\n    const ax = x1 + ux * r;\n    const ay = y1 + uy * r;\n    const bx = x2 - ux * (r + 6);\n    const by = y2 - uy * (r + 6);\n\n    ctx.beginPath();\n    ctx.moveTo(ax, ay);\n    ctx.lineTo(bx, by);\n    ctx.stroke();\n\n    // Arrowhead\n    const size = 8;\n    const angle = Math.atan2(vy, vx);\n    const hx = x2 - ux * r;\n    const hy = y2 - uy * r;\n    ctx.beginPath();\n    ctx.moveTo(hx, hy);\n    ctx.lineTo(hx - size * Math.cos(angle - Math.PI/6), hy - size * Math.sin(angle - Math.PI/6));\n    ctx.lineTo(hx - size * Math.cos(angle + Math.PI/6), hy - size * Math.sin(angle + Math.PI/6));\n    ctx.closePath();\n    ctx.fillStyle = color;\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  function drawLabel(x, y, text, color='#94a3b8') {\n    ctx.save();\n    ctx.font = '11px ui-monospace';\n    const metrics = ctx.measureText(text);\n    const pad = 4;\n    const w = metrics.width + pad*2;\n    const h = 13 + pad*2;\n    ctx.fillStyle = 'rgba(17, 24, 39, 0.9)';\n    ctx.strokeStyle = '#1f2937';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.roundRect(x - w/2, y - h/2, w, h, 6);\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = color;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(text, x, y);\n    ctx.restore();\n  }\n\n  // Distances table\n  function renderDistTable(changedSet = new Set()) {\n    distRows.innerHTML = '';\n    const sorted = [...nodes].sort((a,b) => a.id - b.id);\n    for (const n of sorted) {\n      const row = document.createElement('div');\n      row.className = 'rowdata' + (changedSet.has(n.id) ? ' changed' : '');\n      const dCell = document.createElement('div');\n      const distVal = bf.dist[n.id] ?? Infinity;\n      dCell.textContent = formatDist(distVal);\n\n      const pCell = document.createElement('div');\n      const pred = bf.prev[n.id];\n      pCell.textContent = pred != null ? nodeLabel(pred) : '-';\n\n      const nCell = document.createElement('div');\n      nCell.textContent = nodeLabel(n.id);\n\n      row.appendChild(nCell);\n      row.appendChild(dCell);\n      row.appendChild(pCell);\n      distRows.appendChild(row);\n    }\n    iterValEl.textContent = bf.iter;\n    iterMaxEl.textContent = bf.iterMax;\n    edgeIdxEl.textContent = bf.edgeIdx;\n    edgeMaxEl.textContent = edges.length;\n    negStatusEl.textContent = bf.negativeCycle == null ? 'unknown' : (bf.negativeCycle ? 'present' : 'none');\n  }\n\n  // Algorithm functions\n  function initBF() {\n    if (nodes.length === 0) {\n      alert(\"Add some nodes first.\");\n      return;\n    }\n    if (edges.length === 0) {\n      alert(\"Add some edges first.\");\n      return;\n    }\n    bf.source = Number(sourceSelect.value);\n    bf.dist = [];\n    bf.prev = [];\n    const n = nodes.length;\n    for (const node of nodes) {\n      bf.dist[node.id] = Infinity;\n      bf.prev[node.id] = null;\n    }\n    bf.dist[bf.source] = 0;\n    bf.iter = 0;\n    bf.edgeIdx = 0;\n    bf.iterMax = Math.max(0, n - 1);\n    bf.lastRelaxedEdge = null;\n    bf.changedInIter = new Set();\n    bf.doneRelaxations = false;\n    bf.negativeCycle = null;\n    bf.cycleVertices = [];\n    bf.cycleEdges = new Set();\n    bf.running = true;\n    addLog(`Initialized Bellman-Ford with source ${nodeLabel(bf.source)}. Will perform ${bf.iterMax} iterations.`);\n    renderDistTable();\n    draw();\n    disableEditingWhileRunning(true);\n  }\n\n  function resetBF() {\n    bf.running = false;\n    bf.source = null;\n    bf.dist = [];\n    bf.prev = [];\n    bf.iter = 0;\n    bf.edgeIdx = 0;\n    bf.iterMax = 0;\n    bf.lastRelaxedEdge = null;\n    bf.changedInIter = new Set();\n    bf.doneRelaxations = false;\n    bf.negativeCycle = null;\n    bf.cycleVertices = [];\n    bf.cycleEdges = new Set();\n    stopAuto();\n    renderDistTable();\n    draw();\n    disableEditingWhileRunning(false);\n    addLog('Algorithm reset.');\n  }\n\n  function stepRelaxation() {\n    if (!bf.running) {\n      addLog('Initialize the algorithm first.');\n      return;\n    }\n    if (bf.doneRelaxations) {\n      // Already did V-1 iterations; run detection\n      detectNegativeCycle();\n      return;\n    }\n    if (bf.iter >= bf.iterMax) {\n      bf.doneRelaxations = true;\n      addLog('Completed V-1 iterations. Ready to detect negative cycle.');\n      renderDistTable(bf.changedInIter);\n      draw();\n      return;\n    }\n    if (edges.length === 0) {\n      addLog('No edges to relax.');\n      return;\n    }\n\n    const e = edges[bf.edgeIdx];\n    bf.lastRelaxedEdge = e.id;\n\n    const du = bf.dist[e.from];\n    const dv = bf.dist[e.to];\n    const w = e.weight;\n    let improved = false;\n\n    if (du + w < dv) {\n      bf.dist[e.to] = du + w;\n      bf.prev[e.to] = e.from;\n      bf.changedInIter.add(e.to);\n      improved = true;\n      addLog(`Relaxed edge ${nodeLabel(e.from)} → ${nodeLabel(e.to)}: dist[${nodeLabel(e.to)}] = ${formatDist(du)} + ${w} = ${bf.dist[e.to]}`);\n    } else {\n      addLog(`Checked edge ${nodeLabel(e.from)} → ${nodeLabel(e.to)}: no improvement.`);\n    }\n\n    bf.edgeIdx++;\n    if (bf.edgeIdx >= edges.length) {\n      bf.edgeIdx = 0;\n      bf.iter++;\n      addLog(`Iteration ${bf.iter} completed. Changed nodes: ${[...bf.changedInIter].map(nodeLabel).join(', ') || 'none'}.`);\n      // Reset changed set for next iteration visualization\n      renderDistTable(bf.changedInIter);\n      bf.changedInIter.clear();\n    } else {\n      renderDistTable(bf.changedInIter);\n    }\n\n    draw();\n\n    if (bf.iter >= bf.iterMax) {\n      bf.doneRelaxations = true;\n      addLog('Completed V-1 iterations. Ready to detect negative cycle.');\n      renderDistTable(bf.changedInIter);\n    }\n  }\n\n  function nextIteration() {\n    if (!bf.running) { addLog('Initialize first.'); return; }\n    if (bf.doneRelaxations) { detectNegativeCycle(); return; }\n    const targetIter = Math.min(bf.iter + 1, bf.iterMax);\n    while (bf.iter < targetIter) {\n      stepRelaxation();\n    }\n  }\n\n  function runToCompletion() {\n    if (!bf.running) { addLog('Initialize first.'); return; }\n    while (!bf.doneRelaxations) {\n      stepRelaxation();\n      // prevent UI freeze on massive graphs (but we keep simple)\n    }\n    detectNegativeCycle();\n  }\n\n  function stopAuto() {\n    if (bf.autoTimer) {\n      clearInterval(bf.autoTimer);\n      bf.autoTimer = null;\n      autoBtn.textContent = 'Auto-run';\n      addLog('Auto-run stopped.');\n    }\n  }\n\n  function autoRun() {\n    if (!bf.running) { addLog('Initialize first.'); return; }\n    if (bf.autoTimer) { stopAuto(); return; }\n    autoBtn.textContent = 'Stop Auto';\n    addLog('Auto-run started.');\n    const tick = () => {\n      if (!bf.running) { stopAuto(); return; }\n      if (!bf.doneRelaxations) {\n        stepRelaxation();\n      } else {\n        detectNegativeCycle();\n        stopAuto();\n      }\n    };\n    bf.autoTimer = setInterval(tick, Number(speedRange.value));\n  }\n\n  function detectNegativeCycle() {\n    if (bf.negativeCycle != null) {\n      addLog('Negative cycle detection already performed.');\n      return;\n    }\n    let found = false;\n    let witnessVertex = null;\n    for (const e of edges) {\n      const du = bf.dist[e.from];\n      const dv = bf.dist[e.to];\n      if (du + e.weight < dv) {\n        found = true;\n        witnessVertex = e.to;\n        bf.lastRelaxedEdge = e.id;\n        addLog(`Extra pass: edge ${nodeLabel(e.from)} → ${nodeLabel(e.to)} can still improve: ${formatDist(du)} + ${e.weight} < ${formatDist(dv)}.`);\n        break;\n      }\n    }\n    bf.negativeCycle = found;\n    if (!found) {\n      addLog('No negative-weight cycle detected.');\n      negStatusEl.textContent = 'none';\n      renderDistTable();\n      draw();\n      return;\n    }\n\n    negStatusEl.textContent = 'present';\n    // Find a vertex in the cycle by following prev pointers V times\n    const n = nodes.length;\n    let y = witnessVertex;\n    for (let i = 0; i < n; i++) {\n      y = bf.prev[y] != null ? bf.prev[y] : y;\n    }\n    // Collect cycle vertices\n    const cycle = [];\n    let cur = y;\n    const seen = new Set();\n    while (!seen.has(cur)) {\n      seen.add(cur);\n      cycle.push(cur);\n      cur = bf.prev[cur];\n      if (cur == null) break; // safety\n      if (cycle.length > n + 5) break;\n    }\n    // Close cycle up to where it repeats\n    if (cur != null && seen.has(cur)) {\n      const startIdx = cycle.indexOf(cur);\n      const cycleVertices = cycle.slice(startIdx);\n      bf.cycleVertices = cycleVertices;\n      // Mark cycle edges\n      bf.cycleEdges.clear();\n      for (const v of cycleVertices) {\n        const u = bf.prev[v];\n        if (u == null) continue;\n        const e = edges.find(E => E.from === u && E.to === v);\n        if (e) bf.cycleEdges.add(e.id);\n      }\n      addLog(`Negative cycle found: ${cycleVertices.map(nodeLabel).join(' → ')} → ${nodeLabel(cycleVertices[0])}`);\n    } else {\n      addLog('Negative cycle indicated, but could not reconstruct cycle edges.');\n    }\n    renderDistTable();\n    draw();\n  }\n\n  // Editing lock when running\n  function disableEditingWhileRunning(running) {\n    modeMoveBtn.disabled = running ? false : false; // allow moving while running? Let's lock editing modes except move\n    modeAddNodeBtn.disabled = running;\n    modeAddEdgeBtn.disabled = running;\n    deleteSelBtn.disabled = running;\n    clearGraphBtn.disabled = running;\n    example1Btn.disabled = running;\n    example2Btn.disabled = running;\n    example3Btn.disabled = running;\n  }\n\n  // Examples\n  function loadExample1() {\n    clearGraph();\n    // Classic graph with negative edges but no negative cycle\n    const positions = [\n      {x: 150, y: 100},\n      {x: 350, y: 80},\n      {x: 360, y: 240},\n      {x: 170, y: 250},\n      {x: 80, y: 180}\n    ];\n    for (const p of positions) createNode(p.x, p.y);\n    // Edges (CLRS-style)\n    addEdgeSafe(0,1,6);\n    addEdgeSafe(0,3,7);\n    addEdgeSafe(1,2,5);\n    addEdgeSafe(1,3,8);\n    addEdgeSafe(1,4,-4);\n    addEdgeSafe(2,1,-2);\n    addEdgeSafe(3,2,-3);\n    addEdgeSafe(3,4,9);\n    addEdgeSafe(4,0,2);\n    addEdgeSafe(4,2,7);\n    rebuildSourceSelect();\n    sourceSelect.value = '0';\n    addLog('Example 1 loaded (no negative cycle).');\n    draw();\n  }\n\n  function loadExample2() {\n    clearGraph();\n    const positions = [\n      {x: 140, y: 120}, // 0\n      {x: 320, y: 80},  // 1\n      {x: 460, y: 180}, // 2\n      {x: 300, y: 280}, // 3\n      {x: 140, y: 240}  // 4\n    ];\n    for (const p of positions) createNode(p.x, p.y);\n    addEdgeSafe(0,1,1);\n    addEdgeSafe(1,2,1);\n    addEdgeSafe(2,3,1);\n    addEdgeSafe(3,1,-4); // cycle 1->2->3->1 with total -2\n    addEdgeSafe(0,4,2);\n    addEdgeSafe(4,3,2);\n    rebuildSourceSelect();\n    sourceSelect.value = '0';\n    addLog('Example 2 loaded (includes negative cycle).');\n    draw();\n  }\n\n  function loadRandomSmall() {\n    clearGraph();\n    const count = 5;\n    // Place nodes roughly in a circle\n    const cx = canvas.clientWidth/2, cy = canvas.clientHeight/2, R = Math.min(cx, cy) - 120;\n    for (let i = 0; i < count; i++) {\n      const a = i / count * Math.PI * 2;\n      const x = cx + Math.cos(a) * R;\n      const y = cy + Math.sin(a) * R;\n      createNode(x, y);\n    }\n    // Random directed edges\n    const rand = (min, max) => Math.floor(Math.random()*(max-min+1))+min;\n    const edgesToMake = rand(6, 8);\n    for (let k = 0; k < edgesToMake; k++) {\n      let u = rand(0, count-1);\n      let v = rand(0, count-1);\n      if (u === v) { k--; continue; }\n      const w = rand(-5, 9);\n      // Avoid duplicates\n      if (edges.some(e => e.from === u && e.to === v)) { k--; continue; }\n      addEdgeSafe(u, v, w);\n    }\n    rebuildSourceSelect();\n    sourceSelect.value = '0';\n    addLog('Random small example loaded.');\n    draw();\n  }\n\n  function addEdgeSafe(u, v, w) {\n    createEdge(u, v, w);\n  }\n\n  // Event handlers\n  modeMoveBtn.addEventListener('click', () => setMode(Mode.Move));\n  modeAddNodeBtn.addEventListener('click', () => setMode(Mode.AddNode));\n  modeAddEdgeBtn.addEventListener('click', () => setMode(Mode.AddEdge));\n  deleteSelBtn.addEventListener('click', deleteSelected);\n  clearGraphBtn.addEventListener('click', clearGraph);\n\n  example1Btn.addEventListener('click', loadExample1);\n  example2Btn.addEventListener('click', loadExample2);\n  example3Btn.addEventListener('click', loadRandomSmall);\n\n  initBFBtn.addEventListener('click', initBF);\n  resetBFBtn.addEventListener('click', resetBF);\n\n  stepBtn.addEventListener('click', stepRelaxation);\n  nextIterBtn.addEventListener('click', nextIteration);\n  runAllBtn.addEventListener('click', runToCompletion);\n  autoBtn.addEventListener('click', autoRun);\n\n  // Canvas mouse interactions\n  let isMouseDown = false;\n  canvas.addEventListener('mousedown', (e) => {\n    const pos = getMousePos(e);\n    isMouseDown = true;\n    const hitNode = findNodeAt(pos.x, pos.y);\n    const hitEdge = hitNode ? null : findEdgeAt(pos.x, pos.y);\n    if (mode === Mode.Move) {\n      if (hitNode) {\n        selectedNodeId = hitNode.id;\n        draggingNodeId = hitNode.id;\n        dragOffset.x = pos.x - hitNode.x;\n        dragOffset.y = pos.y - hitNode.y;\n      } else if (hitEdge) {\n        selectedEdgeId = hitEdge.id;\n      } else {\n        resetSelection();\n      }\n    } else if (mode === Mode.AddNode) {\n      createNode(pos.x, pos.y);\n      selectedNodeId = nextNodeId - 1;\n    } else if (mode === Mode.AddEdge) {\n      if (pendingEdge.from == null) {\n        if (hitNode) {\n          pendingEdge.from = hitNode.id;\n          selectedNodeId = hitNode.id;\n        }\n      } else {\n        if (hitNode) {\n          pendingEdge.to = hitNode.id;\n          if (pendingEdge.to === pendingEdge.from) {\n            addLog('Cannot create self-loop edge in this demo.');\n          } else {\n            const w = promptEdgeWeight(1);\n            if (w != null) createEdge(pendingEdge.from, pendingEdge.to, w);\n          }\n          pendingEdge.from = null;\n          pendingEdge.to = null;\n          selectedNodeId = null;\n        }\n      }\n    }\n    draw();\n  });\n\n  canvas.addEventListener('mousemove', (e) => {\n    const pos = getMousePos(e);\n    hoverNodeId = null;\n    hoverEdgeId = null;\n\n    const hitNode = findNodeAt(pos.x, pos.y);\n    const hitEdge = hitNode ? null : findEdgeAt(pos.x, pos.y);\n    if (hitNode) hoverNodeId = hitNode.id;\n    else if (hitEdge) hoverEdgeId = hitEdge.id;\n\n    if (isMouseDown && draggingNodeId != null && mode === Mode.Move) {\n      const n = nodeById(draggingNodeId);\n      if (n) {\n        n.x = pos.x - dragOffset.x;\n        n.y = pos.y - dragOffset.y;\n        draw();\n      }\n    } else {\n      draw();\n    }\n  });\n\n  canvas.addEventListener('mouseup', () => {\n    isMouseDown = false;\n    draggingNodeId = null;\n  });\n\n  canvas.addEventListener('mouseleave', () => {\n    isMouseDown = false;\n    draggingNodeId = null;\n    hoverNodeId = null;\n    hoverEdgeId = null;\n    draw();\n  });\n\n  // Keyboard shortcuts for edge edit/delete\n  window.addEventListener('keydown', (e) => {\n    if (e.key === 'Delete') {\n      deleteSelected();\n    }\n    if (e.key.toLowerCase() === 'e') {\n      if (selectedEdgeId != null) {\n        const edge = edgeById(selectedEdgeId);\n        if (!edge) return;\n        const w = promptEdgeWeight(edge.weight);\n        if (w != null) {\n          edge.weight = w;\n          addLog(`Updated edge weight: ${nodeLabel(edge.from)} → ${nodeLabel(edge.to)} = ${w}`);\n          stopAuto();\n          resetBF();\n          draw();\n        }\n      }\n    }\n  });\n\n  function getMousePos(evt) {\n    const rect = canvas.getBoundingClientRect();\n    const x = evt.clientX - rect.left;\n    const y = evt.clientY - rect.top;\n    return { x, y };\n  }\n\n  // Initial load with example 1\n  loadExample1();\n\n  // Ensure source select updates on changes\n  sourceSelect.addEventListener('change', () => {\n    bf.source = Number(sourceSelect.value);\n  });\n\n  // Polyfill for roundRect if needed\n  if (!CanvasRenderingContext2D.prototype.roundRect) {\n    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {\n      if (w < 2 * r) r = w / 2;\n      if (h < 2 * r) r = h / 2;\n      this.beginPath();\n      this.moveTo(x + r, y);\n      this.arcTo(x + w, y, x + w, y + h, r);\n      this.arcTo(x + w, y + h, x, y + h, r);\n      this.arcTo(x, y + h, x, y, r);\n      this.arcTo(x, y, x + w, y, r);\n      this.closePath();\n      return this;\n    }\n  }\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Bellman-Ford Algorithm"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "7fac81e0-a36d-11f0-9d65-8d8e34989cbb",
    "timestamp": "2025-10-07T11:05:13.726Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Floyd-Warshall Algorithm",
    "answer": {
      "annotations": [],
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Floyd–Warshall Algorithm Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <style>\n    :root {\n      --bg: #0f1220;\n      --panel: #161a2e;\n      --text: #e6e8ef;\n      --muted: #aab0c0;\n      --accent: #4aa3ff;\n      --accent2: #ffd34a;\n      --danger: #ff6b6b;\n      --ok: #57d57a;\n      --tableBorder: #303652;\n      --pivot: rgba(74,163,255,0.15);\n      --changed: rgba(87,213,122,0.20);\n    }\n    * { box-sizing: border-box; }\n    body {\n      margin: 0;\n      background: radial-gradient(1200px 800px at 20% 0%, #1b2140 0, #0f1220 40%, #0c1020 100%);\n      color: var(--text);\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Apple Color Emoji\", \"Segoe UI Emoji\";\n    }\n    a { color: var(--accent); }\n    h1, h2, h3 {\n      margin: 0 0 12px;\n      line-height: 1.2;\n    }\n    .wrap {\n      max-width: 1200px;\n      margin: 32px auto;\n      padding: 0 16px;\n    }\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.03));\n      border: 1px solid #22263e;\n      border-radius: 12px;\n      padding: 16px;\n      box-shadow: 0 8px 25px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.03);\n    }\n    .grid {\n      display: grid;\n      grid-template-columns: 360px 1fr;\n      gap: 16px;\n    }\n    .controls {\n      display: grid;\n      gap: 12px;\n    }\n    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }\n    label { font-size: 13px; color: var(--muted); }\n    select, input[type=\"number\"], input[type=\"text\"] {\n      background: #12162a;\n      border: 1px solid #2a3152;\n      color: var(--text);\n      border-radius: 8px;\n      padding: 8px 10px;\n      min-width: 90px;\n      outline: none;\n    }\n    input[type=\"number\"]::-webkit-outer-spin-button, input[type=\"number\"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }\n    button {\n      background: linear-gradient(180deg, #223466, #18244b);\n      border: 1px solid #31406a;\n      color: #dfe6ff;\n      border-radius: 10px;\n      padding: 8px 12px;\n      cursor: pointer;\n      transition: transform .05s ease;\n    }\n    button:hover { filter: brightness(1.05); }\n    button:active { transform: translateY(1px); }\n    button.secondary {\n      background: #1a203a;\n      border-color: #303b66;\n      color: #cdd5f5;\n    }\n    button.warn {\n      background: #3a1a1a;\n      border-color: #7a3434;\n      color: #ffd9d9;\n    }\n    button.ok {\n      background: #193424;\n      border-color: #2d6a44;\n      color: #d7ffe8;\n    }\n    .small { font-size: 12px; color: var(--muted); }\n    .list {\n      background: #12162a;\n      border: 1px solid #2a3152;\n      border-radius: 8px;\n      padding: 8px;\n      max-height: 200px;\n      overflow: auto;\n    }\n    .edgeItem {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      padding: 6px 8px;\n      border-radius: 6px;\n    }\n    .edgeItem:nth-child(odd) { background: rgba(255,255,255,0.02); }\n    .edgeItem .lab { font-family: ui-monospace, Menlo, Consolas, monospace; }\n    .sectionTitle {\n      display: flex;\n      align-items: baseline;\n      justify-content: space-between;\n      margin-bottom: 8px;\n    }\n\n    /* Matrix */\n    .matrixWrap {\n      margin-top: 8px;\n      overflow: auto;\n      background: #0f142b;\n      border: 1px solid var(--tableBorder);\n      border-radius: 8px;\n    }\n    table.matrix {\n      border-collapse: collapse;\n      width: 100%;\n      min-width: 420px;\n      font-variant-numeric: tabular-nums;\n    }\n    table.matrix th, table.matrix td {\n      border: 1px solid var(--tableBorder);\n      padding: 6px 8px;\n      text-align: center;\n      min-width: 42px;\n    }\n    table.matrix th {\n      position: sticky;\n      top: 0;\n      background: #101636;\n      color: #c3ccff;\n      z-index: 2;\n    }\n    .rowHeader {\n      position: sticky;\n      left: 0;\n      background: #101636;\n      z-index: 1;\n      color: #c3ccff;\n    }\n    td.pivot { background: var(--pivot); }\n    td.changed { background: var(--changed); }\n    td.infinite { color: #7b84a9; }\n    td.diag { font-weight: 600; color: #eee; }\n    caption {\n      caption-side: bottom;\n      color: var(--muted);\n      padding: 8px;\n    }\n\n    /* Graph canvas */\n    .canvasBox {\n      position: relative;\n      background: radial-gradient(600px 400px at 50% 50%, #101635 0, #0d1228 60%, #0a1022 100%);\n      border: 1px solid #222849;\n      border-radius: 12px;\n      height: 420px;\n      overflow: hidden;\n    }\n    canvas { display: block; width: 100%; height: 100%; }\n    .legend {\n      display: flex; gap: 14px; align-items: center; flex-wrap: wrap;\n      font-size: 13px; color: var(--muted); margin-top: 8px;\n    }\n    .chip { display: inline-flex; align-items: center; gap: 6px; }\n    .dot { width: 14px; height: 14px; border-radius: 50%; display: inline-block; border: 1px solid #0003; }\n    .dot.pivot { background: var(--accent); }\n    .dot.path { background: var(--ok); }\n    .dot.neg { background: var(--danger); }\n\n    .footer {\n      margin-top: 24px;\n      color: var(--muted);\n      font-size: 13px;\n    }\n    .code {\n      font-family: ui-monospace, \"SF Mono\", Menlo, Consolas, monospace;\n      background: #12162a;\n      border: 1px solid #2a3152;\n      border-radius: 8px;\n      padding: 8px 10px;\n      display: inline-block;\n    }\n\n    .status { margin-top: 8px; font-size: 13px; color: var(--muted); }\n    .status strong { color: #fff; }\n\n    .kbd {\n      font-family: ui-monospace, Menlo, Consolas, monospace;\n      background: #11162d;\n      border: 1px solid #2a3152;\n      border-radius: 6px;\n      padding: 2px 6px;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <h1>Floyd–Warshall Algorithm Visualizer</h1>\n    <p class=\"small\">\n      This page demonstrates the Floyd–Warshall algorithm for all-pairs shortest paths on a weighted directed graph (supports negative edges and detects negative cycles).\n      Add nodes and edges, then step through the algorithm with k as the intermediate node. The distance matrix shows updates per step; changed cells are highlighted.\n    </p>\n\n    <div class=\"grid\">\n      <div class=\"panel controls\">\n        <div class=\"sectionTitle\">\n          <h2>Build Graph</h2>\n          <div class=\"row\">\n            <button id=\"sample1Btn\" class=\"secondary\">Load sample (no negative cycle)</button>\n            <button id=\"sample2Btn\" class=\"secondary\">Load sample (negative cycle)</button>\n          </div>\n        </div>\n        <div class=\"row\">\n          <button id=\"addNodeBtn\">Add node</button>\n          <button id=\"removeNodeBtn\" class=\"secondary\">Remove last node</button>\n          <span class=\"small\" id=\"nodeCountLabel\"></span>\n        </div>\n        <div class=\"row\" style=\"align-items:flex-end\">\n          <div>\n            <label>From</label><br>\n            <select id=\"edgeFrom\"></select>\n          </div>\n          <div>\n            <label>To</label><br>\n            <select id=\"edgeTo\"></select>\n          </div>\n          <div>\n            <label>Weight</label><br>\n            <input type=\"number\" id=\"edgeWeight\" value=\"1\" step=\"1\">\n          </div>\n          <div>\n            <button id=\"addEdgeBtn\" class=\"ok\">Add edge</button>\n          </div>\n        </div>\n        <div>\n          <div class=\"sectionTitle\">\n            <h3>Edges</h3>\n            <span class=\"small\">Directed edges with weights</span>\n          </div>\n          <div id=\"edgesList\" class=\"list\"></div>\n        </div>\n\n        <div class=\"sectionTitle\" style=\"margin-top:8px\">\n          <h2>Run Algorithm</h2>\n          <span class=\"small\">Floyd–Warshall (k as intermediate)</span>\n        </div>\n        <div class=\"row\">\n          <button id=\"initBtn\">Initialize & compute steps</button>\n          <button id=\"prevBtn\" class=\"secondary\">Prev</button>\n          <button id=\"nextBtn\">Next</button>\n          <button id=\"playBtn\">Play</button>\n          <button id=\"finalBtn\" class=\"ok\">Final</button>\n          <span class=\"small\" id=\"stepInfo\"></span>\n        </div>\n\n        <div>\n          <div class=\"sectionTitle\" style=\"margin-top:8px\">\n            <h3>Shortest path query</h3>\n            <span class=\"small\">Uses final matrices</span>\n          </div>\n          <div class=\"row\">\n            <div>\n              <label>Source</label><br>\n              <select id=\"srcSelect\"></select>\n            </div>\n            <div>\n              <label>Target</label><br>\n              <select id=\"dstSelect\"></select>\n            </div>\n            <div>\n              <button id=\"pathBtn\" class=\"ok\">Show shortest path</button>\n            </div>\n          </div>\n          <div id=\"pathResult\" class=\"status\"></div>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <div class=\"sectionTitle\">\n          <h2>Graph</h2>\n          <span class=\"small\">Directed, weighted; hover to enjoy the glow</span>\n        </div>\n        <div class=\"canvasBox\">\n          <canvas id=\"graphCanvas\"></canvas>\n        </div>\n        <div class=\"legend\">\n          <span class=\"chip\"><span class=\"dot pivot\"></span> Pivot node (k)</span>\n          <span class=\"chip\"><span class=\"dot path\"></span> Shortest path highlight</span>\n          <span class=\"chip\"><span class=\"dot neg\"></span> Node in negative cycle (dist[ii] < 0)</span>\n        </div>\n\n        <div class=\"sectionTitle\" style=\"margin-top:16px\">\n          <h2>Distance matrix</h2>\n          <span class=\"small\">All-pairs shortest path distances at current step</span>\n        </div>\n        <div id=\"matrixWrap\" class=\"matrixWrap\"></div>\n        <div id=\"negStatus\" class=\"status\"></div>\n      </div>\n    </div>\n\n    <div class=\"footer\">\n      Tip: The update rule is dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]). Changed cells per step are highlighted. If any dist[v][v] < 0 at the end, the graph has a negative cycle, and shortest paths through that cycle are undefined. Path reconstruction uses the next-matrix approach: next[i][j] holds the next hop on a shortest path from i to j.\n    </div>\n  </div>\n\n  <script>\n    // State\n    const state = {\n      nodes: [], // {id, label}\n      edges: [], // {from, to, w}\n      positions: new Map(), // id -> {x,y}\n      steps: [], // [{k, dist, changed}]\n      finalNext: null, // next matrix at end\n      finalDist: null, // dist matrix at end\n      negCycleNodes: [], // ids with dist[ii] < 0\n      stepIndex: 0,\n      playing: false,\n      playTimer: null,\n      pathHighlight: { nodes: new Set(), edges: new Set() },\n      pivotNode: null,\n    };\n\n    // Helpers\n    const labelForIndex = (i) => {\n      if (i < 26) return String.fromCharCode(65 + i); // A..Z\n      return \"N\" + (i+1);\n    };\n    const deepCopyMatrix = (m) => m.map(row => row.slice());\n    const prettyNum = (x) => {\n      if (x === Infinity) return \"∞\";\n      const isInt = Number.isInteger(x);\n      return isInt ? String(x) : x.toFixed(2);\n    };\n    const buildEmptyMatrix = (n, fill=Infinity) => {\n      const m = new Array(n);\n      for (let i = 0; i < n; i++) {\n        m[i] = new Array(n).fill(fill);\n      }\n      return m;\n    };\n\n    // Graph management\n    function rebuildNodeSelects() {\n      const selects = [document.getElementById('edgeFrom'), document.getElementById('edgeTo'), document.getElementById('srcSelect'), document.getElementById('dstSelect')];\n      for (const sel of selects) {\n        const prev = sel.value;\n        sel.innerHTML = \"\";\n        state.nodes.forEach(n => {\n          const opt = document.createElement('option');\n          opt.value = String(n.id);\n          opt.textContent = n.label;\n          sel.appendChild(opt);\n        });\n        // Restore selection if possible\n        const found = Array.from(sel.options).find(o => o.value === prev);\n        if (found) sel.value = prev;\n      }\n      document.getElementById('nodeCountLabel').textContent = `Nodes: ${state.nodes.length}`;\n    }\n\n    function addNode() {\n      const id = state.nodes.length;\n      const label = labelForIndex(id);\n      state.nodes.push({ id, label });\n      computePositions();\n      rebuildNodeSelects();\n      renderGraph();\n      clearComputed();\n    }\n\n    function removeLastNode() {\n      if (state.nodes.length === 0) return;\n      const lastId = state.nodes.length - 1;\n      state.nodes.pop();\n      // Remove edges touching lastId\n      state.edges = state.edges.filter(e => e.from !== lastId && e.to !== lastId);\n      computePositions();\n      rebuildNodeSelects();\n      renderEdgesList();\n      renderGraph();\n      clearComputed();\n    }\n\n    function addEdge(fromId, toId, w) {\n      if (fromId === null || toId === null) return;\n      if (fromId === toId) {\n        alert('Self-loops are allowed but use with care; they immediately affect diagonal');\n      }\n      state.edges.push({ from: fromId, to: toId, w: w });\n      renderEdgesList();\n      renderGraph();\n      clearComputed();\n    }\n\n    function removeEdgeByIndex(idx) {\n      state.edges.splice(idx, 1);\n      renderEdgesList();\n      renderGraph();\n      clearComputed();\n    }\n\n    function renderEdgesList() {\n      const box = document.getElementById('edgesList');\n      box.innerHTML = \"\";\n      if (state.edges.length === 0) {\n        box.innerHTML = `<div class=\"small\">No edges yet. Add directed edges with weights above.</div>`;\n        return;\n      }\n      state.edges.forEach((e, i) => {\n        const div = document.createElement('div');\n        div.className = 'edgeItem';\n        const lab = document.createElement('div');\n        const f = state.nodes[e.from]?.label ?? `#${e.from}`;\n        const t = state.nodes[e.to]?.label ?? `#${e.to}`;\n        lab.className = 'lab';\n        lab.textContent = `${f} → ${t}   w=${e.w}`;\n        const btn = document.createElement('button');\n        btn.className = 'secondary';\n        btn.textContent = 'Delete';\n        btn.onclick = () => removeEdgeByIndex(i);\n        div.appendChild(lab);\n        div.appendChild(btn);\n        box.appendChild(div);\n      });\n    }\n\n    // Layout positions (circle)\n    function computePositions() {\n      const n = state.nodes.length;\n      const canvas = document.getElementById('graphCanvas');\n      const w = canvas.clientWidth || 800;\n      const h = canvas.clientHeight || 420;\n      const cx = w / 2, cy = h / 2;\n      const R = Math.min(w, h) * 0.34 + Math.random() * 0.0001; // avoid exact overlap rounding\n      state.positions = new Map();\n      for (let i = 0; i < n; i++) {\n        const theta = (2 * Math.PI * i) / n - Math.PI/2;\n        const x = cx + R * Math.cos(theta);\n        const y = cy + R * Math.sin(theta);\n        state.positions.set(i, { x, y });\n      }\n    }\n\n    // Canvas drawing\n    function drawArrow(ctx, x1, y1, x2, y2, color, width, headSize=8) {\n      ctx.strokeStyle = color;\n      ctx.lineWidth = width;\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.stroke();\n      // Arrowhead\n      const angle = Math.atan2(y2 - y1, x2 - x1);\n      const hx = x2 - Math.cos(angle) * 12; // inset so head isn't beyond node\n      const hy = y2 - Math.sin(angle) * 12;\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      ctx.moveTo(hx, hy);\n      ctx.lineTo(hx - headSize * Math.cos(angle - Math.PI/6), hy - headSize * Math.sin(angle - Math.PI/6));\n      ctx.lineTo(hx - headSize * Math.cos(angle + Math.PI/6), hy - headSize * Math.sin(angle + Math.PI/6));\n      ctx.closePath();\n      ctx.fill();\n    }\n\n    function drawNode(ctx, x, y, label, color='#ccd4ff', radius=16, pivot=false, neg=false, highlight=false) {\n      const grad = ctx.createRadialGradient(x, y, 6, x, y, radius + 8);\n      if (pivot) {\n        grad.addColorStop(0, '#4aa3ff'); grad.addColorStop(1, '#1b3a66');\n      } else if (neg) {\n        grad.addColorStop(0, '#ff6b6b'); grad.addColorStop(1, '#5a1b1b');\n      } else if (highlight) {\n        grad.addColorStop(0, '#57d57a'); grad.addColorStop(1, '#1c3a26');\n      } else {\n        grad.addColorStop(0, '#c3ccff'); grad.addColorStop(1, '#2a325a');\n      }\n      ctx.fillStyle = grad;\n      ctx.beginPath();\n      ctx.arc(x, y, radius, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.strokeStyle = 'rgba(0,0,0,0.25)';\n      ctx.lineWidth = 1;\n      ctx.stroke();\n      ctx.fillStyle = '#0b1020';\n      ctx.font = 'bold 13px system-ui, -apple-system, Segoe UI, Roboto';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(label, x, y);\n    }\n\n    function renderGraph() {\n      const canvas = document.getElementById('graphCanvas');\n      const rect = canvas.getBoundingClientRect();\n      canvas.width = Math.floor(rect.width);\n      canvas.height = Math.floor(rect.height);\n      const ctx = canvas.getContext('2d');\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Background subtle grid\n      ctx.save();\n      ctx.strokeStyle = 'rgba(255,255,255,0.04)';\n      ctx.lineWidth = 1;\n      for (let x = 0; x < canvas.width; x += 40) {\n        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();\n      }\n      for (let y = 0; y < canvas.height; y += 40) {\n        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();\n      }\n      ctx.restore();\n\n      // Draw edges\n      const highlightEdges = state.pathHighlight.edges;\n      for (const e of state.edges) {\n        const p1 = state.positions.get(e.from);\n        const p2 = state.positions.get(e.to);\n        if (!p1 || !p2) continue;\n        const dx = p2.x - p1.x, dy = p2.y - p1.y;\n        const len = Math.hypot(dx, dy);\n        const ux = dx / len, uy = dy / len;\n        const startInset = 18, endInset = 18;\n        const sx = p1.x + ux * startInset, sy = p1.y + uy * startInset;\n        const ex = p2.x - ux * endInset, ey = p2.y - uy * endInset;\n\n        const key = `${e.from}->${e.to}`;\n        const isOnPath = highlightEdges.has(key);\n        const color = isOnPath ? '#57d57a' : '#7fb2ff';\n        const width = isOnPath ? 3.5 : 1.6;\n        drawArrow(ctx, sx, sy, ex, ey, color, width, 9);\n\n        // weight label\n        const mx = (sx + ex) / 2, my = (sy + ey) / 2;\n        ctx.save();\n        ctx.fillStyle = isOnPath ? 'rgba(87,213,122,0.85)' : 'rgba(200,220,255,0.75)';\n        ctx.font = '12px ui-monospace, Menlo, Consolas';\n        ctx.fillText(e.w, mx + 8, my - 4);\n        ctx.restore();\n      }\n\n      // Draw nodes\n      const negSet = new Set(state.negCycleNodes);\n      const pathNodes = state.pathHighlight.nodes;\n      for (const n of state.nodes) {\n        const pos = state.positions.get(n.id);\n        if (!pos) continue;\n        const isPivot = state.pivotNode === n.id;\n        const isNeg = negSet.has(n.id);\n        const isOnPath = pathNodes.has(n.id);\n        drawNode(ctx, pos.x, pos.y, n.label, '#ccd4ff', 16, isPivot, isNeg, isOnPath);\n      }\n    }\n\n    // Matrix UI\n    let matrixCells = null;\n    function buildMatrixTable() {\n      const wrap = document.getElementById('matrixWrap');\n      wrap.innerHTML = \"\";\n      const n = state.nodes.length;\n      if (n === 0) {\n        wrap.innerHTML = `<div class=\"small\" style=\"padding:8px\">Add some nodes to see the distance matrix.</div>`;\n        return;\n      }\n      const table = document.createElement('table');\n      table.className = 'matrix';\n      const thead = document.createElement('thead');\n      const thr = document.createElement('tr');\n      thr.appendChild(document.createElement('th')); // corner\n      for (let j = 0; j < n; j++) {\n        const th = document.createElement('th');\n        th.textContent = state.nodes[j].label;\n        thr.appendChild(th);\n      }\n      thead.appendChild(thr);\n      table.appendChild(thead);\n\n      const tbody = document.createElement('tbody');\n      matrixCells = Array.from({ length: n }, () => Array.from({ length: n }, () => null));\n      for (let i = 0; i < n; i++) {\n        const tr = document.createElement('tr');\n        const rowH = document.createElement('th');\n        rowH.className = 'rowHeader';\n        rowH.textContent = state.nodes[i].label;\n        tr.appendChild(rowH);\n        for (let j = 0; j < n; j++) {\n          const td = document.createElement('td');\n          if (i === j) td.classList.add('diag');\n          tr.appendChild(td);\n          matrixCells[i][j] = td;\n        }\n        tbody.appendChild(tr);\n      }\n      table.appendChild(tbody);\n      const caption = document.createElement('caption');\n      caption.textContent = 'Cells marked as changed were updated by dist[i][k] + dist[k][j] at this step.';\n      table.appendChild(caption);\n      wrap.appendChild(table);\n    }\n\n    function updateMatrixDisplay(step) {\n      if (!matrixCells || !step) return;\n      const n = state.nodes.length;\n      const k = step.k;\n      const changedSet = new Set(step.changed.map(([i,j]) => `${i}:${j}`));\n\n      for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n          const td = matrixCells[i][j];\n          const val = step.dist[i][j];\n          td.textContent = prettyNum(val);\n          td.classList.toggle('infinite', val === Infinity);\n          td.classList.toggle('changed', changedSet.has(`${i}:${j}`));\n          // pivot highlight: k-th row and k-th column (excluding headers)\n          const pivot = (i === k || j === k) && k >= 0;\n          td.classList.toggle('pivot', pivot);\n        }\n      }\n      state.pivotNode = k >= 0 ? k : null;\n      renderGraph();\n\n      const infoEl = document.getElementById('stepInfo');\n      const stepNum = state.stepIndex;\n      const pivotLabel = k >= 0 ? state.nodes[k]?.label ?? `#${k}` : \"none\";\n      infoEl.textContent = `Step ${stepNum}/${state.steps.length-1}  |  k = ${pivotLabel}  |  changed: ${step.changed.length}`;\n    }\n\n    function setNegStatus() {\n      const el = document.getElementById('negStatus');\n      if (!state.finalDist) { el.textContent = \"\"; return; }\n      const negs = state.negCycleNodes;\n      if (negs.length === 0) {\n        el.innerHTML = `<strong>No negative cycles detected.</strong> All-pairs shortest distances are well-defined.`;\n      } else {\n        const names = negs.map(i => state.nodes[i].label).join(\", \");\n        el.innerHTML = `<strong class=\"warn\">Negative cycle detected.</strong> Nodes in negative cycles: ${names}. Distances involving these cycles are undefined; use caution when querying paths that can reach them.`;\n      }\n    }\n\n    function clearComputed() {\n      state.steps = [];\n      state.finalNext = null;\n      state.finalDist = null;\n      state.negCycleNodes = [];\n      state.stepIndex = 0;\n      state.pivotNode = null;\n      state.pathHighlight.nodes.clear();\n      state.pathHighlight.edges.clear();\n      buildMatrixTable();\n      updateMatrixDisplay(null);\n      setNegStatus();\n    }\n\n    // Floyd–Warshall computation\n    function computeFloydWarshallSteps() {\n      const n = state.nodes.length;\n      const edges = state.edges;\n      if (n === 0) { alert('Add nodes first.'); return; }\n\n      // init dist and next\n      const dist = buildEmptyMatrix(n, Infinity);\n      const next = Array.from({ length: n }, () => Array.from({ length: n }, () => null));\n      for (let i = 0; i < n; i++) {\n        dist[i][i] = 0;\n        next[i][i] = i;\n      }\n      for (const e of edges) {\n        if (e.from < n && e.to < n) {\n          if (e.w < dist[e.from][e.to]) {\n            dist[e.from][e.to] = e.w;\n            next[e.from][e.to] = e.to;\n          }\n        }\n      }\n\n      const steps = [];\n      // step 0 = initial\n      steps.push({ k: -1, dist: deepCopyMatrix(dist), changed: [] });\n\n      for (let k = 0; k < n; k++) {\n        const changed = [];\n        for (let i = 0; i < n; i++) {\n          for (let j = 0; j < n; j++) {\n            const dik = dist[i][k], dkj = dist[k][j];\n            if (dik === Infinity || dkj === Infinity) continue;\n            const cand = dik + dkj;\n            if (cand < dist[i][j]) {\n              dist[i][j] = cand;\n              next[i][j] = next[i][k];\n              changed.push([i, j]);\n            }\n          }\n        }\n        steps.push({ k, dist: deepCopyMatrix(dist), changed });\n      }\n\n      state.steps = steps;\n      state.finalNext = next;\n      state.finalDist = deepCopyMatrix(dist);\n      state.negCycleNodes = [];\n      for (let v = 0; v < n; v++) {\n        if (dist[v][v] < 0) state.negCycleNodes.push(v);\n      }\n      setNegStatus();\n      buildMatrixTable();\n      state.stepIndex = 0;\n      updateMatrixDisplay(state.steps[0]);\n    }\n\n    // Playback controls\n    function goPrev() {\n      if (state.steps.length === 0) return;\n      state.stepIndex = Math.max(0, state.stepIndex - 1);\n      updateMatrixDisplay(state.steps[state.stepIndex]);\n    }\n    function goNext() {\n      if (state.steps.length === 0) return;\n      state.stepIndex = Math.min(state.steps.length - 1, state.stepIndex + 1);\n      updateMatrixDisplay(state.steps[state.stepIndex]);\n      if (state.playing && state.stepIndex === state.steps.length - 1) togglePlay(false);\n    }\n    function goFinal() {\n      if (state.steps.length === 0) return;\n      state.stepIndex = state.steps.length - 1;\n      updateMatrixDisplay(state.steps[state.stepIndex]);\n    }\n    function togglePlay(forceState) {\n      const btn = document.getElementById('playBtn');\n      const shouldPlay = typeof forceState === 'boolean' ? forceState : !state.playing;\n      if (shouldPlay) {\n        if (state.steps.length === 0) return;\n        state.playing = true;\n        btn.textContent = 'Pause';\n        state.playTimer = setInterval(goNext, 800);\n      } else {\n        state.playing = false;\n        btn.textContent = 'Play';\n        clearInterval(state.playTimer);\n        state.playTimer = null;\n      }\n    }\n\n    // Path reconstruction\n    function reconstructPath(u, v, next) {\n      if (u === null || v === null) return null;\n      if (next[u][v] === null) return null;\n      const path = [u];\n      const visited = new Set([u]);\n      let cur = u;\n      // To prevent infinite loop for bad next or negative cycle influence, limit iterations\n      for (let i = 0; i < next.length * 2; i++) {\n        if (cur === v) break;\n        cur = next[cur][v];\n        if (cur === null) return null;\n        path.push(cur);\n        if (visited.has(cur)) {\n          // loop detected\n          return null;\n        }\n        visited.add(cur);\n      }\n      if (path[path.length-1] !== v) return null;\n      return path;\n    }\n\n    function pathUndefinedDueToNegCycle(u, v, dist, negNodes) {\n      if (!dist || negNodes.length === 0) return false;\n      // If any negative-cycle node k is reachable from u and can reach v, then u->v shortest path is undefined\n      for (const k of negNodes) {\n        if (dist[u][k] !== Infinity && dist[k][v] !== Infinity) return true;\n      }\n      return false;\n    }\n\n    function showPath() {\n      const srcSel = document.getElementById('srcSelect');\n      const dstSel = document.getElementById('dstSelect');\n      const u = parseInt(srcSel.value);\n      const v = parseInt(dstSel.value);\n      const resEl = document.getElementById('pathResult');\n\n      if (!state.finalNext || !state.finalDist) {\n        resEl.innerHTML = `<strong>Compute steps first.</strong> Click \"Initialize & compute steps\".`;\n        return;\n      }\n      if (state.nodes.length === 0) {\n        resEl.textContent = \"No nodes.\";\n        return;\n      }\n\n      const undefinedPath = pathUndefinedDueToNegCycle(u, v, state.finalDist, state.negCycleNodes);\n      if (undefinedPath) {\n        state.pathHighlight.nodes.clear();\n        state.pathHighlight.edges.clear();\n        renderGraph();\n        resEl.innerHTML = `<strong class=\"warn\">Undefined:</strong> path from ${state.nodes[u].label} to ${state.nodes[v].label} is affected by a negative cycle (reachable both ways), so no well-defined shortest path exists.`;\n        return;\n      }\n\n      const path = reconstructPath(u, v, state.finalNext);\n      const distVal = state.finalDist[u][v];\n      if (!path || distVal === Infinity) {\n        state.pathHighlight.nodes.clear();\n        state.pathHighlight.edges.clear();\n        renderGraph();\n        resEl.innerHTML = `No path exists from <strong>${state.nodes[u].label}</strong> to <strong>${state.nodes[v].label}</strong>.`;\n        return;\n      }\n\n      // Highlight path on graph\n      state.pathHighlight.nodes.clear();\n      state.pathHighlight.edges.clear();\n      for (const node of path) state.pathHighlight.nodes.add(node);\n      for (let i = 0; i < path.length - 1; i++) {\n        const a = path[i], b = path[i+1];\n        state.pathHighlight.edges.add(`${a}->${b}`);\n      }\n      renderGraph();\n\n      const labels = path.map(i => state.nodes[i].label).join(' → ');\n      resEl.innerHTML = `Shortest distance: <strong>${prettyNum(distVal)}</strong><br>Path: <span class=\"code\">${labels}</span>`;\n    }\n\n    // Samples\n    function loadSample1() {\n      // No negative cycle\n      state.nodes = [];\n      for (let i = 0; i < 5; i++) state.nodes.push({ id: i, label: labelForIndex(i) }); // A..E\n      state.edges = [\n        { from:0,to:1,w:3 },   // A->B\n        { from:0,to:2,w:8 },   // A->C\n        { from:0,to:3,w:10 },  // A->D\n        { from:1,to:2,w:2 },   // B->C\n        { from:1,to:3,w:6 },   // B->D\n        { from:2,to:3,w:-4 },  // C->D\n        { from:3,to:4,w:1 },   // D->E\n        { from:4,to:1,w:-1 },  // E->B\n      ];\n      computePositions();\n      rebuildNodeSelects();\n      renderEdgesList();\n      renderGraph();\n      clearComputed();\n    }\n    function loadSample2() {\n      // With negative cycle: A->B (1), B->C (-1), C->A (-1)\n      state.nodes = [];\n      for (let i = 0; i < 4; i++) state.nodes.push({ id: i, label: labelForIndex(i) }); // A..D\n      state.edges = [\n        { from:0,to:1,w:1 },\n        { from:1,to:2,w:-1 },\n        { from:2,to:0,w:-1 },\n        { from:1,to:3,w:2 },\n        { from:0,to:3,w:5 },\n      ];\n      computePositions();\n      rebuildNodeSelects();\n      renderEdgesList();\n      renderGraph();\n      clearComputed();\n    }\n\n    // Events\n    function setupEvents() {\n      document.getElementById('addNodeBtn').onclick = addNode;\n      document.getElementById('removeNodeBtn').onclick = removeLastNode;\n      document.getElementById('addEdgeBtn').onclick = () => {\n        const from = parseInt(document.getElementById('edgeFrom').value);\n        const to = parseInt(document.getElementById('edgeTo').value);\n        const wRaw = document.getElementById('edgeWeight').value;\n        const w = parseFloat(wRaw);\n        if (Number.isNaN(w)) { alert('Weight must be a number'); return; }\n        if (!state.nodes.find(n => n.id === from) || !state.nodes.find(n => n.id === to)) {\n          alert('Select valid nodes for edge.');\n          return;\n        }\n        addEdge(from, to, w);\n      };\n      document.getElementById('initBtn').onclick = computeFloydWarshallSteps;\n      document.getElementById('prevBtn').onclick = goPrev;\n      document.getElementById('nextBtn').onclick = goNext;\n      document.getElementById('finalBtn').onclick = goFinal;\n      document.getElementById('playBtn').onclick = () => togglePlay();\n      document.getElementById('pathBtn').onclick = showPath;\n\n      document.getElementById('sample1Btn').onclick = loadSample1;\n      document.getElementById('sample2Btn').onclick = loadSample2;\n\n      window.addEventListener('resize', () => {\n        computePositions();\n        renderGraph();\n      });\n    }\n\n    // Init default\n    function init() {\n      setupEvents();\n      // Preload sample\n      loadSample1();\n      buildMatrixTable();\n    }\n\n    init();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Floyd-Warshall Algorithm"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "a8c179a0-a36d-11f0-ac43-0f065c62f207",
    "timestamp": "2025-10-07T11:06:22.650Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Kruskal’s Algorithm",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Kruskal’s Algorithm Visualizer</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --text: #e5e7eb;\n    --accent: #38bdf8;\n    --muted: #9ca3af;\n    --edge: #6b7280;\n    --current: #f59e0b;\n    --accept: #22c55e;\n    --reject: #ef4444;\n    --node: #3b82f6;\n  }\n  html, body {\n    height: 100%;\n    margin: 0;\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;\n    background: var(--bg);\n    color: var(--text);\n  }\n  .app {\n    display: grid;\n    grid-template-columns: 320px 1fr;\n    grid-template-rows: auto 1fr auto;\n    grid-template-areas:\n      \"header header\"\n      \"sidebar canvas\"\n      \"footer canvas\";\n    height: 100%;\n  }\n  header {\n    grid-area: header;\n    padding: 14px 16px;\n    border-bottom: 1px solid #1f2937;\n    display: flex;\n    align-items: center;\n    gap: 12px;\n  }\n  header h1 {\n    font-size: 20px;\n    margin: 0;\n  }\n  header .sub {\n    color: var(--muted);\n    font-size: 13px;\n  }\n  .sidebar {\n    grid-area: sidebar;\n    padding: 12px;\n    border-right: 1px solid #1f2937;\n    background: var(--panel);\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    overflow: auto;\n  }\n  .canvas-wrap {\n    grid-area: canvas;\n    position: relative;\n    display: grid;\n    grid-template-rows: 1fr auto;\n    background: #0b1220;\n  }\n  .svgwrap {\n    position: relative;\n  }\n  svg {\n    width: 100%;\n    height: 100%;\n    background: radial-gradient(1200px circle at 20% 30%, #0b1220 0, #0b1220 60%, #0a0f1a 100%);\n  }\n  .legend {\n    display: flex;\n    gap: 16px;\n    padding: 8px 10px;\n    border-top: 1px solid #1f2937;\n    background: rgba(17, 24, 39, 0.7);\n    font-size: 13px;\n  }\n  .legend .key {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n  }\n  .dot {\n    width: 12px; height: 2px; border-radius: 1px;\n    background: var(--edge);\n    display: inline-block;\n  }\n  .dot.current { background: var(--current); }\n  .dot.accept { background: var(--accept); }\n  .dot.reject { background: var(--reject); }\n  .dot.node { width: 10px; height: 10px; border-radius: 50%; background: var(--node); }\n  .panel {\n    background: #0b1220;\n    border: 1px solid #1f2937;\n    border-radius: 8px;\n    padding: 10px;\n  }\n  .panel h3 {\n    margin: 0 0 8px 0;\n    font-size: 14px;\n    color: var(--accent);\n  }\n  .controls {\n    display: grid;\n    gap: 10px;\n  }\n  .row {\n    display: grid;\n    grid-template-columns: 1fr auto;\n    gap: 8px;\n    align-items: center;\n  }\n  label {\n    font-size: 13px;\n    color: var(--muted);\n  }\n  input[type=\"range\"] { width: 100%; }\n  input[type=\"number\"] {\n    width: 76px;\n    background: #0b1220;\n    border: 1px solid #1f2937;\n    color: var(--text);\n    padding: 6px 8px;\n    border-radius: 6px;\n  }\n  select, button {\n    background: #0b1220;\n    border: 1px solid #1f2937;\n    color: var(--text);\n    padding: 8px 10px;\n    border-radius: 8px;\n    font-size: 14px;\n    cursor: pointer;\n  }\n  button.primary {\n    background: #0e7490;\n    border-color: #0ea5a6;\n  }\n  button:disabled {\n    opacity: 0.5; cursor: not-allowed;\n  }\n  .btnrow {\n    display: grid;\n    grid-template-columns: repeat(4, 1fr);\n    gap: 8px;\n  }\n  .status {\n    background: #0b1220;\n    border: 1px solid #1f2937;\n    border-radius: 8px;\n    padding: 10px;\n    font-size: 13px;\n  }\n  .status .line { margin-top: 6px; }\n  .code {\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;\n    color: #cbd5e1;\n  }\n  .edge-list {\n    max-height: 240px;\n    overflow: auto;\n    border: 1px solid #1f2937;\n    border-radius: 8px;\n    padding: 6px;\n    background: #0b1220;\n  }\n  .edge-item {\n    display: flex;\n    justify-content: space-between;\n    padding: 6px 8px;\n    border-radius: 6px;\n    font-size: 13px;\n    cursor: pointer;\n  }\n  .edge-item:hover { background: rgba(56, 189, 248, 0.08); }\n  .edge-item.current { outline: 1px dashed var(--current); }\n  .edge-item.accepted { background: rgba(34, 197, 94, 0.1); }\n  .edge-item.rejected { background: rgba(239, 68, 68, 0.1); }\n  .sets {\n    background: #0b1220;\n    border: 1px solid #1f2937;\n    border-radius: 8px;\n    padding: 10px;\n    font-size: 13px;\n  }\n  .sets .group {\n    display: inline-block;\n    padding: 4px 6px;\n    border-radius: 6px;\n    margin: 2px 4px 2px 0;\n    background: rgba(56, 189, 248, 0.08);\n    border: 1px solid #1f2937;\n  }\n  /* SVG styles */\n  .edge-line {\n    stroke: var(--edge);\n    stroke-width: 2px;\n    opacity: 0.8;\n    transition: stroke 120ms ease, opacity 120ms ease;\n  }\n  .edge-line.current { stroke: var(--current); opacity: 1; }\n  .edge-line.accepted { stroke: var(--accept); opacity: 1; stroke-width: 3px; }\n  .edge-line.rejected { stroke: var(--reject); opacity: 0.9; stroke-dasharray: 4 4; }\n  .edge-weight {\n    font-size: 11px;\n    fill: #cbd5e1;\n    pointer-events: none;\n    text-shadow: 0 0 6px rgba(0,0,0,0.8);\n  }\n  .edge-weight.accepted { fill: var(--accept); }\n  .edge-weight.rejected { fill: var(--reject); }\n  .node-circle {\n    fill: var(--node);\n    stroke: #1f2937;\n    stroke-width: 1px;\n  }\n  .node-label {\n    font-size: 12px;\n    fill: white;\n    font-weight: 600;\n    pointer-events: none;\n  }\n  footer {\n    grid-area: footer;\n    border-top: 1px solid #1f2937;\n    padding: 8px 12px;\n    font-size: 12px;\n    color: var(--muted);\n  }\n  .link {\n    color: var(--accent);\n    text-decoration: none;\n    border-bottom: 1px dashed var(--accent);\n  }\n</style>\n</head>\n<body>\n<div class=\"app\">\n  <header>\n    <h1>Kruskal’s Algorithm</h1>\n    <span class=\"sub\">Minimum Spanning Tree via greedy edge selection with Union-Find</span>\n  </header>\n\n  <div class=\"sidebar\">\n    <div class=\"panel\">\n      <h3>Graph Settings</h3>\n      <div class=\"controls\">\n        <div class=\"row\">\n          <label for=\"nodeCount\">Nodes</label>\n          <input id=\"nodeCount\" type=\"number\" min=\"3\" max=\"40\" value=\"12\">\n        </div>\n        <div class=\"row\">\n          <label for=\"density\">Extra edge density: <span id=\"densityVal\">0.30</span></label>\n          <input id=\"density\" type=\"range\" min=\"0\" max=\"1\" step=\"0.05\" value=\"0.30\">\n        </div>\n        <div class=\"row\">\n          <label for=\"weightMode\">Edge weight</label>\n          <select id=\"weightMode\">\n            <option value=\"distance\">Euclidean distance</option>\n            <option value=\"random\">Random integers</option>\n          </select>\n        </div>\n        <div class=\"btnrow\">\n          <button id=\"newGraph\" class=\"primary\">New Graph</button>\n          <button id=\"resetAlgo\">Reset</button>\n          <button id=\"stepBack\">Back</button>\n          <button id=\"stepForward\">Step</button>\n        </div>\n        <div class=\"row\">\n          <label for=\"speed\">Auto-play speed: <span id=\"speedVal\">800ms</span></label>\n          <input id=\"speed\" type=\"range\" min=\"200\" max=\"2000\" step=\"100\" value=\"800\">\n        </div>\n        <button id=\"playPause\">Play</button>\n      </div>\n    </div>\n\n    <div class=\"status\">\n      <div><strong>Status:</strong> <span id=\"statusText\">Ready</span></div>\n      <div class=\"line\"><strong>Step:</strong> <span id=\"stepCount\">0</span> / <span id=\"totalSteps\">0</span></div>\n      <div class=\"line\"><strong>Current edge:</strong> <span id=\"currentEdgeText\">-</span></div>\n      <div class=\"line\"><strong>MST weight:</strong> <span id=\"mstWeight\">0</span></div>\n    </div>\n\n    <div class=\"panel\">\n      <h3>Sorted edges (ascending weight)</h3>\n      <div id=\"edgeList\" class=\"edge-list\"></div>\n    </div>\n\n    <div class=\"sets\">\n      <div><strong>Union-Find (Disjoint Sets):</strong></div>\n      <div id=\"setDisplay\"></div>\n      <div style=\"margin-top:8px; color: var(--muted);\">\n        Kruskal sorts edges by weight, then adds the next lightest edge that does not form a cycle (i.e., it connects two different components). Union-Find efficiently checks and merges components.\n      </div>\n    </div>\n  </div>\n\n  <div class=\"canvas-wrap\">\n    <div class=\"svgwrap\">\n      <svg id=\"svg\" preserveAspectRatio=\"xMidYMid meet\">\n        <defs>\n          <filter id=\"glow\">\n            <feGaussianBlur stdDeviation=\"2.5\" result=\"coloredBlur\"/>\n            <feMerge>\n              <feMergeNode in=\"coloredBlur\"/>\n              <feMergeNode in=\"SourceGraphic\"/>\n            </feMerge>\n          </filter>\n        </defs>\n      </svg>\n    </div>\n    <div class=\"legend\">\n      <div class=\"key\"><span class=\"dot node\"></span> Node</div>\n      <div class=\"key\"><span class=\"dot\"></span> Unprocessed edge</div>\n      <div class=\"key\"><span class=\"dot current\"></span> Current edge</div>\n      <div class=\"key\"><span class=\"dot accept\"></span> Accepted edge</div>\n      <div class=\"key\"><span class=\"dot reject\"></span> Rejected edge</div>\n    </div>\n  </div>\n\n  <footer>\n    Tip: Generate a new graph, then click Step to watch Kruskal pick the next valid lightest edge. Play auto-steps until the MST is complete (n−1 edges).\n  </footer>\n</div>\n\n<script>\n(function() {\n  // Utility\n  const rand = (min, max) => Math.random() * (max - min) + min;\n  const randInt = (min, max) => Math.floor(rand(min, max + 1));\n  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));\n\n  // DSU (Union-Find)\n  class DSU {\n    constructor(n) {\n      this.parent = Array.from({length: n}, (_, i) => i);\n      this.rank = Array(n).fill(0);\n    }\n    find(x) {\n      let p = this.parent[x];\n      if (p !== x) this.parent[x] = this.find(p);\n      return this.parent[x];\n    }\n    union(a, b) {\n      let ra = this.find(a), rb = this.find(b);\n      if (ra === rb) return false;\n      if (this.rank[ra] < this.rank[rb]) {\n        this.parent[ra] = rb;\n      } else if (this.rank[ra] > this.rank[rb]) {\n        this.parent[rb] = ra;\n      } else {\n        this.parent[rb] = ra;\n        this.rank[ra]++;\n      }\n      return true;\n    }\n  }\n\n  // DOM elements\n  const svg = document.getElementById('svg');\n  const nodeCountInput = document.getElementById('nodeCount');\n  const densityInput = document.getElementById('density');\n  const densityVal = document.getElementById('densityVal');\n  const weightModeSel = document.getElementById('weightMode');\n  const newGraphBtn = document.getElementById('newGraph');\n  const resetBtn = document.getElementById('resetAlgo');\n  const stepFwdBtn = document.getElementById('stepForward');\n  const stepBackBtn = document.getElementById('stepBack');\n  const playPauseBtn = document.getElementById('playPause');\n  const speedInput = document.getElementById('speed');\n  const speedVal = document.getElementById('speedVal');\n\n  const statusText = document.getElementById('statusText');\n  const stepCount = document.getElementById('stepCount');\n  const totalSteps = document.getElementById('totalSteps');\n  const currentEdgeText = document.getElementById('currentEdgeText');\n  const mstWeightEl = document.getElementById('mstWeight');\n  const edgeList = document.getElementById('edgeList');\n  const setDisplay = document.getElementById('setDisplay');\n\n  // State\n  let nodes = [];\n  let edges = [];\n  let edgesSorted = [];\n  let dsu = null;\n  let currentIndex = 0;\n  let mstWeight = 0;\n  let autoplayTimer = null;\n  let isPlaying = false;\n\n  // Drawing groups\n  let gEdges, gLabels, gNodes;\n\n  function initSVG() {\n    // Clear\n    while (svg.firstChild) svg.removeChild(svg.firstChild);\n\n    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n    svg.appendChild(defs);\n    gEdges  = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    gEdges.setAttribute('id', 'edges');\n    gLabels = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    gLabels.setAttribute('id', 'labels');\n    gNodes  = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    gNodes.setAttribute('id', 'nodes');\n\n    svg.appendChild(gEdges);\n    svg.appendChild(gLabels);\n    svg.appendChild(gNodes);\n  }\n\n  function resizeSVG() {\n    // Fit SVG to container\n    const rect = svg.getBoundingClientRect();\n    svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);\n  }\n\n  window.addEventListener('resize', () => {\n    resizeSVG();\n    repositionAll();\n  });\n\n  function repositionAll() {\n    for (const edge of edges) {\n      const u = nodes[edge.u], v = nodes[edge.v];\n      edge.line.setAttribute('x1', u.x);\n      edge.line.setAttribute('y1', u.y);\n      edge.line.setAttribute('x2', v.x);\n      edge.line.setAttribute('y2', v.y);\n      const mx = (u.x + v.x) / 2;\n      const my = (u.y + v.y) / 2;\n      edge.label.setAttribute('x', mx);\n      edge.label.setAttribute('y', my);\n    }\n    for (const node of nodes) {\n      node.circle.setAttribute('cx', node.x);\n      node.circle.setAttribute('cy', node.y);\n      node.text.setAttribute('x', node.x);\n      node.text.setAttribute('y', node.y + 4);\n    }\n  }\n\n  // Graph generation: ensure connected by building a random tree, then add random extra edges\n  function generateGraph(n, density, weightMode) {\n    initSVG();\n    resizeSVG();\n    const rect = svg.getBoundingClientRect();\n    const pad = 30;\n\n    // Nodes\n    nodes = [];\n    for (let i = 0; i < n; i++) {\n      nodes.push({\n        id: i,\n        x: rand(pad, rect.width - pad),\n        y: rand(pad, rect.height - pad),\n        circle: null,\n        text: null\n      });\n    }\n\n    // Create at least a spanning tree (connectivity)\n    const baseEdgesSet = new Set();\n    const baseEdges = [];\n    for (let i = 1; i < n; i++) {\n      // connect i to a random previous node\n      const j = randInt(0, i - 1);\n      const key = i < j ? `${i}-${j}` : `${j}-${i}`;\n      if (!baseEdgesSet.has(key)) {\n        baseEdgesSet.add(key);\n        baseEdges.push([i, j]);\n      }\n    }\n\n    // Extra edges with probability density\n    const extraEdges = [];\n    for (let i = 0; i < n; i++) {\n      for (let j = i + 1; j < n; j++) {\n        const key = `${i}-${j}`;\n        if (baseEdgesSet.has(key)) continue;\n        if (Math.random() < density) {\n          extraEdges.push([i, j]);\n        }\n      }\n    }\n\n    const allPairs = baseEdges.concat(extraEdges);\n\n    // Compute weights\n    edges = [];\n    let eid = 0;\n    for (const [uIdx, vIdx] of allPairs) {\n      const u = nodes[uIdx], v = nodes[vIdx];\n      let w;\n      if (weightMode === 'distance') {\n        w = Math.round(Math.hypot(u.x - v.x, u.y - v.y));\n      } else {\n        w = randInt(1, 99);\n      }\n      edges.push({\n        id: eid++,\n        u: uIdx,\n        v: vIdx,\n        w,\n        line: null,\n        label: null,\n        item: null,\n        state: 'none' // 'none' | 'accepted' | 'rejected'\n      });\n    }\n\n    drawGraph();\n    prepareAlgorithm();\n  }\n\n  function drawGraph() {\n    // Draw edges and weight labels first\n    for (const edge of edges) {\n      const u = nodes[edge.u], v = nodes[edge.v];\n\n      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n      line.classList.add('edge-line');\n      line.setAttribute('x1', u.x);\n      line.setAttribute('y1', u.y);\n      line.setAttribute('x2', v.x);\n      line.setAttribute('y2', v.y);\n      line.dataset.eid = edge.id;\n      gEdges.appendChild(line);\n\n      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      label.classList.add('edge-weight');\n      label.setAttribute('x', (u.x + v.x) / 2);\n      label.setAttribute('y', (u.y + v.y) / 2);\n      label.setAttribute('text-anchor', 'middle');\n      label.setAttribute('alignment-baseline', 'middle');\n      label.textContent = edge.w;\n      gLabels.appendChild(label);\n\n      edge.line = line;\n      edge.label = label;\n\n      line.addEventListener('mouseenter', () => {\n        if (edge.state === 'none') line.classList.add('current');\n      });\n      line.addEventListener('mouseleave', () => {\n        if (edge.state === 'none') line.classList.remove('current');\n      });\n    }\n\n    // Draw nodes\n    for (const node of nodes) {\n      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n      circle.classList.add('node-circle');\n      circle.setAttribute('r', 10);\n      circle.setAttribute('cx', node.x);\n      circle.setAttribute('cy', node.y);\n      circle.setAttribute('filter', 'url(#glow)');\n      gNodes.appendChild(circle);\n\n      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      label.classList.add('node-label');\n      label.setAttribute('x', node.x);\n      label.setAttribute('y', node.y + 4);\n      label.setAttribute('text-anchor', 'middle');\n      label.textContent = node.id;\n      gNodes.appendChild(label);\n\n      node.circle = circle;\n      node.text = label;\n    }\n\n    buildEdgeList();\n  }\n\n  function buildEdgeList() {\n    edgesSorted = edges.slice().sort((a, b) => a.w - b.w || a.id - b.id);\n    edgeList.innerHTML = '';\n    for (const edge of edgesSorted) {\n      const div = document.createElement('div');\n      div.className = 'edge-item';\n      div.dataset.eid = edge.id;\n      div.innerHTML = `<span>${edge.u}–${edge.v}</span><span class=\"code\">${edge.w}</span>`;\n      div.addEventListener('click', () => {\n        // Flash highlight on the corresponding edge\n        flashEdge(edge);\n      });\n      edge.item = div;\n      edgeList.appendChild(div);\n    }\n    totalSteps.textContent = edgesSorted.length;\n  }\n\n  function flashEdge(edge) {\n    edge.item.classList.add('current');\n    edge.line.classList.add('current');\n    setTimeout(() => {\n      edge.item.classList.remove('current');\n      if (edge.state === 'none') edge.line.classList.remove('current');\n    }, 400);\n  }\n\n  function prepareAlgorithm() {\n    dsu = new DSU(nodes.length);\n    currentIndex = 0;\n    mstWeight = 0;\n    for (const e of edges) {\n      e.state = 'none';\n      e.line.classList.remove('accepted', 'rejected', 'current');\n      e.label.classList.remove('accepted', 'rejected');\n      if (e.item) {\n        e.item.classList.remove('accepted', 'rejected', 'current');\n      }\n    }\n    statusText.textContent = 'Ready';\n    stepCount.textContent = '0';\n    currentEdgeText.textContent = '-';\n    mstWeightEl.textContent = '0';\n    updateSetsDisplay();\n    stopAutoplay();\n    playPauseBtn.textContent = 'Play';\n    playPauseBtn.disabled = false;\n    stepFwdBtn.disabled = false;\n    stepBackBtn.disabled = false;\n    resetBtn.disabled = false;\n  }\n\n  function updateSetsDisplay() {\n    const components = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      const r = dsu.find(i);\n      if (!components.has(r)) components.set(r, []);\n      components.get(r).push(i);\n    }\n    setDisplay.innerHTML = '';\n    for (const [root, members] of components.entries()) {\n      const div = document.createElement('div');\n      div.className = 'group';\n      div.textContent = `{ ${members.join(', ')} }`;\n      setDisplay.appendChild(div);\n    }\n  }\n\n  function processNextEdge() {\n    if (currentIndex >= edgesSorted.length) {\n      statusText.textContent = 'All edges processed.';\n      stopAutoplay();\n      playPauseBtn.textContent = 'Play';\n      return;\n    }\n    // If MST is complete (n-1 edges)\n    const acceptedCount = edgesSorted.filter(e => e.state === 'accepted').length;\n    if (acceptedCount >= nodes.length - 1) {\n      statusText.textContent = 'MST complete.';\n      stopAutoplay();\n      playPauseBtn.textContent = 'Play';\n      return;\n    }\n\n    const edge = edgesSorted[currentIndex];\n    // Highlight current\n    edge.item.classList.add('current');\n    edge.line.classList.add('current');\n    currentEdgeText.textContent = `${edge.u}–${edge.v} (w=${edge.w})`;\n\n    // Decide using Union-Find\n    const ru = dsu.find(edge.u);\n    const rv = dsu.find(edge.v);\n\n    let accepted = false;\n    if (ru !== rv) {\n      dsu.union(ru, rv);\n      accepted = true;\n    }\n\n    // Apply visual state\n    edge.item.classList.remove('current');\n    edge.line.classList.remove('current');\n    if (accepted) {\n      edge.state = 'accepted';\n      edge.item.classList.add('accepted');\n      edge.line.classList.add('accepted');\n      edge.label.classList.add('accepted');\n      mstWeight += edge.w;\n      mstWeightEl.textContent = mstWeight;\n      statusText.textContent = `Accepted: ${edge.u}–${edge.v} (weight ${edge.w}). No cycle.`;\n    } else {\n      edge.state = 'rejected';\n      edge.item.classList.add('rejected');\n      edge.line.classList.add('rejected');\n      edge.label.classList.add('rejected');\n      statusText.textContent = `Rejected: ${edge.u}–${edge.v}. Cycle detected (same component).`;\n    }\n\n    currentIndex++;\n    stepCount.textContent = String(currentIndex);\n    updateSetsDisplay();\n\n    // Auto stop if MST finished\n    const newAcceptedCount = edgesSorted.filter(e => e.state === 'accepted').length;\n    if (newAcceptedCount >= nodes.length - 1) {\n      statusText.textContent = 'MST complete.';\n      stopAutoplay();\n      playPauseBtn.textContent = 'Play';\n      highlightMST();\n    }\n  }\n\n  function highlightMST() {\n    // Optional subtle glow on accepted edges\n    for (const e of edgesSorted) {\n      if (e.state === 'accepted') {\n        e.line.setAttribute('filter', 'url(#glow)');\n      } else {\n        e.line.removeAttribute('filter');\n      }\n    }\n  }\n\n  function stepBack() {\n    if (currentIndex <= 0) return;\n    // Remove last processed edge\n    currentIndex--;\n    const edge = edgesSorted[currentIndex];\n\n    // Reset edge visuals\n    edge.state = 'none';\n    edge.item.classList.remove('accepted', 'rejected', 'current');\n    edge.line.classList.remove('accepted', 'rejected', 'current');\n    edge.label.classList.remove('accepted', 'rejected');\n\n    // Rebuild DSU and MST weight based on remaining accepted edges up to currentIndex\n    dsu = new DSU(nodes.length);\n    mstWeight = 0;\n    for (let i = 0; i < currentIndex; i++) {\n      const e = edgesSorted[i];\n      if (e.state === 'accepted') {\n        dsu.union(e.u, e.v);\n        mstWeight += e.w;\n      }\n    }\n    mstWeightEl.textContent = mstWeight;\n    stepCount.textContent = String(currentIndex);\n    statusText.textContent = 'Step reverted.';\n    currentEdgeText.textContent = '-';\n    updateSetsDisplay();\n  }\n\n  function startAutoplay() {\n    if (isPlaying) return;\n    isPlaying = true;\n    playPauseBtn.textContent = 'Pause';\n    const interval = parseInt(speedInput.value, 10);\n    autoplayTimer = setInterval(() => {\n      const acceptedCount = edgesSorted.filter(e => e.state === 'accepted').length;\n      if (currentIndex >= edgesSorted.length || acceptedCount >= nodes.length - 1) {\n        stopAutoplay();\n        playPauseBtn.textContent = 'Play';\n        return;\n      }\n      processNextEdge();\n    }, interval);\n  }\n\n  function stopAutoplay() {\n    if (autoplayTimer) clearInterval(autoplayTimer);\n    autoplayTimer = null;\n    isPlaying = false;\n  }\n\n  // Events\n  newGraphBtn.addEventListener('click', () => {\n    const n = clamp(parseInt(nodeCountInput.value, 10) || 12, 3, 40);\n    nodeCountInput.value = n;\n    const density = parseFloat(densityInput.value);\n    const weightMode = weightModeSel.value;\n    generateGraph(n, density, weightMode);\n  });\n\n  resetBtn.addEventListener('click', () => prepareAlgorithm());\n\n  stepFwdBtn.addEventListener('click', () => processNextEdge());\n  stepBackBtn.addEventListener('click', () => stepBack());\n\n  playPauseBtn.addEventListener('click', () => {\n    if (isPlaying) stopAutoplay(); else startAutoplay();\n    playPauseBtn.textContent = isPlaying ? 'Pause' : 'Play';\n  });\n\n  densityInput.addEventListener('input', () => {\n    densityVal.textContent = parseFloat(densityInput.value).toFixed(2);\n  });\n\n  speedInput.addEventListener('input', () => {\n    speedVal.textContent = `${speedInput.value}ms`;\n    if (isPlaying) {\n      stopAutoplay();\n      startAutoplay();\n    }\n  });\n\n  // Initialize with a default graph\n  window.addEventListener('load', () => {\n    generateGraph(parseInt(nodeCountInput.value, 10), parseFloat(densityInput.value), weightModeSel.value);\n  });\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Kruskal’s Algorithm"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "d3f9c690-a36d-11f0-b3e0-1368ffa7231a",
    "timestamp": "2025-10-07T11:07:35.161Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Prim’s Algorithm",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Prim’s Algorithm Visualizer (Minimum Spanning Tree)</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --accent: #22c55e;\n    --accent2: #60a5fa;\n    --text: #e5e7eb;\n    --muted: #94a3b8;\n    --danger: #ef4444;\n    --edge: #64748b;\n    --visited: #124e17;\n    --start: #f59e0b;\n  }\n  * { box-sizing: border-box; }\n  body {\n    margin: 0;\n    background: radial-gradient(1200px 600px at 75% 0%, #0b1229 0%, var(--bg) 60%), var(--bg);\n    color: var(--text);\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\", sans-serif;\n  }\n  header {\n    padding: 18px 20px;\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    border-bottom: 1px solid #1f2937;\n    position: sticky;\n    top: 0;\n    background: rgba(15, 23, 42, 0.7);\n    backdrop-filter: blur(6px);\n    z-index: 10;\n  }\n  header h1 {\n    font-size: 20px;\n    margin: 0;\n    letter-spacing: 0.2px;\n  }\n  header .sub {\n    font-size: 14px;\n    color: var(--muted);\n  }\n  .container {\n    display: grid;\n    grid-template-columns: 320px 1fr;\n    gap: 12px;\n    padding: 12px;\n  }\n  .panel {\n    background: rgba(17, 24, 39, .8);\n    border: 1px solid #1f2937;\n    border-radius: 10px;\n    padding: 14px;\n  }\n  .panel h2 {\n    font-size: 16px;\n    color: var(--muted);\n    margin: 0 0 8px 0;\n    font-weight: 600;\n  }\n  .controls .row {\n    display: grid;\n    grid-template-columns: 1fr 90px;\n    align-items: center;\n    gap: 10px;\n    margin-bottom: 10px;\n  }\n  .controls label {\n    font-size: 13px;\n    color: var(--muted);\n  }\n  input[type=\"number\"], input[type=\"range\"], select {\n    width: 100%;\n  }\n  input[type=\"number\"], select {\n    background: #0b1228;\n    border: 1px solid #1f2937;\n    color: var(--text);\n    padding: 6px 8px;\n    border-radius: 8px;\n  }\n  input[type=\"range\"] {\n    accent-color: var(--accent2);\n  }\n  .buttons {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 8px;\n    margin-top: 10px;\n  }\n  button {\n    background: #0b1228;\n    border: 1px solid #1f2937;\n    color: var(--text);\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 13px;\n  }\n  button.primary {\n    background: linear-gradient(180deg, #16a34a 0%, #22c55e 100%);\n    border: none;\n    color: #06290e;\n    font-weight: 600;\n  }\n  button.warn {\n    background: linear-gradient(180deg, #ef4444 0%, #b91c1c 100%);\n    border: none;\n    color: #fff;\n    font-weight: 600;\n  }\n  button:disabled { opacity: 0.5; cursor: not-allowed; }\n  .legend {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 10px;\n    align-items: center;\n    margin-top: 10px;\n    font-size: 12px;\n    color: var(--muted);\n  }\n  .chip { display: inline-flex; align-items: center; gap: 6px; padding: 6px 8px; border-radius: 999px; border: 1px dashed #334155; background: #0b1228; }\n  .swatch { width: 14px; height: 14px; border-radius: 50%; }\n  .sw-edge { width: 18px; height: 3px; border-radius: 2px; }\n  .sw-mst { background: var(--accent); }\n  .sw-frontier { background: var(--accent2); }\n  .sw-last { background: var(--danger); }\n  .sw-default { background: var(--edge); }\n  .sw-visited { background: var(--visited); }\n  .sw-start { background: var(--start); }\n  .canvas-wrap {\n    position: relative;\n    height: calc(100vh - 170px);\n    min-height: 420px;\n  }\n  canvas {\n    width: 100%;\n    height: 100%;\n    display: block;\n    border-radius: 10px;\n    background:\n      radial-gradient(900px 500px at 20% 0%, rgba(96, 165, 250, 0.09) 0%, rgba(0,0,0,0) 60%),\n      radial-gradient(900px 500px at 80% 100%, rgba(34, 197, 94, 0.09) 0%, rgba(0,0,0,0) 60%),\n      #0b1228;\n    border: 1px solid #1f2937;\n  }\n  .stats {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 10px;\n    margin-top: 10px;\n    font-size: 13px;\n  }\n  .stats .item {\n    background: #0b1228;\n    border: 1px solid #1f2937;\n    border-radius: 8px;\n    padding: 8px;\n  }\n  .stats .label { color: var(--muted); }\n  .stats .value { font-weight: 600; }\n  .pseudo {\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n    font-size: 12px;\n    background: #0b1228;\n    border: 1px solid #1f2937;\n    border-radius: 8px;\n    padding: 8px;\n    color: #cbd5e1;\n    line-height: 1.4;\n    white-space: pre-wrap;\n  }\n  .notice {\n    font-size: 12px;\n    color: var(--muted);\n    margin-top: 8px;\n  }\n  a {\n    color: #a5b4fc;\n    text-decoration: none;\n  }\n  a:hover { text-decoration: underline; }\n  .kbd {\n    padding: 2px 6px; background: #0b1228; border: 1px solid #1f2937; border-radius: 6px; font-size: 12px;\n  }\n  @media (max-width: 980px) {\n    .container {\n      grid-template-columns: 1fr;\n    }\n    header { position: static; }\n    .canvas-wrap { height: 60vh; }\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Prim’s Algorithm</h1>\n  <div class=\"sub\">Interactive Minimum Spanning Tree builder for an undirected weighted graph</div>\n</header>\n\n<div class=\"container\">\n  <div class=\"panel controls\">\n    <h2>Graph Controls</h2>\n\n    <div class=\"row\">\n      <label>Nodes</label>\n      <input id=\"nodesCount\" type=\"number\" min=\"3\" max=\"60\" step=\"1\" value=\"12\" />\n    </div>\n    <div class=\"row\">\n      <label>Extra edge probability</label>\n      <input id=\"edgeProb\" type=\"range\" min=\"0\" max=\"1\" step=\"0.02\" value=\"0.28\" />\n    </div>\n    <div class=\"row\">\n      <label>Weights</label>\n      <select id=\"weightMode\">\n        <option value=\"random\">Random 1..20</option>\n        <option value=\"distance\">Euclidean distance</option>\n      </select>\n    </div>\n    <div class=\"row\">\n      <label>Auto-run speed (steps/sec)</label>\n      <input id=\"speed\" type=\"range\" min=\"0.5\" max=\"10\" step=\"0.5\" value=\"2.5\" />\n    </div>\n\n    <div class=\"buttons\">\n      <button id=\"genBtn\">Generate Graph</button>\n      <button id=\"resetBtn\">Reset Algorithm</button>\n      <button id=\"stepBtn\">Step</button>\n      <button id=\"startBtn\" class=\"primary\">Start Auto</button>\n      <button id=\"pauseBtn\">Pause</button>\n      <button id=\"runAllBtn\">Run to End</button>\n    </div>\n\n    <div class=\"legend\">\n      <div class=\"chip\"><div class=\"sw-edge sw-default\"></div> Edge</div>\n      <div class=\"chip\"><div class=\"sw-edge sw-mst\"></div> In MST</div>\n      <div class=\"chip\"><div class=\"sw-edge sw-frontier\"></div> Frontier</div>\n      <div class=\"chip\"><div class=\"sw-edge sw-last\"></div> Chosen edge</div>\n      <div class=\"chip\"><div class=\"swatch sw-visited\"></div> Visited node</div>\n      <div class=\"chip\"><div class=\"swatch sw-start\"></div> Start node</div>\n    </div>\n\n    <div class=\"stats\">\n      <div class=\"item\">\n        <div class=\"label\">Status</div>\n        <div class=\"value\" id=\"status\">Ready</div>\n      </div>\n      <div class=\"item\">\n        <div class=\"label\">MST total weight</div>\n        <div class=\"value\" id=\"mstWeight\">0</div>\n      </div>\n      <div class=\"item\">\n        <div class=\"label\">Visited nodes</div>\n        <div class=\"value\" id=\"visitedCount\">0</div>\n      </div>\n      <div class=\"item\">\n        <div class=\"label\">Frontier edges</div>\n        <div class=\"value\" id=\"frontierCount\">0</div>\n      </div>\n    </div>\n\n    <h2 style=\"margin-top:14px;\">How it works</h2>\n    <div class=\"pseudo\">\nStart with any node (click a node to choose the start).\nVisited = {start}\nFrontier = edges that connect Visited to Unvisited\n\nRepeat until all nodes are visited:\n  - Pick the minimum-weight edge from Frontier\n    that connects to an Unvisited node\n  - Add that edge to MST\n  - Add the new node to Visited\n  - Update Frontier\n\nResult: MST contains N-1 edges with minimum total weight\nfor the connected graph.\n    </div>\n    <div class=\"notice\">\n      Tip: Click a node to set the start. Use Step to see choices, or Start Auto to watch it run. Press Pause anytime.\n      Keyboard: <span class=\"kbd\">Space</span> = Step, <span class=\"kbd\">Enter</span> = Start/Pause.\n    </div>\n  </div>\n\n  <div class=\"panel\">\n    <h2>Graph (click a node to choose start)</h2>\n    <div class=\"canvas-wrap\">\n      <canvas id=\"canvas\"></canvas>\n    </div>\n  </div>\n</div>\n\n<script>\n(function() {\n  // Canvas setup\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  function resizeCanvas() {\n    const rect = canvas.getBoundingClientRect();\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = Math.floor(rect.width * dpr);\n    canvas.height = Math.floor(rect.height * dpr);\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawing to CSS pixels\n    draw();\n  }\n  window.addEventListener('resize', () => {\n    resizeCanvas();\n  });\n\n  // UI elements\n  const nodesCountEl = document.getElementById('nodesCount');\n  const edgeProbEl = document.getElementById('edgeProb');\n  const weightModeEl = document.getElementById('weightMode');\n  const speedEl = document.getElementById('speed');\n\n  const genBtn = document.getElementById('genBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const startBtn = document.getElementById('startBtn');\n  const pauseBtn = document.getElementById('pauseBtn');\n  const runAllBtn = document.getElementById('runAllBtn');\n\n  const statusEl = document.getElementById('status');\n  const mstWeightEl = document.getElementById('mstWeight');\n  const visitedCountEl = document.getElementById('visitedCount');\n  const frontierCountEl = document.getElementById('frontierCount');\n\n  // Graph + algorithm state\n  let nodes = [];          // {id, x, y}\n  let edges = [];          // {u, v, w, key}\n  let adj = new Map();     // id -> [{to, w}]\n  let edgeByKey = new Map();\n\n  let startNode = 0;\n  let visited = new Set();\n  let mstEdges = [];       // array of edges\n  let frontierKeys = new Set();\n  let lastChosenKey = null;\n  let stepCount = 0;\n  let running = false;\n  let rafTimer = null;     // for auto-run via rAF\n  let nextStepTime = 0;\n\n  // Utility\n  function keyFor(u, v) {\n    return u < v ? `${u}-${v}` : `${v}-${u}`;\n  }\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n  function clamp(x, a, b) {\n    return Math.max(a, Math.min(b, x));\n  }\n\n  function updateStats() {\n    mstWeightEl.textContent = mstEdges.reduce((s,e)=>s+e.w,0);\n    visitedCountEl.textContent = visited.size + ' / ' + nodes.length;\n    frontierCountEl.textContent = frontierKeys.size;\n    const done = visited.size === nodes.length;\n    statusEl.textContent = done ? 'Done (MST complete)' : (running ? 'Auto-running...' : 'Ready');\n  }\n\n  // Graph generation: produce a connected undirected weighted graph\n  function generateGraph(n, prob, mode) {\n    // Layout: random positions with padding\n    nodes = [];\n    const rect = canvas.getBoundingClientRect();\n    const W = rect.width, H = rect.height;\n    const pad = 30;\n    for (let i = 0; i < n; i++) {\n      const x = randInt(pad, W - pad);\n      const y = randInt(pad, H - pad);\n      nodes.push({ id: i, x, y });\n    }\n\n    edges = [];\n    edgeByKey.clear();\n    adj = new Map();\n    nodes.forEach(node => adj.set(node.id, []));\n\n    // Ensure connectivity by building a random spanning tree first\n    for (let i = 1; i < n; i++) {\n      const j = randInt(0, i - 1);\n      addEdge(i, j, mode);\n    }\n    // Add extra random edges with probability\n    for (let i = 0; i < n; i++) {\n      for (let j = i + 1; j < n; j++) {\n        const k = keyFor(i, j);\n        if (!edgeByKey.has(k) && Math.random() < prob) {\n          addEdge(i, j, mode);\n        }\n      }\n    }\n\n    // Choose default start\n    startNode = 0;\n    resetAlgorithm(false);\n  }\n\n  function addEdge(u, v, mode) {\n    const k = keyFor(u, v);\n    if (edgeByKey.has(k)) return;\n    const a = nodes[u], b = nodes[v];\n    const dist = Math.hypot(a.x - b.x, a.y - b.y);\n    let w;\n    if (mode === 'distance') {\n      // Scale distance to a reasonable integer weight\n      const scale = Math.max(canvas.getBoundingClientRect().width, canvas.getBoundingClientRect().height);\n      const factor = scale / 20; // tune for typical weights ~ 1..40\n      w = Math.max(1, Math.round(dist / (factor / 10)));\n    } else {\n      w = randInt(1, 20);\n    }\n    const e = { u, v, w, key: k };\n    edges.push(e);\n    edgeByKey.set(k, e);\n    adj.get(u).push({ to: v, w });\n    adj.get(v).push({ to: u, w });\n  }\n\n  // Prim's algorithm helpers\n  function recomputeFrontier() {\n    frontierKeys.clear();\n    for (const e of edges) {\n      const vu = visited.has(e.u);\n      const vv = visited.has(e.v);\n      if (vu ^ vv) {\n        frontierKeys.add(e.key);\n      }\n    }\n  }\n\n  function stepPrim() {\n    // If complete or invalid, stop\n    if (!nodes.length || !edges.length) return false;\n    if (visited.size === nodes.length) return false;\n\n    // Initialize: add start to visited\n    if (visited.size === 0) {\n      visited.add(startNode);\n      recomputeFrontier();\n    }\n\n    // Pick minimum crossing edge\n    let minEdge = null;\n    for (const key of frontierKeys) {\n      const e = edgeByKey.get(key);\n      if (!e) continue;\n      const vu = visited.has(e.u);\n      const vv = visited.has(e.v);\n      if (vu ^ vv) {\n        if (!minEdge || e.w < minEdge.w) {\n          minEdge = e;\n        }\n      }\n    }\n    if (!minEdge) {\n      // Graph might be disconnected (shouldn't with our generator), or we are done\n      return false;\n    }\n\n    // Add the chosen edge to MST and its new vertex to visited\n    mstEdges.push(minEdge);\n    lastChosenKey = minEdge.key;\n    const newVertex = visited.has(minEdge.u) ? minEdge.v : minEdge.u;\n    visited.add(newVertex);\n\n    // Update frontier\n    recomputeFrontier();\n\n    stepCount++;\n    updateStats();\n    draw();\n    return true;\n  }\n\n  function resetAlgorithm(clearMST = true) {\n    visited = new Set();\n    frontierKeys = new Set();\n    lastChosenKey = null;\n    stepCount = 0;\n    if (clearMST) mstEdges = [];\n    stopAutoRun();\n    updateStats();\n    draw();\n  }\n\n  // Auto-run loop using requestAnimationFrame for smooth timing\n  function startAutoRun() {\n    if (running) return;\n    running = true;\n    statusEl.textContent = 'Auto-running...';\n    const stepsPerSec = parseFloat(speedEl.value);\n    const intervalMs = 1000 / clamp(stepsPerSec, 0.5, 10);\n    let lastTS = performance.now();\n    nextStepTime = lastTS + intervalMs;\n\n    function tick(ts) {\n      if (!running) return;\n      if (ts >= nextStepTime) {\n        const didStep = stepPrim();\n        nextStepTime += intervalMs;\n        if (!didStep) {\n          stopAutoRun();\n          statusEl.textContent = 'Done (MST complete)';\n          return;\n        }\n      }\n      rafTimer = requestAnimationFrame(tick);\n    }\n    rafTimer = requestAnimationFrame(tick);\n  }\n\n  function stopAutoRun() {\n    running = false;\n    if (rafTimer) cancelAnimationFrame(rafTimer);\n    rafTimer = null;\n    updateStats();\n  }\n\n  // Drawing\n  function draw() {\n    if (!ctx) return;\n    const rect = canvas.getBoundingClientRect();\n    ctx.clearRect(0, 0, rect.width, rect.height);\n\n    // Draw edges\n    ctx.lineCap = 'round';\n    for (const e of edges) {\n      const a = nodes[e.u], b = nodes[e.v];\n      let color = '#64748b';\n      let width = 2;\n      let dash = [];\n\n      const inMST = mstEdges.find(me => me.key === e.key);\n      const inFrontier = frontierKeys.has(e.key);\n      const isLast = (lastChosenKey === e.key);\n\n      if (inMST) { color = '#22c55e'; width = 3.2; }\n      if (inFrontier) { color = '#60a5fa'; dash = [8, 6]; width = Math.max(width, 2.4); }\n      if (isLast) { color = '#ef4444'; width = 4; dash = []; }\n\n      ctx.strokeStyle = color;\n      ctx.lineWidth = width;\n      ctx.setLineDash(dash);\n      ctx.beginPath();\n      ctx.moveTo(a.x, a.y);\n      ctx.lineTo(b.x, b.y);\n      ctx.stroke();\n      ctx.setLineDash([]);\n\n      // Weight label near midpoint\n      const mx = (a.x + b.x) / 2;\n      const my = (a.y + b.y) / 2;\n      const label = String(e.w);\n      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial';\n      const tw = ctx.measureText(label).width;\n      const pad = 3;\n      // draw background rounded rect\n      const bgx = mx - tw/2 - pad, bgy = my - 9, bgw = tw + pad*2, bgh = 16;\n      ctx.fillStyle = 'rgba(255,255,255,0.12)';\n      roundRect(ctx, bgx, bgy, bgw, bgh, 5);\n      ctx.fill();\n      ctx.strokeStyle = 'rgba(255,255,255,0.22)';\n      ctx.lineWidth = 1;\n      ctx.stroke();\n      // text\n      ctx.fillStyle = '#e5e7eb';\n      ctx.fillText(label, mx - tw/2, my + 4);\n    }\n\n    // Draw nodes\n    for (const n of nodes) {\n      const r = 13;\n      const isVisited = visited.has(n.id);\n      const isStart = (n.id === startNode);\n\n      // Node fill\n      ctx.beginPath();\n      ctx.arc(n.x, n.y, r, 0, Math.PI*2);\n      ctx.fillStyle = isVisited ? '#124e17' : '#0b1228';\n      ctx.fill();\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = '#1f2937';\n      ctx.stroke();\n\n      // Start ring\n      if (isStart) {\n        ctx.beginPath();\n        ctx.arc(n.x, n.y, r+4, 0, Math.PI*2);\n        ctx.strokeStyle = '#f59e0b';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n      }\n\n      // Node label\n      const label = String(n.id);\n      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial';\n      const tw = ctx.measureText(label).width;\n      ctx.fillStyle = '#e5e7eb';\n      ctx.fillText(label, n.x - tw/2, n.y + 4);\n    }\n  }\n\n  function roundRect(ctx, x, y, w, h, r) {\n    const radius = Math.min(r, w/2, h/2);\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.arcTo(x + w, y, x + w, y + h, radius);\n    ctx.arcTo(x + w, y + h, x, y + h, radius);\n    ctx.arcTo(x, y + h, x, y, radius);\n    ctx.arcTo(x, y, x + w, y, radius);\n    ctx.closePath();\n  }\n\n  // Canvas interactions: select start node by click\n  canvas.addEventListener('click', (ev) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = ev.clientX - rect.left;\n    const y = ev.clientY - rect.top;\n    let clicked = null;\n    for (const n of nodes) {\n      const d = Math.hypot(n.x - x, n.y - y);\n      if (d <= 14) { clicked = n.id; break; }\n    }\n    if (clicked != null) {\n      if (running) return; // ignore during auto run\n      startNode = clicked;\n      resetAlgorithm(true);\n      draw();\n    }\n  });\n\n  // Keyboard shortcuts\n  window.addEventListener('keydown', (ev) => {\n    if (ev.key === ' ') {\n      ev.preventDefault();\n      if (!running) stepPrim();\n    } else if (ev.key === 'Enter') {\n      ev.preventDefault();\n      if (running) {\n        stopAutoRun();\n      } else {\n        startAutoRun();\n      }\n    }\n  });\n\n  // Controls events\n  genBtn.addEventListener('click', () => {\n    const n = clamp(parseInt(nodesCountEl.value || '12', 10), 3, 60);\n    const p = clamp(parseFloat(edgeProbEl.value || '0.28'), 0, 1);\n    const mode = weightModeEl.value;\n    generateGraph(n, p, mode);\n  });\n  resetBtn.addEventListener('click', () => resetAlgorithm(true));\n  stepBtn.addEventListener('click', () => {\n    if (!running) stepPrim();\n  });\n  startBtn.addEventListener('click', () => startAutoRun());\n  pauseBtn.addEventListener('click', () => stopAutoRun());\n  runAllBtn.addEventListener('click', () => {\n    stopAutoRun();\n    let guard = 0;\n    while (visited.size < nodes.length) {\n      if (!stepPrim()) break;\n      if (++guard > 10000) break; // safety\n    }\n  });\n\n  speedEl.addEventListener('input', () => {\n    // If running, restart with new speed\n    if (running) {\n      stopAutoRun();\n      startAutoRun();\n    }\n  });\n\n  // Initial graph\n  resizeCanvas();\n  generateGraph(parseInt(nodesCountEl.value,10), parseFloat(edgeProbEl.value), weightModeEl.value);\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Prim’s Algorithm"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "1459b9c0-a36e-11f0-ac69-a55463918934",
    "timestamp": "2025-10-07T11:09:23.164Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Topological Sort",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<title>Topological Sort Visualizer (Kahn's Algorithm)</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --panel2: #0b1220;\n    --text: #e5e7eb;\n    --muted: #9ca3af;\n    --accent: #34d399;\n    --accent2: #60a5fa;\n    --warn: #fbbf24;\n    --danger: #f87171;\n    --edge: #64748b;\n    --edge-faded: #334155;\n  }\n  html, body {\n    margin: 0;\n    height: 100%;\n    color: var(--text);\n    background: linear-gradient(180deg, #0b1220 0%, #0f172a 100%);\n    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n  }\n  .container {\n    display: grid;\n    grid-template-columns: 340px 1fr;\n    gap: 16px;\n    height: 100%;\n    padding: 16px;\n    box-sizing: border-box;\n  }\n  .panel {\n    background: radial-gradient(120% 140% at 0% 0%, var(--panel) 0%, var(--panel2) 70%);\n    border: 1px solid #1f2937;\n    border-radius: 12px;\n    box-shadow: 0 4px 30px rgba(0,0,0,0.35);\n  }\n  .left {\n    padding: 16px;\n    display: flex;\n    flex-direction: column;\n    gap: 12px;\n    min-height: 0;\n  }\n  .title {\n    font-weight: 700;\n    font-size: 18px;\n    letter-spacing: 0.2px;\n  }\n  .subtitle {\n    color: var(--muted);\n    font-size: 12px;\n    line-height: 1.4;\n  }\n  textarea {\n    width: 100%;\n    min-height: 140px;\n    resize: vertical;\n    border-radius: 10px;\n    border: 1px solid #1f2937;\n    background: #0b1220;\n    color: var(--text);\n    padding: 10px 12px;\n    box-sizing: border-box;\n    outline: none;\n  }\n  textarea::placeholder {\n    color: #60708d;\n  }\n  .btn-row {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 8px;\n  }\n  button {\n    background: #0b1220;\n    border: 1px solid #1f2937;\n    color: var(--text);\n    border-radius: 10px;\n    padding: 8px 12px;\n    cursor: pointer;\n    transition: all 0.15s ease;\n    font-weight: 600;\n  }\n  button:hover {\n    border-color: #334155;\n    transform: translateY(-1px);\n  }\n  .btn-primary {\n    background: linear-gradient(180deg, #0ea5e9 0%, #0284c7 100%);\n    border: none;\n    color: white;\n  }\n  .btn-accent {\n    background: linear-gradient(180deg, #10b981 0%, #059669 100%);\n    border: none;\n    color: white;\n  }\n  .btn-danger {\n    background: linear-gradient(180deg, #ef4444 0%, #dc2626 100%);\n    border: none;\n    color: white;\n  }\n  .controls {\n    padding: 12px 16px;\n    display: flex;\n    flex-direction: column;\n    gap: 12px;\n  }\n  .chips {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 6px;\n  }\n  .chip {\n    padding: 6px 10px;\n    border-radius: 999px;\n    font-weight: 700;\n    font-size: 12px;\n    border: 1px solid #1f2937;\n    background: #0b1220;\n    color: var(--text);\n  }\n  .chip.queue {\n    background: rgba(16,185,129,0.12);\n    border-color: rgba(16,185,129,0.35);\n    color: #a7f3d0;\n  }\n  .chip.done {\n    background: rgba(96,165,250,0.14);\n    border-color: rgba(96,165,250,0.35);\n    color: #bfdbfe;\n  }\n  .chip.warn {\n    background: rgba(234,179,8,0.12);\n    border-color: rgba(234,179,8,0.35);\n    color: #fde68a;\n  }\n  .legend {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 10px;\n    color: var(--muted);\n    font-size: 12px;\n  }\n  .legend .dot {\n    display: inline-block;\n    width: 10px;\n    height: 10px;\n    border-radius: 50%;\n    margin-right: 6px;\n    vertical-align: -1px;\n  }\n  .dot-ready { background: #10b981; }\n  .dot-processed { background: #60a5fa; }\n  .dot-pending { background: #64748b; }\n  .dot-cyclic { background: #f87171; }\n  .right {\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    overflow: hidden;\n  }\n  .canvas-wrap {\n    position: relative;\n    padding: 12px;\n    min-height: 380px;\n  }\n  svg {\n    width: 100%;\n    height: 100%;\n    min-height: 420px;\n    display: block;\n    border-radius: 12px;\n    background:\n      radial-gradient(120% 120% at 0% 0%, rgba(45, 212, 191, 0.04) 0%, transparent 50%) no-repeat,\n      radial-gradient(140% 140% at 100% 0%, rgba(99, 102, 241, 0.04) 0%, transparent 50%) no-repeat,\n      radial-gradient(200% 200% at 50% 100%, rgba(14, 165, 233, 0.05) 0%, transparent 60%) no-repeat,\n      #0b1220;\n    border: 1px solid #1f2937;\n  }\n  .edge {\n    stroke: var(--edge);\n    stroke-width: 2;\n    opacity: 0.95;\n  }\n  .edge.faded {\n    stroke: var(--edge-faded);\n    opacity: 0.4;\n  }\n  .edge.cyclic {\n    stroke: var(--danger);\n    opacity: 0.9;\n  }\n  .node {\n    cursor: grab;\n  }\n  .node:active {\n    cursor: grabbing;\n  }\n  .node circle {\n    fill: #0b1220;\n    stroke: #334155;\n    stroke-width: 2px;\n    transition: all 0.2s ease;\n  }\n  .node text {\n    fill: #cbd5e1;\n    font-weight: 800;\n    pointer-events: none;\n    text-shadow: 0 1px 0 rgba(0,0,0,0.3);\n  }\n  .node.pending circle {\n    stroke: #334155;\n  }\n  .node.ready circle {\n    stroke: #10b981;\n    filter: drop-shadow(0 0 8px rgba(16,185,129,0.4));\n  }\n  .node.processed circle {\n    stroke: #60a5fa;\n    filter: drop-shadow(0 0 10px rgba(96,165,250,0.35));\n  }\n  .node.cyclic circle {\n    stroke: #f87171;\n    filter: drop-shadow(0 0 10px rgba(248,113,113,0.5));\n  }\n  .top-bar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: 12px 16px 4px 16px;\n  }\n  .top-bar .controls-row {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n  }\n  .slider {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    color: var(--muted);\n    font-size: 12px;\n  }\n  input[type=range] {\n    width: 160px;\n  }\n  .status {\n    padding: 10px 16px 16px 16px;\n    color: var(--muted);\n    font-size: 13px;\n  }\n  .status strong {\n    color: var(--text);\n  }\n  .footer {\n    padding: 10px 16px 16px 16px;\n    color: var(--muted);\n    font-size: 12px;\n    display: flex;\n    justify-content: space-between;\n  }\n  .info {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 12px;\n  }\n  .info .panel {\n    padding: 12px;\n  }\n  .mono {\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  }\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <div class=\"panel left\">\n    <div class=\"title\">Topological Sort</div>\n    <div class=\"subtitle\">\n      Visualize Kahn's algorithm for topological sorting on a directed graph (DAG).\n      Enter edges below, one per line. Supported formats:\n      A->B, A B, A,B, or a single node per line to include isolated nodes.\n    </div>\n    <textarea id=\"edgesInput\" placeholder=\"Examples:\nA->B\nA->C\nB->D\nC->D\n\nOr include isolated nodes:\nX\nY\n\nAlso accepted: A B or A,B\n\"></textarea>\n    <div class=\"btn-row\">\n      <button id=\"btnParse\" class=\"btn-primary\">Build Graph</button>\n      <button id=\"btnRandom\">Random DAG</button>\n      <button id=\"btnSample1\">Chain</button>\n      <button id=\"btnSample2\">Diamond</button>\n      <button id=\"btnSample3\">Course Prereqs</button>\n      <button id=\"btnSample4\" class=\"btn-danger\">Cycle Example</button>\n    </div>\n    <div class=\"panel controls\">\n      <div class=\"legend\">\n        <span><span class=\"dot dot-ready\"></span>Ready (indegree 0)</span>\n        <span><span class=\"dot dot-processed\"></span>Processed</span>\n        <span><span class=\"dot dot-pending\"></span>Pending</span>\n        <span><span class=\"dot dot-cyclic\"></span>Cyclic/Unresolved</span>\n      </div>\n      <div class=\"info\">\n        <div class=\"panel\">\n          <div style=\"font-weight:700;margin-bottom:6px;\">Queue (Zero Indegree)</div>\n          <div id=\"queueView\" class=\"chips\"></div>\n        </div>\n        <div class=\"panel\">\n          <div style=\"font-weight:700;margin-bottom:6px;\">Topological Order</div>\n          <div id=\"orderView\" class=\"chips\"></div>\n        </div>\n      </div>\n    </div>\n    <div class=\"subtitle mono\" style=\"opacity:0.85\">\n      Tips:\n      - Click Build Graph after editing edges.\n      - Step to advance one node at a time.\n      - Play to animate. Drag nodes to reposition them.\n      - If a cycle exists, the algorithm will stop when the queue is empty.\n    </div>\n  </div>\n  <div class=\"right panel\">\n    <div class=\"top-bar\">\n      <div class=\"controls-row\">\n        <button id=\"btnStep\">Step</button>\n        <button id=\"btnPlay\" class=\"btn-accent\">Play</button>\n        <button id=\"btnReset\">Reset</button>\n      </div>\n      <div class=\"controls-row\">\n        <div class=\"slider\">\n          Speed\n          <input id=\"speed\" type=\"range\" min=\"100\" max=\"1500\" step=\"50\" value=\"650\" />\n        </div>\n      </div>\n    </div>\n    <div class=\"canvas-wrap\">\n      <svg id=\"svg\" viewBox=\"0 0 1000 620\" preserveAspectRatio=\"xMidYMid meet\">\n        <defs>\n          <marker id=\"arrow\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\"\n                  markerWidth=\"8\" markerHeight=\"8\" orient=\"auto-start-reverse\">\n            <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#64748b\"></path>\n          </marker>\n          <marker id=\"arrowFaded\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\"\n                  markerWidth=\"8\" markerHeight=\"8\" orient=\"auto-start-reverse\">\n            <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#334155\"></path>\n          </marker>\n          <marker id=\"arrowDanger\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\"\n                  markerWidth=\"8\" markerHeight=\"8\" orient=\"auto-start-reverse\">\n            <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#f87171\"></path>\n          </marker>\n        </defs>\n        <g id=\"edgesLayer\"></g>\n        <g id=\"nodesLayer\"></g>\n      </svg>\n    </div>\n    <div class=\"status\" id=\"status\">\n      Provide a directed acyclic graph (DAG) and press Build Graph. Then Step or Play to see Kahn's algorithm:\n      - Start with all nodes of indegree 0 in the queue.\n      - Repeatedly remove one, append to the order, and decrement indegrees of its neighbors.\n      - If the queue becomes empty before all nodes are processed, a cycle exists.\n    </div>\n    <div class=\"footer\">\n      <div>\n        Algorithm: Kahn's algorithm\n      </div>\n      <div>\n        Drag nodes to rearrange. Edges fade when removed.\n      </div>\n    </div>\n  </div>\n</div>\n\n<script>\n(function(){\n  const svg = document.getElementById('svg');\n  const edgesLayer = document.getElementById('edgesLayer');\n  const nodesLayer = document.getElementById('nodesLayer');\n\n  const input = document.getElementById('edgesInput');\n  const btnParse = document.getElementById('btnParse');\n  const btnRandom = document.getElementById('btnRandom');\n  const btnSample1 = document.getElementById('btnSample1');\n  const btnSample2 = document.getElementById('btnSample2');\n  const btnSample3 = document.getElementById('btnSample3');\n  const btnSample4 = document.getElementById('btnSample4');\n  const btnStep = document.getElementById('btnStep');\n  const btnPlay = document.getElementById('btnPlay');\n  const btnReset = document.getElementById('btnReset');\n  const queueView = document.getElementById('queueView');\n  const orderView = document.getElementById('orderView');\n  const statusEl = document.getElementById('status');\n  const speed = document.getElementById('speed');\n\n  const NODE_RADIUS = 22;\n\n  let graph = {\n    nodes: [],           // array of node ids (labels)\n    edges: [],           // array of {from, to}\n    adj: new Map(),      // label -> array of neighbors\n    indegree0: new Map(),// label -> indegree (initial)\n    positions: new Map(),// label -> {x,y}\n    edgeIds: new Set(),  // keep unique edges\n  };\n\n  let run = {\n    indegree: new Map(), // current indegrees\n    queue: [],           // nodes with zero indegree\n    processed: new Set(),\n    order: [],\n    edgesRemoved: new Set(), // edge signature \"from->to\"\n    playing: false,\n    timer: null,\n    cycleDetected: false\n  };\n\n  function resetRunState() {\n    run.indegree = new Map(graph.indegree0);\n    run.queue = zeroIndegreeList(run.indegree);\n    run.processed = new Set();\n    run.order = [];\n    run.edgesRemoved = new Set();\n    run.playing = false;\n    run.cycleDetected = false;\n    clearInterval(run.timer);\n    run.timer = null;\n    btnPlay.textContent = 'Play';\n    updateUI();\n    updateStyles();\n  }\n\n  function zeroIndegreeList(ind) {\n    const arr = [];\n    for (const [k, v] of ind.entries()) if (v === 0) arr.push(k);\n    arr.sort(lexCmp);\n    return arr;\n  }\n\n  function lexCmp(a, b) {\n    const sA = a.toString(), sB = b.toString();\n    return sA.localeCompare(sB, undefined, {numeric: true, sensitivity: 'base'});\n  }\n\n  function parseInput(text) {\n    const nodes = new Set();\n    const edgesSet = new Set();\n    const edges = [];\n    const lines = (text || '').split(/\\r?\\n/);\n\n    function parseLine(line) {\n      let l = line.trim();\n      if (!l) return;\n      // Accept comments after '#'\n      const hash = l.indexOf('#');\n      if (hash >= 0) l = l.substring(0, hash).trim();\n      if (!l) return;\n      let tokens = l.split(/->|=>|,|:|\\s+/).filter(Boolean);\n      if (tokens.length === 1) {\n        nodes.add(tokens[0]);\n        return;\n      }\n      if (tokens.length >= 2) {\n        const from = tokens[0];\n        const to = tokens[1];\n        nodes.add(from);\n        nodes.add(to);\n        const sig = from + '->' + to;\n        if (!edgesSet.has(sig)) {\n          edgesSet.add(sig);\n          edges.push({from, to});\n        }\n      }\n    }\n\n    for (const line of lines) parseLine(line);\n\n    return {nodes: Array.from(nodes), edges};\n  }\n\n  function buildGraphFromInput() {\n    const {nodes, edges} = parseInput(input.value);\n    if (nodes.length === 0 && edges.length === 0) {\n      setStatus('No nodes found. Enter edges or node names and press Build Graph.');\n      return;\n    }\n    buildGraph(nodes, edges);\n    resetRunState();\n    layoutCircular();\n    drawGraph();\n    setStatus('Graph built. Nodes: ' + graph.nodes.length + ', Edges: ' + graph.edges.length + '. Press Step or Play.');\n  }\n\n  function buildGraph(nodesList, edgesList) {\n    graph.nodes = [...nodesList].sort(lexCmp);\n    graph.edges = [];\n    graph.adj = new Map();\n    graph.indegree0 = new Map();\n    graph.positions = new Map();\n    graph.edgeIds = new Set();\n\n    for (const n of graph.nodes) {\n      graph.adj.set(n, []);\n      graph.indegree0.set(n, 0);\n    }\n    for (const e of edgesList) {\n      const {from, to} = e;\n      if (!graph.adj.has(from)) {\n        graph.adj.set(from, []);\n        graph.indegree0.set(from, 0);\n        graph.nodes.push(from);\n      }\n      if (!graph.adj.has(to)) {\n        graph.adj.set(to, []);\n        graph.indegree0.set(to, 0);\n        graph.nodes.push(to);\n      }\n      const sig = from + '->' + to;\n      if (!graph.edgeIds.has(sig)) {\n        graph.edges.push({from, to});\n        graph.edgeIds.add(sig);\n        graph.adj.get(from).push(to);\n        graph.indegree0.set(to, graph.indegree0.get(to) + 1);\n      }\n    }\n    graph.nodes.sort(lexCmp);\n  }\n\n  function layoutCircular() {\n    // Arrange nodes on a circle; center & radius based on viewBox.\n    // viewBox 0 0 1000 620\n    const W = 1000, H = 620;\n    const cx = W / 2, cy = H / 2;\n    const n = graph.nodes.length;\n    const R = Math.max(120, Math.min(cx, cy) - 60);\n    for (let i = 0; i < n; i++) {\n      const angle = 2 * Math.PI * (i / n) - Math.PI / 2;\n      const x = cx + R * Math.cos(angle);\n      const y = cy + R * Math.sin(angle);\n      graph.positions.set(graph.nodes[i], {x, y});\n    }\n  }\n\n  function drawGraph() {\n    // Clear layers\n    edgesLayer.innerHTML = '';\n    nodesLayer.innerHTML = '';\n\n    // Draw edges\n    for (const e of graph.edges) {\n      const id = edgeId(e.from, e.to);\n      const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n      line.setAttribute('id', id);\n      line.classList.add('edge');\n      line.setAttribute('marker-end', 'url(#arrow)');\n      edgesLayer.appendChild(line);\n    }\n\n    // Draw nodes\n    for (const node of graph.nodes) {\n      const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      g.setAttribute('id', nodeId(node));\n      g.classList.add('node', 'pending');\n      g.dataset.label = node;\n\n      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n      circle.setAttribute('r', NODE_RADIUS);\n      circle.setAttribute('cx', 0);\n      circle.setAttribute('cy', 0);\n\n      const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n      text.setAttribute('x', 0);\n      text.setAttribute('y', 5);\n      text.setAttribute('text-anchor', 'middle');\n      const label = node.toString();\n      const fontSize = label.length > 8 ? 10 : (label.length > 5 ? 12 : 14);\n      text.setAttribute('font-size', fontSize);\n      text.textContent = label;\n\n      // indegree badge\n      const badge = document.createElementNS('http://www.w3.org/2000/svg','text');\n      badge.setAttribute('x', NODE_RADIUS + 12);\n      badge.setAttribute('y', -NODE_RADIUS + 4);\n      badge.setAttribute('text-anchor', 'start');\n      badge.setAttribute('font-size', 11);\n      badge.setAttribute('fill', '#93c5fd');\n      badge.setAttribute('class', 'indegree');\n      badge.textContent = 'deg: 0';\n\n      g.appendChild(circle);\n      g.appendChild(text);\n      g.appendChild(badge);\n\n      nodesLayer.appendChild(g);\n\n      // Set initial position\n      const pos = graph.positions.get(node) || {x: 100, y: 100};\n      g.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);\n\n      enableDrag(g);\n    }\n\n    updateEdgesPositions();\n    updateStyles();\n    updateUI();\n  }\n\n  function updateEdgesPositions() {\n    for (const e of graph.edges) {\n      const line = document.getElementById(edgeId(e.from, e.to));\n      if (!line) continue;\n      const A = graph.positions.get(e.from);\n      const B = graph.positions.get(e.to);\n      if (!A || !B) continue;\n      const pts = edgeEndpoints(A, B, NODE_RADIUS);\n      line.setAttribute('x1', pts.x1);\n      line.setAttribute('y1', pts.y1);\n      line.setAttribute('x2', pts.x2);\n      line.setAttribute('y2', pts.y2);\n    }\n  }\n\n  function updateStyles() {\n    // Node styles: ready, processed, pending, cyclic\n    for (const n of graph.nodes) {\n      const g = document.getElementById(nodeId(n));\n      if (!g) continue;\n      g.classList.remove('ready','processed','pending','cyclic');\n      if (run.processed.has(n)) {\n        g.classList.add('processed');\n      } else if (run.cycleDetected && !run.processed.has(n)) {\n        g.classList.add('cyclic');\n      } else if (run.queue.includes(n)) {\n        g.classList.add('ready');\n      } else {\n        g.classList.add('pending');\n      }\n      const badge = g.querySelector('.indegree');\n      const deg = run.indegree.get(n) ?? 0;\n      badge.textContent = 'deg: ' + deg;\n    }\n    // Edge styles: faded if removed; cyclic if cycle left\n    for (const e of graph.edges) {\n      const line = document.getElementById(edgeId(e.from, e.to));\n      if (!line) continue;\n      line.classList.remove('faded','cyclic');\n      if (run.edgesRemoved.has(edgeSig(e.from, e.to))) {\n        line.classList.add('faded');\n        line.setAttribute('marker-end', 'url(#arrowFaded)');\n      } else if (run.cycleDetected) {\n        // If either endpoint is unresolved, mark potential cycle region red\n        const unresolved = !(run.processed.has(e.from) && run.processed.has(e.to));\n        if (unresolved) {\n          line.classList.add('cyclic');\n          line.setAttribute('marker-end', 'url(#arrowDanger)');\n        } else {\n          line.setAttribute('marker-end', 'url(#arrow)');\n        }\n      } else {\n        line.setAttribute('marker-end', 'url(#arrow)');\n      }\n    }\n  }\n\n  function updateUI() {\n    // Queue chips\n    queueView.innerHTML = '';\n    for (const q of run.queue) {\n      const c = document.createElement('div');\n      c.className = 'chip queue';\n      c.textContent = q;\n      queueView.appendChild(c);\n    }\n    // Order chips\n    orderView.innerHTML = '';\n    for (let i = 0; i < run.order.length; i++) {\n      const c = document.createElement('div');\n      c.className = 'chip done';\n      c.textContent = (i+1) + '. ' + run.order[i];\n      orderView.appendChild(c);\n    }\n    if (run.cycleDetected) {\n      setStatus('Cycle detected. Queue is empty but ' + (graph.nodes.length - run.processed.size) + ' node(s) remain unresolved. No topological order exists for this graph.');\n    } else if (run.order.length === graph.nodes.length && graph.nodes.length > 0) {\n      setStatus('Topological sort complete. Order length: ' + run.order.length + '.');\n    } else {\n      setStatus('Processed: ' + run.order.length + ' / ' + graph.nodes.length + '. Queue size: ' + run.queue.length + '.');\n    }\n  }\n\n  function setStatus(text) {\n    statusEl.textContent = text;\n  }\n\n  function stepOnce() {\n    if (run.cycleDetected || run.order.length === graph.nodes.length) {\n      updateUI();\n      updateStyles();\n      return;\n    }\n    if (run.queue.length === 0) {\n      run.cycleDetected = true;\n      updateUI();\n      updateStyles();\n      return;\n    }\n    const u = run.queue.shift(); // choose a ready node\n    if (!u) return;\n\n    run.processed.add(u);\n    run.order.push(u);\n\n    // remove outgoing edges from u\n    const nbrs = graph.adj.get(u) || [];\n    for (const v of nbrs) {\n      if (run.processed.has(v)) continue;\n      const sig = edgeSig(u, v);\n      run.edgesRemoved.add(sig);\n      const cur = run.indegree.get(v) ?? 0;\n      const next = Math.max(0, cur - 1);\n      run.indegree.set(v, next);\n      if (next === 0 && !run.queue.includes(v)) {\n        run.queue.push(v);\n      }\n    }\n    run.queue.sort(lexCmp);\n\n    // Animate hint: briefly scale processed node\n    pulseNode(u);\n\n    updateUI();\n    updateStyles();\n\n    // If after step we have no queue and not done, it's a cycle\n    if (run.queue.length === 0 && run.order.length < graph.nodes.length) {\n      // But allow next tick to show final state\n      // Mark cycle now\n      run.cycleDetected = true;\n      updateUI();\n      updateStyles();\n    }\n  }\n\n  function pulseNode(label) {\n    const g = document.getElementById(nodeId(label));\n    if (!g) return;\n    g.style.transition = 'transform 0.18s ease';\n    const pos = graph.positions.get(label);\n    g.setAttribute('transform', `translate(${pos.x}, ${pos.y}) scale(1.08)`);\n    setTimeout(() => {\n      g.setAttribute('transform', `translate(${pos.x}, ${pos.y}) scale(1)`);\n      setTimeout(() => {\n        g.style.transition = '';\n      }, 200);\n    }, 160);\n  }\n\n  function playToggle() {\n    if (run.playing) {\n      pause();\n      return;\n    }\n    run.playing = true;\n    btnPlay.textContent = 'Pause';\n    const tick = () => {\n      if (run.cycleDetected || run.order.length === graph.nodes.length) {\n        pause();\n        return;\n      }\n      stepOnce();\n    };\n    // Start interval\n    const ms = parseInt(speed.value, 10) || 650;\n    run.timer = setInterval(tick, ms);\n  }\n\n  function pause() {\n    run.playing = false;\n    btnPlay.textContent = 'Play';\n    clearInterval(run.timer);\n    run.timer = null;\n  }\n\n  function edgeEndpoints(A, B, r) {\n    const dx = B.x - A.x;\n    const dy = B.y - A.y;\n    const d = Math.hypot(dx, dy) || 1;\n    const ux = dx / d;\n    const uy = dy / d;\n    const x1 = A.x + ux * r;\n    const y1 = A.y + uy * r;\n    const x2 = B.x - ux * (r + 4); // add a bit for arrowhead\n    const y2 = B.y - uy * (r + 4);\n    return {x1, y1, x2, y2};\n  }\n\n  function nodeId(label) {\n    return 'node-' + label.replace(/[^a-zA-Z0-9_-]/g, '_');\n  }\n  function edgeId(from, to) {\n    return 'edge-' + from.replace(/[^a-zA-Z0-9_-]/g, '_') + '--' + to.replace(/[^a-zA-Z0-9_-]/g, '_');\n  }\n  function edgeSig(from, to) {\n    return from + '->' + to;\n  }\n\n  function enableDrag(g) {\n    let dragging = false;\n    let start = {x: 0, y: 0};\n    let nodeLabel = g.dataset.label;\n\n    const onMouseDown = (e) => {\n      dragging = true;\n      g.style.pointerEvents = 'all';\n      const pt = clientToSVG(e.clientX, e.clientY);\n      start.x = pt.x;\n      start.y = pt.y;\n      e.preventDefault();\n    };\n    const onMouseMove = (e) => {\n      if (!dragging) return;\n      const pt = clientToSVG(e.clientX, e.clientY);\n      const dx = pt.x - start.x;\n      const dy = pt.y - start.y;\n      start.x = pt.x;\n      start.y = pt.y;\n      const pos = graph.positions.get(nodeLabel);\n      const nx = pos.x + dx;\n      const ny = pos.y + dy;\n      graph.positions.set(nodeLabel, {x: nx, y: ny});\n      g.setAttribute('transform', `translate(${nx}, ${ny})`);\n      updateEdgesPositions();\n    };\n    const onMouseUp = () => {\n      dragging = false;\n    };\n\n    g.addEventListener('mousedown', onMouseDown);\n    window.addEventListener('mousemove', onMouseMove);\n    window.addEventListener('mouseup', onMouseUp);\n\n    // Touch\n    g.addEventListener('touchstart', (e) => {\n      dragging = true;\n      const t = e.touches[0];\n      const pt = clientToSVG(t.clientX, t.clientY);\n      start.x = pt.x;\n      start.y = pt.y;\n      e.preventDefault();\n    }, {passive: false});\n    window.addEventListener('touchmove', (e) => {\n      if (!dragging) return;\n      const t = e.touches[0];\n      const pt = clientToSVG(t.clientX, t.clientY);\n      const dx = pt.x - start.x;\n      const dy = pt.y - start.y;\n      start.x = pt.x;\n      start.y = pt.y;\n      const pos = graph.positions.get(nodeLabel);\n      const nx = pos.x + dx;\n      const ny = pos.y + dy;\n      graph.positions.set(nodeLabel, {x: nx, y: ny});\n      g.setAttribute('transform', `translate(${nx}, ${ny})`);\n      updateEdgesPositions();\n      e.preventDefault();\n    }, {passive: false});\n    window.addEventListener('touchend', () => {\n      dragging = false;\n    });\n  }\n\n  function clientToSVG(clientX, clientY) {\n    const pt = svg.createSVGPoint();\n    pt.x = clientX;\n    pt.y = clientY;\n    const ctm = svg.getScreenCTM().inverse();\n    return pt.matrixTransform(ctm);\n  }\n\n  // Samples\n  function sampleChain() {\n    input.value = `A->B\nB->C\nC->D`;\n    buildGraphFromInput();\n  }\n  function sampleDiamond() {\n    input.value = `A->B\nA->C\nB->D\nC->D\nD->E`;\n    buildGraphFromInput();\n  }\n  function sampleCourses() {\n    input.value = `Math->Physics\nMath->CS\nCS->AI\nCS->Compilers\nPhysics->Robotics\nAI->Robotics\nCompilers->Robotics\nDesign\n`;\n    buildGraphFromInput();\n  }\n  function sampleCycle() {\n    input.value = `A->B\nB->C\nC->A\nC->D`;\n    buildGraphFromInput();\n  }\n  function randomDAG() {\n    const n = Math.floor(5 + Math.random()*5); // 5..9 nodes\n    const labels = [];\n    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    const used = new Set();\n    while (labels.length < n) {\n      const c = alphabet[ Math.floor(Math.random()*alphabet.length) ];\n      if (!used.has(c)) { used.add(c); labels.push(c); }\n    }\n    // To ensure DAG, choose a random permutation and only create edges from lower index to higher index\n    const perm = [...labels];\n    perm.sort(() => Math.random()-0.5);\n    const edges = [];\n    const density = 0.3 + Math.random()*0.4; // 0.3..0.7\n    for (let i = 0; i < perm.length; i++) {\n      for (let j = i+1; j < perm.length; j++) {\n        if (Math.random() < density) {\n          edges.push(perm[i] + '->' + perm[j]);\n        }\n      }\n    }\n    if (edges.length === 0 && perm.length >= 2) {\n      edges.push(perm[0] + '->' + perm[1]);\n    }\n    input.value = edges.join('\\n');\n    buildGraphFromInput();\n  }\n\n  // Events\n  btnParse.addEventListener('click', buildGraphFromInput);\n  btnRandom.addEventListener('click', randomDAG);\n  btnSample1.addEventListener('click', sampleChain);\n  btnSample2.addEventListener('click', sampleDiamond);\n  btnSample3.addEventListener('click', sampleCourses);\n  btnSample4.addEventListener('click', sampleCycle);\n\n  btnStep.addEventListener('click', () => {\n    if (run.playing) pause();\n    stepOnce();\n  });\n  btnPlay.addEventListener('click', playToggle);\n  btnReset.addEventListener('click', () => {\n    if (graph.nodes.length === 0) {\n      setStatus('Nothing to reset. Build a graph first.');\n      return;\n    }\n    resetRunState();\n    updateStyles();\n  });\n  speed.addEventListener('change', () => {\n    if (run.playing) {\n      pause();\n      playToggle();\n    }\n  });\n\n  // Initialize with a simple graph\n  sampleDiamond();\n\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Topological Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "5597b0e0-a36e-11f0-97db-3beb2489e4a9",
    "timestamp": "2025-10-07T11:11:12.623Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Fibonacci Sequence",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Fibonacci Sequence — Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --accent: #22c55e;\n    --accent2: #60a5fa;\n    --text: #e5e7eb;\n    --muted: #9ca3af;\n    --border: #1f2937;\n    --warn: #f59e0b;\n  }\n  * { box-sizing: border-box; }\n  body {\n    margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Apple Color Emoji\",\"Segoe UI Emoji\", \"Segoe UI Symbol\";\n    color: var(--text); background: radial-gradient(1000px 480px at 20% 0%, #0b1221, #0f172a);\n  }\n  header {\n    padding: 24px 20px; border-bottom: 1px solid var(--border);\n    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0));\n    position: sticky; top: 0; z-index: 3;\n    backdrop-filter: blur(6px);\n  }\n  h1 { margin: 0; font-weight: 700; font-size: 22px; letter-spacing: 0.4px; }\n  header p { margin: 8px 0 0; color: var(--muted); font-size: 14px; }\n  main {\n    padding: 20px; max-width: 1200px; margin: 0 auto;\n    display: grid; grid-template-columns: 1fr; gap: 16px;\n  }\n  @media (min-width: 900px) {\n    main { grid-template-columns: 1.05fr 0.95fr; }\n  }\n  section {\n    background: linear-gradient(180deg, #0f182b, #0e1628);\n    border: 1px solid var(--border);\n    border-radius: 12px; overflow: hidden;\n    box-shadow: 0 8px 24px rgba(0,0,0,0.35);\n  }\n  section header {\n    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0));\n    border-bottom: 1px solid var(--border); position: static;\n    padding: 14px 16px;\n  }\n  section header h2 {\n    margin: 0; font-size: 16px; font-weight: 700; letter-spacing: 0.2px;\n  }\n  section header p { margin: 6px 0 0; color: var(--muted); font-size: 13px; }\n  .content { padding: 14px; }\n  .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px; }\n  .control { background: #101a2d; border: 1px solid var(--border); border-radius: 10px; padding: 10px; }\n  .control label { display: flex; justify-content: space-between; align-items: center; font-size: 13px; color: var(--muted); margin-bottom: 8px; }\n  .control input[type=\"range\"] { width: 100%; }\n  .control input[type=\"number\"] { width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid var(--border); background: #0c1426; color: var(--text); }\n  .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }\n  .btn {\n    background: linear-gradient(180deg, #1f2937, #111827); color: var(--text);\n    border: 1px solid var(--border); border-radius: 9px; padding: 8px 12px;\n    cursor: pointer; font-size: 13px;\n  }\n  .btn:hover { border-color: #334155; }\n  .btn.accent { background: linear-gradient(180deg, #1f8b5f, #136c48); border-color: #1a8a57; }\n  .btn.warn { background: linear-gradient(180deg, #925b13, #7a470c); border-color: #b97513; }\n  .pill {\n    display:inline-block; padding: 2px 8px; border-radius:100px; font-size:12px;\n    border: 1px solid var(--border); color: var(--muted);\n  }\n  .sequence-box {\n    background: #0c1527; border: 1px solid var(--border); border-radius: 10px;\n    padding: 10px; max-height: 240px; overflow: auto; font-size: 13px; line-height: 1.6;\n  }\n  .sequence-box b { color: var(--accent); }\n  .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 8px; }\n  .stat {\n    background: #0e172a; border: 1px solid var(--border); border-radius: 10px; padding: 10px;\n  }\n  .stat .label { color: var(--muted); font-size: 12px; }\n  .stat .value { font-weight: 700; margin-top: 6px; font-size: 14px; }\n  canvas, svg { display: block; width: 100%; height: 320px; background: #0c1527; border: 1px solid var(--border); border-radius: 10px; }\n  .legend { display:flex; gap:10px; align-items:center; margin:10px 0 0; }\n  .swatch { width: 12px; height: 12px; border-radius: 2px; display:inline-block; border: 1px solid var(--border); margin-right: 6px; }\n  .swatch.green { background: #22c55e; }\n  .swatch.blue { background: #60a5fa; }\n  .swatch.purple { background: #a78bfa; }\n  .note { color: var(--muted); font-size: 12px; margin-top: 8px; }\n  .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }\n  @media (max-width: 700px) { .controls { grid-template-columns: 1fr; } .grid2 { grid-template-columns: 1fr; } }\n</style>\n</head>\n<body>\n<header>\n  <h1>Fibonacci Sequence — Interactive Demo</h1>\n  <p>Explore Fibonacci numbers, algorithms, the golden ratio convergence, and a classic Fibonacci spiral, all in one page.</p>\n</header>\n\n<main>\n  <!-- Sequence Generator -->\n  <section id=\"seqPanel\">\n    <header>\n      <h2>Sequence Generator</h2>\n      <p>Generate the first N Fibonacci numbers using an efficient BigInt algorithm.</p>\n    </header>\n    <div class=\"content\">\n      <div class=\"controls\">\n        <div class=\"control\">\n          <label>\n            Length N\n            <span class=\"pill\"><span id=\"seqNLabel\">30</span></span>\n          </label>\n          <input id=\"seqN\" type=\"range\" min=\"0\" max=\"300\" step=\"1\" value=\"30\">\n        </div>\n        <div class=\"control\">\n          <label>\n            Display options\n            <span class=\"pill\">Formatting</span>\n          </label>\n          <div class=\"row\">\n            <button id=\"btnFormatGroup\" class=\"btn\">Group digits</button>\n            <button id=\"btnFormatPlain\" class=\"btn\">Plain</button>\n            <button id=\"btnCopy\" class=\"btn\">Copy list</button>\n            <button id=\"btnAnimate\" class=\"btn accent\">Play build</button>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"sequence-box\" id=\"sequenceBox\" aria-live=\"polite\"></div>\n\n      <div class=\"stats\">\n        <div class=\"stat\">\n          <div class=\"label\">F(N) value</div>\n          <div class=\"value\" id=\"statFn\">—</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"label\">Sum of first N terms</div>\n          <div class=\"value\" id=\"statSum\">—</div>\n        </div>\n        <div class=\"stat\">\n          <div class=\"label\">Largest term digits</div>\n          <div class=\"value\" id=\"statDigits\">—</div>\n        </div>\n      </div>\n      <div class=\"note\">By convention F(0)=0, F(1)=1. This generator uses constant space arithmetic with BigInt and runs in O(N).</div>\n    </div>\n  </section>\n\n  <!-- Ratio Convergence -->\n  <section id=\"ratioPanel\">\n    <header>\n      <h2>Golden Ratio Convergence</h2>\n      <p>See how F(n+1)/F(n) approaches φ = (1+√5)/2.</p>\n    </header>\n    <div class=\"content\">\n      <div class=\"controls\">\n        <div class=\"control\">\n          <label>\n            Max n for ratio plot\n            <span class=\"pill\"><span id=\"ratioNLabel\">30</span></span>\n          </label>\n          <input id=\"ratioN\" type=\"range\" min=\"2\" max=\"93\" step=\"1\" value=\"30\">\n        </div>\n        <div class=\"control\">\n          <label>\n            Options\n            <span class=\"pill\">Lines</span>\n          </label>\n          <div class=\"row\">\n            <button id=\"btnRatioAnimate\" class=\"btn accent\">Animate ratios</button>\n            <button id=\"btnRatioReset\" class=\"btn\">Reset</button>\n          </div>\n        </div>\n      </div>\n      <canvas id=\"ratioCanvas\" width=\"640\" height=\"320\" aria-label=\"Ratio chart\"></canvas>\n      <div class=\"legend\">\n        <span><span class=\"swatch green\"></span>F(n+1)/F(n)</span>\n        <span><span class=\"swatch blue\"></span>Golden ratio φ</span>\n      </div>\n      <div class=\"note\">Numerical stability: we use safe integers for n ≤ 93. Ratios quickly stabilize near φ ≈ 1.6180339887…</div>\n    </div>\n  </section>\n\n  <!-- Spiral Visualization -->\n  <section id=\"spiralPanel\">\n    <header>\n      <h2>Fibonacci Spiral</h2>\n      <p>Squares sized by Fibonacci numbers arranged in a spiral, with quarter-circle arcs.</p>\n    </header>\n    <div class=\"content\">\n      <div class=\"controls\">\n        <div class=\"control\">\n          <label>\n            Squares count\n            <span class=\"pill\"><span id=\"spiralCountLabel\">10</span></span>\n          </label>\n          <input id=\"spiralCount\" type=\"range\" min=\"2\" max=\"16\" step=\"1\" value=\"10\">\n        </div>\n        <div class=\"control\">\n          <label>\n            Styles\n            <span class=\"pill\">Visuals</span>\n          </label>\n          <div class=\"row\">\n            <button id=\"btnSpiralSquares\" class=\"btn\">Squares</button>\n            <button id=\"btnSpiralArcs\" class=\"btn accent\">Squares + arcs</button>\n            <button id=\"btnSpiralAnimate\" class=\"btn accent\">Animate</button>\n          </div>\n        </div>\n      </div>\n      <canvas id=\"spiralCanvas\" width=\"640\" height=\"360\" aria-label=\"Fibonacci spiral\"></canvas>\n      <div class=\"legend\">\n        <span><span class=\"swatch blue\"></span>Squares</span>\n        <span><span class=\"swatch purple\"></span>Quarter arcs</span>\n      </div>\n      <div class=\"note\">To fit the canvas, sizes are scaled. Orientation cycles: right → up → left → down.</div>\n    </div>\n  </section>\n\n  <!-- Algorithms and Performance -->\n  <section id=\"algoPanel\">\n    <header>\n      <h2>Algorithms & Performance</h2>\n      <p>Compare naive recursion with efficient iteration and memoization.</p>\n    </header>\n    <div class=\"content\">\n      <div class=\"grid2\">\n        <div class=\"control\">\n          <label>\n            n for F(n)\n            <span class=\"pill\"><span id=\"algoNLabel\">35</span></span>\n          </label>\n          <input id=\"algoN\" type=\"range\" min=\"0\" max=\"45\" step=\"1\" value=\"35\">\n          <div class=\"row\" style=\"margin-top:10px;\">\n            <button id=\"btnRunAll\" class=\"btn accent\">Run All</button>\n            <button id=\"btnRunIter\" class=\"btn\">Iterative</button>\n            <button id=\"btnRunRec\" class=\"btn warn\">Naive recursive</button>\n            <button id=\"btnRunMemo\" class=\"btn\">Memoized</button>\n          </div>\n          <div class=\"note\">Warning: naive recursion is exponential. Keep n ≤ 40–45.</div>\n        </div>\n        <div class=\"control\">\n          <label>\n            Results\n            <span class=\"pill\">Time & calls</span>\n          </label>\n          <div id=\"algoResults\" class=\"sequence-box\" style=\"max-height:180px;\"></div>\n        </div>\n      </div>\n    </div>\n  </section>\n</main>\n\n<script>\n/* Utilities */\nconst phi = (1 + Math.sqrt(5)) / 2;\n\nfunction fibSequenceBigInt(n) {\n  const seq = [];\n  let a = 0n, b = 1n;\n  for (let i = 0; i <= n; i++) {\n    seq.push(a);\n    const next = a + b;\n    a = b; b = next;\n  }\n  return seq;\n}\nfunction fibNthIterativeBigInt(n) {\n  let a = 0n, b = 1n;\n  if (n === 0) return a;\n  for (let i = 1; i < n; i++) {\n    const t = a + b;\n    a = b;\n    b = t;\n  }\n  return b;\n}\n// Numeric versions for ratio and recursion demos\nfunction fibNthIterativeNumber(n) {\n  let a = 0, b = 1;\n  if (n === 0) return a;\n  for (let i = 1; i < n; i++) {\n    const t = a + b; a = b; b = t;\n  }\n  return b;\n}\nfunction fibNthRecursiveNumber(n, stats) {\n  stats.calls++;\n  if (n <= 1) return n;\n  return fibNthRecursiveNumber(n - 1, stats) + fibNthRecursiveNumber(n - 2, stats);\n}\nfunction fibNthMemoNumber(n, memo, stats) {\n  stats.calls++;\n  if (memo.has(n)) return memo.get(n);\n  const v = n <= 1 ? n : fibNthMemoNumber(n - 1, memo, stats) + fibNthMemoNumber(n - 2, memo, stats);\n  memo.set(n, v);\n  return v;\n}\nfunction bigIntDigits(bi) {\n  return bi.toString().length;\n}\nfunction formatBigInt(bi, grouped) {\n  const s = bi.toString();\n  if (!grouped) return s;\n  // group in threes for readability\n  const neg = s[0] === '-';\n  const raw = neg ? s.slice(1) : s;\n  let out = '';\n  for (let i = 0; i < raw.length; i++) {\n    const idx = raw.length - i;\n    const ch = raw[i];\n    out += ch;\n    const left = raw.length - i - 1;\n    if (left > 0 && left % 3 === 0) out += ' '; // thin space\n  }\n  return neg ? '-' + out : out;\n}\n\n/* Sequence Panel */\nconst seqN = document.getElementById('seqN');\nconst seqNLabel = document.getElementById('seqNLabel');\nconst sequenceBox = document.getElementById('sequenceBox');\nconst statFn = document.getElementById('statFn');\nconst statSum = document.getElementById('statSum');\nconst statDigits = document.getElementById('statDigits');\nconst btnFormatGroup = document.getElementById('btnFormatGroup');\nconst btnFormatPlain = document.getElementById('btnFormatPlain');\nconst btnCopy = document.getElementById('btnCopy');\nconst btnAnimate = document.getElementById('btnAnimate');\n\nlet seqFormatGrouped = true;\nlet seqAnimating = false;\nlet seqAnimationFrame = null;\nlet seqAnimationIndex = 0;\n\nfunction updateSequence() {\n  const n = parseInt(seqN.value, 10);\n  seqNLabel.textContent = n.toString();\n  const seq = fibSequenceBigInt(n);\n  const formatted = seq.map((v, i) => {\n    const label = `F(${i})`;\n    return `${label} = ${formatBigInt(v, seqFormatGrouped)}`;\n  }).join('\\n');\n  sequenceBox.textContent = formatted;\n  const fn = seq[seq.length - 1] || 0n;\n  statFn.textContent = formatBigInt(fn, seqFormatGrouped);\n  // Sum of first N terms (including F(0) to F(N)): we have identity Sum F(0..n) = F(n+2) - 1\n  const sum = fibNthIterativeBigInt(n + 2) - 1n;\n  statSum.textContent = formatBigInt(sum, seqFormatGrouped);\n  statDigits.textContent = bigIntDigits(fn).toString();\n}\nseqN.addEventListener('input', () => {\n  if (seqAnimating) stopSeqAnimation();\n  updateSequence();\n});\nbtnFormatGroup.addEventListener('click', () => {\n  seqFormatGrouped = true; updateSequence();\n});\nbtnFormatPlain.addEventListener('click', () => {\n  seqFormatGrouped = false; updateSequence();\n});\nbtnCopy.addEventListener('click', async () => {\n  try {\n    await navigator.clipboard.writeText(sequenceBox.textContent);\n    btnCopy.textContent = 'Copied!';\n    setTimeout(() => btnCopy.textContent = 'Copy list', 1200);\n  } catch (e) {\n    btnCopy.textContent = 'Copy failed';\n    setTimeout(() => btnCopy.textContent = 'Copy list', 1200);\n  }\n});\nfunction startSeqAnimation() {\n  if (seqAnimating) return;\n  seqAnimating = true;\n  btnAnimate.textContent = 'Pause';\n  seqAnimationIndex = 0;\n  const n = parseInt(seqN.value, 10);\n  const seq = fibSequenceBigInt(n);\n  const step = () => {\n    if (!seqAnimating) return;\n    if (seqAnimationIndex > n) { stopSeqAnimation(); return; }\n    const lines = [];\n    for (let i = 0; i <= seqAnimationIndex; i++) {\n      lines.push(`F(${i}) = ${formatBigInt(seq[i], seqFormatGrouped)}`);\n    }\n    sequenceBox.textContent = lines.join('\\n');\n    seqAnimationIndex++;\n    seqAnimationFrame = requestAnimationFrame(step);\n  };\n  step();\n}\nfunction stopSeqAnimation() {\n  seqAnimating = false;\n  btnAnimate.textContent = 'Play build';\n  if (seqAnimationFrame) cancelAnimationFrame(seqAnimationFrame);\n  updateSequence();\n}\nbtnAnimate.addEventListener('click', () => {\n  if (seqAnimating) stopSeqAnimation(); else startSeqAnimation();\n});\n\n/* Ratio Convergence */\nconst ratioCanvas = document.getElementById('ratioCanvas');\nconst rctx = ratioCanvas.getContext('2d');\nconst ratioN = document.getElementById('ratioN');\nconst ratioNLabel = document.getElementById('ratioNLabel');\nconst btnRatioAnimate = document.getElementById('btnRatioAnimate');\nconst btnRatioReset = document.getElementById('btnRatioReset');\nlet ratioAnimating = false;\nlet ratioAnimStep = 2; // start at n=2\nfunction computeRatios(m) {\n  const ratios = [];\n  for (let n = 1; n <= m; n++) {\n    const f1 = fibNthIterativeNumber(n);\n    const f2 = fibNthIterativeNumber(n + 1);\n    ratios.push(f2 / f1);\n  }\n  return ratios;\n}\nfunction drawRatioChart(maxN, animN = null) {\n  const w = ratioCanvas.width, h = ratioCanvas.height;\n  rctx.clearRect(0, 0, w, h);\n  // padding\n  const padL = 40, padB = 28, padT = 18, padR = 16;\n  const plotW = w - padL - padR;\n  const plotH = h - padT - padB;\n  rctx.fillStyle = '#0b1429';\n  rctx.fillRect(0,0,w,h);\n  rctx.strokeStyle = '#1f2937'; rctx.lineWidth = 1.0;\n  // grid\n  rctx.beginPath();\n  for (let i = 0; i <= 5; i++) {\n    const y = padT + i * plotH / 5;\n    rctx.moveTo(padL, y); rctx.lineTo(padL + plotW, y);\n  }\n  for (let i = 0; i <= 10; i++) {\n    const x = padL + i * plotW / 10;\n    rctx.moveTo(x, padT); rctx.lineTo(x, padT + plotH);\n  }\n  rctx.stroke();\n  // axes labels\n  rctx.fillStyle = '#9ca3af'; rctx.font = '12px system-ui, sans-serif';\n  rctx.fillText('n', w - padR - 10, h - 8);\n  rctx.fillText('ratio', 8, padT + 12);\n  // compute ratios\n  const m = maxN;\n  const ratios = computeRatios(m);\n  const maxY = 2.0, minY = 1.0;\n  // phi line\n  const phiY = padT + (1 - (phi - minY) / (maxY - minY)) * plotH;\n  rctx.strokeStyle = '#60a5fa'; rctx.lineWidth = 1.2;\n  rctx.beginPath(); rctx.moveTo(padL, phiY); rctx.lineTo(padL + plotW, phiY); rctx.stroke();\n  rctx.fillStyle = '#60a5fa';\n  rctx.fillText(`φ ≈ ${phi.toFixed(6)}`, padL + 6, phiY - 6);\n  // plot ratios\n  const xFor = n => padL + (n - 1) * plotW / (m - 1);\n  const yFor = val => padT + (1 - (val - minY) / (maxY - minY)) * plotH;\n  rctx.strokeStyle = '#22c55e'; rctx.lineWidth = 2.0; rctx.beginPath();\n  const Nplot = animN ? Math.min(animN - 1, ratios.length) : ratios.length;\n  for (let i = 0; i < Nplot; i++) {\n    const x = xFor(i + 1);\n    const y = yFor(ratios[i]);\n    if (i === 0) rctx.moveTo(x, y); else rctx.lineTo(x, y);\n  }\n  rctx.stroke();\n  // points\n  rctx.fillStyle = '#22c55e';\n  for (let i = 0; i < Nplot; i++) {\n    const x = xFor(i + 1), y = yFor(ratios[i]);\n    rctx.beginPath(); rctx.arc(x, y, 2.8, 0, Math.PI * 2); rctx.fill();\n  }\n}\nfunction updateRatio() {\n  const n = parseInt(ratioN.value, 10);\n  ratioNLabel.textContent = n.toString();\n  drawRatioChart(n);\n}\nratioN.addEventListener('input', () => { ratioAnimating = false; btnRatioAnimate.textContent='Animate ratios'; updateRatio(); });\nbtnRatioReset.addEventListener('click', () => {\n  ratioAnimating = false; btnRatioAnimate.textContent='Animate ratios'; ratioAnimStep = 2; updateRatio();\n});\nfunction animateRatios() {\n  const nMax = parseInt(ratioN.value, 10);\n  if (!ratioAnimating) {\n    ratioAnimating = true; btnRatioAnimate.textContent='Pause';\n    ratioAnimStep = 2;\n  } else {\n    ratioAnimating = false; btnRatioAnimate.textContent='Animate ratios';\n    return;\n  }\n  const tick = () => {\n    if (!ratioAnimating) return;\n    drawRatioChart(nMax, ratioAnimStep);\n    ratioAnimStep++;\n    if (ratioAnimStep > nMax + 1) { ratioAnimating = false; btnRatioAnimate.textContent='Animate ratios'; return; }\n    requestAnimationFrame(tick);\n  };\n  tick();\n}\nbtnRatioAnimate.addEventListener('click', animateRatios);\n\n/* Spiral Visualization */\nconst spiralCanvas = document.getElementById('spiralCanvas');\nconst sctx = spiralCanvas.getContext('2d');\nconst spiralCount = document.getElementById('spiralCount');\nconst spiralCountLabel = document.getElementById('spiralCountLabel');\nconst btnSpiralSquares = document.getElementById('btnSpiralSquares');\nconst btnSpiralArcs = document.getElementById('btnSpiralArcs');\nconst btnSpiralAnimate = document.getElementById('btnSpiralAnimate');\nlet spiralShowArcs = true;\nlet spiralAnimating = false;\nlet spiralAnimIndex = 0;\n\nfunction buildSpiralSquares(k) {\n  // sizes: F(1)..F(k)\n  const sizes = [];\n  let a = 1, b = 1;\n  sizes.push(a); sizes.push(b);\n  for (let i = 3; i <= k; i++) {\n    const t = a + b; a = b; b = t; sizes.push(b);\n  }\n  // positions\n  const squares = [];\n  // s1 at (0,0), s2 to the right\n  squares.push({ size: sizes[0], x: 0, y: 0 });\n  squares.push({ size: sizes[1], x: sizes[0], y: 0 });\n  // bounding rect\n  let rectX = 0, rectY = 0, rectW = sizes[0] + sizes[1], rectH = sizes[1];\n  // place s3..k\n  for (let i = 3; i <= k; i++) {\n    const s = sizes[i - 1];\n    const orientIdx = (i - 3) % 4; // 0 up, 1 left, 2 down, 3 right\n    if (orientIdx === 0) { // up\n      squares.push({ size: s, x: rectX, y: rectY - s });\n      rectY -= s; rectH += s;\n    } else if (orientIdx === 1) { // left\n      squares.push({ size: s, x: rectX - s, y: rectY });\n      rectX -= s; rectW += s;\n    } else if (orientIdx === 2) { // down\n      squares.push({ size: s, x: rectX, y: rectY + rectH });\n      rectH += s;\n    } else { // right\n      squares.push({ size: s, x: rectX + rectW, y: rectY });\n      rectW += s;\n    }\n  }\n  return { squares, bounds: { x: rectX, y: rectY, w: rectW, h: rectH } };\n}\nfunction drawSpiral(k, stepLimit = null) {\n  const w = spiralCanvas.width, h = spiralCanvas.height;\n  sctx.clearRect(0, 0, w, h);\n  sctx.fillStyle = '#0b1429';\n  sctx.fillRect(0, 0, w, h);\n\n  const data = buildSpiralSquares(k);\n  const { squares, bounds } = data;\n  // scale to fit\n  const pad = 16;\n  const scale = Math.min((w - 2*pad) / bounds.w, (h - 2*pad) / bounds.h);\n  const offsetX = (w - bounds.w * scale) / 2 - bounds.x * scale;\n  const offsetY = (h - bounds.h * scale) / 2 - bounds.y * scale;\n\n  const countToDraw = stepLimit ? Math.min(stepLimit, squares.length) : squares.length;\n  // draw squares\n  sctx.strokeStyle = '#3b82f6'; sctx.lineWidth = 2.0;\n  for (let i = 0; i < countToDraw; i++) {\n    const sq = squares[i];\n    const x = offsetX + sq.x * scale;\n    const y = offsetY + sq.y * scale;\n    const s = sq.size * scale;\n    sctx.strokeRect(x, y, s, s);\n  }\n  // draw arcs\n  if (spiralShowArcs) {\n    sctx.strokeStyle = '#a78bfa'; sctx.lineWidth = 2.0;\n    for (let i = 0; i < countToDraw; i++) {\n      const sq = squares[i];\n      const x = offsetX + sq.x * scale;\n      const y = offsetY + sq.y * scale;\n      const s = sq.size * scale;\n      // orientation pattern for arcs: right, up, left, down repeating starting at i=1\n      const orientIdx = i % 4; // 0:right,1:up,2:left,3:down\n      let cx, cy, start, end;\n      if (orientIdx === 0) { // right\n        cx = x; cy = y + s; start = -Math.PI/2; end = 0;\n      } else if (orientIdx === 1) { // up\n        cx = x + s; cy = y + s; start = 0; end = Math.PI/2;\n      } else if (orientIdx === 2) { // left\n        cx = x + s; cy = y; start = Math.PI/2; end = Math.PI;\n      } else { // down\n        cx = x; cy = y; start = Math.PI; end = 3*Math.PI/2;\n      }\n      sctx.beginPath();\n      sctx.arc(cx, cy, s, start, end);\n      sctx.stroke();\n    }\n  }\n}\nfunction updateSpiral() {\n  const k = parseInt(spiralCount.value, 10);\n  spiralCountLabel.textContent = k.toString();\n  drawSpiral(k);\n}\nspiralCount.addEventListener('input', () => { spiralAnimating = false; btnSpiralAnimate.textContent = 'Animate'; updateSpiral(); });\nbtnSpiralSquares.addEventListener('click', () => { spiralShowArcs = false; updateSpiral(); });\nbtnSpiralArcs.addEventListener('click', () => { spiralShowArcs = true; updateSpiral(); });\nbtnSpiralAnimate.addEventListener('click', () => {\n  const k = parseInt(spiralCount.value, 10);\n  if (!spiralAnimating) {\n    spiralAnimating = true; btnSpiralAnimate.textContent = 'Pause';\n    spiralAnimIndex = 1;\n    const tick = () => {\n      if (!spiralAnimating) return;\n      drawSpiral(k, spiralAnimIndex);\n      spiralAnimIndex++;\n      if (spiralAnimIndex > k) { spiralAnimating = false; btnSpiralAnimate.textContent = 'Animate'; return; }\n      requestAnimationFrame(tick);\n    };\n    tick();\n  } else {\n    spiralAnimating = false; btnSpiralAnimate.textContent = 'Animate';\n  }\n});\n\n/* Algorithms & Performance */\nconst algoN = document.getElementById('algoN');\nconst algoNLabel = document.getElementById('algoNLabel');\nconst btnRunAll = document.getElementById('btnRunAll');\nconst btnRunIter = document.getElementById('btnRunIter');\nconst btnRunRec = document.getElementById('btnRunRec');\nconst btnRunMemo = document.getElementById('btnRunMemo');\nconst algoResults = document.getElementById('algoResults');\n\nfunction runIter() {\n  const n = parseInt(algoN.value, 10);\n  const t0 = performance.now();\n  const v = fibNthIterativeBigInt(n);\n  const t1 = performance.now();\n  logAlgo(`Iterative (BigInt) F(${n})`, formatBigInt(v, true), `${(t1 - t0).toFixed(3)} ms`, '—');\n}\nfunction runRec() {\n  const n = parseInt(algoN.value, 10);\n  const stats = { calls: 0 };\n  const t0 = performance.now();\n  const v = fibNthRecursiveNumber(n, stats);\n  const t1 = performance.now();\n  logAlgo(`Naive recursive (Number) F(${n})`, v.toString(), `${(t1 - t0).toFixed(3)} ms`, stats.calls.toLocaleString());\n}\nfunction runMemo() {\n  const n = parseInt(algoN.value, 10);\n  const memo = new Map();\n  const stats = { calls: 0 };\n  const t0 = performance.now();\n  const v = fibNthMemoNumber(n, memo, stats);\n  const t1 = performance.now();\n  logAlgo(`Memoized recursion (Number) F(${n})`, v.toString(), `${(t1 - t0).toFixed(3)} ms`, stats.calls.toLocaleString());\n}\nfunction logAlgo(name, value, time, calls) {\n  const line = `${name}\\n  Value: ${value}\\n  Time: ${time}\\n  Calls: ${calls}\\n`;\n  algoResults.textContent = line + '\\n' + algoResults.textContent;\n}\nalgoN.addEventListener('input', () => { algoNLabel.textContent = algoN.value; });\nbtnRunIter.addEventListener('click', runIter);\nbtnRunRec.addEventListener('click', runRec);\nbtnRunMemo.addEventListener('click', runMemo);\nbtnRunAll.addEventListener('click', () => { runIter(); runMemo(); runRec(); });\n\n/* Initial render */\nupdateSequence();\nupdateRatio();\nupdateSpiral();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Fibonacci Sequence"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "92574bd0-a36e-11f0-9e8b-49340235d7b5",
    "timestamp": "2025-10-07T11:12:54.542Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Knapsack Problem",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Knapsack Problem Visualizer</title>\n<style>\n  :root{\n    --bg:#0f172a;\n    --panel:#111827;\n    --muted:#334155;\n    --text:#e5e7eb;\n    --accent:#22d3ee;\n    --accent2:#f59e0b;\n    --good:#22c55e;\n    --bad:#ef4444;\n    --shadow:rgba(0,0,0,0.3);\n    --cell:#1f2937;\n    --cell2:#0b2239;\n    --hilite:#2563eb;\n  }\n  *{box-sizing:border-box}\n  body{\n    margin:0;\n    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,\"Helvetica Neue\",Arial;\n    background:linear-gradient(180deg,#0b1222,#0f172a);\n    color:var(--text);\n    line-height:1.4;\n    min-height:100vh;\n  }\n  header{\n    padding:28px 20px 16px;\n    text-align:center;\n  }\n  h1{\n    margin:0 0 8px;\n    font-size:28px;\n    letter-spacing:.3px;\n  }\n  .sub{\n    opacity:.8;\n    font-size:14px;\n  }\n  .container{\n    max-width:1200px;\n    margin:0 auto;\n    padding:16px;\n    display:grid;\n    grid-template-columns: 1.05fr 1.2fr;\n    gap:16px;\n  }\n  .panel{\n    background:linear-gradient(180deg,#101826,#0d1522);\n    border:1px solid #1f2a44;\n    border-radius:14px;\n    box-shadow:0 10px 30px var(--shadow);\n    overflow:hidden;\n  }\n  .panel h2{\n    margin:0;\n    padding:14px 16px;\n    font-size:16px;\n    border-bottom:1px solid #1f2a44;\n    background:linear-gradient(180deg,#0f1929,#0e1725);\n  }\n  .section{\n    padding:14px 16px 18px;\n  }\n  .grid{\n    display:grid;\n    gap:10px;\n    grid-template-columns: repeat(12, 1fr);\n    align-items:end;\n  }\n  label{\n    font-size:12px;\n    opacity:.9;\n    display:block;\n    margin-bottom:6px;\n  }\n  select,input[type=\"number\"],input[type=\"text\"]{\n    width:100%;\n    padding:10px 12px;\n    background:#0b1320;\n    color:var(--text);\n    border:1px solid #1f2a44;\n    border-radius:10px;\n    outline:none;\n    transition:.15s border;\n  }\n  select:focus, input:focus{\n    border-color:#2b78ff;\n    box-shadow:0 0 0 3px rgba(43,120,255,0.15);\n  }\n  .controls{\n    display:flex;\n    flex-wrap:wrap;\n    gap:8px;\n  }\n  button{\n    background:linear-gradient(180deg,#16325a,#132945);\n    border:1px solid #264b80;\n    color:#dce7ff;\n    padding:10px 14px;\n    border-radius:10px;\n    cursor:pointer;\n    transition:.15s transform, .15s filter;\n  }\n  button:hover{ filter:brightness(1.1) }\n  button:active{ transform:translateY(1px) }\n  button.secondary{\n    background:linear-gradient(180deg,#142035,#101a2b);\n    border-color:#263246;\n    color:#cdd7ea;\n  }\n  button.warn{\n    background:linear-gradient(180deg,#4a1720,#3b1219);\n    border-color:#7a2431;\n    color:#ffd9df;\n  }\n  .row{\n    display:flex;\n    gap:10px;\n    align-items:center;\n    flex-wrap:wrap;\n  }\n  .items{\n    margin-top:8px;\n    border:1px solid #1f2a44;\n    border-radius:10px;\n    overflow:hidden;\n  }\n  .items header, .items .item{\n    display:grid;\n    grid-template-columns: 2fr 1fr 1fr 64px;\n    gap:8px;\n    padding:10px 10px;\n    align-items:center;\n  }\n  .items header{\n    background:linear-gradient(180deg,#0f1929,#0e1725);\n    font-size:12px;\n    opacity:.9;\n    border-bottom:1px solid #1f2a44;\n  }\n  .items .item{\n    background:#0a1323;\n    border-bottom:1px solid #131f33;\n  }\n  .items .item:last-child{ border-bottom:none }\n  .items .item input{\n    width:100%;\n    padding:8px 10px;\n    background:#07101d;\n    border:1px solid #17243a;\n    border-radius:8px;\n    color:var(--text);\n  }\n  .del{\n    background:linear-gradient(180deg,#2b1a1d,#231417);\n    border-color:#5a2a31;\n    color:#ffdfe6;\n    padding:8px 10px;\n  }\n  .hint{\n    font-size:12px;\n    opacity:.8;\n    margin-top:6px;\n  }\n  .badge{\n    display:inline-block;\n    background:#0c2038;\n    border:1px solid #20426e;\n    padding:4px 8px;\n    border-radius:999px;\n    font-size:12px;\n    margin-right:6px;\n  }\n  .out{\n    padding:0;\n    display:flex;\n    flex-direction:column;\n    gap:0;\n  }\n  .out .top{\n    display:flex;\n    flex-wrap:wrap;\n    gap:10px;\n    padding:12px 14px;\n    border-bottom:1px solid #1f2a44;\n    align-items:center;\n    background:linear-gradient(180deg,#0f1929,#0e1725);\n  }\n  .stat{\n    background:#0b1930;\n    border:1px solid #1f2a44;\n    padding:8px 10px;\n    border-radius:8px;\n    font-size:13px;\n  }\n  .viz{\n    padding:14px;\n    display:grid;\n    grid-template-columns: 1fr;\n    gap:14px;\n  }\n  .canvas{\n    background:#081325;\n    border:1px solid #1f2a44;\n    border-radius:12px;\n    padding:12px;\n    min-height:180px;\n    position:relative;\n    overflow:auto;\n  }\n  .table{\n    display:inline-grid;\n    grid-auto-rows: 28px;\n    grid-template-columns: 120px repeat(var(--cols), 48px);\n    border:1px solid #1f2a44;\n    border-radius:10px;\n    overflow:hidden;\n  }\n  .cell{\n    border-right:1px solid #1b2841;\n    border-bottom:1px solid #1b2841;\n    background:#0a1628;\n    display:flex;\n    align-items:center;\n    justify-content:center;\n    font-size:12px;\n    min-width:48px;\n    color:#cfe2ff;\n  }\n  .cell.header{\n    background:#0d1b32;\n    font-weight:600;\n  }\n  .cell.itemhead{\n    justify-content:flex-start;\n    padding-left:8px;\n  }\n  .cell.active{\n    outline:2px solid var(--hilite);\n    z-index:2;\n  }\n  .cell.best{\n    background:linear-gradient(180deg,#0e203e,#0b1a33);\n  }\n  .legend{\n    font-size:12px;\n    opacity:.9;\n  }\n  .bar{\n    display:flex;\n    gap:2px;\n    height:28px;\n    background:#0b1b30;\n    border:1px solid #1f2a44;\n    border-radius:8px;\n    overflow:hidden;\n  }\n  .seg{\n    height:100%;\n  }\n  .seglabel{\n    position:relative;\n    top:-2px;\n    font-size:11px;\n    opacity:.9;\n    white-space:nowrap;\n  }\n  .list{\n    display:grid;\n    gap:6px;\n  }\n  .list .rowi{\n    display:grid;\n    grid-template-columns: 1fr auto auto auto;\n    gap:10px;\n    padding:8px 10px;\n    background:#0a1628;\n    border:1px solid #1f2a44;\n    border-radius:8px;\n    align-items:center;\n  }\n  .footer{\n    padding:12px 14px;\n    border-top:1px solid #1f2a44;\n    background:linear-gradient(180deg,#0e1725,#0f1929);\n    display:flex;\n    flex-wrap:wrap;\n    gap:8px;\n    justify-content:space-between;\n    align-items:center;\n  }\n  .range{\n    display:flex;\n    align-items:center;\n    gap:8px;\n  }\n  input[type=\"range\"]{ width:160px }\n  .note{\n    font-size:12px;\n    opacity:.8;\n  }\n  .err{\n    color:#ffb4bd;\n  }\n  .ok{\n    color:#a7f3d0;\n  }\n  .pill{\n    padding:3px 8px;\n    border-radius:999px;\n    border:1px solid #284a7a;\n    background:#0b2239;\n    font-size:12px;\n  }\n  @media (max-width: 980px){\n    .container{ grid-template-columns: 1fr; }\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Knapsack Problem Visualizer</h1>\n  <div class=\"sub\">Explore 0/1, Unbounded, and Fractional knapsack with interactive items, dynamic programming tables, and step-by-step animation.</div>\n</header>\n\n<div class=\"container\">\n  <div class=\"panel\">\n    <h2>Setup</h2>\n    <div class=\"section\">\n      <div class=\"grid\" style=\"grid-template-columns: repeat(12, 1fr); gap:12px;\">\n        <div style=\"grid-column: span 6;\">\n          <label for=\"type\">Problem type</label>\n          <select id=\"type\">\n            <option value=\"01\">0/1 Knapsack (each item at most once)</option>\n            <option value=\"unbounded\">Unbounded Knapsack (infinite copies)</option>\n            <option value=\"fractional\">Fractional Knapsack (greedy, allow fractions)</option>\n          </select>\n        </div>\n        <div style=\"grid-column: span 3;\">\n          <label for=\"capacity\">Capacity</label>\n          <input type=\"number\" id=\"capacity\" min=\"0\" step=\"1\" value=\"5\" />\n        </div>\n        <div style=\"grid-column: span 3;\">\n          <label>&nbsp;</label>\n          <div class=\"controls\">\n            <button id=\"random\">Random items</button>\n            <button id=\"clear\" class=\"secondary\">Clear items</button>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"items\" id=\"items\">\n        <header>\n          <div>Name</div>\n          <div>Weight</div>\n          <div>Value</div>\n          <div>Action</div>\n        </header>\n        <div id=\"itemsBody\"></div>\n      </div>\n\n      <div class=\"row\" style=\"margin-top:10px;\">\n        <button id=\"addItem\">Add item</button>\n        <span class=\"hint\">\n          For 0/1 and Unbounded: weights must be non-negative integers. For Fractional: weights can be decimal. Values must be non-negative.\n        </span>\n      </div>\n    </div>\n\n    <h2>Run</h2>\n    <div class=\"section\">\n      <div class=\"row\">\n        <button id=\"solve\">Solve</button>\n        <button id=\"stop\" class=\"warn\" disabled>Stop</button>\n        <span class=\"badge\" id=\"algoInfo\">Algorithm: DP</span>\n      </div>\n      <div class=\"row\" style=\"margin-top:8px;\">\n        <label class=\"pill\"><input type=\"checkbox\" id=\"animate\" checked style=\"accent-color:#22d3ee; vertical-align:middle; margin-right:6px;\"> Animate</label>\n        <div class=\"range\">\n          <label for=\"speed\">Speed</label>\n          <input type=\"range\" id=\"speed\" min=\"10\" max=\"800\" value=\"150\" />\n        </div>\n        <div class=\"note\" id=\"notes\"></div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"panel out\">\n    <div class=\"top\">\n      <div class=\"stat\" id=\"bestVal\">Best value: -</div>\n      <div class=\"stat\" id=\"usedCap\">Used capacity: -</div>\n      <div class=\"stat\" id=\"optSet\">Chosen: -</div>\n      <div class=\"stat\" id=\"complexity\">Complexity: -</div>\n      <div style=\"flex:1\"></div>\n      <div class=\"legend\">Legend: <span class=\"pill\">Value</span> <span class=\"pill\">Take decision</span> <span class=\"pill\">Capacity columns</span></div>\n    </div>\n    <div class=\"viz\">\n      <div id=\"explain\" class=\"note\"></div>\n      <div class=\"canvas\" id=\"canvas\">\n        <!-- dynamic rendering -->\n      </div>\n      <div id=\"selectionList\" class=\"list\"></div>\n    </div>\n    <div class=\"footer\">\n      <div class=\"note\" id=\"status\">Ready.</div>\n      <div class=\"row\">\n        <button class=\"secondary\" id=\"example\">Load example</button>\n        <button class=\"secondary\" id=\"tiny\">Tiny</button>\n        <button class=\"secondary\" id=\"dense\">Many items</button>\n      </div>\n    </div>\n  </div>\n</div>\n\n<script>\n(function(){\n  const itemsBody = document.getElementById('itemsBody');\n  const typeSel = document.getElementById('type');\n  const capacityEl = document.getElementById('capacity');\n  const addBtn = document.getElementById('addItem');\n  const randomBtn = document.getElementById('random');\n  const clearBtn = document.getElementById('clear');\n  const solveBtn = document.getElementById('solve');\n  const stopBtn = document.getElementById('stop');\n  const animateChk = document.getElementById('animate');\n  const speedEl = document.getElementById('speed');\n  const canvas = document.getElementById('canvas');\n  const selectionList = document.getElementById('selectionList');\n  const statusEl = document.getElementById('status');\n  const bestValEl = document.getElementById('bestVal');\n  const usedCapEl = document.getElementById('usedCap');\n  const optSetEl = document.getElementById('optSet');\n  const complexityEl = document.getElementById('complexity');\n  const notesEl = document.getElementById('notes');\n  const algoInfo = document.getElementById('algoInfo');\n  const explainEl = document.getElementById('explain');\n  const exampleBtn = document.getElementById('example');\n  const tinyBtn = document.getElementById('tiny');\n  const denseBtn = document.getElementById('dense');\n\n  let animHandle = null;\n  let animQueue = [];\n  let animIndex = 0;\n  let isAnimating = false;\n  let colors = [\n    '#60a5fa','#34d399','#f472b6','#f59e0b','#a78bfa','#22d3ee',\n    '#ef4444','#10b981','#eab308','#c084fc','#38bdf8','#f43f5e'\n  ];\n  function colorFor(i){ return colors[i % colors.length]; }\n\n  function addItemRow(name='', weight='', value=''){\n    const row = document.createElement('div');\n    row.className = 'item';\n    row.innerHTML = `\n      <input type=\"text\" placeholder=\"Name\" value=\"${name}\"/>\n      <input type=\"number\" placeholder=\"Weight\" min=\"0\" step=\"0.01\" value=\"${weight}\"/>\n      <input type=\"number\" placeholder=\"Value\" min=\"0\" step=\"0.01\" value=\"${value}\"/>\n      <div><button class=\"del\">Remove</button></div>\n    `;\n    row.querySelector('.del').onclick = () => {\n      row.remove();\n      updateNote();\n    };\n    itemsBody.appendChild(row);\n  }\n  function clearItems(){\n    itemsBody.innerHTML = '';\n  }\n  function getItems(){\n    const rows = [...itemsBody.querySelectorAll('.item')];\n    const items = [];\n    for (let i=0;i<rows.length;i++){\n      const [nameEl, wEl, vEl] = rows[i].querySelectorAll('input');\n      const name = nameEl.value.trim() || `Item ${i+1}`;\n      const w = parseFloat(wEl.value);\n      const v = parseFloat(vEl.value);\n      if (Number.isFinite(w) && Number.isFinite(v) && w >= 0 && v >= 0){\n        items.push({ name, weight: w, value: v, idx: i });\n      }\n    }\n    return items;\n  }\n  function setStatus(msg, ok=true){\n    statusEl.textContent = msg;\n    statusEl.className = ok ? 'note ok' : 'note err';\n  }\n  function setExplain(){\n    const t = typeSel.value;\n    if (t === '01'){\n      explainEl.innerHTML = \"0/1 Knapsack: Dynamic programming O(n·W) builds a table of best value using first i items and capacity w. We either skip the item or take it once if weight fits. Backtracking yields chosen items.\";\n      algoInfo.textContent = \"Algorithm: Dynamic Programming (2D)\";\n      complexityEl.textContent = \"Complexity: Time O(n·W), Space O(n·W).\";\n      notesEl.textContent = \"Requires integer capacity and item weights.\";\n    } else if (t === 'unbounded'){\n      explainEl.innerHTML = \"Unbounded Knapsack: Dynamic programming O(n·W) with 1D array over capacity. For each capacity, try taking any item again and again.\";\n      algoInfo.textContent = \"Algorithm: Dynamic Programming (1D)\";\n      complexityEl.textContent = \"Complexity: Time O(n·W), Space O(W).\";\n      notesEl.textContent = \"Requires integer capacity and item weights.\";\n    } else {\n      explainEl.innerHTML = \"Fractional Knapsack: Greedy O(n log n) by value/weight density. Take highest-density items, possibly fractions, until capacity is full.\";\n      algoInfo.textContent = \"Algorithm: Greedy (sorting by value/weight)\";\n      complexityEl.textContent = \"Complexity: Time O(n log n), Space O(1) or O(n).\";\n      notesEl.textContent = \"Allows decimal weights; exact optimal with fractions.\";\n    }\n  }\n\n  function validate(items, capacity){\n    if (!Number.isFinite(capacity) || capacity < 0){\n      return \"Capacity must be a non-negative number.\";\n    }\n    if (items.length === 0){\n      return \"Please add at least one item.\";\n    }\n    for (const it of items){\n      if (!(Number.isFinite(it.value) && it.value >= 0)) return `Invalid value for ${it.name}.`;\n      if (!(Number.isFinite(it.weight) && it.weight >= 0)) return `Invalid weight for ${it.name}.`;\n    }\n    const t = typeSel.value;\n    if (t !== 'fractional'){\n      if (!Number.isInteger(capacity)) return \"Capacity must be an integer for DP variants.\";\n      for (const it of items){\n        if (!Number.isInteger(it.weight)) return `Weight of ${it.name} must be an integer for DP variants.`;\n      }\n    }\n    return null;\n  }\n\n  function resetOutput(){\n    bestValEl.textContent = \"Best value: -\";\n    usedCapEl.textContent = \"Used capacity: -\";\n    optSetEl.textContent = \"Chosen: -\";\n    selectionList.innerHTML = \"\";\n    canvas.innerHTML = \"\";\n  }\n\n  function renderSelection(itemsChosen, type, totalValue, totalWeight){\n    bestValEl.textContent = `Best value: ${fmt(totalValue)}`;\n    usedCapEl.textContent = `Used capacity: ${fmt(totalWeight)}`;\n    if (itemsChosen.length === 0){\n      optSetEl.textContent = \"Chosen: (none)\";\n    } else {\n      const names = itemsChosen.map(c => {\n        const qty = type === 'fractional' ? (c.fraction === 1 ? \"1\" : c.fraction.toFixed(2)) : (c.count ?? 1);\n        return `${c.item.name} × ${qty}`;\n      });\n      optSetEl.textContent = \"Chosen: \" + names.join(\", \");\n    }\n    selectionList.innerHTML = \"\";\n    if (type === 'fractional'){\n      // Bar visualization for fractional fill\n      const bar = document.createElement('div');\n      bar.className = 'bar';\n      let total = itemsChosen.reduce((s,x)=> s + x.weightTaken, 0);\n      const cap = parseFloat(capacityEl.value);\n      if (cap <= 0) total = 0;\n      if (cap > 0){\n        for (let i=0;i<itemsChosen.length;i++){\n          const c = itemsChosen[i];\n          const seg = document.createElement('div');\n          const pct = (c.weightTaken / cap) * 100;\n          seg.className = 'seg';\n          seg.style.width = Math.max(0.0001, pct) + '%';\n          seg.style.background = colorFor(c.item.idx);\n          bar.appendChild(seg);\n        }\n        if (total < cap){\n          const rem = document.createElement('div');\n          rem.className = 'seg';\n          rem.style.width = Math.max(0.0001, (100 - (total/cap)*100)) + '%';\n          rem.style.background = '#071426';\n          bar.appendChild(rem);\n        }\n      }\n      const wrap = document.createElement('div');\n      wrap.appendChild(bar);\n      wrap.style.marginBottom = \"6px\";\n      canvas.appendChild(wrap);\n    }\n    // Detailed list\n    for (const c of itemsChosen){\n      const row = document.createElement('div');\n      row.className = 'rowi';\n      const dot = document.createElement('div');\n      dot.textContent = c.item.name;\n      dot.style.display = 'flex';\n      dot.style.alignItems = 'center';\n      const badge = document.createElement('span');\n      badge.style.display = 'inline-block';\n      badge.style.width = '10px';\n      badge.style.height = '10px';\n      badge.style.borderRadius = '50%';\n      badge.style.marginRight = '8px';\n      badge.style.background = colorFor(c.item.idx);\n      dot.prepend(badge);\n      const w = document.createElement('div'); w.textContent = `w=${fmt(c.item.weight)}`;\n      const v = document.createElement('div'); v.textContent = `v=${fmt(c.item.value)}`;\n      const q = document.createElement('div');\n      if (type === 'fractional'){\n        q.textContent = `fraction=${fmt(c.fraction)} (taken w=${fmt(c.weightTaken)}, v=${fmt(c.valueTaken)})`;\n      } else {\n        q.textContent = `count=${c.count ?? 1}`;\n      }\n      row.append(dot, w, v, q);\n      selectionList.appendChild(row);\n    }\n  }\n\n  function fmt(x){\n    return Number.isInteger(x) ? x.toString() : (+x.toFixed(4)).toString().replace(/\\.?0+$/,'');\n  }\n\n  // 0/1 Knapsack DP (2D)\n  function solve01(items, W, onStep){\n    const n = items.length;\n    const dp = Array.from({length: n+1}, ()=> Array(W+1).fill(0));\n    const take = Array.from({length: n+1}, ()=> Array(W+1).fill(false));\n\n    const steps = [];\n    for (let i=1;i<=n;i++){\n      const wt = items[i-1].weight|0;\n      const val = items[i-1].value;\n      for (let w=0;w<=W;w++){\n        const skip = dp[i-1][w];\n        let opt = skip;\n        let took = false;\n        if (wt <= w){\n          const cand = dp[i-1][w-wt] + val;\n          if (cand > opt){\n            opt = cand;\n            took = true;\n          }\n        }\n        dp[i][w] = opt;\n        take[i][w] = took;\n        steps.push({i,w,val:opt,took,iName:items[i-1].name});\n        if (onStep) onStep({phase:'fill01', i, w, value: opt, took});\n      }\n    }\n    // Reconstruct\n    let w = W;\n    const chosen = [];\n    for (let i=n;i>=1;i--){\n      if (take[i][w]){\n        chosen.push(items[i-1]);\n        w -= items[i-1].weight;\n      }\n    }\n    const best = dp[n][W];\n    const used = chosen.reduce((s,it)=> s+it.weight,0);\n    return { dp, take, chosen, best, used, steps };\n  }\n\n  // Unbounded Knapsack DP (1D)\n  function solveUnbounded(items, W, onStep){\n    const dp = Array(W+1).fill(0);\n    const choice = Array(W+1).fill(-1); // item idx chosen at capacity c\n    const steps = [];\n    for (let c=0;c<=W;c++){\n      let best = dp[c];\n      for (let j=0;j<items.length;j++){\n        const it = items[j];\n        const wt = it.weight|0;\n        if (wt <= c){\n          const val = dp[c-wt] + it.value;\n          if (val > best){\n            best = val;\n            choice[c] = j;\n          }\n          steps.push({c, j, candidate: val, best});\n          if (onStep) onStep({phase:'fillUnb', c, j, candidate: val, best});\n        }\n      }\n      dp[c] = best;\n    }\n    // reconstruct\n    let c = W;\n    const counts = new Map();\n    while (c > 0 && choice[c] !== -1){\n      const j = choice[c];\n      counts.set(j, (counts.get(j) || 0) + 1);\n      c -= items[j].weight|0;\n      if (onStep) onStep({phase:'chooseUnb', c, j});\n    }\n    const chosen = [];\n    let used = 0;\n    counts.forEach((count,j)=>{\n      chosen.push({ item: items[j], count });\n      used += items[j].weight * count;\n    });\n    const best = dp[W];\n    return { dp, choice, chosen, best, used, steps };\n  }\n\n  // Fractional Knapsack Greedy\n  function solveFractional(items, W, onStep){\n    let cap = W;\n    const sorted = items\n      .map((it,i)=> ({...it, density: it.value/(it.weight||1e-9), origIdx:i}))\n      .sort((a,b)=> b.density - a.density);\n    const chosen = [];\n    let totalValue = 0;\n    let used = 0;\n    for (let k=0;k<sorted.length;k++){\n      const it = sorted[k];\n      if (cap <= 0) break;\n      if (it.weight === 0){\n        if (it.value > 0){\n          // Zero weight, positive value: take fully but won't change capacity\n          chosen.push({ item: it, fraction: 1, weightTaken: 0, valueTaken: it.value });\n          totalValue += it.value;\n        }\n        continue;\n      }\n      const takeW = Math.min(it.weight, cap);\n      const fraction = takeW / it.weight;\n      const addVal = it.value * fraction;\n      chosen.push({ item: it, fraction, weightTaken: takeW, valueTaken: addVal });\n      cap -= takeW;\n      used += takeW;\n      totalValue += addVal;\n      if (onStep) onStep({phase:'greedy', k, item: it, takeW, fraction, totalValue, used});\n    }\n    // Map back to original items indices for coloring\n    const mapped = chosen.map(c => ({\n      item: { name: c.item.name, weight: c.item.weight, value: c.item.value, idx: c.item.idx ?? c.item.origIdx },\n      fraction: c.fraction, weightTaken: c.weightTaken, valueTaken: c.valueTaken\n    }));\n    return { chosen: mapped, best: totalValue, used, steps: [] };\n  }\n\n  // Rendering functions\n  function renderDPTable01(dp, items, active=null){\n    // dp is (n+1) x (W+1)\n    const n = dp.length - 1;\n    const W = dp[0].length - 1;\n    canvas.innerHTML = '';\n    const table = document.createElement('div');\n    table.className = 'table';\n    table.style.setProperty('--cols', (W+2).toString());\n    // top row headers\n    const corner = document.createElement('div');\n    corner.className = 'cell header';\n    corner.textContent = 'Items/Capacity';\n    table.appendChild(corner);\n    const itemHdr = document.createElement('div');\n    itemHdr.className = 'cell header';\n    itemHdr.textContent = 'Item';\n    table.appendChild(itemHdr);\n    for (let w=0;w<=W;w++){\n      const h = document.createElement('div');\n      h.className = 'cell header';\n      h.textContent = w;\n      table.appendChild(h);\n    }\n    // rows\n    for (let i=0;i<=n;i++){\n      // item label\n      const lbl0 = document.createElement('div');\n      lbl0.className = 'cell itemhead';\n      lbl0.textContent = i === 0 ? '0 items' : `${i}. ${items[i-1].name} (w=${items[i-1].weight}, v=${items[i-1].value})`;\n      lbl0.style.gridColumn = '1 / span 2';\n      table.appendChild(lbl0);\n      for (let w=0;w<=W;w++){\n        const c = document.createElement('div');\n        c.className = 'cell';\n        c.textContent = dp[i][w];\n        c.dataset.i = i; c.dataset.w = w;\n        if (active && active.i === i && active.w === w){\n          c.classList.add('active');\n        }\n        table.appendChild(c);\n      }\n    }\n    canvas.appendChild(table);\n  }\n\n  function renderDPArrayUnbounded(dp, choice, items, active=null){\n    canvas.innerHTML = '';\n    const W = dp.length - 1;\n    const wrap = document.createElement('div');\n    wrap.style.display = 'grid';\n    wrap.style.gridTemplateColumns = 'repeat(auto-fit, minmax(48px,1fr))';\n    wrap.style.gap = '6px';\n    for (let c=0;c<=W;c++){\n      const cell = document.createElement('div');\n      cell.style.border = '1px solid #1f2a44';\n      cell.style.background = '#0a1628';\n      cell.style.borderRadius = '8px';\n      cell.style.padding = '6px';\n      cell.style.textAlign = 'center';\n      cell.innerHTML = `<div style=\"font-size:11px; opacity:.8\">c=${c}</div>\n                        <div style=\"font-weight:700; font-size:14px\">${dp[c]}</div>\n                        <div style=\"font-size:11px; opacity:.8\">${choice[c]!==-1 ? 'take '+items[choice[c]].name : '-'}</div>`;\n      if (active && active.c === c){\n        cell.style.outline = '2px solid var(--hilite)';\n      }\n      wrap.appendChild(cell);\n    }\n    canvas.appendChild(wrap);\n  }\n\n  function renderFractionalBar(chosen, capacity){\n    canvas.innerHTML = '';\n    const title = document.createElement('div');\n    title.textContent = 'Capacity fill';\n    title.style.marginBottom = '6px';\n    canvas.appendChild(title);\n    const bar = document.createElement('div');\n    bar.className = 'bar';\n    const used = chosen.reduce((s,x)=> s+x.weightTaken, 0);\n    if (capacity > 0){\n      chosen.forEach(c=>{\n        const seg = document.createElement('div');\n        seg.className='seg';\n        seg.style.background = colorFor(c.item.idx);\n        seg.style.width = Math.max(0.001, (c.weightTaken/capacity)*100) + '%';\n        seg.title = `${c.item.name} (fraction ${fmt(c.fraction)})`;\n        bar.appendChild(seg);\n      });\n      if (used < capacity){\n        const rem = document.createElement('div');\n        rem.className = 'seg';\n        rem.style.background = '#071426';\n        rem.style.width = Math.max(0.001, ((capacity-used)/capacity)*100) + '%';\n        bar.appendChild(rem);\n      }\n    }\n    canvas.appendChild(bar);\n    const detail = document.createElement('div');\n    detail.style.marginTop = '8px';\n    detail.innerHTML = chosen.map(c => {\n      return `<span class=\"pill\" style=\"border-color:#1d406c;background:#0b2239;\"><span style=\"display:inline-block;width:10px;height:10px;border-radius:50%;background:${colorFor(c.item.idx)};margin-right:6px;vertical-align:middle;\"></span>${c.item.name}: fraction=${fmt(c.fraction)}, w=${fmt(c.weightTaken)}, v=${fmt(c.valueTaken)}</span>`;\n    }).join(' ');\n    canvas.appendChild(detail);\n  }\n\n  function stopAnimation(){\n    if (animHandle){\n      clearTimeout(animHandle);\n      animHandle = null;\n    }\n    isAnimating = false;\n    animQueue = [];\n    animIndex = 0;\n    stopBtn.disabled = true;\n    solveBtn.disabled = false;\n  }\n\n  function animateSteps(steps, renderer, done){\n    stopAnimation(); // reset\n    if (steps.length === 0){\n      renderer(null);\n      done && done();\n      return;\n    }\n    isAnimating = true;\n    stopBtn.disabled = false;\n    solveBtn.disabled = true;\n    animQueue = steps;\n    animIndex = 0;\n\n    const loop = ()=>{\n      if (!isAnimating) return;\n      const s = animQueue[animIndex];\n      renderer(s);\n      animIndex++;\n      if (animIndex >= animQueue.length){\n        stopAnimation();\n        done && done();\n        return;\n      }\n      const delay = Math.max(10, +speedEl.value);\n      animHandle = setTimeout(loop, delay);\n    };\n    loop();\n  }\n\n  function solve(){\n    stopAnimation();\n    resetOutput();\n    const items = getItems();\n    const type = typeSel.value;\n    const capacity = type === 'fractional' ? parseFloat(capacityEl.value) : (capacityEl.value|0);\n    const err = validate(items, capacity);\n    if (err){\n      setStatus(err, false);\n      return;\n    }\n    setStatus('Solving...');\n    selectionList.innerHTML = '';\n    const animate = animateChk.checked;\n\n    if (type === '01'){\n      const onStep = null; // We'll animate after building steps array to simplify\n      const res = solve01(items, capacity, onStep);\n      const render = (s)=>{\n        if (!s){\n          renderDPTable01(res.dp, items, null);\n          return;\n        }\n        renderDPTable01(res.dp, items, {i:s.i, w:s.w});\n      };\n      if (animate){\n        // Create a synthetic steps array matching cell traversal\n        const steps = [];\n        for (let i=1;i<res.dp.length;i++){\n          for (let w=0;w<res.dp[0].length;w++){\n            steps.push({i,w});\n          }\n        }\n        animateSteps(steps, render, ()=>{\n          renderDPTable01(res.dp, items, null);\n          const chosen = res.chosen.map(it => ({ item: it, count: 1 }));\n          renderSelection(chosen, '01', res.best, res.used);\n          setStatus('Done.');\n        });\n      } else {\n        renderDPTable01(res.dp, items, null);\n        const chosen = res.chosen.map(it => ({ item: it, count: 1 }));\n        renderSelection(chosen, '01', res.best, res.used);\n        setStatus('Done.');\n      }\n    } else if (type === 'unbounded'){\n      const res = solveUnbounded(items, capacity, null);\n      const render = (s)=>{\n        renderDPArrayUnbounded(res.dp, res.choice, items, s ? {c: s.c} : null);\n      };\n      if (animate){\n        const steps = [];\n        for (let c=0;c<res.dp.length;c++){\n          steps.push({c});\n        }\n        animateSteps(steps, render, ()=>{\n          renderDPArrayUnbounded(res.dp, res.choice, items, null);\n          renderSelection(res.chosen, 'unbounded', res.best, res.used);\n          setStatus('Done.');\n        });\n      } else {\n        renderDPArrayUnbounded(res.dp, res.choice, items, null);\n        renderSelection(res.chosen, 'unbounded', res.best, res.used);\n        setStatus('Done.');\n      }\n    } else {\n      const res = solveFractional(items, capacity, null);\n      if (animate){\n        // Animate greedy picks one by one\n        const steps = res.chosen.map((c,idx)=> ({idx}));\n        animateSteps(steps, (s)=>{\n          const partial = res.chosen.slice(0, s.idx+1);\n          renderFractionalBar(partial, capacity);\n        }, ()=>{\n          renderFractionalBar(res.chosen, capacity);\n          renderSelection(res.chosen, 'fractional', res.best, res.used);\n          setStatus('Done.');\n        });\n      } else {\n        renderFractionalBar(res.chosen, capacity);\n        renderSelection(res.chosen, 'fractional', res.best, res.used);\n        setStatus('Done.');\n      }\n    }\n  }\n\n  // Examples\n  function loadExample(){\n    clearItems();\n    addItemRow('A', 2, 12);\n    addItemRow('B', 1, 10);\n    addItemRow('C', 3, 20);\n    addItemRow('D', 2, 15);\n    capacityEl.value = 5;\n  }\n  function loadTiny(){\n    clearItems();\n    addItemRow('Gold', 2, 3);\n    addItemRow('Silver', 3, 4);\n    capacityEl.value = 3;\n  }\n  function loadDense(){\n    clearItems();\n    const n=12;\n    for (let i=0;i<n;i++){\n      const w = Math.floor(Math.random()*7)+1;\n      const v = Math.floor(Math.random()*18)+3;\n      addItemRow(`I${i+1}`, w, v);\n    }\n    capacityEl.value = 25;\n  }\n  function randomItems(){\n    clearItems();\n    const n = Math.floor(Math.random()*6)+5;\n    for (let i=0;i<n;i++){\n      const w = Math.floor(Math.random()*9)+1;\n      const v = Math.floor(Math.random()*20)+5;\n      addItemRow(`Item ${i+1}`, w, v);\n    }\n    capacityEl.value = Math.floor(Math.random()*20)+10;\n  }\n\n  function updateNote(){\n    const items = getItems();\n    document.getElementById('optSet').textContent = \"Chosen: -\";\n    if (items.length > 0){\n      const sumW = items.reduce((s,it)=> s+it.weight,0);\n      const sumV = items.reduce((s,it)=> s+it.value,0);\n      notesEl.textContent = `Items: ${items.length}, total weight ${fmt(sumW)}, total value ${fmt(sumV)}`;\n    } else {\n      notesEl.textContent = '';\n    }\n  }\n\n  addBtn.onclick = ()=> { addItemRow('', '', ''); updateNote(); };\n  randomBtn.onclick = ()=> { randomItems(); resetOutput(); setStatus('Randomized.'); updateNote(); };\n  clearBtn.onclick = ()=> { clearItems(); resetOutput(); setStatus('Cleared.'); updateNote(); };\n  solveBtn.onclick = solve;\n  stopBtn.onclick = ()=> { stopAnimation(); setStatus('Stopped.', false); };\n  typeSel.onchange = ()=> { setExplain(); resetOutput(); };\n  exampleBtn.onclick = ()=> { loadExample(); resetOutput(); updateNote(); setStatus('Example loaded.'); };\n  tinyBtn.onclick = ()=> { loadTiny(); resetOutput(); updateNote(); setStatus('Tiny example loaded.'); };\n  denseBtn.onclick = ()=> { loadDense(); resetOutput(); updateNote(); setStatus('Large example loaded.'); };\n\n  // Initialize\n  loadExample();\n  setExplain();\n  updateNote();\n\n  // Accessibility: pressing Enter in inputs triggers solve\n  itemsBody.addEventListener('keydown', (e)=>{\n    if (e.key === 'Enter'){ solve(); }\n  });\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Knapsack Problem"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "ce1a3740-a36e-11f0-9662-bd06bca98e70",
    "timestamp": "2025-10-07T11:14:34.804Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Longest Common Subsequence",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Longest Common Subsequence (LCS) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root{\n      --bg: #0f172a;\n      --panel: #111827;\n      --accent: #6366f1;\n      --accent-2: #22c55e;\n      --accent-3: #f59e0b;\n      --text: #e5e7eb;\n      --muted: #9ca3af;\n      --border: #1f2937;\n      --danger: #ef4444;\n      --grid-cell: #0b1220;\n      --grid-header: #0d1526;\n      --current: #fde68a;\n      --neighbor: #1f2937;\n      --path: #a78bfa;\n      --match: #064e3b;\n    }\n    * { box-sizing: border-box; }\n    html, body { height: 100%; }\n    body {\n      margin: 0;\n      background: linear-gradient(120deg, #0b1020, #0f172a 60%, #0b1020);\n      color: var(--text);\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Segoe UI Emoji\", \"Apple Color Emoji\", sans-serif;\n      overflow-y: auto;\n    }\n    a { color: var(--accent); text-decoration: none; }\n    header {\n      padding: 16px 20px;\n      display: flex;\n      align-items: center;\n      justify-content: space-between;\n      border-bottom: 1px solid var(--border);\n      background: rgba(17, 24, 39, 0.6);\n      backdrop-filter: blur(6px);\n      position: sticky;\n      top: 0;\n      z-index: 10;\n    }\n    header h1 {\n      margin: 0;\n      font-size: 20px;\n      letter-spacing: 0.5px;\n    }\n    .container {\n      max-width: 1200px;\n      margin: 24px auto;\n      padding: 0 20px 40px;\n    }\n    .panel {\n      background: rgba(17, 24, 39, 0.65);\n      border: 1px solid var(--border);\n      border-radius: 12px;\n      padding: 16px;\n      box-shadow: 0 8px 16px rgba(0,0,0,0.25);\n    }\n    .row {\n      display: grid;\n      grid-template-columns: 1.25fr 0.75fr;\n      gap: 16px;\n    }\n    @media (max-width: 960px) {\n      .row { grid-template-columns: 1fr; }\n    }\n\n    /* Inputs */\n    .inputs {\n      display: grid;\n      grid-template-columns: 1fr 1fr;\n      gap: 12px;\n    }\n    @media (max-width: 720px) {\n      .inputs { grid-template-columns: 1fr; }\n    }\n    label {\n      display: block;\n      font-size: 12px;\n      color: var(--muted);\n      margin-bottom: 6px;\n      letter-spacing: 0.3px;\n    }\n    input[type=\"text\"], textarea {\n      width: 100%;\n      padding: 10px 12px;\n      border-radius: 8px;\n      border: 1px solid var(--border);\n      background: #0b1220;\n      color: var(--text);\n      font-size: 14px;\n    }\n    textarea { min-height: 52px; resize: vertical; }\n    .controls {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 8px;\n      align-items: center;\n      margin-top: 12px;\n    }\n    .btn {\n      background: #0b1220;\n      border: 1px solid var(--border);\n      color: var(--text);\n      padding: 8px 12px;\n      border-radius: 8px;\n      font-size: 14px;\n      cursor: pointer;\n      transition: 0.15s all ease;\n    }\n    .btn:hover { border-color: #334155; transform: translateY(-1px); }\n    .btn.primary {\n      background: linear-gradient(135deg, #4338ca, #6366f1);\n      border-color: transparent;\n    }\n    .btn.primary:hover { filter: brightness(1.08); }\n    .btn.danger {\n      background: linear-gradient(135deg, #be123c, #ef4444);\n      border-color: transparent;\n    }\n    .btn.secondary {\n      background: linear-gradient(135deg, #0b1220, #0d1526);\n      border-color: #1f2937;\n    }\n    .toggle {\n      display: inline-flex;\n      align-items: center;\n      gap: 6px;\n      font-size: 13px;\n      color: var(--muted);\n      padding: 6px 8px;\n      border-radius: 8px;\n      border: 1px dashed #1f2937;\n    }\n    .toggle input { transform: translateY(1px); }\n    .speed {\n      display: inline-flex;\n      align-items: center;\n      gap: 8px;\n      padding: 6px 10px;\n      border-radius: 8px;\n      border: 1px dashed #1f2937;\n      color: var(--muted);\n      font-size: 13px;\n    }\n    input[type=\"range\"] {\n      width: 140px;\n    }\n    select {\n      background: #0b1220;\n      border: 1px solid var(--border);\n      color: var(--text);\n      padding: 8px 12px;\n      border-radius: 8px;\n      font-size: 14px;\n      cursor: pointer;\n    }\n\n    /* Result summary */\n    .summary {\n      display: grid;\n      grid-template-columns: 3fr 2fr;\n      gap: 16px;\n      margin-top: 16px;\n    }\n    @media (max-width: 960px) {\n      .summary { grid-template-columns: 1fr; }\n    }\n    .lcs-box {\n      background: linear-gradient(135deg, rgba(67, 56, 202, 0.22), rgba(99, 102, 241, 0.12));\n      border: 1px solid #3730a3;\n      border-radius: 12px;\n      padding: 14px;\n    }\n    .lcs-title { font-size: 13px; color: #c7d2fe; }\n    .lcs-value {\n      font-weight: 700;\n      font-size: 18px;\n      margin-top: 4px;\n      letter-spacing: 0.4px;\n    }\n    .lcs-length {\n      margin-top: 6px;\n      font-size: 13px;\n      color: #cbd5e1;\n    }\n    .explain {\n      background: #0b1220;\n      border: 1px dashed #334155;\n      border-radius: 12px;\n      padding: 12px;\n      min-height: 72px;\n      display: flex;\n      flex-direction: column;\n      gap: 6px;\n      font-size: 14px;\n    }\n    .explain .line { color: #cbd5e1; }\n    .explain .muted { color: var(--muted); }\n    .legend {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 8px;\n      margin-top: 8px;\n      font-size: 12px;\n      color: var(--muted);\n    }\n    .key {\n      display: inline-flex;\n      align-items: center;\n      gap: 6px;\n      padding: 4px 8px;\n      border: 1px dashed #334155;\n      border-radius: 8px;\n      background: #0b1220;\n    }\n    .swatch {\n      width: 14px; height: 14px; border-radius: 4px; display: inline-block;\n    }\n\n    /* Grid */\n    .grid-wrapper {\n      margin-top: 16px;\n      overflow: auto;\n      border: 1px solid var(--border);\n      border-radius: 12px;\n      background: #0d1526;\n    }\n    .grid {\n      display: grid;\n      grid-auto-rows: 34px;\n      grid-auto-columns: 34px;\n      justify-content: start;\n      align-content: start;\n      padding: 10px;\n      gap: 2px;\n    }\n    .cell {\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      background: var(--grid-cell);\n      border: 1px solid #1f2937;\n      border-radius: 6px;\n      font-size: 13px;\n      position: relative;\n      color: #cbd5e1;\n      user-select: none;\n    }\n    .cell.header {\n      background: var(--grid-header);\n      color: #93c5fd;\n      font-weight: 600;\n      border-color: #1e293b;\n    }\n    .cell.corner {\n      background: #0b1220;\n    }\n    .cell.zero {\n      color: #64748b;\n    }\n    .cell.current {\n      background: #fef3c7;\n      color: #0f172a;\n      border-color: #f59e0b;\n      z-index: 2;\n    }\n    .cell.neighbor {\n      outline: 2px dashed #6b7280;\n      outline-offset: -3px;\n    }\n    .cell.match {\n      background: #064e3b;\n      border-color: #065f46;\n      color: #ecfeff;\n    }\n    .cell.path {\n      border-color: #a78bfa;\n      box-shadow: 0 0 0 2px rgba(167, 139, 250, 0.6) inset;\n    }\n    .arrow {\n      position: absolute;\n      right: 6px;\n      bottom: 2px;\n      font-size: 16px;\n      opacity: 0.9;\n    }\n    .arrow.diag { color: var(--accent-2); }\n    .arrow.up { color: #60a5fa; }\n    .arrow.left { color: #fb923c; }\n\n    .notice {\n      margin-top: 8px;\n      font-size: 12px;\n      color: var(--muted);\n    }\n\n    footer {\n      max-width: 1200px;\n      margin: 24px auto 40px;\n      color: var(--muted);\n      padding: 0 20px;\n      font-size: 12px;\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Longest Common Subsequence (LCS) Visualizer</h1>\n    <div style=\"font-size: 12px; color: var(--muted)\">Interactive dynamic programming grid with path reconstruction</div>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"row\">\n      <div class=\"panel\">\n        <div class=\"inputs\">\n          <div>\n            <label for=\"seqA\">Sequence A</label>\n            <textarea id=\"seqA\" placeholder=\"Enter first sequence\">ABCBDAB</textarea>\n          </div>\n          <div>\n            <label for=\"seqB\">Sequence B</label>\n            <textarea id=\"seqB\" placeholder=\"Enter second sequence\">BDCABA</textarea>\n          </div>\n        </div>\n\n        <div class=\"controls\">\n          <button class=\"btn primary\" id=\"computeBtn\">Compute</button>\n          <button class=\"btn secondary\" id=\"resetBtn\">Reset</button>\n          <button class=\"btn\" id=\"stepBtn\">Step</button>\n          <button class=\"btn\" id=\"playBtn\">Play</button>\n          <button class=\"btn\" id=\"pauseBtn\" disabled>Pause</button>\n\n          <span class=\"toggle\">\n            <input type=\"checkbox\" id=\"caseToggle\" />\n            <label for=\"caseToggle\" style=\"margin: 0\">Case sensitive</label>\n          </span>\n          <span class=\"toggle\">\n            <input type=\"checkbox\" id=\"spaceToggle\" />\n            <label for=\"spaceToggle\" style=\"margin: 0\">Ignore spaces</label>\n          </span>\n          <span class=\"toggle\">\n            <input type=\"checkbox\" id=\"pathToggle\" checked />\n            <label for=\"pathToggle\" style=\"margin: 0\">Show LCS path</label>\n          </span>\n          <span class=\"speed\">\n            Speed\n            <input type=\"range\" id=\"speedRange\" min=\"50\" max=\"800\" value=\"350\" />\n          </span>\n          <select id=\"examples\">\n            <option value=\"\">Examples</option>\n            <option value=\"ABCBDAB|BDCABA\">ABCBDAB vs BDCABA</option>\n            <option value=\"XMJYAUZ|MZJAWXU\">XMJYAUZ vs MZJAWXU</option>\n            <option value=\"AGGTAB|GXTXAYB\">AGGTAB vs GXTXAYB</option>\n            <option value=\"BANANA|ATANA\">BANANA vs ATANA</option>\n            <option value=\"ABCDGH|AEDFHR\">ABCDGH vs AEDFHR</option>\n          </select>\n          <button class=\"btn danger\" id=\"randomBtn\">Random A/B</button>\n        </div>\n\n        <div class=\"summary\">\n          <div class=\"lcs-box\">\n            <div class=\"lcs-title\">Longest Common Subsequence</div>\n            <div class=\"lcs-value\" id=\"lcsValue\">—</div>\n            <div class=\"lcs-length\" id=\"lcsLength\">Length: —</div>\n          </div>\n          <div class=\"explain\" id=\"explainBox\">\n            <div class=\"line\">Press Compute to fill the DP table or Step/Play to watch the algorithm.</div>\n            <div class=\"legend\">\n              <span class=\"key\"><span class=\"swatch\" style=\"background: var(--accent-2)\"></span> match: take diagonal + 1</span>\n              <span class=\"key\"><span class=\"swatch\" style=\"background: #60a5fa\"></span> up: take from top</span>\n              <span class=\"key\"><span class=\"swatch\" style=\"background: #fb923c\"></span> left: take from left</span>\n              <span class=\"key\"><span class=\"swatch\" style=\"background: var(--path)\"></span> LCS path</span>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"grid-wrapper\">\n          <div class=\"grid\" id=\"grid\"></div>\n        </div>\n        <div class=\"notice\" id=\"notice\"></div>\n      </div>\n\n      <div class=\"panel\">\n        <div style=\"font-weight: 700; margin-bottom: 8px\">How it works</div>\n        <ul style=\"margin: 0 0 10px 18px; line-height: 1.5\">\n          <li>Dynamic programming builds a (m+1)×(n+1) table where m and n are the lengths of the sequences.</li>\n          <li>Base row and column are 0 (empty prefix). For each cell (i, j):\n            <ul style=\"margin: 6px 0 0 18px\">\n              <li>If A[i−1] = B[j−1], L[i][j] = L[i−1][j−1] + 1 (diagonal step).</li>\n              <li>Else, L[i][j] = max(L[i−1][j], L[i][j−1]) (take top or left).</li>\n            </ul>\n          </li>\n          <li>Reconstruct the LCS by following arrows from the bottom-right: diagonal steps collect matched characters.</li>\n        </ul>\n        <div style=\"margin-top: 10px; color: var(--muted); font-size: 12px\">\n          Time complexity: O(m·n), Space: O(m·n) for full reconstruction. Space can be reduced to O(min(m, n)) if only the length is needed.\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <footer>\n    Tip: Keep sequences up to about 40 characters each to see the full grid clearly. Longer inputs still compute the LCS but skip the grid visualization.\n  </footer>\n\n  <script>\n    // LCS Visualizer\n    (function() {\n      const gridEl = document.getElementById('grid');\n      const seqAEl = document.getElementById('seqA');\n      const seqBEl = document.getElementById('seqB');\n      const lcsValueEl = document.getElementById('lcsValue');\n      const lcsLengthEl = document.getElementById('lcsLength');\n      const explainEl = document.getElementById('explainBox');\n      const computeBtn = document.getElementById('computeBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const stepBtn = document.getElementById('stepBtn');\n      const playBtn = document.getElementById('playBtn');\n      const pauseBtn = document.getElementById('pauseBtn');\n      const caseToggle = document.getElementById('caseToggle');\n      const spaceToggle = document.getElementById('spaceToggle');\n      const pathToggle = document.getElementById('pathToggle');\n      const speedRange = document.getElementById('speedRange');\n      const examples = document.getElementById('examples');\n      const randomBtn = document.getElementById('randomBtn');\n      const noticeEl = document.getElementById('notice');\n\n      const MAX_GRID = 40; // Visualization limit\n\n      let A = '';\n      let B = '';\n      let dp = [];\n      let dir = [];\n      let cellRefs = []; // DOM references for dp cells: [i][j]\n      let runningTimer = null;\n      let stepPos = { i: 1, j: 1 };\n      let gridVisible = true;\n\n      function preprocess(s) {\n        if (!caseToggle.checked) s = s.toLowerCase();\n        if (spaceToggle.checked) s = s.replace(/\\s+/g, '');\n        return s;\n      }\n\n      function clearExplain() {\n        explainEl.innerHTML = `\n          <div class=\"line\">Press Compute to fill the DP table or Step/Play to watch the algorithm.</div>\n          <div class=\"legend\">\n            <span class=\"key\"><span class=\"swatch\" style=\"background: var(--accent-2)\"></span> match: take diagonal + 1</span>\n            <span class=\"key\"><span class=\"swatch\" style=\"background: #60a5fa\"></span> up: take from top</span>\n            <span class=\"key\"><span class=\"swatch\" style=\"background: #fb923c\"></span> left: take from left</span>\n            <span class=\"key\"><span class=\"swatch\" style=\"background: var(--path)\"></span> LCS path</span>\n          </div>\n        `;\n      }\n\n      function explainCell(i, j, type, info) {\n        // type: 'match' | 'up' | 'left' | 'done'\n        let html = '';\n        if (type === 'match') {\n          html = `\n          <div class=\"line\">Comparing A[${i-1}] = '${escapeChar(A[i-1])}' and B[${j-1}] = '${escapeChar(B[j-1])}' → match</div>\n          <div class=\"line\">L[${i}][${j}] = L[${i-1}][${j-1}] + 1 = ${info.prev} + 1 = ${info.val}</div>`;\n        } else if (type === 'up') {\n          html = `\n          <div class=\"line\">Comparing A[${i-1}] = '${escapeChar(A[i-1])}' and B[${j-1}] = '${escapeChar(B[j-1])}' → no match</div>\n          <div class=\"line\">Take max(top, left): max(L[${i-1}][${j}] = ${info.top}, L[${i}][${j-1}] = ${info.left}) = ${info.val}</div>\n          <div class=\"muted\">Chose up (top)</div>`;\n        } else if (type === 'left') {\n          html = `\n          <div class=\"line\">Comparing A[${i-1}] = '${escapeChar(A[i-1])}' and B[${j-1}] = '${escapeChar(B[j-1])}' → no match</div>\n          <div class=\"line\">Take max(top, left): max(L[${i-1}][${j}] = ${info.top}, L[${i}][${j-1}] = ${info.left}) = ${info.val}</div>\n          <div class=\"muted\">Chose left</div>`;\n        } else if (type === 'done') {\n          html = `\n          <div class=\"line\">Done. Reconstructing path by following arrows from bottom-right.</div>\n          <div class=\"muted\">Diagonal moves collect characters in the LCS.</div>`;\n        }\n        explainEl.innerHTML = html + explainEl.innerHTML.replace(/[\\s\\S]*<div class=\"legend\">/, '<div class=\"legend\">$&'); // Keep legend\n      }\n\n      function escapeChar(ch) {\n        if (ch === ' ') return '␠';\n        if (ch === '\\t') return '␉';\n        if (ch === '\\n') return '␤';\n        return ch;\n      }\n\n      function initMatrices(m, n) {\n        dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n        dir = Array.from({ length: m + 1 }, () => Array(n + 1).fill(null));\n        cellRefs = Array.from({ length: m + 1 }, () => Array(n + 1).fill(null));\n      }\n\n      function buildGrid() {\n        gridEl.innerHTML = '';\n        cellRefs.forEach(row => row.fill(null));\n\n        const m = A.length, n = B.length;\n        // Visualization on/off based on size\n        gridVisible = (m <= MAX_GRID && n <= MAX_GRID);\n        noticeEl.textContent = '';\n        if (!gridVisible) {\n          noticeEl.textContent = `Grid hidden: sequence lengths m=${m}, n=${n}. Enter ≤ ${MAX_GRID} characters each to show visualization.`;\n          return;\n        }\n\n        gridEl.style.gridTemplateColumns = `repeat(${n + 2}, 34px)`;\n        gridEl.style.gridTemplateRows = `repeat(${m + 2}, 34px)`;\n\n        // Top-left corner\n        appendCell('↗', 'cell header corner');\n\n        // Top row: col2 is empty marker for j=0\n        appendCell('∅', 'cell header');\n        for (let j = 1; j <= n; j++) {\n          appendCell(escapeChar(B[j - 1]), 'cell header');\n        }\n\n        // Rows\n        for (let i = 0; i <= m; i++) {\n          // Left header: i=0 shows ∅, else A[i-1]\n          if (i === 0) appendCell('∅', 'cell header');\n          else appendCell(escapeChar(A[i - 1]), 'cell header');\n\n          // DP row j=0..n\n          for (let j = 0; j <= n; j++) {\n            const c = document.createElement('div');\n            c.className = 'cell zero';\n            c.textContent = '0';\n            gridEl.appendChild(c);\n            cellRefs[i][j] = c;\n\n            // Add arrow holder\n            const a = document.createElement('div');\n            a.className = 'arrow';\n            c.appendChild(a);\n          }\n        }\n      }\n\n      function appendCell(text, className) {\n        const c = document.createElement('div');\n        c.className = className;\n        c.textContent = text;\n        gridEl.appendChild(c);\n      }\n\n      function resetState() {\n        stopPlaying();\n        const rawA = seqAEl.value;\n        const rawB = seqBEl.value;\n        A = preprocess(rawA);\n        B = preprocess(rawB);\n\n        const m = A.length, n = B.length;\n        initMatrices(m, n);\n        buildGrid();\n        lcsValueEl.textContent = '—';\n        lcsLengthEl.textContent = 'Length: —';\n        clearExplain();\n\n        // Step pointers\n        stepPos = { i: 1, j: 1 };\n\n        // Render base zeros in grid cells if visible\n        if (gridVisible) {\n          for (let i = 0; i <= m; i++) {\n            for (let j = 0; j <= n; j++) {\n              updateCellContent(i, j, 0, null);\n              removeClasses(cellRefs[i][j], ['current', 'neighbor', 'match', 'path']);\n              cellRefs[i][j].classList.add('zero');\n            }\n          }\n        }\n      }\n\n      function computeAll() {\n        const m = A.length, n = B.length;\n        for (let i = 1; i <= m; i++) {\n          for (let j = 1; j <= n; j++) {\n            if (A[i - 1] === B[j - 1]) {\n              dp[i][j] = dp[i - 1][j - 1] + 1;\n              dir[i][j] = 'diag';\n            } else {\n              const up = dp[i - 1][j];\n              const left = dp[i][j - 1];\n              if (up >= left) {\n                dp[i][j] = up;\n                dir[i][j] = 'up';\n              } else {\n                dp[i][j] = left;\n                dir[i][j] = 'left';\n              }\n            }\n            if (gridVisible) {\n              updateCellContent(i, j, dp[i][j], dir[i][j], A[i - 1] === B[j - 1]);\n            }\n          }\n        }\n        const { lcs, path } = reconstructLCS();\n        lcsValueEl.textContent = lcs.length ? lcs : '—';\n        lcsLengthEl.textContent = `Length: ${dp[m][n]}`;\n        if (gridVisible && pathToggle.checked) highlightPath(path);\n        explainCell(m, n, 'done');\n      }\n\n      function stepOnce() {\n        const m = A.length, n = B.length;\n        if (stepPos.i > m) {\n          // Already finished\n          const { lcs, path } = reconstructLCS();\n          lcsValueEl.textContent = lcs.length ? lcs : '—';\n          lcsLengthEl.textContent = `Length: ${dp[m][n]}`;\n          if (gridVisible && pathToggle.checked) highlightPath(path);\n          explainCell(m, n, 'done');\n          return false;\n        }\n        const i = stepPos.i, j = stepPos.j;\n\n        // Clear previous highlights\n        clearHighlights();\n\n        // Highlight current and neighbors\n        if (gridVisible) {\n          cellRefs[i][j].classList.add('current');\n          if (i - 1 >= 0) cellRefs[i - 1][j].classList.add('neighbor');\n          if (j - 1 >= 0) cellRefs[i][j - 1].classList.add('neighbor');\n          if (i - 1 >= 0 && j - 1 >= 0) cellRefs[i - 1][j - 1].classList.add('neighbor');\n        }\n\n        if (A[i - 1] === B[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1] + 1;\n          dir[i][j] = 'diag';\n          if (gridVisible) updateCellContent(i, j, dp[i][j], 'diag', true);\n          explainCell(i, j, 'match', { prev: dp[i - 1][j - 1], val: dp[i][j] });\n        } else {\n          const up = dp[i - 1][j];\n          const left = dp[i][j - 1];\n          if (up >= left) {\n            dp[i][j] = up;\n            dir[i][j] = 'up';\n            if (gridVisible) updateCellContent(i, j, dp[i][j], 'up', false);\n            explainCell(i, j, 'up', { top: up, left, val: dp[i][j] });\n          } else {\n            dp[i][j] = left;\n            dir[i][j] = 'left';\n            if (gridVisible) updateCellContent(i, j, dp[i][j], 'left', false);\n            explainCell(i, j, 'left', { top: up, left, val: dp[i][j] });\n          }\n        }\n\n        // Advance\n        stepPos.j++;\n        if (stepPos.j > n) {\n          stepPos.i++;\n          stepPos.j = 1;\n        }\n\n        // If completed after this step, finalize\n        if (stepPos.i > m) {\n          const { lcs, path } = reconstructLCS();\n          lcsValueEl.textContent = lcs.length ? lcs : '—';\n          lcsLengthEl.textContent = `Length: ${dp[m][n]}`;\n          if (gridVisible && pathToggle.checked) highlightPath(path);\n          explainCell(m, n, 'done');\n          return false;\n        }\n        return true;\n      }\n\n      function play() {\n        stopPlaying();\n        playBtn.disabled = true;\n        pauseBtn.disabled = false;\n        stepBtn.disabled = true;\n        const delay = Number(speedRange.value);\n        runningTimer = setInterval(() => {\n          const cont = stepOnce();\n          if (!cont) stopPlaying();\n        }, delay);\n      }\n\n      function stopPlaying() {\n        if (runningTimer) clearInterval(runningTimer);\n        runningTimer = null;\n        playBtn.disabled = false;\n        pauseBtn.disabled = true;\n        stepBtn.disabled = false;\n      }\n\n      function updateCellContent(i, j, val, arrow, isMatch=false) {\n        if (!gridVisible) return;\n        const cell = cellRefs[i][j];\n        if (!cell) return;\n        cell.textContent = val.toString();\n        cell.classList.remove('zero');\n        const arr = cell.querySelector('.arrow');\n        if (arr) {\n          arr.textContent = arrow === 'diag' ? '↖' : arrow === 'up' ? '↑' : arrow === 'left' ? '←' : '';\n          arr.className = 'arrow ' + (arrow || '');\n        }\n        removeClasses(cell, ['match']);\n        if (isMatch) cell.classList.add('match');\n      }\n\n      function removeClasses(el, classes) {\n        classes.forEach(cls => el.classList.remove(cls));\n      }\n\n      function clearHighlights() {\n        if (!gridVisible) return;\n        const m = A.length, n = B.length;\n        for (let i = 0; i <= m; i++) {\n          for (let j = 0; j <= n; j++) {\n            const c = cellRefs[i][j];\n            removeClasses(c, ['current', 'neighbor']);\n          }\n        }\n      }\n\n      function reconstructLCS() {\n        const m = A.length, n = B.length;\n        let i = m, j = n;\n        const chars = [];\n        const path = [];\n        while (i > 0 && j > 0) {\n          const d = dir[i][j];\n          if (d === 'diag') {\n            chars.push(A[i - 1]);\n            path.push([i, j]);\n            i--; j--;\n          } else if (d === 'up') {\n            i--;\n          } else if (d === 'left') {\n            j--;\n          } else {\n            // Shouldn't happen; safeguard\n            i--; j--;\n          }\n        }\n        return { lcs: chars.reverse().join(''), path };\n      }\n\n      function highlightPath(path) {\n        if (!gridVisible) return;\n        const m = A.length, n = B.length;\n        // Clear previous path highlights\n        for (let i = 0; i <= m; i++) for (let j = 0; j <= n; j++) cellRefs[i][j].classList.remove('path');\n        // Apply new path\n        path.forEach(([i, j]) => cellRefs[i][j].classList.add('path'));\n      }\n\n      // Events\n      computeBtn.addEventListener('click', () => {\n        resetState();\n        computeAll();\n      });\n      resetBtn.addEventListener('click', () => {\n        resetState();\n      });\n      stepBtn.addEventListener('click', () => {\n        if (!dp.length) resetState();\n        stepOnce();\n      });\n      playBtn.addEventListener('click', () => {\n        if (!dp.length) resetState();\n        play();\n      });\n      pauseBtn.addEventListener('click', () => {\n        stopPlaying();\n      });\n      caseToggle.addEventListener('change', () => resetState());\n      spaceToggle.addEventListener('change', () => resetState());\n      pathToggle.addEventListener('change', () => {\n        if (!dp.length) return;\n        const { path } = reconstructLCS();\n        if (pathToggle.checked) highlightPath(path);\n        else if (gridVisible) {\n          const m = A.length, n = B.length;\n          for (let i = 0; i <= m; i++) for (let j = 0; j <= n; j++) cellRefs[i][j].classList.remove('path');\n        }\n      });\n      speedRange.addEventListener('input', () => {\n        if (runningTimer) {\n          stopPlaying();\n          play();\n        }\n      });\n      examples.addEventListener('change', () => {\n        const v = examples.value;\n        if (!v) return;\n        const [a, b] = v.split('|');\n        seqAEl.value = a;\n        seqBEl.value = b;\n        resetState();\n        computeAll();\n      });\n      randomBtn.addEventListener('click', () => {\n        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n        const lenA = randInt(6, 14);\n        const lenB = randInt(6, 14);\n        seqAEl.value = randString(alphabet, lenA);\n        seqBEl.value = randString(alphabet, lenB);\n        resetState();\n        computeAll();\n      });\n\n      function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n      function randString(alphabet, len) {\n        let s = '';\n        for (let i = 0; i < len; i++) s += alphabet[randInt(0, alphabet.length - 1)];\n        return s;\n      }\n\n      // Initialize\n      resetState();\n      computeAll();\n    })();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Longest Common Subsequence"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "096d70f0-a36f-11f0-8688-f9c849d2427d",
    "timestamp": "2025-10-07T11:16:14.335Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Huffman Coding",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<title>Huffman Coding – Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<style>\n  :root {\n    --bg: #101317;\n    --panel: #1a1f24;\n    --accent: #4db6ff;\n    --accent2: #ffb84d;\n    --text: #e6edf3;\n    --muted: #9aa4ad;\n    --good: #42c876;\n    --bad: #ff5f5f;\n    --border: #2a3238;\n    --code: #0f1720;\n  }\n  * { box-sizing: border-box; }\n  html, body { height: 100%; }\n  body {\n    margin: 0;\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n    color: var(--text);\n    background: linear-gradient(180deg, #0c0f13 0%, var(--bg) 60%, #131821 100%);\n  }\n  header {\n    padding: 16px 20px;\n    border-bottom: 1px solid var(--border);\n    background: rgba(26,31,36,0.7);\n    position: sticky;\n    top: 0;\n    backdrop-filter: blur(6px);\n    z-index: 2;\n  }\n  header h1 {\n    margin: 0;\n    font-size: 20px;\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    letter-spacing: 0.3px;\n  }\n  header h1 .chip {\n    font-size: 12px;\n    color: var(--muted);\n    padding: 2px 8px;\n    border: 1px solid var(--border);\n    border-radius: 999px;\n  }\n  main {\n    padding: 18px;\n    max-width: 1200px;\n    margin: 0 auto;\n    display: grid;\n    gap: 14px;\n    grid-template-columns: 1.2fr 1fr;\n    grid-auto-rows: min-content;\n  }\n  .panel {\n    background: var(--panel);\n    border: 1px solid var(--border);\n    border-radius: 10px;\n    overflow: hidden;\n  }\n  .panel header {\n    background: none;\n    border: none;\n    padding: 12px 14px;\n    position: static;\n  }\n  .panel header h2 {\n    margin: 0;\n    font-size: 16px;\n    font-weight: 600;\n  }\n  .panel .body {\n    padding: 12px;\n  }\n  .controls {\n    display: flex;\n    gap: 8px;\n    flex-wrap: wrap;\n    margin-top: 10px;\n  }\n  textarea {\n    width: 100%;\n    min-height: 160px;\n    resize: vertical;\n    color: var(--text);\n    background: #0c1116;\n    border: 1px solid var(--border);\n    border-radius: 8px;\n    padding: 10px 12px;\n    line-height: 1.5;\n  }\n  button, .btn {\n    cursor: pointer;\n    background: #0c1116;\n    color: var(--text);\n    border: 1px solid var(--border);\n    border-radius: 8px;\n    padding: 8px 12px;\n    font-size: 14px;\n    transition: background .15s, border-color .15s, transform .02s;\n  }\n  button.primary {\n    background: linear-gradient(180deg, #0e2130 0%, #0c1722 100%);\n    border-color: #143047;\n    color: #cfe9ff;\n  }\n  button:hover {\n    background: #0f141a;\n    border-color: #37424a;\n  }\n  button.primary:hover { border-color: #1e4b6b; }\n  button:active { transform: translateY(1px); }\n  .grid {\n    display: grid;\n    gap: 10px;\n  }\n  .row { display: flex; align-items: center; gap: 10px; }\n  .summary {\n    display: grid;\n    grid-template-columns: repeat(3, 1fr);\n    gap: 8px;\n  }\n  .summary .stat {\n    background: #0c1116;\n    border: 1px solid var(--border);\n    border-radius: 8px;\n    padding: 8px 10px;\n  }\n  .stat .label { font-size: 12px; color: var(--muted); }\n  .stat .value { font-size: 16px; margin-top: 4px; }\n  .mono {\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", monospace;\n    background: var(--code);\n    border-radius: 6px;\n    padding: 2px 6px;\n  }\n  .table {\n    width: 100%;\n    border-collapse: collapse;\n    font-size: 14px;\n  }\n  .table th, .table td {\n    border-bottom: 1px solid var(--border);\n    padding: 6px 6px;\n    text-align: left;\n    vertical-align: top;\n  }\n  .table th {\n    color: var(--muted);\n    font-weight: 600;\n    background: #0c1116;\n    position: sticky;\n    top: 0;\n    z-index: 1;\n  }\n  .scroll {\n    max-height: 260px;\n    overflow: auto;\n    border: 1px solid var(--border);\n    border-radius: 8px;\n  }\n  .badge {\n    display: inline-block;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid var(--border);\n    color: var(--muted);\n    font-size: 12px;\n    margin-left: 4px;\n  }\n  .note {\n    color: var(--muted);\n    font-size: 13px;\n  }\n  .steps {\n    display: grid;\n    gap: 8px;\n  }\n  .step {\n    padding: 8px;\n    border-radius: 8px;\n    border: 1px solid var(--border);\n    background: #0c1116;\n  }\n  .step .title {\n    font-weight: 600;\n    font-size: 13px;\n    color: var(--accent);\n    margin-bottom: 4px;\n  }\n  .codes {\n    display: grid;\n    gap: 6px;\n  }\n  .code-row {\n    display: grid;\n    grid-template-columns: 72px 1fr auto;\n    gap: 8px;\n    align-items: center;\n    border: 1px solid var(--border);\n    border-radius: 8px;\n    padding: 6px 8px;\n    background: #0c1116;\n  }\n  .char-box {\n    display: flex; align-items: center; justify-content: center;\n    border: 1px dashed #334;\n    border-radius: 6px;\n    padding: 6px 8px;\n    min-height: 30px;\n    color: #d5dee6;\n    background: #0a0f14;\n  }\n  .svg-wrap {\n    border: 1px solid var(--border);\n    border-radius: 10px;\n    overflow: hidden;\n    background: #0c1116;\n  }\n  svg { width: 100%; height: 100%; display: block; }\n  .edge-label {\n    font-size: 12px; fill: #95a3ad;\n    background: rgba(0,0,0,0.5);\n  }\n  .node circle {\n    fill: #14202a;\n    stroke: #23323b;\n    stroke-width: 1.5;\n  }\n  .node.leaf circle { fill: #1b2a34; }\n  .node text {\n    fill: #e6edf3; font-size: 12px; text-anchor: middle; dominant-baseline: central;\n  }\n  .legend { font-size: 12px; color: var(--muted); }\n  .encoded {\n    border: 1px solid var(--border);\n    border-radius: 8px;\n    background: #0c1116;\n    padding: 8px;\n    font-size: 13px;\n  }\n  .encoded .bits {\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", monospace;\n    word-break: break-all;\n    background: #0a0f14;\n    border-radius: 6px;\n    padding: 8px;\n    line-height: 1.5;\n    max-height: 200px;\n    overflow: auto;\n    border: 1px solid #223;\n  }\n  .row-actions { display: flex; gap: 8px; align-items: center; }\n  .ok { color: var(--good); }\n  .fail { color: var(--bad); }\n  .help {\n    font-size: 13px;\n    color: var(--muted);\n    margin-top: 6px;\n  }\n  .kpi {\n    display: inline-flex; align-items: center; gap: 8px;\n    padding: 6px 8px; border-radius: 8px; background: #0c1116; border: 1px solid var(--border);\n  }\n  .small { font-size: 12px; color: var(--muted); }\n  .hidden { display: none !important; }\n  .footer-note {\n    text-align: center; color: var(--muted); padding: 16px; font-size: 12px;\n  }\n  .toggle {\n    display: inline-flex;\n    align-items: center;\n    gap: 6px;\n    padding: 4px 6px;\n    border: 1px solid var(--border);\n    border-radius: 999px;\n    color: var(--muted);\n    cursor: pointer;\n  }\n  .toggle input { accent-color: var(--accent); }\n</style>\n</head>\n<body>\n  <header>\n    <h1>\n      Huffman Coding\n      <span class=\"chip\">Prefix-free variable-length codes</span>\n    </h1>\n  </header>\n\n  <main>\n    <section class=\"panel\" style=\"grid-column: 1 / span 2;\">\n      <header><h2>Input Text</h2></header>\n      <div class=\"body\">\n        <textarea id=\"input\" placeholder=\"Type some text to compress using Huffman coding.\">this is an example of a huffman tree</textarea>\n        <div class=\"controls\">\n          <button class=\"primary\" id=\"buildBtn\">Build Huffman & Encode</button>\n          <button id=\"decodeBtn\">Decode Encoded Bits</button>\n          <button id=\"randomBtn\">Use Sample Text</button>\n          <button id=\"clearBtn\">Clear</button>\n          <label class=\"toggle\"><input type=\"checkbox\" id=\"showSteps\" checked /> Show build steps</label>\n          <label class=\"toggle\"><input type=\"checkbox\" id=\"showTree\" checked /> Show tree</label>\n          <label class=\"toggle\"><input type=\"checkbox\" id=\"canonical\" /> Canonical view (sorted codes)</label>\n        </div>\n        <div class=\"help\">\n          Huffman coding assigns shorter bit-codes to more frequent characters and longer bit-codes to less frequent ones. The tree below is built by repeatedly merging the two least frequent nodes.\n        </div>\n      </div>\n    </section>\n\n    <section class=\"panel\">\n      <header><h2>Frequencies</h2></header>\n      <div class=\"body\">\n        <div id=\"freqSummary\" class=\"summary\" aria-live=\"polite\">\n          <div class=\"stat\"><div class=\"label\">Unique chars</div><div class=\"value\" id=\"statUnique\">–</div></div>\n          <div class=\"stat\"><div class=\"label\">Total chars</div><div class=\"value\" id=\"statTotal\">–</div></div>\n          <div class=\"stat\"><div class=\"label\">Entropy bound</div><div class=\"value\" id=\"statEntropy\">–</div></div>\n        </div>\n        <div class=\"scroll\" style=\"margin-top:10px;\">\n          <table class=\"table\" id=\"freqTable\">\n            <thead>\n              <tr><th>Char</th><th>Count</th><th>Probability</th></tr>\n            </thead>\n            <tbody></tbody>\n          </table>\n        </div>\n        <div class=\"note\">Entropy shown is the theoretical lower bound (bits/char) from −Σp log₂ p.</div>\n      </div>\n    </section>\n\n    <section class=\"panel\">\n      <header><h2>Codes</h2></header>\n      <div class=\"body\">\n        <div id=\"codesList\" class=\"codes\"></div>\n        <div class=\"note\">Huffman codes are prefix-free: no code is the prefix of another.</div>\n      </div>\n    </section>\n\n    <section class=\"panel\" style=\"grid-column: 1 / span 2;\">\n      <header><h2>Huffman Tree</h2></header>\n      <div class=\"body\">\n        <div id=\"treeWrap\" class=\"svg-wrap\" style=\"height: 380px;\">\n          <svg id=\"treeSvg\" viewBox=\"0 0 800 380\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n        </div>\n        <div class=\"legend\" style=\"margin-top:8px;\">\n          Left edge labeled 0, right edge labeled 1. Leaves show character and frequency; internal nodes show combined frequency.\n        </div>\n      </div>\n    </section>\n\n    <section class=\"panel\">\n      <header><h2>Encoding</h2></header>\n      <div class=\"body\">\n        <div class=\"grid\">\n          <div class=\"encoded\">\n            <div class=\"row-actions\">\n              <div class=\"kpi\">\n                <div>Encoded length: <span id=\"encodedBitsLen\" class=\"mono\">–</span> bits</div>\n              </div>\n              <div class=\"kpi\">\n                <div>Original: <span id=\"originalBitsLen\" class=\"mono\">–</span> bits</div>\n              </div>\n              <div class=\"kpi\">\n                <div>Avg bits/char: <span id=\"avgBits\" class=\"mono\">–</span></div>\n              </div>\n              <div class=\"kpi\">\n                <div>Compression ratio: <span id=\"ratio\" class=\"mono\">–</span></div>\n              </div>\n            </div>\n            <div class=\"bits\" id=\"encodedBits\"></div>\n            <div class=\"controls\">\n              <button id=\"copyBits\">Copy Bits</button>\n              <button id=\"toggleBits\">Toggle full bits view</button>\n            </div>\n          </div>\n          <div class=\"note\">\n            Original size assumes 8 bits per character (typical single-byte encoding). Huffman improves average bits/char toward the entropy bound for this distribution.\n          </div>\n        </div>\n      </div>\n    </section>\n\n    <section class=\"panel\">\n      <header><h2>Build Steps</h2></header>\n      <div class=\"body\">\n        <div id=\"stepsList\" class=\"steps\"></div>\n      </div>\n    </section>\n\n    <section class=\"panel\" style=\"grid-column: 1 / span 2;\">\n      <header><h2>Decode</h2></header>\n      <div class=\"body\">\n        <div class=\"row\">\n          <div class=\"kpi\">Decoded matches original: <span id=\"decodeStatus\" class=\"mono\">–</span></div>\n        </div>\n        <div class=\"encoded\" style=\"margin-top:10px;\">\n          <div style=\"margin-bottom:6px; color: var(--muted);\">Decoded text:</div>\n          <div id=\"decodedText\" class=\"bits\" style=\"max-height:120px;\"></div>\n        </div>\n      </div>\n    </section>\n\n    <div class=\"footer-note\">This demo builds a Huffman tree from your input, shows the resulting prefix-free codes, encodes the text to a bitstream, and decodes it back using the tree.</div>\n  </main>\n\n<script>\n(function(){\n  // Utility helpers\n  const displayChar = ch => {\n    if (ch === ' ') return 'space';\n    if (ch === '\\n') return '↵ newline';\n    if (ch === '\\t') return '⇥ tab';\n    if (ch === '\\r') return '␍ CR';\n    const code = ch.codePointAt(0);\n    const printable = code >= 33 && code <= 126;\n    if (printable) return ch;\n    return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n  };\n  const formatProb = p => (p === 0 ? '0' : (Math.round(p * 10000) / 10000).toString());\n  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));\n\n  // Huffman core\n  function getFrequencies(text) {\n    const map = new Map();\n    for (const ch of text) map.set(ch, (map.get(ch) || 0) + 1);\n    return map;\n  }\n  function entropy(freqMap) {\n    let total = 0, H = 0;\n    for (const [,count] of freqMap) total += count;\n    for (const [,count] of freqMap) {\n      const p = count / total;\n      H += -p * Math.log2(p);\n    }\n    return { H, total };\n  }\n  let NODE_ID = 0, ORDER_ID = 0;\n  function nodeId() { return NODE_ID++; }\n  function orderId() { return ORDER_ID++; }\n\n  function buildHuffman(text) {\n    NODE_ID = 0; ORDER_ID = 0;\n    const freqMap = getFrequencies(text);\n    const totalChars = text.length;\n    const unique = freqMap.size;\n\n    const leaves = [];\n    for (const [ch, cnt] of freqMap) {\n      leaves.push({ id: nodeId(), order: orderId(), freq: cnt, char: ch, left: null, right: null });\n    }\n\n    const steps = [];\n    let root = null;\n    if (leaves.length === 0) {\n      root = null;\n    } else if (leaves.length === 1) {\n      // Single-char special case: the tree is just one leaf.\n      root = leaves[0];\n    } else {\n      const pq = leaves.slice();\n      while (pq.length > 1) {\n        pq.sort((a,b)=> (a.freq - b.freq) || (a.order - b.order));\n        const left = pq.shift();\n        const right = pq.shift();\n        const parent = { id: nodeId(), order: orderId(), freq: left.freq + right.freq, char: null, left, right };\n        steps.push({ left, right, parent });\n        pq.push(parent);\n      }\n      root = pq[0];\n    }\n\n    const codes = {};\n    if (root) {\n      const traverse = (node, prefix) => {\n        if (!node) return;\n        if (node.char !== null && node.left === null && node.right === null) {\n          // If prefix is empty (single unique char), assign '0'\n          codes[node.char] = prefix.length ? prefix : '0';\n          return;\n        }\n        if (node.left) traverse(node.left, prefix + '0');\n        if (node.right) traverse(node.right, prefix + '1');\n      };\n      traverse(root, '');\n    }\n\n    const encodedBitsArr = [];\n    for (const ch of text) {\n      const code = codes[ch];\n      if (!code) continue;\n      encodedBitsArr.push(code);\n    }\n    const encodedBits = encodedBitsArr.join('');\n    const encodedBitsLen = encodedBits.length;\n\n    return {\n      freqMap,\n      totalChars,\n      unique,\n      steps,\n      root,\n      codes,\n      encodedBits,\n      encodedBitsLen\n    };\n  }\n\n  function decodeBits(root, bits, freqMap, originalLen) {\n    if (!root) return '';\n    // Single-leaf tree:\n    if (root.char !== null && !root.left && !root.right) {\n      const count = (bits && bits.length) ? bits.length : (freqMap.get(root.char) || originalLen || 0);\n      return root.char.repeat(count);\n    }\n    let out = '';\n    let node = root;\n    for (let i=0; i<bits.length; i++) {\n      const b = bits[i];\n      node = (b === '0') ? node.left : node.right;\n      if (!node) {\n        // invalid bitstream\n        return out;\n      }\n      if (node.char !== null) {\n        out += node.char;\n        node = root;\n      }\n    }\n    return out;\n  }\n\n  // Tree drawing\n  function computeDepth(node) {\n    if (!node) return 0;\n    if (node.char !== null && !node.left && !node.right) return 1;\n    return 1 + Math.max(node.left ? computeDepth(node.left) : 0, node.right ? computeDepth(node.right) : 0);\n  }\n  function assignPositions(node) {\n    const nodes = [];\n    let xIndex = 0;\n    const visit = (n, depth) => {\n      if (!n) return;\n      const isLeaf = n.char !== null && !n.left && !n.right;\n      if (!isLeaf) {\n        visit(n.left, depth+1);\n        visit(n.right, depth+1);\n      }\n      if (isLeaf) {\n        n._x = xIndex++;\n        n._y = depth;\n      } else {\n        const lx = n.left ? n.left._x : xIndex;\n        const rx = n.right ? n.right._x : xIndex;\n        n._x = (lx + rx) / 2;\n        n._y = depth;\n      }\n      nodes.push(n);\n    };\n    visit(node, 0);\n    return { nodes, leafCount: Math.max(1, xIndex) };\n  }\n\n  function drawTree(root, svgEl) {\n    while (svgEl.firstChild) svgEl.removeChild(svgEl.firstChild);\n    if (!root) {\n      const t = createSvgEl('text', { x: 20, y: 24, fill: '#95a3ad' });\n      t.textContent = 'No tree (input is empty).';\n      svgEl.appendChild(t);\n      return;\n    }\n    const depth = computeDepth(root);\n    const { nodes, leafCount } = assignPositions(root);\n    const hGap = clamp(1200 / Math.max(leafCount, 4), 70, 160);\n    const vGap = clamp(360 / Math.max(depth, 3), 60, 120);\n    const marginX = 30, marginY = 30;\n    const width = Math.max(leafCount * hGap + marginX * 2, 600);\n    const height = Math.max(depth * vGap + marginY * 2, 300);\n    svgEl.setAttribute('viewBox', `0 0 ${width} ${height}`);\n\n    const pos = n => [marginX + n._x * hGap, marginY + n._y * vGap];\n\n    // Edges\n    const drawEdge = (from, to, label) => {\n      if (!to) return;\n      const [x1,y1] = pos(from);\n      const [x2,y2] = pos(to);\n      const line = createSvgEl('line', { x1, y1, x2, y2, stroke: '#284050', 'stroke-width': 1.5 });\n      svgEl.appendChild(line);\n      // label\n      const mx = (x1 + x2)/2;\n      const my = (y1 + y2)/2;\n      const lbl = createSvgEl('text', { x: mx, y: my - 4, class: 'edge-label' });\n      lbl.textContent = label;\n      svgEl.appendChild(lbl);\n    };\n\n    const visited = new Set();\n    const drawNode = n => {\n      if (!n || visited.has(n.id)) return;\n      visited.add(n.id);\n      if (n.left) drawEdge(n, n.left, '0');\n      if (n.right) drawEdge(n, n.right, '1');\n\n      const [x,y] = pos(n);\n      const g = createSvgEl('g', { class: 'node' + (n.char !== null && !n.left && !n.right ? ' leaf' : '' ) });\n      const circle = createSvgEl('circle', { cx: x, cy: y, r: 16 });\n      g.appendChild(circle);\n      const text = createSvgEl('text', { x, y });\n      if (n.char !== null && !n.left && !n.right) {\n        text.textContent = `${displayChar(n.char)} • ${n.freq}`;\n      } else {\n        text.textContent = `${n.freq}`;\n      }\n      g.appendChild(text);\n      svgEl.appendChild(g);\n\n      drawNode(n.left);\n      drawNode(n.right);\n    };\n    drawNode(root);\n  }\n  function createSvgEl(tag, attrs) {\n    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);\n    for (const k in attrs) el.setAttribute(k, attrs[k]);\n    return el;\n  }\n\n  // UI binding\n  const els = {\n    input: document.getElementById('input'),\n    buildBtn: document.getElementById('buildBtn'),\n    decodeBtn: document.getElementById('decodeBtn'),\n    randomBtn: document.getElementById('randomBtn'),\n    clearBtn: document.getElementById('clearBtn'),\n    showSteps: document.getElementById('showSteps'),\n    showTree: document.getElementById('showTree'),\n    canonical: document.getElementById('canonical'),\n\n    statUnique: document.getElementById('statUnique'),\n    statTotal: document.getElementById('statTotal'),\n    statEntropy: document.getElementById('statEntropy'),\n\n    freqTableBody: document.querySelector('#freqTable tbody'),\n    codesList: document.getElementById('codesList'),\n    stepsList: document.getElementById('stepsList'),\n\n    treeSvg: document.getElementById('treeSvg'),\n    treeWrap: document.getElementById('treeWrap'),\n\n    encodedBits: document.getElementById('encodedBits'),\n    encodedBitsLen: document.getElementById('encodedBitsLen'),\n    originalBitsLen: document.getElementById('originalBitsLen'),\n    avgBits: document.getElementById('avgBits'),\n    ratio: document.getElementById('ratio'),\n    copyBits: document.getElementById('copyBits'),\n    toggleBits: document.getElementById('toggleBits'),\n\n    decodeStatus: document.getElementById('decodeStatus'),\n    decodedText: document.getElementById('decodedText'),\n  };\n\n  let state = {\n    result: null,\n    showFullBits: false\n  };\n\n  function renderAll() {\n    const text = els.input.value || '';\n    const result = buildHuffman(text);\n    state.result = result;\n\n    // Stats & freq\n    const ent = entropy(result.freqMap);\n    els.statUnique.textContent = result.unique || '0';\n    els.statTotal.textContent = result.totalChars || '0';\n    els.statEntropy.textContent = ent.H ? (Math.round(ent.H * 100) / 100) + ' bits/char' : '0';\n\n    // Frequency table\n    renderFreqTable(result.freqMap, ent.total);\n    // Codes\n    renderCodes(result.codes, result.freqMap, !!els.canonical.checked);\n    // Tree\n    els.treeWrap.classList.toggle('hidden', !els.showTree.checked);\n    if (els.showTree.checked) drawTree(result.root, els.treeSvg);\n    // Steps\n    els.stepsList.parentElement.parentElement.classList.toggle('hidden', !els.showSteps.checked);\n    renderSteps(result.steps);\n\n    // Encoding outputs\n    const bitsLen = result.encodedBitsLen || 0;\n    const origBits = result.totalChars * 8;\n    els.encodedBitsLen.textContent = bitsLen;\n    els.originalBitsLen.textContent = origBits;\n    const avg = result.totalChars ? (bitsLen / result.totalChars) : 0;\n    els.avgBits.textContent = result.totalChars ? (Math.round(avg * 100) / 100) : '0';\n    const ratio = origBits ? (Math.round((bitsLen / origBits) * 1000) / 1000) : 0;\n    els.ratio.textContent = origBits ? (ratio + 'x') : '–';\n    renderEncodedBits(result.encodedBits);\n\n    // Reset decode display\n    els.decodeStatus.textContent = '–';\n    els.decodeStatus.className = 'mono';\n    els.decodedText.textContent = '';\n  }\n\n  function renderFreqTable(freqMap, total) {\n    const tbody = els.freqTableBody;\n    tbody.innerHTML = '';\n    const rows = [...freqMap.entries()].sort((a,b)=> b[1]-a[1]);\n    for (const [ch, cnt] of rows) {\n      const tr = document.createElement('tr');\n      const tdChar = document.createElement('td');\n      tdChar.textContent = displayChar(ch);\n      const tdCnt = document.createElement('td');\n      tdCnt.textContent = cnt;\n      const tdProb = document.createElement('td');\n      tdProb.textContent = formatProb(cnt / (total || 1));\n      tr.append(tdChar, tdCnt, tdProb);\n      tbody.appendChild(tr);\n    }\n    if (rows.length === 0) {\n      const tr = document.createElement('tr');\n      const td = document.createElement('td');\n      td.colSpan = 3;\n      td.textContent = 'No characters.';\n      tr.appendChild(td);\n      tbody.appendChild(tr);\n    }\n  }\n\n  function renderCodes(codes, freqMap, canonical) {\n    const container = els.codesList;\n    container.innerHTML = '';\n    const entries = Object.entries(codes);\n    if (entries.length === 0) {\n      container.innerHTML = '<div class=\"note\">No codes (empty input).</div>';\n      return;\n    }\n    const items = entries.map(([ch, code]) => {\n      const cnt = freqMap.get(ch) || 0;\n      return { ch, code, cnt, len: code.length };\n    });\n    if (canonical) {\n      items.sort((a,b)=> (a.len - b.len) || (a.code.localeCompare(b.code)) || (a.ch.localeCompare(b.ch)));\n    } else {\n      items.sort((a,b)=> b.cnt - a.cnt);\n    }\n    for (const it of items) {\n      const row = document.createElement('div');\n      row.className = 'code-row';\n      const charBox = document.createElement('div');\n      charBox.className = 'char-box';\n      charBox.textContent = displayChar(it.ch);\n      const codeBox = document.createElement('div');\n      codeBox.className = 'mono';\n      codeBox.textContent = it.code;\n      const meta = document.createElement('div');\n      meta.className = 'small';\n      meta.textContent = `${it.cnt} × ${it.len} bits = ${it.cnt * it.len} bits`;\n      row.append(charBox, codeBox, meta);\n      container.appendChild(row);\n    }\n  }\n\n  function renderSteps(steps) {\n    const container = els.stepsList;\n    container.innerHTML = '';\n    if (!steps || steps.length === 0) {\n      container.innerHTML = '<div class=\"note\">No merges (single or empty input).</div>';\n      return;\n    }\n    let i = 1;\n    for (const st of steps) {\n      const div = document.createElement('div');\n      div.className = 'step';\n      const title = document.createElement('div');\n      title.className = 'title';\n      title.textContent = `Step ${i++}: Merge two lowest-frequency nodes`;\n      const body = document.createElement('div');\n      const leftLabel = st.left.char !== null ? `‘${displayChar(st.left.char)}’ (${st.left.freq})` : `node(${st.left.freq})`;\n      const rightLabel = st.right.char !== null ? `‘${displayChar(st.right.char)}’ (${st.right.freq})` : `node(${st.right.freq})`;\n      body.textContent = `Merged ${leftLabel} + ${rightLabel} -> node(${st.parent.freq})`;\n      div.append(title, body);\n      container.appendChild(div);\n    }\n  }\n\n  function renderEncodedBits(bits) {\n    const showFull = state.showFullBits;\n    const maxShow = 900;\n    if (!bits || bits.length === 0) {\n      els.encodedBits.textContent = '(empty)';\n      return;\n    }\n    if (showFull || bits.length <= maxShow) {\n      els.encodedBits.textContent = bits;\n    } else {\n      const head = bits.slice(0, maxShow);\n      els.encodedBits.textContent = head + ' … (+' + (bits.length - head.length) + ' bits)';\n    }\n  }\n\n  // Events\n  els.buildBtn.addEventListener('click', renderAll);\n  els.decodeBtn.addEventListener('click', () => {\n    const res = state.result;\n    if (!res) return;\n    const decoded = decodeBits(res.root, res.encodedBits, res.freqMap, res.totalChars);\n    els.decodedText.textContent = decoded;\n    const ok = decoded === (els.input.value || '');\n    els.decodeStatus.textContent = ok ? 'OK' : 'Mismatch';\n    els.decodeStatus.className = 'mono ' + (ok ? 'ok' : 'fail');\n  });\n  els.randomBtn.addEventListener('click', () => {\n    const samples = [\n      'this is an example of a huffman tree',\n      'banana bandana',\n      'the quick brown fox jumps over the lazy dog',\n      'aaaaabcccdde',\n      'lorem ipsum dolor sit amet, consectetur adipiscing elit',\n      'mississippi river',\n      'hello hello hello world'\n    ];\n    const s = samples[Math.floor(Math.random() * samples.length)];\n    els.input.value = s;\n    renderAll();\n  });\n  els.clearBtn.addEventListener('click', () => {\n    els.input.value = '';\n    renderAll();\n  });\n  els.showSteps.addEventListener('change', () => {\n    renderAll();\n  });\n  els.showTree.addEventListener('change', () => {\n    renderAll();\n  });\n  els.canonical.addEventListener('change', () => {\n    renderAll();\n  });\n  els.copyBits.addEventListener('click', async () => {\n    const res = state.result;\n    if (!res || !res.encodedBits) return;\n    try {\n      await navigator.clipboard.writeText(res.encodedBits);\n      els.copyBits.textContent = 'Copied!';\n      setTimeout(()=> els.copyBits.textContent = 'Copy Bits', 1000);\n    } catch (e) {\n      alert('Clipboard copy failed.');\n    }\n  });\n  els.toggleBits.addEventListener('click', () => {\n    state.showFullBits = !state.showFullBits;\n    renderEncodedBits(state.result ? state.result.encodedBits : '');\n    els.toggleBits.textContent = state.showFullBits ? 'Show less' : 'Toggle full bits view';\n  });\n\n  // Auto-build on load and on typing\n  let typingTimer = null;\n  els.input.addEventListener('input', () => {\n    clearTimeout(typingTimer);\n    typingTimer = setTimeout(renderAll, 150);\n  });\n\n  // Initial render\n  renderAll();\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Huffman Coding"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "4996c3c0-a36f-11f0-8129-759c71b18af6",
    "timestamp": "2025-10-07T11:18:01.980Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Recursion",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n<title>Recursion Demonstration</title>\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --accent: #22d3ee;\n    --accent2: #a78bfa;\n    --text: #e5e7eb;\n    --muted: #94a3b8;\n    --green: #34d399;\n    --yellow: #f59e0b;\n    --red: #ef4444;\n    --border: #1f2937;\n  }\n  html, body {\n    margin: 0;\n    padding: 0;\n    background: radial-gradient(1000px 800px at 20% 0%, #0a0f24 0%, #0f172a 33%, #0b1322 100%);\n    color: var(--text);\n    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n  }\n  header {\n    padding: 24px 16px 8px;\n    text-align: center;\n  }\n  header h1 {\n    margin: 0;\n    font-size: 28px;\n    letter-spacing: 0.3px;\n  }\n  header p {\n    margin: 8px auto 0;\n    max-width: 900px;\n    color: var(--muted);\n    font-size: 15px;\n  }\n  main {\n    max-width: 1100px;\n    margin: 16px auto 48px;\n    padding: 0 12px;\n  }\n  section {\n    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.00));\n    border: 1px solid var(--border);\n    border-radius: 12px;\n    padding: 16px;\n    margin-bottom: 18px;\n    box-shadow: 0 15px 35px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.05);\n  }\n  section h2 {\n    margin: 0 0 8px 0;\n    font-size: 20px;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n  }\n  .controls {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 10px;\n    align-items: center;\n    margin: 8px 0 12px;\n  }\n  .control {\n    display: inline-flex;\n    gap: 8px;\n    align-items: center;\n    padding: 8px 10px;\n    border-radius: 10px;\n    background: #0b1223;\n    border: 1px solid var(--border);\n  }\n  label {\n    font-size: 13px;\n    color: var(--muted);\n  }\n  input[type=\"number\"], input[type=\"range\"] {\n    accent-color: var(--accent);\n  }\n  input[type=\"number\"] {\n    width: 90px;\n    padding: 6px 8px;\n    border-radius: 8px;\n    border: 1px solid var(--border);\n    background: #0a1021;\n    color: var(--text);\n  }\n  button {\n    padding: 8px 12px;\n    border-radius: 10px;\n    border: 1px solid var(--border);\n    background: #0b1223;\n    color: var(--text);\n    cursor: pointer;\n    transition: transform 0.05s ease, background 0.2s ease, border-color 0.2s ease;\n  }\n  button:hover {\n    background: #0e162b;\n    border-color: #263248;\n  }\n  button:active {\n    transform: translateY(1px);\n  }\n  button.primary {\n    background: linear-gradient(90deg, rgba(34,211,238,0.15), rgba(167,139,250,0.15));\n    border-color: #2a405f;\n  }\n  .note {\n    font-size: 13px;\n    color: var(--muted);\n    margin-top: 6px;\n  }\n\n  /* Trace tree */\n  #traceOutput {\n    border: 1px dashed #223048;\n    border-radius: 10px;\n    padding: 12px;\n    background: #0a1021;\n    max-height: 400px;\n    overflow: auto;\n  }\n  .traceHeader {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 16px;\n    align-items: baseline;\n    margin-bottom: 8px;\n  }\n  .traceHeader .result {\n    font-weight: 600;\n    color: var(--green);\n  }\n  .traceHeader .meta {\n    color: var(--muted);\n    font-size: 13px;\n  }\n  ul.tree {\n    list-style: none;\n    margin: 0;\n    padding-left: 14px;\n    border-left: 1px dashed #253047;\n  }\n  .tree li {\n    margin: 3px 0;\n    position: relative;\n  }\n  .tree li::before {\n    content: \"\";\n    position: absolute;\n    left: -13px;\n    top: 10px;\n    width: 12px;\n    height: 1px;\n    background: #253047;\n  }\n  .nodeLabel {\n    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, \"Liberation Mono\", monospace;\n    font-size: 13px;\n    padding: 2px 6px;\n    border-radius: 6px;\n    background: #0f1831;\n    border: 1px solid #1f2a46;\n  }\n  .baseCase { color: var(--green); border-color: #23543b; background: #0b1a14; }\n  .recursiveCase { color: #8ab4f8; }\n\n  /* Fractal canvas */\n  #fractalCanvas {\n    width: 100%;\n    max-width: 1000px;\n    height: 420px;\n    border-radius: 12px;\n    border: 1px solid var(--border);\n    background: radial-gradient(800px 500px at 50% 0%, #0a0f24 0%, #0f162c 50%, #0a1020 100%);\n    display: block;\n    margin: auto;\n  }\n  .legend {\n    font-size: 12px;\n    color: var(--muted);\n    text-align: center;\n    margin-top: 6px;\n  }\n\n  /* Hanoi */\n  .pegContainer {\n    display: grid;\n    grid-template-columns: 1fr 1fr 1fr;\n    gap: 10px;\n    margin-top: 8px;\n  }\n  .peg {\n    position: relative;\n    min-height: 220px;\n    border: 1px solid var(--border);\n    border-radius: 12px;\n    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.00));\n    padding: 8px;\n    display: flex;\n    align-items: flex-end;\n    justify-content: center;\n    overflow: hidden;\n  }\n  .peg::after {\n    content: \"\";\n    position: absolute;\n    width: 6px;\n    height: 150px;\n    background: #1a2742;\n    bottom: 45px;\n    left: 50%;\n    transform: translateX(-50%);\n    border-radius: 3px;\n    box-shadow: inset 0 0 6px rgba(0,0,0,0.5);\n  }\n  .pegLabel {\n    position: absolute;\n    top: 6px;\n    left: 8px;\n    font-weight: 600;\n    color: var(--muted);\n    font-size: 13px;\n  }\n  .base {\n    position: absolute;\n    bottom: 8px;\n    left: 10%;\n    right: 10%;\n    height: 12px;\n    background: #1a2742;\n    border-radius: 8px;\n    box-shadow: inset 0 0 6px rgba(0,0,0,0.6);\n  }\n  .disk {\n    height: 18px;\n    border-radius: 10px;\n    margin: 2px 0;\n    border: 1px solid #213251;\n    box-shadow: 0 6px 12px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.08);\n  }\n  .diskLabel {\n    font-size: 11px;\n    color: #dbeafe;\n    text-shadow: 0 1px 0 rgba(0,0,0,0.4);\n    text-align: center;\n    line-height: 18px;\n  }\n  #hanoiMoves {\n    max-height: 200px;\n    overflow: auto;\n    border: 1px dashed #223048;\n    border-radius: 10px;\n    padding: 10px;\n    background: #0a1021;\n    margin-top: 8px;\n    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, \"Liberation Mono\", monospace;\n    font-size: 13px;\n  }\n  .warn {\n    color: var(--yellow);\n  }\n  .err {\n    color: var(--red);\n  }\n  .success {\n    color: var(--green);\n  }\n  footer {\n    text-align: center;\n    color: var(--muted);\n    font-size: 13px;\n    padding: 18px 12px 30px;\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Recursion in JavaScript</h1>\n  <p>Recursion is when a function calls itself to break a problem into smaller subproblems. This page demonstrates recursion with numeric traces, a fractal tree, and the Tower of Hanoi algorithm.</p>\n</header>\n<main>\n  <section id=\"traces\">\n    <h2>Recursive Functions: Factorial and Fibonacci</h2>\n    <div class=\"controls\">\n      <div class=\"control\">\n        <label for=\"nInput\">n</label>\n        <input id=\"nInput\" type=\"number\" min=\"0\" max=\"20\" value=\"5\"/>\n      </div>\n      <button id=\"btnFactorial\" class=\"primary\">Trace Factorial(n)</button>\n      <button id=\"btnFibonacci\">Trace Fibonacci(n)</button>\n      <button id=\"btnClearTrace\">Clear</button>\n    </div>\n    <div class=\"note\">Tip: Fibonacci grows exponentially in calls. For responsiveness, n is limited to 12.</div>\n    <div id=\"traceOutput\" aria-live=\"polite\"></div>\n  </section>\n\n  <section id=\"fractal\">\n    <h2>Fractal Tree: Visual Recursion</h2>\n    <div class=\"controls\">\n      <div class=\"control\">\n        <label for=\"depthRange\">Depth</label>\n        <input id=\"depthRange\" type=\"range\" min=\"0\" max=\"12\" value=\"8\"/>\n        <span id=\"depthVal\">8</span>\n      </div>\n      <div class=\"control\">\n        <label for=\"angleRange\">Branch Angle</label>\n        <input id=\"angleRange\" type=\"range\" min=\"10\" max=\"60\" value=\"30\"/>\n        <span id=\"angleVal\">30°</span>\n      </div>\n      <div class=\"control\">\n        <label for=\"factorRange\">Length Factor</label>\n        <input id=\"factorRange\" type=\"range\" min=\"55\" max=\"80\" value=\"67\"/>\n        <span id=\"factorVal\">0.67</span>\n      </div>\n      <button id=\"btnRedraw\" class=\"primary\">Redraw Tree</button>\n      <button id=\"btnAnimateTree\">Animate Depth</button>\n      <button id=\"btnStopTree\">Stop</button>\n    </div>\n    <canvas id=\"fractalCanvas\" width=\"1000\" height=\"420\"></canvas>\n    <div class=\"legend\">Each branch splits into two smaller branches until the depth reaches zero. That branching is a recursive call.</div>\n  </section>\n\n  <section id=\"hanoi\">\n    <h2>Tower of Hanoi: Recursive Algorithm</h2>\n    <div class=\"controls\">\n      <div class=\"control\">\n        <label for=\"diskRange\">Disks</label>\n        <input id=\"diskRange\" type=\"range\" min=\"1\" max=\"8\" value=\"4\"/>\n        <span id=\"diskVal\">4</span>\n      </div>\n      <button id=\"btnBuildHanoi\" class=\"primary\">Setup</button>\n      <button id=\"btnSolveHanoi\">Solve (List Moves)</button>\n      <button id=\"btnAnimateHanoi\">Animate</button>\n      <button id=\"btnStopHanoi\">Stop</button>\n    </div>\n    <div class=\"pegContainer\">\n      <div class=\"peg\" id=\"pegA\"><div class=\"pegLabel\">A</div><div class=\"base\"></div></div>\n      <div class=\"peg\" id=\"pegB\"><div class=\"pegLabel\">B</div><div class=\"base\"></div></div>\n      <div class=\"peg\" id=\"pegC\"><div class=\"pegLabel\">C</div><div class=\"base\"></div></div>\n    </div>\n    <div id=\"hanoiMoves\"></div>\n    <div class=\"note\">Algorithm: Move n−1 disks from A→B, move the largest from A→C, then move n−1 from B→C. This self-referential step is recursion.</div>\n  </section>\n</main>\n\n<footer>\n  Recursion lets us express complex structures and algorithms elegantly by repeatedly solving smaller instances of the same problem.\n</footer>\n\n<script>\n  // Utility: create element\n  function el(tag, props = {}, children = []) {\n    const e = document.createElement(tag);\n    Object.entries(props).forEach(([k, v]) => {\n      if (k === 'class') e.className = v;\n      else if (k === 'text') e.textContent = v;\n      else e.setAttribute(k, v);\n    });\n    children.forEach(c => e.appendChild(c));\n    return e;\n  }\n\n  // ----- Trace: Factorial & Fibonacci -----\n  function traceFactorial(n) {\n    const node = { label: `fact(${n})`, value: null, children: [], base: false };\n    if (n <= 1) {\n      node.value = 1;\n      node.base = true;\n    } else {\n      const child = traceFactorial(n - 1);\n      node.children.push(child);\n      node.value = n * child.value;\n    }\n    return node;\n  }\n\n  function traceFibonacci(n) {\n    const node = { label: `fib(${n})`, value: null, children: [], base: false };\n    if (n <= 1) {\n      node.value = n;\n      node.base = true;\n    } else {\n      // recursive calls\n      const left = traceFibonacci(n - 1);\n      const right = traceFibonacci(n - 2);\n      node.children.push(left, right);\n      node.value = left.value + right.value;\n    }\n    return node;\n  }\n\n  function renderTree(node) {\n    const rootUl = el('ul', { class: 'tree' });\n    function walk(n) {\n      const li = el('li');\n      const span = el('span', { class: `nodeLabel ${n.base ? 'baseCase' : 'recursiveCase'}`, title: n.base ? 'Base case' : 'Recursive case' }, []);\n      span.textContent = `${n.label} = ${n.value}`;\n      li.appendChild(span);\n      if (n.children && n.children.length) {\n        const ul = el('ul', { class: 'tree' });\n        n.children.forEach(c => ul.appendChild(walk(c)));\n        li.appendChild(ul);\n      }\n      return li;\n    }\n    rootUl.appendChild(walk(node));\n    return rootUl;\n  }\n\n  function countNodes(node) {\n    let c = 1;\n    for (const ch of node.children || []) c += countNodes(ch);\n    return c;\n  }\n\n  const nInput = document.getElementById('nInput');\n  const traceOut = document.getElementById('traceOutput');\n  const btnFact = document.getElementById('btnFactorial');\n  const btnFib = document.getElementById('btnFibonacci');\n  const btnClearTrace = document.getElementById('btnClearTrace');\n\n  btnClearTrace.addEventListener('click', () => {\n    traceOut.innerHTML = '';\n  });\n\n  btnFact.addEventListener('click', () => {\n    let n = parseInt(nInput.value, 10) || 0;\n    n = Math.max(0, Math.min(n, 20)); // safe upper bound\n    const node = traceFactorial(n);\n    const header = el('div', { class: 'traceHeader' }, [\n      el('div', { class: 'result' }, [el('span', { text: `fact(${n}) = ${node.value}` })]),\n      el('div', { class: 'meta' }, [el('span', { text: `recursive calls: ${countNodes(node)}` })]),\n      el('div', { class: 'meta' }, [el('span', { text: `base cases: ${n === 0 ? 1 : 1}` })])\n    ]);\n    traceOut.innerHTML = '';\n    traceOut.appendChild(header);\n    traceOut.appendChild(renderTree(node));\n  });\n\n  btnFib.addEventListener('click', () => {\n    let n = parseInt(nInput.value, 10) || 0;\n    if (n > 12) {\n      n = 12;\n      nInput.value = 12;\n      const warn = el('div', { class: 'note warn' }, [el('span', { text: 'Fibonacci capped at n = 12 for performance.' })]);\n      traceOut.prepend(warn);\n      setTimeout(() => warn.remove(), 2500);\n    }\n    const node = traceFibonacci(n);\n    const header = el('div', { class: 'traceHeader' }, [\n      el('div', { class: 'result' }, [el('span', { text: `fib(${n}) = ${node.value}` })]),\n      el('div', { class: 'meta' }, [el('span', { text: `recursive calls: ${countNodes(node)}` })]),\n      el('div', { class: 'meta' }, [el('span', { text: 'base cases: fib(0) and fib(1)' })])\n    ]);\n    traceOut.innerHTML = '';\n    traceOut.appendChild(header);\n    traceOut.appendChild(renderTree(node));\n  });\n\n  // ----- Fractal Tree -----\n  const canvas = document.getElementById('fractalCanvas');\n  const ctx = canvas.getContext('2d');\n\n  const depthRange = document.getElementById('depthRange');\n  const angleRange = document.getElementById('angleRange');\n  const factorRange = document.getElementById('factorRange');\n  const depthVal = document.getElementById('depthVal');\n  const angleVal = document.getElementById('angleVal');\n  const factorVal = document.getElementById('factorVal');\n\n  let treeAnim = null;\n\n  function clearCanvas() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  function drawBranch(x1, y1, x2, y2, width, hue) {\n    ctx.strokeStyle = `hsl(${hue}, 70%, 70%)`;\n    ctx.lineWidth = width;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n  }\n\n  function drawTree(x, y, len, angleRad, depth, factor, angleDelta, width = 6, hue = 200) {\n    if (depth === 0 || len < 2) return;\n    const x2 = x + Math.cos(angleRad) * len;\n    const y2 = y - Math.sin(angleRad) * len;\n    drawBranch(x, y, x2, y2, width, hue);\n\n    const nextLen = len * factor;\n    const nextHue = hue + 2;\n    const nextWidth = Math.max(1.2, width * 0.72);\n\n    // Left and Right branches\n    drawTree(x2, y2, nextLen, angleRad + angleDelta, depth - 1, factor, angleDelta, nextWidth, nextHue);\n    drawTree(x2, y2, nextLen, angleRad - angleDelta, depth - 1, factor, angleDelta, nextWidth, nextHue);\n  }\n\n  function renderFractal() {\n    const depth = parseInt(depthRange.value, 10);\n    const angleDeg = parseInt(angleRange.value, 10);\n    const factorPct = parseInt(factorRange.value, 10);\n    const factor = factorPct / 100;\n\n    depthVal.textContent = depth;\n    angleVal.textContent = angleDeg + '°';\n    factorVal.textContent = factor.toFixed(2);\n\n    clearCanvas();\n    // Base trunk length scales to canvas width/height\n    const trunkLen = Math.min(canvas.height * 0.28, canvas.width * 0.18);\n    const startX = canvas.width / 2;\n    const startY = canvas.height - 16;\n    const angleRad = Math.PI / 2; // upwards\n    const angleDelta = angleDeg * Math.PI / 180;\n\n    drawTree(startX, startY, trunkLen, angleRad, depth, factor, angleDelta);\n  }\n\n  document.getElementById('btnRedraw').addEventListener('click', renderFractal);\n  depthRange.addEventListener('input', renderFractal);\n  angleRange.addEventListener('input', renderFractal);\n  factorRange.addEventListener('input', renderFractal);\n\n  document.getElementById('btnAnimateTree').addEventListener('click', () => {\n    if (treeAnim) return;\n    let d = 0;\n    const target = parseInt(depthRange.value, 10);\n    treeAnim = setInterval(() => {\n      depthRange.value = d;\n      renderFractal();\n      d++;\n      if (d > target) {\n        clearInterval(treeAnim);\n        treeAnim = null;\n      }\n    }, 120);\n  });\n  document.getElementById('btnStopTree').addEventListener('click', () => {\n    if (treeAnim) {\n      clearInterval(treeAnim);\n      treeAnim = null;\n    }\n  });\n\n  // Initial render\n  renderFractal();\n\n  // ----- Tower of Hanoi -----\n  const diskRange = document.getElementById('diskRange');\n  const diskVal = document.getElementById('diskVal');\n  const pegA = document.getElementById('pegA');\n  const pegB = document.getElementById('pegB');\n  const pegC = document.getElementById('pegC');\n  const hanoiMovesDiv = document.getElementById('hanoiMoves');\n\n  let pegs = { A: [], B: [], C: [] };\n  let hanoiAnim = null;\n\n  function updateDiskVal() {\n    diskVal.textContent = diskRange.value;\n  }\n  diskRange.addEventListener('input', updateDiskVal);\n  updateDiskVal();\n\n  function buildInitial(disks) {\n    pegs = { A: [], B: [], C: [] };\n    // Largest disk is disks, smallest is 1\n    for (let i = disks; i >= 1; i--) pegs.A.push(i);\n    renderPegs();\n    hanoiMovesDiv.innerHTML = `<div class=\"success\">Ready: ${disks} disks on peg A.</div>`;\n  }\n\n  function renderPegs() {\n    [pegA, pegB, pegC].forEach(peg => {\n      // Remove all disks first\n      Array.from(peg.querySelectorAll('.disk')).forEach(d => d.remove());\n    });\n    const maxDisks = Math.max(pegs.A.length, pegs.B.length, pegs.C.length, parseInt(diskRange.value, 10));\n    const maxWidth = 220;\n    const minWidth = 60;\n\n    function renderPeg(pegEl, arr) {\n      // Render bottom to top\n      arr.forEach((size, idx) => {\n        const t = (size - 1) / Math.max(1, maxDisks - 1);\n        const w = Math.round(minWidth + t * (maxWidth - minWidth));\n        const disk = el('div', { class: 'disk' });\n        disk.style.width = w + 'px';\n        // Color gradient by size\n        const hue = 200 + Math.round(t * 140);\n        disk.style.background = `linear-gradient(90deg, hsl(${hue},60%,42%), hsl(${hue+20},70%,52%))`;\n        disk.style.borderColor = `hsl(${hue},50%,32%)`;\n        const label = el('div', { class: 'diskLabel', text: `Disk ${size}` });\n        disk.appendChild(label);\n        pegEl.appendChild(disk);\n      });\n    }\n    renderPeg(pegA, pegs.A);\n    renderPeg(pegB, pegs.B);\n    renderPeg(pegC, pegs.C);\n  }\n\n  function hanoiMoves(n, from, aux, to, list) {\n    // Count calls implicitly by list length; but track if needed\n    if (n === 1) {\n      list.push([from, to]);\n    } else {\n      hanoiMoves(n - 1, from, to, aux, list);\n      list.push([from, to]);\n      hanoiMoves(n - 1, aux, from, to, list);\n    }\n    return list;\n  }\n\n  function performMove(from, to) {\n    const disk = pegs[from].pop();\n    if (disk == null) return false;\n    // Simple validity check\n    const top = pegs[to][pegs[to].length - 1];\n    if (top != null && top < disk) {\n      hanoiMovesDiv.appendChild(el('div', { class: 'err' }, [el('span', { text: `Invalid move attempted: ${from} → ${to}` })]));\n      // revert\n      pegs[from].push(disk);\n      return false;\n    }\n    pegs[to].push(disk);\n    renderPegs();\n    return true;\n  }\n\n  document.getElementById('btnBuildHanoi').addEventListener('click', () => {\n    const n = parseInt(diskRange.value, 10);\n    stopHanoi();\n    buildInitial(n);\n  });\n\n  document.getElementById('btnSolveHanoi').addEventListener('click', () => {\n    stopHanoi();\n    const n = parseInt(diskRange.value, 10);\n    if (pegs.A.length !== n || pegs.B.length !== 0 || pegs.C.length !== 0) {\n      buildInitial(n);\n    }\n    const moves = hanoiMoves(n, 'A', 'B', 'C', []);\n    const total = moves.length;\n    hanoiMovesDiv.innerHTML = '';\n    hanoiMovesDiv.appendChild(el('div', { class: 'success' }, [el('span', { text: `Total moves: ${total} (2^${n} - 1)` })]));\n    moves.forEach((m, i) => {\n      hanoiMovesDiv.appendChild(el('div', {}, [el('span', { text: `${String(i + 1).padStart(3, ' ')}. ${m[0]} → ${m[1]}` })]));\n    });\n  });\n\n  function stopHanoi() {\n    if (hanoiAnim) {\n      clearInterval(hanoiAnim);\n      hanoiAnim = null;\n    }\n  }\n  document.getElementById('btnStopHanoi').addEventListener('click', stopHanoi);\n\n  document.getElementById('btnAnimateHanoi').addEventListener('click', () => {\n    stopHanoi();\n    const n = parseInt(diskRange.value, 10);\n    if (pegs.A.length !== n || pegs.B.length !== 0 || pegs.C.length !== 0) {\n      buildInitial(n);\n    }\n    const moves = hanoiMoves(n, 'A', 'B', 'C', []);\n    hanoiMovesDiv.innerHTML = '';\n    hanoiMovesDiv.appendChild(el('div', { class: 'success' }, [el('span', { text: `Animating ${moves.length} moves...` })]));\n    let i = 0;\n    hanoiAnim = setInterval(() => {\n      if (i >= moves.length) {\n        clearInterval(hanoiAnim);\n        hanoiAnim = null;\n        hanoiMovesDiv.appendChild(el('div', { class: 'success' }, [el('span', { text: `Done!` })]));\n        return;\n      }\n      const [from, to] = moves[i++];\n      performMove(from, to);\n      hanoiMovesDiv.appendChild(el('div', {}, [el('span', { text: `${String(i).padStart(3, ' ')}. ${from} → ${to}` })]));\n      hanoiMovesDiv.scrollTop = hanoiMovesDiv.scrollHeight;\n    }, Math.max(50, 600 - n * 60));\n  });\n\n  // Set up initial states\n  buildInitial(parseInt(diskRange.value, 10));\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Recursion"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "7279fd20-a36f-11f0-9fe0-ef2a550c087d",
    "timestamp": "2025-10-07T11:19:10.578Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Divide and Conquer",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Divide and Conquer Explorer</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f1420;\n      --panel: #141a29;\n      --accent: #4ea1ff;\n      --accent2: #f865b0;\n      --combine: #53d77a;\n      --warn: #ffb54e;\n      --text: #e8eefb;\n      --muted: #9fb0c8;\n      --bar: #2b3955;\n      --barBorder: #3a4a72;\n    }\n    * { box-sizing: border-box; }\n    body {\n      margin: 0;\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n      background: radial-gradient(1200px 600px at 15% 10%, #27324d 0%, var(--bg) 60%), var(--bg);\n      color: var(--text);\n      min-height: 100vh;\n      display: flex;\n      flex-direction: column;\n    }\n    header {\n      padding: 18px 24px;\n      border-bottom: 1px solid #1f2840;\n      background: linear-gradient(180deg, rgba(30,40,70,.6), rgba(20,26,41,.6));\n      backdrop-filter: blur(6px);\n      position: sticky; top: 0; z-index: 5;\n    }\n    header .title {\n      font-weight: 700; font-size: 20px; letter-spacing: .3px;\n    }\n    header .subtitle {\n      font-size: 13px; color: var(--muted);\n    }\n    .container {\n      padding: 16px;\n      display: grid;\n      grid-template-columns: 320px 1fr;\n      gap: 16px;\n    }\n    @media (max-width: 980px) {\n      .container { grid-template-columns: 1fr; }\n    }\n    .panel {\n      background: var(--panel);\n      border: 1px solid #223052;\n      border-radius: 12px;\n      padding: 12px;\n      box-shadow: 0 16px 40px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.04);\n    }\n    .panel h2 {\n      font-size: 14px; margin: 4px 0 8px; color: var(--muted); font-weight: 600; text-transform: uppercase; letter-spacing: .15em;\n    }\n    .controls .row {\n      display: grid;\n      grid-template-columns: 1fr 1fr;\n      gap: 8px;\n      margin-bottom: 8px;\n    }\n    .controls label {\n      font-size: 12px; color: var(--muted); margin-bottom: 4px; display: block;\n    }\n    select, input[type=\"number\"], input[type=\"text\"] {\n      width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid #2a3860;\n      background: #101628; color: var(--text);\n      outline: none;\n    }\n    .sliderWrap { display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: 8px; }\n    input[type=\"range\"] { width: 100%; }\n    .btnRow {\n      display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-top: 8px;\n    }\n    button {\n      border: 1px solid #2a3860;\n      background: #101628;\n      color: var(--text);\n      padding: 10px 12px;\n      border-radius: 10px;\n      cursor: pointer;\n      transition: transform .05s ease, background .2s ease, border-color .2s ease;\n      font-weight: 600; letter-spacing: .02em;\n    }\n    button:hover { background: #162038; border-color: #38508b; }\n    button:active { transform: translateY(1px); }\n    button.primary {\n      background: linear-gradient(180deg, #1a2746, #102037);\n      border-color: #416fb8;\n      box-shadow: inset 0 1px 0 rgba(255,255,255,.06), 0 8px 20px rgba(67,140,255,.15);\n    }\n    button.warn {\n      border-color: #7a5322; background: linear-gradient(180deg, #2b1f12, #1b140c);\n    }\n    .legend {\n      display: grid; gap: 6px; margin-top: 10px;\n      grid-template-columns: repeat(2, minmax(0, 1fr));\n      font-size: 12px;\n    }\n    .legend .item { display: flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 8px; border: 1px dashed #334466; background: #0d1426; }\n    .swatch { width: 16px; height: 16px; border-radius: 4px; border: 1px solid rgba(255,255,255,.15); }\n    .viz {\n      display: grid; grid-template-rows: auto 1fr auto; gap: 8px;\n    }\n    .barArea {\n      height: 340px;\n      border-radius: 12px;\n      border: 1px solid #223052;\n      background: linear-gradient(180deg, rgba(18,24,40,.9), rgba(16,22,38,.9));\n      padding: 12px;\n      overflow: hidden;\n      display: grid;\n      align-items: end;\n    }\n    .bars {\n      display: flex; align-items: end; gap: 6px; width: 100%; height: 100%;\n    }\n    .bar {\n      flex: 1;\n      background: var(--bar);\n      border: 1px solid var(--barBorder);\n      border-radius: 6px 6px 0 0;\n      position: relative;\n      transition: height .25s ease, background .25s ease, border-color .25s ease, transform .1s ease;\n      min-width: 8px;\n    }\n    .bar span {\n      position: absolute;\n      bottom: -22px;\n      left: 50%;\n      transform: translateX(-50%);\n      font-size: 11px;\n      color: var(--muted);\n      user-select: none;\n    }\n    .bar:hover { transform: translateY(-2px); }\n    .statusRow {\n      display: grid;\n      grid-template-columns: 1fr auto;\n      gap: 10px;\n      align-items: center;\n      margin-top: 6px;\n    }\n    .statusRow .text { font-size: 13px; color: var(--muted); }\n    .statusRow .clock { font-size: 12px; color: #8fb3ff; }\n    .msg {\n      font-size: 13px; padding: 8px 10px; border-radius: 8px; background: #11182b; border: 1px dashed #2a3e6e;\n    }\n    .footerNote { font-size: 12px; color: var(--muted); }\n    /* Highlights */\n    .hl-range { background: linear-gradient(180deg, #1f2e4e, #15223e); border-color: #4567a8; }\n    .hl-left { background: linear-gradient(180deg, rgba(78,161,255,.25), rgba(78,161,255,.1)); border-color: #4ea1ff; }\n    .hl-right { background: linear-gradient(180deg, rgba(248,101,176,.25), rgba(248,101,176,.1)); border-color: #f865b0; }\n    .hl-merge { background: linear-gradient(180deg, rgba(83,215,122,.25), rgba(83,215,122,.1)); border-color: #53d77a; }\n    .hl-mid { background: linear-gradient(180deg, rgba(255,181,78,.35), rgba(255,181,78,.15)); border-color: #ffb54e; }\n    .hl-target { outline: 2px solid #ffb54e; }\n    .hl-found { background: linear-gradient(180deg, rgba(83,215,122,.35), rgba(83,215,122,.15)); border-color: #53d77a; box-shadow: 0 0 0 2px rgba(83,215,122,.35); }\n    .small {\n      font-size: 12px; color: var(--muted);\n    }\n    .kbd {\n      border: 1px solid #2a3860; background: #0f1527; padding: 2px 6px; border-radius: 6px; font-size: 12px;\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <div class=\"title\">Divide and Conquer Explorer</div>\n    <div class=\"subtitle\">Interactively visualize how problems are split, solved, and combined.</div>\n  </header>\n\n  <div class=\"container\">\n    <!-- Controls -->\n    <div class=\"panel controls\">\n      <h2>Controls</h2>\n\n      <div class=\"row\">\n        <div>\n          <label for=\"algoSelect\">Algorithm</label>\n          <select id=\"algoSelect\">\n            <option value=\"merge\">Merge Sort (Sort by dividing)</option>\n            <option value=\"binary\">Binary Search (Search by dividing)</option>\n          </select>\n        </div>\n        <div>\n          <label for=\"sizeRange\">Array Size</label>\n          <div class=\"sliderWrap\">\n            <span class=\"small\">8</span>\n            <input type=\"range\" id=\"sizeRange\" min=\"8\" max=\"48\" step=\"2\" value=\"16\">\n            <span id=\"sizeVal\" class=\"small\">16</span>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"row\">\n        <div>\n          <label for=\"speedRange\">Speed</label>\n          <div class=\"sliderWrap\">\n            <span class=\"small\">Slow</span>\n            <input type=\"range\" id=\"speedRange\" min=\"1\" max=\"5\" step=\"1\" value=\"3\">\n            <span id=\"speedVal\" class=\"small\">3x</span>\n          </div>\n        </div>\n        <div id=\"targetWrap\" style=\"display:none;\">\n          <label for=\"targetInput\">Target (Binary Search)</label>\n          <input id=\"targetInput\" type=\"number\" min=\"0\" max=\"999\" placeholder=\"Click a bar or enter a value\">\n        </div>\n      </div>\n\n      <div class=\"btnRow\">\n        <button id=\"genBtn\">Generate Array</button>\n        <button id=\"runBtn\" class=\"primary\">Run</button>\n        <button id=\"stepBtn\">Step</button>\n        <button id=\"resetBtn\">Reset</button>\n      </div>\n\n      <div class=\"legend\">\n        <div class=\"item\"><div class=\"swatch\" style=\"background:#1f2e4e;border-color:#4567a8\"></div><div>Current range</div></div>\n        <div class=\"item\"><div class=\"swatch\" style=\"background:#4ea1ff\"></div><div>Left subproblem</div></div>\n        <div class=\"item\"><div class=\"swatch\" style=\"background:#f865b0\"></div><div>Right subproblem</div></div>\n        <div class=\"item\"><div class=\"swatch\" style=\"background:#53d77a\"></div><div>Combining</div></div>\n      </div>\n\n      <div class=\"msg\" id=\"explain\">\n        Divide and Conquer breaks a problem into smaller subproblems (divide), solves them (conquer), and combines the results (combine).\n        Try Merge Sort or Binary Search and step through each decision.\n      </div>\n    </div>\n\n    <!-- Visualization -->\n    <div class=\"panel viz\">\n      <h2>Visualization</h2>\n      <div class=\"barArea\">\n        <div id=\"bars\" class=\"bars\"></div>\n      </div>\n      <div class=\"statusRow\">\n        <div id=\"status\" class=\"text\">Ready.</div>\n        <div class=\"clock\"><span id=\"framePos\">0</span>/<span id=\"frameTotal\">0</span></div>\n      </div>\n      <div class=\"small\">Tip: In Binary Search, click a bar to set the target quickly.</div>\n      <div class=\"footerNote\" style=\"margin-top:8px;\">\n        Each frame highlights one step:\n        - Divide: split the problem (blue/pink ranges).\n        - Conquer: solve base cases.\n        - Combine: merge results (green).\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // State\n    const state = {\n      algorithm: 'merge',\n      size: 16,\n      speed: 3,\n      baseArray: [],\n      frames: [],\n      frameIndex: 0,\n      playing: false,\n      timer: null,\n      target: null,\n    };\n\n    // Elements\n    const algoSelect = document.getElementById('algoSelect');\n    const sizeRange = document.getElementById('sizeRange');\n    const sizeVal = document.getElementById('sizeVal');\n    const speedRange = document.getElementById('speedRange');\n    const speedVal = document.getElementById('speedVal');\n    const genBtn = document.getElementById('genBtn');\n    const runBtn = document.getElementById('runBtn');\n    const stepBtn = document.getElementById('stepBtn');\n    const resetBtn = document.getElementById('resetBtn');\n    const targetWrap = document.getElementById('targetWrap');\n    const targetInput = document.getElementById('targetInput');\n    const barsEl = document.getElementById('bars');\n    const statusEl = document.getElementById('status');\n    const framePosEl = document.getElementById('framePos');\n    const frameTotalEl = document.getElementById('frameTotal');\n    const explainEl = document.getElementById('explain');\n\n    // Utils\n    const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n    function generateArray(n) {\n      const arr = Array.from({ length: n }, () => randInt(5, 95));\n      return arr;\n    }\n    function msPerFrame(speed) {\n      // 1..5 -> 900..150 ms\n      return 1050 - speed * 180;\n    }\n    function clone(arr) {\n      return arr.slice();\n    }\n\n    // Rendering bars with highlights\n    function renderBars(values, highlight = {}) {\n      barsEl.innerHTML = '';\n      const maxVal = Math.max(...values, 100);\n      const n = values.length;\n      for (let i = 0; i < n; i++) {\n        const v = values[i];\n        const h = Math.max(12, Math.round((v / maxVal) * 300));\n        const bar = document.createElement('div');\n        bar.className = 'bar';\n        bar.style.height = h + 'px';\n\n        // Highlight logic\n        const { mode, operation } = highlight;\n        if (mode === 'merge') {\n          const { range, leftRange, rightRange, mergeRange, k, baseRange } = highlight;\n          if (range && i >= range[0] && i <= range[1]) bar.classList.add('hl-range');\n          if (leftRange && i >= leftRange[0] && i <= leftRange[1]) bar.classList.add('hl-left');\n          if (rightRange && i >= rightRange[0] && i <= rightRange[1]) bar.classList.add('hl-right');\n          if (mergeRange && i >= mergeRange[0] && i <= mergeRange[1]) bar.classList.add('hl-merge');\n          if (typeof k === 'number' && i === k) {\n            bar.style.outline = '2px solid #8bf5ac';\n          }\n          if (baseRange && i >= baseRange[0] && i <= baseRange[1]) bar.style.opacity = 0.9;\n        } else if (mode === 'binary') {\n          const { lo, hi, mid, targetIndex, foundIndex } = highlight;\n          if (typeof lo === 'number' && typeof hi === 'number' && i >= lo && i <= hi) bar.classList.add('hl-range');\n          if (typeof mid === 'number' && i === mid) bar.classList.add('hl-mid');\n          if (typeof targetIndex === 'number' && i === targetIndex) bar.classList.add('hl-target');\n          if (typeof foundIndex === 'number' && i === foundIndex) bar.classList.add('hl-found');\n        }\n\n        const label = document.createElement('span');\n        label.textContent = v;\n        bar.appendChild(label);\n\n        // Click to set target for binary search\n        bar.addEventListener('click', () => {\n          if (state.algorithm === 'binary') {\n            const sorted = clone(state.baseArray).sort((a,b) => a - b);\n            const val = v;\n            targetInput.value = val;\n            state.target = val;\n            // Precompute target index in sorted array for highlight convenience\n            const idx = sorted.indexOf(val);\n            renderBars(sorted, { mode: 'binary', lo: 0, hi: sorted.length - 1, mid: null, targetIndex: idx });\n            statusEl.textContent = 'Target set to ' + val + '. Click Run to search.';\n          }\n        });\n\n        barsEl.appendChild(bar);\n      }\n    }\n\n    function pushFrame(arr, highlight, message) {\n      state.frames.push({ arr: clone(arr), highlight: highlight ? { ...highlight } : null, message: message || '' });\n    }\n    function updateFrameInfo() {\n      framePosEl.textContent = Math.min(state.frameIndex, Math.max(0, state.frames.length));\n      frameTotalEl.textContent = state.frames.length;\n    }\n    function renderFrame() {\n      if (state.frames.length === 0) return;\n      const idx = Math.max(0, Math.min(state.frameIndex, state.frames.length - 1));\n      const frame = state.frames[idx];\n      renderBars(frame.arr, frame.highlight);\n      statusEl.textContent = frame.message || `Step ${idx + 1}/${state.frames.length}`;\n      updateFrameInfo();\n    }\n    function resetPlayback() {\n      clearInterval(state.timer);\n      state.playing = false;\n      runBtn.textContent = 'Run';\n    }\n    function play() {\n      if (state.frames.length === 0) return;\n      state.playing = true;\n      runBtn.textContent = 'Pause';\n      clearInterval(state.timer);\n      state.timer = setInterval(() => {\n        if (state.frameIndex >= state.frames.length - 1) {\n          resetPlayback();\n          return;\n        }\n        state.frameIndex++;\n        renderFrame();\n      }, msPerFrame(state.speed));\n    }\n    function pause() {\n      resetPlayback();\n    }\n    function step() {\n      if (state.frames.length === 0) return;\n      state.frameIndex = Math.min(state.frameIndex + 1, state.frames.length - 1);\n      renderFrame();\n    }\n\n    // Merge Sort frames\n    function buildMergeSortFrames() {\n      state.frames = [];\n      const arr = clone(state.baseArray);\n\n      function mergeSort(l, r) {\n        if (l >= r) {\n          pushFrame(arr, { mode: 'merge', baseRange: [l, r] }, `Conquer: base case at index ${l}`);\n          return;\n        }\n        const m = Math.floor((l + r) / 2);\n        pushFrame(arr, { mode: 'merge', range: [l, r], leftRange: [l, m], rightRange: [m+1, r] }, `Divide: split [${l}, ${r}] into [${l}, ${m}] and [${m+1}, ${r}]`);\n        mergeSort(l, m);\n        mergeSort(m + 1, r);\n        // Merge step\n        const left = arr.slice(l, m + 1);\n        const right = arr.slice(m + 1, r + 1);\n        let i = 0, j = 0, k = l;\n        while (i < left.length || j < right.length) {\n          const chooseLeft = j >= right.length || (i < left.length && left[i] <= right[j]);\n          arr[k] = chooseLeft ? left[i++] : right[j++];\n          pushFrame(arr, { mode: 'merge', mergeRange: [l, r], leftRange: [l, m], rightRange: [m+1, r], k },\n            `Combine: placing ${arr[k]} into position ${k}`);\n          k++;\n        }\n        pushFrame(arr, { mode: 'merge', mergeRange: [l, r] }, `Combined: merged sorted range [${l}, ${r}]`);\n      }\n\n      mergeSort(0, arr.length - 1);\n      state.frameIndex = 0;\n      explainEl.textContent = 'Merge Sort: Divide the array into halves, recursively sort each half, then combine by merging.';\n    }\n\n    // Binary Search frames\n    function buildBinarySearchFrames() {\n      state.frames = [];\n      const arr = clone(state.baseArray).sort((a, b) => a - b);\n\n      let lo = 0, hi = arr.length - 1;\n      let target = state.target;\n\n      // If no target set, pick a random existing value to ensure \"found\" possibility\n      if (target === null || target === undefined || target === '') {\n        target = arr[randInt(0, arr.length - 1)];\n        state.target = target;\n        targetInput.value = target;\n      }\n      const targetIndex = arr.indexOf(target);\n\n      pushFrame(arr, { mode: 'binary', lo, hi, mid: null, targetIndex }, `Start: search for ${target} in sorted array.`);\n\n      while (lo <= hi) {\n        const mid = Math.floor((lo + hi) / 2);\n        pushFrame(arr, { mode: 'binary', lo, hi, mid, targetIndex }, `Divide: check middle index ${mid} (value ${arr[mid]})`);\n        if (arr[mid] === target) {\n          pushFrame(arr, { mode: 'binary', lo, hi, mid, targetIndex, foundIndex: mid }, `Conquer: found ${target} at index ${mid}`);\n          break;\n        } else if (arr[mid] < target) {\n          lo = mid + 1;\n          pushFrame(arr, { mode: 'binary', lo, hi, targetIndex }, `Reduce: target greater than middle, search right half [${lo}, ${hi}]`);\n        } else {\n          hi = mid - 1;\n          pushFrame(arr, { mode: 'binary', lo, hi, targetIndex }, `Reduce: target less than middle, search left half [${lo}, ${hi}]`);\n        }\n      }\n      if (lo > hi) {\n        pushFrame(arr, { mode: 'binary', lo, hi, targetIndex }, `Conquer: ${target} not found (empty range).`);\n      }\n      state.frameIndex = 0;\n      explainEl.textContent = 'Binary Search: Divide the search space by checking the middle; narrow to the half that could contain the target.';\n    }\n\n    // Initialize\n    function refreshBaseArray() {\n      state.baseArray = generateArray(state.size);\n      if (state.algorithm === 'binary') {\n        const sorted = clone(state.baseArray).sort((a,b) => a - b);\n        renderBars(sorted, { mode: 'binary', lo: 0, hi: sorted.length - 1 });\n        statusEl.textContent = 'Generated new array (sorted for binary search). Choose a target or click a bar.';\n      } else {\n        renderBars(state.baseArray, { mode: 'merge' });\n        statusEl.textContent = 'Generated new array. Click Run to visualize Merge Sort.';\n      }\n      state.frames = [];\n      state.frameIndex = 0;\n      updateFrameInfo();\n    }\n\n    // Event handlers\n    algoSelect.addEventListener('change', () => {\n      state.algorithm = algoSelect.value;\n      targetWrap.style.display = state.algorithm === 'binary' ? '' : 'none';\n      resetPlayback();\n      refreshBaseArray();\n      explainEl.textContent = state.algorithm === 'merge'\n        ? 'Merge Sort: Divide the array into halves, recursively sort each half, then combine by merging.'\n        : 'Binary Search: Divide the search space by checking the middle; narrow to the half that could contain the target.';\n    });\n\n    sizeRange.addEventListener('input', () => {\n      state.size = parseInt(sizeRange.value, 10);\n      sizeVal.textContent = state.size;\n      resetPlayback();\n      refreshBaseArray();\n    });\n\n    speedRange.addEventListener('input', () => {\n      state.speed = parseInt(speedRange.value, 10);\n      speedVal.textContent = `${state.speed}x`;\n      if (state.playing) {\n        clearInterval(state.timer);\n        play();\n      }\n    });\n\n    genBtn.addEventListener('click', () => {\n      resetPlayback();\n      refreshBaseArray();\n    });\n\n    runBtn.addEventListener('click', () => {\n      if (state.playing) {\n        pause();\n        return;\n      }\n      if (state.frames.length === 0) {\n        if (state.algorithm === 'merge') buildMergeSortFrames();\n        else buildBinarySearchFrames();\n        updateFrameInfo();\n        renderFrame();\n      }\n      play();\n    });\n\n    stepBtn.addEventListener('click', () => {\n      if (state.frames.length === 0) {\n        if (state.algorithm === 'merge') buildMergeSortFrames();\n        else buildBinarySearchFrames();\n        updateFrameInfo();\n        renderFrame();\n        return;\n      }\n      pause();\n      step();\n    });\n\n    resetBtn.addEventListener('click', () => {\n      resetPlayback();\n      state.frameIndex = 0;\n      renderFrame();\n    });\n\n    targetInput.addEventListener('input', () => {\n      const val = targetInput.value.trim();\n      if (val === '') {\n        state.target = null;\n        statusEl.textContent = 'Target cleared. Click a bar or type a value.';\n        return;\n      }\n      state.target = parseInt(val, 10);\n      const sorted = clone(state.baseArray).sort((a,b) => a - b);\n      const idx = sorted.indexOf(state.target);\n      renderBars(sorted, { mode: 'binary', lo: 0, hi: sorted.length - 1, targetIndex: idx >= 0 ? idx : null });\n      statusEl.textContent = `Target set to ${state.target}.`;\n    });\n\n    // Keyboard shortcuts\n    document.addEventListener('keydown', (e) => {\n      if (e.key === ' ') {\n        e.preventDefault();\n        runBtn.click();\n      } else if (e.key.toLowerCase() === 'n' || e.key === 'ArrowRight') {\n        e.preventDefault();\n        stepBtn.click();\n      } else if (e.key.toLowerCase() === 'r') {\n        e.preventDefault();\n        genBtn.click();\n      }\n    });\n\n    // Boot\n    (function init() {\n      refreshBaseArray();\n      updateFrameInfo();\n      explainEl.textContent = 'Select an algorithm and click Run or Step to walk through Divide and Conquer in action.';\n    })();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Divide and Conquer"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "be8d6440-a36f-11f0-a0bf-038daf457c4c",
    "timestamp": "2025-10-07T11:21:18.212Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Sliding Window",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n<title>Sliding Window Visualizer</title>\n<style>\n  :root {\n    --bg: #0e1116;\n    --panel: #171b22;\n    --text: #e6e6e6;\n    --muted: #aeb4be;\n    --accent: #57a6ff;\n    --accent-2: #65d38b;\n    --accent-3: #ff7a7a;\n    --best: #ffd166;\n    --border: #2a313d;\n  }\n  * { box-sizing: border-box; }\n  body {\n    margin: 0;\n    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;\n    color: var(--text);\n    background: linear-gradient(180deg, #0d1218, #0b1015 120%);\n  }\n  header {\n    padding: 16px 24px;\n    border-bottom: 1px solid var(--border);\n    background: rgba(23,27,34,0.9);\n    position: sticky;\n    top: 0;\n    backdrop-filter: blur(8px);\n    z-index: 5;\n  }\n  header h1 {\n    margin: 0;\n    font-size: 20px;\n    letter-spacing: 0.2px;\n  }\n  header p {\n    margin: 6px 0 0 0;\n    color: var(--muted);\n    font-size: 13px;\n  }\n  .container {\n    display: grid;\n    grid-template-columns: 320px 1fr;\n    gap: 16px;\n    padding: 16px;\n    min-height: calc(100vh - 82px);\n  }\n  .sidebar, .main {\n    background: var(--panel);\n    border: 1px solid var(--border);\n    border-radius: 10px;\n    padding: 16px;\n  }\n  .sidebar h2, .main h2 { font-size: 16px; margin: 0 0 12px 0; }\n  .section {\n    border-top: 1px dashed var(--border);\n    margin-top: 12px;\n    padding-top: 12px;\n  }\n  .row { display: flex; align-items: center; gap: 8px; margin: 8px 0; }\n  label {\n    font-size: 13px;\n    color: var(--muted);\n    min-width: 90px;\n  }\n  input[type=\"text\"], input[type=\"number\"] {\n    flex: 1;\n    background: #0f1319;\n    border: 1px solid var(--border);\n    color: var(--text);\n    padding: 8px 10px;\n    border-radius: 8px;\n    outline: none;\n  }\n  input[type=\"number\"] { max-width: 120px; }\n  .btn {\n    background: #141a22;\n    border: 1px solid var(--border);\n    color: var(--text);\n    padding: 8px 12px;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 13px;\n    transition: all .15s ease;\n  }\n  .btn:hover { border-color: #39414e; transform: translateY(-1px); }\n  .btn.primary { background: linear-gradient(180deg, #2a6fff, #1b5deb); border-color: #2753ca; }\n  .btn.green { background: linear-gradient(180deg, #21b573, #149f62); border-color: #1d8a61; }\n  .btn.red { background: linear-gradient(180deg, #e05666, #c64555); border-color: #b13b4a; }\n  .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }\n  .tabs { display: flex; gap: 8px; margin-bottom: 8px; }\n  .tab {\n    padding: 8px 12px;\n    border: 1px solid var(--border);\n    border-radius: 999px;\n    cursor: pointer;\n    font-size: 13px;\n    color: var(--muted);\n    background: #12161d;\n  }\n  .tab.active {\n    color: var(--text);\n    background: #182231;\n    border-color: #3a4a63;\n  }\n  .hint { color: var(--muted); font-size: 12px; margin-top: 6px; }\n\n  .array-wrap {\n    overflow-x: auto;\n    border: 1px solid var(--border);\n    border-radius: 10px;\n    padding: 12px;\n    background: #0d1218;\n    position: relative;\n  }\n  .array {\n    display: flex;\n    gap: 8px;\n    min-height: 88px;\n    align-items: center;\n    position: relative;\n  }\n  .box {\n    position: relative;\n    width: 52px;\n    height: 52px;\n    border: 1px solid #2a313d;\n    border-radius: 10px;\n    background: linear-gradient(180deg,#17202c,#121923);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: #e9eef5;\n    font-weight: 600;\n    font-variant-numeric: tabular-nums;\n    user-select: none;\n  }\n  .box.in-window {\n    background: linear-gradient(180deg,#1b2a3d,#152230);\n    border-color: #3d5473;\n    box-shadow: 0 0 0 2px rgba(87,166,255,0.12) inset;\n  }\n  .box.window-left { border-left-width: 3px; border-left-color: var(--accent); }\n  .box.window-right { border-right-width: 3px; border-right-color: var(--accent); }\n  .box.best {\n    background: linear-gradient(180deg,#2a2d16,#23250f);\n    border-color: #b59a33;\n    box-shadow: 0 0 0 2px rgba(255,209,102,0.18) inset;\n  }\n  .tag {\n    position: absolute;\n    top: -18px;\n    font-size: 11px;\n    background: #243041;\n    color: #a8c8ff;\n    border: 1px solid #34445c;\n    padding: 2px 5px;\n    border-radius: 5px;\n  }\n  .tag.L { left: 4px; }\n  .tag.R { right: 4px; }\n  .tag.LR { left: 4px; right: 4px; text-align: center; }\n\n  @keyframes pulseGreen {\n    0% { box-shadow: 0 0 0 0 rgba(101,211,139,0.0); transform: scale(1); }\n    35% { box-shadow: 0 0 0 8px rgba(101,211,139,0.15); transform: scale(1.06); }\n    100% { box-shadow: 0 0 0 0 rgba(101,211,139,0.0); transform: scale(1); }\n  }\n  @keyframes pulseRed {\n    0% { box-shadow: 0 0 0 0 rgba(255,122,122,0.0); transform: scale(1); }\n    35% { box-shadow: 0 0 0 8px rgba(255,122,122,0.15); transform: scale(1.06); }\n    100% { box-shadow: 0 0 0 0 rgba(255,122,122,0.0); transform: scale(1); }\n  }\n  .entering { animation: pulseGreen 600ms ease-out; outline: 2px solid rgba(101,211,139,0.35); }\n  .leaving { animation: pulseRed 600ms ease-out; outline: 2px solid rgba(255,122,122,0.35); }\n\n  .controls { display: flex; flex-wrap: wrap; gap: 8px; }\n  .spacer { flex: 1 1 auto; }\n  .speed {\n    display: flex; align-items: center; gap: 8px;\n    padding: 8px; background: #0f1319; border: 1px solid var(--border); border-radius: 8px;\n  }\n  .speed input[type=\"range\"] { width: 140px; }\n  .statbar {\n    margin-top: 12px;\n    display: grid;\n    grid-template-columns: repeat(4, minmax(120px,1fr));\n    gap: 8px;\n  }\n  .stat {\n    background: #0f1319;\n    border: 1px solid var(--border);\n    border-radius: 10px;\n    padding: 10px;\n    min-height: 56px;\n  }\n  .stat .k { font-size: 12px; color: var(--muted); }\n  .stat .v { font-size: 18px; margin-top: 4px; font-weight: 700; }\n  .log {\n    margin-top: 12px;\n    height: 160px;\n    overflow: auto;\n    background: #0d1218;\n    border: 1px solid var(--border);\n    border-radius: 10px;\n    padding: 8px;\n    font-size: 12px;\n  }\n  .log .item { color: #cfd6e0; margin: 4px 0; }\n  .code {\n    background: #0d1218;\n    border: 1px dashed var(--border);\n    border-radius: 10px;\n    padding: 10px;\n    margin-top: 12px;\n    overflow: auto;\n  }\n  pre { margin: 0; font-size: 12px; color: #dbe3ee; }\n  .error { color: #ff8b8b; font-size: 12px; }\n</style>\n</head>\n<body>\n<header>\n  <h1>Sliding Window Visualizer</h1>\n  <p>Step through the sliding window technique on arrays: fixed-size windows and variable-size two-pointer windows.</p>\n</header>\n\n<div class=\"container\">\n  <div class=\"sidebar\">\n    <div class=\"tabs\">\n      <button class=\"tab active\" data-tab=\"fixed\">Fixed-size Window</button>\n      <button class=\"tab\" data-tab=\"variable\">Variable-size Window</button>\n    </div>\n\n    <div id=\"fixed-panel\">\n      <h2>Inputs</h2>\n      <div class=\"row\">\n        <label for=\"arr-fixed\">Array</label>\n        <input id=\"arr-fixed\" type=\"text\" value=\"2,1,5,1,3,2\" />\n      </div>\n      <div class=\"row\">\n        <label for=\"k\">Window size (k)</label>\n        <input id=\"k\" type=\"number\" min=\"1\" value=\"3\" />\n      </div>\n      <div class=\"row\">\n        <button id=\"rand-fixed\" class=\"btn\">Randomize</button>\n        <span class=\"spacer\"></span>\n        <span class=\"error\" id=\"err-fixed\"></span>\n      </div>\n      <div class=\"section\">\n        <div class=\"controls\">\n          <button id=\"start-fixed\" class=\"btn primary\">Start</button>\n          <button id=\"step-fixed\" class=\"btn\">Step</button>\n          <button id=\"play-fixed\" class=\"btn green\">Play</button>\n          <button id=\"pause-fixed\" class=\"btn\">Pause</button>\n          <button id=\"reset-fixed\" class=\"btn red\">Reset</button>\n          <span class=\"spacer\"></span>\n          <div class=\"speed\">\n            <span>Speed</span>\n            <input id=\"speed-fixed\" type=\"range\" min=\"0.25\" max=\"3\" step=\"0.25\" value=\"1\" />\n            <span id=\"speed-label-fixed\">1x</span>\n          </div>\n        </div>\n        <div class=\"hint\">Task: compute the maximum sum of any subarray of size k using a sliding window.</div>\n      </div>\n      <div class=\"section\">\n        <h2>Pseudocode</h2>\n        <div class=\"code\">\n          <pre>\n// max sum of any subarray of size k\nsum = sum(arr[0..k-1])\nbest = sum\nfor i from k to n-1:\n  sum += arr[i]        // enter new\n  sum -= arr[i-k]      // leave old\n  best = max(best, sum)\n          </pre>\n        </div>\n      </div>\n    </div>\n\n    <div id=\"variable-panel\" style=\"display:none\">\n      <h2>Inputs</h2>\n      <div class=\"row\">\n        <label for=\"arr-var\">Array</label>\n        <input id=\"arr-var\" type=\"text\" value=\"2,1,5,2,3,2\" />\n      </div>\n      <div class=\"row\">\n        <label for=\"target\">Target sum (≥)</label>\n        <input id=\"target\" type=\"number\" min=\"1\" value=\"7\" />\n      </div>\n      <div class=\"row\">\n        <button id=\"rand-var\" class=\"btn\">Randomize</button>\n        <span class=\"spacer\"></span>\n        <span class=\"error\" id=\"err-var\"></span>\n      </div>\n      <div class=\"section\">\n        <div class=\"controls\">\n          <button id=\"start-var\" class=\"btn primary\">Start</button>\n          <button id=\"step-var\" class=\"btn\">Step</button>\n          <button id=\"play-var\" class=\"btn green\">Play</button>\n          <button id=\"pause-var\" class=\"btn\">Pause</button>\n          <button id=\"reset-var\" class=\"btn red\">Reset</button>\n          <span class=\"spacer\"></span>\n          <div class=\"speed\">\n            <span>Speed</span>\n            <input id=\"speed-var\" type=\"range\" min=\"0.25\" max=\"3\" step=\"0.25\" value=\"1\" />\n            <span id=\"speed-label-var\">1x</span>\n          </div>\n        </div>\n        <div class=\"hint\">Task: find the shortest subarray with sum ≥ target using an expanding/contracting window.</div>\n      </div>\n      <div class=\"section\">\n        <h2>Pseudocode</h2>\n        <div class=\"code\">\n          <pre>\n// min length subarray with sum ≥ target\nleft = 0, sum = 0, bestLen = ∞\nfor right from 0 to n-1:\n  sum += arr[right]\n  while sum ≥ target:\n    bestLen = min(bestLen, right-left+1)\n    sum -= arr[left]\n    left += 1\n          </pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"main\">\n    <h2>Visualization</h2>\n    <div class=\"array-wrap\">\n      <div id=\"array\" class=\"array\"></div>\n    </div>\n\n    <div class=\"statbar\" id=\"stats\">\n      <div class=\"stat\">\n        <div class=\"k\">Current window</div>\n        <div class=\"v\" id=\"stat-window\">[ - , - ]</div>\n      </div>\n      <div class=\"stat\">\n        <div class=\"k\">Current sum</div>\n        <div class=\"v\" id=\"stat-sum\">0</div>\n      </div>\n      <div class=\"stat\">\n        <div class=\"k\">Best found</div>\n        <div class=\"v\" id=\"stat-best\">—</div>\n      </div>\n      <div class=\"stat\">\n        <div class=\"k\">Ops (add/sub)</div>\n        <div class=\"v\" id=\"stat-ops\">0 / 0</div>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <h2>Step log</h2>\n      <div id=\"log\" class=\"log\"></div>\n    </div>\n  </div>\n</div>\n\n<script>\n  // Utility: parse comma-separated numbers\n  function parseArray(str) {\n    if (!str.trim()) return [];\n    const parts = str.split(/[,\\s]+/).map(s => s.trim()).filter(Boolean);\n    const nums = parts.map(Number);\n    if (nums.some(n => Number.isNaN(n))) return null;\n    return nums;\n  }\n\n  // Visual array manager\n  class VisualArray {\n    constructor(container) {\n      this.container = container;\n      this.boxes = [];\n      this.values = [];\n    }\n    render(values) {\n      this.values = values.slice();\n      this.container.innerHTML = '';\n      this.boxes = values.map((v, i) => {\n        const d = document.createElement('div');\n        d.className = 'box';\n        d.dataset.index = i;\n        d.textContent = v;\n        this.container.appendChild(d);\n        return d;\n      });\n    }\n    clearClasses() {\n      this.boxes.forEach(b => {\n        b.classList.remove('in-window','window-left','window-right','best','entering','leaving');\n      });\n      this.boxes.forEach(b => {\n        const tags = b.querySelectorAll('.tag');\n        tags.forEach(t => t.remove());\n      });\n    }\n    setWindow(l, r) {\n      this.boxes.forEach((b, i) => {\n        b.classList.toggle('in-window', i >= l && i <= r);\n        b.classList.toggle('window-left', i === l && l <= r);\n        b.classList.toggle('window-right', i === r && l <= r);\n      });\n    }\n    setPointers(l, r) {\n      // remove previous tags\n      this.boxes.forEach(b => {\n        const tags = b.querySelectorAll('.tag');\n        tags.forEach(t => t.remove());\n      });\n      if (l >= 0 && l < this.boxes.length) {\n        const tl = document.createElement('div');\n        tl.className = 'tag L';\n        tl.textContent = 'L';\n        this.boxes[l].appendChild(tl);\n      }\n      if (r >= 0 && r < this.boxes.length) {\n        if (r === l && r >= 0) {\n          const t = this.boxes[r].querySelector('.tag.L');\n          if (t) { t.className = 'tag LR'; t.textContent = 'L,R'; }\n          else {\n            const both = document.createElement('div');\n            both.className = 'tag LR';\n            both.textContent = 'L,R';\n            this.boxes[r].appendChild(both);\n          }\n        } else {\n          const tr = document.createElement('div');\n          tr.className = 'tag R';\n          tr.textContent = 'R';\n          this.boxes[r].appendChild(tr);\n        }\n      }\n    }\n    flashEnter(i) {\n      if (i >= 0 && i < this.boxes.length) {\n        this.boxes[i].classList.add('entering');\n        setTimeout(() => this.boxes[i].classList.remove('entering'), 650);\n      }\n    }\n    flashLeave(i) {\n      if (i >= 0 && i < this.boxes.length) {\n        this.boxes[i].classList.add('leaving');\n        setTimeout(() => this.boxes[i].classList.remove('leaving'), 650);\n      }\n    }\n    setBestRange(l, r) {\n      this.boxes.forEach((b, i) => {\n        b.classList.toggle('best', i >= l && i <= r && l <= r);\n      });\n    }\n  }\n\n  // Logger\n  class Logger {\n    constructor(el) { this.el = el; this.step = 0; }\n    reset() { this.el.innerHTML = ''; this.step = 0; }\n    log(msg) {\n      this.step++;\n      const item = document.createElement('div');\n      item.className = 'item';\n      item.textContent = `#${this.step} — ${msg}`;\n      this.el.appendChild(item);\n      this.el.scrollTop = this.el.scrollHeight;\n    }\n  }\n\n  // Stats manager\n  class Stats {\n    constructor() {\n      this.elWindow = document.getElementById('stat-window');\n      this.elSum = document.getElementById('stat-sum');\n      this.elBest = document.getElementById('stat-best');\n      this.elOps = document.getElementById('stat-ops');\n    }\n    setWindow(l, r) { this.elWindow.textContent = `[ ${l} , ${r} ]`; }\n    setSum(v) { this.elSum.textContent = `${v}`; }\n    setBest(v) { this.elBest.textContent = `${v}`; }\n    setBestText(t) { this.elBest.textContent = t; }\n    setOps(add, sub) { this.elOps.textContent = `${add} / ${sub}`; }\n    reset() {\n      this.setWindow('-', '-');\n      this.setSum(0);\n      this.setBestText('—');\n      this.setOps(0, 0);\n    }\n  }\n\n  // Fixed-size window simulator: max sum of size k\n  class FixedWindowSimulator {\n    constructor(visual, logger, stats) {\n      this.v = visual; this.log = logger; this.stats = stats;\n      this.timer = null; this.interval = 600;\n      this.reset();\n    }\n    reset() {\n      this.arr = []; this.k = 0; this.n = 0;\n      this.left = 0; this.right = -1; this.sum = 0;\n      this.bestSum = -Infinity; this.bestL = -1; this.bestR = -1;\n      this.started = false; this.done = false;\n      this.opsAdd = 0; this.opsSub = 0;\n      if (this.timer) { clearInterval(this.timer); this.timer = null; }\n      this.v.clearClasses();\n      this.stats.reset();\n      this.log.reset();\n    }\n    init(arr, k) {\n      this.reset();\n      this.arr = arr.slice(); this.n = arr.length; this.k = k|0;\n      this.v.render(this.arr);\n      this.v.setPointers(-1, -1);\n      this.stats.setWindow('-', '-');\n      this.stats.setBestText('—');\n      this.log.log(`Loaded array of length ${this.n}, window size k = ${this.k}`);\n    }\n    setSpeed(mult) {\n      this.interval = Math.round(600 / Math.max(0.1, mult));\n      if (this.timer) {\n        clearInterval(this.timer);\n        this.timer = setInterval(() => this.step(), this.interval);\n      }\n    }\n    start() {\n      if (this.started || this.n === 0 || this.k < 1 || this.k > this.n) return;\n      this.step(); // compute initial sum\n    }\n    step() {\n      if (this.done) return;\n      // Initial setup: compute first window sum\n      if (!this.started) {\n        this.left = 0; this.right = this.k - 1; this.sum = 0;\n        for (let i = 0; i < this.k; i++) {\n          this.sum += this.arr[i]; this.opsAdd++;\n          this.v.flashEnter(i);\n        }\n        this.v.setWindow(this.left, this.right);\n        this.v.setPointers(this.left, this.right);\n        this.bestSum = this.sum; this.bestL = this.left; this.bestR = this.right;\n        this.v.setBestRange(this.bestL, this.bestR);\n        this.stats.setWindow(this.left, this.right);\n        this.stats.setSum(this.sum);\n        this.stats.setBest(this.bestSum);\n        this.stats.setOps(this.opsAdd, this.opsSub);\n        this.log.log(`Init: sum of arr[0..${this.right}] = ${this.sum}`);\n        this.started = true;\n        if (this.k === this.n) {\n          this.done = true;\n          this.log.log(`Done: only one window. Best sum = ${this.bestSum} at [${this.bestL}, ${this.bestR}]`);\n        }\n        return;\n      }\n      // Move window by one to the right\n      if (this.right < this.n - 1) {\n        const leaveIdx = this.left;\n        const enterIdx = this.right + 1;\n        this.v.flashLeave(leaveIdx);\n        this.v.flashEnter(enterIdx);\n        const leaving = this.arr[leaveIdx];\n        const entering = this.arr[enterIdx];\n        this.sum += entering; this.opsAdd++;\n        this.sum -= leaving; this.opsSub++;\n        this.left++; this.right++;\n        this.v.setWindow(this.left, this.right);\n        this.v.setPointers(this.left, this.right);\n        this.stats.setWindow(this.left, this.right);\n        this.stats.setSum(this.sum);\n        this.stats.setOps(this.opsAdd, this.opsSub);\n        this.log.log(`Slide: +${entering} (idx ${enterIdx}), -${leaving} (idx ${leaveIdx}) → sum = ${this.sum}`);\n        if (this.sum > this.bestSum) {\n          this.bestSum = this.sum; this.bestL = this.left; this.bestR = this.right;\n          this.v.setBestRange(this.bestL, this.bestR);\n          this.stats.setBest(this.bestSum);\n          this.log.log(`New best: sum = ${this.bestSum} at [${this.bestL}, ${this.bestR}]`);\n        }\n        if (this.right === this.n - 1) {\n          this.done = true;\n          this.log.log(`Done: best sum = ${this.bestSum} at [${this.bestL}, ${this.bestR}]`);\n        }\n      }\n    }\n    play() {\n      if (this.done) return;\n      if (!this.started) this.start();\n      if (!this.timer) {\n        this.timer = setInterval(() => this.step(), this.interval);\n      }\n    }\n    pause() {\n      if (this.timer) { clearInterval(this.timer); this.timer = null; }\n    }\n  }\n\n  // Variable-size window: min len subarray with sum >= target\n  class VariableWindowSimulator {\n    constructor(visual, logger, stats) {\n      this.v = visual; this.log = logger; this.stats = stats;\n      this.timer = null; this.interval = 600;\n      this.reset();\n    }\n    reset() {\n      this.arr = []; this.n = 0; this.target = 0;\n      this.left = 0; this.right = -1; this.sum = 0;\n      this.bestLen = Infinity; this.bestL = -1; this.bestR = -1;\n      this.done = false; this.started = false;\n      this.wantShrink = false;\n      this.opsAdd = 0; this.opsSub = 0;\n      if (this.timer) { clearInterval(this.timer); this.timer = null; }\n      this.v.clearClasses();\n      this.stats.reset();\n      this.log.reset();\n    }\n    init(arr, target) {\n      this.reset();\n      this.arr = arr.slice(); this.n = arr.length; this.target = target|0;\n      this.v.render(this.arr);\n      this.v.setPointers(0, -1);\n      this.v.setWindow(0, -1); // empty\n      this.stats.setWindow('-', '-');\n      this.stats.setBestText('—');\n      this.log.log(`Loaded array of length ${this.n}, target = ${this.target}`);\n    }\n    setSpeed(mult) {\n      this.interval = Math.round(600 / Math.max(0.1, mult));\n      if (this.timer) {\n        clearInterval(this.timer);\n        this.timer = setInterval(() => this.step(), this.interval);\n      }\n    }\n    start() {\n      if (this.started || this.n === 0) return;\n      this.started = true;\n      this.log.log(`Init: empty window at [0, -1], sum = 0`);\n      this.stats.setWindow(0, -1);\n      this.stats.setSum(0);\n      this.stats.setOps(0, 0);\n    }\n    step() {\n      if (!this.started) this.start();\n      if (this.done) return;\n\n      // If we need to shrink and condition holds, shrink from left\n      if (this.wantShrink && this.sum >= this.target) {\n        const len = this.right - this.left + 1;\n        if (len < this.bestLen) {\n          this.bestLen = len; this.bestL = this.left; this.bestR = this.right;\n          this.v.setBestRange(this.bestL, this.bestR);\n          this.stats.setBest(`${this.bestLen} [${this.bestL}, ${this.bestR}]`);\n          this.log.log(`New best: length = ${this.bestLen} at [${this.bestL}, ${this.bestR}]`);\n        }\n        // shrink\n        const leaveIdx = this.left;\n        const leaving = this.arr[leaveIdx];\n        this.v.flashLeave(leaveIdx);\n        this.sum -= leaving; this.opsSub++;\n        this.left++;\n        this.v.setWindow(this.left, this.right);\n        this.v.setPointers(this.left, this.right);\n        this.stats.setWindow(this.left, this.right);\n        this.stats.setSum(this.sum);\n        this.stats.setOps(this.opsAdd, this.opsSub);\n        this.log.log(`Shrink: -${leaving} (idx ${leaveIdx}) → sum = ${this.sum}`);\n        // continue shrinking next step if still >= target\n        if (this.sum < this.target) this.wantShrink = false;\n        // Not done yet; next step will decide to shrink again or advance R\n        return;\n      }\n\n      // Otherwise, advance right if possible\n      if (this.right < this.n - 1) {\n        this.right++;\n        const enterIdx = this.right;\n        const entering = this.arr[enterIdx];\n        this.v.flashEnter(enterIdx);\n        this.sum += entering; this.opsAdd++;\n        if (this.left > this.right) this.left = this.right; // sanity\n        this.v.setWindow(this.left, this.right);\n        this.v.setPointers(this.left, this.right);\n        this.stats.setWindow(this.left, this.right);\n        this.stats.setSum(this.sum);\n        this.stats.setOps(this.opsAdd, this.opsSub);\n        this.log.log(`Expand: +${entering} (idx ${enterIdx}) → sum = ${this.sum}`);\n        // Decide whether to start shrinking on next steps\n        if (this.sum >= this.target) this.wantShrink = true;\n        // If reached end and can't shrink, we might finish soon\n        if (this.right === this.n - 1 && this.sum < this.target) {\n          // No further shrink possible; continue until done when we can't expand more and sum < target\n          // The done condition handled below after a shrink or if cannot shrink further\n        }\n        return;\n      }\n\n      // No more expansion possible; if cannot shrink, we are done\n      if (this.right === this.n - 1 && !(this.wantShrink && this.sum >= this.target)) {\n        this.done = true;\n        if (this.bestLen === Infinity) {\n          this.stats.setBestText('No subarray meets target');\n          this.log.log(`Done: no subarray with sum ≥ ${this.target}`);\n        } else {\n          this.stats.setBest(`${this.bestLen} [${this.bestL}, ${this.bestR}]`);\n          this.log.log(`Done: best length = ${this.bestLen} at [${this.bestL}, ${this.bestR}]`);\n        }\n      }\n    }\n    play() {\n      if (this.done) return;\n      if (!this.started) this.start();\n      if (!this.timer) {\n        this.timer = setInterval(() => this.step(), this.interval);\n      }\n    }\n    pause() {\n      if (this.timer) { clearInterval(this.timer); this.timer = null; }\n    }\n  }\n\n  // Hook up UI\n  const elArray = document.getElementById('array');\n  const visual = new VisualArray(elArray);\n  const logger = new Logger(document.getElementById('log'));\n  const stats = new Stats();\n\n  // Tabs\n  const tabs = document.querySelectorAll('.tab');\n  const fixedPanel = document.getElementById('fixed-panel');\n  const varPanel = document.getElementById('variable-panel');\n  let mode = 'fixed';\n\n  tabs.forEach(t => t.addEventListener('click', () => {\n    tabs.forEach(x => x.classList.remove('active'));\n    t.classList.add('active');\n    mode = t.dataset.tab;\n    if (mode === 'fixed') { fixedPanel.style.display = ''; varPanel.style.display = 'none'; initFixedFromUI(); }\n    else { fixedPanel.style.display = 'none'; varPanel.style.display = ''; initVarFromUI(); }\n  }));\n\n  // Fixed UI\n  const inArrFixed = document.getElementById('arr-fixed');\n  const inK = document.getElementById('k');\n  const btnRandFixed = document.getElementById('rand-fixed');\n  const btnStartFixed = document.getElementById('start-fixed');\n  const btnStepFixed = document.getElementById('step-fixed');\n  const btnPlayFixed = document.getElementById('play-fixed');\n  const btnPauseFixed = document.getElementById('pause-fixed');\n  const btnResetFixed = document.getElementById('reset-fixed');\n  const errFixed = document.getElementById('err-fixed');\n  const speedFixed = document.getElementById('speed-fixed');\n  const speedLabelFixed = document.getElementById('speed-label-fixed');\n\n  const fixedSim = new FixedWindowSimulator(visual, logger, stats);\n\n  function randomArray(len=10, min=0, max=9) {\n    return Array.from({length: len}, () => Math.floor(Math.random()*(max-min+1))+min);\n  }\n  function initFixedFromUI() {\n    const arr = parseArray(inArrFixed.value);\n    const k = Number(inK.value);\n    if (!arr) { errFixed.textContent = 'Invalid array'; return; }\n    if (k < 1 || k > arr.length) {\n      errFixed.textContent = 'k must be between 1 and array length';\n    } else {\n      errFixed.textContent = '';\n    }\n    fixedSim.init(arr, k);\n  }\n\n  btnRandFixed.addEventListener('click', () => {\n    const arr = randomArray(10, -5, 9);\n    inArrFixed.value = arr.join(',');\n    inK.value = Math.max(1, Math.min(5, Math.floor(arr.length/2)));\n    initFixedFromUI();\n  });\n  btnStartFixed.addEventListener('click', () => {\n    const arr = parseArray(inArrFixed.value);\n    const k = Number(inK.value);\n    if (!arr) { errFixed.textContent = 'Invalid array'; return; }\n    if (k < 1 || k > arr.length) { errFixed.textContent = 'k must be between 1 and array length'; return; }\n    errFixed.textContent = '';\n    fixedSim.init(arr, k);\n    fixedSim.start();\n  });\n  btnStepFixed.addEventListener('click', () => fixedSim.step());\n  btnPlayFixed.addEventListener('click', () => fixedSim.play());\n  btnPauseFixed.addEventListener('click', () => fixedSim.pause());\n  btnResetFixed.addEventListener('click', () => initFixedFromUI());\n  speedFixed.addEventListener('input', () => {\n    const m = Number(speedFixed.value);\n    speedLabelFixed.textContent = `${m}x`;\n    fixedSim.setSpeed(m);\n  });\n\n  // Variable UI\n  const inArrVar = document.getElementById('arr-var');\n  const inTarget = document.getElementById('target');\n  const btnRandVar = document.getElementById('rand-var');\n  const btnStartVar = document.getElementById('start-var');\n  const btnStepVar = document.getElementById('step-var');\n  const btnPlayVar = document.getElementById('play-var');\n  const btnPauseVar = document.getElementById('pause-var');\n  const btnResetVar = document.getElementById('reset-var');\n  const errVar = document.getElementById('err-var');\n  const speedVar = document.getElementById('speed-var');\n  const speedLabelVar = document.getElementById('speed-label-var');\n\n  const varSim = new VariableWindowSimulator(visual, logger, stats);\n\n  function initVarFromUI() {\n    const arr = parseArray(inArrVar.value);\n    const target = Number(inTarget.value);\n    if (!arr) { errVar.textContent = 'Invalid array'; return; }\n    if (!Number.isFinite(target)) { errVar.textContent = 'Invalid target'; return; }\n    errVar.textContent = '';\n    varSim.init(arr, target);\n  }\n\n  btnRandVar.addEventListener('click', () => {\n    const len = Math.floor(Math.random()*8)+6; // 6..13\n    const arr = randomArray(len, 1, 9);\n    inArrVar.value = arr.join(',');\n    const sum = arr.reduce((a,b)=>a+b,0);\n    inTarget.value = Math.max(5, Math.min(sum, Math.floor(sum*0.6)));\n    initVarFromUI();\n  });\n  btnStartVar.addEventListener('click', () => {\n    const arr = parseArray(inArrVar.value);\n    const target = Number(inTarget.value);\n    if (!arr) { errVar.textContent = 'Invalid array'; return; }\n    if (!Number.isFinite(target)) { errVar.textContent = 'Invalid target'; return; }\n    errVar.textContent = '';\n    varSim.init(arr, target);\n    varSim.start();\n  });\n  btnStepVar.addEventListener('click', () => varSim.step());\n  btnPlayVar.addEventListener('click', () => varSim.play());\n  btnPauseVar.addEventListener('click', () => varSim.pause());\n  btnResetVar.addEventListener('click', () => initVarFromUI());\n  speedVar.addEventListener('input', () => {\n    const m = Number(speedVar.value);\n    speedLabelVar.textContent = `${m}x`;\n    varSim.setSpeed(m);\n  });\n\n  // Initial boot\n  initFixedFromUI();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Sliding Window"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "b0548880-a370-11f0-9793-7747c3107ce0",
    "timestamp": "2025-10-07T11:28:03.848Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Two Pointers",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>Two Pointers Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1320;\n      --panel:#171b2b;\n      --accent:#6bc1ff;\n      --accent2:#ffc36b;\n      --green:#6bff88;\n      --red:#ff6b6b;\n      --yellow:#ffd86b;\n      --text:#e8ebf2;\n      --muted:#a9b1c7;\n      --border:#2a3048;\n      --purple:#b28aff;\n      --pink:#ff9ad1;\n      --cyan:#8cf0ff;\n    }\n\n    *{ box-sizing: border-box; }\n    body{\n      margin:0;\n      background: radial-gradient(1200px 600px at 10% 0%, #151b30 0%, #0f1320 60%, #0b0f1a 100%);\n      color: var(--text);\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n      line-height: 1.4;\n    }\n\n    header{\n      padding: 20px;\n      border-bottom: 1px solid var(--border);\n      background: linear-gradient(0deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      position: sticky;\n      top:0;\n      z-index: 5;\n    }\n\n    h1{\n      margin:0 0 6px 0;\n      font-size: 22px;\n      letter-spacing: 0.2px;\n    }\n    .subtitle{\n      font-size: 13px;\n      color: var(--muted);\n    }\n\n    .container{\n      padding: 16px 20px 26px;\n    }\n\n    .controls{\n      background: var(--panel);\n      border: 1px solid var(--border);\n      border-radius: 12px;\n      padding: 12px;\n      display: grid;\n      grid-template-columns: 1fr;\n      gap: 10px;\n    }\n    @media (min-width: 900px){\n      .controls{\n        grid-template-columns: 1.2fr 1fr 1fr;\n      }\n    }\n\n    .control-block{\n      border: 1px solid var(--border);\n      border-radius: 10px;\n      padding: 10px;\n      background: rgba(255,255,255,0.02);\n    }\n    .control-block h3{\n      margin: 0 0 8px 0;\n      font-size: 14px;\n      color: var(--muted);\n      font-weight: 600;\n      letter-spacing: 0.3px;\n    }\n\n    .row{ display:flex; gap:8px; flex-wrap: wrap; align-items: center; }\n    label{ font-size: 12px; color: var(--muted); }\n    input[type=\"text\"], input[type=\"number\"], select{\n      width: 100%;\n      padding: 8px 10px;\n      background: #0f1426;\n      border: 1px solid var(--border);\n      color: var(--text);\n      border-radius: 8px;\n      outline: none;\n    }\n    input[type=\"checkbox\"]{ transform: translateY(2px); }\n    .small{ font-size: 12px; color: var(--muted); }\n    .btn{\n      padding: 8px 12px;\n      border-radius: 8px;\n      background: #122040;\n      border: 1px solid #1e2a4d;\n      color: var(--text);\n      cursor: pointer;\n      font-size: 13px;\n    }\n    .btn:hover{ filter: brightness(1.1); }\n    .btn.primary{ background: #17305c; border-color: #274b84; }\n    .btn.danger{ background:#32101a; border-color:#601a2b; }\n    .btn:disabled{ opacity:0.5; cursor:not-allowed; }\n\n    .viz-wrap{\n      margin-top: 14px;\n      background: var(--panel);\n      border: 1px solid var(--border);\n      border-radius: 12px;\n      padding: 14px;\n    }\n\n    .legend{\n      display:flex; gap:16px; flex-wrap: wrap;\n      font-size: 12px; color: var(--muted); margin-bottom:8px;\n    }\n    .legend .swatch{\n      width: 10px; height: 10px; border-radius: 50%; display:inline-block; margin-right:6px; position: relative; top:1px;\n      border:1px solid rgba(255,255,255,0.15);\n    }\n\n    .array-scroll{\n      overflow-x: auto;\n      padding-bottom: 8px;\n    }\n\n    .array{\n      display:flex; gap: 8px; padding: 6px; min-height: 88px;\n    }\n    .cell{\n      position: relative;\n      min-width: 56px;\n      height: 64px;\n      border: 1px solid var(--border);\n      border-radius: 10px;\n      background: #0f1426;\n      display:flex; align-items:center; justify-content:center;\n      font-size: 16px; font-weight: 600;\n      color: var(--text);\n      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);\n    }\n    .cell.muted{ color: #7f8aa8; }\n    .cell.found{ border-color: var(--green); box-shadow: 0 0 10px rgba(107,255,136,0.3); }\n    .cell.swap{ animation: pulse 400ms ease; }\n    .cell.compare{ animation: pulse2 400ms ease; }\n    @keyframes pulse{\n      0%{ box-shadow: 0 0 0 rgba(255,255,255,0.0); }\n      50%{ box-shadow: 0 0 14px rgba(107,193,255,0.3); }\n      100%{ box-shadow: 0 0 0 rgba(255,255,255,0.0); }\n    }\n    @keyframes pulse2{\n      0%{ box-shadow: 0 0 0 rgba(255,255,255,0.0); }\n      50%{ box-shadow: 0 0 14px rgba(255,216,107,0.3); }\n      100%{ box-shadow: 0 0 0 rgba(255,255,255,0.0); }\n    }\n\n    .index{\n      position: absolute; bottom: 4px; right: 6px;\n      font-size: 11px; color: var(--muted);\n    }\n    .badge{\n      position: absolute;\n      top: -10px; left: 50%; transform: translateX(-50%);\n      background: #19243d;\n      border: 1px solid #2a3f68;\n      color: var(--text);\n      padding: 3px 6px;\n      border-radius: 12px;\n      font-size: 11px;\n      white-space: nowrap;\n      box-shadow: 0 2px 6px rgba(0,0,0,0.2);\n    }\n    .badge.bottom{ top: auto; bottom: -10px; }\n    .badge.l{ background: #142f47; border-color: #2a5f84; }\n    .badge.r{ background: #3a243f; border-color: #7a4a84; }\n    .badge.slow{ background: #143824; border-color: #2a6f48; }\n    .badge.fast{ background: #443014; border-color: #8a5f2a; }\n    .badge.mid{ background: #2a152a; border-color: #6a3a6a; }\n    .badge.k{ background:#152a2a; border-color:#3a6a6a; }\n\n    .status{\n      margin-top: 10px;\n      font-size: 13px;\n      color: var(--muted);\n      display:flex; gap:8px; flex-wrap: wrap;\n    }\n    .status .pill{\n      padding: 4px 8px;\n      border:1px solid var(--border);\n      border-radius: 999px;\n      background: rgba(255,255,255,0.02);\n      color: var(--text);\n    }\n\n    .invariant{\n      margin-top: 8px;\n      font-size: 13px;\n      color: var(--muted);\n      border-left: 3px solid #2a3f68;\n      padding-left: 10px;\n    }\n\n    .log{\n      margin-top: 12px;\n      background: #0e1629;\n      border: 1px solid var(--border);\n      border-radius: 10px;\n      padding: 10px;\n      max-height: 180px;\n      overflow: auto;\n      font-size: 12px;\n    }\n    .log .entry{\n      padding: 6px 8px;\n      border-radius: 8px;\n      margin-bottom: 6px;\n      background: rgba(255,255,255,0.03);\n    }\n\n    .footer{\n      padding: 10px 20px 30px;\n      color: var(--muted);\n      font-size: 12px;\n      text-align: center;\n    }\n\n    .examples{\n      display:flex; gap:8px; flex-wrap: wrap;\n    }\n    .example{\n      padding: 6px 8px;\n      border-radius: 8px;\n      background: #10182b;\n      border: 1px solid var(--border);\n      font-size: 12px;\n      cursor: pointer;\n      color: var(--text);\n    }\n    .example:hover{ filter: brightness(1.1); }\n  </style>\n</head>\n<body>\n<header>\n  <h1>Two Pointers Visualizer</h1>\n  <div class=\"subtitle\">Interactively step through classic two-pointer algorithms on arrays.</div>\n</header>\n\n<div class=\"container\">\n  <div class=\"controls\">\n    <div class=\"control-block\">\n      <h3>Algorithm</h3>\n      <div class=\"row\">\n        <select id=\"algoSelect\">\n          <option value=\"twoSum\">Two Sum (sorted)</option>\n          <option value=\"reverse\">Reverse Array</option>\n          <option value=\"removeDup\">Remove Duplicates (sorted)</option>\n          <option value=\"moveZeroes\">Move Zeroes</option>\n          <option value=\"partitionParity\">Partition Even/Odd</option>\n        </select>\n      </div>\n      <div class=\"row\" id=\"algoExtraRow\" style=\"margin-top:8px; display:none;\">\n        <label for=\"targetInput\">Target</label>\n        <input id=\"targetInput\" type=\"number\" placeholder=\"Enter target sum\" />\n      </div>\n      <div class=\"row\" style=\"margin-top:8px;\">\n        <label><input type=\"checkbox\" id=\"sortInputChk\" /> Sort input where needed</label>\n      </div>\n      <div class=\"small\" id=\"algoHint\">Hint: Select an algorithm to see its invariant.</div>\n    </div>\n\n    <div class=\"control-block\">\n      <h3>Array</h3>\n      <div class=\"row\">\n        <input id=\"arrayInput\" type=\"text\" placeholder=\"e.g., 1,2,2,3,4,5\" />\n      </div>\n      <div class=\"row\">\n        <button class=\"btn\" id=\"btnRandom\">Random</button>\n        <input id=\"randLen\" type=\"number\" min=\"2\" max=\"40\" value=\"12\" style=\"max-width:90px;\" />\n        <input id=\"randMin\" type=\"number\" value=\"0\" style=\"max-width:90px;\" />\n        <input id=\"randMax\" type=\"number\" value=\"20\" style=\"max-width:90px;\" />\n      </div>\n      <div class=\"examples\" style=\"margin-top:6px;\">\n        <div class=\"example\" data-arr=\"1,2,3,4,7,9,11\">Sorted example</div>\n        <div class=\"example\" data-arr=\"0,1,0,3,12,0,5\">Zeros example</div>\n        <div class=\"example\" data-arr=\"1,1,2,2,3,3,4\">Duplicates example</div>\n        <div class=\"example\" data-arr=\"9,2,5,8,1,6,3,4\">Mixed example</div>\n      </div>\n    </div>\n\n    <div class=\"control-block\">\n      <h3>Run</h3>\n      <div class=\"row\">\n        <button class=\"btn primary\" id=\"btnInit\">Initialize</button>\n        <button class=\"btn\" id=\"btnStep\" disabled>Next Step</button>\n        <button class=\"btn\" id=\"btnAuto\" disabled>Auto Play</button>\n        <button class=\"btn danger\" id=\"btnReset\" disabled>Reset</button>\n      </div>\n      <div class=\"row\" style=\"margin-top:8px;\">\n        <label for=\"speedRange\">Speed</label>\n        <input id=\"speedRange\" type=\"range\" min=\"100\" max=\"1500\" value=\"600\" />\n        <span class=\"small\" id=\"speedLabel\">600 ms</span>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"viz-wrap\">\n    <div class=\"legend\">\n      <div><span class=\"swatch\" style=\"background: #142f47;\"></span> Left/L</div>\n      <div><span class=\"swatch\" style=\"background: #3a243f;\"></span> Right/R</div>\n      <div><span class=\"swatch\" style=\"background: #143824;\"></span> Slow</div>\n      <div><span class=\"swatch\" style=\"background: #443014;\"></span> Fast</div>\n      <div><span class=\"swatch\" style=\"background: #2a152a;\"></span> Mid/K</div>\n    </div>\n    <div class=\"array-scroll\">\n      <div class=\"array\" id=\"arrayView\"></div>\n    </div>\n    <div class=\"status\" id=\"statusBar\"></div>\n    <div class=\"invariant\" id=\"invariantText\"></div>\n    <div class=\"log\" id=\"log\"></div>\n  </div>\n\n  <div class=\"footer\">\n    Two pointers is a technique where you maintain indices moving through a structure under invariants that ensure linear-time solutions. Step through to see decisions and pointer movements.\n  </div>\n</div>\n\n<script>\n  // Utility Functions\n  function parseArrayInput(str){\n    if(!str) return [];\n    return str\n      .split(/[\\s,;]+/)\n      .map(s => s.trim())\n      .filter(s => s.length>0)\n      .map(Number)\n      .filter(n => Number.isFinite(n));\n  }\n  function randomArray(len=10, min=0, max=20){\n    const arr = [];\n    for(let i=0;i<len;i++){\n      arr.push(Math.floor(Math.random()*(max-min+1))+min);\n    }\n    return arr;\n  }\n  function clone(arr){ return arr.slice(); }\n\n  // Algorithms Definition\n  const ALGORITHMS = {\n    twoSum: {\n      name: \"Two Sum (sorted)\",\n      requiresSorted: true,\n      inputs: [\"target\"],\n      invariant: \"Array must be sorted. Compare a[L] + a[R] with target: if sum < target, move L++; if sum > target, move R--; else found.\",\n      init(array, options){\n        const arr = options.sort ? clone(array).sort((a,b)=>a-b) : clone(array);\n        const target = Number(options.target ?? 0);\n        return {\n          array: arr,\n          left: 0,\n          right: arr.length - 1,\n          target,\n          found: null,\n          done: false,\n          lastOp: null\n        };\n      },\n      pointers(state){\n        const p = [];\n        if(state.left>=0 && state.left < state.array.length){\n          p.push({index: state.left, label: \"L\", class: \"l\", side: \"top\"});\n        }\n        if(state.right>=0 && state.right < state.array.length){\n          p.push({index: state.right, label: \"R\", class: \"r\", side: \"top\"});\n        }\n        return p;\n      },\n      step(state){\n        if(state.done) return {status:\"done\", msg:\"Finished\"};\n        const {array, left, right, target} = state;\n        if(array.length===0) { state.done=true; return {status:\"done\", msg:\"Empty array\"}; }\n        if(left >= right){\n          state.done = true;\n          state.lastOp = {type:\"final\", indices:[left,right], msg:\"Pointers crossed: no pair found\"};\n          return {status:\"done\", msg:\"Pointers crossed: no pair found\"};\n        }\n        const sum = array[left] + array[right];\n        let msg = `Compare a[L=${left}]=${array[left]} + a[R=${right}]=${array[right]} = ${sum}`;\n        if(sum === target){\n          state.found = [left,right];\n          state.done = true;\n          state.lastOp = {type:\"found\", indices:[left,right], msg: msg + ` equals target ${target}. Pair found!`};\n          return {status:\"done\", msg: state.lastOp.msg};\n        } else if(sum < target){\n          state.lastOp = {type:\"compare\", indices:[left,right], msg: msg + ` < target ${target}. Move L++`};\n          state.left++;\n          return {status:\"continue\", msg: state.lastOp.msg};\n        } else {\n          state.lastOp = {type:\"compare\", indices:[left,right], msg: msg + ` > target ${target}. Move R--`};\n          state.right--;\n          return {status:\"continue\", msg: state.lastOp.msg};\n        }\n      },\n      result(state){\n        if(state.found) {\n          const [l,r] = state.found;\n          return `Found indices L=${l}, R=${r} -> ${state.array[l]} + ${state.array[r]} = ${state.target}`;\n        }\n        return \"No pair sums to target.\";\n      }\n    },\n\n    reverse: {\n      name: \"Reverse Array\",\n      requiresSorted: false,\n      inputs: [],\n      invariant: \"Elements before L and after R are in their final reversed positions. Swap a[L] and a[R], then move L++, R--.\",\n      init(array){\n        return { array: clone(array), left: 0, right: array.length-1, done: false, lastOp: null };\n      },\n      pointers(state){\n        const p = [];\n        if(state.left>=0 && state.left<state.array.length) p.push({index: state.left, label: \"L\", class:\"l\", side:\"top\"});\n        if(state.right>=0 && state.right<state.array.length) p.push({index: state.right, label: \"R\", class:\"r\", side:\"top\"});\n        return p;\n      },\n      step(state){\n        if(state.done) return {status:\"done\", msg:\"Finished\"};\n        if(state.left >= state.right){\n          state.done = true;\n          state.lastOp = {type:\"final\", indices:[state.left,state.right], msg:\"Pointers met/crossed. Reversal complete.\"};\n          return {status:\"done\", msg: state.lastOp.msg};\n        }\n        const i = state.left, j = state.right;\n        const ai = state.array[i], aj = state.array[j];\n        [state.array[i], state.array[j]] = [state.array[j], state.array[i]];\n        state.lastOp = {type:\"swap\", indices:[i,j], msg:`Swap a[L=${i}]=${ai} with a[R=${j}]=${aj}. Move L++, R--.`};\n        state.left++; state.right--;\n        return {status:\"continue\", msg: state.lastOp.msg};\n      },\n      result(state){\n        return `Reversed array: [${state.array.join(\", \")}]`;\n      }\n    },\n\n    removeDup: {\n      name: \"Remove Duplicates (sorted)\",\n      requiresSorted: true,\n      inputs: [],\n      invariant: \"All elements in [0..slow] are unique. Fast scans forward; on a[fast] != a[slow], increment slow and copy a[fast] to a[slow].\",\n      init(array, options){\n        const arr = options.sort ? clone(array).sort((a,b)=>a-b) : clone(array);\n        return { array: arr, slow: 0, fast: arr.length>0 ? 1 : 0, done:false, lastOp:null };\n      },\n      pointers(state){\n        const p = [];\n        if(state.array.length>0){\n          p.push({index: state.slow, label:\"slow\", class:\"slow\", side:\"top\"});\n          if(state.fast < state.array.length) p.push({index: state.fast, label:\"fast\", class:\"fast\", side:\"top\"});\n        }\n        return p;\n      },\n      step(state){\n        const n = state.array.length;\n        if(n===0){ state.done=true; return {status:\"done\", msg:\"Empty array\"}; }\n        if(state.done) return {status:\"done\", msg:\"Finished\"};\n        if(state.fast >= n){\n          state.done = true;\n          const k = state.slow + 1;\n          state.lastOp = {type:\"final\", indices:[state.slow], msg:`Done. Unique count = ${k}. First ${k} elements are deduplicated.`};\n          return {status:\"done\", msg: state.lastOp.msg};\n        }\n        const s = state.slow, f = state.fast;\n        const msgBase = `Compare a[fast=${f}]=${state.array[f]} with a[slow=${s}]=${state.array[s]}`;\n        if(state.array[f] !== state.array[s]){\n          state.slow++;\n          const prev = state.array[state.slow];\n          state.array[state.slow] = state.array[f];\n          state.lastOp = {type:\"write\", indices:[state.slow,f], msg:`${msgBase} -> different. slow++ to ${state.slow}, write a[slow]=a[fast]=${state.array[f]}`};\n        } else {\n          state.lastOp = {type:\"compare\", indices:[s,f], msg:`${msgBase} -> equal. Keep slow at ${s}.`};\n        }\n        state.fast++;\n        return {status:\"continue\", msg: state.lastOp.msg};\n      },\n      result(state){\n        const k = state.array.length ? state.slow + 1 : 0;\n        return `Unique length: ${k}. Deduplicated prefix: [${state.array.slice(0,k).join(\", \")}]`;\n      }\n    },\n\n    moveZeroes: {\n      name: \"Move Zeroes\",\n      requiresSorted: false,\n      inputs: [],\n      invariant: \"All elements before slow are non-zero. Fast iterates; when a[fast] != 0, swap with a[slow] and advance slow.\",\n      init(array){\n        return { array: clone(array), slow: 0, fast: 0, done:false, lastOp:null };\n      },\n      pointers(state){\n        const p = [];\n        if(state.array.length>0){\n          p.push({index: Math.min(state.slow,state.array.length-1), label:\"slow\", class:\"slow\", side:\"top\"});\n          if(state.fast < state.array.length) p.push({index: state.fast, label:\"fast\", class:\"fast\", side:\"top\"});\n        }\n        return p;\n      },\n      step(state){\n        const n = state.array.length;\n        if(state.done) return {status:\"done\", msg:\"Finished\"};\n        if(state.fast >= n){\n          state.done = true;\n          state.lastOp = {type:\"final\", indices:[state.slow,state.fast-1], msg:\"Completed. All non-zero elements moved to front; zeros pushed to end.\"};\n          return {status:\"done\", msg: state.lastOp.msg};\n        }\n        const f = state.fast, s = state.slow;\n        const val = state.array[f];\n        if(val !== 0){\n          if(s !== f){\n            const beforeS = state.array[s], beforeF = state.array[f];\n            [state.array[s], state.array[f]] = [state.array[f], state.array[s]];\n            state.lastOp = {type:\"swap\", indices:[s,f], msg:`a[fast=${f}]=${beforeF} != 0 -> swap with a[slow=${s}]=${beforeS}; slow++`};\n          } else {\n            state.lastOp = {type:\"write\", indices:[s,f], msg:`a[fast=${f}]=${val} != 0 & slow==fast -> keep, slow++`};\n          }\n          state.slow++;\n        } else {\n          state.lastOp = {type:\"compare\", indices:[s,f], msg:`a[fast=${f}]=0 -> do nothing; just advance fast`};\n        }\n        state.fast++;\n        return {status:\"continue\", msg: state.lastOp.msg};\n      },\n      result(state){\n        return `Result: [${state.array.join(\", \")}] (zeros at the end)`;\n      }\n    },\n\n    partitionParity: {\n      name: \"Partition Even/Odd\",\n      requiresSorted: false,\n      inputs: [],\n      invariant: \"All elements left of L are even; all right of R are odd. Move L right over evens and R left over odds; swap when L < R and both mis-placed.\",\n      init(array){\n        return { array: clone(array), left: 0, right: array.length-1, done:false, lastOp:null };\n      },\n      pointers(state){\n        const p=[];\n        if(state.array.length>0){\n          if(state.left>=0 && state.left<state.array.length) p.push({index: state.left, label:\"L\", class:\"l\", side:\"top\"});\n          if(state.right>=0 && state.right<state.array.length) p.push({index: state.right, label:\"R\", class:\"r\", side:\"top\"});\n        }\n        return p;\n      },\n      step(state){\n        if(state.done) return {status:\"done\", msg:\"Finished\"};\n        const arr = state.array;\n        let i = state.left, j = state.right;\n        const n = arr.length;\n        if(n===0){ state.done=true; return {status:\"done\", msg:\"Empty array\"}; }\n\n        let moved = [];\n        while(i < n && arr[i] % 2 === 0){ i++; moved.push(`L->${i}`); }\n        while(j >= 0 && arr[j] % 2 === 1){ j--; moved.push(`R->${j}`); }\n\n        const moveMsg = moved.length ? `Advance pointers: ${moved.join(\", \")}` : \"Pointers at candidates\";\n        state.left = i; state.right = j;\n\n        if(i >= j){\n          state.done = true;\n          state.lastOp = {type:\"final\", indices:[i,j], msg:`${moveMsg}. Pointers met/crossed; partition complete.`};\n          return {status:\"done\", msg: state.lastOp.msg};\n        }\n\n        const ai = arr[i], aj = arr[j];\n        if(ai % 2 === 1 && aj % 2 === 0){\n          [arr[i], arr[j]] = [arr[j], arr[i]];\n          state.lastOp = {type:\"swap\", indices:[i,j], msg:`Swap odd a[L=${i}]=${ai} with even a[R=${j}]=${aj}.`};\n          return {status:\"continue\", msg: `${moveMsg}. ` + state.lastOp.msg};\n        } else {\n          // Rare: if they already in correct parity, just move one step to avoid infinite loop.\n          if(ai % 2 === 0) state.left++;\n          if(aj % 2 === 1) state.right--;\n          state.lastOp = {type:\"compare\", indices:[i,j], msg:`No swap needed here. Adjust pointers.`};\n          return {status:\"continue\", msg: `${moveMsg}. ` + state.lastOp.msg};\n        }\n      },\n      result(state){\n        return `Partitioned array: [${state.array.join(\", \")}] (evens left, odds right)`;\n      }\n    }\n  };\n\n  // UI State\n  const ui = {\n    algoSelect: document.getElementById(\"algoSelect\"),\n    arrayInput: document.getElementById(\"arrayInput\"),\n    sortChk: document.getElementById(\"sortInputChk\"),\n    targetInput: document.getElementById(\"targetInput\"),\n    algoExtraRow: document.getElementById(\"algoExtraRow\"),\n    algoHint: document.getElementById(\"algoHint\"),\n    btnRandom: document.getElementById(\"btnRandom\"),\n    randLen: document.getElementById(\"randLen\"),\n    randMin: document.getElementById(\"randMin\"),\n    randMax: document.getElementById(\"randMax\"),\n    examples: document.querySelectorAll(\".example\"),\n    btnInit: document.getElementById(\"btnInit\"),\n    btnStep: document.getElementById(\"btnStep\"),\n    btnAuto: document.getElementById(\"btnAuto\"),\n    btnReset: document.getElementById(\"btnReset\"),\n    speedRange: document.getElementById(\"speedRange\"),\n    speedLabel: document.getElementById(\"speedLabel\"),\n    arrayView: document.getElementById(\"arrayView\"),\n    statusBar: document.getElementById(\"statusBar\"),\n    invariantText: document.getElementById(\"invariantText\"),\n    log: document.getElementById(\"log\")\n  };\n\n  let runtime = {\n    algoId: ui.algoSelect.value,\n    state: null,\n    autoTimer: null,\n    speed: Number(ui.speedRange.value),\n    lastHighlights: { swap:[], compare:[], found:[] }\n  };\n\n  // Rendering\n  function render(){\n    renderArray();\n    renderStatus();\n    renderInvariant();\n  }\n\n  function renderArray(){\n    const arr = runtime.state ? runtime.state.array : parseArrayInput(ui.arrayInput.value);\n    const arrayView = ui.arrayView;\n    arrayView.innerHTML = \"\";\n\n    const pointers = runtime.state ? getPointers(runtime.algoId, runtime.state) : [];\n    const highlights = runtime.lastHighlights;\n\n    arr.forEach((val, idx) => {\n      const cell = document.createElement(\"div\");\n      cell.className = \"cell\";\n      // Highlights based on last operation\n      if(highlights.swap.includes(idx)) cell.classList.add(\"swap\");\n      if(highlights.compare.includes(idx)) cell.classList.add(\"compare\");\n      if(highlights.found.includes(idx)) cell.classList.add(\"found\");\n\n      cell.textContent = String(val);\n      const index = document.createElement(\"div\");\n      index.className = \"index\";\n      index.textContent = idx;\n      cell.appendChild(index);\n\n      // Attach pointer badges\n      const atIdx = pointers.filter(p => p.index === idx);\n      atIdx.forEach((p, k) => {\n        const badge = document.createElement(\"div\");\n        badge.className = `badge ${p.class} ${p.side === \"bottom\" ? \"bottom\" : \"\"}`;\n        badge.textContent = p.label;\n        badge.style.top = p.side === \"bottom\" ? \"\" : (-10 - 16*k) + \"px\";\n        if(p.side === \"bottom\"){\n          badge.style.bottom = (-10 - 16*k) + \"px\";\n        }\n        cell.appendChild(badge);\n      });\n\n      arrayView.appendChild(cell);\n    });\n  }\n\n  function renderStatus(){\n    const statusBar = ui.statusBar;\n    statusBar.innerHTML = \"\";\n\n    const algo = ALGORITHMS[runtime.algoId];\n    const pills = [];\n\n    pills.push(`Algorithm: ${algo.name}`);\n\n    const arr = runtime.state ? runtime.state.array : parseArrayInput(ui.arrayInput.value);\n    pills.push(`Array length: ${arr.length}`);\n\n    if(runtime.algoId === \"twoSum\"){\n      const t = runtime.state ? runtime.state.target : Number(ui.targetInput.value || 0);\n      pills.push(`Target: ${t}`);\n    }\n\n    if(runtime.state){\n      const ls = document.createElement(\"div\");\n      ls.className = \"pill\";\n      ls.textContent = runtime.state.lastOp ? runtime.state.lastOp.msg : \"Initialized\";\n      statusBar.appendChild(ls);\n    }\n\n    pills.forEach(p => {\n      const pill = document.createElement(\"div\");\n      pill.className = \"pill\";\n      pill.textContent = p;\n      statusBar.appendChild(pill);\n    });\n\n    // Log last op\n    if(runtime.state && runtime.state.lastOp){\n      appendLog(runtime.state.lastOp.msg);\n    }\n  }\n\n  function renderInvariant(){\n    const algo = ALGORITHMS[runtime.algoId];\n    ui.invariantText.textContent = algo.invariant;\n  }\n\n  function appendLog(msg){\n    if(!msg) return;\n    const entry = document.createElement(\"div\");\n    entry.className = \"entry\";\n    entry.textContent = msg;\n    ui.log.appendChild(entry);\n    ui.log.scrollTop = ui.log.scrollHeight;\n  }\n\n  function getPointers(algoId, state){\n    try{\n      return ALGORITHMS[algoId].pointers(state);\n    }catch(e){\n      return [];\n    }\n  }\n\n  function clearHighlights(){\n    runtime.lastHighlights = { swap:[], compare:[], found:[] };\n  }\n  function applyHighlightsFromLastOp(){\n    clearHighlights();\n    if(!runtime.state || !runtime.state.lastOp) return;\n    const op = runtime.state.lastOp;\n    const idxs = op.indices || [];\n    if(op.type === \"swap\" || op.type === \"write\"){\n      runtime.lastHighlights.swap = idxs;\n    } else if(op.type === \"compare\"){\n      runtime.lastHighlights.compare = idxs;\n    } else if(op.type === \"found\"){\n      runtime.lastHighlights.found = idxs;\n    }\n  }\n\n  // Interaction\n  function initRun(){\n    const algoId = ui.algoSelect.value;\n    runtime.algoId = algoId;\n    const algo = ALGORITHMS[algoId];\n\n    const array = parseArrayInput(ui.arrayInput.value);\n    if(array.length === 0){\n      alert(\"Please provide a non-empty array input.\");\n      return;\n    }\n\n    const options = {\n      sort: !!ui.sortChk.checked,\n      target: ui.targetInput.value\n    };\n\n    // Warn if requires sorted and not sorted, unless sort checked\n    if(algo.requiresSorted && !options.sort){\n      if(!isSorted(array)){\n        if(!confirm(\"This algorithm expects a sorted array. Continue without sorting?\")) return;\n      }\n    }\n\n    runtime.state = algo.init(array, options);\n    ui.btnStep.disabled = false;\n    ui.btnAuto.disabled = false;\n    ui.btnReset.disabled = false;\n    appendLog(`Initialized: ${algo.name}`);\n    clearHighlights();\n    render();\n  }\n\n  function stepRun(){\n    if(!runtime.state){\n      alert(\"Initialize first.\");\n      return;\n    }\n    const algo = ALGORITHMS[runtime.algoId];\n    const res = algo.step(runtime.state);\n    applyHighlightsFromLastOp();\n    render();\n    if(res.status === \"done\"){\n      stopAuto();\n      const summary = algo.result(runtime.state);\n      appendLog(summary);\n      ui.btnStep.disabled = true;\n      ui.btnAuto.disabled = true;\n    }\n  }\n\n  function autoRun(){\n    if(!runtime.state){\n      alert(\"Initialize first.\");\n      return;\n    }\n    if(runtime.autoTimer){\n      stopAuto();\n      return;\n    }\n    ui.btnAuto.textContent = \"Stop\";\n    ui.btnStep.disabled = true;\n    runtime.autoTimer = setInterval(() => {\n      const algo = ALGORITHMS[runtime.algoId];\n      const res = algo.step(runtime.state);\n      applyHighlightsFromLastOp();\n      render();\n      if(res.status === \"done\"){\n        stopAuto();\n        const summary = algo.result(runtime.state);\n        appendLog(summary);\n        ui.btnStep.disabled = true;\n        ui.btnAuto.disabled = true;\n      }\n    }, runtime.speed);\n  }\n\n  function stopAuto(){\n    if(runtime.autoTimer){\n      clearInterval(runtime.autoTimer);\n      runtime.autoTimer = null;\n      ui.btnAuto.textContent = \"Auto Play\";\n      ui.btnStep.disabled = false;\n    }\n  }\n\n  function resetRun(){\n    stopAuto();\n    runtime.state = null;\n    clearHighlights();\n    ui.btnStep.disabled = true;\n    ui.btnAuto.disabled = true;\n    ui.btnReset.disabled = true;\n    ui.log.innerHTML = \"\";\n    render();\n  }\n\n  function updateAlgoUI(){\n    const algoId = ui.algoSelect.value;\n    const algo = ALGORITHMS[algoId];\n    ui.algoHint.textContent = algo.invariant;\n\n    ui.algoExtraRow.style.display = algo.inputs && algo.inputs.includes(\"target\") ? \"flex\" : \"none\";\n    ui.sortChk.checked = algo.requiresSorted;\n\n    render();\n  }\n\n  function isSorted(arr){\n    for(let i=1;i<arr.length;i++){\n      if(arr[i] < arr[i-1]) return false;\n    }\n    return true;\n  }\n\n  // Events\n  ui.algoSelect.addEventListener(\"change\", updateAlgoUI);\n\n  ui.btnRandom.addEventListener(\"click\", () => {\n    let len = Number(ui.randLen.value);\n    let min = Number(ui.randMin.value);\n    let max = Number(ui.randMax.value);\n    if(!Number.isFinite(len) || len<2) len = 10;\n    if(min > max){ const t=min; min=max; max=t; }\n    const arr = randomArray(len, min, max);\n    ui.arrayInput.value = arr.join(\",\");\n    render();\n  });\n\n  ui.examples.forEach(el => {\n    el.addEventListener(\"click\", () => {\n      const arr = el.getAttribute(\"data-arr\");\n      ui.arrayInput.value = arr;\n      render();\n    });\n  });\n\n  ui.btnInit.addEventListener(\"click\", initRun);\n  ui.btnStep.addEventListener(\"click\", stepRun);\n  ui.btnAuto.addEventListener(\"click\", autoRun);\n  ui.btnReset.addEventListener(\"click\", resetRun);\n\n  ui.speedRange.addEventListener(\"input\", () => {\n    runtime.speed = Number(ui.speedRange.value);\n    ui.speedLabel.textContent = `${runtime.speed} ms`;\n    if(runtime.autoTimer){\n      stopAuto();\n      autoRun();\n    }\n  });\n\n  ui.arrayInput.addEventListener(\"input\", () => { if(!runtime.state) render(); });\n  ui.targetInput.addEventListener(\"input\", () => { if(!runtime.state) render(); });\n  ui.sortChk.addEventListener(\"change\", () => { if(!runtime.state) render(); });\n\n  // Initial render\n  updateAlgoUI();\n  render();\n\n  // Prefill with a helpful example\n  ui.arrayInput.value = \"1,2,3,4,7,9,11\";\n  ui.targetInput.value = \"13\";\n  ui.sortChk.checked = true;\n  render();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Two Pointers"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "dbe92640-a370-11f0-8e65-899847045688",
    "timestamp": "2025-10-07T11:29:16.965Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Linear Regression",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Linear Regression Playground</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <style>\n    :root {\n      --bg: #0f172a;        /* slate-900 */\n      --panel: #111827;     /* gray-900 */\n      --accent: #22c55e;    /* green-500 */\n      --accent2: #3b82f6;   /* blue-500 */\n      --accent3: #f43f5e;   /* rose-500 */\n      --text: #e5e7eb;      /* gray-200 */\n      --muted: #94a3b8;     /* slate-400 */\n      --grid: #1f2937;      /* gray-800 */\n      --axis: #334155;      /* slate-700 */\n      --point: #fb923c;     /* orange-400 */\n      --residual: rgba(244,63,94,0.5); /* rose-500 alpha */\n    }\n    * { box-sizing: border-box }\n    html, body {\n      height: 100%;\n      margin: 0;\n      background: var(--bg);\n      color: var(--text);\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n    }\n    header {\n      padding: 16px 20px;\n      border-bottom: 1px solid var(--axis);\n      display: flex;\n      align-items: center;\n      gap: 16px;\n    }\n    header h1 {\n      margin: 0;\n      font-size: 20px;\n      letter-spacing: 0.2px;\n    }\n    header .desc {\n      color: var(--muted);\n      font-size: 14px;\n    }\n    main {\n      display: grid;\n      grid-template-columns: 1.1fr 0.9fr;\n      gap: 16px;\n      padding: 16px;\n    }\n    .card {\n      background: var(--panel);\n      border: 1px solid var(--axis);\n      border-radius: 10px;\n      overflow: hidden;\n      box-shadow: 0 4px 24px rgba(0,0,0,0.25);\n    }\n    .card-header {\n      padding: 12px 16px;\n      border-bottom: 1px solid var(--axis);\n      font-weight: 600;\n      font-size: 14px;\n      display: flex;\n      align-items: center;\n      gap: 8px;\n    }\n    .card-body {\n      padding: 12px;\n    }\n    .row {\n      display: flex;\n      gap: 10px;\n      align-items: center;\n      flex-wrap: wrap;\n    }\n    .col {\n      display: flex;\n      flex-direction: column;\n      gap: 6px;\n    }\n    label {\n      font-size: 12px;\n      color: var(--muted);\n    }\n    input[type=\"number\"], input[type=\"text\"] {\n      background: #0b1220;\n      border: 1px solid var(--axis);\n      color: var(--text);\n      padding: 8px 10px;\n      border-radius: 8px;\n      width: 100%;\n      font-size: 13px;\n    }\n    input[type=\"range\"] {\n      width: 160px;\n    }\n    button {\n      background: var(--grid);\n      border: 1px solid var(--axis);\n      color: var(--text);\n      padding: 8px 12px;\n      border-radius: 8px;\n      font-weight: 600;\n      cursor: pointer;\n      transition: transform 0.08s ease, background 0.2s ease, border 0.2s ease, opacity 0.2s ease;\n      font-size: 13px;\n    }\n    button:hover { background: #172033 }\n    button:active { transform: scale(0.98) }\n    button.primary {\n      background: #0b3b20;\n      border-color: #14532d;\n      color: #b1f0c5;\n    }\n    button.blue {\n      background: #0b2c4a;\n      border-color: #1e40af;\n      color: #cfe3ff;\n    }\n    button.red {\n      background: #3f1020;\n      border-color: #7f1d1d;\n      color: #ffd0d5;\n    }\n    button.gray {\n      background: #0f1420;\n      border-color: #263247;\n      color: #cbd5e1;\n    }\n    button:disabled {\n      opacity: 0.55;\n      cursor: not-allowed;\n    }\n    .badge {\n      display: inline-flex;\n      align-items: center;\n      gap: 6px;\n      font-size: 12px;\n      padding: 6px 8px;\n      border-radius: 999px;\n      background: #0b182c;\n      border: 1px solid var(--axis);\n      color: #dbeafe;\n    }\n    .metrics {\n      display: grid;\n      grid-template-columns: 1fr 1fr;\n      gap: 8px;\n      padding-top: 8px;\n    }\n    .metric {\n      background: #0b1423;\n      border: 1px solid var(--axis);\n      border-radius: 8px;\n      padding: 10px;\n      display: flex;\n      justify-content: space-between;\n      align-items: baseline;\n    }\n    .metric .label { font-size: 12px; color: var(--muted) }\n    .metric .value { font-size: 16px; font-weight: 700 }\n    .hint {\n      font-size: 12px;\n      color: var(--muted);\n    }\n    canvas {\n      display: block;\n      background: #0b1423;\n    }\n    .legend {\n      display: flex;\n      gap: 10px;\n      padding: 8px 12px;\n      border-top: 1px solid var(--axis);\n      background: #0c1828;\n      font-size: 12px;\n      color: var(--muted);\n    }\n    .legend .item { display: flex; align-items: center; gap: 6px }\n    .swatch {\n      width: 14px; height: 2px; border-radius: 2px;\n    }\n    .swatch.dot { height: 10px; width: 10px; border-radius: 50% }\n    .grid {\n      display: grid;\n      grid-template-columns: repeat(2, minmax(240px, 1fr));\n      gap: 10px;\n    }\n    .explain {\n      font-size: 13px;\n      line-height: 1.4;\n      color: var(--muted);\n    }\n    .toggle {\n      display: inline-flex;\n      align-items: center;\n      gap: 6px;\n      cursor: pointer;\n      user-select: none;\n    }\n    .toggle input { margin: 0 }\n    .footer {\n      padding: 10px 16px;\n      font-size: 12px;\n      color: var(--muted);\n      border-top: 1px solid var(--axis);\n    }\n    @media (max-width: 980px) {\n      main { grid-template-columns: 1fr }\n    }\n  </style>\n</head>\n<body>\n<header>\n  <h1>Linear Regression</h1>\n  <div class=\"desc\">Fit a line y = a·x + b to data points using Least Squares or Gradient Descent</div>\n</header>\n\n<main>\n  <section class=\"card\">\n    <div class=\"card-header\">\n      Interactive plot\n      <span class=\"badge\" id=\"pointCount\">0 points</span>\n      <label class=\"toggle\" title=\"Click on the plot to add data points\">\n        <input type=\"checkbox\" id=\"addMode\">\n        Click-to-add\n      </label>\n      <label class=\"toggle\" title=\"Show residuals (errors) from each point to the fitted line\">\n        <input type=\"checkbox\" id=\"showResiduals\" checked>\n        Residuals\n      </label>\n      <div style=\"margin-left:auto; display:flex; gap:8px;\">\n        <button class=\"gray\" id=\"clearPoints\">Clear points</button>\n      </div>\n    </div>\n    <div class=\"card-body\">\n      <canvas id=\"plot\" width=\"860\" height=\"480\"></canvas>\n    </div>\n    <div class=\"legend\">\n      <div class=\"item\"><span class=\"swatch dot\" style=\"background: var(--point)\"></span> Data points</div>\n      <div class=\"item\"><span class=\"swatch\" style=\"background: var(--accent)\"></span> Fitted line</div>\n      <div class=\"item\"><span class=\"swatch\" style=\"background: var(--residual)\"></span> Residuals</div>\n      <div class=\"item\"><span class=\"swatch\" style=\"background: var(--axis)\"></span> Axes</div>\n    </div>\n  </section>\n\n  <section class=\"card\">\n    <div class=\"card-header\">Controls</div>\n    <div class=\"card-body\">\n      <div class=\"grid\">\n        <div class=\"col\">\n          <label>Generate synthetic data</label>\n          <div class=\"row\">\n            <div class=\"col\" style=\"min-width:120px\">\n              <label>Points</label>\n              <input type=\"number\" id=\"genN\" min=\"2\" max=\"500\" value=\"40\">\n            </div>\n            <div class=\"col\" style=\"min-width:120px\">\n              <label>Slope (a)</label>\n              <input type=\"number\" id=\"genSlope\" step=\"0.1\" value=\"1.5\">\n            </div>\n            <div class=\"col\" style=\"min-width:120px\">\n              <label>Intercept (b)</label>\n              <input type=\"number\" id=\"genIntercept\" step=\"0.1\" value=\"2\">\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col\" style=\"min-width:140px\">\n              <label>X range [min, max]</label>\n              <div class=\"row\" style=\"gap:6px\">\n                <input type=\"number\" id=\"genXMin\" value=\"0\" style=\"width:90px\">\n                <input type=\"number\" id=\"genXMax\" value=\"10\" style=\"width:90px\">\n              </div>\n            </div>\n            <div class=\"col\" style=\"min-width:140px\">\n              <label>Noise (σ)</label>\n              <input type=\"number\" id=\"genNoise\" step=\"0.1\" value=\"1.0\">\n            </div>\n          </div>\n          <div class=\"row\">\n            <button class=\"blue\" id=\"btnGenerate\">Generate</button>\n            <span class=\"hint\">Generates y = a·x + b + Normal(0, σ²)</span>\n          </div>\n        </div>\n\n        <div class=\"col\">\n          <label>Fit the model</label>\n          <div class=\"row\">\n            <button class=\"primary\" id=\"btnLeastSquares\">Fit (Least Squares)</button>\n            <button class=\"primary\" id=\"btnResetModel\">Reset model</button>\n          </div>\n          <div class=\"row\" style=\"margin-top:6px\">\n            <div class=\"col\" style=\"min-width:140px\">\n              <label>Learning rate (η)</label>\n              <input type=\"range\" id=\"lr\" min=\"0.0005\" max=\"1.0000\" step=\"0.0005\" value=\"0.030\">\n              <div class=\"hint\">η = <span id=\"lrVal\">0.03</span></div>\n            </div>\n            <div class=\"col\" style=\"min-width:140px\">\n              <label>Gradient Descent</label>\n              <div class=\"row\">\n                <button class=\"blue\" id=\"btnTrain\">Start training</button>\n                <button class=\"gray\" id=\"btnStep\">Step ×10</button>\n                <button class=\"red\" id=\"btnStop\" disabled>Stop</button>\n              </div>\n              <div class=\"hint\">Batch gradient descent minimizes mean squared error</div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"metrics\">\n        <div class=\"metric\">\n          <div class=\"label\">Equation</div>\n          <div class=\"value\" id=\"eq\">y = a·x + b</div>\n        </div>\n        <div class=\"metric\">\n          <div class=\"label\">Mean Squared Error (MSE)</div>\n          <div class=\"value\" id=\"mse\">—</div>\n        </div>\n        <div class=\"metric\">\n          <div class=\"label\">Slope (a)</div>\n          <div class=\"value\" id=\"slope\">0</div>\n        </div>\n        <div class=\"metric\">\n          <div class=\"label\">Intercept (b)</div>\n          <div class=\"value\" id=\"intercept\">0</div>\n        </div>\n      </div>\n\n      <div class=\"explain\" style=\"margin-top:10px\">\n        Linear Regression finds the line y = a·x + b that minimizes the average squared distance between the line and the data points (residuals).\n        Least Squares provides a closed-form solution. Gradient Descent iteratively adjusts a and b to reduce the Mean Squared Error.\n      </div>\n    </div>\n  </section>\n\n  <section class=\"card\">\n    <div class=\"card-header\">Training Loss (MSE) over iterations</div>\n    <div class=\"card-body\">\n      <canvas id=\"loss\" width=\"860\" height=\"180\"></canvas>\n      <div class=\"footer\" id=\"lossInfo\">No training yet</div>\n    </div>\n  </section>\n</main>\n\n<script>\n(function(){\n  // State\n  const points = [];\n  let model = { a: 0, b: 0 };\n  let costHistory = []; // {iter, cost}\n  let training = false;\n  let iter = 0;\n  let trainReq = null;\n\n  // Elements\n  const plot = document.getElementById('plot');\n  const lossCanvas = document.getElementById('loss');\n  const ctx = plot.getContext('2d');\n  const lossCtx = lossCanvas.getContext('2d');\n\n  const addMode = document.getElementById('addMode');\n  const showResidualsEl = document.getElementById('showResiduals');\n  const pointCount = document.getElementById('pointCount');\n  const clearPointsBtn = document.getElementById('clearPoints');\n\n  const genN = document.getElementById('genN');\n  const genSlope = document.getElementById('genSlope');\n  const genIntercept = document.getElementById('genIntercept');\n  const genXMin = document.getElementById('genXMin');\n  const genXMax = document.getElementById('genXMax');\n  const genNoise = document.getElementById('genNoise');\n  const btnGenerate = document.getElementById('btnGenerate');\n\n  const btnLeast = document.getElementById('btnLeastSquares');\n  const btnResetModel = document.getElementById('btnResetModel');\n\n  const lrInput = document.getElementById('lr');\n  const lrVal = document.getElementById('lrVal');\n  const btnTrain = document.getElementById('btnTrain');\n  const btnStop = document.getElementById('btnStop');\n  const btnStep = document.getElementById('btnStep');\n\n  const eqEl = document.getElementById('eq');\n  const mseEl = document.getElementById('mse');\n  const slopeEl = document.getElementById('slope');\n  const interceptEl = document.getElementById('intercept');\n  const lossInfo = document.getElementById('lossInfo');\n\n  // Plot config\n  const margin = { left: 48, right: 18, top: 20, bottom: 42 };\n  const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--grid');\n  const axisColor = getComputedStyle(document.documentElement).getPropertyValue('--axis');\n  const pointColor = getComputedStyle(document.documentElement).getPropertyValue('--point');\n  const lineColor = getComputedStyle(document.documentElement).getPropertyValue('--accent');\n  const residualColor = getComputedStyle(document.documentElement).getPropertyValue('--residual');\n\n  function formatNum(x, digits = 4) {\n    if (!isFinite(x)) return '—';\n    const ax = Math.abs(x);\n    if (ax !== 0 && (ax >= 1e4 || ax < 1e-3)) return x.toExponential(2);\n    return Number(x).toFixed(digits);\n  }\n\n  // Data utilities\n  function stats(points) {\n    if (points.length === 0) return null;\n    let xmin = Infinity, xmax = -Infinity, ymin = Infinity, ymax = -Infinity;\n    for (const p of points) {\n      if (p.x < xmin) xmin = p.x;\n      if (p.x > xmax) xmax = p.x;\n      if (p.y < ymin) ymin = p.y;\n      if (p.y > ymax) ymax = p.y;\n    }\n    if (xmin === xmax) { xmin -= 1; xmax += 1; }\n    if (ymin === ymax) { ymin -= 1; ymax += 1; }\n    const dx = xmax - xmin, dy = ymax - ymin;\n    const padX = dx * 0.08 || 1;\n    const padY = dy * 0.08 || 1;\n    return { xmin: xmin - padX, xmax: xmax + padX, ymin: ymin - padY, ymax: ymax + padY };\n  }\n\n  function defaultRange() {\n    return { xmin: 0, xmax: 10, ymin: 0, ymax: 10 };\n  }\n\n  function getRange() {\n    return points.length ? stats(points) : defaultRange();\n  }\n\n  function sx(x, r) {\n    return margin.left + (x - r.xmin) / (r.xmax - r.xmin) * (plot.width - margin.left - margin.right);\n  }\n  function sy(y, r) {\n    return plot.height - margin.bottom - (y - r.ymin) / (r.ymax - r.ymin) * (plot.height - margin.top - margin.bottom);\n  }\n\n  function invCoord(px, py, r) {\n    const x = r.xmin + (px - margin.left) / (plot.width - margin.left - margin.right) * (r.xmax - r.xmin);\n    const y = r.ymin + (plot.height - margin.bottom - py) / (plot.height - margin.top - margin.bottom) * (r.ymax - r.ymin);\n    return { x, y };\n  }\n\n  // Drawing\n  function drawAxes(r) {\n    ctx.save();\n    ctx.clearRect(0, 0, plot.width, plot.height);\n\n    // Grid\n    ctx.fillStyle = '#0b1423';\n    ctx.fillRect(0,0,plot.width,plot.height);\n\n    // Axis rectangles\n    ctx.strokeStyle = axisColor;\n    ctx.lineWidth = 1;\n    ctx.strokeRect(margin.left, margin.top, plot.width - margin.left - margin.right, plot.height - margin.top - margin.bottom);\n\n    // Ticks\n    const ticks = 5;\n    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted');\n    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n\n    for (let i=0;i<=ticks;i++){\n      const t = r.xmin + i*(r.xmax - r.xmin)/ticks;\n      const px = sx(t, r);\n      ctx.strokeStyle = gridColor;\n      ctx.beginPath();\n      ctx.moveTo(px, margin.top);\n      ctx.lineTo(px, plot.height - margin.bottom);\n      ctx.stroke();\n      ctx.fillText(Number(t).toFixed(2), px, plot.height - margin.bottom + 6);\n    }\n    ctx.textAlign = 'right';\n    ctx.textBaseline = 'middle';\n    for (let i=0;i<=ticks;i++){\n      const t = r.ymin + i*(r.ymax - r.ymin)/ticks;\n      const py = sy(t, r);\n      ctx.strokeStyle = gridColor;\n      ctx.beginPath();\n      ctx.moveTo(margin.left, py);\n      ctx.lineTo(plot.width - margin.right, py);\n      ctx.stroke();\n      ctx.fillText(Number(t).toFixed(2), margin.left - 6, py);\n    }\n    ctx.restore();\n  }\n\n  function drawPoints(r) {\n    ctx.save();\n    ctx.fillStyle = pointColor;\n    for (const p of points) {\n      const px = sx(p.x, r), py = sy(p.y, r);\n      ctx.beginPath();\n      ctx.arc(px, py, 4, 0, Math.PI*2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n\n  function drawResiduals(r) {\n    if (!points.length) return;\n    ctx.save();\n    ctx.strokeStyle = residualColor;\n    ctx.lineWidth = 2;\n    for (const p of points) {\n      const yhat = model.a * p.x + model.b;\n      const px = sx(p.x, r);\n      const py = sy(p.y, r);\n      const pyh = sy(yhat, r);\n      ctx.beginPath();\n      ctx.moveTo(px, py);\n      ctx.lineTo(px, pyh);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawLine(r) {\n    if (!isFinite(model.a) || !isFinite(model.b)) return;\n    ctx.save();\n    ctx.strokeStyle = lineColor;\n    ctx.lineWidth = 2.5;\n    ctx.beginPath();\n    const x1 = r.xmin, y1 = model.a * x1 + model.b;\n    const x2 = r.xmax, y2 = model.a * x2 + model.b;\n    ctx.moveTo(sx(x1, r), sy(y1, r));\n    ctx.lineTo(sx(x2, r), sy(y2, r));\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  function drawPlot() {\n    const r = getRange();\n    drawAxes(r);\n    if (showResidualsEl.checked) drawResiduals(r);\n    drawLine(r);\n    drawPoints(r);\n    updateHUD();\n  }\n\n  // Loss chart\n  function drawLoss() {\n    const w = lossCanvas.width, h = lossCanvas.height;\n    lossCtx.clearRect(0, 0, w, h);\n    lossCtx.fillStyle = '#0b1423';\n    lossCtx.fillRect(0, 0, w, h);\n\n    const left = 52, right = 12, top = 14, bottom = 32;\n\n    lossCtx.strokeStyle = axisColor;\n    lossCtx.strokeRect(left, top, w - left - right, h - top - bottom);\n\n    if (costHistory.length < 2) {\n      lossInfo.textContent = costHistory.length ? `Iter ${costHistory[costHistory.length-1].iter}, MSE ${formatNum(costHistory[costHistory.length-1].cost, 6)}` : 'No training yet';\n      return;\n    }\n\n    const minIter = costHistory[0].iter;\n    const maxIter = costHistory[costHistory.length-1].iter;\n    let minCost = Infinity, maxCost = -Infinity;\n    for (const c of costHistory) {\n      if (c.cost < minCost) minCost = c.cost;\n      if (c.cost > maxCost) maxCost = c.cost;\n    }\n    if (minCost === maxCost) {\n      minCost -= 1e-6;\n      maxCost += 1e-6;\n    }\n\n    const sx = (t)=> left + (t - minIter)/(maxIter - minIter) * (w - left - right);\n    const sy = (val)=> h - bottom - (val - minCost)/(maxCost - minCost) * (h - top - bottom);\n\n    // grid\n    const ticks = 4;\n    lossCtx.strokeStyle = gridColor;\n    for (let i=0;i<=ticks;i++){\n      const px = left + i*(w - left - right)/ticks;\n      lossCtx.beginPath(); lossCtx.moveTo(px, top); lossCtx.lineTo(px, h - bottom); lossCtx.stroke();\n    }\n    for (let i=0;i<=ticks;i++){\n      const py = top + i*(h - top - bottom)/ticks;\n      lossCtx.beginPath(); lossCtx.moveTo(left, py); lossCtx.lineTo(w - right, py); lossCtx.stroke();\n    }\n\n    // labels\n    lossCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted');\n    lossCtx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';\n    lossCtx.textAlign = 'center';\n    lossCtx.textBaseline = 'top';\n    for (let i=0;i<=ticks;i++){\n      const t = Math.round(minIter + i*(maxIter - minIter)/ticks);\n      const px = left + i*(w - left - right)/ticks;\n      lossCtx.fillText(t, px, h - bottom + 6);\n    }\n    lossCtx.textAlign = 'right';\n    lossCtx.textBaseline = 'middle';\n    for (let i=0;i<=ticks;i++){\n      const val = minCost + i*(maxCost - minCost)/ticks;\n      const py = h - bottom - i*(h - top - bottom)/ticks;\n      lossCtx.fillText(formatNum(val, 6), left - 6, py);\n    }\n\n    // path\n    lossCtx.strokeStyle = lineColor;\n    lossCtx.lineWidth = 2;\n    lossCtx.beginPath();\n    for (let i=0;i<costHistory.length;i++){\n      const c = costHistory[i];\n      const px = sx(c.iter);\n      const py = sy(c.cost);\n      if (i === 0) lossCtx.moveTo(px, py);\n      else lossCtx.lineTo(px, py);\n    }\n    lossCtx.stroke();\n\n    const last = costHistory[costHistory.length-1];\n    lossInfo.textContent = `Iterations ${minIter} – ${maxIter} (n=${costHistory.length}), last MSE ${formatNum(last.cost, 6)}`;\n  }\n\n  // Fitting\n  function leastSquares(points) {\n    const n = points.length;\n    if (n < 2) return { a: NaN, b: NaN, mse: NaN };\n    let sumX=0, sumY=0;\n    for (const p of points) { sumX += p.x; sumY += p.y; }\n    const meanX = sumX / n, meanY = sumY / n;\n    let sxx = 0, sxy = 0;\n    for (const p of points) {\n      const dx = p.x - meanX;\n      sxx += dx * dx;\n      sxy += dx * (p.y - meanY);\n    }\n    if (sxx === 0) return { a: NaN, b: NaN, mse: NaN }; // vertical line fit not supported\n    const a = sxy / sxx;\n    const b = meanY - a * meanX;\n    const mse = computeMSE(points, { a, b });\n    return { a, b, mse };\n  }\n\n  function computeMSE(points, model) {\n    const n = points.length;\n    if (n === 0) return NaN;\n    let sum = 0;\n    for (const p of points) {\n      const err = model.a * p.x + model.b - p.y;\n      sum += err * err;\n    }\n    return sum / n;\n  }\n\n  function stepGradientDescent(times = 1) {\n    if (points.length === 0) return;\n    const lr = parseFloat(lrInput.value);\n    for (let t=0; t<times; t++) {\n      const n = points.length;\n      let gradA = 0, gradB = 0;\n      // Gradient of MSE: (2/n) * sum(err * x), (2/n) * sum(err)\n      for (const p of points) {\n        const err = model.a * p.x + model.b - p.y;\n        gradA += err * p.x;\n        gradB += err;\n      }\n      gradA = (2 / n) * gradA;\n      gradB = (2 / n) * gradB;\n\n      model.a -= lr * gradA;\n      model.b -= lr * gradB;\n\n      iter++;\n      const cost = computeMSE(points, model);\n      costHistory.push({ iter, cost });\n    }\n    updateHUD();\n    drawPlot();\n    drawLoss();\n  }\n\n  function startTraining() {\n    if (training || points.length === 0) return;\n    training = true;\n    btnTrain.disabled = true;\n    btnStop.disabled = false;\n    btnStep.disabled = true;\n\n    const loop = () => {\n      if (!training) return;\n      stepGradientDescent(1);\n      trainReq = requestAnimationFrame(loop);\n    };\n    trainReq = requestAnimationFrame(loop);\n  }\n\n  function stopTraining() {\n    training = false;\n    btnTrain.disabled = false;\n    btnStop.disabled = true;\n    btnStep.disabled = false;\n    if (trainReq) cancelAnimationFrame(trainReq);\n  }\n\n  // HUD\n  function updateHUD() {\n    const mse = computeMSE(points, model);\n    slopeEl.textContent = formatNum(model.a, 4);\n    interceptEl.textContent = formatNum(model.b, 4);\n    eqEl.textContent = `y = ${formatNum(model.a, 4)} · x + ${formatNum(model.b, 4)}`;\n    mseEl.textContent = isFinite(mse) ? formatNum(mse, 6) : '—';\n    pointCount.textContent = `${points.length} point${points.length===1?'':'s'}`;\n  }\n\n  // Events\n  btnGenerate.addEventListener('click', () => {\n    const n = Math.max(2, Math.min(2000, parseInt(genN.value || '40', 10)));\n    const a = parseFloat(genSlope.value || '1.5');\n    const b = parseFloat(genIntercept.value || '2');\n    const xmin = parseFloat(genXMin.value || '0');\n    const xmax = parseFloat(genXMax.value || '10');\n    const sigma = Math.max(0, parseFloat(genNoise.value || '1.0'));\n\n    if (!(xmax > xmin)) {\n      alert('X max must be greater than X min.');\n      return;\n    }\n\n    points.length = 0;\n    // Generate x uniformly, and y with noise\n    for (let i=0;i<n;i++){\n      const x = xmin + Math.random()*(xmax - xmin);\n      const noise = gaussian(0, sigma);\n      const y = a * x + b + noise;\n      points.push({ x, y });\n    }\n    // Reset model and training\n    resetTraining();\n    drawPlot();\n    drawLoss();\n  });\n\n  function gaussian(mu, sigma) {\n    // Box-Muller\n    let u = 0, v = 0;\n    while (u === 0) u = Math.random();\n    while (v === 0) v = Math.random();\n    const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n    return mu + sigma * z;\n  }\n\n  btnLeast.addEventListener('click', () => {\n    if (points.length < 2) {\n      alert('Add at least two points to fit a line.');\n      return;\n    }\n    const fit = leastSquares(points);\n    if (!isFinite(fit.a) || !isFinite(fit.b)) {\n      alert('Cannot fit a vertical line with this method (all x are equal). Add varied x values.');\n      return;\n    }\n    model.a = fit.a;\n    model.b = fit.b;\n    const mse = computeMSE(points, model);\n    costHistory.push({ iter: ++iter, cost: mse });\n    drawPlot();\n    drawLoss();\n  });\n\n  btnResetModel.addEventListener('click', () => {\n    model.a = 0;\n    model.b = 0;\n    drawPlot();\n  });\n\n  lrInput.addEventListener('input', () => {\n    lrVal.textContent = parseFloat(lrInput.value).toFixed(3);\n  });\n\n  btnTrain.addEventListener('click', () => {\n    if (points.length === 0) {\n      alert('Add or generate points to train.');\n      return;\n    }\n    startTraining();\n  });\n\n  btnStop.addEventListener('click', stopTraining);\n\n  btnStep.addEventListener('click', () => {\n    if (points.length === 0) {\n      alert('Add or generate points to train.');\n      return;\n    }\n    stepGradientDescent(10);\n  });\n\n  addMode.addEventListener('change', () => {\n    plot.style.cursor = addMode.checked ? 'crosshair' : 'default';\n  });\n\n  clearPointsBtn.addEventListener('click', () => {\n    points.length = 0;\n    resetTraining();\n    drawPlot();\n    drawLoss();\n  });\n\n  plot.addEventListener('click', (e) => {\n    if (!addMode.checked) return;\n    const rect = plot.getBoundingClientRect();\n    const px = e.clientX - rect.left;\n    const py = e.clientY - rect.top;\n    const r = getRange();\n    const p = invCoord(px, py, r);\n    points.push(p);\n    // Keep training consistent\n    drawPlot();\n  });\n\n  function resetTraining() {\n    stopTraining();\n    model.a = 0;\n    model.b = 0;\n    iter = 0;\n    costHistory.length = 0;\n    updateHUD();\n    lossInfo.textContent = 'No training yet';\n  }\n\n  // Initial\n  lrVal.textContent = parseFloat(lrInput.value).toFixed(3);\n  drawPlot();\n  drawLoss();\n\n})();\n</script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Linear Regression"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "0d1b72e0-a371-11f0-b0ef-53765fa8ead1",
    "timestamp": "2025-10-07T11:30:39.503Z",
    "model": "gpt-5",
    "status": "success",
    "question": "K-Nearest Neighbors (KNN)",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>K-Nearest Neighbors (KNN) Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #f7f9fc;\n      --panel: #ffffff;\n      --text: #222;\n      --muted: #6b7280;\n      --border: #d1d5db;\n      --accent: #0ea5e9;\n    }\n    * { box-sizing: border-box; }\n    body {\n      margin: 0;\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n      color: var(--text);\n      background: var(--bg);\n    }\n    header {\n      padding: 16px 20px 8px 20px;\n    }\n    h1 {\n      font-size: 20px;\n      margin: 0 0 6px 0;\n    }\n    p {\n      margin: 0 0 10px 0;\n      color: var(--muted);\n      font-size: 14px;\n    }\n    .container {\n      display: grid;\n      grid-template-columns: 1fr 320px;\n      gap: 12px;\n      padding: 0 20px 20px 20px;\n    }\n    .left, .right {\n      background: var(--panel);\n      border: 1px solid var(--border);\n      border-radius: 8px;\n      overflow: hidden;\n    }\n    .controls {\n      padding: 12px;\n      border-bottom: 1px solid var(--border);\n      display: grid;\n      grid-template-columns: repeat(3, 1fr);\n      gap: 12px;\n      align-items: center;\n    }\n    .controls .row { display: contents; }\n    .control {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      font-size: 14px;\n    }\n    .control label {\n      color: var(--muted);\n      min-width: 110px;\n      white-space: nowrap;\n    }\n    .control input[type=\"range\"] {\n      width: 100%;\n    }\n    .control select, .control button {\n      padding: 6px 8px;\n      font-size: 14px;\n      border: 1px solid var(--border);\n      border-radius: 6px;\n      background: #fff;\n      color: var(--text);\n    }\n    .control button {\n      cursor: pointer;\n    }\n    .control button:hover {\n      border-color: var(--accent);\n    }\n    .toggles {\n      display: flex;\n      gap: 16px;\n      align-items: center;\n      flex-wrap: wrap;\n      font-size: 14px;\n      padding: 8px 12px;\n    }\n    .legend {\n      display: flex;\n      gap: 10px;\n      align-items: center;\n      flex-wrap: wrap;\n      padding: 8px 12px;\n      border-top: 1px solid var(--border);\n    }\n    .legend .item {\n      display: flex;\n      align-items: center;\n      gap: 6px;\n      font-size: 13px;\n      color: var(--muted);\n    }\n    .swatch {\n      width: 14px;\n      height: 14px;\n      border-radius: 50%;\n      border: 1px solid rgba(0,0,0,0.15);\n      flex: 0 0 auto;\n    }\n    .canvas-wrap {\n      position: relative;\n      width: 100%;\n      height: 520px;\n      background: #fff;\n    }\n    canvas {\n      width: 100%;\n      height: 100%;\n      display: block;\n      cursor: crosshair;\n      background:\n        linear-gradient(to right, #f9fafb 1px, transparent 1px) 0 0/20px 20px,\n        linear-gradient(to bottom, #f9fafb 1px, transparent 1px) 0 0/20px 20px;\n    }\n    .hint {\n      position: absolute;\n      bottom: 8px;\n      left: 8px;\n      right: 8px;\n      font-size: 12px;\n      color: var(--muted);\n      background: rgba(255,255,255,0.85);\n      border: 1px solid var(--border);\n      padding: 6px 8px;\n      border-radius: 6px;\n    }\n    .right .panel {\n      padding: 12px;\n    }\n    .panel h2 {\n      font-size: 16px;\n      margin: 0 0 8px 0;\n    }\n    .panel .info {\n      font-size: 13px;\n      color: var(--muted);\n      line-height: 1.4;\n    }\n    .kv {\n      margin-top: 8px;\n      padding-top: 8px;\n      border-top: 1px solid var(--border);\n      font-family: ui-monospace, Menlo, Consolas, monospace;\n      font-size: 12px;\n      white-space: pre-wrap;\n      color: #111827;\n      background: #f9fafb;\n      border-radius: 6px;\n      padding: 8px;\n    }\n    .footer {\n      padding: 8px 12px;\n      border-top: 1px solid var(--border);\n      font-size: 12px;\n      color: var(--muted);\n    }\n\n    /* Colors for classes */\n    .c0 { background: #e74c3c; }\n    .c1 { background: #3498db; }\n    .c2 { background: #2ecc71; }\n    .c3 { background: #f39c12; }\n    .c4 { background: #9b59b6; }\n    .muted {\n      opacity: 0.6;\n    }\n    .inline {\n      display: inline-flex;\n      align-items: center;\n      gap: 6px;\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>K-Nearest Neighbors (KNN) Interactive Demo</h1>\n    <p>Add training points, choose k, and click to classify a test point. Toggle decision boundary to see how KNN partitions the space.</p>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"left\">\n      <div class=\"controls\">\n        <div class=\"control\">\n          <label for=\"kRange\">K neighbors</label>\n          <input id=\"kRange\" type=\"range\" min=\"1\" max=\"25\" step=\"1\" value=\"5\" />\n          <span id=\"kVal\">5</span>\n        </div>\n        <div class=\"control\">\n          <label>Distance</label>\n          <div class=\"inline\">\n            <label class=\"inline\"><input type=\"radio\" name=\"metric\" id=\"metricEuclidean\" value=\"euclidean\" checked /> Euclidean</label>\n            <label class=\"inline\"><input type=\"radio\" name=\"metric\" id=\"metricManhattan\" value=\"manhattan\" /> Manhattan</label>\n          </div>\n        </div>\n        <div class=\"control\">\n          <label>Weighting</label>\n          <label class=\"inline\"><input type=\"checkbox\" id=\"weightInvDist\" /> Inverse-distance</label>\n        </div>\n\n        <div class=\"control\">\n          <label>Mode</label>\n          <div class=\"inline\">\n            <label class=\"inline\"><input type=\"radio\" name=\"mode\" id=\"modeAdd\" value=\"add\" checked /> Add points</label>\n            <label class=\"inline\"><input type=\"radio\" name=\"mode\" id=\"modeClassify\" value=\"classify\" /> Classify</label>\n          </div>\n        </div>\n        <div class=\"control\">\n          <label>Active class</label>\n          <select id=\"classSelect\">\n            <option value=\"0\">Class 0 (red)</option>\n            <option value=\"1\">Class 1 (blue)</option>\n            <option value=\"2\">Class 2 (green)</option>\n          </select>\n        </div>\n        <div class=\"control\">\n          <label>Actions</label>\n          <div class=\"inline\">\n            <button id=\"btnSample\">Sample data</button>\n            <button id=\"btnClear\">Clear</button>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"toggles\">\n        <label class=\"inline\"><input type=\"checkbox\" id=\"snapOddK\" /> Prefer odd K</label>\n        <label class=\"inline\"><input type=\"checkbox\" id=\"showNeighborLines\" checked /> Show nearest neighbor lines</label>\n        <label class=\"inline\"><input type=\"checkbox\" id=\"showBoundary\" /> Show decision boundary</label>\n      </div>\n\n      <div class=\"legend\">\n        <div class=\"item\"><span class=\"swatch c0\"></span> Class 0</div>\n        <div class=\"item\"><span class=\"swatch c1\"></span> Class 1</div>\n        <div class=\"item\"><span class=\"swatch c2\"></span> Class 2</div>\n        <div class=\"item muted\">Left-click: add/classify • Right-click: delete nearest point</div>\n      </div>\n\n      <div class=\"canvas-wrap\">\n        <canvas id=\"canvas\" width=\"960\" height=\"600\" aria-label=\"KNN canvas\"></canvas>\n        <div class=\"hint\">Tip: Toggle \"Decision boundary\" to see KNN partitions. Inverse-distance weighting lets closer neighbors influence more.</div>\n      </div>\n    </div>\n\n    <div class=\"right\">\n      <div class=\"panel\">\n        <h2>Classification Details</h2>\n        <div class=\"info\" id=\"infoSummary\">\n          Click the canvas in Classify mode to predict the label at that point.\n        </div>\n        <div class=\"kv\" id=\"infoDetails\"></div>\n      </div>\n      <div class=\"footer\">\n        KNN is a lazy, non-parametric method: it stores the dataset and classifies by majority vote among the k nearest training points.\n      </div>\n    </div>\n  </div>\n\n  <script>\n    (function() {\n      // Colors for up to 5 classes (we use 3 here)\n      const CLASS_COLORS = [\n        '#e74c3c', // red\n        '#3498db', // blue\n        '#2ecc71', // green\n        '#f39c12', // orange\n        '#9b59b6'  // purple\n      ];\n      const BG_COLOR = '#ffffff';\n      const GRID_STEP = 20; // px grid lines\n      const POINT_RADIUS = 6;\n      const NEIGHBOR_LINE_ALPHA = 0.35;\n      const DECISION_ALPHA = 0.16;\n      const DELETE_THRESHOLD = 14; // px\n\n      const canvas = document.getElementById('canvas');\n      const ctx = canvas.getContext('2d');\n\n      // Controls\n      const kRange = document.getElementById('kRange');\n      const kVal = document.getElementById('kVal');\n      const metricEuclidean = document.getElementById('metricEuclidean');\n      const metricManhattan = document.getElementById('metricManhattan');\n      const weightInvDist = document.getElementById('weightInvDist');\n      const showBoundary = document.getElementById('showBoundary');\n      const showNeighborLines = document.getElementById('showNeighborLines');\n      const snapOddK = document.getElementById('snapOddK');\n      const classSelect = document.getElementById('classSelect');\n      const modeAdd = document.getElementById('modeAdd');\n      const modeClassify = document.getElementById('modeClassify');\n      const btnSample = document.getElementById('btnSample');\n      const btnClear = document.getElementById('btnClear');\n\n      const infoSummary = document.getElementById('infoSummary');\n      const infoDetails = document.getElementById('infoDetails');\n\n      // State\n      let training = []; // {x, y, label}\n      let testPoint = null; // {x, y}\n      let lastResult = null; // classification result\n      let boundaryDirty = true;\n\n      // Utility to get mouse position\n      function getMousePos(evt) {\n        const rect = canvas.getBoundingClientRect();\n        const scaleX = canvas.width / rect.width;\n        const scaleY = canvas.height / rect.height;\n        return {\n          x: (evt.clientX - rect.left) * scaleX,\n          y: (evt.clientY - rect.top) * scaleY\n        };\n      }\n\n      function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }\n\n      function setKDisplay(val) {\n        kVal.textContent = String(val);\n      }\n\n      function currentK() {\n        let k = parseInt(kRange.value, 10);\n        if (snapOddK.checked && k % 2 === 0) {\n          // Snap to nearest odd number\n          k = (k === parseInt(kRange.max, 10)) ? k - 1 : k + 1;\n          kRange.value = String(k);\n        }\n        setKDisplay(k);\n        return k;\n      }\n\n      function metric() {\n        return metricEuclidean.checked ? 'euclidean' : 'manhattan';\n      }\n\n      function dist(a, b) {\n        if (metric() === 'euclidean') {\n          const dx = a.x - b.x, dy = a.y - b.y;\n          return Math.sqrt(dx*dx + dy*dy);\n        } else {\n          return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n        }\n      }\n\n      function classify(test, k, useInvDist) {\n        if (training.length === 0) return null;\n        k = Math.min(k, training.length);\n        if (k <= 0) return null;\n\n        // Compute all distances\n        const arr = training.map((p, idx) => ({ index: idx, label: p.label, d: dist(test, p) }));\n        arr.sort((a, b) => a.d - b.d);\n        const neighbors = arr.slice(0, k);\n\n        // Weighted or unweighted vote\n        const votes = new Map(); // label -> weight\n        neighbors.forEach(n => {\n          const w = useInvDist ? 1 / (n.d + 1e-9) : 1;\n          votes.set(n.label, (votes.get(n.label) || 0) + w);\n        });\n\n        // Determine predicted label, handling ties by nearest neighbor\n        let bestLabel = null;\n        let bestWeight = -Infinity;\n        votes.forEach((w, lbl) => {\n          if (w > bestWeight) {\n            bestWeight = w;\n            bestLabel = lbl;\n          } else if (w === bestWeight) {\n            // tie -> prefer label of nearest among neighbors\n            const nearestForLbl = neighbors.find(n => n.label === lbl);\n            const nearestForBest = neighbors.find(n => n.label === bestLabel);\n            if (nearestForLbl && nearestForBest && nearestForLbl.d < nearestForBest.d) {\n              bestLabel = lbl;\n            } else if (nearestForLbl && nearestForBest && nearestForLbl.d === nearestForBest.d) {\n              // still tie, prefer smaller label id\n              if (lbl < bestLabel) bestLabel = lbl;\n            }\n          }\n        });\n\n        return { neighbors, votes, label: bestLabel, kUsed: k };\n      }\n\n      function drawPoint(p, color, radius = POINT_RADIUS, outline = true) {\n        ctx.beginPath();\n        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);\n        ctx.fillStyle = color;\n        ctx.fill();\n        if (outline) {\n          ctx.lineWidth = 1.25;\n          ctx.strokeStyle = 'rgba(0,0,0,0.45)';\n          ctx.stroke();\n        }\n      }\n\n      function drawCross(p, color, size = 9, width = 2) {\n        ctx.save();\n        ctx.translate(p.x, p.y);\n        ctx.strokeStyle = color;\n        ctx.lineWidth = width;\n        ctx.beginPath();\n        ctx.moveTo(-size, 0); ctx.lineTo(size, 0);\n        ctx.moveTo(0, -size); ctx.lineTo(0, size);\n        ctx.stroke();\n        ctx.restore();\n      }\n\n      function drawNeighborLinesFromTest(result) {\n        if (!result || !testPoint || result.neighbors.length === 0) return;\n        ctx.save();\n        ctx.lineWidth = 1.5;\n        ctx.setLineDash([4, 3]);\n        result.neighbors.forEach(n => {\n          const p = training[n.index];\n          const color = CLASS_COLORS[p.label % CLASS_COLORS.length];\n          ctx.strokeStyle = hexToRgba(color, NEIGHBOR_LINE_ALPHA);\n          ctx.beginPath();\n          ctx.moveTo(testPoint.x, testPoint.y);\n          ctx.lineTo(p.x, p.y);\n          ctx.stroke();\n          // Halo around neighbor point\n          ctx.beginPath();\n          ctx.arc(p.x, p.y, POINT_RADIUS + 3, 0, Math.PI * 2);\n          ctx.strokeStyle = hexToRgba(color, 0.35);\n          ctx.setLineDash([]);\n          ctx.stroke();\n        });\n        ctx.restore();\n      }\n\n      function hexToRgba(hex, alpha) {\n        const c = hex.replace('#','');\n        const bigint = parseInt(c, 16);\n        const r = (bigint >> 16) & 255;\n        const g = (bigint >> 8) & 255;\n        const b = bigint & 255;\n        return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n      }\n\n      function clearCanvas() {\n        ctx.fillStyle = BG_COLOR;\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Background grid drawn by CSS; we keep canvas background clean\n      }\n\n      function drawDecisionBoundary() {\n        if (!showBoundary.checked) return;\n        if (training.length === 0) return;\n        const cell = 10; // resolution in pixels\n        ctx.save();\n        for (let y = cell/2; y < canvas.height; y += cell) {\n          for (let x = cell/2; x < canvas.width; x += cell) {\n            const res = classify({x, y}, currentK(), weightInvDist.checked);\n            if (!res) continue;\n            const color = hexToRgba(CLASS_COLORS[res.label % CLASS_COLORS.length], DECISION_ALPHA);\n            ctx.fillStyle = color;\n            ctx.fillRect(x - cell/2, y - cell/2, cell, cell);\n          }\n        }\n        ctx.restore();\n      }\n\n      function drawAll() {\n        clearCanvas();\n        // Decision boundary first so points overlay on top\n        drawDecisionBoundary();\n        // Training points\n        for (const p of training) {\n          const color = CLASS_COLORS[p.label % CLASS_COLORS.length];\n          drawPoint(p, color);\n        }\n        // Neighbor lines\n        if (showNeighborLines.checked && lastResult && testPoint) {\n          drawNeighborLinesFromTest(lastResult);\n        }\n        // Test point cross, and emphasized predicted region\n        if (testPoint) {\n          const color = lastResult ? CLASS_COLORS[lastResult.label % CLASS_COLORS.length] : '#111827';\n          drawCross(testPoint, color, 10, 2);\n          // small ring to indicate predicted class color\n          if (lastResult) {\n            ctx.beginPath();\n            ctx.arc(testPoint.x, testPoint.y, POINT_RADIUS + 5, 0, Math.PI * 2);\n            ctx.strokeStyle = hexToRgba(color, 0.65);\n            ctx.lineWidth = 2;\n            ctx.stroke();\n          }\n        }\n      }\n\n      function updateInfoPanel() {\n        if (!lastResult || !testPoint) {\n          infoSummary.textContent = 'Click the canvas in Classify mode to predict the label at that point.';\n          infoDetails.textContent = '';\n          return;\n        }\n        const kUsed = lastResult.kUsed;\n        const pred = lastResult.label;\n        const color = CLASS_COLORS[pred % CLASS_COLORS.length];\n\n        const votesStr = [...lastResult.votes.entries()]\n          .sort((a,b) => a[0]-b[0])\n          .map(([lbl, w]) => `Class ${lbl}: ${weightInvDist.checked ? w.toFixed(3) : w}`)\n          .join('\\n');\n\n        const neighborStr = lastResult.neighbors\n          .map((n, i) => {\n            const p = training[n.index];\n            const d = n.d.toFixed(2);\n            return `#${i+1}: Class ${p.label} at (${Math.round(p.x)}, ${Math.round(p.y)}) d=${d}`;\n          }).join('\\n');\n\n        infoSummary.innerHTML = `Predicted class: <span style=\"color:${color}; font-weight:600;\">${pred}</span> using k=${kUsed} (${metric()} distance${weightInvDist.checked ? ', inverse-distance weighting' : ''}).`;\n        infoDetails.textContent =\n`Votes:\n${votesStr}\n\nNearest ${kUsed} neighbors:\n${neighborStr}`;\n      }\n\n      function addPoint(pos, label) {\n        training.push({ x: clamp(pos.x, 0, canvas.width), y: clamp(pos.y, 0, canvas.height), label });\n        boundaryDirty = true;\n      }\n\n      function deleteNearest(pos) {\n        if (training.length === 0) return false;\n        let bestIdx = -1, bestDist = Infinity;\n        training.forEach((p, idx) => {\n          const d = dist(pos, p);\n          if (d < bestDist) {\n            bestDist = d; bestIdx = idx;\n          }\n        });\n        if (bestIdx >= 0 && bestDist <= DELETE_THRESHOLD) {\n          training.splice(bestIdx, 1);\n          boundaryDirty = true;\n          return true;\n        }\n        return false;\n      }\n\n      function onCanvasClick(evt) {\n        const pos = getMousePos(evt);\n        if (modeAdd.checked) {\n          addPoint(pos, parseInt(classSelect.value, 10));\n          // If a test point exists, update classification to reflect data change\n          if (testPoint) {\n            lastResult = classify(testPoint, currentK(), weightInvDist.checked);\n          }\n        } else {\n          testPoint = { x: pos.x, y: pos.y };\n          lastResult = classify(testPoint, currentK(), weightInvDist.checked);\n          updateInfoPanel();\n        }\n        drawAll();\n        evt.preventDefault();\n      }\n\n      function onCanvasRightClick(evt) {\n        evt.preventDefault();\n        const pos = getMousePos(evt);\n        const deleted = deleteNearest(pos);\n        if (deleted) {\n          if (testPoint) lastResult = classify(testPoint, currentK(), weightInvDist.checked);\n          updateInfoPanel();\n          drawAll();\n        }\n      }\n\n      function onKChange() {\n        const k = currentK();\n        if (testPoint) {\n          lastResult = classify(testPoint, k, weightInvDist.checked);\n          updateInfoPanel();\n        }\n        drawAll();\n      }\n\n      function onOptionChange() {\n        if (testPoint) {\n          lastResult = classify(testPoint, currentK(), weightInvDist.checked);\n          updateInfoPanel();\n        }\n        drawAll();\n      }\n\n      function sampleData() {\n        training = [];\n        const W = canvas.width, H = canvas.height;\n        // Three Gaussian blobs\n        const clusters = [\n          { cx: W*0.30, cy: H*0.35, label: 0, n: 35, spread: 55 },\n          { cx: W*0.65, cy: H*0.40, label: 1, n: 35, spread: 55 },\n          { cx: W*0.48, cy: H*0.70, label: 2, n: 30, spread: 60 }\n        ];\n        for (const c of clusters) {\n          for (let i=0; i<c.n; i++) {\n            const [dx, dy] = gaussian2D(c.spread);\n            addPoint({ x: c.cx + dx, y: c.cy + dy }, c.label);\n          }\n        }\n        // Remove occasional points outside bounds\n        training = training.filter(p => p.x >= 0 && p.x <= W && p.y >= 0 && p.y <= H);\n        boundaryDirty = true;\n        // Auto-place a test point\n        testPoint = { x: W*0.50, y: H*0.50 };\n        lastResult = classify(testPoint, currentK(), weightInvDist.checked);\n        updateInfoPanel();\n        drawAll();\n      }\n\n      function gaussian2D(spread) {\n        // Box-Muller transform\n        let u = 0, v = 0;\n        while (u === 0) u = Math.random();\n        while (v === 0) v = Math.random();\n        const r = Math.sqrt(-2.0 * Math.log(u));\n        const theta = 2.0 * Math.PI * v;\n        const z0 = r * Math.cos(theta);\n        const z1 = r * Math.sin(theta);\n        return [z0 * spread, z1 * spread];\n      }\n\n      function clearAll() {\n        training = [];\n        testPoint = null;\n        lastResult = null;\n        boundaryDirty = true;\n        infoSummary.textContent = 'Dataset cleared. Add points, then click Classify.';\n        infoDetails.textContent = '';\n        drawAll();\n      }\n\n      // Event listeners\n      canvas.addEventListener('click', onCanvasClick);\n      canvas.addEventListener('contextmenu', onCanvasRightClick);\n      kRange.addEventListener('input', onKChange);\n      snapOddK.addEventListener('change', onKChange);\n      metricEuclidean.addEventListener('change', onOptionChange);\n      metricManhattan.addEventListener('change', onOptionChange);\n      weightInvDist.addEventListener('change', onOptionChange);\n      showNeighborLines.addEventListener('change', drawAll);\n      showBoundary.addEventListener('change', drawAll);\n      classSelect.addEventListener('change', () => {});\n      modeAdd.addEventListener('change', () => {\n        infoSummary.textContent = 'Add points by left-clicking. Right-click to delete nearest point.';\n        infoDetails.textContent = '';\n      });\n      modeClassify.addEventListener('change', () => {\n        infoSummary.textContent = 'Click the canvas to classify that point.';\n        infoDetails.textContent = '';\n      });\n      btnSample.addEventListener('click', sampleData);\n      btnClear.addEventListener('click', clearAll);\n\n      // Initial draw\n      setKDisplay(parseInt(kRange.value, 10));\n      drawAll();\n\n      // Accessibility: keyboard shortcuts\n      window.addEventListener('keydown', (e) => {\n        if (e.key === 'b') {\n          showBoundary.checked = !showBoundary.checked;\n          drawAll();\n        } else if (e.key === 'l') {\n          showNeighborLines.checked = !showNeighborLines.checked;\n          drawAll();\n        } else if (e.key === 'k') {\n          let k = parseInt(kRange.value, 10);\n          k = clamp(k + (e.shiftKey ? -1 : 1), parseInt(kRange.min, 10), parseInt(kRange.max, 10));\n          kRange.value = String(k);\n          onKChange();\n        }\n      });\n\n      // Resize handling to keep crispness; keep fixed internal size and scale with CSS, so we don't need DPR scaling\n      window.addEventListener('resize', () => {\n        // No-op; CSS scales the canvas view, internal pixels remain constant\n      });\n\n    })();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "K-Nearest Neighbors (KNN)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  },
  {
    "id": "567add90-a371-11f0-ae43-3309dbaf0f79",
    "timestamp": "2025-10-07T11:32:42.602Z",
    "model": "gpt-5",
    "status": "success",
    "question": "K-Means Clustering",
    "answer": {
      "annotations": [],
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>K-Means Clustering Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <style>\n    :root {\n      --bg: #0f172a;\n      --panel: #111827;\n      --text: #e5e7eb;\n      --muted: #9ca3af;\n      --accent: #60a5fa;\n      --accent2: #34d399;\n      --danger: #ef4444;\n      --border: #1f2937;\n    }\n    * { box-sizing: border-box; }\n    body {\n      margin: 0;\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif;\n      background: radial-gradient(circle at 20% 20%, #0b1023, #0f172a 40%, #0b1225 100%);\n      color: var(--text);\n    }\n    header {\n      padding: 16px 24px;\n      border-bottom: 1px solid var(--border);\n      display: flex;\n      align-items: center;\n      gap: 18px;\n    }\n    header h1 {\n      margin: 0;\n      font-size: 20px;\n      font-weight: 600;\n    }\n    header .sub {\n      color: var(--muted);\n      font-size: 13px;\n    }\n    #wrap {\n      display: grid;\n      grid-template-columns: 320px 1fr;\n      gap: 16px;\n      padding: 16px;\n    }\n    #controls {\n      background: linear-gradient(180deg, rgba(17,24,39,0.9), rgba(17,24,39,0.6));\n      border: 1px solid var(--border);\n      border-radius: 12px;\n      padding: 14px 14px 4px 14px;\n      backdrop-filter: blur(6px);\n      position: sticky;\n      top: 16px;\n      height: fit-content;\n    }\n    #controls h2 {\n      margin: 0 0 10px 0;\n      font-size: 16px;\n      font-weight: 600;\n    }\n    .group {\n      margin: 10px 0 14px 0;\n      padding-bottom: 10px;\n      border-bottom: 1px dashed var(--border);\n    }\n    .row {\n      display: grid;\n      grid-template-columns: 1fr auto;\n      align-items: center;\n      gap: 10px;\n      margin: 8px 0;\n    }\n    label { font-size: 13px; color: var(--muted); }\n    select, input[type=\"number\"], input[type=\"text\"] {\n      width: 140px;\n      padding: 6px 8px;\n      border-radius: 8px;\n      border: 1px solid var(--border);\n      background: #0b1225;\n      color: var(--text);\n      outline: none;\n    }\n    input[type=\"range\"] { width: 140px; }\n    .buttons {\n      display: grid;\n      grid-template-columns: 1fr 1fr;\n      gap: 8px;\n      margin-top: 8px;\n    }\n    button {\n      padding: 8px 10px;\n      border-radius: 10px;\n      border: 1px solid var(--border);\n      background: #0b1225;\n      color: var(--text);\n      cursor: pointer;\n      transition: background 0.15s, transform 0.06s, border-color 0.15s;\n      font-weight: 600;\n    }\n    button:hover { background: #0e1530; border-color: #25324d; }\n    button:active { transform: translateY(1px); }\n    .primary { background: #10254d; border-color: #1e40af; }\n    .primary:hover { background: #0f2a5e; }\n    .danger { background: #2a0f12; border-color: #4c1d1d; }\n    .danger:hover { background: #3b1216; }\n    .togglebtn.active { background: #0f3a25; border-color: #14532d; color: #a7f3d0; }\n    .small {\n      font-size: 12px;\n      color: var(--muted);\n      margin-top: 6px;\n    }\n    .checkrow {\n      display: grid;\n      grid-template-columns: auto 1fr;\n      align-items: center;\n      gap: 8px;\n      margin: 6px 0;\n    }\n    .pill {\n      display: inline-block;\n      padding: 3px 8px;\n      border-radius: 999px;\n      background: #13203f;\n      border: 1px solid #1f3b74;\n      color: #9cc0ff;\n      font-size: 12px;\n      margin-right: 6px;\n    }\n    #canvasWrap {\n      position: relative;\n      background: radial-gradient(1200px 600px at 80% 20%, rgba(30,58,138,0.15), transparent 60%),\n                  radial-gradient(600px 600px at 20% 80%, rgba(6,78,59,0.15), transparent 70%);\n      border: 1px solid var(--border);\n      border-radius: 12px;\n      overflow: hidden;\n    }\n    canvas {\n      width: 100%;\n      height: 72vh;\n      display: block;\n      background:\n        linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)),\n        repeating-linear-gradient(0deg, rgba(255,255,255,0.03) 0, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 30px),\n        repeating-linear-gradient(90deg, rgba(255,255,255,0.03) 0, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 30px);\n    }\n    #stats {\n      position: absolute;\n      top: 8px;\n      left: 8px;\n      background: rgba(10,16,31,0.75);\n      border: 1px solid var(--border);\n      border-radius: 10px;\n      padding: 8px 10px;\n      font-size: 12px;\n      color: var(--text);\n      backdrop-filter: blur(4px);\n      pointer-events: none;\n    }\n    #legend {\n      position: absolute;\n      top: 8px;\n      right: 8px;\n      background: rgba(10,16,31,0.75);\n      border: 1px solid var(--border);\n      border-radius: 10px;\n      padding: 6px 8px;\n      font-size: 12px;\n      color: var(--text);\n      backdrop-filter: blur(4px);\n    }\n    .legendRow {\n      display: grid;\n      grid-template-columns: 22px 1fr;\n      align-items: center;\n      gap: 8px;\n      margin: 4px 0;\n    }\n    .swatch {\n      width: 16px;\n      height: 16px;\n      border-radius: 3px;\n      border: 1px solid rgba(255,255,255,0.2);\n    }\n    footer {\n      padding: 10px 16px 18px 16px;\n      color: var(--muted);\n      font-size: 12px;\n      text-align: center;\n    }\n    a { color: #93c5fd; text-decoration: none; }\n    a:hover { text-decoration: underline; }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>K-Means Clustering</h1>\n    <div class=\"sub\">Interactive visualization of iterative cluster assignment and centroid update</div>\n  </header>\n\n  <div id=\"wrap\">\n    <div id=\"controls\">\n      <h2>Setup</h2>\n      <div class=\"group\">\n        <div class=\"row\">\n          <label>Points</label>\n          <input id=\"pointsCount\" type=\"number\" min=\"10\" max=\"2000\" step=\"10\" value=\"400\">\n        </div>\n        <div class=\"row\">\n          <label>Distribution</label>\n          <select id=\"distSelect\">\n            <option value=\"blobs\">Gaussian blobs</option>\n            <option value=\"uniform\">Uniform random</option>\n          </select>\n        </div>\n        <div class=\"row\">\n          <label>K (clusters)</label>\n          <input id=\"kInput\" type=\"number\" min=\"1\" max=\"10\" step=\"1\" value=\"3\">\n        </div>\n        <div class=\"row\">\n          <label>Init method</label>\n          <select id=\"initSelect\">\n            <option value=\"forgy\">Forgy (random points)</option>\n            <option value=\"random\">Random positions</option>\n            <option value=\"kpp\">K-Means++</option>\n          </select>\n        </div>\n        <div class=\"row\">\n          <label>Seed (optional)</label>\n          <input id=\"seedInput\" type=\"text\" placeholder=\"e.g. 42\">\n        </div>\n        <div class=\"buttons\">\n          <button id=\"genBtn\">Generate Data</button>\n          <button id=\"initBtn\" class=\"primary\">Initialize K-Means</button>\n          <button id=\"iterBtn\" class=\"primary\">Run 1 Iteration</button>\n          <button id=\"autoBtn\" class=\"togglebtn\">Auto-Run</button>\n          <button id=\"resetBtn\" class=\"danger\">Reset</button>\n          <button id=\"clearBtn\" class=\"danger\">Clear Points</button>\n        </div>\n        <div class=\"small\">Tip: Enable \"Click to add points\" and click the canvas to add custom points.</div>\n      </div>\n\n      <h2>Display</h2>\n      <div class=\"group\">\n        <div class=\"checkrow\">\n          <input id=\"linesChk\" type=\"checkbox\" checked>\n          <label>Show lines from points to centroids</label>\n        </div>\n        <div class=\"checkrow\">\n          <input id=\"trailChk\" type=\"checkbox\" checked>\n          <label>Show centroid trails</label>\n        </div>\n        <div class=\"checkrow\">\n          <input id=\"addPtsChk\" type=\"checkbox\">\n          <label>Click to add points</label>\n        </div>\n        <div class=\"row\">\n          <label>Auto-run speed (ms)</label>\n          <input id=\"speedRange\" type=\"range\" min=\"50\" max=\"1000\" value=\"200\">\n        </div>\n      </div>\n\n      <h2>About</h2>\n      <div class=\"group\">\n        <div class=\"pill\">Assign</div>\n        <span class=\"small\">Assign each point to the nearest centroid.</span><br>\n        <div class=\"pill\">Update</div>\n        <span class=\"small\">Move each centroid to the mean of its assigned points.</span><br>\n        <div class=\"small\">Repeat until convergence (centroids stop moving or assignments stop changing).</div>\n      </div>\n    </div>\n\n    <div id=\"canvasWrap\">\n      <canvas id=\"canvas\"></canvas>\n      <div id=\"stats\">Iteration: <span id=\"iterOut\">0</span><br>\n        SSE (intra-cluster): <span id=\"sseOut\">—</span><br>\n        Converged: <span id=\"convOut\">No</span>\n      </div>\n      <div id=\"legend\"></div>\n    </div>\n  </div>\n\n  <footer>\n    Drag a centroid to reposition it. K-Means++ provides smarter initialization for faster convergence.\n  </footer>\n\n  <script>\n    // ========= Utility: PRNG and math helpers =========\n    function makePRNG(seedStr) {\n      if (!seedStr) return Math.random;\n      let seed = 0;\n      for (let i = 0; i < seedStr.length; i++) seed = (seed * 31 + seedStr.charCodeAt(i)) >>> 0;\n      let m = 0x80000000, a = 1103515245, c = 12345;\n      return function () { seed = (a * seed + c) % m; return seed / m; };\n    }\n    function randBoxMuller(rnd) {\n      let u = 0, v = 0;\n      while (u === 0) u = rnd(); // avoid 0\n      while (v === 0) v = rnd();\n      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n    }\n    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }\n    function dist2(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return dx * dx + dy * dy; }\n\n    // ========= Colors =========\n    const palette = [\n      \"#e74c3c\", \"#3498db\", \"#2ecc71\", \"#f1c40f\", \"#9b59b6\",\n      \"#e67e22\", \"#1abc9c\", \"#34495e\", \"#fd79a8\", \"#00cec9\"\n    ];\n    function colorFor(i) { return palette[i % palette.length]; }\n\n    // ========= Canvas setup (HiDPI) =========\n    const canvas = document.getElementById('canvas');\n    const ctx = canvas.getContext('2d');\n    function resizeCanvas() {\n      const ratio = window.devicePixelRatio || 1;\n      const rect = canvas.getBoundingClientRect();\n      canvas.width = Math.round(rect.width * ratio);\n      canvas.height = Math.round(rect.height * ratio);\n      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);\n      draw();\n    }\n    window.addEventListener('resize', resizeCanvas);\n\n    // ========= State =========\n    const state = {\n      points: [],\n      centroids: [],\n      centroidHistory: [], // arrays of positions per cluster\n      k: 3,\n      iteration: 0,\n      sse: null,\n      converged: false,\n      running: false,\n      draggingCentroid: null,\n      showLines: true,\n      showTrails: true,\n      addPointsMode: false,\n      rnd: Math.random\n    };\n\n    // ========= UI refs =========\n    const pointsCount = document.getElementById('pointsCount');\n    const distSelect = document.getElementById('distSelect');\n    const kInput = document.getElementById('kInput');\n    const initSelect = document.getElementById('initSelect');\n    const seedInput = document.getElementById('seedInput');\n    const genBtn = document.getElementById('genBtn');\n    const initBtn = document.getElementById('initBtn');\n    const iterBtn = document.getElementById('iterBtn');\n    const autoBtn = document.getElementById('autoBtn');\n    const resetBtn = document.getElementById('resetBtn');\n    const clearBtn = document.getElementById('clearBtn');\n\n    const linesChk = document.getElementById('linesChk');\n    const trailChk = document.getElementById('trailChk');\n    const addPtsChk = document.getElementById('addPtsChk');\n    const speedRange = document.getElementById('speedRange');\n\n    const iterOut = document.getElementById('iterOut');\n    const sseOut = document.getElementById('sseOut');\n    const convOut = document.getElementById('convOut');\n    const legend = document.getElementById('legend');\n\n    // ========= Data generation =========\n    function genUniform(n) {\n      const rect = canvas.getBoundingClientRect();\n      const w = rect.width, h = rect.height;\n      const margin = 20;\n      const points = [];\n      for (let i = 0; i < n; i++) {\n        points.push({ x: margin + state.rnd() * (w - 2 * margin), y: margin + state.rnd() * (h - 2 * margin), c: -1 });\n      }\n      return points;\n    }\n    function genBlobs(n, blobCount = 4) {\n      const rect = canvas.getBoundingClientRect();\n      const w = rect.width, h = rect.height;\n      const margin = 40;\n      const centers = [];\n      for (let b = 0; b < blobCount; b++) {\n        centers.push({\n          x: margin + state.rnd() * (w - 2 * margin),\n          y: margin + state.rnd() * (h - 2 * margin),\n          r: 20 + state.rnd() * 60\n        });\n      }\n      const points = [];\n      for (let i = 0; i < n; i++) {\n        const c = centers[Math.floor(state.rnd() * centers.length)];\n        const gx = randBoxMuller(state.rnd), gy = randBoxMuller(state.rnd);\n        const x = clamp(c.x + gx * c.r, margin, w - margin);\n        const y = clamp(c.y + gy * c.r, margin, h - margin);\n        points.push({ x, y, c: -1 });\n      }\n      return points;\n    }\n\n    // ========= Initialization methods =========\n    function initCentroids(method) {\n      const k = state.k;\n      state.centroidHistory = [];\n      if (state.points.length === 0 || k < 1) return;\n      const rect = canvas.getBoundingClientRect();\n      const w = rect.width, h = rect.height;\n\n      if (method === 'random') {\n        state.centroids = [];\n        for (let i = 0; i < k; i++) {\n          const cx = 20 + state.rnd() * (w - 40);\n          const cy = 20 + state.rnd() * (h - 40);\n          state.centroids.push({ x: cx, y: cy, color: colorFor(i) });\n          state.centroidHistory.push([{ x: cx, y: cy }]);\n        }\n      } else if (method === 'forgy') {\n        state.centroids = [];\n        const used = new Set();\n        for (let i = 0; i < k; i++) {\n          let idx;\n          do { idx = Math.floor(state.rnd() * state.points.length); } while (used.has(idx));\n          used.add(idx);\n          const p = state.points[idx];\n          state.centroids.push({ x: p.x, y: p.y, color: colorFor(i) });\n          state.centroidHistory.push([{ x: p.x, y: p.y }]);\n        }\n      } else if (method === 'kpp') {\n        // K-Means++ initialization\n        state.centroids = [];\n        let idx0 = Math.floor(state.rnd() * state.points.length);\n        let p0 = state.points[idx0];\n        state.centroids.push({ x: p0.x, y: p0.y, color: colorFor(0) });\n        state.centroidHistory.push([{ x: p0.x, y: p0.y }]);\n\n        while (state.centroids.length < k) {\n          // compute D(x)^2 for each point (distance to nearest chosen centroid)\n          let distances = [];\n          let sum = 0;\n          for (let i = 0; i < state.points.length; i++) {\n            const p = state.points[i];\n            let dmin = Infinity;\n            for (let c = 0; c < state.centroids.length; c++) {\n              const cc = state.centroids[c];\n              const d = dist2(p.x, p.y, cc.x, cc.y);\n              if (d < dmin) dmin = d;\n            }\n            distances[i] = dmin;\n            sum += dmin;\n          }\n          if (sum === 0) {\n            // All points identical; fallback to random\n            const rx = 20 + state.rnd() * (w - 40);\n            const ry = 20 + state.rnd() * (h - 40);\n            const ci = state.centroids.length;\n            state.centroids.push({ x: rx, y: ry, color: colorFor(ci) });\n            state.centroidHistory.push([{ x: rx, y: ry }]);\n            continue;\n          }\n          // choose next center proportional to D(x)^2\n          let r = state.rnd() * sum;\n          let cum = 0, chosen = 0;\n          for (let i = 0; i < distances.length; i++) {\n            cum += distances[i];\n            if (cum >= r) { chosen = i; break; }\n          }\n          const pp = state.points[chosen];\n          const ci = state.centroids.length;\n          state.centroids.push({ x: pp.x, y: pp.y, color: colorFor(ci) });\n          state.centroidHistory.push([{ x: pp.x, y: pp.y }]);\n        }\n      }\n      // reset\n      state.iteration = 0;\n      state.converged = false;\n      for (const p of state.points) p.c = -1;\n      updateLegend();\n      draw();\n    }\n\n    // ========= Algorithm steps =========\n    function assignPoints() {\n      if (state.centroids.length === 0) return { changed: false, sse: null };\n      let changed = false;\n      let sse = 0;\n      for (let i = 0; i < state.points.length; i++) {\n        const p = state.points[i];\n        let best = -1, bestD = Infinity;\n        for (let c = 0; c < state.centroids.length; c++) {\n          const cc = state.centroids[c];\n          const d = dist2(p.x, p.y, cc.x, cc.y);\n          if (d < bestD) { bestD = d; best = c; }\n        }\n        if (p.c !== best) { changed = true; p.c = best; }\n        sse += bestD;\n      }\n      state.sse = sse;\n      return { changed, sse };\n    }\n\n    function updateCentroids() {\n      const k = state.centroids.length;\n      if (k === 0) return { moved: false, emptyClusters: [] };\n\n      const sumX = new Array(k).fill(0);\n      const sumY = new Array(k).fill(0);\n      const count = new Array(k).fill(0);\n\n      for (const p of state.points) {\n        if (p.c >= 0) {\n          sumX[p.c] += p.x;\n          sumY[p.c] += p.y;\n          count[p.c] += 1;\n        }\n      }\n\n      const epsilon = 0.01; // movement threshold\n      let moved = false;\n      const emptyClusters = [];\n\n      const rect = canvas.getBoundingClientRect();\n      const w = rect.width, h = rect.height;\n\n      for (let c = 0; c < k; c++) {\n        let oldX = state.centroids[c].x;\n        let oldY = state.centroids[c].y;\n\n        if (count[c] > 0) {\n          const nx = sumX[c] / count[c];\n          const ny = sumY[c] / count[c];\n          const dx = nx - oldX, dy = ny - oldY;\n          if (dx * dx + dy * dy > epsilon * epsilon) moved = true;\n          state.centroids[c].x = nx;\n          state.centroids[c].y = ny;\n        } else {\n          // Handle empty cluster: re-seed randomly to encourage recovery\n          emptyClusters.push(c);\n          const rx = 20 + state.rnd() * (w - 40);\n          const ry = 20 + state.rnd() * (h - 40);\n          state.centroids[c].x = rx;\n          state.centroids[c].y = ry;\n          moved = true;\n        }\n        // Record history\n        if (state.centroidHistory[c]) {\n          state.centroidHistory[c].push({ x: state.centroids[c].x, y: state.centroids[c].y });\n          if (state.centroidHistory[c].length > 64) state.centroidHistory[c].shift();\n        }\n      }\n      return { moved, emptyClusters };\n    }\n\n    function runIteration() {\n      if (state.centroids.length === 0 || state.points.length === 0) return;\n      const assignResult = assignPoints();\n      const updateResult = updateCentroids();\n      state.iteration += 1;\n\n      // Convergence check: no assignment change and centroids did not move significantly\n      state.converged = !assignResult.changed && !updateResult.moved;\n\n      updateStats();\n      draw();\n      if (state.running && state.converged) {\n        toggleAutoRun(false);\n      }\n    }\n\n    // ========= Drawing =========\n    function drawGrid() {\n      const rect = canvas.getBoundingClientRect();\n      const w = rect.width, h = rect.height;\n      ctx.clearRect(0, 0, w, h);\n      // Subtle axes lines already added via CSS background\n    }\n\n    function drawPoints() {\n      ctx.lineWidth = 1.2;\n      for (const p of state.points) {\n        const cidx = p.c;\n        const color = cidx >= 0 ? colorFor(cidx) : \"rgba(255,255,255,0.6)\";\n        ctx.fillStyle = color;\n        ctx.strokeStyle = \"rgba(0,0,0,0.4)\";\n\n        ctx.beginPath();\n        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      if (state.showLines && state.centroids.length > 0) {\n        ctx.globalAlpha = 0.3;\n        for (const p of state.points) {\n          if (p.c >= 0) {\n            ctx.strokeStyle = colorFor(p.c);\n            ctx.beginPath();\n            ctx.moveTo(p.x, p.y);\n            ctx.lineTo(state.centroids[p.c].x, state.centroids[p.c].y);\n            ctx.stroke();\n          }\n        }\n        ctx.globalAlpha = 1;\n      }\n    }\n\n    function drawCentroids() {\n      for (let i = 0; i < state.centroids.length; i++) {\n        const c = state.centroids[i];\n        // Trail\n        if (state.showTrails && state.centroidHistory[i] && state.centroidHistory[i].length > 1) {\n          const trail = state.centroidHistory[i];\n          ctx.lineWidth = 2;\n          for (let t = 1; t < trail.length; t++) {\n            const alpha = 0.1 + 0.6 * (t / trail.length);\n            ctx.strokeStyle = hexWithAlpha(c.color, alpha);\n            ctx.beginPath();\n            ctx.moveTo(trail[t - 1].x, trail[t - 1].y);\n            ctx.lineTo(trail[t].x, trail[t].y);\n            ctx.stroke();\n          }\n        }\n        // Centroid marker\n        ctx.lineWidth = 2.2;\n        ctx.fillStyle = c.color;\n        ctx.strokeStyle = \"#111827\";\n        ctx.beginPath();\n        ctx.arc(c.x, c.y, 7, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.stroke();\n\n        // Crosshair\n        ctx.strokeStyle = \"rgba(255,255,255,0.25)\";\n        ctx.beginPath();\n        ctx.moveTo(c.x - 10, c.y);\n        ctx.lineTo(c.x + 10, c.y);\n        ctx.moveTo(c.x, c.y - 10);\n        ctx.lineTo(c.x, c.y + 10);\n        ctx.stroke();\n      }\n    }\n\n    function hexWithAlpha(hex, alpha) {\n      // hex like #rrggbb\n      const r = parseInt(hex.slice(1, 3), 16);\n      const g = parseInt(hex.slice(3, 5), 16);\n      const b = parseInt(hex.slice(5, 7), 16);\n      return `rgba(${r},${g},${b},${alpha})`;\n    }\n\n    function draw() {\n      drawGrid();\n      drawPoints();\n      drawCentroids();\n    }\n\n    function updateStats() {\n      iterOut.textContent = state.iteration;\n      sseOut.textContent = (state.sse != null ? Math.round(state.sse).toLocaleString() : \"—\");\n      convOut.textContent = state.converged ? \"Yes\" : \"No\";\n      convOut.style.color = state.converged ? \"#34d399\" : \"#e5e7eb\";\n    }\n\n    function updateLegend() {\n      legend.innerHTML = \"\";\n      for (let i = 0; i < state.k; i++) {\n        const div = document.createElement('div');\n        div.className = 'legendRow';\n        const sw = document.createElement('div');\n        sw.className = 'swatch';\n        sw.style.background = colorFor(i);\n        const label = document.createElement('div');\n        label.textContent = `Cluster ${i + 1}`;\n        div.appendChild(sw);\n        div.appendChild(label);\n        legend.appendChild(div);\n      }\n    }\n\n    // ========= Interactivity: drag centroids and add points =========\n    canvas.addEventListener('mousedown', (e) => {\n      const rect = canvas.getBoundingClientRect();\n      const mx = e.clientX - rect.left;\n      const my = e.clientY - rect.top;\n\n      if (state.addPointsMode) {\n        state.points.push({ x: mx, y: my, c: -1 });\n        state.converged = false;\n        state.sse = null;\n        draw();\n        return;\n      }\n\n      // Try to pick a centroid near the click\n      let picked = null;\n      for (let i = 0; i < state.centroids.length; i++) {\n        const c = state.centroids[i];\n        if (Math.hypot(mx - c.x, my - c.y) <= 12) { picked = i; break; }\n      }\n      if (picked != null) {\n        state.draggingCentroid = picked;\n      }\n    });\n    canvas.addEventListener('mousemove', (e) => {\n      if (state.draggingCentroid == null) return;\n      const rect = canvas.getBoundingClientRect();\n      const mx = e.clientX - rect.left;\n      const my = e.clientY - rect.top;\n      const c = state.centroids[state.draggingCentroid];\n      c.x = mx; c.y = my;\n      // record in history to show trail\n      state.centroidHistory[state.draggingCentroid].push({ x: mx, y: my });\n      if (state.centroidHistory[state.draggingCentroid].length > 64) state.centroidHistory[state.draggingCentroid].shift();\n      state.converged = false;\n      draw();\n    });\n    window.addEventListener('mouseup', () => {\n      if (state.draggingCentroid != null) {\n        state.draggingCentroid = null;\n        // recompute assignment after manual move\n        assignPoints();\n        updateStats();\n        draw();\n      }\n    });\n\n    // ========= Auto-run control =========\n    let timer = null;\n    function toggleAutoRun(forceState) {\n      const shouldRun = forceState != null ? forceState : !state.running;\n      state.running = shouldRun;\n      autoBtn.classList.toggle('active', state.running);\n      autoBtn.textContent = state.running ? \"Auto-Running…\" : \"Auto-Run\";\n      if (state.running) {\n        const speed = parseInt(speedRange.value);\n        if (timer) clearInterval(timer);\n        timer = setInterval(() => runIteration(), speed);\n      } else {\n        if (timer) {\n          clearInterval(timer);\n          timer = null;\n        }\n      }\n    }\n\n    // ========= Event bindings =========\n    genBtn.addEventListener('click', () => {\n      state.rnd = makePRNG(seedInput.value.trim());\n      const n = parseInt(pointsCount.value);\n      state.points = distSelect.value === 'uniform' ? genUniform(n) : genBlobs(n);\n      state.iteration = 0; state.sse = null; state.converged = false;\n      draw();\n    });\n\n    initBtn.addEventListener('click', () => {\n      state.k = clamp(parseInt(kInput.value), 1, palette.length);\n      initCentroids(initSelect.value);\n      // First assignment for visualization clarity\n      assignPoints();\n      updateStats();\n      draw();\n    });\n\n    iterBtn.addEventListener('click', () => runIteration());\n    autoBtn.addEventListener('click', () => toggleAutoRun());\n\n    resetBtn.addEventListener('click', () => {\n      toggleAutoRun(false);\n      state.points = [];\n      state.centroids = [];\n      state.centroidHistory = [];\n      state.iteration = 0;\n      state.sse = null;\n      state.converged = false;\n      updateStats();\n      draw();\n    });\n\n    clearBtn.addEventListener('click', () => {\n      for (const p of state.points) p.c = -1;\n      state.sse = null;\n      state.converged = false;\n      state.iteration = 0;\n      draw();\n    });\n\n    linesChk.addEventListener('change', () => { state.showLines = linesChk.checked; draw(); });\n    trailChk.addEventListener('change', () => { state.showTrails = trailChk.checked; draw(); });\n    addPtsChk.addEventListener('change', () => { state.addPointsMode = addPtsChk.checked; });\n\n    kInput.addEventListener('change', () => {\n      state.k = clamp(parseInt(kInput.value), 1, palette.length);\n      updateLegend();\n      draw();\n    });\n    speedRange.addEventListener('input', () => {\n      if (state.running) toggleAutoRun(true);\n    });\n\n    // ========= Initial boot =========\n    function boot() {\n      resizeCanvas();\n      state.rnd = makePRNG(seedInput.value.trim());\n      state.points = genBlobs(parseInt(pointsCount.value));\n      state.k = clamp(parseInt(kInput.value), 1, palette.length);\n      updateLegend();\n      initCentroids(initSelect.value);\n      assignPoints();\n      updateStats();\n      draw();\n    }\n    boot();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "role": "assistant"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "K-Means Clustering"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    }
  }
]