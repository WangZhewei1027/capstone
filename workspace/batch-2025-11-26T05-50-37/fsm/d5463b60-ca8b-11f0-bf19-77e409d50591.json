{
  "topic": "Array",
  "description": "Finite state machine modelling the interactive Array Playground web application: array creation, mutation operations, functional operations, custom code execution, and UI actions (show code, copy, download, clear output).",
  "states": [
    {
      "name": "idle",
      "onEnter": "renderArray",
      "onExit": "noop",
      "on": {
        "SET_ARRAY_CLICKED": "setting_array",
        "PRESET_SELECTED": "preset_selected",
        "RESET_CLICKED": "resetting",
        "PUSH_CLICKED": "pushing",
        "POP_CLICKED": "popping",
        "UNSHIFT_CLICKED": "unshifting",
        "SHIFT_CLICKED": "shifting",
        "SPLICE_APPLIED": "splicing",
        "SLICE_CLICKED": "slicing",
        "CONCAT_CLICKED": "concatenating",
        "REVERSE_CLICKED": "reversing",
        "SORT_CLICKED": "sorting",
        "FLAT_CLICKED": "flattening",
        "MAP_CLICKED": "mapping",
        "FILTER_CLICKED": "filtering",
        "REDUCE_CLICKED": "reducing",
        "FIND_CLICKED": "finding",
        "FIND_INDEX_CLICKED": "finding_index",
        "INCLUDES_CLICKED": "includes_check",
        "INDEX_OF_CLICKED": "indexof_check",
        "RUN_CUSTOM_CLICKED": "custom_running",
        "RUN_REPLACE_CLICKED": "custom_replacing",
        "SHOW_CODE_CLICKED": "code_view",
        "COPY_CODE_CLICKED": "copy_attempt",
        "DOWNLOAD_JSON_CLICKED": "downloading",
        "CLEAR_CONSOLE_CLICKED": "console_cleared"
      }
    },
    {
      "name": "setting_array",
      "onEnter": "parse JSON from #initInput; if Array then arr=parsed; renderArray; showOutput('Array set.')",
      "onExit": "noop",
      "on": {
        "COMPLETE": "array_updated",
        "ERROR": "error"
      }
    },
    {
      "name": "preset_selected",
      "onEnter": "set #initInput.value = selected preset value",
      "onExit": "noop",
      "on": {
        "COMPLETE": "idle"
      }
    },
    {
      "name": "resetting",
      "onEnter": "set #initInput to defaultInit; arr = JSON.parse(defaultInit) or []; renderArray; showOutput('Reset to default.')",
      "onExit": "noop",
      "on": {
        "COMPLETE": "array_updated",
        "ERROR": "error"
      }
    },
    {
      "name": "pushing",
      "onEnter": "v = parseValue(#pushVal.value); arr.push(v); renderArray; showOutput('push -> ' + JSON.stringify(v))",
      "onExit": "noop",
      "on": {
        "COMPLETE": "array_updated",
        "ERROR": "error"
      }
    },
    {
      "name": "popping",
      "onEnter": "v = arr.pop(); renderArray; showOutput('pop -> ' + JSON.stringify(v))",
      "onExit": "noop",
      "on": {
        "COMPLETE": "array_updated",
        "ERROR": "error"
      }
    },
    {
      "name": "unshifting",
      "onEnter": "v = parseValue(#unshiftVal.value); arr.unshift(v); renderArray; showOutput('unshift -> ' + JSON.stringify(v))",
      "onExit": "noop",
      "on": {
        "COMPLETE": "array_updated",
        "ERROR": "error"
      }
    },
    {
      "name": "shifting",
      "onEnter": "v = arr.shift(); renderArray; showOutput('shift -> ' + JSON.stringify(v))",
      "onExit": "noop",
      "on": {
        "COMPLETE": "array_updated",
        "ERROR": "error"
      }
    },
    {
      "name": "splicing",
      "onEnter": "start = Number(#spliceStart.value)||0; del = Number(#spliceDel.value)||0; items = parseCSVItems(#spliceItems.value); removed = arr.splice(start,del,...items); renderArray; showOutput('splice removed: '+JSON.stringify(removed))",
      "onExit": "noop",
      "on": {
        "COMPLETE": "array_updated",
        "ERROR": "error"
      }
    },
    {
      "name": "slicing",
      "onEnter": "start = (#sliceStart.value === '' ? undefined : Number(#sliceStart.value)); end = (#sliceEnd.value === '' ? undefined : Number(#sliceEnd.value)); res = arr.slice(start,end); showOutput('slice result: '+JSON.stringify(res))",
      "onExit": "noop",
      "on": {
        "COMPLETE": "idle",
        "ERROR": "error"
      }
    },
    {
      "name": "concatenating",
      "onEnter": "text = #concatVal.value.trim(); parse; arr = arr.concat(toConcat); renderArray; showOutput('concat applied.')",
      "onExit": "noop",
      "on": {
        "COMPLETE": "array_updated",
        "ERROR": "error"
      }
    },
    {
      "name": "reversing",
      "onEnter": "arr.reverse(); renderArray(); showOutput('reverse applied.')",
      "onExit": "noop",
      "on": {
        "COMPLETE": "array_updated",
        "ERROR": "error"
      }
    },
    {
      "name": "sorting",
      "onEnter": "expr = #sortExpr.value.trim(); if (!expr||expr==='alpha') arr.sort(); else cmp = safeEvalFunction(expr,['a','b']); arr.sort(cmp); renderArray(); showOutput('sort applied.')",
      "onExit": "noop",
      "on": {
        "COMPLETE": "array_updated",
        "ERROR": "error"
      }
    },
    {
      "name": "flattening",
      "onEnter": "d = Number(#flatDepth.value); arr = arr.flat(Number.isFinite(d)?d:1); renderArray(); showOutput('flat('+d+') applied.')",
      "onExit": "noop",
      "on": {
        "COMPLETE": "array_updated",
        "ERROR": "error"
      }
    },
    {
      "name": "mapping",
      "onEnter": "expr = #mapExpr.value; replace = #mapReplace.checked; fn = safeEvalFunction(expr,['x','i','arr']); res = arr.map(fn); showOutput('map result: '+JSON.stringify(res)); if (replace){arr=res; renderArray(); showOutput('map replaced array.');}",
      "onExit": "noop",
      "on": {
        "COMPLETE": "array_updated",
        "ERROR": "error",
        "NO_REPLACE_COMPLETE": "idle"
      }
    },
    {
      "name": "filtering",
      "onEnter": "expr = #filterExpr.value; replace = #filterReplace.checked; fn = safeEvalFunction(expr,['x','i','arr']); res = arr.filter(fn); showOutput('filter result: '+JSON.stringify(res)); if (replace){arr=res; renderArray(); showOutput('filter replaced array.');}",
      "onExit": "noop",
      "on": {
        "COMPLETE": "array_updated",
        "ERROR": "error",
        "NO_REPLACE_COMPLETE": "idle"
      }
    },
    {
      "name": "reducing",
      "onEnter": "expr = #reduceExpr.value; initTxt = #reduceInit.value; fn = safeEvalFunction(expr,['acc','x','i','arr']); init = initTxt===''?undefined:parseValue(initTxt); res = Array.prototype.reduce.call(arr,fn,init); showOutput('reduce result: '+JSON.stringify(res))",
      "onExit": "noop",
      "on": {
        "COMPLETE": "idle",
        "ERROR": "error"
      }
    },
    {
      "name": "finding",
      "onEnter": "txt = #findExpr.value; if (txt.includes('=>')) {fn = safeEvalFunction(txt,[]); r = arr.find(fn);} else {val = parseValue(txt); r = arr.find(x => deepEqual(x,val));} showOutput('find -> '+JSON.stringify(r))",
      "onExit": "noop",
      "on": {
        "COMPLETE": "idle",
        "ERROR": "error"
      }
    },
    {
      "name": "finding_index",
      "onEnter": "txt = #findExpr.value; if (txt.includes('=>')) {fn = safeEvalFunction(txt,[]); idx = arr.findIndex(fn);} else {val = parseValue(txt); idx = arr.findIndex(x => deepEqual(x,val));} showOutput('findIndex -> '+idx)",
      "onExit": "noop",
      "on": {
        "COMPLETE": "idle",
        "ERROR": "error"
      }
    },
    {
      "name": "includes_check",
      "onEnter": "txt = #findExpr.value; val = parseValue(txt); yes = arr.some(x => deepEqual(x,val)); showOutput('includes -> '+yes)",
      "onExit": "noop",
      "on": {
        "COMPLETE": "idle",
        "ERROR": "error"
      }
    },
    {
      "name": "indexof_check",
      "onEnter": "txt = #findExpr.value; val = parseValue(txt); idx = arr.findIndex(x => deepEqual(x,val)); showOutput('indexOf (deep) -> '+idx)",
      "onExit": "noop",
      "on": {
        "COMPLETE": "idle",
        "ERROR": "error"
      }
    },
    {
      "name": "custom_running",
      "onEnter": "code = #customCode.value; arrCopy = arr.slice(); fn = new Function('arr','return (function(){ try { return ' + code + '} catch(e){ throw e } })();'); res = fn(arrCopy); showOutput('result: '+JSON.stringify(res))",
      "onExit": "noop",
      "on": {
        "COMPLETE": "idle",
        "ERROR": "error"
      }
    },
    {
      "name": "custom_replacing",
      "onEnter": "code = #customCode.value; arrCopy = arr.slice(); fn = new Function('arr','return (function(){ try { return ' + code + '} catch(e){ throw e } })();'); res = fn(arrCopy); if (!Array.isArray(res)){ showOutput('Replace aborted: result is not an array', true); } else { arr = res; renderArray(); showOutput('Array replaced by custom result.'); }",
      "onExit": "noop",
      "on": {
        "COMPLETE": "array_updated",
        "ERROR": "error",
        "REJECTED_REPLACE": "idle"
      }
    },
    {
      "name": "code_view",
      "onEnter": "document.getElementById('codeView').textContent = 'const arr = ' + JSON.stringify(arr, null, 2) + ';'; showOutput('Code updated.')",
      "onExit": "noop",
      "on": {
        "COMPLETE": "idle"
      }
    },
    {
      "name": "copy_attempt",
      "onEnter": "txt = 'const arr = ' + JSON.stringify(arr, null, 2) + ';'; navigator.clipboard?.writeText(txt).then(()=> showOutput('Code copied to clipboard.'), ()=> showOutput('Copy failed.', true))",
      "onExit": "noop",
      "on": {
        "COMPLETE": "idle",
        "ERROR": "error"
      }
    },
    {
      "name": "downloading",
      "onEnter": "data = JSON.stringify(arr, null, 2); create blob and trigger download 'array.json'; showOutput('Downloaded array.json')",
      "onExit": "noop",
      "on": {
        "COMPLETE": "idle",
        "ERROR": "error"
      }
    },
    {
      "name": "console_cleared",
      "onEnter": "document.getElementById('output').textContent = ''; document.getElementById('output').style.background='#0f172a'; document.getElementById('output').style.color='#fff';",
      "onExit": "noop",
      "on": {
        "COMPLETE": "idle"
      }
    },
    {
      "name": "array_updated",
      "onEnter": "renderArray",
      "onExit": "noop",
      "on": {
        "IDLE": "idle"
      }
    },
    {
      "name": "result_shown",
      "onEnter": "showOutput (operation-specific result)",
      "onExit": "noop",
      "on": {
        "IDLE": "idle"
      }
    },
    {
      "name": "error",
      "onEnter": "showOutput(errorMessage, true)",
      "onExit": "noop",
      "on": {
        "IDLE": "idle"
      }
    }
  ],
  "events": [
    "SET_ARRAY_CLICKED",
    "PRESET_SELECTED",
    "RESET_CLICKED",
    "PUSH_CLICKED",
    "POP_CLICKED",
    "UNSHIFT_CLICKED",
    "SHIFT_CLICKED",
    "SPLICE_APPLIED",
    "SLICE_CLICKED",
    "CONCAT_CLICKED",
    "REVERSE_CLICKED",
    "SORT_CLICKED",
    "FLAT_CLICKED",
    "MAP_CLICKED",
    "FILTER_CLICKED",
    "REDUCE_CLICKED",
    "FIND_CLICKED",
    "FIND_INDEX_CLICKED",
    "INCLUDES_CLICKED",
    "INDEX_OF_CLICKED",
    "RUN_CUSTOM_CLICKED",
    "RUN_REPLACE_CLICKED",
    "SHOW_CODE_CLICKED",
    "COPY_CODE_CLICKED",
    "DOWNLOAD_JSON_CLICKED",
    "CLEAR_CONSOLE_CLICKED",
    "COMPLETE",
    "ERROR",
    "ALL_SELECTORS"
  ],
  "triggers": {
    "SET_ARRAY_CLICKED": "#setArrayBtn",
    "PRESET_SELECTED": "#presetSelect",
    "RESET_CLICKED": "#resetBtn",
    "PUSH_CLICKED": "#pushBtn",
    "POP_CLICKED": "#popBtn",
    "UNSHIFT_CLICKED": "#unshiftBtn",
    "SHIFT_CLICKED": "#shiftBtn",
    "SPLICE_APPLIED": "#spliceBtn",
    "SLICE_CLICKED": "#sliceBtn",
    "CONCAT_CLICKED": "#concatBtn",
    "REVERSE_CLICKED": "#reverseBtn",
    "SORT_CLICKED": "#sortBtn",
    "FLAT_CLICKED": "#flatBtn",
    "MAP_CLICKED": "#mapBtn",
    "FILTER_CLICKED": "#filterBtn",
    "REDUCE_CLICKED": "#reduceBtn",
    "FIND_CLICKED": "#findBtn",
    "FIND_INDEX_CLICKED": "#findIndexBtn",
    "INCLUDES_CLICKED": "#includesBtn",
    "INDEX_OF_CLICKED": "#indexOfBtn",
    "RUN_CUSTOM_CLICKED": "#runCustom",
    "RUN_REPLACE_CLICKED": "#runReplace",
    "SHOW_CODE_CLICKED": "#showCodeBtn",
    "COPY_CODE_CLICKED": "#copyCode",
    "DOWNLOAD_JSON_CLICKED": "#downloadJson",
    "CLEAR_CONSOLE_CLICKED": "#clearConsole",
    "ALL_SELECTORS": "#initInput, #setArrayBtn, #resetBtn, #presetSelect, #arrayVis, #metaInfo, #pushVal, #pushBtn, #popBtn, #unshiftVal, #unshiftBtn, #shiftBtn, #spliceStart, #spliceDel, #spliceItems, #spliceBtn, #sliceStart, #sliceEnd, #sliceBtn, #concatVal, #concatBtn, #reverseBtn, #sortExpr, #sortBtn, #flatDepth, #flatBtn, #mapExpr, #mapBtn, #mapReplace, #filterExpr, #filterBtn, #filterReplace, #reduceExpr, #reduceInit, #reduceBtn, #findExpr, #findBtn, #findIndexBtn, #includesBtn, #indexOfBtn, #customCode, #runCustom, #runReplace, #showCodeBtn, #clearConsole, #output, #codeView, #copyCode, #downloadJson, #lenInfo, #firstInfo, #lastInfo, .ghost, .secondary, .array-visual, .cell, .idx, .type, .meta, .result, .small, .card, .controls, .ops-grid"
  },
  "notes": "triggers maps user actions (click/change) to exact DOM selectors found in the HTML. States encode synchronous JS actions invoked on those events (parse, mutating methods, safeEvalFunction, renderArray, showOutput). Internal flow events include COMPLETE and ERROR to represent success/failure transitions. The ALL_SELECTORS entry lists all relevant IDs and classes discovered in the markup."
}