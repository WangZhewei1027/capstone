{
  "id": "d5466271-ca8b-11f0-bf19-77e409d50591",
  "timestamp": "2025-11-26T05:53:44.975Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Stack",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<title>Stack Visualizer</title>\n<style>\n  :root{\n    --bg:#0f1724;\n    --card:#0b1220;\n    --accent:#06b6d4;\n    --muted:#94a3b8;\n    --glass: rgba(255,255,255,0.03);\n    --success: #10b981;\n    --danger: #ef4444;\n  }\n  *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;}\n  body{margin:0;background:linear-gradient(180deg,#071028 0%,#081428 60%);color:#e6eef6;min-height:100vh;display:flex;align-items:flex-start;justify-content:center;padding:28px;}\n  .container{width:1100px;max-width:100%;display:grid;grid-template-columns:360px 1fr;gap:20px;}\n  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);box-shadow: 0 6px 30px rgba(2,6,23,0.6);}\n  h1{margin:0 0 8px 0;font-size:20px;}\n  .muted{color:var(--muted);font-size:13px;margin-bottom:6px;}\n  label{display:block;font-size:13px;margin-top:10px;margin-bottom:6px;color:var(--muted);}\n  .controls{display:flex;gap:8px;flex-wrap:wrap;}\n  input[type=\"text\"], input[type=\"number\"], select{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:var(--card);color:inherit;min-width:0;}\n  button{background:var(--accent);border:none;color:#012;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600;}\n  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600;}\n  button.warn{background:var(--danger);color:white;}\n  button.small{padding:6px 8px;font-size:13px;border-radius:6px;}\n  .stack-area{display:flex;gap:20px;align-items:flex-start;height:560px;}\n  .visual{flex:1;display:flex;flex-direction:column;align-items:center;padding:12px;justify-content:center;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:10px;}\n  .stack-visual{width:220px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));border-radius:8px;padding:12px;border:1px dashed rgba(255,255,255,0.03);min-height:420px;display:flex;flex-direction:column-reverse;align-items:center;justify-content:flex-start;position:relative;overflow:hidden;}\n  .slot{width:86%;height:48px;margin:6px 0;border-radius:8px;background:var(--glass);display:flex;align-items:center;justify-content:center;color:var(--muted);border:1px solid rgba(255,255,255,0.03);position:relative;transform:translateY(0);transition:transform 300ms ease, background 250ms ease, opacity 250ms ease;}\n  .slot.filled{background:linear-gradient(90deg, rgba(6,182,212,0.12), rgba(6,182,212,0.06));color:#dff8fb;border-color:rgba(6,182,212,0.15);font-weight:700;}\n  .slot.top{box-shadow:0 8px 30px rgba(6,182,212,0.08);border-color:rgba(6,182,212,0.28);}\n  .slot .index{position:absolute;left:8px;font-size:12px;color:var(--muted);}\n  .slot .value{font-size:15px;}\n  .label-top{position:absolute;right:8px;top:12px;background:rgba(255,255,255,0.03);padding:4px 8px;border-radius:8px;font-size:12px;color:var(--muted);}\n  .info{width:320px;padding:12px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));}\n  .stat{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;margin:6px 0;background:rgba(255,255,255,0.01);font-size:13px;}\n  .log{height:200px;overflow:auto;background:rgba(0,0,0,0.06);padding:8px;border-radius:8px;margin-top:10px;font-size:13px;}\n  .controls-row{display:flex;gap:8px;align-items:center;margin-top:6px;flex-wrap:wrap;}\n  .mode-toggle{display:flex;gap:8px;}\n  .mode-toggle button{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:6px 8px;border-radius:8px;}\n  .mode-toggle button.active{background:rgba(255,255,255,0.03);color:var(--accent);border-color:rgba(6,182,212,0.18);}\n  .footer{margin-top:12px;font-size:13px;color:var(--muted);line-height:1.4;}\n  .pseudocode{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;margin-top:10px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:13px;}\n  .time-table{display:flex;gap:8px;margin-top:10px;}\n  .time-card{flex:1;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px;}\n  .history-controls{display:flex;gap:6px;align-items:center;margin-top:8px;}\n  .badge{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:999px;font-size:12px;color:var(--muted);}\n  .node{display:flex;align-items:center;gap:8px;background:linear-gradient(90deg, rgba(99,102,241,0.06), rgba(99,102,241,0.03));padding:8px;border-radius:8px;border:1px solid rgba(99,102,241,0.06);}\n  .arrow{width:20px;height:2px;background:linear-gradient(90deg,var(--muted),transparent);position:relative;}\n  .arrow::after{content:\"\";position:absolute;right:0;top:-4px;border-left:8px solid var(--muted);border-top:6px solid transparent;border-bottom:6px solid transparent;}\n  .linked-list-area{display:flex;gap:12px;align-items:center;flex-wrap:wrap;justify-content:center;padding:12px;}\n  .small-muted{font-size:12px;color:var(--muted);}\n  .ops-row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;}\n  @media (max-width:980px){\n    .container{grid-template-columns:1fr;align-items:center;}\n    .stack-area{height:auto}\n  }\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <div class=\"card\">\n    <h1>Stack — Visualizer & Playground</h1>\n    <div class=\"muted\">Interactive demonstration of a Stack (LIFO). Try pushing, popping, peeking, and step through the operation history. Switch between array-backed and linked-list implementations.</div>\n\n    <label>Implementation</label>\n    <div class=\"mode-toggle\" id=\"modeToggle\">\n      <button data-mode=\"array\" class=\"active\">Array-backed</button>\n      <button data-mode=\"linked\">Linked-list</button>\n    </div>\n\n    <label>Value to push</label>\n    <div style=\"display:flex;gap:8px;\">\n      <input id=\"valueInput\" type=\"text\" placeholder=\"e.g. 42 or hello\" />\n      <button id=\"pushBtn\">Push</button>\n      <button id=\"popBtn\" class=\"warn\">Pop</button>\n    </div>\n\n    <div class=\"controls-row\">\n      <button id=\"peekBtn\" class=\"ghost small\">Peek</button>\n      <button id=\"clearBtn\" class=\"ghost small\">Clear</button>\n      <button id=\"randBtn\" class=\"ghost small\">Push Random</button>\n      <input id=\"capInput\" type=\"number\" placeholder=\"Capacity (0=∞)\" style=\"width:120px\" min=\"0\"/>\n    </div>\n\n    <label>Batch / Simulation</label>\n    <div class=\"controls-row\">\n      <input id=\"bulkInput\" type=\"number\" placeholder=\"How many randoms?\" style=\"width:130px\"/>\n      <button id=\"bulkPush\" class=\"small\">Push Many</button>\n      <button id=\"autoDemo\" class=\"small\">Auto Demo (5 ops)</button>\n    </div>\n\n    <label>History / Step-through</label>\n    <div class=\"history-controls\">\n      <button id=\"stepPrev\" class=\"small ghost\">Prev</button>\n      <button id=\"stepNext\" class=\"small ghost\">Next</button>\n      <div class=\"badge\" id=\"stepBadge\">Step 0 / 0</div>\n      <div style=\"flex:1\"></div>\n      <button id=\"undoBtn\" class=\"small ghost\">Undo Last</button>\n    </div>\n\n    <div class=\"footer\">\n      <div class=\"small-muted\" style=\"margin-top:8px\">Stack supports push (add to top), pop (remove top), peek (view top). LIFO = Last In First Out.</div>\n    </div>\n  </div>\n\n  <div class=\"card\">\n    <div class=\"stack-area\">\n      <div class=\"visual\">\n        <div style=\"display:flex;gap:12px;align-items:center;width:100%;justify-content:center;margin-bottom:6px;\">\n          <div class=\"label-top\">Top</div>\n          <div class=\"small-muted\">Capacity: <span id=\"capBadge\">∞</span></div>\n          <div style=\"width:6px\"></div>\n          <div class=\"small-muted\">Size: <strong id=\"sizeBadge\">0</strong></div>\n        </div>\n\n        <div class=\"stack-visual\" id=\"stackVisual\" aria-live=\"polite\" aria-label=\"Stack visualization\">\n          <!-- slots generated by JS -->\n        </div>\n      </div>\n\n      <div class=\"info\">\n        <div class=\"stat\"><div>Implementation</div><div id=\"implBadge\" style=\"color:var(--accent);font-weight:700\">Array-backed</div></div>\n        <div class=\"stat\"><div>Top element</div><div id=\"topBadge\" class=\"small-muted\">—</div></div>\n        <div class=\"stat\"><div>Operations performed</div><div id=\"opsBadge\" class=\"small-muted\">0</div></div>\n\n        <div class=\"log\" id=\"opLog\"></div>\n\n        <div class=\"pseudocode\">\n          <div style=\"font-weight:700;margin-bottom:6px\">Pseudocode</div>\n          <div style=\"font-family:ui-monospace,monospace;font-size:13px\">\n            push(x): if size == capacity => overflow else array[size++] = x<br/>\n            pop(): if size == 0 => underflow else return array[--size]<br/>\n            peek(): return array[size-1]\n          </div>\n        </div>\n\n        <div class=\"time-table\">\n          <div class=\"time-card\">\n            <div style=\"font-weight:700\">Time (avg)</div>\n            <div style=\"margin-top:6px\" class=\"small-muted\">push: O(1)</div>\n            <div class=\"small-muted\">pop: O(1)</div>\n            <div class=\"small-muted\">peek: O(1)</div>\n          </div>\n          <div class=\"time-card\">\n            <div style=\"font-weight:700\">Notes</div>\n            <div class=\"small-muted\" style=\"margin-top:6px\">Array-backed stacks can be fixed-capacity or dynamically resized; linked-list stacks use nodes and pointers (no preallocated capacity).</div>\n          </div>\n        </div>\n\n        <div style=\"margin-top:10px\">\n          <div style=\"font-weight:700;margin-bottom:6px\">Linked-list view</div>\n          <div class=\"linked-list-area\" id=\"linkedArea\" style=\"min-height:64px\">\n            <!-- nodes shown when in linked mode -->\n          </div>\n        </div>\n\n      </div>\n    </div>\n  </div>\n</div>\n\n<script>\n/*\nStack Visualizer\n- Two implementations: array-backed (with capacity) and linked-list.\n- Supports push, pop, peek, clear, random, batch push, undo, and stepping through history.\n- Visualization shows vertical stack (top at top) and linked-list nodes when selected.\n*/\n(function(){\n  // DOM elements\n  const modeToggle = document.getElementById('modeToggle');\n  const buttons = modeToggle.querySelectorAll('button');\n  const valueInput = document.getElementById('valueInput');\n  const pushBtn = document.getElementById('pushBtn');\n  const popBtn = document.getElementById('popBtn');\n  const peekBtn = document.getElementById('peekBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const randBtn = document.getElementById('randBtn');\n  const capInput = document.getElementById('capInput');\n  const bulkInput = document.getElementById('bulkInput');\n  const bulkPush = document.getElementById('bulkPush');\n  const autoDemo = document.getElementById('autoDemo');\n  const stackVisual = document.getElementById('stackVisual');\n  const sizeBadge = document.getElementById('sizeBadge');\n  const topBadge = document.getElementById('topBadge');\n  const opsBadge = document.getElementById('opsBadge');\n  const opLog = document.getElementById('opLog');\n  const capBadge = document.getElementById('capBadge');\n  const implBadge = document.getElementById('implBadge');\n  const linkedArea = document.getElementById('linkedArea');\n  const stepPrev = document.getElementById('stepPrev');\n  const stepNext = document.getElementById('stepNext');\n  const stepBadge = document.getElementById('stepBadge');\n  const undoBtn = document.getElementById('undoBtn');\n\n  // State\n  let mode = 'array'; // or 'linked'\n  let capacity = Infinity;\n  let arrayStack = []; // underlying array representation\n  let linkedStack = null; // linked-list head (node: {value, next})\n  let opsCount = 0;\n\n  // History for stepping and undo (stores snapshots)\n  const history = [];\n  let historyIndex = -1; // points to current snapshot\n\n  function push(value){\n    if(mode === 'array'){\n      if(arrayStack.length >= capacity){\n        log('push('+value+') => Overflow (capacity reached)', true);\n        flash('warn');\n        return false;\n      }\n      arrayStack.push(value);\n    } else {\n      // linked-list push: create new head\n      const node = {value: value, next: linkedStack};\n      linkedStack = node;\n    }\n    opsCount++;\n    log('push('+value+')');\n    saveSnapshot('push', value);\n    update();\n    return true;\n  }\n\n  function pop(){\n    if(mode === 'array'){\n      if(arrayStack.length === 0){\n        log('pop() => Underflow (empty)', true);\n        flash('warn');\n        return null;\n      }\n      const v = arrayStack.pop();\n      opsCount++;\n      log('pop() => ' + v);\n      saveSnapshot('pop', v);\n      update();\n      return v;\n    } else {\n      if(!linkedStack){\n        log('pop() => Underflow (empty)', true);\n        flash('warn');\n        return null;\n      }\n      const v = linkedStack.value;\n      linkedStack = linkedStack.next;\n      opsCount++;\n      log('pop() => ' + v);\n      saveSnapshot('pop', v);\n      update();\n      return v;\n    }\n  }\n\n  function peek(){\n    let v = null;\n    if(mode === 'array'){\n      if(arrayStack.length === 0){\n        log('peek() => empty', true);\n        return null;\n      }\n      v = arrayStack[arrayStack.length - 1];\n    } else {\n      if(!linkedStack){\n        log('peek() => empty', true);\n        return null;\n      }\n      v = linkedStack.value;\n    }\n    log('peek() => ' + v);\n    flash('peek');\n    return v;\n  }\n\n  function clearAll(){\n    arrayStack = [];\n    linkedStack = null;\n    opsCount = 0;\n    log('clear()');\n    saveSnapshot('clear', null);\n    update();\n  }\n\n  function saveSnapshot(action, value){\n    // store a deep representation for stepping/undo\n    const snapshot = {\n      mode,\n      capacity: isFinite(capacity) ? capacity : 0,\n      array: arrayStack.slice(),\n      linked: cloneLinked(linkedStack),\n      opsCount,\n      action,\n      value,\n      timestamp: Date.now()\n    };\n    // If we are in the middle of history and perform a new action, truncate future\n    if(historyIndex < history.length - 1){\n      history.splice(historyIndex + 1);\n    }\n    history.push(snapshot);\n    historyIndex = history.length - 1;\n    updateStepBadge();\n  }\n\n  function cloneLinked(node){\n    if(!node) return null;\n    return {value: node.value, next: cloneLinked(node.next)};\n  }\n\n  function restoreSnapshot(idx){\n    const s = history[idx];\n    if(!s) return;\n    mode = s.mode;\n    // apply mode toggle UI\n    setMode(mode, false);\n    arrayStack = s.array.slice();\n    linkedStack = cloneLinked(s.linked);\n    opsCount = s.opsCount;\n    capacity = s.capacity === 0 ? Infinity : s.capacity;\n    capBadge.textContent = isFinite(capacity) ? capacity : '∞';\n    capInput.value = isFinite(capacity) ? capacity : '';\n    log('(replayed) ' + s.action + (s.value !== null && s.value !== undefined ? ' ' + s.value : ''));\n    update(false);\n  }\n\n  function updateStepBadge(){\n    stepBadge.textContent = 'Step ' + (historyIndex+1) + ' / ' + history.length;\n  }\n\n  function update(logOp=true){\n    // update visual based on mode\n    sizeBadge.textContent = mode === 'array' ? arrayStack.length : computeLinkedSize();\n    opsBadge.textContent = opsCount;\n    const top = mode === 'array' ? (arrayStack.length ? arrayStack[arrayStack.length - 1] : '—') : (linkedStack ? linkedStack.value : '—');\n    topBadge.textContent = top;\n\n    implBadge.textContent = mode === 'array' ? 'Array-backed' : 'Linked-list';\n    capBadge.textContent = isFinite(capacity) ? capacity : '∞';\n    renderVisual();\n    renderLinked();\n    updateStepBadge();\n  }\n\n  function computeLinkedSize(){\n    let n=0; let p=linkedStack;\n    while(p){ n++; p=p.next; }\n    return n;\n  }\n\n  function renderVisual(){\n    // For array mode show slots with index labels.\n    // For linked mode show stack order using slots too (but no capacity).\n    const content = [];\n    const maxSlots = mode==='array' && isFinite(capacity) ? Math.max(6, capacity) : Math.max(8, arrayStack.length, computeLinkedSize(), 6);\n    // We'll display up to maxSlots slots; top is at top.\n    const items = mode === 'array' ? arrayStack.slice() : collectLinkedArray();\n    // We want to show some empty slots above the top to visualize space.\n    const emptyCount = Math.max(0, maxSlots - items.length);\n    stackVisual.innerHTML = '';\n    // Build from bottom to top (we append reversed because container is column-reverse)\n    const slots = [];\n    for(let i=0;i<maxSlots;i++){\n      const slot = document.createElement('div');\n      slot.className = 'slot';\n      const index = i; // bottom index\n      const idxSpan = document.createElement('div');\n      idxSpan.className = 'index';\n      idxSpan.textContent = ''; // optional index\n      slot.appendChild(idxSpan);\n      const valueSpan = document.createElement('div');\n      valueSpan.className = 'value';\n      slot.appendChild(valueSpan);\n      slots.push({slot, valueSpan, idxSpan});\n    }\n\n    // fill slots from bottom up with items\n    for(let i=0;i<maxSlots;i++){\n      const positionFromBottom = i;\n      const itemIndex = i < items.length ? items[i] : null;\n      const s = slots[i];\n      if(itemIndex !== null){\n        s.slot.classList.add('filled');\n        s.valueSpan.textContent = items[i];\n        s.idxSpan.textContent = (mode==='array' ? i : '');\n      } else {\n        s.valueSpan.textContent = '';\n        s.idxSpan.textContent = '';\n      }\n      stackVisual.appendChild(s.slot);\n    }\n\n    // Now mark the top slot: the last filled one\n    const topIdx = items.length - 1;\n    if(topIdx >= 0){\n      const children = stackVisual.children;\n      // children are bottom->top due to column-reverse and insertion order\n      const topChild = children[topIdx];\n      if(topChild) topChild.classList.add('top');\n    }\n  }\n\n  function collectLinkedArray(){\n    // return array from bottom to top\n    const arr = [];\n    const rev = [];\n    let p = linkedStack;\n    while(p){\n      rev.push(p.value);\n      p = p.next;\n    }\n    for(let i=rev.length-1;i>=0;i--) arr.push(rev[i]);\n    return arr;\n  }\n\n  function renderLinked(){\n    linkedArea.innerHTML = '';\n    if(mode !== 'linked') return;\n    // Show linked nodes left-to-right from head (top) to null\n    let p = linkedStack;\n    if(!p){\n      const empty = document.createElement('div'); empty.className='small-muted'; empty.textContent='(empty)';\n      linkedArea.appendChild(empty);\n      return;\n    }\n    while(p){\n      const n = document.createElement('div'); n.className='node';\n      n.textContent = String(p.value);\n      linkedArea.appendChild(n);\n      if(p.next){\n        const a = document.createElement('div'); a.className='arrow'; linkedArea.appendChild(a);\n      }\n      p = p.next;\n    }\n    const tail = document.createElement('div'); tail.className='small-muted'; tail.style.marginLeft='6px'; tail.textContent='null';\n    linkedArea.appendChild(tail);\n  }\n\n  function log(msg, isWarning){\n    const el = document.createElement('div');\n    el.textContent = '[' + new Date().toLocaleTimeString() + '] ' + msg;\n    if(isWarning) el.style.color = 'var(--danger)';\n    opLog.prepend(el);\n    // limit log length\n    while(opLog.children.length > 200) opLog.removeChild(opLog.lastChild);\n  }\n\n  function flash(kind){\n    // small highlight animation on stackVisual\n    if(kind === 'warn'){\n      stackVisual.style.transition = 'box-shadow 150ms';\n      stackVisual.style.boxShadow = '0 8px 40px rgba(239,68,68,0.12)';\n      setTimeout(()=>stackVisual.style.boxShadow='none',350);\n    } else if(kind === 'peek'){\n      stackVisual.style.transition = 'box-shadow 150ms';\n      stackVisual.style.boxShadow = '0 8px 40px rgba(6,182,212,0.12)';\n      setTimeout(()=>stackVisual.style.boxShadow='none',350);\n    }\n  }\n\n  // UI event wiring\n  buttons.forEach(b => {\n    b.addEventListener('click', ()=> setMode(b.dataset.mode));\n  });\n\n  function setMode(m, save=true){\n    mode = m;\n    buttons.forEach(b=> b.classList.toggle('active', b.dataset.mode === m));\n    implBadge.textContent = mode === 'array' ? 'Array-backed' : 'Linked-list';\n    // ensure capacity reflects\n    if(mode === 'linked'){\n      capInput.disabled = true;\n      capInput.placeholder = 'N/A (linked)';\n      capBadge.textContent = '∞';\n      capacity = Infinity;\n    } else {\n      capInput.disabled = false;\n      capInput.placeholder = '0 = ∞';\n      capacity = capInput.value ? Number(capInput.value) : Infinity;\n    }\n    // ensure we save snapshot when switching mode\n    if(save) saveSnapshot('modeSwitch', mode);\n    update();\n  }\n\n  pushBtn.addEventListener('click', ()=> {\n    const v = valueInput.value.trim();\n    if(v === '') { flash('warn'); log('push() skipped: empty value', true); return; }\n    push(v);\n    valueInput.value = '';\n  });\n\n  popBtn.addEventListener('click', ()=> pop());\n  peekBtn.addEventListener('click', ()=> peek());\n  clearBtn.addEventListener('click', ()=> { clearAll(); });\n\n  randBtn.addEventListener('click', ()=> {\n    const v = (Math.random()*100|0);\n    push('R'+v);\n  });\n\n  capInput.addEventListener('change', ()=> {\n    const val = Number(capInput.value);\n    if(Number.isNaN(val) || val <= 0){ capacity = Infinity; capInput.value = ''; capBadge.textContent = '∞'; }\n    else { capacity = Math.max(1, val); capBadge.textContent = capacity; }\n    saveSnapshot('setCapacity', capacity === Infinity ? 0 : capacity);\n    update();\n  });\n\n  bulkPush.addEventListener('click', ()=> {\n    const n = Number(bulkInput.value) || 0;\n    if(n <= 0){ flash('warn'); return; }\n    for(let i=0;i<n;i++){\n      push('R'+(Math.random()*100|0));\n    }\n  });\n\n  autoDemo.addEventListener('click', async ()=> {\n    // simple automated demo of pushes and pops\n    const steps = [\n      ()=> push('A'),\n      ()=> push('B'),\n      ()=> push('C'),\n      ()=> pop(),\n      ()=> push('D'),\n      ()=> peek(),\n      ()=> pop(),\n      ()=> pop()\n    ];\n    for(let i=0;i<steps.length;i++){\n      await delay(320);\n      steps[i]();\n    }\n  });\n\n  stepPrev.addEventListener('click', ()=> {\n    if(historyIndex > 0){\n      historyIndex--;\n      restoreSnapshot(historyIndex);\n      updateStepBadge();\n    } else {\n      flash('warn');\n    }\n  });\n\n  stepNext.addEventListener('click', ()=> {\n    if(historyIndex < history.length - 1){\n      historyIndex++;\n      restoreSnapshot(historyIndex);\n      updateStepBadge();\n    } else {\n      flash('warn');\n    }\n  });\n\n  undoBtn.addEventListener('click', ()=> {\n    // Undo last operation: restore previous snapshot\n    if(history.length <= 1) { flash('warn'); return; }\n    // remove last snapshot and restore previous\n    history.pop();\n    historyIndex = history.length - 1;\n    restoreSnapshot(historyIndex);\n    update();\n  });\n\n  // utilities\n  function delay(ms){ return new Promise(res=>setTimeout(res, ms)); }\n\n  // init\n  function init(){\n    arrayStack = [];\n    linkedStack = null;\n    capacity = Infinity;\n    opsCount = 0;\n    opLog.innerHTML = '';\n    history.length = 0; historyIndex = -1;\n    // initial snapshot\n    saveSnapshot('init', null);\n    update();\n  }\n\n  // small keyboard support\n  document.addEventListener('keydown', (e)=>{\n    if(e.key === 'Enter' && document.activeElement === valueInput){ pushBtn.click(); }\n    if(e.key === 'p' && e.ctrlKey){ e.preventDefault(); popBtn.click(); }\n  });\n\n  // start\n  init();\n\n  // expose for console debugging (optional)\n  window._stackViz = {\n    push, pop, peek, clearAll, getState: ()=> ({mode, capacity, arrayStack: arrayStack.slice(), linkedStack: cloneLinked(linkedStack), opsCount}),\n  };\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Stack"
    }
  ],
  "topic": "Stack",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}