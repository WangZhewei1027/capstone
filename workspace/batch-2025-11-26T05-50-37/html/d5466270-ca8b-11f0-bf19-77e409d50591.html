<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Linked List Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#38bdf8;
      --muted:#94a3b8;
      --node-bg:#071029;
      --node-border:#1e293b;
      --positive:#10b981;
      --negative:#ef4444;
      --glass: rgba(255,255,255,0.03);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color-scheme: dark;
    }
    html,body{ height:100%; margin:0; background:linear-gradient(180deg,var(--bg),#071026); color:#e6eef8; }
    .wrap{ max-width:1100px; margin:20px auto; padding:20px; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); box-shadow: 0 6px 30px rgba(2,6,23,0.6); }
    header{ display:flex; gap:16px; align-items:center; margin-bottom:12px; }
    h1{ font-size:20px; margin:0; letter-spacing:0.2px; }
    p.lead{ margin:0; color:var(--muted); font-size:13px; }
    .main{ display:flex; gap:16px; }
    .left{ flex:1; min-width:420px; background:var(--card); padding:14px; border-radius:10px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); }
    .right{ width:360px; background:var(--card); padding:14px; border-radius:10px; display:flex; flex-direction:column; gap:12px; }
    .controls{ display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px; }
    input[type="text"], input[type="number"], select{
      background:var(--glass); color:inherit; border:1px solid rgba(255,255,255,0.04); padding:8px 10px; border-radius:8px; outline:none;
      min-width:80px; box-sizing:border-box;
    }
    input[type="number"]{ width:90px; }
    button{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); color:var(--accent);
      border:1px solid rgba(56,189,248,0.15); padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600;
      display:inline-flex; gap:8px; align-items:center;
    }
    button.ghost{ background:transparent; color:var(--muted); border:1px dashed rgba(255,255,255,0.03); }
    button.warn{ color:var(--negative); border-color: rgba(239,68,68,0.15); }
    .visual {
      height:260px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); border-radius:8px; padding:12px; position:relative; overflow:auto;
      border: 1px solid rgba(255,255,255,0.02);
    }
    .nodes-wrap{ position:relative; height:220px; display:flex; align-items:center; gap:18px; padding:8px 12px; min-width:700px; }
    .node {
      width:96px; min-width:96px; height:56px; background:var(--node-bg); border-radius:8px; border:1px solid var(--node-border);
      display:flex; align-items:center; justify-content:space-between; padding:6px; box-sizing:border-box; color:#dff6ff;
      position:relative; box-shadow: 0 6px 14px rgba(2,6,23,0.45);
      transition: transform 250ms ease, box-shadow 200ms;
      flex-shrink:0;
    }
    .node .val{ font-weight:700; font-size:16px; margin-left:8px; }
    .node .meta{ font-size:11px; color:var(--muted); padding:4px 6px; border-radius:6px; background:rgba(255,255,255,0.01); margin-right:6px; }
    .node.head { box-shadow: 0 10px 20px rgba(56,189,248,0.06); border-color: rgba(56,189,248,0.28); }
    .node.found { border-color: rgba(16,185,129,0.7); box-shadow: 0 10px 25px rgba(16,185,129,0.06); transform:scale(1.04); }
    .node.removing{ opacity:0.2; transform: translateY(-12px) scale(0.9); }
    .node.adding{ transform: translateY(-8px) scale(1.02); box-shadow: 0 18px 30px rgba(56,189,248,0.04); }
    .node .ptrbox{ width:34px; height:34px; display:flex; align-items:center; justify-content:center; border-radius:6px; background:rgba(255,255,255,0.02); color:var(--muted); font-size:12px; }
    .arrow-svg{ position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; overflow:visible; }
    .legend{ font-size:13px; color:var(--muted); display:flex; gap:12px; align-items:center; margin-top:10px; }
    .legend span{ display:inline-flex; gap:8px; align-items:center; }
    .dot{ width:12px; height:12px; border-radius:4px; display:inline-block; }
    .dot.head{ background: linear-gradient(90deg,var(--accent),#60a5fa); box-shadow:0 3px 8px rgba(96,165,250,0.14); }
    .dot.found{ background: linear-gradient(90deg,var(--positive),#34d399); }
    .log{ background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); border-radius:8px; padding:10px; color:var(--muted); font-size:13px; height:160px; overflow:auto; border:1px solid rgba(255,255,255,0.02); }
    pre.pseudocode{ background:rgba(255,255,255,0.02); padding:10px; border-radius:8px; font-size:13px; color:#dff6ff; margin:0; overflow:auto; max-height:240px; border:1px solid rgba(255,255,255,0.02); }
    .small{ font-size:13px; color:var(--muted); }
    footer{ margin-top:12px; font-size:12px; color:var(--muted); display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap; }
    .btn-row{ display:flex; gap:8px; flex-wrap:wrap; }
    .controls .grow{ flex:1; min-width:140px; }
    .info { font-size:13px; color:var(--muted); line-height:1.35; }
    label{ font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
    .stat { display:flex; gap:8px; align-items:center; }
    .count-bubble{ background:rgba(255,255,255,0.02); padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,0.02); color:var(--muted); font-weight:700; }
    .input-row{ display:flex; gap:8px; align-items:center; }
    .floating-pointer{
      position:absolute; width:22px; height:22px; background:var(--accent); border-radius:50%; display:flex; align-items:center; justify-content:center; color:#001219; font-weight:800; font-size:11px; transform:translate(-50%,-50%); box-shadow:0 10px 25px rgba(56,189,248,0.12); pointer-events:none;
    }
    .muted{ color:var(--muted); }
  </style>
</head>
<body>
  <div class="wrap" role="main">
    <header>
      <div>
        <h1>Linked List — Interactive Demo</h1>
        <p class="lead">Explore a singly linked list with operations: append, prepend, insert, delete, find, reverse, and step through traversal.</p>
      </div>
    </header>

    <div class="main">
      <div class="left">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
          <div class="stat">
            <div class="small muted">Length</div>
            <div class="count-bubble" id="lengthBubble">0</div>
          </div>
          <div class="small muted">Head: <span id="headInfo">null</span></div>
        </div>

        <div class="controls" aria-hidden="false">
          <div style="display:flex;gap:8px;align-items:center;">
            <div>
              <label class="small muted">Value</label>
              <input type="text" id="valueInput" placeholder="enter value" />
            </div>
            <div>
              <label class="small muted">Index</label>
              <input type="number" id="indexInput" value="0" min="0" />
            </div>
          </div>

          <div class="btn-row" style="margin-left:auto;">
            <button id="appendBtn">Append</button>
            <button id="prependBtn">Prepend</button>
            <button id="insertBtn">Insert at</button>
            <button id="delValBtn" class="warn">Delete value</button>
            <button id="delIdxBtn" class="warn">Delete at</button>
          </div>
        </div>

        <div class="controls" style="margin-top:8px;">
          <button id="findBtn" class="ghost">Find</button>
          <button id="reverseBtn">Reverse</button>
          <button id="clearBtn" class="ghost">Clear</button>
          <button id="randomBtn" class="ghost">Randomize</button>

          <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
            <button id="traverseStepBtn" class="ghost">Traverse (step)</button>
            <button id="traverseAutoBtn" class="ghost">Traverse (auto)</button>
          </div>
        </div>

        <div class="visual" id="visualArea" aria-live="polite">
          <svg class="arrow-svg" id="arrowSvg"></svg>
          <div class="nodes-wrap" id="nodesWrap"></div>
          <div id="floatingPointer" class="floating-pointer" style="display:none;">→</div>
        </div>

        <div class="legend">
          <span><i class="dot head"></i> head</span>
          <span><i class="dot found"></i> found/highlight</span>
          <span class="muted">Boxes: node.value with a small "next" area.</span>
        </div>

      </div>

      <div class="right">
        <div>
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <div style="font-weight:700">Operation Log</div>
            <div class="small muted">Recent actions appear here</div>
          </div>
          <div class="log" id="logArea" aria-live="polite"></div>
        </div>

        <div>
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
            <div style="font-weight:700">Pseudocode (reverse)</div>
            <div class="small muted">Iterative</div>
          </div>
          <pre class="pseudocode" id="pseudocode">
function reverse(head):
    prev = null
    current = head
    while current != null:
        next = current.next
        current.next = prev
        prev = current
        current = next
    return prev
          </pre>
        </div>

        <div>
          <div style="font-weight:700;margin-bottom:6px;">Representation (internal)</div>
          <div class="small muted" style="margin-bottom:6px;">Each node: { id, value, nextId }</div>
          <pre class="pseudocode" id="internalRep" style="height:120px; overflow:auto;"></pre>
        </div>
      </div>
    </div>

    <footer>
      <div class="small muted">This demo implements a singly linked list & visualizes pointer changes. Use the controls to experiment.</div>
      <div class="small muted">Nodes are rendered left-to-right from head → tail.</div>
    </footer>
  </div>

  <script>
    // Singly Linked List implementation (internal)
    (function () {
      // Node factory with unique ids (simulate memory addresses)
      let idCounter = 1;
      function makeNode(value) {
        return { id: 'n' + (idCounter++), value: String(value), next: null };
      }

      // List state
      const list = {
        head: null, // points to node object
        length: 0,
        nodesById: new Map(),
      };

      // Helpers
      function setHead(node) {
        list.head = node;
        render();
      }

      function toArrayNodes() {
        const arr = [];
        let cur = list.head;
        while (cur) {
          arr.push(cur);
          cur = cur.next;
        }
        return arr;
      }

      function log(...args) {
        const area = document.getElementById('logArea');
        const time = new Date().toLocaleTimeString();
        const msg = '[' + time + '] ' + args.join(' ');
        const p = document.createElement('div'); p.textContent = msg;
        area.prepend(p);
      }

      function updateInternalRep() {
        const el = document.getElementById('internalRep');
        const nodes = toArrayNodes();
        const repr = nodes.map(n => `${n.id}: { value: "${n.value}", next: ${n.next ? n.next.id : 'null'} }`).join('\\n');
        el.textContent = repr || '(empty list)';
      }

      // Core operations
      function append(value) {
        const node = makeNode(value);
        list.nodesById.set(node.id, node);
        if (!list.head) {
          list.head = node;
        } else {
          let cur = list.head;
          while (cur.next) cur = cur.next;
          cur.next = node;
        }
        list.length++;
        log('append("' + value + '") → added', node.id);
        render();
      }

      function prepend(value) {
        const node = makeNode(value);
        list.nodesById.set(node.id, node);
        node.next = list.head;
        list.head = node;
        list.length++;
        log('prepend("' + value + '") → new head', node.id);
        render();
      }

      function insertAt(value, index) {
        if (index <= 0 || !list.head) {
          prepend(value);
          if(index > 0) log('(insert at index ' + index + ' adjusted to prepend because list was empty or index<=0)');
          return;
        }
        if (index >= list.length) {
          append(value);
          return;
        }
        let prev = null, cur = list.head, i = 0;
        while (i < index) {
          prev = cur;
          cur = cur.next;
          i++;
        }
        const node = makeNode(value);
        list.nodesById.set(node.id, node);
        prev.next = node;
        node.next = cur;
        list.length++;
        log('insertAt(' + index + ', "' + value + '") →', node.id);
        render();
      }

      function deleteByValue(value) {
        if (!list.head) { log('deleteByValue("' + value + '") → list empty'); return; }
        let cur = list.head, prev = null, idx = 0;
        while (cur) {
          if (cur.value === String(value)) {
            if (!prev) {
              // removing head
              list.head = cur.next;
            } else {
              prev.next = cur.next;
            }
            list.nodesById.delete(cur.id);
            list.length--;
            log('deleteByValue("' + value + '") → removed', cur.id, 'at index', idx);
            renderHighlightRemoved(cur.id);
            return;
          }
          prev = cur;
          cur = cur.next;
          idx++;
        }
        log('deleteByValue("' + value + '") → not found');
      }

      function deleteAt(index) {
        if (index < 0 || index >= list.length || !list.head) { log('deleteAt(' + index + ') → index out of range'); return; }
        let cur = list.head, prev = null, i = 0;
        while (i < index) {
          prev = cur;
          cur = cur.next;
          i++;
        }
        if (!prev) list.head = cur.next;
        else prev.next = cur.next;
        list.nodesById.delete(cur.id);
        list.length--;
        log('deleteAt(' + index + ') → removed', cur.id);
        renderHighlightRemoved(cur.id);
      }

      function find(value, options = {}) {
        let cur = list.head, idx = 0;
        while (cur) {
          if (cur.value === String(value)) {
            log('find("' + value + '") → found at index', idx, cur.id);
            renderHighlightFound(cur.id);
            return { node: cur, index: idx };
          }
          if (options.step) {
            // step animation handled outside
          }
          cur = cur.next;
          idx++;
        }
        log('find("' + value + '") → not found');
        return null;
      }

      function reverseIterative() {
        if (!list.head || !list.head.next) { log('reverse() → trivial (0 or 1 node)'); return; }
        let prev = null, cur = list.head, next = null;
        log('reverse() → starting');
        // we will animate steps while reversing
        const steps = [];
        while (cur) {
          next = cur.next;
          // record step: set cur.next = prev
          steps.push({ curId: cur.id, prevId: prev ? prev.id : null, nextId: next ? next.id : null });
          cur = next;
          prev = steps[steps.length-1] && list.nodesById.get(steps[steps.length-1].curId) ? list.nodesById.get(steps[steps.length-1].curId) : prev;
        }
        // Actually perform reversal (iterative real)
        prev = null; cur = list.head;
        const animate = (i) => {
          if (!cur) {
            list.head = prev;
            log('reverse() → complete. new head:', list.head.id);
            render();
            return;
          }
          next = cur.next;
          cur.next = prev;
          prev = cur;
          cur = next;
          render(); // update visualization per step
          setTimeout(() => animate(i+1), 260);
        };
        animate(0);
      }

      function clearList() {
        list.head = null;
        list.length = 0;
        list.nodesById.clear();
        log('clear() → list emptied');
        render();
      }

      function randomize(n) {
        clearList();
        for (let i=0;i<n;i++){
          append(Math.floor(Math.random()*90)+10);
        }
        log('randomize(' + n + ')');
        render();
      }

      // Visualization & UI wiring
      const nodesWrap = document.getElementById('nodesWrap');
      const arrowSvg = document.getElementById('arrowSvg');
      const lengthBubble = document.getElementById('lengthBubble');
      const headInfo = document.getElementById('headInfo');
      const floatingPointer = document.getElementById('floatingPointer');

      function clearSvg() {
        while (arrowSvg.firstChild) arrowSvg.removeChild(arrowSvg.firstChild);
      }

      function drawArrows() {
        clearSvg();
        const nodes = Array.from(nodesWrap.querySelectorAll('.node'));
        for (let i=0;i<nodes.length-1;i++) {
          const a = nodes[i], b = nodes[i+1];
          const rA = a.getBoundingClientRect(), rB = b.getBoundingClientRect();
          const wrap = nodesWrap.getBoundingClientRect();
          const x1 = (rA.right - wrap.left) - 10;
          const y1 = (rA.top + rA.bottom)/2 - wrap.top;
          const x2 = (rB.left - wrap.left) + 10;
          const y2 = (rB.top + rB.bottom)/2 - wrap.top;
          const line = document.createElementNS("http://www.w3.org/2000/svg","path");
          const dx = x2 - x1;
          const dy = y2 - y1;
          const hx = x1 + Math.max(16, dx/2);
          const d = `M ${x1} ${y1} C ${hx} ${y1} ${hx} ${y2} ${x2} ${y2}`;
          line.setAttribute('d', d);
          line.setAttribute('stroke', 'rgba(180,220,255,0.18)');
          line.setAttribute('stroke-width', '2');
          line.setAttribute('fill', 'none');
          line.setAttribute('stroke-linecap','round');
          arrowSvg.appendChild(line);

          // arrow head
          const arrow = document.createElementNS("http://www.w3.org/2000/svg","polygon");
          const ax = x2, ay = y2;
          const size = 6;
          arrow.setAttribute('points', `${ax} ${ay} ${ax-size} ${ay-4} ${ax-size} ${ay+4}`);
          arrow.setAttribute('fill','rgba(180,220,255,0.22)');
          arrowSvg.appendChild(arrow);
        }
      }

      function renderHighlightFound(nodeId) {
        render(() => {
          const el = nodesWrap.querySelector(`[data-id="${nodeId}"]`);
          if (el) {
            el.classList.add('found');
            setTimeout(()=> el.classList.remove('found'), 1000);
          }
        });
      }

      function renderHighlightRemoved(nodeId) {
        const el = nodesWrap.querySelector(`[data-id="${nodeId}"]`);
        if (!el) { render(); return; }
        el.classList.add('removing');
        setTimeout(()=> render(), 320);
      }

      // primary render function; optional callback after DOM update
      function render(afterRender) {
        // update length and head info
        lengthBubble.textContent = list.length;
        headInfo.textContent = list.head ? list.head.id + ' ("' + list.head.value + '")' : 'null';

        // build nodes markup
        const nodes = toArrayNodes();
        nodesWrap.innerHTML = '';
        nodes.forEach((n, idx) => {
          const div = document.createElement('div');
          div.className = 'node' + (idx===0 ? ' head' : '');
          div.setAttribute('data-id', n.id);
          div.innerHTML = '<div style="display:flex;align-items:center"><div class="val">' + escapeHtml(n.value) + '</div></div><div class="ptrbox">' + (n.next ? n.next.id : 'null') + '</div>';
          nodesWrap.appendChild(div);
        });

        // ensure nodesWrap has minimum width so arrows show; done via CSS min-width
        updateInternalRep();

        // let browser compute layout then draw arrows
        requestAnimationFrame(() => {
          drawArrows();
          if (afterRender) afterRender();
        });
      }

      // Utility: escape
      function escapeHtml(s) {
        return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      }

      // Traversal animations
      let traversalCancel = false;
      function traverseStepwise(auto=false, speed=600) {
        const nodes = Array.from(nodesWrap.querySelectorAll('.node'));
        if (!nodes.length) {
          log('traverse → empty list');
          return;
        }
        traversalCancel = false;
        let i = 0;
        function step() {
          if (traversalCancel) {
            floatingPointer.style.display = 'none';
            return;
          }
          const el = nodes[i];
          const wrap = nodesWrap.getBoundingClientRect();
          const r = el.getBoundingClientRect();
          const cx = (r.left + r.right)/2 - wrap.left;
          const cy = (r.top + r.bottom)/2 - wrap.top;
          floatingPointer.style.left = (cx + nodesWrap.offsetLeft) + 'px';
          floatingPointer.style.top = (cy + nodesWrap.offsetTop - 6) + 'px';
          floatingPointer.style.display = 'flex';
          // highlight
          nodes.forEach(nd => nd.classList.remove('found'));
          el.classList.add('found');
          log('traverse → at', el.getAttribute('data-id'), 'value=' + el.querySelector('.val').textContent);
          i++;
          if (i < nodes.length) {
            if (auto) setTimeout(step, speed);
          } else {
            setTimeout(() => {
              floatingPointer.style.display = 'none';
              nodes.forEach(nd => nd.classList.remove('found'));
              log('traverse → complete');
            }, 300);
            return;
          }
          if (!auto && i < nodes.length) {
            // for step mode, we wait for user to press "Traverse (step)" again to continue
          }
        }
        step();
        // For step-by-step: we replace traversal function to proceed with next step on next click
        if (!auto) {
          // Next click should continue from current i
          document.getElementById('traverseStepBtn').onclick = function continueStep() {
            if (traversalCancel) {
              floatingPointer.style.display = 'none';
              return;
            }
            if (i >= nodes.length) {
              floatingPointer.style.display = 'none';
              nodes.forEach(nd => nd.classList.remove('found'));
              document.getElementById('traverseStepBtn').onclick = controls.traverseStep;
              log('traverse → finished (step)');
              return;
            }
            const el = nodes[i];
            const wrap = nodesWrap.getBoundingClientRect();
            const r = el.getBoundingClientRect();
            const cx = (r.left + r.right)/2 - wrap.left;
            const cy = (r.top + r.bottom)/2 - wrap.top;
            floatingPointer.style.left = (cx + nodesWrap.offsetLeft) + 'px';
            floatingPointer.style.top = (cy + nodesWrap.offsetTop - 6) + 'px';
            floatingPointer.style.display = 'flex';
            nodes.forEach(nd => nd.classList.remove('found'));
            el.classList.add('found');
            log('traverse → at', el.getAttribute('data-id'), 'value=' + el.querySelector('.val').textContent);
            i++;
            if (i >= nodes.length) {
              setTimeout(() => {
                floatingPointer.style.display = 'none';
                nodes.forEach(nd => nd.classList.remove('found'));
                document.getElementById('traverseStepBtn').onclick = controls.traverseStep;
                log('traverse → complete');
              }, 300);
            }
          };
        } else {
          // restore default onclick after auto finishes
          setTimeout(() => {
            document.getElementById('traverseStepBtn').onclick = controls.traverseStep;
          }, nodes.length * speed + 300);
        }
      }

      // Controls wiring
      const controls = {
        append() {
          const v = document.getElementById('valueInput').value.trim();
          if (!v) { log('append → value empty'); return; }
          append(v);
        },
        prepend() {
          const v = document.getElementById('valueInput').value.trim();
          if (!v) { log('prepend → value empty'); return; }
          prepend(v);
        },
        insert() {
          const v = document.getElementById('valueInput').value.trim();
          const idx = Number(document.getElementById('indexInput').value);
          if (!v) { log('insert → value empty'); return; }
          if (isNaN(idx)) { log('insert → index invalid'); return; }
          insertAt(v, idx);
        },
        deleteValue() {
          const v = document.getElementById('valueInput').value.trim();
          if (!v) { log('deleteByValue → value empty'); return; }
          deleteByValue(v);
        },
        deleteIndex() {
          const idx = Number(document.getElementById('indexInput').value);
          if (isNaN(idx)) { log('deleteAt → index invalid'); return; }
          deleteAt(idx);
        },
        find() {
          const v = document.getElementById('valueInput').value.trim();
          if (!v) { log('find → value empty'); return; }
          find(v);
        },
        reverse() { reverseIterative(); },
        clear() { clearList(); },
        randomize() {
          const n = Math.max(1, Math.min(12, Number(prompt('How many nodes to generate? (1-12)', '6')) || 6));
          randomize(n);
        },
        traverseStep() { traverseStepwise(false); },
        traverseAuto() { traverseStepwise(true, 520); },
        cancelTraversal() { traversalCancel = true; }
      };

      // Attach buttons
      document.getElementById('appendBtn').addEventListener('click', controls.append);
      document.getElementById('prependBtn').addEventListener('click', controls.prepend);
      document.getElementById('insertBtn').addEventListener('click', controls.insert);
      document.getElementById('delValBtn').addEventListener('click', controls.deleteValue);
      document.getElementById('delIdxBtn').addEventListener('click', controls.deleteIndex);
      document.getElementById('findBtn').addEventListener('click', controls.find);
      document.getElementById('reverseBtn').addEventListener('click', controls.reverse);
      document.getElementById('clearBtn').addEventListener('click', controls.clear);
      document.getElementById('randomBtn').addEventListener('click', controls.randomize);
      document.getElementById('traverseStepBtn').addEventListener('click', controls.traverseStep);
      document.getElementById('traverseAutoBtn').addEventListener('click', controls.traverseAuto);

      // handle window resize to redraw arrows
      window.addEventListener('resize', () => render());

      // basic keyboard: Enter in value input triggers append
      document.getElementById('valueInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') controls.append();
      });

      // initialize with sample nodes
      ['A', 'B', 'C', 'D'].forEach(v => append(v));

      // expose some functions for debugging (no global pollution)
      window.LLdemo = {
        append, prepend, insertAt, deleteByValue, deleteAt, find, reverseIterative, clearList, randomize
      };
    })();
  </script>
</body>
</html>