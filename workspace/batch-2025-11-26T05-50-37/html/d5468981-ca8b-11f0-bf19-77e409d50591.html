<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Deque (Double-Ended Queue) Demo</title>
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#60a5fa;
      --muted:#94a3b8;
      --card:#071028;
      --success:#34d399;
      --danger:#fb7185;
      --glass: rgba(255,255,255,0.03);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#021028 0%, #061226 60%);color:#e6eef8}
    .wrap{max-width:1100px;margin:28px auto;padding:22px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow: 0 6px 30px rgba(2,6,23,0.6);}
    header{display:flex;align-items:center;gap:18px;margin-bottom:18px}
    header h1{font-size:20px;margin:0}
    header p{margin:0;color:var(--muted);font-size:13px}
    .cols{display:flex;gap:18px}
    .col{flex:1;min-width:0}
    .panel{background:var(--panel);padding:14px;border-radius:10px;box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    input[type="text"]{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;width:140px}
    button{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03);color:inherit;padding:8px 12px;border-radius:8px;cursor:pointer}
    button:hover{transform:translateY(-2px);box-shadow:0 6px 18px rgba(2,6,23,0.5)}
    .btn-accent{background:linear-gradient(90deg,var(--accent),#7dd3fc);color:#001122;border:0}
    .btn-danger{background:linear-gradient(90deg,var(--danger),#fda4af);color:#2a0710;border:0}
    .display-area{margin-top:12px;display:flex;flex-direction:column;gap:12px}
    .deque-visual{display:flex;gap:10px;align-items:center;overflow:auto;padding:10px;background:var(--card);border-radius:10px;border:1px solid rgba(255,255,255,0.02)}
    .cell{min-width:60px;height:56px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));display:flex;align-items:center;justify-content:center;border:1px solid rgba(255,255,255,0.03);position:relative;font-weight:600;transition:transform .2s ease,opacity .2s ease}
    .cell .sub{position:absolute;bottom:-16px;left:6px;font-size:11px;color:var(--muted)}
    .cell.head{box-shadow:0 6px 18px rgba(96,165,250,0.12);border-color:rgba(96,165,250,0.25)}
    .cell.tail{box-shadow:0 6px 18px rgba(34,197,94,0.12);border-color:rgba(34,197,94,0.25)}
    .info{font-size:13px;color:var(--muted);display:flex;gap:14px;flex-wrap:wrap}
    .small{font-size:12px;color:var(--muted)}
    .log{height:140px;overflow:auto;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}
    .ops{display:flex;gap:8px;flex-wrap:wrap}
    .internal{margin-top:12px;padding:10px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));border:1px solid rgba(255,255,255,0.02)}
    .arr{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .arr-slot{min-width:50px;height:44px;border-radius:6px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center;border:1px dashed rgba(255,255,255,0.03);position:relative}
    .pointer{position:absolute;top:-16px;font-size:12px;color:var(--muted)}
    pre{white-space:pre-wrap;color:#cfe9ff;background:transparent;margin:0;font-size:13px}
    footer{margin-top:12px;font-size:12px;color:var(--muted)}
    .range{display:flex;align-items:center;gap:8px}
    .hint{font-size:12px;color:var(--muted);margin-top:8px}
    @media (max-width:860px){
      .cols{flex-direction:column}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Deque (Double-Ended Queue) â€” Interactive Demo</h1>
        <p>Perform operations at either end and watch how a circular-buffer deque works internally.</p>
      </div>
    </header>

    <div class="cols">
      <div class="col">
        <div class="panel">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div>
              <strong>Operations</strong>
              <div class="hint">Use the input to push values. You can also fill with random numbers.</div>
            </div>
            <div class="small">Capacity: <span id="capLabel">8</span></div>
          </div>

          <div style="margin-top:10px" class="controls">
            <input type="text" id="valueInput" placeholder="value (string/number)" />
            <button id="pushFrontBtn" class="btn-accent" title="Add to front">&larr; Push Front</button>
            <button id="pushBackBtn" class="btn-accent" title="Add to back">Push Back &rarr;</button>
            <button id="popFrontBtn" title="Remove from front">Pop Front</button>
            <button id="popBackBtn" title="Remove from back">Pop Back</button>
            <button id="peekFrontBtn" title="Peek at front">Peek Front</button>
            <button id="peekBackBtn" title="Peek at back">Peek Back</button>
            <button id="clearBtn" class="btn-danger" title="Clear deque">Clear</button>
            <button id="fillRandomBtn" title="Fill with random ints">Fill Random</button>
          </div>

          <div class="display-area">
            <div class="deque-visual" id="dequeVisual" aria-live="polite" aria-atomic="true">
              <!-- cells injected here -->
            </div>

            <div class="info">
              <div class="small">Size: <strong id="sizeLabel">0</strong></div>
              <div class="small">Head index: <strong id="headLabel">0</strong></div>
              <div class="small">Tail index: <strong id="tailLabel">0</strong></div>
              <div class="small">Logical order: <span id="logicalLabel">[]</span></div>
            </div>

            <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
              <div style="flex:1">
                <div class="small" style="margin-bottom:6px">Animation speed</div>
                <div class="range">
                  <input id="speedRange" type="range" min="0" max="1000" value="200">
                  <div class="small" id="speedLabel">200ms</div>
                </div>
              </div>
              <div style="width:360px">
                <div class="small">Operation log</div>
                <div class="log" id="logBox"></div>
              </div>
            </div>
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="panel">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <strong>Internal Circular Buffer</strong>
            <div class="small">Double-size on full</div>
          </div>

          <div class="internal" id="internalArea">
            <div class="arr" id="internalArr">
              <!-- internal slots -->
            </div>
            <div style="margin-top:12px" class="small">Empty slots are shown as dashed boxes. Head/Tail pointers displayed above.</div>
          </div>
        </div>
      </div>

      <div class="col">
        <div class="panel">
          <strong>Deque Implementation (JavaScript)</strong>
          <p class="small" style="margin-top:6px">This implementation uses a circular buffer that doubles capacity when full. Methods: pushFront, pushBack, popFront, popBack, peekFront, peekBack, size, clear, toArray.</p>

          <pre id="codeBlock">
// JavaScript Deque (circular buffer with dynamic resizing)
class Deque {
  constructor(capacity = 8) {
    this._cap = Math.max(2, capacity|0);
    this._arr = new Array(this._cap);
    this._head = 0;     // index of first element
    this._length = 0;   // number of elements
  }

  _resize(newCap) {
    const a = new Array(newCap);
    for (let i = 0; i < this._length; i++) {
      a[i] = this._arr[(this._head + i) % this._cap];
    }
    this._arr = a;
    this._cap = newCap;
    this._head = 0;
  }

  pushBack(value) {
    if (this._length === this._cap) this._resize(this._cap * 2);
    this._arr[(this._head + this._length) % this._cap] = value;
    this._length++;
  }

  pushFront(value) {
    if (this._length === this._cap) this._resize(this._cap * 2);
    this._head = (this._head - 1 + this._cap) % this._cap;
    this._arr[this._head] = value;
    this._length++;
  }

  popFront() {
    if (this._length === 0) return undefined;
    const v = this._arr[this._head];
    this._arr[this._head] = undefined;
    this._head = (this._head + 1) % this._cap;
    this._length--;
    return v;
  }

  popBack() {
    if (this._length === 0) return undefined;
    const idx = (this._head + this._length - 1) % this._cap;
    const v = this._arr[idx];
    this._arr[idx] = undefined;
    this._length--;
    return v;
  }

  peekFront() { if (this._length === 0) return undefined; return this._arr[this._head]; }
  peekBack()  { if (this._length === 0) return undefined; return this._arr[(this._head + this._length - 1) % this._cap]; }
  size() { return this._length; }
  clear() { this._arr = new Array(this._cap); this._head = 0; this._length = 0; }
  toArray() {
    const out = new Array(this._length);
    for (let i = 0; i < this._length; i++) out[i] = this._arr[(this._head + i) % this._cap];
    return out;
  }
}
          </pre>

          <div style="margin-top:10px" class="small">Try the UI to manipulate a live instance of this Deque.</div>
        </div>

        <div style="height:12px"></div>

        <div class="panel">
          <strong>Tips & Notes</strong>
          <ul class="small" style="margin-top:8px">
            <li>Deque supports O(1) amortized operations at both ends.</li>
            <li>Internally we use a circular buffer. When full we allocate a larger array and copy items linearly.</li>
            <li>Use deques for sliding windows, BFS, undo buffers, or any place you need both-end access.</li>
          </ul>
        </div>
      </div>
    </div>

    <footer>
      Built for demonstration. Try alternating push/pop on each end and watch head/tail indexes.
    </footer>
  </div>

  <script>
    // Deque implementation (same as displayed)
    class Deque {
      constructor(capacity = 8) {
        this._cap = Math.max(2, capacity|0);
        this._arr = new Array(this._cap);
        this._head = 0;
        this._length = 0;
      }

      _resize(newCap) {
        const a = new Array(newCap);
        for (let i = 0; i < this._length; i++) {
          a[i] = this._arr[(this._head + i) % this._cap];
        }
        this._arr = a;
        this._cap = newCap;
        this._head = 0;
      }

      pushBack(value) {
        if (this._length === this._cap) this._resize(this._cap * 2);
        this._arr[(this._head + this._length) % this._cap] = value;
        this._length++;
      }

      pushFront(value) {
        if (this._length === this._cap) this._resize(this._cap * 2);
        this._head = (this._head - 1 + this._cap) % this._cap;
        this._arr[this._head] = value;
        this._length++;
      }

      popFront() {
        if (this._length === 0) return undefined;
        const v = this._arr[this._head];
        this._arr[this._head] = undefined;
        this._head = (this._head + 1) % this._cap;
        this._length--;
        return v;
      }

      popBack() {
        if (this._length === 0) return undefined;
        const idx = (this._head + this._length - 1) % this._cap;
        const v = this._arr[idx];
        this._arr[idx] = undefined;
        this._length--;
        return v;
      }

      peekFront() { if (this._length === 0) return undefined; return this._arr[this._head]; }
      peekBack()  { if (this._length === 0) return undefined; return this._arr[(this._head + this._length - 1) % this._cap]; }
      size() { return this._length; }
      clear() { this._arr = new Array(this._cap); this._head = 0; this._length = 0; }
      toArray() {
        const out = new Array(this._length);
        for (let i = 0; i < this._length; i++) out[i] = this._arr[(this._head + i) % this._cap];
        return out;
      }
    }

    // UI wiring
    const dq = new Deque(8);
    const dequeVisual = document.getElementById('dequeVisual');
    const sizeLabel = document.getElementById('sizeLabel');
    const headLabel = document.getElementById('headLabel');
    const tailLabel = document.getElementById('tailLabel');
    const logicalLabel = document.getElementById('logicalLabel');
    const logBox = document.getElementById('logBox');
    const internalArrDiv = document.getElementById('internalArr');
    const capLabel = document.getElementById('capLabel');
    const valueInput = document.getElementById('valueInput');
    const speedRange = document.getElementById('speedRange');
    const speedLabel = document.getElementById('speedLabel');

    const pushFrontBtn = document.getElementById('pushFrontBtn');
    const pushBackBtn = document.getElementById('pushBackBtn');
    const popFrontBtn = document.getElementById('popFrontBtn');
    const popBackBtn = document.getElementById('popBackBtn');
    const peekFrontBtn = document.getElementById('peekFrontBtn');
    const peekBackBtn = document.getElementById('peekBackBtn');
    const clearBtn = document.getElementById('clearBtn');
    const fillRandomBtn = document.getElementById('fillRandomBtn');

    capLabel.textContent = dq._cap;

    function log(msg){
      const time = new Date().toLocaleTimeString();
      logBox.innerHTML = `<div>[${time}] ${escapeHtml(msg)}</div>` + logBox.innerHTML;
    }

    function escapeHtml(s){
      if (s === undefined) return 'undefined';
      return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    function render(){
      // Visual deque (logical order)
      const arr = dq.toArray();
      dequeVisual.innerHTML = '';
      if (arr.length === 0){
        const empty = document.createElement('div');
        empty.className = 'small';
        empty.textContent = 'Deque is empty';
        dequeVisual.appendChild(empty);
      } else {
        arr.forEach((v,i) => {
          const c = document.createElement('div');
          c.className = 'cell';
          c.style.opacity = '0';
          c.textContent = escapeHtml(v);
          if (i === 0) {
            c.classList.add('head');
            const s = document.createElement('div'); s.className='sub'; s.textContent='front'; c.appendChild(s);
          }
          if (i === arr.length-1){
            c.classList.add('tail');
            const s = document.createElement('div'); s.className='sub'; s.textContent='back'; c.appendChild(s);
          }
          dequeVisual.appendChild(c);
          // simple fade-in
          setTimeout(()=>c.style.opacity='1', 10);
        });
      }

      sizeLabel.textContent = dq.size();
      headLabel.textContent = dq._head;
      tailLabel.textContent = (dq._head + dq._length - 1 + dq._cap) % dq._cap;
      logicalLabel.textContent = JSON.stringify(arr);
      capLabel.textContent = dq._cap;

      // internal circular buffer visualization
      internalArrDiv.innerHTML = '';
      for (let i = 0; i < dq._cap; i++){
        const slot = document.createElement('div');
        slot.className = 'arr-slot';
        if (dq._arr[i] !== undefined) {
          slot.textContent = escapeHtml(dq._arr[i]);
        } else {
          slot.textContent = '';
        }
        // pointers
        if (i === dq._head){
          const ptr = document.createElement('div'); ptr.className='pointer'; ptr.textContent='head';
          slot.appendChild(ptr);
        }
        const tailIdx = (dq._head + dq._length - 1 + dq._cap) % dq._cap;
        if (dq._length > 0 && i === tailIdx){
          const ptr2 = document.createElement('div'); ptr2.className='pointer'; ptr2.style.left='auto'; ptr2.style.right='6px'; ptr2.textContent='tail';
          slot.appendChild(ptr2);
        }
        internalArrDiv.appendChild(slot);
      }

    }

    function animateOperation(fn, message){
      // simple animation delay controlled by speed slider
      const delay = parseInt(speedRange.value,10) || 0;
      try {
        const res = fn();
        render();
        log(message + (res !== undefined ? ` -> ${JSON.stringify(res)}` : ''));
      } catch (e) {
        log('Error: ' + e.message);
      }
      // return promise for potential chaining
      return new Promise(resolve => setTimeout(resolve, delay));
    }

    // buttons
    pushFrontBtn.addEventListener('click', async ()=>{
      const val = valueInput.value.trim();
      if (val === '') { log('Please enter a value to push.'); return; }
      await animateOperation(()=> dq.pushFront(parseInput(valueInput.value)), `pushFront(${valueInput.value})`);
    });

    pushBackBtn.addEventListener('click', async ()=>{
      const val = valueInput.value.trim();
      if (val === '') { log('Please enter a value to push.'); return; }
      await animateOperation(()=> dq.pushBack(parseInput(valueInput.value)), `pushBack(${valueInput.value})`);
    });

    popFrontBtn.addEventListener('click', async ()=>{
      await animateOperation(()=> dq.popFront(), `popFront()`);
    });

    popBackBtn.addEventListener('click', async ()=>{
      await animateOperation(()=> dq.popBack(), `popBack()`);
    });

    peekFrontBtn.addEventListener('click', async ()=>{
      const v = dq.peekFront();
      await animateOperation(()=> v, `peekFront()`);
    });

    peekBackBtn.addEventListener('click', async ()=>{
      const v = dq.peekBack();
      await animateOperation(()=> v, `peekBack()`);
    });

    clearBtn.addEventListener('click', async ()=>{
      await animateOperation(()=> dq.clear(), `clear()`);
    });

    fillRandomBtn.addEventListener('click', async ()=>{
      // fill with some random ints until a bit more than capacity to trigger resize
      const count = Math.floor(Math.random()*6) + 3;
      log(`Filling with ${count} random numbers...`);
      for (let i=0;i<count;i++){
        dq.pushBack(Math.floor(Math.random()*100));
        render();
        await new Promise(r=>setTimeout(r, Math.min(300, Math.max(30, parseInt(speedRange.value,10)||200))));
      }
      log('Done fillRandom.');
    });

    speedRange.addEventListener('input', ()=>{
      speedLabel.textContent = speedRange.value + 'ms';
    });

    function parseInput(s){
      // try to parse numbers and booleans
      const t = s.trim();
      if (t === 'true') return true;
      if (t === 'false') return false;
      if (t === 'null') return null;
      if (!isNaN(Number(t)) && t !== '') return Number(t);
      return t;
    }

    // keyboard shortcuts
    document.addEventListener('keydown', (e)=>{
      if (e.ctrlKey || e.metaKey) return;
      if (e.key === 'Enter') {
        // pushBack
        pushBackBtn.click();
      }
      if (e.key === '[') {
        pushFrontBtn.click();
        e.preventDefault();
      }
      if (e.key === ']') {
        pushBackBtn.click();
        e.preventDefault();
      }
    });

    // initial render
    render();
    log('Deque initialized (capacity 8).');

    // expose to window for debugging
    window._demoDeque = dq;
  </script>
</body>
</html>