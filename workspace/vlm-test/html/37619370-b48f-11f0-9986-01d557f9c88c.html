<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Peterson's Algorithm - Two-Process Mutual Exclusion Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg: #0f172a;
        --panel: #111827;
        --muted: #94a3b8;
        --ok: #10b981;
        --warn: #f59e0b;
        --err: #ef4444;
        --text: #e5e7eb;
        --accent: #60a5fa;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial,
          "Apple Color Emoji", "Segoe UI Emoji";
        background: linear-gradient(180deg, #0b1220, #0f172a);
        color: var(--text);
      }
      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 24px;
      }
      h1 {
        font-size: 28px;
        margin: 0 0 8px 0;
        color: #fafafa;
      }
      p.subtitle {
        color: var(--muted);
        margin: 0 0 16px 0;
      }
      .controls,
      .vars,
      .procs,
      .log {
        background: rgba(17, 24, 39, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 12px;
        padding: 14px;
        margin: 12px 0;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.25);
      }
      .controls .row {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
      }
      button,
      .select,
      .checkbox,
      .range {
        background: #0b1220;
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: var(--text);
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
      }
      button:hover {
        border-color: var(--accent);
      }
      button.primary {
        background: linear-gradient(90deg, #2563eb, #10b981);
        border: none;
      }
      button.warn {
        background: linear-gradient(90deg, #f59e0b, #ef4444);
        border: none;
      }
      .select,
      select,
      .range input {
        background: transparent;
      }
      select {
        color: var(--text);
        border: none;
        outline: none;
      }
      .controls label {
        color: var(--muted);
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 999px;
        background: #0b1220;
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: var(--muted);
        font-size: 12px;
      }
      .stats {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        margin-top: 10px;
      }
      .badge {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: rgba(96, 165, 250, 0.1);
        border: 1px solid rgba(96, 165, 250, 0.25);
        color: #bfdbfe;
        padding: 6px 10px;
        border-radius: 8px;
        font-size: 13px;
      }
      .badge.ok {
        background: rgba(16, 185, 129, 0.12);
        border-color: rgba(16, 185, 129, 0.35);
        color: #b7f7dd;
      }
      .badge.err {
        background: rgba(239, 68, 68, 0.12);
        border-color: rgba(239, 68, 68, 0.35);
        color: #fecaca;
      }
      .vars {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
      }
      .var {
        background: #0b1220;
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 10px;
        padding: 10px;
      }
      .var .name {
        color: var(--muted);
        font-size: 12px;
      }
      .var .value {
        font-weight: 700;
        font-family: ui-monospace, monospace;
        margin-top: 4px;
      }
      .procs {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
      }
      .proc {
        background: #0b1220;
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 12px;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .proc h3 {
        margin: 0;
        font-size: 18px;
      }
      .kv {
        display: grid;
        grid-template-columns: 140px 1fr;
        gap: 6px;
        align-items: center;
      }
      .state {
        font-family: ui-monospace, monospace;
        font-weight: 700;
        padding: 4px 8px;
        border-radius: 6px;
        display: inline-block;
      }
      .state.nc {
        background: rgba(148, 163, 184, 0.1);
        border: 1px solid rgba(148, 163, 184, 0.25);
        color: #cbd5e1;
      }
      .state.try {
        background: rgba(245, 158, 11, 0.12);
        border: 1px solid rgba(245, 158, 11, 0.35);
        color: #fde68a;
      }
      .state.wait {
        background: rgba(96, 165, 250, 0.12);
        border: 1px solid rgba(96, 165, 250, 0.35);
        color: #bfdbfe;
      }
      .state.cs {
        background: rgba(16, 185, 129, 0.12);
        border: 1px solid rgba(16, 185, 129, 0.35);
        color: #b7f7dd;
      }
      .state.exit {
        background: rgba(244, 114, 182, 0.12);
        border: 1px solid rgba(244, 114, 182, 0.35);
        color: #fbcfe8;
      }
      .row-btns {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 6px;
      }
      .log pre {
        margin: 0;
        max-height: 180px;
        overflow: auto;
        white-space: pre-wrap;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        background: #0b1220;
        border-radius: 8px;
        padding: 10px;
        border: 1px solid rgba(255, 255, 255, 0.06);
      }
      .foot {
        color: var(--muted);
        font-size: 12px;
        margin-top: 8px;
      }
      .code {
        background: #0b1220;
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 8px;
        padding: 10px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 12px;
        color: #cbd5e1;
      }
      .hl {
        color: #93c5fd;
      }
      .grid-2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      @media (max-width: 900px) {
        .vars {
          grid-template-columns: 1fr;
        }
        .procs {
          grid-template-columns: 1fr;
        }
        .grid-2 {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Peterson's Algorithm</h1>
      <p class="subtitle">
        A live, step-by-step visualization of two-process mutual exclusion with
        shared variables flag[0], flag[1], and turn.
      </p>

      <div class="controls" role="region" aria-label="Simulation Controls">
        <div class="row">
          <button class="primary" data-testid="start-btn" aria-label="Start">
            Start
          </button>
          <button data-testid="pause-btn" aria-label="Pause">Pause</button>
          <button data-testid="step-btn" aria-label="Step One Tick">
            Step
          </button>
          <button class="warn" data-testid="reset-btn" aria-label="Reset">
            Reset
          </button>

          <span class="pill" title="Ticks executed">
            Ticks: <strong data-testid="tick-count">0</strong>
          </span>

          <label class="select" title="Scheduler strategy">
            Scheduler:
            <select data-testid="scheduler-select" aria-label="Scheduler">
              <option value="alternate">Alternate P0/P1</option>
              <option value="random">Random</option>
              <option value="p0">P0 priority</option>
              <option value="p1">P1 priority</option>
            </select>
          </label>

          <label class="range" title="Tick speed">
            Speed:
            <input
              type="range"
              min="20"
              max="800"
              value="250"
              data-testid="speed-range"
            />
          </label>

          <label class="checkbox" title="Use fixed durations instead of random">
            <input type="checkbox" data-testid="deterministic-toggle" />
            Deterministic durations
          </label>

          <label class="checkbox" title="Loop automatically">
            <input type="checkbox" data-testid="auto-toggle" checked /> Auto
            loop both processes
          </label>
        </div>

        <div class="stats">
          <span
            class="badge ok"
            title="Mutual exclusion is currently satisfied"
          >
            Both in critical? <strong data-testid="both-in-cs">false</strong>
          </span>
          <span
            class="badge"
            title="How many times each process entered the critical section"
          >
            P0 CS entries: <strong data-testid="p0-cs-entries">0</strong>
          </span>
          <span
            class="badge"
            title="How many times each process entered the critical section"
          >
            P1 CS entries: <strong data-testid="p1-cs-entries">0</strong>
          </span>
          <span
            class="badge err"
            title="Number of violations detected (should be 0)"
          >
            Violations: <strong data-testid="violation-count">0</strong>
          </span>
        </div>
      </div>

      <div class="vars" role="region" aria-label="Shared Variables">
        <div class="var" aria-live="polite">
          <div class="name">flag[0]</div>
          <div class="value"><span data-testid="flag-0">false</span></div>
        </div>
        <div class="var" aria-live="polite">
          <div class="name">flag[1]</div>
          <div class="value"><span data-testid="flag-1">false</span></div>
        </div>
        <div class="var" aria-live="polite">
          <div class="name">turn</div>
          <div class="value"><span data-testid="turn-value">0</span></div>
        </div>
      </div>

      <div class="procs" role="region" aria-label="Processes">
        <div class="proc" id="proc0">
          <h3>Process P0</h3>
          <div class="kv">
            <div>State</div>
            <div>
              <span
                class="state nc"
                data-testid="p0-state"
                role="status"
                aria-label="p0-state"
                >noncritical</span
              >
            </div>
          </div>
          <div class="kv">
            <div>flag[0]</div>
            <div><span data-testid="p0-flag">false</span></div>
          </div>
          <div class="kv">
            <div>turn (view)</div>
            <div><span data-testid="p0-turn">0</span></div>
          </div>
          <div class="kv">
            <div>CS time left</div>
            <div><span data-testid="p0-cs-left">0</span></div>
          </div>
          <div class="kv">
            <div>NC time left</div>
            <div><span data-testid="p0-nc-left">0</span></div>
          </div>
          <div class="row-btns">
            <button data-testid="p0-try" aria-label="P0 Try Once">
              P0 Try once
            </button>
            <label class="checkbox" title="Auto loop">
              <input type="checkbox" data-testid="p0-auto" checked /> Auto
            </label>
          </div>
        </div>

        <div class="proc" id="proc1">
          <h3>Process P1</h3>
          <div class="kv">
            <div>State</div>
            <div>
              <span
                class="state nc"
                data-testid="p1-state"
                role="status"
                aria-label="p1-state"
                >noncritical</span
              >
            </div>
          </div>
          <div class="kv">
            <div>flag[1]</div>
            <div><span data-testid="p1-flag">false</span></div>
          </div>
          <div class="kv">
            <div>turn (view)</div>
            <div><span data-testid="p1-turn">0</span></div>
          </div>
          <div class="kv">
            <div>CS time left</div>
            <div><span data-testid="p1-cs-left">0</span></div>
          </div>
          <div class="kv">
            <div>NC time left</div>
            <div><span data-testid="p1-nc-left">0</span></div>
          </div>
          <div class="row-btns">
            <button data-testid="p1-try" aria-label="P1 Try Once">
              P1 Try once
            </button>
            <label class="checkbox" title="Auto loop">
              <input type="checkbox" data-testid="p1-auto" checked /> Auto
            </label>
          </div>
        </div>
      </div>

      <div class="grid-2">
        <div class="log" role="region" aria-label="Event Log">
          <strong>Log</strong>
          <pre data-testid="log"></pre>
        </div>
        <div class="log" role="region" aria-label="Pseudo Code">
          <strong>Peterson's Algorithm (two processes)</strong>
          <div class="code" aria-label="pseudocode">
            <div>// shared:</div>
            <div><span class="hl">boolean</span> flag[2] = {false, false};</div>
            <div><span class="hl">int</span> turn = 0;</div>
            <br />
            <div>process i in {0,1}:</div>
            <div>loop forever:</div>
            <div>// non-critical section</div>
            <div>flag[i] = true;</div>
            <div>turn = j; // j = 1 - i</div>
            <div>while (flag[j] && turn == j) { /* wait */ }</div>
            <div>// critical section</div>
            <div>flag[i] = false;</div>
          </div>
          <div class="foot">
            Invariant: never (P0 in CS and P1 in CS) at the same time.
          </div>
        </div>
      </div>
    </div>

    <script>
      (function () {
        const logEl = document.querySelector('[data-testid="log"]');
        const el = (sel) => document.querySelector(sel);
        const els = (sel) => document.querySelectorAll(sel);

        // Shared variables for Peterson's algorithm
        let flag = [false, false];
        let turn = 0;

        // Simulation controls
        let running = false;
        let timer = null;
        let tickInterval = 250;
        let tickCount = 0;
        let violationCount = 0;
        let lastScheduled = 1; // for alternate scheduling

        // Config
        let deterministic = false;
        let autoBoth = true;

        // Process model
        function makeProc(id) {
          return {
            id,
            state: "noncritical", // 'noncritical','trying_flag','trying_turn','waiting','critical','exiting'
            csLeft: 0,
            ncLeft: 0,
            entries: 0,
            auto: true,
            pendingTry: false,
          };
        }
        let P = [makeProc(0), makeProc(1)];

        // Random helpers (with deterministic fallback)
        function nextCSTicks() {
          if (deterministic) return 2;
          return 1 + Math.floor(Math.random() * 3); // 1..3
        }
        function nextNCTicks() {
          if (deterministic) return 1;
          return 1 + Math.floor(Math.random() * 4); // 1..4
        }

        // UI helpers
        function badgeStateClass(s) {
          if (s === "noncritical") return "state nc";
          if (s === "trying_flag" || s === "trying_turn") return "state try";
          if (s === "waiting") return "state wait";
          if (s === "critical") return "state cs";
          if (s === "exiting") return "state exit";
          return "state";
        }
        function log(msg) {
          const t = new Date().toLocaleTimeString();
          logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent;
        }

        function updateUI() {
          el('[data-testid="flag-0"]').textContent = String(flag[0]);
          el('[data-testid="flag-1"]').textContent = String(flag[1]);
          el('[data-testid="turn-value"]').textContent = String(turn);
          el('[data-testid="tick-count"]').textContent = String(tickCount);
          el('[data-testid="violation-count"]').textContent =
            String(violationCount);

          // process cards
          for (const i of [0, 1]) {
            const p = P[i];
            el(`[data-testid="p${i}-state"]`).textContent = p.state;
            el(`[data-testid="p${i}-state"]`).className = badgeStateClass(
              p.state
            );
            el(`[data-testid="p${i}-flag"]`).textContent = String(flag[i]);
            el(`[data-testid="p${i}-turn"]`).textContent = String(turn);
            el(`[data-testid="p${i}-cs-left"]`).textContent = String(p.csLeft);
            el(`[data-testid="p${i}-nc-left"]`).textContent = String(p.ncLeft);
            // el(`[data-testid="p${i}-cs-entries"]`)?.textContent = String(p.entries);
          }

          // both in CS?
          const both = P[0].state === "critical" && P[1].state === "critical";
          el('[data-testid="both-in-cs"]').textContent = both
            ? "true"
            : "false";
          const bothBadge = el('[data-testid="both-in-cs"]').closest(".badge");
          bothBadge.className = "badge " + (both ? "err" : "ok");

          // totals
          el('[data-testid="p0-cs-entries"]').textContent = String(
            P[0].entries
          );
          el('[data-testid="p1-cs-entries"]').textContent = String(
            P[1].entries
          );
        }

        function resetAll() {
          flag = [false, false];
          turn = 0;
          P = [makeProc(0), makeProc(1)];
          tickCount = 0;
          violationCount = 0;
          lastScheduled = 1;
          P[0].ncLeft = nextNCTicks();
          P[1].ncLeft = nextNCTicks();
          P[0].auto = el('[data-testid="p0-auto"]').checked;
          P[1].auto = el('[data-testid="p1-auto"]').checked;
          autoBoth = el('[data-testid="auto-toggle"]').checked;
          deterministic = el('[data-testid="deterministic-toggle"]').checked;
          updateUI();
          log("Simulation reset.");
        }

        // Transition one micro-step for process i
        function stepProc(i) {
          const j = 1 - i;
          const p = P[i];

          switch (p.state) {
            case "noncritical": {
              // If auto is enabled globally and per-process, count down
              if (autoBoth && p.auto) {
                if (p.ncLeft <= 0) {
                  p.state = "trying_flag";
                  log(`P${i}: wants to enter; set flag[${i}] next`);
                } else {
                  p.ncLeft--;
                  if (p.ncLeft === 0) {
                    // prepare to try next time
                  }
                }
              } else if (p.pendingTry) {
                p.pendingTry = false;
                p.state = "trying_flag";
                log(`P${i}: manual try; set flag[${i}] next`);
              }
              break;
            }

            case "trying_flag": {
              flag[i] = true;
              p.state = "trying_turn";
              log(`P${i}: flag[${i}] = true`);
              break;
            }

            case "trying_turn": {
              turn = j;
              p.state = "waiting";
              log(`P${i}: turn = ${j}`);
              break;
            }

            case "waiting": {
              if (flag[j] && turn === j) {
                // still waiting
                // no-op (spin)
              } else {
                p.state = "critical";
                p.csLeft = nextCSTicks();
                log(`P${i}: enters critical section (for ${p.csLeft} ticks)`);
              }
              break;
            }

            case "critical": {
              if (p.csLeft > 0) {
                p.csLeft--;
              }
              if (p.csLeft === 0) {
                p.state = "exiting";
                p.entries++;
                log(`P${i}: leaving critical; will clear flag[${i}]`);
              }
              break;
            }

            case "exiting": {
              flag[i] = false;
              p.state = "noncritical";
              p.ncLeft = nextNCTicks();
              log(`P${i}: flag[${i}] = false; noncritical (${p.ncLeft} ticks)`);
              break;
            }
          }
        }

        // Safety check and violation detection
        function checkInvariant() {
          const both = P[0].state === "critical" && P[1].state === "critical";
          if (both) {
            violationCount++;
            log("Violation detected! Both in CS.");
          }
        }

        function scheduleNext() {
          const scheduler = el('[data-testid="scheduler-select"]').value;
          if (scheduler === "p0") return 0;
          if (scheduler === "p1") return 1;
          if (scheduler === "random") {
            return Math.random() < 0.5 ? 0 : 1;
          }
          // alternate
          lastScheduled = 1 - lastScheduled;
          return lastScheduled;
        }

        function stepOnce() {
          // choose a process to try step; but ensure progress by allowing other to step too if necessary
          const i = scheduleNext();
          stepProc(i);
          // Some states like waiting require the other to move; do an extra check:
          // If both waiting on each other is impossible in Peterson's for 2 processes, but to drive fairness,
          // also occasionally give the other process a chance on the same tick if running alternate.
          if (P[i].state === "waiting" || P[i].state === "noncritical") {
            const j = 1 - i;
            // give the other one a micro-opportunity
            if (
              Math.random() < 0.25 ||
              el('[data-testid="scheduler-select"]').value === "alternate"
            ) {
              stepProc(j);
            }
          }

          tickCount++;
          checkInvariant();
          updateUI();
        }

        function start() {
          if (running) return;
          running = true;
          clearInterval(timer);
          timer = setInterval(stepOnce, tickInterval);
          log("Started.");
        }
        function pause() {
          running = false;
          clearInterval(timer);
          log("Paused.");
        }

        // Wire up controls
        el('[data-testid="start-btn"]').addEventListener("click", start);
        el('[data-testid="pause-btn"]').addEventListener("click", pause);
        el('[data-testid="step-btn"]').addEventListener("click", stepOnce);
        el('[data-testid="reset-btn"]').addEventListener("click", () => {
          pause();
          resetAll();
        });

        el('[data-testid="speed-range"]').addEventListener("input", (e) => {
          tickInterval = Number(e.target.value);
          if (running) {
            clearInterval(timer);
            timer = setInterval(stepOnce, tickInterval);
          }
        });

        el('[data-testid="scheduler-select"]').addEventListener(
          "change",
          () => {
            log(
              "Scheduler set to " + el('[data-testid="scheduler-select"]').value
            );
          }
        );

        el('[data-testid="deterministic-toggle"]').addEventListener(
          "change",
          (e) => {
            deterministic = e.target.checked;
            log("Deterministic durations: " + deterministic);
          }
        );

        el('[data-testid="auto-toggle"]').addEventListener("change", (e) => {
          autoBoth = e.target.checked;
          log("Auto loop (both): " + autoBoth);
        });

        el('[data-testid="p0-auto"]').addEventListener("change", (e) => {
          P[0].auto = e.target.checked;
          log("P0 auto: " + P[0].auto);
        });
        el('[data-testid="p1-auto"]').addEventListener("change", (e) => {
          P[1].auto = e.target.checked;
          log("P1 auto: " + P[1].auto);
        });

        el('[data-testid="p0-try"]').addEventListener("click", () => {
          if (P[0].state === "noncritical") {
            P[0].pendingTry = true;
            log("P0: manual try requested.");
          }
        });
        el('[data-testid="p1-try"]').addEventListener("click", () => {
          if (P[1].state === "noncritical") {
            P[1].pendingTry = true;
            log("P1: manual try requested.");
          }
        });

        // Initialize
        resetAll();
      })();
    </script>

    <script id="fsm" type="application/json">
      {
        "name": "PetersonTwoProcessDemo",
        "version": "1.0.0",
        "description": "Finite State Machine representing two processes running Peterson's mutual exclusion algorithm with shared variables flag[0], flag[1], and turn.",
        "shared": {
          "variables": {
            "flag": [false, false],
            "turn": 0
          },
          "invariants": [
            "NOT (P0.state == 'critical' AND P1.state == 'critical')"
          ]
        },
        "appStates": {
          "states": ["idle", "running", "paused"],
          "initial": "paused",
          "transitions": [
            { "from": "paused", "to": "running", "on": "start" },
            { "from": "running", "to": "paused", "on": "pause" },
            { "from": "paused", "to": "paused", "on": "step" },
            { "from": ["paused", "running"], "to": "paused", "on": "reset" }
          ]
        },
        "processes": [
          {
            "id": "P0",
            "states": [
              "noncritical",
              "trying_flag",
              "trying_turn",
              "waiting",
              "critical",
              "exiting"
            ],
            "initial": "noncritical",
            "transitions": [
              {
                "from": "noncritical",
                "to": "trying_flag",
                "on": "tick",
                "cond": "desireToEnter(P0)"
              },
              {
                "from": "trying_flag",
                "to": "trying_turn",
                "on": "tick",
                "action": "flag[0]=true"
              },
              {
                "from": "trying_turn",
                "to": "waiting",
                "on": "tick",
                "action": "turn=1"
              },
              {
                "from": "waiting",
                "to": "waiting",
                "on": "tick",
                "cond": "flag[1] && turn==1"
              },
              {
                "from": "waiting",
                "to": "critical",
                "on": "tick",
                "cond": "(!flag[1] || turn!=1)",
                "action": "enterCS(P0)"
              },
              {
                "from": "critical",
                "to": "critical",
                "on": "tick",
                "cond": "csLeft(P0)>0",
                "action": "csLeft(P0)--"
              },
              {
                "from": "critical",
                "to": "exiting",
                "on": "tick",
                "cond": "csLeft(P0)==0"
              },
              {
                "from": "exiting",
                "to": "noncritical",
                "on": "tick",
                "action": "flag[0]=false; resetNC(P0)"
              }
            ]
          },
          {
            "id": "P1",
            "states": [
              "noncritical",
              "trying_flag",
              "trying_turn",
              "waiting",
              "critical",
              "exiting"
            ],
            "initial": "noncritical",
            "transitions": [
              {
                "from": "noncritical",
                "to": "trying_flag",
                "on": "tick",
                "cond": "desireToEnter(P1)"
              },
              {
                "from": "trying_flag",
                "to": "trying_turn",
                "on": "tick",
                "action": "flag[1]=true"
              },
              {
                "from": "trying_turn",
                "to": "waiting",
                "on": "tick",
                "action": "turn=0"
              },
              {
                "from": "waiting",
                "to": "waiting",
                "on": "tick",
                "cond": "flag[0] && turn==0"
              },
              {
                "from": "waiting",
                "to": "critical",
                "on": "tick",
                "cond": "(!flag[0] || turn!=0)",
                "action": "enterCS(P1)"
              },
              {
                "from": "critical",
                "to": "critical",
                "on": "tick",
                "cond": "csLeft(P1)>0",
                "action": "csLeft(P1)--"
              },
              {
                "from": "critical",
                "to": "exiting",
                "on": "tick",
                "cond": "csLeft(P1)==0"
              },
              {
                "from": "exiting",
                "to": "noncritical",
                "on": "tick",
                "action": "flag[1]=false; resetNC(P1)"
              }
            ]
          }
        ],
        "playwright": {
          "events": {
            "start": [{ "click": "[data-testid=\u0022start-btn\u0022]" }],
            "pause": [{ "click": "[data-testid=\u0022pause-btn\u0022]" }],
            "step": [{ "click": "[data-testid=\u0022step-btn\u0022]" }],
            "reset": [{ "click": "[data-testid=\u0022reset-btn\u0022]" }],
            "setAlternateScheduler": [
              {
                "select": {
                  "selector": "[data-testid=\u0022scheduler-select\u0022]",
                  "value": "alternate"
                }
              }
            ],
            "setRandomScheduler": [
              {
                "select": {
                  "selector": "[data-testid=\u0022scheduler-select\u0022]",
                  "value": "random"
                }
              }
            ],
            "enableDeterministic": [
              {
                "check": {
                  "selector": "[data-testid=\u0022deterministic-toggle\u0022]"
                }
              }
            ],
            "enableAuto": [
              {
                "check": { "selector": "[data-testid=\u0022auto-toggle\u0022]" }
              }
            ],
            "p0Try": [{ "click": "[data-testid=\u0022p0-try\u0022]" }],
            "p1Try": [{ "click": "[data-testid=\u0022p1-try\u0022]" }]
          },
          "assertions": {
            "mutualExclusionHolds": [
              {
                "expect": {
                  "selector": "[data-testid=\u0022both-in-cs\u0022]",
                  "text": "false"
                }
              },
              {
                "expect": {
                  "selector": "[data-testid=\u0022violation-count\u0022]",
                  "text": "0"
                }
              }
            ],
            "p0EventuallyEntersCS": [
              {
                "waitForChange": {
                  "selector": "[data-testid=\u0022p0-cs-entries\u0022]",
                  "timeout": 5000
                }
              }
            ],
            "p1EventuallyEntersCS": [
              {
                "waitForChange": {
                  "selector": "[data-testid=\u0022p1-cs-entries\u0022]",
                  "timeout": 5000
                }
              }
            ],
            "bothFlagsOrTurnShow": [
              {
                "expectExist": {
                  "selector": "[data-testid=\u0022flag-0\u0022]"
                }
              },
              {
                "expectExist": {
                  "selector": "[data-testid=\u0022flag-1\u0022]"
                }
              },
              {
                "expectExist": {
                  "selector": "[data-testid=\u0022turn-value\u0022]"
                }
              }
            ]
          },
          "scenarios": [
            {
              "name": "Alternate scheduler maintains mutual exclusion",
              "steps": [
                { "event": "reset" },
                { "event": "enableDeterministic" },
                { "event": "enableAuto" },
                { "event": "setAlternateScheduler" },
                { "event": "start" }
              ],
              "assertions": [
                { "afterMs": 1500, "assert": "mutualExclusionHolds" },
                { "afterMs": 1500, "assert": "p0EventuallyEntersCS" },
                { "afterMs": 1500, "assert": "p1EventuallyEntersCS" }
              ]
            },
            {
              "name": "Manual steps preserve safety",
              "steps": [
                { "event": "reset" },
                { "event": "enableDeterministic" },
                { "event": "setAlternateScheduler" },
                { "repeat": { "event": "step", "times": 30, "delayMs": 5 } }
              ],
              "assertions": [{ "assert": "mutualExclusionHolds" }]
            },
            {
              "name": "Buttons and shared variables are visible",
              "steps": [{ "event": "reset" }],
              "assertions": [{ "assert": "bothFlagsOrTurnShow" }]
            }
          ]
        }
      }
    </script>

    <script id="fsm" type="application/json">
      {
        "topic": "peterson's algorithm",
        "description": "Finite State Machine for an interactive two-process Peterson's mutual exclusion visualization. It models app-level run/pause control and each process's algorithmic phases (noncritical, trying flag/turn, waiting, critical, exiting), along with user-driven scheduler and configuration interactions.",
        "states": [
          {
            "name": "paused",
            "onEnter": "stopTimer",
            "onExit": null,
            "on": {
              "START_CLICK": "running",
              "STEP_CLICK": "paused",
              "RESET_CLICK": "paused",
              "SPEED_CHANGE": "paused",
              "SCHEDULER_CHANGE": "paused",
              "TOGGLE_DETERMINISTIC": "paused",
              "TOGGLE_AUTO_BOTH": "paused",
              "TOGGLE_P0_AUTO": "paused",
              "TOGGLE_P1_AUTO": "paused",
              "P0_TRY_CLICK": "paused",
              "P1_TRY_CLICK": "paused"
            }
          },
          {
            "name": "running",
            "onEnter": "startTimer",
            "onExit": "stopTimer",
            "on": {
              "PAUSE_CLICK": "paused",
              "RESET_CLICK": "paused",
              "SPEED_CHANGE": "running",
              "SCHEDULER_CHANGE": "running",
              "TOGGLE_DETERMINISTIC": "running",
              "TOGGLE_AUTO_BOTH": "running",
              "TOGGLE_P0_AUTO": "running",
              "TOGGLE_P1_AUTO": "running",
              "TIMER_TICK": "running",
              "VIOLATION_DETECTED": "running"
            }
          },
          {
            "name": "p0_noncritical",
            "onEnter": null,
            "onExit": null,
            "on": {
              "P0_READY_TO_TRY": "p0_trying_flag"
            }
          },
          {
            "name": "p0_trying_flag",
            "onEnter": "logP0IntendsToEnter",
            "onExit": "setFlag0True",
            "on": {
              "P0_SET_FLAG_TRUE": "p0_trying_turn"
            }
          },
          {
            "name": "p0_trying_turn",
            "onEnter": null,
            "onExit": "setTurnTo1",
            "on": {
              "P0_SET_TURN_TO_1": "p0_waiting"
            }
          },
          {
            "name": "p0_waiting",
            "onEnter": null,
            "onExit": null,
            "on": {
              "P0_SPIN": "p0_waiting",
              "P0_ENTER_CRITICAL": "p0_critical"
            }
          },
          {
            "name": "p0_critical",
            "onEnter": "setP0CsLeftAndLogEnter",
            "onExit": null,
            "on": {
              "P0_CS_TICK": "p0_critical",
              "P0_CS_DONE": "p0_exiting"
            }
          },
          {
            "name": "p0_exiting",
            "onEnter": "incrementP0EntriesAndLogLeave",
            "onExit": "clearFlag0SetP0NcLeftAndLog",
            "on": {
              "P0_EXIT_TO_NONCRITICAL": "p0_noncritical"
            }
          },
          {
            "name": "p1_noncritical",
            "onEnter": null,
            "onExit": null,
            "on": {
              "P1_READY_TO_TRY": "p1_trying_flag"
            }
          },
          {
            "name": "p1_trying_flag",
            "onEnter": "logP1IntendsToEnter",
            "onExit": "setFlag1True",
            "on": {
              "P1_SET_FLAG_TRUE": "p1_trying_turn"
            }
          },
          {
            "name": "p1_trying_turn",
            "onEnter": null,
            "onExit": "setTurnTo0",
            "on": {
              "P1_SET_TURN_TO_0": "p1_waiting"
            }
          },
          {
            "name": "p1_waiting",
            "onEnter": null,
            "onExit": null,
            "on": {
              "P1_SPIN": "p1_waiting",
              "P1_ENTER_CRITICAL": "p1_critical"
            }
          },
          {
            "name": "p1_critical",
            "onEnter": "setP1CsLeftAndLogEnter",
            "onExit": null,
            "on": {
              "P1_CS_TICK": "p1_critical",
              "P1_CS_DONE": "p1_exiting"
            }
          },
          {
            "name": "p1_exiting",
            "onEnter": "incrementP1EntriesAndLogLeave",
            "onExit": "clearFlag1SetP1NcLeftAndLog",
            "on": {
              "P1_EXIT_TO_NONCRITICAL": "p1_noncritical"
            }
          }
        ],
        "events": [
          "START_CLICK",
          "PAUSE_CLICK",
          "STEP_CLICK",
          "RESET_CLICK",
          "SPEED_CHANGE",
          "SCHEDULER_CHANGE",
          "TOGGLE_DETERMINISTIC",
          "TOGGLE_AUTO_BOTH",
          "TOGGLE_P0_AUTO",
          "TOGGLE_P1_AUTO",
          "P0_TRY_CLICK",
          "P1_TRY_CLICK",
          "TIMER_TICK",
          "VIOLATION_DETECTED",
          "P0_READY_TO_TRY",
          "P0_SET_FLAG_TRUE",
          "P0_SET_TURN_TO_1",
          "P0_SPIN",
          "P0_ENTER_CRITICAL",
          "P0_CS_TICK",
          "P0_CS_DONE",
          "P0_EXIT_TO_NONCRITICAL",
          "P1_READY_TO_TRY",
          "P1_SET_FLAG_TRUE",
          "P1_SET_TURN_TO_0",
          "P1_SPIN",
          "P1_ENTER_CRITICAL",
          "P1_CS_TICK",
          "P1_CS_DONE",
          "P1_EXIT_TO_NONCRITICAL"
        ],
        "notes": "App-level: paused vs running. START_CLICK sets an interval that fires TIMER_TICKs (startTimer), PAUSE_CLICK/RESET_CLICK clears the timer (stopTimer). STEP_CLICK performs a single scheduled tick without leaving paused. SPEED_CHANGE updates tickInterval; SCHEDULER_CHANGE switches among alternate/random/p0/p1 priorities; TOGGLE_DETERMINISTIC flips fixed/random durations; TOGGLE_AUTO_BOTH globally enables auto looping; TOGGLE_P0_AUTO/TOGGLE_P1_AUTO enable per-process auto. P0_TRY_CLICK and P1_TRY_CLICK mark pendingTry only if the process is in noncritical; the actual transition P*_READY_TO_TRY occurs on a subsequent scheduled tick. Process-level: Each process cycles through noncritical → trying_flag → trying_turn → waiting → critical → exiting → noncritical. In trying_flag, on the next micro-step the process sets flag[i]=true and moves to trying_turn; in trying_turn, it sets turn=j (j=1-i) and moves to waiting. In waiting, if flag[j] && turn==j, it spins (P*_SPIN); otherwise it enters critical (P*_ENTER_CRITICAL). On entering critical, csLeft is set to nextCSTicks and a log is written; it decrements csLeft on each P*_CS_TICK until done (P*_CS_DONE) at which point it transitions to exiting, increments entries, and logs leaving. On exiting, the process clears flag[i], sets ncLeft to nextNCTicks, logs noncritical, and transitions to noncritical (P*_EXIT_TO_NONCRITICAL). Scheduler: Each TIMER_TICK schedules exactly one process step via scheduleNext; if the scheduled process is in waiting or noncritical, the other process may also receive a micro-opportunity in the same tick (alternate or 25% random chance) to improve fairness. Invariant monitoring: After each tick, checkInvariant verifies mutual exclusion; if both processes are in critical, VIOLATION_DETECTED increments violationCount and logs an error, but does not change process or app states. UI feedback: shared variables flag[0], flag[1], and turn are updated in updateUI; 'both-in-cs' badge switches between ok/err based on the invariant; stats show per-process critical-section entries and total violations. Initialization: resetAll sets both flags false, turn=0, both processes to noncritical with ncLeft seeded, clears counters, and logs 'Simulation reset.'"
      }
    </script>
  </body>
</html>
