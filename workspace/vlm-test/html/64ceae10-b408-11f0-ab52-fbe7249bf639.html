<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exploring the Binary Tree</title>
    <style>
        body {
            margin: 0;
            padding: 24px;
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
        }
        h1 {
            text-align: center;
        }
        .input-section {
            text-align: center;
            margin: 24px 0;
        }
        .input-section input {
            padding: 8px;
            font-size: 16px;
            margin-right: 16px;
        }
        .input-section button {
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
        }
        .binary-tree {
            display: flex;
            justify-content: center;
            margin-top: 32px;
        }
        .tree-node {
            background-color: #6c757d;
            color: white;
            border-radius: 50%;
            padding: 10px 15px;
            text-align: center;
            transition: all 0.3s ease;
            margin: 4px;
            position: relative;
        }
        .highlight {
            background-color: #28a745;
        }
        #tree-output {
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Exploring the Binary Tree</h1>
    <div class="input-section">
        <input type="number" id="nodeValue" placeholder="Enter a number" />
        <button id="insertBtn">Insert</button>
    </div>
    <div class="binary-tree" id="binaryTree"></div>
    <div id="tree-output">Current Tree (Array Representation): []</div>

    <script>
        class TreeNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
            }
        }

        class BinaryTree {
            constructor() {
                this.root = null;
                this.nodes = [];
            }
            insert(value) {
                const newNode = new TreeNode(value);
                if (!this.root) {
                    this.root = newNode;
                } else {
                    this._insertNode(this.root, newNode);
                }
                this.nodes.push(newNode);
                this.render();
            }
            _insertNode(node, newNode) {
                if (newNode.value < node.value) {
                    if (!node.left) {
                        node.left = newNode;
                    } else {
                        this._insertNode(node.left, newNode);
                    }
                } else if (newNode.value > node.value) {
                    if (!node.right) {
                        node.right = newNode;
                    } else {
                        this._insertNode(node.right, newNode);
                    }
                }
            }
            render() {
                const treeContainer = document.getElementById('binaryTree');
                treeContainer.innerHTML = '';
                this._drawNode(treeContainer, this.root);
                document.getElementById('tree-output').innerText = `Current Tree (Array Representation): [${this.nodes.map(n => n.value).join(', ')}]`;
            }
            _drawNode(container, node) {
                if (!node) return;

                const nodeDiv = document.createElement('div');
                nodeDiv.className = 'tree-node';
                nodeDiv.innerText = node.value;
                nodeDiv.onclick = () => this.highlightPath(node);
                container.appendChild(nodeDiv);
                
                const leftContainer = document.createElement('div');
                const rightContainer = document.createElement('div');

                leftContainer.style.flexDirection = 'column';
                rightContainer.style.flexDirection = 'column';

                nodeDiv.appendChild(leftContainer);
                nodeDiv.appendChild(rightContainer);

                // Recursive drawing of left and right child
                this._drawNode(leftContainer, node.left);
                this._drawNode(rightContainer, node.right);
            }
            highlightPath(node) {
                this.clearHighlights();
                let current = node;
                while (current) {
                    const nodeDivs = document.querySelectorAll('.tree-node');
                    nodeDivs.forEach(n => {
                        if (n.innerText == current.value) {
                            n.classList.add('highlight');
                        }
                    });
                    current = this.root.value > current.value ? current.left : current.right;
                }
            }
            clearHighlights() {
                document.querySelectorAll('.tree-node').forEach(n => {
                    n.classList.remove('highlight');
                });
            }
        }

        const binaryTree = new BinaryTree();
        document.getElementById('insertBtn').onclick = () => {
            const nodeValue = parseInt(document.getElementById('nodeValue').value);
            if (!isNaN(nodeValue)) {
                binaryTree.insert(nodeValue);
                document.getElementById('nodeValue').value = '';  // Clear input field
            } else {
                alert('Please enter a valid number.');
            }
        };
    </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite State Machine for the 'Exploring the Binary Tree' interactive web app, modeling user input, insertion into the binary tree, rendering, node highlighting, and invalid input handling.",
  "states": [
    {
      "name": "app_init",
      "onEnter": "setup_app",
      "on": {
        "APP_READY": "idle_empty"
      }
    },
    {
      "name": "idle_empty",
      "on": {
        "CLICK_INSERT_VALID": "inserting",
        "CLICK_INSERT_INVALID": "invalid_input"
      }
    },
    {
      "name": "idle_populated",
      "on": {
        "CLICK_INSERT_VALID": "inserting",
        "CLICK_INSERT_INVALID": "invalid_input",
        "NODE_CLICK": "highlighting_path"
      }
    },
    {
      "name": "invalid_input",
      "onEnter": "show_alert_invalid_number",
      "on": {
        "ALERT_DISMISSED_EMPTY": "idle_empty",
        "ALERT_DISMISSED_POPULATED": "idle_populated"
      }
    },
    {
      "name": "inserting",
      "onEnter": "insert_node",
      "onExit": "clear_input_field",
      "on": {
        "INSERT_DONE": "rendering"
      }
    },
    {
      "name": "rendering",
      "onEnter": "render_tree_and_update_output",
      "on": {
        "RENDER_COMPLETE": "idle_populated"
      }
    },
    {
      "name": "highlighting_path",
      "onEnter": "clear_highlights_and_highlight_path",
      "on": {
        "HIGHLIGHT_COMPLETE": "idle_populated"
      }
    }
  ],
  "events": [
    "APP_READY",
    "CLICK_INSERT_VALID",
    "CLICK_INSERT_INVALID",
    "INSERT_DONE",
    "RENDER_COMPLETE",
    "NODE_CLICK",
    "HIGHLIGHT_COMPLETE",
    "ALERT_DISMISSED_EMPTY",
    "ALERT_DISMISSED_POPULATED"
  ],
  "notes": "State/action mapping to code: setup_app = instantiate BinaryTree and bind #insertBtn click handler. Valid insert click occurs when parseInt(#nodeValue) is not NaN; invalid shows alert('Please enter a valid number.'). insert_node = BinaryTree.insert(value) which handles creating a new TreeNode, attaching it to the BST via _insertNode, and pushing to nodes array. clear_input_field = document.getElementById('nodeValue').value = ''. render_tree_and_update_output = BinaryTree.render() which rebuilds DOM under #binaryTree via _drawNode, assigns onclick handlers to each node for highlighting, and updates #tree-output with the nodes array. clear_highlights_and_highlight_path = BinaryTree.highlightPath(node) which first calls clearHighlights() to remove 'highlight' class from all .tree-node elements, then traverses from the clicked node downward comparing against root.value and applies 'highlight' to matched DOM nodes. Events INSERT_DONE and RENDER_COMPLETE are conceptual completions of synchronous methods; HIGHLIGHT_COMPLETE is dispatched after traversal/highlighting finishes. ALERT_DISMISSED_* represents user dismissing the blocking alert; choose EMPTY or POPULATED based on whether the tree has a root. Idle states: idle_empty when tree.root is null; after any successful insert/render, transition to idle_populated. Clicking a node only possible in idle_populated (there are clickable nodes); highlighting is transient and leaves the highlights visible upon returning to idle_populated until another NODE_CLICK occurs (which clears then re-highlights). Duplicate values: the code does not attach equal values to the tree (no left/right placement for equality), but still pushes the node into the nodes array; such duplicates will appear in the array output but not in the visual tree and are not clickable. Rendering also binds per-node click handlers during _drawNode."
}
  </script>
</body>
</html>