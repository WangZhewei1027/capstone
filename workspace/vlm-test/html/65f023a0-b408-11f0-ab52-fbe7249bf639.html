<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Deque Exploration</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background-color: #f9f9f9;
        margin: 0;
        padding: 24px;
      }

      .container {
        max-width: 800px;
        margin: auto;
        padding: 16px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        background-color: #ffffff;
      }

      h1 {
        text-align: center;
        color: #333;
      }

      h2 {
        color: #555;
      }

      .deque-display {
        display: flex;
        justify-content: center;
        margin: 16px 0;
        border: 2px dashed #0073e6;
        padding: 16px;
        border-radius: 8px;
      }

      .element {
        background-color: #0073e6;
        color: white;
        padding: 8px 16px;
        margin: 0 8px;
        border-radius: 4px;
      }

      .controls {
        display: flex;
        justify-content: space-between;
        margin: 16px 0;
      }

      input[type="text"] {
        width: 70%;
        padding: 8px;
        margin-right: 16px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      button {
        padding: 8px 16px;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      button:hover {
        background-color: #218838;
      }

      .info {
        margin-top: 16px;
        text-align: center;
        color: #666;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Interactive Deque</h1>
      <h2>Learning Objective</h2>
      <p>
        Understand how a Deque (Double-Ended Queue) works by adding and removing
        elements from both ends interactively.
      </p>

      <div class="deque-display" id="deque-display">
        <!-- Deque elements will be displayed here -->
      </div>

      <div class="controls">
        <input
          type="text"
          id="element-input"
          placeholder="Enter an element..."
        />
        <button id="add-front">Add to Front</button>
        <button id="add-back">Add to Back</button>
        <button id="remove-front">Remove from Front</button>
        <button id="remove-back">Remove from Back</button>
      </div>

      <div class="info" id="info"></div>
    </div>

    <script>
      const deque = [];
      const dequeDisplay = document.getElementById("deque-display");
      const elementInput = document.getElementById("element-input");
      const info = document.getElementById("info");

      function updateDequeDisplay() {
        dequeDisplay.innerHTML = "";
        deque.forEach((element) => {
          const div = document.createElement("div");
          div.className = "element";
          div.innerText = element;
          dequeDisplay.appendChild(div);
        });
        info.innerText = `Current Deque: [${deque.join(", ")}]`;
      }

      document.getElementById("add-front").onclick = () => {
        const value = elementInput.value.trim();
        if (value) {
          deque.unshift(value);
          updateDequeDisplay();
          elementInput.value = "";
        }
      };

      document.getElementById("add-back").onclick = () => {
        const value = elementInput.value.trim();
        if (value) {
          deque.push(value);
          updateDequeDisplay();
          elementInput.value = "";
        }
      };

      document.getElementById("remove-front").onclick = () => {
        if (deque.length > 0) {
          deque.shift();
          updateDequeDisplay();
        }
      };

      document.getElementById("remove-back").onclick = () => {
        if (deque.length > 0) {
          deque.pop();
          updateDequeDisplay();
        }
      };
    </script>

    <script id="fsm" type="application/json">
      {
        "topic": "Interactive Deque Application",
        "description": "Finite State Machine for an interactive Double-Ended Queue (Deque) web app that allows users to add and remove elements from both front and back ends, with input validation and visual updates.",
        "states": [
          {
            "name": "idle",
            "onEnter": "set_idle_state",
            "on": {
              "CLICK_ADD_FRONT": "validating_front_input",
              "CLICK_ADD_BACK": "validating_back_input",
              "CLICK_REMOVE_FRONT": "removing_from_front",
              "CLICK_REMOVE_BACK": "removing_from_back"
            }
          },
          {
            "name": "validating_front_input",
            "onEnter": "validate_input_for_front_add",
            "on": {
              "INPUT_EMPTY": "idle",
              "INPUT_VALID": "adding_to_front"
            }
          },
          {
            "name": "validating_back_input",
            "onEnter": "validate_input_for_back_add",
            "on": {
              "INPUT_EMPTY": "idle",
              "INPUT_VALID": "adding_to_back"
            }
          },
          {
            "name": "adding_to_front",
            "onEnter": "perform_unshift_operation",
            "on": {
              "ELEMENT_ADDED_FRONT": "updating_display"
            }
          },
          {
            "name": "adding_to_back",
            "onEnter": "perform_push_operation",
            "on": {
              "ELEMENT_ADDED_BACK": "updating_display"
            }
          },
          {
            "name": "removing_from_front",
            "onEnter": "check_deque_not_empty_for_front",
            "on": {
              "DEQUE_EMPTY": "idle",
              "DEQUE_NOT_EMPTY": "performing_front_removal"
            }
          },
          {
            "name": "removing_from_back",
            "onEnter": "check_deque_not_empty_for_back",
            "on": {
              "DEQUE_EMPTY": "idle",
              "DEQUE_NOT_EMPTY": "performing_back_removal"
            }
          },
          {
            "name": "performing_front_removal",
            "onEnter": "perform_shift_operation",
            "on": {
              "ELEMENT_REMOVED_FRONT": "updating_display"
            }
          },
          {
            "name": "performing_back_removal",
            "onEnter": "perform_pop_operation",
            "on": {
              "ELEMENT_REMOVED_BACK": "updating_display"
            }
          },
          {
            "name": "updating_display",
            "onEnter": "render_deque_display",
            "on": {
              "DISPLAY_UPDATED": "clearing_input"
            }
          },
          {
            "name": "clearing_input",
            "onEnter": "clear_input_field",
            "on": {
              "INPUT_CLEARED": "idle"
            }
          }
        ],
        "events": [
          "CLICK_ADD_FRONT",
          "CLICK_ADD_BACK",
          "CLICK_REMOVE_FRONT",
          "CLICK_REMOVE_BACK",
          "INPUT_EMPTY",
          "INPUT_VALID",
          "DEQUE_EMPTY",
          "DEQUE_NOT_EMPTY",
          "ELEMENT_ADDED_FRONT",
          "ELEMENT_ADDED_BACK",
          "ELEMENT_REMOVED_FRONT",
          "ELEMENT_REMOVED_BACK",
          "DISPLAY_UPDATED",
          "INPUT_CLEARED"
        ],
        "notes": "Mapping to code: CLICK_ADD_FRONT/CLICK_ADD_BACK are triggered by the respective button onclick handlers. validating_front_input/validating_back_input correspond to the value.trim() check in the onclick handlers. INPUT_EMPTY occurs when the trimmed value is empty, causing no action. INPUT_VALID transitions to adding states. adding_to_front/adding_to_back correspond to deque.unshift(value) and deque.push(value) operations respectively. removing_from_front/removing_from_back first check if deque.length > 0. If empty, DEQUE_EMPTY returns to idle. If not empty, DEQUE_NOT_EMPTY proceeds to performing removal states. performing_front_removal/performing_back_removal execute deque.shift() and deque.pop() respectively. updating_display calls updateDequeDisplay() which rebuilds the DOM elements and updates the info text. clearing_input sets elementInput.value = '' (only for add operations). All operations return to idle state after completion. The FSM abstracts the sequential steps in each button handler into distinct states for clarity and better visualization of the deque operations flow."
      }
    </script>
  </body>
</html>
