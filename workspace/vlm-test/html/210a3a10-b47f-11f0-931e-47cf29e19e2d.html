<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Binary Search Tree Visualizer</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --accent: #22d3ee;
    --accent2: #a78bfa;
    --text: #e5e7eb;
    --muted: #9ca3af;
    --danger: #ef4444;
    --success: #10b981;
    --warn: #f59e0b;
    --node: #1f2937;
    --edge: #334155;
  }
  html, body {
    margin: 0;
    padding: 0;
    background: radial-gradient(1200px 600px at 20% 0%, #10192f 0%, #0a0f1f 100%), var(--bg);
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    height: 100%;
  }
  header {
    padding: 20px;
    text-align: center;
  }
  header h1 {
    margin: 0 0 8px;
    font-size: 24px;
    letter-spacing: 0.5px;
  }
  header p {
    margin: 0;
    color: var(--muted);
    font-size: 14px;
  }
  .container {
    display: grid;
    grid-template-columns: 360px 1fr;
    gap: 20px;
    padding: 20px;
  }
  .panel {
    background: linear-gradient(180deg, #0b1327, #0c1428);
    border: 1px solid #0f1b33;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.25);
  }
  .controls {
    padding: 16px;
  }
  .controls .row {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    align-items: center;
  }
  .controls label {
    font-size: 13px;
    color: var(--muted);
  }
  .controls input[type="number"] {
    flex: 1;
    padding: 10px 12px;
    border-radius: 10px;
    border: 1px solid #1f2d4a;
    background: #0b1224;
    color: var(--text);
    outline: none;
    transition: border-color 0.15s ease, box-shadow 0.15s ease;
  }
  .controls input[type="number"]:focus {
    border-color: #2563eb;
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
  }
  .btn {
    appearance: none;
    border: none;
    border-radius: 10px;
    padding: 10px 14px;
    font-weight: 600;
    cursor: pointer;
    color: #0b1224;
    transition: transform 0.05s ease, filter 0.15s ease, box-shadow 0.15s ease;
  }
  .btn:hover { filter: brightness(1.05); }
  .btn:active { transform: translateY(1px); }
  .btn-insert { background: linear-gradient(90deg, #22d3ee, #06b6d4); color: #001018; }
  .btn-search { background: linear-gradient(90deg, #a78bfa, #7c3aed); color: #0e0618; }
  .btn-delete { background: linear-gradient(90deg, #ef4444, #dc2626); color: #180404; }
  .btn-clear  { background: linear-gradient(90deg, #f59e0b, #d97706); color: #170d03; }
  .status {
    margin-top: 10px;
    padding: 10px 12px;
    border-radius: 10px;
    background: #0b1224;
    border: 1px solid #1f2d4a;
    color: var(--muted);
    min-height: 42px;
  }
  .status.ok { color: #b7f6e7; border-color: #0f4f46; background: #071a18; }
  .status.warn { color: #ffe7b3; border-color: #4f3d0f; background: #1a1607; }
  .status.err { color: #ffc9c9; border-color: #4f0f18; background: #1a070a; }
  .viz {
    position: relative;
    padding: 8px;
  }
  .viz header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    border-bottom: 1px solid #0f1b33;
  }
  .viz header h2 {
    font-size: 16px;
    margin: 0;
    color: #cbd5e1;
    letter-spacing: 0.2px;
  }
  .viz .root-box {
    font-size: 13px;
    color: var(--muted);
  }
  .svg-wrap {
    padding: 8px;
  }
  svg {
    width: 100%;
    height: 500px;
    background: radial-gradient(600px 300px at 50% -20%, #0b1224, #070d1a);
    border-radius: 12px;
    border: 1px solid #0f1b33;
  }
  .edge {
    stroke: var(--edge);
    stroke-width: 2;
  }
  .node {
    cursor: default;
    transition: transform 0.15s ease;
  }
  .node:hover { transform: scale(1.03); }
  .node circle {
    fill: var(--node);
    stroke: #1f2d4a;
    stroke-width: 2;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.25));
  }
  .node text {
    fill: #e5e7eb;
    font-weight: 700;
    font-size: 13px;
    text-anchor: middle;
    dominant-baseline: central;
  }
  .node.root circle {
    stroke: #22d3ee;
    stroke-width: 2.5;
  }
  .path-highlight circle {
    stroke: #a78bfa !important;
    stroke-width: 3 !important;
  }
  .found circle {
    stroke: #10b981 !important;
    stroke-width: 4 !important;
    filter: drop-shadow(0 0 12px rgba(16,185,129,0.45));
  }
  .deleted {
    opacity: 0.15;
  }
  .legend {
    display: flex;
    gap: 12px;
    align-items: center;
    font-size: 12px;
    color: var(--muted);
    padding: 8px 12px 0;
  }
  .legend .swatch {
    width: 16px;
    height: 16px;
    border-radius: 999px;
    display: inline-block;
    margin-right: 6px;
    border: 2px solid var(--accent);
    background: #0b1224;
  }
  .legend .swatch.path { border-color: #a78bfa; }
  .legend .swatch.found { border-color: #10b981; }
  .traversals {
    padding: 12px 16px 16px;
    border-top: 1px solid #0f1b33;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    font-size: 13px;
  }
  .traversal-card {
    background: #0b1224;
    border: 1px solid #1f2d4a;
    border-radius: 10px;
    padding: 10px;
  }
  .traversal-card h3 {
    margin: 0 0 6px;
    font-size: 13px;
    color: #cbd5e1;
  }
  .traversal-card pre {
    margin: 0;
    white-space: pre-wrap;
    word-break: break-word;
    color: #b2c1d6;
  }
  .footer-note {
    text-align: center;
    color: var(--muted);
    font-size: 12px;
    padding: 8px 0 16px;
  }
</style>
</head>
<body>
  <header>
    <h1>Binary Search Tree (BST) Visualizer</h1>
    <p>Insert, search, delete, and clear values. See a real-time visualization and traversals.</p>
  </header>

  <div class="container">
    <section class="panel controls" aria-label="Controls Panel">
      <div class="row" role="group" aria-label="Value Entry">
        <label for="value-input">Value</label>
        <input id="value-input" data-testid="value-input" aria-label="Value" type="number" step="1" placeholder="e.g., 42">
      </div>
      <div class="row" role="group" aria-label="Actions">
        <button class="btn btn-insert" role="button" aria-label="Insert" data-testid="btn-insert">Insert</button>
        <button class="btn btn-search" role="button" aria-label="Search" data-testid="btn-search">Search</button>
        <button class="btn btn-delete" role="button" aria-label="Delete" data-testid="btn-delete">Delete</button>
        <button class="btn btn-clear"  role="button" aria-label="Clear"  data-testid="btn-clear">Clear</button>
      </div>
      <div class="status" role="status" aria-live="polite" data-testid="status">BST is empty. Insert a value to begin.</div>
    </section>

    <section class="panel viz" aria-label="Visualization Panel">
      <header>
        <h2>Tree</h2>
        <div class="root-box">Root: <span data-testid="root-value" aria-label="Root Value">null</span></div>
      </header>

      <div class="legend">
        <span><span class="swatch"></span>Node</span>
        <span><span class="swatch path"></span>Search Path</span>
        <span><span class="swatch found"></span>Found</span>
      </div>

      <div class="svg-wrap">
        <svg role="img" aria-label="Binary Search Tree Visualization" data-testid="tree-svg"></svg>
      </div>

      <div class="traversals" data-testid="traversals">
        <div class="traversal-card">
          <h3>In-order</h3>
          <pre aria-label="In-order Traversal" data-testid="inorder">[]</pre>
        </div>
        <div class="traversal-card">
          <h3>Pre-order</h3>
          <pre aria-label="Pre-order Traversal" data-testid="preorder">[]</pre>
        </div>
        <div class="traversal-card">
          <h3>Post-order</h3>
          <pre aria-label="Post-order Traversal" data-testid="postorder">[]</pre>
        </div>
        <div class="traversal-card">
          <h3>Level-order</h3>
          <pre aria-label="Level-order Traversal" data-testid="levelorder">[]</pre>
        </div>
      </div>
    </section>
  </div>

  <div class="footer-note">Tip: BST maintains the invariant left < node < right. In-order traversal returns a sorted sequence.</div>

<script>
(function(){
  // Basic BST implementation with visualization support
  class Node {
    constructor(value) {
      this.value = value;
      this.left = null;
      this.right = null;
      // layout
      this.x = 0;
      this.y = 0;
      this.depth = 0;
    }
  }

  class BST {
    constructor() {
      this.root = null;
      this._deletedFlag = false;
    }
    insert(value) {
      if (this.root === null) {
        this.root = new Node(value);
        return { inserted: true, duplicate: false };
      }
      let cur = this.root;
      while (cur) {
        if (value === cur.value) {
          return { inserted: false, duplicate: true };
        } else if (value < cur.value) {
          if (!cur.left) { cur.left = new Node(value); return { inserted: true, duplicate: false }; }
          cur = cur.left;
        } else {
          if (!cur.right) { cur.right = new Node(value); return { inserted: true, duplicate: false }; }
          cur = cur.right;
        }
      }
      return { inserted: false, duplicate: false };
    }
    search(value) {
      const path = [];
      let cur = this.root;
      while (cur) {
        path.push(cur);
        if (value === cur.value) {
          return { found: true, node: cur, path };
        } else if (value < cur.value) {
          cur = cur.left;
        } else {
          cur = cur.right;
        }
      }
      return { found: false, node: null, path };
    }
    delete(value) {
      this._deletedFlag = false;
      this.root = this._deleteRec(this.root, value);
      return this._deletedFlag;
    }
    _deleteRec(node, value) {
      if (!node) return null;
      if (value < node.value) {
        node.left = this._deleteRec(node.left, value);
      } else if (value > node.value) {
        node.right = this._deleteRec(node.right, value);
      } else {
        // found
        this._deletedFlag = true;
        if (!node.left && !node.right) return null;
        if (!node.left) return node.right;
        if (!node.right) return node.left;
        // two children: replace with inorder successor (min of right subtree)
        let succParent = node;
        let succ = node.right;
        while (succ.left) { succParent = succ; succ = succ.left; }
        node.value = succ.value;
        if (succParent === node) {
          succParent.right = this._deleteRec(succParent.right, succ.value);
        } else {
          succParent.left = this._deleteRec(succParent.left, succ.value);
        }
      }
      return node;
    }
    clear() { this.root = null; }
    count(node = this.root) {
      if (!node) return 0;
      return 1 + this.count(node.left) + this.count(node.right);
    }
    inorder(node = this.root, out = []) {
      if (!node) return out;
      this.inorder(node.left, out);
      out.push(node.value);
      this.inorder(node.right, out);
      return out;
    }
    preorder(node = this.root, out = []) {
      if (!node) return out;
      out.push(node.value);
      this.preorder(node.left, out);
      this.preorder(node.right, out);
      return out;
    }
    postorder(node = this.root, out = []) {
      if (!node) return out;
      this.postorder(node.left, out);
      this.postorder(node.right, out);
      out.push(node.value);
      return out;
    }
    levelorder() {
      const res = [];
      const q = [];
      if (this.root) q.push(this.root);
      while (q.length) {
        const n = q.shift();
        res.push(n.value);
        if (n.left) q.push(n.left);
        if (n.right) q.push(n.right);
      }
      return res;
    }
    computeLayout(width, height) {
      // Assign positions based on in-order index for x, depth for y.
      const total = this.count();
      let index = 0;
      const xPadding = 24;
      const yStart = 50;
      const yStep = Math.max(70, Math.min(120, height / 6));

      const visit = (node, depth) => {
        if (!node) return;
        visit(node.left, depth + 1);
        index++;
        node.x = xPadding + (index / (total + 1)) * (width - xPadding * 2);
        node.y = yStart + depth * yStep;
        node.depth = depth;
        visit(node.right, depth + 1);
      };
      visit(this.root, 0);
    }
    nodesAndEdges() {
      const nodes = [];
      const edges = [];
      const walk = (node) => {
        if (!node) return;
        nodes.push(node);
        if (node.left) {
          edges.push([node, node.left]);
          walk(node.left);
        }
        if (node.right) {
          edges.push([node, node.right]);
          walk(node.right);
        }
      };
      walk(this.root);
      return { nodes, edges };
    }
  }

  // DOM references
  const input = document.querySelector('[data-testid="value-input"]');
  const btnInsert = document.querySelector('[data-testid="btn-insert"]');
  const btnSearch = document.querySelector('[data-testid="btn-search"]');
  const btnDelete = document.querySelector('[data-testid="btn-delete"]');
  const btnClear  = document.querySelector('[data-testid="btn-clear"]');
  const statusEl = document.querySelector('[data-testid="status"]');
  const svg = document.querySelector('[data-testid="tree-svg"]');
  const rootValueEl = document.querySelector('[data-testid="root-value"]');
  const inorderEl = document.querySelector('[data-testid="inorder"]');
  const preorderEl = document.querySelector('[data-testid="preorder"]');
  const postorderEl = document.querySelector('[data-testid="postorder"]');
  const levelorderEl = document.querySelector('[data-testid="levelorder"]');

  const bst = new BST();

  function setStatus(text, type = '') {
    statusEl.textContent = text;
    statusEl.classList.remove('ok', 'warn', 'err');
    if (type === 'ok') statusEl.classList.add('ok');
    if (type === 'warn') statusEl.classList.add('warn');
    if (type === 'err') statusEl.classList.add('err');
  }

  function renderTraversals() {
    inorderEl.textContent = JSON.stringify(bst.inorder());
    preorderEl.textContent = JSON.stringify(bst.preorder());
    postorderEl.textContent = JSON.stringify(bst.postorder());
    levelorderEl.textContent = JSON.stringify(bst.levelorder());
  }

  function clearSVG() {
    while (svg.firstChild) svg.removeChild(svg.firstChild);
  }

  function renderTree(highlightPath = [], foundNode = null) {
    clearSVG();
    const bbox = svg.getBoundingClientRect();
    const width = bbox.width || 800;
    const height = bbox.height || 500;
    bst.computeLayout(width, height);

    const { nodes, edges } = bst.nodesAndEdges();

    // Draw edges first
    edges.forEach(([a,b]) => {
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', a.x);
      line.setAttribute('y1', a.y);
      line.setAttribute('x2', b.x);
      line.setAttribute('y2', b.y);
      line.setAttribute('class', 'edge');
      svg.appendChild(line);
    });

    // Draw nodes
    nodes.forEach(n => {
      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('transform', `translate(${n.x},${n.y})`);
      g.setAttribute('class', 'node' + (bst.root === n ? ' root' : ''));
      g.setAttribute('aria-label', `Node ${n.value}`);
      g.setAttribute('data-testid', `node-${n.value}`);

      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('r', 20);

      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.textContent = n.value;

      g.appendChild(circle);
      g.appendChild(text);

      // Path highlight
      if (highlightPath.includes(n)) {
        g.classList.add('path-highlight');
      }
      if (foundNode === n) {
        g.classList.add('found');
      }

      svg.appendChild(g);
    });

    rootValueEl.textContent = bst.root ? String(bst.root.value) : 'null';
    renderTraversals();
  }

  function parseInput() {
    const v = input.value.trim();
    if (v === '') return { valid: false, reason: 'Please enter a number.' };
    const num = Number(v);
    if (!Number.isFinite(num)) return { valid: false, reason: 'Invalid number.' };
    if (!Number.isInteger(num)) return { valid: false, reason: 'Only integer values are supported.' };
    return { valid: true, value: num };
  }

  function afterActionFocus() {
    input.focus();
    input.select?.();
  }

  // Event handlers
  btnInsert.addEventListener('click', () => {
    const p = parseInput();
    if (!p.valid) {
      setStatus(p.reason, 'err');
      renderTree();
      afterActionFocus();
      return;
    }
    const res = bst.insert(p.value);
    if (res.duplicate) {
      setStatus(`Duplicate value "${p.value}" not inserted.`, 'warn');
    } else if (res.inserted) {
      setStatus(`Inserted ${p.value}.`, 'ok');
    } else {
      setStatus(`Insert failed for ${p.value}.`, 'err');
    }
    renderTree([], null);
    afterActionFocus();
  });

  btnSearch.addEventListener('click', () => {
    const p = parseInput();
    if (!p.valid) {
      setStatus(p.reason, 'err');
      renderTree();
      afterActionFocus();
      return;
    }
    const res = bst.search(p.value);
    if (res.found) {
      setStatus(`Found ${p.value}.`, 'ok');
      renderTree(res.path, res.node);
    } else {
      setStatus(`Not found: ${p.value}.`, 'warn');
      renderTree(res.path, null);
    }
    afterActionFocus();
  });

  btnDelete.addEventListener('click', () => {
    const p = parseInput();
    if (!p.valid) {
      setStatus(p.reason, 'err');
      renderTree();
      afterActionFocus();
      return;
    }
    const deleted = bst.delete(p.value);
    if (deleted) {
      setStatus(`Deleted ${p.value}.`, 'ok');
    } else {
      setStatus(`Value ${p.value} not found.`, 'warn');
    }
    renderTree([], null);
    afterActionFocus();
  });

  btnClear.addEventListener('click', () => {
    bst.clear();
    setStatus('Cleared tree.', 'ok');
    renderTree([], null);
    afterActionFocus();
  });

  // Keyboard shortcuts for convenience
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      btnInsert.click();
    } else if (e.key.toLowerCase() === 's' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      btnSearch.click();
    } else if (e.key.toLowerCase() === 'd' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      btnDelete.click();
    } else if (e.key.toLowerCase() === 'k' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      btnClear.click();
    }
  });

  // Initial render
  renderTree([], null);

  // Expose some helpers for E2E debug (no globals leaked other than window.__bst__)
  window.__bst__ = {
    getRootValue: () => bst.root ? bst.root.value : null,
    getInorder: () => bst.inorder(),
    getPreorder: () => bst.preorder(),
    getPostorder: () => bst.postorder(),
    getLevelorder: () => bst.levelorder()
  };
})();
</script>

<script id="fsm" type="application/json">
{
  "fsm": {
    "name": "BinarySearchTreeFSM",
    "initial": "Empty",
    "states": {
      "Empty": {
        "description": "Tree has no nodes.",
        "on": {
          "INSERT_VALID": "Ready",
          "INSERT_INVALID": "Error",
          "SEARCH": "Empty",
          "DELETE": "Empty",
          "CLEAR": "Empty"
        }
      },
      "Ready": {
        "description": "Tree has at least one node; idle between operations.",
        "on": {
          "INSERT_VALID": "Ready",
          "INSERT_DUPLICATE": "Ready",
          "INSERT_INVALID": "Error",
          "SEARCH": "Searching",
          "DELETE": "Deleting",
          "CLEAR": "Clearing"
        }
      },
      "Searching": {
        "description": "Highlight path root->leaf until value is found or exhausted.",
        "on": {
          "SEARCH_FOUND": "Ready",
          "SEARCH_NOT_FOUND": "Ready",
          "CANCEL": "Ready"
        }
      },
      "Deleting": {
        "description": "Remove a node (leaf, one child, or two children with successor replacement).",
        "on": {
          "DELETE_DONE": "Ready",
          "DELETE_NOT_FOUND": "Ready"
        }
      },
      "Clearing": {
        "description": "Remove all nodes; reset to empty.",
        "on": {
          "CLEAR_DONE": "Empty"
        }
      },
      "Error": {
        "description": "Invalid input or operation.",
        "on": {
          "RESET": "Ready",
          "CLEAR": "Empty"
        }
      }
    },
    "events": [
      { "name": "INSERT_VALID", "payload": { "value": "integer" } },
      { "name": "INSERT_DUPLICATE", "payload": { "value": "integer" } },
      { "name": "INSERT_INVALID", "payload": { "reason": "string" } },
      { "name": "SEARCH", "payload": { "value": "integer" } },
      { "name": "SEARCH_FOUND", "payload": { "value": "integer" } },
      { "name": "SEARCH_NOT_FOUND", "payload": { "value": "integer" } },
      { "name": "DELETE", "payload": { "value": "integer" } },
      { "name": "DELETE_DONE", "payload": { "value": "integer" } },
      { "name": "DELETE_NOT_FOUND", "payload": { "value": "integer" } },
      { "name": "CLEAR" },
      { "name": "CLEAR_DONE" },
      { "name": "RESET" }
    ],
    "actions": {
      "renderTree": "Update SVG nodes and edges to reflect the current BST structure.",
      "renderTraversals": "Update in-order, pre-order, post-order, and level-order outputs.",
      "setStatus": "Update status message with outcome of operation.",
      "highlightPath": "Mark nodes along the search path; mark found node distinctly."
    },
    "invariant": "For every node N: all nodes in N.left are < N.value and all nodes in N.right are > N.value.",
    "notes": "Duplicates are ignored by design; delete uses in-order successor."
  },
  "playwright": {
    "description": "Event-to-action mappings and assertions for E2E tests of the BST UI.",
    "flows": [
      {
        "name": "Insert basic nodes and verify traversals",
        "steps": [
          { "action": "fill", "selector": "[data-testid='value-input']", "value": "10" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },
          { "assert": { "selector": "[data-testid='node-10']", "exists": true } },
          { "assert": { "selector": "[data-testid='root-value']", "text": "10" } },

          { "action": "fill", "selector": "[data-testid='value-input']", "value": "5" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },
          { "assert": { "selector": "[data-testid='node-5']", "exists": true } },

          { "action": "fill", "selector": "[data-testid='value-input']", "value": "15" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },
          { "assert": { "selector": "[data-testid='node-15']", "exists": true } },

          { "action": "fill", "selector": "[data-testid='value-input']", "value": "3" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },
          { "action": "fill", "selector": "[data-testid='value-input']", "value": "7" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },
          { "action": "fill", "selector": "[data-testid='value-input']", "value": "12" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },
          { "action": "fill", "selector": "[data-testid='value-input']", "value": "18" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },

          { "assert": {
            "selector": "[data-testid='inorder']",
            "text": "[3,5,7,10,12,15,18]"
          } },
          { "assert": {
            "selector": "[data-testid='preorder']",
            "text": "[10,5,3,7,15,12,18]"
          } },
          { "assert": {
            "selector": "[data-testid='levelorder']",
            "text": "[10,5,15,3,7,12,18]"
          } }
        ]
      },
      {
        "name": "Search value and verify path/highlight",
        "steps": [
          { "action": "fill", "selector": "[data-testid='value-input']", "value": "7" },
          { "action": "click", "selector": "[role='button'][aria-label='Search']" },
          { "assert": { "selector": "[data-testid='status']", "text": "Found 7." } },
          { "assert": { "selector": "[data-testid='node-7']", "hasClass": "found" } }
        ]
      },
      {
        "name": "Delete leaf and one-child nodes, verify traversal updates",
        "steps": [
          { "action": "fill", "selector": "[data-testid='value-input']", "value": "3" },
          { "action": "click", "selector": "[role='button'][aria-label='Delete']" },
          { "assert": { "selector": "[data-testid='status']", "text": "Deleted 3." } },
          { "assert": { "selector": "[data-testid='node-3']", "exists": false } },
          { "assert": { "selector": "[data-testid='inorder']", "text": "[5,7,10,12,15,18]" } },

          { "action": "fill", "selector": "[data-testid='value-input']", "value": "5" },
          { "action": "click", "selector": "[role='button'][aria-label='Delete']" },
          { "assert": { "selector": "[data-testid='status']", "text": "Deleted 5." } },
          { "assert": { "selector": "[data-testid='inorder']", "text": "[7,10,12,15,18]" } }
        ]
      },
      {
        "name": "Two-children deletion uses in-order successor",
        "steps": [
          { "action": "click", "selector": "[role='button'][aria-label='Clear']" },
          { "assert": { "selector": "[data-testid='root-value']", "text": "null" } },

          { "action": "fill", "selector": "[data-testid='value-input']", "value": "50" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },
          { "action": "fill", "selector": "[data-testid='value-input']", "value": "30" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },
          { "action": "fill", "selector": "[data-testid='value-input']", "value": "70" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },
          { "action": "fill", "selector": "[data-testid='value-input']", "value": "20" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },
          { "action": "fill", "selector": "[data-testid='value-input']", "value": "40" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },
          { "action": "fill", "selector": "[data-testid='value-input']", "value": "60" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },
          { "action": "fill", "selector": "[data-testid='value-input']", "value": "80" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },

          { "assert": { "selector": "[data-testid='root-value']", "text": "50" } },
          { "action": "fill", "selector": "[data-testid='value-input']", "value": "50" },
          { "action": "click", "selector": "[role='button'][aria-label='Delete']" },
          { "assert": { "selector": "[data-testid='status']", "text": "Deleted 50." } },
          { "assert": { "selector": "[data-testid='root-value']", "text": "60" } },
          { "assert": { "selector": "[data-testid='inorder']", "text": "[20,30,40,60,70,80]" } }
        ]
      },
      {
        "name": "Clear tree resets everything",
        "steps": [
          { "action": "click", "selector": "[role='button'][aria-label='Clear']" },
          { "assert": { "selector": "[data-testid='status']", "text": "Cleared tree." } },
          { "assert": { "selector": "[data-testid='root-value']", "text": "null" } },
          { "assert": { "selector": "[data-testid='inorder']", "text": "[]" } },
          { "assert": { "selector": "[data-testid='preorder']", "text": "[]" } },
          { "assert": { "selector": "[data-testid='postorder']", "text": "[]" } },
          { "assert": { "selector": "[data-testid='levelorder']", "text": "[]" } }
        ]
      },
      {
        "name": "Invalid input handling",
        "steps": [
          { "action": "fill", "selector": "[data-testid='value-input']", "value": "" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },
          { "assert": { "selector": "[data-testid='status']", "text": "Please enter a number." } },

          { "action": "fill", "selector": "[data-testid='value-input']", "value": "3.14" },
          { "action": "click", "selector": "[role='button'][aria-label='Insert']" },
          { "assert": { "selector": "[data-testid='status']", "text": "Only integer values are supported." } }
        ]
      }
    ]
  }
}
</script>


  <script id="fsm" type="application/json">
    {
  "machine": {
    "id": "BinarySearchTreeFSM",
    "initial": "empty",
    "states": {
      "empty": {
        "onEnter": "RENDER_TREE_AND_TRAVERSALS", 
        "onExit": "FOCUS_VALUE_INPUT",
        "on": {
          "INSERT_INVALID": "error",
          "INSERT_VALID": "ready",
          "SEARCH_REQUEST": "searching", 
          "DELETE_REQUEST": "deleting",
          "CLEAR_REQUEST": "clearing"
        }
      },
      "ready": {
        "onEnter": "RENDER_TREE_AND_TRAVERSALS",
        "onExit": "FOCUS_VALUE_INPUT", 
        "on": {
          "INSERT_INVALID": "error",
          "INSERT_VALID": "ready",
          "INSERT_DUPLICATE": "ready",
          "SEARCH_REQUEST": "searching",
          "DELETE_REQUEST": "deleting", 
          "CLEAR_REQUEST": "clearing"
        }
      },
      "searching": {
        "onEnter": "RENDER_SEARCH_PATH_AND_STATUS",
        "onExit": "FOCUS_VALUE_INPUT",
        "on": {
          "SEARCH_FOUND": "ready",
          "SEARCH_NOT_FOUND_READY": "ready", 
          "SEARCH_NOT_FOUND_EMPTY": "empty",
          "INSERT_INVALID": "error",
          "INSERT_VALID": "ready",
          "INSERT_DUPLICATE": "ready",
          "DELETE_REQUEST": "deleting",
          "CLEAR_REQUEST": "clearing"
        }
      },
      "deleting": {
        "onEnter": "APPLY_DELETE_AND_RENDER",
        "onExit": "FOCUS_VALUE_INPUT",
        "on": {
          "DELETE_SUCCESS_READY": "ready",
          "DELETE_SUCCESS_EMPTY": "empty",
          "DELETE_NOT_FOUND_READY": "ready",
          "DELETE_NOT_FOUND_EMPTY": "empty", 
          "SEARCH_REQUEST": "searching",
          "INSERT_INVALID": "error",
          "CLEAR_REQUEST": "clearing"
        }
      },
      "clearing": {
        "onEnter": "APPLY_CLEAR_AND_RENDER",
        "onExit": "FOCUS_VALUE_INPUT",
        "on": {
          "CLEAR_DONE": "empty"
        }
      },
      "error": {
        "onEnter": "SET_STATUS_ERROR_AND_RENDER",
        "onExit": "FOCUS_VALUE_INPUT", 
        "on": {
          "INSERT_VALID": "ready",
          "INSERT_DUPLICATE": "ready",
          "SEARCH_REQUEST": "searching",
          "DELETE_REQUEST": "deleting",
          "CLEAR_REQUEST": "clearing"
        }
      }
    }
  },
  "playwright": {
    "selectors": {
      "valueInput": "[data-testid='value-input']",
      "insertBtn": "[data-testid='btn-insert']", 
      "searchBtn": "[data-testid='btn-search']",
      "deleteBtn": "[data-testid='btn-delete']",
      "clearBtn": "[data-testid='btn-clear']",
      "status": "[data-testid='status']",
      "treeSvg": "[data-testid='tree-svg']"
    },
    "events": [
      "INITIAL_RENDER",
      "INSERT_CLICK", 
      "SEARCH_CLICK",
      "DELETE_CLICK",
      "CLEAR_CLICK",
      "KEY_ENTER_ON_INPUT",
      "KEY_CTRL_OR_META_S",
      "KEY_CTRL_OR_META_D", 
      "KEY_CTRL_OR_META_K",
      "INSERT_REQUEST",
      "SEARCH_REQUEST",
      "DELETE_REQUEST",
      "CLEAR_REQUEST",
      "INSERT_INVALID",
      "INSERT_VALID",
      "INSERT_DUPLICATE",
      "SEARCH_FOUND",
      "SEARCH_NOT_FOUND_READY",
      "SEARCH_NOT_FOUND_EMPTY",
      "DELETE_SUCCESS_READY",
      "DELETE_SUCCESS_EMPTY", 
      "DELETE_NOT_FOUND_READY",
      "DELETE_NOT_FOUND_EMPTY",
      "CLEAR_DONE"
    ],
    "assertions": {
      "nodeExists": "[data-testid='node-{value}']",
      "rootValue": "[data-testid='root-value']",
      "statusMessage": "[data-testid='status']"
    }
  },
  "topic": "binary search tree",
  "description": "Finite state machine modeling the BST Visualizer UI: input validation, insert/search/delete/clear operations, visual path highlighting, status feedback, and tree rendering.",
  "notes": "User interactions occur via buttons and keyboard shortcuts: Enter triggers Insert; Ctrl/Cmd+S triggers Search; Ctrl/Cmd+D triggers Delete; Ctrl/Cmd+K triggers Clear. Each handler parses the input; invalid input yields Error state with status class 'err'. Rendering always updates SVG (nodes/edges) and traversal outputs. Searching highlights the path (path-highlight class) and the found node (found class) and updates status (ok/warn). Insert and Delete update the tree and status (ok/warn) and re-render without path highlights. Clear resets the tree to Empty and re-renders with status 'Cleared tree.' Found/not-found outcomes in Searching depend on BST.search; delete outcomes depend on BST.delete and whether the tree becomes empty after deletion; events DELETE_SUCCESS_READY vs DELETE_SUCCESS_EMPTY capture that branch. After every operation, focus returns to the value input (afterActionFocus). Traversal outputs reflect the current tree after any change (insert/delete/clear). The layout is recomputed on each render via computeLayout. The visual 'deleted' CSS class is defined but not used by the current implementation."
}
  </script>
</body>
</html>