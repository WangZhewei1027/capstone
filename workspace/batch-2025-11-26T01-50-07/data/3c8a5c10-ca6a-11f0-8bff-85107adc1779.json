{
  "id": "3c8a5c10-ca6a-11f0-8bff-85107adc1779",
  "timestamp": "2025-11-26T01:51:23.242Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Huffman Coding",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Huffman Coding Demonstration</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    max-width: 900px;\n    margin: 2rem auto;\n    padding: 0 1rem;\n    background: #f9f9f9;\n    color: #222;\n  }\n  h1 {\n    text-align: center;\n    color: #2c3e50;\n  }\n  textarea {\n    width: 100%;\n    font-family: monospace;\n    font-size: 1rem;\n    height: 100px;\n    resize: vertical;\n  }\n  button {\n    margin-top: 1rem;\n    padding: 0.7rem 1.2rem;\n    font-size: 1.1rem;\n    background: #2980b9;\n    border: none;\n    color: white;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n  button:hover {\n    background: #1f5f8b;\n  }\n  .result {\n    margin-top: 2rem;\n    background: white;\n    padding: 1rem;\n    box-shadow: 0 0 8px rgba(0,0,0,0.1);\n    border-radius: 5px;\n  }\n  .tree-container {\n    margin-top: 1rem;\n    overflow-x: auto;\n    padding-bottom: 1rem;\n  }\n  svg {\n    width: 100%;\n    height: 400px;\n  }\n  table {\n    border-collapse: collapse;\n    width: 100%;\n    margin-top: 1rem;\n  }\n  th, td {\n    border: 1px solid #ddd;\n    padding: 0.4rem 0.6rem;\n    text-align: center;\n  }\n  th {\n    background: #2980b9;\n    color: white;\n  }\n  small {\n    color: #555;\n  }\n</style>\n</head>\n<body>\n\n<h1>Huffman Coding Demonstration</h1>\n\n<label for=\"inputText\"><strong>Enter text to encode:</strong></label>\n<textarea id=\"inputText\" placeholder=\"Type some text here...\">this is an example for huffman encoding</textarea>\n\n<button id=\"encodeBtn\">Generate Huffman Codes</button>\n\n<div class=\"result\" id=\"result\" aria-live=\"polite\" aria-atomic=\"true\">\n  <!-- Results will show here -->\n</div>\n\n<script>\n(() => {\n\n  // Node constructor for Huffman Tree\n  function Node(char, freq, left = null, right = null) {\n    this.char = char;\n    this.freq = freq;\n    this.left = left;\n    this.right = right;\n  }\n\n  // Priority queue using simple array and sorting (efficient enough for demo)\n  function PriorityQueue() {\n    this.nodes = [];\n  }\n  PriorityQueue.prototype.enqueue = function(node) {\n    this.nodes.push(node);\n    this.nodes.sort((a,b) => a.freq - b.freq);\n  };\n  PriorityQueue.prototype.dequeue = function() {\n    return this.nodes.shift();\n  };\n  PriorityQueue.prototype.size = function() {\n    return this.nodes.length;\n  };\n\n  // Build frequency map of characters\n  function buildFrequencyMap(text) {\n    const freqMap = new Map();\n    for (let ch of text) {\n      freqMap.set(ch, (freqMap.get(ch) || 0) + 1);\n    }\n    return freqMap;\n  }\n\n  // Build Huffman Tree\n  function buildHuffmanTree(freqMap) {\n    const pq = new PriorityQueue();\n    for (const [char, freq] of freqMap.entries()) {\n      pq.enqueue(new Node(char, freq));\n    }\n\n    while (pq.size() > 1) {\n      const left = pq.dequeue();\n      const right = pq.dequeue();\n      const newNode = new Node(null, left.freq + right.freq, left, right);\n      pq.enqueue(newNode);\n    }\n\n    return pq.dequeue(); // root node\n  }\n\n  // Generate codes from Huffman Tree\n  function generateCodes(node, prefix = \"\", codes = {}) {\n    if (!node) return;\n    if (node.char !== null) {\n      codes[node.char] = prefix || \"0\"; // handle single node case\n    }\n    generateCodes(node.left, prefix + \"0\", codes);\n    generateCodes(node.right, prefix + \"1\", codes);\n    return codes;\n  }\n\n  // Encode input text using codes\n  function encodeText(text, codes) {\n    let encoded = \"\";\n    for (const ch of text) {\n      encoded += codes[ch];\n    }\n    return encoded;\n  }\n\n  // Decode a bit string using the Huffman tree\n  function decodeText(encoded, root) {\n    let decoded = \"\";\n    let node = root;\n    for (const bit of encoded) {\n      node = (bit === \"0\") ? node.left : node.right;\n      if (node.char !== null) {\n        decoded += node.char;\n        node = root;\n      }\n    }\n    return decoded;\n  }\n\n  // Visualize Huffman Tree as an SVG\n  function visualizeTree(root) {\n    // We will do a simple horizontal tree layout\n    const nodes = [];\n    const links = [];\n\n    let index = 0;\n    function traverse(node, depth, xOffset) {\n      if (!node) return 0;\n\n      // If leaf, width needed is 1\n      if (node.char !== null) {\n        nodes.push({ node, depth, x: xOffset, index });\n        return 1;\n      }\n\n      // For internal nodes, place children side by side\n      const leftWidth = traverse(node.left, depth+1, xOffset);\n      const rightWidth = traverse(node.right, depth+1, xOffset + leftWidth);\n      const nodeX = xOffset + (leftWidth + rightWidth) / 2;\n\n      nodes.push({ node, depth, x: nodeX, index });\n      links.push({ parentIndex: index, leftIndex: index + 1, rightIndex: null }); // rightIndex to fix below\n      const currentIndex = index;\n      index++;\n      // Adjust the children links after traversal:\n      // It's a bit hacky because we push children nodes in different order than parent node\n      // Fix links array now\n      // Actually, the above approach requires care, let's do a simpler approach:\n\n      return leftWidth + rightWidth;\n    }\n\n    // Because above mixing index logic is complicated, let's do a BFS like positioning\n    // So we use a helper to gather nodes per level\n\n    let levels = {};\n    let maxDepth = 0;\n    // Inorder indexing for x axis\n    let currentX = 0;\n\n    function assignPositions(node, depth) {\n      if (!node) return;\n      maxDepth = Math.max(maxDepth, depth);\n      assignPositions(node.left, depth+1);\n      levels[node] = {depth, x: currentX};\n      currentX++;\n      assignPositions(node.right, depth+1);\n    }\n\n    assignPositions(root, 0);\n\n    // Convert levels (map) keys to array to access nodes\n    const treeNodes = [];\n    const nodeMap = new Map();\n    let nodeId = 0;\n    function buildNodeList(node) {\n      if (!node) return;\n      buildNodeList(node.left);\n      treeNodes.push(node);\n      nodeMap.set(node, nodeId++);\n      buildNodeList(node.right);\n    }\n    buildNodeList(root);\n\n    // Collect nodes info for SVG\n    // Using inorder x for horizontal placement, depth for vertical\n\n    const horizontalSpacing = 40;\n    const verticalSpacing = 80;\n\n    let svgNodes = [];\n    let svgLinks = [];\n\n    treeNodes.forEach(node => {\n      const {depth, x} = levels[node];\n      svgNodes.push({\n        id: nodeMap.get(node),\n        char: node.char,\n        freq: node.freq,\n        x: x * horizontalSpacing + 20,\n        y: depth * verticalSpacing + 30,\n        node,\n      });\n      // Add links\n      if (node.left)\n        svgLinks.push({\n          from: nodeMap.get(node),\n          to: nodeMap.get(node.left)\n        });\n      if (node.right)\n        svgLinks.push({\n          from: nodeMap.get(node),\n          to: nodeMap.get(node.right)\n        });\n    });\n\n    // Build SVG markup\n    const w = Math.max(...svgNodes.map(n => n.x)) + 40;\n    const h = (maxDepth+1) * verticalSpacing + 60;\n\n    let svg = `<svg width=\"${w}\" height=\"${h}\" role=\"img\" aria-label=\"Huffman tree visualization\" >`;\n\n    // Draw links\n    svgLinks.forEach(link => {\n      const fromNode = svgNodes.find(n => n.id === link.from);\n      const toNode = svgNodes.find(n => n.id === link.to);\n      svg += `\n        <line x1=\"${fromNode.x}\" y1=\"${fromNode.y + 15}\" x2=\"${toNode.x}\" y2=\"${toNode.y -15}\" stroke=\"#888\" stroke-width=\"2\" />\n      `;\n    });\n\n    // Draw nodes\n    svgNodes.forEach(n => {\n      svg += `\n      <g>\n        <circle cx=\"${n.x}\" cy=\"${n.y}\" r=\"15\" fill=\"#2980b9\" />\n        <text x=\"${n.x}\" y=\"${n.y+5}\" fill=\"#fff\" font-weight=\"bold\" font-size=\"14\" text-anchor=\"middle\" font-family=\"monospace\">\n          ${n.char === null ? '' : (n.char === ' ' ? '␣' : n.char)}\n        </text>\n        <text x=\"${n.x}\" y=\"${n.y+30}\" fill=\"#222\" font-size=\"11\" text-anchor=\"middle\" font-family=\"monospace\">\n          ${n.freq}\n        </text>\n      </g>\n      `;\n    });\n\n    svg += '</svg>';\n    return svg;\n  }\n\n  // Escape HTML for safe display\n  function escapeHtml(text) {\n    return text\n      .replace(/&/g, \"&amp;\")\n      .replace(/</g,\"&lt;\")\n      .replace(/>/g,\"&gt;\")\n      .replace(/\"/g,\"&quot;\")\n      .replace(/'/g,\"&#039;\");\n  }\n\n  // Main function on button click\n  const encodeBtn = document.getElementById('encodeBtn');\n  const resultDiv = document.getElementById('result');\n\n  encodeBtn.addEventListener('click', () => {\n    const inputText = document.getElementById('inputText').value;\n    if (!inputText) {\n      resultDiv.innerHTML = \"<p>Please enter some text to encode.</p>\";\n      return;\n    }\n\n    // Build frequency map\n    const freqMap = buildFrequencyMap(inputText);\n    if (freqMap.size === 0) {\n      resultDiv.innerHTML = \"<p>Please enter some valid characters.</p>\";\n      return;\n    }\n\n    // Build Huffman Tree\n    const root = buildHuffmanTree(freqMap);\n\n    // Generate Codes\n    const codes = generateCodes(root);\n\n    // Encode text\n    const encoded = encodeText(inputText, codes);\n\n    // Decode text (to verify)\n    const decoded = decodeText(encoded, root);\n\n    // Efficiency calculations\n    const originalBits = inputText.length * 8;\n    const compressedBits = encoded.length;\n    const compressionRatio = (compressedBits / originalBits * 100).toFixed(2);\n\n    // Build character code table\n    let tableHtml = \"<table aria-label='Huffman Code Table'>\"\n      + \"<thead><tr><th>Character</th><th>Frequency</th><th>Huffman Code</th></tr></thead><tbody>\";\n    // Sort table by char code for consistent order\n    const sortedChars = [...freqMap.keys()].sort((a,b) => a.charCodeAt(0) - b.charCodeAt(0));\n    for (const ch of sortedChars) {\n      const repr = (ch === ' ') ? \"␣ (space)\" :\n                   (ch === '\\n') ? \"↵ (newline)\" : escapeHtml(ch);\n      tableHtml += \"<tr><td>\" + repr + \"</td><td>\" + freqMap.get(ch) + \"</td><td><code>\" + codes[ch] + \"</code></td></tr>\";\n    }\n    tableHtml += \"</tbody></table>\";\n\n    // Build output HTML\n    resultDiv.innerHTML = `\n      <h2>Results</h2>\n      <p><strong>Original text length:</strong> ${inputText.length} characters</p>\n      <p><strong>Original size (assuming 8 bits/char):</strong> ${originalBits.toLocaleString()} bits</p>\n      <p><strong>Encoded bit length:</strong> ${compressedBits.toLocaleString()} bits</p>\n      <p><strong>Compression ratio:</strong> ${compressionRatio}% of original size</p>\n      ${tableHtml}\n      <h3>Encoded Bit String (first 200 bits)</h3>\n      <p style=\"word-wrap: break-word; font-family: monospace; background:#eee; padding:0.5rem; max-height:120px; overflow:auto;\">${encoded.slice(0,200)}${encoded.length > 200 ? '...' : ''}</p>\n      <h3>Decoded Text</h3>\n      <p style=\"white-space: pre-wrap; background:#f0f8ff; border-left:4px solid #2980b9; padding:0.5rem; font-family: monospace;\">${escapeHtml(decoded)}</p>\n      <h3>Huffman Tree Visualization</h3>\n      <div class=\"tree-container\" role=\"img\" aria-label=\"Visual representation of the Huffman tree\">\n        ${visualizeTree(root)}\n      </div>\n      <small><em>Note: In the Huffman tree, blue circles represent nodes; top text inside the circle is character ('␣' means space), below is node frequency.</em></small>\n    `;\n  });\n\n  // Trigger initial encoding for default text\n  encodeBtn.click();\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Huffman Coding"
    }
  ],
  "topic": "Huffman Coding",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}