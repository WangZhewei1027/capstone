{
  "id": "3c883931-ca6a-11f0-8bff-85107adc1779",
  "timestamp": "2025-11-26T01:51:53.571Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Heap (Min/Max)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Heap (Min/Max) Demonstration</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 2rem;\n    max-width: 700px;\n  }\n  h1 {\n    text-align: center;\n  }\n  .container {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 1.5rem;\n  }\n  .heap-container {\n    flex: 1 1 300px;\n    border: 1px solid #ddd;\n    padding: 1rem;\n    border-radius: 6px;\n    background: #f9f9f9;\n  }\n  label {\n    display: block;\n    margin: 0.6rem 0 0.3rem;\n  }\n  input[type=\"number\"] {\n    width: 7rem;\n    padding: 0.3rem;\n    font-size: 1rem;\n  }\n  input[type=\"text\"] {\n    width: 100%;\n    padding: 0.5rem;\n    font-family: monospace;\n    font-size: 1rem;\n  }\n  button {\n    margin-top: 0.8rem;\n    padding: 0.5rem 1rem;\n    font-size: 1rem;\n    cursor: pointer;\n  }\n  pre {\n    background: #fff;\n    padding: 1rem;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-family: monospace;\n    overflow-x: auto;\n  }\n  .heap-visual {\n    margin-top: 1rem;\n    font-family: monospace;\n    white-space: pre;\n    line-height: 1.2;\n  }\n</style>\n</head>\n<body>\n<h1>Heap (Min/Max) Visualization & Demo</h1>\n<p>\n  This demo lets you work with Min Heap and Max Heap data structures.\n  Enter numbers and insert or extract from the heap to see its state.\n</p>\n\n<div class=\"container\">\n  <div class=\"heap-container\" id=\"minHeapSection\">\n    <h2>Min Heap</h2>\n    <label for=\"minInput\">Enter number to insert:</label>\n    <input type=\"number\" id=\"minInput\" />\n    <br />\n    <button id=\"minInsertBtn\">Insert</button>\n    <button id=\"minExtractBtn\">Extract Min</button>\n\n    <h3>Heap Array:</h3>\n    <pre id=\"minHeapArray\">[]</pre>\n\n    <h3>Heap Tree Visualization:</h3>\n    <div class=\"heap-visual\" id=\"minHeapVisual\"></div>\n  </div>\n\n  <div class=\"heap-container\" id=\"maxHeapSection\">\n    <h2>Max Heap</h2>\n    <label for=\"maxInput\">Enter number to insert:</label>\n    <input type=\"number\" id=\"maxInput\" />\n    <br />\n    <button id=\"maxInsertBtn\">Insert</button>\n    <button id=\"maxExtractBtn\">Extract Max</button>\n\n    <h3>Heap Array:</h3>\n    <pre id=\"maxHeapArray\">[]</pre>\n\n    <h3>Heap Tree Visualization:</h3>\n    <div class=\"heap-visual\" id=\"maxHeapVisual\"></div>\n  </div>\n</div>\n\n<script>\nclass Heap {\n  constructor(comparator) {\n    this.data = [];\n    this.compare = comparator; // comparator(a, b) returns true if a has higher priority than b for the heap\n  }\n\n  size() {\n    return this.data.length;\n  }\n\n  insert(value) {\n    this.data.push(value);\n    this._heapifyUp(this.size() - 1);\n  }\n\n  peek() {\n    if (this.size() === 0) return null;\n    return this.data[0];\n  }\n\n  extract() {\n    if (this.size() === 0) return null;\n    if (this.size() === 1) return this.data.pop();\n\n    const top = this.data[0];\n    this.data[0] = this.data.pop();\n    this._heapifyDown(0);\n    return top;\n  }\n\n  _heapifyUp(index) {\n    let currentIndex = index;\n    while (currentIndex > 0) {\n      const parentIndex = Math.floor((currentIndex - 1) / 2);\n      if (this.compare(this.data[currentIndex], this.data[parentIndex])) {\n        [this.data[currentIndex], this.data[parentIndex]] = [this.data[parentIndex], this.data[currentIndex]];\n        currentIndex = parentIndex;\n      } else {\n        break;\n      }\n    }\n  }\n\n  _heapifyDown(index) {\n    let currentIndex = index;\n    const size = this.size();\n\n    while (true) {\n      const leftChild = 2 * currentIndex + 1;\n      const rightChild = 2 * currentIndex + 2;\n      let candidate = currentIndex;\n\n      if (leftChild < size && this.compare(this.data[leftChild], this.data[candidate])) {\n        candidate = leftChild;\n      }\n      if (rightChild < size && this.compare(this.data[rightChild], this.data[candidate])) {\n        candidate = rightChild;\n      }\n      if (candidate === currentIndex) break;\n\n      [this.data[currentIndex], this.data[candidate]] = [this.data[candidate], this.data[currentIndex]];\n      currentIndex = candidate;\n    }\n  }\n}\n\n// Visualize heap as a tree-like structure (sideways, with root on top)\nfunction visualizeHeap(data) {\n  if (data.length === 0) return \"(empty)\";\n  // We'll use breadth-first levels and print them with spacing accordingly\n  // To keep it simple, we'll print each level on its own line separated by spaces\n\n  // Calculate height of the heap tree\n  const height = Math.floor(Math.log2(data.length)) + 1;\n\n  const lines = [];\n  let index = 0;\n\n  for (let level = 0; level < height; level++) {\n    const levelCount = 2 ** level;\n    let line = \"\";\n    // Calculate padding at start and between elements for better visualization\n    // Max nodes at bottom level = 2^(height-1)\n    // We'll use spacing proportional to max nodes to keep it aligned roughly\n    const maxNodesBottom = 2 ** (height - 1);\n    const spaceBetween = Math.floor(60 / (levelCount));\n    const spaceStart = Math.floor(spaceBetween / 2);\n\n    line += \" \".repeat(spaceStart);\n    for (let i = 0; i < levelCount && index < data.length; i++, index++) {\n      line += data[index].toString().padStart(2, \" \");\n      line += \" \".repeat(spaceBetween);\n    }\n    lines.push(line);\n  }\n  return lines.join(\"\\n\");\n}\n\nconst minHeap = new Heap((a, b) => a < b);\nconst maxHeap = new Heap((a, b) => a > b);\n\nfunction updateDisplay() {\n  document.getElementById(\"minHeapArray\").textContent = JSON.stringify(minHeap.data);\n  document.getElementById(\"minHeapVisual\").textContent = visualizeHeap(minHeap.data);\n\n  document.getElementById(\"maxHeapArray\").textContent = JSON.stringify(maxHeap.data);\n  document.getElementById(\"maxHeapVisual\").textContent = visualizeHeap(maxHeap.data);\n}\n\ndocument.getElementById(\"minInsertBtn\").addEventListener(\"click\", () => {\n  const valStr = document.getElementById(\"minInput\").value;\n  if (valStr === \"\") return alert(\"Enter a number to insert in Min Heap\");\n  const val = Number(valStr);\n  if (isNaN(val)) return alert(\"Enter a valid number\");\n  minHeap.insert(val);\n  document.getElementById(\"minInput\").value = \"\";\n  updateDisplay();\n});\n\ndocument.getElementById(\"minExtractBtn\").addEventListener(\"click\", () => {\n  if (minHeap.size() === 0) return alert(\"Min Heap is empty\");\n  const extracted = minHeap.extract();\n  alert(\"Extracted Min: \" + extracted);\n  updateDisplay();\n});\n\ndocument.getElementById(\"maxInsertBtn\").addEventListener(\"click\", () => {\n  const valStr = document.getElementById(\"maxInput\").value;\n  if (valStr === \"\") return alert(\"Enter a number to insert in Max Heap\");\n  const val = Number(valStr);\n  if (isNaN(val)) return alert(\"Enter a valid number\");\n  maxHeap.insert(val);\n  document.getElementById(\"maxInput\").value = \"\";\n  updateDisplay();\n});\n\ndocument.getElementById(\"maxExtractBtn\").addEventListener(\"click\", () => {\n  if (maxHeap.size() === 0) return alert(\"Max Heap is empty\");\n  const extracted = maxHeap.extract();\n  alert(\"Extracted Max: \" + extracted);\n  updateDisplay();\n});\n\n// Initialize display\nupdateDisplay();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap (Min/Max)"
    }
  ],
  "topic": "Heap (Min/Max)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}