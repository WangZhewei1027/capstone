{
  "id": "3c888751-ca6a-11f0-8bff-85107adc1779",
  "timestamp": "2025-11-26T01:51:06.316Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Adjacency Matrix",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Adjacency Matrix Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  h1 {\n    text-align: center;\n  }\n  #graphInput {\n    margin-bottom: 20px;\n  }\n  textarea {\n    width: 100%;\n    height: 100px;\n    font-family: monospace;\n    font-size: 14px;\n  }\n  button {\n    margin-top: 10px;\n    padding: 10px 15px;\n    font-size: 16px;\n  }\n  table {\n    border-collapse: collapse;\n    margin-top: 20px;\n    width: 100%;\n    max-width: 600px;\n  }\n  th, td {\n    border: 1px solid #333;\n    text-align: center;\n    padding: 6px;\n  }\n  th {\n    background-color: #eee;\n  }\n  #graphCanvas {\n    border: 1px solid #ccc;\n    margin-top: 30px;\n    display: block;\n    margin-left: auto;\n    margin-right: auto;\n    background-color: #fafafa;\n  }\n  .error {\n    color: red;\n    font-weight: bold;\n    margin-top: 10px;\n  }\n  #instructions {\n    font-size: 14px;\n    margin-bottom: 10px;\n    max-width: 600px;\n  }\n</style>\n</head>\n<body>\n<h1>Adjacency Matrix Demonstration</h1>\n\n<div id=\"instructions\">\n  <p>Enter the graph as edge list, one edge per line, nodes separated by spaces or commas. For example:</p>\n  <pre>\nA B\nB C\nC A\nC D\n  </pre>\n  <p>This samples a directed graph with edges A→B, B→C, C→A, and C→D.</p>\n  <p>Node names should be single words (letters or digits).</p>\n</div>\n\n<div id=\"graphInput\">\n  <textarea id=\"edgeInput\" placeholder=\"Enter edges here...\"></textarea><br />\n  <button id=\"buildMatrixBtn\">Build Adjacency Matrix</button>\n  <div id=\"errorMsg\" class=\"error\"></div>\n</div>\n\n<div id=\"matrixContainer\"></div>\n\n<canvas id=\"graphCanvas\" width=\"600\" height=\"400\" aria-label=\"Graph visualization\"></canvas>\n\n<script>\n(() => {\n  const edgeInput = document.getElementById('edgeInput');\n  const buildMatrixBtn = document.getElementById('buildMatrixBtn');\n  const matrixContainer = document.getElementById('matrixContainer');\n  const errorMsg = document.getElementById('errorMsg');\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n\n  // Helper: parse edges list string into edge pairs\n  // Accepts lines in: \"A B\" or \"A,B\"\n  function parseEdges(text) {\n    const lines = text.trim().split('\\n');\n    const edges = [];\n    for (let line of lines) {\n      line = line.trim();\n      if (!line) continue;\n      // Separate by space or comma\n      const parts = line.split(/[ ,]+/);\n      if (parts.length !== 2) throw new Error('Each line must contain exactly two nodes');\n      const [from, to] = parts;\n      if (!from.match(/^\\w+$/) || !to.match(/^\\w+$/)) {\n        throw new Error('Node names must be letters or digits only');\n      }\n      edges.push([from, to]);\n    }\n    if(edges.length === 0) throw new Error('No edges provided');\n    return edges;\n  }\n\n  // Build adjacency matrix: nodes list and matrix (2D array)\n  // Returns {nodes: [...], matrix: [][]\n  // Directed graph, matrix[i][j] = 1 if edge nodes[i]->nodes[j]\n  function buildAdjacencyMatrix(edges) {\n    const nodeSet = new Set();\n    edges.forEach(([f,t]) => {\n      nodeSet.add(f);\n      nodeSet.add(t);\n    });\n    const nodes = Array.from(nodeSet).sort();\n    const n = nodes.length;\n    // Map node -> index for quick access\n    const indexOf = {};\n    nodes.forEach((node,i) => indexOf[node] = i);\n\n    // Initialize matrix with 0s\n    const matrix = [];\n    for(let i=0;i<n;i++) {\n      matrix.push(new Array(n).fill(0));\n    }\n\n    // Fill matrix\n    edges.forEach(([f,t]) => {\n      const i = indexOf[f], j = indexOf[t];\n      matrix[i][j] = 1;\n    });\n    return {nodes,matrix};\n  }\n\n  // Render matrix as HTML table\n  function renderMatrix(nodes, matrix) {\n    let html = '<table aria-label=\"Adjacency matrix\">';\n    html += '<thead><tr><th></th>';\n    for (const n of nodes) {\n      html += `<th>${n}</th>`;\n    }\n    html += '</tr></thead><tbody>';\n    for(let i=0; i<nodes.length; i++) {\n      html += `<tr><th>${nodes[i]}</th>`;\n      for(let j=0; j<nodes.length; j++) {\n        html += `<td>${matrix[i][j]}</td>`;\n      }\n      html += '</tr>';\n    }\n    html += '</tbody></table>';\n    matrixContainer.innerHTML = html;\n  }\n\n  // Draw simple directed graph on canvas using nodes and edges\n  function drawGraph(nodes, matrix) {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    const n = nodes.length;\n    if(n === 0) return;\n\n    // Calculate positions on a circle\n    const centerX = canvas.width/2;\n    const centerY = canvas.height/2;\n    const radius = Math.min(canvas.width, canvas.height)/2 - 60;\n    const nodePos = [];\n\n    for(let i=0; i<n; i++) {\n      const angle = (2*Math.PI*i)/n - Math.PI/2;\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n      nodePos.push({x,y});\n    }\n\n    // Draw edges first (arrows)\n    ctx.strokeStyle = '#333';\n    ctx.fillStyle = '#333';\n    ctx.lineWidth = 2;\n    for(let i=0; i<n; i++) {\n      for(let j=0; j<n; j++) {\n        if(matrix[i][j] === 1) {\n          drawArrow(nodePos[i], nodePos[j]);\n        }\n      }\n    }\n\n    // Draw nodes\n    const nodeRadius = 20;\n    ctx.font = '16px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    for(let i=0; i<n; i++) {\n      // circle\n      ctx.fillStyle = '#4a90e2';\n      ctx.beginPath();\n      ctx.arc(nodePos[i].x, nodePos[i].y, nodeRadius, 0, 2*Math.PI);\n      ctx.fill();\n      // label\n      ctx.fillStyle = 'white';\n      ctx.fillText(nodes[i], nodePos[i].x, nodePos[i].y);\n    }\n\n    // Helper to draw arrow between two points (with some offset from centers)\n    function drawArrow(from, to) {\n      // Calculate vector from->to\n      const dx = to.x - from.x;\n      const dy = to.y - from.y;\n      const dist = Math.sqrt(dx*dx + dy*dy);\n      if(dist < 1) return;\n\n      // Start at edge of from circle\n      const startX = from.x + (dx/dist)*nodeRadius;\n      const startY = from.y + (dy/dist)*nodeRadius;\n      // End at edge of to circle minus arrow tip\n      const endX = to.x - (dx/dist)*nodeRadius;\n      const endY = to.y - (dy/dist)*nodeRadius;\n\n      ctx.beginPath();\n      ctx.moveTo(startX, startY);\n      ctx.lineTo(endX, endY);\n      ctx.stroke();\n\n      // Draw arrow head\n      const headLen = 10;\n      const angle = Math.atan2(dy, dx);\n      ctx.beginPath();\n      ctx.moveTo(endX, endY);\n      ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI/6), endY - headLen * Math.sin(angle - Math.PI/6));\n      ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI/6), endY - headLen * Math.sin(angle + Math.PI/6));\n      ctx.closePath();\n      ctx.fill();\n    }\n  }\n\n  buildMatrixBtn.addEventListener('click', () => {\n    errorMsg.textContent = '';\n    matrixContainer.innerHTML = '';\n    ctx.clearRect(0,0,canvas.width, canvas.height);\n    try {\n      const edges = parseEdges(edgeInput.value);\n      const {nodes, matrix} = buildAdjacencyMatrix(edges);\n      renderMatrix(nodes,matrix);\n      drawGraph(nodes,matrix);\n    } catch(e) {\n      errorMsg.textContent = e.message;\n    }\n  });\n\n  // Prefill example edges\n  edgeInput.value = `A B\nB C\nC A\nC D`;\n\n  // Automatically build matrix on load\n  buildMatrixBtn.click();\n\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency Matrix"
    }
  ],
  "topic": "Adjacency Matrix",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}