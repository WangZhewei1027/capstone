<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Adjacency List Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px; 
    background: #f0f0f0;
  }
  h1 {
    text-align: center;
  }
  #graph-input {
    width: 100%;
    max-width: 600px;
    height: 120px;
    font-family: monospace;
    font-size: 14px;
    margin-bottom: 10px;
  }
  #parse-btn {
    margin-bottom: 20px;
    padding: 8px 16px;
    font-size: 16px;
  }
  #adj-list {
    max-width: 600px;
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 0 10px #ccc;
    font-family: monospace;
  }
  .node {
    font-weight: bold;
    margin-top: 10px;
  }
  .neighbors {
    margin-left: 20px;
  }
  #error {
    color: red;
    margin-bottom: 15px;
  }
  #desc {
    max-width: 600px;
    margin: 0 auto 20px auto;
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 0 10px #ccc;
    font-size: 14px;
  }
</style>
</head>
<body>
<h1>Adjacency List Example</h1>
<div id="desc">
  <p>
    Enter your graph edges below in the format <code>node: neighbor1, neighbor2, ...</code> per line.<br/>
    For example:<br/>
    <code>A: B, C</code><br/>
    <code>B: A, D</code><br/>
    <code>C: A, D</code><br/>
    <code>D: B, C</code>
  </p>
  <p>
    Click "Show Adjacency List" to parse and visualize the adjacency list.
  </p>
</div>
<textarea id="graph-input" placeholder="Enter graph edges here...">A: B, C
B: A, D
C: A, D
D: B, C</textarea><br />
<button id="parse-btn">Show Adjacency List</button>
<div id="error"></div>
<div id="adj-list"></div>

<script>
  const input = document.getElementById('graph-input');
  const parseBtn = document.getElementById('parse-btn');
  const adjListDiv = document.getElementById('adj-list');
  const errorDiv = document.getElementById('error');

  function parseGraph(text) {
    // Parse input lines into adjacency list object
    const graph = {};
    const lines = text.trim().split('\n');
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;
      // format: Node: neighbor1, neighbor2, ...
      const parts = line.split(':');
      if (parts.length !== 2) {
        throw new Error(`Line ${i + 1} is not in the format "Node: neighbor1, neighbor2, ..."`);
      }
      const node = parts[0].trim();
      if (!node) throw new Error(`Line ${i + 1} has empty node label.`);
      const neighborsText = parts[1].trim();
      let neighbors = [];
      if (neighborsText.length) {
        neighbors = neighborsText.split(',').map(n => n.trim()).filter(n => n.length > 0);
      }
      // initialize adjacency list entry for node
      if (!graph[node]) graph[node] = new Set();
      // add neighbors
      neighbors.forEach(nb => {
        graph[node].add(nb);
        // Also ensure neighbor node exists in the graph (even if no explicit line)
        if (!graph[nb]) graph[nb] = new Set();
      });
    }
    // Convert sets to arrays for easier display
    const graphArrays = {};
    for (const node in graph) {
      graphArrays[node] = Array.from(graph[node]).sort();
    }
    return graphArrays;
  }

  function renderAdjacencyList(graph) {
    // Clear existing content
    adjListDiv.innerHTML = '';
    if (Object.keys(graph).length === 0) {
      adjListDiv.textContent = 'Graph is empty.';
      return;
    }
    const ul = document.createElement('ul');
    ul.style.listStyle = 'none';
    ul.style.paddingLeft = '0';

    // Sort nodes alphabetically
    const nodes = Object.keys(graph).sort();
    nodes.forEach(node => {
      const li = document.createElement('li');
      const nodeSpan = document.createElement('span');
      nodeSpan.className = 'node';
      nodeSpan.textContent = node;
      li.appendChild(nodeSpan);

      if (graph[node].length > 0) {
        const neighborsSpan = document.createElement('span');
        neighborsSpan.className = 'neighbors';
        neighborsSpan.textContent = ' : ' + graph[node].join(', ');
        li.appendChild(neighborsSpan);
      } else {
        const neighborsSpan = document.createElement('span');
        neighborsSpan.className = 'neighbors';
        neighborsSpan.style.fontStyle = 'italic';
        neighborsSpan.textContent = ' : (no neighbors)';
        li.appendChild(neighborsSpan);
      }
      ul.appendChild(li);
    });
    adjListDiv.appendChild(ul);
  }

  parseBtn.addEventListener('click', () => {
    errorDiv.textContent = '';
    adjListDiv.textContent = '';
    try {
      const graph = parseGraph(input.value);
      renderAdjacencyList(graph);
    } catch(err) {
      errorDiv.textContent = err.message;
    }
  });

  // Show default adjacency list on load
  window.addEventListener('load', () => {
    try {
      const graph = parseGraph(input.value);
      renderAdjacencyList(graph);
    } catch(err) {
      errorDiv.textContent = err.message;
    }
  });
</script>
</body>
</html>