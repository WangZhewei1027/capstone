<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Priority Queue Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 2rem;
    background: #f0f4f8;
    color: #333;
  }
  h1 {
    text-align: center;
    margin-bottom: 1rem;
  }
  .container {
    max-width: 600px;
    margin: 0 auto;
    background: white;
    padding: 1.5rem 2rem 2rem;
    border-radius: 8px;
    box-shadow: 0 8px 15px rgba(0,0,0,0.1);
  }
  label {
    display: block;
    margin-top: 1rem;
    font-weight: 600;
  }
  input[type="text"],
  input[type="number"] {
    width: 100%;
    padding: 0.4rem 0.6rem;
    margin-top: 0.3rem;
    border-radius: 4px;
    border: 1px solid #bbb;
    font-size: 1rem;
  }
  button {
    margin-top: 1.2rem;
    padding: 0.5rem 1rem;
    font-size: 1rem;
    background: #0078d7;
    border: none;
    border-radius: 4px;
    color: white;
    cursor: pointer;
  }
  button:hover {
    background: #005ea1;
  }
  .output {
    margin-top: 2rem;
    background: #eef5fc;
    border-left: 4px solid #0078d7;
    padding: 1rem 1.25rem;
    min-height: 60px;
    white-space: pre-wrap;
    font-family: monospace;
  }
  .queue-visual {
    margin-top: 1.5rem;
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
  }
  .queue-item {
    background: #0078d7;
    color: white;
    padding: 0.5rem 0.75rem;
    border-radius: 4px;
    min-width: 60px;
    text-align: center;
    font-weight: 600;
    box-shadow: 0 3px 7px rgba(0,120,215,0.5);
  }
  .queue-item .prio {
    display: block;
    font-size: 0.75rem;
    opacity: 0.8;
  }
</style>
</head>
<body>
  <h1>Priority Queue Demonstration</h1>
  <div class="container">
    <label for="elementInput">Element (string or number):</label>
    <input type="text" id="elementInput" placeholder="Enter element to enqueue" />
    <label for="priorityInput">Priority (integer, lower number = higher priority):</label>
    <input type="number" id="priorityInput" placeholder="Enter priority" />
    <button id="enqueueBtn">Enqueue</button>
    <button id="dequeueBtn" style="background: #d9534f; margin-left: 1rem;">Dequeue</button>
    <button id="peekBtn" style="background: #5bc0de; margin-left: 1rem;">Peek</button>

    <div class="output" id="outputArea">Queue is empty.</div>

    <h3 style="margin-top: 2rem;">Current Queue State (front â†’ back):</h3>
    <div class="queue-visual" id="queueVisual"></div>
  </div>

<script>
  // Priority Queue Implementation using a Min-Heap (lowest priority number = highest priority)
  class PriorityQueue {
    constructor() {
      this.heap = [];
    }
    // Helper: Swap two elements in the heap
    swap(i, j) {
      [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
    }
    // Helper: Heapify up starting at index i
    heapifyUp(i) {
      let parent = Math.floor((i - 1) / 2);
      while (
        i > 0 &&
        this.heap[i].priority < this.heap[parent].priority
      ) {
        this.swap(i, parent);
        i = parent;
        parent = Math.floor((i - 1) / 2);
      }
    }
    // Helper: Heapify down starting at index i
    heapifyDown(i) {
      let left = 2 * i + 1;
      let right = 2 * i + 2;
      let smallest = i;

      if (
        left < this.size() &&
        this.heap[left].priority < this.heap[smallest].priority
      ) smallest = left;

      if (
        right < this.size() &&
        this.heap[right].priority < this.heap[smallest].priority
      ) smallest = right;

      if (smallest !== i) {
        this.swap(i, smallest);
        this.heapifyDown(smallest);
      }
    }
    enqueue(element, priority) {
      if (typeof priority !== "number" || !Number.isInteger(priority)) {
        throw new Error("Priority must be an integer.");
      }
      const node = { element, priority };
      this.heap.push(node);
      this.heapifyUp(this.heap.length - 1);
    }
    dequeue() {
      if (this.isEmpty()) return null;
      const min = this.heap[0];
      const end = this.heap.pop();
      if (this.heap.length > 0) {
        this.heap[0] = end;
        this.heapifyDown(0);
      }
      return min;
    }
    peek() {
      return this.isEmpty() ? null : this.heap[0];
    }
    size() {
      return this.heap.length;
    }
    isEmpty() {
      return this.size() === 0;
    }
    // Returns array of elements in priority order without modifying the queue
    toSortedArray() {
      // clone heap array
      const clone = this.heap.slice();
      const result = [];
      // create a temporary min heap using the clone
      const tmpPQ = new PriorityQueue();
      tmpPQ.heap = clone;
      // since we bypassed heapify, heap might not be valid;
      // so heapify entire array once:
      for (let i = Math.floor(tmpPQ.size() / 2); i >= 0; i--) tmpPQ.heapifyDown(i);

      while (!tmpPQ.isEmpty()) {
        result.push(tmpPQ.dequeue());
      }
      return result;
    }
  }
  // === DOM Elements ===
  const elementInput = document.getElementById("elementInput");
  const priorityInput = document.getElementById("priorityInput");
  const enqueueBtn = document.getElementById("enqueueBtn");
  const dequeueBtn = document.getElementById("dequeueBtn");
  const peekBtn = document.getElementById("peekBtn");
  const outputArea = document.getElementById("outputArea");
  const queueVisual = document.getElementById("queueVisual");

  const pq = new PriorityQueue();

  // Updates the queue visual display
  function updateVisual() {
    queueVisual.innerHTML = "";
    // Display queue from front (highest priority) to back (lowest priority)
    const sorted = pq.toSortedArray();
    if (sorted.length === 0) {
      queueVisual.innerHTML = "<em>Queue is empty.</em>";
    } else {
      sorted.forEach(({element, priority}) => {
        const div = document.createElement("div");
        div.className = "queue-item";
        div.textContent = element;
        const prioSpan = document.createElement("span");
        prioSpan.className = "prio";
        prioSpan.textContent = "Prio: " + priority;
        div.appendChild(prioSpan);
        queueVisual.appendChild(div);
      });
    }
  }

  // Updates the textual output area
  function updateOutput(text) {
    outputArea.textContent = text;
  }

  // Event Handlers
  enqueueBtn.onclick = () => {
    const element = elementInput.value.trim();
    const priorityStr = priorityInput.value.trim();

    if (element === "") {
      updateOutput("Error: Element cannot be empty.");
      return;
    }
    if (priorityStr === "") {
      updateOutput("Error: Priority cannot be empty.");
      return;
    }
    const priority = Number(priorityStr);
    if (!Number.isInteger(priority)) {
      updateOutput("Error: Priority must be an integer.");
      return;
    }
    try {
      pq.enqueue(element, priority);
      updateOutput(`Enqueued element "${element}" with priority ${priority}.`);
      elementInput.value = "";
      priorityInput.value = "";
      elementInput.focus();
      updateVisual();
    } catch (err) {
      updateOutput("Error: " + err.message);
    }
  };

  dequeueBtn.onclick = () => {
    if (pq.isEmpty()) {
      updateOutput("Queue is empty, nothing to dequeue.");
      return;
    }
    const {element, priority} = pq.dequeue();
    updateOutput(`Dequeued element "${element}" with priority ${priority}.`);
    updateVisual();
  };

  peekBtn.onclick = () => {
    if (pq.isEmpty()) {
      updateOutput("Queue is empty.");
      return;
    }
    const {element, priority} = pq.peek();
    updateOutput(`Front element is "${element}" with priority ${priority}.`);
  };

  // Initial Visual Update
  updateVisual();
</script>
</body>
</html>