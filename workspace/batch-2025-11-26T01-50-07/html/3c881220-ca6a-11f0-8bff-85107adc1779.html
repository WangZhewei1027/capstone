<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Binary Search Tree (BST) Demo</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f0f2f5;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    h1 {
      margin-bottom: 10px;
      color: #222;
    }
    #controls {
      margin-bottom: 15px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }
    input[type="number"] {
      padding: 8px;
      font-size: 16px;
      width: 120px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    button {
      padding: 8px 16px;
      font-size: 16px;
      background-color: #4CAF50;
      border: none;
      border-radius: 4px;
      color: white;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    button:hover:not(:disabled) {
      background-color: #45a047;
    }
    button:disabled {
      background-color: #888;
      cursor: default;
    }
    #message {
      margin: 10px 0 20px 0;
      min-height: 20px;
      color: #d32f2f;
      font-weight: bold;
    }
    #bstCanvas {
      border: 1px solid #ccc;
      background: white;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      border-radius: 6px;
      max-width: 100%;
      height: 500px;
    }
    #traversalOutputs {
      margin-top: 20px;
      width: 80%;
      max-width: 800px;
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: space-around;
    }
    .traversalBlock {
      background: white;
      padding: 15px 20px;
      border-radius: 6px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.15);
      flex: 1 1 250px;
      min-width: 220px;
    }
    .traversalBlock h3 {
      margin-top: 0;
      font-weight: normal;
      text-align: center;
      color: #333;
    }
    .traversalBlock .output {
      margin-top: 8px;
      font-weight: bold;
      font-family: monospace;
      color: #1565c0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
  </style>
</head>
<body>
  <h1>Binary Search Tree (BST) Demo</h1>

  <div id="controls">
    <input type="number" id="valueInput" placeholder="Enter value" />
    <button id="insertBtn">Insert</button>
    <button id="deleteBtn">Delete</button>
    <button id="searchBtn">Search</button>
    <button id="clearBtn" title="Clear entire tree" style="background-color:#d32f2f;">Clear</button>
  </div>
  <div id="message"></div>

  <canvas id="bstCanvas" width="900" height="500" aria-label="Binary Search Tree visualization"></canvas>

  <div id="traversalOutputs">
    <div class="traversalBlock">
      <h3>In-order Traversal</h3>
      <div class="output" id="inorderOutput"></div>
    </div>
    <div class="traversalBlock">
      <h3>Pre-order Traversal</h3>
      <div class="output" id="preorderOutput"></div>
    </div>
    <div class="traversalBlock">
      <h3>Post-order Traversal</h3>
      <div class="output" id="postorderOutput"></div>
    </div>
    <div class="traversalBlock">
      <h3>Level-order Traversal (BFS)</h3>
      <div class="output" id="levelorderOutput"></div>
    </div>
  </div>

  <script>
    // BST Node class
    class Node {
      constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        this.x = 0; // for visualization
        this.y = 0; // for visualization
      }
    }

    // BST class with insert, search, delete, and traversals
    class BST {
      constructor() {
        this.root = null;
      }

      insert(value) {
        if (this.root === null) {
          this.root = new Node(value);
          return true;
        } 
        else {
          return this._insert(this.root, value);
        }
      }

      _insert(node, value) {
        if (value === node.value) {
          return false; // no duplicates
        }
        else if (value < node.value) {
          if (node.left === null) {
            node.left = new Node(value);
            return true;
          } else {
            return this._insert(node.left, value);
          }
        } 
        else {
          if (node.right === null) {
            node.right = new Node(value);
            return true;
          } else {
            return this._insert(node.right, value);
          }
        }
      }

      search(value) {
        return this._search(this.root, value);
      }

      _search(node, value) {
        if (node === null) return false;
        if (value === node.value) return true;
        if (value < node.value) return this._search(node.left, value);
        else return this._search(node.right, value);
      }

      delete(value) {
        const { newRoot, deleted } = this._delete(this.root, value);
        this.root = newRoot;
        return deleted;
      }

      _delete(node, value) {
        if (node === null) return { newRoot: null, deleted: false };

        let deleted = false;

        if (value < node.value) {
          const result = this._delete(node.left, value);
          node.left = result.newRoot;
          deleted = result.deleted;
          return { newRoot: node, deleted };
        }
        else if (value > node.value) {
          const result = this._delete(node.right, value);
          node.right = result.newRoot;
          deleted = result.deleted;
          return { newRoot: node, deleted };
        }
        else {
          // Node to be deleted found
          deleted = true;

          // Case 1: No children
          if (node.left === null && node.right === null) {
            return { newRoot: null, deleted };
          }
          // Case 2: One child
          else if (node.left === null) {
            return { newRoot: node.right, deleted };
          }
          else if (node.right === null) {
            return { newRoot: node.left, deleted };
          }
          // Case 3: Two children
          else {
            // Find inorder successor (smallest in right subtree)
            let successorParent = node;
            let successor = node.right;
            while (successor.left !== null) {
              successorParent = successor;
              successor = successor.left;
            }
            node.value = successor.value; // Copy successor's value
            // Delete successor node
            if (successorParent !== node) {
              successorParent.left = successor.right;
            } else {
              successorParent.right = successor.right;
            }
            return { newRoot: node, deleted };
          }
        }
      }

      // Traversals
      inorder() {
        const result = [];
        function traverse(node) {
          if (node) {
            traverse(node.left);
            result.push(node.value);
            traverse(node.right);
          }
        }
        traverse(this.root);
        return result;
      }

      preorder() {
        const result = [];
        function traverse(node) {
          if (node) {
            result.push(node.value);
            traverse(node.left);
            traverse(node.right);
          }
        }
        traverse(this.root);
        return result;
      }

      postorder() {
        const result = [];
        function traverse(node) {
          if (node) {
            traverse(node.left);
            traverse(node.right);
            result.push(node.value);
          }
        }
        traverse(this.root);
        return result;
      }

      levelorder() {
        const result = [];
        if (this.root === null) return result;

        const queue = [this.root];
        while (queue.length > 0) {
          const node = queue.shift();
          result.push(node.value);
          if (node.left) queue.push(node.left);
          if (node.right) queue.push(node.right);
        }
        return result;
      }
    }

    // Visualization on canvas

    const canvas = document.getElementById('bstCanvas');
    const ctx = canvas.getContext('2d');

    const radius = 20;
    const verticalGap = 75; // vertical distance between levels

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    // Compute horizontal positions - using inorder indexing
    function assignPositions(root) {
      // We assign x coordinate based on inorder sequence index
      let xPos = 0;
      const xGap = 50; // horizontal gap between nodes

      function inorderAssign(node, depth) {
        if (!node) return;
        inorderAssign(node.left, depth + 1);
        node.x = xPos * xGap + radius + 10;
        node.y = depth * verticalGap + radius + 10;
        xPos++;
        inorderAssign(node.right, depth + 1);
      }
      xPos = 0;
      inorderAssign(root, 0);
    }

    function drawLine(x1, y1, x2, y2) {
      ctx.beginPath();
      ctx.strokeStyle = '#777';
      ctx.lineWidth = 2;
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    function drawNode(node, highlight = false, highlightColor = '#ff9800') {
      if (!node) return;
      ctx.beginPath();
      ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = highlight ? highlightColor : '#4caf50';
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#2e7d32';
      ctx.stroke();

      ctx.fillStyle = 'white';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.value, node.x, node.y);
    }

    // Recursively draw tree edges and nodes
    function drawTree(node, searchPath = []) {
      if (!node) return;
      // Draw edges to children first
      if (node.left) {
        drawLine(node.x, node.y, node.left.x, node.left.y);
        drawTree(node.left, searchPath);
      }
      if (node.right) {
        drawLine(node.x, node.y, node.right.x, node.right.y);
        drawTree(node.right, searchPath);
      }
      // Draw node
      const highlight = searchPath.includes(node);
      drawNode(node, highlight);
    }

    // Highlight nodes in search path (used in search visualization)
    function highlightSearchPath(node, value, path=[]) {
      if (node === null) return path;
      path.push(node);
      if (value === node.value) return path;
      else if (value < node.value) return highlightSearchPath(node.left, value, path);
      else return highlightSearchPath(node.right, value, path);
    }


    // Main Application logic
    const bst = new BST();

    // UI elements
    const valueInput = document.getElementById('valueInput');
    const insertBtn = document.getElementById('insertBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const searchBtn = document.getElementById('searchBtn');
    const clearBtn = document.getElementById('clearBtn');
    const messageDiv = document.getElementById('message');

    const inorderOutput = document.getElementById('inorderOutput');
    const preorderOutput = document.getElementById('preorderOutput');
    const postorderOutput = document.getElementById('postorderOutput');
    const levelorderOutput = document.getElementById('levelorderOutput');

    function updateTraversals() {
      inorderOutput.textContent = bst.inorder().join(' → ') || '(empty)';
      preorderOutput.textContent = bst.preorder().join(' → ') || '(empty)';
      postorderOutput.textContent = bst.postorder().join(' → ') || '(empty)';
      levelorderOutput.textContent = bst.levelorder().join(' → ') || '(empty)';
    }

    function renderTree(searchPath=[]) {
      clearCanvas();
      if (!bst.root) {
        // Show a message in canvas area when empty
        ctx.fillStyle = '#666';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText("Tree is empty", canvas.width/2, canvas.height/2);
        return;
      }
      assignPositions(bst.root);
      drawTree(bst.root, searchPath);
    }

    function resetMessage() {
      messageDiv.textContent = '';
      messageDiv.style.color = '#d32f2f';
    }

    // Insert handler
    insertBtn.addEventListener('click', () => {
      resetMessage();
      const val = parseInt(valueInput.value.trim(), 10);
      if (isNaN(val)) {
        messageDiv.textContent = 'Please enter a valid number to insert.';
        return;
      }
      const inserted = bst.insert(val);
      if (!inserted) {
        messageDiv.textContent = `Value ${val} already exists in the tree. Duplicates not allowed.`;
      } else {
        messageDiv.style.color = '#2e7d32';
        messageDiv.textContent = `Inserted ${val} successfully.`;
      }
      updateTraversals();
      renderTree();
      valueInput.value = '';
      valueInput.focus();
    });

    // Delete handler
    deleteBtn.addEventListener('click', () => {
      resetMessage();
      const val = parseInt(valueInput.value.trim(), 10);
      if (isNaN(val)) {
        messageDiv.textContent = 'Please enter a valid number to delete.';
        return;
      }
      const deleted = bst.delete(val);
      if (!deleted) {
        messageDiv.textContent = `Value ${val} was not found in the tree.`;
      } else {
        messageDiv.style.color = '#2e7d32';
        messageDiv.textContent = `Deleted ${val} successfully.`;
      }
      updateTraversals();
      renderTree();
      valueInput.value = '';
      valueInput.focus();
    });

    // Search handler with highlight animation
    searchBtn.addEventListener('click', () => {
      resetMessage();
      const val = parseInt(valueInput.value.trim(), 10);
      if (isNaN(val)) {
        messageDiv.textContent = 'Please enter a valid number to search.';
        return;
      }
      if (bst.root === null) {
        messageDiv.textContent = 'Tree is empty.';
        return;
      }

      const path = highlightSearchPath(bst.root, val);

      let i = 0;
      function animateStep() {
        if (i < path.length) {
          clearCanvas();
          assignPositions(bst.root);
          drawTree(bst.root, path.slice(0, i+1));
          i++;
          setTimeout(animateStep, 600);
        }
        else {
          if (path[path.length-1].value === val) {
            messageDiv.style.color = '#2e7d32';
            messageDiv.textContent = `Value ${val} found in the tree.`;
          } else {
            messageDiv.style.color = '#d32f2f';
            messageDiv.textContent = `Value ${val} NOT found in the tree.`;
          }
          updateTraversals();
        }
      }
      animateStep();
      valueInput.value = '';
      valueInput.focus();
    });

    // Clear tree handler
    clearBtn.addEventListener('click', () => {
      resetMessage();
      if (bst.root === null) {
        messageDiv.textContent = 'Tree is already empty.';
        return;
      }
      bst.root = null;
      messageDiv.style.color = '#2e7d32';
      messageDiv.textContent = 'Tree cleared successfully.';
      updateTraversals();
      renderTree();
      valueInput.value = '';
      valueInput.focus();
    });

    // Initial UI state
    updateTraversals();
    renderTree();

    // Enable enter key for input field to do insert by default
    valueInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        insertBtn.click();
      }
    });
  </script>
</body>
</html>