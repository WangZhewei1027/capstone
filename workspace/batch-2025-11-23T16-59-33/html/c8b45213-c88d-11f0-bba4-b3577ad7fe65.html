<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Deque (Double-Ended Queue) Demo</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 2rem;
      background: #f5f5f5;
    }
    h1 {
      text-align: center;
      margin-bottom: 1rem;
    }
    #deque-container {
      max-width: 600px;
      margin: 0 auto 2rem;
      padding: 1rem;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    .deque-display {
      margin-bottom: 1rem;
      font-size: 1.2rem;
      word-wrap: break-word;
      min-height: 2rem;
      background: #eaeaea;
      border-radius: 4px;
      padding: 0.5rem 1rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    .deque-element {
      background: #0275d8;
      color: white;
      padding: 0.3rem 0.7rem;
      border-radius: 4px;
      font-weight: bold;
      user-select: none;
      min-width: 20px;
      text-align: center;
    }
    .btn-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.7rem;
      justify-content: center;
      margin-bottom: 1rem;
    }
    button {
      background: #0275d8;
      border: none;
      color: white;
      padding: 0.5rem 1.2rem;
      border-radius: 4px;
      font-size: 1rem;
      cursor: pointer;
      user-select: none;
      transition: background 0.3s;
    }
    button:disabled {
      background: #7ba9d9;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background: #025aa5;
    }
    input[type="text"] {
      padding: 0.4rem 0.7rem;
      font-size: 1rem;
      border-radius: 4px;
      border: 1px solid #aaa;
      width: 120px;
      margin-right: 0.5rem;
    }
    .input-group {
      display: flex;
      justify-content: center;
      margin-bottom: 1rem;
      gap: 0.5rem;
    }
    .info {
      text-align: center;
      max-width: 600px;
      margin: 0 auto;
      font-size: 0.95rem;
      color: #444;
    }
    @media (max-width: 480px) {
      .input-group {
        flex-direction: column;
        align-items: center;
      }
      input[type="text"] {
        width: 100%;
        margin: 0 0 0.5rem 0;
      }
      .btn-group {
        flex-direction: column;
      }
      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <h1>Deque (Double-Ended Queue) Demo</h1>
  <div id="deque-container">
    <div class="deque-display" id="dequeDisplay" aria-live="polite" aria-label="Contents of the deque" role="list"></div>

    <div class="input-group">
      <input type="text" id="valueInput" placeholder="Enter value" aria-label="Value to add to deque" />
    </div>
    
    <div class="btn-group">
      <button id="pushFrontBtn" title="Add to front">Add Front</button>
      <button id="pushBackBtn" title="Add to back">Add Back</button>
      <button id="popFrontBtn" title="Remove from front">Remove Front</button>
      <button id="popBackBtn" title="Remove from back">Remove Back</button>
      <button id="clearBtn" title="Clear the deque" style="background:#d9534f;">Clear</button>
    </div>
  </div>

  <div class="info">
    <p>
      A <strong>Deque</strong> (Double-Ended Queue) is a data structure that allows insertion and deletion of elements from both the front and back ends.
    </p>
    <p>
      Try adding values to the front or back, and removing them likewise. The current contents of the deque are shown above.
    </p>
  </div>

  <script>
    // Deque implementation with a simple class wrapping an array
    class Deque {
      constructor() {
        this._data = [];
      }
      pushFront(item) {
        this._data.unshift(item);
      }
      pushBack(item) {
        this._data.push(item);
      }
      popFront() {
        if(this.isEmpty()) return null;
        return this._data.shift();
      }
      popBack() {
        if(this.isEmpty()) return null;
        return this._data.pop();
      }
      peekFront() {
        if(this.isEmpty()) return null;
        return this._data[0];
      }
      peekBack() {
        if(this.isEmpty()) return null;
        return this._data[this._data.length - 1];
      }
      isEmpty() {
        return this._data.length === 0;
      }
      clear() {
        this._data = [];
      }
      toArray() {
        return this._data.slice();
      }
      size() {
        return this._data.length;
      }
    }

    // UI and logic
    (function(){
      const deque = new Deque();

      const dequeDisplay = document.getElementById('dequeDisplay');
      const valueInput = document.getElementById('valueInput');
      const pushFrontBtn = document.getElementById('pushFrontBtn');
      const pushBackBtn = document.getElementById('pushBackBtn');
      const popFrontBtn = document.getElementById('popFrontBtn');
      const popBackBtn = document.getElementById('popBackBtn');
      const clearBtn = document.getElementById('clearBtn');

      // Update the visual display of the deque
      function updateDisplay() {
        dequeDisplay.innerHTML = '';
        const arr = deque.toArray();

        if(arr.length === 0) {
          const emptyMsg = document.createElement('span');
          emptyMsg.textContent = 'Deque is empty';
          emptyMsg.style.color = '#888';
          emptyMsg.style.fontStyle = 'italic';
          dequeDisplay.appendChild(emptyMsg);
        } else {
          arr.forEach((item, idx) => {
            const el = document.createElement('span');
            el.className = 'deque-element';
            el.textContent = item;
            el.setAttribute('role', 'listitem');
            if(idx === 0) el.title = 'Front of deque';
            else if(idx === arr.length -1) el.title = 'Back of deque';
            dequeDisplay.appendChild(el);
          });
        }
        updateButtons();
      }

      // Enable/disable buttons based on deque state and input
      function updateButtons() {
        const hasValue = valueInput.value.trim() !== '';
        pushFrontBtn.disabled = !hasValue;
        pushBackBtn.disabled = !hasValue;
        const empty = deque.isEmpty();
        popFrontBtn.disabled = empty;
        popBackBtn.disabled = empty;
      }

      // Event handlers
      pushFrontBtn.addEventListener('click', () => {
        const val = valueInput.value.trim();
        if(val !== '') {
          deque.pushFront(val);
          valueInput.value = '';
          updateDisplay();
          valueInput.focus();
        }
      });

      pushBackBtn.addEventListener('click', () => {
        const val = valueInput.value.trim();
        if(val !== '') {
          deque.pushBack(val);
          valueInput.value = '';
          updateDisplay();
          valueInput.focus();
        }
      });

      popFrontBtn.addEventListener('click', () => {
        if(!deque.isEmpty()) {
          const removed = deque.popFront();
          alert(`Removed from front: "${removed}"`);
          updateDisplay();
        }
      });

      popBackBtn.addEventListener('click', () => {
        if(!deque.isEmpty()) {
          const removed = deque.popBack();
          alert(`Removed from back: "${removed}"`);
          updateDisplay();
        }
      });

      clearBtn.addEventListener('click', () => {
        if(deque.isEmpty()) return;
        if(confirm('Clear all elements from the deque?')) {
          deque.clear();
          updateDisplay();
        }
      });

      valueInput.addEventListener('input', updateButtons);

      // Initialize
      updateDisplay();
    })();
  </script>
</body>
</html>