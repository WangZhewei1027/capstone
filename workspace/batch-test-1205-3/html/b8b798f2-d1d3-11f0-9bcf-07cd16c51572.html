<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topological Sort Demonstration</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        #graph {
            margin: 20px 0;
        }
        .node {
            display: inline-block;
            margin: 5px;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 5px;
            background-color: #f0f0f0;
        }
        .button {
            padding: 10px 15px;
            background-color: #008CBA;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .button:hover {
            background-color: #005f71;
        }
    </style>
</head>
<body>

    <h1>Topological Sort Demonstration</h1>
    <p>Enter the edges of a Directed Acyclic Graph (DAG) below:</p>
    <textarea id="edgesInput" rows="5" cols="50" placeholder="Enter edges (e.g., 'A B, B C, A C')"></textarea><br>
    <button class="button" onclick="performTopologicalSort()">Perform Topological Sort</button>

    <h2>Result:</h2>
    <div id="result"></div>

    <script>
        function topologicalSort(vertices, edges) {
            const adjList = {};
            const inDegree = {};

            // Initialize adjacency list and in-degree count
            for (let vertex of vertices) {
                adjList[vertex] = [];
                inDegree[vertex] = 0;
            }

            // Fill adjacency list and in-degree count
            edges.forEach(([u, v]) => {
                adjList[u].push(v);
                inDegree[v] += 1;
            });

            const queue = [];
            for (let vertex of vertices) {
                if (inDegree[vertex] === 0) {
                    queue.push(vertex);
                }
            }

            const sortedList = [];
            while (queue.length > 0) {
                const current = queue.shift();
                sortedList.push(current);

                // Decrease in-degree of neighbors
                adjList[current].forEach(neighbor => {
                    inDegree[neighbor] -= 1;
                    if (inDegree[neighbor] === 0) {
                        queue.push(neighbor);
                    }
                });
            }

            return sortedList.length === vertices.length ? sortedList : "Graph has at least one cycle!";
        }

        function performTopologicalSort() {
            const edgesInput = document.getElementById("edgesInput").value;
            const edges = edgesInput.split(",").map(edge => edge.trim().split(" "));
            const vertices = Array.from(new Set(edges.flat())); // Unique vertices
            const resultDiv = document.getElementById("result");

            const sortedOrder = topologicalSort(vertices, edges);
            resultDiv.innerHTML = Array.isArray(sortedOrder) ? sortedOrder.join(" -> ") : sortedOrder;
        }
    </script>

</body>
</html>