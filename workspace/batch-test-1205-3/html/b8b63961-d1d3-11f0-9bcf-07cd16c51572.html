<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red-Black Tree Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
        }
        #tree-container {
            margin: auto;
            border: 1px solid #000;
            width: 80%;
            height: 400px;
            position: relative;
        }
        .node {
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: inline-block;
            line-height: 30px;
            color: white;
            text-align: center;
            position: absolute;
        }
        .red {
            background-color: red;
        }
        .black {
            background-color: black;
        }
        .line {
            width: 2px;
            background: black;
            position: absolute;
        }
    </style>
</head>
<body>

<h1>Red-Black Tree Visualization</h1>
<div id="tree-container"></div>
<input type="number" id="value-input" placeholder="Enter a value"/>
<button onclick="insertValue()">Insert Value</button>

<script>
    class Node {
        constructor(data) {
            this.data = data;
            this.color = "red"; // Initially new nodes are red
            this.left = null;
            this.right = null;
            this.parent = null;
        }
    }

    class RedBlackTree {
        constructor() {
            this.NIL = new Node(null);
            this.NIL.color = "black";
            this.root = this.NIL;
        }

        insert(data) {
            let newNode = new Node(data);
            newNode.left = this.NIL;
            newNode.right = this.NIL;

            let parent = null;
            let current = this.root;

            while (current !== this.NIL) {
                parent = current;
                if (newNode.data < current.data) {
                    current = current.left;
                } else {
                    current = current.right;
                }
            }

            newNode.parent = parent;

            if (parent === null) {
                this.root = newNode; // Tree was empty
            } else if (newNode.data < parent.data) {
                parent.left = newNode;
            } else {
                parent.right = newNode;
            }

            newNode.color = "red"; // New node must be red
            this.fixViolation(newNode);
        }

        fixViolation(node) {
            while (node !== this.root && node.parent.color === "red") {
                if (node.parent === node.parent.parent.left) {
                    let uncle = node.parent.parent.right;
                    if (uncle.color === "red") {
                        node.parent.color = "black";
                        uncle.color = "black";
                        node.parent.parent.color = "red";
                        node = node.parent.parent;
                    } else {
                        if (node === node.parent.right) {
                            node = node.parent;
                            this.rotateLeft(node);
                        }
                        node.parent.color = "black";
                        node.parent.parent.color = "red";
                        this.rotateRight(node.parent.parent);
                    }
                } else {
                    let uncle = node.parent.parent.left;
                    if (uncle.color === "red") {
                        node.parent.color = "black";
                        uncle.color = "black";
                        node.parent.parent.color = "red";
                        node = node.parent.parent;
                    } else {
                        if (node === node.parent.left) {
                            node = node.parent;
                            this.rotateRight(node);
                        }
                        node.parent.color = "black";
                        node.parent.parent.color = "red";
                        this.rotateLeft(node.parent.parent);
                    }
                }
            }
            this.root.color = "black";
        }

        rotateLeft(node) {
            let y = node.right;
            node.right = y.left;
            if (y.left !== this.NIL) {
                y.left.parent = node;
            }
            y.parent = node.parent;
            if (node.parent === null) {
                this.root = y;
            } else if (node === node.parent.left) {
                node.parent.left = y;
            } else {
                node.parent.right = y;
            }
            y.left = node;
            node.parent = y;
        }

        rotateRight(node) {
            let y = node.left;
            node.left = y.right;
            if (y.right !== this.NIL) {
                y.right.parent = node;
            }
            y.parent = node.parent;
            if (node.parent === null) {
                this.root = y;
            } else if (node === node.parent.right) {
                node.parent.right = y;
            } else {
                node.parent.left = y;
            }
            y.right = node;
            node.parent = y;
        }

        draw(ctx, node, x, y, level) {
            if (node !== this.NIL) {
                ctx.fillStyle = node.color;
                ctx.beginPath();
                ctx.arc(x, y, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "white";
                ctx.fillText(node.data, x - 5, y + 5);

                if (node.left !== this.NIL) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x - 50 / level, y + 50);
                    ctx.stroke();
                    this.draw(ctx, node.left, x - 50 / level, y + 50, level + 1);
                }
                if (node.right !== this.NIL) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + 50 / level, y + 50);
                    ctx.stroke();
                    this.draw(ctx, node.right, x + 50 / level, y + 50, level + 1);
                }
            }
        }
    }

    const rbt = new RedBlackTree();
    const canvas = document.createElement('canvas');
    canvas.width = 800;
    canvas.height = 400;
    document.getElementById('tree-container').appendChild(canvas);
    const ctx = canvas.getContext('2d');

    function insertValue() {
        const value = parseInt(document.getElementById('value-input').value);
        if (!isNaN(value)) {
            rbt.insert(value);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            rbt.draw(ctx, rbt.root, canvas.width / 2, 40, 1);
        }
    }
</script>
</body>
</html>