<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 20px;
        }
        h1 {
            color: #333;
        }
        .content {
            background: #fff;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        pre {
            background: #eaeaea;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="content">
        <h1>Dijkstra's Algorithm</h1>
        <p>Dijkstra's Algorithm is a graph search algorithm that solves the single-source shortest path problem for a graph with non-negative edge weights, producing a shortest path tree. It is often used in routing and as a subroutine in other graph algorithms.</p>
        
        <h2>How It Works</h2>
        <ol>
            <li>Mark all nodes as unvisited. Create a set of all the unvisited nodes called the unvisited set.</li>
            <li>Assign a tentative distance value to every node: set it to zero for the initial node and to infinity for all other nodes.</li>
            <li>While there are unvisited nodes:</li>
            <ul>
                <li>For the current node, consider all of its unvisited neighbors and calculate their tentative distances through the current node.</li>
                <li>Compare the newly calculated tentative distance to the current assigned value and assign the smaller one.</li>
                <li>After considering all neighbors, mark the current node as visited.</li>
                <li>Once all nodes have been visited, the algorithm is complete.</li>
            </ul>
        </ol>

        <h2>Example Pseudocode</h2>
        <pre>
function dijkstra(graph, source):
    dist[source] ← 0
    for each vertex v in graph:
        if v ≠ source:
            dist[v] ← infinity
        add v to unvisited set
    while unvisited set is not empty:
        u ← vertex in unvisited set with smallest dist[]
        remove u from unvisited set
        for each neighbor v of u:
            alt ← dist[u] + length(u, v)
            if alt < dist[v]:
                dist[v] ← alt
        return dist
        </pre>
    </div>
</body>
</html>