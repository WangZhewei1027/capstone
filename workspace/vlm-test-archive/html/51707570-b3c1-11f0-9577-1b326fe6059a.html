<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floyd-Warshall Algorithm</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
        }
        h1 {
            color: #333;
        }
        h2 {
            color: #555;
        }
        pre {
            background-color: #eee;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>Floyd-Warshall Algorithm</h1>
    <h2>Description</h2>
    <p>The Floyd-Warshall algorithm is a dynamic programming technique used to find the shortest paths between all pairs of nodes in a weighted graph. It is applicable to both directed and undirected graphs.</p>

    <h2>Algorithm Steps</h2>
    <ol>
        <li>Initialize the distance matrix. Set the distance from each vertex to itself as zero and the distance between two vertices as the weight of the edge connecting them (if it exists).</li>
        <li>For each vertex k, update the distance matrix. For each pair of vertices (i, j), check if the path from i to j through k is shorter than the direct path from i to j.</li>
        <li>Repeat the process for each vertex k.</li>
    </ol>

    <h2>Example Code (Python)</h2>
    <pre>
def floyd_warshall(graph):
    num_vertices = len(graph)
    
    # Initialize distance matrix
    dist = [[float('inf')] * num_vertices for _ in range(num_vertices)]
    for i in range(num_vertices):
        for j in range(num_vertices):
            dist[i][j] = graph[i][j]
    
    # Update distances
    for k in range(num_vertices):
        for i in range(num_vertices):
            for j in range(num_vertices):
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist
    </pre>

    <h2>Complexity</h2>
    <p>The time complexity of the Floyd-Warshall algorithm is O(V^3), where V is the number of vertices in the graph.</p>

    <h2>Use Cases</h2>
    <ul>
        <li>Network routing protocols</li>
        <li>Finding shortest paths in weighted graphs</li>
    </ul>
</body>
</html>