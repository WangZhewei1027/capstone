<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Exploration - Directed & Undirected</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 24px;
            background-color: #f9f9f9;
        }
        h1 {
            text-align: center;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #graph-container {
            width: 80%;
            height: 400px;
            border: 2px dashed #4a90e2;
            position: relative;
            margin-top: 16px;
            background-color: #ffffff;
        }
        .node {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: #4a90e2;
            position: absolute;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .edge {
            position: absolute;
            background-color: #4a90e2;
            height: 2px;
        }
        #controls {
            margin-top: 16px;
        }
        #graph-type {
            margin-right: 8px;
        }
        .button {
            margin-right: 16px;
            padding: 8px 12px;
            background-color: #4a90e2;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .button:hover {
            background-color: #357ab9;
        }
    </style>
</head>
<body>

<h1>Exploring Graphs: Directed & Undirected</h1>
<div class="container">
    <div id="graph-container"></div>
    <div id="controls">
        <select id="graph-type">
            <option value="undirected">Undirected</option>
            <option value="directed">Directed</option>
        </select>
        <button class="button" id="add-node">Add Node</button>
        <button class="button" id="add-edge">Add Edge</button>
    </div>
</div>

<script>
    let nodes = [];
    let edges = [];
    const graphContainer = document.getElementById('graph-container');
    const graphTypeSelect = document.getElementById('graph-type');

    document.getElementById('add-node').addEventListener('click', addNode);
    document.getElementById('add-edge').addEventListener('click', addEdge);

    function addNode() {
        const nodeId = nodes.length;
        const node = document.createElement('div');
        node.classList.add('node');
        node.innerText = nodeId;
        node.style.left = Math.random() * (graphContainer.clientWidth - 30) + 'px';
        node.style.top = Math.random() * (graphContainer.clientHeight - 30) + 'px';
        node.addEventListener('click', (event) => {
            event.stopPropagation();
            alert('Node ' + nodeId + ' clicked!');
        });
        nodes.push(nodeId);
        graphContainer.appendChild(node);
    }

    function addEdge() {
        if (nodes.length < 2) {
            alert('Add at least two nodes first!');
            return;
        }
        const startNodeId = Math.floor(Math.random() * nodes.length);
        const endNodeId = Math.floor(Math.random() * nodes.length);
        if (startNodeId === endNodeId) {
            return; // Prevent self-loop
        }
        const startNode = graphContainer.children[startNodeId];
        const endNode = graphContainer.children[endNodeId];
        
        const edge = document.createElement('div');
        edge.classList.add('edge');
        const startX = parseInt(startNode.style.left) + 15;
        const startY = parseInt(startNode.style.top) + 15;
        const endX = parseInt(endNode.style.left) + 15;
        const endY = parseInt(endNode.style.top) + 15;

        const direction = graphTypeSelect.value === 'directed' ? 'block' : 'none';
        edge.style = `top: ${startY}px; left: ${startX}px; width: ${Math.sqrt(Math.pow(endX-startX, 2) + Math.pow(endY-startY, 2))}px; transform-origin: left; transform: rotate(${Math.atan2(endY - startY, endX - startX) * (180 / Math.PI)}deg); display: ${direction};`;

        graphContainer.appendChild(edge);
    }
</script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite state machine modeling user interactions for adding nodes and edges in a simple graph exploration app with a directed/undirected mode, including alerts and visual feedback.",
  "states": [
    {
      "name": "idle",
      "onEnter": "READY",
      "on": {
        "CLICK_ADD_NODE": "adding_node",
        "CLICK_ADD_EDGE": "adding_edge",
        "CLICK_NODE": "showing_node_alert",
        "CHANGE_GRAPH_TYPE": "idle"
      }
    },
    {
      "name": "adding_node",
      "onEnter": "CREATE_NODE_ELEMENT",
      "on": {
        "NODE_CREATED": "idle"
      }
    },
    {
      "name": "showing_node_alert",
      "onEnter": "SHOW_ALERT_NODE_CLICKED",
      "on": {
        "ALERT_DISMISSED": "idle"
      }
    },
    {
      "name": "adding_edge",
      "onEnter": "START_EDGE_CREATION",
      "on": {
        "NODES_LT_TWO": "edge_add_blocked_alert",
        "SELF_LOOP_SELECTED": "edge_add_aborted",
        "EDGE_CREATED_VISIBLE": "edge_added_visible",
        "EDGE_CREATED_HIDDEN": "edge_added_hidden"
      }
    },
    {
      "name": "edge_add_blocked_alert",
      "onEnter": "SHOW_ALERT_NOT_ENOUGH_NODES",
      "on": {
        "ALERT_DISMISSED": "idle"
      }
    },
    {
      "name": "edge_add_aborted",
      "onEnter": "ABORT_EDGE_CREATION",
      "on": {
        "DONE": "idle"
      }
    },
    {
      "name": "edge_added_visible",
      "onEnter": "APPEND_EDGE_VISIBLE",
      "on": {
        "EDGE_APPENDED": "idle"
      }
    },
    {
      "name": "edge_added_hidden",
      "onEnter": "APPEND_EDGE_HIDDEN",
      "on": {
        "EDGE_APPENDED": "idle"
      }
    }
  ],
  "events": [
    "CLICK_ADD_NODE",
    "CLICK_ADD_EDGE",
    "CLICK_NODE",
    "CHANGE_GRAPH_TYPE",
    "NODE_CREATED",
    "ALERT_DISMISSED",
    "NODES_LT_TWO",
    "SELF_LOOP_SELECTED",
    "EDGE_CREATED_VISIBLE",
    "EDGE_CREATED_HIDDEN",
    "EDGE_APPENDED",
    "DONE"
  ],
  "notes": "Behavior mapping to code: 1) CLICK_ADD_NODE calls addNode(), which creates a .node element with random position, adds a click listener that shows an alert, appends it to #graph-container, then transitions back via NODE_CREATED. 2) Clicking a node triggers CLICK_NODE -> SHOW_ALERT_NODE_CLICKED ('Node X clicked!'), and returns on ALERT_DISMISSED. 3) CLICK_ADD_EDGE calls addEdge(): If fewer than two nodes exist, NODES_LT_TWO -> SHOW_ALERT_NOT_ENOUGH_NODES ('Add at least two nodes first!'), then ALERT_DISMISSED -> idle. If two or more nodes exist, random start/end are chosen; if equal, SELF_LOOP_SELECTED -> ABORT_EDGE_CREATION (silent abort), then DONE -> idle. Otherwise an edge is created. Its visibility depends on #graph-type value at the moment of creation: 'directed' yields EDGE_CREATED_VISIBLE -> APPEND_EDGE_VISIBLE (display:block), 'undirected' yields EDGE_CREATED_HIDDEN -> APPEND_EDGE_HIDDEN (display:none). After DOM append, EDGE_APPENDED -> idle. 4) CHANGE_GRAPH_TYPE has no JS listener; it does not trigger immediate state changes but affects subsequent edge creation visibility. 5) There are no animations or data loading states. 6) Implementation caveat: addEdge() retrieves start/end elements via graphContainer.children[startNodeId/endNodeId]; since edges are also appended to the same container, indices may not consistently refer to nodes once edges exist, potentially causing incorrect element selection. 7) Node click handler uses event.stopPropagation(); clicks on the container do nothing since no container click listener is defined."
}
  </script>
</body>
</html>