<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #graph {
            width: 800px;
            height: 600px;
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <h1>Dijkstra's Algorithm</h1>
    <button id="generate-btn">Generate Graph</button>
    <canvas id="graph"></canvas>

    <script>
        const generateGraph = () => {
            const graph = {
                vertices: ['A', 'B', 'C', 'D', 'E'],
                edges: [
                    ['A', 'B'],
                    ['A', 'C'],
                    ['B', 'D'],
                    ['C', 'D'],
                    ['D', 'E']
                ]
            };

            const graphCanvas = document.getElementById('graph');
            const graphContext = graphCanvas.getContext('2d');
            graphContext.clearRect(0, 0, graphCanvas.width, graphCanvas.height);

            for (const vertex of graph.vertices) {
                graphContext.beginPath();
                graphContext.arc(vertex, 20, 10, 0, 2 * Math.PI);
                graphContext.fillStyle = 'blue';
                graphContext.fill();
            }

            for (const edge of graph.edges) {
                graphContext.beginPath();
                graphContext.moveTo(edge[0].x, edge[0].y + 20);
                graphContext.lineTo(edge[1].x, edge[1].y + 20);
                graphContext.strokeStyle = 'red';
                graphContext.lineWidth = 2;
                graphContext.stroke();
            }

            const startVertex = graph.vertices[0];
            const endVertex = graph.vertices[graph.vertices.length - 1];

            const distances = Array.from({ length: graph.vertices.length }, () => new Array(graph.vertices.length).fill(Infinity));
            distances[startVertex] = 0;

            const previousVertices = Array.from({ length: graph.vertices.length }, () => null);
            previousVertices[startVertex] = null;

            const queue = [startVertex];

            while (queue.length > 0) {
                const currentVertex = queue.shift();
                for (const neighbor of graph.edges.filter(edge => edge[0] === currentVertex)) {
                    const distance = distances[currentVertex][neighbor[0]];
                    if (distance !== Infinity && distance < distances[neighbor[0]]) {
                        distances[neighbor[0]] = distance;
                        previousVertices[neighbor[0]] = currentVertex;
                        queue.push(neighbor[0]);
                    }
                }
            }

            const shortestDistances = Array.from({ length: graph.vertices.length }, () => new Array(graph.vertices.length).fill(Infinity));
            for (let i = 0; i < graph.vertices.length; i++) {
                for (let j = 0; j < graph.vertices.length; j++) {
                    if (i !== j) {
                        shortestDistances[i][j] = distances[i][j] + Math.sqrt(Math.pow(graph.vertices[j] - graph.vertices[i], 2));
                    }
                }
            }

            const shortestDistance = shortestDistances[0][graph.vertices.length - 1];
            const shortestVertex = graph.vertices.length - 1;

            console.log(`Shortest distance from vertex ${startVertex} to vertex ${endVertex}: ${shortestDistance}`);
            console.log("Shortest path:");
            const path = [];
            let currentVertex = endVertex;
            while (currentVertex !== null) {
                path.push(currentVertex);
                currentVertex = previousVertices[currentVertex];
            }
            path.reverse();
            console.log(path.join(' -> '));
        };

        const generateBtn = document.getElementById('generate-btn');
        generateBtn.addEventListener('click', generateGraph);
    </script>
</body>
</html>