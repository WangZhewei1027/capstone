<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huffman Coding</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .container {
            width: 80%;
            margin: 40px auto;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .header h1 {
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Huffman Coding</h1>
        <p>By: <span id="name"></span></p>
        <p>By: <span id="code"></span></p>
        <p>By: <span id="frequency"></span></p>
        <form id="input-form">
            <input type="text" id="input-text" placeholder="Enter text to encode">
            <button id="encode-button">Encode</button>
        </form>
        <form id="output-form">
            <input type="text" id="output-text" placeholder="Enter encoded text to decode">
            <button id="decode-button">Decode</button>
        </form>
        <p id="error-message"></p>
    </div>

    <script>
        let name = document.getElementById('name').innerHTML;
        let code = document.getElementById('code').innerHTML;
        let frequency = document.getElementById('frequency').innerHTML;

        function calculateFrequency(text) {
            let frequencyMap = {};
            for (let char of text) {
                if (char in frequencyMap) {
                    frequencyMap[char] += 1;
                } else {
                    frequencyMap[char] = 1;
                }
            }
            return frequencyMap;
        }

        function buildHuffmanTree(frequencyMap) {
            let nodes = [];
            for (let char in frequencyMap) {
                let node = { char: char, frequency: frequencyMap[char], left: null, right: null };
                nodes.push(node);
            }
            while (nodes.length > 1) {
                nodes.sort((a, b) => a.frequency - b.frequency);
                let mergedNode = nodes[0];
                nodes[0] = nodes[nodes.length - 1];
                nodes.pop();
                mergedNode.left = nodes[0];
                mergedNode.right = nodes[1];
                nodes.splice(1, 1);
            }
            return nodes[0];
        }

        function buildHuffmanEncodingTree(huffmanTree) {
            let encodingMap = {};
            function buildEncodingMap(node) {
                if (node.char) {
                    encodingMap[node.char] = node.char;
                } else {
                    buildEncodingMap(node.left);
                    buildEncodingMap(node.right);
                }
            }
            buildEncodingMap(huffmanTree);
            return encodingMap;
        }

        function buildHuffmanDecodingTree(encodingMap, huffmanTree) {
            let decodingMap = {};
            function buildDecodingMap(node, parent) {
                if (node.char) {
                    decodingMap[node.char] = parent;
                } else {
                    buildDecodingMap(node.left, node);
                    buildDecodingMap(node.right, node);
                }
            }
            buildDecodingMap(huffmanTree, null);
            return decodingMap;
        }

        function huffmanCoding(text) {
            let frequencyMap = calculateFrequency(text);
            let huffmanTree = buildHuffmanTree(frequencyMap);
            let encodingMap = buildHuffmanEncodingTree(huffmanTree);
            let encodedText = '';
            for (let char of text) {
                encodedText += encodingMap[char] + ' ';
            }
            return encodedText;
        }

        function huffmanDecoding(encodedText, huffmanTree) {
            let decodedText = '';
            function buildDecodedText(node, parent) {
                if (node.char) {
                    decodedText += node.char;
                } else {
                    buildDecodedText(node.left, node);
                    buildDecodedText(node.right, node);
                }
            }
            buildDecodedText(huffmanTree, null);
            return decodedText;
        }

        document.getElementById('input-form').addEventListener('submit', function(event) {
            event.preventDefault();
            let text = document.getElementById('input-text').value;
            let encodedText = huffmanCoding(text);
            document.getElementById('encoded-text').innerHTML = encodedText;
            document.getElementById('error-message').innerHTML = '';
        });

        document.getElementById('decode-button').addEventListener('click', function() {
            let encodedText = document.getElementById('encoded-text').innerHTML;
            let decodedText = huffmanDecoding(encodedText, buildHuffmanDecodingTree(huffmanTree));
            document.getElementById('decoded-text').innerHTML = decodedText;
            document.getElementById('error-message').innerHTML = '';
        });

        let huffmanTree = buildHuffmanTree(calculateFrequency(document.getElementById('input-text').value));
        let encodingMap = buildHuffmanEncodingTree(huffmanTree);
        let decodedText = huffmanDecoding(document.getElementById('encoded-text').innerHTML, huffmanTree);
        document.getElementById('decoded-text').innerHTML = decodedText;
    </script>
</body>
</html>