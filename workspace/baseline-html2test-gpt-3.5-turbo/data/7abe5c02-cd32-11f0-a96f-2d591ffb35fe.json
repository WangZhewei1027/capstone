{
  "id": "7abe5c02-cd32-11f0-a96f-2d591ffb35fe",
  "timestamp": "2025-11-29T14:49:48.861Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Heap (Min/Max)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Heap (Min/Max) Demonstration</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 1em;\n    max-width: 800px;\n  }\n  h1, h2 {\n    text-align: center;\n  }\n  .heap-container {\n    display: flex;\n    justify-content: space-around;\n    margin-top: 1em;\n  }\n  .heap-box {\n    border: 1px solid #aaa;\n    padding: 1em;\n    width: 45%;\n    box-sizing: border-box;\n    background: #f9f9f9;\n  }\n  pre {\n    background: #eee;\n    padding: 1em;\n    overflow-x: auto;\n  }\n  input[type=number] {\n    width: 4em;\n  }\n  button {\n    margin-left: 0.5em;\n  }\n  .heap-visual {\n    margin-top: 1em;\n  }\n  .node {\n    display: inline-block;\n    background: #4a90e2;\n    color: white;\n    border-radius: 50%;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    margin: 0 7px;\n    font-weight: bold;\n    user-select: none;\n    position: relative;\n  }\n  .heap-level {\n    margin-bottom: 1.2em;\n    white-space: nowrap;\n  }\n  .connections {\n    position: relative;\n    height: 40px;\n    margin-bottom: 10px;\n  }\n  /* Lines connecting nodes */\n  .line-left, .line-right {\n    position: absolute;\n    border-top: 2px solid #555;\n    top: 0;\n    width: 20px;\n  }\n  .line-left {\n    transform: rotate(310deg);\n    left: 50%;\n    transform-origin: left top;\n  }\n  .line-right {\n    transform: rotate(50deg);\n    right: 50%;\n    transform-origin: right top;\n  }\n</style>\n</head>\n<body>\n\n<h1>Heap (Min/Max) Demonstration</h1>\n<p>\n  A <strong>Heap</strong> is a specialized tree-based data structure that satisfies the heap property:\n  - <strong>Min-Heap:</strong> Parent node ≤ children\n  - <strong>Max-Heap:</strong> Parent node ≥ children\n</p>\n\n<div style=\"text-align:center; margin-bottom: 1em;\">\n  <label>\n    Choose heap type:\n    <select id=\"heapType\">\n      <option value=\"min\">Min-Heap</option>\n      <option value=\"max\">Max-Heap</option>\n    </select>\n  </label>\n</div>\n\n<div style=\"text-align:center; margin-bottom: 1em;\">\n  <input type=\"number\" id=\"inputValue\" placeholder=\"Value\" />\n  <button id=\"insertBtn\">Insert</button>\n  <button id=\"extractBtn\">Extract Root</button>\n  <button id=\"clearBtn\">Clear</button>\n</div>\n\n<div class=\"heap-container\">\n  <div class=\"heap-box\">\n    <h2>Heap Array Representation</h2>\n    <pre id=\"heapArrayDisplay\">[]</pre>\n  </div>\n  <div class=\"heap-box\">\n    <h2>Heap Tree Visualization</h2>\n    <div id=\"heapTreeVisual\" class=\"heap-visual\" aria-label=\"Heap tree visualization\"></div>\n  </div>\n</div>\n\n<script>\n  // Heap class supporting both min and max heap\n  class Heap {\n    constructor(type = 'min') {\n      this.heap = [];\n      this.type = type; // 'min' or 'max'\n    }\n\n    compare(a, b) {\n      // Min-heap: a < b => true\n      // Max-heap: a > b => true\n      if (this.type === 'min') {\n        return a < b;\n      } else {\n        return a > b;\n      }\n    }\n\n    insert(value) {\n      this.heap.push(value);\n      this.bubbleUp();\n    }\n\n    bubbleUp() {\n      let index = this.heap.length - 1;\n      const current = this.heap[index];\n      while (index > 0) {\n        let parentIndex = Math.floor((index - 1) / 2);\n        let parent = this.heap[parentIndex];\n        if (this.compare(current, parent)) {\n          this.heap[parentIndex] = current;\n          this.heap[index] = parent;\n          index = parentIndex;\n        } else {\n          break;\n        }\n      }\n    }\n\n    extractRoot() {\n      if (this.heap.length === 0) return null;\n      const root = this.heap[0];\n      const end = this.heap.pop();\n      if (this.heap.length > 0) {\n        this.heap[0] = end;\n        this.sinkDown(0);\n      }\n      return root;\n    }\n\n    sinkDown(index) {\n      const length = this.heap.length;\n      const current = this.heap[index];\n      while(true) {\n        let leftChildIdx = 2 * index + 1;\n        let rightChildIdx = 2 * index + 2;\n        let swap = null;\n\n        if (leftChildIdx < length) {\n          let leftChild = this.heap[leftChildIdx];\n          if (this.compare(leftChild, current)) {\n            swap = leftChildIdx;\n          }\n        }\n        if (rightChildIdx < length) {\n          let rightChild = this.heap[rightChildIdx];\n          if (this.compare(rightChild, swap === null ? current : this.heap[swap])) {\n            swap = rightChildIdx;\n          }\n        }\n        if (swap === null) break;\n\n        this.heap[index] = this.heap[swap];\n        this.heap[swap] = current;\n        index = swap;\n      }\n    }\n\n    clear() {\n      this.heap = [];\n    }\n  }\n\n  // Visualization functions\n  function updateArrayDisplay(heap) {\n    const display = document.getElementById('heapArrayDisplay');\n    display.textContent = JSON.stringify(heap.heap);\n  }\n\n  function buildTreeLevels(heapArr) {\n    // Build an array of arrays representing levels of the heap tree\n    const levels = [];\n    let level = 0;\n    let count = 0;\n    while (count < heapArr.length) {\n      let nodesInLevel = Math.pow(2, level);\n      levels.push(heapArr.slice(count, count + nodesInLevel));\n      count += nodesInLevel;\n      level++;\n    }\n    return levels;\n  }\n\n  function createConnectionLines(levelIndex, nodesCount) {\n    // Returns HTML for lines connecting nodes to children\n    // For visual clarity, we only support basic angled lines.\n    // This is a simple and not perfect solution for connections.\n    const container = document.createElement('div');\n    container.className = 'connections';\n    // Each node except the ones at the edges get two lines (left and right)\n    // but we control the CSS arrows via absolute position.\n    // We keep it minimal here, actual lines done in CSS relative to node positions.\n    // We'll keep this empty as lines are handled by CSS on nodes parent-child positioning.\n    return container;\n  }\n\n  function renderHeapTree(heap) {\n    const container = document.getElementById('heapTreeVisual');\n    container.innerHTML = '';\n    if (heap.heap.length === 0) {\n      container.textContent = '(empty)';\n      return;\n    }\n    // Build levels\n    const levels = buildTreeLevels(heap.heap);\n    // We will render inline blocks for each node and attempt to show tree levels\n    // with spacing so it forms a rough tree shape.\n\n    // For each level, create a div with nodes spaced properly\n    // We use monospace fallback for spacing in nodes container\n\n    levels.forEach((nodes, lvl) => {\n      const levelDiv = document.createElement('div');\n      levelDiv.className = 'heap-level';\n\n      // Calculate spacing\n      // Max width of heap tree is nodes.length in last level * 2 spaces spaced approx\n      // We'll center nodes by adding margin on left and between nodes\n\n      const totalWidth = Math.pow(2, levels.length) * 50; // heuristic for spacing\n      const levelWidth = Math.pow(2, lvl) * 50;\n      // add left margin to center this level\n      const leftMargin = (totalWidth - levelWidth) / 2;\n\n      levelDiv.style.marginLeft = leftMargin + 'px';\n\n      nodes.forEach((val, idx) => {\n        const node = document.createElement('div');\n        node.className = 'node';\n        node.textContent = val;\n        // add margin except last node\n        if (idx !== nodes.length - 1) {\n          node.style.marginRight = '40px';\n        }\n        levelDiv.appendChild(node);\n      });\n      container.appendChild(levelDiv);\n    });\n  }\n\n  // Main logic\n  (function(){\n    let heapTypeSelector = document.getElementById('heapType');\n    let inputValue = document.getElementById('inputValue');\n    let insertBtn = document.getElementById('insertBtn');\n    let extractBtn = document.getElementById('extractBtn');\n    let clearBtn = document.getElementById('clearBtn');\n\n    let heap = new Heap(heapTypeSelector.value);\n\n    function updateUI() {\n      updateArrayDisplay(heap);\n      renderHeapTree(heap);\n    }\n\n    heapTypeSelector.addEventListener('change', () => {\n      heap = new Heap(heapTypeSelector.value);\n      updateUI();\n    });\n\n    insertBtn.addEventListener('click', () => {\n      let val = parseInt(inputValue.value, 10);\n      if (isNaN(val)) {\n        alert(\"Please enter a valid integer value to insert.\");\n        return;\n      }\n      heap.insert(val);\n      inputValue.value = '';\n      inputValue.focus();\n      updateUI();\n    });\n\n    extractBtn.addEventListener('click', () => {\n      let extracted = heap.extractRoot();\n      if (extracted === null) {\n        alert(\"Heap is empty, nothing to extract.\");\n        return;\n      }\n      alert((heap.type === 'min' ? \"Min\" : \"Max\") + \" root extracted: \" + extracted);\n      updateUI();\n    });\n\n    clearBtn.addEventListener('click', () => {\n      heap.clear();\n      updateUI();\n    });\n\n    updateUI();\n\n  })();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap (Min/Max)"
    }
  ],
  "topic": "Heap (Min/Max)",
  "hasFSM": false,
  "hasTest": true
}