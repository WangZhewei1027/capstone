{
  "id": "e03a2052-cd32-11f0-a949-f901cf5609c9",
  "timestamp": "2025-11-29T14:52:33.778Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Weighted Graph Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    overflow: hidden;\n    background: #f0f0f0;\n  }\n  svg {\n    background: white;\n    border: 1px solid #ccc;\n    display: block;\n    margin: 20px auto;\n  }\n  .node circle {\n    fill: #4285f4;\n    stroke: #3367d6;\n    stroke-width: 2px;\n    cursor: pointer;\n    transition: fill 0.3s;\n  }\n  .node text {\n    pointer-events: none;\n    fill: white;\n    font-weight: bold;\n    font-size: 14px;\n    user-select: none;\n    text-anchor: middle;\n    dominant-baseline: middle;\n  }\n  .edge path {\n    stroke: #999;\n    stroke-width: 2px;\n    fill: none;\n  }\n  .edge text {\n    font-size: 12px;\n    fill: #333;\n    user-select: none;\n  }\n  #info {\n    max-width: 700px;\n    margin: 0 auto 20px auto;\n    padding: 10px 15px;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 0 7px rgba(0,0,0,0.1);\n    font-size: 16px;\n  }\n  #legend {\n    max-width: 700px;\n    margin: 0 auto 10px auto;\n    font-size: 14px;\n    color: #555;\n  }\n</style>\n</head>\n<body>\n\n<div id=\"info\">Click a node to highlight its connections and see edge weights.</div>\n<div id=\"legend\">\n  <b>Legend:</b> Blue circles = nodes, Gray lines = edges, Numbers on edges = weights.\n</div>\n\n<svg id=\"graph\" width=\"700\" height=\"500\"></svg>\n\n<script>\n// Weighted Graph Data Structure\n// Nodes and edges with weights\n\nconst nodes = [\n  { id: 0, label: 'A', x: 150, y: 100 },\n  { id: 1, label: 'B', x: 400, y: 80 },\n  { id: 2, label: 'C', x: 600, y: 150 },\n  { id: 3, label: 'D', x: 350, y: 250 },\n  { id: 4, label: 'E', x: 550, y: 350 },\n  { id: 5, label: 'F', x: 180, y: 300 }\n];\n\nconst edges = [\n  { from: 0, to: 1, weight: 7 },\n  { from: 0, to: 5, weight: 9 },\n  { from: 0, to: 3, weight: 14 },\n  { from: 1, to: 2, weight: 10 },\n  { from: 1, to: 3, weight: 15 },\n  { from: 2, to: 4, weight: 11 },\n  { from: 3, to: 4, weight: 2 },\n  { from: 5, to: 4, weight: 6 },\n  { from: 5, to: 3, weight: 9 }\n];\n\n// We treat the graph as undirected for visualization:\n// so each edge is drawn once, between from and to.\n\nconst svg = document.getElementById('graph');\n\nconst ns = \"http://www.w3.org/2000/svg\";\n\n// Create groups for edges and nodes\nconst edgeGroup = document.createElementNS(ns, 'g');\nedgeGroup.setAttribute('id', 'edges');\nsvg.appendChild(edgeGroup);\n\nconst nodeGroup = document.createElementNS(ns, 'g');\nnodeGroup.setAttribute('id', 'nodes');\nsvg.appendChild(nodeGroup);\n\nfunction createEdge(fromNode, toNode, weight) {\n  const edge = document.createElementNS(ns, 'g');\n  edge.classList.add('edge');\n\n  // Draw line/path with a slight curve if desired - here a straight line\n  const path = document.createElementNS(ns, 'path');\n  path.setAttribute('stroke', '#999');\n  path.setAttribute('stroke-width', '2');\n  path.setAttribute('fill', 'none');\n  \n  // For slight offset, we could use a quadratic Bezier curve. Let's keep straight lines:\n  const d = `M${fromNode.x} ${fromNode.y} L${toNode.x} ${toNode.y}`;\n  path.setAttribute('d', d);\n\n  edge.appendChild(path);\n\n  // Edge weight label, positioned mid-point between from & to with slight offset perpendicular\n  const weightText = document.createElementNS(ns, 'text');\n  weightText.classList.add('edge-weight');\n  \n  const midX = (fromNode.x + toNode.x) / 2;\n  const midY = (fromNode.y + toNode.y) / 2;\n\n  // Compute offset perpendicular for better visibility\n  const dx = toNode.x - fromNode.x;\n  const dy = toNode.y - fromNode.y;\n  const length = Math.sqrt(dx*dx + dy*dy);\n  const offset = 15;\n  const offsetX = -dy / length * offset;\n  const offsetY = dx / length * offset;\n\n  weightText.setAttribute('x', midX + offsetX);\n  weightText.setAttribute('y', midY + offsetY);\n  weightText.setAttribute('fill', '#333');\n  weightText.textContent = weight;\n\n  edge.appendChild(weightText);\n\n  return edge;\n}\n\nfunction createNode(node) {\n  const g = document.createElementNS(ns, 'g');\n  g.classList.add('node');\n  g.setAttribute('data-id', node.id);\n\n  const circle = document.createElementNS(ns, 'circle');\n  circle.setAttribute('r', 20);\n  circle.setAttribute('cx', node.x);\n  circle.setAttribute('cy', node.y);\n  circle.setAttribute('fill', '#4285f4');\n  circle.setAttribute('stroke', '#3367d6');\n  circle.setAttribute('stroke-width', 2);\n\n  const text = document.createElementNS(ns, 'text');\n  text.setAttribute('x', node.x);\n  text.setAttribute('y', node.y);\n  text.textContent = node.label;\n\n  g.appendChild(circle);\n  g.appendChild(text);\n\n  return g;\n}\n\n// We draw each edge only once since undirected graph:\nconst seenEdges = new Set();\nedges.forEach(({ from, to, weight }) => {\n  const key = from < to ? `${from}-${to}` : `${to}-${from}`;\n  if (!seenEdges.has(key)) {\n    const edgeElem = createEdge(nodes[from], nodes[to], weight);\n    edgeGroup.appendChild(edgeElem);\n    seenEdges.add(key);\n  }\n});\n\nnodes.forEach(node => {\n  const nodeElem = createNode(node);\n  nodeGroup.appendChild(nodeElem);\n});\n\n// Interaction: clicking on a node highlights it and edges connected to it\n\nconst info = document.getElementById('info');\n\nnodeGroup.querySelectorAll('.node').forEach(nodeElem => {\n  nodeElem.style.cursor = 'pointer';\n  nodeElem.addEventListener('click', () => {\n    const nodeId = Number(nodeElem.getAttribute('data-id'));\n    highlightNodeAndEdges(nodeId);\n  });\n});\n\nfunction highlightNodeAndEdges(nodeId) {\n  // Reset all nodes and edges style\n  nodeGroup.querySelectorAll('.node circle').forEach(c => {\n    c.setAttribute('fill', '#4285f4');\n    c.setAttribute('stroke', '#3367d6');\n  });\n  edgeGroup.querySelectorAll('path').forEach(path => {\n    path.setAttribute('stroke', '#999');\n    path.setAttribute('stroke-width', '2');\n  });\n  edgeGroup.querySelectorAll('text').forEach(t => {\n    t.setAttribute('fill', '#333');\n    t.style.fontWeight = 'normal';\n    t.style.fontSize = '12px';\n  });\n\n  // Highlight selected node\n  const selectedNodeCircle = nodeGroup.querySelector(`.node[data-id=\"${nodeId}\"] circle`);\n  selectedNodeCircle.setAttribute('fill', '#fbbc04');\n  selectedNodeCircle.setAttribute('stroke', '#c49000');\n\n  // Highlight edges connected to this node\n  // And highlight the other node connected as well\n  edges.forEach(({ from, to, weight }) => {\n    if (from === nodeId || to === nodeId) {\n      // Find the path element corresponding to this edge:\n      // Paths are in order and only once, so find by matching coordinates\n      let key = from < to ? `${from}-${to}` : `${to}-${from}`;\n      // We identify edges by positions of the path element in DOM == order in seenEdges\n      // To do a direct approach - find the edge with same endpoints (order independent)\n      // Iterate edges group children to find a path with matching line endpoints\n      for (let edgeElem of edgeGroup.children) {\n        const path = edgeElem.querySelector('path');\n        if (!path) continue;\n        const d = path.getAttribute('d');\n        // d format: MfromX fromY LtoX toY\n        const match = d.match(/M([\\d\\.]+) ([\\d\\.]+) L([\\d\\.]+) ([\\d\\.]+)/);\n        if (!match) continue;\n        const [_, x1, y1, x2, y2] = match;\n        const coords1 = [parseFloat(x1), parseFloat(y1)];\n        const coords2 = [parseFloat(x2), parseFloat(y2)];\n        const nFrom = nodes[from];\n        const nTo = nodes[to];\n        // Check if coords match from-to or to-from\n        if (\n          (approxEqual(coords1[0], nFrom.x) && approxEqual(coords1[1], nFrom.y) &&\n           approxEqual(coords2[0], nTo.x) && approxEqual(coords2[1], nTo.y)) ||\n          (approxEqual(coords2[0], nFrom.x) && approxEqual(coords2[1], nFrom.y) &&\n           approxEqual(coords1[0], nTo.x) && approxEqual(coords1[1], nTo.y))\n        ) {\n          // Highlight this edge\n          path.setAttribute('stroke', '#fbbc04');\n          path.setAttribute('stroke-width', '4');\n          const weightText = edgeElem.querySelector('text');\n          if (weightText) {\n            weightText.setAttribute('fill', '#c49000');\n            weightText.style.fontWeight = 'bold';\n            weightText.style.fontSize = '14px';\n          }\n          // Highlight the other node as well\n          if (from === nodeId) {\n            highlightOtherNode(to);\n          } else {\n            highlightOtherNode(from);\n          }\n          break;\n        }\n      }\n    }\n  });\n\n  info.textContent = `Selected node: ${nodes[nodeId].label}. Highlighted edges show weights of connections. Click another node or the same node again to reset.`;\n}\n\nfunction highlightOtherNode(nodeId) {\n  const nodeCircle = nodeGroup.querySelector(`.node[data-id=\"${nodeId}\"] circle`);\n  const currentFill = nodeCircle.getAttribute('fill');\n  if (currentFill === '#fbbc04') return; // already selected node\n  nodeCircle.setAttribute('fill', '#34a853');\n  nodeCircle.setAttribute('stroke', '#2c8e41');\n}\n\nfunction approxEqual(a, b, epsilon = 0.1) {\n  return Math.abs(a - b) < epsilon;\n}\n\n// Reset highlight on clicking empty space (svg background)\nsvg.addEventListener('click', (evt) => {\n  if (evt.target === svg) {\n    resetHighlights();\n  }\n});\nfunction resetHighlights() {\n  nodeGroup.querySelectorAll('.node circle').forEach(c => {\n    c.setAttribute('fill', '#4285f4');\n    c.setAttribute('stroke', '#3367d6');\n  });\n  edgeGroup.querySelectorAll('path').forEach(path => {\n    path.setAttribute('stroke', '#999');\n    path.setAttribute('stroke-width', '2');\n  });\n  edgeGroup.querySelectorAll('text').forEach(t => {\n    t.setAttribute('fill', '#333');\n    t.style.fontWeight = 'normal';\n    t.style.fontSize = '12px';\n  });\n  info.textContent = 'Click a node to highlight its connections and see edge weights.';\n}\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": false,
  "hasTest": true
}