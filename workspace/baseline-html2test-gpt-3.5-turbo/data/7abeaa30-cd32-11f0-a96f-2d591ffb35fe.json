{
  "id": "7abeaa30-cd32-11f0-a96f-2d591ffb35fe",
  "timestamp": "2025-11-29T14:50:37.214Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <title>Kruskal's Algorithm Visualization</title>\n  <style>\n    body {\n      font-family: Arial, sans-serif;\n      margin: 0;\n      display: flex;\n      flex-direction: column;\n      height: 100vh;\n      overflow: hidden;\n    }\n    header {\n      background: #34495e;\n      color: white;\n      padding: 10px 20px;\n      text-align: center;\n    }\n    #container {\n      flex: 1;\n      display: flex;\n    }\n    #graphCanvas {\n      flex: 2;\n      border-right: 1px solid #ccc;\n      background: #f9f9f9;\n    }\n    #controls {\n      flex: 1;\n      padding: 20px;\n      box-sizing: border-box;\n      background: #f0f0f0;\n      overflow-y: auto;\n    }\n    h2 {\n      margin-top: 0;\n    }\n    button {\n      margin-top: 10px;\n      margin-right: 10px;\n      padding: 10px 15px;\n      font-size: 16px;\n      cursor: pointer;\n    }\n    #edgeList {\n      margin-top: 10px;\n      font-family: monospace;\n      background: white;\n      border: 1px solid #ccc;\n      height: 150px;\n      overflow-y: auto;\n      padding: 10px;\n    }\n    .edge-in-mst {\n      color: green;\n      font-weight: bold;\n    }\n    #log {\n      font-family: monospace;\n      background: #222;\n      color: #eee;\n      height: 120px;\n      margin-top: 20px;\n      padding: 10px;\n      overflow-y: scroll;\n      white-space: pre-wrap;\n      border-radius: 3px;\n    }\n    #info {\n      font-size: 14px;\n      margin-top: 15px;\n      line-height: 1.4;\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Kruskal's Algorithm Visualization</h1>\n  </header>\n  <div id=\"container\">\n    <canvas id=\"graphCanvas\"></canvas>\n    <div id=\"controls\">\n      <h2>Graph & Kruskal's Algorithm</h2>\n      <p>\n        Click on nodes to create edges.<br />\n        After adding edges, click <strong>Run Kruskal</strong> to find the MST.<br />\n        Step through the algorithm with <strong>Next Step</strong>.\n      </p>\n      \n      <button id=\"addNodeBtn\">Add Node</button>\n      <button id=\"clearGraphBtn\">Clear Graph</button>\n      <hr />\n      <div>\n        <strong>Selected edge for creation:</strong>\n        <span id=\"edgeCreateStatus\">None</span>\n      </div>\n      <hr />\n      <button id=\"runKruskalBtn\" disabled>Run Kruskal's Algorithm</button>\n      <button id=\"nextStepBtn\" disabled>Next Step</button>\n      \n      <h3>Edges (weight)</h3>\n      <div id=\"edgeList\"></div>\n      <h3>Algorithm Log</h3>\n      <div id=\"log\"></div>\n\n      <div id=\"info\">\n        <h3>How it works:</h3>\n        <p><strong>Kruskal’s algorithm</strong> finds the Minimum Spanning Tree (MST) of a connected, weighted graph. It works by sorting all edges by weight and then adding edges one-by-one, skipping those which form cycles, until all nodes are connected.</p>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Basic constants and setup\n    const canvas = document.getElementById(\"graphCanvas\");\n    const ctx = canvas.getContext(\"2d\");\n    canvas.width = window.innerWidth * 0.65;\n    canvas.height = window.innerHeight - document.querySelector(\"header\").offsetHeight;\n\n    // For responsive resizing:\n    window.addEventListener('resize', () => {\n      canvas.width = window.innerWidth * 0.65;\n      canvas.height = window.innerHeight - document.querySelector(\"header\").offsetHeight;\n      drawGraph();\n    });\n\n    // Graph data structures\n    let nodes = []; // {id: number, x: number, y: number}\n    let edges = []; // {id: number, n1: nodeId, n2: nodeId, weight: number, inMST: boolean}\n\n    // For edge creation\n    let edgeCreateStartNode = null;\n    const edgeCreateStatus = document.getElementById(\"edgeCreateStatus\");\n\n    // For Kruskal algorithm stepping\n    let kruskalEdgesSorted = [];\n    let mstEdges = [];\n    let kruskalStepIndex = 0;\n    let kruskalRunning = false;\n\n    // UI elements\n    const addNodeBtn = document.getElementById(\"addNodeBtn\");\n    const clearGraphBtn = document.getElementById(\"clearGraphBtn\");\n    const runKruskalBtn = document.getElementById(\"runKruskalBtn\");\n    const nextStepBtn = document.getElementById(\"nextStepBtn\");\n    const edgeListDiv = document.getElementById(\"edgeList\");\n    const logDiv = document.getElementById(\"log\");\n\n    // Draw params\n    const NODE_RADIUS = 20;\n    const NODE_COLOR = \"#2980b9\";\n    const NODE_COLOR_SELECTED = \"#e67e22\";\n    const EDGE_COLOR = \"#7f8c8d\";\n    const EDGE_COLOR_MST = \"#27ae60\";\n    const EDGE_COLOR_HIGHLIGHT = \"#c0392b\";\n\n    // Disjoint Set Union (Union Find) structure for Kruskal cycle detection\n    class DSU {\n      constructor(n) {\n        this.parent = new Array(n);\n        for(let i = 0; i < n; i++) this.parent[i] = i;\n      }\n      find(x) {\n        if(this.parent[x] !== x){\n          this.parent[x] = this.find(this.parent[x]);\n        }\n        return this.parent[x];\n      }\n      union(a,b) {\n        a = this.find(a);\n        b = this.find(b);\n        if(a !== b) {\n          this.parent[b] = a;\n          return true;\n        }\n        return false;\n      }\n    }\n\n    // Utility functions\n    function dist(x1, y1, x2, y2) {\n      return Math.sqrt((x1-x2)**2 + (y1-y2)**2);\n    }\n\n    function drawNode(node, highlight = false) {\n      ctx.beginPath();\n      ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI);\n      ctx.fillStyle = highlight ? NODE_COLOR_SELECTED : NODE_COLOR;\n      ctx.fill();\n      ctx.strokeStyle = \"#34495e\";\n      ctx.lineWidth = 2;\n      ctx.stroke();\n      ctx.fillStyle = \"white\";\n      ctx.font = \"16px Arial\";\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(node.id, node.x, node.y);\n    }\n\n    function drawEdge(edge, highlight = false, inMST = false) {\n      const n1 = nodes.find(n => n.id === edge.n1);\n      const n2 = nodes.find(n => n.id === edge.n2);\n      ctx.beginPath();\n      ctx.moveTo(n1.x, n1.y);\n      ctx.lineTo(n2.x, n2.y);\n      if(inMST) {\n        ctx.strokeStyle = EDGE_COLOR_MST;\n        ctx.lineWidth = 4;\n      } else if (highlight) {\n        ctx.strokeStyle = EDGE_COLOR_HIGHLIGHT;\n        ctx.lineWidth = 3;\n      } else {\n        ctx.strokeStyle = EDGE_COLOR;\n        ctx.lineWidth = 2;\n      }\n      ctx.stroke();\n\n      // Draw weight near the midpoint\n      const midX = (n1.x + n2.x) / 2;\n      const midY = (n1.y + n2.y) / 2;\n      const offsetX = (n2.y - n1.y) / dist(n1.x,n1.y,n2.x,n2.y) * 15;\n      const offsetY = (n1.x - n2.x) / dist(n1.x,n1.y,n2.x,n2.y) * 15;\n\n      ctx.fillStyle = \"#2c3e50\";\n      ctx.font = \"14px Arial\";\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(edge.weight, midX + offsetX, midY + offsetY);\n    }\n\n    // Redraw entire graph\n    function drawGraph(highlightEdge = null) {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      // Draw edges first\n      edges.forEach(edge => {\n        drawEdge(edge, edge === highlightEdge, edge.inMST);\n      });\n      // Draw nodes (highlight selected for edge creation)\n      nodes.forEach(node => {\n        drawNode(node, edgeCreateStartNode && node.id === edgeCreateStartNode.id);\n      });\n    }\n\n    // Refresh edges list display\n    function updateEdgeList() {\n      edgeListDiv.innerHTML = \"\";\n      if(edges.length === 0){\n        edgeListDiv.textContent = \"(No edges)\";\n        return;\n      }\n      edges.forEach(e => {\n        const div = document.createElement(\"div\");\n        div.textContent = `(${e.n1} – ${e.n2}) : ${e.weight}`;\n        if(e.inMST) div.classList.add(\"edge-in-mst\");\n        edgeListDiv.appendChild(div);\n      });\n    }\n\n    // Log helper\n    function log(text) {\n      logDiv.textContent += text + \"\\n\";\n      logDiv.scrollTop = logDiv.scrollHeight;\n    }\n\n    // Add node at random position (within canvas bounds with margins)\n    function addNode() {\n      const margin = NODE_RADIUS*3;\n      const id = nodes.length;\n      // Random x,y but ensure no overlap with existing nodes (simple check)\n      let x,y;\n      let tries = 0;\n      do {\n        x = margin + Math.random() * (canvas.width - 2*margin);\n        y = margin + Math.random() * (canvas.height - 2*margin);\n        tries++;\n        if(tries > 100) break; // safety break\n      } while(nodes.some(n => dist(n.x,n.y,x,y) < NODE_RADIUS*3));\n      nodes.push({id, x, y});\n      drawGraph();\n      checkEnableRunKruskal();\n    }\n\n    // Clear entire graph and reset\n    function clearGraph() {\n      nodes = [];\n      edges = [];\n      edgeCreateStartNode = null;\n      edgeCreateStatus.textContent = \"None\";\n      kruskalRunning = false;\n      runKruskalBtn.disabled = true;\n      nextStepBtn.disabled = true;\n      logDiv.textContent = \"\";\n      updateEdgeList();\n      drawGraph();\n    }\n\n    // On canvas click – select node or create edge\n    canvas.addEventListener(\"click\", (e) => {\n      if(kruskalRunning) return; // disable editing mid-algorithm\n      const rect = canvas.getBoundingClientRect();\n      const mouseX = e.clientX - rect.left;\n      const mouseY = e.clientY - rect.top;\n      // Check if clicked on a node\n      let clickedNode = null;\n      for(const node of nodes) {\n        if(dist(mouseX, mouseY, node.x, node.y) < NODE_RADIUS) {\n          clickedNode = node;\n          break;\n        }\n      }\n      if(!clickedNode) return; // not on a node, do nothing\n\n      if(edgeCreateStartNode === null) {\n        edgeCreateStartNode = clickedNode;\n        edgeCreateStatus.textContent = `Selected node ${clickedNode.id}`;\n      } else if(edgeCreateStartNode.id === clickedNode.id) {\n        // Clicking the same node cancels selection\n        edgeCreateStartNode = null;\n        edgeCreateStatus.textContent = \"None\";\n      } else {\n        // Create edge between edgeCreateStartNode and clickedNode if doesn't exist yet\n        const n1 = edgeCreateStartNode.id;\n        const n2 = clickedNode.id;\n        // Check if edge already exists\n        if(edges.some(e => (e.n1 === n1 && e.n2 === n2) || (e.n1 === n2 && e.n2 === n1))) {\n          alert(\"Edge already exists between these nodes.\");\n          edgeCreateStartNode = null;\n          edgeCreateStatus.textContent = \"None\";\n          return;\n        }\n        // Ask for weight\n        let weight = prompt(`Enter weight for edge (${n1} – ${n2}), positive integer:`, \"1\");\n        if(weight === null) {\n          // Cancelled\n          edgeCreateStartNode = null;\n          edgeCreateStatus.textContent = \"None\";\n          return;\n        }\n        weight = parseInt(weight);\n        if(isNaN(weight) || weight <= 0) {\n          alert(\"Invalid weight. Please enter a positive integer.\");\n          edgeCreateStartNode = null;\n          edgeCreateStatus.textContent = \"None\";\n          return;\n        }\n        const id = edges.length;\n        edges.push({id, n1, n2, weight, inMST: false});\n        edgeCreateStartNode = null;\n        edgeCreateStatus.textContent = \"None\";\n        updateEdgeList();\n        drawGraph();\n        checkEnableRunKruskal();\n      }\n      drawGraph();\n    });\n\n    addNodeBtn.addEventListener(\"click\", () => {\n      if(kruskalRunning) return;\n      addNode();\n    });\n\n    clearGraphBtn.addEventListener(\"click\", () => {\n      if(kruskalRunning && !confirm(\"Clear graph will reset the algorithm. Continue?\")) return;\n      clearGraph();\n    });\n\n    function checkEnableRunKruskal(){\n      // Need at least 2 nodes and edges\n      runKruskalBtn.disabled = !(nodes.length >= 2 && edges.length >= 1);\n    }\n\n    // Kruskal's algorithm implementation with step-by-step support\n    runKruskalBtn.addEventListener(\"click\", () => {\n      if(kruskalRunning) return;\n      if(nodes.length < 2 || edges.length < 1) {\n        alert(\"Need at least 2 nodes and 1 edge to run Kruskal's algorithm.\");\n        return;\n      }\n      // Reset MST edges and flags\n      edges.forEach(e => e.inMST = false);\n      mstEdges = [];\n      kruskalStepIndex = 0;\n      kruskalEdgesSorted = [...edges].sort((a,b) => a.weight - b.weight);\n      logDiv.textContent = \"Kruskal's Algorithm started...\\n\";\n      kruskalRunning = true;\n      nextStepBtn.disabled = false;\n      runKruskalBtn.disabled = true;\n      updateEdgeList();\n      drawGraph();\n      log(`Edges sorted by weight: ${kruskalEdgesSorted.map(e => `(${e.n1}–${e.n2}:${e.weight})`).join(\", \")}`);\n    });\n\n    nextStepBtn.addEventListener(\"click\", () => {\n      if(!kruskalRunning) return;\n\n      if(kruskalStepIndex >= kruskalEdgesSorted.length) {\n        log(\"Algorithm finished.\");\n        alert(\"Kruskal's algorithm completed. MST formed.\");\n        kruskalRunning = false;\n        nextStepBtn.disabled = true;\n        runKruskalBtn.disabled = false;\n        updateEdgeList();\n        drawGraph();\n        return;\n      }\n\n      const dsu = new DSU(nodes.length);\n      // Union all MST edges picked so far\n      for(const e of mstEdges) {\n        dsu.union(e.n1, e.n2);\n      }\n\n      const currentEdge = kruskalEdgesSorted[kruskalStepIndex];\n      log(`Considering edge (${currentEdge.n1} – ${currentEdge.n2}) with weight ${currentEdge.weight}...`);\n\n      if(dsu.find(currentEdge.n1) !== dsu.find(currentEdge.n2)) {\n        // No cycle created, add edge to MST\n        mstEdges.push(currentEdge);\n        currentEdge.inMST = true;\n        log(\"No cycle formed. Edge added to MST.\");\n      } else {\n        log(\"Adding this edge would form a cycle. Skipped.\");\n      }\n      updateEdgeList();\n      drawGraph(currentEdge);\n      kruskalStepIndex += 1;\n\n      // Check if MST complete (n-1 edges)\n      if(mstEdges.length === nodes.length - 1){\n        log(\"MST is complete.\");\n        alert(\"Minimum Spanning Tree has been found!\");\n        kruskalRunning = false;\n        nextStepBtn.disabled = true;\n        runKruskalBtn.disabled = false;\n      }\n    });\n\n    // On initial load, add a couple of nodes for convenience\n    for(let i = 0; i < 4; i++){\n      addNode();\n    }\n\n    // Draw initial graph empty\n    drawGraph();\n    \n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}