{
  "id": "e03a4763-cd32-11f0-a949-f901cf5609c9",
  "timestamp": "2025-11-29T14:53:07.705Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Dijkstra's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n  }\n  header {\n    padding: 1rem;\n    background: #2c3e50;\n    color: white;\n    text-align: center;\n  }\n  #container {\n    flex: 1;\n    display: flex;\n    gap: 1rem;\n    padding: 1rem;\n    box-sizing: border-box;\n  }\n  #graph-container {\n    position: relative;\n    width: 70%;\n    background: #f9f9f9;\n    border: 1px solid #ccc;\n    border-radius: 8px;\n  }\n  svg {\n    width: 100%;\n    height: 600px;\n    background: #fff;\n    user-select:none;\n  }\n  #controls {\n    width: 30%;\n    max-width: 350px;\n    display: flex;\n    flex-direction: column;\n    gap: 1rem;\n  }\n  label {\n    font-weight: bold;\n  }\n  select, button {\n    padding: 0.5rem;\n    font-size: 1rem;\n  }\n  #log {\n    height: 250px;\n    overflow-y: auto;\n    background: #222;\n    color: #eee;\n    padding: 0.5rem;\n    font-family: monospace;\n    font-size: 14px;\n    border-radius: 4px;\n  }\n  #legend {\n    margin-top: auto;\n    font-size: 0.9rem;\n  }\n  .status-node {\n    stroke-width: 3px;\n  }\n  .node-circle {\n    cursor: pointer;\n    transition: all 0.3s ease;\n  }\n  .edge-path {\n    stroke-width: 2px;\n    fill: none;\n    transition: stroke 0.3s ease;\n  }\n  .edge-label {\n    user-select:none;\n    font-size: 12px;\n    fill: #333;\n  }\n  .node-label {\n    user-select:none;\n    font-size: 14px;\n    fill: #222;\n    pointer-events:none;\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Dijkstra's Algorithm Visualization</h1>\n  <p>Click nodes to select the Start and End nodes. Then click \"Run Dijkstra\" to find shortest path.</p>\n</header>\n<div id=\"container\">\n  <div id=\"graph-container\">\n    <svg id=\"graph-svg\" viewBox=\"0 0 800 600\" tabindex=\"0\" aria-label=\"Graph visualization\"></svg>\n  </div>\n  <div id=\"controls\" aria-label=\"Controls for Dijkstra's Algorithm\">\n    <div>\n      <label for=\"start-node\">Start Node:</label><br />\n      <select id=\"start-node\" aria-describedby=\"select-start-node-help\">\n        <option value=\"\">Select start node</option>\n      </select>\n    </div>\n    <div>\n      <label for=\"end-node\">End Node:</label><br />\n      <select id=\"end-node\" aria-describedby=\"select-end-node-help\">\n        <option value=\"\">Select end node</option>\n      </select>\n    </div>\n    <button id=\"run-btn\" disabled>Run Dijkstra</button>\n    <button id=\"reset-btn\">Reset</button>\n    <h3>Algorithm Log</h3>\n    <div id=\"log\" aria-live=\"polite\" aria-atomic=\"false\"></div>\n    <div id=\"legend\">\n      <strong>Legend:</strong><br />\n      <span style=\"color:#3498db\">&#9679;</span> Unvisited Node<br />\n      <span style=\"color:#27ae60\">&#9679;</span> Visited Node<br />\n      <span style=\"color:#e74c3c\">&#9679;</span> Current Node<br />\n      <span style=\"color:#f39c12\">&#9679;</span> Path Node<br />\n      <br />\n      <svg width=\"20\" height=\"6\" aria-hidden=\"true\" style=\"vertical-align: middle;\">\n        <line x1=\"2\" y1=\"3\" x2=\"18\" y2=\"3\" stroke=\"#999\" stroke-width=\"2\" />\n      </svg> Edge<br />\n      <svg width=\"20\" height=\"6\" aria-hidden=\"true\" style=\"vertical-align: middle;\">\n        <line x1=\"2\" y1=\"3\" x2=\"18\" y2=\"3\" stroke=\"#f39c12\" stroke-width=\"4\" />\n      </svg> Shortest Path Edge<br />\n    </div>\n  </div>\n</div>\n<script>\n(() => {\n  // Data structure representing the graph (undirected, weighted)\n  // We'll build a simple sample graph with nodes positioned for visualization\n  // Nodes have id, label, x, y\n  // Edges have from, to, weight\n\n  // Use some colors for states\n  const colors = {\n    unvisited: \"#3498db\",\n    visited: \"#27ae60\",\n    current: \"#e74c3c\",\n    path: \"#f39c12\",\n  };\n\n  // Graph nodes\n  const nodes = [\n    { id: \"A\", label: \"A\", x: 100, y: 100 },\n    { id: \"B\", label: \"B\", x: 300, y: 80 },\n    { id: \"C\", label: \"C\", x: 500, y: 100 },\n    { id: \"D\", label: \"D\", x: 150, y: 250 },\n    { id: \"E\", label: \"E\", x: 350, y: 250 },\n    { id: \"F\", label: \"F\", x: 550, y: 250 },\n    { id: \"G\", label: \"G\", x: 100, y: 400 },\n    { id: \"H\", label: \"H\", x: 300, y: 400 },\n    { id: \"I\", label: \"I\", x: 500, y: 400 },\n  ];\n\n  // Graph edges (undirected)\n  const edges = [\n    { from: \"A\", to: \"B\", weight: 4 },\n    { from: \"A\", to: \"D\", weight: 1 },\n    { from: \"B\", to: \"C\", weight: 3 },\n    { from: \"B\", to: \"E\", weight: 2 },\n    { from: \"C\", to: \"F\", weight: 4 },\n    { from: \"D\", to: \"E\", weight: 2 },\n    { from: \"D\", to: \"G\", weight: 7 },\n    { from: \"E\", to: \"F\", weight: 1 },\n    { from: \"E\", to: \"H\", weight: 3 },\n    { from: \"F\", to: \"I\", weight: 5 },\n    { from: \"G\", to: \"H\", weight: 2 },\n    { from: \"H\", to: \"I\", weight: 2 },\n  ];\n\n  // Build adjacency list from edges\n  // For bidirectional edges\n  const adjacency = {};\n  for (const node of nodes) {\n    adjacency[node.id] = [];\n  }\n  for (const edge of edges) {\n    adjacency[edge.from].push({ node: edge.to, weight: edge.weight });\n    adjacency[edge.to].push({ node: edge.from, weight: edge.weight });\n  }\n\n  // Select elements\n  const startSelect = document.getElementById(\"start-node\");\n  const endSelect = document.getElementById(\"end-node\");\n  const runBtn = document.getElementById(\"run-btn\");\n  const resetBtn = document.getElementById(\"reset-btn\");\n  const logEl = document.getElementById(\"log\");\n  const svg = document.getElementById(\"graph-svg\");\n\n  let state = {\n    startNodeId: null,\n    endNodeId: null,\n    running: false,\n    distances: {},        // nodeId => distance\n    previous: {},         // nodeId => previous nodeId on path\n    visited: new Set(),\n    unvisited: new Set(),\n    currentNodeId: null,\n    pathNodes: new Set(),\n  };\n\n  // Utility: Clear log\n  function clearLog() {\n    logEl.textContent = \"\";\n  }\n  // Utility: Log message with timestamp\n  function log(msg) {\n    const time = new Date().toLocaleTimeString();\n    logEl.textContent += `[${time}] ${msg}\\n`;\n    logEl.scrollTop = logEl.scrollHeight;\n  }\n\n  // Populate select dropdowns\n  function populateSelects() {\n    for (const node of nodes) {\n      const option1 = document.createElement(\"option\");\n      option1.value = node.id;\n      option1.textContent = node.label;\n      startSelect.appendChild(option1);\n\n      const option2 = document.createElement(\"option\");\n      option2.value = node.id;\n      option2.textContent = node.label;\n      endSelect.appendChild(option2);\n    }\n  }\n\n  // Draw the graph\n  // We'll create SVG elements for edges and nodes,\n  // and assign IDs and classes for styling and updates.\n\n  function createEdgeId(from, to) {\n    // consistent id, smaller id first\n    return \"edge-\" + [from, to].sort().join(\"-\");\n  }\n\n  // Draw edges\n  function drawEdges() {\n    for (const edge of edges) {\n      const fromNode = nodes.find((n) => n.id === edge.from);\n      const toNode = nodes.find((n) => n.id === edge.to);\n\n      // Draw line\n      const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n      line.setAttribute(\"x1\", fromNode.x);\n      line.setAttribute(\"y1\", fromNode.y);\n      line.setAttribute(\"x2\", toNode.x);\n      line.setAttribute(\"y2\", toNode.y);\n      line.setAttribute(\"stroke\", \"#999\");\n      line.setAttribute(\"stroke-width\", \"2\");\n      line.setAttribute(\"class\", \"edge-path\");\n      line.setAttribute(\"id\", createEdgeId(edge.from, edge.to));\n      svg.appendChild(line);\n\n      // Draw weight label - position midpoint with slight offset\n      const midX = (fromNode.x + toNode.x) / 2;\n      const midY = (fromNode.y + toNode.y) / 2;\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      text.setAttribute(\"x\", midX);\n      text.setAttribute(\"y\", midY - 5);\n      text.setAttribute(\"fill\", \"#333\");\n      text.setAttribute(\"class\", \"edge-label\");\n      text.textContent = edge.weight;\n      text.setAttribute(\"aria-label\", `Edge weight between ${edge.from} and ${edge.to} is ${edge.weight}`);\n      svg.appendChild(text);\n    }\n  }\n\n  // Draw nodes\n  function drawNodes() {\n    for (const node of nodes) {\n      const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      g.setAttribute(\"id\", \"node-\" + node.id);\n      g.setAttribute(\"tabindex\", \"0\");\n      g.setAttribute(\"role\", \"button\");\n      g.setAttribute(\"aria-label\", `Node ${node.label}. Click to select as start or end node.`);\n\n      // Circle\n      const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n      circle.setAttribute(\"cx\", node.x);\n      circle.setAttribute(\"cy\", node.y);\n      circle.setAttribute(\"r\", 18);\n      circle.setAttribute(\"fill\", colors.unvisited);\n      circle.setAttribute(\"stroke\", \"#333\");\n      circle.setAttribute(\"stroke-width\", \"2\");\n      circle.setAttribute(\"class\", \"node-circle\");\n\n      // Label text\n      const label = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      label.setAttribute(\"x\", node.x);\n      label.setAttribute(\"y\", node.y + 5);\n      label.setAttribute(\"text-anchor\", \"middle\");\n      label.setAttribute(\"class\", \"node-label\");\n      label.textContent = node.label;\n\n      g.appendChild(circle);\n      g.appendChild(label);\n\n      // Click handler to choose start or end node\n      g.addEventListener(\"click\", () => {\n        if (state.running) return;\n        if (!state.startNodeId) {\n          state.startNodeId = node.id;\n          startSelect.value = node.id;\n          log(`Start node selected: ${node.id}`);\n          updateNodeStyles();\n          runBtn.disabled = !(!state.endNodeId || !state.startNodeId ? true : false);\n        } else if (!state.endNodeId && node.id !== state.startNodeId) {\n          state.endNodeId = node.id;\n          endSelect.value = node.id;\n          log(`End node selected: ${node.id}`);\n          updateNodeStyles();\n          runBtn.disabled = !(state.startNodeId && state.endNodeId);\n        }\n      });\n\n      // Keyboard accessibility\n      g.addEventListener(\"keydown\", (e) => {\n        if (e.key === \"Enter\" || e.key === \" \") {\n          e.preventDefault();\n          g.click();\n        }\n      });\n\n      svg.appendChild(g);\n    }\n  }\n\n  // Update node and edge styles based on algorithm state\n  function updateNodeStyles() {\n    for (const node of nodes) {\n      const g = document.getElementById(\"node-\" + node.id);\n      if (!g) continue;\n      const circle = g.querySelector(\"circle\");\n      if (!circle) continue;\n\n      if (state.pathNodes.has(node.id)) {\n        circle.setAttribute(\"fill\", colors.path);\n        circle.setAttribute(\"stroke-width\", \"3\");\n      } else if (node.id === state.currentNodeId) {\n        circle.setAttribute(\"fill\", colors.current);\n        circle.setAttribute(\"stroke-width\", \"3\");\n      } else if (state.visited.has(node.id)) {\n        circle.setAttribute(\"fill\", colors.visited);\n        circle.setAttribute(\"stroke-width\", \"2\");\n      } else {\n        circle.setAttribute(\"fill\", colors.unvisited);\n        circle.setAttribute(\"stroke-width\", \"2\");\n      }\n    }\n\n    // Reset all edges to default style\n    for (const edge of edges) {\n      const line = document.getElementById(createEdgeId(edge.from, edge.to));\n      if (!line) continue;\n      if (\n        state.pathEdges &&\n        state.pathEdges.has(createEdgeId(edge.from, edge.to))\n      ) {\n        line.setAttribute(\"stroke\", colors.path);\n        line.setAttribute(\"stroke-width\", \"4\");\n      } else {\n        line.setAttribute(\"stroke\", \"#999\");\n        line.setAttribute(\"stroke-width\", \"2\");\n      }\n    }\n  }\n\n  // Highlight final path edges\n  function highlightPathEdges(path) {\n    const pathEdgesIds = new Set();\n    for (let i = 0; i < path.length - 1; i++) {\n      const edgeId = createEdgeId(path[i], path[i+1]);\n      pathEdgesIds.add(edgeId);\n    }\n    state.pathEdges = pathEdgesIds;\n  }\n\n  // Dijkstra's algorithm implementation with step-by-step visualization\n  // We'll run in async with a delay for animation\n\n  async function runDijkstra(startId, endId) {\n    state.running = true;\n    state.distances = {};\n    state.previous = {};\n    state.visited = new Set();\n    state.unvisited = new Set(nodes.map(n => n.id));\n    state.currentNodeId = null;\n    state.pathNodes = new Set();\n    state.pathEdges = new Set();\n\n    // Init distances\n    for (const node of nodes) {\n      state.distances[node.id] = Infinity;\n      state.previous[node.id] = null;\n    }\n    state.distances[startId] = 0;\n\n    log(`Running Dijkstra's algorithm from ${startId} to ${endId}`);\n\n    while (state.unvisited.size > 0) {\n      // Select the unvisited node with the smallest distance\n      let current = null;\n      let smallestDist = Infinity;\n      for (const nodeId of state.unvisited) {\n        if (state.distances[nodeId] < smallestDist) {\n          smallestDist = state.distances[nodeId];\n          current = nodeId;\n        }\n      }\n      if (current === null) {\n        log(\"No reachable remaining nodes. Ending.\");\n        break;\n      }\n\n      state.currentNodeId = current;\n      updateNodeStyles();\n      log(`Current node: ${current} (distance: ${state.distances[current]})`);\n      await delay(1200);\n\n      if (current === endId) {\n        log(`Reached end node ${endId}. Algorithm finished.`);\n        break;\n      }\n\n      // Check neighbors\n      const neighbors = adjacency[current];\n      for (const { node: neighbor, weight } of neighbors) {\n        if (!state.unvisited.has(neighbor)) continue;\n        const alt = state.distances[current] + weight;\n        if (alt < state.distances[neighbor]) {\n          state.distances[neighbor] = alt;\n          state.previous[neighbor] = current;\n          log(`Updated distance for node ${neighbor} to ${alt} via ${current}`);\n        }\n      }\n\n      state.visited.add(current);\n      state.unvisited.delete(current);\n      updateNodeStyles();\n      await delay(1000);\n    }\n\n    // Construct the shortest path by tracing predecessors\n    let path = [];\n    let iter = endId;\n    if (state.previous[iter] !== null || iter === startId) {\n      while (iter !== null) {\n        path.unshift(iter);\n        iter = state.previous[iter];\n      }\n    }\n\n    if (path.length === 0 || path[0] !== startId) {\n      log(\"No path found from start to end.\");\n      state.running = false;\n      return;\n    }\n\n    log(`Shortest path found: ${path.join(\" → \")}`);\n    for (const n of path) {\n      state.pathNodes.add(n);\n    }\n    highlightPathEdges(path);\n    updateNodeStyles();\n\n    state.running = false;\n  }\n\n  // Simple utility to wait ms milliseconds\n  function delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Setup event listeners for selects and buttons\n  function setupListeners() {\n    startSelect.addEventListener(\"change\", () => {\n      state.startNodeId = startSelect.value || null;\n      if (state.startNodeId === state.endNodeId) {\n        state.endNodeId = null;\n        endSelect.value = \"\";\n      }\n      updateNodeStyles();\n      runBtn.disabled = !(state.startNodeId && state.endNodeId);\n      if (state.startNodeId) log(`Start node selected: ${state.startNodeId}`);\n    });\n    endSelect.addEventListener(\"change\", () => {\n      state.endNodeId = endSelect.value || null;\n      if (state.endNodeId === state.startNodeId) {\n        state.startNodeId = null;\n        startSelect.value = \"\";\n      }\n      updateNodeStyles();\n      runBtn.disabled = !(state.startNodeId && state.endNodeId);\n      if (state.endNodeId) log(`End node selected: ${state.endNodeId}`);\n    });\n\n    runBtn.addEventListener(\"click\", async () => {\n      if (!state.startNodeId || !state.endNodeId || state.running) return;\n\n      clearLog();\n      runBtn.disabled = true;\n      startSelect.disabled = true;\n      endSelect.disabled = true;\n      resetBtn.disabled = true;\n\n      await runDijkstra(state.startNodeId, state.endNodeId);\n\n      runBtn.disabled = false;\n      startSelect.disabled = false;\n      endSelect.disabled = false;\n      resetBtn.disabled = false;\n    });\n\n    resetBtn.addEventListener(\"click\", () => {\n      if (state.running) return;\n      state.startNodeId = null;\n      state.endNodeId = null;\n      startSelect.value = \"\";\n      endSelect.value = \"\";\n      clearLog();\n      state.visited = new Set();\n      state.unvisited = new Set(nodes.map(n => n.id));\n      state.distances = {};\n      state.previous = {};\n      state.currentNodeId = null;\n      state.pathNodes = new Set();\n      state.pathEdges = new Set();\n      updateNodeStyles();\n      runBtn.disabled = true;\n    });\n  }\n\n  // Initialize everything\n  function init() {\n    clearLog();\n    populateSelects();\n    drawEdges();\n    drawNodes();\n    updateNodeStyles();\n    setupListeners();\n    runBtn.disabled = true;\n  }\n\n  window.addEventListener(\"load\", init);\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}