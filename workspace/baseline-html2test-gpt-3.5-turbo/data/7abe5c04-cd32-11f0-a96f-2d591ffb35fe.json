{
  "id": "7abe5c04-cd32-11f0-a96f-2d591ffb35fe",
  "timestamp": "2025-11-29T14:49:36.064Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Weighted Graph Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    background: #f0f0f0;\n  }\n  #graphContainer {\n    width: 90vw;\n    height: 90vh;\n    margin: 20px auto;\n    background: white;\n    border: 1px solid #ccc;\n    position: relative;\n  }\n  canvas {\n    width: 100%;\n    height: 100%;\n    display: block;\n  }\n  #info {\n    text-align: center;\n    margin: 10px auto;\n    width: 90vw;\n  }\n  #instructions {\n    font-size: 14px;\n    color: #555;\n    margin: 0 auto 10px;\n    width: 90vw;\n    text-align: center;\n  }\n</style>\n</head>\n<body>\n<h1 style=\"text-align:center;\">Weighted Graph Visualization</h1>\n<div id=\"instructions\">\n  <b>Instructions:</b> Drag nodes to reposition them. Hover over edges to see their weights.\n</div>\n<div id=\"graphContainer\">\n  <canvas id=\"graphCanvas\"></canvas>\n</div>\n<div id=\"info\"></div>\n\n<script>\n(() => {\n  const canvas = document.getElementById(\"graphCanvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const info = document.getElementById(\"info\");\n\n  let width, height;\n\n  function resize() {\n    width = canvas.clientWidth;\n    height = canvas.clientHeight;\n    // set actual drawing buffer size\n    canvas.width = width * devicePixelRatio;\n    canvas.height = height * devicePixelRatio;\n    ctx.setTransform(1,0,0,1,0,0);\n    ctx.scale(devicePixelRatio, devicePixelRatio);\n  }\n  window.addEventListener('resize', () => {\n    resize();\n    drawGraph();\n  });\n  resize();\n\n  // Weighted Graph Data Structure\n\n  // We'll represent a graph as:\n  // nodes: array of objects {id, x, y}\n  // edges: array of objects {source: nodeId, target: nodeId, weight}\n\n  // Sample graph definition\n  const nodes = [\n    { id: 0, x: 150, y: 150 },\n    { id: 1, x: 350, y: 120 },\n    { id: 2, x: 300, y: 300 },\n    { id: 3, x: 500, y: 200 },\n    { id: 4, x: 400, y: 400 },\n    { id: 5, x: 150, y: 350 },\n  ];\n\n  // edges connect nodes, with weights:\n  const edges = [\n    { source: 0, target: 1, weight: 5 },\n    { source: 0, target: 5, weight: 10 },\n    { source: 1, target: 2, weight: 3 },\n    { source: 1, target: 3, weight: 8 },\n    { source: 2, target: 4, weight: 7 },\n    { source: 5, target: 4, weight: 2 },\n    { source: 3, target: 4, weight: 6 },\n  ];\n\n  // helper: find node by id\n  function getNode(id) {\n    return nodes.find(n => n.id === id);\n  }\n\n  // Drawing params\n  const nodeRadius = 15;\n  const font = \"14px Arial\";\n\n  function distance(x1, y1, x2, y2) {\n    return Math.sqrt((x1-x2)**2+(y1-y2)**2);\n  }\n\n  // For edge hover detection, we determine the minimum distance from mouse to edge line segment,\n  // if less than threshold, consider hovered.\n  function pointToSegmentDistance(px, py, x1, y1, x2, y2) {\n    const A = px - x1;\n    const B = py - y1;\n    const C = x2 - x1;\n    const D = y2 - y1;\n\n    const dot = A * C + B * D;\n    const len_sq = C*C + D*D;\n    let param = -1;\n    if(len_sq != 0) //in case of 0 length line\n        param = dot / len_sq;\n\n    let xx, yy;\n\n    if(param < 0) {\n      xx = x1;\n      yy = y1;\n    }\n    else if(param > 1) {\n      xx = x2;\n      yy = y2;\n    }\n    else {\n      xx = x1 + param * C;\n      yy = y1 + param * D;\n    }\n\n    const dx = px - xx;\n    const dy = py - yy;\n    return Math.sqrt(dx*dx + dy*dy);\n  }\n\n  // Dragging\n  let draggingNode = null;\n  let dragOffsetX = 0;\n  let dragOffsetY = 0;\n\n  // Track hovered edge\n  let hoveredEdge = null;\n\n  // Draw\n\n  function drawGraph() {\n    ctx.clearRect(0, 0, width, height);\n\n    // Draw edges\n    ctx.lineCap = 'round';\n    edges.forEach(edge => {\n      const n1 = getNode(edge.source);\n      const n2 = getNode(edge.target);\n\n      // highlight if hovered\n      if(hoveredEdge === edge){\n        ctx.strokeStyle = '#f44336';\n        ctx.lineWidth = 4;\n      } else {\n        ctx.strokeStyle = '#555';\n        ctx.lineWidth = 2;\n      }\n\n      // Draw edge line\n      ctx.beginPath();\n      ctx.moveTo(n1.x, n1.y);\n      ctx.lineTo(n2.x, n2.y);\n      ctx.stroke();\n\n      // Draw weight text in the middle of the edge\n      const mx = (n1.x + n2.x) / 2;\n      const my = (n1.y + n2.y) / 2;\n      ctx.fillStyle = hoveredEdge === edge ? '#f44336' : 'black';\n      ctx.font = font;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(edge.weight, mx, my - 10);\n    });\n\n    // Draw nodes\n    nodes.forEach(node => {\n      // Fill circle\n      ctx.beginPath();\n      ctx.fillStyle = '#2196f3';\n      ctx.strokeStyle = 'black';\n      ctx.lineWidth = 2;\n      ctx.arc(node.x, node.y, nodeRadius, 0, 2*Math.PI);\n      ctx.fill();\n      ctx.stroke();\n\n      // Draw node id centered\n      ctx.fillStyle = 'white';\n      ctx.font = font;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(node.id, node.x, node.y);\n    });\n  }\n\n  // Mouse interaction\n\n  canvas.addEventListener('mousedown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n\n    // Check if clicking on a node (to drag)\n    for(let node of nodes) {\n      if(distance(mx, my, node.x, node.y) < nodeRadius) {\n        draggingNode = node;\n        dragOffsetX = mx - node.x;\n        dragOffsetY = my - node.y;\n        break;\n      }\n    }\n  });\n\n  canvas.addEventListener('mouseup', (e) => {\n    draggingNode = null;\n  });\n\n  canvas.addEventListener('mouseleave', (e) => {\n    draggingNode = null;\n    if(hoveredEdge){\n      hoveredEdge = null;\n      info.textContent = '';\n      drawGraph();\n    }\n  });\n\n  canvas.addEventListener('mousemove', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n\n    // Handle dragging\n    if(draggingNode) {\n      draggingNode.x = Math.min(width - nodeRadius, Math.max(nodeRadius, mx - dragOffsetX));\n      draggingNode.y = Math.min(height - nodeRadius, Math.max(nodeRadius, my - dragOffsetY));\n      drawGraph();\n      return;\n    }\n\n    // Check if hovering any edge for weight display\n    let foundHover = false;\n    for(let edge of edges) {\n      const n1 = getNode(edge.source);\n      const n2 = getNode(edge.target);\n      const dist = pointToSegmentDistance(mx, my, n1.x, n1.y, n2.x, n2.y);\n      if(dist < 10){\n        if(hoveredEdge !== edge){\n          hoveredEdge = edge;\n          info.textContent = `Edge weight (Node ${edge.source} â†” Node ${edge.target}): ${edge.weight}`;\n          drawGraph();\n        }\n        foundHover = true;\n        break;\n      }\n    }\n    if(!foundHover && hoveredEdge){\n      hoveredEdge = null;\n      info.textContent = '';\n      drawGraph();\n    }\n  });\n\n  drawGraph();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": false,
  "hasTest": true
}