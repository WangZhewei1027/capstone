{
  "id": "20d2d6cc-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:13.479Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Huffman Coding",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Huffman Coding Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 2rem;\n    max-width: 800px;\n  }\n  h1 {\n    text-align: center;\n  }\n  label {\n    font-weight: bold;\n    display: block;\n    margin-top: 1rem;\n  }\n  textarea {\n    width: 100%;\n    height: 100px;\n    font-family: monospace;\n    font-size: 14px;\n  }\n  pre {\n    background: #fafafa;\n    border: 1px solid #ddd;\n    padding: 1rem;\n    white-space: pre-wrap;\n  }\n  button {\n    margin-top: 0.5rem;\n    font-size: 1rem;\n    padding: 0.5rem 1rem;\n  }\n  .flexrow {\n    display: flex;\n    gap: 1rem;\n  }\n  .flexcol {\n    flex: 1;\n  }\n  table {\n    border-collapse: collapse;\n    width: 100%;\n    margin-top: 1rem;\n  }\n  th, td {\n    border: 1px solid #ccc;\n    padding: 0.25rem 0.5rem;\n    text-align: center;\n  }\n  .code-bit {\n    font-weight: bold;\n    color: #007bff;\n    user-select: all;\n  }\n</style>\n</head>\n<body>\n\n<h1>Huffman Coding Demo</h1>\n\n<label for=\"input-text\">Enter text to encode:</label>\n<textarea id=\"input-text\" placeholder=\"Enter text here...\">this is an example for huffman encoding</textarea>\n<button id=\"build-btn\">Build Huffman Tree & Encode</button>\n\n<div id=\"results\" style=\"display:none; margin-top:2rem;\">\n\n  <h2>Step 1: Frequency Table</h2>\n  <table id=\"freq-table\" aria-label=\"Character frequency table\">\n    <thead>\n      <tr><th>Character</th><th>Frequency</th></tr>\n    </thead>\n    <tbody></tbody>\n  </table>\n\n  <h2>Step 2: Huffman Codes</h2>\n  <table id=\"code-table\" aria-label=\"Character Huffman codes table\">\n    <thead>\n      <tr><th>Character</th><th>Code</th></tr>\n    </thead>\n    <tbody></tbody>\n  </table>\n\n  <h2>Step 3: Encoded Output</h2>\n  <pre id=\"encoded-output\" aria-label=\"Encoded binary string\"></pre>\n\n  <h2>Step 4: Decode Input</h2>\n  <button id=\"decode-btn\">Decode the encoded binary string</button>\n  <pre id=\"decoded-output\" aria-live=\"polite\" aria-atomic=\"true\" aria-label=\"Decoded text output\" style=\"margin-top:0.5rem; font-weight:bold;\"></pre>\n\n</div>\n\n<script>\n  // Huffman coding implementation\n\n  // Node class for Huffman tree\n  class Node {\n    constructor(char, freq, left=null, right=null) {\n      this.char = char;\n      this.freq = freq;\n      this.left = left;\n      this.right = right;\n    }\n  }\n\n  // Priority queue implemented as min heap for nodes\n  class PriorityQueue {\n    constructor() {\n      this.data = [];\n    }\n    push(node) {\n      this.data.push(node);\n      this._bubbleUp(this.data.length - 1);\n    }\n    pop() {\n      if (this.data.length === 0) return null;\n      const top = this.data[0];\n      const end = this.data.pop();\n      if(this.data.length > 0){\n        this.data[0] = end;\n        this._bubbleDown(0);\n      }\n      return top;\n    }\n    size() {\n      return this.data.length;\n    }\n    _bubbleUp(idx) {\n      while(idx > 0){\n        let parent = Math.floor((idx-1)/2);\n        if(this.data[parent].freq <= this.data[idx].freq) break;\n        [this.data[parent], this.data[idx]] = [this.data[idx], this.data[parent]];\n        idx = parent;\n      }\n    }\n    _bubbleDown(idx) {\n      let leftChild, rightChild, smallest;\n      while(true){\n        smallest = idx;\n        leftChild = 2*idx + 1;\n        rightChild = 2*idx + 2;\n        if(leftChild < this.data.length && this.data[leftChild].freq < this.data[smallest].freq){\n          smallest = leftChild;\n        }\n        if(rightChild < this.data.length && this.data[rightChild].freq < this.data[smallest].freq){\n          smallest = rightChild;\n        }\n        if(smallest === idx) break;\n        [this.data[smallest], this.data[idx]] = [this.data[idx], this.data[smallest]];\n        idx = smallest;\n      }\n    }\n  }\n\n  // Compute frequency of each character in the text\n  function computeFrequency(text) {\n    const freq = new Map();\n    for(const ch of text){\n      freq.set(ch, (freq.get(ch) || 0) + 1);\n    }\n    return freq;\n  }\n\n  // Build Huffman tree from frequency map\n  function buildHuffmanTree(freqMap) {\n    const pq = new PriorityQueue();\n    for(const [ch, freq] of freqMap.entries()){\n      pq.push(new Node(ch, freq));\n    }\n    // Edge case: If only one character, make a tree with two nodes\n    if(pq.size() === 1){\n      const onlyNode = pq.pop();\n      // Add a dummy node with 0 freq as sibling\n      pq.push(new Node(null, 0));\n      pq.push(onlyNode);\n    }\n    while(pq.size() > 1){\n      const left = pq.pop();\n      const right = pq.pop();\n      const merged = new Node(null, left.freq + right.freq, left, right);\n      pq.push(merged);\n    }\n    return pq.pop();\n  }\n\n  // Generate Huffman codes by traversing the tree\n  function generateCodes(node, prefix = '', codeMap = new Map()){\n    if(!node) return;\n    if(node.char !== null){\n      codeMap.set(node.char, prefix || '0'); // handle single node tree by assigning '0'\n    }\n    generateCodes(node.left, prefix + '0', codeMap);\n    generateCodes(node.right, prefix + '1', codeMap);\n    return codeMap;\n  }\n\n  // Encode text using code map\n  function encodeText(text, codeMap){\n    let encoded = '';\n    for(const ch of text){\n      encoded += codeMap.get(ch);\n    }\n    return encoded;\n  }\n\n  // Decode binary string using Huffman tree\n  function decodeBinary(encodedStr, huffmanTree){\n    let node = huffmanTree;\n    let decoded = '';\n    for(let bit of encodedStr){\n      if(bit === '0'){\n        node = node.left;\n      } else if(bit === '1'){\n        node = node.right;\n      } else {\n        // ignore invalid bits\n        continue;\n      }\n      if(node.char !== null){\n        decoded += node.char;\n        node = huffmanTree;\n      }\n    }\n    return decoded;\n  }\n\n  // UI Elements\n  const inputText = document.getElementById('input-text');\n  const buildBtn = document.getElementById('build-btn');\n  const freqTableBody = document.querySelector('#freq-table tbody');\n  const codeTableBody = document.querySelector('#code-table tbody');\n  const encodedOutput = document.getElementById('encoded-output');\n  const resultsDiv = document.getElementById('results');\n  const decodeBtn = document.getElementById('decode-btn');\n  const decodedOutput = document.getElementById('decoded-output');\n\n  let currentHuffmanTree = null;\n  let currentEncodedStr = '';\n  let currentCodeMap = null;\n\n  function clearTables(){\n    freqTableBody.innerHTML = '';\n    codeTableBody.innerHTML = '';\n    encodedOutput.textContent = '';\n    decodedOutput.textContent = '';\n    resultsDiv.style.display = 'none';\n  }\n\n  buildBtn.addEventListener('click', () => {\n    const text = inputText.value;\n    if(!text || text.length === 0){\n      alert(\"Please enter some text to encode.\");\n      return;\n    }\n\n    // Clear previous results\n    clearTables();\n\n    // Step 1: Frequency Table\n    const freqMap = computeFrequency(text);\n    // Sort frequency by descending freq, then char\n    const freqArray = Array.from(freqMap.entries())\n      .sort((a,b) => b[1] - a[1] || a[0].localeCompare(b[0]));\n    for(const [ch, freq] of freqArray){\n      const tr = document.createElement('tr');\n      const charTd = document.createElement('td');\n      charTd.textContent = ch === ' ' ? 'space' : ch === '\\n' ? '\\\\n' : ch === '\\t' ? '\\\\t' : ch;\n      const freqTd = document.createElement('td');\n      freqTd.textContent = freq;\n      tr.appendChild(charTd);\n      tr.appendChild(freqTd);\n      freqTableBody.appendChild(tr);\n    }\n\n    // Step 2: Build Huffman Tree\n    currentHuffmanTree = buildHuffmanTree(freqMap);\n\n    // Step 3: Generate Codes\n    currentCodeMap = generateCodes(currentHuffmanTree);\n\n    // Display codes sorted by character ascending\n    const codeArray = Array.from(currentCodeMap.entries())\n      .sort((a,b) => a[0].localeCompare(b[0]));\n    for(const [ch, code] of codeArray){\n      const tr = document.createElement('tr');\n      const charTd = document.createElement('td');\n      charTd.textContent = ch === ' ' ? 'space' : ch === '\\n' ? '\\\\n' : ch === '\\t' ? '\\\\t' : ch;\n      const codeTd = document.createElement('td');\n      codeTd.innerHTML = code.split('').map(bit => `<span class=\"code-bit\">${bit}</span>`).join('');\n      tr.appendChild(charTd);\n      tr.appendChild(codeTd);\n      codeTableBody.appendChild(tr);\n    }\n\n    // Step 4: Encode text\n    currentEncodedStr = encodeText(text, currentCodeMap);\n    // Format encoded string with spaces every 8 bits for readability\n    let formattedEncoded = currentEncodedStr.match(/.{1,8}/g)?.join(' ') || '';\n    encodedOutput.textContent = formattedEncoded;\n\n    resultsDiv.style.display = 'block';\n    decodedOutput.textContent = ''; // clear decode output\n  });\n\n  decodeBtn.addEventListener('click', () => {\n    if(!currentEncodedStr || !currentHuffmanTree){\n      alert(\"Please encode text first.\");\n      return;\n    }\n    const decoded = decodeBinary(currentEncodedStr, currentHuffmanTree);\n    decodedOutput.textContent = decoded;\n  });\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Huffman Coding"
    }
  ],
  "topic": "Huffman Coding",
  "hasFSM": false,
  "hasTest": true
}