{
  "id": "e039f942-cd32-11f0-a949-f901cf5609c9",
  "timestamp": "2025-11-29T14:52:37.964Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Binary Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Binary Tree Visualization & Traversal</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0; background: #f0f0f0;\n  }\n  header {\n    background: #333;\n    color: white;\n    padding: 1em;\n    text-align: center;\n  }\n  #container {\n    display: flex;\n    flex-direction: row;\n    height: calc(100vh - 70px);\n  }\n  #treeCanvas {\n    background: white;\n    flex-grow: 1;\n    border-right: 1px solid #ccc;\n  }\n  #controls {\n    width: 320px;\n    background: white;\n    padding: 1em;\n    box-sizing: border-box;\n    overflow-y: auto;\n  }\n  h2 {\n    margin-top: 0;\n  }\n  label, button {\n    display: block;\n    margin-top: 1em;\n  }\n  input[type=\"number\"] {\n    width: 100%;\n    padding: 0.4em;\n    font-size: 1em;\n    box-sizing: border-box;\n  }\n  button {\n    padding: 0.7em;\n    font-size: 1em;\n    cursor: pointer;\n  }\n  #traversalOutput {\n    background: #eef;\n    padding: 0.8em;\n    margin-top: 0.5em;\n    min-height: 2em;\n    border-radius: 4px;\n    font-weight: bold;\n  }\n  #message {\n    color: red;\n    margin-top: 0.5em;\n    min-height: 1em;\n  }\n  #legend {\n    margin-top: 2em;\n    font-size: 0.9em;\n    color: #555;\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Binary Tree Visualizer</h1>\n</header>\n<div id=\"container\">\n  <canvas id=\"treeCanvas\" width=\"800\" height=\"600\" aria-label=\"Binary tree visualization\" role=\"img\"></canvas>\n  <div id=\"controls\" aria-label=\"Controls to create and traverse binary tree\">\n    <h2>Manage Tree</h2>\n    <label for=\"nodeValueInput\">Node Value (integer):</label>\n    <input type=\"number\" id=\"nodeValueInput\" aria-describedby=\"nodeValueDesc\" />\n    <div id=\"nodeValueDesc\" style=\"font-size:0.8em;color:#555;\">\n      Enter the integer value for the node to insert or delete.\n    </div>\n    <button id=\"insertBtn\">Insert Node</button>\n    <button id=\"deleteBtn\">Delete Node</button>\n\n    <h2>Traversal</h2>\n    <button data-traversal=\"inorder\" class=\"traversalBtn\">In-order Traversal</button>\n    <button data-traversal=\"preorder\" class=\"traversalBtn\">Pre-order Traversal</button>\n    <button data-traversal=\"postorder\" class=\"traversalBtn\">Post-order Traversal</button>\n    <button data-traversal=\"levelorder\" class=\"traversalBtn\">Level-order Traversal</button>\n\n    <div id=\"traversalOutput\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n    <div id=\"message\" role=\"alert\"></div>\n\n    <div id=\"legend\">\n      <strong>Legend:</strong><br/>\n      • Blue circles: Nodes<br/>\n      • Lines: Links between parent and children<br/>\n      • Traversal output: Node values in visiting order<br/>\n      <br/>\n      Nodes are inserted following Binary Search Tree rules.\n    </div>\n  </div>\n</div>\n\n<script>\n  // Binary Tree Node class\n  class TreeNode {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n    }\n  }\n\n  // Binary Search Tree class\n  class BinaryTree {\n    constructor() {\n      this.root = null;\n    }\n\n    insert(value) {\n      this.root = this._insertRec(this.root, value);\n    }\n\n    _insertRec(node, value) {\n      if (node === null) return new TreeNode(value);\n      if (value === node.value) {\n        // ignore duplicates\n        return node;\n      }\n      if (value < node.value) {\n        node.left = this._insertRec(node.left, value);\n      } else {\n        node.right = this._insertRec(node.right, value);\n      }\n      return node;\n    }\n\n    delete(value) {\n      this.root = this._deleteRec(this.root, value);\n    }\n\n    _deleteRec(node, value) {\n      if (!node) return null;\n      if (value < node.value) {\n        node.left = this._deleteRec(node.left, value);\n      } else if (value > node.value) {\n        node.right = this._deleteRec(node.right, value);\n      } else {\n        // found node to delete\n        if (!node.left) return node.right;\n        if (!node.right) return node.left;\n        // node with two children - get inorder successor (smallest in right subtree)\n        let minLargerNode = this._minValueNode(node.right);\n        node.value = minLargerNode.value;\n        node.right = this._deleteRec(node.right, minLargerNode.value);\n      }\n      return node;\n    }\n\n    _minValueNode(node) {\n      let current = node;\n      while (current.left) {\n        current = current.left;\n      }\n      return current;\n    }\n\n    inorder() {\n      const res = [];\n      this._inorderRec(this.root, res);\n      return res;\n    }\n    _inorderRec(node, res) {\n      if (!node) return;\n      this._inorderRec(node.left, res);\n      res.push(node.value);\n      this._inorderRec(node.right, res);\n    }\n\n    preorder() {\n      const res = [];\n      this._preorderRec(this.root, res);\n      return res;\n    }\n    _preorderRec(node, res) {\n      if (!node) return;\n      res.push(node.value);\n      this._preorderRec(node.left, res);\n      this._preorderRec(node.right, res);\n    }\n\n    postorder() {\n      const res = [];\n      this._postorderRec(this.root, res);\n      return res;\n    }\n    _postorderRec(node, res) {\n      if (!node) return;\n      this._postorderRec(node.left, res);\n      this._postorderRec(node.right, res);\n      res.push(node.value);\n    }\n\n    levelorder() {\n      const res = [];\n      const queue = [];\n      if (this.root) queue.push(this.root);\n      while (queue.length > 0) {\n        let node = queue.shift();\n        res.push(node.value);\n        if (node.left) queue.push(node.left);\n        if (node.right) queue.push(node.right);\n      }\n      return res;\n    }\n  }\n\n  // Canvas drawing and tree layout\n\n  class TreeVisualizer {\n    constructor(canvas, tree) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext('2d');\n      this.tree = tree;\n      this.nodeRadius = 20;\n      this.levelHeight = 80;\n      this.canvasWidth = canvas.width;\n      this.canvasHeight = canvas.height;\n      this.positions = new Map();\n    }\n\n    draw() {\n      this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n      if (!this.tree.root) {\n        this.ctx.font = '18px Arial';\n        this.ctx.fillStyle = \"#555\";\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText('Tree is empty.', this.canvasWidth/2, this.canvasHeight/2);\n        return;\n      }\n      this.positions.clear();\n      // Calculate horizontal positions using inorder traversal index\n      let index = 0;\n      const positionsInorder = new Map();\n\n      function assignXPos(node) {\n        if (!node) return;\n        assignXPos(node.left);\n        positionsInorder.set(node, index++);\n        assignXPos(node.right);\n      }\n      assignXPos(this.tree.root);\n\n      // Get tree height\n      function height(node) {\n        if (!node) return 0;\n        return 1 + Math.max(height(node.left), height(node.right));\n      }\n      const treeHeight = height(this.tree.root);\n\n      // Calculate horizontal spacing\n      const totalNodes = index;\n      const horizontalSpacing = this.canvasWidth / (totalNodes + 1);\n\n      // Compute all node positions\n      function assignPositions(node, depth) {\n        if (!node) return;\n        const x = horizontalSpacing * (positionsInorder.get(node) + 1);\n        const y = this.levelHeight * depth + this.nodeRadius + 10;\n        this.positions.set(node, {x, y});\n        assignPositions.call(this, node.left, depth + 1);\n        assignPositions.call(this, node.right, depth + 1);\n      }\n      assignPositions.call(this, this.tree.root, 0);\n\n      // Draw edges\n      this.ctx.strokeStyle = '#444';\n      this.ctx.lineWidth = 2;\n      this.positions.forEach((pos, node) => {\n        if (node.left) {\n          this._drawLine(pos, this.positions.get(node.left));\n        }\n        if (node.right) {\n          this._drawLine(pos, this.positions.get(node.right));\n        }\n      });\n\n      // Draw nodes\n      this.positions.forEach((pos, node) => {\n        this._drawNode(pos, node.value);\n      });\n    }\n\n    _drawLine(from, to) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(from.x, from.y);\n      this.ctx.lineTo(to.x, to.y);\n      this.ctx.stroke();\n    }\n\n    _drawNode(pos, value) {\n      const ctx = this.ctx;\n      ctx.beginPath();\n      ctx.fillStyle = '#4287f5';\n      ctx.strokeStyle = '#1a3caa';\n      ctx.lineWidth = 2;\n      ctx.shadowColor = 'rgba(0,0,0,0.3)';\n      ctx.shadowBlur = 4;\n      ctx.shadowOffsetX = 2;\n      ctx.shadowOffsetY = 2;\n      ctx.arc(pos.x, pos.y, this.nodeRadius, 0, 2*Math.PI);\n      ctx.fill();\n      ctx.shadowColor = 'transparent';\n      ctx.stroke();\n\n      ctx.fillStyle = 'white';\n      ctx.font = 'bold 16px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(value, pos.x, pos.y);\n    }\n  }\n\n\n  // DOM elements\n  const insertBtn = document.getElementById('insertBtn');\n  const deleteBtn = document.getElementById('deleteBtn');\n  const nodeValueInput = document.getElementById('nodeValueInput');\n  const traversalButtons = document.querySelectorAll('.traversalBtn');\n  const traversalOutput = document.getElementById('traversalOutput');\n  const message = document.getElementById('message');\n  const canvas = document.getElementById('treeCanvas');\n\n  // Instantiate tree and visualizer\n  const tree = new BinaryTree();\n  const visualizer = new TreeVisualizer(canvas, tree);\n\n  // Initial draw\n  visualizer.draw();\n\n  function clearMessage() {\n    message.textContent = '';\n  }\n\n  function showMessage(text) {\n    message.textContent = text;\n  }\n\n  function getInputValue() {\n    const val = nodeValueInput.value.trim();\n    if (val === '') return null;\n    const num = Number(val);\n    if (Number.isNaN(num) || !Number.isInteger(num)) return null;\n    return num;\n  }\n\n  insertBtn.addEventListener('click', () => {\n    clearMessage();\n    const val = getInputValue();\n    if (val === null) {\n      showMessage('Please enter a valid integer to insert.');\n      return;\n    }\n    tree.insert(val);\n    nodeValueInput.value = '';\n    visualizer.draw();\n    traversalOutput.textContent = '';\n  });\n\n  deleteBtn.addEventListener('click', () => {\n    clearMessage();\n    const val = getInputValue();\n    if (val === null) {\n      showMessage('Please enter a valid integer to delete.');\n      return;\n    }\n    // Check if value exists in tree before deletion\n    const allValues = tree.inorder();\n    if (!allValues.includes(val)) {\n      showMessage('Value not found in tree.');\n      return;\n    }\n    tree.delete(val);\n    nodeValueInput.value = '';\n    visualizer.draw();\n    traversalOutput.textContent = '';\n  });\n\n  traversalButtons.forEach(button => {\n    button.addEventListener('click', () => {\n      clearMessage();\n      if (!tree.root) {\n        showMessage('Tree is empty. Insert nodes first.');\n        traversalOutput.textContent = '';\n        return;\n      }\n      const traversalType = button.getAttribute('data-traversal');\n      let result = [];\n      let label = '';\n      switch (traversalType) {\n        case 'inorder':\n          result = tree.inorder();\n          label = 'In-order Traversal';\n          break;\n        case 'preorder':\n          result = tree.preorder();\n          label = 'Pre-order Traversal';\n          break;\n        case 'postorder':\n          result = tree.postorder();\n          label = 'Post-order Traversal';\n          break;\n        case 'levelorder':\n          result = tree.levelorder();\n          label = 'Level-order Traversal';\n          break;\n      }\n      traversalOutput.textContent = `${label}: ${result.join(', ')}`;\n    });\n  });\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Tree"
    }
  ],
  "topic": "Binary Tree",
  "hasFSM": false,
  "hasTest": true
}