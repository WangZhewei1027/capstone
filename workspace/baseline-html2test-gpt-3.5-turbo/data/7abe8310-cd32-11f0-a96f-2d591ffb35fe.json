{
  "id": "7abe8310-cd32-11f0-a96f-2d591ffb35fe",
  "timestamp": "2025-11-29T14:49:36.919Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency Matrix",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Adjacency Matrix Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f9f9f9;\n  }\n  h1 {\n    text-align: center;\n  }\n  #graphInput {\n    margin-bottom: 20px;\n  }\n  label {\n    display: block;\n    margin: 5px 0 2px;\n  }\n  textarea {\n    width: 100%;\n    height: 120px;\n    font-family: monospace;\n    font-size: 14px;\n  }\n  button {\n    margin-top: 10px;\n    padding: 8px 15px;\n    font-size: 16px;\n  }\n  #output {\n    margin-top: 30px;\n  }\n  table {\n    border-collapse: collapse;\n    margin: 10px 0;\n  }\n  th, td {\n    border: 1px solid #666;\n    padding: 6px 10px;\n    text-align: center;\n    min-width: 24px;\n  }\n  th {\n    background-color: #ddd;\n  }\n  caption {\n    font-weight: bold;\n    margin-bottom: 8px;\n  }\n  #nodesInput {\n    width: 50px;\n    font-size: 14px;\n    padding: 4px;\n  }\n  #error {\n    color: red;\n    margin-top: 10px;\n    font-weight: bold;\n  }\n  #graphVisualization {\n    margin-top: 25px;\n    text-align: center;\n  }\n  svg {\n    border: 1px solid #ccc;\n    background: white;\n  }\n</style>\n</head>\n<body>\n  <h1>Adjacency Matrix of a Graph</h1>\n  <div id=\"graphInput\">\n    <label for=\"nodeCount\">Number of Nodes (max 15):</label>\n    <input type=\"number\" id=\"nodeCount\" min=\"1\" max=\"15\" value=\"5\" />\n    \n    <label for=\"edgeList\">Enter edges (one per line), format: <code>source destination</code><br />\n    Nodes are zero-indexed (0 to n-1). For example:<br />\n    0 1<br />\n    0 4<br />\n    1 2<br />\n    1 3<br />\n    1 4</label>\n    <textarea id=\"edgeList\">0 1\n0 4\n1 2\n1 3\n1 4\n2 3\n3 4</textarea>\n    \n    <br />\n    <button id=\"generateBtn\">Generate Adjacency Matrix</button>\n    <div id=\"error\"></div>\n  </div>\n\n  <div id=\"output\"></div>\n\n  <script>\n    /**\n     * This demo allows the user to input:\n     *   - number of nodes\n     *   - list of edges (undirected graph by default)\n     * It generates and displays the adjacency matrix for the graph.\n     * \n     * Features:\n     * - Validate inputs (nodes and edges)\n     * - Display matrix with row/column labels\n     * - Visualize graph as circles and lines (force-directed simple layout)\n     */\n\n    const nodeCountInput = document.getElementById('nodeCount');\n    const edgeListInput = document.getElementById('edgeList');\n    const generateBtn = document.getElementById('generateBtn');\n    const outputDiv = document.getElementById('output');\n    const errorDiv = document.getElementById('error');\n\n    // Utility: create adjacency matrix n x n filled with 0\n    function createMatrix(n) {\n      const matrix = [];\n      for(let i=0; i<n; i++) {\n        matrix[i] = Array(n).fill(0);\n      }\n      return matrix;\n    }\n\n    // Parse edges input text, returns array of [source, target]\n    // Also validates edges are within node count\n    function parseEdges(text, n) {\n      const lines = text.trim().split('\\n');\n      const edges = [];\n      for(let i=0; i<lines.length; i++) {\n        const line = lines[i].trim();\n        if(line === '') continue;\n        const parts = line.split(/[\\s,]+/);\n        if(parts.length !== 2) throw new Error(`Invalid edge format on line ${i+1}: \"${line}\"`);\n        const s = Number(parts[0]);\n        const t = Number(parts[1]);\n        if(!Number.isInteger(s) || !Number.isInteger(t)) {\n          throw new Error(`Edge nodes must be integers on line ${i+1}: \"${line}\"`);\n        }\n        if(s < 0 || s >= n || t < 0 || t >= n) {\n          throw new Error(`Edge nodes outside valid range on line ${i+1}: \"${line}\"`);\n        }\n        edges.push([s, t]);\n      }\n      return edges;\n    }\n\n    // Build adjacency matrix from edge list (undirected)\n    function buildAdjacencyMatrix(n, edges) {\n      const matrix = createMatrix(n);\n      edges.forEach(([s,t]) => {\n        matrix[s][t] = 1;\n        matrix[t][s] = 1;\n      });\n      return matrix;\n    }\n\n    // Render adjacency matrix as HTML table with row/column labels\n    function renderMatrix(matrix) {\n      const n = matrix.length;\n      const table = document.createElement('table');\n      table.setAttribute('aria-label', 'Adjacency matrix');\n      const caption = document.createElement('caption');\n      caption.textContent = 'Adjacency Matrix';\n      table.appendChild(caption);\n\n      // Header row\n      const headerRow = document.createElement('tr');\n      headerRow.appendChild(document.createElement('th')); // empty top-left cell\n      for(let col=0; col<n; col++) {\n        const th = document.createElement('th');\n        th.textContent = col;\n        headerRow.appendChild(th);\n      }\n      table.appendChild(headerRow);\n\n      // Rows\n      for(let row=0; row<n; row++) {\n        const tr = document.createElement('tr');\n        const rowHeader = document.createElement('th');\n        rowHeader.textContent = row;\n        tr.appendChild(rowHeader);\n        for(let col=0; col<n; col++) {\n          const td = document.createElement('td');\n          td.textContent = matrix[row][col];\n          if(matrix[row][col] === 1) {\n            td.style.backgroundColor = '#87ceeb88'; // lightly blue for edges\n          }\n          tr.appendChild(td);\n        }\n        table.appendChild(tr);\n      }\n      return table;\n    }\n\n    // Simple graph visualization using SVG and force simulation\n    // We'll do a simple circular layout for this demo\n    function renderGraph(n, edges) {\n      const width = 400;\n      const height = 400;\n      const radius = 150;\n      const cx = width / 2;\n      const cy = height / 2;\n\n      // Calculate node positions in a circle\n      const positions = [];\n      for(let i=0; i<n; i++) {\n        const angle = (2 * Math.PI / n) * i;\n        const x = cx + radius * Math.cos(angle);\n        const y = cy + radius * Math.sin(angle);\n        positions.push({x, y});\n      }\n\n      const svgNS = \"http://www.w3.org/2000/svg\";\n      const svg = document.createElementNS(svgNS, 'svg');\n      svg.setAttribute('width', width);\n      svg.setAttribute('height', height);\n      svg.setAttribute('aria-label', 'Graph visualization');\n\n      // Draw edges first (lines)\n      edges.forEach(([s,t]) => {\n        const line = document.createElementNS(svgNS, 'line');\n        line.setAttribute('x1', positions[s].x);\n        line.setAttribute('y1', positions[s].y);\n        line.setAttribute('x2', positions[t].x);\n        line.setAttribute('y2', positions[t].y);\n        line.setAttribute('stroke', '#666');\n        line.setAttribute('stroke-width', 2);\n        svg.appendChild(line);\n      });\n\n      // Draw nodes (circles)\n      positions.forEach((pos, i) => {\n        const circle = document.createElementNS(svgNS, 'circle');\n        circle.setAttribute('cx', pos.x);\n        circle.setAttribute('cy', pos.y);\n        circle.setAttribute('r', 16);\n        circle.setAttribute('fill', '#1e90ff');\n        circle.setAttribute('stroke', '#055aaf');\n        circle.setAttribute('stroke-width', 2);\n        circle.setAttribute('tabindex', 0);\n        circle.setAttribute('aria-label', `Node ${i}`);\n\n        // Add label\n        const text = document.createElementNS(svgNS, 'text');\n        text.setAttribute('x', pos.x);\n        text.setAttribute('y', pos.y + 6);\n        text.setAttribute('text-anchor', 'middle');\n        text.setAttribute('font-size', '14px');\n        text.setAttribute('fill', 'white');\n        text.textContent = i;\n\n        svg.appendChild(circle);\n        svg.appendChild(text);\n      });\n\n      return svg;\n    }\n\n    generateBtn.addEventListener('click', () => {\n      errorDiv.textContent = '';\n      outputDiv.innerHTML = '';\n\n      const n = Number(nodeCountInput.value);\n      if(!Number.isInteger(n) || n < 1 || n > 15) {\n        errorDiv.textContent = 'Number of nodes must be an integer between 1 and 15.';\n        return;\n      }\n\n      let edges;\n      try {\n        edges = parseEdges(edgeListInput.value, n);\n      } catch(e) {\n        errorDiv.textContent = e.message;\n        return;\n      }\n\n      // Build adjacency matrix\n      const matrix = buildAdjacencyMatrix(n, edges);\n\n      // Render adjacency matrix table\n      const matrixTable = renderMatrix(matrix);\n      outputDiv.appendChild(matrixTable);\n\n      // Render graph visualization\n      const graphVis = document.createElement('div');\n      graphVis.id = 'graphVisualization';\n      graphVis.appendChild(renderGraph(n, edges));\n      outputDiv.appendChild(graphVis);\n    });\n\n    // Generate initial on page load\n    generateBtn.click();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency Matrix"
    }
  ],
  "topic": "Adjacency Matrix",
  "hasFSM": false,
  "hasTest": true
}