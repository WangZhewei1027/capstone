{
  "id": "20d2d6c6-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:57.582Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Kruskal's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    background: #f9f9f9;\n    min-height: 100vh;\n  }\n  h1 {\n    margin: 20px 0 10px;\n  }\n  #container {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n    gap: 20px;\n    max-width: 1000px;\n    width: 90vw;\n  }\n  #graph-canvas {\n    border: 1px solid #ccc;\n    background: white;\n    border-radius: 8px;\n  }\n  #controls {\n    margin-top: 15px;\n    display: flex;\n    gap: 15px;\n    flex-wrap: wrap;\n    justify-content: center;\n  }\n  button, select {\n    padding: 10px 15px;\n    font-size: 1rem;\n    border-radius: 6px;\n    border: 1px solid #666;\n    cursor: pointer;\n    background: white;\n    transition: background-color 0.3s ease;\n  }\n  button:hover, select:hover {\n    background: #eee;\n  }\n  button:disabled {\n    cursor: not-allowed;\n    opacity: 0.6;\n  }\n  #info {\n    max-width: 1000px;\n    margin: 20px auto;\n    background: white;\n    padding: 15px 20px;\n    border-radius: 8px;\n    box-shadow: 0 0 8px rgb(0 0 0 / 0.1);\n    font-size: 1rem;\n    line-height: 1.4;\n  }\n  #edges-list {\n    max-height: 150px;\n    overflow-y: auto;\n    background: #fafafa;\n    border: 1px solid #ccc;\n    margin-top: 10px;\n    padding: 5px 10px;\n    font-family: monospace;\n    border-radius: 4px;\n  }\n</style>\n</head>\n<body>\n  <h1>Kruskal's Algorithm Visualization</h1>\n  <div id=\"container\">\n    <canvas id=\"graph-canvas\" width=\"700\" height=\"500\" aria-label=\"Graph visualization\"></canvas>\n    <div id=\"info\" aria-live=\"polite\" role=\"region\">\n      <strong>Algorithm Info:</strong>\n      <p>Kruskal's algorithm finds a Minimum Spanning Tree (MST) of a weighted, connected graph by selecting edges in increasing order of weight while avoiding cycles.</p>\n      <p><strong>Step explanation:</strong></p>\n      <ul>\n        <li>Sort all edges by weight (lowest to highest).</li>\n        <li>Initialize a forest where each vertex is its own set.</li>\n        <li>Iterate edges in sorted order and add an edge if it connects two distinct sets.</li>\n        <li>Union the sets connected by that edge.</li>\n        <li>Stop when all vertices are connected (MST formed).</li>\n      </ul>\n      <p><strong>Selected edges (MST):</strong></p>\n      <div id=\"edges-list\" aria-label=\"List of edges selected in the minimum spanning tree\" tabindex=\"0\"></div>\n    </div>\n  </div>\n  <div id=\"controls\" aria-label=\"Algorithm controls\">\n    <label for=\"graph-select\">Select Graph:</label>\n    <select id=\"graph-select\" aria-controls=\"graph-canvas\">\n      <option value=\"default\">Default Sample Graph</option>\n      <option value=\"triangle\">Triangle Graph</option>\n      <option value=\"square\">Square Graph</option>\n      <option value=\"custom\">Custom Graph (Add edges)</option>\n    </select>\n    <button id=\"start-btn\">Start</button>\n    <button id=\"step-btn\" disabled>Step</button>\n    <button id=\"auto-btn\" disabled>Auto Run</button>\n    <button id=\"reset-btn\" disabled>Reset</button>\n  </div>\n  <div id=\"custom-graph-controls\" style=\"margin-top: 15px; max-width: 700px; display:none; background:#fff; padding:15px; border-radius:8px; box-shadow: 0 0 8px rgb(0 0 0 / 0.1);\">\n    <strong>Add Edge to Custom Graph:</strong><br />\n    <label>From:\n      <select id=\"custom-from\"></select>\n    </label>\n    <label>To:\n      <select id=\"custom-to\"></select>\n    </label>\n    <label>Weight:\n      <input type=\"number\" id=\"custom-weight\" min=\"1\" max=\"100\" value=\"1\" style=\"width: 60px\" />\n    </label>\n    <button id=\"custom-add-edge\">Add Edge</button>\n    <button id=\"custom-clear\" style=\"margin-left: 10px;\">Clear Custom Graph</button>\n    <p><small>Note: Vertices are labeled A-K.</small></p>\n  </div>\n\n<script>\n(() => {\n  // Graph data structures\n  // Graph vertices are labeled with uppercase letters A-J (max 10 vertices for ease)\n  // Graph edges are objects: {from: 'A', to: 'B', weight: n, id: unique}\n\n  // We will draw the graph on canvas with force-directed coordinates or fixed positions.\n\n  // Predefined graphs\n  const predefinedGraphs = {\n    default: {\n      vertices: ['A','B','C','D','E','F','G'],\n      edges: [\n        {from:'A', to:'B', weight:7},\n        {from:'A', to:'D', weight:5},\n        {from:'B', to:'C', weight:8},\n        {from:'B', to:'D', weight:9},\n        {from:'B', to:'E', weight:7},\n        {from:'C', to:'E', weight:5},\n        {from:'D', to:'E', weight:15},\n        {from:'D', to:'F', weight:6},\n        {from:'E', to:'F', weight:8},\n        {from:'E', to:'G', weight:9},\n        {from:'F', to:'G', weight:11},\n      ],\n      positions: {\n        A: [70, 150],\n        B: [180, 80],\n        C: [310, 110],\n        D: [130, 230],\n        E: [250, 230],\n        F: [350, 220],\n        G: [430, 170]\n      }\n    },\n    triangle: {\n      vertices: ['A','B','C'],\n      edges: [\n        {from:'A', to:'B', weight:3},\n        {from:'B', to:'C', weight:1},\n        {from:'A', to:'C', weight:2},\n      ],\n      positions: {\n        A: [100, 250],\n        B: [250, 250],\n        C: [180, 170]\n      }\n    },\n    square: {\n      vertices: ['A','B','C','D'],\n      edges: [\n        {from:'A', to:'B', weight:4},\n        {from:'B', to:'C', weight:1},\n        {from:'C', to:'D', weight:3},\n        {from:'D', to:'A', weight:2},\n        {from:'A', to:'C', weight:5}, // diagonal\n      ],\n      positions: {\n        A: [150, 180],\n        B: [250, 180],\n        C: [250, 300],\n        D: [150, 300],\n      }\n    }\n  };\n\n  // Variables to hold current graph & MST state\n  let currentGraph = null;\n  let MSTedges = []; // edges selected in MST\n  let edgesSorted = [];\n  let stepIndex = 0;\n  let unionFind = null;\n  let autoInterval = null;\n\n  // Canvas setup\n  const canvas = document.getElementById('graph-canvas');\n  const ctx = canvas.getContext('2d');\n  const W = canvas.width;\n  const H = canvas.height;\n\n  // Controls\n  const startBtn = document.getElementById('start-btn');\n  const stepBtn = document.getElementById('step-btn');\n  const autoBtn = document.getElementById('auto-btn');\n  const resetBtn = document.getElementById('reset-btn');\n  const graphSelect = document.getElementById('graph-select');\n  const edgesListDiv = document.getElementById('edges-list');\n\n  // Custom Graph Controls\n  const customControls = document.getElementById('custom-graph-controls');\n  const customFrom = document.getElementById('custom-from');\n  const customTo = document.getElementById('custom-to');\n  const customWeight = document.getElementById('custom-weight');\n  const customAddEdgeBtn = document.getElementById('custom-add-edge');\n  const customClearBtn = document.getElementById('custom-clear');\n\n  // Helper - Union-Find (Disjoint Set) structure\n  class UnionFind {\n    constructor(elements) {\n      this.parent = {};\n      this.rank = {};\n      elements.forEach(e => {\n        this.parent[e] = e;\n        this.rank[e] = 0;\n      });\n    }\n    find(x) {\n      if(this.parent[x] !== x) {\n        this.parent[x] = this.find(this.parent[x]);\n      }\n      return this.parent[x];\n    }\n    union(a,b) {\n      const rootA = this.find(a);\n      const rootB = this.find(b);\n      if(rootA === rootB) return false;\n      if(this.rank[rootA] < this.rank[rootB]) {\n        this.parent[rootA] = rootB;\n      } else if(this.rank[rootB] < this.rank[rootA]) {\n        this.parent[rootB] = rootA;\n      } else {\n        this.parent[rootB] = rootA;\n        this.rank[rootA]++;\n      }\n      return true;\n    }\n  }\n\n\n  // Draw helpers\n  function drawGraph(graph, highlightEdges = [], disabledEdges = [], unionSets = null, highlightEdge = null) {\n    ctx.clearRect(0,0,W,H);\n    // Draw edges first\n    // Draw edges: black lines, highlightEdges in green, disabledEdges in light grey, highlightEdge in blue\n    for(let edge of graph.edges) {\n      const posA = graph.positions[edge.from];\n      const posB = graph.positions[edge.to];\n      const isHighlight = highlightEdges.some(e => e.id === edge.id);\n      const isDisabled = disabledEdges.some(e => e.id === edge.id);\n      const isCurrent = highlightEdge && (highlightEdge.id === edge.id);\n\n      ctx.beginPath();\n      ctx.moveTo(posA[0], posA[1]);\n      ctx.lineTo(posB[0], posB[1]);\n      if(isCurrent) {\n        ctx.strokeStyle = '#007bff'; // blue\n        ctx.lineWidth = 4;\n      } else if(isHighlight) {\n        ctx.strokeStyle = '#28a745'; // green\n        ctx.lineWidth = 4;\n      } else if(isDisabled) {\n        ctx.strokeStyle = '#ccc';\n        ctx.lineWidth = 1;\n        ctx.setLineDash([5, 5]);\n      } else {\n        ctx.strokeStyle = '#444';\n        ctx.lineWidth = 2;\n        ctx.setLineDash([]);\n      }\n      ctx.stroke();\n      ctx.setLineDash([]);\n\n      // Draw weight near middle with slight offset\n      const midX = (posA[0] + posB[0]) / 2;\n      const midY = (posA[1] + posB[1]) / 2;\n      ctx.fillStyle = '#222';\n      ctx.font = '14px Arial';\n      ctx.fillText(edge.weight, midX + 5, midY - 5);\n    }\n\n    // Draw vertices\n    // If unionSets given, color vertices by set for visualization\n    // We'll use a palette\n    const colors = [\n      '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',\n      '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe'\n    ];\n    let setColors = {};\n    if(unionSets) {\n      let roots = [...new Set(Object.values(unionSets.parent).map(x => unionSets.find(x)))];\n      roots.forEach((r,i) => {\n        setColors[r] = colors[i % colors.length];\n      });\n    }\n\n    for(let v of graph.vertices) {\n      const [x,y] = graph.positions[v];\n      let fillColor = '#fff';\n      let strokeColor = '#333';\n\n      if(unionSets) {\n        const root = unionSets.find(v);\n        fillColor = setColors[root];\n      }\n      ctx.beginPath();\n      ctx.fillStyle = fillColor;\n      ctx.strokeStyle = strokeColor;\n      ctx.lineWidth = 2;\n      ctx.arc(x, y, 20, 0, 2*Math.PI);\n      ctx.fill();\n      ctx.stroke();\n\n      ctx.fillStyle = '#000';\n      ctx.font = 'bold 16px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(v, x, y);\n    }\n  }\n\n  // Generate unique edge IDs for internal use\n  function assignEdgeIds(graph) {\n    let idCount = 0;\n    graph.edges.forEach(e => {\n      e.id = idCount++;\n      // For MST union-find and list, we want edges normalized so from < to alphabetically when displaying\n      if(e.from > e.to) {\n        [e.from, e.to] = [e.to, e.from];\n      }\n    });\n  }\n\n  // Prepare graph for MST algorithm\n  function prepareGraph(graph) {\n    // assign ids to edges\n    assignEdgeIds(graph);\n    MSTedges = [];\n    stepIndex = 0;\n    // sort edges by weight ascending (stable)\n    edgesSorted = [...graph.edges].sort((a,b) => a.weight - b.weight);\n    unionFind = new UnionFind(graph.vertices);\n  }\n\n  // Update edges-list div with MST edges\n  function updateEdgesList() {\n    if(MSTedges.length === 0) {\n      edgesListDiv.textContent = 'No edges selected yet.';\n      return;\n    }\n    // Sort edges lex by from-to for presentation\n    const sortedMST = [...MSTedges].sort((a,b) => {\n      if(a.from < b.from) return -1;\n      if(a.from > b.from) return 1;\n      if(a.to < b.to) return -1;\n      if(a.to > b.to) return 1;\n      return 0;\n    });\n    edgesListDiv.innerHTML = sortedMST.map(e => `(${e.from} - ${e.to}) weight: ${e.weight}`).join('<br>');\n  }\n\n  // Step the MST algorithm forward\n  // Returns true if step done, false if finished\n  function stepMST() {\n    if(stepIndex >= edgesSorted.length) {\n      return false;\n    }\n    const edge = edgesSorted[stepIndex];\n    // Check if edge connects two different sets\n    const u = unionFind.find(edge.from);\n    const v = unionFind.find(edge.to);\n    if(u !== v) {\n      unionFind.union(u,v);\n      MSTedges.push(edge);\n    }\n    stepIndex++;\n    return true;\n  }\n\n  // Draw with current MST progress and highlight current edge\n  function drawStep() {\n    let highlightEdge = null;\n    if(stepIndex < edgesSorted.length) {\n      highlightEdge = edgesSorted[stepIndex];\n    }\n    drawGraph(currentGraph, MSTedges, edgesSorted.slice(stepIndex), unionFind, highlightEdge);\n    updateEdgesList();\n  }\n\n  // Controls enable/disable helper\n  function setControls(state) {\n    // state: 'init', 'running', 'finished'\n    if(state === 'init') {\n      startBtn.disabled = false;\n      stepBtn.disabled = true;\n      autoBtn.disabled = true;\n      resetBtn.disabled = true;\n      graphSelect.disabled = false;\n      if(graphSelect.value === \"custom\") customControls.style.display = 'block';\n      else customControls.style.display = 'none';\n    } else if(state === 'running') {\n      startBtn.disabled = true;\n      stepBtn.disabled = false;\n      autoBtn.disabled = false;\n      resetBtn.disabled = false;\n      graphSelect.disabled = true;\n      customControls.style.display = 'none';\n    } else if(state === 'finished') {\n      startBtn.disabled = true;\n      stepBtn.disabled = true;\n      autoBtn.disabled = true;\n      resetBtn.disabled = false;\n      graphSelect.disabled = true;\n      customControls.style.display = 'none';\n    }\n  }\n\n  // Initialize the canvas with chosen graph\n  function loadGraph(name) {\n    if(name === 'custom') {\n      // Custom graph with initially empty graph\n      // We'll allow adding edges between vertices A-K (max 11 vertices)\n      if(!window.customGraph) {\n        window.customGraph = {\n          vertices: ['A','B','C','D','E','F','G','H','I','J','K'],\n          edges: [],\n          positions: {\n            A:[100, 150], B:[160,100], C:[220,150], D:[280,100], E:[340,150],\n            F:[100, 250], G:[160, 300], H:[220, 250], I:[280, 300], J:[340, 250], K:[400, 200]\n          }\n        };\n      }\n      currentGraph = {\n        vertices: [...window.customGraph.vertices],\n        edges: [...window.customGraph.edges],\n        positions: {...window.customGraph.positions}\n      };\n      assignEdgeIds(currentGraph);\n      return;\n    }\n    const g = predefinedGraphs[name];\n    if(!g) {\n      alert(\"Graph not found!\");\n      return;\n    }\n    currentGraph = {\n      vertices: [...g.vertices],\n      edges: g.edges.map(e => ({...e})),\n      positions: {...g.positions}\n    };\n    assignEdgeIds(currentGraph);\n  }\n\n  // Initialize custom selects (from-to vertex selectors)\n  function initCustomSelectors() {\n    const verts = window.customGraph.vertices;\n    customFrom.innerHTML = '';\n    customTo.innerHTML = '';\n    verts.forEach(v => {\n      const opt1 = document.createElement('option');\n      opt1.value = v;\n      opt1.textContent = v;\n      customFrom.appendChild(opt1);\n\n      const opt2 = document.createElement('option');\n      opt2.value = v;\n      opt2.textContent = v;\n      customTo.appendChild(opt2);\n    });\n  }\n\n  // Clear custom graph edges\n  function clearCustomGraph() {\n    window.customGraph.edges.length = 0;\n    loadGraph('custom');\n    drawGraph(currentGraph);\n    updateEdgesList();\n  }\n\n  // Event listeners\n\n  startBtn.addEventListener('click', () => {\n    if(!currentGraph) {\n      alert(\"Load a graph first\");\n      return;\n    }\n    prepareGraph(currentGraph);\n    drawStep();\n    setControls('running');\n  });\n\n  stepBtn.addEventListener('click', () => {\n    if(stepMST()) {\n      drawStep();\n    } else {\n      // Finished MST\n      drawGraph(currentGraph, MSTedges, [], unionFind);\n      updateEdgesList();\n      setControls('finished');\n      if(autoInterval) {\n        clearInterval(autoInterval);\n        autoInterval = null;\n      }\n    }\n  });\n\n  autoBtn.addEventListener('click', () => {\n    if(autoInterval) {\n      clearInterval(autoInterval);\n      autoInterval = null;\n      autoBtn.textContent = 'Auto Run';\n      stepBtn.disabled = false;\n    } else {\n      autoBtn.textContent = 'Pause';\n      stepBtn.disabled = true;\n      autoInterval = setInterval(() => {\n        const hasNext = stepMST();\n        drawStep();\n        if(!hasNext) {\n          drawGraph(currentGraph, MSTedges, [], unionFind);\n          updateEdgesList();\n          setControls('finished');\n          clearInterval(autoInterval);\n          autoInterval = null;\n          autoBtn.textContent = 'Auto Run';\n          stepBtn.disabled = true;\n        }\n      }, 1000);\n    }\n  });\n\n  resetBtn.addEventListener('click', () => {\n    if(autoInterval) {\n      clearInterval(autoInterval);\n      autoInterval = null;\n    }\n    stepIndex = 0;\n    MSTedges = [];\n    unionFind = null;\n    loadGraph(graphSelect.value);\n    drawGraph(currentGraph);\n    updateEdgesList();\n    setControls('init');\n  });\n\n  graphSelect.addEventListener('change', () => {\n    if(autoInterval) {\n      clearInterval(autoInterval);\n      autoInterval = null;\n    }\n    stepIndex = 0;\n    MSTedges = [];\n    unionFind = null;\n    loadGraph(graphSelect.value);\n    drawGraph(currentGraph);\n    updateEdgesList();\n    setControls('init');\n    if(graphSelect.value === 'custom') {\n      customControls.style.display = 'block';\n    } else {\n      customControls.style.display = 'none';\n    }\n  });\n\n  customAddEdgeBtn.addEventListener('click', () => {\n    const fromV = customFrom.value;\n    const toV = customTo.value;\n    const w = Number(customWeight.value);\n    if(fromV === toV) {\n      alert(\"Cannot add edge from a vertex to itself.\");\n      return;\n    }\n    if(!w || w <= 0) {\n      alert(\"Weight should be a positive number.\");\n      return;\n    }\n    // Check for duplicate edges (in either direction)\n    const exists = window.customGraph.edges.some(e => {\n      return (e.from === fromV && e.to === toV) || (e.from === toV && e.to === fromV);\n    });\n    if(exists) {\n      alert(\"Edge already exists.\");\n      return;\n    }\n    window.customGraph.edges.push({from: fromV, to: toV, weight: w});\n    loadGraph('custom');\n    drawGraph(currentGraph);\n    updateEdgesList();\n  });\n\n  customClearBtn.addEventListener('click', () => {\n    if(confirm(\"Clear all edges in the custom graph?\")) {\n      clearCustomGraph();\n    }\n  });\n\n  // Initial load\n  function init() {\n    loadGraph('default');\n    drawGraph(currentGraph);\n    updateEdgesList();\n    setControls('init');\n    if(!window.customGraph) {\n      window.customGraph = {\n        vertices: ['A','B','C','D','E','F','G','H','I','J','K'],\n        edges: [],\n        positions: {\n          A:[100, 150], B:[160,100], C:[220,150], D:[280,100], E:[340,150],\n          F:[100, 250], G:[160, 300], H:[220, 250], I:[280, 300], J:[340, 250], K:[400, 200]\n        }\n      };\n    }\n    initCustomSelectors();\n  }\n\n  init();\n\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}