{
  "id": "20d2d6c5-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:30.283Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Floyd-Warshall Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Floyd-Warshall Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 1em;\n    background: #f0f0f0;\n  }\n  h1 {\n    text-align: center;\n  }\n  .container {\n    max-width: 900px;\n    margin: auto;\n    background: white;\n    padding: 1em 2em 2em 2em;\n    border-radius: 8px;\n    box-shadow: 0 0 10px #ccc;\n  }\n  label {\n    display: block;\n    margin-top: 1em;\n    font-weight: bold;\n  }\n  textarea, input[type=number] {\n    width: 100%;\n    box-sizing: border-box;\n    margin-top: 0.3em;\n    font-family: monospace;\n    font-size: 1em;\n  }\n  textarea {\n    min-height: 120px;\n  }\n  button {\n    margin-top: 1em;\n    font-size: 1.1em;\n    padding: 0.5em 1.2em;\n    background: #0066cc;\n    color: white;\n    border: none;\n    border-radius: 5px;\n    cursor: pointer;\n  }\n  button:disabled {\n    background: #ccc;\n    cursor: not-allowed;\n  }\n  table {\n    border-collapse: collapse;\n    margin-top: 1em;\n    width: 100%;\n  }\n  table, th, td {\n    border: 1px solid #999;\n  }\n  th, td {\n    padding: 0.4em 0.6em;\n    text-align: center;\n    font-family: monospace;\n  }\n  th {\n    background: #e0e0e0;\n  }\n  .infinity {\n    color: #aaa;\n  }\n  .step-controls {\n    margin-top: 1em;\n    text-align: center;\n  }\n  .step-controls button {\n    margin: 0 0.5em;\n    background: #007700;\n  }\n  .step-info {\n    margin-top: 1em;\n    font-family: monospace;\n    font-size: 1.1em;\n    background: #e8f5e9;\n    padding: 0.5em 1em;\n    border-radius: 5px;\n    border: 1px solid #a5d6a7;\n    text-align: center;\n  }\n  .error {\n    color: red;\n    margin-top: 0.5em;\n    font-weight: bold;\n  }\n  .note {\n    font-size: 0.9em;\n    color: #555;\n  }\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <h1>Floyd-Warshall Algorithm Visualization</h1>\n\n  <label for=\"numVertices\">Number of vertices (1 to 10):</label>\n  <input type=\"number\" id=\"numVertices\" value=\"4\" min=\"1\" max=\"10\" />\n  <div class=\"note\">Vertices will be numbered from 0 to n-1.</div>\n\n  <label for=\"adjMatrix\">Enter adjacency matrix (use infinity or -1 for no edge):</label>\n  <textarea id=\"adjMatrix\" spellcheck=\"false\">0 3 -1 7\n8 0 2 -1\n5 -1 0 1\n2 -1 -1 0</textarea>\n  <div class=\"note\">\n    Each row corresponds to edges from a vertex to others, separated by spaces.<br />\n    For example, the above matrix means edge weights (or no edge) between vertices.\n  </div>\n\n  <button id=\"startBtn\">Run Floyd-Warshall</button>\n\n  <div id=\"error\" class=\"error\"></div>\n\n  <div id=\"output\"></div>\n\n</div>\n\n<script>\n(() => {\n  const INF = Infinity;\n  const maxVertices = 10;\n\n  const numInput = document.getElementById(\"numVertices\");\n  const matrixInput = document.getElementById(\"adjMatrix\");\n  const startBtn = document.getElementById(\"startBtn\");\n  const errorDiv = document.getElementById(\"error\");\n  const outputDiv = document.getElementById(\"output\");\n\n  // Parse the adjacency matrix text area input\n  function parseMatrix(text, n) {\n    let rows = text.trim().split('\\n').map(r => r.trim());\n    if (rows.length !== n) return { error: `Expected ${n} rows, but got ${rows.length}` };\n    let matrix = [];\n    for (let i = 0; i < n; i++) {\n      const cols = rows[i].split(/\\s+/);\n      if (cols.length !== n) return { error: `Row ${i} expected ${n} columns, but got ${cols.length}` };\n      let row = [];\n      for (let j = 0; j < n; j++) {\n        let valRaw = cols[j].toLowerCase();\n        if (valRaw === \"infinity\" || valRaw === \"inf\" || valRaw === \"-1\") {\n          row.push(INF);\n        } else {\n          let val = Number(valRaw);\n          if (isNaN(val)) return { error: `Invalid number \"${cols[j]}\" at row ${i} column ${j}` };\n          row.push(val);\n        }\n      }\n      matrix.push(row);\n    }\n    return { matrix };\n  }\n\n  // Create a deep copy of 2D array\n  function copyMatrix(mat) {\n    return mat.map(row => row.slice());\n  }\n\n  // Format a matrix into an HTML table\n  function matrixToTable(mat) {\n    const n = mat.length;\n    let html = \"<table><thead><tr><th></th>\";\n    for (let j = 0; j < n; j++) html += `<th>${j}</th>`;\n    html += \"</tr></thead><tbody>\";\n    for (let i = 0; i < n; i++) {\n      html += `<tr><th>${i}</th>`;\n      for (let j = 0; j < n; j++) {\n        let val = mat[i][j];\n        if (val === INF) {\n          html += `<td class=\"infinity\">∞</td>`;\n        } else {\n          html += `<td>${val}</td>`;\n        }\n      }\n      html += \"</tr>\";\n    }\n    html += \"</tbody></table>\";\n    return html;\n  }\n\n  // Floyd-Warshall algorithm with step capture\n  function floydWarshall(matrix) {\n    // matrix should be n x n\n    const n = matrix.length;\n    // Dist initialized as copy of matrix\n    let dist = copyMatrix(matrix);\n    // Record the state after each k iteration for visualization\n    // Each step:\n    // { k: <number>, i: <number>, j: <number>, dist: <matrix snapshot>, updated: boolean }\n    const steps = [];\n\n    for (let k = 0; k < n; k++) {\n      for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n          let old = dist[i][j];\n          let throughK = (dist[i][k] === INF || dist[k][j] === INF) ? INF : dist[i][k] + dist[k][j];\n          if (throughK < dist[i][j]) {\n            dist[i][j] = throughK;\n            steps.push({\n              k, i, j, dist: copyMatrix(dist), updated: true,\n              oldVal: old, newVal: throughK\n            });\n          } else {\n            // still record step showing no update for completeness\n            steps.push({\n              k, i, j, dist: copyMatrix(dist), updated: false,\n              oldVal: old, newVal: old\n            });\n          }\n        }\n      }\n    }\n\n    return { dist, steps };\n  }\n\n  // Build interface for stepping through the algorithm\n  function visualizeFloydWarshall(steps, n) {\n    outputDiv.innerHTML = \"\";\n\n    if (steps.length === 0) {\n      outputDiv.innerHTML = \"<p>No steps to show (edges may be trivial or single vertex graph).</p>\";\n      return;\n    }\n\n    // Controls\n    const controlsDiv = document.createElement(\"div\");\n    controlsDiv.className = \"step-controls\";\n\n    const prevBtn = document.createElement(\"button\");\n    prevBtn.textContent = \"◀ Previous Step\";\n    const nextBtn = document.createElement(\"button\");\n    nextBtn.textContent = \"Next Step ▶\";\n\n    controlsDiv.appendChild(prevBtn);\n    controlsDiv.appendChild(nextBtn);\n\n    // Step info display\n    const stepInfo = document.createElement(\"div\");\n    stepInfo.className = \"step-info\";\n\n    // Matrix display\n    const matrixContainer = document.createElement(\"div\");\n    matrixContainer.style.marginTop = \"1em\";\n\n    outputDiv.appendChild(controlsDiv);\n    outputDiv.appendChild(stepInfo);\n    outputDiv.appendChild(matrixContainer);\n\n    let currentStep = -1; // -1 means before any step (initial state)\n\n    // Display state for a given step index\n    function showStep(stepIndex) {\n      if (stepIndex < 0) {\n        // Before any update (initial matrix)\n        stepInfo.textContent = \"Initial state before any updates.\";\n        matrixContainer.innerHTML = matrixToTable(steps[0].dist.map((row,i) =>\n          row.map((v,j) => (i === j ? 0 : (v === INF ? INF : v)))));\n      } else if (stepIndex >= steps.length) {\n        stepInfo.textContent = `Algorithm finished after ${steps.length} update checks. Final matrix:`;\n        matrixContainer.innerHTML = matrixToTable(steps[steps.length-1].dist);\n      } else {\n        const stp = steps[stepIndex];\n        const updTxt = stp.updated ? \"UPDATED\" : \"No update\";\n        stepInfo.innerHTML =\n          `Step ${stepIndex + 1} / ${steps.length}: k=${stp.k}, i=${stp.i}, j=${stp.j} — ${updTxt}` +\n          (stp.updated ? `<br>Updated dist[${stp.i}][${stp.j}]: ${stp.oldVal === INF ? '∞' : stp.oldVal} &rarr; ${stp.newVal === INF ? '∞' : stp.newVal}` : \"\");\n        matrixContainer.innerHTML = matrixToTable(stp.dist);\n      }\n      currentStep = stepIndex;\n\n      prevBtn.disabled = currentStep <= -1;\n      nextBtn.disabled = currentStep >= steps.length;\n    }\n\n    prevBtn.addEventListener(\"click\", () => {\n      if (currentStep > -1) showStep(currentStep - 1);\n    });\n    nextBtn.addEventListener(\"click\", () => {\n      if (currentStep < steps.length) showStep(currentStep + 1);\n    });\n\n    // Start from initial\n    showStep(-1);\n  }\n\n  // Validate input and run\n  function run() {\n    errorDiv.textContent = \"\";\n    outputDiv.innerHTML = \"\";\n    const n = Number(numInput.value);\n    if (!n || n < 1 || n > maxVertices || !Number.isInteger(n)) {\n      errorDiv.textContent = `Number of vertices must be an integer between 1 and ${maxVertices}.`;\n      return;\n    }\n    const {matrix, error} = parseMatrix(matrixInput.value, n);\n    if (error) {\n      errorDiv.textContent = error;\n      return;\n    }\n\n    // Validate diagonal zero\n    for (let i = 0; i < n; i++) {\n      if (matrix[i][i] !== 0 && matrix[i][i] !== INF) {\n        errorDiv.textContent = `Diagonal elements must be 0 or infinity (no self loops), check row ${i}.`;\n        return;\n      }\n    }\n\n    const result = floydWarshall(matrix);\n\n    visualizeFloydWarshall(result.steps, n);\n  }\n\n  startBtn.addEventListener(\"click\", run);\n\n  // On numVertices change, update adjacency matrix area default example if smaller or larger\n  numInput.addEventListener(\"change\", () => {\n    const v = Number(numInput.value);\n    if (!v || v < 1 || v > maxVertices) return;\n    const defaultMatrix = {\n      1: \"0\",\n      2: \"0 1\\n1 0\",\n      3: \"0 4 11\\n6 0 2\\n3 9 0\",\n      4: \"0 3 -1 7\\n8 0 2 -1\\n5 -1 0 1\\n2 -1 -1 0\",\n      5: `0 3 8 -1 -4\n-1 0 -1 1 7\n-1 4 0 -1 -1\n2 -1 -5 0 -1\n-1 -1 -1 6 0`\n    };\n    if(numInput.value in defaultMatrix){\n      matrixInput.value = defaultMatrix[numInput.value];\n    } else {\n      // Fill with zeros on diagonal and infinities elsewhere\n      let lines = [];\n      for (let i=0; i<v; i++){\n        let row = [];\n        for(let j=0; j<v; j++){\n          row.push(i===j ? \"0\" : \"∞\");\n        }\n        lines.push(row.join(\" \"));\n      }\n      matrixInput.value = lines.join(\"\\n\");\n    }\n  });\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Floyd-Warshall Algorithm"
    }
  ],
  "topic": "Floyd-Warshall Algorithm",
  "hasFSM": false,
  "hasTest": true
}