{
  "id": "20d288a1-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:23.200Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Red-Black Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Red-Black Tree Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    padding: 0;\n    background: #f7f7f7;\n    user-select: none;\n  }\n  h1 {\n    text-align: center;\n    color: #333;\n    margin: 1rem 0 0.2rem;\n  }\n  #controls {\n    text-align: center;\n    margin: 10px 0 20px;\n  }\n  input[type=number] {\n    padding: 0.4rem;\n    font-size: 1rem;\n    width: 100px;\n    margin-right: 0.5rem;\n  }\n  button {\n    padding: 0.45rem 0.8rem;\n    font-size: 1rem;\n    cursor: pointer;\n    border-radius: 4px;\n    border: none;\n    background-color: #0077cc;\n    color: white;\n    transition: background-color 0.3s ease;\n  }\n  button:hover:not(:disabled) {\n    background-color: #005fa3;\n  }\n  button:disabled {\n    background-color: #aaa;\n    cursor: not-allowed;\n  }\n  #message {\n    text-align: center;\n    margin: 5px 0 15px;\n    font-weight: bold;\n    color: #444;\n  }\n  #canvasContainer {\n    display: flex;\n    justify-content: center;\n    overflow-x: auto;\n    padding-bottom: 20px;\n  }\n  canvas {\n    background: white;\n    box-shadow: 0 0 8px rgba(0,0,0,0.1);\n    border-radius: 8px;\n  }\n  #legend {\n    max-width: 600px;\n    margin: 0 auto 20px;\n    font-size: 0.9rem;\n    color: #444;\n    display: flex;\n    justify-content: center;\n    gap: 20px;\n  }\n  .legend-item {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n  }\n  .circle-sample {\n    width: 18px;\n    height: 18px;\n    border-radius: 50%;\n    display: inline-block;\n    border: 2px solid black;\n  }\n  .red-node {\n    background-color: #d33a3a;\n  }\n  .black-node {\n    background-color: #222;\n  }\n</style>\n</head>\n<body>\n\n<h1>Red-Black Tree Visualization</h1>\n<div id=\"controls\">\n  <input type=\"number\" id=\"inputValue\" placeholder=\"Enter value\" />\n  <button id=\"insertBtn\">Insert</button>\n  <button id=\"clearBtn\">Clear Tree</button>\n</div>\n<div id=\"message\"></div>\n<div id=\"legend\">\n  <div class=\"legend-item\"><span class=\"circle-sample red-node\"></span> Red Node</div>\n  <div class=\"legend-item\"><span class=\"circle-sample black-node\"></span> Black Node</div>\n  <div class=\"legend-item\" style=\"color:#555;\">Black edges are parent-child links</div>\n</div>\n<div id=\"canvasContainer\">\n  <canvas id=\"rbtCanvas\" width=\"1000\" height=\"500\"></canvas>\n</div>\n\n<script>\n// Red-Black Tree Implementation with Visualization\n\nclass RBNode {\n  constructor(value, color, parent = null, left = null, right = null) {\n    this.value = value;\n    this.color = color; // \"RED\" or \"BLACK\"\n    this.parent = parent;\n    this.left = left;\n    this.right = right;\n  }\n  isRed() { return this.color === \"RED\"; }\n  isBlack() { return this.color === \"BLACK\"; }\n}\n\nclass RedBlackTree {\n  constructor() {\n    this.NULL_LEAF = new RBNode(null, \"BLACK\"); // sentinel leaf, shared\n    this.root = this.NULL_LEAF;\n  }\n\n  insert(value) {\n    // Normal BST insert\n    let newNode = new RBNode(value, \"RED\", null, this.NULL_LEAF, this.NULL_LEAF);\n    if (this.root === this.NULL_LEAF) {\n      this.root = newNode;\n      this.root.color = \"BLACK\";\n      return true;\n    }\n    let current = this.root;\n    let parent = null;\n    while (current !== this.NULL_LEAF) {\n      parent = current;\n      if (value === current.value) {\n        return false; // No duplicates allowed\n      } else if (value < current.value) {\n        current = current.left;\n      } else {\n        current = current.right;\n      }\n    }\n    newNode.parent = parent;\n    if (value < parent.value) {\n      parent.left = newNode;\n    } else {\n      parent.right = newNode;\n    }\n    this.fixInsertion(newNode);\n    return true;\n  }\n\n  leftRotate(x) {\n    const y = x.right;\n    x.right = y.left;\n    if (y.left !== this.NULL_LEAF) {\n      y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === null) { // x was root\n      this.root = y;\n    } else if (x === x.parent.left) {\n      x.parent.left = y;\n    } else {\n      x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n  }\n  rightRotate(x) {\n    const y = x.left;\n    x.left = y.right;\n    if (y.right !== this.NULL_LEAF) {\n      y.right.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === null) { // x was root\n      this.root = y;\n    } else if (x === x.parent.right) {\n      x.parent.right = y;\n    } else {\n      x.parent.left = y;\n    }\n    y.right = x;\n    x.parent = y;\n  }\n\n  fixInsertion(z) {\n    while (z.parent && z.parent.isRed()) {\n      if (z.parent === z.parent.parent.left) {\n        let y = z.parent.parent.right; // uncle\n        if (y.isRed()) {\n          // Case 1\n          z.parent.color = \"BLACK\";\n          y.color = \"BLACK\";\n          z.parent.parent.color = \"RED\";\n          z = z.parent.parent;\n        } else {\n          if (z === z.parent.right) {\n            // Case 2\n            z = z.parent;\n            this.leftRotate(z);\n          }\n          // Case 3\n          z.parent.color = \"BLACK\";\n          z.parent.parent.color = \"RED\";\n          this.rightRotate(z.parent.parent);\n        }\n      } else {\n        // Mirror of above case\n        let y = z.parent.parent.left; // uncle\n        if (y.isRed()) {\n          // Case 1\n          z.parent.color = \"BLACK\";\n          y.color = \"BLACK\";\n          z.parent.parent.color = \"RED\";\n          z = z.parent.parent;\n        } else {\n          if (z === z.parent.left) {\n            // Case 2\n            z = z.parent;\n            this.rightRotate(z);\n          }\n          // Case 3\n          z.parent.color = \"BLACK\";\n          z.parent.parent.color = \"RED\";\n          this.leftRotate(z.parent.parent);\n        }\n      }\n    }\n    this.root.color = \"BLACK\";\n  }\n\n  clear() {\n    this.root = this.NULL_LEAF;\n  }\n}\n\n\n// Drawing and UI logic\n\nconst canvas = document.getElementById('rbtCanvas');\nconst ctx = canvas.getContext('2d');\nconst tree = new RedBlackTree();\n\nconst NODE_RADIUS = 20;\nconst VERTICAL_DIST = 70;\nconst HORIZONTAL_GAP_BASE = 40; // base horizontal gap, expands with depth\n\nfunction clearCanvas() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nfunction drawNode(x, y, node) {\n  // Draw the circle\n  ctx.beginPath();\n  ctx.arc(x, y, NODE_RADIUS, 0, 2 * Math.PI, false);\n  ctx.fillStyle = node.isRed() ? '#d33a3a' : '#222222';\n  ctx.fill();\n  ctx.lineWidth = 3;\n  ctx.strokeStyle = '#000000';\n  ctx.stroke();\n  ctx.closePath();\n\n  // Draw the value text\n  ctx.fillStyle = 'white';\n  ctx.font = '16px Arial';\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n  ctx.fillText(node.value, x, y);\n\n  // Draw a small white circle inside black node (optional for style)\n  // if (node.isBlack()) {\n  //   ctx.beginPath();\n  //   ctx.arc(x, y, 6, 0, 2 * Math.PI);\n  //   ctx.fillStyle = '#555555';\n  //   ctx.fill();\n  //   ctx.closePath();\n  // }\n}\n\nfunction drawEdge(x1, y1, x2, y2) {\n  ctx.beginPath();\n  ctx.strokeStyle = '#000000';\n  ctx.lineWidth = 2;\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n  ctx.stroke();\n  ctx.closePath();\n}\n\nfunction computePositions(root) {\n  // We compute the x position of nodes to keep the tree balanced\n  // We'll do a recursive post-order traversal assigning x coords\n\n  let positions = new Map();\n\n  function assignX(node, depth) {\n    if (node === tree.NULL_LEAF) return 0;\n\n    let leftWidth = assignX(node.left, depth + 1);\n    let rightWidth = assignX(node.right, depth + 1);\n\n    // For leaf nodes, width is 1 unit\n    if (leftWidth === 0 && rightWidth === 0) leftWidth = rightWidth = 0;\n\n    let x;\n    if (leftWidth === 0 && rightWidth === 0) {\n      // Leaf node\n      x = 1;\n    } else if (leftWidth === 0) {\n      x = rightWidth;\n    } else if (rightWidth === 0) {\n      x = leftWidth;\n    } else {\n      x = (leftWidth + rightWidth);\n    }\n\n    positions.set(node, {depth, width: x});\n    return x;\n  }\n  assignX(root, 0);\n\n  // Now assign actual x coordinates\n\n  let xOffset = 0;\n  let coords = new Map();\n\n  function setCoords(node, depth) {\n    if (node === tree.NULL_LEAF) return;\n    let pos = positions.get(node);\n\n    if (node.left !== tree.NULL_LEAF) setCoords(node.left, depth + 1);\n\n    let x = xOffset + 1;\n    coords.set(node, {x, y: depth});\n\n    xOffset += 2; // spacing nodes by 2 units horizontally (can be adjusted)\n\n    if (node.right !== tree.NULL_LEAF) setCoords(node.right, depth + 1);\n  }\n  xOffset = 0;\n  setCoords(root, 0);\n\n  return coords;\n}\n\nfunction drawTree() {\n  clearCanvas();\n  if (tree.root === tree.NULL_LEAF) return;\n\n  // Compute positions\n  // For better horizontal spacing, we use an inorder traversal assigning incremental x\n  let coords = new Map();\n  let xCount = 0;\n\n  function setCoordsInOrder(node, depth) {\n    if (node === tree.NULL_LEAF) return;\n    setCoordsInOrder(node.left, depth + 1);\n    coords.set(node, {x: xCount, y: depth});\n    xCount++;\n    setCoordsInOrder(node.right, depth + 1);\n  }\n  setCoordsInOrder(tree.root, 0);\n\n\n  // Calculate horizontal scale to fit canvas width\n  let totalNodes = xCount;\n  let hGap = Math.max(HORIZONTAL_GAP_BASE, canvas.width / (totalNodes + 1));\n\n  // Calculate vertical gap scaling if needed (fixed vertical distance)\n  let vGap = VERTICAL_DIST;\n\n  // Draw edges first\n  coords.forEach((coord, node) => {\n    if (node === tree.NULL_LEAF) return;\n    if (node.left !== tree.NULL_LEAF) {\n      let cLeft = coords.get(node.left);\n      drawEdge(coord.x * hGap + NODE_RADIUS, coord.y * vGap + NODE_RADIUS, cLeft.x * hGap + NODE_RADIUS, cLeft.y * vGap + NODE_RADIUS);\n    }\n    if (node.right !== tree.NULL_LEAF) {\n      let cRight = coords.get(node.right);\n      drawEdge(coord.x * hGap + NODE_RADIUS, coord.y * vGap + NODE_RADIUS, cRight.x * hGap + NODE_RADIUS, cRight.y * vGap + NODE_RADIUS);\n    }\n  });\n\n  // Draw nodes on top\n  coords.forEach((coord, node) => {\n    if (node === tree.NULL_LEAF) return;\n    drawNode(coord.x * hGap + NODE_RADIUS, coord.y * vGap + NODE_RADIUS, node);\n  });\n}\n\n// UI Elements\nconst inputValue = document.getElementById('inputValue');\nconst insertBtn = document.getElementById('insertBtn');\nconst clearBtn = document.getElementById('clearBtn');\nconst message = document.getElementById('message');\n\nfunction showMessage(msg, isError = false) {\n  message.textContent = msg;\n  message.style.color = isError ? 'crimson' : 'green';\n  setTimeout(() => {\n    message.textContent = '';\n  }, 3500);\n}\n\ninsertBtn.addEventListener('click', () => {\n  let val = inputValue.value.trim();\n  if (val === '') {\n    showMessage('Please enter a value to insert.', true);\n    return;\n  }\n  // Support integers only for simplicity\n  let numVal = Number(val);\n  if (Number.isNaN(numVal)) {\n    showMessage('Please enter a valid number.', true);\n    return;\n  }\n  if (!Number.isInteger(numVal)) {\n    showMessage('Please enter an integer value.', true);\n    return;\n  }\n\n  let success = tree.insert(numVal);\n  if (!success) {\n    showMessage(`Value ${numVal} already exists in the tree.`, true);\n    return;\n  }\n  showMessage(`Inserted value ${numVal} into the tree.`);\n  inputValue.value = '';\n  drawTree();\n});\n\ninputValue.addEventListener('keydown', e => {\n  if (e.key === 'Enter') insertBtn.click();\n});\n\nclearBtn.addEventListener('click', () => {\n  tree.clear();\n  drawTree();\n  showMessage(`Red-Black Tree cleared.`);\n  inputValue.value = '';\n  inputValue.focus();\n});\n\nwindow.addEventListener('resize', () => {\n  // Optional: resize canvas or redraw\n  drawTree();\n});\n\n// Initial draw\ndrawTree();\n\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Red-Black Tree"
    }
  ],
  "topic": "Red-Black Tree",
  "hasFSM": false,
  "hasTest": true
}