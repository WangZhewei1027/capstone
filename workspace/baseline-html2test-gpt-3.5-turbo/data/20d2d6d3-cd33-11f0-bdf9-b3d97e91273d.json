{
  "id": "20d2d6d3-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:14.414Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>K-Means Clustering Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 1em;\n    text-align: center;\n  }\n  canvas {\n    border: 1px solid #ccc;\n    cursor: crosshair;\n    margin-bottom: 1em;\n  }\n  #controls {\n    margin-bottom: 1em;\n  }\n  button, input[type=number] {\n    font-size: 1em;\n    padding: 0.3em 0.6em;\n  }\n  #info {\n    max-width: 600px;\n    margin: 0 auto;\n    color: #333;\n    font-size: 0.9em;\n    line-height: 1.3em;\n  }\n  #resetPoints {\n    margin-left: 1em;\n  }\n</style>\n</head>\n<body>\n<h1>K-Means Clustering Interactive Demo</h1>\n<p>Click on the canvas to add points. Choose number of clusters (k) and click \"Run K-Means\".</p>\n<div id=\"controls\">\n  <label for=\"kInput\">Number of clusters (k): </label>\n  <input type=\"number\" id=\"kInput\" min=\"1\" max=\"10\" value=\"3\" />\n  <button id=\"runBtn\">Run K-Means</button>\n  <button id=\"resetBtn\">Reset Clusters</button>\n  <button id=\"resetPoints\">Clear Points</button>\n</div>\n<canvas id=\"canvas\" width=\"600\" height=\"400\" aria-label=\"K-means clustering canvas\"></canvas>\n\n<div id=\"info\">\n  <p><strong>Instructions:</strong></p>\n  <ul style=\"list-style: inside disc; max-width: 600px; margin: 0 auto; text-align: left;\">\n    <li>Click on the canvas area to add points (data).</li>\n    <li>Set the number of clusters (k) you want to group points into.</li>\n    <li>Click \"Run K-Means\" to perform clustering.</li>\n    <li>Clusters show colored circles; centroids marked with larger star shapes.</li>\n    <li>You can \"Reset Clusters\" to assign new initial centroids and run again on same points.</li>\n    <li>\"Clear Points\" erases all points and clusters for a fresh start.</li>\n  </ul>\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const runBtn = document.getElementById(\"runBtn\");\n  const resetBtn = document.getElementById(\"resetBtn\");\n  const resetPointsBtn = document.getElementById(\"resetPoints\");\n  const kInput = document.getElementById(\"kInput\");\n\n  const width = canvas.width;\n  const height = canvas.height;\n\n  let points = [];\n  let clusters = [];\n  let centroids = [];\n  let assignments = [];\n\n  // Colors for clusters (max 10 distinct colors for k â‰¤ 10)\n  const colors = [\n    \"#e6194b\", \"#3cb44b\", \"#ffe119\", \"#4363d8\", \"#f58231\",\n    \"#911eb4\", \"#46f0f0\", \"#f032e6\", \"#bcf60c\", \"#fabebe\"\n  ];\n\n  // Add point on canvas click\n  canvas.addEventListener(\"click\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    points.push({ x, y });\n    assignments = []; // clear previous assignments\n    centroids = [];\n    clusters = [];\n    draw();\n  });\n\n  // Reset everything\n  resetPointsBtn.onclick = () => {\n    points = [];\n    centroids = [];\n    clusters = [];\n    assignments = [];\n    draw();\n  };\n\n  // Run K-means clustering main steps\n  runBtn.onclick = () => {\n    const k = parseInt(kInput.value);\n    if (!points.length) {\n      alert(\"Please add some points by clicking on the canvas first.\");\n      return;\n    }\n    if (k < 1 || k > 10) {\n      alert(\"Please choose a number of clusters (k) between 1 and 10.\");\n      return;\n    }\n    if (k > points.length) {\n      alert(\"Number of clusters can't exceed number of points.\");\n      return;\n    }\n    kMeans(points, k);\n  };\n\n  // Reset centroids and clusters without removing points (to re-run)\n  resetBtn.onclick = () => {\n    const k = parseInt(kInput.value);\n    if (!points.length) {\n      alert(\"Please add some points first.\");\n      return;\n    }\n    if (k < 1 || k > 10) {\n      alert(\"Please choose a number of clusters (k) between 1 and 10.\");\n      return;\n    }\n    if (k > points.length) {\n      alert(\"Number of clusters can't exceed number of points.\");\n      return;\n    }\n    // Just reset clusters, assign new centroids randomly, no iterations yet\n    initCentroidsAndAssign(points, k);\n    draw();\n  };\n\n  // Draw points and clusters\n  function draw() {\n    ctx.clearRect(0, 0, width, height);\n\n    // Cluster coloring if assignments exist\n    if (assignments.length === points.length && centroids.length > 0) {\n      // Draw points colored by cluster\n      points.forEach((pt, i) => {\n        const clusterIndex = assignments[i];\n        ctx.fillStyle = colors[clusterIndex];\n        ctx.beginPath();\n        ctx.arc(pt.x, pt.y, 5, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.strokeStyle = \"#333\";\n        ctx.stroke();\n      });\n\n      // Draw centroids\n      centroids.forEach((c, i) => {\n        drawStar(ctx, c.x, c.y, 10, 5, colors[i], \"#000\");\n      });\n\n    } else {\n      // No cluster assignments yet - draw points as black dots\n      points.forEach(pt => {\n        ctx.fillStyle = \"#000\";\n        ctx.beginPath();\n        ctx.arc(pt.x, pt.y, 5, 0, 2 * Math.PI);\n        ctx.fill();\n      });\n    }\n  }\n\n  // Draw a star shape (for centroids)\n  // x,y: center; radius: outer radius; points: number of star points\n  // fillStyle: fill color, strokeStyle: outline color\n  function drawStar(ctx, x, y, radius, points, fillStyle, strokeStyle) {\n    const step = Math.PI / points;\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    for (let i = 0; i < 2 * points; i++) {\n      const r = (i % 2) === 0 ? radius : radius / 2;\n      const a = i * step;\n      ctx.lineTo(x + r * Math.cos(a), y + r * Math.sin(a));\n    }\n    ctx.closePath();\n    ctx.fillStyle = fillStyle;\n    ctx.fill();\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = 1.5;\n    ctx.stroke();\n  }\n\n  // Initialize centroids randomly from points and assign points to clusters\n  function initCentroidsAndAssign(points, k) {\n    centroids = [];\n    // Pick k unique random points as initial centroids\n    const shuffled = points.slice();\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    centroids = shuffled.slice(0, k).map(p => ({ x: p.x, y: p.y }));\n\n    assignments = new Array(points.length).fill(-1);\n    assignPointsToClusters(points, centroids, assignments);\n  }\n\n  // Assign each point to the nearest centroid\n  function assignPointsToClusters(points, centroids, assignments) {\n    points.forEach((pt, i) => {\n      let minDist = Infinity;\n      let clusterIndex = -1;\n      centroids.forEach((c, ci) => {\n        const d = dist(pt, c);\n        if (d < minDist) {\n          minDist = d;\n          clusterIndex = ci;\n        }\n      });\n      assignments[i] = clusterIndex;\n    });\n  }\n\n  // Update centroid positions as mean of assigned points\n  // Returns true if centroids moved more than a tiny threshold\n  function updateCentroids(points, centroids, assignments, k) {\n    const newCentroids = new Array(k).fill(null).map(() => ({ x: 0, y: 0, count: 0 }));\n    \n    points.forEach((pt, i) => {\n      const cluster = assignments[i];\n      if(cluster >= 0) {\n        newCentroids[cluster].x += pt.x;\n        newCentroids[cluster].y += pt.y;\n        newCentroids[cluster].count++;\n      }\n    });\n\n    let moved = false;\n    for(let i=0; i<k; i++) {\n      if (newCentroids[i].count === 0) {\n        // no points assigned to this centroid; don't move it\n        continue;\n      }\n      const avgX = newCentroids[i].x / newCentroids[i].count;\n      const avgY = newCentroids[i].y / newCentroids[i].count;\n      if (dist({x: avgX, y: avgY}, centroids[i]) > 1e-4) {\n        moved = true;\n        centroids[i].x = avgX;\n        centroids[i].y = avgY;\n      }\n    }\n    return moved;\n  }\n\n  // Euclidean distance between two points\n  function dist(a, b) {\n    return Math.hypot(a.x - b.x, a.y - b.y);\n  }\n\n  // K-Means iterative algorithm\n  function kMeans(points, k) {\n    initCentroidsAndAssign(points, k);\n    draw();\n\n    let iterations = 0;\n    const maxIterations = 100;\n    let moved = true;\n\n    // Animate the iterations with a slight delay\n    function step() {\n      if (!moved || iterations >= maxIterations) {\n        // Finished\n        return;\n      }\n      iterations++;\n      moved = updateCentroids(points, centroids, assignments, k);\n      assignPointsToClusters(points, centroids, assignments);\n      draw();\n      if(moved) {\n        setTimeout(step, 300);\n      }\n    }\n\n    setTimeout(step, 300);\n  }\n\n  // Initial draw to show empty canvas\n  draw();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": false,
  "hasTest": true
}