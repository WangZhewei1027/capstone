{
  "id": "20d2d6c7-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:21.944Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Prim's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; \n    padding: 0;\n    background: #f0f0f0;\n  }\n  h1 {\n    text-align: center;\n    margin: 15px 0;\n  }\n  #container {\n    display: flex;\n    justify-content: center;\n    gap: 30px;\n    flex-wrap: wrap;\n    padding: 0 20px 40px 20px;\n  }\n  #canvas-container {\n    background: #fff;\n    border: 1px solid #ccc;\n    box-shadow: 0 0 8px #bbb;\n    border-radius: 6px;\n    overflow: hidden;\n    position: relative;\n  }\n  canvas {\n    display: block;\n    background: #222;\n  }\n  #controls {\n    max-width: 350px;\n    background: #fff;\n    border-radius: 6px;\n    padding: 15px 20px 20px 20px;\n    box-shadow: 0 0 8px #bbb;\n  }\n  #controls label {\n    display: block;\n    margin-bottom: 6px;\n    font-weight: bold;\n  }\n  #controls input[type=number], #controls input[type=text] {\n    width: 100%;\n    padding: 6px 8px;\n    margin-bottom: 12px;\n    border-radius: 4px;\n    border: 1px solid #aaa;\n    box-sizing: border-box;\n  }\n  #controls button {\n    width: 100%;\n    padding: 10px 0;\n    font-weight: bold;\n    border: none;\n    border-radius: 5px;\n    background: #4CAF50;\n    color: white;\n    font-size: 1.1rem;\n    cursor: pointer;\n    user-select: none;\n  }\n  #controls button:hover {\n    background: #45a049;\n  }\n  #log {\n    margin-top: 15px;\n    max-height: 200px;\n    overflow-y: auto;\n    background: #eee;\n    border-radius: 5px;\n    padding: 8px 12px;\n    font-family: monospace;\n    white-space: pre-wrap;\n    font-size: 0.9rem;\n    line-height: 1.3;\n  }\n  .info {\n    margin-top: 10px;\n    font-size: 0.95rem;\n  }\n  a {\n    color: #555;\n  }\n  footer {\n    text-align: center;\n    padding: 15px;\n    font-size: 0.9rem;\n    color: #666;\n  }\n  /* Scrollbar for log */\n  #log::-webkit-scrollbar {\n    width: 8px;\n  }\n  #log::-webkit-scrollbar-thumb {\n    background-color: #bbb;\n    border-radius: 4px;\n  }\n</style>\n</head>\n<body>\n<h1>Prim's Algorithm - Minimum Spanning Tree Visualization</h1>\n<div id=\"container\">\n  <div id=\"canvas-container\">\n    <canvas id=\"graphCanvas\" width=\"700\" height=\"500\" aria-label=\"Graph visualization\"></canvas>\n  </div>\n  <div id=\"controls\" aria-label=\"Controls for Prim's algorithm\">\n    <label for=\"nodesCount\">Number of Nodes (3 - 20):</label>\n    <input type=\"number\" id=\"nodesCount\" min=\"3\" max=\"20\" value=\"8\" />\n    \n    <label for=\"density\">Edge Density (0.2 - 1.0):</label>\n    <input type=\"number\" id=\"density\" min=\"0.2\" max=\"1\" step=\"0.05\" value=\"0.8\" />\n    \n    <label for=\"maxWeight\">Max Edge Weight (1 - 20):</label>\n    <input type=\"number\" id=\"maxWeight\" min=\"1\" max=\"20\" value=\"15\" />\n    \n    <button id=\"generateGraphBtn\">Generate Random Graph</button>\n    <button id=\"startPrimBtn\" disabled>Start Prim's Algorithm</button>\n    <button id=\"stepPrimBtn\" disabled>Step</button>\n    <button id=\"resetBtn\" disabled>Reset</button>\n    <div class=\"info\" aria-live=\"polite\" id=\"status\">Status: Waiting to generate graph.</div>\n    <div id=\"log\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n  </div>\n</div>\n<footer>\n  Visualization of Prim's algorithm to find Minimum Spanning Tree on a weighted undirected graph.\n</footer>\n<script>\n(() => {\n  // Canvas and drawing context\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n  const W = canvas.width;\n  const H = canvas.height;\n\n  // Controls and log elements\n  const nodesCountInput = document.getElementById('nodesCount');\n  const densityInput = document.getElementById('density');\n  const maxWeightInput = document.getElementById('maxWeight');\n  const generateGraphBtn = document.getElementById('generateGraphBtn');\n  const startPrimBtn = document.getElementById('startPrimBtn');\n  const stepPrimBtn = document.getElementById('stepPrimBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const statusDiv = document.getElementById('status');\n  const logDiv = document.getElementById('log');\n\n  // Graph data structures\n  let nodes = [];\n  let edges = [];\n  let adjacencyList = [];\n  \n  // Constants for drawing\n  const NODE_RADIUS = 18;\n  const WEIGHT_FONT = '14px monospace';\n  \n  // Prim's algorithm state\n  let primState = null;\n\n  // --- Graph generation ---\n  function randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Generate random positions for nodes ensuring minimum distance between nodes\n  function generateNodePositions(n) {\n    const positions = [];\n    const padding = NODE_RADIUS + 10;\n    const minDist = NODE_RADIUS * 4;\n\n    for (let i = 0; i < n; i++) {\n      let tries = 0;\n      let x, y;\n      do {\n        x = randomInt(padding, W - padding);\n        y = randomInt(padding, H - padding);\n        tries++;\n        if (tries > 1000) break; // fallback if can't fulfill conditions\n      } while (positions.some(p => distance(p.x, p.y, x, y) < minDist));\n      positions.push({x, y});\n    }\n    return positions;\n  }\n\n  // Calculate Euclidean distance between two points\n  function distance(x1, y1, x2, y2) {\n    return Math.sqrt((x2-x1)**2 + (y2-y1)**2);\n  }\n\n  // Generate an undirected weighted graph\n  // Uses density parameter to control how many edges exist.\n  // Ensures graph connectivity by first generating a random spanning tree.\n  function generateGraph(n, density, maxWeight) {\n    nodes = [];\n    edges = [];\n    adjacencyList = [];\n    primState = null;\n\n    // Prepare nodes with positions\n    const positions = generateNodePositions(n);\n    for(let i=0; i<n; i++){\n      nodes.push({id: i, x: positions[i].x, y: positions[i].y});\n      adjacencyList.push([]);\n    }\n\n    // Ensure connectivity by creating a random spanning tree first:\n    // Using a randomized version of Prim or simple random linking\n    let connected = [0];\n    let disconnected = [];\n    for(let i=1; i<n; i++) disconnected.push(i);\n\n    while(disconnected.length > 0){\n      // Pick random node from connected\n      const fromId = connected[randomInt(0, connected.length -1)];\n      // Pick random node from disconnected\n      const idx = randomInt(0, disconnected.length -1);\n      const toId = disconnected[idx];\n      disconnected.splice(idx,1);\n      connected.push(toId);\n\n      // create edge between fromId and toId\n      const w = randomInt(1, maxWeight);\n      addEdge(fromId, toId, w);\n    }\n\n    // Add additional edges according to density (up to (n*(n-1)/2) edges)\n    // total possible edges: n*(n-1)/2\n    const totalPossibleEdges = n*(n-1)/2;\n    const targetEdgesCount = Math.floor(totalPossibleEdges * density);\n    // We have currently n-1 edges from spanning tree\n    let currentEdgesCount = edges.length;\n    // Try to add edges randomly if not already present\n    function edgeKey(a,b){ return a < b ? a + '-' + b : b + '-' + a; }\n    const existingEdgesSet = new Set(edges.map(e => edgeKey(e.from, e.to)));\n\n    while(currentEdgesCount < targetEdgesCount){\n      const a = randomInt(0, n-1);\n      const b = randomInt(0, n-1);\n      if(a === b) continue;\n      const k = edgeKey(a,b);\n      if(existingEdgesSet.has(k)) continue;\n\n      // Add edge\n      const w = randomInt(1, maxWeight);\n      addEdge(a,b,w);\n      existingEdgesSet.add(k);\n      currentEdgesCount++;\n    }\n\n    // Prepare adjacency list (undirected)\n    adjacencyList = [];\n    for(let i=0; i<n; i++) adjacencyList.push([]);\n    for(const e of edges){\n      adjacencyList[e.from].push({to: e.to, weight: e.weight});\n      adjacencyList[e.to].push({to: e.from, weight: e.weight});\n    }\n  }\n\n  // Add undirected edge to edges array\n  function addEdge(from, to, weight){\n    edges.push({from, to, weight});\n  }\n\n  // --- Drawing functions ---\n\n  // Clear canvas\n  function clearCanvas(){\n    ctx.clearRect(0,0,W,H);\n  }\n\n  // Draw an edge, color can be specified (default: faded white)\n  function drawEdge(edge, color='rgba(255,255,255,0.4)', lineWidth=2, dashed=false){\n    const fromNode = nodes[edge.from];\n    const toNode = nodes[edge.to];\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    if(dashed){\n      ctx.setLineDash([8,6]);\n    } else {\n      ctx.setLineDash([]);\n    }\n    ctx.beginPath();\n    ctx.moveTo(fromNode.x, fromNode.y);\n    ctx.lineTo(toNode.x, toNode.y);\n    ctx.stroke();\n\n    // Draw edge weight midpoint\n    const wx = (fromNode.x + toNode.x)/2;\n    const wy = (fromNode.y + toNode.y)/2;\n\n    ctx.font = WEIGHT_FONT;\n    ctx.fillStyle = color;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    // Background for readability\n    ctx.fillStyle = 'rgba(0,0,0,0.6)';\n    ctx.fillRect(wx-12, wy-11, 24, 22);\n\n    ctx.fillStyle = color;\n    ctx.fillText(edge.weight, wx, wy+1);\n  }\n\n  // Draw all edges in a \"base\" style\n  function drawAllEdges(){\n    edges.forEach(e => drawEdge(e));\n  }\n\n  // Draw a node with specified color and label\n  function drawNode(node, options = {}){\n    const {color = '#ddd', borderColor = '#555', radius = NODE_RADIUS, labelColor='#fff', highlight=false} = options;\n    ctx.beginPath();\n    ctx.fillStyle = color;\n    ctx.strokeStyle = borderColor;\n    ctx.lineWidth = highlight ? 4 : 2;\n    ctx.shadowColor = highlight ? '#fff' : 'transparent';\n    ctx.shadowBlur = highlight ? 10 : 0;\n    ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.stroke();\n    ctx.shadowBlur = 0;\n\n    ctx.font = 'bold 16px monospace';\n    ctx.fillStyle = labelColor;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(node.id, node.x, node.y);\n  }\n\n  // Draw the full graph with MST highlighted edges and current step markings\n  function drawGraph(primState=null){\n    clearCanvas();\n\n    // Draw all edges faded\n    drawAllEdges();\n\n    if(primState){\n      // Draw MST edges highlighted in green\n      primState.mstEdges.forEach(e => {\n        drawEdge(e, '#4CAF50', 4);\n      });\n\n      // Draw edges in Min-Heap frontier possibly highlighted (yellow)\n      primState.frontier.forEach(({from,to,weight}) => {\n        drawEdge({from,to,weight}, '#ffcc33', 3, true);\n      });\n    }\n\n    // Draw all nodes, highlight those included in MST in greenish color\n    for(const node of nodes){\n      if(primState && primState.inMST.has(node.id)){\n        drawNode(node, {color:'#4CAF50', borderColor:'#2e7d32', labelColor:'#e8f5e9', highlight:true});\n      } else {\n        drawNode(node);\n      }\n    }\n  }\n\n  // --- Prim's Algorithm Implementation ---\n\n  class MinHeap {\n    constructor(){\n      this.heap = [];\n    }\n\n    size(){ return this.heap.length; }\n\n    push(item){\n      this.heap.push(item);\n      this.bubbleUp(this.heap.length -1);\n    }\n    pop(){\n      if(this.heap.length ===0) return null;\n      const top = this.heap[0];\n      const end = this.heap.pop();\n      if(this.heap.length >0){\n        this.heap[0] = end;\n        this.bubbleDown(0);\n      }\n      return top;\n    }\n    bubbleUp(idx){\n      while(idx >0){\n        const parent = Math.floor((idx-1)/2);\n        if(this.heap[parent].weight <= this.heap[idx].weight) break;\n        [this.heap[parent], this.heap[idx]] = [this.heap[idx], this.heap[parent]];\n        idx = parent;\n      }\n    }\n    bubbleDown(idx){\n      const length = this.heap.length;\n      while(true){\n        let left = idx * 2 + 1;\n        let right = idx * 2 + 2;\n        let smallest = idx;\n        if(left < length && this.heap[left].weight < this.heap[smallest].weight){\n          smallest = left;\n        }\n        if(right < length && this.heap[right].weight < this.heap[smallest].weight){\n          smallest = right;\n        }\n        if(smallest === idx) break;\n        [this.heap[smallest], this.heap[idx]] = [this.heap[idx], this.heap[smallest]];\n        idx = smallest;\n      }\n    }\n  }\n\n  // Initialize Prim's algorithm state\n  function initPrim(startNode=0){\n    if(nodes.length === 0) return null;\n\n    return {\n      startNode,\n      inMST: new Set(),\n      mstEdges: [],\n      frontier: [], // edges candidates, but keep them as list to draw\n      minHeap: new MinHeap(),\n      stepCount: 0,\n      logLines: [],\n      currentEdge: null,\n    };\n  }\n\n  // Execute one step of Prim's Algorithm\n  // Returns false if finished, true if more steps available\n  function stepPrim(state){\n    // On first step, add startNode to MST and add all its adjacent edges to heap\n    if(state.stepCount === 0){\n      const s = state.startNode;\n      state.inMST.add(s);\n      for(const edge of adjacencyList[s]){\n        state.minHeap.push({from: s, to: edge.to, weight: edge.weight});\n      }\n      state.logLines.push(`Start from node ${s}`);\n      state.stepCount++;\n      return true;\n    }\n\n    // Remove edges from heap while both ends are in MST to prevent cycle:\n    let edge;\n    while(true){\n      if(state.minHeap.size() === 0){\n        state.currentEdge = null;\n        return false; // done\n      }\n      edge = state.minHeap.pop();\n      if(!state.inMST.has(edge.to)){\n        state.currentEdge = edge;\n        break;\n      }\n      // else ignore this edge because it leads to a node already in MST (reject cycle)\n    }\n    if(!edge) return false;\n\n    // Add edge to MST\n    state.mstEdges.push(edge);\n    state.inMST.add(edge.to);\n    state.logLines.push(`Include edge (${edge.from} - ${edge.to}) with weight ${edge.weight}`);\n\n    // Add all edges adjacent to the newly added node with endpoint outside MST\n    for(const adj of adjacencyList[edge.to]){\n      if(!state.inMST.has(adj.to)){\n        state.minHeap.push({from: edge.to, to: adj.to, weight: adj.weight});\n      }\n    }\n\n    state.stepCount++;\n    return true;\n  }\n\n  // Update controls and buttons states\n  function updateControlsOnGraphGenerated(){\n    startPrimBtn.disabled = false;\n    stepPrimBtn.disabled = true;\n    resetBtn.disabled = true;\n    generateGraphBtn.disabled = false;\n    statusDiv.textContent = 'Status: Graph generated. Ready to start Prim\\'s algorithm.';\n  }\n\n  function updateControlsOnPrimStarted(){\n    startPrimBtn.disabled = true;\n    stepPrimBtn.disabled = false;\n    resetBtn.disabled = false;\n    generateGraphBtn.disabled = true;\n    statusDiv.textContent = 'Status: Prim\\'s algorithm started. Use Step to advance.';\n  }\n\n  function updateControlsOnPrimFinished(){\n    stepPrimBtn.disabled = true;\n    startPrimBtn.disabled = true;\n    resetBtn.disabled = false;\n    generateGraphBtn.disabled = false;\n    statusDiv.textContent = 'Status: Prim\\'s algorithm finished! MST complete.';\n  }\n\n  // Handle generate graph click\n  generateGraphBtn.addEventListener('click', () => {\n    const n = parseInt(nodesCountInput.value);\n    const density = parseFloat(densityInput.value);\n    const maxW = parseInt(maxWeightInput.value);\n\n    if(isNaN(n) || n < 3 || n > 20) {\n      alert('Number of nodes must be between 3 and 20');\n      return;\n    }\n    if(isNaN(density) || density < 0.2 || density > 1){\n      alert('Density must be between 0.2 and 1.0');\n      return;\n    }\n    if(isNaN(maxW) || maxW < 1 || maxW > 20){\n      alert('Max weight must be between 1 and 20');\n      return;\n    }\n    generateGraph(n, density, maxW);\n    primState = null;\n    drawGraph();\n    logDiv.textContent = '';\n    updateControlsOnGraphGenerated();\n  });\n\n  // Handle start Prim's algorithm click\n  startPrimBtn.addEventListener('click', () => {\n    if(nodes.length === 0){\n      alert('Generate a graph first!');\n      return;\n    }\n    primState = initPrim(0);\n    stepPrim(primState); // first step auto\n    drawGraph(primState);\n    updateControlsOnPrimStarted();\n    updateLog(primState);\n  });\n\n  // Handle step click\n  stepPrimBtn.addEventListener('click', () => {\n    if(!primState){\n      alert('Start Prim\\'s algorithm first!');\n      return;\n    }\n    const moreSteps = stepPrim(primState);\n    drawGraph(primState);\n    updateLog(primState);\n    if(!moreSteps){\n      updateControlsOnPrimFinished();\n    }\n  });\n\n  // Handle reset click\n  resetBtn.addEventListener('click', () => {\n    primState = null;\n    drawGraph();\n    logDiv.textContent = '';\n    startPrimBtn.disabled = false;\n    stepPrimBtn.disabled = true;\n    resetBtn.disabled = true;\n    generateGraphBtn.disabled = false;\n    statusDiv.textContent = 'Status: Reset done. Ready to start again or generate a new graph.';\n  });\n\n  // Update log display from primState.logLines\n  function updateLog(state){\n    logDiv.textContent = state.logLines.join('\\n');\n    logDiv.scrollTop = logDiv.scrollHeight;\n  }\n\n  // Initial screen\n  drawGraph();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}