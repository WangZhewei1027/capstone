{
  "id": "7abeaa2c-cd32-11f0-a96f-2d591ffb35fe",
  "timestamp": "2025-11-29T14:49:31.788Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Breadth-First Search (BFS) Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f0f0f0;\n  }\n  h1 {\n    text-align: center;\n  }\n  #graph-container {\n    display: flex;\n    justify-content: center;\n    margin-bottom: 20px;\n  }\n  svg {\n    border: 1px solid #ccc;\n    background: #fff;\n    border-radius: 8px;\n  }\n  circle.node {\n    fill: #3498db;\n    stroke: #2980b9;\n    stroke-width: 2px;\n    cursor: pointer;\n    transition: fill 0.3s;\n  }\n  circle.node.visited {\n    fill: #2ecc71;\n  }\n  circle.node.current {\n    fill: #e67e22;\n  }\n  text.nodelabel {\n    font-size: 14px;\n    pointer-events: none;\n    fill: #fff;\n    font-weight: bold;\n    user-select: none;\n  }\n  line.edge {\n    stroke: #ccc;\n    stroke-width: 2;\n  }\n  #controls {\n    max-width: 400px;\n    margin: 0 auto 40px;\n    background: #fff;\n    padding: 15px 20px;\n    border-radius: 8px;\n    box-shadow: 0 0 10px rgba(0,0,0,0.1);\n  }\n  #controls label {\n    display: block;\n    margin-top: 15px;\n    margin-bottom: 5px;\n    font-weight: bold;\n  }\n  #controls select, #controls button {\n    width: 100%;\n    padding: 8px 10px;\n    font-size: 16px;\n    border-radius: 5px;\n    border: 1.5px solid #ccc;\n    outline: none;\n    transition: border-color 0.3s;\n  }\n  #controls select:focus, #controls button:focus {\n    border-color: #3498db;\n  }\n  #start-bfs {\n    margin-top: 20px;\n    background: #3498db;\n    color: white;\n    border: none;\n    cursor: pointer;\n    font-weight: bold;\n  }\n  #start-bfs:disabled {\n    background: #aaa;\n    cursor: not-allowed;\n  }\n  #bfs-output {\n    max-width: 600px;\n    margin: 0 auto;\n    background: #fff;\n    padding: 15px 20px;\n    border-radius: 8px;\n    font-family: monospace;\n    white-space: pre-wrap;\n    min-height: 50px;\n    box-shadow: inset 0 0 10px #ddd;\n  }\n  #reset-button {\n    margin-top: 10px;\n    background: #e74c3c;\n    color: white;\n    border: none;\n    cursor: pointer;\n    font-weight: bold;\n    padding: 8px 10px;\n    width: 100%;\n    border-radius: 5px;\n  }\n  #legend {\n    max-width: 600px;\n    margin: 0 auto 40px;\n    background: #fff;\n    padding: 15px 20px;\n    border-radius: 8px;\n    box-shadow: 0 0 10px rgba(0,0,0,0.1);\n    display: flex;\n    justify-content: space-around;\n    font-size: 14px;\n  }\n  .legend-item {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n  }\n  .legend-color {\n    width: 20px;\n    height: 20px;\n    border-radius: 50%;\n  }\n  .color-notvisited {\n    background: #3498db;\n    border: 2px solid #2980b9;\n  }\n  .color-visited {\n    background: #2ecc71;\n  }\n  .color-current {\n    background: #e67e22;\n  }\n</style>\n</head>\n<body>\n<h1>Breadth-First Search (BFS) Visualization</h1>\n\n<div id=\"legend\">\n  <div class=\"legend-item\"><div class=\"legend-color color-notvisited\"></div> Not Visited</div>\n  <div class=\"legend-item\"><div class=\"legend-color color-current\"></div> Currently Visiting</div>\n  <div class=\"legend-item\"><div class=\"legend-color color-visited\"></div> Visited</div>\n</div>\n\n<div id=\"graph-container\">\n  <svg id=\"graph\" width=\"600\" height=\"400\"></svg>\n</div>\n\n<div id=\"controls\">\n  <label for=\"start-node\">Select Start Node:</label>\n  <select id=\"start-node\"></select>\n\n  <button id=\"start-bfs\">Start BFS</button>\n  <button id=\"reset-button\" style=\"display:none;\">Reset Graph</button>\n</div>\n\n<div id=\"bfs-output\" aria-live=\"polite\" aria-atomic=\"true\">\n  BFS traversal order will appear here...\n</div>\n\n<script>\n(() => {\n  const svg = document.getElementById('graph');\n  const startNodeSelect = document.getElementById('start-node');\n  const startBFSButton = document.getElementById('start-bfs');\n  const resetButton = document.getElementById('reset-button');\n  const bfsOutput = document.getElementById('bfs-output');\n\n  // Define a graph as adjacency list:\n  // We'll create a simple undirected graph with nodes and edges.\n\n  const nodes = [\n    { id: 'A', x: 100, y: 100 },\n    { id: 'B', x: 250, y: 70 },\n    { id: 'C', x: 400, y: 100 },\n    { id: 'D', x: 100, y: 250 },\n    { id: 'E', x: 250, y: 250 },\n    { id: 'F', x: 400, y: 250 },\n    { id: 'G', x: 520, y: 180 },\n    { id: 'H', x: 520, y: 300 }\n  ];\n\n  // Adjacency list (undirected)\n  const edges = [\n    ['A', 'B'],\n    ['A', 'D'],\n    ['B', 'C'],\n    ['B', 'E'],\n    ['C', 'F'],\n    ['D', 'E'],\n    ['E', 'F'],\n    ['F', 'G'],\n    ['F', 'H']\n  ];\n\n  // Build adjacency map for quick lookup\n  const adjacency = {};\n  nodes.forEach(n => adjacency[n.id] = []);\n  edges.forEach(([a,b]) => {\n    adjacency[a].push(b);\n    adjacency[b].push(a);\n  });\n\n  // States for the nodes for coloring:\n  // \"notvisited\", \"current\", \"visited\"\n  const nodeStates = {};\n  nodes.forEach(n => nodeStates[n.id] = 'notvisited');\n\n  function createEdgeLine(x1, y1, x2, y2) {\n    const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    line.setAttribute(\"class\", \"edge\");\n    line.setAttribute(\"x1\", x1);\n    line.setAttribute(\"y1\", y1);\n    line.setAttribute(\"x2\", x2);\n    line.setAttribute(\"y2\", y2);\n    return line;\n  }\n\n  function createNodeCircle(node) {\n    const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    circle.setAttribute(\"class\", \"node\");\n    circle.setAttribute(\"id\", \"node-\"+node.id);\n    circle.setAttribute(\"cx\", node.x);\n    circle.setAttribute(\"cy\", node.y);\n    circle.setAttribute(\"r\", 25);\n    circle.setAttribute(\"tabindex\", 0);\n    circle.setAttribute(\"aria-label\", `Node ${node.id}. Click to select as start node.`);\n    circle.setAttribute(\"role\", \"button\");\n    return circle;\n  }\n\n  function createNodeLabel(node) {\n    const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    text.setAttribute(\"class\", \"nodelabel\");\n    text.setAttribute(\"x\", node.x);\n    text.setAttribute(\"y\", node.y+6); // roughly center vertically on circle\n    text.setAttribute(\"text-anchor\", \"middle\");\n    text.textContent = node.id;\n    return text;\n  }\n\n  // Draw graph\n  function drawGraph() {\n    // Clear svg first\n    while (svg.firstChild) {\n      svg.removeChild(svg.firstChild);\n    }\n    // Draw edges first\n    edges.forEach(([a,b]) => {\n      const nodeA = nodes.find(n => n.id === a);\n      const nodeB = nodes.find(n => n.id === b);\n      svg.appendChild(createEdgeLine(nodeA.x, nodeA.y, nodeB.x, nodeB.y));\n    });\n    // Draw nodes\n    nodes.forEach(node => {\n      svg.appendChild(createNodeCircle(node));\n      svg.appendChild(createNodeLabel(node));\n    });\n  }\n\n  // Update colors based on state\n  function updateNodeColors() {\n    nodes.forEach(n => {\n      const circle = document.getElementById(\"node-\"+n.id);\n      circle.classList.remove(\"visited\", \"current\");\n      if(nodeStates[n.id] === 'visited') {\n        circle.classList.add(\"visited\");\n      } else if(nodeStates[n.id] === 'current') {\n        circle.classList.add(\"current\");\n      }\n    });\n  }\n\n  // Populate start node options\n  function populateStartNodeOptions() {\n    startNodeSelect.innerHTML = '';\n    nodes.forEach(n => {\n      const option = document.createElement('option');\n      option.value = n.id;\n      option.textContent = n.id;\n      startNodeSelect.appendChild(option);\n    });\n  }\n\n  // Highlight selected start node in dropdown and on graph circle\n  function highlightSelectedStartNode(id) {\n    nodes.forEach(n => {\n      const circle = document.getElementById(\"node-\"+n.id);\n      if(n.id === id) {\n        circle.setAttribute(\"stroke-width\", 4);\n        circle.setAttribute(\"stroke\", \"#f1c40f\");\n      } else {\n        circle.setAttribute(\"stroke-width\", 2);\n        circle.setAttribute(\"stroke\", \"#2980b9\");\n      }\n    });\n  }\n\n  // Run BFS with delay to show steps\n  async function bfs(startId) {\n    // Reset states\n    nodes.forEach(n => nodeStates[n.id] = 'notvisited');\n    updateNodeColors();\n\n    const visitedOrder = [];\n    const queue = [];\n    const visited = new Set();\n\n    queue.push(startId);\n    visited.add(startId);\n\n    bfsOutput.textContent = \"Starting BFS from node \" + startId + \"...\\n\";\n\n    while(queue.length > 0) {\n      const current = queue.shift();\n      // Mark current\n      nodeStates[current] = 'current';\n      updateNodeColors();\n\n      bfsOutput.textContent += `Visiting Node ${current}\\n`;\n      visitedOrder.push(current);\n\n      // Wait so user can see the step\n      await delay(1000);\n\n      // Mark visited\n      nodeStates[current] = 'visited';\n      updateNodeColors();\n\n      for (const neighbor of adjacency[current]) {\n        if (!visited.has(neighbor)) {\n          queue.push(neighbor);\n          visited.add(neighbor);\n          // Optional: could highlight neighbor queue addition here if desired\n        }\n      }\n      await delay(400);\n    }\n\n    bfsOutput.textContent += \"\\nBFS Traversal Completed.\\nOrder: \" + visitedOrder.join(\" â†’ \");\n    return visitedOrder;\n  }\n\n  function delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Event handlers\n  startBFSButton.addEventListener('click', async () => {\n    const startId = startNodeSelect.value;\n    startBFSButton.disabled = true;\n    resetButton.style.display = 'block';\n    startNodeSelect.disabled = true;\n    highlightSelectedStartNode(startId);\n\n    await bfs(startId);\n\n    startBFSButton.disabled = true;\n  });\n\n  resetButton.addEventListener('click', () => {\n    // Reset states and UI\n    nodes.forEach(n => nodeStates[n.id] = 'notvisited');\n    updateNodeColors();\n    bfsOutput.textContent = \"BFS traversal order will appear here...\";\n    startBFSButton.disabled = false;\n    resetButton.style.display = 'none';\n    startNodeSelect.disabled = false;\n    highlightSelectedStartNode(null);\n  });\n\n  // Clicking a node sets start node select\n  svg.addEventListener('click', e => {\n    if(e.target.classList.contains('node') && !startBFSButton.disabled) {\n      const id = e.target.id.replace('node-', '');\n      startNodeSelect.value = id;\n      highlightSelectedStartNode(id);\n      startNodeSelect.focus();\n    }\n  });\n\n  // Keyboard support for nodes (Enter / Space to select)\n  svg.addEventListener('keydown', e => {\n    if((e.key === 'Enter' || e.key === ' ') && e.target.classList.contains('node') && !startBFSButton.disabled) {\n      e.preventDefault();\n      const id = e.target.id.replace('node-', '');\n      startNodeSelect.value = id;\n      highlightSelectedStartNode(id);\n      startNodeSelect.focus();\n    }\n  });\n\n  startNodeSelect.addEventListener('change', (e) => {\n    highlightSelectedStartNode(e.target.value);\n  });\n\n  // Initial draw\n  drawGraph();\n  populateStartNodeOptions();\n  highlightSelectedStartNode(startNodeSelect.value || nodes[0].id);\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": false,
  "hasTest": true
}