{
  "id": "20d288a3-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:35.878Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Graph Visualization (Directed / Undirected)</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    padding: 0;\n    display:flex;\n    height: 100vh;\n    flex-direction: column;\n    background: #f0f0f0;\n  }\n  header {\n    padding: 1rem;\n    background: #333;\n    color: white;\n    text-align: center;\n    font-weight: bold;\n  }\n  #controls {\n    background: white;\n    padding: 1rem;\n    display: flex;\n    justify-content: center;\n    gap: 1rem;\n    flex-wrap: wrap;\n  }\n  label {\n    font-weight: 600;\n  }\n  select, button {\n    padding: 0.3rem 0.6rem;\n    font-size: 1rem;\n  }\n  #canvas-container {\n    flex-grow: 1;\n    background: white;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  canvas {\n    background: #fff;\n    border: 1px solid #ccc;\n    max-width: 100%;\n    max-height: 100%;\n  }\n  #legend {\n    padding: 0.5rem 1rem;\n    background: #fafafa;\n    border-top: 1px solid #ccc;\n    font-size: 0.9rem;\n    color: #555;\n  }\n</style>\n</head>\n<body>\n<header>Graph Visualization (Directed / Undirected)</header>\n<div id=\"controls\">\n  <label for=\"graphType\">Graph Type:</label>\n  <select id=\"graphType\">\n    <option value=\"directed\">Directed</option>\n    <option value=\"undirected\" selected>Undirected</option>\n  </select>\n  <button id=\"randomGraphBtn\">Generate Random Graph</button>\n  <button id=\"clearBtn\">Clear Graph</button>\n</div>\n<div id=\"canvas-container\">\n  <canvas id=\"graphCanvas\" width=\"800\" height=\"600\"></canvas>\n</div>\n<div id=\"legend\">\n  <strong>Instructions:</strong> Drag nodes to reposition. Click on empty space to add a node. Click a node then another node to add an edge. Edges appear with arrows if directed graph.\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n\n  let nodes = [];\n  let edges = [];\n  let graphType = 'undirected';\n\n  const NODE_RADIUS = 20;\n\n  // State for interaction\n  let dragNode = null;\n  let dragOffset = { x: 0, y: 0 };\n\n  let addingEdge = null; // node id where edge starts\n\n  function distance(x1, y1, x2, y2) {\n    return Math.hypot(x2 - x1, y2 - y1);\n  }\n\n  function findNodeAtPosition(x, y) {\n    return nodes.find(n => distance(n.x, n.y, x, y) <= NODE_RADIUS);\n  }\n\n  function drawNode(node) {\n    ctx.beginPath();\n    ctx.fillStyle = '#00aaff';\n    ctx.strokeStyle = '#005577';\n    ctx.lineWidth = 2;\n    ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 14px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(node.id, node.x, node.y);\n  }\n\n  // Arrow drawing utility\n  function drawArrow(fromX, fromY, toX, toY, color='#000', arrowSize=10) {\n    const angle = Math.atan2(toY - fromY, toX - fromX);\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    ctx.lineWidth = 2;\n\n    // Line from from -> to but shortened so arrow head fits inside node radius\n    const offsetFromX = fromX + Math.cos(angle) * NODE_RADIUS;\n    const offsetFromY = fromY + Math.sin(angle) * NODE_RADIUS;\n    const offsetToX = toX - Math.cos(angle) * NODE_RADIUS;\n    const offsetToY = toY - Math.sin(angle) * NODE_RADIUS;\n\n    ctx.beginPath();\n    ctx.moveTo(offsetFromX, offsetFromY);\n    ctx.lineTo(offsetToX, offsetToY);\n    ctx.stroke();\n\n    // Draw arrow head at end\n    ctx.beginPath();\n    ctx.moveTo(offsetToX, offsetToY);\n    ctx.lineTo(\n      offsetToX - arrowSize * Math.cos(angle - Math.PI / 6),\n      offsetToY - arrowSize * Math.sin(angle - Math.PI / 6)\n    );\n    ctx.lineTo(\n      offsetToX - arrowSize * Math.cos(angle + Math.PI / 6),\n      offsetToY - arrowSize * Math.sin(angle + Math.PI / 6)\n    );\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // For undirected edges, draw simple line connecting circles edges\n  // but we offset line endpoints so that line doesn't cross nodes.\n  function drawUndirectedEdge(fromNode, toNode) {\n    const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);\n    const startX = fromNode.x + Math.cos(angle) * NODE_RADIUS;\n    const startY = fromNode.y + Math.sin(angle) * NODE_RADIUS;\n    const endX = toNode.x - Math.cos(angle) * NODE_RADIUS;\n    const endY = toNode.y - Math.sin(angle) * NODE_RADIUS;\n    ctx.strokeStyle = '#222';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n  }\n\n  // Draw loop edge (same node to itself)\n  function drawLoop(node, directed) {\n    const x = node.x;\n    const y = node.y;\n    const radius = NODE_RADIUS;\n    const loopRadius = 15;\n\n    ctx.strokeStyle = '#222';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.arc(x, y - radius - loopRadius, loopRadius, 0, Math.PI * 1.5);\n    ctx.stroke();\n\n    if (directed) {\n      // Draw arrowhead pointing down-left\n      const arrowX = x - loopRadius;\n      const arrowY = y - radius - loopRadius / 2;\n      ctx.fillStyle = '#000';\n      ctx.beginPath();\n      ctx.moveTo(arrowX, arrowY);\n      ctx.lineTo(arrowX - 8, arrowY - 5);\n      ctx.lineTo(arrowX - 8, arrowY + 5);\n      ctx.closePath();\n      ctx.fill();\n    }\n  }\n\n  // For undirected edges between same two nodes, we draw one line.\n  // For directed edges in opposite directions, draw two arrows with slight curve for clarity.\n\n  // To handle multiple edges between same nodes and self loops visually is complex, but we do a basic version.\n\n  function drawEdges() {\n    // We'll draw undirected edges first\n    edges.forEach(edge => {\n      const fromNode = nodes.find(n => n.id === edge.from);\n      const toNode = nodes.find(n => n.id === edge.to);\n      if (!fromNode || !toNode) return;\n\n      if (edge.from === edge.to) {\n        drawLoop(fromNode, graphType === 'directed');\n        return;\n      }\n\n      if (graphType === 'undirected') {\n        drawUndirectedEdge(fromNode, toNode);\n      } else {\n        // Directed: draw arrow from fromNode to toNode\n        drawArrow(fromNode.x, fromNode.y, toNode.x, toNode.y);\n      }\n    });\n  }\n\n  function drawGraph() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    drawEdges();\n    nodes.forEach(drawNode);\n\n    // If adding edge: draw a line from selected node to current mouse (if mouse pos known)\n    if (addingEdge && mousePos) {\n      const fromNode = nodes.find(n => n.id === addingEdge);\n      if (fromNode) {\n        ctx.strokeStyle = 'orange';\n        ctx.fillStyle = 'orange';\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(fromNode.x, fromNode.y);\n        ctx.lineTo(mousePos.x, mousePos.y);\n        ctx.stroke();\n      }\n    }\n  }\n\n  // Generate a new node ID (number)\n  function getNextNodeId() {\n    let id = 1;\n    while (nodes.find(n => n.id === id.toString())) {\n      id++;\n    }\n    return id.toString();\n  }\n\n  function addNode(x, y) {\n    const id = getNextNodeId();\n    nodes.push({ id, x, y });\n  }\n\n  function addEdge(from, to) {\n    // For undirected, prevent duplicate edges (from->to or to->from)\n    if (graphType === 'undirected') {\n      if (edges.find(e => (e.from === from && e.to === to) || (e.from === to && e.to === from))) {\n        return; // already exists\n      }\n      edges.push({ from, to });\n    } else {\n      // directed - allow multiple edges carefully but no duplicates\n      if (edges.find(e => e.from === from && e.to === to)) return;\n      edges.push({ from, to });\n    }\n  }\n\n  // Event handling\n  let mousePos = null;\n\n  canvas.addEventListener('mousedown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    mousePos = { x, y };\n\n    const node = findNodeAtPosition(x, y);\n\n    if (node) {\n      if (addingEdge) {\n        // Finish adding edge here\n        if (addingEdge !== node.id) {\n          addEdge(addingEdge, node.id);\n        }\n        addingEdge = null;\n        drawGraph();\n        return;\n      }\n\n      // Start dragging the node\n      dragNode = node;\n      dragOffset.x = node.x - x;\n      dragOffset.y = node.y - y;\n    } else {\n      if (addingEdge) {\n        // Clicked empty space while adding edge, cancel adding edge\n        addingEdge = null;\n        drawGraph();\n        return;\n      }\n      // Click empty space to add node\n      addNode(x, y);\n      drawGraph();\n    }\n  });\n\n  canvas.addEventListener('mousemove', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    mousePos = { x, y };\n\n    if (dragNode) {\n      dragNode.x = x + dragOffset.x;\n      dragNode.y = y + dragOffset.y;\n      drawGraph();\n    } else if (addingEdge) {\n      drawGraph();\n    }\n  });\n\n  canvas.addEventListener('mouseup', (e) => {\n    dragNode = null;\n  });\n\n  canvas.addEventListener('dblclick', (e) => {\n    // Double click on node removes it & connected edges\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    const node = findNodeAtPosition(x, y);\n    if (node) {\n      nodes = nodes.filter(n => n.id !== node.id);\n      edges = edges.filter(e => e.from !== node.id && e.to !== node.id);\n      addingEdge = null;\n      drawGraph();\n    }\n  });\n\n  canvas.addEventListener('contextmenu', (e) => {\n    e.preventDefault();\n    // Right click on node to start edge adding\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    const node = findNodeAtPosition(x, y);\n    if (node) {\n      if (addingEdge === node.id) {\n        addingEdge = null; // cancel if clicking same node again\n      } else {\n        addingEdge = node.id;\n      }\n      drawGraph();\n    }\n  });\n\n  // Buttons & controls\n\n  document.getElementById('graphType').addEventListener('change', (e) => {\n    graphType = e.target.value;\n    drawGraph();\n  });\n\n  document.getElementById('clearBtn').addEventListener('click', () => {\n    nodes = [];\n    edges = [];\n    addingEdge = null;\n    drawGraph();\n  });\n\n  document.getElementById('randomGraphBtn').addEventListener('click', () => {\n    generateRandomGraph();\n    drawGraph();\n  });\n\n  function generateRandomGraph() {\n    nodes = [];\n    edges = [];\n    addingEdge = null;\n\n    const nodeCount = 7;\n    const padding = 50;\n    for (let i = 0; i < nodeCount; i++) {\n      const x = padding + Math.random() * (canvas.width - 2 * padding);\n      const y = padding + Math.random() * (canvas.height - 2 * padding);\n      nodes.push({ id: (i + 1).toString(), x, y });\n    }\n\n    // Random edges\n    const maxEdges = nodeCount * 1.5; // somewhat sparse\n    let edgeCount = 0;\n    while (edgeCount < maxEdges) {\n      const fromIdx = Math.floor(Math.random() * nodeCount);\n      const toIdx = Math.floor(Math.random() * nodeCount);\n\n      // Either self loop or different node allowed \n      // but avoid duplicate edges\n      let from = nodes[fromIdx].id;\n      let to = nodes[toIdx].id;\n\n      if (graphType === 'undirected') {\n        if (from === to) continue; // no self loops in undirected for simplicity\n        if (edges.find(e => (e.from === from && e.to === to) || (e.from === to && e.to === from))) continue;\n        edges.push({ from, to });\n        edgeCount++;\n      } else {\n        if (edges.find(e => e.from === from && e.to === to)) continue;\n        edges.push({ from, to });\n        edgeCount++;\n      }\n    }\n  }\n\n  // Initial draw\n  drawGraph();\n\n  // Show brief usage instructions on console\n  console.log(`\nGraph Visualization Instructions:\n- Left click empty space: Add node\n- Left click and drag node: Move node\n- Right click on node: Select node to add an edge; right click another node to create edge\n- Double click on node: Remove node & connected edges\n- Choose \"Directed\" or \"Undirected\" graph type above\n- \"Generate Random Graph\" button to create sample graph\n- \"Clear Graph\" button to remove all nodes and edges\n`);\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": false,
  "hasTest": true
}