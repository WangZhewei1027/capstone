{
  "id": "20d2d6c1-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:37.515Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Depth-First Search (DFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Depth-First Search (DFS) Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f0f4f8;\n    color: #333;\n  }\n  h1 {\n    text-align: center;\n  }\n  #graph-container {\n    display: flex;\n    justify-content: center;\n    margin-top: 20px;\n  }\n  svg {\n    background: white;\n    border: 1px solid #ccc;\n    border-radius: 8px;\n  }\n  circle.node {\n    fill: #1f77b4;\n    stroke: #215a8e;\n    stroke-width: 2px;\n    cursor: pointer;\n    transition: fill 0.3s;\n  }\n  circle.node.visited {\n    fill: #ff7f0e;\n  }\n  circle.node.current {\n    fill: #d62728;\n  }\n  line.edge {\n    stroke: #999;\n    stroke-width: 2px;\n    transition: stroke 0.3s;\n  }\n  line.edge.visited {\n    stroke: #ff7f0e;\n    stroke-width: 3px;\n  }\n  #controls {\n    text-align: center;\n    margin-top: 15px;\n  }\n  #start-node {\n    width: 50px;\n    font-size: 16px;\n    text-align: center;\n  }\n  button {\n    font-size: 16px;\n    margin-left: 10px;\n    padding: 6px 12px;\n    cursor: pointer;\n  }\n  #log {\n    margin-top: 20px;\n    background: #fff;\n    border-radius: 8px;\n    padding: 10px;\n    height: 120px;\n    overflow-y: auto;\n    box-shadow: 0 0 5px #ccc;\n    font-family: monospace;\n    font-size: 14px;\n  }\n  #log strong {\n    color: #d62728;\n  }\n  #info {\n    max-width: 650px;\n    margin: 0 auto 15px auto;\n    font-size: 16px;\n    line-height: 1.4;\n    color: #444;\n  }\n  a {\n    color: #1f77b4;\n  }\n</style>\n</head>\n<body>\n<h1>Depth-First Search (DFS) Visualization</h1>\n<div id=\"info\">\n  <p>\n    This visualization demonstrates <strong>Depth-First Search (DFS)</strong> on a directed graph.\n    Click the <em>Start DFS</em> button to explore the graph starting from the chosen starting node.\n    Nodes and edges will be highlighted as DFS visits them.\n  </p>\n  <p>\n    You can change the start node by entering its number (0 to 6) below.\n  </p>\n  <p style=\"font-size:0.9em; color:#666;\">\n    Created by ChatGPT. Learn more about DFS on\n    <a href=\"https://en.wikipedia.org/wiki/Depth-first_search\" target=\"_blank\" rel=\"noopener\">Wikipedia</a>.\n  </p>\n</div>\n<div id=\"graph-container\">\n  <svg id=\"graph\" width=\"700\" height=\"400\" aria-label=\"Graph visualization\" role=\"img\"></svg>\n</div>\n<div id=\"controls\">\n  Start node: <input type=\"number\" id=\"start-node\" min=\"0\" max=\"6\" value=\"0\" />\n  <button id=\"start-btn\">Start DFS</button>\n  <button id=\"reset-btn\">Reset</button>\n</div>\n<div id=\"log\" aria-live=\"polite\" aria-atomic=\"false\" role=\"log\"></div>\n\n<script>\n(() => {\n  // Graph definition: adjacency list\n  const graph = {\n    0: [1, 2],\n    1: [3, 4],\n    2: [5],\n    3: [],\n    4: [5],\n    5: [6],\n    6: []\n  };\n\n  // Node positions for visualization (x,y)\n  const nodePositions = {\n    0: {x: 100, y: 50},\n    1: {x: 200, y: 130},\n    2: {x: 200, y: -10},\n    3: {x: 300, y: 70},\n    4: {x: 300, y: 190},\n    5: {x: 400, y: 60},\n    6: {x: 500, y: 120}\n  };\n\n  // Normalize Y positions for SVG\n  // (We can shift every y by +100 for positive coords)\n  Object.keys(nodePositions).forEach(k => (nodePositions[k].y += 100));\n\n  // Elements\n  const svg = document.getElementById(\"graph\");\n  const startInput = document.getElementById(\"start-node\");\n  const startBtn = document.getElementById(\"start-btn\");\n  const resetBtn = document.getElementById(\"reset-btn\");\n  const logElem = document.getElementById(\"log\");\n\n  // State\n  let visited = new Set();\n  let currentStack = [];\n  let animating = false;\n\n  // Clear log\n  function log(msg, highlight=false) {\n    const div = document.createElement(\"div\");\n    div.textContent = msg;\n    if (highlight) {\n      div.style.fontWeight = 'bold';\n      div.style.color = '#d62728';\n    }\n    logElem.appendChild(div);\n    logElem.scrollTop = logElem.scrollHeight;\n  }\n\n  // Draw the graph: nodes and edges\n  // We will create SVG lines for edges, and circles + text for nodes\n  // We'll keep references for dynamic color updates\n  const edgesElements = [];\n  const nodesElements = [];\n\n  function createArrowMarker() {\n    const marker = document.createElementNS(\"http://www.w3.org/2000/svg\",\"marker\");\n    marker.setAttribute(\"id\",\"arrowhead\");\n    marker.setAttribute(\"markerWidth\",\"10\");\n    marker.setAttribute(\"markerHeight\",\"7\");\n    marker.setAttribute(\"refX\",\"10\");\n    marker.setAttribute(\"refY\",\"3.5\");\n    marker.setAttribute(\"orient\",\"auto\");\n    marker.setAttribute(\"markerUnits\",\"strokeWidth\");\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\",\"path\");\n    path.setAttribute(\"d\",\"M0,0 L10,3.5 L0,7 Z\");\n    path.setAttribute(\"fill\",\"#999\");\n    marker.appendChild(path);\n    return marker;\n  }\n\n  function drawGraph() {\n    // Clear previous\n    svg.innerHTML = \"\";\n\n    // Defining arrowhead marker for directed edges\n    const defs = document.createElementNS(\"http://www.w3.org/2000/svg\",\"defs\");\n    defs.appendChild(createArrowMarker());\n    svg.appendChild(defs);\n\n    // Draw edges first (lines)\n    edgesElements.length = 0;\n    for (const from in graph) {\n      const fromPos = nodePositions[from];\n      for (const to of graph[from]) {\n        const toPos = nodePositions[to];\n        \n        // Draw line with arrow marker at end\n        const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n\n        // To avoid line overlaps with nodes, compute vector and offset ends by radius\n        const dx = toPos.x - fromPos.x;\n        const dy = toPos.y - fromPos.y;\n        const len = Math.sqrt(dx*dx + dy*dy);\n        const r = 20; // radius of node circle\n\n        const offsetX = (dx / len) * r;\n        const offsetY = (dy / len) * r;\n\n        line.setAttribute(\"x1\", fromPos.x + offsetX);\n        line.setAttribute(\"y1\", fromPos.y + offsetY);\n        line.setAttribute(\"x2\", toPos.x - offsetX);\n        line.setAttribute(\"y2\", toPos.y - offsetY);\n        line.setAttribute(\"stroke\", \"#999\");\n        line.setAttribute(\"stroke-width\", \"2\");\n        line.setAttribute(\"class\", \"edge\");\n        line.setAttribute(\"marker-end\", \"url(#arrowhead)\");\n        svg.appendChild(line);\n\n        edgesElements.push({from: parseInt(from), to: to, element: line});\n      }\n    }\n\n    // Draw nodes on top\n    nodesElements.length = 0;\n    for (const id in nodePositions) {\n      const pos = nodePositions[id];\n\n      // Circle\n      const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n      circle.setAttribute(\"cx\", pos.x);\n      circle.setAttribute(\"cy\", pos.y);\n      circle.setAttribute(\"r\", 20);\n      circle.setAttribute(\"fill\", \"#1f77b4\");\n      circle.setAttribute(\"stroke\", \"#215a8e\");\n      circle.setAttribute(\"stroke-width\", \"2\");\n      circle.setAttribute(\"class\", \"node\");\n      circle.setAttribute(\"tabindex\", \"0\");\n      circle.setAttribute(\"aria-label\", `Node ${id}`);\n\n      // Tooltip on hover\n      circle.setAttribute(\"title\", `Node ${id}`);\n\n      // Label (number)\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\",\"text\");\n      text.setAttribute(\"x\", pos.x);\n      text.setAttribute(\"y\", pos.y + 5);\n      text.setAttribute(\"text-anchor\", \"middle\");\n      text.setAttribute(\"font-size\", \"16px\");\n      text.setAttribute(\"fill\", \"white\");\n      text.setAttribute(\"pointer-events\", \"none\");\n      text.textContent = id;\n\n      svg.appendChild(circle);\n      svg.appendChild(text);\n\n      nodesElements.push({id: parseInt(id), circle, text});\n    }\n  }\n\n  // Reset graph colors and state\n  function resetGraph() {\n    visited.clear();\n    currentStack = [];\n    animating = false;\n    logElem.innerHTML = \"\";\n    for (const node of nodesElements) {\n      node.circle.classList.remove(\"visited\", \"current\");\n      node.circle.style.fill = \"#1f77b4\";\n      node.circle.style.stroke = \"#215a8e\";\n    }\n    for (const edge of edgesElements) {\n      edge.element.classList.remove(\"visited\");\n      edge.element.style.stroke = \"#999\";\n      edge.element.style.strokeWidth = \"2\";\n    }\n  }\n\n\n  // Utility: find the edge element connecting u->v\n  function findEdgeElement(u,v) {\n    return edgesElements.find(e => e.from === u && e.to == v);\n  }\n\n  // Delay promise helper\n  function delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // DFS animation - iterative or recursive? Recursive with async is simpler to demonstrate step-by-step\n  async function dfsVisit(node) {\n    if (visited.has(node)) return;\n    // Mark current node\n    visited.add(node);\n\n    // Highlight current node\n    const nodeElem = nodesElements.find(n => n.id === node);\n    if (!nodeElem) return;\n\n    nodeElem.circle.classList.add(\"current\");\n    log(`Visiting node ${node}`, true);\n    await delay(800);\n\n    nodeElem.circle.classList.remove(\"current\");\n    nodeElem.circle.classList.add(\"visited\");\n    nodeElem.circle.style.fill = \"#ff7f0e\";\n\n    // Visit edges & neighbors\n    for (const neighbor of graph[node]) {\n      const edgeElem = findEdgeElement(node, neighbor);\n      if (edgeElem && !visited.has(neighbor)) {\n        // Highlight edge as next to visit\n        edgeElem.element.classList.add(\"visited\");\n        edgeElem.element.style.stroke = \"#ff7f0e\";\n        edgeElem.element.style.strokeWidth = \"3\";\n\n        log(`Traversing edge ${node} â†’ ${neighbor}`);\n        await delay(600);\n\n        await dfsVisit(neighbor);\n      }\n    }\n  }\n\n  async function startDFS() {\n    if (animating) return;\n    animating = true;\n    resetGraph();\n\n    let startNode = parseInt(startInput.value);\n    if (!(startNode in graph)) {\n      alert(\"Start node must be between 0 and 6.\");\n      animating = false;\n      return;\n    }\n\n    log(`Starting DFS from node ${startNode}`, true);\n    await dfsVisit(startNode);\n\n    log(\"DFS Complete.\", true);\n    animating = false;\n  }\n\n  // Setup event listeners\n  startBtn.addEventListener(\"click\", startDFS);\n\n  resetBtn.addEventListener(\"click\", () => {\n    if(animating){\n      alert(\"Wait for current DFS to finish or refresh the page.\");\n      return;\n    }\n    resetGraph();\n    log(\"Reset graph.\");\n  });\n\n  startInput.addEventListener(\"change\", () => {\n    const val = parseInt(startInput.value);\n    if (isNaN(val) || val < 0 || val > 6) {\n      startInput.value = 0;\n    }\n  });\n\n  // Initial draw\n  drawGraph();\n  resetGraph();\n  log(\"Enter a start node and click 'Start DFS' to begin.\");\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Depth-First Search (DFS)"
    }
  ],
  "topic": "Depth-First Search (DFS)",
  "hasFSM": false,
  "hasTest": true
}