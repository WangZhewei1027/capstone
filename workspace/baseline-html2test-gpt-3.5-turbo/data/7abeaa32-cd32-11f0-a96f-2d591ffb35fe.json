{
  "id": "7abeaa32-cd32-11f0-a96f-2d591ffb35fe",
  "timestamp": "2025-11-29T14:49:45.612Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Topological Sort Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 1em;\n    background: #f0f0f0;\n  }\n  h1 {\n    text-align: center;\n  }\n  #inputArea, #outputArea {\n    background: white;\n    border-radius: 6px;\n    padding: 1em;\n    margin-bottom: 1em;\n    box-shadow: 0 0 8px #ccc;\n  }\n  label {\n    font-weight: bold;\n  }\n  textarea {\n    width: 100%;\n    height: 100px;\n    font-family: monospace;\n    font-size: 14px;\n    margin-top: 0.5em;\n    margin-bottom: 1em;\n  }\n  button {\n    padding: 0.6em 1.2em;\n    font-size: 16px;\n    background: #0078d7;\n    border: none;\n    border-radius: 4px;\n    color: white;\n    cursor: pointer;\n  }\n  button:hover {\n    background: #005ea1;\n  }\n  #graph {\n    margin-top: 1em;\n    text-align: center;\n  }\n  svg {\n    border: 1px solid #ccc;\n    background: white;\n    border-radius: 6px;\n  }\n  .node circle {\n    fill: #2980b9;\n    stroke: #1c5980;\n    stroke-width: 2;\n  }\n  .node text {\n    fill: white;\n    font-weight: bold;\n    pointer-events: none;\n  }\n  .edgePath path {\n    stroke: #555;\n    stroke-width: 2;\n    fill: none;\n    marker-end: url(#arrowhead);\n  }\n  .topo-step {\n    margin-top: 0.5em;\n    background: #e7f3fe;\n    padding: 0.5em;\n    border-radius: 4px;\n    font-family: monospace;\n  }\n  #error {\n    color: darkred;\n    font-weight: bold;\n  }\n</style>\n</head>\n<body>\n<h1>Topological Sort Demo</h1>\n<div id=\"inputArea\">\n  <label for=\"graphInput\">Enter Directed Acyclic Graph (DAG) edges (one per line):</label>\n  <textarea id=\"graphInput\" placeholder=\"Format: source target&#10;Example:&#10;5 2&#10;5 0&#10;4 0&#10;4 1&#10;2 3&#10;3 1\"></textarea>\n  <button id=\"runBtn\">Run Topological Sort</button>\n  <p><small>Each line defines a directed edge: <code>source target</code> (node names are strings without spaces).</small></p>\n  <p id=\"error\"></p>\n</div>\n<div id=\"outputArea\">\n  <h2>Result</h2>\n  <div><strong>Topological Order:</strong> <span id=\"topoOrder\"></span></div>\n  <div id=\"steps\"></div>\n  <div id=\"graph\"></div>\n</div>\n\n<script>\n// Topological Sort demonstration with graph visualization (using SVG)\n// No external libraries; simple DAG visualization with nodes and edges\n\nclass Graph {\n  constructor() {\n    this.adj = new Map(); // Map<node, Set of neighbors>\n  }\n  addNode(node) {\n    if (!this.adj.has(node)) {\n      this.adj.set(node, new Set());\n    }\n  }\n  addEdge(u, v) {\n    this.addNode(u);\n    this.addNode(v);\n    this.adj.get(u).add(v);\n  }\n  getNodes() {\n    return Array.from(this.adj.keys());\n  }\n  getNeighbors(u) {\n    return this.adj.get(u) || new Set();\n  }\n  indegrees() {\n    const indeg = new Map();\n    // initialize\n    for (let node of this.getNodes()) {\n      indeg.set(node, 0);\n    }\n    for (let u of this.getNodes()) {\n      for (let v of this.getNeighbors(u)) {\n        indeg.set(v, indeg.get(v) + 1);\n      }\n    }\n    return indeg;\n  }\n}\n\n// Returns { order: Array, steps: Array of strings } or null on cycle\nfunction kahnTopologicalSort(graph) {\n  const indeg = graph.indegrees();\n  const queue = [];\n  for (let [node, degree] of indeg) {\n    if (degree === 0) queue.push(node);\n  }\n\n  const order = [];\n  const steps = [];\n\n  let stepCount = 1;\n\n  while (queue.length > 0) {\n    // sorting queue to get deterministic order for demo\n    queue.sort();\n    const u = queue.shift();\n    order.push(u);\n    steps.push(`Step ${stepCount++}: Remove node '${u}' from queue and add to order.`);\n\n    for (let v of graph.getNeighbors(u)) {\n      indeg.set(v, indeg.get(v) - 1);\n      steps.push(`  Decrement indegree of '${v}', new indegree=${indeg.get(v)}.`);\n      if (indeg.get(v) === 0) {\n        queue.push(v);\n        steps.push(`  Node '${v}' added to queue.`);\n      }\n    }\n  }\n\n  if (order.length !== graph.getNodes().length) {\n    return null; // Cycle detected\n  }\n  return { order, steps };\n}\n\n// Simple function to layout nodes in a circle for visualization\nfunction layoutCircle(nodes, cx, cy, r) {\n  const positions = new Map();\n  const N = nodes.length;\n  for (let i = 0; i < N; i++) {\n    const angle = (2 * Math.PI * i) / N - Math.PI / 2;\n    const x = cx + r * Math.cos(angle);\n    const y = cy + r * Math.sin(angle);\n    positions.set(nodes[i], { x, y });\n  }\n  return positions;\n}\n\nfunction createSVGElement(tag, attrs = {}) {\n  const el = document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n  for (const [k, v] of Object.entries(attrs)) {\n    el.setAttribute(k, v);\n  }\n  return el;\n}\n\nfunction drawGraphSVG(graph, highlightNodes = []) {\n  // Highlight nodes in topological order (optional)\n  // Draw nodes and edges\n\n  const nodes = graph.getNodes().sort();\n  const positions = layoutCircle(nodes, 400, 250, 180);\n\n  const svg = createSVGElement(\"svg\", { width: 800, height: 500 });\n\n  // Arrow marker definition for edges\n  const defs = createSVGElement(\"defs\");\n  const marker = createSVGElement(\"marker\", {\n    id: \"arrowhead\",\n    markerWidth: \"10\",\n    markerHeight: \"7\",\n    refX: \"10\",\n    refY: \"3.5\",\n    orient: \"auto\",\n    fill: \"#555\",\n  });\n  const path = createSVGElement(\"path\", { d: \"M0,0 L10,3.5 L0,7 Z\" });\n  marker.appendChild(path);\n  defs.appendChild(marker);\n  svg.appendChild(defs);\n\n  // Draw edges as curved lines\n  for (const u of nodes) {\n    const from = positions.get(u);\n    for (const v of graph.getNeighbors(u)) {\n      const to = positions.get(v);\n      // We will draw a quadratic bezier curve from u to v\n      const dx = to.x - from.x;\n      const dy = to.y - from.y;\n      const mx = (from.x + to.x) / 2;\n      const my = (from.y + to.y) / 2;\n      const nx = my - from.y + mx;\n      const ny = mx - from.x + my;\n      const pathData = `M ${from.x} ${from.y} Q ${nx} ${ny} ${to.x} ${to.y}`;\n      const edgePath = createSVGElement(\"path\", {\n        d: pathData,\n        \"marker-end\": \"url(#arrowhead)\",\n        stroke: \"#555\",\n        \"stroke-width\": \"2\",\n        fill: \"none\",\n      });\n      svg.appendChild(edgePath);\n    }\n  }\n\n  // Draw nodes\n  nodes.forEach((node, i) => {\n    const pos = positions.get(node);\n    const group = createSVGElement(\"g\", { class: \"node\" });\n    group.setAttribute(\"transform\", `translate(${pos.x},${pos.y})`);\n\n    const circle = createSVGElement(\"circle\", {\n      r: 22,\n      fill: \"#2980b9\",\n      stroke: \"#1c5980\",\n      \"stroke-width\": 2,\n    });\n    // Highlight ordering by coloring nodes in the topological order\n    if (highlightNodes.length > 0) {\n      const idx = highlightNodes.indexOf(node);\n      if (idx !== -1) {\n        // Gradient from green to blue by order index\n        const colorInterp = (i) =>\n          `hsl(${120 - (120 * i) / highlightNodes.length}, 70%, 50%)`;\n        circle.setAttribute(\"fill\", colorInterp(idx));\n        circle.setAttribute(\"stroke\", \"#004d00\");\n      }\n    }\n    const text = createSVGElement(\"text\", {\n      \"text-anchor\": \"middle\",\n      \"dominant-baseline\": \"middle\",\n      fill: \"white\",\n      \"font-weight\": \"bold\",\n      \"font-size\": \"16px\",\n      style: \"pointer-events:none;\",\n    });\n    text.textContent = node;\n\n    group.appendChild(circle);\n    group.appendChild(text);\n    svg.appendChild(group);\n  });\n\n  return svg;\n}\n\nfunction parseInput(text) {\n  // Parses text into array of edges [u,v]\n  // Ignores empty lines and trims whitespace\n  const lines = text.split(\"\\n\").map((l) => l.trim()).filter((l) => l.length > 0);\n  const edges = [];\n  for (const line of lines) {\n    const parts = line.split(/\\s+/);\n    if (parts.length !== 2) {\n      throw new Error(`Invalid edge line: '${line}'. Each line must have exactly two nodes.`);\n    }\n    edges.push(parts);\n  }\n  return edges;\n}\n\nfunction main() {\n  const inputArea = document.getElementById(\"graphInput\");\n  const runBtn = document.getElementById(\"runBtn\");\n  const outputOrder = document.getElementById(\"topoOrder\");\n  const outputSteps = document.getElementById(\"steps\");\n  const outputGraph = document.getElementById(\"graph\");\n  const errorElem = document.getElementById(\"error\");\n\n  runBtn.onclick = () => {\n    // Clear previous outputs\n    outputOrder.textContent = \"\";\n    outputSteps.innerHTML = \"\";\n    outputGraph.innerHTML = \"\";\n    errorElem.textContent = \"\";\n\n    let edges;\n    try {\n      edges = parseInput(inputArea.value);\n    } catch (e) {\n      errorElem.textContent = e.message;\n      return;\n    }\n\n    // Build graph\n    const graph = new Graph();\n    for (const [u, v] of edges) {\n      graph.addEdge(u, v);\n    }\n    // Also add isolated nodes (nodes not appearing as source but possibly isolated)\n    const allNodes = new Set();\n    for (const [u, v] of edges) {\n      allNodes.add(u);\n      allNodes.add(v);\n    }\n    for (const node of allNodes) graph.addNode(node);\n\n    // Run Kahn's topological sort\n    const result = kahnTopologicalSort(graph);\n    if (!result) {\n      errorElem.textContent = \"Cycle detected in the graph. Topological sort not possible.\";\n      return;\n    }\n\n    outputOrder.textContent = result.order.join(\" â†’ \");\n    // Show steps\n    for (const step of result.steps) {\n      const div = document.createElement(\"div\");\n      div.classList.add(\"topo-step\");\n      div.textContent = step;\n      outputSteps.appendChild(div);\n    }\n\n    // Draw graph with nodes colored by topological order\n    const svg = drawGraphSVG(graph, result.order);\n    outputGraph.appendChild(svg);\n  };\n}\n\n// Initialize sample input on page load\nwindow.onload = () => {\n  const example = `5 2\n5 0\n4 0\n4 1\n2 3\n3 1`;\n  document.getElementById(\"graphInput\").value = example;\n  main();\n};\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": false,
  "hasTest": true
}