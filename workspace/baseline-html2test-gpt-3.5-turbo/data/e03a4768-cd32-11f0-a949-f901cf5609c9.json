{
  "id": "e03a4768-cd32-11f0-a949-f901cf5609c9",
  "timestamp": "2025-11-29T14:52:18.738Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <title>Topological Sort Demo</title>\n  <style>\n    body {\n      font-family: Arial, sans-serif;\n      margin: 2rem;\n      background: #f9f9f9;\n    }\n    h1 {\n      text-align: center;\n    }\n    #graph-input {\n      width: 100%;\n      height: 150px;\n      font-family: monospace;\n      font-size: 14px;\n      margin-bottom: 0.5rem;\n    }\n    #run-btn {\n      padding: 0.5rem 1rem;\n      font-size: 1rem;\n      cursor: pointer;\n      margin-bottom: 1rem;\n    }\n    #output {\n      white-space: pre-wrap;\n      background: #fff;\n      border: 1px solid #ccc;\n      padding: 1rem;\n      min-height: 4rem;\n    }\n    label {\n      font-weight: bold;\n      display: block;\n      margin-bottom: 0.3rem;\n    }\n    #instructions {\n      background: #eef6ff;\n      border: 1px solid #99c2ff;\n      padding: 1rem;\n      margin-bottom: 1rem;\n      font-size: 0.9rem;\n      color: #333;\n    }\n  </style>\n</head>\n<body>\n  <h1>Topological Sort Visualizer</h1>\n  <div id=\"instructions\">\n    <p><strong>Input format:</strong></p>\n    <p>Define a directed graph (DAG) edges in this format (one edge per line):</p>\n    <pre>fromNode → toNode</pre>\n    <p>Example:</p>\n    <pre>\n5 -> 2\n5 -> 0\n4 -> 0\n4 -> 1\n2 -> 3\n3 -> 1\n    </pre>\n    <p>This example describes edges from node 5 to 2, 5 to 0, etc.</p>\n    <p>After entering edges, click \"Run Topological Sort\" to see the ordering or detect cycles.</p>\n  </div>\n  <label for=\"graph-input\">Enter DAG edges:</label>\n  <textarea id=\"graph-input\" placeholder=\"e.g.&#10;5 -> 2&#10;5 -> 0&#10;4 -> 0&#10;4 -> 1&#10;2 -> 3&#10;3 -> 1\"></textarea>\n  <br />\n  <button id=\"run-btn\">Run Topological Sort</button>\n  <h2>Result:</h2>\n  <div id=\"output\"></div>\n\n<script>\n(() => {\n  const inputEl = document.getElementById('graph-input');\n  const outputEl = document.getElementById('output');\n  const runBtn = document.getElementById('run-btn');\n\n  // Parse edges from input string lines of format 'from -> to'\n  function parseEdges(text) {\n    const lines = text.trim().split('\\n');\n    const edges = [];\n    for (const line of lines) {\n      if (!line.trim()) continue;\n      const match = line.trim().match(/^(.+?)\\s*->\\s*(.+)$/);\n      if (!match) {\n        throw new Error(`Invalid edge format: \"${line}\". Use \"from -> to\".`);\n      }\n      // Trim nodes and keep as strings\n      const from = match[1].trim();\n      const to = match[2].trim();\n      edges.push([from, to]);\n    }\n    return edges;\n  }\n\n  // Build adjacency list graph from edges\n  function buildGraph(edges) {\n    const graph = new Map();\n    // Collect all nodes\n    const nodesSet = new Set();\n    for (const [from, to] of edges) {\n      nodesSet.add(from);\n      nodesSet.add(to);\n    }\n    // Initialize nodes in graph map\n    for (const node of nodesSet) graph.set(node, []);\n    // Add edges\n    for (const [from, to] of edges) {\n      graph.get(from).push(to);\n    }\n    return graph;\n  }\n  \n  // Kahn's Algorithm for Topological Sort\n  function topologicalSort(graph) {\n    // Calculate in-degree of each node\n    const inDegree = new Map();\n    for (const node of graph.keys()) {\n      inDegree.set(node, 0);\n    }\n    for (const [node, neighbors] of graph.entries()) {\n      for (const neigh of neighbors) {\n        inDegree.set(neigh, (inDegree.get(neigh) || 0) + 1);\n      }\n    }\n    \n    // Start with all nodes that have in-degree 0\n    const queue = [];\n    for (const [node, degree] of inDegree.entries()) {\n      if (degree === 0) queue.push(node);\n    }\n\n    const topoOrder = [];\n    while (queue.length) {\n      const current = queue.shift();\n      topoOrder.push(current);\n      for (const neighbor of graph.get(current)) {\n        inDegree.set(neighbor, inDegree.get(neighbor) - 1);\n        if (inDegree.get(neighbor) === 0) {\n          queue.push(neighbor);\n        }\n      }\n    }\n\n    // If topoOrder includes all nodes, success; otherwise, cycle detected\n    if (topoOrder.length !== graph.size) {\n      return null; // cycle found\n    }\n\n    return topoOrder;\n  }\n\n  function showResult(text, isError = false) {\n    outputEl.textContent = text;\n    outputEl.style.color = isError ? '#d00' : '#060';\n  }\n\n  runBtn.addEventListener('click', () => {\n    outputEl.textContent = '';\n    try {\n      const edges = parseEdges(inputEl.value);\n      const graph = buildGraph(edges);\n      const order = topologicalSort(graph);\n      if (!order) {\n        showResult('Error: The graph contains a cycle. Topological sort is not possible.', true);\n      } else {\n        showResult('Topological Order:\\n' + order.join(' → '));\n      }\n    } catch (ex) {\n      showResult('Error: ' + ex.message, true);\n    }\n  });\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": false,
  "hasTest": true
}