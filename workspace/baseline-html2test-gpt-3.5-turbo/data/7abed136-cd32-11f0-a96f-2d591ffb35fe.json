{
  "id": "7abed136-cd32-11f0-a96f-2d591ffb35fe",
  "timestamp": "2025-11-29T14:49:52.367Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Linear Regression",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <title>Linear Regression Demo</title>\n  <style>\n    body {\n      font-family: Arial, sans-serif;\n      margin: 20px;\n      max-width: 900px;\n    }\n    h1 {\n      text-align: center;\n    }\n    #plot {\n      border: 1px solid #ccc;\n    }\n    #controls {\n      margin-top: 20px;\n      display: flex;\n      flex-wrap: wrap;\n      gap: 15px;\n      align-items: center;\n      justify-content: center;\n    }\n    #controls > div {\n      display: flex;\n      flex-direction: column;\n      align-items: flex-start;\n    }\n    label {\n      font-size: 14px;\n      margin-bottom: 4px;\n      font-weight: bold;\n    }\n    input[type=number] {\n      width: 80px;\n      padding: 4px;\n      font-size: 14px;\n    }\n    button {\n      padding: 8px 14px;\n      font-size: 16px;\n      cursor: pointer;\n      border: none;\n      border-radius: 5px;\n      background-color: #3a87ad;\n      color: white;\n      transition: background-color 0.3s ease;\n    }\n    button:hover {\n      background-color: #2e5d73;\n    }\n    #explanation {\n      margin-top: 30px;\n      font-size: 16px;\n      line-height: 1.4;\n      max-width: 800px;\n      margin-left: auto;\n      margin-right: auto;\n    }\n    canvas {\n      display: block;\n      margin-left: auto;\n      margin-right: auto;\n      background: #fff;\n    }\n    #dataPointsCount {\n      font-weight: bold;\n    }\n  </style>\n</head>\n<body>\n  <h1>Interactive Linear Regression Demo</h1>\n\n  <canvas id=\"plot\" width=\"800\" height=\"500\"></canvas>\n\n  <div id=\"controls\">\n    <div>\n      <label for=\"pointCount\">Number of points</label>\n      <input type=\"number\" id=\"pointCount\" value=\"50\" min=\"5\" max=\"200\" />\n    </div>\n\n    <div>\n      <label for=\"noiseLevel\">Noise level (std dev)</label>\n      <input type=\"number\" id=\"noiseLevel\" value=\"10\" min=\"0\" max=\"50\" step=\"1\" />\n    </div>\n\n    <div>\n      <label for=\"slopeInput\">True slope (m)</label>\n      <input type=\"number\" id=\"slopeInput\" value=\"2\" step=\"0.1\" />\n    </div>\n\n    <div>\n      <label for=\"interceptInput\">True intercept (b)</label>\n      <input type=\"number\" id=\"interceptInput\" value=\"5\" step=\"0.1\" />\n    </div>\n\n    <div style=\"align-self: flex-end;\">\n      <button id=\"generateBtn\" title=\"Generate new dataset\">Generate Data</button>\n    </div>\n  </div>\n\n  <div id=\"explanation\">\n    <p>\n      This demo illustrates simple <strong>linear regression</strong>, which fits a straight line y = m x + b to a dataset.\n      You can adjust the number of data points, noise level, and true underlying slope/intercept used to generate the points.\n    </p>\n    <p>\n      The blue dots are the generated noisy data points, while the red line is the best fit line computed using the\n      <a href=\"https://en.wikipedia.org/wiki/Simple_linear_regression#Fitting_the_regression_line\" target=\"_blank\">least squares method</a>.\n    </p>\n    <p>\n      The computed parameters are displayed below the plot.\n    </p>\n  </div>\n\n  <div style=\"text-align:center; margin-top:20px; font-size: 18px;\">\n    <span><strong>Estimated slope (m): </strong><span id=\"estimatedSlope\">-</span></span> &nbsp;&nbsp;&nbsp;\n    <span><strong>Estimated intercept (b): </strong><span id=\"estimatedIntercept\">-</span></span> &nbsp;&nbsp;&nbsp;\n    <span><strong>RÂ² (coefficient of determination): </strong><span id=\"rSquared\">-</span></span>\n  </div>\n\n<script>\n  (() => {\n    const canvas = document.getElementById(\"plot\");\n    const ctx = canvas.getContext(\"2d\");\n\n    const pointCountInput = document.getElementById(\"pointCount\");\n    const noiseInput = document.getElementById(\"noiseLevel\");\n    const slopeInput = document.getElementById(\"slopeInput\");\n    const interceptInput = document.getElementById(\"interceptInput\");\n    const generateBtn = document.getElementById(\"generateBtn\");\n\n    const estSlopeElem = document.getElementById(\"estimatedSlope\");\n    const estInterceptElem = document.getElementById(\"estimatedIntercept\");\n    const rSquaredElem = document.getElementById(\"rSquared\");\n\n    // Plot margins and scale info\n    const margin = {top: 40, bottom: 60, left: 70, right: 30};\n    const plotWidth = canvas.width - margin.left - margin.right;\n    const plotHeight = canvas.height - margin.top - margin.bottom;\n\n    // Data storage\n    let dataPoints = [];\n\n    // Utility: Linear regression using least squares\n    // Returns {m, b, r2}\n    function linearRegression(points) {\n      const n = points.length;\n      if (n === 0) return null;\n\n      let sumX = 0, sumY = 0, sumXX = 0, sumXY = 0, sumYY = 0;\n      for (const p of points) {\n        sumX += p.x;\n        sumY += p.y;\n        sumXX += p.x * p.x;\n        sumXY += p.x * p.y;\n        sumYY += p.y * p.y;\n      }\n\n      const denominator = (n * sumXX - sumX * sumX);\n      if (denominator === 0) return null; // vertical line or all x same\n\n      const m = (n * sumXY - sumX * sumY) / denominator;\n      const b = (sumY - m * sumX) / n;\n\n      // Calculate R squared\n      const meanY = sumY / n;\n      let ssTot = 0;\n      let ssRes = 0;\n      for (const p of points) {\n        const yPred = m * p.x + b;\n        ssTot += (p.y - meanY) ** 2;\n        ssRes += (p.y - yPred) ** 2;\n      }\n      const r2 = 1 - ssRes / ssTot;\n\n      return {m, b, r2};\n    }\n\n    // Generate random normal values using Box-Muller\n    function randNormal(mean=0, stddev=1) {\n      let u = 0, v = 0;\n      while(u === 0) u = Math.random();\n      while(v === 0) v = Math.random();\n      let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n      return num * stddev + mean;\n    }\n\n    // Generate dataset according to user params:\n    function generateData(numPoints, noiseStd, slope, intercept) {\n      const points = [];\n      // Generate x values spaced somewhat evenly between 0 and 100\n      for(let i = 0; i < numPoints; i++) {\n        const x = Math.random() * 100;\n        const trueY = slope * x + intercept;\n        const noisyY = trueY + randNormal(0, noiseStd);\n        points.push({x, y: noisyY});\n      }\n      return points;\n    }\n\n    // Plotting functions:\n    function clearPlot() {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      // White background\n      ctx.fillStyle = \"#fff\";\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Find min/max for x and y in data (including some padding)\n    function findBounds(points) {\n      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;\n      points.forEach(p => {\n        if(p.x < minX) minX = p.x;\n        if(p.x > maxX) maxX = p.x;\n        if(p.y < minY) minY = p.y;\n        if(p.y > maxY) maxY = p.y;\n      });\n\n      // Add padding (10%)\n      const xPad = (maxX - minX) * 0.1 || 10;\n      const yPad = (maxY - minY) * 0.1 || 10;\n\n      return {\n        minX: minX - xPad,\n        maxX: maxX + xPad,\n        minY: minY - yPad,\n        maxY: maxY + yPad\n      };\n    }\n\n    // Map data coordinate to canvas pixel coordinate\n    // x and y are data coords; bounds is min/max object\n    function toCanvasCoords(x, y, bounds) {\n      const xRatio = (x - bounds.minX) / (bounds.maxX - bounds.minX);\n      const yRatio = (y - bounds.minY) / (bounds.maxY - bounds.minY);\n      const cx = margin.left + xRatio * plotWidth;\n      const cy = margin.top + plotHeight - yRatio * plotHeight; // invert y axis\n      return {cx, cy};\n    }\n\n    // Draw axis\n    function drawAxis(bounds) {\n      ctx.strokeStyle = \"#000\";\n      ctx.lineWidth = 1;\n      ctx.fillStyle = \"#000\";\n      ctx.font = \"14px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n\n      // Y axis line\n      ctx.beginPath();\n      ctx.moveTo(margin.left, margin.top);\n      ctx.lineTo(margin.left, margin.top + plotHeight);\n      ctx.stroke();\n\n      // X axis line\n      ctx.beginPath();\n      ctx.moveTo(margin.left, margin.top + plotHeight);\n      ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);\n      ctx.stroke();\n\n      // Ticks and labels X axis\n      const xTicks = 10;\n      for(let i = 0; i <= xTicks; i++) {\n        const val = bounds.minX + (bounds.maxX - bounds.minX) * i / xTicks;\n        const xPos = margin.left + (plotWidth) * i / xTicks;\n        ctx.beginPath();\n        ctx.moveTo(xPos, margin.top + plotHeight);\n        ctx.lineTo(xPos, margin.top + plotHeight + 7);\n        ctx.stroke();\n        ctx.fillText(val.toFixed(1), xPos, margin.top + plotHeight + 20);\n      }\n\n      // Ticks and labels Y axis\n      const yTicks = 10;\n      ctx.textAlign = \"right\";\n      for(let i = 0; i <= yTicks; i++) {\n        const val = bounds.minY + (bounds.maxY - bounds.minY) * i / yTicks;\n        const yPos = margin.top + plotHeight - (plotHeight) * i / yTicks;\n        ctx.beginPath();\n        ctx.moveTo(margin.left - 7, yPos);\n        ctx.lineTo(margin.left, yPos);\n        ctx.stroke();\n        ctx.fillText(val.toFixed(1), margin.left - 12, yPos);\n      }\n\n      // Axis labels\n      ctx.textAlign = \"center\";\n      ctx.font = \"16px Arial\";\n      ctx.fillText(\"X\", margin.left + plotWidth / 2, margin.top + plotHeight + 45);\n      ctx.save();\n      ctx.translate(margin.left - 50, margin.top + plotHeight / 2);\n      ctx.rotate(-Math.PI / 2);\n      ctx.fillText(\"Y\", 0, 0);\n      ctx.restore();\n\n      // Title\n      ctx.font = \"18px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"Linear Regression: Data and Best Fit Line\", margin.left + plotWidth/2, margin.top - 15);\n    }\n\n    // Draw data points\n    function drawPoints(points, bounds) {\n      ctx.fillStyle = \"blue\";\n      for (const p of points) {\n        const {cx, cy} = toCanvasCoords(p.x, p.y, bounds);\n        ctx.beginPath();\n        ctx.arc(cx, cy, 4, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n    }\n\n    // Draw regression line\n    function drawRegressionLine(m, b, bounds) {\n      ctx.strokeStyle = \"red\";\n      ctx.lineWidth = 2;\n\n      // Calculate y for minX and maxX\n      const x1 = bounds.minX;\n      const y1 = m * x1 + b;\n      const x2 = bounds.maxX;\n      const y2 = m * x2 + b;\n\n      const {cx: cx1, cy: cy1} = toCanvasCoords(x1, y1, bounds);\n      const {cx: cx2, cy: cy2} = toCanvasCoords(x2, y2, bounds);\n\n      ctx.beginPath();\n      ctx.moveTo(cx1, cy1);\n      ctx.lineTo(cx2, cy2);\n      ctx.stroke();\n    }\n\n    // Main function to generate data, calc regression, draw, update UI\n    function update() {\n      const numPoints = Math.min(Math.max(parseInt(pointCountInput.value), 5), 200);\n      const noise = Math.max(parseFloat(noiseInput.value), 0);\n      const trueSlope = parseFloat(slopeInput.value);\n      const trueIntercept = parseFloat(interceptInput.value);\n\n      dataPoints = generateData(numPoints, noise, trueSlope, trueIntercept);\n\n      const regression = linearRegression(dataPoints);\n\n      clearPlot();\n\n      // Find bounds combining data and regression line for better framing\n      let bounds = findBounds(dataPoints);\n\n      if (regression) {\n        // Include line ends in bounds\n        const lineYs = [regression.m * bounds.minX + regression.b, regression.m * bounds.maxX + regression.b];\n        bounds.minY = Math.min(bounds.minY, ...lineYs);\n        bounds.maxY = Math.max(bounds.maxY, ...lineYs);\n      }\n\n      drawAxis(bounds);\n      drawPoints(dataPoints, bounds);\n\n      if (regression) {\n        drawRegressionLine(regression.m, regression.b, bounds);\n        estSlopeElem.textContent = regression.m.toFixed(4);\n        estInterceptElem.textContent = regression.b.toFixed(4);\n        rSquaredElem.textContent = regression.r2.toFixed(4);\n      } else {\n        estSlopeElem.textContent = \"-\";\n        estInterceptElem.textContent = \"-\";\n        rSquaredElem.textContent = \"-\";\n      }\n    }\n\n    generateBtn.addEventListener(\"click\", () => {\n      update();\n    });\n\n    // Also update when pressing Enter in inputs\n    [pointCountInput, noiseInput, slopeInput, interceptInput].forEach(input => {\n      input.addEventListener(\"keydown\", e => {\n        if(e.key === \"Enter\") {\n          e.preventDefault();\n          update();\n        }\n      });\n    });\n\n    // Initial draw\n    update();\n  })();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Linear Regression"
    }
  ],
  "topic": "Linear Regression",
  "hasFSM": false,
  "hasTest": true
}