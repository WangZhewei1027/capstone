{
  "id": "7abeaa31-cd32-11f0-a96f-2d591ffb35fe",
  "timestamp": "2025-11-29T14:49:46.389Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Prim's Algorithm Demonstration</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    background: #f5f5f5;\n  }\n  header {\n    background: #2c3e50;\n    color: white;\n    padding: 1rem 2rem;\n    text-align: center;\n  }\n  #container {\n    display: flex;\n    height: calc(100vh - 72px);\n  }\n  #graphArea {\n    flex: 1;\n    background: white;\n    border-right: 1px solid #ccc;\n    position: relative;\n  }\n  #controls {\n    width: 300px;\n    padding: 1rem;\n    background: #ecf0f1;\n    overflow-y: auto;\n    box-sizing: border-box;\n  }\n  #controls section {\n    margin-bottom: 1.5rem;\n  }\n  label {\n    display: block;\n    margin-bottom: 0.4rem;\n    font-weight: bold;\n  }\n  input[type=number], select {\n    width: 100%;\n    padding: 0.3rem;\n    margin-bottom: 0.6rem;\n    box-sizing: border-box;\n  }\n  button {\n    padding: 0.6rem 1rem;\n    font-size: 1rem;\n    margin-top: 0.5rem;\n    background: #3498db;\n    color: white;\n    border: none;\n    cursor: pointer;\n    border-radius: 3px;\n  }\n  button:disabled {\n    background: #95a5a6;\n    cursor: not-allowed;\n  }\n  canvas {\n    display: block;\n    width: 100%;\n    height: 100%;\n  }\n  #log {\n    height: 150px;\n    background: #222;\n    color: #eee;\n    font-family: monospace;\n    overflow-y: auto;\n    padding: 10px;\n    border-radius: 4px;\n  }\n  .edge-weight-label {\n    position: absolute;\n    background: rgba(255,255,255,0.9);\n    padding: 1px 4px;\n    border-radius: 3px;\n    font-size: 12px;\n    pointer-events: none;\n  }\n  .node {\n    fill: #2980b9;\n    stroke: #1f5980;\n    stroke-width: 2px;\n    cursor: pointer;\n  }\n  .node.selected {\n    fill: #e74c3c;\n  }\n  .edge {\n    stroke: #bdc3c7;\n    stroke-width: 2px;\n  }\n  .edge.in-mst {\n    stroke: #27ae60;\n    stroke-width: 4px;\n  }\n  #info {\n    font-size: 14px;\n    margin-top: 1rem;\n    color: #333;\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Prim's Algorithm Visualization</h1>\n</header>\n<div id=\"container\">\n  <div id=\"graphArea\">\n    <svg id=\"graphSvg\" width=\"100%\" height=\"100%\"></svg>\n  </div>\n  <div id=\"controls\">\n    <section>\n      <h2>Graph Input</h2>\n      <label for=\"nodeCount\">Number of nodes (2-10):</label>\n      <input type=\"number\" id=\"nodeCount\" min=\"2\" max=\"10\" value=\"6\" />\n      <button id=\"generateRandomGraphBtn\">Generate Random Graph</button>\n      <small>Click on nodes to select start node for Prim's algorithm.</small>\n    </section>\n    <section>\n      <h2>Run Prim's Algorithm</h2>\n      <button id=\"startPrimBtn\" disabled>Start Prim's Algorithm</button>\n      <button id=\"stepPrimBtn\" disabled>Next Step</button>\n      <button id=\"resetPrimBtn\" disabled>Reset Algorithm</button>\n    </section>\n    <section>\n      <h2>Log:</h2>\n      <div id=\"log\"></div>\n    </section>\n    <section id=\"info\">\n      <b>How to use:</b><br/>\n      1. Generate a random weighted undirected graph.<br/>\n      2. Click on a node to select it as the start node.<br/>\n      3. Press \"Start Prim's Algorithm\".<br/>\n      4. Use \"Next Step\" button to advance algorithm step by step.<br/>\n      5. Edges in green are included in the MST.<br/>\n    </section>\n  </div>\n</div>\n\n<script>\n(() => {\n  const svgNS = \"http://www.w3.org/2000/svg\";\n  const graphSvg = document.getElementById(\"graphSvg\");\n  const nodeCountInput = document.getElementById(\"nodeCount\");\n  const generateBtn = document.getElementById(\"generateRandomGraphBtn\");\n  const startBtn = document.getElementById(\"startPrimBtn\");\n  const stepBtn = document.getElementById(\"stepPrimBtn\");\n  const resetBtn = document.getElementById(\"resetPrimBtn\");\n  const logDiv = document.getElementById(\"log\");\n\n  let width, height;\n\n  function getSvgSize() {\n    width = graphSvg.clientWidth;\n    height = graphSvg.clientHeight;\n  }\n\n  let nodes = [];\n  let edges = [];\n  // nodes: {id, x, y, circleElement, labelElement}\n  // edges: {id, u, v, weight, lineElement, labelElement, inMST}\n\n  // Prim's algorithm state\n  let primState = null;\n  // primState: {\n  //   startNode,\n  //   mstSet: Set(nodeId),\n  //   edgeQueue: array of edges candidates (or better a PriorityQueue)\n  //   mstEdges: array of edges in MST\n  //   step: current step number\n  // }\n  let selectedNodeId = null;\n\n  // Priority Queue implementation (min-heap based on edge weight)\n  class PriorityQueue {\n    constructor() {\n      this.data = [];\n    }\n    enqueue(edge) {\n      this.data.push(edge);\n      this._bubbleUp(this.data.length -1);\n    }\n    dequeue() {\n      if(this.isEmpty()) return null;\n      const min = this.data[0];\n      const end = this.data.pop();\n      if(this.data.length > 0) {\n        this.data[0] = end;\n        this._sinkDown(0);\n      }\n      return min;\n    }\n    _bubbleUp(idx) {\n      let element = this.data[idx];\n      while(idx > 0) {\n        const parentIdx = Math.floor((idx-1)/2);\n        const parent = this.data[parentIdx];\n        if(element.weight >= parent.weight) break;\n        this.data[parentIdx] = element;\n        this.data[idx] = parent;\n        idx = parentIdx;\n      }\n    }\n    _sinkDown(idx) {\n      const length = this.data.length;\n      const element = this.data[idx];\n      while(true){\n        let leftChildIdx = 2*idx + 1;\n        let rightChildIdx = 2*idx + 2;\n        let swap = null;\n        if(leftChildIdx < length){\n          if(this.data[leftChildIdx].weight < element.weight){\n            swap = leftChildIdx;\n          }\n        }\n        if(rightChildIdx < length){\n          if((swap === null && this.data[rightChildIdx].weight < element.weight) ||\n             (swap !== null && this.data[rightChildIdx].weight < this.data[leftChildIdx].weight)){\n            swap = rightChildIdx;\n          }\n        }\n        if(swap === null) break;\n        this.data[idx] = this.data[swap];\n        this.data[swap] = element;\n        idx = swap;\n      }\n    }\n    isEmpty() {\n      return this.data.length === 0;\n    }\n    clear() {\n      this.data.length = 0;\n    }\n  }\n\n  function clearLog(){\n    logDiv.textContent = \"\";\n  }\n  function log(msg){\n    const time = new Date().toLocaleTimeString();\n    logDiv.textContent += `[${time}] ${msg}\\n`;\n    logDiv.scrollTop = logDiv.scrollHeight;\n  }\n\n  function createNode(id, x, y){\n    // Group for circle + label\n    const g = document.createElementNS(svgNS, \"g\");\n    g.setAttribute(\"class\", \"node-group\");\n    g.style.cursor = \"pointer\";\n    g.dataset.id = id;\n\n    // Circle\n    const circle = document.createElementNS(svgNS, \"circle\");\n    circle.setAttribute(\"cx\", x);\n    circle.setAttribute(\"cy\", y);\n    circle.setAttribute(\"r\", 20);\n    circle.setAttribute(\"class\", \"node\");\n    circle.style.transition = \"fill 0.3s ease\";\n\n    // Label\n    const label = document.createElementNS(svgNS, \"text\");\n    label.setAttribute(\"x\", x);\n    label.setAttribute(\"y\", y+5);\n    label.setAttribute(\"text-anchor\", \"middle\");\n    label.setAttribute(\"font-weight\", \"bold\");\n    label.setAttribute(\"font-size\", \"14\");\n    label.textContent = id;\n\n    g.appendChild(circle);\n    g.appendChild(label);\n    graphSvg.appendChild(g);\n\n    return {id, x, y, group: g, circleElement: circle, labelElement: label};\n  }\n\n  function createEdge(id, uNode, vNode, weight){\n    // Line\n    const line = document.createElementNS(svgNS, \"line\");\n    line.setAttribute(\"x1\", uNode.x);\n    line.setAttribute(\"y1\", uNode.y);\n    line.setAttribute(\"x2\", vNode.x);\n    line.setAttribute(\"y2\", vNode.y);\n    line.setAttribute(\"class\", \"edge\");\n\n    // Label\n    const label = document.createElementNS(svgNS, \"text\");\n    label.setAttribute(\"font-size\", \"12\");\n    label.setAttribute(\"font-weight\", \"bold\");\n    label.setAttribute(\"fill\", \"#2c3e50\");\n    // midpoint for label:\n    const mx = (uNode.x + vNode.x) / 2;\n    const my = (uNode.y + vNode.y) / 2;\n\n    label.setAttribute(\"x\", mx);\n    label.setAttribute(\"y\", my - 5);\n    label.setAttribute(\"text-anchor\", \"middle\");\n    label.textContent = weight;\n\n    graphSvg.appendChild(line);\n    graphSvg.appendChild(label);\n\n    return {id, u: uNode.id, v: vNode.id, weight, lineElement: line, labelElement: label, inMST:false};\n  }\n\n  function clearGraph(){\n    while(graphSvg.lastChild){\n      graphSvg.removeChild(graphSvg.lastChild);\n    }\n    nodes.length = 0;\n    edges.length = 0;\n    selectedNodeId = null;\n  }\n\n  // Generate random connected graph with n nodes\n  function generateRandomGraph(n){\n    clearGraph();\n    getSvgSize();\n\n    // Place nodes in a circle\n    const radius = Math.min(width, height)/2.5;\n    const centerX = width/2;\n    const centerY = height/2;\n    for(let i=0; i<n; i++){\n      const angle = (2*Math.PI * i) / n;\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n      nodes.push(createNode(i+1, x, y));\n    }\n\n    // Connect nodes to form a spanning tree first (to ensure connectivity)\n    let connected = new Set();\n    connected.add(1);\n    const remaining = new Set();\n    for(let i=2; i<=n; i++) remaining.add(i);\n\n    let edgeId = 1;\n    while(remaining.size > 0){\n      // pick one node from connected and one from remaining\n      let cArray = Array.from(connected);\n      let rArray = Array.from(remaining);\n      const u = cArray[Math.floor(Math.random()*cArray.length)];\n      const v = rArray[Math.floor(Math.random()*rArray.length)];\n      // Weight random 1 to 20\n      const w = Math.floor(Math.random()*20)+1;\n      let uNode = nodes.find(nd=>nd.id === u);\n      let vNode = nodes.find(nd=>nd.id === v);\n      edges.push(createEdge(edgeId++, uNode, vNode, w));\n      connected.add(v);\n      remaining.delete(v);\n    }\n\n    // Add some additional random edges to make the graph denser\n    const maxEdges = n*(n-1)/2;\n    const currentEdges = edges.length;\n    const additionalEdgesCount = Math.min(n*2, maxEdges - currentEdges);\n    let attempts = 0;\n    while(additionalEdgesCount > 0 && attempts < 1000){\n      const u = Math.floor(Math.random()*n)+1;\n      const v = Math.floor(Math.random()*n)+1;\n      if(u === v) { attempts++; continue;}\n      // Check if edge exists already\n      const exists = edges.some(e => (e.u === u && e.v === v) || (e.u === v && e.v === u));\n      if(exists) {\n        attempts++;\n        continue;\n      }\n      const w = Math.floor(Math.random()*20)+1;\n      let uNode = nodes.find(nd=>nd.id === u);\n      let vNode = nodes.find(nd=>nd.id === v);\n      edges.push(createEdge(edgeId++, uNode, vNode, w));\n      if(edges.length >= currentEdges + additionalEdgesCount) break;\n      attempts++;\n    }\n\n    // Attach events to nodes (for selection)\n    nodes.forEach(node => {\n      node.group.style.pointerEvents = \"auto\";\n      node.group.onclick = () => {\n        setSelectedNode(node.id);\n      };\n    });\n\n    clearLog();\n    log(`Generated random graph with ${n} nodes and ${edges.length} edges.`);\n    selectedNodeId = null;\n    updateButtons();\n    clearPrimState();\n    updateGraphStyles();\n  }\n\n  function setSelectedNode(id){\n    if(selectedNodeId === id) return;\n    selectedNodeId = id;\n    nodes.forEach(nd => {\n      if(nd.id === id){\n        nd.circleElement.classList.add(\"selected\");\n      } else {\n        nd.circleElement.classList.remove(\"selected\");\n      }\n    });\n    log(`Selected node ${id} as start node.`);\n    updateButtons();\n  }\n\n  function updateButtons(){\n    startBtn.disabled = (selectedNodeId === null) || (primState !== null);\n    stepBtn.disabled = primState === null;\n    resetBtn.disabled = primState === null;\n  }\n\n  function clearPrimState(){\n    if(primState !== null){\n      primState = null;\n    }\n    // Reset edge styles:\n    edges.forEach(e => {\n      e.inMST = false;\n    });\n    updateGraphStyles();\n    updateButtons();\n  }\n\n  // Update visual style of edges and nodes based on MST inclusion\n  function updateGraphStyles(){\n    edges.forEach(e => {\n      if(e.inMST){\n        e.lineElement.classList.add(\"in-mst\");\n      } else {\n        e.lineElement.classList.remove(\"in-mst\");\n      }\n    });\n  }\n\n  // Prim's algorithm initialization\n  function startPrim(){\n    if(selectedNodeId === null) return;\n    clearLog();\n    log(`Starting Prim's Algorithm at node ${selectedNodeId}`);\n    primState = {\n      startNode: selectedNodeId,\n      mstSet: new Set([selectedNodeId]),\n      edgeQueue: new PriorityQueue(),\n      mstEdges: [],\n      step: 0\n    };\n    // Add edges adjacent to startNode to the queue\n    addAdjacentEdges(selectedNodeId);\n    updateButtons();\n  }\n\n  // Add edges that connect mstSet to outside vertices into the queue\n  function addAdjacentEdges(nodeId){\n    edges.forEach(e => {\n      if( (e.u === nodeId && !primState.mstSet.has(e.v)) ||\n          (e.v === nodeId && !primState.mstSet.has(e.u))){\n        primState.edgeQueue.enqueue(e);\n        log(`Added edge (${e.u} — ${e.v}) with weight ${e.weight} to candidates.`);\n      }\n    });\n  }\n\n  const highlightTimeoutDelay = 1200;\n  let highlightTimeoutHandle = null;\n\n  function stepPrim(){\n    if(primState === null) return;\n\n    // If all nodes included, done\n    if(primState.mstSet.size === nodes.length){\n      log(\"All nodes included in MST. Prim's algorithm completed.\");\n      stepBtn.disabled = true;\n      return;\n    }\n\n    let edge = null;\n    // Extract min edge that connects mstSet to outside\n    while(!primState.edgeQueue.isEmpty()){\n      let e = primState.edgeQueue.dequeue();\n      const uIn = primState.mstSet.has(e.u);\n      const vIn = primState.mstSet.has(e.v);\n      if( (uIn && !vIn) || (vIn && !uIn) ){\n        edge = e;\n        break;\n      }\n    }\n\n    if(edge === null){\n      log(\"No connecting edges found. Graph might be disconnected.\");\n      stepBtn.disabled = true;\n      return;\n    }\n\n    // Highlight edge temporarily\n    highlightEdge(edge);\n\n    primState.step++;\n    const newNode = primState.mstSet.has(edge.u) ? edge.v : edge.u;\n    primState.mstSet.add(newNode);\n    primState.mstEdges.push(edge);\n    edge.inMST = true;\n\n    log(`Step ${primState.step}: Selected edge (${edge.u} — ${edge.v}) weight ${edge.weight}, adding node ${newNode} to MST.`);\n\n    // Add new adjacent edges for the newly included node\n    addAdjacentEdges(newNode);\n    updateGraphStyles();\n\n    if(primState.mstSet.size === nodes.length){\n      log(\"All nodes included in MST. Prim's algorithm completed.\");\n      stepBtn.disabled = true;\n    }\n  }\n\n  // Visually highlight edge briefly\n  function highlightEdge(edge){\n    edge.lineElement.style.stroke = \"#f1c40f\";\n    edge.lineElement.style.strokeWidth = \"6px\";\n\n    if(highlightTimeoutHandle) clearTimeout(highlightTimeoutHandle);\n    highlightTimeoutHandle = setTimeout(() => {\n      edge.lineElement.style.stroke = \"\";\n      edge.lineElement.style.strokeWidth = \"\";\n      updateGraphStyles();\n    }, highlightTimeoutDelay);\n  }\n\n  generateBtn.onclick = () => {\n    let n = parseInt(nodeCountInput.value);\n    if(isNaN(n) || n < 2 || n > 10){\n      alert(\"Please enter a number of nodes between 2 and 10.\");\n      return;\n    }\n    generateRandomGraph(n);\n  };\n\n  startBtn.onclick = () => {\n    startPrim();\n  };\n\n  stepBtn.onclick = () => {\n    stepPrim();\n  };\n\n  resetBtn.onclick = () => {\n    clearPrimState();\n    startBtn.disabled = (selectedNodeId === null);\n    stepBtn.disabled = true;\n    resetBtn.disabled = true;\n    log(\"Algorithm reset.\");\n  };\n\n  window.addEventListener('resize', () => {\n    // Redraw graph positions on resize\n    if(nodes.length > 0){\n      generateRandomGraph(nodes.length);\n    }\n  });\n\n  // Initial graph on load\n  window.onload = () => {\n    generateRandomGraph(parseInt(nodeCountInput.value));\n  };\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}