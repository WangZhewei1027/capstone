{
  "id": "7abe5c00-cd32-11f0-a96f-2d591ffb35fe",
  "timestamp": "2025-11-29T14:49:55.133Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Binary Search Tree (BST) Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f9f9f9;\n  }\n  h1 {\n    text-align: center;\n  }\n  #bst-input {\n    margin-bottom: 10px;\n  }\n  #bst-input input[type=\"number\"] {\n    padding: 5px;\n    width: 120px;\n    font-size: 16px;\n  }\n  #bst-input button {\n    padding: 6px 12px;\n    font-size: 16px;\n    margin-left: 6px;\n    cursor: pointer;\n  }\n\n  #operations {\n    margin: 15px 0;\n  }\n\n  #operations input[type=\"number\"] {\n    width: 120px;\n    font-size: 16px;\n    padding: 5px;\n  }\n  #operations button {\n    font-size: 16px;\n    padding: 6px 12px;\n    margin-left: 6px;\n    cursor: pointer;\n  }\n  #output {\n    margin-top: 20px;\n    background: #fff;\n    border: 1px solid #ccc;\n    min-height: 100px;\n    padding: 10px;\n    font-family: monospace;\n    white-space: pre-wrap;\n  }\n\n  #tree-container {\n    margin-top: 30px;\n    text-align: center;\n  }\n  svg {\n    border: 1px solid #ccc;\n    background: white;\n  }\n</style>\n</head>\n<body>\n<h1>Binary Search Tree (BST) Interactive Demo</h1>\n\n<div id=\"bst-input\">\n  <label for=\"insert-value\">Insert number:</label>\n  <input type=\"number\" id=\"insert-value\" />\n  <button id=\"insert-btn\">Insert</button>\n  <button id=\"clear-btn\" title=\"Clear entire tree\">Clear Tree</button>\n</div>\n\n<div id=\"operations\">\n  <label for=\"search-value\">Search:</label>\n  <input type=\"number\" id=\"search-value\" />\n  <button id=\"search-btn\">Search</button>\n\n  <label for=\"delete-value\" style=\"margin-left: 30px;\">Delete:</label>\n  <input type=\"number\" id=\"delete-value\" />\n  <button id=\"delete-btn\">Delete</button>\n</div>\n\n<div id=\"output\" aria-live=\"polite\"></div>\n\n<div id=\"tree-container\">\n  <svg id=\"bst-svg\" width=\"1000\" height=\"400\" role=\"img\" aria-label=\"Binary Search Tree Visualization\"></svg>\n</div>\n\n<script>\n  class Node {\n    constructor(val) {\n      this.val = val;\n      this.left = null;\n      this.right = null;\n      this.x = 0; // position for visualization\n      this.y = 0;\n    }\n  }\n\n  class BST {\n    constructor() {\n      this.root = null;\n    }\n\n    insert(val) {\n      this.root = this._insert(this.root, val);\n    }\n\n    _insert(node, val) {\n      if (node === null) return new Node(val);\n      if (val === node.val) return node; // no duplicates\n      if (val < node.val) {\n        node.left = this._insert(node.left, val);\n      } else {\n        node.right = this._insert(node.right, val);\n      }\n      return node;\n    }\n\n    search(val) {\n      return this._search(this.root, val);\n    }\n\n    _search(node, val) {\n      if (node === null) return null;\n      if (val === node.val) return node;\n      else if (val < node.val) return this._search(node.left, val);\n      else return this._search(node.right, val);\n    }\n\n    delete(val) {\n      let found = { deleted: false };\n      this.root = this._delete(this.root, val, found);\n      return found.deleted;\n    }\n\n    _delete(node, val, found) {\n      if (node === null) return null;\n\n      if (val < node.val) {\n        node.left = this._delete(node.left, val, found);\n      } else if (val > node.val) {\n        node.right = this._delete(node.right, val, found);\n      } else {\n        found.deleted = true;\n        // node with only one child or no child\n        if (!node.left) return node.right;\n        if (!node.right) return node.left;\n\n        // node with two children: get inorder successor (smallest in right subtree)\n        let successor = this._minValueNode(node.right);\n        node.val = successor.val;\n        node.right = this._delete(node.right, successor.val, found);\n      }\n      return node;\n    }\n\n    _minValueNode(node) {\n      let current = node;\n      while (current && current.left != null) {\n        current = current.left;\n      }\n      return current;\n    }\n\n    inorder() {\n      let res = [];\n      this._inorder(this.root, res);\n      return res;\n    }\n\n    _inorder(node, res) {\n      if (node === null) return;\n      this._inorder(node.left, res);\n      res.push(node.val);\n      this._inorder(node.right, res);\n    }\n  }\n\n  // --- Visualization ---\n\n  const svg = document.getElementById(\"bst-svg\");\n  const WIDTH = svg.clientWidth;\n  const HEIGHT = svg.clientHeight;\n  const NODE_RADIUS = 20;\n  const LEVEL_HEIGHT = 70;\n\n  function clearSVG() {\n    while (svg.lastChild) svg.removeChild(svg.lastChild);\n  }\n\n  // Assign positions with a DFS + in-order traversal to spread nodes horizontally\n  function assignPositions(root) {\n    let positions = [];\n    let x = 0;\n    function inorderPos(node, depth) {\n      if (node === null) return;\n      inorderPos(node.left, depth + 1);\n      node.x = x;\n      node.y = depth;\n      x++;\n      inorderPos(node.right, depth + 1);\n    }\n    inorderPos(root, 0);\n  }\n\n  // Scale x position to width nicely\n  function scalePositions(maxIndex) {\n    // Map node.x in [0, maxIndex-1] to [NODE_RADIUS*2, WIDTH - NODE_RADIUS*2]\n    return function(x) {\n      if (maxIndex <= 1) return WIDTH / 2;\n      return NODE_RADIUS * 2 + (x / (maxIndex - 1)) * (WIDTH - NODE_RADIUS * 4);\n    };\n  }\n\n  function drawBST(tree, highlightNode = null, deletedNodeVal = null) {\n    clearSVG();\n    if (!tree.root) return;\n\n    assignPositions(tree.root);\n    // Find max x value (number of nodes)\n    const maxIndex = countNodes(tree.root);\n\n    const scaleX = scalePositions(maxIndex);\n\n    function drawEdges(node) {\n      if (!node) return;\n      if (node.left) {\n        drawLine(node, node.left);\n        drawEdges(node.left);\n      }\n      if (node.right) {\n        drawLine(node, node.right);\n        drawEdges(node.right);\n      }\n    }\n\n    function drawLine(parent, child) {\n      const startX = scaleX(parent.x);\n      const startY = parent.y * LEVEL_HEIGHT + NODE_RADIUS + 10;\n      const endX = scaleX(child.x);\n      const endY = child.y * LEVEL_HEIGHT + NODE_RADIUS + 10;\n\n      const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n      line.setAttribute(\"x1\", startX);\n      line.setAttribute(\"y1\", startY);\n      line.setAttribute(\"x2\", endX);\n      line.setAttribute(\"y2\", endY);\n      line.setAttribute(\"stroke\", \"#555\");\n      line.setAttribute(\"stroke-width\", \"2\");\n      svg.appendChild(line);\n    }\n\n    function drawNode(node) {\n      const cx = scaleX(node.x);\n      const cy = node.y * LEVEL_HEIGHT + NODE_RADIUS + 10;\n\n      const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      g.setAttribute(\"tabindex\", \"0\");\n      g.setAttribute(\"role\", \"img\");\n      g.setAttribute(\"aria-label\", `Node with value ${node.val}`);\n      g.style.cursor = \"default\";\n\n      const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n      circle.setAttribute(\"cx\", cx);\n      circle.setAttribute(\"cy\", cy);\n      circle.setAttribute(\"r\", NODE_RADIUS);\n      circle.setAttribute(\"stroke\", \"#333\");\n      circle.setAttribute(\"stroke-width\", \"2\");\n\n      if (highlightNode && node === highlightNode) {\n        circle.setAttribute(\"fill\", \"#ffd54f\");\n      } else if (deletedNodeVal !== null && node.val === deletedNodeVal) {\n        circle.setAttribute(\"fill\", \"#ef5350\");\n      } else {\n        circle.setAttribute(\"fill\", \"#90caf9\");\n      }\n\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      text.setAttribute(\"x\", cx);\n      text.setAttribute(\"y\", cy + 6);\n      text.setAttribute(\"font-size\", \"14\");\n      text.setAttribute(\"font-weight\", \"bold\");\n      text.setAttribute(\"fill\", \"#212121\");\n      text.setAttribute(\"text-anchor\", \"middle\");\n      text.textContent = node.val;\n\n      g.appendChild(circle);\n      g.appendChild(text);\n      svg.appendChild(g);\n    }\n\n    drawEdges(tree.root);\n    drawAllNodes(tree.root);\n\n    function drawAllNodes(node) {\n      if (!node) return;\n      drawAllNodes(node.left);\n      drawNode(node);\n      drawAllNodes(node.right);\n    }\n  }\n\n  function countNodes(node) {\n    if (!node) return 0;\n    return 1 + countNodes(node.left) + countNodes(node.right);\n  }\n\n  // --- UI Logic ---\n\n  const bst = new BST();\n  const output = document.getElementById(\"output\");\n  const insertInput = document.getElementById(\"insert-value\");\n  const insertBtn = document.getElementById(\"insert-btn\");\n  const clearBtn = document.getElementById(\"clear-btn\");\n  const searchInput = document.getElementById(\"search-value\");\n  const searchBtn = document.getElementById(\"search-btn\");\n  const deleteInput = document.getElementById(\"delete-value\");\n  const deleteBtn = document.getElementById(\"delete-btn\");\n\n  function printOutput(message) {\n    output.textContent = message;\n  }\n\n  insertBtn.onclick = () => {\n    const val = Number(insertInput.value);\n    if (Number.isNaN(val)) {\n      printOutput(\"Please enter a valid number to insert.\");\n      return;\n    }\n    if (bst.search(val)) {\n      printOutput(`Value ${val} already exists in the BST (duplicates not allowed).`);\n      insertInput.value = \"\";\n      drawBST(bst);\n      return;\n    }\n    bst.insert(val);\n    printOutput(`Inserted value: ${val}\\nIn-Order Traversal: [${bst.inorder().join(\", \")}]`);\n    insertInput.value = \"\";\n    drawBST(bst);\n  };\n\n  searchBtn.onclick = () => {\n    const val = Number(searchInput.value);\n    if (Number.isNaN(val)) {\n      printOutput(\"Please enter a valid number to search.\");\n      return;\n    }\n    const node = bst.search(val);\n    if (node) {\n      printOutput(`Search: Value ${val} found in the BST.`);\n      drawBST(bst, node);\n    } else {\n      printOutput(`Search: Value ${val} NOT found.`);\n      drawBST(bst);\n    }\n    searchInput.value = \"\";\n  };\n\n  deleteBtn.onclick = () => {\n    const val = Number(deleteInput.value);\n    if (Number.isNaN(val)) {\n      printOutput(\"Please enter a valid number to delete.\");\n      return;\n    }\n    const deleted = bst.delete(val);\n    if (deleted) {\n      printOutput(`Deleted value: ${val}\\nIn-Order Traversal: [${bst.inorder().join(\", \")}]`);\n      drawBST(bst, null, val);\n    } else {\n      printOutput(`Delete: Value ${val} not found in BST.`);\n      drawBST(bst);\n    }\n    deleteInput.value = \"\";\n  };\n\n  clearBtn.onclick = () => {\n    bst.root = null;\n    printOutput(\"BST cleared.\");\n    drawBST(bst);\n    insertInput.value = \"\";\n    searchInput.value = \"\";\n    deleteInput.value = \"\";\n  };\n\n  // Initial draw (empty)\n  drawBST(bst);\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": false,
  "hasTest": true
}