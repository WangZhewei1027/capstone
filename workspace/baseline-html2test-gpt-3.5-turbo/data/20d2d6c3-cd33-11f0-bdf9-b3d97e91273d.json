{
  "id": "20d2d6c3-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:49.631Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Dijkstra's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    display: flex;\n    height: 100vh;\n    overflow: hidden;\n  }\n  #leftPanel {\n    width: 320px;\n    background: #f0f0f0;\n    padding: 15px;\n    box-sizing: border-box;\n    overflow-y: auto;\n  }\n  #leftPanel h2 {\n    margin-top: 0;\n  }\n  #graphCanvas {\n    flex: 1;\n    background: #222;\n    display: block;\n  }\n  label {\n    display: block;\n    margin-top: 15px;\n    font-weight: bold;\n  }\n  select, button {\n    width: 100%;\n    padding: 8px;\n    margin-top: 5px;\n    font-size: 1em;\n  }\n  #distanceTable {\n    margin-top: 15px;\n    border-collapse: collapse;\n    width: 100%;\n  }\n  #distanceTable th, #distanceTable td {\n    border: 1px solid #ccc;\n    padding: 6px 8px;\n    text-align: center;\n  }\n  #steps {\n    margin-top: 10px;\n    background: #fff;\n    padding: 10px;\n    height: 220px;\n    overflow-y: auto;\n    font-size: 0.9em;\n    line-height: 1.3;\n    white-space: pre-wrap;\n    border: 1px solid #ccc;\n  }\n  #footer {\n    font-size: 0.8em;\n    color: #555;\n    margin-top: 20px;\n  }\n</style>\n</head>\n<body>\n\n<div id=\"leftPanel\">\n  <h2>Dijkstra's Algorithm</h2>\n  <label for=\"startNode\">Select Start Node:</label>\n  <select id=\"startNode\"></select>\n\n  <button id=\"runBtn\">Run Algorithm</button>\n  <button id=\"resetBtn\" style=\"margin-top: 8px;\">Reset</button>\n\n  <h3>Distances from Start Node</h3>\n  <table id=\"distanceTable\" aria-label=\"Distances table\">\n    <thead><tr><th>Node</th><th>Distance</th><th>Previous</th></tr></thead>\n    <tbody></tbody>\n  </table>\n\n  <h3>Algorithm Steps</h3>\n  <div id=\"steps\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n\n  <div id=\"footer\">Click nodes on the graph to set edges (drag from one node to another).\n  You can drag nodes to reposition.<br><br>Edges show weights. Running starts from selected node.</div>\n</div>\n\n<canvas id=\"graphCanvas\" tabindex=\"0\" aria-label=\"Graph visualization\"></canvas>\n\n<script>\n(() => {\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n  const startNodeSelect = document.getElementById('startNode');\n  const runBtn = document.getElementById('runBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const distanceTableBody = document.querySelector('#distanceTable tbody');\n  const stepsDiv = document.getElementById('steps');\n\n  // Constants\n  const NODE_RADIUS = 20;\n  const NODE_COLOR = '#4a90e2';\n  const NODE_COLOR_SELECTED = '#f5a623';\n  const NODE_COLOR_VISITED = '#50e3c2';\n  const EDGE_COLOR = '#999';\n  const EDGE_COLOR_HIGHLIGHT = '#f5a623';\n  const EDGE_WEIGHT_BG = '#333';\n  const EDGE_WEIGHT_TEXT = '#eee';\n\n  // Graph data structures\n  // We'll use an adjacency list:\n  // nodes: array of {id, x, y}\n  // edges: array of {from, to, weight}\n  // Undirected graph for demo simplicity\n  let nodes = [];\n  let edges = [];\n\n  // Interaction state\n  let draggingNode = null;\n  let dragOffset = {x:0,y:0};\n  let creatingEdge = null;  // node id from which edge is created\n  let hoverNode = null;\n  let hoverEdge = null;\n\n  // Algorithm state\n  let distances = {};\n  let previous = {};\n  let visited = new Set();\n  let algorithmRunning = false;\n\n  // Utility Functions\n  function distanceBetween(x1,y1,x2,y2){\n    return Math.sqrt((x1-x2)**2 + (y1-y2)**2);\n  }\n\n  function clearCanvas(){\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n  }\n\n  function drawNode(node, options = {}){\n    const {highlight=false, visited=false, selected=false} = options;\n    ctx.beginPath();\n    ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI*2);\n    if(selected){\n      ctx.fillStyle = NODE_COLOR_SELECTED;\n    } else if(visited){\n      ctx.fillStyle = NODE_COLOR_VISITED;\n    } else if(highlight){\n      ctx.fillStyle = '#7b9aff';\n    } else {\n      ctx.fillStyle = NODE_COLOR;\n    }\n    ctx.fill();\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = '#222';\n    ctx.stroke();\n\n    // Node label\n    ctx.fillStyle = '#fff';\n    ctx.font = 'bold 16px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(node.id, node.x, node.y);\n  }\n\n  function drawEdge(edge, options = {}) {\n    const {highlight=false} = options;\n    const fromNode = nodes.find(n => n.id === edge.from);\n    const toNode = nodes.find(n => n.id === edge.to);\n    if(!fromNode || !toNode) return;\n\n    ctx.beginPath();\n    ctx.lineWidth = highlight ? 4 : 2;\n    ctx.strokeStyle = highlight ? EDGE_COLOR_HIGHLIGHT : EDGE_COLOR;\n\n    // Draw line from fromNode to toNode, but offset so line doesn't cross node center (for better aesthetics)\n    const dx = toNode.x - fromNode.x;\n    const dy = toNode.y - fromNode.y;\n    const dist = Math.sqrt(dx*dx+dy*dy);\n    if(dist === 0) return;\n\n    const offsetX = (dx/dist)*NODE_RADIUS;\n    const offsetY = (dy/dist)*NODE_RADIUS;\n    ctx.moveTo(fromNode.x + offsetX, fromNode.y + offsetY);\n    ctx.lineTo(toNode.x - offsetX, toNode.y - offsetY);\n    ctx.stroke();\n\n    // Draw weight label at midpoint\n    const midX = (fromNode.x + toNode.x)/2;\n    const midY = (fromNode.y + toNode.y)/2;\n    const label = edge.weight.toString();\n\n    ctx.font = '14px Arial';\n    const textWidth = ctx.measureText(label).width;\n    const textHeight = 14;\n\n    ctx.fillStyle = EDGE_WEIGHT_BG;\n    ctx.strokeStyle = 'rgba(0,0,0,0.5)';\n    const padding = 4;\n    ctx.lineWidth = 2;\n    ctx.fillRect(midX - textWidth/2 - padding, midY - textHeight/2 - padding/2, textWidth + 2*padding, textHeight + padding);\n    ctx.strokeRect(midX - textWidth/2 - padding, midY - textHeight/2 - padding/2, textWidth + 2*padding, textHeight + padding);\n\n    ctx.fillStyle = EDGE_WEIGHT_TEXT;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(label, midX, midY);\n  }\n\n  // Detect if mouse is on a node\n  function nodeAtPosition(x,y){\n    return nodes.find(n => distanceBetween(n.x, n.y, x, y) <= NODE_RADIUS);\n  }\n\n  // Detect edge at position (rough estimation: distance from point to line segment)\n  function edgeAtPosition(x,y){\n    for(let edge of edges){\n      const fromNode = nodes.find(n => n.id === edge.from);\n      const toNode = nodes.find(n => n.id === edge.to);\n      if(!fromNode || !toNode) continue;\n      // Distance from point (x,y) to line segment fromNode->toNode\n      let dist = pointToSegmentDistance(x,y,fromNode.x,fromNode.y,toNode.x,toNode.y);\n      if(dist < 8) return edge;\n    }\n    return null;\n  }\n\n  // Compute distance from point (px,py) to line segment (x1,y1)-(x2,y2)\n  function pointToSegmentDistance(px, py, x1, y1, x2, y2){\n    let dx = x2 - x1;\n    let dy = y2 - y1;\n    if(dx === 0 && dy === 0){\n      return distanceBetween(px, py, x1, y1);\n    }\n    let t = ((px - x1)*dx + (py - y1)*dy)/(dx*dx + dy*dy);\n    t = Math.max(0, Math.min(1, t));\n    const projX = x1 + t*dx;\n    const projY = y1 + t*dy;\n    return distanceBetween(px, py, projX, projY);\n  }\n\n  // Draw everything\n  function drawGraph(highlightEdges = []) {\n    clearCanvas();\n    // Draw edges first\n    for(let edge of edges){\n      let highlight = highlightEdges.some(e=>(\n        (e.from === edge.from && e.to === edge.to) || (e.from === edge.to && e.to === edge.from)\n      ));\n      drawEdge(edge, {highlight});\n    }\n\n    // Draw nodes\n    for(let node of nodes){\n      const visitedFlag = visited.has(node.id);\n      const selectedFlag = node.id === startNodeSelect.value;\n      const highlightFlag = node === hoverNode || node === creatingEdge;\n      drawNode(node, {visited: visitedFlag, selected: selectedFlag, highlight: highlightFlag});\n    }\n\n    // If creating edge, draw a line from originating node to mouse\n    if(creatingEdge && mousePos){\n      const fromNode = nodes.find(n=>n.id === creatingEdge);\n      if(fromNode){\n        ctx.beginPath();\n        ctx.strokeStyle = 'orange';\n        ctx.lineWidth = 2;\n        ctx.moveTo(fromNode.x, fromNode.y);\n        ctx.lineTo(mousePos.x, mousePos.y);\n        ctx.stroke();\n      }\n    }\n  }\n\n  // Populate start node options\n  function populateStartNodeOptions(){\n    startNodeSelect.innerHTML = '';\n    for(let node of nodes){\n      let option = document.createElement('option');\n      option.value = node.id;\n      option.textContent = node.id;\n      startNodeSelect.appendChild(option);\n    }\n  }\n\n  // Initialize graph with some nodes & edges\n  function initGraph(){\n    nodes = [\n      {id: 'A', x: 100, y: 150},\n      {id: 'B', x: 270, y: 80},\n      {id: 'C', x: 450, y: 140},\n      {id: 'D', x: 380, y: 280},\n      {id: 'E', x: 150, y: 300},\n      {id: 'F', x: 600, y: 200}\n    ];\n    edges = [\n      {from: 'A', to: 'B', weight: 4},\n      {from: 'A', to: 'E', weight: 7},\n      {from: 'B', to: 'C', weight: 8},\n      {from: 'B', to: 'E', weight: 11},\n      {from: 'C', to: 'D', weight: 2},\n      {from: 'D', to: 'E', weight: 6},\n      {from: 'C', to: 'F', weight: 7},\n      {from: 'D', to: 'F', weight: 14}\n    ];\n    distances = {};\n    previous = {};\n    visited = new Set();\n    algorithmRunning = false;\n    stepsDiv.textContent = '';\n    populateStartNodeOptions();\n  }\n\n  // Resize canvas to window size minus left panel\n  function resizeCanvas(){\n    canvas.width = window.innerWidth - 320;\n    canvas.height = window.innerHeight;\n    drawGraph();\n  }\n\n  // Convert mouse event coords to canvas coords\n  function getMousePos(evt){\n    const rect = canvas.getBoundingClientRect();\n    return {\n      x: evt.clientX - rect.left,\n      y: evt.clientY - rect.top\n    };\n  }\n\n  // Add / edit edges weights via prompt\n  function editEdgeWeight(edge){\n    let newWeight = prompt('Enter new weight (positive integer):', edge.weight);\n    if(newWeight === null) return; // cancel\n    newWeight = parseInt(newWeight);\n    if(isNaN(newWeight) || newWeight <= 0){\n      alert('Invalid weight. Must be a positive integer.');\n      return;\n    }\n    edge.weight = newWeight;\n    drawGraph();\n  }\n\n  // Update distances table\n  function updateDistancesTable(){\n    distanceTableBody.innerHTML = '';\n    for(let node of nodes){\n      let tr = document.createElement('tr');\n      let tdNode = document.createElement('td');\n      tdNode.textContent = node.id;\n      let tdDist = document.createElement('td');\n      tdDist.textContent = distances[node.id] === Infinity ? '∞' : distances[node.id];\n      let tdPrev = document.createElement('td');\n      tdPrev.textContent = previous[node.id] ? previous[node.id] : '-';\n      tr.appendChild(tdNode);\n      tr.appendChild(tdDist);\n      tr.appendChild(tdPrev);\n      distanceTableBody.appendChild(tr);\n    }\n  }\n\n  // Dijkstra's Algorithm Implementation\n\n  // Using a simple priority queue (min heap) implementation.\n  class MinPriorityQueue {\n    constructor(){\n      this.elements = [];\n    }\n    enqueue(item, priority){\n      this.elements.push({item, priority});\n      this.elements.sort((a,b) => a.priority - b.priority);\n    }\n    dequeue(){\n      return this.elements.shift().item;\n    }\n    isEmpty(){\n      return this.elements.length === 0;\n    }\n  }\n\n  function getNeighbors(nodeId){\n    let neighbors = [];\n    for(let edge of edges){\n      if(edge.from === nodeId){\n        neighbors.push({id: edge.to, weight: edge.weight});\n      } else if(edge.to === nodeId){\n        neighbors.push({id: edge.from, weight: edge.weight});\n      }\n    }\n    return neighbors;\n  }\n\n  // Run the algorithm stepwise with animation and update UI\n  async function runDijkstra(startId){\n    algorithmRunning = true;\n    distances = {};\n    previous = {};\n    visited = new Set();\n\n    // Set all distances to infinity\n    for(let node of nodes){\n      distances[node.id] = Infinity;\n      previous[node.id] = null;\n    }\n    distances[startId] = 0;\n    updateDistancesTable();\n\n    const pq = new MinPriorityQueue();\n    pq.enqueue(startId, 0);\n\n    stepsDiv.textContent = `Start from node ${startId}\\n\\n`;\n\n    while(!pq.isEmpty()){\n      const current = pq.dequeue();\n      if(visited.has(current)) continue;\n      visited.add(current);\n\n      stepsDiv.textContent += `Visiting node ${current} with current shortest distance ${distances[current]}\\n`;\n      updateDistancesTable();\n      drawGraph();\n\n      // Highlight edges used to reach current node (single edge from previous)\n      if(previous[current]){\n        drawGraph([{from: previous[current], to: current}]);\n        await sleep(800);\n      } else {\n        await sleep(800);\n      }\n\n      if(distances[current] === Infinity){\n        stepsDiv.textContent += `Node ${current} is unreachable from start node.\\n\\n`;\n        continue;\n      }\n\n      const neighbors = getNeighbors(current);\n\n      for(let neighbor of neighbors){\n        if(visited.has(neighbor.id)) continue;\n        let newDist = distances[current] + neighbor.weight;\n        if(newDist < distances[neighbor.id]){\n          distances[neighbor.id] = newDist;\n          previous[neighbor.id] = current;\n          pq.enqueue(neighbor.id, newDist);\n          stepsDiv.textContent += `Updated distance of node ${neighbor.id} to ${newDist} via ${current}\\n`;\n          updateDistancesTable();\n          drawGraph([{from: current, to: neighbor.id}]);\n          await sleep(700);\n        }\n      }\n      stepsDiv.textContent += '\\n';\n    }\n    algorithmRunning = false;\n    stepsDiv.textContent += 'Algorithm finished!';\n  }\n\n  // Pause helper\n  function sleep(ms){\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Mouse interaction\n  let mousePos = null;\n\n  canvas.addEventListener('mousedown', e => {\n    if(algorithmRunning) return;\n    const pos = getMousePos(e);\n    mousePos = pos;\n    let node = nodeAtPosition(pos.x,pos.y);\n    if(node){\n      draggingNode = node;\n      dragOffset.x = pos.x - node.x;\n      dragOffset.y = pos.y - node.y;\n      return;\n    }\n  });\n\n  canvas.addEventListener('mousemove', e => {\n    if(algorithmRunning) return;\n    const pos = getMousePos(e);\n    mousePos = pos;\n\n    if(draggingNode){\n      draggingNode.x = pos.x - dragOffset.x;\n      draggingNode.y = pos.y - dragOffset.y;\n      drawGraph();\n      return;\n    }\n\n    // Hover logic\n    let node = nodeAtPosition(pos.x, pos.y);\n    if(node !== hoverNode){\n      hoverNode = node;\n      drawGraph();\n    }\n\n    // highlight edges on hover\n    let edge = edgeAtPosition(pos.x,pos.y);\n    if(edge !== hoverEdge){\n      hoverEdge = edge;\n    }\n\n  });\n\n  canvas.addEventListener('mouseup', e => {\n    if(algorithmRunning) return;\n    const pos = getMousePos(e);\n    if(draggingNode){\n      draggingNode = null;\n      drawGraph();\n      return;\n    }\n\n    let nodeClicked = nodeAtPosition(pos.x,pos.y);\n    if(!creatingEdge){\n      // Start edge creation by clicking on node\n      if(nodeClicked){\n        creatingEdge = nodeClicked.id;\n        drawGraph();\n      }\n    } else {\n      // Finish edge creation by clicking second node (could be same)\n      if(nodeClicked && nodeClicked.id !== creatingEdge){\n        // Check if edge already exists between these nodes\n        let existingEdge = edges.find(e => \n          (e.from === creatingEdge && e.to === nodeClicked.id) || \n          (e.to === creatingEdge && e.from === nodeClicked.id)\n        );\n        if(existingEdge){\n          if(confirm('Edge already exists. Do you want to edit its weight?')){\n            editEdgeWeight(existingEdge);\n          }\n        } else {\n          // Create new edge with user input weight\n          let w = prompt(`Enter weight for edge (${creatingEdge} <-> ${nodeClicked.id}):`, '1');\n          if(w !== null){\n            w = parseInt(w);\n            if(isNaN(w) || w <= 0){\n              alert('Invalid weight, edge not created.');\n            } else {\n              edges.push({from: creatingEdge, to: nodeClicked.id, weight: w});\n            }\n          }\n        }\n      }\n      creatingEdge = null;\n      drawGraph();\n    }\n  });\n\n  // Right-click on edge to edit weight\n  canvas.addEventListener('contextmenu', e => {\n    e.preventDefault();\n    if(algorithmRunning) return;\n    const pos = getMousePos(e);\n    let edge = edgeAtPosition(pos.x,pos.y);\n    if(edge){\n      editEdgeWeight(edge);\n    }\n  });\n\n  // Run button\n  runBtn.addEventListener('click', async () => {\n    if(algorithmRunning) return;\n    const startId = startNodeSelect.value;\n    if(!startId){\n      alert('Select a start node!');\n      return;\n    }\n    stepsDiv.textContent = '';\n    visited.clear();\n    await runDijkstra(startId);\n  });\n\n  resetBtn.addEventListener('click', () => {\n    if(algorithmRunning) return;\n    initGraph();\n    drawGraph();\n    stepsDiv.textContent = '';\n    distanceTableBody.innerHTML = '';\n  });\n\n  // Keyboard accessibility: select node with arrows and run\n  let keyboardSelectedIndex = 0;\n  startNodeSelect.addEventListener('keydown', e => {\n    if(e.key === 'Enter'){\n      runBtn.click();\n    }\n  });\n\n  // Initialization\n  function init(){\n    resizeCanvas();\n    initGraph();\n    drawGraph();\n  }\n\n  window.addEventListener('resize', () => {\n    resizeCanvas();\n  });\n\n  init();\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}