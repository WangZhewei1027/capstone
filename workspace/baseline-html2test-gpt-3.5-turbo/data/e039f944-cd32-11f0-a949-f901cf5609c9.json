{
  "id": "e039f944-cd32-11f0-a949-f901cf5609c9",
  "timestamp": "2025-11-29T14:52:36.827Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Red-Black Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Red-Black Tree Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    display: flex; flex-direction: column; align-items: center;\n    background: #f0f0f0;\n  }\n  h1 {\n    margin-top: 1em;\n  }\n  #controls {\n    margin: 1em;\n  }\n  input[type=number] {\n    font-size: 1em;\n    padding: 0.3em;\n    width: 6em;\n  }\n  button {\n    font-size: 1em;\n    padding: 0.4em 1em;\n    margin-left: 0.5em;\n    cursor: pointer;\n  }\n  #canvasContainer {\n    background: white;\n    border: 1px solid #aaa;\n    box-shadow: 0 0 10px #ccc;\n    margin-bottom: 2em;\n    width: 95vw;\n    max-width: 1000px;\n    height: 600px;\n    overflow: auto;\n  }\n  canvas {\n    display: block;\n  }\n  #log {\n    width: 95vw;\n    max-width: 1000px;\n    max-height: 150px;\n    overflow-y: auto;\n    background: #222;\n    color: #eee;\n    font-family: monospace;\n    font-size: 0.9em;\n    border: 1px solid #444;\n    padding: 0.5em;\n    box-sizing: border-box;\n    white-space: pre-wrap;\n  }\n\n  /* Legend */\n  #legend {\n    margin-bottom: 1em;\n    max-width: 1000px;\n    font-size: 0.9em;\n  }\n  .node-red {\n    color: #c0392b;\n    font-weight: bold;\n  }\n  .node-black {\n    color: #2c3e50;\n    font-weight: bold;\n  }\n</style>\n</head>\n<body>\n<h1>Red-Black Tree Visualization</h1>\n<div id=\"controls\">\n  <label for=\"valueInput\">Insert key:</label>\n  <input type=\"number\" id=\"valueInput\" />\n  <button id=\"insertBtn\">Insert</button>\n  <button id=\"clearBtn\">Clear Tree</button>\n</div>\n<div id=\"legend\">\n  <strong>Legend:</strong> \n  <span class=\"node-red\">● Red Node</span> &nbsp;&nbsp; \n  <span class=\"node-black\">● Black Node</span>\n</div>\n<div id=\"canvasContainer\">\n  <canvas id=\"treeCanvas\" width=\"1000\" height=\"600\"></canvas>\n</div>\n<div id=\"log\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n\n<script>\n(() => {\n  // Red-Black Tree Node colors\n  const RED = 'RED';\n  const BLACK = 'BLACK';\n  \n  // Node class\n  class Node {\n    constructor(key) {\n      this.key = key;\n      this.color = RED;\n      this.left = null;\n      this.right = null;\n      this.parent = null;\n    }\n  }\n  \n  // RedBlackTree implementation\n  class RedBlackTree {\n    constructor() {\n      this.nil = new Node(null);\n      this.nil.color = BLACK;\n      this.root = this.nil;\n    }\n    \n    leftRotate(x) {\n      let y = x.right;\n      x.right = y.left;\n      if (y.left !== this.nil) {\n        y.left.parent = x;\n      }\n      y.parent = x.parent;\n      if (x.parent === this.nil) {\n        this.root = y;\n      } else if (x === x.parent.left) {\n        x.parent.left = y;\n      } else {\n        x.parent.right = y;\n      }\n      y.left = x;\n      x.parent = y;\n      log(`Left rotate on node ${x.key}`);\n    }\n    \n    rightRotate(y) {\n      let x = y.left;\n      y.left = x.right;\n      if (x.right !== this.nil) {\n        x.right.parent = y;\n      }\n      x.parent = y.parent;\n      if (y.parent === this.nil) {\n        this.root = x;\n      } else if (y === y.parent.right) {\n        y.parent.right = x;\n      } else {\n        y.parent.left = x;\n      }\n      x.right = y;\n      y.parent = x;\n      log(`Right rotate on node ${y.key}`);\n    }\n    \n    insert(key) {\n      let node = new Node(key);\n      node.left = this.nil;\n      node.right = this.nil;\n      node.parent = this.nil;\n      \n      let y = this.nil;\n      let x = this.root;\n      while (x !== this.nil) {\n        y = x;\n        if (node.key < x.key) {\n          x = x.left;\n        } else if(node.key > x.key) {\n          x = x.right;\n        } else {\n          log(`Key ${key} already present. Duplicates not allowed.`);\n          return false;\n        }\n      }\n      node.parent = y;\n      if (y === this.nil) {\n        this.root = node;\n      } else if (node.key < y.key) {\n        y.left = node;\n      } else {\n        y.right = node;\n      }\n      node.color = RED;\n      log(`Inserted node ${node.key} (color RED)`);\n      this.insertFixup(node);\n      return true;\n    }\n    \n    insertFixup(z) {\n      while (z.parent.color === RED) {\n        if (z.parent === z.parent.parent.left) {\n          let y = z.parent.parent.right;\n          if (y.color === RED) {\n            log(`Case 1 (uncle red) at node ${z.key}`);\n            z.parent.color = BLACK;\n            y.color = BLACK;\n            z.parent.parent.color = RED;\n            z = z.parent.parent;\n          } else {\n            if (z === z.parent.right) {\n              log(`Case 2 (triangle) at node ${z.key}`);\n              z = z.parent;\n              this.leftRotate(z);\n            }\n            log(`Case 3 (line) at node ${z.key}`);\n            z.parent.color = BLACK;\n            z.parent.parent.color = RED;\n            this.rightRotate(z.parent.parent);\n          }\n        } else {\n          let y = z.parent.parent.left;\n          if (y.color === RED) {\n            log(`Case 1 mirror (uncle red) at node ${z.key}`);\n            z.parent.color = BLACK;\n            y.color = BLACK;\n            z.parent.parent.color = RED;\n            z = z.parent.parent;\n          } else {\n            if (z === z.parent.left) {\n              log(`Case 2 mirror (triangle) at node ${z.key}`);\n              z = z.parent;\n              this.rightRotate(z);\n            }\n            log(`Case 3 mirror (line) at node ${z.key}`);\n            z.parent.color = BLACK;\n            z.parent.parent.color = RED;\n            this.leftRotate(z.parent.parent);\n          }\n        }\n        if (z === this.root) {\n          break;\n        }\n      }\n      this.root.color = BLACK;\n      log(`Root set to BLACK`);\n    }\n    \n    inorderWalk(node, func) {\n      if (node !== this.nil) {\n        this.inorderWalk(node.left, func);\n        func(node);\n        this.inorderWalk(node.right, func);\n      }\n    }\n    \n    // For visualization - builds a tree structure with position\n    getNodesWithPositions() {\n      if (this.root === this.nil) return [];\n      // Assign (x,y) using BFS and relative positions\n      let levels = [];\n      let queue = [{node: this.root, depth: 0, pos: 0}];\n      while (queue.length > 0) {\n        let {node, depth, pos} = queue.shift();\n        if (!levels[depth]) levels[depth] = [];\n        levels[depth].push({node, pos});\n        // For pos we just assign index in array, exact X calculated later\n        if (node.left !== this.nil)\n          queue.push({node: node.left, depth: depth+1, pos: 2*pos});\n        if (node.right !== this.nil)\n          queue.push({node: node.right, depth: depth+1, pos: 2*pos+1});\n      }\n      return levels;\n    }\n  }\n\n  // UI and visualization part\n\n  const canvas = document.getElementById('treeCanvas');\n  const ctx = canvas.getContext('2d');\n  const insertBtn = document.getElementById('insertBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const valueInput = document.getElementById('valueInput');\n  const logDiv = document.getElementById('log');\n\n  const TREE_NODE_RADIUS = 20;\n  const VERTICAL_GAP = 70;  \n  const HORIZONTAL_MARGIN = 20;\n  const COLORS = {\n    RED: '#c0392b',\n    BLACK: '#2c3e50',\n    LINE: '#35495e',\n    BACKGROUND: '#fff'\n  };\n\n  let tree = new RedBlackTree();\n\n  // Clear log text\n  function clearLog() {\n    logDiv.textContent = '';\n  }\n\n  // Append a message to log window with time stamp\n  function log(msg) {\n    let time = new Date().toLocaleTimeString();\n    logDiv.textContent += `[${time}] ${msg}\\n`;\n    logDiv.scrollTop = logDiv.scrollHeight;\n  }\n\n  // Calculate horizontal positions for nodes in each level to avoid overlapping\n  function calculatePositions(levels, width) {\n    // levels: array of arrays of {node, pos}\n    // assign x coordinate for each node at each level\n\n    let positions = new Map();\n\n    let maxLevels = levels.length;\n    if (maxLevels === 0) return positions;\n    \n    // The horizontal width for a node: roughly space between nodes on bottom-most level\n    // We use the bottom level's count to divide width\n    \n    // Bottom level nodes (usually the most)\n    let bottomCount = levels[maxLevels - 1].length;\n\n    let nodeGap = Math.max(TREE_NODE_RADIUS*2 + 10,\n      (width - 2*HORIZONTAL_MARGIN) / bottomCount);\n\n    // We calculate x pos for bottom level nodes\n    levels[maxLevels - 1].forEach((entry, index) => {\n      let x = HORIZONTAL_MARGIN + nodeGap/2 + index * nodeGap;\n      positions.set(entry.node, {x: x, y: VERTICAL_GAP * (maxLevels - 1) + TREE_NODE_RADIUS + 10});\n    });\n\n    // Now for each upper level, calculate x pos as average of children if exists\n    for (let level = maxLevels - 2; level >= 0; level--) {\n      levels[level].forEach(entry => {\n        let node = entry.node;\n        let leftPos = positions.get(node.left);\n        let rightPos = positions.get(node.right);\n        let y = VERTICAL_GAP * level + TREE_NODE_RADIUS + 10;\n        let x;\n        if (leftPos && rightPos) {\n          x = (leftPos.x + rightPos.x) / 2;\n        } else if (leftPos) {\n          x = leftPos.x + nodeGap / 2;\n        } else if (rightPos) {\n          x = rightPos.x - nodeGap / 2;\n        } else {\n          // Leaf node\n          x = HORIZONTAL_MARGIN + nodeGap/2 + entry.pos * nodeGap;\n        }\n        positions.set(node, {x, y});\n      });\n    }\n    return positions;\n  }\n\n  // Draw a node with key, color, and position\n  function drawNode(node, x, y) {\n    ctx.beginPath();\n    ctx.arc(x, y, TREE_NODE_RADIUS, 0, 2*Math.PI);\n    ctx.fillStyle = node.color === RED ? COLORS.RED : COLORS.BLACK;\n    ctx.fill();\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = '#333';\n    ctx.stroke();\n\n    // Text - white for red nodes, white for black nodes\n    ctx.fillStyle = node.color === RED ? '#fff' : '#fff';\n    ctx.font = '16px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(node.key, x, y);\n  }\n\n  // Draw edge between parent and child nodes\n  function drawEdge(x1, y1, x2, y2) {\n    ctx.beginPath();\n    ctx.strokeStyle = COLORS.LINE;\n    ctx.lineWidth = 2;\n    ctx.moveTo(x1, y1 + TREE_NODE_RADIUS);\n    ctx.lineTo(x2, y2 - TREE_NODE_RADIUS);\n    ctx.stroke();\n  }\n\n  // Clear canvas\n  function clearCanvas() {\n    ctx.fillStyle = COLORS.BACKGROUND;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n  }\n\n  // Draw tree to canvas\n  function drawTree() {\n    clearCanvas();\n    let levels = tree.getNodesWithPositions();\n    let positions = calculatePositions(levels, canvas.width);\n    if (positions.size === 0) return;\n\n    // Draw edges first\n    positions.forEach((pos, node) => {\n      if (node.left !== tree.nil) {\n        let childPos = positions.get(node.left);\n        drawEdge(pos.x, pos.y, childPos.x, childPos.y);\n      }\n      if (node.right !== tree.nil) {\n        let childPos = positions.get(node.right);\n        drawEdge(pos.x, pos.y, childPos.x, childPos.y);\n      }\n    });\n\n    // Draw nodes on top\n    positions.forEach((pos, node) => {\n      drawNode(node, pos.x, pos.y);\n    });\n  }\n\n  // Insert key from input and redraw tree\n  function insertKey() {\n    let val = parseInt(valueInput.value);\n    if (isNaN(val)) {\n      alert('Please enter a valid integer');\n      return;\n    }\n    if(val === null) return;\n    if(tree.insert(val)) {\n      drawTree();\n    }\n    valueInput.value = '';\n    valueInput.focus();\n  }\n\n  // Clear the entire tree (reset)\n  function clearTree() {\n    tree = new RedBlackTree();\n    clearCanvas();\n    clearLog();\n  }\n\n  // Event listeners\n  insertBtn.addEventListener('click', insertKey);\n  clearBtn.addEventListener('click', clearTree);\n  valueInput.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter') {\n      insertKey();\n    }\n  });\n\n  // Initial welcome message in log\n  log(\"Welcome! Enter integer keys and click 'Insert' to build the Red-Black Tree.\");\n  log(\"Duplicates are not allowed.\");\n  valueInput.focus();\n\n  // Initial draw call for empty tree\n  drawTree();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Red-Black Tree"
    }
  ],
  "topic": "Red-Black Tree",
  "hasFSM": false,
  "hasTest": true
}