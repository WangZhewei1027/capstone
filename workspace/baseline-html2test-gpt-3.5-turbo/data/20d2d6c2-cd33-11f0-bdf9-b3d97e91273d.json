{
  "id": "20d2d6c2-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:33.925Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Breadth-First Search (BFS) Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f5f5f5;\n  }\n  h1 {\n    text-align: center;\n  }\n  #graph-container {\n    margin: 20px auto;\n    width: 600px;\n    height: 400px;\n    border: 2px solid #444;\n    border-radius: 8px;\n    background: white;\n    position: relative;\n  }\n  svg {\n    width: 100%;\n    height: 100%;\n    overflow: visible;\n  }\n  circle.node {\n    fill: #ddd;\n    stroke: #666;\n    stroke-width: 2px;\n    cursor: pointer;\n    transition: fill 0.3s, stroke 0.3s;\n  }\n  circle.node.visited {\n    fill: #7bc8a4;\n    stroke: #3a7d44;\n  }\n  circle.node.current {\n    fill: #f9d71c;\n    stroke: #b38b00;\n  }\n  circle.node.start {\n    fill: #4a90e2;\n    stroke: #0d47a1;\n  }\n  circle.node.end {\n    fill: #e94e77;\n    stroke: #7a2033;\n  }\n  text.label {\n    pointer-events: none;\n    font-weight: bold;\n    user-select: none;\n    fill: #333;\n  }\n  line.edge {\n    stroke: #bbb;\n    stroke-width: 2px;\n  }\n  line.edge.visited {\n    stroke: #7bc8a4;\n    stroke-width: 4px;\n  }\n  #controls {\n    text-align: center;\n    margin-top: 10px;\n  }\n  button, select {\n    font-size: 16px;\n    padding: 8px 16px;\n    margin: 5px;\n  }\n  #queue-display {\n    margin-top: 15px;\n    font-family: monospace;\n    text-align: center;\n    background: #fff;\n    padding: 10px;\n    border-radius: 6px;\n    border: 1px solid #ccc;\n    max-width: 600px;\n    margin-left: auto;\n    margin-right: auto;\n  }\n  #instructions {\n    max-width: 600px;\n    margin: 10px auto 0 auto;\n    font-size: 14px;\n    background: #eef6f9;\n    padding: 10px 15px;\n    border-radius: 6px;\n    border: 1px solid #a0c4d1;\n  }\n  #start-label, #end-label {\n    font-weight: bold;\n  }\n</style>\n</head>\n<body>\n\n<h1>Breadth-First Search (BFS) Visualization</h1>\n\n<div id=\"graph-container\" aria-label=\"Graph visualization area\" role=\"img\"></div>\n\n<div id=\"controls\" aria-label=\"Controls for BFS visualization\">\n  <label for=\"startNode\">Start Node:</label>\n  <select id=\"startNode\" aria-describedby=\"start-label\">\n  </select>\n\n  <button id=\"startBtn\" aria-pressed=\"false\">Start BFS</button>\n  <button id=\"stepBtn\" disabled>Step</button>\n  <button id=\"autoBtn\" disabled>Auto Run</button>\n  <button id=\"resetBtn\">Reset</button>\n  <div id=\"speedControl\" style=\"display:inline-block; margin-left: 15px;\">\n    <label for=\"speedRange\">Speed:</label>\n    <input type=\"range\" id=\"speedRange\" min=\"200\" max=\"2000\" step=\"100\" value=\"800\" aria-valuemin=\"200\" aria-valuemax=\"2000\" aria-valuenow=\"800\" />\n    <span id=\"speedValue\">800ms</span>\n  </div>\n</div>\n\n<div id=\"queue-display\" aria-live=\"polite\" aria-atomic=\"true\" aria-relevant=\"additions\" role=\"region\">\n  <strong>Queue:</strong> (empty)\n</div>\n\n<div id=\"instructions\">\n  <p><b>Instructions:</b> Select a start node and press \"Start BFS\" to visualize the BFS algorithm on the graph. Use \"Step\" to advance one step at a time, or \"Auto Run\" for automatic step advancement. \"Reset\" clears the visualization.</p>\n  <p>The graph is undirected. Nodes visited will turn green. The current node being explored is yellow. Edges used in BFS are highlighted.</p>\n</div>\n\n<script>\n(() => {\n  // Graph Data: nodes with positions, edges undirected\n  const nodes = [\n    { id: 'A', x: 100, y: 80 },\n    { id: 'B', x: 250, y: 50 },\n    { id: 'C', x: 250, y: 150 },\n    { id: 'D', x: 400, y: 80 },\n    { id: 'E', x: 100, y: 220 },\n    { id: 'F', x: 400, y: 220 },\n    { id: 'G', x: 550, y: 200 },\n    { id: 'H', x: 550, y: 80 },\n  ];\n\n  const edges = [\n    ['A', 'B'],\n    ['A', 'C'],\n    ['B', 'D'],\n    ['B', 'C'],\n    ['C', 'E'],\n    ['D', 'F'],\n    ['E', 'F'],\n    ['F', 'G'],\n    ['D', 'H'],\n    ['H', 'G'],\n  ];\n\n  // Build adjacency list\n  const adjList = {};\n  for (const node of nodes) adjList[node.id] = [];\n  for (const [u, v] of edges) {\n    adjList[u].push(v);\n    adjList[v].push(u);\n  }\n\n  // Colors & classes defined in CSS\n  // Setup the SVG and elements\n  const graphContainer = document.getElementById('graph-container');\n  const SVG_NS = \"http://www.w3.org/2000/svg\";\n  const svg = document.createElementNS(SVG_NS, 'svg');\n  graphContainer.appendChild(svg);\n\n  // Store svg elements for quick access\n  const nodeElems = {};\n  const edgeElems = {};\n\n  // Draw edges as lines\n  for (const [u, v] of edges) {\n    const line = document.createElementNS(SVG_NS, 'line');\n    const nodeU = nodes.find(n => n.id === u);\n    const nodeV = nodes.find(n => n.id === v);\n    line.setAttribute('x1', nodeU.x);\n    line.setAttribute('y1', nodeU.y);\n    line.setAttribute('x2', nodeV.x);\n    line.setAttribute('y2', nodeV.y);\n    line.setAttribute('class', 'edge');\n    svg.appendChild(line);\n    edgeElems[`${u}-${v}`] = line;\n    edgeElems[`${v}-${u}`] = line; // for easy lookup both ways\n  }\n\n  // Draw nodes as circles with labels\n  for (const node of nodes) {\n    const g = document.createElementNS(SVG_NS, 'g');\n    g.setAttribute('tabindex', '0');\n    g.setAttribute('role', 'button');\n    g.setAttribute('aria-label', `Node ${node.id}, click to select as start node`);\n    g.style.cursor = 'pointer';\n\n    const circle = document.createElementNS(SVG_NS, 'circle');\n    circle.setAttribute('cx', node.x);\n    circle.setAttribute('cy', node.y);\n    circle.setAttribute('r', 20);\n    circle.setAttribute('class', 'node');\n    circle.dataset.id = node.id;\n\n    const text = document.createElementNS(SVG_NS, 'text');\n    text.setAttribute('x', node.x);\n    text.setAttribute('y', node.y + 6);\n    text.setAttribute('text-anchor', 'middle');\n    text.setAttribute('class', 'label');\n    text.textContent = node.id;\n\n    g.appendChild(circle);\n    g.appendChild(text);\n    svg.appendChild(g);\n\n    nodeElems[node.id] = circle;\n  }\n\n  // UI elements\n  const startNodeSelect = document.getElementById('startNode');\n  const startBtn = document.getElementById('startBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const autoBtn = document.getElementById('autoBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const queueDisplay = document.getElementById('queue-display');\n  const speedRange = document.getElementById('speedRange');\n  const speedValue = document.getElementById('speedValue');\n\n  // Populate startNodeSelect options\n  for (const node of nodes) {\n    const option = document.createElement('option');\n    option.value = node.id;\n    option.textContent = node.id;\n    startNodeSelect.appendChild(option);\n  }\n\n  // Clicking nodes selects start node\n  svg.addEventListener('click', (e) => {\n    if (e.target.classList.contains('node')) {\n      const id = e.target.dataset.id;\n      startNodeSelect.value = id;\n      highlightStartNode(id);\n    }\n  });\n\n  startNodeSelect.addEventListener('change', e => {\n    highlightStartNode(e.target.value);\n  });\n\n  function highlightStartNode(id) {\n    // Reset all nodes from start class\n    for (const nid in nodeElems) {\n      nodeElems[nid].classList.remove('start');\n    }\n    if (id && nodeElems[id]) {\n      nodeElems[id].classList.add('start');\n    }\n  }\n\n  // BFS state\n  let visited = new Set();\n  let queue = [];\n  let bfsStarted = false;\n  let bfsFinished = false;\n  let currentNode = null;\n  let parents = {}; // To track edges used\n  let autoInterval = null;\n\n  function reset() {\n    visited.clear();\n    queue = [];\n    currentNode = null;\n    bfsStarted = false;\n    bfsFinished = false;\n    parents = {};\n    if(autoInterval) {\n      clearInterval(autoInterval);\n      autoInterval = null;\n      autoBtn.textContent = 'Auto Run';\n      autoBtn.disabled = true;\n    }\n\n    // Reset all styles\n    for (const nid in nodeElems) {\n      nodeElems[nid].classList.remove('visited', 'current', 'start');\n    }\n    for (const key in edgeElems) {\n      edgeElems[key].classList.remove('visited');\n    }\n\n    updateQueueDisplay();\n    stepBtn.disabled = true;\n    autoBtn.disabled = true;\n    startBtn.disabled = false;\n    highlightStartNode(startNodeSelect.value);\n  }\n\n  function updateQueueDisplay() {\n    if(queue.length === 0) {\n      queueDisplay.innerHTML = `<strong>Queue:</strong> (empty)`;\n    } else {\n      queueDisplay.innerHTML = `<strong>Queue:</strong> ${queue.join(' â†’ ')}`;\n    }\n  }\n\n  // Highlight edge between two nodes\n  function highlightEdge(u, v) {\n    const e = edgeElems[`${u}-${v}`];\n    if(e) {\n      e.classList.add('visited');\n    }\n  }\n\n  // One step of BFS\n  function bfsStep() {\n    if(queue.length === 0) {\n      currentNode = null;\n      bfsFinished = true;\n      stepBtn.disabled = true;\n      autoBtn.disabled = true;\n      startBtn.disabled = false;\n      alert('BFS complete! All reachable nodes visited.');\n      return;\n    }\n\n    // Remove current highlight of previous currentNode\n    if(currentNode && nodeElems[currentNode]) {\n      nodeElems[currentNode].classList.remove('current');\n      nodeElems[currentNode].classList.add('visited');\n    }\n\n    currentNode = queue.shift();\n\n    // Highlight current node\n    nodeElems[currentNode].classList.add('current');\n\n    // Enqueue all unvisited neighbors\n    for (const neighbor of adjList[currentNode]) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n        parents[neighbor] = currentNode;\n        highlightEdge(currentNode, neighbor);\n      }\n    }\n    updateQueueDisplay();\n  }\n\n  // Event handlers\n  startBtn.addEventListener('click', () => {\n    if(bfsStarted) return;\n    const start = startNodeSelect.value;\n    if (!start) {\n      alert('Please select a start node.');\n      return;\n    }\n    reset();\n    bfsStarted = true;\n    visited.add(start);\n    queue.push(start);\n    updateQueueDisplay();\n\n    nodeElems[start].classList.add('start');\n\n    startBtn.disabled = true;\n    stepBtn.disabled = false;\n    autoBtn.disabled = false;\n\n    // Kick off first step\n    bfsStep();\n  });\n\n  stepBtn.addEventListener('click', () => {\n    if(!bfsStarted || bfsFinished) return;\n    bfsStep();\n  });\n\n  autoBtn.addEventListener('click', () => {\n    if(!bfsStarted || bfsFinished) return;\n    if(autoInterval) {\n      clearInterval(autoInterval);\n      autoInterval = null;\n      autoBtn.textContent = 'Auto Run';\n      stepBtn.disabled = false;\n      startBtn.disabled = true;\n      resetBtn.disabled = false;\n    } else {\n      const speed = Number(speedRange.value);\n      autoBtn.textContent = 'Pause';\n      stepBtn.disabled = true;\n      startBtn.disabled = true;\n      resetBtn.disabled = true;\n      autoInterval = setInterval(() => {\n        bfsStep();\n        if(bfsFinished) {\n          clearInterval(autoInterval);\n          autoInterval = null;\n          autoBtn.textContent = 'Auto Run';\n          stepBtn.disabled = true;\n          startBtn.disabled = false;\n          resetBtn.disabled = false;\n        }\n      }, speed);\n    }\n  });\n\n  resetBtn.addEventListener('click', () => {\n    reset();\n  });\n\n  speedRange.addEventListener('input', () => {\n    speedValue.textContent = speedRange.value + 'ms';\n    speedRange.setAttribute('aria-valuenow', speedRange.value);\n    if(autoInterval){\n      clearInterval(autoInterval);\n      autoInterval = null;\n      autoBtn.textContent = 'Auto Run';\n      stepBtn.disabled = false;\n      startBtn.disabled = true;\n      resetBtn.disabled = false;\n    }\n  });\n\n  // Initialize\n  reset();\n  highlightStartNode(startNodeSelect.value);\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": false,
  "hasTest": true
}