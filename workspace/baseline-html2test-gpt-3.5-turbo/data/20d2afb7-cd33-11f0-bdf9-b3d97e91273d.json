{
  "id": "20d2afb7-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:08.706Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Heap Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Heap Sort Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f0f4f8;\n    color: #333;\n  }\n  h1 {\n    text-align: center;\n    margin-bottom: 5px;\n  }\n  #controls {\n    max-width: 600px;\n    margin: 0 auto 20px auto;\n    display: flex;\n    gap: 10px;\n    justify-content: center;\n    flex-wrap: wrap;\n  }\n  input[type=number] {\n    width: 80px;\n    padding: 8px;\n    font-size: 16px;\n    border-radius: 4px;\n    border: 1px solid #ccc;\n  }\n  button {\n    background-color: #005f99;\n    color: white;\n    border: none;\n    padding: 10px 16px;\n    font-size: 16px;\n    border-radius: 4px;\n    cursor: pointer;\n    min-width: 120px;\n    transition: background-color 0.3s;\n  }\n  button:disabled {\n    background-color: #999;\n    cursor: default;\n  }\n  button:hover:not(:disabled) {\n    background-color: #004b7a;\n  }\n  #array {\n    max-width: 800px;\n    margin: 0 auto;\n    height: 120px;\n    display: flex;\n    align-items: flex-end;\n    gap: 6px;\n    border: 1px solid #ccc;\n    background: white;\n    padding: 10px;\n    border-radius: 6px;\n    user-select: none;\n    font-weight: 600;\n  }\n  .bar {\n    background-color: #006bb3;\n    height: 50px;\n    width: 30px;\n    border-radius: 4px;\n    color: white;\n    display: flex;\n    align-items: flex-end;\n    justify-content: center;\n    font-size: 14px;\n    position: relative;\n    transition: background-color 0.3s, height 0.3s;\n  }\n  .bar.heapify {\n    background-color: #ff9500;\n  }\n  .bar.swapping {\n    background-color: #d50000;\n  }\n  .bar.sorted {\n    background-color: #2e7d32;\n  }\n  #description {\n    max-width: 700px;\n    margin: 20px auto;\n    line-height: 1.5;\n  }\n  #speedLabel {\n    margin-left: 10px;\n    font-weight: 600;\n  }\n  #speedControl {\n    vertical-align: middle;\n  }\n</style>\n</head>\n<body>\n<h1>Heap Sort Visualization</h1>\n<div id=\"controls\">\n  <input type=\"text\" id=\"inputArray\" placeholder=\"Enter numbers e.g. 4,1,7,3\" />\n  <button id=\"generateBtn\" title=\"Generate random array\">Generate Random</button>\n  <button id=\"startBtn\" disabled>Start Sorting</button>\n  <label for=\"speedControl\">Speed:</label>\n  <input type=\"range\" id=\"speedControl\" min=\"100\" max=\"2000\" step=\"100\" value=\"700\" />\n  <span id=\"speedLabel\">700 ms</span>\n</div>\n<div id=\"array\" aria-label=\"Array visualization\" role=\"list\"></div>\n\n<div id=\"description\">\n  <h2>Heap Sort Algorithm</h2>\n  <p>\n    Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure.\n    It works in two main steps:\n  </p>\n  <ol>\n    <li>\n      <strong>Build a max heap</strong> from the unsorted array, ensuring the largest element is at the root.\n    </li>\n    <li>\n      <strong>Repeatedly swap</strong> the root (maximum value) with the last element and reduce the heap size by one,\n      then heapify the root again. This process continues until the heap size is 1 and the array is sorted.\n    </li>\n  </ol>\n  <p>\n    The algorithm sorts the array in-place with an average and worst-case time complexity of O(n log n).\n  </p>\n  <p>\n    <em>In the visualization, yellow bars denote heapify operations, red bars show elements being swapped,\n    and green bars indicate sorted elements.</em>\n  </p>\n</div>\n\n<script>\n(() => {\n  const arrayContainer = document.getElementById('array');\n  const inputArray = document.getElementById('inputArray');\n  const generateBtn = document.getElementById('generateBtn');\n  const startBtn = document.getElementById('startBtn');\n  const speedControl = document.getElementById('speedControl');\n  const speedLabel = document.getElementById('speedLabel');\n\n  let arr = [];\n  let delay = +speedControl.value; // milliseconds per step\n\n  // Helper delay function for animation\n  function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  function createBars(array) {\n    arrayContainer.innerHTML = '';\n    const maxVal = Math.max(...array);\n    array.forEach((val, i) => {\n      const bar = document.createElement('div');\n      bar.classList.add('bar');\n      bar.style.height = `${(val / maxVal) * 100 + 20}px`;\n      bar.textContent = val;\n      bar.dataset.index = i;\n      bar.setAttribute('role', 'listitem');\n      arrayContainer.appendChild(bar);\n    });\n  }\n\n  function updateBars(array, highlights = {}) {\n    // highlights keys: heapify, swapping, sorted: arrays of indices\n    const bars = arrayContainer.childNodes;\n    const maxVal = Math.max(...array);\n    array.forEach((val, i) => {\n      const bar = bars[i];\n      if (!bar) return;\n      bar.style.height = `${(val / maxVal) * 100 + 20}px`;\n      bar.textContent = val;\n\n      bar.classList.remove('heapify', 'swapping', 'sorted');\n      if (highlights.heapify && highlights.heapify.includes(i)) {\n        bar.classList.add('heapify');\n      } else if (highlights.swapping && highlights.swapping.includes(i)) {\n        bar.classList.add('swapping');\n      } else if (highlights.sorted && highlights.sorted.includes(i)) {\n        bar.classList.add('sorted');\n      }\n    });\n  }\n\n  // Max-heapify function adjusted for visualization\n  async function maxHeapify(array, heapSize, rootIndex) {\n    let largest = rootIndex;\n    const left = 2 * rootIndex + 1;\n    const right = 2 * rootIndex + 2;\n\n    if (left < heapSize && array[left] > array[largest]) {\n      largest = left;\n    }\n    if (right < heapSize && array[right] > array[largest]) {\n      largest = right;\n    }\n\n    // Highlight the root and its children involved in heapify\n    let heapifyIndices = [rootIndex];\n    if (left < heapSize) heapifyIndices.push(left);\n    if (right < heapSize) heapifyIndices.push(right);\n\n    updateBars(array, { heapify: heapifyIndices });\n    await sleep(delay);\n\n    if (largest !== rootIndex) {\n      // Swap values\n      [array[rootIndex], array[largest]] = [array[largest], array[rootIndex]];\n      updateBars(array, { swapping: [rootIndex, largest] });\n      await sleep(delay);\n\n      // Recursively heapify the affected subtree\n      await maxHeapify(array, heapSize, largest);\n    }\n    else {\n      // No swap needed, just update bars to normal after a short delay\n      updateBars(array, {});\n      await sleep(delay / 2);\n    }\n  }\n\n  async function heapSort(array) {\n    const n = array.length;\n    let sortedIndices = [];\n\n    // Build max heap\n    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n      await maxHeapify(array, n, i);\n    }\n\n    // Extract elements one by one from heap\n    for (let i = n - 1; i > 0; i--) {\n      // Swap current root to end\n      updateBars(array, { swapping: [0, i], sorted: sortedIndices });\n      await sleep(delay);\n      [array[0], array[i]] = [array[i], array[0]];\n      sortedIndices.push(i);\n\n      updateBars(array, { sorted: sortedIndices });\n      await sleep(delay);\n\n      // Heapify reduced heap\n      await maxHeapify(array, i, 0);\n    }\n\n    // Mark the last remaining element as sorted\n    sortedIndices.push(0);\n    updateBars(array, { sorted: sortedIndices });\n  }\n\n  function parseInput(str) {\n    const parts = str.split(',').map(s => s.trim());\n    const nums = [];\n    for (let p of parts) {\n      if (p === '') continue;\n      const n = Number(p);\n      if (Number.isNaN(n) || !Number.isFinite(n)) return null;\n      nums.push(n);\n    }\n    return nums.length > 0 ? nums : null;\n  }\n\n  function generateRandomArray(size=15, max=100) {\n    return Array.from({ length: size }, () => Math.floor(Math.random() * max) + 1);\n  }\n\n  // Event handlers\n  inputArray.addEventListener('input', () => {\n    const userArr = parseInput(inputArray.value);\n    if (userArr && userArr.length <= 30) {\n      arr = userArr;\n      createBars(arr);\n      startBtn.disabled = false;\n    }\n    else {\n      arrayContainer.innerHTML = '';\n      startBtn.disabled = true;\n    }\n  });\n\n  generateBtn.addEventListener('click', () => {\n    arr = generateRandomArray();\n    inputArray.value = arr.join(', ');\n    createBars(arr);\n    startBtn.disabled = false;\n  });\n\n  startBtn.addEventListener('click', async () => {\n    startBtn.disabled = true;\n    generateBtn.disabled = true;\n    inputArray.disabled = true;\n    speedControl.disabled = true;\n\n    await heapSort(arr);\n\n    startBtn.disabled = false;\n    generateBtn.disabled = false;\n    inputArray.disabled = false;\n    speedControl.disabled = false;\n  });\n\n  speedControl.addEventListener('input', () => {\n    delay = +speedControl.value;\n    speedLabel.textContent = delay + ' ms';\n  });\n\n  // Initialize with random array\n  arr = generateRandomArray();\n  inputArray.value = arr.join(', ');\n  createBars(arr);\n  startBtn.disabled = false;\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap Sort"
    }
  ],
  "topic": "Heap Sort",
  "hasFSM": false,
  "hasTest": true
}