{
  "id": "e03a2054-cd32-11f0-a949-f901cf5609c9",
  "timestamp": "2025-11-29T14:52:11.329Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency List",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Adjacency List Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  #graphInput {\n    width: 100%;\n    height: 100px;\n    font-family: monospace;\n  }\n  #adjList {\n    margin-top: 20px;\n  }\n  .adj-node {\n    margin-bottom: 10px;\n  }\n  #graphCanvas {\n    border: 1px solid #ccc;\n    margin-top: 30px;\n    background: #fafafa;\n  }\n  button {\n    margin-top: 10px;\n    padding: 8px 14px;\n    font-size: 14px;\n  }\n  .error {\n    color: red;\n    margin-top: 10px;\n    font-weight: bold;\n  }\n</style>\n</head>\n<body>\n  <h1>Adjacency List Representation of a Graph</h1>\n  <p>Enter edges below, one per line, in the format: <code>nodeA nodeB</code> or <code>nodeA,nodeB</code></p>\n  <p>Example:<br>\n  <code>A B</code><br>\n  <code>A C</code><br>\n  <code>B D</code><br>\n  <code>C D</code><br>\n  <code>D E</code></p>\n  <textarea id=\"graphInput\" placeholder=\"Enter edges here...\"></textarea>\n  <br />\n  <button id=\"buildGraphBtn\">Build Graph</button>\n  <div id=\"errorMsg\" class=\"error\"></div>\n  <div id=\"adjList\"></div>\n  <canvas id=\"graphCanvas\" width=\"600\" height=\"400\"></canvas>\n\n<script>\n(() => {\n  const inputEl = document.getElementById(\"graphInput\");\n  const buildBtn = document.getElementById(\"buildGraphBtn\");\n  const adjListDiv = document.getElementById(\"adjList\");\n  const canvas = document.getElementById(\"graphCanvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const errorMsg = document.getElementById(\"errorMsg\");\n\n  // Graph data structure: adjacency list\n  // { node: [neighbors] }\n  let graph = {};\n\n  // Positions of nodes on canvas for visualization\n  let nodePositions = {};\n\n  // Clears canvas and adjList display\n  function clearDisplay() {\n    adjListDiv.innerHTML = \"\";\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    errorMsg.textContent = \"\";\n  }\n\n  // Parse input edges into adjacency list\n  function parseInput(input) {\n    const lines = input.trim().split(\"\\n\");\n    const adjacency = {};\n    for (let lineNum = 0; lineNum < lines.length; lineNum++) {\n      const lineRaw = lines[lineNum].trim();\n      if (lineRaw === \"\") continue;\n      // Support \"A B\" or \"A,B\"\n      let parts = lineRaw.includes(\",\") ? lineRaw.split(\",\") : lineRaw.split(/\\s+/);\n      if (parts.length !== 2) {\n        throw new Error(`Invalid edge format on line ${lineNum+1}: \"${lineRaw}\"`);\n      }\n      let [from, to] = parts.map(s => s.trim());\n      if (!from || !to) {\n        throw new Error(`Invalid nodes on line ${lineNum+1}: \"${lineRaw}\"`);\n      }\n\n      // Initialize adjacency entries if needed\n      if (!adjacency[from]) adjacency[from] = [];\n      if (!adjacency[to]) adjacency[to] = []; // also add the 'to' node as a key if not present\n\n      adjacency[from].push(to);\n      // For undirected graph, add opposite edge:\n      // adjacency[to].push(from);\n    }\n    return adjacency;\n  }\n\n  // Display adjacency list in readable format\n  function displayAdjList(adj) {\n    adjListDiv.innerHTML = \"<h2>Adjacency List</h2>\";\n    const ul = document.createElement(\"ul\");\n    for (const node of Object.keys(adj).sort()) {\n      const li = document.createElement(\"li\");\n      li.className = \"adj-node\";\n      li.textContent = `${node}: ${adj[node].join(\", \")}`;\n      ul.appendChild(li);\n    }\n    adjListDiv.appendChild(ul);\n  }\n\n  // Basic circle layout for visualization\n  function layoutNodes(nodes) {\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const radius = Math.min(centerX, centerY) - 50;\n    const angleStep = (2 * Math.PI) / nodes.length;\n    let positions = {};\n    nodes.forEach((node, i) => {\n      const angle = i * angleStep;\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n      positions[node] = { x, y };\n    });\n    return positions;\n  }\n\n  // Draw graph on canvas\n  function drawGraph(adj) {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    const nodes = Object.keys(adj);\n    nodePositions = layoutNodes(nodes);\n\n    // Draw edges\n    ctx.strokeStyle = \"#666\";\n    ctx.lineWidth = 2;\n    ctx.font = \"14px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n\n    for (const from of nodes) {\n      const fromPos = nodePositions[from];\n      for (const to of adj[from]) {\n        const toPos = nodePositions[to];\n        drawArrow(fromPos, toPos);\n      }\n    }\n\n    // Draw nodes\n    for (const node of nodes) {\n      const { x, y } = nodePositions[node];\n      drawNode(x, y, node);\n    }\n  }\n\n  // Draw a circle node\n  function drawNode(x, y, label) {\n    const radius = 20;\n    // Circle\n    ctx.fillStyle = \"#2980b9\";\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, 2 * Math.PI);\n    ctx.fill();\n    // Label\n    ctx.fillStyle = \"white\";\n    ctx.fillText(label, x, y);\n  }\n\n  // Draw arrow from point A to B\n  function drawArrow(from, to) {\n    const headLength = 10;\n    const dx = to.x - from.x;\n    const dy = to.y - from.y;\n    const angle = Math.atan2(dy, dx);\n    // Draw line shortened a bit to not overlap circle\n    const radius = 20;\n    const startX = from.x + radius * Math.cos(angle);\n    const startY = from.y + radius * Math.sin(angle);\n    const endX = to.x - radius * Math.cos(angle);\n    const endY = to.y - radius * Math.sin(angle);\n\n    ctx.beginPath();\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n\n    // Draw arrowhead\n    ctx.beginPath();\n    ctx.moveTo(endX, endY);\n    ctx.lineTo(\n      endX - headLength * Math.cos(angle - Math.PI / 6),\n      endY - headLength * Math.sin(angle - Math.PI / 6)\n    );\n    ctx.lineTo(\n      endX - headLength * Math.cos(angle + Math.PI / 6),\n      endY - headLength * Math.sin(angle + Math.PI / 6)\n    );\n    ctx.lineTo(endX, endY);\n    ctx.fillStyle = \"#666\";\n    ctx.fill();\n  }\n\n  // Main button click handler\n  buildBtn.addEventListener(\"click\", () => {\n    clearDisplay();\n    const input = inputEl.value;\n    if (!input.trim()) {\n      errorMsg.textContent = \"Please enter at least one edge.\";\n      return;\n    }\n    try {\n      graph = parseInput(input);\n      displayAdjList(graph);\n      drawGraph(graph);\n    } catch (err) {\n      errorMsg.textContent = err.message;\n    }\n  });\n\n  // Prefill example data\n  inputEl.value = `A B\nA C\nB D\nC D\nD E`;\n  // Automatically build graph on load\n  buildBtn.click();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency List"
    }
  ],
  "topic": "Adjacency List",
  "hasFSM": false,
  "hasTest": true
}