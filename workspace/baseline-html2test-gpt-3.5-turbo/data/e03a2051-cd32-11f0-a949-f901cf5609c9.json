{
  "id": "e03a2051-cd32-11f0-a949-f901cf5609c9",
  "timestamp": "2025-11-29T14:52:29.285Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Graph Visualization (Directed / Undirected)</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f0f0f0;\n  }\n  h1 {\n    text-align: center;\n  }\n  #controls {\n    text-align: center;\n    margin-bottom: 12px;\n  }\n  #graphCanvas {\n    border: 1px solid #999;\n    background: #fff;\n    display: block;\n    margin: 0 auto;\n  }\n  label {\n    font-weight: bold;\n    margin-right: 8px;\n  }\n  #info {\n    max-width: 800px;\n    margin: 12px auto;\n    font-size: 14px;\n    color: #333;\n  }\n  button {\n    margin-left:10px;\n    padding: 6px 12px;\n    font-weight: bold;\n    cursor: pointer;\n  }\n</style>\n</head>\n<body>\n<h1>Graph Visualization (Directed / Undirected)</h1>\n\n<div id=\"controls\">\n  <label><input type=\"radio\" name=\"graphType\" value=\"undirected\" checked /> Undirected</label>\n  <label><input type=\"radio\" name=\"graphType\" value=\"directed\" /> Directed</label>\n  <button id=\"randomGraphBtn\" title=\"Generate Random Graph\">Generate Random Graph</button>\n</div>\n\n<canvas id=\"graphCanvas\" width=\"800\" height=\"600\" aria-label=\"Graph visualization\"></canvas>\n\n<div id=\"info\" aria-live=\"polite\">\n  Click on nodes to highlight their edges and neighbors.<br/>\n  Use \"Generate Random Graph\" to create a new example.\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById(\"graphCanvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const width = canvas.width;\n  const height = canvas.height;\n\n  let graphType = \"undirected\"; // or \"directed\"\n  let nodes = [];\n  let edges = [];\n\n  const NODE_RADIUS = 20;\n\n  // Position nodes in a circle for clear visualization\n  function layoutNodesCircular(n) {\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const radius = Math.min(width,height) / 2 - 60;\n    let nodePositions = [];\n    for (let i = 0; i < n; i++) {\n      const angle = (2 * Math.PI * i) / n - Math.PI / 2;\n      nodePositions.push({\n        x: centerX + radius * Math.cos(angle),\n        y: centerY + radius * Math.sin(angle),\n      });\n    }\n    return nodePositions;\n  }\n\n  function generateRandomGraph(nodeCount=8, edgeProbability=0.25) {\n    nodes = [];\n    edges = [];\n    // create nodes\n    const positions = layoutNodesCircular(nodeCount);\n    for(let i=0; i<nodeCount; i++){\n      nodes.push({ id: i, label: `Node ${i}`, x: positions[i].x, y: positions[i].y });\n    }\n    // create edges\n    for(let i=0; i<nodeCount; i++){\n      for(let j=0; j<nodeCount; j++){\n        if(i === j) continue;\n        if(Math.random() < edgeProbability){\n          if(graphType === \"undirected\"){\n            // to prevent duplicate edges in undirected, only add if i < j\n            if(i < j){\n              edges.push({ from: i, to: j });\n            }\n          } else {\n            edges.push({ from: i, to: j });\n          }\n        }\n      }\n    }\n    drawGraph();\n  }\n\n  // Clear canvas\n  function clear() {\n    ctx.clearRect(0, 0, width, height);\n  }\n\n  // Draw arrowhead\n  function drawArrowhead(x0, y0, x1, y1, color) {\n    const headlen = 12; // length of head in pixels\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    const angle = Math.atan2(dy, dx);\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x1 - headlen * Math.cos(angle - Math.PI / 6), y1 - headlen * Math.sin(angle - Math.PI / 6));\n    ctx.lineTo(x1 - headlen * Math.cos(angle + Math.PI / 6), y1 - headlen * Math.sin(angle + Math.PI / 6));\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Draw edge (line between nodes)\n  function drawEdge(fromNode, toNode, options={color:\"#888\", highlight:false}) {\n    let color = options.highlight ? \"#e91e63\" : options.color;\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    ctx.lineWidth = options.highlight ? 3 : 1.5;\n\n    // Calculate line start and end so it doesn't go inside node circles\n    const dx = toNode.x - fromNode.x;\n    const dy = toNode.y - fromNode.y;\n    const dist = Math.sqrt(dx*dx + dy*dy);\n    const offsetX = (dx/dist)*NODE_RADIUS;\n    const offsetY = (dy/dist)*NODE_RADIUS;\n\n    const startX = fromNode.x + offsetX;\n    const startY = fromNode.y + offsetY;\n    const endX = toNode.x - offsetX;\n    const endY = toNode.y - offsetY;\n\n    ctx.beginPath();\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n\n    if(graphType === \"directed\"){\n      drawArrowhead(startX, startY, endX, endY, color);\n    }\n  }\n\n  // Draw node as circle with label\n  function drawNode(node, options={color:\"#2196f3\", highlight:false}) {\n    let color = options.highlight ? \"#e91e63\" : options.color;\n    ctx.fillStyle = color;\n    ctx.strokeStyle = \"#333\";\n    ctx.lineWidth = options.highlight ? 3 : 1.5;\n\n    ctx.beginPath();\n    ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = \"#fff\";\n    ctx.font = \"bold 14px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(node.label.replace(\"Node \", \"\"), node.x, node.y);\n  }\n\n  function drawGraph(highlightNodeId=null) {\n    clear();\n    // Draw edges first\n    edges.forEach(edge => {\n      const fromNode = nodes[edge.from];\n      const toNode = nodes[edge.to];\n      let highlight = false;\n      if(highlightNodeId !== null){\n        // Highlight edges connected to this node\n        if (graphType === \"undirected\") {\n          if(edge.from === highlightNodeId || edge.to === highlightNodeId){\n            highlight = true;\n          }\n        } else {\n          // Directed: highlight edges from or to node\n          if(edge.from === highlightNodeId || edge.to === highlightNodeId){\n            highlight = true;\n          }\n        }\n      }\n      drawEdge(fromNode, toNode, { highlight: highlight });\n    });\n\n    // Draw nodes over edges\n    nodes.forEach(node => {\n      let highlight = node.id === highlightNodeId;\n      drawNode(node, { highlight: highlight });\n    });\n  }\n\n  // Find node under mouse position\n  function getNodeAtPosition(x, y) {\n    for (let node of nodes){\n      const dx = x - node.x;\n      const dy = y - node.y;\n      if(dx*dx + dy*dy <= NODE_RADIUS*NODE_RADIUS){\n        return node;\n      }\n    }\n    return null;\n  }\n\n  // Event handlers\n  canvas.addEventListener(\"click\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    const clickedNode = getNodeAtPosition(x,y);\n    if(clickedNode){\n      drawGraph(clickedNode.id);\n      showNodeNeighbors(clickedNode.id);\n    } else {\n      drawGraph(null);\n      clearInfoNeighbors();\n    }\n  });\n\n  function showNodeNeighbors(nodeId){\n    let neighbors = [];\n    if(graphType === \"undirected\"){\n     neighbors = edges.reduce((acc, edge) => {\n       if(edge.from === nodeId) acc.push(edge.to);\n       else if(edge.to === nodeId) acc.push(edge.from);\n       return acc;\n     }, []);\n    } else {\n      // Directed - neighbors are those with edges going from nodeId\n      neighbors = edges.filter(e => e.from === nodeId).map(e => e.to);\n    }\n\n    let infoDiv = document.getElementById(\"info\");\n    if(neighbors.length === 0){\n      infoDiv.textContent = `Node ${nodeId} has no neighbors. Click outside nodes to reset.`;\n    } else {\n      let neighborLabels = neighbors.map(nid => `Node ${nid}`).join(\", \");\n      infoDiv.textContent = `Node ${nodeId} neighbors: ${neighborLabels}. Click outside nodes to reset.`;\n    }\n  }\n\n  function clearInfoNeighbors(){\n    let infoDiv = document.getElementById(\"info\");\n    infoDiv.innerHTML = `Click on nodes to highlight their edges and neighbors.<br/>\n  Use \"Generate Random Graph\" to create a new example.`;\n  }\n\n  // Radio buttons change graph type\n  const radios = document.querySelectorAll('input[name=\"graphType\"]');\n  radios.forEach(radio => {\n    radio.addEventListener(\"change\", e => {\n      graphType = e.target.value;\n      generateRandomGraph();\n      clearInfoNeighbors();\n    });\n  });\n\n  // Generate random graph button\n  document.getElementById(\"randomGraphBtn\").addEventListener(\"click\", () => {\n    generateRandomGraph();\n    clearInfoNeighbors();\n  });\n\n  // Initial graph generation\n  generateRandomGraph();\n\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": false,
  "hasTest": true
}