{
  "id": "7abe5c01-cd32-11f0-a96f-2d591ffb35fe",
  "timestamp": "2025-11-29T14:49:53.526Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Red-Black Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Red-Black Tree Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    padding: 0;\n    background: #fafafa;\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n  }\n  header {\n    background-color: #2a3f54;\n    color: white;\n    padding: 1em;\n    text-align: center;\n    font-weight: bold;\n    font-size: 1.5em;\n  }\n  #controls {\n    background: #fff;\n    padding: 1em;\n    display: flex;\n    justify-content: center;\n    gap: 1em;\n    flex-wrap: wrap;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n  }\n  input[type=\"number\"] {\n    padding: 0.3em 0.6em;\n    font-size: 1em;\n    width: 80px;\n  }\n  button {\n    background-color: #2a3f54;\n    border: none;\n    color: white;\n    padding: 0.5em 1em;\n    font-size: 1em;\n    cursor: pointer;\n    border-radius: 3px;\n    user-select: none;\n    transition: background-color 0.2s ease;\n  }\n  button:hover:not(:disabled) {\n    background-color: #3d5776;\n  }\n  button:disabled {\n    background-color: #999;\n    cursor: default;\n  }\n  #messages {\n    color: #555;\n    min-height: 1.4em;\n    font-size: 1em;\n    text-align: center;\n    font-style: italic;\n    margin-top: 0.3em;\n  }\n  #tree-container {\n    flex-grow: 1;\n    overflow: auto;\n    background: white;\n  }\n  svg {\n    display: block;\n    margin: 0 auto;\n    width: 100%;\n    height: 100%;\n    min-height: 400px;\n  }\n  .node circle {\n    stroke-width: 3px;\n    stroke: #555;\n    cursor: pointer;\n    transition: stroke-width 0.2s ease;\n  }\n  .node text {\n    user-select: none;\n    font-weight: bold;\n    pointer-events: none;\n  }\n  .node.red circle {\n    fill: #e03e3e;\n    stroke: #a12a2a;\n  }\n  .node.black circle {\n    fill: #1f1f1f;\n    stroke: #555;\n  }\n  .link {\n    fill: none;\n    stroke: #888;\n    stroke-width: 2px;\n  }\n  .highlight {\n    stroke-width: 5px !important;\n    stroke: #666 !important;\n  }\n  #legend {\n    max-width: 500px;\n    margin: 0.5em auto 1em;\n    text-align: center;\n    font-size: 0.9em;\n    color: #444;\n  }\n  #legend span {\n    display: inline-block;\n    width: 18px;\n    height: 18px;\n    vertical-align: middle;\n    margin-right: 0.3em;\n    border-radius: 50%;\n  }\n  #legend .red {\n    background-color: #e03e3e;\n    border: 2px solid #a12a2a;\n  }\n  #legend .black {\n    background-color: #1f1f1f;\n    border: 2px solid #555;\n  }\n</style>\n</head>\n<body>\n<header>Red-Black Tree Interactive Visualization</header>\n<div id=\"controls\">\n  <input type=\"number\" id=\"inputValue\" placeholder=\"Number\" />\n  <button id=\"insertBtn\">Insert</button>\n  <button id=\"deleteBtn\">Delete</button>\n  <button id=\"clearBtn\">Clear Tree</button>\n</div>\n<div id=\"messages\"></div>\n<div id=\"legend\">\n  <strong>Legend:</strong> \n  <span class=\"red\"></span> Red Node &nbsp;&nbsp; \n  <span class=\"black\"></span> Black Node\n</div>\n<div id=\"tree-container\">\n  <svg id=\"tree\"></svg>\n</div>\n<script>\n(() => {\n  // Red-Black Tree Implementation with visualization\n\n  class RBNode {\n    constructor(value, color, parent = null) {\n      this.value = value;\n      this.color = color; // \"red\" or \"black\"\n      this.parent = parent;\n      this.left = null;\n      this.right = null;\n    }\n    get grandparent() {\n      if (!this.parent) return null;\n      return this.parent.parent;\n    }\n    get sibling() {\n      if (!this.parent) return null;\n      return this === this.parent.left ? this.parent.right : this.parent.left;\n    }\n    get uncle() {\n      if (!this.parent) return null;\n      return this.parent.sibling;\n    }\n  }\n\n  class RBTree {\n    constructor() {\n      this.nil = new RBNode(null, \"black\"); // Sentinel node for leaves\n      this.root = this.nil;\n    }\n\n    search(value) {\n      let current = this.root;\n      while (current !== this.nil) {\n        if (value === current.value) return current;\n        current = value < current.value ? current.left : current.right;\n      }\n      return null;\n    }\n\n    leftRotate(x) {\n      let y = x.right;\n      x.right = y.left;\n      if (y.left !== this.nil) y.left.parent = x;\n      y.parent = x.parent;\n      if (x.parent === null) {\n        this.root = y;\n      } else if (x === x.parent.left) {\n        x.parent.left = y;\n      } else {\n        x.parent.right = y;\n      }\n      y.left = x;\n      x.parent = y;\n    }\n\n    rightRotate(y) {\n      let x = y.left;\n      y.left = x.right;\n      if (x.right !== this.nil) x.right.parent = y;\n      x.parent = y.parent;\n      if (y.parent === null) {\n        this.root = x;\n      } else if (y === y.parent.right) {\n        y.parent.right = x;\n      } else {\n        y.parent.left = x;\n      }\n      x.right = y;\n      y.parent = x;\n    }\n\n    insert(value) {\n      let node = new RBNode(value, \"red\", null);\n      node.left = this.nil;\n      node.right = this.nil;\n\n      let y = null;\n      let x = this.root;\n\n      while (x !== this.nil) {\n        y = x;\n        if (node.value === x.value) {\n          // Duplicate values not allowed\n          return false;\n        }\n        x = node.value < x.value ? x.left : x.right;\n      }\n\n      node.parent = y;\n      if (y === null) {\n        this.root = node;\n      } else if (node.value < y.value) {\n        y.left = node;\n      } else {\n        y.right = node;\n      }\n\n      this.insertFixup(node);\n      return true;\n    }\n\n    insertFixup(z) {\n      while (z.parent && z.parent.color === \"red\") {\n        if (z.parent === z.parent.parent.left) {\n          let y = z.parent.parent.right;\n          if (y && y.color === \"red\") {\n            z.parent.color = \"black\";\n            y.color = \"black\";\n            z.parent.parent.color = \"red\";\n            z = z.parent.parent;\n          } else {\n            if (z === z.parent.right) {\n              z = z.parent;\n              this.leftRotate(z);\n            }\n            z.parent.color = \"black\";\n            z.parent.parent.color = \"red\";\n            this.rightRotate(z.parent.parent);\n          }\n        } else {\n          let y = z.parent.parent.left;\n          if (y && y.color === \"red\") {\n            z.parent.color = \"black\";\n            y.color = \"black\";\n            z.parent.parent.color = \"red\";\n            z = z.parent.parent;\n          } else {\n            if (z === z.parent.left) {\n              z = z.parent;\n              this.rightRotate(z);\n            }\n            z.parent.color = \"black\";\n            z.parent.parent.color = \"red\";\n            this.leftRotate(z.parent.parent);\n          }\n        }\n      }\n      this.root.color = \"black\";\n    }\n\n    transplant(u, v) {\n      if (u.parent === null) {\n        this.root = v;\n      } else if (u === u.parent.left) {\n        u.parent.left = v;\n      } else {\n        u.parent.right = v;\n      }\n      v.parent = u.parent;\n    }\n\n    minimum(x) {\n      while (x.left !== this.nil) {\n        x = x.left;\n      }\n      return x;\n    }\n\n    delete(value) {\n      let z = this.search(value);\n      if (!z) return false;\n\n      let y = z;\n      let yOriginalColor = y.color;\n      let x;\n\n      if (z.left === this.nil) {\n        x = z.right;\n        this.transplant(z, z.right);\n      } else if (z.right === this.nil) {\n        x = z.left;\n        this.transplant(z, z.left);\n      } else {\n        y = this.minimum(z.right);\n        yOriginalColor = y.color;\n        x = y.right;\n        if (y.parent === z) {\n          x.parent = y;\n        } else {\n          this.transplant(y, y.right);\n          y.right = z.right;\n          y.right.parent = y;\n        }\n        this.transplant(z, y);\n        y.left = z.left;\n        y.left.parent = y;\n        y.color = z.color;\n      }\n      if (yOriginalColor === \"black\") {\n        this.deleteFixup(x);\n      }\n      return true;\n    }\n\n    deleteFixup(x) {\n      while (x !== this.root && x.color === \"black\") {\n        if (x === x.parent.left) {\n          let w = x.parent.right;\n          if (w.color === \"red\") {\n            w.color = \"black\";\n            x.parent.color = \"red\";\n            this.leftRotate(x.parent);\n            w = x.parent.right;\n          }\n          if (w.left.color === \"black\" && w.right.color === \"black\") {\n            w.color = \"red\";\n            x = x.parent;\n          } else {\n            if (w.right.color === \"black\") {\n              w.left.color = \"black\";\n              w.color = \"red\";\n              this.rightRotate(w);\n              w = x.parent.right;\n            }\n            w.color = x.parent.color;\n            x.parent.color = \"black\";\n            w.right.color = \"black\";\n            this.leftRotate(x.parent);\n            x = this.root;\n          }\n        } else {\n          let w = x.parent.left;\n          if (w.color === \"red\") {\n            w.color = \"black\";\n            x.parent.color = \"red\";\n            this.rightRotate(x.parent);\n            w = x.parent.left;\n          }\n          if (w.right.color === \"black\" && w.left.color === \"black\") {\n            w.color = \"red\";\n            x = x.parent;\n          } else {\n            if (w.left.color === \"black\") {\n              w.right.color = \"black\";\n              w.color = \"red\";\n              this.leftRotate(w);\n              w = x.parent.left;\n            }\n            w.color = x.parent.color;\n            x.parent.color = \"black\";\n            w.left.color = \"black\";\n            this.rightRotate(x.parent);\n            x = this.root;\n          }\n        }\n      }\n      x.color = \"black\";\n    }\n\n    clear() {\n      this.root = this.nil;\n    }\n  }\n\n  // Visualizer\n\n  class Visualizer {\n    constructor(tree, svg) {\n      this.tree = tree;\n      this.svg = svg;\n      this.nodeRadius = 20;\n      this.levelHeight = 80;\n      this.width = svg.clientWidth;\n      this.height = svg.clientHeight;\n      this.svg.setAttribute(\"viewBox\", `0 0 ${this.svg.clientWidth} ${this.svg.clientHeight}`);\n    }\n\n    clearSVG() {\n      while (this.svg.firstChild) this.svg.firstChild.remove();\n    }\n\n    computePositions() {\n      // We use inorder traversal indexing for horizontal positions, level for vertical\n      this.positions = new Map();\n      this.maxXIndex = 0;\n\n      const inorder = (node, depth) => {\n        if (node === this.tree.nil) return;\n        inorder(node.left, depth + 1);\n        this.positions.set(node, { xIndex: this.maxXIndex++, depth });\n        inorder(node.right, depth + 1);\n      };\n\n      inorder(this.tree.root, 0);\n    }\n\n    draw() {\n      this.clearSVG();\n      if (this.tree.root === this.tree.nil) return; // empty tree\n\n      this.computePositions();\n\n      // Compute horizontal spacing\n      const totalNodes = this.positions.size;\n      const hSpacing = Math.max(this.nodeRadius * 3, this.width / (totalNodes + 1));\n\n      // Draw edges\n      for (let [node, pos] of this.positions.entries()) {\n        if (node.left !== this.tree.nil) this.drawEdge(node, node.left);\n        if (node.right !== this.tree.nil) this.drawEdge(node, node.right);\n      }\n\n      // Draw nodes\n      for (let [node, pos] of this.positions.entries()) {\n        this.drawNode(node);\n      }\n    }\n\n    drawEdge(parent, child) {\n      const pPos = this.positions.get(parent);\n      const cPos = this.positions.get(child);\n      const hSpacing = Math.max(this.nodeRadius * 3, this.width / (this.positions.size + 1));\n\n      const x1 = hSpacing * (pPos.xIndex + 1);\n      const y1 = this.levelHeight * (pPos.depth + 1);\n\n      const x2 = hSpacing * (cPos.xIndex + 1);\n      const y2 = this.levelHeight * (cPos.depth + 1);\n\n      const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n      line.setAttribute(\"class\", \"link\");\n      line.setAttribute(\"x1\", x1);\n      line.setAttribute(\"y1\", y1);\n      line.setAttribute(\"x2\", x2);\n      line.setAttribute(\"y2\", y2);\n      this.svg.appendChild(line);\n    }\n\n    drawNode(node) {\n      const pos = this.positions.get(node);\n      const hSpacing = Math.max(this.nodeRadius * 3, this.width / (this.positions.size + 1));\n\n      const cx = hSpacing * (pos.xIndex + 1);\n      const cy = this.levelHeight * (pos.depth + 1);\n\n      const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      g.setAttribute(\"class\", \"node \" + node.color);\n      g.setAttribute(\"transform\", `translate(${cx},${cy})`);\n\n      const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n      circle.setAttribute(\"r\", this.nodeRadius);\n\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      text.setAttribute(\"text-anchor\", \"middle\");\n      text.setAttribute(\"dy\", \"0.35em\");\n      text.setAttribute(\"fill\", node.color === \"red\" ? \"#fff\" : \"#eee\");\n      text.textContent = node.value;\n\n      g.appendChild(circle);\n      g.appendChild(text);\n\n      this.svg.appendChild(g);\n    }\n  }\n\n  const rbTree = new RBTree();\n  const svgTree = document.getElementById(\"tree\");\n  const visualizer = new Visualizer(rbTree, svgTree);\n\n  const inputValue = document.getElementById(\"inputValue\");\n  const insertBtn = document.getElementById(\"insertBtn\");\n  const deleteBtn = document.getElementById(\"deleteBtn\");\n  const clearBtn = document.getElementById(\"clearBtn\");\n  const messages = document.getElementById(\"messages\");\n\n  function showMessage(msg, isError = false) {\n    messages.textContent = msg;\n    messages.style.color = isError ? \"#d9534f\" : \"#555\";\n  }\n\n  function clearMessage() {\n    messages.textContent = \"\";\n  }\n\n  insertBtn.addEventListener(\"click\", () => {\n    const val = Number(inputValue.value);\n    if (!Number.isInteger(val)) {\n      showMessage(\"Please enter a valid integer.\", true);\n      return;\n    }\n    const inserted = rbTree.insert(val);\n    if (inserted) {\n      clearMessage();\n      visualizer.draw();\n    } else {\n      showMessage(`Value ${val} already exists in the tree.`, true);\n    }\n    inputValue.value = \"\";\n    inputValue.focus();\n  });\n\n  deleteBtn.addEventListener(\"click\", () => {\n    const val = Number(inputValue.value);\n    if (!Number.isInteger(val)) {\n      showMessage(\"Please enter a valid integer to delete.\", true);\n      return;\n    }\n    const deleted = rbTree.delete(val);\n    if (deleted) {\n      clearMessage();\n      visualizer.draw();\n    } else {\n      showMessage(`Value ${val} not found in the tree.`, true);\n    }\n    inputValue.value = \"\";\n    inputValue.focus();\n  });\n\n  clearBtn.addEventListener(\"click\", () => {\n    rbTree.clear();\n    visualizer.draw();\n    clearMessage();\n  });\n\n  window.addEventListener(\"resize\", () => {\n    visualizer.width = svgTree.clientWidth;\n    visualizer.height = svgTree.clientHeight;\n    svgTree.setAttribute(\"viewBox\", `0 0 ${svgTree.clientWidth} ${svgTree.clientHeight}`);\n    visualizer.draw();\n  });\n\n  // Initial draw empty\n  visualizer.draw();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Red-Black Tree"
    }
  ],
  "topic": "Red-Black Tree",
  "hasFSM": false,
  "hasTest": true
}