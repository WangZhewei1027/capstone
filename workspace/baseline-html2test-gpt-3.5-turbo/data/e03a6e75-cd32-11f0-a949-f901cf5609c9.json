{
  "id": "e03a6e75-cd32-11f0-a949-f901cf5609c9",
  "timestamp": "2025-11-29T14:52:19.435Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>K-Means Clustering Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    background: #f7f9fc;\n  }\n  h1 {\n    margin: 1rem 0 0.5rem 0;\n  }\n  #container {\n    display: flex;\n    flex-direction: row;\n    margin: 1rem;\n  }\n  #canvas-container {\n    position: relative;\n  }\n  canvas {\n    border: 1px solid #ccc;\n    background: #fff;\n    cursor: crosshair;\n  }\n  #controls {\n    margin-left: 20px;\n    max-width: 300px;\n  }\n  #controls label {\n    display: block;\n    margin-top: 10px;\n    font-weight: bold;\n  }\n  #controls input[type=range] {\n    width: 100%;\n  }\n  #info {\n    margin-top: 10px;\n    font-size: 0.9rem;\n    color: #555;\n  }\n  button {\n    margin-top: 20px;\n    background: #007bff;\n    color: white;\n    font-size: 1rem;\n    border: none;\n    padding: 8px 15px;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n  button:hover {\n    background: #0056b3;\n  }\n  #legend {\n    margin-top: 15px;\n    display: flex;\n    flex-wrap: wrap;\n  }\n  .legend-item {\n    display: flex;\n    align-items: center;\n    margin-right: 15px;\n    font-size: 0.9rem;\n  }\n  .legend-color {\n    width: 16px;\n    height: 16px;\n    margin-right: 6px;\n    border-radius: 3px;\n    border: 1px solid #999;\n  }\n  #instructions {\n    max-width: 650px;\n    font-size: 0.9rem;\n    color: #333;\n    margin: 0 auto 1rem auto;\n    line-height: 1.4;\n  }\n  #footer {\n    margin: 2rem 0 1rem 0;\n    font-size: 0.8rem;\n    color: #777;\n  }\n</style>\n</head>\n<body>\n<h1>K-Means Clustering Demo</h1>\n<div id=\"instructions\">\n  <p><strong>Instructions:</strong> Click inside the white canvas to add points. Set the number of clusters (K) and then click <em>Run K-Means</em> to cluster the points into K groups. You can reset the points or run multiple times with different K.</p>\n  <p>The color of points and their cluster centroid will be shown. Centroids are displayed as larger crosses.</p>\n</div>\n<div id=\"container\">\n  <div id=\"canvas-container\">\n    <canvas id=\"canvas\" width=\"600\" height=\"600\" tabindex=\"0\" aria-label=\"K-Means clustering canvas\"></canvas>\n  </div>\n  <div id=\"controls\" role=\"region\" aria-label=\"Controls for clustering\">\n    <label for=\"kRange\">Number of clusters (K): <span id=\"kValue\">3</span></label>\n    <input type=\"range\" id=\"kRange\" min=\"1\" max=\"10\" value=\"3\" />\n    <button id=\"runButton\" aria-live=\"polite\">Run K-Means</button>\n    <button id=\"resetButton\">Reset Points</button>\n    <div id=\"info\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n    <div id=\"legend\" aria-hidden=\"true\"></div>\n  </div>\n</div>\n\n<script>\n(() => {\n  'use strict';\n\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  const kRange = document.getElementById('kRange');\n  const kValueSpan = document.getElementById('kValue');\n  const runButton = document.getElementById('runButton');\n  const resetButton = document.getElementById('resetButton');\n  const info = document.getElementById('info');\n  const legend = document.getElementById('legend');\n\n  const width = canvas.width;\n  const height = canvas.height;\n\n  let points = [];\n  let clusters = [];\n  let centroids = [];\n  let colors = [];\n\n  // Generate an array of visually distinct colors for cluster coloring\n  function generateColors(n) {\n    const baseColors = [\n      '#e6194b', '#3cb44b', '#ffe119', '#0082c8', '#f58231',\n      '#911eb4', '#46f0f0', '#f032e6', '#d2f53c', '#fabebe',\n      '#008080', '#e6beff', '#aa6e28', '#fffac8', '#800000',\n      '#aaffc3', '#808000', '#ffd8b1', '#000080', '#808080'\n    ];\n    if (n <= baseColors.length) {\n      return baseColors.slice(0, n);\n    }\n    // If more colors needed, generate via HSL stepping\n    let arr = [];\n    for (let i = 0; i < n; i++) {\n      const hue = i * 360 / n;\n      arr.push(`hsl(${hue}, 80%, 60%)`);\n    }\n    return arr;\n  }\n\n  // Draw functions\n  function drawCanvas() {\n    ctx.clearRect(0, 0, width, height);\n    drawPoints();\n    drawCentroids();\n  }\n\n  function drawPoints() {\n    for (let i = 0; i < points.length; i++) {\n      const p = points[i];\n      const c = clusters[i];\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, 6, 0, 2 * Math.PI);\n      ctx.fillStyle = c === -1 ? '#999999' : colors[c];\n      ctx.strokeStyle = '#333';\n      ctx.lineWidth = 1;\n      ctx.fill();\n      ctx.stroke();\n    }\n  }\n\n  function drawCentroids() {\n    for (let i = 0; i < centroids.length; i++) {\n      const c = centroids[i];\n      const color = colors[i];\n      drawCross(c.x, c.y, 12, color, 3);\n    }\n  }\n\n  function drawCross(x, y, size, color, lineWidth=2) {\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.beginPath();\n    ctx.moveTo(x - size, y - size);\n    ctx.lineTo(x + size, y + size);\n    ctx.moveTo(x + size, y - size);\n    ctx.lineTo(x - size, y + size);\n    ctx.stroke();\n  }\n\n  // K-Means algorithm implementation\n  function kMeans(points, K, maxIterations = 100) {\n    if (points.length === 0) return {clusters: [], centroids: []};\n    // Initialize centroids by randomly selecting distinct points\n    let centroids = [];\n    const usedIndexes = new Set();\n    while (centroids.length < K) {\n      const idx = Math.floor(Math.random() * points.length);\n      if (!usedIndexes.has(idx)) {\n        usedIndexes.add(idx);\n        centroids.push({x: points[idx].x, y: points[idx].y});\n      }\n    }\n\n    let clusters = new Array(points.length).fill(-1);\n    let changed = true;\n    let iterations = 0;\n\n    while (changed && iterations < maxIterations) {\n      changed = false;\n      iterations++;\n\n      // Assign points to nearest centroid\n      for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n        let minDist = Infinity;\n        let assignedCluster = clusters[i];\n        for (let c = 0; c < K; c++) {\n          const dist = distance(p, centroids[c]);\n          if (dist < minDist) {\n            minDist = dist;\n            assignedCluster = c;\n          }\n        }\n        if (clusters[i] !== assignedCluster) {\n          clusters[i] = assignedCluster;\n          changed = true;\n        }\n      }\n\n      // Update centroids\n      let sums = new Array(K).fill(0).map(() => ({x: 0, y: 0, count: 0}));\n      for (let i = 0; i < points.length; i++) {\n        const c = clusters[i];\n        sums[c].x += points[i].x;\n        sums[c].y += points[i].y;\n        sums[c].count++;\n      }\n      for (let c = 0; c < K; c++) {\n        if (sums[c].count > 0) {\n          centroids[c].x = sums[c].x / sums[c].count;\n          centroids[c].y = sums[c].y / sums[c].count;\n        } else {\n          // If cluster lost all points, reinitialize centroid randomly\n          const idx = Math.floor(Math.random() * points.length);\n          centroids[c].x = points[idx].x;\n          centroids[c].y = points[idx].y;\n          changed = true;\n        }\n      }\n    }\n\n    return {clusters, centroids, iterations};\n  }\n\n  function distance(a, b) {\n    return Math.hypot(a.x - b.x, a.y - b.y);\n  }\n\n  // Event handlers and UI updates\n  canvas.addEventListener('click', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    // Add point snapped inside canvas bounds\n    points.push({x: clamp(x, 0, width), y: clamp(y, 0, height)});\n    // Reset clustering - need to run again to see clusters\n    clusters = new Array(points.length).fill(-1);\n    centroids = [];\n    colors = generateColors(kRange.value);\n    updateLegend([]);\n    updateInfo(`Point added. Total points: ${points.length}`);\n    drawCanvas();\n  });\n\n  kRange.addEventListener('input', () => {\n    kValueSpan.textContent = kRange.value;\n    colors = generateColors(kRange.value);\n    // Reset clusters and centroids on K change\n    clusters = new Array(points.length).fill(-1);\n    centroids = [];\n    updateLegend([]);\n    updateInfo('');\n    drawCanvas();\n  });\n\n  runButton.addEventListener('click', () => {\n    const K = parseInt(kRange.value, 10);\n    if (points.length === 0) {\n      updateInfo('Please add points by clicking on the canvas first.');\n      return;\n    }\n    if (K < 1) {\n      updateInfo('Number of clusters must be at least 1.');\n      return;\n    }\n    if (K > points.length) {\n      updateInfo('Number of clusters cannot exceed number of points.');\n      return;\n    }\n    updateInfo('Running K-Means clustering...');\n    colors = generateColors(K);\n    const startTime = performance.now();\n    const result = kMeans(points, K);\n    const endTime = performance.now();\n\n    clusters = result.clusters;\n    centroids = result.centroids;\n    updateInfo(`K-Means converged in ${result.iterations} iterations (${(endTime - startTime).toFixed(2)} ms).`);\n    updateLegend(colors);\n    drawCanvas();\n  });\n\n  resetButton.addEventListener('click', () => {\n    points = [];\n    clusters = [];\n    centroids = [];\n    colors = generateColors(kRange.value);\n    updateLegend([]);\n    updateInfo('Points reset. Add new points by clicking on the canvas.');\n    drawCanvas();\n  });\n\n  // Utility functions\n  function clamp(v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  }\n\n  function updateInfo(text) {\n    info.textContent = text;\n  }\n\n  function updateLegend(colorsArray) {\n    legend.innerHTML = '';\n    if (colorsArray.length === 0) {\n      return;\n    }\n    for (let i = 0; i < colorsArray.length; i++) {\n      const div = document.createElement('div');\n      div.className = 'legend-item';\n      const colorBox = document.createElement('div');\n      colorBox.className = 'legend-color';\n      colorBox.style.backgroundColor = colorsArray[i];\n      div.appendChild(colorBox);\n      const label = document.createElement('span');\n      label.textContent = `Cluster ${i+1}`;\n      div.appendChild(label);\n      legend.appendChild(div);\n    }\n  }\n\n  // Initialize\n  clusters = [];\n  centroids = [];\n  colors = generateColors(kRange.value);\n  updateInfo('Click on canvas to add points. Set K and run clustering.');\n  drawCanvas();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": false,
  "hasTest": true
}