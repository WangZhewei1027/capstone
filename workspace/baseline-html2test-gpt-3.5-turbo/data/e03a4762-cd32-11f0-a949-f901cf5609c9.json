{
  "id": "e03a4762-cd32-11f0-a949-f901cf5609c9",
  "timestamp": "2025-11-29T14:52:17.928Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Breadth-First Search (BFS) Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f0f0f0;\n  }\n  h1 {\n    text-align: center;\n  }\n  #graph-container {\n    margin: 20px auto;\n    max-width: 600px;\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n  }\n  .node {\n    width: 50px;\n    height: 50px;\n    background: #ddd;\n    border: 2px solid #888;\n    border-radius: 50%;\n    margin: 10px;\n    line-height: 50px;\n    text-align: center;\n    font-weight: bold;\n    cursor: pointer;\n    user-select: none;\n    transition: background-color 0.3s, border-color 0.3s;\n    position: relative;\n  }\n  .node.visited {\n    background-color: #4CAF50;\n    border-color: #2e7d32;\n    color: white;\n  }\n  .node.current {\n    background-color: #ff9800;\n    border-color: #ef6c00;\n    color: white;\n  }\n  .node.start {\n    border-color: #2196f3;\n    box-shadow: 0 0 10px #2196f3;\n  }\n  #controls {\n    max-width: 600px;\n    margin: 0 auto 20px auto;\n    text-align: center;\n  }\n  #adjacency-list {\n    max-width: 600px;\n    margin: 0 auto 20px auto;\n    background: #fff;\n    padding: 10px;\n    border-radius: 8px;\n    font-family: monospace;\n    overflow-x: auto;\n  }\n  button {\n    cursor: pointer;\n    font-size: 16px;\n    padding: 8px 16px;\n    margin-top: 10px;\n  }\n  #bfs-order {\n    max-width: 600px;\n    margin: 10px auto;\n    background: #fff;\n    padding: 10px;\n    border-radius: 8px;\n    min-height: 30px;\n    font-weight: bold;\n  }\n  #help {\n    max-width: 600px;\n    margin: 20px auto;\n    font-size: 0.9em;\n    color: #555;\n    line-height: 1.4em;\n  }\n  /* Lines between nodes */\n  svg {\n    position: absolute;\n    top: 0;\n    left: 0;\n    pointer-events: none;\n  }\n</style>\n</head>\n<body>\n<h1>Breadth-First Search (BFS) Visualization</h1>\n<div id=\"controls\">\n  <label for=\"start-node\">Select Start Node: </label>\n  <select id=\"start-node\"></select>\n  <button id=\"start-bfs\">Start BFS</button>\n</div>\n\n<div id=\"graph-container\"></div>\n<svg id=\"edges-svg\"></svg>\n\n<div id=\"bfs-order\">BFS Visit Order: <span id=\"visit-sequence\"></span></div>\n\n<div id=\"help\">\n  <strong>How to use:</strong> Click \"Start BFS\" to see the BFS traversal starting from the selected node.\n  Nodes currently being visited are colored orange, visited nodes are green. The BFS order updates as the algorithm progresses.\n</div>\n\n<script>\n(() => {\n  // Graph definition - adjacency list\n  // Example graph with 8 nodes labeled A-H\n  const graph = {\n    A: [\"B\", \"C\"],\n    B: [\"A\", \"D\", \"E\"],\n    C: [\"A\", \"F\"],\n    D: [\"B\"],\n    E: [\"B\", \"F\"],\n    F: [\"C\", \"E\", \"G\", \"H\"],\n    G: [\"F\"],\n    H: [\"F\"],\n  };\n\n  const nodes = Object.keys(graph);\n  let visitOrder = [];\n  let visitedSet = new Set();\n  let queue = [];\n\n  const graphContainer = document.getElementById(\"graph-container\");\n  const startSelect = document.getElementById(\"start-node\");\n  const startBtn = document.getElementById(\"start-bfs\");\n  const visitSequence = document.getElementById(\"visit-sequence\");\n  const edgesSvg = document.getElementById(\"edges-svg\");\n\n  // Create node elements\n  // We'll position nodes in a simple circular layout for visualization\n  const nodeElements = {};\n  const centerX = 300;\n  const centerY = 300;\n  const radius = 200;\n  const nodePositions = {}; // To store x,y for edges lines\n\n  function createNodes() {\n    graphContainer.innerHTML = \"\";\n    nodeElements = {};\n    const n = nodes.length;\n    nodes.forEach((label, i) => {\n      const angle = (2 * Math.PI * i) / n - Math.PI / 2; // start at top\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n      nodePositions[label] = { x, y };\n\n      const div = document.createElement(\"div\");\n      div.classList.add(\"node\");\n      div.textContent = label;\n      div.style.position = \"absolute\";\n      div.style.left = (x - 25) + \"px\";\n      div.style.top = (y - 25) + \"px\";\n      graphContainer.appendChild(div);\n      nodeElements[label] = div;\n\n      // mark start node style on selection change\n      div.dataset.label = label;\n    });\n    graphContainer.style.position = \"relative\";\n    graphContainer.style.minHeight = \"600px\";\n  }\n\n  // Draw edges lines between node centers\n  function drawEdges() {\n    // Clear previous\n    edgesSvg.innerHTML = \"\";\n    edgesSvg.setAttribute(\"width\", centerX * 2);\n    edgesSvg.setAttribute(\"height\", centerY * 2);\n\n    const drawnEdges = new Set();\n\n    for (const [node, neighbors] of Object.entries(graph)) {\n      neighbors.forEach((nbr) => {\n        // Undirected edge - avoid double drawing by ordering nodes lex\n        const edgeId = [node, nbr].sort().join(\"-\");\n        if (drawnEdges.has(edgeId)) return;\n        drawnEdges.add(edgeId);\n\n        const pos1 = nodePositions[node];\n        const pos2 = nodePositions[nbr];\n        const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n        line.setAttribute(\"x1\", pos1.x);\n        line.setAttribute(\"y1\", pos1.y);\n        line.setAttribute(\"x2\", pos2.x);\n        line.setAttribute(\"y2\", pos2.y);\n        line.setAttribute(\"stroke\", \"#aaa\");\n        line.setAttribute(\"stroke-width\", \"2\");\n        edgesSvg.appendChild(line);\n      });\n    }\n  }\n\n  // Populate start node dropdown\n  function populateStartNodeSelector() {\n    startSelect.innerHTML = \"\";\n    nodes.forEach((n) => {\n      const option = document.createElement(\"option\");\n      option.value = n;\n      option.textContent = n;\n      startSelect.appendChild(option);\n    });\n  }\n\n  // Reset all nodes colors/styles\n  function resetNodes() {\n    Object.values(nodeElements).forEach((nodeEl) => {\n      nodeEl.classList.remove(\"visited\", \"current\", \"start\");\n    });\n  }\n\n  // Mark start node visually\n  function markStartNode(nodeLabel) {\n    resetNodes();\n    nodeElements[nodeLabel]?.classList.add(\"start\");\n  }\n\n  // BFS algorithm with visualization and delay\n  async function bfs(startNode) {\n    resetNodes();\n    visitOrder = [];\n    visitedSet = new Set();\n    queue = [];\n\n    markStartNode(startNode);\n\n    queue.push(startNode);\n    visitedSet.add(startNode);\n\n    while (queue.length > 0) {\n      const current = queue.shift();\n\n      nodeElements[current].classList.add(\"current\");\n\n      // Wait a bit to visualize\n      await sleep(700);\n\n      nodeElements[current].classList.remove(\"current\");\n      nodeElements[current].classList.add(\"visited\");\n      visitOrder.push(current);\n      updateVisitSequence();\n\n      // Enqueue neighbors if not visited\n      for (const neighbor of graph[current]) {\n        if (!visitedSet.has(neighbor)) {\n          queue.push(neighbor);\n          visitedSet.add(neighbor);\n        }\n      }\n    }\n  }\n\n  function sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  function updateVisitSequence() {\n    visitSequence.textContent = visitOrder.join(\" â†’ \");\n  }\n\n  // Initialize\n  createNodes();\n  drawEdges();\n  populateStartNodeSelector();\n  markStartNode(startSelect.value);\n\n  // On start-node change, update start styling\n  startSelect.addEventListener(\"change\", () => {\n    markStartNode(startSelect.value);\n    visitSequence.textContent = \"\";\n  });\n\n  startBtn.addEventListener(\"click\", async () => {\n    startBtn.disabled = true;\n    startSelect.disabled = true;\n    visitSequence.textContent = \"\";\n    await bfs(startSelect.value);\n    startBtn.disabled = false;\n    startSelect.disabled = false;\n  });\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": false,
  "hasTest": true
}