{
  "id": "e03a4767-cd32-11f0-a949-f901cf5609c9",
  "timestamp": "2025-11-29T14:52:34.159Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Prim's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    overflow: hidden;\n    background: #2c3e50;\n    color: #ecf0f1;\n  }\n  #container {\n    display: flex;\n    height: 100vh;\n  }\n  #canvasContainer {\n    flex: 1;\n    position: relative;\n  }\n  canvas {\n    background: #34495e;\n    display: block;\n    margin: 0 auto;\n  }\n  #controls {\n    width: 320px;\n    background: #1a252f;\n    padding: 20px;\n    box-sizing: border-box;\n    overflow-y: auto;\n  }\n  h1 {\n    margin-top: 0;\n    font-size: 24px;\n    text-align:center;\n  }\n  button {\n    background: #2980b9;\n    border: none;\n    border-radius: 3px;\n    padding: 10px 15px;\n    color: white;\n    font-size: 16px;\n    cursor: pointer;\n    margin-top: 10px;\n    width: 100%;\n    user-select:none;\n  }\n  button:disabled {\n    background: #7f8c8d;\n    cursor: default;\n  }\n  label {\n    display: block;\n    margin-top: 15px;\n    margin-bottom: 8px;\n  }\n  input[type=number] {\n    width: 100%;\n    padding: 8px;\n    font-size: 16px;\n    box-sizing: border-box;\n    border-radius: 3px;\n    border: none;\n  }\n  #description {\n    font-size: 14px;\n    line-height: 1.4;\n    margin-top: 20px;\n    background: #22303b;\n    padding: 10px;\n    border-radius: 4px;\n    height: 200px;\n    overflow-y: auto;\n  }\n  #stepDetails {\n    margin-top: 15px;\n    font-size: 14px;\n    line-height: 1.3;\n    background: #22303b;\n    padding: 10px;\n    border-radius: 4px;\n    height: 130px;\n    overflow-y: auto;\n  }\n  #graphInfo {\n    font-size: 14px;\n    margin-top: 15px;\n  }\n  .small-note {\n    font-size: 12px;\n    color: #aab7c4;\n    margin-top: 5px;\n  }\n  a {\n    color: #3498db;\n  }\n</style>\n</head>\n<body>\n<div id=\"container\">\n  <div id=\"canvasContainer\">\n    <canvas id=\"graphCanvas\" width=\"700\" height=\"600\"></canvas>\n  </div>\n  <div id=\"controls\">\n    <h1>Prim's Algorithm</h1>\n\n    <label for=\"numVertices\">Number of vertices (3 - 12):</label>\n    <input type=\"number\" id=\"numVertices\" min=\"3\" max=\"12\" value=\"6\" />\n\n    <button id=\"generateGraphBtn\">Generate Random Graph</button>\n    <button id=\"startBtn\" disabled>Start Prim's Algorithm</button>\n    <button id=\"stepBtn\" disabled>Next Step</button>\n    <button id=\"resetBtn\" disabled>Reset</button>\n\n    <div id=\"graphInfo\"></div>\n\n    <div id=\"stepDetails\">\n      <strong>Algorithm Status:</strong>\n      <div id=\"statusText\">Click \"Generate Random Graph\" to begin.</div>\n    </div>\n    <div id=\"description\">\n      <strong>Prim's Algorithm (Minimal Spanning Tree):</strong>\n      <p>\n        Prim's algorithm builds a minimum spanning tree (MST) for a weighted undirected graph.\n        It starts from any vertex and grows the spanning tree by repeatedly adding the smallest \n        edge that connects a vertex inside the MST to a vertex outside it until all vertices are included.\n      </p>\n      <p>\n        <strong>Steps: </strong>\n        <ol>\n          <li>Initialize MST with one vertex (start vertex).</li>\n          <li>Find the edge with the minimum weight that connects MST to a vertex not yet included.</li>\n          <li>Add that edge and the vertex to MST.</li>\n          <li>Repeat until all vertices are in MST.</li>\n        </ol>\n      </p>\n      <p>\n        This visualization shows the graph with weighted edges, and step-by-step how Prim's algorithm selects edges.\n      </p>\n      <p style=\"font-size: 12px; text-align:center; margin-top:20px;\">\n        Created by ChatGPT &mdash; <a href=\"https://en.wikipedia.org/wiki/Prim%27s_algorithm\" target=\"_blank\" rel=\"noopener\">Learn More</a>\n      </p>\n    </div>\n  </div>\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n  const width = canvas.width;\n  const height = canvas.height;\n\n  // Controls\n  const numVerticesInput = document.getElementById('numVertices');\n  const generateBtn = document.getElementById('generateGraphBtn');\n  const startBtn = document.getElementById('startBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const statusText = document.getElementById('statusText');\n  const graphInfo = document.getElementById('graphInfo');\n\n  // Graph data structures\n  let vertices = [];\n  let edges = []; // {from, to, weight}\n  let adjList = [];\n\n  // Prim's variables\n  let primMSTEdges = [];\n  let inMST = [];\n  let edgeCandidates = [];\n  let currentStep = 0;\n  let totalVertices = 0;\n\n  // Visual config\n  const vertexRadius = 20;\n  const vertexColor = '#2980b9';\n  const vertexInMSTColor = '#2ecc71';\n  const vertexSelectedColor = '#f39c12';\n  const edgeColor = '#bdc3c7';\n  const edgeMSTColor = '#27ae60';\n  const edgeCandidateColor = '#f1c40f';\n  const textColor = '#ecf0f1';\n\n  // For step by step highlighting\n  let lastAddedEdge = null;\n\n  // Utility functions\n  function dist(p1, p2) {\n    return Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2);\n  }\n\n  function drawVertex(vertex, index, color) {\n    ctx.beginPath();\n    ctx.fillStyle = color;\n    ctx.shadowColor = 'rgba(0,0,0,0.7)';\n    ctx.shadowBlur = 6;\n    ctx.arc(vertex.x, vertex.y, vertexRadius, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.shadowBlur = 0;\n\n    // Draw number\n    ctx.fillStyle = textColor;\n    ctx.font = 'bold 16px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(index, vertex.x, vertex.y);\n  }\n\n  function drawEdge(edge, color, lineWidth=3) {\n    let v1 = vertices[edge.from];\n    let v2 = vertices[edge.to];\n    ctx.beginPath();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.shadowColor = 'rgba(0,0,0,0.6)';\n    ctx.shadowBlur = 4;\n    ctx.moveTo(v1.x, v1.y);\n    ctx.lineTo(v2.x, v2.y);\n    ctx.stroke();\n    ctx.shadowBlur = 0;\n\n    // Draw the weight near the middle with a white background\n    const midX = (v1.x + v2.x) / 2;\n    const midY = (v1.y + v2.y) / 2;\n\n    const weightText = edge.weight.toFixed(1);\n\n    ctx.font = '14px Arial';\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = 'center';\n    const textWidth = ctx.measureText(weightText).width;\n    const padding = 4;\n    ctx.fillStyle = '#ecf0f1';\n    ctx.shadowColor = 'rgba(0,0,0,0.7)';\n    ctx.shadowBlur = 3;\n    ctx.fillRect(midX - textWidth/2 - padding, midY - 10, textWidth + 2*padding, 20);\n    ctx.shadowBlur = 0;\n\n    ctx.fillStyle = '#2c3e50';\n    ctx.fillText(weightText, midX, midY);\n  }\n\n  function clearCanvas() {\n    ctx.clearRect(0, 0, width, height);\n  }\n\n  function generateVertices(n) {\n    const margin = 60;\n    const points = [];\n    let tries = 0;\n\n    while(points.length < n && tries < 1000) {\n      tries++;\n      const p = {\n        x: margin + Math.random() * (width - 2*margin),\n        y: margin + Math.random() * (height - 2*margin)\n      };\n      // Avoid too close points\n      const minDist = vertexRadius*4;\n      let close = false;\n      for(let pt of points) {\n        if(dist(pt, p) < minDist) {\n          close = true;\n          break;\n        }\n      }\n      if(!close) points.push(p);\n    }\n    if(points.length < n) {\n      // fallback evenly spaced\n      points.length = 0;\n      for(let i=0; i<n; i++) {\n        points.push({\n          x: margin + (i * (width - 2*margin)) / (n-1),\n          y: height/2 + 50 * Math.sin(i)\n        });\n      }\n    }\n    return points;\n  }\n\n  function generateRandomGraph(n) {\n    vertices = generateVertices(n);\n    adjList = Array.from({length:n}, () => []);\n    edges = [];\n\n    // We'll create a connected graph\n    // First make a simple connected chain with random weights\n    for(let i=1; i<n; i++) {\n      let w = +(1 + Math.random()*10).toFixed(1);\n      edges.push({from: i-1, to: i, weight: w});\n      adjList[i-1].push({to: i, weight: w});\n      adjList[i].push({to: i-1, weight: w});\n    }\n\n    // Add some random additional edges (not creating multi-edges or self-loops)\n    const maxEdges = n*(n-1)/2; // full graph edges\n    let currentEdges = edges.length;\n    const additionalEdges = Math.min(n + 3, maxEdges - currentEdges);\n\n    let attempts = 0;\n    while(currentEdges < n - 1 + additionalEdges && attempts < 500) {\n      attempts++;\n      let u = Math.floor(Math.random()*n);\n      let v = Math.floor(Math.random()*n);\n      if(u === v) continue;\n      if(adjList[u].some(e => e.to === v)) continue;\n      let w = +(1 + Math.random()*10).toFixed(1);\n\n      edges.push({from: u, to: v, weight: w});\n      adjList[u].push({to: v, weight: w});\n      adjList[v].push({to: u, weight: w});\n      currentEdges++;\n    }\n  }\n\n  // Draw the full graph with current MST and highlights\n  function drawGraph() {\n    clearCanvas();\n\n    // Draw all edges first\n    edges.forEach(e => {\n      let color = edgeColor;\n      let lineWidth = 2;\n      // If in MST edges\n      if (primMSTEdges.find(me =>\n          (me.from === e.from && me.to === e.to) ||\n          (me.from === e.to && me.to === e.from)\n        )) {\n        color = edgeMSTColor;\n        lineWidth = 4;\n      }\n      else if(lastAddedEdge && \n        ((lastAddedEdge.from === e.from && lastAddedEdge.to === e.to) ||\n        (lastAddedEdge.from === e.to && lastAddedEdge.to === e.from))) {\n        color = '#e74c3c'; // highlight last added edge red\n        lineWidth = 5;\n      }\n      else if(edgeCandidates.includes(e)) {\n        color = edgeCandidateColor;\n        lineWidth = 3;\n      }\n      drawEdge(e,color,lineWidth);\n    });\n\n    // Draw vertices\n    for(let i=0; i<vertices.length; i++) {\n      let color = vertexColor;\n      if(inMST[i]) {\n        color = vertexInMSTColor;\n      }\n      drawVertex(vertices[i], i, color);\n    }\n  }\n\n  // Find edge in edges list matching from and to (undirected)\n  function findEdge(u,v) {\n    return edges.find(e => (e.from === u && e.to === v) || (e.from === v && e.to === u));\n  }\n\n  // Prim's Algorithm initialization\n  function primInit() {\n    const n = vertices.length;\n    inMST = Array(n).fill(false);\n    primMSTEdges = [];\n    edgeCandidates = [];\n    currentStep = 0;\n    lastAddedEdge = null;\n\n    // Start from vertex 0\n    inMST[0] = true;\n\n    // Add edges from vertex 0 to edgeCandidates\n    edgeCandidates = [];\n    for(let e of edges) {\n      if(e.from === 0 && !inMST[e.to]) edgeCandidates.push(e);\n      else if(e.to === 0 && !inMST[e.from]) edgeCandidates.push(e);\n    }\n\n    updateStatus(`Starting from vertex 0. Edges connected to 0 are candidates.`);\n    drawGraph();\n  }\n\n  // Prim's Algorithm step - adds one edge and vertex per step\n  function primStep() {\n    if(inMST.every(v => v)) {\n      updateStatus(`All vertices included. MST complete.`);\n      drawGraph();\n      stepBtn.disabled = true;\n      return;\n    }\n\n    // Find edge with minimum weight connecting MST to outside vertex\n    // edgeCandidates holds edges crossing MST frontier\n    let minEdge = null;\n    let minWeight = Infinity;\n    for(let edge of edges) {\n      const uIn = inMST[edge.from];\n      const vIn = inMST[edge.to];\n      if(uIn !== vIn) { // connecting MST to outside vertex\n        if(edge.weight < minWeight) {\n          minWeight = edge.weight;\n          minEdge = edge;\n        }\n      }\n    }\n    if(!minEdge) {\n      updateStatus(`No edge found connecting MST to remaining vertices. Graph might be disconnected.`);\n      stepBtn.disabled = true;\n      return;\n    }\n\n    // Add the edge and vertex to MST\n    primMSTEdges.push(minEdge);\n    lastAddedEdge = minEdge;\n\n    // Mark the new vertex included in MST\n    if(inMST[minEdge.from]) {\n      inMST[minEdge.to] = true;\n      updateStatus(`Adding edge (${minEdge.from} - ${minEdge.to}) with weight ${minEdge.weight.toFixed(1)} to MST. Vertex ${minEdge.to} included.`);\n    } else {\n      inMST[minEdge.from] = true;\n      updateStatus(`Adding edge (${minEdge.from} - ${minEdge.to}) with weight ${minEdge.weight.toFixed(1)} to MST. Vertex ${minEdge.from} included.`);\n    }\n\n    currentStep++;\n    drawGraph();\n\n    if(inMST.every(v => v)) {\n      updateStatus(`All vertices included. MST complete. Total edges: ${primMSTEdges.length}`);\n      stepBtn.disabled = true;\n      startBtn.disabled = true;\n    }\n  }\n\n  function updateStatus(text) {\n    statusText.textContent = text;\n  }\n\n  function updateGraphInfo() {\n    let info = `<strong>Graph Info:</strong><br>`;\n    info += `Vertices: ${vertices.length}<br>`;\n    info += `Edges: ${edges.length}<br>`;\n    graphInfo.innerHTML = info;\n  }\n\n  // Button events\n  generateBtn.onclick = () => {\n    const n = parseInt(numVerticesInput.value);\n    if(isNaN(n) || n < 3 || n > 12) {\n      alert('Please enter a number of vertices between 3 and 12.');\n      return;\n    }\n    generateRandomGraph(n);\n    updateGraphInfo();\n    primMSTEdges = [];\n    inMST = [];\n    edgeCandidates = [];\n    currentStep = 0;\n    lastAddedEdge = null;\n    startBtn.disabled = false;\n    stepBtn.disabled = true;\n    resetBtn.disabled = true;\n    updateStatus(`Random connected graph generated with ${n} vertices. Click \"Start Prim's Algorithm\" to begin.`);\n    drawGraph();\n  };\n\n  startBtn.onclick = () => {\n    if(vertices.length === 0) {\n      alert('Generate a graph first.');\n      return;\n    }\n    primInit();\n    startBtn.disabled = true;\n    stepBtn.disabled = false;\n    resetBtn.disabled = false;\n  };\n\n  stepBtn.onclick = () => {\n    primStep();\n  };\n\n  resetBtn.onclick = () => {\n    primMSTEdges = [];\n    inMST = [];\n    edgeCandidates = [];\n    currentStep = 0;\n    lastAddedEdge = null;\n    startBtn.disabled = false;\n    stepBtn.disabled = true;\n    resetBtn.disabled = true;\n    updateStatus(`Reset algorithm state. Click \"Start Prim's Algorithm\" to begin again.`);\n    drawGraph();\n  };\n\n  // Initial clear\n  clearCanvas();\n  updateStatus(`Click \"Generate Random Graph\" to begin.`);\n  graphInfo.innerHTML = '';\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}