{
  "id": "e03a4765-cd32-11f0-a949-f901cf5609c9",
  "timestamp": "2025-11-29T14:53:05.836Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Floyd-Warshall Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Floyd-Warshall Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f0f0f0;\n  }\n  h1 {\n    text-align: center;\n  }\n  #matrixInput {\n    margin: 10px auto;\n    max-width: 600px;\n    overflow-x: auto;\n  }\n  table {\n    border-collapse: collapse;\n    margin: 10px 0;\n    width: 100%;\n    max-width: 600px;\n  }\n  th, td {\n    border: 1px solid #666;\n    text-align: center;\n    padding: 8px;\n    min-width: 40px;\n  }\n  input[type=\"number\"] {\n    width: 50px;\n    text-align: center;\n  }\n  button {\n    margin: 10px 5px 20px 5px;\n    padding: 10px 20px;\n    font-size: 16px;\n    cursor: pointer;\n  }\n  #output {\n    max-width: 600px;\n    margin: 0 auto;\n    background: white;\n    padding: 15px;\n    border-radius: 6px;\n    box-shadow: 0 0 10px #aaa;\n  }\n  .step {\n    background: #e8f4fc;\n    border-left: 5px solid #2196f3;\n    margin: 10px 0;\n    padding: 10px;\n    font-family: monospace;\n    white-space: pre-wrap;\n  }\n  #distMatrix, #pathMatrix {\n    font-family: monospace;\n    margin-top: 10px;\n    max-width: 100%;\n    overflow-x: auto;\n  }\n  .highlight {\n    background: #ffff99;\n    font-weight: bold;\n  }\n  #legend {\n    max-width: 600px;\n    margin: 20px auto;\n    font-size: 14px;\n    color: #555;\n  }\n</style>\n</head>\n<body>\n<h1>Floyd-Warshall Algorithm Demonstration</h1>\n<div id=\"instructions\" style=\"max-width:600px;margin:auto;text-align:center;\">\n  <p>Enter the number of vertices and fill the adjacency matrix with weights. Use <code>∞</code> or <code>9999</code> to represent no direct edge.</p>\n</div>\n\n<div style=\"max-width: 600px; margin: auto; text-align:center;\">\n  <label for=\"vertexCount\">Number of vertices (max 10): </label>\n  <input type=\"number\" id=\"vertexCount\" value=\"4\" min=\"2\" max=\"10\" />\n  <button id=\"generateMatrix\">Generate Matrix</button>\n</div>\n\n<form id=\"matrixForm\" style=\"max-width: 600px; margin: 10px auto;\">\n  <div id=\"matrixInput\"></div>\n  <div style=\"text-align:center;\">\n    <button type=\"submit\" id=\"runAlgorithmBtn\">Run Floyd-Warshall</button>\n    <button type=\"button\" id=\"resetBtn\">Reset</button>\n  </div>\n</form>\n\n<div id=\"output\"></div>\n\n<div id=\"legend\" style=\"max-width:600px;margin:auto;\">\n  <p><strong>Legend:</strong></p>\n  <ul>\n    <li><code>∞</code> or <code>9999</code> means no path / infinity distance</li>\n    <li>The matrix displayed after each iteration shows shortest distances so far</li>\n    <li>The path matrix shows the next vertex on the shortest path between nodes</li>\n  </ul>\n</div>\n\n<script>\n(() => {\n  const INF = 9999;\n\n  const vertexCountInput = document.getElementById('vertexCount');\n  const generateMatrixBtn = document.getElementById('generateMatrix');\n  const matrixInputDiv = document.getElementById('matrixInput');\n  const matrixForm = document.getElementById('matrixForm');\n  const outputDiv = document.getElementById('output');\n  const runAlgorithmBtn = document.getElementById('runAlgorithmBtn');\n  const resetBtn = document.getElementById('resetBtn');\n\n  function createMatrixInput(n) {\n    matrixInputDiv.innerHTML = '';\n    const table = document.createElement('table');\n    const headerRow = document.createElement('tr');\n    headerRow.appendChild(document.createElement('th')); // Top-left empty cell\n    for (let j = 0; j < n; j++) {\n      const th = document.createElement('th');\n      th.textContent = `V${j}`;\n      headerRow.appendChild(th);\n    }\n    table.appendChild(headerRow);\n\n    for (let i = 0; i < n; i++) {\n      const row = document.createElement('tr');\n      const rowHeader = document.createElement('th');\n      rowHeader.textContent = `V${i}`;\n      row.appendChild(rowHeader);\n      for (let j = 0; j < n; j++) {\n        const td = document.createElement('td');\n        if (i === j) {\n          const input = document.createElement('input');\n          input.type = 'number';\n          input.value = '0';\n          input.min = '0';\n          input.max = '9999';\n          input.step = '1';\n          input.name = `weight_${i}_${j}`;\n          input.readOnly = true;\n          input.style.backgroundColor = '#dddddd';\n          td.appendChild(input);\n        } else {\n          const input = document.createElement('input');\n          input.type = 'text';\n          input.value = String(INF);\n          input.name = `weight_${i}_${j}`;\n          input.style.textAlign = 'center';\n          input.title = 'Enter edge weight or ∞ for no direct edge';\n          td.appendChild(input);\n        }\n        row.appendChild(td);\n      }\n      table.appendChild(row);\n    }\n    matrixInputDiv.appendChild(table);\n  }\n\n  // Parse matrix from inputs\n  function parseMatrix(n) {\n    const matrix = [];\n    for (let i = 0; i < n; i++) {\n      matrix[i] = [];\n      for (let j = 0; j < n; j++) {\n        const inputName = `weight_${i}_${j}`;\n        const input = matrixForm.elements[inputName];\n        let val = input.value.trim();\n        if (val === '∞' || val.toLowerCase() === 'inf' || val === '') {\n          val = INF;\n        } else {\n          const num = Number(val);\n          if (isNaN(num) || num < 0) {\n            throw new Error(`Invalid weight at (${i},${j}). Must be non-negative number or ∞.`);\n          }\n          val = num;\n        }\n        matrix[i][j] = (val === INF || val >= INF) ? INF : val;\n      }\n    }\n    return matrix;\n  }\n\n  // Format distance for display\n  function distToString(d) {\n    return d >= INF ? '∞' : d.toString();\n  }\n\n  // Initialize path matrix for reconstruction\n  // path[i][j] = next vertex to go from i to j on shortest path, or null if no path\n  function initializePathMatrix(n, dist) {\n    const path = [];\n    for (let i = 0; i < n; i++) {\n      path[i] = [];\n      for (let j = 0; j < n; j++) {\n        if (i === j || dist[i][j] === INF) path[i][j] = null;\n        else path[i][j] = j;\n      }\n    }\n    return path;\n  }\n\n  // Render a square matrix nicely in monospace with labels\n  function renderMatrix(n, matrix, label) {\n    let s = label + '\\n';\n    s += '     ';\n    for (let j = 0; j < n; j++) {\n      s += `V${j}`.padStart(5, ' ') + ' ';\n    }\n    s += '\\n';\n    for (let i = 0; i < n; i++) {\n      s += `V${i}`.padStart(4, ' ') + ' ';\n      for (let j = 0; j < n; j++) {\n        let val = matrix[i][j];\n        if (val === null || val === undefined) val = '';\n        if (typeof val === 'number') val = distToString(val);\n        s += val.toString().padStart(5, ' ') + ' ';\n      }\n      s += '\\n';\n    }\n    return s;\n  }\n\n  // Render path matrix with vertices or '-' if none\n  function renderPathMatrix(n, path) {\n    let s = 'Path matrix (next vertex on shortest path):\\n';\n    s += '     ';\n    for (let j = 0; j < n; j++) {\n      s += `V${j}`.padStart(4, ' ') + ' ';\n    }\n    s += '\\n';\n    for (let i = 0; i < n; i++) {\n      s += `V${i}`.padStart(4, ' ') + ' ';\n      for (let j = 0; j < n; j++) {\n        s += (path[i][j] === null ? '-' : 'V' + path[i][j]).padStart(4, ' ') + ' ';\n      }\n      s += '\\n';\n    }\n    return s;\n  }\n\n  // Floyd-Warshall Algorithm with step-wise output\n  function floydWarshall(n, dist) {\n    // dist is n x n matrix\n    // We will produce iterations showing intermediate matrices\n    // Return final dist and path matrices and an array of steps\n    const path = initializePathMatrix(n, dist);\n\n    const steps = [];\n\n    // We copy dist to avoid mutating original\n    let d = dist.map(row => row.slice());\n\n    for (let k = 0; k < n; k++) {\n      let stepDesc = `Iteration k = ${k} (considering vertex V${k} as intermediate):\\n`;\n      let changedPairs = [];\n      for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n          if (d[i][k] < INF && d[k][j] < INF && d[i][k] + d[k][j] < d[i][j]) {\n            d[i][j] = d[i][k] + d[k][j];\n            path[i][j] = path[i][k];\n            changedPairs.push(`d[V${i}][V${j}] updated to ${d[i][j]} via V${k}`);\n          }\n        }\n      }\n      if (changedPairs.length === 0) {\n        stepDesc += 'No updates this iteration.\\n';\n      } else {\n        stepDesc += changedPairs.join('\\n') + '\\n';\n      }\n      stepDesc += '\\nDistance matrix:\\n';\n      stepDesc += renderMatrix(n, d, '');\n      stepDesc += '\\n' + renderPathMatrix(n, path);\n\n      steps.push(stepDesc);\n    }\n\n    return {dist: d, path, steps};\n  }\n\n\n  // Reconstruct path from i to j using path matrix\n  function reconstructPath(path, i, j) {\n    if (path[i][j] === null) return null; // no path\n    let route = [i];\n    while (i !== j) {\n      i = path[i][j];\n      if (i === null) return null;\n      route.push(i);\n    }\n    return route;\n  }\n\n  // Format a route as string e.g. V0 -> V2 -> V3\n  function formatRoute(route) {\n    if (!route) return 'No path';\n    return route.map(v => 'V' + v).join(' → ');\n  }\n\n  // Event: generate matrix inputs\n  generateMatrixBtn.onclick = () => {\n    let n = Number(vertexCountInput.value);\n    if (isNaN(n) || n < 2 || n > 10) {\n      alert('Please enter a number between 2 and 10.');\n      return;\n    }\n    createMatrixInput(n);\n    outputDiv.innerHTML = '';\n  };\n\n  // Event: run Floyd-Warshall\n  matrixForm.onsubmit = e => {\n    e.preventDefault();\n    outputDiv.innerHTML = '';\n    const n = Number(vertexCountInput.value);\n    if (isNaN(n) || n < 2 || n > 10) {\n      alert('Invalid number of vertices.');\n      return;\n    }\n    let dist;\n    try {\n      dist = parseMatrix(n);\n    } catch (err) {\n      alert(err.message);\n      return;\n    }\n\n    outputDiv.innerHTML = '<p><strong>Running Floyd-Warshall Algorithm...</strong></p>';\n\n    // Run algorithm\n    // We will show all steps\n    const result = floydWarshall(n, dist);\n\n    // Show each iteration in a collapsible detail\n    let html = '';\n    result.steps.forEach((step, i) => {\n      html += `<details ${i===result.steps.length-1 ? 'open' : ''}><summary>Iteration k = ${i}</summary><pre class=\"step\">${step}</pre></details>`;\n    });\n\n    // Show shortest path example controls\n    html += `<hr/><h3>Shortest Path Reconstruction</h3>\n    <p>Pick start and end vertices to display the shortest path and length.</p>\n    <label for=\"startVertex\">Start vertex: </label>\n    <select id=\"startVertex\">${Array.from({length:n},(_,i)=>`<option value=\"${i}\">V${i}</option>`).join('')}</select>\n    <label for=\"endVertex\" style=\"margin-left:15px;\">End vertex: </label>\n    <select id=\"endVertex\">${Array.from({length:n},(_,i)=>`<option value=\"${i}\">V${i}</option>`).join('')}</select>\n    <button id=\"showPathBtn\">Show Path</button>\n    <pre id=\"pathOutput\" style=\"background:#eef;padding:10px;margin-top:10px;max-width:600px;\"></pre>\n    `;\n\n    outputDiv.innerHTML += html;\n\n    const showPathBtn = document.getElementById('showPathBtn');\n    const pathOutput = document.getElementById('pathOutput');\n    const startSelect = document.getElementById('startVertex');\n    const endSelect = document.getElementById('endVertex');\n\n    showPathBtn.onclick = () => {\n      const start = Number(startSelect.value);\n      const end = Number(endSelect.value);\n      if (start === end) {\n        pathOutput.textContent = `Start and end vertex are the same: V${start}`;\n        return;\n      }\n      const route = reconstructPath(result.path, start, end);\n      if (!route) {\n        pathOutput.textContent = `No path from V${start} to V${end}`;\n      } else {\n        pathOutput.textContent = `Shortest path from V${start} to V${end}:\\n${formatRoute(route)}\\n\\nDistance: ${result.dist[start][end]}`;\n      }\n    };\n\n  };\n\n  // Event: Reset inputs and output\n  resetBtn.onclick = () => {\n    outputDiv.innerHTML = '';\n    createMatrixInput(Number(vertexCountInput.value));\n  };\n\n  // Initial matrix on page load\n  createMatrixInput(Number(vertexCountInput.value));\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Floyd-Warshall Algorithm"
    }
  ],
  "topic": "Floyd-Warshall Algorithm",
  "hasFSM": false,
  "hasTest": true
}