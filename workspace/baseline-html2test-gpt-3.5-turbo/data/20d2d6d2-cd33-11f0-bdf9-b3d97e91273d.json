{
  "id": "20d2d6d2-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:28.177Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "K-Nearest Neighbors (KNN)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>K-Nearest Neighbors (KNN) Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f7f9fc;\n  }\n  h1 {\n    text-align: center;\n    margin-bottom: 5px;\n  }\n  #canvasContainer {\n    text-align: center;\n    margin: 20px auto;\n    max-width: 800px;\n  }\n  canvas {\n    border: 1px solid #ddd;\n    background: white;\n    cursor: crosshair;\n  }\n  #controls {\n    max-width: 800px;\n    margin: 0 auto 20px auto;\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    flex-wrap: wrap;\n  }\n  label {\n    font-weight: bold;\n  }\n  input[type=number] {\n    width: 60px;\n    padding: 5px;\n  }\n  button {\n    padding: 6px 12px;\n    font-size: 1em;\n    cursor: pointer;\n  }\n  #info {\n    max-width: 800px;\n    margin: 10px auto;\n    padding: 10px;\n    background: #eef6ff;\n    border-radius: 5px;\n    min-height: 24px;\n  }\n  #legend {\n    max-width: 800px;\n    margin: 10px auto;\n    font-size: 14px;\n  }\n  .point {\n    display: inline-block;\n    width: 14px;\n    height: 14px;\n    margin-right: 6px;\n    vertical-align: middle;\n    border-radius: 50%;\n  }\n  .classA { background: #E24A4A; }\n  .classB { background: #4A90E2; }\n  .classUnknown { background: #777777; }\n</style>\n</head>\n<body>\n<h1>K-Nearest Neighbors (KNN) Demonstration</h1>\n<div id=\"controls\">\n  <label for=\"kInput\">Choose k:</label>\n  <input type=\"number\" id=\"kInput\" min=\"1\" max=\"15\" value=\"3\" />\n  <button id=\"clearDataBtn\">Clear Data Points</button>\n  <button id=\"clearQueryBtn\">Clear Query Points</button>\n  <button id=\"resetAllBtn\">Reset All</button>\n  <span style=\"flex-grow: 1;\"></span>\n  <label><input type=\"radio\" name=\"classSelect\" value=\"A\" checked /> Class A (red)</label>\n  <label><input type=\"radio\" name=\"classSelect\" value=\"B\" /> Class B (blue)</label>\n</div>\n<div id=\"canvasContainer\">\n  <canvas id=\"knnCanvas\" width=\"700\" height=\"500\" aria-label=\"KNN plot area\"></canvas>\n</div>\n<div id=\"info\">Click on canvas to add data points or query points.<br>\n- Left Click: add point for selected class<br>\n- Shift + Click: add query point (unlabeled)<br>\nQuery points will be classified using KNN with chosen k.</div>\n<div id=\"legend\">\n  <span class=\"point classA\"></span> Class A points &nbsp;&nbsp;\n  <span class=\"point classB\"></span> Class B points &nbsp;&nbsp;\n  <span class=\"point classUnknown\"></span> Query (unlabeled) points<br>\n  When clicking query points, colored circle shows predicted class and its neighbors are highlighted.\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('knnCanvas');\n  const ctx = canvas.getContext('2d');\n\n  let dataPoints = [];  // {x, y, class: 'A' or 'B'}\n  let queryPoints = []; // {x, y, predictedClass, neighbors: [...]}\n\n  // Colors and styles\n  const colors = {\n    A: '#E24A4A', // Red-ish\n    B: '#4A90E2', // Blue-ish\n    queryFill: '#777777',\n    neighborLine: 'rgba(100,100,100,0.5)',\n    neighborFill: 'rgba(255, 165, 0, 0.4)',\n  };\n\n  // Get selected class for data point adding\n  function getSelectedClass() {\n    const radios = document.getElementsByName('classSelect');\n    for (const r of radios) {\n      if (r.checked) return r.value;\n    }\n    return 'A';\n  }\n\n  // Euclidean distance between two points\n  function dist(p1, p2) {\n    return Math.hypot(p1.x - p2.x, p1.y - p2.y);\n  }\n\n  // Find K nearest neighbors of point p among dataPoints\n  function findKNearestNeighbors(p, k) {\n    // Sort dataPoints by distance to p\n    const sorted = dataPoints\n      .map(dp => ({...dp, distance: dist(p, dp)}))\n      .sort((a, b) => a.distance - b.distance);\n    return sorted.slice(0, k);\n  }\n\n  // Classify a query point with KNN\n  function classifyPoint(p, k) {\n    if (!dataPoints.length) return null;\n    const neighbors = findKNearestNeighbors(p, k);\n    // Count votes\n    const votes = {};\n    neighbors.forEach(n => {\n      votes[n.class] = (votes[n.class] || 0) + 1;\n    });\n    // Find class with max votes (break ties by nearest neighbor)\n    let maxVotes = -1;\n    let candidates = [];\n    for (const cls in votes) {\n      if (votes[cls] > maxVotes) {\n        maxVotes = votes[cls];\n        candidates = [cls];\n      } else if (votes[cls] === maxVotes) {\n        candidates.push(cls);\n      }\n    }\n    if (candidates.length === 1) {\n      return {predictedClass: candidates[0], neighbors};\n    } else {\n      // Tie-break: choose closest neighbor's class among candidates\n      for (const n of neighbors) {\n        if (candidates.includes(n.class)) {\n          return {predictedClass: n.class, neighbors};\n        }\n      }\n    }\n    return {predictedClass: candidates[0], neighbors};\n  }\n\n  // Draw all points and query predictions\n  function draw() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw data points\n    for (const p of dataPoints) {\n      drawPoint(p.x, p.y, colors[p.class], 8, 'black');\n    }\n\n    // Draw all query points first with neutral color\n    for (const qp of queryPoints) {\n      if (!qp.predictedClass) {\n        drawPoint(qp.x, qp.y, colors.queryFill, 8, 'black', true);\n      }\n    }\n\n    // Then draw classified query points with predicted class and neighbors lines\n    for (const qp of queryPoints) {\n      if (qp.predictedClass && qp.neighbors) {\n        // Draw lines to neighbors\n        for (const n of qp.neighbors) {\n          ctx.strokeStyle = colors.neighborLine;\n          ctx.lineWidth = 1.5;\n          ctx.beginPath();\n          ctx.moveTo(qp.x, qp.y);\n          ctx.lineTo(n.x, n.y);\n          ctx.stroke();\n          // Draw neighbor highlight circle\n          ctx.fillStyle = colors.neighborFill;\n          ctx.beginPath();\n          ctx.arc(n.x, n.y, 12, 0, Math.PI*2);\n          ctx.fill();\n          // Draw neighbor center point\n          drawPoint(n.x, n.y, colors[n.class], 8, 'black');\n        }\n        // Draw query point with predicted class color\n        drawPoint(qp.x, qp.y, colors[qp.predictedClass], 10, 'black', false, 2);\n      }\n    }\n  }\n\n  // Draw a point with fill and stroke\n  // If hollow=true, just draw circle outline\n  function drawPoint(x, y, fillColor, radius=6, strokeColor='black', hollow=false, strokeWidth=1) {\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI*2);\n    if(hollow) {\n      ctx.strokeStyle = strokeColor;\n      ctx.lineWidth = strokeWidth;\n      ctx.stroke();\n    } else {\n      ctx.fillStyle = fillColor;\n      ctx.fill();\n      ctx.strokeStyle = strokeColor;\n      ctx.lineWidth = strokeWidth;\n      ctx.stroke();\n    }\n  }\n\n  // Update all query points classification\n  function updateQueryClassifications() {\n    const k = parseInt(document.getElementById('kInput').value) || 3;\n    if (!dataPoints.length) {\n      queryPoints.forEach(qp => {\n        qp.predictedClass = null;\n        qp.neighbors = null;\n      });\n      return;\n    }\n    queryPoints.forEach(qp => {\n      const res = classifyPoint(qp, k);\n      if (res) {\n        qp.predictedClass = res.predictedClass;\n        qp.neighbors = res.neighbors;\n      } else {\n        qp.predictedClass = null;\n        qp.neighbors = null;\n      }\n    });\n  }\n\n  // Convert mouse event coords to canvas coords\n  function getMousePos(evt) {\n    const rect = canvas.getBoundingClientRect();\n    return {\n      x: evt.clientX - rect.left,\n      y: evt.clientY - rect.top\n    };\n  }\n\n  // Handle canvas clicks:\n  // - Shift+Click => add query point (unlabeled)\n  // - Click => add data point with selected class\n  canvas.addEventListener('click', evt => {\n    const pos = getMousePos(evt);\n    if (evt.shiftKey) {\n      // Add query point (unlabeled)\n      queryPoints.push({x: pos.x, y: pos.y});\n      updateQueryClassifications();\n      draw();\n      updateInfo(`Added QUERY point at (${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}).`);\n    } else {\n      // Add data point\n      const cls = getSelectedClass();\n      dataPoints.push({x: pos.x, y: pos.y, class: cls});\n      updateQueryClassifications();\n      draw();\n      updateInfo(`Added DATA point for class ${cls} at (${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}).`);\n    }\n  });\n\n  // Update info text\n  const infoBox = document.getElementById('info');\n  function updateInfo(text) {\n    infoBox.innerHTML = text;\n  }\n\n  // Handle k input changes\n  document.getElementById('kInput').addEventListener('input', () => {\n    const k = parseInt(document.getElementById('kInput').value);\n    const maxK = Math.max(1, Math.min(15, dataPoints.length));\n    if (k > maxK) {\n      document.getElementById('kInput').value = maxK;\n    }\n    updateQueryClassifications();\n    draw();\n    updateInfo(`Changed k to ${document.getElementById('kInput').value}.`);\n  });\n\n  // Buttons to clear data or query points\n  document.getElementById('clearDataBtn').addEventListener('click', () => {\n    dataPoints = [];\n    updateQueryClassifications();\n    draw();\n    updateInfo(\"Cleared all data points.\");\n  });\n\n  document.getElementById('clearQueryBtn').addEventListener('click', () => {\n    queryPoints = [];\n    draw();\n    updateInfo(\"Cleared all query points.\");\n  });\n\n  document.getElementById('resetAllBtn').addEventListener('click', () => {\n    dataPoints = [];\n    queryPoints = [];\n    document.getElementById('kInput').value = 3;\n    draw();\n    updateInfo(\"Reset all points and k.\");\n  });\n\n  // Initial draw\n  draw();\n  updateInfo(\"Click on canvas to add data points or query points.<br>- Left Click: add point for selected class<br>- Shift + Click: add query point (unlabeled)<br>Query points will be classified using KNN with chosen k.\");\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Nearest Neighbors (KNN)"
    }
  ],
  "topic": "K-Nearest Neighbors (KNN)",
  "hasFSM": false,
  "hasTest": true
}