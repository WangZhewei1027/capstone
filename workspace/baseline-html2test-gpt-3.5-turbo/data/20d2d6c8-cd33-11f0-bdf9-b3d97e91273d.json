{
  "id": "20d2d6c8-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:11.761Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Topological Sort Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    max-width: 900px;\n  }\n  h1 {\n    text-align: center;\n  }\n  textarea {\n    width: 100%;\n    height: 150px;\n    font-family: monospace;\n  }\n  label {\n    font-weight: bold;\n  }\n  #runBtn {\n    margin-top: 10px;\n    padding: 10px 20px;\n    font-size: 16px;\n  }\n  #output {\n    margin-top: 20px;\n    background: #f5f5f5;\n    padding: 15px;\n    white-space: pre-wrap;\n    border-radius: 5px;\n    min-height: 50px;\n  }\n  #graphViz {\n    margin-top: 30px;\n    border: 1px solid #ddd;\n    height: 350px;\n    position: relative;\n    overflow: auto;\n  }\n  .node {\n    cursor: default;\n    fill: #4a90e2;\n    stroke: #1c3d72;\n    stroke-width: 2px;\n  }\n  .node.done {\n    fill: #7ed56f;\n    stroke: #2e7d32;\n  }\n  text {\n    pointer-events: none;\n    user-select: none;\n    font-weight: bold;\n    fill: white;\n  }\n  svg {\n    width: 100%;\n    height: 100%;\n  }\n  .edge {\n    fill: none;\n    stroke: #999;\n    stroke-width: 2px;\n    marker-end: url(#arrowhead);\n  }\n  .edge.highlight {\n    stroke: #e94e77;\n    stroke-width: 3px;\n  }\n</style>\n</head>\n<body>\n  <h1>Topological Sort Demo</h1>\n  <p>Enter a directed acyclic graph (DAG) as edges (one per line):</p>\n  <p>Format: <code>NodeA NodeB</code> means an edge from NodeA → NodeB</p>\n  <textarea id=\"inputGraph\" placeholder=\"Example:\n5 2\n5 0\n4 0\n4 1\n2 3\n3 1\"></textarea>\n  <br />\n  <button id=\"runBtn\">Run Topological Sort</button>\n  <div id=\"output\" aria-live=\"polite\"></div>\n\n  <div id=\"graphViz\" aria-label=\"Graph visualization\"></div>\n\n<script>\n(() => {\n  // Utility to create SVG elements\n  function svgElem(tag, attrs) {\n    const el = document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n    for (const [k,v] of Object.entries(attrs)) {\n      el.setAttribute(k,v);\n    }\n    return el;\n  }\n\n  // Parse input to build graph adjacency list\n  function parseInput(text) {\n    const edges = [];\n    const lines = text.trim().split('\\n');\n    for (const line of lines) {\n      const parts = line.trim().split(/\\s+/);\n      if(parts.length !== 2) {\n        throw new Error(\"Each line must contain exactly two nodes separated by space.\");\n      }\n      edges.push(parts);\n    }\n    return edges;\n  }\n\n  // Build adjacency list and compute in-degree\n  function buildGraph(edges) {\n    const adj = {};\n    const inDegree = {};\n    const nodes = new Set();\n\n    edges.forEach(([from,to]) => {\n      nodes.add(from);\n      nodes.add(to);\n    });\n\n    nodes.forEach(n => {\n      adj[n] = [];\n      inDegree[n] = 0;\n    });\n\n    edges.forEach(([from,to]) => {\n      adj[from].push(to);\n      inDegree[to]++;\n    });\n\n    return {adj, inDegree, nodes: Array.from(nodes)};\n  }\n\n  // Topological sort using Kahn's algorithm, with step callback\n  async function topologicalSort(adj, inDegree, nodes, stepCallback) {\n    const queue = [];\n    const order = [];\n\n    for (const n of nodes) {\n      if (inDegree[n] === 0) {\n        queue.push(n);\n      }\n    }\n\n    // Use a queue but visually show progress at each step\n    while(queue.length) {\n      const n = queue.shift();\n      order.push(n);\n      await stepCallback(n, order.slice());\n\n      for (const nbr of adj[n]) {\n        inDegree[nbr]--;\n        if (inDegree[nbr] === 0) {\n          queue.push(nbr);\n        }\n      }\n    }\n\n    if (order.length !== nodes.length) {\n      throw new Error(\"Graph contains a cycle - topological sort not possible.\");\n    }\n    return order;\n  }\n\n  // Layout graph nodes in a circle since no obvious layering without topology calculation upfront\n  // We will place nodes evenly spaced in circle for visualization simplicity\n  function layoutNodes(nodes, width, height) {\n    const centerX = width/2;\n    const centerY = height/2;\n    const radius = Math.min(width,height)/2 - 80;\n    const pos = {};\n    const N = nodes.length;\n\n    nodes.forEach((n,i) => {\n      const angle = (2*Math.PI * i)/N - Math.PI/2; // start from top\n      pos[n] = {\n        x: centerX + radius*Math.cos(angle),\n        y: centerY + radius*Math.sin(angle),\n      };\n    });\n    return pos;\n  }\n\n  // Draw graph with SVG\n  function drawGraph(adj, nodes, highlightNodes=[]) {\n    const container = document.getElementById(\"graphViz\");\n    container.innerHTML = \"\";\n    const width = container.clientWidth;\n    const height = container.clientHeight;\n\n    const svg = svgElem(\"svg\", {width: width, height: height});\n    container.appendChild(svg);\n\n    // Define arrowhead\n    const defs = svgElem(\"defs\", {});\n    const marker = svgElem(\"marker\", {\n      id:\"arrowhead\", markerWidth:\"10\", markerHeight:\"7\",\n      refX:\"10\", refY:\"3.5\", orient:\"auto\", markerUnits:\"strokeWidth\",\n    });\n    const path = svgElem(\"path\", {d:\"M0,0 L10,3.5 L0,7 Z\", fill:\"#999\"});\n    marker.appendChild(path);\n    defs.appendChild(marker);\n    svg.appendChild(defs);\n\n    // positions\n    const positions = layoutNodes(nodes, width, height);\n\n    // Draw edges first to be under nodes\n    for (const from of nodes) {\n      for (const to of adj[from]) {\n        const start = positions[from];\n        const end = positions[to];\n\n        // Calculate line start and end with small offset so arrow touches edge of node circle\n        const dx = end.x - start.x;\n        const dy = end.y - start.y;\n        const dist = Math.sqrt(dx*dx + dy*dy);\n        const offset = 20;\n        const x1 = start.x + (dx/dist)*offset;\n        const y1 = start.y + (dy/dist)*offset;\n        const x2 = end.x - (dx/dist)*offset;\n        const y2 = end.y - (dy/dist)*offset;\n\n        const edge = svgElem(\"line\", {\n          x1:x1, y1:y1, x2:x2, y2:y2,\n          class:\"edge\"\n        });\n        svg.appendChild(edge);\n      }\n    }\n\n    // Draw nodes\n    for (const n of nodes) {\n      const {x,y} = positions[n];\n      const g = svgElem(\"g\", {class:\"node-group\"});\n      g.setAttribute(\"data-node\", n);\n      // Circle\n      const circle = svgElem(\"circle\", {\n        cx:x, cy:y, r:20,\n        class: highlightNodes.includes(n) ? \"node done\" : \"node\"\n      });\n      // Text\n      const text = svgElem(\"text\", {\n        x:x, y:y+6, \"text-anchor\": \"middle\",\n        \"font-size\":\"14\"\n      });\n      text.textContent = n;\n      g.appendChild(circle);\n      g.appendChild(text);\n      svg.appendChild(g);\n    }\n  }\n\n  // Animate topological sort step by step\n  async function runTopologicalSort(edges) {\n    const output = document.getElementById(\"output\");\n    output.textContent = \"Parsing graph and building adjacency list...\";\n    let graph;\n    try {\n      graph = buildGraph(edges);\n    } catch(e) {\n      output.textContent = \"Error building graph: \" + e.message;\n      return;\n    }\n\n    drawGraph(graph.adj, graph.nodes);\n    output.textContent = \"Starting topological sort...\\n\";\n\n    const highlighted = new Set();\n\n    try {\n      const order = await topologicalSort(graph.adj, {...graph.inDegree}, graph.nodes, async (node, currentOrder) => {\n        highlighted.add(node);\n        drawGraph(graph.adj, graph.nodes, Array.from(highlighted));\n        output.textContent = `Visited node: ${node}\\nCurrent topological order: ${currentOrder.join(\" → \")}\\n`;\n        await new Promise(r => setTimeout(r, 1000));\n      });\n\n      output.textContent += \"\\nTopological sort completed!\\n\\nFinal order:\\n\" + order.join(\" → \");\n    } catch(e) {\n      output.textContent = \"Error: \" + e.message;\n    }\n\n  }\n\n  document.getElementById(\"runBtn\").addEventListener(\"click\", () => {\n    const input = document.getElementById(\"inputGraph\").value;\n    if (!input.trim()) {\n      alert(\"Please enter graph edges.\");\n      return;\n    }\n    // Parse and run\n    try {\n      const edges = parseInput(input);\n      runTopologicalSort(edges);\n    } catch(e) {\n      document.getElementById(\"output\").textContent = \"Parsing error: \" + e.message;\n    }\n  });\n\n  // Fill example on load\n  const example = \n`5 2\n5 0\n4 0\n4 1\n2 3\n3 1`;\n  document.getElementById(\"inputGraph\").value = example;\n\n  // Run first example automatically\n  window.addEventListener('load', () => {\n    document.getElementById(\"runBtn\").click();\n  });\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": false,
  "hasTest": true
}