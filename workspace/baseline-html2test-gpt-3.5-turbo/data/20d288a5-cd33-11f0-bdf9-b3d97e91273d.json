{
  "id": "20d288a5-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:04.170Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency Matrix",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <title>Adjacency Matrix Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 20px;\n            background: #f0f2f5;\n        }\n        h1 {\n            text-align: center;\n        }\n        #graph-input {\n            margin-bottom: 20px;\n        }\n        label, textarea, input, button {\n            display: block;\n            width: 100%;\n            max-width: 600px;\n            margin: 10px auto;\n            font-size: 1rem;\n        }\n        textarea {\n            height: 120px;\n            font-family: monospace;\n            resize: vertical;\n        }\n        button {\n            padding: 10px;\n            background-color: #007acc;\n            border: none;\n            color: white;\n            cursor: pointer;\n            border-radius: 4px;\n        }\n        button:hover {\n            background-color: #005fa3;\n        }\n        #matrix-container {\n            max-width: 700px;\n            margin: 20px auto;\n            overflow-x: auto;\n            background: white;\n            border-radius: 8px;\n            padding: 20px;\n            box-shadow: 0 0 8px #ccc;\n        }\n        table {\n            border-collapse: collapse;\n            width: 100%;\n            font-size: 0.9rem;\n            text-align: center;\n        }\n        th, td {\n            border: 1px solid #aaa;\n            padding: 6px 8px;\n        }\n        th {\n            background-color: #007acc;\n            color: white;\n            position: sticky;\n            top: 0;\n            z-index: 1;\n        }\n        .node-label {\n            background-color: #dceeff;\n            font-weight: bold;\n            position: sticky;\n            left: 0;\n            z-index: 1;\n        }\n        #error-message {\n            max-width: 600px;\n            margin: 10px auto;\n            color: red;\n            font-weight: bold;\n            height: 1.2em;\n        }\n        #example-graph {\n            max-width: 600px;\n            margin: 10px auto;\n            font-size: 0.9rem;\n        }\n    </style>\n</head>\n<body>\n    <h1>Adjacency Matrix Generator</h1>\n    <div id=\"graph-input\">\n        <label for=\"edge-list\">Enter edges of the graph (one per line):<br>\n            Format: node1 node2 [weight]<br>\n            For unweighted graphs, omit weight.<br>\n            Example:<br>\n            A B<br>\n            B C 2<br>\n            C A 5<br>\n            Use spaces or tabs to separate values.\n        </label>\n        <textarea id=\"edge-list\" placeholder=\"A B\\nB C 2\\nC A 5\"></textarea>\n        <button id=\"generate-btn\">Generate Adjacency Matrix</button>\n        <div id=\"error-message\"></div>\n        <div id=\"example-graph\" style=\"font-style: italic;\"></div>\n    </div>\n    <div id=\"matrix-container\"></div>\n\n    <script>\n        // Function to parse the user input edges text into a graph object\n        // Returns {nodes: Array, adjacency: Map[node][node]=weight}\n        // Supports unweighted (weight=1) or weighted graphs\n        // Nodes can be any string, but trimmed\n        // Edges are considered directed unless the user duplicates edges both ways\n        function parseEdges(input) {\n            const lines = input.trim().split('\\n').filter(l => l.trim());\n            const nodesSet = new Set();\n            const adjacency = new Map();\n\n            for (let i = 0; i < lines.length; i++) {\n                const line = lines[i].trim();\n                if (line === '') continue;\n\n                // Split by whitespace (space/tab)\n                const parts = line.split(/\\s+/);\n                if (parts.length < 2) throw `Line ${i+1}: Must have at least two nodes per edge`;\n                const [from, to, weightStr] = parts;\n\n                if (!from || !to) throw `Line ${i+1}: Invalid edge nodes`;\n\n                nodesSet.add(from);\n                nodesSet.add(to);\n\n                let weight = 1;\n                if (weightStr !== undefined) {\n                    weight = parseFloat(weightStr);\n                    if (isNaN(weight)) {\n                        throw `Line ${i+1}: Invalid weight \"${weightStr}\"`;\n                    }\n                }\n\n                if (!adjacency.has(from)) adjacency.set(from, new Map());\n                adjacency.get(from).set(to, weight);\n            }\n\n            // Sort nodes for consistent order\n            const nodes = Array.from(nodesSet);\n            nodes.sort((a,b) => a.localeCompare(b, undefined, {numeric:true}));\n\n            return { nodes, adjacency };\n        }\n\n        // Create and display an adjacency matrix table for the given graph\n        // adjacency: Map[node][node] = weight\n        // nodes: Array of nodes (ordered)\n        // If unweighted, show 1 where edge exists, otherwise weight\n        // Empty edges show 0\n        function displayAdjacencyMatrix(nodes, adjacency) {\n            const container = document.getElementById('matrix-container');\n            container.innerHTML = '';\n\n            const table = document.createElement('table');\n\n            // Create header row: empty top-left cell + nodes as columns\n            const headerRow = document.createElement('tr');\n            const topLeftCell = document.createElement('th');\n            topLeftCell.textContent = '';\n            headerRow.appendChild(topLeftCell);\n\n            for (const node of nodes) {\n                const th = document.createElement('th');\n                th.textContent = node;\n                headerRow.appendChild(th);\n            }\n            table.appendChild(headerRow);\n\n            // Create rows for each node\n            for (const rowNode of nodes) {\n                const row = document.createElement('tr');\n                const rowHeader = document.createElement('th');\n                rowHeader.textContent = rowNode;\n                rowHeader.classList.add('node-label');\n                row.appendChild(rowHeader);\n\n                for (const colNode of nodes) {\n                    const td = document.createElement('td');\n                    const fromMap = adjacency.get(rowNode);\n                    const val = fromMap && fromMap.has(colNode) ? fromMap.get(colNode) : 0;\n                    td.textContent = val === 0 ? '0' : val;\n                    row.appendChild(td);\n                }\n                table.appendChild(row);\n            }\n\n            container.appendChild(table);\n        }\n\n\n        const inputEl = document.getElementById('edge-list');\n        const generateBtn = document.getElementById('generate-btn');\n        const errorMessageEl = document.getElementById('error-message');\n        const exampleGraphEl = document.getElementById('example-graph');\n\n        // Provide an example on load\n        const exampleInput = `A B\nB C 2\nC A 5\nD C\nA D 4`;\n\n        exampleGraphEl.textContent = `Example Input:\n${exampleInput}`;\n\n        inputEl.value = exampleInput;\n\n        generateBtn.addEventListener('click', () => {\n            errorMessageEl.textContent = '';\n            try {\n                const { nodes, adjacency } = parseEdges(inputEl.value);\n                displayAdjacencyMatrix(nodes, adjacency);\n            } catch (e) {\n                errorMessageEl.textContent = e;\n                document.getElementById('matrix-container').innerHTML = '';\n            }\n        });\n\n        // Auto-generate matrix on page load\n        window.addEventListener('load', () => {\n            generateBtn.click();\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency Matrix"
    }
  ],
  "topic": "Adjacency Matrix",
  "hasFSM": false,
  "hasTest": true
}