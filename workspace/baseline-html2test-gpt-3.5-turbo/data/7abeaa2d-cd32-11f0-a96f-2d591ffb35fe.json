{
  "id": "7abeaa2d-cd32-11f0-a96f-2d591ffb35fe",
  "timestamp": "2025-11-29T14:50:35.845Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Dijkstra's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    overflow: hidden;\n    background: #fafafa;\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n  }\n  h1 {\n    text-align: center;\n    margin: 10px 0 5px 0;\n    color: #222;\n  }\n  #container {\n    display: flex;\n    flex: 1;\n    overflow: hidden;\n  }\n  #canvasContainer {\n    flex: 1;\n    position: relative;\n    background: #fff;\n    border-right: 1px solid #ccc;\n  }\n  canvas {\n    display: block;\n    background: #fff;\n    cursor: pointer;\n    user-select: none;\n  }\n  #controls {\n    width: 350px;\n    background: #f9f9f9;\n    border-left: 1px solid #ccc;\n    padding: 15px;\n    box-sizing: border-box;\n    overflow-y: auto;\n  }\n  label {\n    display: block;\n    margin-bottom: 5px;\n    font-weight: bold;\n  }\n  select, button, input {\n    width: 100%;\n    padding: 7px 8px;\n    margin-bottom: 12px;\n    box-sizing: border-box;\n    font-size: 14px;\n  }\n  button {\n    cursor: pointer;\n    background-color: #2d89ef;\n    border: none;\n    color: white;\n    font-weight: bold;\n    border-radius: 3px;\n  }\n  button:disabled {\n    background-color: #aaa;\n    cursor: default;\n  }\n  #log {\n    height: 180px;\n    background: #222;\n    color: #eee;\n    font-family: monospace;\n    font-size: 13px;\n    overflow-y: auto;\n    padding: 6px;\n    border-radius: 3px;\n  }\n  #instructions {\n    margin-bottom: 15px;\n    color: #444;\n    font-size: 14px;\n  }\n  .node {\n    cursor: pointer;\n  }\n</style>\n</head>\n<body>\n<h1>Dijkstra's Algorithm Visualization</h1>\n<div id=\"container\">\n  <div id=\"canvasContainer\">\n    <canvas id=\"graphCanvas\" width=\"700\" height=\"600\"></canvas>\n  </div>\n  <div id=\"controls\">\n    <div id=\"instructions\">\n      <p><b>Instructions:</b></p>\n      <ul>\n        <li>Click on the canvas to create nodes.</li>\n        <li>Click and drag from one node to another to add a directed edge (weight prompted).</li>\n        <li>Select start and end nodes below.</li>\n        <li>Click <b>Run Dijkstra</b> to find shortest path.</li>\n        <li>Clear or reset as needed.</li>\n      </ul>\n    </div>\n    <label for=\"startNode\">Start Node:</label>\n    <select id=\"startNode\" disabled></select>\n\n    <label for=\"endNode\">End Node:</label>\n    <select id=\"endNode\" disabled></select>\n\n    <button id=\"runBtn\" disabled>Run Dijkstra</button>\n    <button id=\"stepBtn\" disabled>Step</button>\n    <button id=\"resetBtn\" disabled>Reset</button>\n    <button id=\"clearBtn\">Clear Graph</button>\n\n    <label>Log/Steps:</label>\n    <div id=\"log\"></div>\n  </div>\n</div>\n\n<script>\n(() => {\n  // Data Structures\n  class Node {\n    constructor(id, x, y) {\n      this.id = id;\n      this.x = x;\n      this.y = y;\n      this.radius = 20;\n      this.adj = []; // array of { to: Node, weight: number }\n    }\n  }\n\n  class Edge {\n    constructor(from, to, weight) {\n      this.from = from;\n      this.to = to;\n      this.weight = weight;\n    }\n  }\n\n  // Priority Queue (min-heap) for Dijkstra\n  class MinHeap {\n    constructor() {\n      this.heap = [];\n    }\n    push(item) {\n      this.heap.push(item);\n      this._bubbleUp();\n    }\n    pop() {\n      if(this.heap.length === 0) return null;\n      const top = this.heap[0];\n      let end = this.heap.pop();\n      if(this.heap.length){\n        this.heap[0] = end;\n        this._sinkDown();\n      }\n      return top;\n    }\n    _bubbleUp(){\n      let idx = this.heap.length-1;\n      const element = this.heap[idx];\n      while(idx > 0){\n        let parentIdx = Math.floor((idx-1)/2);\n        let parent = this.heap[parentIdx];\n        if(element.priority >= parent.priority) break;\n        this.heap[parentIdx] = element;\n        this.heap[idx] = parent;\n        idx = parentIdx;\n      }\n    }\n    _sinkDown(){\n      let idx = 0;\n      const length = this.heap.length;\n      const element = this.heap[0];\n      while(true){\n        let leftChildIdx = 2*idx+1;\n        let rightChildIdx = 2*idx+2;\n        let swap = null;\n        let leftChild, rightChild;\n        if(leftChildIdx < length){\n          leftChild = this.heap[leftChildIdx];\n          if(leftChild.priority < element.priority){\n            swap = leftChildIdx;\n          }\n        }\n        if(rightChildIdx < length){\n          rightChild = this.heap[rightChildIdx];\n          if((swap === null && rightChild.priority < element.priority) || (swap !== null && rightChild.priority < leftChild.priority)){\n            swap = rightChildIdx;\n          }\n        }\n        if(swap === null) break;\n        this.heap[idx] = this.heap[swap];\n        this.heap[swap] = element;\n        idx = swap;\n      }\n    }\n    size(){\n      return this.heap.length;\n    }\n  }\n\n  // DOM Elements\n  const canvas = document.getElementById(\"graphCanvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const startNodeSelect = document.getElementById(\"startNode\");\n  const endNodeSelect = document.getElementById(\"endNode\");\n  const runBtn = document.getElementById(\"runBtn\");\n  const stepBtn = document.getElementById(\"stepBtn\");\n  const resetBtn = document.getElementById(\"resetBtn\");\n  const clearBtn = document.getElementById(\"clearBtn\");\n  const logDiv = document.getElementById(\"log\");\n\n  // Variables\n  let nodes = [];\n  let edges = [];\n  let nodeIdCounter = 0;\n  let draggingEdge = null; // { fromNode, fromX, fromY }\n  let hoverNode = null;\n  let draggingNode = null;\n  let dragOffset = {x:0, y:0};\n\n  // Dijkstra Variables\n  let dijkstraState = null;\n\n  // Helper Functions\n  function distance(x1,y1,x2,y2){\n    return Math.sqrt((x1-x2)**2 + (y1-y2)**2);\n  }\n  function clearLog(){\n    logDiv.textContent = \"\";\n  }\n  function appendLog(line){\n    logDiv.textContent += line + \"\\n\";\n    logDiv.scrollTop = logDiv.scrollHeight;\n  }\n  function resetDijkstraState(){\n    dijkstraState = null;\n    stepBtn.disabled = true;\n    resetBtn.disabled = true;\n    runBtn.disabled = nodes.length < 2;\n  }\n  function enableControls(){\n    const hasNodes = nodes.length > 0;\n    startNodeSelect.disabled = !hasNodes;\n    endNodeSelect.disabled = !hasNodes;\n    runBtn.disabled = !hasNodes || !startNodeSelect.value || !endNodeSelect.value || startNodeSelect.value === endNodeSelect.value;\n  }\n  function updateNodeSelects(){\n    const oldStart = startNodeSelect.value;\n    const oldEnd = endNodeSelect.value;\n    [startNodeSelect,endNodeSelect].forEach(sel => {\n      while(sel.options.length > 0) sel.remove(0);\n    });\n    nodes.forEach(n => {\n      let opt1 = document.createElement(\"option\");\n      opt1.value = n.id;\n      opt1.textContent = `Node ${n.id}`;\n      startNodeSelect.appendChild(opt1);\n      let opt2 = document.createElement(\"option\");\n      opt2.value = n.id;\n      opt2.textContent = `Node ${n.id}`;\n      endNodeSelect.appendChild(opt2);\n    });\n    startNodeSelect.value = oldStart && [...startNodeSelect.options].some(o=>o.value===oldStart) ? oldStart : \"\";\n    endNodeSelect.value = oldEnd && [...endNodeSelect.options].some(o=>o.value===oldEnd) ? oldEnd : \"\";\n  }\n\n  // Drawing functions\n  function drawArrow(fromX, fromY, toX, toY, color=\"#888\", width=2, label=null, highlight=false){\n    const headlen = 10;\n    const angle = Math.atan2(toY - fromY, toX - fromX);\n    ctx.strokeStyle = highlight ? \"#d43f3a\" : color;\n    ctx.fillStyle = highlight ? \"#d43f3a\" : color;\n    ctx.lineWidth = width;\n\n    ctx.beginPath();\n    // shorten line to not overlap node circle\n    const shortenFromX = fromX + 20 * Math.cos(angle);\n    const shortenFromY = fromY + 20 * Math.sin(angle);\n    const shortenToX = toX - 20 * Math.cos(angle);\n    const shortenToY = toY - 20 * Math.sin(angle);\n    ctx.moveTo(shortenFromX, shortenFromY);\n    ctx.lineTo(shortenToX, shortenToY);\n    ctx.stroke();\n\n    // draw arrowhead\n    ctx.beginPath();\n    ctx.moveTo(shortenToX, shortenToY);\n    ctx.lineTo(shortenToX - headlen * Math.cos(angle - Math.PI / 6), shortenToY - headlen * Math.sin(angle - Math.PI / 6));\n    ctx.lineTo(shortenToX - headlen * Math.cos(angle + Math.PI / 6), shortenToY - headlen * Math.sin(angle + Math.PI / 6));\n    ctx.closePath();\n    ctx.fill();\n\n    // draw label near middle of edge\n    if(label !== null){\n      const midX = (shortenFromX + shortenToX) / 2;\n      const midY = (shortenFromY + shortenToY) / 2;\n      ctx.fillStyle = \"#225\";\n      ctx.font = \"bold 14px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"bottom\";\n      ctx.fillText(label, midX, midY);\n    }\n  }\n\n  function drawNode(node, highlight=false, distance=null, predecessor=null, isCurrent=false){\n    ctx.beginPath();\n    ctx.fillStyle = highlight ? \"#f49494\" : (isCurrent ? \"#f29f05\" : \"#4a90e2\");\n    ctx.strokeStyle = \"#333\";\n    ctx.lineWidth = isCurrent ? 4 : 2;\n    ctx.shadowColor = highlight||isCurrent ? \"rgba(255,0,0,0.3)\" : \"transparent\";\n    ctx.shadowBlur = highlight||isCurrent ? 8 : 0;\n    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.shadowBlur = 0;\n    ctx.stroke();\n\n    ctx.fillStyle = \"#fff\";\n    ctx.font = \"bold 16px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(node.id, node.x, node.y);\n\n    if(distance !== null){\n      ctx.fillStyle = highlight ? \"#730000\" : \"#222\";\n      ctx.font = \"bold 12px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"top\";\n      const distStr = distance === Infinity ? \"∞\" : distance;\n      ctx.fillText(\"Dist: \" + distStr, node.x, node.y + node.radius + 4);\n    }\n    if(predecessor !== null){\n      ctx.fillStyle = \"#555\";\n      ctx.font = \"10px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"top\";\n      ctx.fillText(\"Prev: \" + predecessor, node.x, node.y + node.radius + 18);\n    }\n  }\n\n  function render(){\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    // Draw edges\n    edges.forEach(e=>{\n      const highlight = dijkstraState && dijkstraState.pathEdges.has(e);\n      drawArrow(e.from.x,e.from.y,e.to.x,e.to.y,'#888',2, e.weight, highlight);\n    });\n\n    // Draw dragging edge\n    if(draggingEdge){\n      ctx.strokeStyle = \"#aaa\";\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(draggingEdge.fromNode.x, draggingEdge.fromNode.y);\n      ctx.lineTo(draggingEdge.currentX, draggingEdge.currentY);\n      ctx.stroke();\n      drawArrow(draggingEdge.fromNode.x, draggingEdge.fromNode.y,\n                draggingEdge.currentX, draggingEdge.currentY,\n                \"#aaa\", 2);\n    }\n\n    // Draw nodes\n    nodes.forEach(node=>{\n      let isCurrent = false, highlight=false;\n      let dist = null;\n      let pred = null;\n      if(dijkstraState){\n        dist = dijkstraState.dist.get(node) || Infinity;\n        pred = dijkstraState.prev.has(node) ? dijkstraState.prev.get(node)?.id : null;\n        if(dijkstraState.currentNode === node) isCurrent = true;\n        if(dijkstraState.visited.has(node)) highlight = true;\n      }\n      drawNode(node, highlight, dist, pred, isCurrent);\n    });\n  }\n\n  // Node hit detection\n  function getNodeAt(x,y){\n    for(let i=nodes.length-1; i >= 0; i--){\n      const n = nodes[i];\n      if(distance(x,y,n.x,n.y) <= n.radius + 4){\n        return n;\n      }\n    }\n    return null;\n  }\n\n  // Event Handlers\n  canvas.addEventListener(\"mousedown\", e=>{\n    const rect = canvas.getBoundingClientRect();\n    const cx = e.clientX - rect.left;\n    const cy = e.clientY - rect.top;\n\n    if(dijkstraState){\n      // Don't allow editing during algorithm run\n      return;\n    }\n\n    const clickedNode = getNodeAt(cx,cy);\n    if(clickedNode){\n      draggingNode = clickedNode;\n      dragOffset.x = cx - clickedNode.x;\n      dragOffset.y = cy - clickedNode.y;\n    } else {\n      // Add new node\n      nodeIdCounter++;\n      const newNode = new Node(nodeIdCounter, cx, cy);\n      nodes.push(newNode);\n      updateNodeSelects();\n      enableControls();\n      resetDijkstraState();\n      clearLog();\n      appendLog(`Added Node ${newNode.id} at (${Math.round(cx)},${Math.round(cy)})`);\n    }\n    render();\n  });\n  canvas.addEventListener(\"mousemove\", e=>{\n    const rect = canvas.getBoundingClientRect();\n    const cx = e.clientX - rect.left;\n    const cy = e.clientY - rect.top;\n\n    if(draggingEdge){\n      draggingEdge.currentX = cx;\n      draggingEdge.currentY = cy;\n      render();\n      return;\n    }\n    if(draggingNode){\n      draggingNode.x = cx - dragOffset.x;\n      draggingNode.y = cy - dragOffset.y;\n      render();\n      return;\n    }\n  });\n  canvas.addEventListener(\"mouseup\", e=>{\n    const rect = canvas.getBoundingClientRect();\n    const cx = e.clientX - rect.left;\n    const cy = e.clientY - rect.top;\n\n    if(draggingNode){\n      draggingNode = null;\n      render();\n      return;\n    }\n    if(draggingEdge){\n      const fromNode = draggingEdge.fromNode;\n      const toNode = getNodeAt(cx, cy);\n      if(toNode && toNode !== fromNode){\n        // Create edge from fromNode to toNode\n        let existingEdge = edges.find(e=>e.from===fromNode && e.to===toNode);\n        if(existingEdge){\n          alert(\"Edge already exists!\");\n        } else {\n          let weightStr = prompt(`Enter weight for edge from Node ${fromNode.id} to Node ${toNode.id}:`, \"1\");\n          if(weightStr !== null){\n            let weight = Number(weightStr);\n            if(isNaN(weight) || weight <= 0){\n              alert(\"Invalid weight! Must be a positive number.\");\n            } else {\n              fromNode.adj.push({to: toNode, weight});\n              edges.push(new Edge(fromNode, toNode, weight));\n              appendLog(`Added edge: ${fromNode.id} → ${toNode.id} (weight ${weight})`);\n              resetDijkstraState();\n            }\n          }\n        }\n      }\n      draggingEdge = null;\n      render();\n      return;\n    }\n  });\n\n  canvas.addEventListener(\"dblclick\", e=>{\n    // Optional: Remove node or edge on dblclick? For simplicity, no.\n  });\n\n  canvas.addEventListener(\"contextmenu\", e=>{\n    e.preventDefault();\n    const rect = canvas.getBoundingClientRect();\n    const cx = e.clientX - rect.left;\n    const cy = e.clientY - rect.top;\n\n    if(dijkstraState){\n      // Don't allow editing\n      return;\n    }\n\n    const node = getNodeAt(cx, cy);\n    if(node){\n      // Remove node and its edges\n      if(confirm(`Delete Node ${node.id} and all connecting edges?`)){\n        // Remove edges connected to node\n        edges = edges.filter(e=>e.from !== node && e.to !== node);\n        nodes = nodes.filter(n=>n !== node);\n        // Remove adj entries\n        nodes.forEach(n=>{\n          n.adj = n.adj.filter(a=>a.to !== node);\n        });\n        appendLog(`Deleted Node ${node.id} and connected edges.`);\n        updateNodeSelects();\n        enableControls();\n        resetDijkstraState();\n        render();\n      }\n    }\n  });\n\n  // Implement drag to create edges: drag from node with right-click or shift/alt key or ctrl ? For simplicity, add edge on mousedown+drag from a node\n  // We'll use mousedown on node + shift key to start drag edge creation\n  canvas.addEventListener(\"mousedown\", e=>{\n    if(e.shiftKey){\n      const rect = canvas.getBoundingClientRect();\n      const cx = e.clientX - rect.left;\n      const cy = e.clientY - rect.top;\n      const n = getNodeAt(cx, cy);\n      if(n && !dijkstraState){\n        draggingEdge = {fromNode: n, currentX: cx, currentY: cy};\n        render();\n      }\n    }\n  });\n\n  // Buttons\n  runBtn.addEventListener(\"click\", ()=>{\n    if(dijkstraState) return; // already running\n\n    const startId = Number(startNodeSelect.value);\n    const endId = Number(endNodeSelect.value);\n    if(!startId || !endId || startId === endId) return;\n\n    const startNode = nodes.find(n=>n.id === startId);\n    const endNode = nodes.find(n=>n.id === endId);\n\n    if(!startNode || !endNode) return;\n\n    // Initialize Dijkstra state\n    dijkstraState = {\n      dist: new Map(),\n      prev: new Map(),\n      visited: new Set(),\n      queue: new MinHeap(),\n      currentNode: null,\n      endNode: endNode,\n      pathEdges: new Set(),\n      finished: false,\n    };\n\n    // init distances\n    nodes.forEach(n=>{\n      dijkstraState.dist.set(n, Infinity);\n      dijkstraState.prev.set(n, null);\n    });\n    dijkstraState.dist.set(startNode, 0);\n    dijkstraState.queue.push({node: startNode, priority: 0});\n\n    appendLog(`Starting Dijkstra's Algorithm from Node ${startNode.id} to Node ${endNode.id}...`);\n    stepBtn.disabled = false;\n    resetBtn.disabled = false;\n    runBtn.disabled = true;\n    startNodeSelect.disabled = true;\n    endNodeSelect.disabled = true;\n    clearBtn.disabled = true;\n    render();\n  });\n\n  stepBtn.addEventListener(\"click\", ()=>{\n    if(!dijkstraState || dijkstraState.finished) return;\n\n    // Dijkstra step\n    let q = dijkstraState.queue;\n    if(q.size() === 0){\n      appendLog(\"No path found to destination.\");\n      dijkstraState.finished = true;\n      stepBtn.disabled = true;\n      resetBtn.disabled = false;\n      render();\n      return;\n    }\n    let current = q.pop().node;\n    if(dijkstraState.visited.has(current)){\n      // Already processed, skip\n      dijkstraState.currentNode = null;\n      render();\n      return;\n    }\n    dijkstraState.currentNode = current;\n    dijkstraState.visited.add(current);\n    appendLog(`Processing Node ${current.id} (dist: ${dijkstraState.dist.get(current)})`);\n\n    if(current === dijkstraState.endNode){\n      // Finish and reconstruct path edges\n      appendLog(`Reached destination Node ${current.id}.`);\n      dijkstraState.finished = true;\n      stepBtn.disabled = true;\n      // Highlight path edges\n      dijkstraState.pathEdges.clear();\n      let cur = current;\n      while(dijkstraState.prev.get(cur)){\n        let p = dijkstraState.prev.get(cur);\n        let edge = edges.find(e=>e.from === p && e.to === cur);\n        if(edge) dijkstraState.pathEdges.add(edge);\n        cur = p;\n      }\n      render();\n      return;\n    }\n\n    // Relax edges\n    current.adj.forEach(adjEdge=>{\n      if(dijkstraState.visited.has(adjEdge.to)) return;\n      const altDist = dijkstraState.dist.get(current) + adjEdge.weight;\n      if(altDist < dijkstraState.dist.get(adjEdge.to)){\n        dijkstraState.dist.set(adjEdge.to, altDist);\n        dijkstraState.prev.set(adjEdge.to, current);\n        q.push({node: adjEdge.to, priority: altDist});\n        appendLog(`Updated dist of Node ${adjEdge.to.id} to ${altDist} via Node ${current.id}.`);\n      }\n    });\n    render();\n  });\n\n  resetBtn.addEventListener(\"click\", ()=>{\n    if(!dijkstraState) return;\n    dijkstraState = null;\n    appendLog(\"Reset algorithm. You can run it again.\");\n    stepBtn.disabled = true;\n    resetBtn.disabled = true;\n    runBtn.disabled = false;\n    startNodeSelect.disabled = false;\n    endNodeSelect.disabled = false;\n    clearBtn.disabled = false;\n    render();\n  });\n\n  clearBtn.addEventListener(\"click\", ()=>{\n    if(dijkstraState){\n      alert(\"Reset algorithm before clearing graph.\");\n      return;\n    }\n    if(!confirm(\"Clear entire graph? This cannot be undone.\")) return;\n    nodes = [];\n    edges = [];\n    nodeIdCounter = 0;\n    updateNodeSelects();\n    enableControls();\n    clearLog();\n    render();\n  });\n\n  // Initial render\n  updateNodeSelects();\n  enableControls();\n  render();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}