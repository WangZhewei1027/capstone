{
  "id": "e03a2056-cd32-11f0-a949-f901cf5609c9",
  "timestamp": "2025-11-29T14:52:09.494Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Priority Queue",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Priority Queue Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 2rem;\n    max-width: 600px;\n  }\n  h1 {\n    text-align: center;\n  }\n  label {\n    display: block;\n    margin-top: 1rem;\n  }\n  input[type=\"text\"], input[type=\"number\"] {\n    width: 100%;\n    padding: 0.4rem;\n    margin-top: 0.3rem;\n    box-sizing: border-box;\n  }\n  button {\n    margin-top: 1rem;\n    padding: 0.5rem 1rem;\n  }\n  #queue {\n    margin-top: 2rem;\n    border: 1px solid #bbb;\n    border-radius: 4px;\n    min-height: 60px;\n    padding: 0.5rem;\n    background: #f9f9f9;\n  }\n  #log {\n    margin-top: 1rem;\n    background: #eef;\n    padding: 0.5rem;\n    height: 100px;\n    overflow-y: auto;\n    font-family: monospace;\n    border-radius: 4px;\n    border: 1px solid #ccd;\n  }\n</style>\n</head>\n<body>\n<h1>Priority Queue Demo</h1>\n<form id=\"pqForm\">\n  <label>\n    Element (string):\n    <input type=\"text\" id=\"element\" required />\n  </label>\n  <label>\n    Priority (number, lower = higher priority):\n    <input type=\"number\" id=\"priority\" required />\n  </label>\n  <button type=\"submit\">Enqueue</button>\n  <button type=\"button\" id=\"dequeueBtn\">Dequeue</button>\n  <button type=\"button\" id=\"peekBtn\">Peek</button>\n  <button type=\"button\" id=\"clearBtn\">Clear Queue</button>\n</form>\n\n<h2>Queue State (front → back):</h2>\n<div id=\"queue\">(empty)</div>\n\n<h2>Operations Log:</h2>\n<div id=\"log\"></div>\n\n<script>\n// Priority Queue implemented as a min-heap for efficient priority management\nclass PriorityQueue {\n  constructor() {\n    this.heap = [];\n  }\n\n  // Helper methods for heap index calculations\n  _parent(idx) { return Math.floor((idx - 1) / 2); }\n  _leftChild(idx) { return idx * 2 + 1; }\n  _rightChild(idx) { return idx * 2 + 2; }\n\n  _swap(i, j) {\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\n  }\n\n  // Insert element with priority\n  enqueue(element, priority) {\n    const node = { element, priority };\n    this.heap.push(node);\n    this._bubbleUp(this.heap.length - 1);\n  }\n\n  // Remove and return the element with the highest priority (lowest priority number)\n  dequeue() {\n    if (this.isEmpty()) return null;\n    const top = this.heap[0];\n    const last = this.heap.pop();\n    if (!this.isEmpty()) {\n      this.heap[0] = last;\n      this._bubbleDown(0);\n    }\n    return top;\n  }\n\n  peek() {\n    return this.isEmpty() ? null : this.heap[0];\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  size() {\n    return this.heap.length;\n  }\n\n  clear() {\n    this.heap = [];\n  }\n\n  _bubbleUp(idx) {\n    while (idx > 0) {\n      const parentIdx = this._parent(idx);\n      if (this.heap[parentIdx].priority <= this.heap[idx].priority) break;\n      this._swap(parentIdx, idx);\n      idx = parentIdx;\n    }\n  }\n\n  _bubbleDown(idx) {\n    const length = this.heap.length;\n    while (true) {\n      let leftIdx = this._leftChild(idx);\n      let rightIdx = this._rightChild(idx);\n      let smallest = idx;\n\n      if (leftIdx < length &&\n          this.heap[leftIdx].priority < this.heap[smallest].priority) {\n        smallest = leftIdx;\n      }\n\n      if (rightIdx < length &&\n          this.heap[rightIdx].priority < this.heap[smallest].priority) {\n        smallest = rightIdx;\n      }\n\n      if (smallest === idx) break;\n\n      this._swap(idx, smallest);\n      idx = smallest;\n    }\n  }\n\n  toArray() {\n    // Return array copy sorted by priority for display purposes (does not alter original heap)\n    return [...this.heap].sort((a,b)=>a.priority - b.priority);\n  }\n}\n\n/////// UI Logic ///////\n\nconst pq = new PriorityQueue();\nconst form = document.getElementById('pqForm');\nconst elementInput = document.getElementById('element');\nconst priorityInput = document.getElementById('priority');\nconst queueDiv = document.getElementById('queue');\nconst logDiv = document.getElementById('log');\nconst dequeueBtn = document.getElementById('dequeueBtn');\nconst peekBtn = document.getElementById('peekBtn');\nconst clearBtn = document.getElementById('clearBtn');\n\nfunction log(msg) {\n  const time = new Date().toLocaleTimeString();\n  logDiv.textContent += `[${time}] ${msg}\\n`;\n  logDiv.scrollTop = logDiv.scrollHeight;\n}\n\nfunction updateQueueDisplay() {\n  if (pq.isEmpty()) {\n    queueDiv.textContent = '(empty)';\n  } else {\n    // Display from front (highest priority) to back (lowest priority)\n    // We use toArray() which is sorted by priority\n    const arr = pq.toArray();\n    const display = arr.map(({element, priority}) =>\n      `\"${element}\" (priority: ${priority})`\n    ).join(' → ');\n    queueDiv.textContent = display;\n  }\n}\n\nform.addEventListener('submit', e => {\n  e.preventDefault();\n  const element = elementInput.value.trim();\n  const priorityStr = priorityInput.value.trim();\n\n  if (element === '') {\n    alert('Element must not be empty.');\n    return;\n  }\n  const priority = Number(priorityStr);\n  if (isNaN(priority)) {\n    alert('Priority must be a valid number.');\n    return;\n  }\n\n  pq.enqueue(element, priority);\n  log(`Enqueued element \"${element}\" with priority ${priority}.`);\n  updateQueueDisplay();\n\n  // Clear inputs for convenience\n  elementInput.value = '';\n  priorityInput.value = '';\n  elementInput.focus();\n});\n\ndequeueBtn.addEventListener('click', () => {\n  if (pq.isEmpty()) {\n    log('Dequeue attempted but queue is empty.');\n    alert('Queue is empty.');\n    return;\n  }\n  const node = pq.dequeue();\n  log(`Dequeued element \"${node.element}\" with priority ${node.priority}.`);\n  updateQueueDisplay();\n});\n\npeekBtn.addEventListener('click', () => {\n  if (pq.isEmpty()) {\n    log('Peek attempted but queue is empty.');\n    alert('Queue is empty.');\n    return;\n  }\n  const node = pq.peek();\n  log(`Peeked at element \"${node.element}\" with priority ${node.priority}.`);\n  alert(`Front element: \"${node.element}\" with priority ${node.priority}`);\n});\n\nclearBtn.addEventListener('click', () => {\n  pq.clear();\n  log('Cleared the queue.');\n  updateQueueDisplay();\n});\n\nupdateQueueDisplay();\nlog('Priority Queue initialized.');\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Priority Queue"
    }
  ],
  "topic": "Priority Queue",
  "hasFSM": false,
  "hasTest": true
}