{
  "id": "20d288a4-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:20.390Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Weighted Graph Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    overflow: hidden;\n    background: #f0f0f0;\n  }\n  #graph-container {\n    width: 100vw;\n    height: 100vh;\n  }\n  .node circle {\n    fill: #2196f3;\n    stroke: #0d47a1;\n    stroke-width: 2px;\n    cursor: pointer;\n    transition: fill 0.3s ease;\n  }\n  .node text {\n    fill: #fff;\n    font-weight: bold;\n    pointer-events: none;\n    user-select: none;\n  }\n  .edge path {\n    stroke: #666;\n    stroke-width: 2px;\n    fill: none;\n  }\n  .edge text {\n    fill: #000;\n    font-size: 14px;\n    user-select: none;\n    pointer-events: none;\n    background: #fff;\n  }\n  #info {\n    position: absolute;\n    top: 10px;\n    left: 10px;\n    background: rgba(255 255 255 / 0.9);\n    border: 1px solid #ccc;\n    border-radius: 6px;\n    padding: 10px 15px;\n    max-width: 320px;\n    font-size: 14px;\n    box-shadow: 2px 3px 10px rgba(0,0,0,0.1);\n  }\n  #info h2 {\n    margin-top: 0;\n  }\n  #info button {\n    margin-top: 8px;\n    background: #2196f3;\n    border: none;\n    color: #fff;\n    padding: 5px 12px;\n    border-radius: 4px;\n    cursor: pointer;\n    font-weight: bold;\n  }\n  #info button:hover {\n    background: #1769aa;\n  }\n</style>\n</head>\n<body>\n<div id=\"graph-container\"></div>\n<div id=\"info\">\n  <h2>Weighted Graph Demo</h2>\n  <p>This is a demonstration of a weighted undirected graph. Nodes are draggable. Edges have weights displayed on them.</p>\n  <p><b>Drag nodes</b> to rearrange the graph.</p>\n  <p><b>Click an edge</b> to highlight its weight.</p>\n  <button id=\"resetBtn\">Reset Layout</button>\n</div>\n\n<script>\n// Weighted Graph Data: Undirected with weights\nconst graphData = {\n  nodes: [\n    { id: \"A\" },\n    { id: \"B\" },\n    { id: \"C\" },\n    { id: \"D\" },\n    { id: \"E\" },\n    { id: \"F\" }\n  ],\n  edges: [\n    { source: \"A\", target: \"B\", weight: 4 },\n    { source: \"A\", target: \"C\", weight: 2 },\n    { source: \"B\", target: \"C\", weight: 5 },\n    { source: \"B\", target: \"D\", weight: 10 },\n    { source: \"C\", target: \"E\", weight: 3 },\n    { source: \"E\", target: \"D\", weight: 4 },\n    { source: \"D\", target: \"F\", weight: 11 }\n  ]\n};\n\nconst width = window.innerWidth;\nconst height = window.innerHeight;\n\n// Create SVG container\nconst svgNS = \"http://www.w3.org/2000/svg\";\nconst svg = document.createElementNS(svgNS, \"svg\");\nsvg.setAttribute(\"width\", width);\nsvg.setAttribute(\"height\", height);\nsvg.style.background = \"#ffffff\";\ndocument.getElementById('graph-container').appendChild(svg);\n\n// Create SVG elements groups\nconst edgesGroup = document.createElementNS(svgNS, \"g\");\nconst nodesGroup = document.createElementNS(svgNS, \"g\");\nsvg.appendChild(edgesGroup);\nsvg.appendChild(nodesGroup);\n\n// Helper function: create SVG element\nfunction createSVGElement(type, attrs = {}) {\n  const elem = document.createElementNS(svgNS, type);\n  for (const attr in attrs) {\n    elem.setAttribute(attr, attrs[attr]);\n  }\n  return elem;\n}\n\n// Store node objects with positions\nconst nodes = graphData.nodes.map((n, i) => {\n  // Random initial positions around center\n  return {\n    id: n.id,\n    x: width/2 + 150*Math.cos((2*Math.PI*i)/graphData.nodes.length),\n    y: height/2 + 150*Math.sin((2*Math.PI*i)/graphData.nodes.length),\n    elem: null,\n    textElem: null,\n    edges: []\n  };\n});\n\n// Map for quick lookup\nconst nodeById = {};\nnodes.forEach(n => nodeById[n.id] = n);\n\n// Create edges\nconst edges = graphData.edges.map(e => {\n  const sourceNode = nodeById[e.source];\n  const targetNode = nodeById[e.target];\n  const edge = {\n    source: sourceNode,\n    target: targetNode,\n    weight: e.weight,\n    pathElem: null,\n    weightTextElem: null\n  };\n  sourceNode.edges.push(edge);\n  targetNode.edges.push(edge);\n  return edge;\n});\n\n// Draw edges\nedges.forEach(edge => {\n  // Path line for edge - we draw straight lines\n  const path = createSVGElement(\"path\", {\n    stroke: \"#666\",\n    \"stroke-width\": 2,\n    fill: \"none\",\n    cursor: \"pointer\"\n  });\n  edgesGroup.appendChild(path);\n\n  // Weight text - positioned midpoint of the line plus offset\n  const weightText = createSVGElement(\"text\", {\n    fill: \"#000\",\n    \"font-size\": 14,\n    \"text-anchor\": \"middle\",\n    \"alignment-baseline\": \"middle\",\n    \"pointer-events\": \"none\",\n    style: \"user-select:none; font-family: sans-serif;\"\n  });\n  weightText.textContent = edge.weight;\n  edgesGroup.appendChild(weightText);\n\n  edge.pathElem = path;\n  edge.weightTextElem = weightText;\n\n  // Add click to highlight weight text & edge line\n  path.addEventListener(\"click\", () => {\n    clearEdgeHighlights();\n    path.setAttribute(\"stroke\", \"#e91e63\");\n    path.setAttribute(\"stroke-width\", 4);\n    weightText.setAttribute(\"fill\", \"#e91e63\");\n  });\n});\n\nfunction clearEdgeHighlights() {\n  edges.forEach(e => {\n    e.pathElem.setAttribute(\"stroke\", \"#666\");\n    e.pathElem.setAttribute(\"stroke-width\", 2);\n    e.weightTextElem.setAttribute(\"fill\", \"#000\");\n  });\n}\n\n// Draw nodes\nnodes.forEach(node => {\n  const g = createSVGElement(\"g\", { class: \"node\", cursor: \"move\" });\n\n  const circle = createSVGElement(\"circle\", {\n    r: 20,\n    fill: \"#2196f3\",\n    stroke: \"#0d47a1\",\n    \"stroke-width\": 2,\n    cx: 0,\n    cy: 0,\n    cursor: \"pointer\"\n  });\n\n  const text = createSVGElement(\"text\", {\n    \"text-anchor\": \"middle\",\n    \"alignment-baseline\": \"middle\",\n    fill: \"#fff\",\n    \"font-weight\": \"bold\",\n    \"pointer-events\": \"none\",\n    \"user-select\": \"none\",\n    style: \"font-family:sans-serif; font-size: 16px;\"\n  });\n  text.textContent = node.id;\n\n  g.appendChild(circle);\n  g.appendChild(text);\n  nodesGroup.appendChild(g);\n\n  node.elem = g;\n  node.circle = circle;\n  node.textElem = text;\n\n  // Position the group initially\n  g.setAttribute(\"transform\", `translate(${node.x},${node.y})`);\n});\n\n// Force-directed layout parameters\nconst alphaDecay = 0.03; // simulation cooling\nlet alpha = 1; // current simulation alpha\nconst repulsionStrength = 8000;\nconst linkDistance = 150;\nconst linkStrength = 0.1;\n\n// Simulation step: apply forces & update positions\nfunction simulationStep() {\n  if (alpha < 0.005) return false; // stop simulation\n\n  // Apply repulsive forces between all nodes\n  for(let i=0; i<nodes.length; i++) {\n    let n1 = nodes[i];\n    for(let j=i+1; j<nodes.length; j++) {\n      let n2 = nodes[j];\n      let dx = n1.x - n2.x;\n      let dy = n1.y - n2.y;\n      let dist = Math.sqrt(dx*dx + dy*dy) + 0.1;\n      if(dist < 1) dist = 1;\n      let force = repulsionStrength / (dist*dist);\n      // Apply displacement\n      let fx = (dx / dist) * force * alpha;\n      let fy = (dy / dist) * force * alpha;\n      n1.x += fx;\n      n1.y += fy;\n      n2.x -= fx;\n      n2.y -= fy;\n    }\n  }\n\n  // Apply attractive forces from edges (links)\n  edges.forEach(edge => {\n    const source = edge.source;\n    const target = edge.target;\n    let dx = target.x - source.x;\n    let dy = target.y - source.y;\n    let dist = Math.sqrt(dx*dx + dy*dy) + 0.1;\n    // Desired distance influenced slightly by edge weight\n    let desiredDist = linkDistance + edge.weight * 10;\n\n    let force = (dist - desiredDist) * linkStrength * alpha;\n    let fx = (dx / dist) * force;\n    let fy = (dy / dist) * force;\n\n    source.x += fx;\n    source.y += fy;\n    target.x -= fx;\n    target.y -= fy;\n  });\n\n  // Dampen alpha (cooling)\n  alpha *= (1 - alphaDecay);\n\n  return true;\n}\n\nfunction updatePositions() {\n  // Update SVG positions of nodes\n  nodes.forEach(node => {\n    node.elem.setAttribute(\"transform\", `translate(${node.x.toFixed(1)},${node.y.toFixed(1)})`);\n  });\n\n  // Update edges positions\n  edges.forEach(edge => {\n    const sx = edge.source.x;\n    const sy = edge.source.y;\n    const tx = edge.target.x;\n    const ty = edge.target.y;\n    // Line's path string\n    const d = `M${sx.toFixed(1)} ${sy.toFixed(1)} L${tx.toFixed(1)} ${ty.toFixed(1)}`;\n    edge.pathElem.setAttribute(\"d\", d);\n\n    // Place weight text at midpoint with slight offset perpendicular to edge\n    let mx = (sx + tx)/2;\n    let my = (sy + ty)/2;\n\n    // Compute perpendicular offset vector normalized\n    let dx = tx - sx;\n    let dy = ty - sy;\n    let length = Math.sqrt(dx*dx + dy*dy) + 0.1;\n    let offset = 12; // pixels offset from line\n    let offsetX = -(dy / length) * offset;\n    let offsetY = (dx / length) * offset;\n\n    edge.weightTextElem.setAttribute(\"x\", (mx + offsetX).toFixed(1));\n    edge.weightTextElem.setAttribute(\"y\", (my + offsetY).toFixed(1));\n  });\n}\n\n// Initial simulation before enabling drag for better layout\nfunction runInitialSimulation() {\n  let steps = 300;\n  function runStep(i=0) {\n    if(i < steps) {\n      simulationStep();\n      updatePositions();\n      requestAnimationFrame(() => runStep(i+1));\n    } else {\n      alpha = 0; // stop further simulation\n    }\n  }\n  runStep();\n}\n\nrunInitialSimulation();\n\n// Drag behavior for nodes\nlet dragTarget = null;\nlet dragOffset = {x:0, y:0};\n\nsvg.addEventListener(\"mousedown\", e => {\n  // Check if clicked on node circle or text by hit testing\n  if(e.target.tagName === \"circle\" || e.target.tagName === \"text\") {\n    dragTarget = e.target.parentNode;\n    const transform = dragTarget.getAttribute(\"transform\");\n    const match = transform.match(/translate\\(([-0-9.]+),\\s*([-0-9.]+)\\)/);\n    if(match) {\n      dragOffset.x = parseFloat(match[1]) - e.clientX;\n      dragOffset.y = parseFloat(match[2]) - e.clientY;\n    }\n    // Stop simulation alpha while dragging\n    alpha = 0;\n    clearEdgeHighlights();\n  }\n});\n\nwindow.addEventListener(\"mouseup\", e => {\n  dragTarget = null;\n});\n\nwindow.addEventListener(\"mousemove\", e => {\n  if(dragTarget) {\n    // Update node position\n    let newX = e.clientX + dragOffset.x;\n    let newY = e.clientY + dragOffset.y;\n\n    // Clamp inside viewport\n    newX = Math.min(width-20, Math.max(20, newX));\n    newY = Math.min(height-20, Math.max(20, newY));\n\n    dragTarget.setAttribute(\"transform\", `translate(${newX},${newY})`);\n\n    // Update node data x,y for simulation\n    let node = nodes.find(n => n.elem === dragTarget);\n    if(node) {\n      node.x = newX;\n      node.y = newY;\n    }\n\n    updatePositions();\n  }\n});\n\n// Reset button - reset node positions and rerun simulation\ndocument.getElementById(\"resetBtn\").addEventListener(\"click\", () => {\n  // Reset node positions to circle\n  nodes.forEach((n,i) => {\n    n.x = width/2 + 150*Math.cos((2*Math.PI*i)/nodes.length);\n    n.y = height/2 + 150*Math.sin((2*Math.PI*i)/nodes.length);\n  });\n  alpha = 1;\n  runInitialSimulation();\n  clearEdgeHighlights();\n});\n\n// When clicking outside edges or nodes clear highlights\nsvg.addEventListener(\"click\", e => {\n  if(e.target === svg) {\n    clearEdgeHighlights();\n  }\n});\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": false,
  "hasTest": true
}