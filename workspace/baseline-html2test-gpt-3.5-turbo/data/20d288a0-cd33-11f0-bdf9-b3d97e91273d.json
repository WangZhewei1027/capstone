{
  "id": "20d288a0-cd33-11f0-bdf9-b3d97e91273d",
  "timestamp": "2025-11-29T14:54:24.353Z",
  "type": "html-to-test",
  "htmlModel": "gpt-3.5-turbo",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Binary Search Tree (BST) Visualization and Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f4f7f9;\n    color: #333;\n  }\n  h1 {\n    text-align: center;\n    color: #0275d8;\n  }\n  #container {\n    max-width: 900px;\n    margin: auto;\n  }\n  #controls {\n    display: flex;\n    gap: 15px;\n    flex-wrap: wrap;\n    margin-bottom: 20px;\n    align-items: center;\n  }\n  #controls input[type=\"number\"] {\n    width: 100px;\n    padding: 8px;\n    font-size: 1rem;\n  }\n  #controls button {\n    padding: 10px 15px;\n    font-size: 1rem;\n    border: none;\n    border-radius: 4px;\n    background: #0275d8;\n    color: white;\n    cursor: pointer;\n    transition: background 0.3s ease;\n  }\n  #controls button:disabled {\n    background: #89b8e7;\n    cursor: not-allowed;\n  }\n  #controls button:hover:not(:disabled) {\n    background: #025aa5;\n  }\n  #traversalOutput {\n    background: white;\n    border-radius: 6px;\n    padding: 15px;\n    min-height: 40px;\n    font-family: monospace;\n    font-size: 1.1rem;\n    margin-top: 5px;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n  }\n  #message {\n    margin: 10px 0;\n    font-weight: 600;\n  }\n  svg {\n    display: block;\n    margin: 30px auto;\n    border: 1px solid #ccc;\n    background: white;\n    overflow: visible;\n  }\n  .node circle {\n    fill: #0275d8;\n    stroke: #014f86;\n    stroke-width: 2px;\n    cursor: pointer;\n    transition: fill 0.3s ease;\n  }\n  .node circle.highlighted {\n    fill: #d9534f;\n  }\n  .node text {\n    fill: white;\n    font-weight: bold;\n    pointer-events: none;\n    user-select: none;\n  }\n  line {\n    stroke: #555;\n    stroke-width: 2px;\n  }\n  #legend {\n    max-width: 900px;\n    margin: 20px auto 0;\n    font-size: 0.9rem;\n    color: #555;\n    line-height: 1.4;\n  }\n  @media(max-width: 600px) {\n    #controls {\n      flex-direction: column;\n    }\n    #controls input[type=\"number\"] {\n      width: 100%;\n      max-width: 100%;\n    }\n    #controls button {\n      width: 100%;\n    }\n  }\n</style>\n</head>\n<body>\n  <div id=\"container\">\n    <h1>Binary Search Tree (BST) Visualization and Demo</h1>\n    <div id=\"controls\" aria-label=\"BST controls\">\n      <input type=\"number\" id=\"inputValue\" placeholder=\"Enter a number\" aria-label=\"Number input\" />\n      <button id=\"insertBtn\">Insert</button>\n      <button id=\"deleteBtn\">Delete</button>\n      <button id=\"searchBtn\">Search</button>\n      <button id=\"inorderBtn\">In-order</button>\n      <button id=\"preorderBtn\">Pre-order</button>\n      <button id=\"postorderBtn\">Post-order</button>\n      <button id=\"clearBtn\" title=\"Clear the entire BST\">Clear All</button>\n    </div>\n    <div id=\"message\" role=\"alert\" aria-live=\"polite\"></div>\n    <div>\n      <strong>Traversal Output:</strong>\n      <div id=\"traversalOutput\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n    </div>\n    <svg id=\"bstCanvas\" height=\"400\" width=\"900\" aria-label=\"Binary Search Tree visualization\"></svg>\n    <div id=\"legend\">\n      <p><strong>Instructions:</strong> Enter a number and click Insert, Delete, or Search to modify or query the BST. Use the traversal buttons to see node visits in order.</p>\n      <p><strong>Highlights:</strong> Red filled nodes in search/traversal indicate the current node being highlighted/visited.</p>\n      <p><em>Click nodes in the tree to highlight them during traversal.</em></p>\n    </div>\n  </div>\n<script>\n(() => {\n  // BST Node class\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n      this.x = 0; // for visualization position\n      this.y = 0;\n    }\n  }\n\n  // BST class with insert, delete, search, traversals\n  class BST {\n    constructor() {\n      this.root = null;\n    }\n\n    insert(value) {\n      if (this.root === null) {\n        this.root = new Node(value);\n        return true;\n      }\n      let current = this.root;\n      while (true) {\n        if (value === current.value) {\n          // no duplicates in this BST\n          return false;\n        }\n        if (value < current.value) {\n          if (current.left === null) {\n            current.left = new Node(value);\n            return true;\n          }\n          current = current.left;\n        } else {\n          if (current.right === null) {\n            current.right = new Node(value);\n            return true;\n          }\n          current = current.right;\n        }\n      }\n    }\n\n    search(value) {\n      let current = this.root;\n      while (current !== null) {\n        if (value === current.value) {\n          return current;\n        }\n        if (value < current.value) current = current.left;\n        else current = current.right;\n      }\n      return null;\n    }\n\n    delete(value) {\n      this.root = this._deleteRec(this.root, value);\n    }\n\n    _deleteRec(root, value) {\n      if (root == null) return root;\n\n      if (value < root.value) {\n        root.left = this._deleteRec(root.left, value);\n      } else if (value > root.value) {\n        root.right = this._deleteRec(root.right, value);\n      } else {\n        // found node to delete\n        if (root.left == null) return root.right;\n        else if (root.right == null) return root.left;\n\n        // node with two children, find inorder successor (min in right subtree)\n        root.value = this._minValue(root.right);\n        root.right = this._deleteRec(root.right, root.value);\n      }\n      return root;\n    }\n\n    _minValue(node) {\n      let current = node;\n      while (current.left != null) {\n        current = current.left;\n      }\n      return current.value;\n    }\n\n    inorder() {\n      let result = [];\n      this._inorderRec(this.root, result);\n      return result;\n    }\n\n    _inorderRec(node, result) {\n      if (node !== null) {\n        this._inorderRec(node.left, result);\n        result.push(node.value);\n        this._inorderRec(node.right, result);\n      }\n    }\n\n    preorder() {\n      let result = [];\n      this._preorderRec(this.root, result);\n      return result;\n    }\n\n    _preorderRec(node, result) {\n      if (node !== null) {\n        result.push(node.value);\n        this._preorderRec(node.left, result);\n        this._preorderRec(node.right, result);\n      }\n    }\n\n    postorder() {\n      let result = [];\n      this._postorderRec(this.root, result);\n      return result;\n    }\n\n    _postorderRec(node, result) {\n      if (node !== null) {\n        this._postorderRec(node.left, result);\n        this._postorderRec(node.right, result);\n        result.push(node.value);\n      }\n    }\n  }\n\n  // Visualization & App logic\n  const svg = document.getElementById('bstCanvas');\n  const insertBtn = document.getElementById('insertBtn');\n  const deleteBtn = document.getElementById('deleteBtn');\n  const searchBtn = document.getElementById('searchBtn');\n  const inorderBtn = document.getElementById('inorderBtn');\n  const preorderBtn = document.getElementById('preorderBtn');\n  const postorderBtn = document.getElementById('postorderBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const inputValue = document.getElementById('inputValue');\n  const traversalOutput = document.getElementById('traversalOutput');\n  const message = document.getElementById('message');\n\n  const nodeRadius = 20;\n  const verticalSpacing = 70;\n  const horizontalSpacing = 40;\n  let bst = new BST();\n\n  // Clear previous drawing\n  function clearSVG() {\n    while (svg.firstChild) {\n      svg.removeChild(svg.firstChild);\n    }\n  }\n\n  // Assign coordinates to nodes for visualization using inorder position and depth\n  function assignCoordinates(node, depth = 0, positions = {x: 0}) {\n    if (!node) return;\n    assignCoordinates(node.left, depth + 1, positions);\n    node.x = positions.x++;\n    node.y = depth;\n    assignCoordinates(node.right, depth + 1, positions);\n  }\n\n  // Draw lines(connections) between nodes\n  function drawLines(node, nodeMap) {\n    if (!node) return;\n    if (node.left) {\n      drawLine(node, node.left, nodeMap);\n      drawLines(node.left, nodeMap);\n    }\n    if (node.right) {\n      drawLine(node, node.right, nodeMap);\n      drawLines(node.right, nodeMap);\n    }\n  }\n\n  function drawLine(parent, child, nodeMap) {\n    const parentPos = nodeMap.get(parent);\n    const childPos = nodeMap.get(child);\n\n    const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    line.setAttribute('x1', parentPos.x);\n    line.setAttribute('y1', parentPos.y + nodeRadius);\n    line.setAttribute('x2', childPos.x);\n    line.setAttribute('y2', childPos.y - nodeRadius);\n    line.setAttribute('stroke', '#555');\n    line.setAttribute('stroke-width', '2');\n    svg.appendChild(line);\n  }\n\n  // Draw nodes\n  function drawNodes(node, nodeMap) {\n    if (!node) return;\n    drawNode(node, nodeMap);\n    drawNodes(node.left, nodeMap);\n    drawNodes(node.right, nodeMap);\n  }\n\n  // Draw a single node circle with text\n  function drawNode(node, nodeMap) {\n    const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    g.setAttribute('class', 'node');\n    g.setAttribute('role', 'treeitem');\n    g.setAttribute('tabindex', 0);\n    g.setAttribute('aria-label', `Node with value ${node.value}`);\n\n    // Calculate position\n    const x = node.x * (nodeRadius * 2 + horizontalSpacing) + nodeRadius + 10;\n    const y = node.y * verticalSpacing + nodeRadius + 10;\n\n    nodeMap.set(node, {x, y});\n\n    // circle\n    const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    circle.setAttribute('cx', x);\n    circle.setAttribute('cy', y);\n    circle.setAttribute('r', nodeRadius);\n    circle.setAttribute('fill', '#0275d8');\n    circle.setAttribute('stroke', '#014f86');\n    circle.setAttribute('stroke-width', 2);\n    circle.style.cursor = 'pointer';\n\n    // text\n    const text = document.createElementNS(\"http://www.w3.org/2000/svg\", 'text');\n    text.setAttribute('x', x);\n    text.setAttribute('y', y + 5); // small vertical offset to center text visually\n    text.setAttribute('text-anchor', 'middle');\n    text.setAttribute('font-size', '14px');\n    text.setAttribute('fill', 'white');\n    text.style.userSelect = 'none';\n    text.textContent = node.value;\n\n    g.appendChild(circle);\n    g.appendChild(text);\n\n    svg.appendChild(g);\n\n    // On click highlight node\n    g.addEventListener('click', () => {\n      clearHighlights();\n      circle.classList.add('highlighted');\n      message.textContent = `Node ${node.value} selected.`;\n    });\n  }\n\n  // Redraw the entire BST visualization\n  function redraw() {\n    clearSVG();\n    if (!bst.root) return;\n    assignCoordinates(bst.root);\n    const nodeMap = new Map();\n    drawLines(bst.root, nodeMap);\n    drawNodes(bst.root, nodeMap);\n    adjustSVGWidth();\n  }\n\n  // Adjust SVG width dynamically based on tree width\n  function adjustSVGWidth() {\n    if (!bst.root) {\n      svg.setAttribute('width', 900);\n      return;\n    }\n    // Find max x position\n    let maxX = 0;\n    function dfs(node) {\n      if (!node) return;\n      if (node.x > maxX) maxX = node.x;\n      dfs(node.left);\n      dfs(node.right);\n    }\n    dfs(bst.root);\n    const width = (maxX + 1) * (nodeRadius * 2 + horizontalSpacing) + 40;\n    svg.setAttribute('width', Math.max(width, 400));\n  }\n\n  // Clear highlights on all nodes\n  function clearHighlights() {\n    const circles = svg.querySelectorAll('circle.highlighted');\n    circles.forEach(c => c.classList.remove('highlighted'));\n  }\n\n  // Highlight a node by value\n  function highlightNode(value) {\n    clearHighlights();\n    const nodes = svg.querySelectorAll('g.node');\n    for (let g of nodes) {\n      const text = g.querySelector('text').textContent;\n      if (+text === value) {\n        const circle = g.querySelector('circle');\n        circle.classList.add('highlighted');\n        return;\n      }\n    }\n  }\n\n  // Animate traversal highlighting nodes in sequence\n  async function animateTraversal(values) {\n    traversalOutput.textContent = '';\n    if (values.length === 0) {\n      traversalOutput.textContent = '(empty)';\n      return;\n    }\n    for (let val of values) {\n      highlightNode(val);\n      traversalOutput.textContent += val + ' ';\n      await pause(700);\n    }\n    clearHighlights();\n  }\n\n  // Pause utility for async\n  function pause(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Event handlers\n  insertBtn.addEventListener('click', () => {\n    clearHighlights();\n    message.textContent = '';\n    const val = Number(inputValue.value);\n    if (isNaN(val)) {\n      message.textContent = 'Please enter a valid number to insert.';\n      inputValue.focus();\n      return;\n    }\n    const inserted = bst.insert(val);\n    if (inserted) {\n      message.textContent = `Inserted ${val} into the BST.`;\n      traversalOutput.textContent = '';\n    } else {\n      message.textContent = `Value ${val} already exists in the BST. No duplicates allowed.`;\n    }\n    inputValue.value = '';\n    redraw();\n  });\n\n  deleteBtn.addEventListener('click', () => {\n    clearHighlights();\n    message.textContent = '';\n    const val = Number(inputValue.value);\n    if (isNaN(val)) {\n      message.textContent = 'Please enter a valid number to delete.';\n      inputValue.focus();\n      return;\n    }\n    if (!bst.search(val)) {\n      message.textContent = `Value ${val} not found in the BST.`;\n      inputValue.value = '';\n      return;\n    }\n    bst.delete(val);\n    message.textContent = `Deleted ${val} from the BST.`;\n    inputValue.value = '';\n    traversalOutput.textContent = '';\n    redraw();\n  });\n\n  searchBtn.addEventListener('click', async () => {\n    clearHighlights();\n    message.textContent = '';\n    traversalOutput.textContent = '';\n    const val = Number(inputValue.value);\n    if (isNaN(val)) {\n      message.textContent = 'Please enter a valid number to search.';\n      inputValue.focus();\n      return;\n    }\n    let current = bst.root;\n    let path = [];\n    while (current != null) {\n      path.push(current.value);\n      if (val === current.value) {\n        message.textContent = `Value ${val} found in the BST.`;\n        break;\n      }\n      if (val < current.value) current = current.left;\n      else current = current.right;\n    }\n    if (current == null) {\n      message.textContent = `Value ${val} not found in the BST.`;\n    }\n    await animateTraversal(path);\n    inputValue.value = '';\n  });\n\n  inorderBtn.addEventListener('click', async () => {\n    clearHighlights();\n    message.textContent = '';\n    const values = bst.inorder();\n    message.textContent = 'In-order traversal:';\n    await animateTraversal(values);\n  });\n\n  preorderBtn.addEventListener('click', async () => {\n    clearHighlights();\n    message.textContent = '';\n    const values = bst.preorder();\n    message.textContent = 'Pre-order traversal:';\n    await animateTraversal(values);\n  });\n\n  postorderBtn.addEventListener('click', async () => {\n    clearHighlights();\n    message.textContent = '';\n    const values = bst.postorder();\n    message.textContent = 'Post-order traversal:';\n    await animateTraversal(values);\n  });\n\n  clearBtn.addEventListener('click', () => {\n    bst = new BST();\n    clearHighlights();\n    message.textContent = 'BST cleared.';\n    traversalOutput.textContent = '';\n    inputValue.value = '';\n    redraw();\n  });\n\n  // Keyboard accessibility for Enter key in input field for insert\n  inputValue.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter') {\n      insertBtn.click();\n    }\n  });\n\n  // Initialize empty tree visualization\n  redraw();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": false,
  "hasTest": true
}