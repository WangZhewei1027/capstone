import { test, expect } from '@playwright/test';

const APP_URL = 'http://127.0.0.1:5500/workspace/baseline-html2test-gpt-3.5-turbo/html/7abe8312-cd32-11f0-a96f-2d591ffb35fe.html';

// Page Object Model for the Union-Find visualizer
class UnionFindPage {
  /**
   * @param {import('@playwright/test').Page} page
   */
  constructor(page) {
    this.page = page;
    this.sets = page.locator('#sets');
    this.log = page.locator('#log');
    this.inputA = page.locator('#elementA');
    this.inputB = page.locator('#elementB');
    this.unionBtn = page.locator('#union-btn');
    this.findBtn = page.locator('#find-btn');
    this.resetBtn = page.locator('#reset-btn');
    this.circleLocator = page.locator('.set-circle');
  }

  // Navigate to the app
  async goto() {
    await this.page.goto(APP_URL);
    // Ensure the main container is present before proceeding
    await expect(this.page.locator('#union-find-container')).toBeVisible();
  }

  // Helper to set inputs A and B
  async setElements(a, b) {
    await this.inputA.fill(String(a));
    await this.inputB.fill(String(b));
  }

  // Perform a union operation, handling dialogs if they appear.
  async union(a, b) {
    // Prepare dialog handler promise in case an alert shows up
    const [dialog] = await Promise.all([
      this.page.waitForEvent('dialog').catch(() => null),
      (async () => {
        await this.setElements(a, b);
        await this.unionBtn.click();
      })(),
    ]);
    return dialog; // may be null if no dialog was shown
  }

  // Perform a find operation, handling dialogs if they appear.
  async find(a, b) {
    const [dialog] = await Promise.all([
      this.page.waitForEvent('dialog').catch(() => null),
      (async () => {
        await this.setElements(a, b);
        await this.findBtn.click();
      })(),
    ]);
    return dialog;
  }

  // Click reset button
  async reset() {
    await this.resetBtn.click();
  }

  // Return the entire log text content
  async getLogText() {
    return (await this.log.textContent()) || '';
  }

  // Count number of set circles rendered
  async countCircles() {
    return this.circleLocator.count();
  }

  // Count leader circles
  async countLeaders() {
    return this.page.locator('.set-circle.leader').count();
  }

  // Get locator for a leader element by element id (aria-label generated by app)
  leaderLocator(id) {
    return this.page.locator(`[aria-label="Element ${id}, group leader"]`);
  }

  // Get the sets-group parent for a given leader locator
  async getGroupChildrenTextsForLeader(id) {
    const leader = this.leaderLocator(id);
    await expect(leader).toBeVisible();
    // The structure places the leader inside a .sets-group parent.
    const group = leader.locator('xpath=..'); // parent node
    const circles = group.locator('.set-circle');
    const count = await circles.count();
    const texts = [];
    for (let i = 0; i < count; i++) {
      const t = (await circles.nth(i).textContent()) || '';
      texts.push(t.trim());
    }
    return texts;
  }
}

test.describe('Union-Find (Disjoint Set) Visualizer - E2E', () => {
  let consoleMessages;
  let consoleErrors;
  let pageErrors;

  // Attach console and pageerror listeners in beforeEach to capture runtime issues
  test.beforeEach(async ({ page }) => {
    consoleMessages = [];
    consoleErrors = [];
    pageErrors = [];

    page.on('console', (msg) => {
      const type = msg.type();
      const text = msg.text();
      consoleMessages.push({ type, text });
      if (type === 'error') consoleErrors.push(text);
    });

    page.on('pageerror', (err) => {
      pageErrors.push(err && err.message ? String(err.message) : String(err));
    });
  });

  // Test initial load and default state
  test('loads page and displays initial state with 16 separate leaders and welcome log', async ({ page }) => {
    const uf = new UnionFindPage(page);
    await uf.goto();

    // Verify the initial log contains the welcome message
    const logText = await uf.getLogText();
    expect(logText).toContain('Welcome! Select two elements and perform Union or Find operations.');

    // There should be 16 circles (elements 0..15)
    const circlesCount = await uf.countCircles();
    expect(circlesCount).toBe(16);

    // Initially each element is its own leader, so 16 leaders expected
    const leadersCount = await uf.countLeaders();
    expect(leadersCount).toBe(16);

    // Ensure no page errors or console errors occurred during initial load
    expect(pageErrors).toHaveLength(0);
    expect(consoleErrors).toHaveLength(0);
  });

  test.describe('Union operations and edge cases', () => {
    test('union merges two distinct elements and updates DOM and log', async ({ page }) => {
      const uf1 = new UnionFindPage(page);
      await uf.goto();

      // Perform union(0,1)
      const dialog = await uf.union(0, 1);
      // No alert expected for a valid union of distinct elements
      expect(dialog).toBeNull();

      // The log should contain a message about the union
      const log = await uf.getLogText();
      expect(log).toContain('Union done: elements 0 and 1 merged.');

      // The group whose leader is 0 should contain both elements 0 and 1
      const texts1 = await uf.getGroupChildrenTextsForLeader(0);
      expect(texts).toContain('0');
      expect(texts).toContain('1');

      // Leaders count should have decreased by 1 (now 15 leaders)
      const leadersCount1 = await uf.countLeaders();
      expect(leadersCount).toBe(15);

      // Sanity: overall circles still 16
      const circlesCount1 = await uf.countCircles();
      expect(circlesCount).toBe(16);

      // No runtime errors occurred during this operation
      expect(pageErrors).toHaveLength(0);
      expect(consoleErrors).toHaveLength(0);
    });

    test('union of the same element triggers an alert and does not change sets', async ({ page }) => {
      const uf2 = new UnionFindPage(page);
      await uf.goto();

      // Count leaders before attempting invalid union
      const leadersBefore = await uf.countLeaders();

      // Attempt union(2,2) which should trigger an alert
      const dialogPromise = page.waitForEvent('dialog');
      await uf.setElements(2, 2);
      await uf.unionBtn.click();
      const dialog1 = await dialogPromise;
      expect(dialog).not.toBeNull();
      expect(dialog.message()).toBe('Please select two different elements to union.');
      await dialog.accept();

      // Ensure leaders count did not change
      const leadersAfter = await uf.countLeaders();
      expect(leadersAfter).toBe(leadersBefore);

      // Ensure log did not add a union success message for this operation
      const log1 = await uf.getLogText();
      expect(log).not.toContain('Union done: elements 2 and 2 merged.');

      // No page errors
      expect(pageErrors).toHaveLength(0);
      expect(consoleErrors).toHaveLength(0);
    });

    test('union with out-of-range element triggers validation alert', async ({ page }) => {
      const uf3 = new UnionFindPage(page);
      await uf.goto();

      // Set elementB to 16 (out of valid range 0-15)
      const dialogPromise1 = page.waitForEvent('dialog');
      await uf.setElements(0, 16);
      await uf.unionBtn.click();
      const dialog2 = await dialogPromise;
      expect(dialog).not.toBeNull();
      expect(dialog.message()).toBe('Please enter valid elements between 0 and 15');
      await dialog.accept();

      // No change should occur to the sets - still 16 circles and leaders
      const circlesCount2 = await uf.countCircles();
      expect(circlesCount).toBe(16);
      const leadersCount2 = await uf.countLeaders();
      expect(leadersCount).toBe(16);

      // No runtime errors
      expect(pageErrors).toHaveLength(0);
      expect(consoleErrors).toHaveLength(0);
    });

    test('attempting to union already connected elements logs a message but does not change grouping', async ({ page }) => {
      const uf4 = new UnionFindPage(page);
      await uf.goto();

      // First merge 5 and 6
      await uf.union(5, 6);
      let log2 = await uf.getLogText();
      expect(log).toContain('Union done: elements 5 and 6 merged.');

      // Count leaders now should be 15
      const leadersAfterFirst = await uf.countLeaders();
      expect(leadersAfterFirst).toBe(15);

      // Attempt to union 6 and 5 again (already connected)
      await uf.union(6, 5); // no dialog expected
      log = await uf.getLogText();
      expect(log).toContain('Elements 6 and 5 are already in the same set.');

      // Group for leader '5' should still include 5 and 6
      const texts2 = await uf.getGroupChildrenTextsForLeader(5);
      expect(texts).toContain('5');
      expect(texts).toContain('6');

      // Leaders count should remain unchanged
      const leadersAfterSecond = await uf.countLeaders();
      expect(leadersAfterSecond).toBe(15);

      // No runtime errors
      expect(pageErrors).toHaveLength(0);
      expect(consoleErrors).toHaveLength(0);
    });
  });

  test.describe('Find operations and reset behavior', () => {
    test('find reports connected elements and leader after unions', async ({ page }) => {
      const uf5 = new UnionFindPage(page);
      await uf.goto();

      // Create a union between 7 and 8
      await uf.union(7, 8);

      // Now do find(7,8)
      const dialog3 = await uf.find(7, 8);
      expect(dialog).toBeNull(); // find on valid connected elements should not trigger an alert

      // The log should indicate they are connected and reveal the leader
      const log3 = await uf.getLogText();
      expect(log).toMatch(/Find: elements 7 and 8 are connected\. Leader: \d+/);

      // Ensure the leader is either 7 or 8 (depending on union-by-rank)
      const match = log.match(/Leader: (\d+)/);
      expect(match).not.toBeNull();
      const leaderId = Number(match[1]);
      expect([7, 8]).toContain(leaderId);

      // No runtime errors
      expect(pageErrors).toHaveLength(0);
      expect(consoleErrors).toHaveLength(0);
    });

    test('find correctly reports NOT connected for separate elements', async ({ page }) => {
      const uf6 = new UnionFindPage(page);
      await uf.goto();

      // Ensure elements 9 and 10 are separate initially
      const logBefore = await uf.getLogText();
      expect(logBefore).not.toContain('Find: elements 9 and 10');

      // Perform find(9,10)
      const dialog4 = await uf.find(9, 10);
      expect(dialog).toBeNull();

      // Log should indicate they are NOT connected
      const log4 = await uf.getLogText();
      expect(log).toContain('Find: elements 9 and 10 are NOT connected.');

      // No runtime errors
      expect(pageErrors).toHaveLength(0);
      expect(consoleErrors).toHaveLength(0);
    });

    test('reset restores the initial separate sets and logs the reset message', async ({ page }) => {
      const uf7 = new UnionFindPage(page);
      await uf.goto();

      // Make a union so that state changes
      await uf.union(11, 12);
      const leadersAfterUnion = await uf.countLeaders();
      expect(leadersAfterUnion).toBeLessThan(16);

      // Click reset
      await uf.reset();

      // The log should contain reset message
      const log5 = await uf.getLogText();
      expect(log).toContain('Union-Find structure reset.');

      // After reset, each element should be a leader again (16 leaders)
      const leadersAfterReset = await uf.countLeaders();
      expect(leadersAfterReset).toBe(16);

      // Ensure groups are back to one element each
      const circlesCount3 = await uf.countCircles();
      expect(circlesCount).toBe(16);

      // No runtime errors
      expect(pageErrors).toHaveLength(0);
      expect(consoleErrors).toHaveLength(0);
    });
  });

  test.describe('Accessibility and DOM attributes', () => {
    test('sets container has appropriate ARIA attributes and live region updates log', async ({ page }) => {
      const uf8 = new UnionFindPage(page);
      await uf.goto();

      // The sets container should be marked as an ARIA live region
      const setsEl = page.locator('#sets');
      await expect(setsEl).toHaveAttribute('aria-live', 'polite');

      // Trigger a union to cause updates (and log changes)
      await uf.union(13, 14);

      // The log area should be an ARIA live region too
      const logEl = page.locator('#log');
      await expect(logEl).toHaveAttribute('aria-live', 'polite');

      // The newly appended log entry should be visible in the log area
      const logText1 = await uf.getLogText();
      expect(logText).toContain('Union done: elements 13 and 14 merged.');

      // No runtime errors
      expect(pageErrors).toHaveLength(0);
      expect(consoleErrors).toHaveLength(0);
    });
  });
});