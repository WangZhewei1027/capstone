import { test, expect } from '@playwright/test';

const APP_URL = 'http://127.0.0.1:5500/workspace/baseline-html2test-gpt-3.5-turbo/html/e03a476b-cd32-11f0-a949-f901cf5609c9.html';

// Page Object for the LCS application to keep tests readable and maintainable
class LCSPage {
  /**
   * @param {import('@playwright/test').Page} page
   */
  constructor(page) {
    this.page = page;
    this.input1 = page.locator('#string1');
    this.input2 = page.locator('#string2');
    this.calcBtn = page.locator('#calc-btn');
    this.output = page.locator('#output');
    this.lcsLength = page.locator('#lcs-length');
    this.lcsString = page.locator('#lcs-string');
    this.matrixContainer = page.locator('#matrix');
    // table inside #matrix (generated by JS)
    this.matrixTable = this.matrixContainer.locator('table');
  }

  async goto() {
    await this.page.goto(APP_URL);
  }

  // Fill both inputs (values will be trimmed client-side)
  async fillInputs(s1, s2) {
    await this.input1.fill(s1);
    await this.input2.fill(s2);
  }

  // Click the calculate button and wait briefly for UI updates
  async clickCalculate() {
    await Promise.all([
      this.page.waitForTimeout(50), // small wait to allow event handlers to process
      this.calcBtn.click()
    ]);
  }

  // Convenience to perform full calculation flow
  async calculate(s1, s2) {
    await this.fillInputs(s1, s2);
    await this.clickCalculate();
  }

  // Wait until output becomes visible
  async waitForOutputVisible() {
    await expect(this.output).toBeVisible();
  }

  async waitForOutputHidden() {
    await expect(this.output).toBeHidden();
  }
}

test.describe('Longest Common Subsequence - Interactive App', () => {
  let consoleErrors;
  let pageErrors;
  let lcsPage;

  // Setup: create arrays to collect console error messages and page errors for each test
  test.beforeEach(async ({ page }) => {
    consoleErrors = [];
    pageErrors = [];

    // Collect console messages of type 'error' for assertions
    page.on('console', (msg) => {
      if (msg.type() === 'error') {
        consoleErrors.push({ text: msg.text(), location: msg.location() });
      }
    });

    // Collect uncaught page errors
    page.on('pageerror', (err) => {
      pageErrors.push(String(err));
    });

    lcsPage = new LCSPage(page);
    await lcsPage.goto();
  });

  // Teardown health check: assert there were no unexpected console errors or page errors after each test
  test.afterEach(async () => {
    // Assert no console 'error' messages were emitted
    expect(consoleErrors.length, `Console errors were emitted: ${JSON.stringify(consoleErrors)}`).toBe(0);
    // Assert no uncaught page errors
    expect(pageErrors.length, `Page errors occurred: ${JSON.stringify(pageErrors)}`).toBe(0);
  });

  test('Initial page load shows inputs and button, output is hidden', async ({ page }) => {
    // Purpose: Verify initial DOM layout and default visibility/state of elements
    await expect(page).toHaveTitle(/Longest Common Subsequence/i);

    // Inputs and button are present
    await expect(lcsPage.input1).toBeVisible();
    await expect(lcsPage.input2).toBeVisible();
    await expect(lcsPage.calcBtn).toBeVisible();

    // Inputs should be empty by default
    await expect(lcsPage.input1).toHaveValue('');
    await expect(lcsPage.input2).toHaveValue('');

    // Output container should be hidden initially
    await lcsPage.waitForOutputHidden();

    // Matrix container should be present but empty until calculation
    await expect(lcsPage.matrixContainer).toBeEmpty();
  });

  test('Clicking Calculate with empty inputs shows alert and keeps output hidden', async ({ page }) => {
    // Purpose: Validate client-side validation that both strings are required and alert is shown
    // Intercept dialog to assert its message
    const dialogs = [];
    page.on('dialog', async (dialog) => {
      dialogs.push({ message: dialog.message(), type: dialog.type() });
      await dialog.dismiss();
    });

    // Ensure both inputs are empty then click
    await lcsPage.input1.fill('');
    await lcsPage.input2.fill('');
    await lcsPage.clickCalculate();

    // Expect an alert dialog to have been shown with the expected message
    expect(dialogs.length).toBeGreaterThanOrEqual(1);
    expect(dialogs[0].message).toBe('Please enter both strings.');
    expect(dialogs[0].type).toBe('alert');

    // Output must remain hidden after validation failure
    await lcsPage.waitForOutputHidden();
  });

  test('Calculates LCS for two non-empty strings and displays results with DP matrix', async ({ page }) => {
    // Purpose: End-to-end validation of LCS computation, displayed length, LCS string and generated matrix
    // Use a known example: s1 = 'ABCBDAB', s2 = 'BDCABA' -> LCS length is 4
    await lcsPage.calculate('ABCBDAB', 'BDCABA');

    // Output container should now be visible
    await lcsPage.waitForOutputVisible();

    // The displayed length should be '4'
    await expect(lcsPage.lcsLength).toHaveText('4');

    // The LCS string should be non-empty and its length should be equal to the length displayed
    const displayedLcs = await lcsPage.lcsString.textContent();
    // Accept any valid LCS output of length 4
    expect(displayedLcs.length, 'LCS string should have length 4').toBe(4);

    // Matrix table should exist and last cell (bottom-right) should equal the length
    await expect(lcsPage.matrixTable).toBeVisible();

    // Verify that the bottom-right cell contains the same numeric value as the LCS length
    // Locate last row and last cell via DOM traversal
    const lastRow = lcsPage.matrixTable.locator('tr').nth(-1);
    const lastCell = lastRow.locator('td').nth(-1);
    await expect(lastCell).toHaveText('4');

    // Check styling of last cell: should be bold and colored per implementation
    const fontWeight = await lastCell.evaluate((el) => window.getComputedStyle(el).fontWeight);
    const color = await lastCell.evaluate((el) => window.getComputedStyle(el).color);
    // fontWeight can be '700' or 'bold' depending on browser; ensure it's at least not normal '400'
    expect(['700', 'bold', '800', '900'].includes(String(fontWeight)) || Number(fontWeight) > 400).toBeTruthy();
    // color should include the expected blue hex converted to rgb; check presence of 'rgb' and blue-ish value
    expect(String(color)).toContain('rgb');

    // Sanity: ensure matrix has correct dimensions: rows = m + 2 (header row + m+1 rows)
    // m = 7 (s1 length), so expected total rows = 1 (header) + (m+1)=1+8=9
    const totalRows = await lcsPage.matrixTable.locator('tr').count();
    expect(totalRows).toBe(9);
  });

  test('Shows "(No common subsequence)" message and 0 length for completely distinct strings', async ({ page }) => {
    // Purpose: Validate edge case with no common characters between inputs
    await lcsPage.calculate('ABC', 'DEF');

    // Output visible and length should be 0
    await lcsPage.waitForOutputVisible();
    await expect(lcsPage.lcsLength).toHaveText('0');

    // The app should display the fallback text when LCS is empty
    await expect(lcsPage.lcsString).toHaveText('(No common subsequence)');

    // Matrix bottom-right cell should be '0'
    const lastRow1 = lcsPage.matrixTable.locator('tr').nth(-1);
    const lastCell1 = lastRow.locator('td').nth(-1);
    await expect(lastCell).toHaveText('0');
  });

  test('Trims input whitespace before processing', async ({ page }) => {
    // Purpose: Confirm inputs are trimmed (the script calls .trim() on values)
    await lcsPage.calculate('  ABC  ', '  C  ');

    // Output should show LCS length 1 and LCS string 'C'
    await lcsPage.waitForOutputVisible();
    await expect(lcsPage.lcsLength).toHaveText('1');
    await expect(lcsPage.lcsString).toHaveText('C');
  });

  test('Generated matrix headers reflect second string characters and matrix values are numeric', async ({ page }) => {
    // Purpose: Verify the matrix table header is labeled with characters of the second string and numeric cell contents
    const s1 = 'AGGTAB';
    const s2 = 'GXTXAYB';
    await lcsPage.calculate(s1, s2);

    await lcsPage.waitForOutputVisible();
    // First row is header row: after the empty corner, there are n characters from s2
    const headerRow = lcsPage.matrixTable.locator('tr').first();
    // Count header <th> excluding the corner: headerRow has 1 + n <th>
    const headerThCount = await headerRow.locator('th').count();
    expect(headerThCount).toBe(1 + s2.length);

    // Verify each displayed header character matches s2
    for (let i = 0; i < s2.length; i++) {
      const th = headerRow.locator('th').nth(i + 1);
      await expect(th).toHaveText(s2[i]);
    }

    // Verify that all numeric cells contain digits only
    const dataCells = lcsPage.matrixTable.locator('td');
    const count = await dataCells.count();
    for (let i = 0; i < count; i++) {
      const txt = await dataCells.nth(i).textContent();
      // Should be representable as integer (including '0')
      expect(/^\d+$/.test(txt)).toBeTruthy();
    }

    // Validate final LCS length numerically equals bottom-right table cell
    const displayedLengthText = await lcsPage.lcsLength.textContent();
    const bottomRight = await lcsPage.matrixTable.locator('tr').nth(-1).locator('td').nth(-1).textContent();
    expect(String(displayedLengthText)).toBe(String(bottomRight));
  });
});