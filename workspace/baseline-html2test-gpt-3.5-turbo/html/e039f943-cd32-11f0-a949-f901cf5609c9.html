<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Binary Search Tree (BST) Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f4f7fa;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  h1 {
    color: #023e8a;
  }
  #controls {
    margin-bottom: 20px;
  }
  input[type="number"] {
    width: 80px;
    padding: 6px;
    margin-right: 10px;
    font-size: 16px;
  }
  button {
    padding: 8px 14px;
    margin-right: 6px;
    font-size: 16px;
    border: none;
    background: #0077b6;
    color: white;
    cursor: pointer;
    border-radius: 4px;
    transition: background 0.3s ease;
  }
  button:hover {
    background: #023e8a;
  }
  #message {
    margin-top: 10px;
    min-height: 18px;
    color: #0077b6;
    font-weight: bold;
  }
  #tree-container {
    margin-top: 20px;
    position: relative;
    width: 100%;
    max-width: 900px;
    height: 380px;
    background: white;
    border: 2px solid #0077b6;
    border-radius: 8px;
    overflow-x: auto;
    overflow-y: hidden;
    padding-top: 20px;
  }
  svg {
    display: block;
    margin: 0 auto;
  }
  .node {
    fill: #caf0f8;
    stroke: #0077b6;
    stroke-width: 2;
    cursor: pointer;
  }
  .node.highlight {
    fill: #ffb703;
  }
  text {
    font-weight: bold;
    fill: #03045e;
    user-select: none;
  }
  line {
    stroke: #0077b6;
    stroke-width: 2;
  }
</style>
</head>
<body>
  <h1>Binary Search Tree (BST) Demo</h1>
  <div id="controls">
    <input type="number" id="valueInput" placeholder="Enter number" />
    <button id="insertBtn">Insert</button>
    <button id="searchBtn">Search</button>
    <button id="inorderBtn">In-order Traversal</button>
    <button id="preorderBtn">Pre-order Traversal</button>
    <button id="postorderBtn">Post-order Traversal</button>
    <button id="clearBtn" style="background:#d90429;">Clear</button>
  </div>
  <div id="message"></div>
  <div id="tree-container">
    <!-- SVG will be injected here -->
  </div>

<script>
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
    // Position for visualization
    this.x = 0;
    this.y = 0;
  }
}

class BST {
  constructor() {
    this.root = null;
  }

  insert(value) {
    if(this.root === null) {
      this.root = new Node(value);
      return true;
    }
    return this._insert(this.root, value);
  }

  _insert(node, value) {
    if(value === node.value) {
      return false; // duplicate, do not insert
    }
    if(value < node.value) {
      if(node.left == null) {
        node.left = new Node(value);
        return true;
      } else {
        return this._insert(node.left, value);
      }
    } else {
      if(node.right == null) {
        node.right = new Node(value);
        return true;
      } else {
        return this._insert(node.right, value);
      }
    }
  }

  search(value) {
    return this._search(this.root, value);
  }

  _search(node, value) {
    if(node == null) return null;
    if(value === node.value) return node;
    if(value < node.value) return this._search(node.left, value);
    return this._search(node.right, value);
  }

  inorder() {
    const result = [];
    this._inorder(this.root, result);
    return result;
  }
  _inorder(node, result) {
    if(node === null) return;
    this._inorder(node.left, result);
    result.push(node.value);
    this._inorder(node.right, result);
  }

  preorder() {
    const result = [];
    this._preorder(this.root, result);
    return result;
  }
  _preorder(node, result) {
    if(node === null) return;
    result.push(node.value);
    this._preorder(node.left, result);
    this._preorder(node.right, result);
  }

  postorder() {
    const result = [];
    this._postorder(this.root, result);
    return result;
  }
  _postorder(node, result) {
    if(node === null) return;
    this._postorder(node.left, result);
    this._postorder(node.right, result);
    result.push(node.value);
  }
}

// Visualization logic
const treeContainer = document.getElementById('tree-container');
const messageDiv = document.getElementById('message');

const NODE_RADIUS = 20;
const LEVEL_HEIGHT = 80;

let bst = new BST();

function clearMessage() {
  messageDiv.textContent = '';
}

function showMessage(msg, isError = false) {
  messageDiv.textContent = msg;
  messageDiv.style.color = isError ? '#d90429' : '#0077b6';
}

function computeNodePositions(root) {
  // We will do an inorder x-position assignment and level-based y-position
  let positions = [];
  let x = 0;

  function assignPositions(node, depth) {
    if (!node) return;
    assignPositions(node.left, depth + 1);
    node.x = x++;
    node.y = depth;
    assignPositions(node.right, depth + 1);
  }

  assignPositions(root, 0);
}

function drawTree(root) {
  treeContainer.innerHTML = '';
  if(!root) return;

  computeNodePositions(root);

  // Find width needed
  let totalNodes = 0;
  function countNodes(n) {
    if(!n) return 0;
    return 1 + countNodes(n.left) + countNodes(n.right);
  }
  totalNodes = countNodes(root);

  // Calculate dimensions
  // Horizontal spacing between nodes
  const H_SPACING = 70;
  const width = Math.max(treeContainer.clientWidth, totalNodes * H_SPACING + 40);
  const height = LEVEL_HEIGHT * (maxDepth(root) + 1) + 40;

  // Create SVG
  let svgNS = "http://www.w3.org/2000/svg";
  let svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", width);
  svg.setAttribute("height", height);
  svg.setAttribute("style", "overflow: visible");

  // Draw lines (edges) first
  function drawEdges(node) {
    if(!node) return;
    if(node.left) {
      let line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", node.x * H_SPACING + NODE_RADIUS + 10);
      line.setAttribute("y1", node.y * LEVEL_HEIGHT + NODE_RADIUS + 10);
      line.setAttribute("x2", node.left.x * H_SPACING + NODE_RADIUS + 10);
      line.setAttribute("y2", node.left.y * LEVEL_HEIGHT + NODE_RADIUS + 10);
      svg.appendChild(line);
      drawEdges(node.left);
    }
    if(node.right) {
      let line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", node.x * H_SPACING + NODE_RADIUS + 10);
      line.setAttribute("y1", node.y * LEVEL_HEIGHT + NODE_RADIUS + 10);
      line.setAttribute("x2", node.right.x * H_SPACING + NODE_RADIUS + 10);
      line.setAttribute("y2", node.right.y * LEVEL_HEIGHT + NODE_RADIUS + 10);
      svg.appendChild(line);
      drawEdges(node.right);
    }
  }

  drawEdges(root);

  // Draw nodes
  function drawNodes(node) {
    if(!node) return;
    let g = document.createElementNS(svgNS, "g");
    g.setAttribute("class", "node-group");
    g.setAttribute("transform", `translate(${node.x * H_SPACING + 10}, ${node.y * LEVEL_HEIGHT + 10})`);
    g.style.cursor = 'pointer';

    let circle = document.createElementNS(svgNS, "circle");
    circle.classList.add("node");
    circle.setAttribute("r", NODE_RADIUS);
    circle.setAttribute("cx", NODE_RADIUS);
    circle.setAttribute("cy", NODE_RADIUS);

    let text = document.createElementNS(svgNS, "text");
    text.setAttribute("x", NODE_RADIUS);
    text.setAttribute("y", NODE_RADIUS + 6);
    text.setAttribute("text-anchor", "middle");
    text.textContent = node.value;

    g.appendChild(circle);
    g.appendChild(text);

    // Add tooltip and click: highlight node on click
    g.title = `Value: ${node.value}`;
    g.addEventListener("click", () => {
      clearHighlights();
      circle.classList.add('highlight');
      showMessage(`Node clicked: ${node.value}`);
    });

    svg.appendChild(g);

    drawNodes(node.left);
    drawNodes(node.right);
  }
  drawNodes(root);

  treeContainer.appendChild(svg);
}

// utility: max depth of tree
function maxDepth(node) {
  if(!node) return 0;
  return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));
}

function clearHighlights() {
  const circles = document.querySelectorAll('.node.highlight');
  circles.forEach(c => c.classList.remove('highlight'));
}

// Animate highlighting a node (during search or traversals)
async function highlightNode(value) {
  const circles = [...document.querySelectorAll('circle.node')];
  for(let circle of circles) {
    if(circle.nextSibling && +circle.nextSibling.textContent === value) {
      circle.classList.add('highlight');
      await sleep(700);
      circle.classList.remove('highlight');
      break;
    }
  }
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Traversal animation
async function animateTraversal(values, traversalName) {
  clearHighlights();
  showMessage(`${traversalName} traversal: ${values.join(', ')}`);
  for(let val of values) {
    await highlightNode(val);
  }
  showMessage(`${traversalName} traversal complete.`);
}

// Handlers
document.getElementById('insertBtn').addEventListener('click', () => {
  clearMessage();
  const input = document.getElementById('valueInput');
  const val = parseInt(input.value);
  if(isNaN(val)) {
    showMessage("Please enter a valid number.", true);
    return;
  }
  const inserted = bst.insert(val);
  if(!inserted) {
    showMessage(`Value ${val} already exists in the BST.`, true);
  } else {
    showMessage(`Inserted ${val} into BST.`);
  }
  input.value = '';
  drawTree(bst.root);
});

document.getElementById('searchBtn').addEventListener('click', async () => {
  clearMessage();
  const input = document.getElementById('valueInput');
  const val = parseInt(input.value);
  if(isNaN(val)) {
    showMessage("Please enter a valid number to search.", true);
    return;
  }
  clearHighlights();
  let node = bst.root;
  let found = false;
  while(node) {
    await highlightNode(node.value);
    if(val === node.value) {
      found = true;
      break;
    }
    node = val < node.value ? node.left : node.right;
  }
  if(found) {
    showMessage(`Value ${val} found in BST.`);
  } else {
    showMessage(`Value ${val} not found in BST.`, true);
  }
  input.value = '';
});

document.getElementById('inorderBtn').addEventListener('click', async () => {
  clearMessage();
  const values = bst.inorder();
  if(values.length === 0) {
    showMessage("BST is empty.", true);
    return;
  }
  await animateTraversal(values, "In-order");
});

document.getElementById('preorderBtn').addEventListener('click', async () => {
  clearMessage();
  const values = bst.preorder();
  if(values.length === 0) {
    showMessage("BST is empty.", true);
    return;
  }
  await animateTraversal(values, "Pre-order");
});

document.getElementById('postorderBtn').addEventListener('click', async () => {
  clearMessage();
  const values = bst.postorder();
  if(values.length === 0) {
    showMessage("BST is empty.", true);
    return;
  }
  await animateTraversal(values, "Post-order");
});

document.getElementById('clearBtn').addEventListener('click', () => {
  bst = new BST();
  clearHighlights();
  drawTree(bst.root);
  clearMessage();
});

// Initialize empty tree view
drawTree(bst.root);

</script>
</body>
</html>