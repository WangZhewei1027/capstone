<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Adjacency List Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  #graphInput {
    width: 100%;
    height: 100px;
    font-family: monospace;
  }
  #adjList {
    margin-top: 20px;
  }
  .adj-node {
    margin-bottom: 10px;
  }
  #graphCanvas {
    border: 1px solid #ccc;
    margin-top: 30px;
    background: #fafafa;
  }
  button {
    margin-top: 10px;
    padding: 8px 14px;
    font-size: 14px;
  }
  .error {
    color: red;
    margin-top: 10px;
    font-weight: bold;
  }
</style>
</head>
<body>
  <h1>Adjacency List Representation of a Graph</h1>
  <p>Enter edges below, one per line, in the format: <code>nodeA nodeB</code> or <code>nodeA,nodeB</code></p>
  <p>Example:<br>
  <code>A B</code><br>
  <code>A C</code><br>
  <code>B D</code><br>
  <code>C D</code><br>
  <code>D E</code></p>
  <textarea id="graphInput" placeholder="Enter edges here..."></textarea>
  <br />
  <button id="buildGraphBtn">Build Graph</button>
  <div id="errorMsg" class="error"></div>
  <div id="adjList"></div>
  <canvas id="graphCanvas" width="600" height="400"></canvas>

<script>
(() => {
  const inputEl = document.getElementById("graphInput");
  const buildBtn = document.getElementById("buildGraphBtn");
  const adjListDiv = document.getElementById("adjList");
  const canvas = document.getElementById("graphCanvas");
  const ctx = canvas.getContext("2d");
  const errorMsg = document.getElementById("errorMsg");

  // Graph data structure: adjacency list
  // { node: [neighbors] }
  let graph = {};

  // Positions of nodes on canvas for visualization
  let nodePositions = {};

  // Clears canvas and adjList display
  function clearDisplay() {
    adjListDiv.innerHTML = "";
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    errorMsg.textContent = "";
  }

  // Parse input edges into adjacency list
  function parseInput(input) {
    const lines = input.trim().split("\n");
    const adjacency = {};
    for (let lineNum = 0; lineNum < lines.length; lineNum++) {
      const lineRaw = lines[lineNum].trim();
      if (lineRaw === "") continue;
      // Support "A B" or "A,B"
      let parts = lineRaw.includes(",") ? lineRaw.split(",") : lineRaw.split(/\s+/);
      if (parts.length !== 2) {
        throw new Error(`Invalid edge format on line ${lineNum+1}: "${lineRaw}"`);
      }
      let [from, to] = parts.map(s => s.trim());
      if (!from || !to) {
        throw new Error(`Invalid nodes on line ${lineNum+1}: "${lineRaw}"`);
      }

      // Initialize adjacency entries if needed
      if (!adjacency[from]) adjacency[from] = [];
      if (!adjacency[to]) adjacency[to] = []; // also add the 'to' node as a key if not present

      adjacency[from].push(to);
      // For undirected graph, add opposite edge:
      // adjacency[to].push(from);
    }
    return adjacency;
  }

  // Display adjacency list in readable format
  function displayAdjList(adj) {
    adjListDiv.innerHTML = "<h2>Adjacency List</h2>";
    const ul = document.createElement("ul");
    for (const node of Object.keys(adj).sort()) {
      const li = document.createElement("li");
      li.className = "adj-node";
      li.textContent = `${node}: ${adj[node].join(", ")}`;
      ul.appendChild(li);
    }
    adjListDiv.appendChild(ul);
  }

  // Basic circle layout for visualization
  function layoutNodes(nodes) {
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(centerX, centerY) - 50;
    const angleStep = (2 * Math.PI) / nodes.length;
    let positions = {};
    nodes.forEach((node, i) => {
      const angle = i * angleStep;
      const x = centerX + radius * Math.cos(angle);
      const y = centerY + radius * Math.sin(angle);
      positions[node] = { x, y };
    });
    return positions;
  }

  // Draw graph on canvas
  function drawGraph(adj) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const nodes = Object.keys(adj);
    nodePositions = layoutNodes(nodes);

    // Draw edges
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 2;
    ctx.font = "14px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    for (const from of nodes) {
      const fromPos = nodePositions[from];
      for (const to of adj[from]) {
        const toPos = nodePositions[to];
        drawArrow(fromPos, toPos);
      }
    }

    // Draw nodes
    for (const node of nodes) {
      const { x, y } = nodePositions[node];
      drawNode(x, y, node);
    }
  }

  // Draw a circle node
  function drawNode(x, y, label) {
    const radius = 20;
    // Circle
    ctx.fillStyle = "#2980b9";
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, 2 * Math.PI);
    ctx.fill();
    // Label
    ctx.fillStyle = "white";
    ctx.fillText(label, x, y);
  }

  // Draw arrow from point A to B
  function drawArrow(from, to) {
    const headLength = 10;
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const angle = Math.atan2(dy, dx);
    // Draw line shortened a bit to not overlap circle
    const radius = 20;
    const startX = from.x + radius * Math.cos(angle);
    const startY = from.y + radius * Math.sin(angle);
    const endX = to.x - radius * Math.cos(angle);
    const endY = to.y - radius * Math.sin(angle);

    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();

    // Draw arrowhead
    ctx.beginPath();
    ctx.moveTo(endX, endY);
    ctx.lineTo(
      endX - headLength * Math.cos(angle - Math.PI / 6),
      endY - headLength * Math.sin(angle - Math.PI / 6)
    );
    ctx.lineTo(
      endX - headLength * Math.cos(angle + Math.PI / 6),
      endY - headLength * Math.sin(angle + Math.PI / 6)
    );
    ctx.lineTo(endX, endY);
    ctx.fillStyle = "#666";
    ctx.fill();
  }

  // Main button click handler
  buildBtn.addEventListener("click", () => {
    clearDisplay();
    const input = inputEl.value;
    if (!input.trim()) {
      errorMsg.textContent = "Please enter at least one edge.";
      return;
    }
    try {
      graph = parseInput(input);
      displayAdjList(graph);
      drawGraph(graph);
    } catch (err) {
      errorMsg.textContent = err.message;
    }
  });

  // Prefill example data
  inputEl.value = `A B
A C
B D
C D
D E`;
  // Automatically build graph on load
  buildBtn.click();
})();
</script>
</body>
</html>