<!DOCTYPE html>
```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Huffman Coding Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 2rem;
    background: #f0f4f8;
    color: #333;
  }
  h1 {
    text-align: center;
    color: #155a8a;
  }
  textarea {
    width: 100%;
    height: 100px;
    font-family: monospace;
    font-size: 1.1rem;
    padding: 0.5rem;
    border-radius: 4px;
    border: 1px solid #aaa;
    resize: vertical;
  }
  button {
    margin-top: 1rem;
    padding: 0.6rem 1.2rem;
    font-size: 1rem;
    border: none;
    border-radius: 4px;
    background-color: #1e88e5;
    color: white;
    cursor: pointer;
  }
  button:hover {
    background-color: #1669bb;
  }
  .output-section {
    margin-top: 2rem;
    background: white;
    padding: 1rem 1.5rem;
    border-radius: 6px;
    box-shadow: 0 0 12px rgb(0 0 0 / 0.1);
  }
  h2 {
    color: #155a8a;
  }
  pre {
    background: #e8f0fe;
    padding: 1rem;
    border-radius: 5px;
    overflow-x: auto;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    max-width: 400px;
    margin-top: 0.5rem;
  }
  th, td {
    border: 1px solid #ccc;
    padding: 0.25rem 0.5rem;
    text-align: center;
  }
  th {
    background-color: #e3f2fd;
  }
  #tree-svg {
    margin-top: 1rem;
    overflow-x: auto;
  }
  svg text {
    font-family: monospace;
    font-size: 12px;
    fill: #222;
  }
  .node circle {
    fill: #1e88e5;
    stroke: #0f5ea8;
    stroke-width: 2;
  }
  .leaf circle {
    fill: #43a047;
  }
  .edge-text {
    fill: #b71c1c;
    font-weight: bold;
  }
</style>
</head>
<body>

<h1>Huffman Coding Demonstration</h1>

<label for="inputText">Enter text to encode with Huffman coding:</label>
<textarea id="inputText" placeholder="Type some text here..."></textarea>
<button id="encodeBtn">Encode</button>

<div class="output-section" id="output" style="display:none;">
  <h2>Results:</h2>
  <div>
    <strong>Frequency Table:</strong>
    <table id="freqTable">
      <thead>
        <tr><th>Character</th><th>Frequency</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div>
    <strong>Huffman Codes:</strong>
    <table id="codeTable">
      <thead>
        <tr><th>Character</th><th>Code</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div>
    <strong>Encoded Binary String:</strong>
    <pre id="encodedBin"></pre>
  </div>

  <div>
    <strong>Original String Length:</strong> <span id="origBits"></span> bits<br/>
    <strong>Encoded Length:</strong> <span id="encodedBits"></span> bits<br/>
    <strong>Compression Ratio:</strong> <span id="compressionRatio"></span>
  </div>

  <div>
    <strong>Decoded Text:</strong>
    <pre id="decodedText"></pre>
  </div>

  <div>
    <strong>Huffman Tree Visualization:</strong>
    <div id="tree-svg"></div>
  </div>
</div>

<script>
// Huffman coding implementation

// Node class for Huffman tree
class Node {
  constructor(char, freq, left=null, right=null) {
    this.char = char;
    this.freq = freq;
    this.left = left;
    this.right = right;
  }
  isLeaf() {
    return !this.left && !this.right;
  }
}

// Build frequency map from input string
function buildFrequencyTable(str) {
  const freq = new Map();
  for (const ch of str) {
    freq.set(ch, (freq.get(ch) || 0) + 1);
  }
  return freq;
}

// Build Huffman tree given frequency map
function buildHuffmanTree(freqMap) {
  let nodes = [];

  for (const [char, freq] of freqMap.entries()) {
    nodes.push(new Node(char, freq));
  }

  // Build tree:
  while (nodes.length > 1) {
    // Sort by freq ascending
    nodes.sort((a,b) => a.freq - b.freq);

    // Take two smallest
    const left = nodes.shift();
    const right = nodes.shift();

    // Create new merged node
    const merged = new Node(null, left.freq + right.freq, left, right);

    // Add back to nodes
    nodes.push(merged);
  }
  return nodes[0];
}

// Generate code map from tree
function generateCodes(node, prefix = '', codes = {}) {
  if (!node) return codes;
  if (node.isLeaf()) {
    codes[node.char] = prefix || '0'; // Handle single char case
  } else {
    generateCodes(node.left, prefix + '0', codes);
    generateCodes(node.right, prefix + '1', codes);
  }
  return codes;
}

// Encode string using code map
function encodeString(str, codes) {
  let result = '';
  for (const ch of str) {
    result += codes[ch];
  }
  return result;
}

// Decode the binary string using Huffman tree
function decodeString(encodedStr, tree) {
  let result = '';
  let node = tree;
  for (const bit of encodedStr) {
    node = bit === '0' ? node.left : node.right;
    if (node.isLeaf()) {
      result += node.char;
      node = tree;
    }
  }
  return result;
}

// Drawing the tree visualization
function drawTreeSVG(root) {
  // Clear previous
  const container = document.getElementById('tree-svg');
  container.innerHTML = '';

  if (!root) return;

  // We'll do a simple top-down tree layout using DFS traversal
  // Compute positions:

  let nodes = [];
  let edges = [];

  // Assign x position based on inorder traversal
  let xCounter = 0;
  function assignX(node) {
    if (!node) return;
    assignX(node.left);
    node.x = xCounter++;
    assignX(node.right);
  }
  assignX(root);

  // Assign y position based on depth
  function assignY(node, depth=0) {
    if (!node) return;
    node.y = depth;
    assignY(node.left, depth + 1);
    assignY(node.right, depth + 1);
  }
  assignY(root);

  // Collect nodes and edges
  function collect(node) {
    if (!node) return;
    nodes.push(node);
    if (node.left) edges.push({from: node, to: node.left, label: '0'});
    if (node.right) edges.push({from: node, to: node.right, label: '1'});
    collect(node.left);
    collect(node.right);
  }
  collect(root);

  // SVG parameters
  const nodeRadius = 15;
  const hSpacing = 50;
  const vSpacing = 70;
  const width = (xCounter + 1) * hSpacing;
  const height = (Math.max(...nodes.map(n=>n.y)) + 2) * vSpacing;

  const svgns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgns, "svg");
  svg.setAttribute('width', width);
  svg.setAttribute('height', height);

  // Draw edges first
  for (const edge of edges) {
    const x1 = edge.from.x * hSpacing + hSpacing;
    const y1 = edge.from.y * vSpacing + vSpacing;
    const x2 = edge.to.x * hSpacing + hSpacing;
    const y2 = edge.to.y * vSpacing + vSpacing;

    // Line
    const line