<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Priority Queue Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 2rem;
    max-width: 600px;
  }
  h1 {
    text-align: center;
  }
  label {
    display: block;
    margin-top: 1rem;
  }
  input[type="text"], input[type="number"] {
    width: 100%;
    padding: 0.4rem;
    margin-top: 0.3rem;
    box-sizing: border-box;
  }
  button {
    margin-top: 1rem;
    padding: 0.5rem 1rem;
  }
  #queue {
    margin-top: 2rem;
    border: 1px solid #bbb;
    border-radius: 4px;
    min-height: 60px;
    padding: 0.5rem;
    background: #f9f9f9;
  }
  #log {
    margin-top: 1rem;
    background: #eef;
    padding: 0.5rem;
    height: 100px;
    overflow-y: auto;
    font-family: monospace;
    border-radius: 4px;
    border: 1px solid #ccd;
  }
</style>
</head>
<body>
<h1>Priority Queue Demo</h1>
<form id="pqForm">
  <label>
    Element (string):
    <input type="text" id="element" required />
  </label>
  <label>
    Priority (number, lower = higher priority):
    <input type="number" id="priority" required />
  </label>
  <button type="submit">Enqueue</button>
  <button type="button" id="dequeueBtn">Dequeue</button>
  <button type="button" id="peekBtn">Peek</button>
  <button type="button" id="clearBtn">Clear Queue</button>
</form>

<h2>Queue State (front → back):</h2>
<div id="queue">(empty)</div>

<h2>Operations Log:</h2>
<div id="log"></div>

<script>
// Priority Queue implemented as a min-heap for efficient priority management
class PriorityQueue {
  constructor() {
    this.heap = [];
  }

  // Helper methods for heap index calculations
  _parent(idx) { return Math.floor((idx - 1) / 2); }
  _leftChild(idx) { return idx * 2 + 1; }
  _rightChild(idx) { return idx * 2 + 2; }

  _swap(i, j) {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }

  // Insert element with priority
  enqueue(element, priority) {
    const node = { element, priority };
    this.heap.push(node);
    this._bubbleUp(this.heap.length - 1);
  }

  // Remove and return the element with the highest priority (lowest priority number)
  dequeue() {
    if (this.isEmpty()) return null;
    const top = this.heap[0];
    const last = this.heap.pop();
    if (!this.isEmpty()) {
      this.heap[0] = last;
      this._bubbleDown(0);
    }
    return top;
  }

  peek() {
    return this.isEmpty() ? null : this.heap[0];
  }

  isEmpty() {
    return this.heap.length === 0;
  }

  size() {
    return this.heap.length;
  }

  clear() {
    this.heap = [];
  }

  _bubbleUp(idx) {
    while (idx > 0) {
      const parentIdx = this._parent(idx);
      if (this.heap[parentIdx].priority <= this.heap[idx].priority) break;
      this._swap(parentIdx, idx);
      idx = parentIdx;
    }
  }

  _bubbleDown(idx) {
    const length = this.heap.length;
    while (true) {
      let leftIdx = this._leftChild(idx);
      let rightIdx = this._rightChild(idx);
      let smallest = idx;

      if (leftIdx < length &&
          this.heap[leftIdx].priority < this.heap[smallest].priority) {
        smallest = leftIdx;
      }

      if (rightIdx < length &&
          this.heap[rightIdx].priority < this.heap[smallest].priority) {
        smallest = rightIdx;
      }

      if (smallest === idx) break;

      this._swap(idx, smallest);
      idx = smallest;
    }
  }

  toArray() {
    // Return array copy sorted by priority for display purposes (does not alter original heap)
    return [...this.heap].sort((a,b)=>a.priority - b.priority);
  }
}

/////// UI Logic ///////

const pq = new PriorityQueue();
const form = document.getElementById('pqForm');
const elementInput = document.getElementById('element');
const priorityInput = document.getElementById('priority');
const queueDiv = document.getElementById('queue');
const logDiv = document.getElementById('log');
const dequeueBtn = document.getElementById('dequeueBtn');
const peekBtn = document.getElementById('peekBtn');
const clearBtn = document.getElementById('clearBtn');

function log(msg) {
  const time = new Date().toLocaleTimeString();
  logDiv.textContent += `[${time}] ${msg}\n`;
  logDiv.scrollTop = logDiv.scrollHeight;
}

function updateQueueDisplay() {
  if (pq.isEmpty()) {
    queueDiv.textContent = '(empty)';
  } else {
    // Display from front (highest priority) to back (lowest priority)
    // We use toArray() which is sorted by priority
    const arr = pq.toArray();
    const display = arr.map(({element, priority}) =>
      `"${element}" (priority: ${priority})`
    ).join(' → ');
    queueDiv.textContent = display;
  }
}

form.addEventListener('submit', e => {
  e.preventDefault();
  const element = elementInput.value.trim();
  const priorityStr = priorityInput.value.trim();

  if (element === '') {
    alert('Element must not be empty.');
    return;
  }
  const priority = Number(priorityStr);
  if (isNaN(priority)) {
    alert('Priority must be a valid number.');
    return;
  }

  pq.enqueue(element, priority);
  log(`Enqueued element "${element}" with priority ${priority}.`);
  updateQueueDisplay();

  // Clear inputs for convenience
  elementInput.value = '';
  priorityInput.value = '';
  elementInput.focus();
});

dequeueBtn.addEventListener('click', () => {
  if (pq.isEmpty()) {
    log('Dequeue attempted but queue is empty.');
    alert('Queue is empty.');
    return;
  }
  const node = pq.dequeue();
  log(`Dequeued element "${node.element}" with priority ${node.priority}.`);
  updateQueueDisplay();
});

peekBtn.addEventListener('click', () => {
  if (pq.isEmpty()) {
    log('Peek attempted but queue is empty.');
    alert('Queue is empty.');
    return;
  }
  const node = pq.peek();
  log(`Peeked at element "${node.element}" with priority ${node.priority}.`);
  alert(`Front element: "${node.element}" with priority ${node.priority}`);
});

clearBtn.addEventListener('click', () => {
  pq.clear();
  log('Cleared the queue.');
  updateQueueDisplay();
});

updateQueueDisplay();
log('Priority Queue initialized.');
</script>
</body>
</html>