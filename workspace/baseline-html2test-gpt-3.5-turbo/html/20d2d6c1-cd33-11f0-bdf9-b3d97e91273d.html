<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Depth-First Search (DFS) Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f0f4f8;
    color: #333;
  }
  h1 {
    text-align: center;
  }
  #graph-container {
    display: flex;
    justify-content: center;
    margin-top: 20px;
  }
  svg {
    background: white;
    border: 1px solid #ccc;
    border-radius: 8px;
  }
  circle.node {
    fill: #1f77b4;
    stroke: #215a8e;
    stroke-width: 2px;
    cursor: pointer;
    transition: fill 0.3s;
  }
  circle.node.visited {
    fill: #ff7f0e;
  }
  circle.node.current {
    fill: #d62728;
  }
  line.edge {
    stroke: #999;
    stroke-width: 2px;
    transition: stroke 0.3s;
  }
  line.edge.visited {
    stroke: #ff7f0e;
    stroke-width: 3px;
  }
  #controls {
    text-align: center;
    margin-top: 15px;
  }
  #start-node {
    width: 50px;
    font-size: 16px;
    text-align: center;
  }
  button {
    font-size: 16px;
    margin-left: 10px;
    padding: 6px 12px;
    cursor: pointer;
  }
  #log {
    margin-top: 20px;
    background: #fff;
    border-radius: 8px;
    padding: 10px;
    height: 120px;
    overflow-y: auto;
    box-shadow: 0 0 5px #ccc;
    font-family: monospace;
    font-size: 14px;
  }
  #log strong {
    color: #d62728;
  }
  #info {
    max-width: 650px;
    margin: 0 auto 15px auto;
    font-size: 16px;
    line-height: 1.4;
    color: #444;
  }
  a {
    color: #1f77b4;
  }
</style>
</head>
<body>
<h1>Depth-First Search (DFS) Visualization</h1>
<div id="info">
  <p>
    This visualization demonstrates <strong>Depth-First Search (DFS)</strong> on a directed graph.
    Click the <em>Start DFS</em> button to explore the graph starting from the chosen starting node.
    Nodes and edges will be highlighted as DFS visits them.
  </p>
  <p>
    You can change the start node by entering its number (0 to 6) below.
  </p>
  <p style="font-size:0.9em; color:#666;">
    Created by ChatGPT. Learn more about DFS on
    <a href="https://en.wikipedia.org/wiki/Depth-first_search" target="_blank" rel="noopener">Wikipedia</a>.
  </p>
</div>
<div id="graph-container">
  <svg id="graph" width="700" height="400" aria-label="Graph visualization" role="img"></svg>
</div>
<div id="controls">
  Start node: <input type="number" id="start-node" min="0" max="6" value="0" />
  <button id="start-btn">Start DFS</button>
  <button id="reset-btn">Reset</button>
</div>
<div id="log" aria-live="polite" aria-atomic="false" role="log"></div>

<script>
(() => {
  // Graph definition: adjacency list
  const graph = {
    0: [1, 2],
    1: [3, 4],
    2: [5],
    3: [],
    4: [5],
    5: [6],
    6: []
  };

  // Node positions for visualization (x,y)
  const nodePositions = {
    0: {x: 100, y: 50},
    1: {x: 200, y: 130},
    2: {x: 200, y: -10},
    3: {x: 300, y: 70},
    4: {x: 300, y: 190},
    5: {x: 400, y: 60},
    6: {x: 500, y: 120}
  };

  // Normalize Y positions for SVG
  // (We can shift every y by +100 for positive coords)
  Object.keys(nodePositions).forEach(k => (nodePositions[k].y += 100));

  // Elements
  const svg = document.getElementById("graph");
  const startInput = document.getElementById("start-node");
  const startBtn = document.getElementById("start-btn");
  const resetBtn = document.getElementById("reset-btn");
  const logElem = document.getElementById("log");

  // State
  let visited = new Set();
  let currentStack = [];
  let animating = false;

  // Clear log
  function log(msg, highlight=false) {
    const div = document.createElement("div");
    div.textContent = msg;
    if (highlight) {
      div.style.fontWeight = 'bold';
      div.style.color = '#d62728';
    }
    logElem.appendChild(div);
    logElem.scrollTop = logElem.scrollHeight;
  }

  // Draw the graph: nodes and edges
  // We will create SVG lines for edges, and circles + text for nodes
  // We'll keep references for dynamic color updates
  const edgesElements = [];
  const nodesElements = [];

  function createArrowMarker() {
    const marker = document.createElementNS("http://www.w3.org/2000/svg","marker");
    marker.setAttribute("id","arrowhead");
    marker.setAttribute("markerWidth","10");
    marker.setAttribute("markerHeight","7");
    marker.setAttribute("refX","10");
    marker.setAttribute("refY","3.5");
    marker.setAttribute("orient","auto");
    marker.setAttribute("markerUnits","strokeWidth");
    const path = document.createElementNS("http://www.w3.org/2000/svg","path");
    path.setAttribute("d","M0,0 L10,3.5 L0,7 Z");
    path.setAttribute("fill","#999");
    marker.appendChild(path);
    return marker;
  }

  function drawGraph() {
    // Clear previous
    svg.innerHTML = "";

    // Defining arrowhead marker for directed edges
    const defs = document.createElementNS("http://www.w3.org/2000/svg","defs");
    defs.appendChild(createArrowMarker());
    svg.appendChild(defs);

    // Draw edges first (lines)
    edgesElements.length = 0;
    for (const from in graph) {
      const fromPos = nodePositions[from];
      for (const to of graph[from]) {
        const toPos = nodePositions[to];
        
        // Draw line with arrow marker at end
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");

        // To avoid line overlaps with nodes, compute vector and offset ends by radius
        const dx = toPos.x - fromPos.x;
        const dy = toPos.y - fromPos.y;
        const len = Math.sqrt(dx*dx + dy*dy);
        const r = 20; // radius of node circle

        const offsetX = (dx / len) * r;
        const offsetY = (dy / len) * r;

        line.setAttribute("x1", fromPos.x + offsetX);
        line.setAttribute("y1", fromPos.y + offsetY);
        line.setAttribute("x2", toPos.x - offsetX);
        line.setAttribute("y2", toPos.y - offsetY);
        line.setAttribute("stroke", "#999");
        line.setAttribute("stroke-width", "2");
        line.setAttribute("class", "edge");
        line.setAttribute("marker-end", "url(#arrowhead)");
        svg.appendChild(line);

        edgesElements.push({from: parseInt(from), to: to, element: line});
      }
    }

    // Draw nodes on top
    nodesElements.length = 0;
    for (const id in nodePositions) {
      const pos = nodePositions[id];

      // Circle
      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("cx", pos.x);
      circle.setAttribute("cy", pos.y);
      circle.setAttribute("r", 20);
      circle.setAttribute("fill", "#1f77b4");
      circle.setAttribute("stroke", "#215a8e");
      circle.setAttribute("stroke-width", "2");
      circle.setAttribute("class", "node");
      circle.setAttribute("tabindex", "0");
      circle.setAttribute("aria-label", `Node ${id}`);

      // Tooltip on hover
      circle.setAttribute("title", `Node ${id}`);

      // Label (number)
      const text = document.createElementNS("http://www.w3.org/2000/svg","text");
      text.setAttribute("x", pos.x);
      text.setAttribute("y", pos.y + 5);
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("font-size", "16px");
      text.setAttribute("fill", "white");
      text.setAttribute("pointer-events", "none");
      text.textContent = id;

      svg.appendChild(circle);
      svg.appendChild(text);

      nodesElements.push({id: parseInt(id), circle, text});
    }
  }

  // Reset graph colors and state
  function resetGraph() {
    visited.clear();
    currentStack = [];
    animating = false;
    logElem.innerHTML = "";
    for (const node of nodesElements) {
      node.circle.classList.remove("visited", "current");
      node.circle.style.fill = "#1f77b4";
      node.circle.style.stroke = "#215a8e";
    }
    for (const edge of edgesElements) {
      edge.element.classList.remove("visited");
      edge.element.style.stroke = "#999";
      edge.element.style.strokeWidth = "2";
    }
  }


  // Utility: find the edge element connecting u->v
  function findEdgeElement(u,v) {
    return edgesElements.find(e => e.from === u && e.to == v);
  }

  // Delay promise helper
  function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // DFS animation - iterative or recursive? Recursive with async is simpler to demonstrate step-by-step
  async function dfsVisit(node) {
    if (visited.has(node)) return;
    // Mark current node
    visited.add(node);

    // Highlight current node
    const nodeElem = nodesElements.find(n => n.id === node);
    if (!nodeElem) return;

    nodeElem.circle.classList.add("current");
    log(`Visiting node ${node}`, true);
    await delay(800);

    nodeElem.circle.classList.remove("current");
    nodeElem.circle.classList.add("visited");
    nodeElem.circle.style.fill = "#ff7f0e";

    // Visit edges & neighbors
    for (const neighbor of graph[node]) {
      const edgeElem = findEdgeElement(node, neighbor);
      if (edgeElem && !visited.has(neighbor)) {
        // Highlight edge as next to visit
        edgeElem.element.classList.add("visited");
        edgeElem.element.style.stroke = "#ff7f0e";
        edgeElem.element.style.strokeWidth = "3";

        log(`Traversing edge ${node} â†’ ${neighbor}`);
        await delay(600);

        await dfsVisit(neighbor);
      }
    }
  }

  async function startDFS() {
    if (animating) return;
    animating = true;
    resetGraph();

    let startNode = parseInt(startInput.value);
    if (!(startNode in graph)) {
      alert("Start node must be between 0 and 6.");
      animating = false;
      return;
    }

    log(`Starting DFS from node ${startNode}`, true);
    await dfsVisit(startNode);

    log("DFS Complete.", true);
    animating = false;
  }

  // Setup event listeners
  startBtn.addEventListener("click", startDFS);

  resetBtn.addEventListener("click", () => {
    if(animating){
      alert("Wait for current DFS to finish or refresh the page.");
      return;
    }
    resetGraph();
    log("Reset graph.");
  });

  startInput.addEventListener("change", () => {
    const val = parseInt(startInput.value);
    if (isNaN(val) || val < 0 || val > 6) {
      startInput.value = 0;
    }
  });

  // Initial draw
  drawGraph();
  resetGraph();
  log("Enter a start node and click 'Start DFS' to begin.");
})();
</script>
</body>
</html>