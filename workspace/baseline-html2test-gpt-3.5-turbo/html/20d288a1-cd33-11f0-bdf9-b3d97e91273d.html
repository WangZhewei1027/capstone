<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Red-Black Tree Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background: #f7f7f7;
    user-select: none;
  }
  h1 {
    text-align: center;
    color: #333;
    margin: 1rem 0 0.2rem;
  }
  #controls {
    text-align: center;
    margin: 10px 0 20px;
  }
  input[type=number] {
    padding: 0.4rem;
    font-size: 1rem;
    width: 100px;
    margin-right: 0.5rem;
  }
  button {
    padding: 0.45rem 0.8rem;
    font-size: 1rem;
    cursor: pointer;
    border-radius: 4px;
    border: none;
    background-color: #0077cc;
    color: white;
    transition: background-color 0.3s ease;
  }
  button:hover:not(:disabled) {
    background-color: #005fa3;
  }
  button:disabled {
    background-color: #aaa;
    cursor: not-allowed;
  }
  #message {
    text-align: center;
    margin: 5px 0 15px;
    font-weight: bold;
    color: #444;
  }
  #canvasContainer {
    display: flex;
    justify-content: center;
    overflow-x: auto;
    padding-bottom: 20px;
  }
  canvas {
    background: white;
    box-shadow: 0 0 8px rgba(0,0,0,0.1);
    border-radius: 8px;
  }
  #legend {
    max-width: 600px;
    margin: 0 auto 20px;
    font-size: 0.9rem;
    color: #444;
    display: flex;
    justify-content: center;
    gap: 20px;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .circle-sample {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    display: inline-block;
    border: 2px solid black;
  }
  .red-node {
    background-color: #d33a3a;
  }
  .black-node {
    background-color: #222;
  }
</style>
</head>
<body>

<h1>Red-Black Tree Visualization</h1>
<div id="controls">
  <input type="number" id="inputValue" placeholder="Enter value" />
  <button id="insertBtn">Insert</button>
  <button id="clearBtn">Clear Tree</button>
</div>
<div id="message"></div>
<div id="legend">
  <div class="legend-item"><span class="circle-sample red-node"></span> Red Node</div>
  <div class="legend-item"><span class="circle-sample black-node"></span> Black Node</div>
  <div class="legend-item" style="color:#555;">Black edges are parent-child links</div>
</div>
<div id="canvasContainer">
  <canvas id="rbtCanvas" width="1000" height="500"></canvas>
</div>

<script>
// Red-Black Tree Implementation with Visualization

class RBNode {
  constructor(value, color, parent = null, left = null, right = null) {
    this.value = value;
    this.color = color; // "RED" or "BLACK"
    this.parent = parent;
    this.left = left;
    this.right = right;
  }
  isRed() { return this.color === "RED"; }
  isBlack() { return this.color === "BLACK"; }
}

class RedBlackTree {
  constructor() {
    this.NULL_LEAF = new RBNode(null, "BLACK"); // sentinel leaf, shared
    this.root = this.NULL_LEAF;
  }

  insert(value) {
    // Normal BST insert
    let newNode = new RBNode(value, "RED", null, this.NULL_LEAF, this.NULL_LEAF);
    if (this.root === this.NULL_LEAF) {
      this.root = newNode;
      this.root.color = "BLACK";
      return true;
    }
    let current = this.root;
    let parent = null;
    while (current !== this.NULL_LEAF) {
      parent = current;
      if (value === current.value) {
        return false; // No duplicates allowed
      } else if (value < current.value) {
        current = current.left;
      } else {
        current = current.right;
      }
    }
    newNode.parent = parent;
    if (value < parent.value) {
      parent.left = newNode;
    } else {
      parent.right = newNode;
    }
    this.fixInsertion(newNode);
    return true;
  }

  leftRotate(x) {
    const y = x.right;
    x.right = y.left;
    if (y.left !== this.NULL_LEAF) {
      y.left.parent = x;
    }
    y.parent = x.parent;
    if (x.parent === null) { // x was root
      this.root = y;
    } else if (x === x.parent.left) {
      x.parent.left = y;
    } else {
      x.parent.right = y;
    }
    y.left = x;
    x.parent = y;
  }
  rightRotate(x) {
    const y = x.left;
    x.left = y.right;
    if (y.right !== this.NULL_LEAF) {
      y.right.parent = x;
    }
    y.parent = x.parent;
    if (x.parent === null) { // x was root
      this.root = y;
    } else if (x === x.parent.right) {
      x.parent.right = y;
    } else {
      x.parent.left = y;
    }
    y.right = x;
    x.parent = y;
  }

  fixInsertion(z) {
    while (z.parent && z.parent.isRed()) {
      if (z.parent === z.parent.parent.left) {
        let y = z.parent.parent.right; // uncle
        if (y.isRed()) {
          // Case 1
          z.parent.color = "BLACK";
          y.color = "BLACK";
          z.parent.parent.color = "RED";
          z = z.parent.parent;
        } else {
          if (z === z.parent.right) {
            // Case 2
            z = z.parent;
            this.leftRotate(z);
          }
          // Case 3
          z.parent.color = "BLACK";
          z.parent.parent.color = "RED";
          this.rightRotate(z.parent.parent);
        }
      } else {
        // Mirror of above case
        let y = z.parent.parent.left; // uncle
        if (y.isRed()) {
          // Case 1
          z.parent.color = "BLACK";
          y.color = "BLACK";
          z.parent.parent.color = "RED";
          z = z.parent.parent;
        } else {
          if (z === z.parent.left) {
            // Case 2
            z = z.parent;
            this.rightRotate(z);
          }
          // Case 3
          z.parent.color = "BLACK";
          z.parent.parent.color = "RED";
          this.leftRotate(z.parent.parent);
        }
      }
    }
    this.root.color = "BLACK";
  }

  clear() {
    this.root = this.NULL_LEAF;
  }
}


// Drawing and UI logic

const canvas = document.getElementById('rbtCanvas');
const ctx = canvas.getContext('2d');
const tree = new RedBlackTree();

const NODE_RADIUS = 20;
const VERTICAL_DIST = 70;
const HORIZONTAL_GAP_BASE = 40; // base horizontal gap, expands with depth

function clearCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function drawNode(x, y, node) {
  // Draw the circle
  ctx.beginPath();
  ctx.arc(x, y, NODE_RADIUS, 0, 2 * Math.PI, false);
  ctx.fillStyle = node.isRed() ? '#d33a3a' : '#222222';
  ctx.fill();
  ctx.lineWidth = 3;
  ctx.strokeStyle = '#000000';
  ctx.stroke();
  ctx.closePath();

  // Draw the value text
  ctx.fillStyle = 'white';
  ctx.font = '16px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(node.value, x, y);

  // Draw a small white circle inside black node (optional for style)
  // if (node.isBlack()) {
  //   ctx.beginPath();
  //   ctx.arc(x, y, 6, 0, 2 * Math.PI);
  //   ctx.fillStyle = '#555555';
  //   ctx.fill();
  //   ctx.closePath();
  // }
}

function drawEdge(x1, y1, x2, y2) {
  ctx.beginPath();
  ctx.strokeStyle = '#000000';
  ctx.lineWidth = 2;
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  ctx.closePath();
}

function computePositions(root) {
  // We compute the x position of nodes to keep the tree balanced
  // We'll do a recursive post-order traversal assigning x coords

  let positions = new Map();

  function assignX(node, depth) {
    if (node === tree.NULL_LEAF) return 0;

    let leftWidth = assignX(node.left, depth + 1);
    let rightWidth = assignX(node.right, depth + 1);

    // For leaf nodes, width is 1 unit
    if (leftWidth === 0 && rightWidth === 0) leftWidth = rightWidth = 0;

    let x;
    if (leftWidth === 0 && rightWidth === 0) {
      // Leaf node
      x = 1;
    } else if (leftWidth === 0) {
      x = rightWidth;
    } else if (rightWidth === 0) {
      x = leftWidth;
    } else {
      x = (leftWidth + rightWidth);
    }

    positions.set(node, {depth, width: x});
    return x;
  }
  assignX(root, 0);

  // Now assign actual x coordinates

  let xOffset = 0;
  let coords = new Map();

  function setCoords(node, depth) {
    if (node === tree.NULL_LEAF) return;
    let pos = positions.get(node);

    if (node.left !== tree.NULL_LEAF) setCoords(node.left, depth + 1);

    let x = xOffset + 1;
    coords.set(node, {x, y: depth});

    xOffset += 2; // spacing nodes by 2 units horizontally (can be adjusted)

    if (node.right !== tree.NULL_LEAF) setCoords(node.right, depth + 1);
  }
  xOffset = 0;
  setCoords(root, 0);

  return coords;
}

function drawTree() {
  clearCanvas();
  if (tree.root === tree.NULL_LEAF) return;

  // Compute positions
  // For better horizontal spacing, we use an inorder traversal assigning incremental x
  let coords = new Map();
  let xCount = 0;

  function setCoordsInOrder(node, depth) {
    if (node === tree.NULL_LEAF) return;
    setCoordsInOrder(node.left, depth + 1);
    coords.set(node, {x: xCount, y: depth});
    xCount++;
    setCoordsInOrder(node.right, depth + 1);
  }
  setCoordsInOrder(tree.root, 0);


  // Calculate horizontal scale to fit canvas width
  let totalNodes = xCount;
  let hGap = Math.max(HORIZONTAL_GAP_BASE, canvas.width / (totalNodes + 1));

  // Calculate vertical gap scaling if needed (fixed vertical distance)
  let vGap = VERTICAL_DIST;

  // Draw edges first
  coords.forEach((coord, node) => {
    if (node === tree.NULL_LEAF) return;
    if (node.left !== tree.NULL_LEAF) {
      let cLeft = coords.get(node.left);
      drawEdge(coord.x * hGap + NODE_RADIUS, coord.y * vGap + NODE_RADIUS, cLeft.x * hGap + NODE_RADIUS, cLeft.y * vGap + NODE_RADIUS);
    }
    if (node.right !== tree.NULL_LEAF) {
      let cRight = coords.get(node.right);
      drawEdge(coord.x * hGap + NODE_RADIUS, coord.y * vGap + NODE_RADIUS, cRight.x * hGap + NODE_RADIUS, cRight.y * vGap + NODE_RADIUS);
    }
  });

  // Draw nodes on top
  coords.forEach((coord, node) => {
    if (node === tree.NULL_LEAF) return;
    drawNode(coord.x * hGap + NODE_RADIUS, coord.y * vGap + NODE_RADIUS, node);
  });
}

// UI Elements
const inputValue = document.getElementById('inputValue');
const insertBtn = document.getElementById('insertBtn');
const clearBtn = document.getElementById('clearBtn');
const message = document.getElementById('message');

function showMessage(msg, isError = false) {
  message.textContent = msg;
  message.style.color = isError ? 'crimson' : 'green';
  setTimeout(() => {
    message.textContent = '';
  }, 3500);
}

insertBtn.addEventListener('click', () => {
  let val = inputValue.value.trim();
  if (val === '') {
    showMessage('Please enter a value to insert.', true);
    return;
  }
  // Support integers only for simplicity
  let numVal = Number(val);
  if (Number.isNaN(numVal)) {
    showMessage('Please enter a valid number.', true);
    return;
  }
  if (!Number.isInteger(numVal)) {
    showMessage('Please enter an integer value.', true);
    return;
  }

  let success = tree.insert(numVal);
  if (!success) {
    showMessage(`Value ${numVal} already exists in the tree.`, true);
    return;
  }
  showMessage(`Inserted value ${numVal} into the tree.`);
  inputValue.value = '';
  drawTree();
});

inputValue.addEventListener('keydown', e => {
  if (e.key === 'Enter') insertBtn.click();
});

clearBtn.addEventListener('click', () => {
  tree.clear();
  drawTree();
  showMessage(`Red-Black Tree cleared.`);
  inputValue.value = '';
  inputValue.focus();
});

window.addEventListener('resize', () => {
  // Optional: resize canvas or redraw
  drawTree();
});

// Initial draw
drawTree();

</script>

</body>
</html>