<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Binary Tree Visualization & Traversal</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0; padding: 0; background: #f0f0f0;
  }
  header {
    background: #333;
    color: white;
    padding: 1em;
    text-align: center;
  }
  #container {
    display: flex;
    flex-direction: row;
    height: calc(100vh - 70px);
  }
  #treeCanvas {
    background: white;
    flex-grow: 1;
    border-right: 1px solid #ccc;
  }
  #controls {
    width: 320px;
    background: white;
    padding: 1em;
    box-sizing: border-box;
    overflow-y: auto;
  }
  h2 {
    margin-top: 0;
  }
  label, button {
    display: block;
    margin-top: 1em;
  }
  input[type="number"] {
    width: 100%;
    padding: 0.4em;
    font-size: 1em;
    box-sizing: border-box;
  }
  button {
    padding: 0.7em;
    font-size: 1em;
    cursor: pointer;
  }
  #traversalOutput {
    background: #eef;
    padding: 0.8em;
    margin-top: 0.5em;
    min-height: 2em;
    border-radius: 4px;
    font-weight: bold;
  }
  #message {
    color: red;
    margin-top: 0.5em;
    min-height: 1em;
  }
  #legend {
    margin-top: 2em;
    font-size: 0.9em;
    color: #555;
  }
</style>
</head>
<body>
<header>
  <h1>Binary Tree Visualizer</h1>
</header>
<div id="container">
  <canvas id="treeCanvas" width="800" height="600" aria-label="Binary tree visualization" role="img"></canvas>
  <div id="controls" aria-label="Controls to create and traverse binary tree">
    <h2>Manage Tree</h2>
    <label for="nodeValueInput">Node Value (integer):</label>
    <input type="number" id="nodeValueInput" aria-describedby="nodeValueDesc" />
    <div id="nodeValueDesc" style="font-size:0.8em;color:#555;">
      Enter the integer value for the node to insert or delete.
    </div>
    <button id="insertBtn">Insert Node</button>
    <button id="deleteBtn">Delete Node</button>

    <h2>Traversal</h2>
    <button data-traversal="inorder" class="traversalBtn">In-order Traversal</button>
    <button data-traversal="preorder" class="traversalBtn">Pre-order Traversal</button>
    <button data-traversal="postorder" class="traversalBtn">Post-order Traversal</button>
    <button data-traversal="levelorder" class="traversalBtn">Level-order Traversal</button>

    <div id="traversalOutput" aria-live="polite" aria-atomic="true"></div>
    <div id="message" role="alert"></div>

    <div id="legend">
      <strong>Legend:</strong><br/>
      • Blue circles: Nodes<br/>
      • Lines: Links between parent and children<br/>
      • Traversal output: Node values in visiting order<br/>
      <br/>
      Nodes are inserted following Binary Search Tree rules.
    </div>
  </div>
</div>

<script>
  // Binary Tree Node class
  class TreeNode {
    constructor(value) {
      this.value = value;
      this.left = null;
      this.right = null;
    }
  }

  // Binary Search Tree class
  class BinaryTree {
    constructor() {
      this.root = null;
    }

    insert(value) {
      this.root = this._insertRec(this.root, value);
    }

    _insertRec(node, value) {
      if (node === null) return new TreeNode(value);
      if (value === node.value) {
        // ignore duplicates
        return node;
      }
      if (value < node.value) {
        node.left = this._insertRec(node.left, value);
      } else {
        node.right = this._insertRec(node.right, value);
      }
      return node;
    }

    delete(value) {
      this.root = this._deleteRec(this.root, value);
    }

    _deleteRec(node, value) {
      if (!node) return null;
      if (value < node.value) {
        node.left = this._deleteRec(node.left, value);
      } else if (value > node.value) {
        node.right = this._deleteRec(node.right, value);
      } else {
        // found node to delete
        if (!node.left) return node.right;
        if (!node.right) return node.left;
        // node with two children - get inorder successor (smallest in right subtree)
        let minLargerNode = this._minValueNode(node.right);
        node.value = minLargerNode.value;
        node.right = this._deleteRec(node.right, minLargerNode.value);
      }
      return node;
    }

    _minValueNode(node) {
      let current = node;
      while (current.left) {
        current = current.left;
      }
      return current;
    }

    inorder() {
      const res = [];
      this._inorderRec(this.root, res);
      return res;
    }
    _inorderRec(node, res) {
      if (!node) return;
      this._inorderRec(node.left, res);
      res.push(node.value);
      this._inorderRec(node.right, res);
    }

    preorder() {
      const res = [];
      this._preorderRec(this.root, res);
      return res;
    }
    _preorderRec(node, res) {
      if (!node) return;
      res.push(node.value);
      this._preorderRec(node.left, res);
      this._preorderRec(node.right, res);
    }

    postorder() {
      const res = [];
      this._postorderRec(this.root, res);
      return res;
    }
    _postorderRec(node, res) {
      if (!node) return;
      this._postorderRec(node.left, res);
      this._postorderRec(node.right, res);
      res.push(node.value);
    }

    levelorder() {
      const res = [];
      const queue = [];
      if (this.root) queue.push(this.root);
      while (queue.length > 0) {
        let node = queue.shift();
        res.push(node.value);
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
      }
      return res;
    }
  }

  // Canvas drawing and tree layout

  class TreeVisualizer {
    constructor(canvas, tree) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.tree = tree;
      this.nodeRadius = 20;
      this.levelHeight = 80;
      this.canvasWidth = canvas.width;
      this.canvasHeight = canvas.height;
      this.positions = new Map();
    }

    draw() {
      this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
      if (!this.tree.root) {
        this.ctx.font = '18px Arial';
        this.ctx.fillStyle = "#555";
        this.ctx.textAlign = 'center';
        this.ctx.fillText('Tree is empty.', this.canvasWidth/2, this.canvasHeight/2);
        return;
      }
      this.positions.clear();
      // Calculate horizontal positions using inorder traversal index
      let index = 0;
      const positionsInorder = new Map();

      function assignXPos(node) {
        if (!node) return;
        assignXPos(node.left);
        positionsInorder.set(node, index++);
        assignXPos(node.right);
      }
      assignXPos(this.tree.root);

      // Get tree height
      function height(node) {
        if (!node) return 0;
        return 1 + Math.max(height(node.left), height(node.right));
      }
      const treeHeight = height(this.tree.root);

      // Calculate horizontal spacing
      const totalNodes = index;
      const horizontalSpacing = this.canvasWidth / (totalNodes + 1);

      // Compute all node positions
      function assignPositions(node, depth) {
        if (!node) return;
        const x = horizontalSpacing * (positionsInorder.get(node) + 1);
        const y = this.levelHeight * depth + this.nodeRadius + 10;
        this.positions.set(node, {x, y});
        assignPositions.call(this, node.left, depth + 1);
        assignPositions.call(this, node.right, depth + 1);
      }
      assignPositions.call(this, this.tree.root, 0);

      // Draw edges
      this.ctx.strokeStyle = '#444';
      this.ctx.lineWidth = 2;
      this.positions.forEach((pos, node) => {
        if (node.left) {
          this._drawLine(pos, this.positions.get(node.left));
        }
        if (node.right) {
          this._drawLine(pos, this.positions.get(node.right));
        }
      });

      // Draw nodes
      this.positions.forEach((pos, node) => {
        this._drawNode(pos, node.value);
      });
    }

    _drawLine(from, to) {
      this.ctx.beginPath();
      this.ctx.moveTo(from.x, from.y);
      this.ctx.lineTo(to.x, to.y);
      this.ctx.stroke();
    }

    _drawNode(pos, value) {
      const ctx = this.ctx;
      ctx.beginPath();
      ctx.fillStyle = '#4287f5';
      ctx.strokeStyle = '#1a3caa';
      ctx.lineWidth = 2;
      ctx.shadowColor = 'rgba(0,0,0,0.3)';
      ctx.shadowBlur = 4;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      ctx.arc(pos.x, pos.y, this.nodeRadius, 0, 2*Math.PI);
      ctx.fill();
      ctx.shadowColor = 'transparent';
      ctx.stroke();

      ctx.fillStyle = 'white';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(value, pos.x, pos.y);
    }
  }


  // DOM elements
  const insertBtn = document.getElementById('insertBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const nodeValueInput = document.getElementById('nodeValueInput');
  const traversalButtons = document.querySelectorAll('.traversalBtn');
  const traversalOutput = document.getElementById('traversalOutput');
  const message = document.getElementById('message');
  const canvas = document.getElementById('treeCanvas');

  // Instantiate tree and visualizer
  const tree = new BinaryTree();
  const visualizer = new TreeVisualizer(canvas, tree);

  // Initial draw
  visualizer.draw();

  function clearMessage() {
    message.textContent = '';
  }

  function showMessage(text) {
    message.textContent = text;
  }

  function getInputValue() {
    const val = nodeValueInput.value.trim();
    if (val === '') return null;
    const num = Number(val);
    if (Number.isNaN(num) || !Number.isInteger(num)) return null;
    return num;
  }

  insertBtn.addEventListener('click', () => {
    clearMessage();
    const val = getInputValue();
    if (val === null) {
      showMessage('Please enter a valid integer to insert.');
      return;
    }
    tree.insert(val);
    nodeValueInput.value = '';
    visualizer.draw();
    traversalOutput.textContent = '';
  });

  deleteBtn.addEventListener('click', () => {
    clearMessage();
    const val = getInputValue();
    if (val === null) {
      showMessage('Please enter a valid integer to delete.');
      return;
    }
    // Check if value exists in tree before deletion
    const allValues = tree.inorder();
    if (!allValues.includes(val)) {
      showMessage('Value not found in tree.');
      return;
    }
    tree.delete(val);
    nodeValueInput.value = '';
    visualizer.draw();
    traversalOutput.textContent = '';
  });

  traversalButtons.forEach(button => {
    button.addEventListener('click', () => {
      clearMessage();
      if (!tree.root) {
        showMessage('Tree is empty. Insert nodes first.');
        traversalOutput.textContent = '';
        return;
      }
      const traversalType = button.getAttribute('data-traversal');
      let result = [];
      let label = '';
      switch (traversalType) {
        case 'inorder':
          result = tree.inorder();
          label = 'In-order Traversal';
          break;
        case 'preorder':
          result = tree.preorder();
          label = 'Pre-order Traversal';
          break;
        case 'postorder':
          result = tree.postorder();
          label = 'Post-order Traversal';
          break;
        case 'levelorder':
          result = tree.levelorder();
          label = 'Level-order Traversal';
          break;
      }
      traversalOutput.textContent = `${label}: ${result.join(', ')}`;
    });
  });
</script>
</body>
</html>