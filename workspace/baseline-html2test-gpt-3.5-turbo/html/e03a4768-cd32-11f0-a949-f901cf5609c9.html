<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Topological Sort Demo</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 2rem;
      background: #f9f9f9;
    }
    h1 {
      text-align: center;
    }
    #graph-input {
      width: 100%;
      height: 150px;
      font-family: monospace;
      font-size: 14px;
      margin-bottom: 0.5rem;
    }
    #run-btn {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      cursor: pointer;
      margin-bottom: 1rem;
    }
    #output {
      white-space: pre-wrap;
      background: #fff;
      border: 1px solid #ccc;
      padding: 1rem;
      min-height: 4rem;
    }
    label {
      font-weight: bold;
      display: block;
      margin-bottom: 0.3rem;
    }
    #instructions {
      background: #eef6ff;
      border: 1px solid #99c2ff;
      padding: 1rem;
      margin-bottom: 1rem;
      font-size: 0.9rem;
      color: #333;
    }
  </style>
</head>
<body>
  <h1>Topological Sort Visualizer</h1>
  <div id="instructions">
    <p><strong>Input format:</strong></p>
    <p>Define a directed graph (DAG) edges in this format (one edge per line):</p>
    <pre>fromNode → toNode</pre>
    <p>Example:</p>
    <pre>
5 -> 2
5 -> 0
4 -> 0
4 -> 1
2 -> 3
3 -> 1
    </pre>
    <p>This example describes edges from node 5 to 2, 5 to 0, etc.</p>
    <p>After entering edges, click "Run Topological Sort" to see the ordering or detect cycles.</p>
  </div>
  <label for="graph-input">Enter DAG edges:</label>
  <textarea id="graph-input" placeholder="e.g.&#10;5 -> 2&#10;5 -> 0&#10;4 -> 0&#10;4 -> 1&#10;2 -> 3&#10;3 -> 1"></textarea>
  <br />
  <button id="run-btn">Run Topological Sort</button>
  <h2>Result:</h2>
  <div id="output"></div>

<script>
(() => {
  const inputEl = document.getElementById('graph-input');
  const outputEl = document.getElementById('output');
  const runBtn = document.getElementById('run-btn');

  // Parse edges from input string lines of format 'from -> to'
  function parseEdges(text) {
    const lines = text.trim().split('\n');
    const edges = [];
    for (const line of lines) {
      if (!line.trim()) continue;
      const match = line.trim().match(/^(.+?)\s*->\s*(.+)$/);
      if (!match) {
        throw new Error(`Invalid edge format: "${line}". Use "from -> to".`);
      }
      // Trim nodes and keep as strings
      const from = match[1].trim();
      const to = match[2].trim();
      edges.push([from, to]);
    }
    return edges;
  }

  // Build adjacency list graph from edges
  function buildGraph(edges) {
    const graph = new Map();
    // Collect all nodes
    const nodesSet = new Set();
    for (const [from, to] of edges) {
      nodesSet.add(from);
      nodesSet.add(to);
    }
    // Initialize nodes in graph map
    for (const node of nodesSet) graph.set(node, []);
    // Add edges
    for (const [from, to] of edges) {
      graph.get(from).push(to);
    }
    return graph;
  }
  
  // Kahn's Algorithm for Topological Sort
  function topologicalSort(graph) {
    // Calculate in-degree of each node
    const inDegree = new Map();
    for (const node of graph.keys()) {
      inDegree.set(node, 0);
    }
    for (const [node, neighbors] of graph.entries()) {
      for (const neigh of neighbors) {
        inDegree.set(neigh, (inDegree.get(neigh) || 0) + 1);
      }
    }
    
    // Start with all nodes that have in-degree 0
    const queue = [];
    for (const [node, degree] of inDegree.entries()) {
      if (degree === 0) queue.push(node);
    }

    const topoOrder = [];
    while (queue.length) {
      const current = queue.shift();
      topoOrder.push(current);
      for (const neighbor of graph.get(current)) {
        inDegree.set(neighbor, inDegree.get(neighbor) - 1);
        if (inDegree.get(neighbor) === 0) {
          queue.push(neighbor);
        }
      }
    }

    // If topoOrder includes all nodes, success; otherwise, cycle detected
    if (topoOrder.length !== graph.size) {
      return null; // cycle found
    }

    return topoOrder;
  }

  function showResult(text, isError = false) {
    outputEl.textContent = text;
    outputEl.style.color = isError ? '#d00' : '#060';
  }

  runBtn.addEventListener('click', () => {
    outputEl.textContent = '';
    try {
      const edges = parseEdges(inputEl.value);
      const graph = buildGraph(edges);
      const order = topologicalSort(graph);
      if (!order) {
        showResult('Error: The graph contains a cycle. Topological sort is not possible.', true);
      } else {
        showResult('Topological Order:\n' + order.join(' → '));
      }
    } catch (ex) {
      showResult('Error: ' + ex.message, true);
    }
  });
})();
</script>
</body>
</html>