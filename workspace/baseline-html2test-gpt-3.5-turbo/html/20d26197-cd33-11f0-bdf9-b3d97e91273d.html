<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Binary Tree Visualization and Traversal</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f0f0f0;
    color: #222;
  }
  h1 {
    text-align: center;
  }
  #tree-container {
    text-align: center;
    margin: 20px auto;
    width: 100%;
    max-width: 600px;
  }
  svg {
    width: 100%;
    height: 320px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 8px;
  }
  .node circle {
    fill: #3498db;
    stroke: #2980b9;
    stroke-width: 2px;
    cursor: pointer;
    transition: fill 0.3s;
  }
  .node text {
    fill: white;
    font-weight: bold;
    pointer-events: none;
  }
  .node:hover circle {
    fill: #1abc9c;
  }
  .link {
    fill: none;
    stroke: #999;
    stroke-width: 2px;
  }
  #controls {
    max-width: 600px;
    margin: 0 auto 20px;
    background: white;
    padding: 15px 20px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }
  #controls label {
    margin-right: 10px;
    font-weight: bold;
  }
  #addNodeForm {
    margin-top: 10px;
  }
  #addNodeForm input[type="number"], #addNodeForm select {
    padding: 5px;
    font-size: 1rem;
    margin-right: 10px;
    width: 100px;
  }
  #addNodeForm button {
    padding: 6px 12px;
    font-size: 1rem;
    cursor: pointer;
  }
  #traversal-output {
    max-width: 600px;
    margin: 0 auto;
    background: white;
    padding: 15px 20px;
    border-radius: 8px;
    min-height: 48px;
    font-weight: bold;
    font-size: 1.1rem;
  }
  #buttons {
    margin-top: 15px;
    text-align: center;
  }
  #buttons button {
    padding: 8px 15px;
    margin: 5px;
    font-size: 1rem;
    cursor: pointer;
    background-color: #2980b9;
    border: none;
    border-radius: 5px;
    color: white;
    transition: background-color 0.3s;
  }
  #buttons button:hover {
    background-color: #1c5980;
  }
  @media (max-width: 640px) {
    svg {
      height: 240px;
    }
  }
</style>
</head>
<body>
<h1>Interactive Binary Tree</h1>

<div id="controls">
  <div>
    <label for="rootValue">Root Node Value:</label>
    <input type="number" id="rootValue" value="10" />
    <button id="setRoot">Set / Reset Root</button>
  </div>

  <form id="addNodeForm">
    <label>Add Node:</label>
    <input type="number" id="parentValue" placeholder="Parent Value" required />
    <select id="childPosition" aria-label="Child position">
      <option value="left">Left Child</option>
      <option value="right">Right Child</option>
    </select>
    <input type="number" id="childValue" placeholder="New Node Value" required />
    <button type="submit">Add</button>
  </form>
</div>

<div id="tree-container">
  <svg id="tree-svg" aria-label="Binary Tree Visualization" role="img"></svg>
</div>

<div id="buttons">
  <button id="preorderBtn">Pre-order Traversal</button>
  <button id="inorderBtn">In-order Traversal</button>
  <button id="postorderBtn">Post-order Traversal</button>
  <button id="clearOutputBtn">Clear Output</button>
</div>

<div id="traversal-output" aria-live="polite" aria-atomic="true"></div>

<script>
  /*
    Binary Tree Implementation with Visualization using SVG.
    Supports:
      - Setting/resetting root node
      - Adding nodes as left/right child of existing nodes
      - Visualizes tree structure with links and nodes
      - Traversal: preorder, inorder, postorder with output display
  */

  class TreeNode {
    constructor(value) {
      this.value = value;
      this.left = null;
      this.right = null;
      this.x = 0; // for visualization
      this.y = 0;
    }
  }

  class BinaryTree {
    constructor() {
      this.root = null;
    }

    // Find a node with given value (DFS)
    find(value, node = this.root) {
      if (!node) return null;
      if (node.value === value) return node;
      return this.find(value, node.left) || this.find(value, node.right);
    }

    addNode(parentValue, childPosition, childValue) {
      if (!this.root) {
        return false; // no root yet
      }
      const parent = this.find(parentValue);
      if (!parent) return false;
      if (childPosition === 'left') {
        if (parent.left !== null) return false; // left child already exists
        parent.left = new TreeNode(childValue);
        return true;
      } else if (childPosition === 'right') {
        if (parent.right !== null) return false; // right child already exists
        parent.right = new TreeNode(childValue);
        return true;
      }
      return false;
    }

    setRoot(value) {
      this.root = new TreeNode(value);
    }

    preorder(node = this.root, result = []) {
      if (!node) return result;
      result.push(node.value);
      this.preorder(node.left, result);
      this.preorder(node.right, result);
      return result;
    }

    inorder(node = this.root, result = []) {
      if (!node) return result;
      this.inorder(node.left, result);
      result.push(node.value);
      this.inorder(node.right, result);
      return result;
    }

    postorder(node = this.root, result = []) {
      if (!node) return result;
      this.postorder(node.left, result);
      this.postorder(node.right, result);
      result.push(node.value);
      return result;
    }
  }

  // Visualization and UI logic:
  (function() {
    const tree = new BinaryTree();
    const svg = document.getElementById('tree-svg');
    const traversalOutput = document.getElementById('traversal-output');
    const setRootBtn = document.getElementById('setRoot');
    const rootValueInput = document.getElementById('rootValue');
    const addNodeForm = document.getElementById('addNodeForm');
    const preorderBtn = document.getElementById('preorderBtn');
    const inorderBtn = document.getElementById('inorderBtn');
    const postorderBtn = document.getElementById('postorderBtn');
    const clearOutputBtn = document.getElementById('clearOutputBtn');

    // Constants for tree node visualization
    const NODE_RADIUS = 20;
    const LEVEL_HEIGHT = 80;
    const HORIZONTAL_GAP = 30;

    // Calculate x,y for each node for visualization, returns width used by subtree
    function layoutTree(node, xStart, y, depth) {
      if (!node) return 0;

      let leftWidth = layoutTree(node.left, xStart, y + LEVEL_HEIGHT, depth + 1);
      // Current node x is start plus left subtree width plus half node width
      let currX = xStart + leftWidth;

      node.x = currX;
      node.y = y;

      let rightWidth = layoutTree(node.right, currX + HORIZONTAL_GAP, y + LEVEL_HEIGHT, depth + 1);
      
      let subtreeWidth = leftWidth + HORIZONTAL_GAP + rightWidth;
      if (subtreeWidth < NODE_RADIUS*2) subtreeWidth = NODE_RADIUS*2;
      return subtreeWidth;
    }

    // Clear SVG children
    function clearSVG() {
      while (svg.firstChild) {
        svg.removeChild(svg.firstChild);
      }
    }

    // Draw the tree recursively by adding SVG elements
    function drawTree(node) {
      if (!node) return;

      // Draw links to children
      if (node.left) {
        drawLine(node.x, node.y, node.left.x, node.left.y);
        drawTree(node.left);
      }
      if (node.right) {
        drawLine(node.x, node.y, node.right.x, node.right.y);
        drawTree(node.right);
      }

      // Draw node circle and value
      drawNodeCircle(node.x, node.y, node.value);
    }

    function drawLine(x1, y1, x2, y2) {
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('class', 'link');
      // Adjust y coordinate to bottom of circle
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1 + NODE_RADIUS);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2 - NODE_RADIUS);
      svg.appendChild(line);
    }

    function drawNodeCircle(x, y, value) {
      const group = document.createElementNS('http://www.w3.org/2000/svg','g');
      group.setAttribute('class', 'node');
      group.setAttribute('tabindex', '0');
      group.setAttribute('aria-label', `Node with value ${value}`);

      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('cx', x);
      circle.setAttribute('cy', y);
      circle.setAttribute('r', NODE_RADIUS);

      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('x', x);
      text.setAttribute('y', y + 6); // Vertical align center approx
      text.setAttribute('text-anchor', 'middle');
      text.textContent = value;

      group.appendChild(circle);
      group.appendChild(text);

      svg.appendChild(group);
    }

    function renderTree() {
      clearSVG();
      if (!tree.root) return;

      // Layout the tree: center it horizontally within SVG width
      const svgWidth = svg.clientWidth || 600;
      const subtreeWidth = layoutTree(tree.root, 0, LEVEL_HEIGHT, 0);

      // After layout, translate all node x positions to center the tree
      const offsetX = (svgWidth - subtreeWidth) / 2;
      function offsetNode(node) {
        if (!node) return;
        node.x += offsetX;
        offsetNode(node.left);
        offsetNode(node.right);
      }
      offsetNode(tree.root);

      drawTree(tree.root);
    }

    // Traversal output display
    function showTraversal(arr, traversalType) {
      traversalOutput.textContent = `${traversalType} traversal: ${arr.join(' â†’ ')}`;
    }

    setRootBtn.addEventListener('click', () => {
      const val = Number(rootValueInput.value);
      if (isNaN(val)) {
        alert('Please enter a valid number for the root value.');
        return;
      }
      tree.setRoot(val);
      traversalOutput.textContent = '';
      renderTree();
    });

    addNodeForm.addEventListener('submit', e => {
      e.preventDefault();
      if (!tree.root) {
        alert('Set the root node first.');
        return;
      }
      const parentVal = Number(document.getElementById('parentValue').value);
      const childPos = document.getElementById('childPosition').value;
      const childVal = Number(document.getElementById('childValue').value);

      if (isNaN(parentVal) || isNaN(childVal)) {
        alert('Please enter valid numbers for parent and child values.');
        return;
      }

      const success = tree.addNode(parentVal, childPos, childVal);
      if (!success) {
        alert('Failed to add node. Check if parent exists and child position is free.');
        return;
      }
      traversalOutput.textContent = '';
      addNodeForm.reset();
      renderTree();
    });

    preorderBtn.addEventListener('click', () => {
      if (!tree.root) {
        alert('Set the root node first.');
        return;
      }
      const result = tree.preorder();
      showTraversal(result, 'Pre-order');
    });

    inorderBtn.addEventListener('click', () => {
      if (!tree.root) {
        alert('Set the root node first.');
        return;
      }
      const result = tree.inorder();
      showTraversal(result, 'In-order');
    });

    postorderBtn.addEventListener('click', () => {
      if (!tree.root) {
        alert('Set the root node first.');
        return;
      }
      const result = tree.postorder();
      showTraversal(result, 'Post-order');
    });

    clearOutputBtn.addEventListener('click', () => {
      traversalOutput.textContent = '';
    });

    // Initial root
    tree.setRoot(10);
    rootValueInput.value = 10;
    renderTree();

    // Accessibility note
    svg.setAttribute('role', 'img');
    svg.setAttribute('aria-label', 'A binary tree diagram with nodes and connections');

  })();
</script>
</body>
</html>