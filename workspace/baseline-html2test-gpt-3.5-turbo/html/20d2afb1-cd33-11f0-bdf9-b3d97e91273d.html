<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Priority Queue Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 1rem;
    background: #f9fafb;
    color: #333;
  }
  h1 {
    text-align: center;
  }
  .container {
    max-width: 480px;
    margin: 0 auto;
    background: #fff;
    padding: 1rem 2rem 2rem;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    border-radius: 6px;
  }
  label {
    display: block;
    margin-top: 1rem;
  }
  input[type="text"], input[type="number"] {
    width: 100%;
    box-sizing: border-box;
    padding: 0.4rem 0.6rem;
    margin-top: 0.3rem;
    font-size: 1rem;
  }
  button {
    margin-top: 1.3rem;
    font-size: 1rem;
    padding: 0.5rem 1.2rem;
    border-radius: 4px;
    border: none;
    cursor: pointer;
    background: #2563eb;
    color: white;
  }
  button:disabled {
    background: #94a3b8;
    cursor: not-allowed;
  }
  .queue-view {
    margin-top: 2rem;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 0.6rem;
  }
  th, td {
    border-bottom: 1px solid #ddd;
    padding: 0.6rem 0.8rem;
    text-align: left;
  }
  th {
    background-color: #e0e7ff;
  }
  .output {
    margin-top: 1.5rem;
    padding: 1rem;
    background: #f3f4f6;
    border-radius: 4px;
    font-family: monospace;
    white-space: pre-wrap;
    max-height: 150px;
    overflow-y: auto;
  }
</style>
</head>
<body>
  <div class="container">
    <h1>Priority Queue Demo</h1>
    <p>Insert elements with priority and dequeue highest priority first (lowest priority number = highest priority).</p>

    <label for="itemInput">Item Value:</label>
    <input type="text" id="itemInput" placeholder="Enter value (string)" />

    <label for="priorityInput">Priority (integer):</label>
    <input type="number" id="priorityInput" placeholder="Enter priority (lower = higher priority)" min="0" />

    <button id="enqueueBtn" disabled>Add to Priority Queue</button>
    <button id="dequeueBtn" disabled>Dequeue Highest Priority</button>

    <div class="queue-view">
      <h3>Current Queue (sorted by priority):</h3>
      <table>
        <thead><tr><th>Index</th><th>Item</th><th>Priority</th></tr></thead>
        <tbody id="queueBody">
          <tr><td colspan="3" style="text-align:center;color:#777;">Queue is empty</td></tr>
        </tbody>
      </table>
    </div>

    <div class="output" id="outputArea" aria-live="polite" aria-atomic="true"></div>
  </div>

<script>
// Priority Queue implemented with a binary min-heap for efficiency
class PriorityQueue {
  constructor() {
    this.heap = [];
  }

  _parentIndex(i) {
    return Math.floor((i - 1) / 2);
  }
  _leftChildIndex(i) {
    return 2 * i + 1;
  }
  _rightChildIndex(i) {
    return 2 * i + 2;
  }

  _swap(i, j) {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }

  _heapifyUp(index) {
    let currentIndex = index;
    while (currentIndex > 0) {
      let parent = this._parentIndex(currentIndex);
      if (this.heap[parent].priority > this.heap[currentIndex].priority) {
        this._swap(parent, currentIndex);
        currentIndex = parent;
      } else {
        break;
      }
    }
  }

  _heapifyDown(index) {
    let currentIndex = index;
    let left, right, smallest;

    while (true) {
      left = this._leftChildIndex(currentIndex);
      right = this._rightChildIndex(currentIndex);
      smallest = currentIndex;

      if (
        left < this.heap.length &&
        this.heap[left].priority < this.heap[smallest].priority
      ) {
        smallest = left;
      }
      if (
        right < this.heap.length &&
        this.heap[right].priority < this.heap[smallest].priority
      ) {
        smallest = right;
      }

      if (smallest !== currentIndex) {
        this._swap(currentIndex, smallest);
        currentIndex = smallest;
      } else {
        break;
      }
    }
  }

  enqueue(item, priority) {
    if (priority == null || isNaN(priority)) {
      throw new Error("Priority must be a number");
    }
    let node = { item, priority: Number(priority) };
    this.heap.push(node);
    this._heapifyUp(this.heap.length - 1);
  }

  dequeue() {
    if (this.isEmpty()) return null;
    const root = this.heap[0];
    const last = this.heap.pop();
    if (!this.isEmpty()) {
      this.heap[0] = last;
      this._heapifyDown(0);
    }
    return root;
  }

  peek() {
    return this.isEmpty() ? null : this.heap[0];
  }

  size() {
    return this.heap.length;
  }

  isEmpty() {
    return this.heap.length === 0;
  }

  // Return a sorted array (lowest priority first) without altering heap
  toSortedArray() {
    // clone the heap array
    let copy = this.heap.slice();
    let result = [];
    let tempPQ = new PriorityQueue();
    tempPQ.heap = copy;
    while (!tempPQ.isEmpty()) {
      result.push(tempPQ.dequeue());
    }
    return result;
  }
}

// UI Logic
const pq = new PriorityQueue();

const itemInput = document.getElementById('itemInput');
const priorityInput = document.getElementById('priorityInput');
const enqueueBtn = document.getElementById('enqueueBtn');
const dequeueBtn = document.getElementById('dequeueBtn');
const queueBody = document.getElementById('queueBody');
const outputArea = document.getElementById('outputArea');

function updateButtons() {
  enqueueBtn.disabled =
    itemInput.value.trim() === '' ||
    priorityInput.value.trim() === '' ||
    isNaN(priorityInput.value);
  dequeueBtn.disabled = pq.isEmpty();
}

function renderQueue() {
  const arr = pq.toSortedArray();
  queueBody.innerHTML = '';
  if (arr.length === 0) {
    queueBody.innerHTML =
      '<tr><td colspan="3" style="text-align:center;color:#777;">Queue is empty</td></tr>';
    return;
  }
  arr.forEach(({ item, priority }, i) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${i + 1}</td><td>${escapeHTML(item)}</td><td>${priority}</td>`;
    queueBody.appendChild(tr);
  });
}

function escapeHTML(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function logOutput(msg) {
  outputArea.textContent = msg;
}

enqueueBtn.addEventListener('click', () => {
  const item = itemInput.value.trim();
  const priorityVal = priorityInput.value.trim();
  if (item === '' || priorityVal === '' || isNaN(priorityVal)) {
    alert('Please enter valid item and numeric priority.');
    return;
  }
  try {
    pq.enqueue(item, Number(priorityVal));
    logOutput(`Enqueued: "${item}" with priority ${priorityVal}`);
    renderQueue();
    updateButtons();
    itemInput.value = '';
    priorityInput.value = '';
    itemInput.focus();
  } catch (e) {
    alert(e.message);
  }
});

dequeueBtn.addEventListener('click', () => {
  const removed = pq.dequeue();
  if (removed) {
    logOutput(`Dequeued: "${removed.item}" with priority ${removed.priority}`);
  } else {
    logOutput(`Queue is empty.`);
  }
  renderQueue();
  updateButtons();
});

itemInput.addEventListener('input', updateButtons);
priorityInput.addEventListener('input', updateButtons);

updateButtons();
renderQueue();

</script>
</body>
</html>