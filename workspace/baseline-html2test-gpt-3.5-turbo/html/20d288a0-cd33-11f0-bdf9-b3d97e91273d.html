<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Binary Search Tree (BST) Visualization and Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f4f7f9;
    color: #333;
  }
  h1 {
    text-align: center;
    color: #0275d8;
  }
  #container {
    max-width: 900px;
    margin: auto;
  }
  #controls {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    margin-bottom: 20px;
    align-items: center;
  }
  #controls input[type="number"] {
    width: 100px;
    padding: 8px;
    font-size: 1rem;
  }
  #controls button {
    padding: 10px 15px;
    font-size: 1rem;
    border: none;
    border-radius: 4px;
    background: #0275d8;
    color: white;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  #controls button:disabled {
    background: #89b8e7;
    cursor: not-allowed;
  }
  #controls button:hover:not(:disabled) {
    background: #025aa5;
  }
  #traversalOutput {
    background: white;
    border-radius: 6px;
    padding: 15px;
    min-height: 40px;
    font-family: monospace;
    font-size: 1.1rem;
    margin-top: 5px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
  }
  #message {
    margin: 10px 0;
    font-weight: 600;
  }
  svg {
    display: block;
    margin: 30px auto;
    border: 1px solid #ccc;
    background: white;
    overflow: visible;
  }
  .node circle {
    fill: #0275d8;
    stroke: #014f86;
    stroke-width: 2px;
    cursor: pointer;
    transition: fill 0.3s ease;
  }
  .node circle.highlighted {
    fill: #d9534f;
  }
  .node text {
    fill: white;
    font-weight: bold;
    pointer-events: none;
    user-select: none;
  }
  line {
    stroke: #555;
    stroke-width: 2px;
  }
  #legend {
    max-width: 900px;
    margin: 20px auto 0;
    font-size: 0.9rem;
    color: #555;
    line-height: 1.4;
  }
  @media(max-width: 600px) {
    #controls {
      flex-direction: column;
    }
    #controls input[type="number"] {
      width: 100%;
      max-width: 100%;
    }
    #controls button {
      width: 100%;
    }
  }
</style>
</head>
<body>
  <div id="container">
    <h1>Binary Search Tree (BST) Visualization and Demo</h1>
    <div id="controls" aria-label="BST controls">
      <input type="number" id="inputValue" placeholder="Enter a number" aria-label="Number input" />
      <button id="insertBtn">Insert</button>
      <button id="deleteBtn">Delete</button>
      <button id="searchBtn">Search</button>
      <button id="inorderBtn">In-order</button>
      <button id="preorderBtn">Pre-order</button>
      <button id="postorderBtn">Post-order</button>
      <button id="clearBtn" title="Clear the entire BST">Clear All</button>
    </div>
    <div id="message" role="alert" aria-live="polite"></div>
    <div>
      <strong>Traversal Output:</strong>
      <div id="traversalOutput" aria-live="polite" aria-atomic="true"></div>
    </div>
    <svg id="bstCanvas" height="400" width="900" aria-label="Binary Search Tree visualization"></svg>
    <div id="legend">
      <p><strong>Instructions:</strong> Enter a number and click Insert, Delete, or Search to modify or query the BST. Use the traversal buttons to see node visits in order.</p>
      <p><strong>Highlights:</strong> Red filled nodes in search/traversal indicate the current node being highlighted/visited.</p>
      <p><em>Click nodes in the tree to highlight them during traversal.</em></p>
    </div>
  </div>
<script>
(() => {
  // BST Node class
  class Node {
    constructor(value) {
      this.value = value;
      this.left = null;
      this.right = null;
      this.x = 0; // for visualization position
      this.y = 0;
    }
  }

  // BST class with insert, delete, search, traversals
  class BST {
    constructor() {
      this.root = null;
    }

    insert(value) {
      if (this.root === null) {
        this.root = new Node(value);
        return true;
      }
      let current = this.root;
      while (true) {
        if (value === current.value) {
          // no duplicates in this BST
          return false;
        }
        if (value < current.value) {
          if (current.left === null) {
            current.left = new Node(value);
            return true;
          }
          current = current.left;
        } else {
          if (current.right === null) {
            current.right = new Node(value);
            return true;
          }
          current = current.right;
        }
      }
    }

    search(value) {
      let current = this.root;
      while (current !== null) {
        if (value === current.value) {
          return current;
        }
        if (value < current.value) current = current.left;
        else current = current.right;
      }
      return null;
    }

    delete(value) {
      this.root = this._deleteRec(this.root, value);
    }

    _deleteRec(root, value) {
      if (root == null) return root;

      if (value < root.value) {
        root.left = this._deleteRec(root.left, value);
      } else if (value > root.value) {
        root.right = this._deleteRec(root.right, value);
      } else {
        // found node to delete
        if (root.left == null) return root.right;
        else if (root.right == null) return root.left;

        // node with two children, find inorder successor (min in right subtree)
        root.value = this._minValue(root.right);
        root.right = this._deleteRec(root.right, root.value);
      }
      return root;
    }

    _minValue(node) {
      let current = node;
      while (current.left != null) {
        current = current.left;
      }
      return current.value;
    }

    inorder() {
      let result = [];
      this._inorderRec(this.root, result);
      return result;
    }

    _inorderRec(node, result) {
      if (node !== null) {
        this._inorderRec(node.left, result);
        result.push(node.value);
        this._inorderRec(node.right, result);
      }
    }

    preorder() {
      let result = [];
      this._preorderRec(this.root, result);
      return result;
    }

    _preorderRec(node, result) {
      if (node !== null) {
        result.push(node.value);
        this._preorderRec(node.left, result);
        this._preorderRec(node.right, result);
      }
    }

    postorder() {
      let result = [];
      this._postorderRec(this.root, result);
      return result;
    }

    _postorderRec(node, result) {
      if (node !== null) {
        this._postorderRec(node.left, result);
        this._postorderRec(node.right, result);
        result.push(node.value);
      }
    }
  }

  // Visualization & App logic
  const svg = document.getElementById('bstCanvas');
  const insertBtn = document.getElementById('insertBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const searchBtn = document.getElementById('searchBtn');
  const inorderBtn = document.getElementById('inorderBtn');
  const preorderBtn = document.getElementById('preorderBtn');
  const postorderBtn = document.getElementById('postorderBtn');
  const clearBtn = document.getElementById('clearBtn');
  const inputValue = document.getElementById('inputValue');
  const traversalOutput = document.getElementById('traversalOutput');
  const message = document.getElementById('message');

  const nodeRadius = 20;
  const verticalSpacing = 70;
  const horizontalSpacing = 40;
  let bst = new BST();

  // Clear previous drawing
  function clearSVG() {
    while (svg.firstChild) {
      svg.removeChild(svg.firstChild);
    }
  }

  // Assign coordinates to nodes for visualization using inorder position and depth
  function assignCoordinates(node, depth = 0, positions = {x: 0}) {
    if (!node) return;
    assignCoordinates(node.left, depth + 1, positions);
    node.x = positions.x++;
    node.y = depth;
    assignCoordinates(node.right, depth + 1, positions);
  }

  // Draw lines(connections) between nodes
  function drawLines(node, nodeMap) {
    if (!node) return;
    if (node.left) {
      drawLine(node, node.left, nodeMap);
      drawLines(node.left, nodeMap);
    }
    if (node.right) {
      drawLine(node, node.right, nodeMap);
      drawLines(node.right, nodeMap);
    }
  }

  function drawLine(parent, child, nodeMap) {
    const parentPos = nodeMap.get(parent);
    const childPos = nodeMap.get(child);

    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute('x1', parentPos.x);
    line.setAttribute('y1', parentPos.y + nodeRadius);
    line.setAttribute('x2', childPos.x);
    line.setAttribute('y2', childPos.y - nodeRadius);
    line.setAttribute('stroke', '#555');
    line.setAttribute('stroke-width', '2');
    svg.appendChild(line);
  }

  // Draw nodes
  function drawNodes(node, nodeMap) {
    if (!node) return;
    drawNode(node, nodeMap);
    drawNodes(node.left, nodeMap);
    drawNodes(node.right, nodeMap);
  }

  // Draw a single node circle with text
  function drawNode(node, nodeMap) {
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    g.setAttribute('class', 'node');
    g.setAttribute('role', 'treeitem');
    g.setAttribute('tabindex', 0);
    g.setAttribute('aria-label', `Node with value ${node.value}`);

    // Calculate position
    const x = node.x * (nodeRadius * 2 + horizontalSpacing) + nodeRadius + 10;
    const y = node.y * verticalSpacing + nodeRadius + 10;

    nodeMap.set(node, {x, y});

    // circle
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute('cx', x);
    circle.setAttribute('cy', y);
    circle.setAttribute('r', nodeRadius);
    circle.setAttribute('fill', '#0275d8');
    circle.setAttribute('stroke', '#014f86');
    circle.setAttribute('stroke-width', 2);
    circle.style.cursor = 'pointer';

    // text
    const text = document.createElementNS("http://www.w3.org/2000/svg", 'text');
    text.setAttribute('x', x);
    text.setAttribute('y', y + 5); // small vertical offset to center text visually
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('font-size', '14px');
    text.setAttribute('fill', 'white');
    text.style.userSelect = 'none';
    text.textContent = node.value;

    g.appendChild(circle);
    g.appendChild(text);

    svg.appendChild(g);

    // On click highlight node
    g.addEventListener('click', () => {
      clearHighlights();
      circle.classList.add('highlighted');
      message.textContent = `Node ${node.value} selected.`;
    });
  }

  // Redraw the entire BST visualization
  function redraw() {
    clearSVG();
    if (!bst.root) return;
    assignCoordinates(bst.root);
    const nodeMap = new Map();
    drawLines(bst.root, nodeMap);
    drawNodes(bst.root, nodeMap);
    adjustSVGWidth();
  }

  // Adjust SVG width dynamically based on tree width
  function adjustSVGWidth() {
    if (!bst.root) {
      svg.setAttribute('width', 900);
      return;
    }
    // Find max x position
    let maxX = 0;
    function dfs(node) {
      if (!node) return;
      if (node.x > maxX) maxX = node.x;
      dfs(node.left);
      dfs(node.right);
    }
    dfs(bst.root);
    const width = (maxX + 1) * (nodeRadius * 2 + horizontalSpacing) + 40;
    svg.setAttribute('width', Math.max(width, 400));
  }

  // Clear highlights on all nodes
  function clearHighlights() {
    const circles = svg.querySelectorAll('circle.highlighted');
    circles.forEach(c => c.classList.remove('highlighted'));
  }

  // Highlight a node by value
  function highlightNode(value) {
    clearHighlights();
    const nodes = svg.querySelectorAll('g.node');
    for (let g of nodes) {
      const text = g.querySelector('text').textContent;
      if (+text === value) {
        const circle = g.querySelector('circle');
        circle.classList.add('highlighted');
        return;
      }
    }
  }

  // Animate traversal highlighting nodes in sequence
  async function animateTraversal(values) {
    traversalOutput.textContent = '';
    if (values.length === 0) {
      traversalOutput.textContent = '(empty)';
      return;
    }
    for (let val of values) {
      highlightNode(val);
      traversalOutput.textContent += val + ' ';
      await pause(700);
    }
    clearHighlights();
  }

  // Pause utility for async
  function pause(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // Event handlers
  insertBtn.addEventListener('click', () => {
    clearHighlights();
    message.textContent = '';
    const val = Number(inputValue.value);
    if (isNaN(val)) {
      message.textContent = 'Please enter a valid number to insert.';
      inputValue.focus();
      return;
    }
    const inserted = bst.insert(val);
    if (inserted) {
      message.textContent = `Inserted ${val} into the BST.`;
      traversalOutput.textContent = '';
    } else {
      message.textContent = `Value ${val} already exists in the BST. No duplicates allowed.`;
    }
    inputValue.value = '';
    redraw();
  });

  deleteBtn.addEventListener('click', () => {
    clearHighlights();
    message.textContent = '';
    const val = Number(inputValue.value);
    if (isNaN(val)) {
      message.textContent = 'Please enter a valid number to delete.';
      inputValue.focus();
      return;
    }
    if (!bst.search(val)) {
      message.textContent = `Value ${val} not found in the BST.`;
      inputValue.value = '';
      return;
    }
    bst.delete(val);
    message.textContent = `Deleted ${val} from the BST.`;
    inputValue.value = '';
    traversalOutput.textContent = '';
    redraw();
  });

  searchBtn.addEventListener('click', async () => {
    clearHighlights();
    message.textContent = '';
    traversalOutput.textContent = '';
    const val = Number(inputValue.value);
    if (isNaN(val)) {
      message.textContent = 'Please enter a valid number to search.';
      inputValue.focus();
      return;
    }
    let current = bst.root;
    let path = [];
    while (current != null) {
      path.push(current.value);
      if (val === current.value) {
        message.textContent = `Value ${val} found in the BST.`;
        break;
      }
      if (val < current.value) current = current.left;
      else current = current.right;
    }
    if (current == null) {
      message.textContent = `Value ${val} not found in the BST.`;
    }
    await animateTraversal(path);
    inputValue.value = '';
  });

  inorderBtn.addEventListener('click', async () => {
    clearHighlights();
    message.textContent = '';
    const values = bst.inorder();
    message.textContent = 'In-order traversal:';
    await animateTraversal(values);
  });

  preorderBtn.addEventListener('click', async () => {
    clearHighlights();
    message.textContent = '';
    const values = bst.preorder();
    message.textContent = 'Pre-order traversal:';
    await animateTraversal(values);
  });

  postorderBtn.addEventListener('click', async () => {
    clearHighlights();
    message.textContent = '';
    const values = bst.postorder();
    message.textContent = 'Post-order traversal:';
    await animateTraversal(values);
  });

  clearBtn.addEventListener('click', () => {
    bst = new BST();
    clearHighlights();
    message.textContent = 'BST cleared.';
    traversalOutput.textContent = '';
    inputValue.value = '';
    redraw();
  });

  // Keyboard accessibility for Enter key in input field for insert
  inputValue.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      insertBtn.click();
    }
  });

  // Initialize empty tree visualization
  redraw();
})();
</script>
</body>
</html>