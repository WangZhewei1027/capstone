<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Prim's Algorithm Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    overflow: hidden;
    background: #2c3e50;
    color: #ecf0f1;
  }
  #container {
    display: flex;
    height: 100vh;
  }
  #canvasContainer {
    flex: 1;
    position: relative;
  }
  canvas {
    background: #34495e;
    display: block;
    margin: 0 auto;
  }
  #controls {
    width: 320px;
    background: #1a252f;
    padding: 20px;
    box-sizing: border-box;
    overflow-y: auto;
  }
  h1 {
    margin-top: 0;
    font-size: 24px;
    text-align:center;
  }
  button {
    background: #2980b9;
    border: none;
    border-radius: 3px;
    padding: 10px 15px;
    color: white;
    font-size: 16px;
    cursor: pointer;
    margin-top: 10px;
    width: 100%;
    user-select:none;
  }
  button:disabled {
    background: #7f8c8d;
    cursor: default;
  }
  label {
    display: block;
    margin-top: 15px;
    margin-bottom: 8px;
  }
  input[type=number] {
    width: 100%;
    padding: 8px;
    font-size: 16px;
    box-sizing: border-box;
    border-radius: 3px;
    border: none;
  }
  #description {
    font-size: 14px;
    line-height: 1.4;
    margin-top: 20px;
    background: #22303b;
    padding: 10px;
    border-radius: 4px;
    height: 200px;
    overflow-y: auto;
  }
  #stepDetails {
    margin-top: 15px;
    font-size: 14px;
    line-height: 1.3;
    background: #22303b;
    padding: 10px;
    border-radius: 4px;
    height: 130px;
    overflow-y: auto;
  }
  #graphInfo {
    font-size: 14px;
    margin-top: 15px;
  }
  .small-note {
    font-size: 12px;
    color: #aab7c4;
    margin-top: 5px;
  }
  a {
    color: #3498db;
  }
</style>
</head>
<body>
<div id="container">
  <div id="canvasContainer">
    <canvas id="graphCanvas" width="700" height="600"></canvas>
  </div>
  <div id="controls">
    <h1>Prim's Algorithm</h1>

    <label for="numVertices">Number of vertices (3 - 12):</label>
    <input type="number" id="numVertices" min="3" max="12" value="6" />

    <button id="generateGraphBtn">Generate Random Graph</button>
    <button id="startBtn" disabled>Start Prim's Algorithm</button>
    <button id="stepBtn" disabled>Next Step</button>
    <button id="resetBtn" disabled>Reset</button>

    <div id="graphInfo"></div>

    <div id="stepDetails">
      <strong>Algorithm Status:</strong>
      <div id="statusText">Click "Generate Random Graph" to begin.</div>
    </div>
    <div id="description">
      <strong>Prim's Algorithm (Minimal Spanning Tree):</strong>
      <p>
        Prim's algorithm builds a minimum spanning tree (MST) for a weighted undirected graph.
        It starts from any vertex and grows the spanning tree by repeatedly adding the smallest 
        edge that connects a vertex inside the MST to a vertex outside it until all vertices are included.
      </p>
      <p>
        <strong>Steps: </strong>
        <ol>
          <li>Initialize MST with one vertex (start vertex).</li>
          <li>Find the edge with the minimum weight that connects MST to a vertex not yet included.</li>
          <li>Add that edge and the vertex to MST.</li>
          <li>Repeat until all vertices are in MST.</li>
        </ol>
      </p>
      <p>
        This visualization shows the graph with weighted edges, and step-by-step how Prim's algorithm selects edges.
      </p>
      <p style="font-size: 12px; text-align:center; margin-top:20px;">
        Created by ChatGPT &mdash; <a href="https://en.wikipedia.org/wiki/Prim%27s_algorithm" target="_blank" rel="noopener">Learn More</a>
      </p>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('graphCanvas');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;

  // Controls
  const numVerticesInput = document.getElementById('numVertices');
  const generateBtn = document.getElementById('generateGraphBtn');
  const startBtn = document.getElementById('startBtn');
  const stepBtn = document.getElementById('stepBtn');
  const resetBtn = document.getElementById('resetBtn');
  const statusText = document.getElementById('statusText');
  const graphInfo = document.getElementById('graphInfo');

  // Graph data structures
  let vertices = [];
  let edges = []; // {from, to, weight}
  let adjList = [];

  // Prim's variables
  let primMSTEdges = [];
  let inMST = [];
  let edgeCandidates = [];
  let currentStep = 0;
  let totalVertices = 0;

  // Visual config
  const vertexRadius = 20;
  const vertexColor = '#2980b9';
  const vertexInMSTColor = '#2ecc71';
  const vertexSelectedColor = '#f39c12';
  const edgeColor = '#bdc3c7';
  const edgeMSTColor = '#27ae60';
  const edgeCandidateColor = '#f1c40f';
  const textColor = '#ecf0f1';

  // For step by step highlighting
  let lastAddedEdge = null;

  // Utility functions
  function dist(p1, p2) {
    return Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2);
  }

  function drawVertex(vertex, index, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.shadowColor = 'rgba(0,0,0,0.7)';
    ctx.shadowBlur = 6;
    ctx.arc(vertex.x, vertex.y, vertexRadius, 0, 2 * Math.PI);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Draw number
    ctx.fillStyle = textColor;
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(index, vertex.x, vertex.y);
  }

  function drawEdge(edge, color, lineWidth=3) {
    let v1 = vertices[edge.from];
    let v2 = vertices[edge.to];
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.shadowColor = 'rgba(0,0,0,0.6)';
    ctx.shadowBlur = 4;
    ctx.moveTo(v1.x, v1.y);
    ctx.lineTo(v2.x, v2.y);
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Draw the weight near the middle with a white background
    const midX = (v1.x + v2.x) / 2;
    const midY = (v1.y + v2.y) / 2;

    const weightText = edge.weight.toFixed(1);

    ctx.font = '14px Arial';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    const textWidth = ctx.measureText(weightText).width;
    const padding = 4;
    ctx.fillStyle = '#ecf0f1';
    ctx.shadowColor = 'rgba(0,0,0,0.7)';
    ctx.shadowBlur = 3;
    ctx.fillRect(midX - textWidth/2 - padding, midY - 10, textWidth + 2*padding, 20);
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#2c3e50';
    ctx.fillText(weightText, midX, midY);
  }

  function clearCanvas() {
    ctx.clearRect(0, 0, width, height);
  }

  function generateVertices(n) {
    const margin = 60;
    const points = [];
    let tries = 0;

    while(points.length < n && tries < 1000) {
      tries++;
      const p = {
        x: margin + Math.random() * (width - 2*margin),
        y: margin + Math.random() * (height - 2*margin)
      };
      // Avoid too close points
      const minDist = vertexRadius*4;
      let close = false;
      for(let pt of points) {
        if(dist(pt, p) < minDist) {
          close = true;
          break;
        }
      }
      if(!close) points.push(p);
    }
    if(points.length < n) {
      // fallback evenly spaced
      points.length = 0;
      for(let i=0; i<n; i++) {
        points.push({
          x: margin + (i * (width - 2*margin)) / (n-1),
          y: height/2 + 50 * Math.sin(i)
        });
      }
    }
    return points;
  }

  function generateRandomGraph(n) {
    vertices = generateVertices(n);
    adjList = Array.from({length:n}, () => []);
    edges = [];

    // We'll create a connected graph
    // First make a simple connected chain with random weights
    for(let i=1; i<n; i++) {
      let w = +(1 + Math.random()*10).toFixed(1);
      edges.push({from: i-1, to: i, weight: w});
      adjList[i-1].push({to: i, weight: w});
      adjList[i].push({to: i-1, weight: w});
    }

    // Add some random additional edges (not creating multi-edges or self-loops)
    const maxEdges = n*(n-1)/2; // full graph edges
    let currentEdges = edges.length;
    const additionalEdges = Math.min(n + 3, maxEdges - currentEdges);

    let attempts = 0;
    while(currentEdges < n - 1 + additionalEdges && attempts < 500) {
      attempts++;
      let u = Math.floor(Math.random()*n);
      let v = Math.floor(Math.random()*n);
      if(u === v) continue;
      if(adjList[u].some(e => e.to === v)) continue;
      let w = +(1 + Math.random()*10).toFixed(1);

      edges.push({from: u, to: v, weight: w});
      adjList[u].push({to: v, weight: w});
      adjList[v].push({to: u, weight: w});
      currentEdges++;
    }
  }

  // Draw the full graph with current MST and highlights
  function drawGraph() {
    clearCanvas();

    // Draw all edges first
    edges.forEach(e => {
      let color = edgeColor;
      let lineWidth = 2;
      // If in MST edges
      if (primMSTEdges.find(me =>
          (me.from === e.from && me.to === e.to) ||
          (me.from === e.to && me.to === e.from)
        )) {
        color = edgeMSTColor;
        lineWidth = 4;
      }
      else if(lastAddedEdge && 
        ((lastAddedEdge.from === e.from && lastAddedEdge.to === e.to) ||
        (lastAddedEdge.from === e.to && lastAddedEdge.to === e.from))) {
        color = '#e74c3c'; // highlight last added edge red
        lineWidth = 5;
      }
      else if(edgeCandidates.includes(e)) {
        color = edgeCandidateColor;
        lineWidth = 3;
      }
      drawEdge(e,color,lineWidth);
    });

    // Draw vertices
    for(let i=0; i<vertices.length; i++) {
      let color = vertexColor;
      if(inMST[i]) {
        color = vertexInMSTColor;
      }
      drawVertex(vertices[i], i, color);
    }
  }

  // Find edge in edges list matching from and to (undirected)
  function findEdge(u,v) {
    return edges.find(e => (e.from === u && e.to === v) || (e.from === v && e.to === u));
  }

  // Prim's Algorithm initialization
  function primInit() {
    const n = vertices.length;
    inMST = Array(n).fill(false);
    primMSTEdges = [];
    edgeCandidates = [];
    currentStep = 0;
    lastAddedEdge = null;

    // Start from vertex 0
    inMST[0] = true;

    // Add edges from vertex 0 to edgeCandidates
    edgeCandidates = [];
    for(let e of edges) {
      if(e.from === 0 && !inMST[e.to]) edgeCandidates.push(e);
      else if(e.to === 0 && !inMST[e.from]) edgeCandidates.push(e);
    }

    updateStatus(`Starting from vertex 0. Edges connected to 0 are candidates.`);
    drawGraph();
  }

  // Prim's Algorithm step - adds one edge and vertex per step
  function primStep() {
    if(inMST.every(v => v)) {
      updateStatus(`All vertices included. MST complete.`);
      drawGraph();
      stepBtn.disabled = true;
      return;
    }

    // Find edge with minimum weight connecting MST to outside vertex
    // edgeCandidates holds edges crossing MST frontier
    let minEdge = null;
    let minWeight = Infinity;
    for(let edge of edges) {
      const uIn = inMST[edge.from];
      const vIn = inMST[edge.to];
      if(uIn !== vIn) { // connecting MST to outside vertex
        if(edge.weight < minWeight) {
          minWeight = edge.weight;
          minEdge = edge;
        }
      }
    }
    if(!minEdge) {
      updateStatus(`No edge found connecting MST to remaining vertices. Graph might be disconnected.`);
      stepBtn.disabled = true;
      return;
    }

    // Add the edge and vertex to MST
    primMSTEdges.push(minEdge);
    lastAddedEdge = minEdge;

    // Mark the new vertex included in MST
    if(inMST[minEdge.from]) {
      inMST[minEdge.to] = true;
      updateStatus(`Adding edge (${minEdge.from} - ${minEdge.to}) with weight ${minEdge.weight.toFixed(1)} to MST. Vertex ${minEdge.to} included.`);
    } else {
      inMST[minEdge.from] = true;
      updateStatus(`Adding edge (${minEdge.from} - ${minEdge.to}) with weight ${minEdge.weight.toFixed(1)} to MST. Vertex ${minEdge.from} included.`);
    }

    currentStep++;
    drawGraph();

    if(inMST.every(v => v)) {
      updateStatus(`All vertices included. MST complete. Total edges: ${primMSTEdges.length}`);
      stepBtn.disabled = true;
      startBtn.disabled = true;
    }
  }

  function updateStatus(text) {
    statusText.textContent = text;
  }

  function updateGraphInfo() {
    let info = `<strong>Graph Info:</strong><br>`;
    info += `Vertices: ${vertices.length}<br>`;
    info += `Edges: ${edges.length}<br>`;
    graphInfo.innerHTML = info;
  }

  // Button events
  generateBtn.onclick = () => {
    const n = parseInt(numVerticesInput.value);
    if(isNaN(n) || n < 3 || n > 12) {
      alert('Please enter a number of vertices between 3 and 12.');
      return;
    }
    generateRandomGraph(n);
    updateGraphInfo();
    primMSTEdges = [];
    inMST = [];
    edgeCandidates = [];
    currentStep = 0;
    lastAddedEdge = null;
    startBtn.disabled = false;
    stepBtn.disabled = true;
    resetBtn.disabled = true;
    updateStatus(`Random connected graph generated with ${n} vertices. Click "Start Prim's Algorithm" to begin.`);
    drawGraph();
  };

  startBtn.onclick = () => {
    if(vertices.length === 0) {
      alert('Generate a graph first.');
      return;
    }
    primInit();
    startBtn.disabled = true;
    stepBtn.disabled = false;
    resetBtn.disabled = false;
  };

  stepBtn.onclick = () => {
    primStep();
  };

  resetBtn.onclick = () => {
    primMSTEdges = [];
    inMST = [];
    edgeCandidates = [];
    currentStep = 0;
    lastAddedEdge = null;
    startBtn.disabled = false;
    stepBtn.disabled = true;
    resetBtn.disabled = true;
    updateStatus(`Reset algorithm state. Click "Start Prim's Algorithm" to begin again.`);
    drawGraph();
  };

  // Initial clear
  clearCanvas();
  updateStatus(`Click "Generate Random Graph" to begin.`);
  graphInfo.innerHTML = '';
})();
</script>
</body>
</html>