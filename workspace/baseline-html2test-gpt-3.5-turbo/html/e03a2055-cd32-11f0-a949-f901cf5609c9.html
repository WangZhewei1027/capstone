<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Union-Find (Disjoint Set) Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  h1 {
    text-align: center;
  }
  #container {
    max-width: 600px;
    margin: 0 auto;
  }
  label {
    margin-right: 10px;
  }
  input[type="number"] {
    width: 60px;
  }
  button {
    margin: 5px;
    padding: 6px 12px;
  }
  #output {
    white-space: pre-wrap;
    background: #f0f0f0;
    padding: 15px;
    border-radius: 6px;
    margin-top: 15px;
    height: 220px;
    overflow-y: auto;
    font-family: Consolas, monospace;
  }
  .set-item {
    display: inline-block;
    margin: 3px 10px 3px 0;
    padding: 6px 10px;
    border-radius: 20px;
    background: #3498db;
    color: white;
    font-weight: bold;
    user-select: none;
  }
  .set-group {
    margin-bottom: 15px;
  }
  .section {
    margin-bottom: 25px;
  }
  footer {
    margin-top: 40px;
    font-size: 0.85em;
    color: #555;
    text-align: center;
  }
</style>
</head>
<body>
  <div id="container">
    <h1>Union-Find (Disjoint Set) Visualizer</h1>
    <div class="section">
      <label for="sizeInput">Number of elements (max 30): </label>
      <input type="number" id="sizeInput" value="10" min="1" max="30" />
      <button id="initBtn">Initialize</button>
    </div>

    <div id="operations" style="display:none;">
      <div class="section">
        <strong>Union operation:</strong><br/>
        <label for="unionX">Element X: </label><input type="number" id="unionX" min="0" />
        <label for="unionY">Element Y: </label><input type="number" id="unionY" min="0" />
        <button id="unionBtn">Union</button>
      </div>
      <div class="section">
        <strong>Find operation:</strong><br/>
        <label for="findX">Element X: </label><input type="number" id="findX" min="0" />
        <button id="findBtn">Find</button>
      </div>
      <div class="section">
        <button id="showSetsBtn">Show All Sets</button>
        <button id="resetBtn">Reset</button>
      </div>
    </div>

    <div id="output" aria-live="polite" aria-atomic="true"></div>
  </div>

<script>
  class UnionFind {
    constructor(size) {
      this.size = size;
      this.parent = new Array(size);
      this.rank = new Array(size);
      for(let i = 0; i < size; i++) {
        this.parent[i] = i;
        this.rank[i] = 0;
      }
    }

    find(x) {
      if (this.parent[x] !== x) {
        this.parent[x] = this.find(this.parent[x]); // path compression
      }
      return this.parent[x];
    }

    union(x, y) {
      let rootX = this.find(x);
      let rootY = this.find(y);

      if(rootX === rootY) {
        return false; // Already in the same set
      }

      // union by rank
      if(this.rank[rootX] < this.rank[rootY]) {
        this.parent[rootX] = rootY;
      } else if (this.rank[rootX] > this.rank[rootY]) {
        this.parent[rootY] = rootX;
      } else {
        this.parent[rootY] = rootX;
        this.rank[rootX]++;
      }
      return true;
    }

    getSets() {
      // Build sets by root representative
      const sets = new Map();
      for(let i = 0; i < this.size; i++) {
        let root = this.find(i);
        if(!sets.has(root)) {
          sets.set(root, []);
        }
        sets.get(root).push(i);
      }
      return Array.from(sets.values());
    }
  }

  (function(){
    const sizeInput = document.getElementById('sizeInput');
    const initBtn = document.getElementById('initBtn');
    const operationsDiv = document.getElementById('operations');
    const unionX = document.getElementById('unionX');
    const unionY = document.getElementById('unionY');
    const unionBtn = document.getElementById('unionBtn');
    const findX = document.getElementById('findX');
    const findBtn = document.getElementById('findBtn');
    const showSetsBtn = document.getElementById('showSetsBtn');
    const output = document.getElementById('output');
    const resetBtn = document.getElementById('resetBtn');

    let uf = null;
    let n = 0;

    function log(msg) {
      output.textContent += msg + "\n";
      output.scrollTop = output.scrollHeight;
    }
    function clearLog() {
      output.textContent = '';
    }

    function validateElement(x) {
      if(isNaN(x) || x < 0 || x >= n) {
        log(`‚ö†Ô∏è Element ${x} is out of bounds (0 to ${n-1}).`);
        return false;
      }
      return true;
    }

    function displaySets() {
      clearLog();
      const sets = uf.getSets();
      if(sets.length === n) {
        log(`There are ${n} disjoint sets: each element is alone.`);
      } else {
        log(`There are ${sets.length} disjoint sets:`);
      }
      output.appendChild(document.createElement('br'));

      sets.forEach((group, i) => {
        const container = document.createElement('div');
        container.className = 'set-group';
        container.innerHTML = `<strong>Set ${i+1}:</strong> `;
        group.forEach(el => {
          const span = document.createElement('span');
          span.className = 'set-item';
          span.textContent = el;
          container.appendChild(span);
        });
        output.appendChild(container);
      });
      output.appendChild(document.createElement('br'));
    }

    initBtn.addEventListener('click', () => {
      const val = parseInt(sizeInput.value, 10);
      if(isNaN(val) || val < 1 || val > 30) {
        alert('Please enter a valid number of elements between 1 and 30.');
        return;
      }
      n = val;
      uf = new UnionFind(n);
      unionX.min = 0; unionX.max = n - 1; unionX.value = 0;
      unionY.min = 0; unionY.max = n - 1; unionY.value = 0;
      findX.min = 0; findX.max = n - 1; findX.value = 0;
      clearLog();
      log(`‚úÖ Initialized Union-Find structure with ${n} elements (0 to ${n-1}).`);
      operationsDiv.style.display = 'block';
      displaySets();
    });

    unionBtn.addEventListener('click', () => {
      if(!uf) {
        alert('Please initialize first.');
        return;
      }
      const x = parseInt(unionX.value, 10);
      const y = parseInt(unionY.value, 10);
      if(!validateElement(x) || !validateElement(y)) return;
      if (x === y) {
        log(`‚ö†Ô∏è Union operation skipped: elements are the same (${x}).`);
        return;
      }
      const merged = uf.union(x, y);
      if(merged) {
        log(`üîó Union done: merged sets containing ${x} and ${y}.`);
      } else {
        log(`‚ÑπÔ∏è Elements ${x} and ${y} are already in the same set.`);
      }
      displaySets();
    });

    findBtn.addEventListener('click', () => {
      if(!uf) {
        alert('Please initialize first.');
        return;
      }
      const x = parseInt(findX.value, 10);
      if(!validateElement(x)) return;
      const root = uf.find(x);
      log(`üîé Find operation: element ${x} belongs to set represented by ${root}.`);
    });

    showSetsBtn.addEventListener('click', () => {
      if(!uf) {
        alert('Please initialize first.');
        return;
      }
      displaySets();
    });

    resetBtn.addEventListener('click', () => {
      uf = null;
      n = 0;
      operationsDiv.style.display = 'none';
      clearLog();
      log('üóëÔ∏è Reset done. Please initialize a new Union-Find structure.');
    });

  })();
</script>
<footer>
  &copy; 2024 Union-Find Demo
</footer>
</body>
</html>