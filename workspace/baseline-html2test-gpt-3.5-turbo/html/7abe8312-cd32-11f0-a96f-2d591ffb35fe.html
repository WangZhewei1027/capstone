<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Union-Find (Disjoint Set) Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f0f4f8;
  }
  h1 {
    text-align: center;
    margin-bottom: 10px;
  }
  #union-find-container {
    max-width: 600px;
    margin: 0 auto 40px auto;
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 0 12px rgba(0,0,0,0.1);
  }
  .sets-container {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
    margin-bottom: 20px;
  }
  .set-circle {
    background: #1976d2;
    color: white;
    padding: 25px 10px 15px 10px;
    border-radius: 50%;
    width: 70px;
    height: 70px;
    line-height: 26px;
    font-weight: bold;
    font-size: 20px;
    text-align: center;
    user-select: none;
    position: relative;
    cursor: default;
    box-shadow: 0 4px 8px rgb(25 118 210 / 0.3);
    transition: background 0.3s ease;
  }
  .set-circle.leader {
    background: #43a047;
    box-shadow: 0 0 10px 4px #43a047aa;
  }
  .set-circle.dimmed {
    background: #999999;
    box-shadow: none;
  }
  #controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 15px;
    margin-bottom: 10px;
  }
  label, input, button {
    font-size: 16px;
  }
  input[type="number"] {
    padding: 6px 8px;
    width: 70px;
    border: 1px solid #ccc;
    border-radius: 4px;
  }
  button {
    background: #1976d2;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    user-select: none;
    transition: background 0.3s ease;
  }
  button:hover:not(:disabled) {
    background: #115293;
  }
  button:disabled {
    background: #bbb;
    cursor: default;
  }
  #log {
    max-height: 150px;
    overflow-y: auto;
    background: #e3f2fd;
    padding: 15px;
    border-radius: 8px;
    font-family: monospace;
    font-size: 14px;
    white-space: pre-wrap;
    user-select: text;
  }
  #reset-btn {
    background: #e53935;
  }
  #reset-btn:hover {
    background: #b71c1c;
  }
  .footer {
    text-align: center;
    color: #666;
    margin-top: 40px;
    font-size: 14px;
  }
</style>
</head>
<body>
<h1>Union-Find (Disjoint Set) Visualizer</h1>
<div id="union-find-container" role="main" aria-label="Union Find Disjoint Set visualizer">
  <div id="sets" class="sets-container" aria-live="polite" aria-atomic="true" aria-relevant="additions removals">
    <!-- Sets rendered here -->
  </div>

  <div id="controls" aria-label="Union Find operations">
    <label for="elementA">Element A:</label>
    <input type="number" id="elementA" min="0" max="15" value="0" />
    <label for="elementB">Element B:</label>
    <input type="number" id="elementB" min="0" max="15" value="1" />
    <button id="union-btn">Union</button>
    <button id="find-btn">Find</button>
    <button id="reset-btn">Reset</button>
  </div>

  <div id="log" aria-live="polite" aria-atomic="false" aria-relevant="additions">Welcome! Select two elements and perform Union or Find operations.</div>
</div>

<script>
  // Union-Find (Disjoint Set) Implementation with visualization
  class UnionFind {
    constructor(size) {
      this.parent = Array(size);
      this.rank = Array(size);
      for (let i = 0; i < size; i++) {
        this.parent[i] = i;
        this.rank[i] = 0;
      }
    }

    find(x) {
      if (this.parent[x] !== x) {
        this.parent[x] = this.find(this.parent[x]); // Path compression
      }
      return this.parent[x];
    }

    union(x, y) {
      let rootX = this.find(x);
      let rootY = this.find(y);

      if (rootX === rootY) return false; // Already connected

      // Union by rank
      if (this.rank[rootX] < this.rank[rootY]) {
        this.parent[rootX] = rootY;
      } else if (this.rank[rootX] > this.rank[rootY]) {
        this.parent[rootY] = rootX;
      } else {
        this.parent[rootY] = rootX;
        this.rank[rootX]++;
      }
      return true;
    }

    connected(x, y) {
      return this.find(x) === this.find(y);
    }
  }

  (function(){
    const SIZE = 16; // Number of elements in the set (0 to 15)
    const uf = new UnionFind(SIZE);

    const setsContainer = document.getElementById('sets');
    const logEl = document.getElementById('log');
    const elementAInput = document.getElementById('elementA');
    const elementBInput = document.getElementById('elementB');
    const unionButton = document.getElementById('union-btn');
    const findButton = document.getElementById('find-btn');
    const resetButton = document.getElementById('reset-btn');

    // Render the current sets with leaders highlighted
    function renderSets() {
      setsContainer.innerHTML = '';
      // Group elements by their root leaders
      const groups = {};
      for (let i = 0; i < SIZE; i++) {
        const leader = uf.find(i);
        if (!groups[leader]) groups[leader] = [];
        groups[leader].push(i);
      }

      // For visual grouping, sort groups by leader id
      let leadersSorted = Object.keys(groups).map(Number).sort((a,b) => a-b);

      leadersSorted.forEach(leader => {
        const groupEl = document.createElement('div');
        groupEl.className = 'sets-group';
        groups[leader].forEach(elem => {
          const circle = document.createElement('div');
          circle.className = 'set-circle';
          circle.textContent = elem;
          if(elem === leader) {
            circle.classList.add('leader');
            circle.setAttribute('aria-label', `Element ${elem}, group leader`);
          } else {
            circle.setAttribute('aria-label', `Element ${elem}`);
          }
          groupEl.appendChild(circle);
        });
        setsContainer.appendChild(groupEl);
      });
    }

    // Log messages to the log console
    function log(message) {
      const now = new Date().toLocaleTimeString();
      logEl.textContent += '\n[' + now + '] ' + message;
      logEl.scrollTop = logEl.scrollHeight;
    }

    // Validate inputs for elements A and B
    function validateInputs() {
      const a = Number(elementAInput.value);
      const b = Number(elementBInput.value);
      const validRange = (x) => Number.isInteger(x) && x >= 0 && x < SIZE;
      return validRange(a) && validRange(b);
    }

    // On union button click
    unionButton.addEventListener('click', () => {
      if (!validateInputs()) {
        alert('Please enter valid elements between 0 and ' + (SIZE-1));
        return;
      }
      const a = Number(elementAInput.value);
      const b = Number(elementBInput.value);

      if(a === b) {
        alert('Please select two different elements to union.');
        return;
      }

      const merged = uf.union(a,b);
      if (merged) {
        log(`Union done: elements ${a} and ${b} merged.`);
      } else {
        log(`Elements ${a} and ${b} are already in the same set.`);
      }
      renderSets();
    });

    // On find button click
    findButton.addEventListener('click', () => {
      if (!validateInputs()) {
        alert('Please enter valid elements between 0 and ' + (SIZE-1));
        return;
      }
      const a = Number(elementAInput.value);
      const b = Number(elementBInput.value);

      if(uf.connected(a,b)) {
        const leader = uf.find(a);
        log(`Find: elements ${a} and ${b} are connected. Leader: ${leader}`);
      } else {
        log(`Find: elements ${a} and ${b} are NOT connected.`);
      }
    });

    // Reset the structure
    resetButton.addEventListener('click', () => {
      for(let i=0; i<SIZE; i++) {
        uf.parent[i] = i;
        uf.rank[i] = 0;
      }
      log('Union-Find structure reset.');
      renderSets();
    });

    // Initialize rendering
    renderSets();
  })();
</script>
</body>
</html>