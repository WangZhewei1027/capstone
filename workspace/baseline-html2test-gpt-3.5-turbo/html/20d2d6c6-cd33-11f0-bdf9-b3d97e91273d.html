<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Kruskal's Algorithm Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0; padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    background: #f9f9f9;
    min-height: 100vh;
  }
  h1 {
    margin: 20px 0 10px;
  }
  #container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 20px;
    max-width: 1000px;
    width: 90vw;
  }
  #graph-canvas {
    border: 1px solid #ccc;
    background: white;
    border-radius: 8px;
  }
  #controls {
    margin-top: 15px;
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
  }
  button, select {
    padding: 10px 15px;
    font-size: 1rem;
    border-radius: 6px;
    border: 1px solid #666;
    cursor: pointer;
    background: white;
    transition: background-color 0.3s ease;
  }
  button:hover, select:hover {
    background: #eee;
  }
  button:disabled {
    cursor: not-allowed;
    opacity: 0.6;
  }
  #info {
    max-width: 1000px;
    margin: 20px auto;
    background: white;
    padding: 15px 20px;
    border-radius: 8px;
    box-shadow: 0 0 8px rgb(0 0 0 / 0.1);
    font-size: 1rem;
    line-height: 1.4;
  }
  #edges-list {
    max-height: 150px;
    overflow-y: auto;
    background: #fafafa;
    border: 1px solid #ccc;
    margin-top: 10px;
    padding: 5px 10px;
    font-family: monospace;
    border-radius: 4px;
  }
</style>
</head>
<body>
  <h1>Kruskal's Algorithm Visualization</h1>
  <div id="container">
    <canvas id="graph-canvas" width="700" height="500" aria-label="Graph visualization"></canvas>
    <div id="info" aria-live="polite" role="region">
      <strong>Algorithm Info:</strong>
      <p>Kruskal's algorithm finds a Minimum Spanning Tree (MST) of a weighted, connected graph by selecting edges in increasing order of weight while avoiding cycles.</p>
      <p><strong>Step explanation:</strong></p>
      <ul>
        <li>Sort all edges by weight (lowest to highest).</li>
        <li>Initialize a forest where each vertex is its own set.</li>
        <li>Iterate edges in sorted order and add an edge if it connects two distinct sets.</li>
        <li>Union the sets connected by that edge.</li>
        <li>Stop when all vertices are connected (MST formed).</li>
      </ul>
      <p><strong>Selected edges (MST):</strong></p>
      <div id="edges-list" aria-label="List of edges selected in the minimum spanning tree" tabindex="0"></div>
    </div>
  </div>
  <div id="controls" aria-label="Algorithm controls">
    <label for="graph-select">Select Graph:</label>
    <select id="graph-select" aria-controls="graph-canvas">
      <option value="default">Default Sample Graph</option>
      <option value="triangle">Triangle Graph</option>
      <option value="square">Square Graph</option>
      <option value="custom">Custom Graph (Add edges)</option>
    </select>
    <button id="start-btn">Start</button>
    <button id="step-btn" disabled>Step</button>
    <button id="auto-btn" disabled>Auto Run</button>
    <button id="reset-btn" disabled>Reset</button>
  </div>
  <div id="custom-graph-controls" style="margin-top: 15px; max-width: 700px; display:none; background:#fff; padding:15px; border-radius:8px; box-shadow: 0 0 8px rgb(0 0 0 / 0.1);">
    <strong>Add Edge to Custom Graph:</strong><br />
    <label>From:
      <select id="custom-from"></select>
    </label>
    <label>To:
      <select id="custom-to"></select>
    </label>
    <label>Weight:
      <input type="number" id="custom-weight" min="1" max="100" value="1" style="width: 60px" />
    </label>
    <button id="custom-add-edge">Add Edge</button>
    <button id="custom-clear" style="margin-left: 10px;">Clear Custom Graph</button>
    <p><small>Note: Vertices are labeled A-K.</small></p>
  </div>

<script>
(() => {
  // Graph data structures
  // Graph vertices are labeled with uppercase letters A-J (max 10 vertices for ease)
  // Graph edges are objects: {from: 'A', to: 'B', weight: n, id: unique}

  // We will draw the graph on canvas with force-directed coordinates or fixed positions.

  // Predefined graphs
  const predefinedGraphs = {
    default: {
      vertices: ['A','B','C','D','E','F','G'],
      edges: [
        {from:'A', to:'B', weight:7},
        {from:'A', to:'D', weight:5},
        {from:'B', to:'C', weight:8},
        {from:'B', to:'D', weight:9},
        {from:'B', to:'E', weight:7},
        {from:'C', to:'E', weight:5},
        {from:'D', to:'E', weight:15},
        {from:'D', to:'F', weight:6},
        {from:'E', to:'F', weight:8},
        {from:'E', to:'G', weight:9},
        {from:'F', to:'G', weight:11},
      ],
      positions: {
        A: [70, 150],
        B: [180, 80],
        C: [310, 110],
        D: [130, 230],
        E: [250, 230],
        F: [350, 220],
        G: [430, 170]
      }
    },
    triangle: {
      vertices: ['A','B','C'],
      edges: [
        {from:'A', to:'B', weight:3},
        {from:'B', to:'C', weight:1},
        {from:'A', to:'C', weight:2},
      ],
      positions: {
        A: [100, 250],
        B: [250, 250],
        C: [180, 170]
      }
    },
    square: {
      vertices: ['A','B','C','D'],
      edges: [
        {from:'A', to:'B', weight:4},
        {from:'B', to:'C', weight:1},
        {from:'C', to:'D', weight:3},
        {from:'D', to:'A', weight:2},
        {from:'A', to:'C', weight:5}, // diagonal
      ],
      positions: {
        A: [150, 180],
        B: [250, 180],
        C: [250, 300],
        D: [150, 300],
      }
    }
  };

  // Variables to hold current graph & MST state
  let currentGraph = null;
  let MSTedges = []; // edges selected in MST
  let edgesSorted = [];
  let stepIndex = 0;
  let unionFind = null;
  let autoInterval = null;

  // Canvas setup
  const canvas = document.getElementById('graph-canvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  // Controls
  const startBtn = document.getElementById('start-btn');
  const stepBtn = document.getElementById('step-btn');
  const autoBtn = document.getElementById('auto-btn');
  const resetBtn = document.getElementById('reset-btn');
  const graphSelect = document.getElementById('graph-select');
  const edgesListDiv = document.getElementById('edges-list');

  // Custom Graph Controls
  const customControls = document.getElementById('custom-graph-controls');
  const customFrom = document.getElementById('custom-from');
  const customTo = document.getElementById('custom-to');
  const customWeight = document.getElementById('custom-weight');
  const customAddEdgeBtn = document.getElementById('custom-add-edge');
  const customClearBtn = document.getElementById('custom-clear');

  // Helper - Union-Find (Disjoint Set) structure
  class UnionFind {
    constructor(elements) {
      this.parent = {};
      this.rank = {};
      elements.forEach(e => {
        this.parent[e] = e;
        this.rank[e] = 0;
      });
    }
    find(x) {
      if(this.parent[x] !== x) {
        this.parent[x] = this.find(this.parent[x]);
      }
      return this.parent[x];
    }
    union(a,b) {
      const rootA = this.find(a);
      const rootB = this.find(b);
      if(rootA === rootB) return false;
      if(this.rank[rootA] < this.rank[rootB]) {
        this.parent[rootA] = rootB;
      } else if(this.rank[rootB] < this.rank[rootA]) {
        this.parent[rootB] = rootA;
      } else {
        this.parent[rootB] = rootA;
        this.rank[rootA]++;
      }
      return true;
    }
  }


  // Draw helpers
  function drawGraph(graph, highlightEdges = [], disabledEdges = [], unionSets = null, highlightEdge = null) {
    ctx.clearRect(0,0,W,H);
    // Draw edges first
    // Draw edges: black lines, highlightEdges in green, disabledEdges in light grey, highlightEdge in blue
    for(let edge of graph.edges) {
      const posA = graph.positions[edge.from];
      const posB = graph.positions[edge.to];
      const isHighlight = highlightEdges.some(e => e.id === edge.id);
      const isDisabled = disabledEdges.some(e => e.id === edge.id);
      const isCurrent = highlightEdge && (highlightEdge.id === edge.id);

      ctx.beginPath();
      ctx.moveTo(posA[0], posA[1]);
      ctx.lineTo(posB[0], posB[1]);
      if(isCurrent) {
        ctx.strokeStyle = '#007bff'; // blue
        ctx.lineWidth = 4;
      } else if(isHighlight) {
        ctx.strokeStyle = '#28a745'; // green
        ctx.lineWidth = 4;
      } else if(isDisabled) {
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
      } else {
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
      }
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw weight near middle with slight offset
      const midX = (posA[0] + posB[0]) / 2;
      const midY = (posA[1] + posB[1]) / 2;
      ctx.fillStyle = '#222';
      ctx.font = '14px Arial';
      ctx.fillText(edge.weight, midX + 5, midY - 5);
    }

    // Draw vertices
    // If unionSets given, color vertices by set for visualization
    // We'll use a palette
    const colors = [
      '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
      '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe'
    ];
    let setColors = {};
    if(unionSets) {
      let roots = [...new Set(Object.values(unionSets.parent).map(x => unionSets.find(x)))];
      roots.forEach((r,i) => {
        setColors[r] = colors[i % colors.length];
      });
    }

    for(let v of graph.vertices) {
      const [x,y] = graph.positions[v];
      let fillColor = '#fff';
      let strokeColor = '#333';

      if(unionSets) {
        const root = unionSets.find(v);
        fillColor = setColors[root];
      }
      ctx.beginPath();
      ctx.fillStyle = fillColor;
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = 2;
      ctx.arc(x, y, 20, 0, 2*Math.PI);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#000';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(v, x, y);
    }
  }

  // Generate unique edge IDs for internal use
  function assignEdgeIds(graph) {
    let idCount = 0;
    graph.edges.forEach(e => {
      e.id = idCount++;
      // For MST union-find and list, we want edges normalized so from < to alphabetically when displaying
      if(e.from > e.to) {
        [e.from, e.to] = [e.to, e.from];
      }
    });
  }

  // Prepare graph for MST algorithm
  function prepareGraph(graph) {
    // assign ids to edges
    assignEdgeIds(graph);
    MSTedges = [];
    stepIndex = 0;
    // sort edges by weight ascending (stable)
    edgesSorted = [...graph.edges].sort((a,b) => a.weight - b.weight);
    unionFind = new UnionFind(graph.vertices);
  }

  // Update edges-list div with MST edges
  function updateEdgesList() {
    if(MSTedges.length === 0) {
      edgesListDiv.textContent = 'No edges selected yet.';
      return;
    }
    // Sort edges lex by from-to for presentation
    const sortedMST = [...MSTedges].sort((a,b) => {
      if(a.from < b.from) return -1;
      if(a.from > b.from) return 1;
      if(a.to < b.to) return -1;
      if(a.to > b.to) return 1;
      return 0;
    });
    edgesListDiv.innerHTML = sortedMST.map(e => `(${e.from} - ${e.to}) weight: ${e.weight}`).join('<br>');
  }

  // Step the MST algorithm forward
  // Returns true if step done, false if finished
  function stepMST() {
    if(stepIndex >= edgesSorted.length) {
      return false;
    }
    const edge = edgesSorted[stepIndex];
    // Check if edge connects two different sets
    const u = unionFind.find(edge.from);
    const v = unionFind.find(edge.to);
    if(u !== v) {
      unionFind.union(u,v);
      MSTedges.push(edge);
    }
    stepIndex++;
    return true;
  }

  // Draw with current MST progress and highlight current edge
  function drawStep() {
    let highlightEdge = null;
    if(stepIndex < edgesSorted.length) {
      highlightEdge = edgesSorted[stepIndex];
    }
    drawGraph(currentGraph, MSTedges, edgesSorted.slice(stepIndex), unionFind, highlightEdge);
    updateEdgesList();
  }

  // Controls enable/disable helper
  function setControls(state) {
    // state: 'init', 'running', 'finished'
    if(state === 'init') {
      startBtn.disabled = false;
      stepBtn.disabled = true;
      autoBtn.disabled = true;
      resetBtn.disabled = true;
      graphSelect.disabled = false;
      if(graphSelect.value === "custom") customControls.style.display = 'block';
      else customControls.style.display = 'none';
    } else if(state === 'running') {
      startBtn.disabled = true;
      stepBtn.disabled = false;
      autoBtn.disabled = false;
      resetBtn.disabled = false;
      graphSelect.disabled = true;
      customControls.style.display = 'none';
    } else if(state === 'finished') {
      startBtn.disabled = true;
      stepBtn.disabled = true;
      autoBtn.disabled = true;
      resetBtn.disabled = false;
      graphSelect.disabled = true;
      customControls.style.display = 'none';
    }
  }

  // Initialize the canvas with chosen graph
  function loadGraph(name) {
    if(name === 'custom') {
      // Custom graph with initially empty graph
      // We'll allow adding edges between vertices A-K (max 11 vertices)
      if(!window.customGraph) {
        window.customGraph = {
          vertices: ['A','B','C','D','E','F','G','H','I','J','K'],
          edges: [],
          positions: {
            A:[100, 150], B:[160,100], C:[220,150], D:[280,100], E:[340,150],
            F:[100, 250], G:[160, 300], H:[220, 250], I:[280, 300], J:[340, 250], K:[400, 200]
          }
        };
      }
      currentGraph = {
        vertices: [...window.customGraph.vertices],
        edges: [...window.customGraph.edges],
        positions: {...window.customGraph.positions}
      };
      assignEdgeIds(currentGraph);
      return;
    }
    const g = predefinedGraphs[name];
    if(!g) {
      alert("Graph not found!");
      return;
    }
    currentGraph = {
      vertices: [...g.vertices],
      edges: g.edges.map(e => ({...e})),
      positions: {...g.positions}
    };
    assignEdgeIds(currentGraph);
  }

  // Initialize custom selects (from-to vertex selectors)
  function initCustomSelectors() {
    const verts = window.customGraph.vertices;
    customFrom.innerHTML = '';
    customTo.innerHTML = '';
    verts.forEach(v => {
      const opt1 = document.createElement('option');
      opt1.value = v;
      opt1.textContent = v;
      customFrom.appendChild(opt1);

      const opt2 = document.createElement('option');
      opt2.value = v;
      opt2.textContent = v;
      customTo.appendChild(opt2);
    });
  }

  // Clear custom graph edges
  function clearCustomGraph() {
    window.customGraph.edges.length = 0;
    loadGraph('custom');
    drawGraph(currentGraph);
    updateEdgesList();
  }

  // Event listeners

  startBtn.addEventListener('click', () => {
    if(!currentGraph) {
      alert("Load a graph first");
      return;
    }
    prepareGraph(currentGraph);
    drawStep();
    setControls('running');
  });

  stepBtn.addEventListener('click', () => {
    if(stepMST()) {
      drawStep();
    } else {
      // Finished MST
      drawGraph(currentGraph, MSTedges, [], unionFind);
      updateEdgesList();
      setControls('finished');
      if(autoInterval) {
        clearInterval(autoInterval);
        autoInterval = null;
      }
    }
  });

  autoBtn.addEventListener('click', () => {
    if(autoInterval) {
      clearInterval(autoInterval);
      autoInterval = null;
      autoBtn.textContent = 'Auto Run';
      stepBtn.disabled = false;
    } else {
      autoBtn.textContent = 'Pause';
      stepBtn.disabled = true;
      autoInterval = setInterval(() => {
        const hasNext = stepMST();
        drawStep();
        if(!hasNext) {
          drawGraph(currentGraph, MSTedges, [], unionFind);
          updateEdgesList();
          setControls('finished');
          clearInterval(autoInterval);
          autoInterval = null;
          autoBtn.textContent = 'Auto Run';
          stepBtn.disabled = true;
        }
      }, 1000);
    }
  });

  resetBtn.addEventListener('click', () => {
    if(autoInterval) {
      clearInterval(autoInterval);
      autoInterval = null;
    }
    stepIndex = 0;
    MSTedges = [];
    unionFind = null;
    loadGraph(graphSelect.value);
    drawGraph(currentGraph);
    updateEdgesList();
    setControls('init');
  });

  graphSelect.addEventListener('change', () => {
    if(autoInterval) {
      clearInterval(autoInterval);
      autoInterval = null;
    }
    stepIndex = 0;
    MSTedges = [];
    unionFind = null;
    loadGraph(graphSelect.value);
    drawGraph(currentGraph);
    updateEdgesList();
    setControls('init');
    if(graphSelect.value === 'custom') {
      customControls.style.display = 'block';
    } else {
      customControls.style.display = 'none';
    }
  });

  customAddEdgeBtn.addEventListener('click', () => {
    const fromV = customFrom.value;
    const toV = customTo.value;
    const w = Number(customWeight.value);
    if(fromV === toV) {
      alert("Cannot add edge from a vertex to itself.");
      return;
    }
    if(!w || w <= 0) {
      alert("Weight should be a positive number.");
      return;
    }
    // Check for duplicate edges (in either direction)
    const exists = window.customGraph.edges.some(e => {
      return (e.from === fromV && e.to === toV) || (e.from === toV && e.to === fromV);
    });
    if(exists) {
      alert("Edge already exists.");
      return;
    }
    window.customGraph.edges.push({from: fromV, to: toV, weight: w});
    loadGraph('custom');
    drawGraph(currentGraph);
    updateEdgesList();
  });

  customClearBtn.addEventListener('click', () => {
    if(confirm("Clear all edges in the custom graph?")) {
      clearCustomGraph();
    }
  });

  // Initial load
  function init() {
    loadGraph('default');
    drawGraph(currentGraph);
    updateEdgesList();
    setControls('init');
    if(!window.customGraph) {
      window.customGraph = {
        vertices: ['A','B','C','D','E','F','G','H','I','J','K'],
        edges: [],
        positions: {
          A:[100, 150], B:[160,100], C:[220,150], D:[280,100], E:[340,150],
          F:[100, 250], G:[160, 300], H:[220, 250], I:[280, 300], J:[340, 250], K:[400, 200]
        }
      };
    }
    initCustomSelectors();
  }

  init();

})();
</script>

</body>
</html>