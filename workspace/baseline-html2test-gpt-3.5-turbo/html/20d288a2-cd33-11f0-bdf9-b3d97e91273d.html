<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Min Heap and Max Heap Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  h1, h2 {
    color: #333;
  }
  .heap-container {
    margin-top: 20px;
    display: flex;
    gap: 40px;
  }
  .heap-box {
    border: 2px solid #007acc;
    padding: 15px;
    border-radius: 8px;
    width: 45%;
  }
  label {
    display: block;
    margin-bottom: 6px;
    font-weight: bold;
  }
  input[type="number"] {
    width: 100%;
    padding: 6px;
    font-size: 16px;
    margin-bottom: 10px;
    box-sizing: border-box;
  }
  button {
    background-color: #007acc;
    color: white;
    border: none;
    padding: 10px 16px;
    font-size: 16px;
    cursor: pointer;
    border-radius: 4px;
  }
  button:hover {
    background-color: #005fa3;
  }
  .output {
    margin-top: 10px;
    background-color: #f4f9ff;
    padding: 10px;
    border-radius: 4px;
    font-family: monospace;
    min-height: 38px;
    white-space: pre-wrap;
  }
  .heap-array {
    font-weight: bold;
    margin-top: 8px;
  }
  .note {
    margin-top: 10px;
    font-size: 0.9em;
    color: #555;
    font-style: italic;
  }
</style>
</head>
<body>
<h1>Heap (Min Heap / Max Heap) Demonstration</h1>
<p>This demo shows how Min Heaps and Max Heaps work. You can insert numbers and extract the root (minimum or maximum) from each heap.</p>

<div class="heap-container">
  <div class="heap-box" id="minHeapBox">
    <h2>Min Heap</h2>
    <label for="minValueInput">Insert value:</label>
    <input type="number" id="minValueInput" />
    <button id="minInsertBtn">Insert</button>
    <button id="minExtractBtn">Extract Min</button>
    <div class="output" id="minOutput">Heap is empty</div>
    <div class="heap-array" id="minHeapArray"></div>
    <div class="note">Root is the smallest element</div>
  </div>

  <div class="heap-box" id="maxHeapBox">
    <h2>Max Heap</h2>
    <label for="maxValueInput">Insert value:</label>
    <input type="number" id="maxValueInput" />
    <button id="maxInsertBtn">Insert</button>
    <button id="maxExtractBtn">Extract Max</button>
    <div class="output" id="maxOutput">Heap is empty</div>
    <div class="heap-array" id="maxHeapArray"></div>
    <div class="note">Root is the largest element</div>
  </div>
</div>

<script>
  // Heap class that can function as Min or Max Heap depending on comparator
  class Heap {
    constructor(comparator) {
      this.data = [];
      this.compare = comparator;
    }

    // Return parent index
    parent(i) {
      return Math.floor((i - 1) / 2);
    }
    // Return left child index
    left(i) {
      return 2 * i + 1;
    }
    // Return right child index
    right(i) {
      return 2 * i + 2;
    }

    // Swap elements at indices i and j
    swap(i, j) {
      [this.data[i], this.data[j]] = [this.data[j], this.data[i]];
    }

    // Insert new value
    insert(value) {
      this.data.push(value);
      this.heapifyUp(this.data.length - 1);
    }

    // Heapify up (used after insert)
    heapifyUp(index) {
      let current = index;
      while (
        current > 0 &&
        this.compare(this.data[current], this.data[this.parent(current)])
      ) {
        this.swap(current, this.parent(current));
        current = this.parent(current);
      }
    }

    // Heapify down (used after extraction)
    heapifyDown(index) {
      let current = index;
      const size = this.data.length;

      while (true) {
        const leftIdx = this.left(current);
        const rightIdx = this.right(current);
        let next = current;

        if (
          leftIdx < size &&
          this.compare(this.data[leftIdx], this.data[next])
        ) {
          next = leftIdx;
        }
        if (
          rightIdx < size &&
          this.compare(this.data[rightIdx], this.data[next])
        ) {
          next = rightIdx;
        }
        if (next !== current) {
          this.swap(current, next);
          current = next;
        } else {
          break;
        }
      }
    }

    // Extract root (min or max)
    extractRoot() {
      if (this.data.length === 0) return null;
      if (this.data.length === 1) return this.data.pop();
      const root = this.data[0];
      this.data[0] = this.data.pop();
      this.heapifyDown(0);
      return root;
    }

    // Peek root value
    peek() {
      if (this.data.length === 0) return null;
      return this.data[0];
    }

    // Get heap data as string
    toString() {
      return this.data.join(", ");
    }
  }

  // Min Heap comparator: returns true if a < b
  function minComparator(a, b) {
    return a < b;
  }
  // Max Heap comparator: returns true if a > b
  function maxComparator(a, b) {
    return a > b;
  }

  // Initialize Min and Max heaps
  const minHeap = new Heap(minComparator);
  const maxHeap = new Heap(maxComparator);

  // DOM Elements for Min Heap
  const minValueInput = document.getElementById("minValueInput");
  const minInsertBtn = document.getElementById("minInsertBtn");
  const minExtractBtn = document.getElementById("minExtractBtn");
  const minOutput = document.getElementById("minOutput");
  const minHeapArray = document.getElementById("minHeapArray");

  // DOM Elements for Max Heap
  const maxValueInput = document.getElementById("maxValueInput");
  const maxInsertBtn = document.getElementById("maxInsertBtn");
  const maxExtractBtn = document.getElementById("maxExtractBtn");
  const maxOutput = document.getElementById("maxOutput");
  const maxHeapArray = document.getElementById("maxHeapArray");

  function updateMinHeapDisplay() {
    if (minHeap.data.length === 0) {
      minOutput.textContent = "Heap is empty";
      minHeapArray.textContent = "";
    } else {
      minOutput.textContent = "Min (root): " + minHeap.peek();
      minHeapArray.textContent = "Heap Array: [" + minHeap.toString() + "]";
    }
  }

  function updateMaxHeapDisplay() {
    if (maxHeap.data.length === 0) {
      maxOutput.textContent = "Heap is empty";
      maxHeapArray.textContent = "";
    } else {
      maxOutput.textContent = "Max (root): " + maxHeap.peek();
      maxHeapArray.textContent = "Heap Array: [" + maxHeap.toString() + "]";
    }
  }

  minInsertBtn.addEventListener("click", () => {
    const val = Number(minValueInput.value);
    if (isNaN(val)) {
      alert("Please enter a valid number to insert.");
      return;
    }
    minHeap.insert(val);
    minValueInput.value = "";
    updateMinHeapDisplay();
  });

  minExtractBtn.addEventListener("click", () => {
    const extracted = minHeap.extractRoot();
    if (extracted === null) {
      alert("Heap is empty, nothing to extract.");
    } else {
      minOutput.textContent = "Extracted Min: " + extracted;
      updateMinHeapDisplay();
    }
  });

  maxInsertBtn.addEventListener("click", () => {
    const val = Number(maxValueInput.value);
    if (isNaN(val)) {
      alert("Please enter a valid number to insert.");
      return;
    }
    maxHeap.insert(val);
    maxValueInput.value = "";
    updateMaxHeapDisplay();
  });

  maxExtractBtn.addEventListener("click", () => {
    const extracted = maxHeap.extractRoot();
    if (extracted === null) {
      alert("Heap is empty, nothing to extract.");
    } else {
      maxOutput.textContent = "Extracted Max: " + extracted;
      updateMaxHeapDisplay();
    }
  });

  // Initial display update
  updateMinHeapDisplay();
  updateMaxHeapDisplay();
</script>
</body>
</html>