<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Huffman Coding Demonstration</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 2rem;
    background: #f4f4f9;
    color: #222;
  }
  h1 {
    text-align: center;
    color: #3a3a8f;
  }
  textarea {
    width: 100%;
    height: 80px;
    font-size: 1.2rem;
    padding: 0.5rem;
    resize: vertical;
  }
  button {
    margin-top: 1rem;
    padding: 0.6rem 1.2rem;
    font-size: 1.1rem;
    background-color: #3a3a8f;
    border: none;
    color: white;
    border-radius: 4px;
    cursor: pointer;
  }
  button:hover {
    background-color: #2c2c6f;
  }
  .result {
    margin-top: 2rem;
    background: white;
    padding: 1rem;
    border-radius: 6px;
    box-shadow: 0 0 5px #aaa;
  }
  .tree-node {
    display: inline-block;
    vertical-align: top;
    text-align: center;
    font-size: 0.9rem;
    margin: 0.2rem 1rem 2rem 1rem;
  }
  .tree-branch {
    border-left: 2px solid #555;
    margin-left: 50%;
    height: 40px;
  }
  .tree-children {
    display: flex;
    justify-content: center;
  }
  .code-table {
    border-collapse: collapse;
    width: auto;
    margin-top: 1rem;
  }
  .code-table th, .code-table td {
    border: 1px solid #ddd;
    padding: 0.4rem 0.7rem;
    text-align: center;
  }
  .code-table th {
    background-color: #3a3a8f;
    color: white;
  }
  .binary-output {
    font-family: monospace;
    background: #222;
    color: #8f8;
    padding: 0.7rem;
    margin-top: 1rem;
    white-space: pre-wrap;
    word-break: break-word;
  }
  .explanation {
    margin-top: 1rem;
    font-size: 0.9rem;
    color: #555;
  }
  footer {
    text-align: center;
    margin-top: 3rem;
    font-size: 0.85rem;
    color: #666;
  }
</style>
</head>
<body>
<h1>Huffman Coding Demonstration</h1>
<p>Enter a string below and see its Huffman encoding, decoding, and tree visualization.</p>
<textarea id="inputText" placeholder="Type your text here (e.g. hello huffman)"></textarea>
<button id="encodeBtn">Encode & Decode</button>

<div class="result" id="result" style="display:none;">
  <h2>Frequency Table:</h2>
  <table class="code-table" id="freqTable"></table>

  <h2>Huffman Tree Visualization:</h2>
  <div id="treeContainer"></div>

  <h2>Huffman Codes:</h2>
  <table class="code-table" id="codeTable"></table>

  <h2>Encoded Binary String:</h2>
  <div class="binary-output" id="encodedOutput"></div>

  <h2>Decoded String:</h2>
  <p id="decodedOutput" style="font-weight:bold; font-size:1.1rem;"></p>

  <div class="explanation" id="explanation"></div>
</div>

<script>
  // Build Huffman coding classes and functions

  class HuffmanNode {
    constructor(char, freq, left=null, right=null) {
      this.char = char;
      this.freq = freq;
      this.left = left;
      this.right = right;
    }
    // Check if leaf
    isLeaf() {
      return !this.left && !this.right;
    }
  }

  function buildFrequencyTable(str) {
    const freqMap = new Map();
    for (let ch of str) {
      freqMap.set(ch, (freqMap.get(ch)||0)+1);
    }
    return freqMap;
  }

  // Build min-priority queue based on freq using array (for simplicity)
  function buildHuffmanTree(freqMap) {
    let nodes = [];
    // create leaf nodes
    for (let [ch,freq] of freqMap) {
      nodes.push(new HuffmanNode(ch, freq));
    }

    if(nodes.length === 0) return null;

    // edge: if only one char, make a dummy node as parent for correct coding
    if (nodes.length === 1) {
      let loneNode = nodes[0];
      return new HuffmanNode(null, loneNode.freq, loneNode, null);
    }

    // build tree
    while (nodes.length > 1) {
      nodes.sort((a,b)=>a.freq - b.freq);
      let left = nodes.shift();
      let right = nodes.shift();
      let parent = new HuffmanNode(null, left.freq + right.freq, left, right);
      nodes.push(parent);
    }
    return nodes[0];
  }

  // Generate codes by traversing tree
  function generateCodes(root) {
    const codes = new Map();
    function traverse(node, path) {
      if (!node) return;
      if (node.isLeaf()) {
        codes.set(node.char, path || "0");  // if single char tree, assign "0"
      } else {
        traverse(node.left, path + "0");
        traverse(node.right, path + "1");
      }
    }
    traverse(root, "");
    return codes;
  }

  // Encode string to bits:
  function encode(str, codes) {
    let result = "";
    for (let ch of str) {
      result += codes.get(ch);
    }
    return result;
  }

  // Decode bits to string using tree
  function decode(bits, root) {
    let result = "";
    let node = root;
    for(let bit of bits){
      node = bit === "0" ? node.left : node.right;
      if(node.isLeaf()){
        result += node.char;
        node = root;
      }
    }
    return result;
  }

  // Visualization of tree as nested divs with branching lines:
  // We'll draw each node and below its two children horizontally aligned.

  function createTreeDiv(node) {
    if (!node) return null;

    const div = document.createElement("div");
    div.className = "tree-node";

    // Label for node
    let label = "";
    if (node.isLeaf()) {
      label = `"${node.char}"<br/><small>freq: ${node.freq}</small>`;
    } else {
      label = `<small>freq: ${node.freq}</small>`;
    }
    div.innerHTML = `<div style="padding:4px 10px; border: 2px solid #3a3a8f; border-radius: 6px; background:#e0e0f8;">${label}</div>`;

    if (!node.isLeaf()) {
      // create horizontal container for children
      const childrenDiv = document.createElement("div");
      childrenDiv.className = "tree-children";

      // create branches
      const leftDiv = createTreeDiv(node.left);
      const rightDiv = createTreeDiv(node.right);

      childrenDiv.appendChild(leftDiv);
      childrenDiv.appendChild(rightDiv);

      // vertical connection line from parent to children
      const branchDiv = document.createElement("div");
      branchDiv.className = "tree-branch";

      div.appendChild(branchDiv);
      div.appendChild(childrenDiv);
    }
    return div;
  }

  // Fill frequency table
  function fillFrequencyTable(freqMap, el) {
    el.innerHTML = "";
    if (freqMap.size === 0) return;
    const header = document.createElement("tr");
    header.innerHTML = "<th>Character</th><th>Frequency</th>";
    el.appendChild(header);

    Array.from(freqMap.entries())
      .sort((a,b)=>b[1]-a[1])
      .forEach(([ch,freq]) => {
      const row = document.createElement("tr");
      const dispChar = ch === " " ? "(space)" : ch === "\n" ? "\\n" : ch === "\t" ? "\\t" : ch;
      row.innerHTML = `<td>${dispChar}</td><td>${freq}</td>`;
      el.appendChild(row);
    });
  }

  // Fill codes table
  function fillCodesTable(codes, freqMap, el) {
    el.innerHTML = "";
    const header = document.createElement("tr");
    header.innerHTML = "<th>Character</th><th>Frequency</th><th>Huffman Code</th>";
    el.appendChild(header);

    Array.from(codes.entries())
      .sort((a,b)=>{
        // Sort by frequency desc for display only
        const fa = freqMap.get(a[0]) || 0;
        const fb = freqMap.get(b[0]) || 0;
        return fb - fa;
      })
      .forEach(([ch, code]) => {
      const freq = freqMap.get(ch);
      const dispChar = ch === " " ? "(space)" : ch === "\n" ? "\\n" : ch === "\t" ? "\\t" : ch;
      const row = document.createElement("tr");
      row.innerHTML = `<td>${dispChar}</td><td>${freq}</td><td style="font-family: monospace;">${code}</td>`;
      el.appendChild(row);
    });
  }

  document.getElementById("encodeBtn").addEventListener("click", () => {
    const input = document.getElementById("inputText").value;
    const resultDiv = document.getElementById("result");
    const freqMap = buildFrequencyTable(input);
    
    // Hide result if empty input
    if(input.length === 0){
      alert("Please enter some text to encode.");
      return;
    }

    // build tree and codes
    const root = buildHuffmanTree(freqMap);
    if(!root){
      alert("Input string cannot be encoded.");
      return;
    }
    const codes = generateCodes(root);
    const encoded = encode(input, codes);
    const decoded = decode(encoded, root);

    // Fill frequency table
    fillFrequencyTable(freqMap, document.getElementById("freqTable"));
    // Fill code table
    fillCodesTable(codes, freqMap, document.getElementById("codeTable"));

    // Show encoded output with spacing of 8 bits for readability
    const spacedEncoded = encoded.match(/.{1,8}/g).join(' ');

    document.getElementById("encodedOutput").textContent = spacedEncoded;
    document.getElementById("decodedOutput").textContent = decoded;

    // Visualize tree
    const treeContainer = document.getElementById("treeContainer");
    treeContainer.innerHTML = "";
    treeContainer.appendChild(createTreeDiv(root));

    // Show explanation
    const explanationEl = document.getElementById("explanation");
    explanationEl.innerHTML = `
    <strong>How Huffman Coding Works:</strong><br/>
    - The string's characters are counted to create a frequency table.<br/>
    - A binary tree is built by combining the least frequent nodes first.<br/>
    - Each character is assigned a unique prefix code based on its path in the tree, with <code>0</code> for left and <code>1</code> for right.<br/>
    - The input string is encoded by replacing each character with its code.<br/>
    - Decoding uses the tree to translate the binary back to characters.<br/>
    - Huffman coding produces an optimal prefix-free binary encoding minimizing the average code length.
    `;

    resultDiv.style.display = "block";
  });
</script>
</body>
</html>