<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Heap (Min/Max) Demonstration</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 1em;
    max-width: 800px;
  }
  h1, h2 {
    text-align: center;
  }
  .heap-container {
    display: flex;
    justify-content: space-around;
    margin-top: 1em;
  }
  .heap-box {
    border: 1px solid #aaa;
    padding: 1em;
    width: 45%;
    box-sizing: border-box;
    background: #f9f9f9;
  }
  pre {
    background: #eee;
    padding: 1em;
    overflow-x: auto;
  }
  input[type=number] {
    width: 4em;
  }
  button {
    margin-left: 0.5em;
  }
  .heap-visual {
    margin-top: 1em;
  }
  .node {
    display: inline-block;
    background: #4a90e2;
    color: white;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    line-height: 40px;
    text-align: center;
    margin: 0 7px;
    font-weight: bold;
    user-select: none;
    position: relative;
  }
  .heap-level {
    margin-bottom: 1.2em;
    white-space: nowrap;
  }
  .connections {
    position: relative;
    height: 40px;
    margin-bottom: 10px;
  }
  /* Lines connecting nodes */
  .line-left, .line-right {
    position: absolute;
    border-top: 2px solid #555;
    top: 0;
    width: 20px;
  }
  .line-left {
    transform: rotate(310deg);
    left: 50%;
    transform-origin: left top;
  }
  .line-right {
    transform: rotate(50deg);
    right: 50%;
    transform-origin: right top;
  }
</style>
</head>
<body>

<h1>Heap (Min/Max) Demonstration</h1>
<p>
  A <strong>Heap</strong> is a specialized tree-based data structure that satisfies the heap property:
  - <strong>Min-Heap:</strong> Parent node ≤ children
  - <strong>Max-Heap:</strong> Parent node ≥ children
</p>

<div style="text-align:center; margin-bottom: 1em;">
  <label>
    Choose heap type:
    <select id="heapType">
      <option value="min">Min-Heap</option>
      <option value="max">Max-Heap</option>
    </select>
  </label>
</div>

<div style="text-align:center; margin-bottom: 1em;">
  <input type="number" id="inputValue" placeholder="Value" />
  <button id="insertBtn">Insert</button>
  <button id="extractBtn">Extract Root</button>
  <button id="clearBtn">Clear</button>
</div>

<div class="heap-container">
  <div class="heap-box">
    <h2>Heap Array Representation</h2>
    <pre id="heapArrayDisplay">[]</pre>
  </div>
  <div class="heap-box">
    <h2>Heap Tree Visualization</h2>
    <div id="heapTreeVisual" class="heap-visual" aria-label="Heap tree visualization"></div>
  </div>
</div>

<script>
  // Heap class supporting both min and max heap
  class Heap {
    constructor(type = 'min') {
      this.heap = [];
      this.type = type; // 'min' or 'max'
    }

    compare(a, b) {
      // Min-heap: a < b => true
      // Max-heap: a > b => true
      if (this.type === 'min') {
        return a < b;
      } else {
        return a > b;
      }
    }

    insert(value) {
      this.heap.push(value);
      this.bubbleUp();
    }

    bubbleUp() {
      let index = this.heap.length - 1;
      const current = this.heap[index];
      while (index > 0) {
        let parentIndex = Math.floor((index - 1) / 2);
        let parent = this.heap[parentIndex];
        if (this.compare(current, parent)) {
          this.heap[parentIndex] = current;
          this.heap[index] = parent;
          index = parentIndex;
        } else {
          break;
        }
      }
    }

    extractRoot() {
      if (this.heap.length === 0) return null;
      const root = this.heap[0];
      const end = this.heap.pop();
      if (this.heap.length > 0) {
        this.heap[0] = end;
        this.sinkDown(0);
      }
      return root;
    }

    sinkDown(index) {
      const length = this.heap.length;
      const current = this.heap[index];
      while(true) {
        let leftChildIdx = 2 * index + 1;
        let rightChildIdx = 2 * index + 2;
        let swap = null;

        if (leftChildIdx < length) {
          let leftChild = this.heap[leftChildIdx];
          if (this.compare(leftChild, current)) {
            swap = leftChildIdx;
          }
        }
        if (rightChildIdx < length) {
          let rightChild = this.heap[rightChildIdx];
          if (this.compare(rightChild, swap === null ? current : this.heap[swap])) {
            swap = rightChildIdx;
          }
        }
        if (swap === null) break;

        this.heap[index] = this.heap[swap];
        this.heap[swap] = current;
        index = swap;
      }
    }

    clear() {
      this.heap = [];
    }
  }

  // Visualization functions
  function updateArrayDisplay(heap) {
    const display = document.getElementById('heapArrayDisplay');
    display.textContent = JSON.stringify(heap.heap);
  }

  function buildTreeLevels(heapArr) {
    // Build an array of arrays representing levels of the heap tree
    const levels = [];
    let level = 0;
    let count = 0;
    while (count < heapArr.length) {
      let nodesInLevel = Math.pow(2, level);
      levels.push(heapArr.slice(count, count + nodesInLevel));
      count += nodesInLevel;
      level++;
    }
    return levels;
  }

  function createConnectionLines(levelIndex, nodesCount) {
    // Returns HTML for lines connecting nodes to children
    // For visual clarity, we only support basic angled lines.
    // This is a simple and not perfect solution for connections.
    const container = document.createElement('div');
    container.className = 'connections';
    // Each node except the ones at the edges get two lines (left and right)
    // but we control the CSS arrows via absolute position.
    // We keep it minimal here, actual lines done in CSS relative to node positions.
    // We'll keep this empty as lines are handled by CSS on nodes parent-child positioning.
    return container;
  }

  function renderHeapTree(heap) {
    const container = document.getElementById('heapTreeVisual');
    container.innerHTML = '';
    if (heap.heap.length === 0) {
      container.textContent = '(empty)';
      return;
    }
    // Build levels
    const levels = buildTreeLevels(heap.heap);
    // We will render inline blocks for each node and attempt to show tree levels
    // with spacing so it forms a rough tree shape.

    // For each level, create a div with nodes spaced properly
    // We use monospace fallback for spacing in nodes container

    levels.forEach((nodes, lvl) => {
      const levelDiv = document.createElement('div');
      levelDiv.className = 'heap-level';

      // Calculate spacing
      // Max width of heap tree is nodes.length in last level * 2 spaces spaced approx
      // We'll center nodes by adding margin on left and between nodes

      const totalWidth = Math.pow(2, levels.length) * 50; // heuristic for spacing
      const levelWidth = Math.pow(2, lvl) * 50;
      // add left margin to center this level
      const leftMargin = (totalWidth - levelWidth) / 2;

      levelDiv.style.marginLeft = leftMargin + 'px';

      nodes.forEach((val, idx) => {
        const node = document.createElement('div');
        node.className = 'node';
        node.textContent = val;
        // add margin except last node
        if (idx !== nodes.length - 1) {
          node.style.marginRight = '40px';
        }
        levelDiv.appendChild(node);
      });
      container.appendChild(levelDiv);
    });
  }

  // Main logic
  (function(){
    let heapTypeSelector = document.getElementById('heapType');
    let inputValue = document.getElementById('inputValue');
    let insertBtn = document.getElementById('insertBtn');
    let extractBtn = document.getElementById('extractBtn');
    let clearBtn = document.getElementById('clearBtn');

    let heap = new Heap(heapTypeSelector.value);

    function updateUI() {
      updateArrayDisplay(heap);
      renderHeapTree(heap);
    }

    heapTypeSelector.addEventListener('change', () => {
      heap = new Heap(heapTypeSelector.value);
      updateUI();
    });

    insertBtn.addEventListener('click', () => {
      let val = parseInt(inputValue.value, 10);
      if (isNaN(val)) {
        alert("Please enter a valid integer value to insert.");
        return;
      }
      heap.insert(val);
      inputValue.value = '';
      inputValue.focus();
      updateUI();
    });

    extractBtn.addEventListener('click', () => {
      let extracted = heap.extractRoot();
      if (extracted === null) {
        alert("Heap is empty, nothing to extract.");
        return;
      }
      alert((heap.type === 'min' ? "Min" : "Max") + " root extracted: " + extracted);
      updateUI();
    });

    clearBtn.addEventListener('click', () => {
      heap.clear();
      updateUI();
    });

    updateUI();

  })();
</script>

</body>
</html>