<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hash Map Demonstration</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 2rem;
    background: #f5f7fa;
  }
  h1 {
    color: #333;
  }
  .container {
    max-width: 700px;
    margin: 0 auto;
    background: white;
    padding: 1.5rem 2rem;
    border-radius: 8px;
    box-shadow: 0 4px 14px rgba(0,0,0,0.1);
  }
  label {
    font-weight: 600;
    display: block;
    margin-top: 1rem;
    margin-bottom: 0.3rem;
  }
  input[type="text"] {
    width: 100%;
    padding: 0.5rem 0.6rem;
    font-size: 1rem;
    border-radius: 4px;
    border: 1.8px solid #ccc;
    box-sizing: border-box;
  }
  button {
    margin-top: 1rem;
    padding: 0.55rem 1.2rem;
    font-size: 1rem;
    border: none;
    background-color: #4a90e2;
    color: white;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.25s ease;
  }
  button:hover {
    background-color: #357abd;
  }
  #msg {
    margin-top: 1rem;
    font-weight: 600;
  }
  table {
    margin-top: 1.5rem;
    width: 100%;
    border-collapse: collapse;
  }
  th, td {
    text-align: left;
    padding: 0.6rem 0.8rem;
    border-bottom: 1px solid #ddd;
  }
  th {
    background-color: #4a90e2;
    color: white;
  }
  .error {
    color: #d64545;
    font-weight: 600;
  }
  .success {
    color: #3c763d;
    font-weight: 600;
  }
</style>
</head>
<body>
  <div class="container">
    <h1>Hash Map Demonstration</h1>
    <p>A basic interactive Hash Map implementation in JavaScript using separate chaining for collision resolution.</p>

    <label for="hashKey">Key:</label>
    <input type="text" id="hashKey" placeholder="Enter key (string)" />

    <label for="hashValue">Value:</label>
    <input type="text" id="hashValue" placeholder="Enter value" />

    <button id="insertBtn">Insert / Update</button>
    <button id="getBtn">Get Value</button>
    <button id="removeBtn">Remove Key</button>
    <button id="clearBtn">Clear All</button>

    <div id="msg"></div>

    <h2>Current Hash Map Contents</h2>
    <table id="hashTable">
      <thead>
        <tr><th>Key</th><th>Value</th></tr>
      </thead>
      <tbody>
      </tbody>
    </table>
  </div>

<script>
  /*
   * Simple Hash Map implementation with basic functionalities:
   * - put(key, value)
   * - get(key)
   * - remove(key)
   * - clear()
   * 
   * Uses separate chaining to handle collisions.
   */

  class HashMap {
    constructor(initialCapacity = 16) {
      this._buckets = new Array(initialCapacity).fill(null).map(() => []);
      this._size = 0;
    }

    // A simple hash function for strings that produces an integer index
    hash(key) {
      if (typeof key !== 'string') {
        key = String(key);
      }
      let hash = 0;
      for(let i = 0; i < key.length; i++) {
        hash = (hash << 5) - hash + key.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }
      return Math.abs(hash) % this._buckets.length;
    }

    put(key, value) {
      const idx = this.hash(key);
      const bucket = this._buckets[idx];
      for(let i = 0; i < bucket.length; i++) {
        if(bucket[i][0] === key) {
          bucket[i][1] = value;
          return; // Update existing key
        }
      }
      bucket.push([key, value]);
      this._size++;
      // Optional: resize if load factor > 0.75 (not implemented here)
    }

    get(key) {
      const idx = this.hash(key);
      const bucket = this._buckets[idx];
      for(let i = 0; i < bucket.length; i++) {
        if(bucket[i][0] === key) {
          return bucket[i][1];
        }
      }
      return undefined;
    }

    remove(key) {
      const idx = this.hash(key);
      const bucket = this._buckets[idx];
      for(let i = 0; i < bucket.length; i++) {
        if(bucket[i][0] === key) {
          bucket.splice(i, 1);
          this._size--;
          return true;
        }
      }
      return false;
    }

    clear() {
      this._buckets = new Array(this._buckets.length).fill(null).map(() => []);
      this._size = 0;
    }

    entries() {
      const all = [];
      for(const bucket of this._buckets) {
        for(const pair of bucket) {
          all.push(pair);
        }
      }
      return all;
    }

    size() {
      return this._size;
    }
  }

  // Instantiate the hash map
  const hashMap = new HashMap();

  // UI Elements
  const keyInput = document.getElementById('hashKey');
  const valueInput = document.getElementById('hashValue');
  const insertBtn = document.getElementById('insertBtn');
  const getBtn = document.getElementById('getBtn');
  const removeBtn = document.getElementById('removeBtn');
  const clearBtn = document.getElementById('clearBtn');
  const msgDiv = document.getElementById('msg');
  const tableBody = document.querySelector('#hashTable tbody');

  // Helper to display messages
  function showMessage(text, type = 'success') {
    msgDiv.textContent = text;
    msgDiv.className = type;
  }

  // Update displayed hash map table
  function updateTable() {
    tableBody.innerHTML = '';
    const entries = hashMap.entries();
    if(entries.length === 0) {
      const row = document.createElement('tr');
      const cell = document.createElement('td');
      cell.setAttribute('colspan', '2');
      cell.style.fontStyle = 'italic';
      cell.style.color = '#888';
      cell.textContent = 'Hash Map is empty';
      row.appendChild(cell);
      tableBody.appendChild(row);
      return;
    }

    for(const [k,v] of entries) {
      const row = document.createElement('tr');
      const kCell = document.createElement('td');
      kCell.textContent = k;
      const vCell = document.createElement('td');
      vCell.textContent = v;
      row.appendChild(kCell);
      row.appendChild(vCell);
      tableBody.appendChild(row);
    }
  }

  // Insert / Update handler
  insertBtn.addEventListener('click', () => {
    const key = keyInput.value.trim();
    const value = valueInput.value.trim();

    if(key === '') {
      showMessage('Please enter a valid non-empty key.', 'error');
      return;
    }

    hashMap.put(key, value);
    showMessage(`Key "${key}" inserted/updated successfully.`);
    updateTable();
  });

  // Get value handler
  getBtn.addEventListener('click', () => {
    const key = keyInput.value.trim();
    if(key === '') {
      showMessage('Please enter a key to get its value.', 'error');
      return;
    }
    const val = hashMap.get(key);
    if(val === undefined) {
      showMessage(`Key "${key}" not found in the hash map.`, 'error');
    } else {
      showMessage(`Value for key "${key}": "${val}"`);
    }
  });

  // Remove key handler
  removeBtn.addEventListener('click', () => {
    const key = keyInput.value.trim();
    if(key === '') {
      showMessage('Please enter a key to remove.', 'error');
      return;
    }
    const removed = hashMap.remove(key);
    if(removed) {
      showMessage(`Key "${key}" removed successfully.`);
      updateTable();
    } else {
      showMessage(`Key "${key}" not found in the hash map.`, 'error');
    }
  });

  // Clear all entries
  clearBtn.addEventListener('click', () => {
    hashMap.clear();
    showMessage('Hash map cleared.');
    updateTable();
  });

  // Initial update
  updateTable();

</script>
</body>
</html>