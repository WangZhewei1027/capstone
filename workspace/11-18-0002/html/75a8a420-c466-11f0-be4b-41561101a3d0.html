<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Nearest Neighbors (KNN) Exploration</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }
        header {
            background-color: #007bff;
            color: white;
            padding: 10px 0;
            text-align: center;
        }
        h1 {
            margin: 0;
        }
        section {
            margin: 20px 0;
        }
        #canvas {
            border: 1px solid #cccccc;
            margin: 20px 0;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }
        .controls div {
            margin: 0 10px;
        }
        button {
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>

<header>
    <h1>K-Nearest Neighbors (KNN) Interactive Exploration</h1>
</header>

<section>
    <h2>What is KNN?</h2>
    <p>K-Nearest Neighbors is a simple, instance-based learning algorithm that classifies data points based on the closest training examples in the feature space. It can be used for both classification and regression tasks.</p>
</section>

<section>
    <h2>How KNN Works</h2>
    <p>Given a data point to classify, KNN identifies the 'K' nearest neighbors from the training dataset and assigns the majority class among those neighbors to the new point.</p>
</section>

<section>
    <h2>Interactive Simulation</h2>
    <canvas id="canvas" width="600" height="400"></canvas>
    <div class="controls">
        <div>
            <label for="kValue">Select K: </label>
            <input type="number" id="kValue" value="3" min="1" max="10">
        </div>
        <div>
            <button id="clearBtn">Clear Points</button>
            <button id="predictBtn">Predict Class</button>
        </div>
    </div>
</section>

<section>
    <h2>How to Use</h2>
    <ol>
        <li>Click on the canvas to place data points.</li>
        <li>Use the slider to select the value of K.</li>
        <li>Click "Predict Class" to see the classification based on KNN.</li>
        <li>Press "Clear Points" to start over.</li>
    </ol>
</section>

<footer>
    <p>Developed by [Your Name] | Inspired by K-Nearest Neighbors Algorithm</p>
</footer>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const points = [];
    const kValueInput = document.getElementById('kValue');
    const clearBtn = document.getElementById('clearBtn');
    const predictBtn = document.getElementById('predictBtn');

    canvas.addEventListener('click', (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const label = Math.random() < 0.5 ? 'A' : 'B';
        points.push({ x, y, label });
        drawPoints();
    });

    function drawPoints() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        points.forEach(point => {
            ctx.fillStyle = point.label === 'A' ? 'blue' : 'red';
            ctx.beginPath();
            ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    clearBtn.addEventListener('click', () => {
        points.length = 0;
        drawPoints();
    });

    predictBtn.addEventListener('click', () => {
        const k = parseInt(kValueInput.value);
        const newPoint = { x: Math.random() * canvas.width, y: Math.random() * canvas.height };
        ctx.fillStyle = 'green';
        ctx.beginPath();
        ctx.arc(newPoint.x, newPoint.y, 5, 0, Math.PI * 2);
        ctx.fill();
        classifyPoint(newPoint, k);
    });

    function classifyPoint(newPoint, k) {
        const distances = points.map(point => {
            return {
                point: point,
                distance: Math.sqrt(Math.pow(point.x - newPoint.x, 2) + Math.pow(point.y - newPoint.y, 2))
            };
        });

        distances.sort((a, b) => a.distance - b.distance);
        const nearestNeighbors = distances.slice(0, k);
        
        const votes = {};
        nearestNeighbors.forEach(neighbor => {
            if (!votes[neighbor.point.label]) {
                votes[neighbor.point.label] = 0;
            }
            votes[neighbor.point.label]++;
        });

        const predictedLabel = Object.keys(votes).reduce((a, b) => votes[a] > votes[b] ? a : b);
        alert(`Predicted class for new point: ${predictedLabel}`);
    }
</script>
</body>
</html>