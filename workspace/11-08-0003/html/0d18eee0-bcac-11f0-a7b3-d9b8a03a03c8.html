<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bellman-Ford Algorithm Interactive Module</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
        }
        #container {
            display: flex;
            margin: 24px;
            width: calc(100% - 48px);
            max-width: 1200px;
        }
        #canvas {
            border: 1px solid #ccc;
            background-color: #fff;
            position: relative;
            flex-grow: 1;
            height: 400px;
        }
        #controls {
            width: 200px;
            margin-left: 16px;
        }
        button {
            margin-bottom: 8px;
            padding: 8px;
        }
    </style>
</head>
<body>
    <h1>Exploring the Bellman-Ford Algorithm</h1>
    <p>Understand and visualize how the Bellman-Ford algorithm works for finding shortest paths in graphs.</p>
    <div id="container">
        <div id="canvas"></div>
        <div id="controls">
            <button id="addNode">Add Node</button>
            <button id="addEdge">Add Edge</button>
            <button id="runAlgorithm">Run Algorithm</button>
            <select id="startNodeSelect"></select>
            <p id="message"></p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const message = document.getElementById('message');
        const startNodeSelect = document.getElementById('startNodeSelect');
        const nodes = [];
        const edges = [];
        let nodeId = 0;

        canvas.addEventListener('click', (e) => {
            if (document.getElementById('addNode').clicked) {
                nodes.push({ id: nodeId++, x: e.offsetX, y: e.offsetY, edges: [] });
                draw();
                updateStartNodeSelect();
            }
        });

        // Draw nodes and edges function
        function draw() {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            nodes.forEach(node => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = 'lightblue';
                ctx.fill();
                ctx.strokeText(node.id, node.x - 5, node.y + 5);
                node.edges.forEach(edge => drawEdge(ctx, edge));
            });
        }

        function drawEdge(ctx, edge) {
            ctx.beginPath();
            ctx.moveTo(nodes[edge.from].x, nodes[edge.from].y);
            ctx.lineTo(nodes[edge.to].x, nodes[edge.to].y);
            ctx.strokeStyle = edge.relaxed ? 'green' : 'gray';
            ctx.stroke();
            ctx.strokeText(edge.weight, (nodes[edge.from].x + nodes[edge.to].x) / 2, (nodes[edge.from].y + nodes[edge.to].y) / 2);
        }

        document.getElementById('addEdge').onclick = () => {
            // Add logic to add an edge with weight
            // For simplicity, this function will remain unimplemented in this sample
        };

        document.getElementById('runAlgorithm').onclick = () => {
            const startId = startNodeSelect.value;
            if (startId !== "") {
                bellmanFord(startId);
            } else {
                alert("Please select a start node.");
            }
        };

        function bellmanFord(startId) {
            // Basic implementation of Bellman-Ford Algorithm
            const distance = Array(nodes.length).fill(Infinity);
            distance[startId] = 0;

            for (let i = 0; i < nodes.length - 1; i++) {
                edges.forEach(edge => {
                    if (distance[edge.from] + edge.weight < distance[edge.to]) {
                        distance[edge.to] = distance[edge.from] + edge.weight;
                        edge.relaxed = true; // Mark edge as relaxed
                    }
                });
            }

            // Highlighting process for learning
            updateGraphWithDistances(distance);
        }

        function updateGraphWithDistances(distance) {
            message.textContent = "Final Distances: " + JSON.stringify(distance);
            draw(); // Refresh graph visualization
        }

        function updateStartNodeSelect() {
            startNodeSelect.innerHTML = '';
            nodes.forEach(node => {
                const option = document.createElement('option');
                option.value = node.id;
                option.textContent = `Node ${node.id}`;
                startNodeSelect.appendChild(option);
            });
        }
    </script>
</body>
</html>