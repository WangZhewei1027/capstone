<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Understanding Prim's Algorithm</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 24px;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            font-size: 28px;
            margin-bottom: 16px;
        }
        .explanation {
            margin-bottom: 16px;
            text-align: center;
        }
        .graph-container {
            position: relative;
            width: 80%;
            max-width: 600px;
            height: 400px;
            background: white;
            border: 2px solid #ccc;
            overflow: hidden;
        }
        .vertex {
            width: 20px;
            height: 20px;
            background: #4caf50;
            border-radius: 50%;
            position: absolute;
            cursor: pointer;
            transition: background 0.3s;
        }
        .selected {
            background: #ffeb3b;
        }
        .line {
            position: absolute;
            width: 2px;
            background: #666;
            transform-origin: 0 0;
            transition: background 0.3s;
        }
        .button {
            margin-top: 16px;
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .button:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>
    <h1>Understanding Prim's Algorithm</h1>
    <div class="explanation">
        <p>Click on the vertices to visualize how Prim's Algorithm builds a Minimum Spanning Tree (MST). Press the "Start" button to see the algorithm in action!</p>
    </div>
    <div class="graph-container" id="graph-container">
        <!-- Vertices will be added here dynamically -->
    </div>
    <button class="button" id="startButton">Start</button>

    <script>
        const vertices = [];
        const edges = [];
        const graphContainer = document.getElementById('graph-container');
        const startButton = document.getElementById('startButton');

        // Function to generate random positions for vertices
        function createVertex(x, y) {
            const vertex = document.createElement('div');
            vertex.className = 'vertex';
            vertex.style.left = `${x}px`;
            vertex.style.top = `${y}px`;
            vertex.onclick = () => selectVertex(vertex);
            graphContainer.appendChild(vertex);
            vertices.push(vertex);
        }

        // Add vertices to the graph
        for (let i = 0; i < 5; i++) {
            createVertex(Math.random() * 560, Math.random() * 360);
        }

        let selectedVertex = null;

        function selectVertex(vertex) {
            if (selectedVertex) {
                selectedVertex.classList.remove('selected');
            }
            selectedVertex = vertex;
            selectedVertex.classList.add('selected');
        }

        function drawEdge(vertex1, vertex2) {
            const line = document.createElement('div');
            line.className = 'line';
            const x1 = parseInt(vertex1.style.left) + 10;
            const y1 = parseInt(vertex1.style.top) + 10;
            const x2 = parseInt(vertex2.style.left) + 10;
            const y2 = parseInt(vertex2.style.top) + 10;

            const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);

            line.style.width = `${length}px`;
            line.style.transform = `rotate(${angle}deg)`;
            line.style.left = `${x1}px`;
            line.style.top = `${y1}px`;
            graphContainer.appendChild(line);
            edges.push(line);
        }

        let step = 0;

        startButton.onclick = function() {
            // Reset previous selections
            vertices.forEach(vertex => vertex.classList.remove('selected'));
            edges.forEach(edge => edge.remove());
            edges.length = 0;

            if (vertices.length === 0) return;

            // Prim's Algorithm visualization
            selectedVertex = vertices[0];
            selectedVertex.classList.add('selected');

            const connectedVertices = new Set([selectedVertex]);
            
            const interval = setInterval(() => {
                let minEdge = null;
                let minVertex = null;
                
                // Find the minimum edge from connected vertices to remaining vertices
                for (let cv of Array.from(connectedVertices)) {
                    for (let v of vertices) {
                        if (!connectedVertices.has(v)) {
                            // Dummy check for connection
                            // In an actual implementation, calculate distance/weight
                            if (!minEdge || Math.random() < 0.5) { // Simulating condition for demo
                                minEdge = cv;
                                minVertex = v;
                            }
                        }
                    }
                }
                
                if (minVertex) {
                    connectedVertices.add(minVertex);
                    drawEdge(minEdge, minVertex);
                    minVertex.classList.add('selected');
                }

                if (connectedVertices.size === vertices.length) {
                    clearInterval(interval);
                }
            }, 1000);
        };
    </script>
</body>
</html>