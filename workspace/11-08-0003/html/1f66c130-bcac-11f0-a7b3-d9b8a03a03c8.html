<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topological Sort Interactive Module</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 24px;
            padding: 0;
            background-color: #f9f9f9;
        }
        header {
            text-align: center;
            margin-bottom: 16px;
        }
        #canvas {
            border: 2px dashed #333;
            width: 100%;
            height: 400px;
            position: relative;
            background-color: #eee;
        }
        button {
            padding: 10px 16px;
            margin: 0 8px;
            cursor: pointer;
            font-size: 16px;
        }
        #output {
            margin-top: 16px;
            font-weight: bold;
            min-height: 40px;
        }
        .node {
            border: 2px solid #007bff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            position: absolute;
            text-align: center;
            line-height: 40px;
            color: white;
            background-color: #007bff;
            cursor: pointer;
        }
        .active {
            background-color: orange;
            border-color: red;
        }
        .error {
            color: red;
        }
    </style>
</head>
<body>

<header>
    <h1>Discovering Topological Sort</h1>
</header>

<div id="canvas"></div>

<div id="controls">
    <button id="addNode">Add Node</button>
    <button id="sort">Sort</button>
    <button id="reset">Reset</button>
</div>

<div id="output"></div>

<script>
    let nodes = [];
    let edges = [];
    const canvas = document.getElementById('canvas');
    const outputDiv = document.getElementById('output');
    let nodeCount = 0;

    document.getElementById('addNode').onclick = function() {
        const newNode = document.createElement('div');
        newNode.className = 'node';
        newNode.id = 'node' + nodeCount;
        newNode.innerText = nodeCount++;
        newNode.draggable = true;
        newNode.style.left = Math.random() * (canvas.offsetWidth - 60) + 'px';
        newNode.style.top = Math.random() * (canvas.offsetHeight - 60) + 'px';
        newNode.addEventListener('dragstart', dragStart);
        canvas.appendChild(newNode);
        nodes.push(newNode);
    };

    canvas.addEventListener('click', (event) => {
        if (event.target.classList.contains('node')) return;
        const activeNode = document.querySelector('.active');
        if (activeNode) {
            activeNode.classList.remove('active');
            let targetNode = event.target;
            if (targetNode === canvas) {
                const target = event.target;
                if (target.classList.contains('node')) {
                    // create edge
                    edges.push({ from: activeNode.id, to: target.id });
                    drawEdge(activeNode, target);
                }
            }
        }
    });

    document.getElementById('sort').onclick = function() {
        outputDiv.innerHTML = ''; // Clear previous output
        if (!isDAG()) {
            outputDiv.innerHTML = "<span class='error'>Graph must be a Directed Acyclic Graph (DAG).</span>";
            return;
        }

        // Perform topological sort (Kahn's algorithm)
        let sorted = topologicalSort();
        animateSort(sorted);
    };

    document.getElementById('reset').onclick = function() {
        nodes.forEach(node => canvas.removeChild(node));
        nodes = [];
        edges = [];
        outputDiv.innerHTML = '';
        nodeCount = 0;
    };

    function dragStart(event) {
        event.dataTransfer.setData('text', event.target.id);
        const activeNode = document.querySelector('.active');
        if (activeNode) activeNode.classList.remove('active');
        event.target.classList.add('active');
    }

    function drawEdge(fromNode, toNode) {
        let x1 = parseInt(fromNode.style.left) + 20;
        let y1 = parseInt(fromNode.style.top) + 20;
        let x2 = parseInt(toNode.style.left) + 20;
        let y2 = parseInt(toNode.style.top) + 20;

        const edge = document.createElement('div');
        edge.style.position = 'absolute';
        edge.style.width = Math.sqrt((x2 - x1)**2 + (y2 - y1)**2) + 'px';
        edge.style.height = '2px';
        edge.style.backgroundColor = '#333';
        edge.style.transform = `rotate(${Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI}deg)`;
        edge.style.left = Math.min(x1, x2) + 'px';
        edge.style.top = Math.min(y1, y2) + 'px';

        canvas.appendChild(edge);
    }

    function topologicalSort() {
        // Kahn's algorithm for topological sorting
        let inDegrees = {};
        nodes.forEach(node => inDegrees[node.id] = 0);
        edges.forEach(edge => inDegrees[edge.to]++);

        let queue = [];
        for (let id in inDegrees) {
            if (inDegrees[id] === 0) {
                queue.push(id);
            }
        }

        let sorted = [];
        while (queue.length) {
            let nodeId = queue.shift();
            sorted.push(nodeId);
            edges = edges.filter(edge => edge.from !== nodeId);
            edges.forEach(edge => {
                inDegrees[edge.to]--;
                if (inDegrees[edge.to] === 0) {
                    queue.push(edge.to);
                }
            });
        }
        return sorted.length === nodes.length ? sorted : [];
    }

    function animateSort(sorted) {
        let index = 0;
        function highlightNextNode() {
            if (index < sorted.length) {
                const node = document.getElementById(sorted[index]);
                node.classList.add('active');
                outputDiv.innerHTML += sorted[index] + (index < sorted.length - 1 ? " -> " : " ");
                index++;
                setTimeout(() => {
                    node.classList.remove('active');
                    highlightNextNode();
                }, 1000);
            }
        }
        highlightNextNode();
    }

    function isDAG() {
        // Basic check for cycles can be implemented here
        return true; // Assume all graphs are DAG for demonstration
    }
</script>

</body>
</html>