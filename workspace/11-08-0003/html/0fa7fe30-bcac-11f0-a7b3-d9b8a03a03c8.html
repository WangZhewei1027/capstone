<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prim's Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 24px;
        }
        #canvas {
            border: 2px solid black;
            width: calc(100% - 48px);
            height: 400px;
            position: relative;
            background-color: #f9f9f9;
            overflow: hidden;
        }
        .button {
            padding: 10px 20px;
            margin: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        .button:hover {
            background-color: #0056b3;
        }
        .instruction {
            margin-bottom: 16px;
        }
    </style>
</head>
<body>

<h1>Visualizing Primâ€™s Algorithm</h1>
<div class="instruction">
    <p>Click on the canvas to create nodes. Drag to form edges, then click "Run Prim's Algorithm" to visualize the MST.</p>
</div>
<div id="canvas"></div>
<button id="reset" class="button">Reset Graph</button>
<button id="run" class="button">Run Prim's Algorithm</button>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let nodes = [];
    let edges = [];
    let isDrawing = false;
    let startNode = null;

    canvas.addEventListener('click', (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        nodes.push({ x, y });
        if (nodes.length === 1) startNode = nodes[0];
        draw();
    });

    // Draw all nodes and edges
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw edges
        ctx.strokeStyle = 'lightgrey';
        edges.forEach(edge => {
            ctx.beginPath();
            ctx.moveTo(edge[0].x, edge[0].y);
            ctx.lineTo(edge[1].x, edge[1].y);
            ctx.stroke();
        });

        // Draw nodes
        nodes.forEach(node => {
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(node.x, node.y, 6, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    // Reset functionality
    document.getElementById('reset').addEventListener('click', () => {
        nodes = [];
        edges = [];
        startNode = null;
        draw();
    });

    // Algorithm visualization
    document.getElementById('run').addEventListener('click', () => {
        if (!startNode) return;
        let visited = new Set();
        let mstEdges = [];
        visited.add(startNode);

        // Initialize with edges from the starting node
        let availableEdges = edgesFromNode(startNode);
        const interval = setInterval(() => {
            if (availableEdges.length === 0) {
                clearInterval(interval);
                return;
            }

            let minEdge = findMinEdge(availableEdges);
            mstEdges.push(minEdge);
            availableEdges = availableEdges.filter(edge => edge !== minEdge);
            drawMSTStep(mstEdges, visited);

            visited.add(minEdge[1]);
            availableEdges = availableEdges.concat(edgesFromNode(minEdge[1]));
        }, 1000);
    });

    function edgesFromNode(node) {
        return edges.filter(edge => edge[0] === node || edge[1] === node);
    }

    function findMinEdge(edges) {
        return edges.reduce((min, edge) => {
            return edge[2] < min[2] ? edge : min;
        });
    }

    function drawMSTStep(mstEdges, visited) {
        // Draw the MST
        draw();
        mstEdges.forEach(edge => {
            ctx.strokeStyle = 'blue';
            ctx.beginPath();
            ctx.moveTo(edge[0].x, edge[0].y);
            ctx.lineTo(edge[1].x, edge[1].y);
            ctx.stroke();
        });
        
        visited.forEach(node => {
            ctx.fillStyle = 'green';
            ctx.beginPath();
            ctx.arc(node.x, node.y, 8, 0, Math.PI * 2);
            ctx.fill();
        });
    }
</script>

</body>
</html>