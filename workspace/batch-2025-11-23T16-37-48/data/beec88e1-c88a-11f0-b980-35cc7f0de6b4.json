{
  "id": "beec88e1-c88a-11f0-b980-35cc7f0de6b4",
  "timestamp": "2025-11-23T16:40:02.724Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "创建一个Stack算法的交互式可视化演示，包含动画效果和用户控制按钮",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"zh-CN\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Stack 算法交互式可视化演示</title>\n<style>\n  body {\n    font-family: \"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;\n    background-color: #f0f4f8;\n    margin: 0;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n  h1 {\n    margin-bottom: 5px;\n    color: #333;\n  }\n  #stack-container {\n    width: 200px;\n    min-height: 300px;\n    border: 2px solid #4a90e2;\n    border-radius: 8px;\n    background: white;\n    position: relative;\n    overflow: visible;\n    box-shadow: 0 4px 8px rgb(74 144 226 / 0.3);\n  }\n  .stack-element {\n    width: 160px;\n    height: 40px;\n    margin: 8px auto;\n    background: #4a90e2;\n    color: white;\n    font-weight: 700;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-radius: 6px;\n    box-shadow: 0 2px 6px rgb(0 0 0 / 0.2);\n    position: relative;\n    opacity: 1;\n    transition: transform 0.5s ease, opacity 0.5s ease;\n    user-select: none;\n  }\n  .stack-element.removing {\n    opacity: 0;\n    transform: translateX(100px) rotate(20deg);\n  }\n  .stack-element.pushing {\n    opacity: 0;\n    transform: translateY(-60px);\n    animation: pushIn 0.5s forwards ease;\n  }\n  @keyframes pushIn {\n    0% {\n      opacity: 0;\n      transform: translateY(-60px);\n    }\n    100% {\n      opacity: 1;\n      transform: translateY(0);\n    }\n  }\n  #controls {\n    margin-top: 25px;\n    display: flex;\n    gap: 12px;\n    flex-wrap: wrap;\n    justify-content: center;\n  }\n  button {\n    padding: 10px 20px;\n    font-size: 16px;\n    background-color: #3178c6;\n    color: white;\n    border: none;\n    border-radius: 6px;\n    cursor: pointer;\n    box-shadow: 0 3px 6px rgb(49 120 198 / 0.6);\n    user-select: none;\n    transition: background-color 0.3s ease;\n  }\n  button:disabled {\n    background-color: #98c1f2;\n    cursor: not-allowed;\n    box-shadow: none;\n  }\n  button:hover:not(:disabled) {\n    background-color: #255a9b;\n  }\n  #input-value {\n    width: 140px;\n    padding: 10px;\n    font-size: 16px;\n    border: 2px solid #4a90e2;\n    border-radius: 6px;\n    outline-offset: 2px;\n  }\n  #info {\n    margin-top: 20px;\n    max-width: 500px;\n    color: #555;\n    font-size: 14px;\n    line-height: 1.4;\n  }\n  #top-label {\n    position: absolute;\n    top: 6px;\n    right: 8px;\n    font-size: 14px;\n    font-weight: 600;\n    background: #4a90e2;\n    color: white;\n    padding: 2px 6px;\n    border-radius: 4px;\n    user-select: none;\n  }\n  #help-text {\n    margin-top: 30px;\n    max-width: 520px;\n    font-size: 14px;\n    color: #666;\n    text-align: center;\n  }\n</style>\n</head>\n<body>\n<h1>Stack 算法交互式可视化演示</h1>\n<div id=\"stack-container\">\n  <div id=\"top-label\" style=\"display:none;\">Top</div>\n</div>\n\n<div id=\"controls\">\n  <input type=\"text\" id=\"input-value\" placeholder=\"请填写要入栈的值\" maxlength=\"10\" aria-label=\"入栈元素值\" />\n  <button id=\"push-btn\" aria-label=\"执行入栈操作\">Push</button>\n  <button id=\"pop-btn\" aria-label=\"执行出栈操作\">Pop</button>\n  <button id=\"peek-btn\" aria-label=\"查看栈顶元素\">Peek</button>\n  <button id=\"clear-btn\" aria-label=\"清空栈\">Clear</button>\n</div>\n\n<div id=\"info\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n\n<div id=\"help-text\">\n  <p>操作说明：</p>\n  <ul style=\"list-style: inside disc; padding-left: 0; margin-top:0;\">\n    <li>输入一个值，点击 <strong>Push</strong> 可将元素入栈；</li>\n    <li>点击 <strong>Pop</strong> 可将栈顶元素出栈；</li>\n    <li>点击 <strong>Peek</strong> 查看当前栈顶元素不删除；</li>\n    <li>点击 <strong>Clear</strong> 可清空整个栈；</li>\n    <li>每个操作都有动画辅助直观理解栈操作过程。</li>\n  </ul>\n</div>\n\n<script>\n(() => {\n  const stackContainer = document.getElementById('stack-container');\n  const inputValue = document.getElementById('input-value');\n  const pushBtn = document.getElementById('push-btn');\n  const popBtn = document.getElementById('pop-btn');\n  const peekBtn = document.getElementById('peek-btn');\n  const clearBtn = document.getElementById('clear-btn');\n  const infoBox = document.getElementById('info');\n  const topLabel = document.getElementById('top-label');\n\n  // 数据结构\n  let stack = [];\n\n  // 动画标识，防止重复操作中断动画\n  let animating = false;\n\n  // 最大栈长度（防止页面溢出）\n  const MAX_STACK_SIZE = 10;\n\n  // Helper: 更新栈视觉层\n  function renderStack() {\n    stackContainer.innerHTML = '';\n    if (stack.length === 0){\n      topLabel.style.display = 'none';\n    } else {\n      topLabel.style.display = 'block';\n    }\n\n    // 遍历stack从底到顶渲染(底部第一个元素)\n    for (let i = 0; i < stack.length; i++) {\n      const val = stack[i];\n      const elem = document.createElement('div');\n      elem.className = 'stack-element';\n      elem.textContent = val;\n      // 标记top元素位置\n      // 元素从底部开始排列，top元素在最后一个，显示top标识相对定位即可\n      if(i === stack.length - 1) {\n        elem.appendChild(topLabel);\n        topLabel.style.position = 'absolute';\n        topLabel.style.top = '8px';\n        topLabel.style.right = '10px';\n      }\n      stackContainer.appendChild(elem);\n    }\n  }\n\n  // 动画辅助函数：添加一个新的元素动画入栈\n  function animatePush(value) {\n    animating = true;\n    // 创建元素，初始在容器上面透明且向上偏移，用动画下落\n    const elem = document.createElement('div');\n    elem.className = 'stack-element pushing';\n    elem.textContent = value;\n    stackContainer.appendChild(elem);\n    topLabel.style.display = 'none';\n\n    // 动画结束后，把元素转换为普通状态，更新stack结构并画面\n    elem.addEventListener('animationend', () => {\n      stack.push(value);\n      animating = false;\n      renderStack();\n      updateInfo(`已入栈元素 \"${value}\"。`);\n      updateButtons();\n    }, {once:true});\n  }\n\n  // 动画辅助函数：动画出栈顶部元素\n  function animatePop() {\n    if(stack.length === 0) return;\n    animating = true;\n    // 获取栈顶元素dom节点（stackContainer的最后一个div）\n    const elems = stackContainer.querySelectorAll('.stack-element');\n    if(elems.length === 0) {\n      animating = false;\n      return;\n    }\n    const topElem = elems[elems.length - 1];\n    // 标记删除动画\n    topElem.classList.add('removing');\n\n    // 动画结束后删除元素，更新stack结构和更新界面\n    topElem.addEventListener('transitionend', () => {\n      const poppedVal = stack.pop();\n      animating = false;\n      renderStack();\n      updateInfo(`已出栈元素 \"${poppedVal}\"。`);\n      updateButtons();\n    }, {once:true});\n  }\n\n  // 操作按钮状态更新\n  function updateButtons(){\n    pushBtn.disabled = animating || inputValue.value.trim() === '' || stack.length >= MAX_STACK_SIZE;\n    popBtn.disabled = animating || stack.length === 0;\n    peekBtn.disabled = animating || stack.length === 0;\n    clearBtn.disabled = animating || stack.length === 0;\n  }\n\n  // 更新提示信息\n  function updateInfo(msg){\n    infoBox.textContent = msg;\n  }\n\n  // 按钮事件绑定\n  pushBtn.addEventListener('click', () => {\n    if(animating) return;\n    const val = inputValue.value.trim();\n    if(val === ''){\n      updateInfo('请输入一个有效的值进行入栈。');\n      return;\n    }\n    if(stack.length >= MAX_STACK_SIZE) {\n      updateInfo(`栈已满，最多可包含 ${MAX_STACK_SIZE} 个元素。`);\n      return;\n    }\n    inputValue.value = '';\n    updateButtons();\n    animatePush(val);\n  });\n\n  popBtn.addEventListener('click', () => {\n    if(animating) return;\n    if(stack.length === 0) {\n      updateInfo('栈为空，无法出栈。');\n      return;\n    }\n    updateButtons();\n    animatePop();\n  });\n\n  peekBtn.addEventListener('click', () => {\n    if(animating) return;\n    if(stack.length === 0) {\n      updateInfo('栈为空，无栈顶元素。');\n      return;\n    }\n    const topVal = stack[stack.length - 1];\n    updateInfo(`栈顶元素是 \"${topVal}\"。`);\n  });\n\n  clearBtn.addEventListener('click', () => {\n    if(animating) return;\n    if(stack.length === 0) {\n      updateInfo('栈已为空，无需清空。');\n      return;\n    }\n    animating = true;\n    // 简单淡出全部元素\n    const elems = stackContainer.querySelectorAll('.stack-element');\n    let transitionCount = 0;\n    elems.forEach(elem => {\n      elem.classList.add('removing');\n      elem.addEventListener('transitionend', () => {\n        transitionCount++;\n        if(transitionCount === elems.length){\n          stack = [];\n          animating = false;\n          renderStack();\n          updateInfo('栈已清空。');\n          updateButtons();\n        }\n      }, {once:true});\n    });\n    if(elems.length === 0){\n      // safety fallback\n      stack = [];\n      animating = false;\n      renderStack();\n      updateInfo('栈已清空。');\n      updateButtons();\n    }\n  });\n\n  // 输入框输入事件监测更新Push按钮状态\n  inputValue.addEventListener('input', () => {\n    updateButtons();\n  });\n\n  // 初始化界面\n  renderStack();\n  updateButtons();\n  updateInfo('欢迎使用 Stack 算法可视化演示！请输入值点击Push开始。');\n\n  // 支持回车键快速Push\n  inputValue.addEventListener('keydown', e => {\n    if(e.key === 'Enter' && !pushBtn.disabled){\n      e.preventDefault();\n      pushBtn.click();\n    }\n  });\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "创建一个Stack算法的交互式可视化演示，包含动画效果和用户控制按钮"
    }
  ],
  "topic": "Stack",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}