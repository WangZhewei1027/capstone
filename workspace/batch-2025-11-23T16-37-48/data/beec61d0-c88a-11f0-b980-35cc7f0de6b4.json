{
  "id": "beec61d0-c88a-11f0-b980-35cc7f0de6b4",
  "timestamp": "2025-11-23T16:41:43.873Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "创建一个Array算法的交互式可视化演示，包含动画效果和用户控制按钮",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"zh-CN\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Array算法交互式可视化演示</title>\n<style>\n  body {\n    font-family: \"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;\n    margin: 0;\n    padding: 0;\n    background: #f0f2f5;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    min-height: 100vh;\n  }\n  h1 {\n    margin-top: 20px;\n    color: #333;\n  }\n  #array-container {\n    margin: 20px 0;\n    display: flex;\n    justify-content: center;\n    min-height: 80px;\n  }\n  .array-bar {\n    margin: 0 3px;\n    background-color: #4a90e2;\n    width: 30px;\n    color: white;\n    font-size: 14px;\n    font-weight: bold;\n    text-align: center;\n    border-radius: 4px;\n    user-select: none;\n    display: flex;\n    justify-content: center;\n    align-items: flex-end;\n    transition: background-color 0.3s ease;\n    position: relative;\n  }\n  .array-bar span {\n    display: block;\n    padding-bottom: 4px;\n  }\n  .highlight {\n    background-color: #f39c12 !important;\n  }\n  .swap {\n    background-color: #e74c3c !important;\n  }\n  .done {\n    background-color: #27ae60 !important;\n  }\n  #controls {\n    margin-bottom: 20px;\n  }\n  button, select, input[type=number] {\n    margin: 5px;\n    padding: 8px 16px;\n    font-size: 16px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n  button:disabled {\n    cursor: not-allowed;\n    opacity: 0.6;\n  }\n  button {\n    background-color: #4a90e2;\n    color: white;\n    transition: background-color 0.2s ease;\n  }\n  button:hover:not(:disabled) {\n    background-color: #357ABD;\n  }\n  label {\n    font-weight: bold;\n    margin-left: 10px;\n  }\n  #speed-label {\n    margin-left: 15px;\n    font-weight: normal;\n    font-size: 14px;\n  }\n  #log {\n    width: 90%;\n    max-width: 800px;\n    height: 100px;\n    margin-bottom: 20px;\n    background: white;\n    border-radius: 6px;\n    padding: 10px;\n    overflow-y: auto;\n    box-shadow: 0 0 10px rgb(0 0 0 / 0.1);\n    font-family: Consolas, \"Courier New\", monospace;\n    font-size: 14px;\n    color: #333;\n    user-select: text;\n  }\n  #algorithm-select {\n    min-width: 150px;\n  }\n  #array-size-label {\n    margin-left: 10px;\n    font-weight: normal;\n  }\n</style>\n</head>\n<body>\n  <h1>数组算法交互式可视化演示</h1>\n  <div id=\"controls\">\n    <label for=\"algorithm-select\">算法:</label>\n    <select id=\"algorithm-select\" aria-label=\"选择算法\">\n      <option value=\"bubbleSort\">冒泡排序 (Bubble Sort)</option>\n      <option value=\"selectionSort\">选择排序 (Selection Sort)</option>\n      <option value=\"insertionSort\">插入排序 (Insertion Sort)</option>\n      <option value=\"linearSearch\">线性搜索 (Linear Search)</option>\n      <option value=\"binarySearch\">二分搜索 (Binary Search) - 需排序数组</option>\n    </select>\n\n    <label for=\"array-size\">数组大小:</label>\n    <input type=\"number\" id=\"array-size\" min=\"5\" max=\"50\" value=\"20\" aria-label=\"数组大小\" />\n\n    <button id=\"generate-array-btn\">生成数组</button>\n    <button id=\"start-btn\">开始</button>\n    <button id=\"pause-btn\" disabled>暂停</button>\n    <button id=\"reset-btn\" disabled>重置</button>\n\n    <label for=\"speed-range\">速度:</label>\n    <input type=\"range\" id=\"speed-range\" min=\"100\" max=\"2000\" step=\"50\" value=\"700\" aria-label=\"动画速度\" />\n    <span id=\"speed-label\">700ms</span>\n  </div>\n\n  <div id=\"array-container\" aria-live=\"polite\" aria-atomic=\"true\" aria-relevant=\"all\"></div>\n  <div id=\"log\" aria-live=\"polite\" aria-atomic=\"false\"></div>\n\n<script>\n(() => {\n  // 我们来实现多个算法的可视化动画。结构：\n  // 1. 用户可生成新数组，调整大小。\n  // 2. 选择算法：冒泡、选择、插入、线性搜索、二分搜索(需提前排序)\n  // 3. 设定动画速度。\n  // 4. 启动/暂停/重置功能。\n  // 5. 动画演示时，以颜色和动画显示元素变化，\n  //    log区显示步骤和状态信息。\n\n  // DOM Elements\n  const arrayContainer = document.getElementById(\"array-container\");\n  const logContainer = document.getElementById(\"log\");\n\n  const generateBtn = document.getElementById(\"generate-array-btn\");\n  const startBtn = document.getElementById(\"start-btn\");\n  const pauseBtn = document.getElementById(\"pause-btn\");\n  const resetBtn = document.getElementById(\"reset-btn\");\n\n  const algorithmSelect = document.getElementById(\"algorithm-select\");\n  const arraySizeInput = document.getElementById(\"array-size\");\n  const speedRange = document.getElementById(\"speed-range\");\n  const speedLabel = document.getElementById(\"speed-label\");\n\n  // State\n  let array = [];\n  let arraySize = +arraySizeInput.value || 20;\n  let animationSpeed = +speedRange.value; // ms delay\n  let animationTimeouts = [];\n  let running = false;\n  let paused = false;\n  let currentStep = 0;\n  let steps = [];\n  let currentAlgorithm = algorithmSelect.value;\n\n  // For searching algorithms need a target value input\n  // We'll add an input box dynamically\n  let searchTargetInput = null;\n\n  // Clear visual and logs\n  function clearAll() {\n    animationTimeouts.forEach(clearTimeout);\n    animationTimeouts = [];\n    running = false;\n    paused = false;\n    currentStep = 0;\n    steps = [];\n    startBtn.disabled = false;\n    pauseBtn.disabled = true;\n    resetBtn.disabled = true;\n    logContainer.textContent = \"\";\n  }\n\n  // Generate random array\n  function generateArray(size) {\n    const arr = [];\n    for (let i = 0; i < size; i++) {\n      // Use a range from 5 to 100 for better visuals\n      arr.push(Math.floor(Math.random() * 95) + 5);\n    }\n    return arr;\n  }\n\n  // Rendering the array bars\n  function renderArray(arr, highlightIndices = {}, extraClass = {}) {\n    // highlightIndices: {i: 'highlight'/'swap'/'done'...}\n    // extraClass: {className: [i1,i2,...]}\n    arrayContainer.innerHTML = \"\";\n    const maxVal = Math.max(...arr);\n    arr.forEach((val, i) => {\n      const bar = document.createElement(\"div\");\n      bar.classList.add(\"array-bar\");\n      const heightPercent = (val / maxVal) * 100;\n      bar.style.height = `${heightPercent}%`;\n      bar.setAttribute(\"data-index\", i);\n      bar.setAttribute(\"aria-label\", `索引 ${i}, 值 ${val}`);\n      bar.tabIndex = 0;\n      bar.style.width = `${Math.max(20, 600 / array.length)}px`;\n\n      if (highlightIndices[i]) {\n        bar.classList.add(highlightIndices[i]);\n      }\n      for (const [cls, indices] of Object.entries(extraClass)) {\n        if (indices.includes(i)) {\n          bar.classList.add(cls);\n        }\n      }\n\n      const textSpan = document.createElement(\"span\");\n      textSpan.textContent = val;\n      bar.appendChild(textSpan);\n\n      arrayContainer.appendChild(bar);\n    });\n  }\n\n  // Log utility\n  function log(message, clear = false) {\n    if (clear) {\n      logContainer.textContent = \"\";\n    }\n    const p = document.createElement(\"div\");\n    p.textContent = message;\n    logContainer.appendChild(p);\n    logContainer.scrollTop = logContainer.scrollHeight;\n  }\n\n  // Disable controls during running except pause\n  function updateControlsDuringRun() {\n    generateBtn.disabled = true;\n    startBtn.disabled = true;\n    pauseBtn.disabled = false;\n    resetBtn.disabled = false;\n    arraySizeInput.disabled = true;\n    algorithmSelect.disabled = true;\n    if (searchTargetInput) searchTargetInput.disabled = true;\n  }\n\n  // Enable controls after stop/reset\n  function updateControlsAfterStop() {\n    generateBtn.disabled = false;\n    startBtn.disabled = false;\n    pauseBtn.disabled = true;\n    resetBtn.disabled = true;\n    arraySizeInput.disabled = false;\n    algorithmSelect.disabled = false;\n    if (searchTargetInput) searchTargetInput.disabled = false;\n  }\n\n  // Animation scheduler: Support pause/resume\n  // We will store all timeouts and a global time counter,\n  // and on pause clear all pending timeouts,\n  // on resume schedule the rest with adjusted timeouts.\n  // For simplicity here, we implement a step-based manual startNextStep() function.\n\n  function runSteps() {\n    if (paused) return;\n    if (currentStep >= steps.length) {\n      running = false;\n      log(`算法执行完毕。`, false);\n      updateControlsAfterStop();\n      // Mark all done\n      renderArray(array, {}, { done: [...Array(array.length).keys()] });\n      return;\n    }\n\n    const step = steps[currentStep];\n    // Step is a function with animation and log internally\n    step();\n    currentStep++;\n    if (running && !paused) {\n      animationTimeouts.push(\n        setTimeout(() => {\n          runSteps();\n        }, animationSpeed)\n      );\n    }\n  }\n\n  function startAnimation() {\n    if (running) return;\n    if (steps.length === 0) return;\n    running = true;\n    paused = false;\n    updateControlsDuringRun();\n    log(`开始执行算法: ${algorithmSelect.options[algorithmSelect.selectedIndex].text}`, true);\n    currentStep = 0;\n    runSteps();\n  }\n  function pauseAnimation() {\n    if (!running) return;\n    if (paused) return;\n    paused = true;\n    animationTimeouts.forEach(clearTimeout);\n    animationTimeouts = [];\n    log(\"动画已暂停。\");\n    pauseBtn.disabled = true;\n    startBtn.disabled = false;\n  }\n  function resumeAnimation() {\n    if (!running) return;\n    if (!paused) return;\n    paused = false;\n    log(\"动画已恢复。\");\n    pauseBtn.disabled = false;\n    startBtn.disabled = true;\n    runSteps();\n  }\n\n  // Reset animation\n  function resetAnimation() {\n    animationTimeouts.forEach(clearTimeout);\n    animationTimeouts = [];\n    running = false;\n    paused = false;\n    currentStep = 0;\n    steps = [];\n    log(\"动画已重置。\", true);\n    renderArray(array);\n    updateControlsAfterStop();\n    if (searchTargetInput) searchTargetInput.disabled = false;\n  }\n\n  // Create steps for algorithms\n  // 格式: steps 是一组函数，执行该函数就进行一步动画和log\n\n  // Utils for steps\n  function makeStepRender(highlight = {}, arrCopy = null, logMsg = \"\") {\n    return () => {\n      if (arrCopy) {\n        renderArray(arrCopy, highlight);\n      } else {\n        renderArray(array, highlight);\n      }\n      if (logMsg) log(logMsg, false);\n    };\n  }\n\n  // 冒泡排序\n  function generateBubbleSortSteps(arr) {\n    let stepsArray = [];\n    let a = arr.slice(); // copy array\n\n    const n = a.length;\n    for (let i = 0; i < n - 1; i++) {\n      for (let j = 0; j < n - i - 1; j++) {\n        // highlight comparing j and j+1\n        stepsArray.push(() => {\n          renderArray(a, { [j]: \"highlight\", [j+1]: \"highlight\" });\n          log(`比较索引 ${j} 和 ${j+1}: ${a[j]} 和 ${a[j+1]}`, false);\n        });\n        if (a[j] > a[j + 1]) {\n          // highlight swap\n          stepsArray.push(() => {\n            let newArr = a.slice();\n            [newArr[j], newArr[j + 1]] = [newArr[j + 1], newArr[j]];\n            renderArray(newArr, { [j]: \"swap\", [j+1]: \"swap\" });\n            log(`交换索引 ${j} 和 ${j + 1}`, false);\n          });\n          // perform swap in original array for next step\n          [a[j], a[j + 1]] = [a[j + 1], a[j]];\n        }\n      }\n      // Mark the last sorted element as done\n      stepsArray.push(() => {\n        let doneIndices = [];\n        for(let k = n - i - 1; k < n; k++) {\n          doneIndices.push(k);\n        }\n        renderArray(a, {}, { done: doneIndices });\n        log(`索引 ${n - i - 1} 及之后元素排序完成`, false);\n      });\n    }\n    // After finishing mark all done\n    stepsArray.push(() => {\n      renderArray(a, {}, { done: [...Array(n).keys()] });\n      log(\"排序完成。\", false);\n      array = a;\n    });\n    return stepsArray;\n  }\n\n  // 选择排序\n  function generateSelectionSortSteps(arr) {\n    let stepsArray = [];\n    let a = arr.slice();\n\n    const n = a.length;\n\n    for(let i=0; i<n-1; i++) {\n      let minIndex = i;\n      stepsArray.push(() => {\n        renderArray(a, {[i]: \"highlight\"});\n        log(`开始选择索引 ${i} 之后的最小元素`, false);\n      });\n      for(let j=i+1; j<n; j++) {\n        stepsArray.push(() => {\n          renderArray(a, {[minIndex]: \"highlight\", [j]: \"swap\"});\n          log(`比较当前最小值索引 ${minIndex} 的值 ${a[minIndex]} 和索引 ${j} 的值 ${a[j]}`, false);\n        });\n        if(a[j] < a[minIndex]) {\n          minIndex = j;\n          stepsArray.push(() => {\n            renderArray(a, {[minIndex]: \"highlight\"});\n            log(`新的最小值更新为索引 ${minIndex}: ${a[minIndex]}`, false);\n          });\n        }\n      }\n      if(minIndex !== i) {\n        stepsArray.push(() => {\n          let newArr = a.slice();\n          [newArr[i], newArr[minIndex]] = [newArr[minIndex], newArr[i]];\n          renderArray(newArr, {[i]: \"swap\", [minIndex]: \"swap\"});\n          log(`交换索引 ${i} 和 ${minIndex}`, false);\n        });\n        [a[i], a[minIndex]] = [a[minIndex], a[i]];\n      }\n      stepsArray.push(() => {\n        renderArray(a, {}, { done: [...Array(i+1).keys()] });\n        log(`索引 ${i} 及之前元素排序完成`, false);\n      });\n    }\n    stepsArray.push(() => {\n      renderArray(a, {}, { done: [...Array(n).keys()] });\n      log(\"排序完成。\", false);\n      array = a;\n    });\n    return stepsArray;\n  }\n\n  // 插入排序\n  function generateInsertionSortSteps(arr) {\n    let stepsArray = [];\n    let a = arr.slice();\n    const n = a.length;\n\n    for(let i=1; i<n; i++) {\n      let key = a[i];\n      let j = i - 1;\n      stepsArray.push(() => {\n        renderArray(a, {[i]: \"highlight\"});\n        log(`插入元素索引 ${i} 的值 ${key}`, false);\n      });\n      while(j >= 0 && a[j] > key) {\n        stepsArray.push(() => {\n          renderArray(a, {[j]: \"swap\", [j+1]: \"swap\"});\n          log(`索引 ${j} 的值 ${a[j]} 大于 ${key}, 向后移动`, false);\n        });\n        a[j+1] = a[j];\n        j--;\n      }\n      stepsArray.push(() => {\n        a[j+1] = key;\n        renderArray(a, {[j+1]: \"highlight\"});\n        log(`插入元素 ${key} 到索引 ${j+1}`, false);\n      });\n      stepsArray.push(() => {\n        renderArray(a, {}, { done: [...Array(i+1).keys()] });\n        log(`索引 0 到 ${i} 排序完成`, false);\n      });\n    }\n    stepsArray.push(() => {\n      renderArray(a, {}, { done: [...Array(n).keys()] });\n      log(\"排序完成。\", false);\n      array = a;\n    });\n    return stepsArray;\n  }\n\n  // 线性搜索\n  // 用户需输入目标值\n  // 每步highlight一个元素，找到即结束\n  function generateLinearSearchSteps(arr, targetValue) {\n    let stepsArray = [];\n    let a = arr.slice();\n\n    stepsArray.push(() => {\n      log(`线性搜索目标值: ${targetValue}`, true);\n    });\n\n    for(let i=0; i<a.length; i++) {\n      stepsArray.push(() => {\n        renderArray(a, {[i]: \"highlight\"});\n        log(`检查索引 ${i}, 值 ${a[i]}`, false);\n      });\n      if(a[i] == targetValue) {\n        stepsArray.push(() => {\n          renderArray(a, {[i]: \"done\"});\n          log(`找到目标值 ${targetValue} 在索引 ${i}`, false);\n        });\n        return stepsArray;\n      }\n    }\n    // 结束没找到\n    stepsArray.push(() => {\n      renderArray(a);\n      log(`未找到目标值 ${targetValue}。`, false);\n    });\n    return stepsArray;\n  }\n\n  // 二分搜索\n  // 数组要求是有序的，用户须输入目标值\n  // 每步突出中间元素\n  function generateBinarySearchSteps(arr, targetValue) {\n    let stepsArray = [];\n    let a = arr.slice();\n\n    stepsArray.push(() => {\n      log(`二分搜索目标值: ${targetValue}`, true);\n    });\n\n    let left = 0;\n    let right = a.length - 1;\n\n    while(left <= right) {\n      let mid = Math.floor((left + right) / 2);\n      stepsArray.push(() => {\n        // highlight mid\n        renderArray(a, {[mid]: \"highlight\"});\n        log(`检查中间索引 ${mid}, 值 ${a[mid]}`, false);\n      });\n      if(a[mid] == targetValue) {\n        stepsArray.push(() => {\n          renderArray(a, {[mid]: \"done\"});\n          log(`找到目标值 ${targetValue} 在索引 ${mid}`, false);\n        });\n        return stepsArray;\n      } else if(a[mid] < targetValue) {\n        stepsArray.push(() => {\n          log(`目标值大于索引 ${mid} 的值 ${a[mid]}, 在右半部分继续搜索`, false);\n        });\n        left = mid + 1;\n      } else {\n        stepsArray.push(() => {\n          log(`目标值小于索引 ${mid} 的值 ${a[mid]}, 在左半部分继续搜索`, false);\n        });\n        right = mid - 1;\n      }\n    }\n    stepsArray.push(() => {\n      renderArray(a);\n      log(`未找到目标值 ${targetValue}。`, false);\n    });\n\n    return stepsArray;\n  }\n\n  // 根据选择的算法生成steps\n  function prepareSteps() {\n    steps = [];\n    currentStep = 0;\n    let target = null;\n    if (searchTargetInput) {\n      const val = searchTargetInput.value.trim();\n      if(val.length > 0) {\n        target = Number(val);\n        if (isNaN(target)) {\n          alert(\"请输入有效的目标值（数字）。\");\n          return false;\n        }\n      }\n    }\n    if((currentAlgorithm === \"linearSearch\" || currentAlgorithm === \"binarySearch\") && target === null) {\n      alert(\"请先输入搜索目标值。\");\n      return false;\n    }\n    // For binary search must be sorted\n    if(currentAlgorithm === \"binarySearch\") {\n      array.sort((a,b) => a-b);\n      renderArray(array);\n    }\n    switch(currentAlgorithm) {\n      case \"bubbleSort\":\n        steps = generateBubbleSortSteps(array);\n        break;\n      case \"selectionSort\":\n        steps = generateSelectionSortSteps(array);\n        break;\n      case \"insertionSort\":\n        steps = generateInsertionSortSteps(array);\n        break;\n      case \"linearSearch\":\n        steps = generateLinearSearchSteps(array, target);\n        break;\n      case \"binarySearch\":\n        steps = generateBinarySearchSteps(array, target);\n        break;\n    }\n    return true;\n  }\n\n  // Event listeners:\n\n  // Update speed label\n  speedRange.addEventListener(\"input\", e => {\n    animationSpeed = +e.target.value;\n    speedLabel.textContent = animationSpeed + \"ms\";\n  });\n\n  // Generate new array\n  generateBtn.addEventListener(\"click\", () => {\n    let size = +arraySizeInput.value;\n    if (isNaN(size) || size < 5) {\n      size = 5;\n      arraySizeInput.value = size;\n    } else if (size > 50) {\n      size = 50;\n      arraySizeInput.value = size;\n    }\n    arraySize = size;\n    array = generateArray(arraySize);\n    renderArray(array);\n    log(\"生成新数组。\", true);\n    resetAnimation();\n\n    // If binary search selected, sort immediately for user clarity\n    if (algorithmSelect.value === \"binarySearch\") {\n      array.sort((a,b) => a-b);\n      renderArray(array);\n      log(\"数组已排序以用于二分搜索。\", false);\n    }\n  });\n\n  // Algorithm change\n  algorithmSelect.addEventListener(\"change\", e => {\n    currentAlgorithm = e.target.value;\n    resetAnimation();\n    if (searchTargetInput) {\n      searchTargetInput.remove();\n      searchTargetInput = null;\n    }\n    // For search algorithms, show input box for target value\n    if(currentAlgorithm === \"linearSearch\" || currentAlgorithm === \"binarySearch\") {\n      searchTargetInput = document.createElement(\"input\");\n      searchTargetInput.type = \"number\";\n      searchTargetInput.id = \"search-target\";\n      searchTargetInput.placeholder = \"输入搜索目标值\";\n      searchTargetInput.setAttribute(\"aria-label\", \"搜索目标值输入框\");\n      searchTargetInput.style.marginLeft = \"10px\";\n      const label = document.createElement(\"label\");\n      label.htmlFor = \"search-target\";\n      label.textContent = \"目标值:\";\n      label.style.marginLeft = \"10px\";\n      label.style.fontWeight = \"bold\";\n      document.getElementById(\"controls\").insertBefore(searchTargetInput, startBtn);\n      document.getElementById(\"controls\").insertBefore(label, searchTargetInput);\n    } else {\n      // Remove any left labels\n      const labels = document.querySelectorAll(\"#controls label\");\n      labels.forEach(lbl=>{\n        if(lbl.htmlFor === \"search-target\") lbl.remove();\n      });\n    }\n\n    // If user changed to binary search, sort the array first and render\n    if(currentAlgorithm === \"binarySearch\") {\n      array.sort((a,b) => a-b);\n      renderArray(array);\n      log(\"数组已排序以用于二分搜索。\", true);\n    } else {\n      renderArray(array);\n    }\n  });\n\n  // Start button\n  startBtn.addEventListener(\"click\", () => {\n    if (running && paused) {\n      resumeAnimation();\n      startBtn.disabled = true;\n      pauseBtn.disabled = false;\n      return;\n    }\n\n    if (!prepareSteps()) return;\n\n    startAnimation();\n  });\n\n  // Pause button\n  pauseBtn.addEventListener(\"click\", () => {\n    pauseAnimation();\n  });\n\n  // Reset button\n  resetBtn.addEventListener(\"click\", () => {\n    resetAnimation();\n  });\n\n  // Initialize\n\n  array = generateArray(arraySize);\n  renderArray(array);\n  log(\"欢迎使用数组算法交互式可视化演示。\", true);\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "创建一个Array算法的交互式可视化演示，包含动画效果和用户控制按钮"
    }
  ],
  "topic": "Array",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}