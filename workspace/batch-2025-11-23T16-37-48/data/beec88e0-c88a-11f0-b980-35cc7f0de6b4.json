{
  "id": "beec88e0-c88a-11f0-b980-35cc7f0de6b4",
  "timestamp": "2025-11-23T16:42:35.383Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "创建一个Linked List算法的交互式可视化演示，包含动画效果和用户控制按钮",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"zh-CN\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>链表算法交互式可视化演示</title>\n<style>\n  body {\n    font-family: \"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;\n    margin: 0;\n    background: #f0f2f5;\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n  }\n  header {\n    background: #004aad;\n    color: #fff;\n    padding: 1rem;\n    text-align: center;\n    font-weight: 700;\n    font-size: 1.5rem;\n    user-select: none;\n  }\n  #container {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    max-width: 1000px;\n    margin: 1rem auto;\n  }\n  #canvas-wrapper {\n    flex: 1;\n    background: #fff;\n    border: 1px solid #ccc;\n    margin-bottom: 1rem;\n    border-radius: 8px;\n    position: relative;\n    overflow-x: auto;\n  }\n  canvas {\n    display: block;\n    background: #fff;\n  }\n  #controls {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 0.8rem;\n    justify-content: center;\n  }\n  #controls > * {\n    flex: none;\n  }\n  input[type=\"number\"], input[type=\"text\"] {\n    padding: 0.4rem 0.6rem;\n    font-size: 1rem;\n    border: 1.5px solid #ccc;\n    border-radius: 4px;\n    width: 80px;\n    text-align: center;\n  }\n  button {\n    background: #004aad;\n    border: none;\n    color: white;\n    font-size: 1rem;\n    padding: 0.5rem 1rem;\n    border-radius: 6px;\n    cursor: pointer;\n    user-select: none;\n    transition: background-color 0.2s ease;\n  }\n  button:disabled {\n    background: #7a86a2;\n    cursor: not-allowed;\n  }\n  button:hover:not(:disabled) {\n    background: #003080;\n  }\n  label {\n    font-weight: 600;\n    margin-right: 0.4rem;\n  }\n  .input-group {\n    display: flex;\n    align-items: center;\n    gap: 0.3rem;\n  }\n  #speedControl {\n    width: 120px;\n  }\n  #info {\n    margin-top: 0.5rem;\n    text-align: center;\n    color: #333;\n    font-weight: 600;\n    user-select: none;\n    min-height: 1.2rem;\n  }\n  /* Node styles for legend */\n  #legend {\n    margin-top: 0.6rem;\n    text-align: center;\n    font-size: 0.9rem;\n    color: #555;\n  }\n  #legend span {\n    display: inline-flex;\n    align-items: center;\n    margin: 0 0.6rem;\n  }\n  .legend-node {\n    width: 22px;\n    height: 28px;\n    border: 2px solid #004aad;\n    border-radius: 6px;\n    margin-right: 0.3rem;\n    position: relative;\n    background: #cce0ff;\n  }\n  .legend-current {\n    background: #0f74e5;\n  }\n  .legend-visited {\n    background: #a6c8ff;\n  }\n</style>\n</head>\n<body>\n<header>链表算法交互式可视化演示</header>\n<div id=\"container\">\n  <div id=\"canvas-wrapper\" tabindex=\"0\">\n    <canvas id=\"canvas\" height=\"200\"></canvas>\n  </div>\n  <div id=\"controls\" aria-label=\"链表操作控制\">\n    <div class=\"input-group\" title=\"节点数据 (字符串)\">\n      <label for=\"valueInput\">节点值：</label>\n      <input type=\"text\" id=\"valueInput\" maxlength=\"10\" placeholder=\"例: 10\" aria-describedby=\"valueInputDesc\" />\n    </div>\n    <div class=\"input-group\" title=\"位置索引 (从 0 开始)\">\n      <label for=\"indexInput\">位置：</label>\n      <input type=\"number\" id=\"indexInput\" min=\"0\" placeholder=\"0\" aria-describedby=\"indexInputDesc\" />\n    </div>\n    <button id=\"pushBtn\" title=\"在链表尾部添加节点\">尾部添加</button>\n    <button id=\"unshiftBtn\" title=\"在链表头部添加节点\">头部添加</button>\n    <button id=\"insertBtn\" title=\"在指定位置插入节点\">指定位置插入</button>\n    <button id=\"popBtn\" title=\"删除链表尾部节点\">尾部删除</button>\n    <button id=\"shiftBtn\" title=\"删除链表头部节点\">头部删除</button>\n    <button id=\"removeBtn\" title=\"删除指定位置节点\">指定位置删除</button>\n    <button id=\"searchBtn\" title=\"查找指定值(高亮显示)\">查找节点</button>\n    <button id=\"resetBtn\" title=\"重置链表为初始状态\">重置链表</button>\n    <div class=\"input-group\" title=\"动画速度调整\">\n      <label for=\"speedControl\">速度：</label>\n      <input type=\"range\" id=\"speedControl\" min=\"0.1\" max=\"2\" value=\"1\" step=\"0.1\" aria-label=\"动画速度\" />\n    </div>\n  </div>\n  <div id=\"info\" role=\"alert\" aria-live=\"polite\"></div>\n  <div id=\"legend\" aria-label=\"图例\">\n    <span><div class=\"legend-node\"></div> 节点</span>\n    <span><div class=\"legend-node legend-current\"></div> 当前遍历节点</span>\n    <span><div class=\"legend-node legend-visited\"></div> 已遍历节点</span>\n  </div>\n</div>\n<script>\n(() => {\n  \"use strict\";\n\n  const canvas = document.getElementById(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const wrapper = document.getElementById(\"canvas-wrapper\");\n  const info = document.getElementById(\"info\");\n\n  // Control elements\n  const valueInput = document.getElementById(\"valueInput\");\n  const indexInput = document.getElementById(\"indexInput\");\n  const pushBtn = document.getElementById(\"pushBtn\");\n  const unshiftBtn = document.getElementById(\"unshiftBtn\");\n  const insertBtn = document.getElementById(\"insertBtn\");\n  const popBtn = document.getElementById(\"popBtn\");\n  const shiftBtn = document.getElementById(\"shiftBtn\");\n  const removeBtn = document.getElementById(\"removeBtn\");\n  const searchBtn = document.getElementById(\"searchBtn\");\n  const resetBtn = document.getElementById(\"resetBtn\");\n  const speedControl = document.getElementById(\"speedControl\");\n\n  // Canvas sizing for horizontal scroll\n  function setCanvasWidth(nodesCount) {\n    // Each node + space ~120px width\n    let width = Math.max(wrapper.clientWidth, nodesCount * 140 + 40);\n    canvas.width = width;\n  }\n  function setCanvasHeight() {\n    canvas.height = 200;\n  }\n  setCanvasHeight();\n\n  // Node class\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  // LinkedList class with event callbacks for animation sync\n  class LinkedList {\n    constructor() {\n      this.head = null;\n      this.length = 0;\n    }\n    push(value) {\n      const newNode = new Node(value);\n      if (!this.head) {\n        this.head = newNode;\n      } else {\n        let current = this.head;\n        while (current.next) current = current.next;\n        current.next = newNode;\n      }\n      this.length++;\n      return newNode;\n    }\n    unshift(value) {\n      const newNode = new Node(value);\n      newNode.next = this.head;\n      this.head = newNode;\n      this.length++;\n      return newNode;\n    }\n    insert(value, position) {\n      if (position < 0 || position > this.length) return null;\n      if (position === 0) return this.unshift(value);\n      if (position === this.length) return this.push(value);\n      const newNode = new Node(value);\n      let prev = this._getNodeAt(position - 1);\n      newNode.next = prev.next;\n      prev.next = newNode;\n      this.length++;\n      return newNode;\n    }\n    pop() {\n      if (!this.head) return null;\n      if (this.length === 1) {\n        let temp = this.head;\n        this.head = null;\n        this.length--;\n        return temp;\n      }\n      let current = this.head;\n      let prev = null;\n      while (current.next) {\n        prev = current;\n        current = current.next;\n      }\n      prev.next = null;\n      this.length--;\n      return current;\n    }\n    shift() {\n      if (!this.head) return null;\n      let temp = this.head;\n      this.head = this.head.next;\n      this.length--;\n      return temp;\n    }\n    remove(position) {\n      if (position < 0 || position >= this.length) return null;\n      if (position === 0) return this.shift();\n      let prev = this._getNodeAt(position - 1);\n      let removed = prev.next;\n      prev.next = removed.next;\n      this.length--;\n      return removed;\n    }\n    _getNodeAt(position) {\n      if (position < 0 || position >= this.length) return null;\n      let current = this.head;\n      let i = 0;\n      while (i < position) {\n        current = current.next;\n        i++;\n      }\n      return current;\n    }\n    toArray() {\n      let arr = [];\n      let current = this.head;\n      while (current) {\n        arr.push(current.value);\n        current = current.next;\n      }\n      return arr;\n    }\n  }\n\n  // Animation & Rendering\n  const NODE_WIDTH = 80;\n  const NODE_HEIGHT = 50;\n  const NODE_RADIUS = 12;\n  const NODE_MARGIN_X = 60; // space between nodes horizontally (excluding width)\n  const START_X = 40;\n  const START_Y = 80;\n\n  const ARROW_LENGTH = 30;\n\n  // Colors\n  const COLOR_NODE_BORDER = \"#004aad\";\n  const COLOR_NODE_FILL = \"#cce0ff\";\n  const COLOR_NODE_TEXT = \"#003080\";\n  const COLOR_NODE_CURRENT = \"#0f74e5\";\n  const COLOR_NODE_VISITED = \"#a6c8ff\";\n  const COLOR_ARROW = \"#004aad\";\n\n  // State for animation:\n  // Nodes positions: calculated from linked list nodes\n  // visitedIndices: indices highlighted as visited\n  // currentIndex: current traversal index for animation\n\n  let linkedList = new LinkedList();\n  // Initialize with some nodes:\n  [\"A\", \"B\", \"C\", \"D\"].forEach(v => linkedList.push(v));\n  setCanvasWidth(linkedList.length);\n  info.textContent = \"链表初始化完成，包含节点: A → B → C → D\";\n\n  // Animation frame & traversal state\n  let visitedIndices = new Set();\n  let currentIndex = -1;\n  let animationSpeed = 1; // speed multiplier, from speedControl\n  let animationRunning = false;\n  let animationType = null; // \"search\" or null\n  let animationValue = null; // value to search for\n  let animationResolve = null;\n\n  // Helpers drawing rounded rect with text\n  function drawNode(ctx, x, y, width, height, radius, value, options = {}) {\n    const {\n      fillColor = COLOR_NODE_FILL,\n      borderColor = COLOR_NODE_BORDER,\n      textColor = COLOR_NODE_TEXT,\n      highlight = false,\n      visited = false,\n    } = options;\n\n    ctx.beginPath();\n    ctx.fillStyle = fillColor;\n    ctx.strokeStyle = borderColor;\n    ctx.lineWidth = 2;\n    if (visited) {\n      ctx.fillStyle = COLOR_NODE_VISITED;\n    }\n    if (highlight) {\n      ctx.fillStyle = COLOR_NODE_CURRENT;\n      ctx.strokeStyle = \"#003070\";\n      ctx.lineWidth = 3;\n    }\n    // Rounded rectangle\n    ctx.moveTo(x + radius, y);\n    ctx.lineTo(x + width - radius, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n    ctx.lineTo(x + width, y + height - radius);\n    ctx.quadraticCurveTo(\n      x + width,\n      y + height,\n      x + width - radius,\n      y + height\n    );\n    ctx.lineTo(x + radius, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n    ctx.lineTo(x, y + radius);\n    ctx.quadraticCurveTo(x, y, x + radius, y);\n    ctx.closePath();\n\n    ctx.fill();\n    ctx.stroke();\n\n    // Text in center\n    ctx.fillStyle = textColor;\n    ctx.font = \"bold 20px 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(value, x + width / 2, y + height / 2);\n  }\n\n  function drawArrow(ctx, fromX, fromY, toX, toY, options = {}) {\n    const { color = COLOR_ARROW } = options;\n    const headLength = 8;\n    const dx = toX - fromX;\n    const dy = toY - fromY;\n    const angle = Math.atan2(dy, dx);\n\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    ctx.lineWidth = 2;\n\n    ctx.beginPath();\n    ctx.moveTo(fromX, fromY);\n    ctx.lineTo(toX, toY);\n    ctx.stroke();\n\n    // arrowhead\n    ctx.beginPath();\n    ctx.moveTo(toX, toY);\n    ctx.lineTo(\n      toX - headLength * Math.cos(angle - Math.PI / 6),\n      toY - headLength * Math.sin(angle - Math.PI / 6)\n    );\n    ctx.lineTo(\n      toX - headLength * Math.cos(angle + Math.PI / 6),\n      toY - headLength * Math.sin(angle + Math.PI / 6)\n    );\n    ctx.lineTo(toX, toY);\n    ctx.fill();\n  }\n\n  // Draw linked list nodes and arrows between them\n  function drawLinkedList(ctx, list, highlightIndex = -1, visitedSet = new Set()) {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    let current = list.head;\n    let index = 0;\n    let x = START_X;\n    let y = START_Y;\n\n    // Draw nodes\n    const nodePositions = [];\n    while (current) {\n      // Determine highlight/visited\n      const isCurrent = index === highlightIndex;\n      const isVisited = visitedSet.has(index);\n\n      drawNode(ctx, x, y, NODE_WIDTH, NODE_HEIGHT, NODE_RADIUS, current.value, {\n        highlight: isCurrent,\n        visited: isVisited,\n      });\n      nodePositions.push({ x, y });\n\n      current = current.next;\n      index++;\n      x += NODE_WIDTH + NODE_MARGIN_X;\n    }\n\n    // Draw arrows\n    for (let i = 0; i < nodePositions.length - 1; i++) {\n      const startX = nodePositions[i].x + NODE_WIDTH;\n      const startY = nodePositions[i].y + NODE_HEIGHT / 2;\n      const endX = nodePositions[i + 1].x;\n      const endY = nodePositions[i + 1].y + NODE_HEIGHT / 2;\n      drawArrow(ctx, startX, startY, endX, endY);\n    }\n\n    // Draw 'null' box at the end if list not empty\n    if (nodePositions.length > 0) {\n      let lastX = nodePositions[nodePositions.length - 1].x + NODE_WIDTH + NODE_MARGIN_X / 2;\n      let lastY = START_Y;\n      ctx.beginPath();\n      ctx.rect(lastX, lastY + NODE_HEIGHT / 4, 40, NODE_HEIGHT / 2);\n      ctx.fillStyle = \"#fff\";\n      ctx.fill();\n      ctx.strokeStyle = COLOR_NODE_BORDER;\n      ctx.lineWidth = 2;\n      ctx.stroke();\n\n      ctx.fillStyle = COLOR_NODE_TEXT;\n      ctx.font = \"bold 18px 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(\"null\", lastX + 20, lastY + NODE_HEIGHT / 2);\n    }\n  }\n\n  // Animation control helpers\n  function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Adjusted sleep with speed multiplier\n  function sleepSpeedAdjusted(ms) {\n    return sleep(ms / animationSpeed);\n  }\n\n  // Disable or enable controls (except speed) during animation\n  function setControlsEnabled(enabled) {\n    [pushBtn, unshiftBtn, insertBtn, popBtn, shiftBtn, removeBtn, searchBtn, resetBtn, valueInput, indexInput].forEach(control => {\n      control.disabled = !enabled;\n    });\n  }\n\n  // Validate inputs\n  function getValueInput() {\n    let val = valueInput.value.trim();\n    if (val === \"\") return null;\n    if (val.length > 10) val = val.substring(0, 10);\n    return val;\n  }\n  function getIndexInput() {\n    let idx = indexInput.value;\n    if (idx === \"\") return null;\n    idx = Number(idx);\n    if (Number.isNaN(idx) || idx < 0) return null;\n    if (!Number.isInteger(idx)) return null;\n    return idx;\n  }\n\n  // Animation for searching a node by value\n  async function animateSearch(value) {\n    if (linkedList.length === 0) {\n      info.textContent = \"链表为空，无法查找节点。\";\n      return;\n    }\n    animationRunning = true;\n    animationType = \"search\";\n    animationValue = value;\n    setControlsEnabled(false);\n    info.textContent = `开始查找值 \"${value}\" ...`;\n\n    visitedIndices.clear();\n    currentIndex = -1;\n    drawLinkedList(ctx, linkedList, currentIndex, visitedIndices);\n    await sleepSpeedAdjusted(500);\n\n    let current = linkedList.head;\n    let idx = 0;\n    while (current) {\n      currentIndex = idx;\n      visitedIndices.add(idx);\n      drawLinkedList(ctx, linkedList, currentIndex, visitedIndices);\n      info.textContent = `访问节点 ${idx}, 值=\"${current.value}\"`;\n      await sleepSpeedAdjusted(1200);\n      if (current.value === value) {\n        info.textContent = `找到节点，位置: ${idx}`;\n        animationRunning = false;\n        animationType = null;\n        currentIndex = -1;\n        setControlsEnabled(true);\n        return true;\n      }\n      current = current.next;\n      idx++;\n    }\n    info.textContent = `未找到值为 \"${value}\" 的节点。`;\n    animationRunning = false;\n    animationType = null;\n    currentIndex = -1;\n    setControlsEnabled(true);\n    drawLinkedList(ctx, linkedList);\n    return false;\n  }\n\n  // Animate traversal for insert/remove to show the traversed path\n  async function animateTraversal(position, actionText) {\n    // Position out of range?\n    if (position < 0 || position > linkedList.length) return false;\n    animationRunning = true;\n    setControlsEnabled(false);\n    visitedIndices.clear();\n    for (let i = 0; i < position; i++) {\n      currentIndex = i;\n      visitedIndices.add(i);\n      info.textContent = `${actionText} 操作: 访问节点 ${i}`;\n      drawLinkedList(ctx, linkedList, currentIndex, visitedIndices);\n      await sleepSpeedAdjusted(800);\n    }\n    visitedIndices.add(position);\n    currentIndex = position;\n    drawLinkedList(ctx, linkedList, currentIndex, visitedIndices);\n    info.textContent = `${actionText} 节点位置到达 ${position}`;\n    await sleepSpeedAdjusted(800);\n    currentIndex = -1;\n    visitedIndices.clear();\n    drawLinkedList(ctx, linkedList);\n    setControlsEnabled(true);\n    animationRunning = false;\n    return true;\n  }\n\n  async function animatePopOrShift(isPop) {\n    if (linkedList.length === 0) {\n      info.textContent = (isPop ? \"尾部\" : \"头部\") + \"删除失败，链表为空。\";\n      return;\n    }\n    animationRunning = true;\n    setControlsEnabled(false);\n    info.textContent = (isPop ? \"尾部\" : \"头部\") + \"删除操作中...\";\n\n    // For pop we traverse all but last, for shift just highlight head\n    if (isPop) {\n      for (let i = 0; i < linkedList.length - 1; i++) {\n        currentIndex = i;\n        visitedIndices.add(i);\n        drawLinkedList(ctx, linkedList, currentIndex, visitedIndices);\n        info.textContent = `访问节点 ${i} ...`;\n        await sleepSpeedAdjusted(600);\n      }\n      currentIndex = linkedList.length - 1;\n      drawLinkedList(ctx, linkedList, currentIndex, visitedIndices);\n      info.textContent = `准备删除尾部节点，位置: ${currentIndex}`;\n      await sleepSpeedAdjusted(1000);\n      linkedList.pop();\n    } else {\n      currentIndex = 0;\n      visitedIndices.add(0);\n      drawLinkedList(ctx, linkedList, currentIndex, visitedIndices);\n      info.textContent = `准备删除头部节点，位置: 0`;\n      await sleepSpeedAdjusted(1100);\n      linkedList.shift();\n    }\n    currentIndex = -1;\n    visitedIndices.clear();\n    drawLinkedList(ctx, linkedList);\n    info.textContent = (isPop ? \"尾部\" : \"头部\") + \"删除操作完成。\";\n    setControlsEnabled(true);\n    animationRunning = false;\n  }\n\n  // Common function to validate and perform insert with animation\n  async function handleInsertAtPosition(value, index) {\n    if (value === null) {\n      info.textContent = \"请先输入节点值。\";\n      return;\n    }\n    if (index === null || index < 0 || index > linkedList.length) {\n      info.textContent = `请输入合法的位置（0 - ${linkedList.length}）。`;\n      return;\n    }\n    if (animationRunning) return;\n    await animateTraversal(index, \"插入\");\n    linkedList.insert(value, index);\n    drawLinkedList(ctx, linkedList);\n    info.textContent = `节点值 \"${value}\" 已成功插入位置 ${index}。`;\n  }\n\n  // Common function to validate and remove node at position with animation\n  async function handleRemoveAtPosition(index) {\n    if (index === null || index < 0 || index >= linkedList.length) {\n      info.textContent = `请输入合法的位置（0 - ${linkedList.length - 1}）。`;\n      return;\n    }\n    if (animationRunning) return;\n    await animateTraversal(index, \"删除\");\n    let removedNode = linkedList.remove(index);\n    drawLinkedList(ctx, linkedList);\n    info.textContent = `位置 ${index} 的节点值 \"${removedNode.value}\" 已删除。`;\n  }\n\n  // Common function to push value at tail with minimal animation\n  async function handlePush(value) {\n    if (value === null) {\n      info.textContent = \"请先输入节点值。\";\n      return;\n    }\n    if (animationRunning) return;\n    // Visually highlight tail before adding\n    if (linkedList.length > 0) {\n      animationRunning = true;\n      setControlsEnabled(false);\n      currentIndex = linkedList.length - 1;\n      visitedIndices.clear();\n      visitedIndices.add(currentIndex);\n      drawLinkedList(ctx, linkedList, currentIndex, visitedIndices);\n      info.textContent = \"准备在尾部添加节点...\";\n      await sleepSpeedAdjusted(1000);\n      currentIndex = -1;\n      visitedIndices.clear();\n      linkedList.push(value);\n      drawLinkedList(ctx, linkedList);\n      info.textContent = `尾部添加节点 \"${value}\" 完成。`;\n      setControlsEnabled(true);\n      animationRunning = false;\n    } else {\n      linkedList.push(value);\n      drawLinkedList(ctx, linkedList);\n      info.textContent = `尾部添加节点 \"${value}\" 完成。`;\n    }\n  }\n\n  // Common function to unshift value at head with minimal animation\n  async function handleUnshift(value) {\n    if (value === null) {\n      info.textContent = \"请先输入节点值。\";\n      return;\n    }\n    if (animationRunning) return;\n    animationRunning = true;\n    setControlsEnabled(false);\n    currentIndex = 0;\n    visitedIndices.clear();\n    visitedIndices.add(0);\n    drawLinkedList(ctx, linkedList, currentIndex, visitedIndices);\n    info.textContent = \"准备在头部添加节点...\";\n    await sleepSpeedAdjusted(1000);\n    currentIndex = -1;\n    visitedIndices.clear();\n    linkedList.unshift(value);\n    drawLinkedList(ctx, linkedList);\n    info.textContent = `头部添加节点 \"${value}\" 完成。`;\n    setControlsEnabled(true);\n    animationRunning = false;\n  }\n\n  // Reset linked list to default state\n  function resetLinkedList() {\n    if (animationRunning) return;\n    linkedList = new LinkedList();\n    [\"A\", \"B\", \"C\", \"D\"].forEach(v => linkedList.push(v));\n    setCanvasWidth(linkedList.length);\n    drawLinkedList(ctx, linkedList);\n    info.textContent = \"链表重置为默认状态: A → B → C → D\";\n  }\n\n  // Resize handler\n  function onResize() {\n    setCanvasWidth(linkedList.length);\n    setCanvasHeight();\n    drawLinkedList(ctx, linkedList, currentIndex, visitedIndices);\n  }\n\n  window.addEventListener(\"resize\", onResize);\n\n  // Event handlers for buttons\n  pushBtn.addEventListener(\"click\", async () => {\n    if (animationRunning) return;\n    let val = getValueInput();\n    await handlePush(val);\n    setCanvasWidth(linkedList.length);\n  });\n  unshiftBtn.addEventListener(\"click\", async () => {\n    if (animationRunning) return;\n    let val = getValueInput();\n    await handleUnshift(val);\n    setCanvasWidth(linkedList.length);\n  });\n  insertBtn.addEventListener(\"click\", async () => {\n    if (animationRunning) return;\n    let val = getValueInput();\n    let idx = getIndexInput();\n    await handleInsertAtPosition(val, idx);\n    setCanvasWidth(linkedList.length);\n  });\n  popBtn.addEventListener(\"click\", async () => {\n    if (animationRunning) return;\n    await animatePopOrShift(true);\n    setCanvasWidth(linkedList.length);\n  });\n  shiftBtn.addEventListener(\"click\", async () => {\n    if (animationRunning) return;\n    await animatePopOrShift(false);\n    setCanvasWidth(linkedList.length);\n  });\n  removeBtn.addEventListener(\"click\", async () => {\n    if (animationRunning) return;\n    let idx = getIndexInput();\n    await handleRemoveAtPosition(idx);\n    setCanvasWidth(linkedList.length);\n  });\n  searchBtn.addEventListener(\"click\", async () => {\n    if (animationRunning) return;\n    let val = getValueInput();\n    if (val === null) {\n      info.textContent = \"请输入要查找的节点值。\";\n      return;\n    }\n    await animateSearch(val);\n  });\n  resetBtn.addEventListener(\"click\", () => {\n    resetLinkedList();\n  });\n  speedControl.addEventListener(\"input\", () => {\n    animationSpeed = parseFloat(speedControl.value);\n    info.textContent = `动画速度设为 ${animationSpeed.toFixed(1)}x`;\n  });\n\n  // Initialize canvas and draw default list\n  function init() {\n    setCanvasWidth(linkedList.length);\n    setCanvasHeight();\n    drawLinkedList(ctx, linkedList);\n  }\n  init();\n\n  // Keyboard accessibility to focus canvas wrapper (scroll)\n  wrapper.addEventListener(\"keydown\", e => {\n    if (e.key === \"ArrowRight\") {\n      wrapper.scrollLeft += 40;\n    } else if (e.key === \"ArrowLeft\") {\n      wrapper.scrollLeft -= 40;\n    }\n  });\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "创建一个Linked List算法的交互式可视化演示，包含动画效果和用户控制按钮"
    }
  ],
  "topic": "Linked List",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}