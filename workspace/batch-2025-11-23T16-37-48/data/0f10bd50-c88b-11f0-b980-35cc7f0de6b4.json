{
  "id": "0f10bd50-c88b-11f0-b980-35cc7f0de6b4",
  "timestamp": "2025-11-23T16:42:20.016Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "创建一个Queue算法的交互式可视化演示，包含动画效果和用户控制按钮",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"zh-CN\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>队列 (Queue) 交互式可视化演示</title>\n<style>\n  body {\n    font-family: \"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;\n    margin: 20px;\n    background: #f0f4f8;\n    color: #333;\n  }\n  h1 {\n    text-align: center;\n    margin-bottom: 10px;\n  }\n  #queue-container {\n    margin: 20px auto;\n    width: 80%;\n    max-width: 800px;\n    height: 120px;\n    border: 2px solid #333;\n    border-radius: 8px;\n    background-color: #fff;\n    display: flex;\n    align-items: center;\n    padding: 10px;\n    overflow-x: auto;\n  }\n\n  .node {\n    min-width: 60px;\n    height: 60px;\n    background-color: #4a90e2;\n    color: white;\n    margin-right: 12px;\n    font-weight: bold;\n    font-size: 20px;\n    line-height: 60px;\n    border-radius: 8px;\n    position: relative;\n    user-select: none;\n    box-shadow: 0 3px 6px rgb(74 144 226 / 0.5);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n\n  /* Tail and Head labels */\n  .node::after {\n    content: \"\";\n    position: absolute;\n    top: -20px;\n    right: 5px;\n    font-weight: normal;\n    font-size: 12px;\n    color: #222;\n  }\n  .node.head::after {\n    content: \"Front\";\n    color: #e94e77;\n  }\n  .node.tail::after {\n    content: \"Rear\";\n    color: #27ae60;\n    right: auto;\n    left: 5px;\n  }\n\n  #controls {\n    margin: 0 auto;\n    max-width: 800px;\n    display: flex;\n    justify-content: center;\n    flex-wrap: wrap;\n    gap: 15px;\n  }\n  #controls input[type=\"number\"] {\n    width: 100px;\n    font-size: 18px;\n    padding: 5px 10px;\n    border-radius: 6px;\n    border: 2px solid #ccc;\n    transition: border-color 0.3s ease;\n  }\n  #controls input[type=\"number\"]:focus {\n    outline: none;\n    border-color: #4a90e2;\n  }\n  button {\n    background-color: #4a90e2;\n    border: none;\n    color: white;\n    padding: 10px 18px;\n    font-size: 18px;\n    cursor: pointer;\n    border-radius: 8px;\n    box-shadow: 0 4px 8px rgb(74 144 226 / 0.6);\n    transition: background-color 0.3s ease;\n    user-select: none;\n  }\n  button:hover:not(:disabled) {\n    background-color: #357ABD;\n  }\n  button:disabled {\n    background-color: #a4c1f9;\n    cursor: default;\n    box-shadow: none;\n  }\n  #message {\n    max-width: 800px;\n    margin: 15px auto;\n    font-size: 18px;\n    text-align: center;\n    min-height: 28px;\n    color: #e94e77;\n    font-weight: bold;\n    user-select: none;\n  }\n  /* Animation */\n  .enqueue-animation {\n    animation: enqueueMove 0.7s ease forwards;\n  }\n  .dequeue-animation {\n    animation: dequeueMove 0.7s ease forwards;\n  }\n  @keyframes enqueueMove {\n    0% {\n      transform: translateY(-50px) scale(1.2);\n      opacity: 0;\n    }\n    100% {\n      transform: translateY(0) scale(1);\n      opacity: 1;\n    }\n  }\n  @keyframes dequeueMove {\n    0% {\n      transform: translateX(0) scale(1);\n      opacity: 1;\n    }\n    100% {\n      transform: translateX(50px) scale(1.3);\n      opacity: 0;\n    }\n  }\n\n  /* Scrollbar for queue container */\n  #queue-container::-webkit-scrollbar {\n    height: 8px;\n  }\n  #queue-container::-webkit-scrollbar-track {\n    background: #eee;\n    border-radius: 4px;\n  }\n  #queue-container::-webkit-scrollbar-thumb {\n    background: #4a90e2;\n    border-radius: 4px;\n  }\n\n  /* Responsive */\n  @media (max-width: 500px) {\n    .node {\n      min-width: 50px;\n      height: 50px;\n      font-size: 16px;\n      line-height: 50px;\n      margin-right: 8px;\n    }\n    #controls {\n      flex-direction: column;\n      gap: 12px;\n    }\n    #controls input[type=\"number\"], button {\n      width: 100%;\n      max-width: 300px;\n      font-size: 16px;\n      padding: 8px 12px;\n    }\n  }\n</style>\n</head>\n<body>\n  <h1>队列 (Queue) 交互式可视化演示</h1>\n\n  <div id=\"queue-container\" aria-label=\"队列可视化区域\" role=\"list\"></div>\n\n  <div id=\"message\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n\n  <div id=\"controls\" role=\"region\" aria-label=\"队列操作控制面板\">\n    <input id=\"enqueue-input\" type=\"number\" aria-label=\"输入要入队的数字\" placeholder=\"输入数字\" />\n    <button id=\"enqueue-btn\" aria-describedby=\"enqueue-desc\">入队 (Enqueue)</button>\n    <button id=\"dequeue-btn\" aria-describedby=\"dequeue-desc\">出队 (Dequeue)</button>\n    <button id=\"clear-btn\" aria-describedby=\"clear-desc\">清空队列 (Clear)</button>\n  </div>\n\n  <div style=\"width:80%; max-width:800px; margin:15px auto; font-size:14px; color:#555; text-align:center;\">\n    <p id=\"enqueue-desc\">将输入的数字添加到队列的尾部。</p>\n    <p id=\"dequeue-desc\">移除队列头部的元素。</p>\n    <p id=\"clear-desc\">清空整个队列。</p>\n  </div>\n\n<script>\n  (function(){\n    const queueContainer = document.getElementById(\"queue-container\");\n    const enqueueBtn = document.getElementById(\"enqueue-btn\");\n    const dequeueBtn = document.getElementById(\"dequeue-btn\");\n    const clearBtn = document.getElementById(\"clear-btn\");\n    const enqueueInput = document.getElementById(\"enqueue-input\");\n    const message = document.getElementById(\"message\");\n\n    // 队列数据结构（用数组实现）\n    let queue = [];\n\n    // 动画时长(ms)\n    const ANIMATION_DURATION = 700;\n\n    // 更新UI显示队列内容\n    function renderQueue(animatedNode = null, action = '') {\n      // 清空容器，重新生成\n      queueContainer.innerHTML = \"\";\n      queue.forEach((value, index) => {\n        const node = document.createElement(\"div\");\n        node.classList.add(\"node\");\n        node.textContent = value;\n        node.setAttribute(\"role\", \"listitem\");\n\n        // 头尾节点标记\n        if (index === 0) node.classList.add(\"head\");\n        if (index === queue.length - 1) node.classList.add(\"tail\");\n        queueContainer.appendChild(node);\n      });\n\n      // 动画处理\n      if (animatedNode) {\n        // Use absolute positioned clone during animation\n        const animNode = animatedNode.cloneNode(true);\n        animNode.style.position = \"absolute\";\n        animNode.style.zIndex = 1000;\n        animNode.style.width = animatedNode.offsetWidth + \"px\";\n        animNode.style.height = animatedNode.offsetHeight + \"px\";\n\n        // Calculate start position:\n        // For enqueue: start above container center, move down into tail position\n        // For dequeue: start at head node position, move right and fade\n\n        if (action === \"enqueue\") {\n          const containerRect = queueContainer.getBoundingClientRect();\n          const tailNode = queueContainer.querySelector(\".node.tail\");\n          let tailRect;\n          if (tailNode) {\n            tailRect = tailNode.getBoundingClientRect();\n          } else {\n            // Queue empty: put at left+some padding\n            tailRect = { left: containerRect.left + 10, top: containerRect.top + 20, width: 60, height: 60 };\n          }\n\n          animNode.style.left = (tailRect.left) + \"px\";\n          animNode.style.top = (tailRect.top - 80) + \"px\";\n          animNode.style.opacity = \"0\";\n          document.body.appendChild(animNode);\n          animNode.classList.add(\"enqueue-animation\");\n\n          // After animation end, remove animNode and render normal\n          animNode.addEventListener(\"animationend\", () => {\n            animNode.remove();\n            // Just render again normal (already done)\n          });\n        } else if (action === \"dequeue\") {\n          const headNode = animatedNode;\n          const headRect = headNode.getBoundingClientRect();\n\n          animNode.style.left = headRect.left + \"px\";\n          animNode.style.top = headRect.top + \"px\";\n          animNode.style.opacity = \"1\";\n          document.body.appendChild(animNode);\n          animNode.classList.add(\"dequeue-animation\");\n\n          animNode.addEventListener(\"animationend\", () => {\n            animNode.remove();\n            // Render normal already done\n          });\n        }\n      }\n      updateButtons();\n    }\n\n    // 更新按钮状态\n    function updateButtons() {\n      enqueueBtn.disabled = false;\n      dequeueBtn.disabled = queue.length === 0;\n      clearBtn.disabled = queue.length === 0;\n    }\n\n    // 显示提示信息\n    function setMessage(text, isError = false) {\n      if (isError) {\n        message.style.color = \"#e94e77\";\n      } else {\n        message.style.color = \"#27ae60\";\n      }\n      message.textContent = text;\n      // Clear message after 3 seconds if not error\n      if (!isError) {\n        clearTimeout(message._timeout);\n        message._timeout = setTimeout(() => {\n          message.textContent = \"\";\n        }, 3000);\n      }\n    }\n\n    // 入队操作\n    enqueueBtn.addEventListener(\"click\", () => {\n      const valRaw = enqueueInput.value.trim();\n      if (valRaw === \"\") {\n        setMessage(\"请输入一个数字！\", true);\n        enqueueInput.focus();\n        return;\n      }\n      // Check if number\n      const valNum = Number(valRaw);\n      if (Number.isNaN(valNum) || !Number.isFinite(valNum)) {\n        setMessage(\"请输入有效数字！\", true);\n        enqueueInput.focus();\n        return;\n      }\n      // Optional: Limit number range or size? For demo no limit\n\n      enqueueInput.value = \"\";\n      enqueueInput.focus();\n\n      // Animate enqueue:\n      // Create a temp node for animation start point\n      const animNode = document.createElement(\"div\");\n      animNode.classList.add(\"node\");\n      animNode.textContent = valNum;\n      animNode.style.position = \"absolute\";\n      animNode.style.pointerEvents = \"none\";\n\n      // Start animation from above container center\n      const containerRect = queueContainer.getBoundingClientRect();\n      animNode.style.left = (containerRect.left + containerRect.width / 2 - 30) + \"px\";\n      animNode.style.top = (containerRect.top - 80) + \"px\";\n      animNode.style.opacity = \"0\";\n\n      document.body.appendChild(animNode);\n\n      // Trigger animation frame to apply animation:\n      requestAnimationFrame(() => {\n        animNode.style.transition = `transform ${ANIMATION_DURATION}ms ease, opacity ${ANIMATION_DURATION}ms ease`;\n        animNode.style.transform = `translateY(80px) scale(1)`;\n        animNode.style.opacity = \"1\";\n      });\n\n      setTimeout(() => {\n        animNode.remove();\n        queue.push(valNum);\n        renderQueue();\n        setMessage(`元素 ${valNum} 已入队。`);\n      }, ANIMATION_DURATION);\n\n      updateButtons();\n    });\n\n    // 出队操作\n    dequeueBtn.addEventListener(\"click\", () => {\n      if (queue.length === 0) {\n        setMessage(\"队列为空，无法出队！\", true);\n        return;\n      }\n      dequeueBtn.disabled = true;\n      enqueueBtn.disabled = true;\n      clearBtn.disabled = true;\n      const value = queue[0];\n\n      // Animate dequeue the head node from the displayed queue nodes\n      const headNode = queueContainer.querySelector(\".node.head\");\n      if (!headNode) {\n        // Fallback: just dequeue\n        queue.shift();\n        renderQueue();\n        setMessage(`元素 ${value} 已出队。`);\n        updateButtons();\n        return;\n      }\n\n      // Clone node for animation\n      const animNode = headNode.cloneNode(true);\n      const headRect = headNode.getBoundingClientRect();\n\n      animNode.style.position = \"absolute\";\n      animNode.style.left = headRect.left + \"px\";\n      animNode.style.top = headRect.top + \"px\";\n      animNode.style.width = headRect.width + \"px\";\n      animNode.style.height = headRect.height + \"px\";\n      animNode.style.margin = 0;\n      animNode.style.zIndex = 1000;\n      animNode.style.userSelect = \"none\";\n      document.body.appendChild(animNode);\n\n      // Remove the first item from the queue immediately but re-render without the first\n      queue.shift();\n\n      // Trigger animation\n      requestAnimationFrame(() => {\n        animNode.style.transition = `transform ${ANIMATION_DURATION}ms ease, opacity ${ANIMATION_DURATION}ms ease`;\n        animNode.style.transform = \"translateX(50px) scale(1.3)\";\n        animNode.style.opacity = \"0\";\n      });\n\n      // Also update queue container UI immediately\n      renderQueue();\n\n      setTimeout(() => {\n        animNode.remove();\n        setMessage(`元素 ${value} 已出队。`);\n        updateButtons();\n        enqueueBtn.disabled = false;\n        clearBtn.disabled = queue.length === 0;\n      }, ANIMATION_DURATION);\n    });\n\n    // 清空队列操作\n    clearBtn.addEventListener(\"click\", () => {\n      if (queue.length === 0) {\n        setMessage(\"队列已为空。\");\n        return;\n      }\n      queue = [];\n      renderQueue();\n      setMessage(\"队列已清空。\");\n      updateButtons();\n      enqueueInput.focus();\n    });\n\n    // 支持输入回车入队\n    enqueueInput.addEventListener(\"keydown\", (e) => {\n      if (e.key === \"Enter\") {\n        e.preventDefault();\n        enqueueBtn.click();\n      }\n    });\n\n    // 初始渲染\n    renderQueue();\n\n  })();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "创建一个Queue算法的交互式可视化演示，包含动画效果和用户控制按钮"
    }
  ],
  "topic": "Queue",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}