<!DOCTYPE html>
# Heap Sort Algorithm Demonstration

Here's an interactive HTML demonstration of the Heap Sort algorithm:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heap Sort Algorithm</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        
        .container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .array-input {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .visualization {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 250px;
            background-color: #ecf0f1;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 20px;
        }
        
        .element {
            background-color: #3498db;
            margin: 0 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .current {
            background-color: #e74c3c;
        }
        
        .sorted {
            background-color: #2ecc71;
        }
        
        .heap-node {
            background-color: #f39c12;
        }
        
        .code-container {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        
        .highlight {
            background-color: #e74c3c;
            padding: 2px;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        .heap-visual {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }
        
        .heap-row {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .heap-element {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f39c12;
            color: white;
            font-weight: bold;
            margin: 0 10px;
        }
        
        .heap-connections {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        .heap-container {
            position: relative;
        }
    </style>
</head>
<body>
    <h1>Heap Sort Algorithm Visualization</h1>
    
    <div class="container">
        <div class="controls">
            <input type="text" id="arrayInput" class="array-input" placeholder="Enter numbers separated by commas (e.g., 5, 2, 8, 1, 9)">
            <button id="resetBtn">Reset</button>
            <button id="randomBtn">Generate Random Array</button>
            <button id="startBtn">Start Sorting</button>
            <button id="stepBtn">Next Step</button>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #3498db;"></div>
                <span>Unsorted</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #f39c12;"></div>
                <span>Heap Node</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #e74c3c;"></div>
                <span>Current Element</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #2ecc71;"></div>
                <span>Sorted</span>
            </div>
        </div>
        
        <div id="visualization" class="visualization">
            <!-- Array elements will be generated here -->
        </div>
        
        <div class="heap-container">
            <h3>Heap Structure</h3>
            <div id="heapVisual" class="heap-visual">
                <!-- Heap visualization will be generated here -->
            </div>
        </div>
        
        <div class="code-container">
            <pre id="codeDisplay">
// Heap Sort Algorithm

function heapSort(arr) {
    let n = arr.length;
    
    // Build max heap
    for (let i = Math.floor(n/2) - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // Extract elements from heap one by one
    for (let i = n - 1; i > 0; i--) {
        // Move current root to end
        [arr[0], arr[i]] = [arr[i], arr[0]];
        
        // Call heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

function heapify(arr, n, i) {
    let largest = i;        // Initialize largest as root
    let left = 2 * i + 1;   // left child
    let right = 2 * i + 2;  // right child
    
    // If left child is larger than root
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    
    // If right child is larger than largest so far
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    // If largest is not root
    if (largest !== i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]];
        
        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}
            </pre>
        </div>
    </div>
    
    <div class="container">
        <h2>How Heap Sort Works</h2>
        <p>Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure. It has an O(n log n) time complexity, making it efficient for large datasets.</p>
        
        <h3>Steps:</h3>
        <ol>
            <li><strong>Build a max heap</strong> from the input data.</li>
            <li>The largest element is at the root of the heap. Replace it with the last item of the heap followed by reducing the size of the heap by one.</li>
            <li><strong>Heapify</strong> the root of the tree.</li>
            <li>Repeat the above steps while the size of the heap is greater than 1.</li>
        </ol>
        
        <h3>Complexity:</h3>
        <ul>
            <li>Time Complexity: O(n log n) in all cases</li>
            <li>Space Complexity: O(1) as it's an in-place algorithm</li>
        </ul>
    </div>

    <script>
        // Algorithm state
        let array = [];
        let sortedArray = [];
        let currentStep = 0;
        let heapSize = 0;
        let sorting = false;
        let steps = [];
        let currentHeap = [];
        
        // DOM elements
        const arrayInput = document.getElementById('arrayInput');
        const resetBtn = document.getElementById('resetBtn');
        const randomBtn = document.getElementById('randomBtn');
        const startBtn = document.getElementById('startBtn');
        const stepBtn = document.getElementById('stepBtn');
        const visualization = document.getElementById('visualization');
        const heapVisual = document.getElementById('heapVisual');
        const codeDisplay = document.getElementById('codeDisplay');
        
        // Initialize with a sample array
        arrayInput.value = '5, 2, 8, 1, 9, 3, 7, 4, 6';
        initializeArray();
        
        // Event listeners
        resetBtn.addEventListener('click', initializeArray);
        randomBtn.addEventListener('click', generateRandomArray);
        startBtn.addEventListener('click', startSorting);
        stepBtn.addEventListener('click', performNextStep);
        
        function initializeArray() {
            const input = arrayInput.value.split(',').map(num => parseInt(num.trim())).filter(num => !isNaN(num));
            array = input.length > 0 ? input : [5, 2, 8, 1, 9, 3, 7, 4, 6];
            arrayInput.value = array.join(', ');
            sortedArray = [...array];
            currentStep = 0;
            heapSize = array.length;
            sorting = false;
            steps = [];
            visualizeArray();
            updateButtons();
            highlightCode(-1);
            
            // Initialize steps for heap sort
            prepareHeapSort();
        }
        
        function generateRandomArray() {
            const size = Math.floor(Math.random() * 10) + 5; // 5 to 14 elements
            array = Array.from({length: size}, () => Math.floor(Math.random() * 100) + 1);
            arrayInput.value = array.join(', ');
            initializeArray();
        }
        
        function prepareHeapSort() {
            // Reset steps
            steps = [];
            
            // Create a copy to manipulate
            const arr = [...array];
            const n = arr.length;
            
            // Build max heap phase
            for (let i = Math.floor(n/2) - 1; i >= 0; i--) {
                heapify(arr, n, i, true);
            }
            
            // Extract elements from heap one by one
            for (let i = n - 1; i > 0; i--) {
                // Save state before swapping
                steps.push({
                    array: [...arr],
                    action: 'swap',
                    index1: 0,
                    index2: i,
                    heapSize: i,
                    description: `Swap root (${arr[0]}) with last element (${arr[i]})`
                });
                
                // Perform swap
                [arr[0], arr[i]] = [arr[i], arr[0]];
                
                // Save state after swapping
                steps.push({
                    array: [...arr],
                    action: 'heapify',
                    index: 0,
                    heapSize: i,
                    description: `Heapify the root (index 0)`
                });
                
                // Heapify the root
                heapify(arr, i, 0, false);
            }
            
            // Final state - fully sorted
            steps.push({
                array: [...arr],
                action: 'complete',
                description: 'Array is fully sorted'
            });
        }
        
        function heapify(arr, n, i, isBuilding) {
            let largest = i;
            let left = 2 * i + 1;
            let right = 2 * i + 2;
            
            // Save initial state
            if (isBuilding) {
                steps.push({
                    array: [...arr],
                    action: 'heapify',
                    index: i,
                    heapSize: n,
                    description: `Building heap: heapify node at index ${i}`
                });
            }
            
            // Check left child
            if (left < n && arr[left] > arr[largest]) {
                largest = left;
            }
            
            // Check right child
            if (right < n && arr[right] > arr[largest]) {
                largest = right;
            }
            
            // If largest is not the current node, swap and heapify
            if (largest !== i) {
                // Save state before swapping
                steps.push({
                    array: [...arr],
                    action: 'swap',
                    index1: i,
                    index2: largest,
                    heapSize: n,
                    description: `Swap ${arr[i]} at index ${i} with ${arr[largest]} at index ${largest}`
                });
                
                // Perform swap
                [arr[i], arr[largest]] = [arr[largest], arr[i]];
                
                // Save state after swapping
                steps.push({
                    array: [...arr],
                    action: 'heapify',
                    index: largest,
                    heapSize: n,
                    description: `Continue heapifying from index ${largest}`
                });
                
                // Recursively heapify the affected sub-tree
                heapify(arr, n, largest, isBuilding);
            }
        }
        
        function startSorting() {
            if (sorting) return;
            sorting = true;
            updateButtons();
            
            // Auto-advance through steps
            const interval = setInterval(() => {
                if (currentStep >= steps.length) {
                    clearInterval(interval);
                    sorting = false;
                    updateButtons();
                    return;
                }
                
                performNextStep();
            }, 1500);
        }
        
        function performNextStep() {
            if (currentStep >= steps.length) return;
            
            const step = steps[currentStep];
            sortedArray = [...step.array];
            heapSize = step.heapSize || sortedArray.length;
            
            visualizeArray();
            visualizeHeap();
            highlightCode(currentStep);
            
            currentStep++;
            updateButtons();
        }
        
        function visualizeArray() {
            visualization.innerHTML = '';
            const maxValue = Math.max(...sortedArray);
            const containerHeight = visualization.clientHeight - 20;
            
            sortedArray.forEach((value, index) => {
                const element = document.createElement('div');
                element.className = 'element';
                element.textContent = value;
                
                // Calculate height based on value
                const height = (value / maxValue) * containerHeight;
                element.style.height = `${height}px`;
                element.style.width = `calc(100% / ${sortedArray.length} - 4px)`;
                
                // Apply styling based on current state
                if (index >= heapSize) {
                    element.classList.add('sorted');
                } else if (currentStep < steps.length && steps[currentStep]) {
                    const step = steps[currentStep];
                    if ((step.index1 === index || step.index2 === index) && step.action === 'swap') {
                        element.classList.add('current');
                    } else if (step.index === index && step.action === 'heapify') {
                        element.classList.add('heap-node');
                    }
                }
                
                visualization.appendChild(element);
            });
        }
        
        function visualizeHeap() {
            if (heapSize === 0) return;
            
            heapVisual.innerHTML = '';
            
            // Build heap structure for visualization
            const heapElements = [];
            for (let i = 0; i < heapSize; i++) {
                heapElements.push({
                    value: sortedArray[i],
                    index: i,
                    level: Math.floor(Math.log2(i + 1)),
                    position: i - (Math.pow(2, Math.floor(Math.log2(i + 1))) - 1)
                });
            }
            
            // Group by level
            const levels = {};
            heapElements.forEach(item => {
                if (!levels[item.level]) levels[item.level] = [];
                levels[item.level].push(item);
            });
            
            // Create rows for each level
            Object.keys(levels).forEach(level => {
                const row = document.createElement('div');
                row.className = 'heap-row';
                
                levels[level].forEach(item => {
                    const element = document.createElement('div');
                    element.className = 'heap-element';
                    element.textContent = item.value;
                    
                    // Highlight if this is the current node being processed
                    if (currentStep < steps.length && steps[currentStep]) {
                        const step = steps[currentStep];
                        if ((step.index1 === item.index || step.index2 === item.index) && step.action === 'swap') {
                            element.style.backgroundColor = '#e74c3c';
                        } else if (step.index === item.index && step.action === 'heapify') {
                            element.style.backgroundColor = '#e74c3c';
                        }
                    }
                    
                    row.appendChild(element);
                });
                
                heapVisual.appendChild(row);
            });
            
            // Add description if available
            if (currentStep < steps.length && steps[currentStep]) {
                const description = document.createElement('p');
                description.textContent = steps[currentStep].description;
                description.style.textAlign = 'center';
                description.style.marginTop = '10px';
                heapVisual.appendChild(description);
            }
        }
        
        function highlightCode(stepIndex) {
            // Remove previous highlights
            codeDisplay.innerHTML = codeDisplay.textContent;
            
            if (stepIndex < 0) return;
            
            // Simple highlighting based on step type
            const codeText = codeDisplay.textContent;
            let highlightedCode = codeText;
            
            if (steps[stepIndex]) {
                const step = steps[stepIndex];
                
                if (step.action === 'heapify') {
                    highlightedCode = codeText.replace(/heapify\(arr, n, i\)/g, '<span class="highlight">heapify(arr, n, i)</span>');
                } else if (step.action === 'swap') {
