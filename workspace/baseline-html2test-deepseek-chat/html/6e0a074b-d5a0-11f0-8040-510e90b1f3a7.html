<!DOCTYPE html>
# Prim's Algorithm Visualization

I'll create an interactive visualization of Prim's Algorithm for finding Minimum Spanning Trees (MST). This visualization will let users build their own graphs and watch the algorithm in action.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prim's Algorithm Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .description {
            text-align: center;
            margin-bottom: 25px;
            color: #7f8c8d;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
        }
        button {
            padding: 10px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .visualization {
            display: flex;
            gap: 20px;
        }
        #graphCanvas {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .info-panel {
            flex: 1;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .info-panel h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        .step-info {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            min-height: 150px;
            margin-bottom: 15px;
        }
        .logs {
            height: 200px;
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
        }
        .node-count {
            width: 80px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        .mst-edge {
            background-color: #2ecc71;
        }
        .candidate-edge {
            background-color: #3498db;
        }
        .unvisited-node {
            background-color: #e74c3c;
        }
        .visited-node {
            background-color: #2ecc71;
        }
    </style>
</head>
<body>
    <h1>Prim's Algorithm Visualization</h1>
    <p class="description">Prim's Algorithm finds a Minimum Spanning Tree (MST) for a weighted undirected graph.</p>
    
    <div class="container">
        <div class="controls">
            <div class="control-group">
                <button id="addNodeBtn">Add Node</button>
                <button id="runAlgorithmBtn">Run Prim's Algorithm</button>
                <button id="nextStepBtn">Next Step</button>
                <button id="resetBtn">Reset</button>
                <button id="randomGraphBtn">Generate Random Graph</button>
                <input type="number" id="nodeCount" class="node-count" min="3" max="10" value="5" placeholder="Nodes">
            </div>
            <div class="control-group">
                <span>Click on the canvas to add nodes. Click and drag between nodes to add edges.</span>
            </div>
        </div>
        
        <div class="visualization">
            <canvas id="graphCanvas" width="800" height="500"></canvas>
            
            <div class="info-panel">
                <h3>Algorithm Steps</h3>
                <div class="step-info" id="stepInfo">
                    <p>Click "Run Prim's Algorithm" to start the visualization.</p>
                </div>
                
                <h3>Algorithm Log</h3>
                <div class="logs" id="logs"></div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color visited-node"></div>
                        <span>Visited Node</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color unvisited-node"></div>
                        <span>Unvisited Node</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color mst-edge"></div>
                        <span>MST Edge</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color candidate-edge"></div>
                        <span>Candidate Edge</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI elements
        const addNodeBtn = document.getElementById('addNodeBtn');
        const runAlgorithmBtn = document.getElementById('runAlgorithmBtn');
        const nextStepBtn = document.getElementById('nextStepBtn');
        const resetBtn = document.getElementById('resetBtn');
        const randomGraphBtn = document.getElementById('randomGraphBtn');
        const nodeCountInput = document.getElementById('nodeCount');
        const stepInfo = document.getElementById('stepInfo');
        const logs = document.getElementById('logs');
        
        // Graph data structure
        let nodes = [];
        let edges = [];
        let isRunningAlgorithm = false;
        let algorithmStep = 0;
        let animationId = null;
        
        // Prim's algorithm state
        let visited = new Set();
        let mstEdges = [];
        let candidateEdges = [];
        
        // Node class
        class Node {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.id = nodes.length;
                this.radius = 20;
            }
            
            draw() {
                // Draw node circle
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                
                if (visited.has(this.id)) {
                    ctx.fillStyle = '#2ecc71'; // Visited node - green
                } else {
                    ctx.fillStyle = '#e74c3c'; // Unvisited node - red
                }
                
                ctx.fill();
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw node label
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.id, this.x, this.y);
            }
            
            containsPoint(x, y) {
                const distance = Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2);
                return distance <= this.radius;
            }
        }
        
        // Edge class
        class Edge {
            constructor(node1, node2, weight) {
                this.node1 = node1;
                this.node2 = node2;
                this.weight = weight || Math.floor(Math.random() * 20) + 1;
            }
            
            draw() {
                const x1 = this.node1.x;
                const y1 = this.node1.y;
                const x2 = this.node2.x;
                const y2 = this.node2.y;
                
                // Determine edge color based on state
                if (mstEdges.some(e => 
                    (e.node1.id === this.node1.id && e.node2.id === this.node2.id) ||
                    (e.node1.id === this.node2.id && e.node2.id === this.node1.id))) {
                    ctx.strokeStyle = '#2ecc71'; // MST edge - green
                    ctx.lineWidth = 4;
                } else if (candidateEdges.some(e => 
                    (e.node1.id === this.node1.id && e.node2.id === this.node2.id) ||
                    (e.node1.id === this.node2.id && e.node2.id === this.node1.id))) {
                    ctx.strokeStyle = '#3498db'; // Candidate edge - blue
                    ctx.lineWidth = 3;
                } else {
                    ctx.strokeStyle = '#7f8c8d'; // Regular edge - gray
                    ctx.lineWidth = 2;
                }
                
                // Draw the edge line
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // Draw weight label
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                
                ctx.fillStyle = 'white';
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 1;
                ctx.fillRect(midX - 15, midY - 10, 30, 20);
                ctx.strokeRect(midX - 15, midY - 10, 30, 20);
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.weight, midX, midY);
            }
        }
        
        // Draw the graph
        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges first (so they appear behind nodes)
            edges.forEach(edge => edge.draw());
            
            // Draw nodes on top
            nodes.forEach(node => node.draw());
        }
        
        // Find node at coordinates
        function findNodeAt(x, y) {
            for (let i = nodes.length - 1; i >= 0; i--) {
                if (nodes[i].containsPoint(x, y)) {
                    return nodes[i];
                }
            }
            return null;
        }
        
        // Reset the algorithm state
        function resetAlgorithm() {
            visited.clear();
            mstEdges = [];
            candidateEdges = [];
            algorithmStep = 0;
            isRunningAlgorithm = false;
            stepInfo.innerHTML = '<p>Click "Run Prim\'s Algorithm" to start the visualization.</p>';
            logs.innerHTML = '';
            drawGraph();
        }
        
        // Add a log message
        function addLog(message) {
            const logEntry = document.createElement('div');
            logEntry.textContent = `Step ${algorithmStep}: ${message}`;
            logs.appendChild(logEntry);
            logs.scrollTop = logs.scrollHeight;
        }
        
        // Perform one step of Prim's algorithm
        function primStep() {
            if (!isRunningAlgorithm) return;
            
            algorithmStep++;
            let message = '';
            
            // Step 1: Initialize with the first node if no nodes visited yet
            if (visited.size === 0 && nodes.length > 0) {
                const startNode = nodes[0];
                visited.add(startNode.id);
                message = `Starting with node ${startNode.id}`;
                addLog(message);
                stepInfo.innerHTML = `<p>${message}</p><p>Added node ${startNode.id} to the MST.</p>`;
                drawGraph();
                return;
            }
            
            // Step 2: If all nodes are visited, we're done
            if (visited.size === nodes.length) {
                message = 'All nodes are in the MST. Algorithm completed!';
                addLog(message);
                stepInfo.innerHTML = `<p>${message}</p><p>Total MST weight: ${calculateMSTWeight()}</p>`;
                isRunningAlgorithm = false;
                drawGraph();
                return;
            }
            
            // Step 3: Update candidate edges (edges connecting visited to unvisited nodes)
            candidateEdges = [];
            edges.forEach(edge => {
                const node1Visited = visited.has(edge.node1.id);
                const node2Visited = visited.has(edge.node2.id);
                
                // Candidate edge connects a visited node to an unvisited node
                if ((node1Visited && !node2Visited) || (!node1Visited && node2Visited)) {
                    candidateEdges.push(edge);
                }
            });
            
            // Step 4: If no candidate edges, the graph might be disconnected
            if (candidateEdges.length === 0) {
                message = 'No candidate edges found. The graph might be disconnected.';
                addLog(message);
                stepInfo.innerHTML = `<p>${message}</p>`;
                isRunningAlgorithm = false;
                drawGraph();
                return;
            }
            
            // Step 5: Find the minimum weight candidate edge
            let minEdge = candidateEdges[0];
            for (let i = 1; i < candidateEdges.length; i++) {
                if (candidateEdges[i].weight < minEdge.weight) {
                    minEdge = candidateEdges[i];
                }
            }
            
            // Step 6: Add the edge to MST and mark the unvisited node as visited
            mstEdges.push(minEdge);
            const newNode = visited.has(minEdge.node1.id) ? minEdge.node2 : minEdge.node1;
            visited.add(newNode.id);
            
            message = `Added edge (${minEdge.node1.id}-${minEdge.node2.id}) with weight ${minEdge.weight} to MST`;
            addLog(message);
            stepInfo.innerHTML = `<p>${message}</p><p>Added node ${newNode.id} to the MST.</p>`;
            
            drawGraph();
        }
        
        // Calculate the total weight of the MST
        function calculateMSTWeight() {
            return mstEdges.reduce((sum, edge) => sum + edge.weight, 0);
        }
        
        // Run the algorithm continuously
        function runAlgorithm() {
            if (nodes.length < 2) {
                alert('Please add at least 2 nodes to run the algorithm.');
                return;
            }
            
            isRunningAlgorithm = true;
            algorithmStep = 0;
            visited.clear();
            mstEdges = [];
            candidateEdges = [];
            logs.innerHTML = '';
            
            // Run the algorithm steps with a delay for visualization
            function runStep() {
                if (isRunningAlgorithm && visited.size < nodes.length) {
                    primStep();
                    animationId = setTimeout(runStep, 1500);
                }
            }
            
            runStep();
        }
        
        // Generate a random graph
        function generateRandomGraph() {
            const nodeCount = parseInt(nodeCountInput.value) || 5;
            if (nodeCount < 3 || nodeCount > 10) {
                alert('Please enter a number between 3 and 10 for nodes.');
                return;
            }
            
            resetAlgorithm();
            nodes = [];
            edges = [];
            
            // Create nodes in a circular arrangement
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.35;
            
            for (let i = 0; i < nodeCount; i++) {
                const angle = (2 * Math.PI * i) / nodeCount;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                nodes.push(new Node(x, y));
            }
            
            // Create edges - connect each node to a few others
            for (let i = 0; i < nodeCount; i++) {
                // Connect to the next node (creating a cycle)
                edges.push(new Edge(nodes[i], nodes[(i + 1) % nodeCount]));
                
                // Randomly connect to one or two other nodes
                const extraConnections = Math.floor(Math.random() * 2) + 1;
                for (let j = 0; j < extraConnections; j++) {
                    const randomNode = Math.floor(Math.random() * nodeCount);
                    if (randomNode !== i && randomNode !== (i + 1) % nodeCount) {
                        // Check if edge already exists
                        const edgeExists = edges.some(edge => 
                            (edge.node1.id === i && edge.node2.id === randomNode) ||
                            (edge.node1.id === randomNode && edge.node2.id === i));
                        
                        if (!edgeExists) {
                            edges.push(new Edge(nodes[i], nodes[randomNode]));
                        }
                    }
                }
            }
            
            drawGraph();
            stepInfo.innerHTML = `<p>Random graph generated with ${nodeCount} nodes and ${edges.length} edges.</p>`;
        }
        
        // Event listeners
        addNodeBtn.addEventListener('click', () => {
            resetAlgorithm();
            // Add a node at a random position (avoiding edges)
            const padding = 40;
            const x = Math.random() * (canvas.width - 2 * padding) + padding;
            const y = Math.random() * (canvas.height - 2 * padding) + padding;
            nodes.push(new Node(x, y));
            drawGraph();
        });
        
        runAlgorithmBtn.addEventListener('click', runAlgorithm);
        
        nextStepBtn.addEventListener('click', () => {
            if (!isRunningAlgorithm) {
                if (nodes.length < 2)