<!DOCTYPE html>
# Interactive Red-Black Tree Visualization

I'll create a comprehensive visualization of a Red-Black Tree with insertion functionality and detailed animations to demonstrate how this self-balancing binary search tree works.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red-Black Tree Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .description {
            color: #7f8c8d;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .controls {
            flex: 1;
            min-width: 300px;
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .visualization {
            flex: 2;
            min-width: 300px;
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
        }
        
        .tree-container {
            flex: 1;
            overflow: auto;
            min-height: 400px;
            border: 1px solid #eee;
            border-radius: 5px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            width: 100%;
            margin-top: 5px;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .operations {
            margin-top: 20px;
        }
        
        .operations button {
            margin-bottom: 10px;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 5px;
            border: 1px solid #999;
        }
        
        .red {
            background-color: #e74c3c;
        }
        
        .black {
            background-color: #2c3e50;
            color: white;
        }
        
        .properties {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        
        .history {
            margin-top: 20px;
        }
        
        .history-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 5px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        
        .history-item {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }
        
        .history-item:last-child {
            border-bottom: none;
        }
        
        svg {
            display: block;
            margin: 0 auto;
        }
        
        .node {
            cursor: pointer;
        }
        
        .node-text {
            font-weight: bold;
            font-size: 14px;
            text-anchor: middle;
            dominant-baseline: central;
        }
        
        .red-node {
            fill: #e74c3c;
        }
        
        .black-node {
            fill: #2c3e50;
        }
        
        .highlight {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { stroke-width: 2px; }
            50% { stroke-width: 4px; stroke: #f39c12; }
            100% { stroke-width: 2px; }
        }
        
        footer {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        @media (max-width: 768px) {
            .content {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Red-Black Tree Visualization</h1>
            <p class="description">
                A Red-Black Tree is a self-balancing binary search tree where each node contains an extra bit for denoting the color of the node (red or black). 
                These trees maintain balance by ensuring that no path from the root to a leaf is more than twice as long as any other path.
            </p>
        </header>
        
        <div class="content">
            <div class="controls">
                <div class="input-group">
                    <label for="nodeValue">Enter a value to insert:</label>
                    <input type="number" id="nodeValue" placeholder="Enter a number">
                    <button id="insertBtn">Insert Value</button>
                </div>
                
                <div class="operations">
                    <button id="randomBtn">Insert Random Value</button>
                    <button id="clearBtn">Clear Tree</button>
                    <button id="balanceBtn">Show Balance Properties</button>
                </div>
                
                <div class="properties">
                    <h3>Red-Black Tree Properties:</h3>
                    <ul>
                        <li>Every node is either RED or BLACK</li>
                        <li>The root is always BLACK</li>
                        <li>All leaves (NIL) are BLACK</li>
                        <li>If a node is RED, both children are BLACK</li>
                        <li>Every path from a node to its NIL descendants has the same number of BLACK nodes</li>
                    </ul>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="color-box red"></div>
                        <span>Red Node</span>
                    </div>
                    <div class="legend-item">
                        <div class="color-box black"></div>
                        <span>Black Node</span>
                    </div>
                </div>
            </div>
            
            <div class="visualization">
                <h2>Tree Visualization</h2>
                <div class="tree-container" id="treeContainer">
                    <svg id="treeSVG" width="100%" height="100%"></svg>
                </div>
                
                <div class="history">
                    <h3>Operation History:</h3>
                    <div class="history-list" id="historyList">
                        <div class="history-item">Tree initialized</div>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>Red-Black Tree Visualization | Created for educational purposes</p>
        </footer>
    </div>

    <script>
        // Red-Black Tree Implementation
        class Node {
            constructor(value, color = 'RED') {
                this.value = value;
                this.color = color;
                this.left = null;
                this.right = null;
                this.parent = null;
            }
            
            isRed() {
                return this.color === 'RED';
            }
            
            isBlack() {
                return this.color === 'BLACK';
            }
        }

        class RedBlackTree {
            constructor() {
                this.root = null;
                this.NIL = new Node(null, 'BLACK'); // Sentinel node
            }
            
            // Insert a value into the tree
            insert(value) {
                const newNode = new Node(value);
                if (this.root === null) {
                    this.root = newNode;
                    this.root.color = 'BLACK';
                    return newNode;
                }
                
                let current = this.root;
                let parent = null;
                
                while (current !== null) {
                    parent = current;
                    if (value < current.value) {
                        current = current.left;
                    } else if (value > current.value) {
                        current = current.right;
                    } else {
                        // Value already exists
                        return null;
                    }
                }
                
                newNode.parent = parent;
                if (value < parent.value) {
                    parent.left = newNode;
                } else {
                    parent.right = newNode;
                }
                
                this.fixInsert(newNode);
                return newNode;
            }
            
            // Fix the tree after insertion
            fixInsert(node) {
                while (node !== this.root && node.parent.isRed()) {
                    if (node.parent === node.parent.parent.left) {
                        const uncle = node.parent.parent.right;
                        
                        if (uncle !== null && uncle.isRed()) {
                            // Case 1: Uncle is red
                            node.parent.color = 'BLACK';
                            uncle.color = 'BLACK';
                            node.parent.parent.color = 'RED';
                            node = node.parent.parent;
                        } else {
                            if (node === node.parent.right) {
                                // Case 2: Node is right child
                                node = node.parent;
                                this.rotateLeft(node);
                            }
                            
                            // Case 3: Node is left child
                            node.parent.color = 'BLACK';
                            node.parent.parent.color = 'RED';
                            this.rotateRight(node.parent.parent);
                        }
                    } else {
                        // Symmetric case
                        const uncle = node.parent.parent.left;
                        
                        if (uncle !== null && uncle.isRed()) {
                            // Case 1: Uncle is red
                            node.parent.color = 'BLACK';
                            uncle.color = 'BLACK';
                            node.parent.parent.color = 'RED';
                            node = node.parent.parent;
                        } else {
                            if (node === node.parent.left) {
                                // Case 2: Node is left child
                                node = node.parent;
                                this.rotateRight(node);
                            }
                            
                            // Case 3: Node is right child
                            node.parent.color = 'BLACK';
                            node.parent.parent.color = 'RED';
                            this.rotateLeft(node.parent.parent);
                        }
                    }
                }
                
                this.root.color = 'BLACK';
            }
            
            // Rotate left around a node
            rotateLeft(node) {
                const rightChild = node.right;
                node.right = rightChild.left;
                
                if (rightChild.left !== null) {
                    rightChild.left.parent = node;
                }
                
                rightChild.parent = node.parent;
                
                if (node.parent === null) {
                    this.root = rightChild;
                } else if (node === node.parent.left) {
                    node.parent.left = rightChild;
                } else {
                    node.parent.right = rightChild;
                }
                
                rightChild.left = node;
                node.parent = rightChild;
            }
            
            // Rotate right around a node
            rotateRight(node) {
                const leftChild = node.left;
                node.left = leftChild.right;
                
                if (leftChild.right !== null) {
                    leftChild.right.parent = node;
                }
                
                leftChild.parent = node.parent;
                
                if (node.parent === null) {
                    this.root = leftChild;
                } else if (node === node.parent.right) {
                    node.parent.right = leftChild;
                } else {
                    node.parent.left = leftChild;
                }
                
                leftChild.right = node;
                node.parent = leftChild;
            }
            
            // Find a node with the given value
            find(value) {
                let current = this.root;
                while (current !== null) {
                    if (value === current.value) {
                        return current;
                    } else if (value < current.value) {
                        current = current.left;
                    } else {
                        current = current.right;
                    }
                }
                return null;
            }
        }

        // Visualization Code
        class TreeVisualizer {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.svg = document.getElementById('treeSVG');
                this.tree = new RedBlackTree();
                this.nodeRadius = 20;
                this.levelHeight = 80;
                this.animationSpeed = 800;
                
                this.setupEventListeners();
                this.updateVisualization();
            }
            
            setupEventListeners() {
                document.getElementById('insertBtn').addEventListener('click', () => {
                    const value = parseInt(document.getElementById('nodeValue').value);
                    if (!isNaN(value)) {
                        this.insertValue(value);
                        document.getElementById('nodeValue').value = '';
                    }
                });
                
                document.getElementById('randomBtn').addEventListener('click', () => {
                    const value = Math.floor(Math.random() * 100) + 1;
                    this.insertValue(value);
                });
                
                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.tree = new RedBlackTree();
                    this.updateVisualization();
                    this.addHistory('Tree cleared');
                });
                
                document.getElementById('balanceBtn').addEventListener('click', () => {
                    this.highlightBalanceProperties();
                });
                
                document.getElementById('nodeValue').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('insertBtn').click();
                    }
                });
            }
            
            insertValue(value) {
                if (this.tree.find(value) !== null) {
                    this.addHistory(`Value ${value} already exists in the tree`);
                    return;
                }
                
                this.addHistory(`Inserting value ${value}`);
                this.tree.insert(value);
                this.updateVisualization();
                
                // Highlight the newly inserted node
                setTimeout(() => {
                    this.highlightNode(value);
                }, 300);
            }
            
            updateVisualization() {
                // Clear the SVG
                this.svg.innerHTML = '';
                
                if (this.tree.root === null) {
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', '50%');
                    text.setAttribute('y', '50%');
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.textContent = 'Tree is empty';
                    text.setAttribute('fill', '#7f8c8d');
                    this.svg.appendChild(text);
                    return;
                }
                
                // Calculate node positions
                const positions = this.calculateNodePositions(this.tree.root);
                
                // Draw edges first (so they appear behind nodes)
                this.drawEdges(this.tree.root, positions);
                
                // Draw nodes
                this.drawNodes(positions);
            }
            
            calculateNodePositions(root) {
                const positions = new Map();
                this.calculatePositionsRecursive(root, positions, 0, 0, 0);
                return positions;
            }
            
            calculatePositionsRecursive(node, positions, level, position, offset) {
                if (node === null) return offset;
                
                // Calculate left subtree width
                const leftOffset = this.calculatePositionsRecursive(node.left, positions, level + 1, position, offset);
                
                // Calculate current node position
                const x = leftOffset * this.nodeRadius * 2.5;
                const y = level * this.levelHeight + this.nodeRadius;
                
                positions.set(node, { x, y, value: node.value, color: node.color });
                
                // Calculate right subtree width
                const rightOffset = this.calculatePositionsRecursive(node.right, positions, level + 1, position, leftOffset + 1);
                
                return rightOffset;
            }
            
            drawEdges(node, positions) {
                if (node === null) return;
                
                const nodePos = positions.get(node);
                
                if (node.left !== null) {
                    const leftPos = positions.get(node.left);
                    this.drawEdge(nodePos.x, nodePos.y, leftPos.x, leftPos.y);
                    this.drawEdges(node.left, positions);
                }
                
                if (node.right !== null) {
                    const rightPos = positions.get(node.right);
                    this.drawEdge(nodePos.x, nodePos.y, rightPos.x, rightPos.y);
                    this.drawEdges(node.right, positions);
                }
            }
            
            drawEdge(x1, y1, x2, y2) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', '#7f8c8d');
                line.setAttribute('stroke-width', '2');
                this.svg.appendChild(line);
            }
            
            drawNodes(positions) {
                positions.forEach((pos, node) => {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', pos.x);
                    circle.setAttribute('cy', pos.y);
                    circle.setAttribute('r', this.nodeRadius);
                    circle