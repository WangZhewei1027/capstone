<!DOCTYPE html>
# Quick Sort Visualization

I've created an interactive visualization that demonstrates how the Quick Sort algorithm works. You can see step-by-step how the algorithm recursively partitions arrays and sorts elements.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quick Sort Visualization</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            max-width: 1000px;
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            margin-bottom: 30px;
        }
        
        h1 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .description {
            text-align: center;
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
        }
        
        input[type="range"] {
            width: 200px;
            margin: 0 10px;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .array-container {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 300px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            position: relative;
        }
        
        .array-element {
            background: #3498db;
            margin: 0 2px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
        }
        
        .array-element.pivot {
            background: #e74c3c;
        }
        
        .array-element.comparing {
            background: #f1c40f;
        }
        
        .array-element.sorted {
            background: #2ecc71;
        }
        
        .partition {
            position: absolute;
            bottom: 0;
            height: 10px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
        
        .explanation {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-size: 1rem;
            line-height: 1.5;
            min-height: 100px;
        }
        
        .code-section {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            overflow-x: auto;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .step-counter {
            font-size: 1.2rem;
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .stat-item {
            text-align: center;
            background: rgba(255, 255, 255, 0.15);
            padding: 10px 20px;
            border-radius: 8px;
            min-width: 120px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #f1c40f;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .array-container {
                height: 250px;
            }
            
            .legend {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Quick Sort Visualization</h1>
        
        <div class="description">
            <p>Quick Sort is a highly efficient sorting algorithm that uses a divide-and-conquer strategy.</p>
            <p>It works by selecting a 'pivot' element and partitioning the array around it, such that elements less than the pivot are on the left and elements greater than the pivot are on the right. This process is recursively applied to the subarrays.</p>
        </div>
        
        <div class="controls">
            <button id="generateBtn">Generate New Array</button>
            <button id="startBtn">Start Sorting</button>
            <button id="pauseBtn" disabled>Pause</button>
            <button id="resetBtn" disabled>Reset</button>
            <button id="stepBtn" disabled>Step Forward</button>
        </div>
        
        <div class="slider-container">
            <span>Speed:</span>
            <input type="range" id="speedSlider" min="1" max="10" value="5">
            <span>Array Size:</span>
            <input type="range" id="sizeSlider" min="5" max="40" value="15">
        </div>
        
        <div class="step-counter">
            Step: <span id="stepCount">0</span>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <div>Comparisons</div>
                <div class="stat-value" id="comparisons">0</div>
            </div>
            <div class="stat-item">
                <div>Swaps</div>
                <div class="stat-value" id="swaps">0</div>
            </div>
            <div class="stat-item">
                <div>Recursive Calls</div>
                <div class="stat-value" id="recursions">0</div>
            </div>
        </div>
        
        <div class="array-container" id="arrayContainer"></div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #3498db;"></div>
                <span>Normal Element</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #e74c3c;"></div>
                <span>Pivot Element</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #f1c40f;"></div>
                <span>Comparing</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #2ecc71;"></div>
                <span>Sorted</span>
            </div>
        </div>
        
        <div class="explanation" id="explanation">
            Click "Generate New Array" to create a random array, then "Start Sorting" to begin the visualization.
        </div>
        
        <div class="code-section">
// Quick Sort Algorithm (JavaScript implementation)
function quickSort(arr, low, high) {
    if (low < high) {
        // Partition the array and get the pivot index
        let pi = partition(arr, low, high);
        
        // Recursively sort elements before and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

function partition(arr, low, high) {
    // Select the rightmost element as pivot
    let pivot = arr[high];
    
    // Index of smaller element (indicates right position of pivot)
    let i = low - 1;
    
    for (let j = low; j < high; j++) {
        // If current element is smaller than or equal to pivot
        if (arr[j] <= pivot) {
            i++; // Increment index of smaller element
            swap(arr, i, j);
        }
    }
    
    swap(arr, i + 1, high);
    return i + 1;
}

function swap(arr, i, j) {
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
        </div>
    </div>

    <script>
        // DOM elements
        const arrayContainer = document.getElementById('arrayContainer');
        const generateBtn = document.getElementById('generateBtn');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const stepBtn = document.getElementById('stepBtn');
        const speedSlider = document.getElementById('speedSlider');
        const sizeSlider = document.getElementById('sizeSlider');
        const stepCount = document.getElementById('stepCount');
        const comparisons = document.getElementById('comparisons');
        const swaps = document.getElementById('swaps');
        const recursions = document.getElementById('recursions');
        const explanation = document.getElementById('explanation');

        // Global variables
        let array = [];
        let animations = [];
        let currentAnimation = 0;
        let isSorting = false;
        let isPaused = true;
        let animationSpeed = 300;
        let arraySize = 15;
        let stepCounter = 0;
        let comparisonCount = 0;
        let swapCount = 0;
        let recursionCount = 0;

        // Initialize the visualization
        function init() {
            generateNewArray();
            updateSpeed();
            updateSize();
            addEventListeners();
        }

        // Generate a new random array
        function generateNewArray() {
            resetVisualization();
            array = [];
            arraySize = parseInt(sizeSlider.value);
            
            for (let i = 0; i < arraySize; i++) {
                array.push(Math.floor(Math.random() * 95) + 5);
            }
            
            renderArray();
            explanation.textContent = "New array generated. Click 'Start Sorting' to begin the visualization.";
        }

        // Render the array as bars
        function renderArray() {
            arrayContainer.innerHTML = '';
            const containerWidth = arrayContainer.clientWidth;
            const containerHeight = arrayContainer.clientHeight;
            const barWidth = Math.min(30, (containerWidth - 20) / array.length - 2);
            
            for (let i = 0; i < array.length; i++) {
                const bar = document.createElement('div');
                bar.className = 'array-element';
                bar.style.height = `${(array[i] / 100) * containerHeight}px`;
                bar.style.width = `${barWidth}px`;
                bar.textContent = array[i];
                arrayContainer.appendChild(bar);
            }
        }

        // Start the sorting animation
        function startSorting() {
            if (isSorting) return;
            
            isSorting = true;
            isPaused = false;
            currentAnimation = 0;
            stepCounter = 0;
            comparisonCount = 0;
            swapCount = 0;
            recursionCount = 0;
            
            updateButtons();
            generateAnimations();
            playAnimations();
        }

        // Generate the animations for quick sort
        function generateAnimations() {
            animations = [];
            const arr = [...array];
            quickSortWithAnimations(arr, 0, arr.length - 1, []);
            animations.push({type: 'final'});
        }

        // Quick sort algorithm with animation tracking
        function quickSortWithAnimations(arr, low, high, partitionStack) {
            if (low < high) {
                recursionCount++;
                
                // Add partition start animation
                animations.push({
                    type: 'partitionStart',
                    low: low,
                    high: high,
                    stack: [...partitionStack]
                });
                
                let pi = partitionWithAnimations(arr, low, high);
                
                // Add partition end animation
                animations.push({
                    type: 'partitionEnd',
                    pivotIndex: pi
                });
                
                // Recursively sort elements before partition
                quickSortWithAnimations(arr, low, pi - 1, [...partitionStack, [low, pi - 1]]);
                
                // Recursively sort elements after partition
                quickSortWithAnimations(arr, pi + 1, high, [...partitionStack, [pi + 1, high]]);
            }
        }

        // Partition function with animation tracking
        function partitionWithAnimations(arr, low, high) {
            let pivot = arr[high];
            let i = low - 1;
            
            // Highlight pivot
            animations.push({
                type: 'highlightPivot',
                index: high
            });
            
            for (let j = low; j < high; j++) {
                // Compare elements
                animations.push({
                    type: 'compare',
                    indices: [j, high]
                });
                comparisonCount++;
                
                if (arr[j] <= pivot) {
                    i++;
                    
                    if (i !== j) {
                        // Swap elements
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                        animations.push({
                            type: 'swap',
                            indices: [i, j]
                        });
                        swapCount++;
                    }
                }
            }
            
            if (i + 1 !== high) {
                // Swap pivot to correct position
                [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
                animations.push({
                    type: 'swap',
                    indices: [i + 1, high]
                });
                swapCount++;
            }
            
            return i + 1;
        }

        // Play the animations
        function playAnimations() {
            if (isPaused || currentAnimation >= animations.length) {
                if (currentAnimation >= animations.length) {
                    isSorting = false;
                    explanation.textContent = "Sorting completed! The array is now fully sorted.";
                }
                updateButtons();
                return;
            }
            
            const animation = animations[currentAnimation];
            executeAnimation(animation);
            
            currentAnimation++;
            stepCounter++;
            stepCount.textContent = stepCounter;
            comparisons.textContent = comparisonCount;
            swaps.textContent = swapCount;
            recursions.textContent = recursionCount;
            
            setTimeout(playAnimations, animationSpeed);
        }

        // Execute a single animation step
        function executeAnimation(animation) {
            const bars = document.querySelectorAll('.array-element');
            
            // Reset all bars to normal state
            bars.forEach(bar => {
                bar.classList.remove('pivot', 'comparing', 'sorted');
            });
            
            switch (animation.type) {
                case 'partitionStart':
                    explanation.textContent = `Partitioning array from index ${animation.low} to ${animation.high}.`;
                    break;
                    
                case 'highlightPivot':
                    bars[animation.index].classList.add('pivot');
                    explanation.textContent = `Selected element at index ${animation.index} (value: ${array[animation.index]}) as pivot.`;
                    break;
                    
                case 'compare':
                    bars[animation.indices[0]].classList.add('comparing');
                    bars[animation.indices[1]].classList.add('comparing');
                    explanation.textContent = `Comparing elements at indices ${animation.indices[0]} (${array[animation.indices[0]]}) and ${animation.indices[1]} (${array[animation.indices[1]]}).`;
                    break;
                    
                case 'swap':
                    // Swap values in the array
                    [array[animation.indices[0]], array[animation.indices[1]]] = [array[animation.indices[1]], array[animation.indices[0]]];
                    
                    // Update bar heights and values
                    bars[animation.indices[0]].style.height = `${(array[animation.indices[0]] / 100) * arrayContainer.clientHeight}px`;
                    bars[animation.indices[0]].textContent = array[animation.indices[0]];
                    
                    bars[animation.indices[1]].style.height = `${(array[animation.indices[1]] / 100) * arrayContainer.clientHeight}px`;
                    bars