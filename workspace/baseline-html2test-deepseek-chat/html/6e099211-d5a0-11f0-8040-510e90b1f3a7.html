<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Search Tree Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        input, button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        .tree-container {
            display: flex;
            justify-content: center;
            min-height: 400px;
            margin-top: 20px;
        }
        .node {
            width: 40px;
            height: 40px;
            border: 2px solid #333;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px 20px;
            background: white;
            position: relative;
        }
        .node-value {
            font-weight: bold;
        }
        .level {
            display: flex;
            justify-content: center;
            position: relative;
        }
        .line {
            position: absolute;
            background: #333;
            height: 2px;
            transform-origin: 0 0;
        }
        .operations {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .log {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Binary Search Tree Visualization</h1>
        
        <div class="controls">
            <input type="number" id="valueInput" placeholder="Enter a number" min="-999" max="999">
            <button onclick="insertValue()">Insert</button>
            <button onclick="removeValue()">Remove</button>
            <button onclick="searchValue()">Search</button>
            <button onclick="clearTree()">Clear Tree</button>
            <button onclick="generateRandomTree()">Generate Random Tree</button>
        </div>

        <div class="tree-container" id="treeContainer">
            <!-- Tree will be rendered here -->
        </div>

        <div class="operations">
            <h3>Tree Operations</h3>
            <div class="controls">
                <button onclick="traverseInOrder()">In-Order Traversal</button>
                <button onclick="traversePreOrder()">Pre-Order Traversal</button>
                <button onclick="traversePostOrder()">Post-Order Traversal</button>
                <button onclick="findMin()">Find Minimum</button>
                <button onclick="findMax()">Find Maximum</button>
            </div>
        </div>

        <div class="log" id="log">
            <h3>Operation Log</h3>
            <div id="logContent"></div>
        </div>
    </div>

    <script>
        class Node {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
            }
        }

        class BinarySearchTree {
            constructor() {
                this.root = null;
            }

            insert(value) {
                const newNode = new Node(value);
                
                if (this.root === null) {
                    this.root = newNode;
                    return true;
                }

                let current = this.root;
                while (true) {
                    if (value === current.value) {
                        logMessage(`Value ${value} already exists in the tree`);
                        return false;
                    }

                    if (value < current.value) {
                        if (current.left === null) {
                            current.left = newNode;
                            return true;
                        }
                        current = current.left;
                    } else {
                        if (current.right === null) {
                            current.right = newNode;
                            return true;
                        }
                        current = current.right;
                    }
                }
            }

            remove(value) {
                this.root = this._removeNode(this.root, value);
            }

            _removeNode(node, value) {
                if (node === null) {
                    logMessage(`Value ${value} not found in the tree`);
                    return null;
                }

                if (value < node.value) {
                    node.left = this._removeNode(node.left, value);
                    return node;
                } else if (value > node.value) {
                    node.right = this._removeNode(node.right, value);
                    return node;
                } else {
                    // Node to be deleted found
                    if (node.left === null && node.right === null) {
                        return null;
                    }
                    
                    if (node.left === null) {
                        return node.right;
                    } else if (node.right === null) {
                        return node.left;
                    }

                    // Node with two children
                    const minNode = this._findMinNode(node.right);
                    node.value = minNode.value;
                    node.right = this._removeNode(node.right, minNode.value);
                    return node;
                }
            }

            _findMinNode(node) {
                while (node && node.left !== null) {
                    node = node.left;
                }
                return node;
            }

            search(value) {
                let current = this.root;
                let steps = 0;
                
                while (current !== null) {
                    steps++;
                    if (value === current.value) {
                        logMessage(`Value ${value} found in ${steps} steps`);
                        return current;
                    } else if (value < current.value) {
                        current = current.left;
                    } else {
                        current = current.right;
                    }
                }
                
                logMessage(`Value ${value} not found in the tree`);
                return null;
            }

            inOrder(node = this.root, result = []) {
                if (node !== null) {
                    this.inOrder(node.left, result);
                    result.push(node.value);
                    this.inOrder(node.right, result);
                }
                return result;
            }

            preOrder(node = this.root, result = []) {
                if (node !== null) {
                    result.push(node.value);
                    this.preOrder(node.left, result);
                    this.preOrder(node.right, result);
                }
                return result;
            }

            postOrder(node = this.root, result = []) {
                if (node !== null) {
                    this.postOrder(node.left, result);
                    this.postOrder(node.right, result);
                    result.push(node.value);
                }
                return result;
            }

            findMin() {
                if (this.root === null) return null;
                let current = this.root;
                while (current.left !== null) {
                    current = current.left;
                }
                return current.value;
            }

            findMax() {
                if (this.root === null) return null;
                let current = this.root;
                while (current.right !== null) {
                    current = current.right;
                }
                return current.value;
            }

            getHeight(node = this.root) {
                if (node === null) return 0;
                return 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
            }
        }

        const bst = new BinarySearchTree();

        function logMessage(message) {
            const logContent = document.getElementById('logContent');
            const timestamp = new Date().toLocaleTimeString();
            logContent.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            logContent.scrollTop = logContent.scrollHeight;
        }

        function insertValue() {
            const valueInput = document.getElementById('valueInput');
            const value = parseInt(valueInput.value);
            
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }

            if (bst.insert(value)) {
                logMessage(`Inserted value: ${value}`);
                renderTree();
            }
            valueInput.value = '';
            valueInput.focus();
        }

        function removeValue() {
            const valueInput = document.getElementById('valueInput');
            const value = parseInt(valueInput.value);
            
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }

            bst.remove(value);
            logMessage(`Attempted to remove value: ${value}`);
            renderTree();
            valueInput.value = '';
            valueInput.focus();
        }

        function searchValue() {
            const valueInput = document.getElementById('valueInput');
            const value = parseInt(valueInput.value);
            
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }

            bst.search(value);
            valueInput.value = '';
            valueInput.focus();
        }

        function clearTree() {
            bst.root = null;
            logMessage('Tree cleared');
            renderTree();
        }

        function generateRandomTree() {
            bst.root = null;
            const count = 7 + Math.floor(Math.random() * 8); // 7-14 nodes
            const values = new Set();
            
            while (values.size < count) {
                values.add(Math.floor(Math.random() * 100) - 50); // -50 to 49
            }
            
            values.forEach(value => bst.insert(value));
            logMessage(`Generated random tree with ${count} nodes`);
            renderTree();
        }

        function traverseInOrder() {
            const result = bst.inOrder();
            logMessage(`In-Order Traversal: ${result.join(' → ')}`);
        }

        function traversePreOrder() {
            const result = bst.preOrder();
            logMessage(`Pre-Order Traversal: ${result.join(' → ')}`);
        }

        function traversePostOrder() {
            const result = bst.postOrder();
            logMessage(`Post-Order Traversal: ${result.join(' → ')}`);
        }

        function findMin() {
            const min = bst.findMin();
            if (min !== null) {
                logMessage(`Minimum value: ${min}`);
            } else {
                logMessage('Tree is empty');
            }
        }

        function findMax() {
            const max = bst.findMax();
            if (max !== null) {
                logMessage(`Maximum value: ${max}`);
            } else {
                logMessage('Tree is empty');
            }
        }

        function renderTree() {
            const container = document.getElementById('treeContainer');
            container.innerHTML = '';
            
            if (bst.root === null) {
                container.innerHTML = '<p>Tree is empty</p>';
                return;
            }

            const levels = getTreeLevels(bst.root);
            const maxLevel = levels.length - 1;
            
            levels.forEach((level, levelIndex) => {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'level';
                levelDiv.style.marginBottom = '50px';
                
                level.forEach(nodeObj => {
                    if (nodeObj.node) {
                        const nodeDiv = document.createElement('div');
                        nodeDiv.className = 'node';
                        nodeDiv.innerHTML = `<span class="node-value">${nodeObj.node.value}</span>`;
                        nodeDiv.style.position = 'relative';
                        
                        // Add connecting lines
                        if (levelIndex > 0) {
                            const parentPos = findParentPosition(levels, levelIndex, nodeObj.index);
                            if (parentPos !== null) {
                                const line = createLine(nodeObj.position, parentPos, levelIndex);
                                container.appendChild(line);
                            }
                        }
                        
                        levelDiv.appendChild(nodeDiv);
                    } else {
                        // Empty node for spacing
                        const spacer = document.createElement('div');
                        spacer.className = 'node';
                        spacer.style.visibility = 'hidden';
                        levelDiv.appendChild(spacer);
                    }
                });
                
                container.appendChild(levelDiv);
            });
        }

        function getTreeLevels(node) {
            const levels = [];
            const queue = [{ node, level: 0, index: 0 }];
            
            while (queue.length > 0) {
                const { node, level, index } = queue.shift();
                
                if (!levels[level]) levels[level] = [];
                levels[level][index] = { node, index, position: index };
                
                if (node) {
                    const leftIndex = index * 2;
                    const rightIndex = index * 2 + 1;
                    
                    queue.push({ node: node.left, level: level + 1, index: leftIndex });
                    queue.push({ node: node.right, level: level + 1, index: rightIndex });
                }
            }
            
            return levels;
        }

        function findParentPosition(levels, currentLevel, currentIndex) {
            if (currentLevel === 0) return null;
            
            const parentIndex = Math.floor(currentIndex / 2);
            const parentLevel = levels[currentLevel - 1];
            
            if (parentLevel && parentLevel[parentIndex] && parentLevel[parentIndex].node) {
                return parentLevel[parentIndex].position;
            }
            
            return null;
        }

        function createLine(childPos, parentPos, level) {
            const line = document.createElement('div');
            line.className = 'line';
            
            const levelHeight = 80;
            const nodeSpacing = 80;
            
            const startX = parentPos * nodeSpacing + 20;
            const startY = (level - 1) * levelHeight + 40;
            const endX = childPos * nodeSpacing + 20;
            const endY = level * levelHeight + 20;
            
            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
            
            line.style.width = length + 'px';
            line.style.left = startX + 'px';
            line.style.top = startY + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            
            return line;
        }

        // Initialize with some values
        bst.insert(50);
        bst.insert(30);
        bst.insert(70);
        bst.insert(20);
        bst.insert(40);
        bst.insert(60);
        bst.insert(80);
        renderTree();
        logMessage('Demo tree created with values: 50, 30, 70, 20, 40, 60, 80');

        // Add keyboard support
        document.getElementById('valueInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                insertValue();
            }
        });
    </script>
</body>
</html>