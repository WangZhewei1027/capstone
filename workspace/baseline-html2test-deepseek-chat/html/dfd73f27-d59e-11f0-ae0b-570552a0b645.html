<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Union-Find (Disjoint Set) Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
        }
        
        .container {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .explanation {
            flex: 1;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .visualization {
            flex: 1;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .operations {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        input[type="number"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 60px;
        }
        
        #sets-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }
        
        .set {
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 10px;
            min-width: 150px;
        }
        
        .set-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #2c3e50;
        }
        
        .element {
            display: inline-block;
            width: 35px;
            height: 35px;
            line-height: 35px;
            text-align: center;
            background-color: #ecf0f1;
            margin: 3px;
            border-radius: 50%;
            border: 2px solid #bdc3c7;
            transition: all 0.3s;
        }
        
        .leader {
            background-color: #3498db;
            color: white;
            border-color: #2980b9;
        }
        
        .selected {
            border-color: #e74c3c;
            box-shadow: 0 0 5px #e74c3c;
        }
        
        .parent-arrow {
            display: inline-block;
            margin: 0 5px;
            color: #7f8c8d;
        }
        
        .complexity {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            gap: 10px;
        }
        
        .complexity-card {
            flex: 1;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }
        
        .complexity-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #2c3e50;
        }
        
        .animation-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }
        
        .log {
            background-color: #ecf0f1;
            padding: 10px;
            border-radius: 4px;
            height: 100px;
            overflow-y: auto;
            margin-top: 20px;
            font-family: monospace;
            font-size: 14px;
        }
        
        .log-entry {
            margin: 3px 0;
            padding: 2px 5px;
        }
        
        .success {
            background-color: #d4edda;
            color: #155724;
        }
        
        .info {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        
        .algorithm-step {
            margin: 10px 0;
            padding: 8px;
            border-left: 3px solid #3498db;
            background-color: #f8f9fa;
        }
        
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <h1>Union-Find (Disjoint Set) Visualization</h1>
    <p class="subtitle">Interactive demonstration of the Union-Find data structure with path compression and union by rank</p>
    
    <div class="complexity">
        <div class="complexity-card">
            <div class="complexity-title">Time Complexity</div>
            <div>Find: O(α(n))</div>
            <div>Union: O(α(n))</div>
        </div>
        <div class="complexity-card">
            <div class="complexity-title">Space Complexity</div>
            <div>O(n)</div>
        </div>
        <div class="complexity-card">
            <div class="complexity-title">α(n)</div>
            <div>Inverse Ackermann function</div>
        </div>
    </div>
    
    <div class="container">
        <div class="explanation">
            <h2>About Union-Find</h2>
            <p>The Union-Find data structure, also known as Disjoint Set Union (DSU), is used to manage a collection of disjoint sets. It supports two main operations:</p>
            <ul>
                <li><strong>Find(x):</strong> Determine which set an element belongs to</li>
                <li><strong>Union(x, y):</strong> Merge two sets together</li>
            </ul>
            <p>This visualization demonstrates the algorithm with path compression and union by rank optimizations, achieving near-constant time complexity per operation.</p>
            
            <h3>Algorithm Steps:</h3>
            <div class="algorithm-step">
                <strong>Initialization:</strong> Each element starts as its own set with parent pointing to itself and rank 0.
            </div>
            <div class="algorithm-step">
                <strong>Find (with path compression):</strong> Find the root of the set while flattening the tree for future operations.<br>
                <code>while parent[x] != x: parent[x] = parent[parent[x]]; x = parent[x]</code>
            </div>
            <div class="algorithm-step">
                <strong>Union (by rank):</strong> Attach the root with smaller rank to the root with larger rank to keep trees balanced.<br>
                <code>rootX = Find(x); rootY = Find(y); if rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX</code>
            </div>
            
            <div class="animation-controls">
                <button id="speed-slow">Slow</button>
                <button id="speed-medium">Medium</button>
                <button id="speed-fast">Fast</button>
            </div>
        </div>
        
        <div class="visualization">
            <h2>Interactive Visualization</h2>
            
            <div class="operations">
                <div>
                    <label for="num-elements">Elements: </label>
                    <input type="number" id="num-elements" min="1" max="20" value="10">
                    <button id="init-btn">Initialize</button>
                </div>
                <div>
                    <label for="element1">Element 1: </label>
                    <input type="number" id="element1" min="0" value="0">
                    <label for="element2">Element 2: </label>
                    <input type="number" id="element2" min="0" value="1">
                    <button id="union-btn">Union</button>
                </div>
                <div>
                    <label for="find-element">Find: </label>
                    <input type="number" id="find-element" min="0" value="0">
                    <button id="find-btn">Find</button>
                </div>
                <button id="reset-btn">Reset</button>
            </div>
            
            <div id="sets-container"></div>
            
            <h3>Operation Log</h3>
            <div id="log" class="log"></div>
        </div>
    </div>

    <script>
        class UnionFind {
            constructor(size) {
                this.parent = new Array(size);
                this.rank = new Array(size);
                this.size = size;
                
                // Initialize each element as its own set
                for (let i = 0; i < size; i++) {
                    this.parent[i] = i;
                    this.rank[i] = 0;
                }
            }
            
            // Find with path compression
            find(x) {
                if (this.parent[x] !== x) {
                    // Path compression: make x point directly to the root
                    this.parent[x] = this.find(this.parent[x]);
                }
                return this.parent[x];
            }
            
            // Union by rank
            union(x, y) {
                const rootX = this.find(x);
                const rootY = this.find(y);
                
                if (rootX === rootY) {
                    return false; // Already in the same set
                }
                
                // Union by rank: attach smaller tree to larger tree
                if (this.rank[rootX] < this.rank[rootY]) {
                    this.parent[rootX] = rootY;
                } else if (this.rank[rootX] > this.rank[rootY]) {
                    this.parent[rootY] = rootX;
                } else {
                    // If ranks are equal, make one root and increment its rank
                    this.parent[rootY] = rootX;
                    this.rank[rootX]++;
                }
                
                return true;
            }
        }

        // Visualization logic
        let uf;
        let animationSpeed = 800; // milliseconds
        let selectedElements = [];
        
        // DOM elements
        const numElementsInput = document.getElementById('num-elements');
        const element1Input = document.getElementById('element1');
        const element2Input = document.getElementById('element2');
        const findElementInput = document.getElementById('find-element');
        const initBtn = document.getElementById('init-btn');
        const unionBtn = document.getElementById('union-btn');
        const findBtn = document.getElementById('find-btn');
        const resetBtn = document.getElementById('reset-btn');
        const setsContainer = document.getElementById('sets-container');
        const logElement = document.getElementById('log');
        const speedSlowBtn = document.getElementById('speed-slow');
        const speedMediumBtn = document.getElementById('speed-medium');
        const speedFastBtn = document.getElementById('speed-fast');
        
        // Initialize the visualization
        function init() {
            const size = parseInt(numElementsInput.value);
            if (size < 1 || size > 20) {
                alert('Please enter a number between 1 and 20');
                return;
            }
            
            uf = new UnionFind(size);
            selectedElements = [];
            updateVisualization();
            addLog(`Initialized Union-Find with ${size} elements`, 'info');
        }
        
        // Perform union operation
        function performUnion() {
            if (!uf) {
                alert('Please initialize first');
                return;
            }
            
            const x = parseInt(element1Input.value);
            const y = parseInt(element2Input.value);
            
            if (isNaN(x) || isNaN(y) || x < 0 || y < 0 || x >= uf.size || y >= uf.size) {
                alert(`Please enter valid element numbers between 0 and ${uf.size - 1}`);
                return;
            }
            
            if (x === y) {
                alert('Elements must be different for union operation');
                return;
            }
            
            selectedElements = [x, y];
            updateVisualization();
            
            setTimeout(() => {
                const result = uf.union(x, y);
                if (result) {
                    addLog(`Union(${x}, ${y}): Elements ${x} and ${y} are now in the same set`, 'success');
                } else {
                    addLog(`Union(${x}, ${y}): Elements ${x} and ${y} are already in the same set`, 'info');
                }
                selectedElements = [];
                updateVisualization();
            }, animationSpeed);
        }
        
        // Perform find operation
        function performFind() {
            if (!uf) {
                alert('Please initialize first');
                return;
            }
            
            const x = parseInt(findElementInput.value);
            
            if (isNaN(x) || x < 0 || x >= uf.size) {
                alert(`Please enter a valid element number between 0 and ${uf.size - 1}`);
                return;
            }
            
            selectedElements = [x];
            updateVisualization();
            
            setTimeout(() => {
                const root = uf.find(x);
                addLog(`Find(${x}): Element ${x} belongs to set with root ${root}`, 'success');
                
                // Highlight the path to the root
                let current = x;
                const path = [x];
                
                while (current !== uf.parent[current]) {
                    current = uf.parent[current];
                    path.push(current);
                }
                
                selectedElements = path;
                updateVisualization();
                
                setTimeout(() => {
                    selectedElements = [];
                    updateVisualization();
                }, animationSpeed * 2);
            }, animationSpeed);
        }
        
        // Reset the visualization
        function reset() {
            if (uf) {
                init();
            }
        }
        
        // Update the visualization
        function updateVisualization() {
            if (!uf) return;
            
            setsContainer.innerHTML = '';
            
            // Group elements by their root
            const sets = new Map();
            
            for (let i = 0; i < uf.size; i++) {
                const root = uf.find(i);
                if (!sets.has(root)) {
                    sets.set(root, []);
                }
                sets.get(root).push(i);
            }
            
            // Create visual representation for each set
            sets.forEach((elements, root) => {
                const setElement = document.createElement('div');
                setElement.className = 'set';
                
                const title = document.createElement('div');
                title.className = 'set-title';
                title.textContent = `Set with root ${root}`;
                setElement.appendChild(title);
                
                elements.forEach(element => {
                    const elementDiv = document.createElement('div');
                    elementDiv.className = 'element';
                    elementDiv.textContent = element;
                    
                    if (element === root) {
                        elementDiv.classList.add('leader');
                    }
                    
                    if (selectedElements.includes(element)) {
                        elementDiv.classList.add('selected');
                    }
                    
                    // Show parent relationship if not root
                    if (element !== root) {
                        const arrow = document.createElement('span');
                        arrow.className = 'parent-arrow';
                        arrow.textContent = '→';
                        setElement.appendChild(arrow);
                    }
                    
                    setElement.appendChild(elementDiv);
                });
                
                setsContainer.appendChild(setElement);
            });
        }
        
        // Add log entry
        function addLog(message, type) {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = message;
            logElement.appendChild(logEntry);
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        // Set animation speed
        function setAnimationSpeed(speed) {
            animationSpeed = speed;
            
            // Update button states
            speedSlowBtn.disabled = speed === 1200;
            speedMediumBtn.disabled = speed === 800;
            speedFastBtn.disabled = speed === 400;
        }
        
        // Event listeners
        initBtn.addEventListener('click', init);
        unionBtn.addEventListener('click', performUnion);
        findBtn.addEventListener('click', performFind);
        resetBtn.addEventListener('click', reset);
        
        speedSlowBtn.addEventListener('click', () => setAnimationSpeed(1200));
        speedMediumBtn.addEventListener('click', () => setAnimationSpeed(800));
        speedFastBtn.addEventListener('click', () => setAnimationSpeed(400));
        
        // Initialize on load
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>