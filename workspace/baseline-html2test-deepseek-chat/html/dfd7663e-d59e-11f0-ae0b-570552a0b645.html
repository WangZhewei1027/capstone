<!DOCTYPE html>
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bellman-Ford Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .graph-section, .algorithm-section {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        canvas {
            border: 1px solid #ddd;
            background-color: #fff;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .step-info {
            background-color: #e8f4fd;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            min-height: 60px;
        }
        
        .distance-table {
            margin-top: 20px;
            width: 100%;
            border-collapse: collapse;
        }
        
        .distance-table th, .distance-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        .distance-table th {
            background-color: #f2f2f2;
        }
        
        .node {
            fill: #4CAF50;
            stroke: #333;
            stroke-width: 2;
        }
        
        .edge {
            stroke: #666;
            stroke-width: 2;
            fill: none;
        }
        
        .edge-weight {
            font-size: 14px;
            font-weight: bold;
            fill: #333;
        }
        
        .current-edge {
            stroke: #ff0000;
            stroke-width: 3;
        }
        
        .updated-node {
            fill: #ff9800;
        }
        
        .negative-cycle {
            color: #f44336;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Bellman-Ford Algorithm Visualization</h1>
    
    <div class="controls">
        <button id="stepBtn">Next Step</button>
        <button id="runBtn">Run Algorithm</button>
        <button id="resetBtn">Reset</button>
        <button id="randomGraphBtn">Generate Random Graph</button>
        <select id="graphSelect">
            <option value="simple">Simple Graph</option>
            <option value="negative">Graph with Negative Edge</option>
            <option value="cycle">Graph with Negative Cycle</option>
        </select>
    </div>
    
    <div class="container">
        <div class="graph-section">
            <h2>Graph Visualization</h2>
            <canvas id="graphCanvas" width="500" height="400"></canvas>
        </div>
        
        <div class="algorithm-section">
            <h2>Algorithm Execution</h2>
            <div class="step-info" id="stepInfo">
                Click "Next Step" to start the algorithm execution.
            </div>
            
            <h3>Distance Table</h3>
            <table class="distance-table" id="distanceTable">
                <thead>
                    <tr>
                        <th>Vertex</th>
                        <th>Distance</th>
                        <th>Previous</th>
                    </tr>
                </thead>
                <tbody id="distanceTableBody">
                </tbody>
            </table>
            
            <h3>Algorithm Steps</h3>
            <div id="algorithmSteps"></div>
        </div>
    </div>

    <script>
        class BellmanFord {
            constructor() {
                this.graph = {
                    nodes: [],
                    edges: []
                };
                this.distances = {};
                this.previous = {};
                this.step = 0;
                this.maxSteps = 0;
                this.sourceNode = 0;
                this.isRunning = false;
                this.animationSpeed = 1000;
                this.animationInterval = null;
                this.canvas = document.getElementById('graphCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.initializeEventListeners();
                this.generateGraph('simple');
                this.drawGraph();
                this.updateDistanceTable();
            }
            
            initializeEventListeners() {
                document.getElementById('stepBtn').addEventListener('click', () => this.nextStep());
                document.getElementById('runBtn').addEventListener('click', () => this.toggleRun());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                document.getElementById('randomGraphBtn').addEventListener('click', () => this.generateRandomGraph());
                document.getElementById('graphSelect').addEventListener('change', (e) => {
                    this.generateGraph(e.target.value);
                    this.drawGraph();
                    this.updateDistanceTable();
                });
            }
            
            generateGraph(type) {
                this.graph = { nodes: [], edges: [] };
                
                // Create 5 nodes positioned in a circle
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = 150;
                
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 2 * Math.PI) / 5;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    this.graph.nodes.push({ id: i, x: x, y: y });
                }
                
                switch(type) {
                    case 'simple':
                        this.graph.edges = [
                            { from: 0, to: 1, weight: 6 },
                            { from: 0, to: 3, weight: 7 },
                            { from: 1, to: 2, weight: 5 },
                            { from: 1, to: 3, weight: 8 },
                            { from: 1, to: 4, weight: -4 },
                            { from: 2, to: 1, weight: -2 },
                            { from: 3, to: 2, weight: -3 },
                            { from: 3, to: 4, weight: 9 },
                            { from: 4, to: 0, weight: 2 },
                            { from: 4, to: 2, weight: 7 }
                        ];
                        break;
                        
                    case 'negative':
                        this.graph.edges = [
                            { from: 0, to: 1, weight: 6 },
                            { from: 0, to: 3, weight: 7 },
                            { from: 1, to: 2, weight: 5 },
                            { from: 1, to: 3, weight: 8 },
                            { from: 1, to: 4, weight: -4 },
                            { from: 2, to: 1, weight: -2 },
                            { from: 3, to: 2, weight: -3 },
                            { from: 3, to: 4, weight: 9 },
                            { from: 4, to: 0, weight: 2 },
                            { from: 4, to: 2, weight: 7 }
                        ];
                        break;
                        
                    case 'cycle':
                        this.graph.edges = [
                            { from: 0, to: 1, weight: 6 },
                            { from: 1, to: 2, weight: 5 },
                            { from: 2, to: 3, weight: -2 },
                            { from: 3, to: 4, weight: -3 },
                            { from: 4, to: 1, weight: -8 }  // This creates a negative cycle
                        ];
                        break;
                }
                
                this.reset();
            }
            
            generateRandomGraph() {
                this.graph = { nodes: [], edges: [] };
                
                const numNodes = 6;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = 150;
                
                for (let i = 0; i < numNodes; i++) {
                    const angle = (i * 2 * Math.PI) / numNodes;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    this.graph.nodes.push({ id: i, x: x, y: y });
                }
                
                // Generate random edges
                for (let i = 0; i < numNodes; i++) {
                    for (let j = 0; j < numNodes; j++) {
                        if (i !== j && Math.random() > 0.6) {
                            const weight = Math.floor(Math.random() * 20) - 5; // Random weight between -5 and 15
                            this.graph.edges.push({ from: i, to: j, weight: weight });
                        }
                    }
                }
                
                this.reset();
                this.drawGraph();
                this.updateDistanceTable();
            }
            
            reset() {
                this.step = 0;
                this.isRunning = false;
                
                // Initialize distances
                this.distances = {};
                this.previous = {};
                
                for (let node of this.graph.nodes) {
                    this.distances[node.id] = node.id === this.sourceNode ? 0 : Infinity;
                    this.previous[node.id] = null;
                }
                
                this.maxSteps = this.graph.nodes.length - 1;
                
                document.getElementById('stepInfo').innerHTML = 
                    'Algorithm reset. Ready to start from source node ' + this.sourceNode + '.';
                document.getElementById('algorithmSteps').innerHTML = '';
                
                if (this.animationInterval) {
                    clearInterval(this.animationInterval);
                    this.animationInterval = null;
                }
                
                document.getElementById('runBtn').textContent = 'Run Algorithm';
                this.drawGraph();
                this.updateDistanceTable();
            }
            
            nextStep() {
                if (this.step === 0) {
                    document.getElementById('algorithmSteps').innerHTML = 
                        '<p>Step 1: Initialize distances. Source node distance set to 0, others to Infinity.</p>';
                    this.step++;
                    this.updateStepInfo('Initialization complete.');
                    return;
                }
                
                if (this.step > this.maxSteps) {
                    // Check for negative cycles
                    let hasNegativeCycle = false;
                    let cycleInfo = '';
                    
                    for (let edge of this.graph.edges) {
                        if (this.distances[edge.from] + edge.weight < this.distances[edge.to]) {
                            hasNegativeCycle = true;
                            cycleInfo = `Negative cycle detected! Edge (${edge.from} → ${edge.to}) with weight ${edge.weight} would reduce distance.`;
                            break;
                        }
                    }
                    
                    if (hasNegativeCycle) {
                        document.getElementById('stepInfo').innerHTML = 
                            '<span class="negative-cycle">' + cycleInfo + '</span>';
                        document.getElementById('algorithmSteps').innerHTML += 
                            '<p class="negative-cycle">' + cycleInfo + '</p>';
                    } else {
                        document.getElementById('stepInfo').innerHTML = 
                            'Algorithm completed successfully. No negative cycles detected.';
                        document.getElementById('algorithmSteps').innerHTML += 
                            '<p>Final step: No negative cycles detected. Algorithm complete.</p>';
                    }
                    
                    this.step++;
                    return;
                }
                
                let updated = false;
                let stepInfo = `Relaxation round ${this.step}: `;
                let stepDetails = '';
                
                for (let i = 0; i < this.graph.edges.length; i++) {
                    const edge = this.graph.edges[i];
                    const u = edge.from;
                    const v = edge.to;
                    const w = edge.weight;
                    
                    if (this.distances[u] !== Infinity && this.distances[u] + w < this.distances[v]) {
                        this.distances[v] = this.distances[u] + w;
                        this.previous[v] = u;
                        updated = true;
                        
                        stepDetails += `Relaxing edge (${u} → ${v}): distance[${v}] = min(∞, ${this.distances[u]} + ${w} = ${this.distances[u] + w})<br>`;
                    }
                }
                
                if (updated) {
                    stepInfo += 'Some distances were updated.';
                } else {
                    stepInfo += 'No distances were updated.';
                }
                
                this.updateStepInfo(stepInfo, stepDetails);
                document.getElementById('algorithmSteps').innerHTML += 
                    `<p><strong>Step ${this.step + 1}:</strong> ${stepInfo}<br>${stepDetails}</p>`;
                
                this.step++;
                this.drawGraph(this.step - 1);
                this.updateDistanceTable();
            }
            
            updateStepInfo(info, details = '') {
                document.getElementById('stepInfo').innerHTML = 
                    `<strong>Step ${this.step}:</strong> ${info}<br>${details}`;
            }
            
            toggleRun() {
                if (this.isRunning) {
                    this.isRunning = false;
                    document.getElementById('runBtn').textContent = 'Run Algorithm';
                    
                    if (this.animationInterval) {
                        clearInterval(this.animationInterval);
                        this.animationInterval = null;
                    }
                } else {
                    this.isRunning = true;
                    document.getElementById('runBtn').textContent = 'Pause';
                    
                    this.animationInterval = setInterval(() => {
                        if (this.step > this.maxSteps + 1) {
                            this.toggleRun();
                            return;
                        }
                        
                        this.nextStep();
                    }, this.animationSpeed);
                }
            }
            
            drawGraph(highlightEdgeIndex = -1) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw edges
                for (let i = 0; i < this.graph.edges.length; i++) {
                    const edge = this.graph.edges[i];
                    const fromNode = this.graph.nodes[edge.from];
                    const toNode = this.graph.nodes[edge.to];
                    
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = i === highlightEdgeIndex ? '#ff0000' : '#666';
                    this.ctx.lineWidth = i === highlightEdgeIndex ? 3 : 2;
                    
                    // Draw arrow
                    const headlen = 10;
                    const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
                    
                    this.ctx.moveTo(fromNode.x, fromNode.y);
                    this.ctx.lineTo(toNode.x, toNode.y);
                    this.ctx.stroke();
                    
                    // Arrowhead
                    this.ctx.beginPath();
                    this.ctx.moveTo(toNode.x, toNode.y);
                    this.ctx.lineTo(
                        toNode.x - headlen * Math.cos(angle - Math.PI/6),
                        toNode.y - headlen * Math.sin(angle - Math.PI/6)
                    );
                    this.ctx.lineTo(
                        toNode.x - headlen * Math.cos(angle + Math.PI/6),
                        toNode.y - headlen * Math.sin(angle + Math.PI/6)
                    );
                    this.ctx.closePath();
                    this.ctx.fillStyle = i === highlightEdgeIndex ? '#ff0000' : '#666';
                    this.ctx.fill();
                    
                    // Edge weight
                    const midX = (fromNode.x + toNode.x) / 2;
                    const midY = (fromNode.y + toNode.y) / 2;
                    
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = '14px Arial';
                    this.ctx.fillText(edge.weight, midX + 5, midY + 5);
                }
                
                // Draw nodes
                for (let node of this.graph.nodes) {
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
                    this.ctx.fillStyle = node.id === this.sourceNode ? '#4CAF50' : 
                                        (this.distances[node.id] !== Infinity ? '#ff9800' : '#4CAF50');
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#333';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    // Node label
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(node.id, node.x, node.y);
                    
                    // Distance label
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = '12px Arial';
                    this.ctx.fillText(
                        this.distances[node.id] === Infinity ? '∞' : this.distances[node.id], 
                        node.x, 
                        node.y + 30
                    );
                }
            }
            
            updateDistanceTable() {
                const tableBody = document.getElementById('distanceTableBody');
                tableBody.innerHTML = '';
                
                for (let node of this.graph.nodes) {
                    const row = document.createElement('tr');
                    
                    const cellNode = document.createElement('td');
                    cellNode.textContent = node.id;
                    row.appendChild(cellNode);
                    
                    const cellDistance = document.createElement('td');
                    cellDistance.textContent = this.distances[node.id] === Infinity ? '∞' : this.distances[node.id];
                    row.appendChild(cellDistance);
                    
                    const cellPrevious = document.createElement('td');
                    cellPrevious.textContent = this.previous[node.id] === null ? '-' : this.previous[node.id];
                    row.appendChild(cellPrevious);
                    
                    tableBody.appendChild(row);
                }
            }
        }
        
