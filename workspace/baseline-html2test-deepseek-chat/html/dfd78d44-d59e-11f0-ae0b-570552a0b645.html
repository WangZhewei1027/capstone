<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huffman Coding Demonstration</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        header {
            background: #4a6fa5;
            color: white;
            padding: 25px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }
        
        .description {
            font-size: 1.1rem;
            opacity: 0.9;
            max-width: 700px;
            margin: 0 auto;
        }
        
        .content {
            padding: 30px;
        }
        
        .input-section, .results-section {
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 10px;
            background: #f9f9f9;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        h2 {
            color: #4a6fa5;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eaeaea;
        }
        
        textarea {
            width: 100%;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            resize: vertical;
            min-height: 100px;
            font-family: 'Courier New', monospace;
            transition: border-color 0.3s;
        }
        
        textarea:focus {
            outline: none;
            border-color: #4a6fa5;
        }
        
        button {
            background: #4a6fa5;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background 0.3s, transform 0.2s;
            margin-top: 15px;
        }
        
        button:hover {
            background: #3a5a80;
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .results {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        @media (max-width: 768px) {
            .results {
                grid-template-columns: 1fr;
            }
        }
        
        .result-box {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
        }
        
        .tree-visualization {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
            overflow-x: auto;
        }
        
        .frequency-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        .frequency-table th, .frequency-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .frequency-table th {
            background: #f0f0f0;
        }
        
        .huffman-code {
            font-family: 'Courier New', monospace;
            background: #f8f8f8;
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
            margin: 2px;
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            text-align: center;
        }
        
        .stat-box {
            padding: 15px;
            border-radius: 8px;
            background: white;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
            flex: 1;
            margin: 0 10px;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #4a6fa5;
        }
        
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Courier New', monospace;
            background: #f8f8f8;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 5px;
        }
        
        .tree-node {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 5px;
            margin: 5px;
            font-size: 0.9rem;
            text-align: center;
        }
        
        .tree-connector {
            height: 20px;
            width: 2px;
            background: #ccc;
            margin: 0 auto;
        }
        
        .tree-level {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Huffman Coding Algorithm</h1>
            <p class="description">Huffman coding is a lossless data compression algorithm that assigns variable-length codes to characters based on their frequencies. More frequent characters get shorter codes, resulting in efficient compression.</p>
        </header>
        
        <div class="content">
            <section class="input-section">
                <h2>Input Text</h2>
                <p>Enter the text you want to compress using Huffman coding:</p>
                <textarea id="inputText" placeholder="Type your text here...">Hello, World! This is a demonstration of Huffman coding.</textarea>
                <button id="encodeBtn">Encode with Huffman Coding</button>
            </section>
            
            <section class="results-section">
                <h2>Results</h2>
                
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">Original Size</div>
                        <div class="stat-value" id="originalSize">0 bits</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Encoded Size</div>
                        <div class="stat-value" id="encodedSize">0 bits</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Compression Ratio</div>
                        <div class="stat-value" id="compressionRatio">0%</div>
                    </div>
                </div>
                
                <div class="results">
                    <div class="result-box">
                        <h3>Character Frequencies</h3>
                        <table class="frequency-table" id="frequencyTable">
                            <thead>
                                <tr>
                                    <th>Character</th>
                                    <th>Frequency</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    
                    <div class="result-box">
                        <h3>Huffman Codes</h3>
                        <div id="huffmanCodes"></div>
                    </div>
                </div>
                
                <div class="result-box">
                    <h3>Encoded Text</h3>
                    <pre id="encodedOutput"></pre>
                </div>
                
                <div class="result-box">
                    <h3>Decoded Text</h3>
                    <pre id="decodedOutput"></pre>
                </div>
                
                <div class="tree-visualization">
                    <h3>Huffman Tree Visualization</h3>
                    <div id="treeContainer"></div>
                </div>
            </section>
        </div>
    </div>

    <script>
        // Huffman Node class
        class HuffmanNode {
            constructor(char, frequency) {
                this.char = char;
                this.frequency = frequency;
                this.left = null;
                this.right = null;
            }
        }

        // Main Huffman Coding class
        class HuffmanCoding {
            constructor() {
                this.codes = {};
                this.reverseMapping = {};
            }

            // Build frequency map from input string
            buildFrequencyMap(str) {
                const frequencyMap = {};
                for (let char of str) {
                    frequencyMap[char] = (frequencyMap[char] || 0) + 1;
                }
                return frequencyMap;
            }

            // Build Huffman tree from frequency map
            buildHuffmanTree(frequencyMap) {
                const priorityQueue = [];
                
                // Create a leaf node for each character and add to priority queue
                for (let char in frequencyMap) {
                    priorityQueue.push(new HuffmanNode(char, frequencyMap[char]));
                }
                
                // Sort by frequency (ascending)
                priorityQueue.sort((a, b) => a.frequency - b.frequency);
                
                // Build the tree by combining the two nodes with the lowest frequency
                while (priorityQueue.length > 1) {
                    // Remove the two nodes with the lowest frequency
                    const left = priorityQueue.shift();
                    const right = priorityQueue.shift();
                    
                    // Create a new internal node with these two nodes as children
                    const newNode = new HuffmanNode(null, left.frequency + right.frequency);
                    newNode.left = left;
                    newNode.right = right;
                    
                    // Insert the new node back into the priority queue
                    priorityQueue.push(newNode);
                    
                    // Re-sort the queue
                    priorityQueue.sort((a, b) => a.frequency - b.frequency);
                }
                
                // The remaining node is the root of the Huffman tree
                return priorityQueue[0];
            }

            // Generate Huffman codes by traversing the tree
            generateCodes(node, currentCode = "") {
                if (node === null) return;
                
                // If it's a leaf node (contains a character)
                if (node.char !== null) {
                    this.codes[node.char] = currentCode;
                    this.reverseMapping[currentCode] = node.char;
                    return;
                }
                
                // Traverse left (add '0' to code)
                this.generateCodes(node.left, currentCode + "0");
                
                // Traverse right (add '1' to code)
                this.generateCodes(node.right, currentCode + "1");
            }

            // Encode the input text
            encode(str) {
                if (str === "") return "";
                
                const frequencyMap = this.buildFrequencyMap(str);
                const root = this.buildHuffmanTree(frequencyMap);
                this.codes = {};
                this.reverseMapping = {};
                this.generateCodes(root);
                
                let encodedText = "";
                for (let char of str) {
                    encodedText += this.codes[char];
                }
                
                return encodedText;
            }

            // Decode the encoded text
            decode(encodedText) {
                let currentCode = "";
                let decodedText = "";
                
                for (let bit of encodedText) {
                    currentCode += bit;
                    if (this.reverseMapping[currentCode]) {
                        decodedText += this.reverseMapping[currentCode];
                        currentCode = "";
                    }
                }
                
                return decodedText;
            }

            // Get the Huffman codes mapping
            getCodes() {
                return this.codes;
            }

            // Get the reverse mapping (codes to characters)
            getReverseMapping() {
                return this.reverseMapping;
            }
        }

        // DOM elements
        const inputText = document.getElementById('inputText');
        const encodeBtn = document.getElementById('encodeBtn');
        const frequencyTable = document.getElementById('frequencyTable').querySelector('tbody');
        const huffmanCodes = document.getElementById('huffmanCodes');
        const encodedOutput = document.getElementById('encodedOutput');
        const decodedOutput = document.getElementById('decodedOutput');
        const originalSize = document.getElementById('originalSize');
        const encodedSize = document.getElementById('encodedSize');
        const compressionRatio = document.getElementById('compressionRatio');
        const treeContainer = document.getElementById('treeContainer');

        // Initialize the Huffman coding instance
        const huffman = new HuffmanCoding();

        // Function to update the UI with results
        function updateUI() {
            const text = inputText.value;
            
            if (text === "") {
                alert("Please enter some text to encode.");
                return;
            }
            
            // Encode the text
            const encodedText = huffman.encode(text);
            
            // Update frequency table
            const frequencyMap = huffman.buildFrequencyMap(text);
            frequencyTable.innerHTML = '';
            for (let char in frequencyMap) {
                const row = document.createElement('tr');
                
                const charCell = document.createElement('td');
                charCell.textContent = char === ' ' ? 'Space' : char;
                row.appendChild(charCell);
                
                const freqCell = document.createElement('td');
                freqCell.textContent = frequencyMap[char];
                row.appendChild(freqCell);
                
                frequencyTable.appendChild(row);
            }
            
            // Update Huffman codes
            const codes = huffman.getCodes();
            huffmanCodes.innerHTML = '';
            for (let char in codes) {
                const codeElement = document.createElement('div');
                codeElement.innerHTML = `<strong>${char === ' ' ? 'Space' : char}:</strong> <span class="huffman-code">${codes[char]}</span>`;
                huffmanCodes.appendChild(codeElement);
            }
            
            // Update encoded and decoded text
            encodedOutput.textContent = encodedText;
            decodedOutput.textContent = huffman.decode(encodedText);
            
            // Update statistics
            const originalBits = text.length * 8; // Assuming 8 bits per character
            const encodedBits = encodedText.length;
            const ratio = ((originalBits - encodedBits) / originalBits * 100).toFixed(2);
            
            originalSize.textContent = `${originalBits} bits`;
            encodedSize.textContent = `${encodedBits} bits`;
            compressionRatio.textContent = `${ratio}%`;
            
            // Generate tree visualization
            generateTreeVisualization(text);
        }

        // Function to generate a simple tree visualization
        function generateTreeVisualization(text) {
            if (text === "") return;
            
            const frequencyMap = huffman.buildFrequencyMap(text);
            const root = huffman.buildHuffmanTree(frequencyMap);
            
            treeContainer.innerHTML = '';
            
            // Create a simple text-based tree representation
            let treeHTML = '<div class="tree-structure">';
            
            // Function to recursively build the tree visualization
            function buildTreeHTML(node, level = 0) {
                if (!node) return '';
                
                let html = '';
                const indent = '&nbsp;'.repeat(level * 4);
                
                if (node.char !== null) {
                    // Leaf node with character
                    html += `${indent}<div class="tree-node" style="background-color: #4a6fa5; color: white;">'${node.char === ' ' ? 'Space' : node.char}':${node.frequency}</div>`;
                } else {
                    // Internal node
                    html += `${indent}<div class="tree-node" style="background-color: #f0f0f0;">${node.frequency}</div>`;
                }
                
                if (node.left || node.right) {
                    html += `${indent}<div class="tree-connector"></div>`;
                    html += '<div class="tree-level">';
                    if (node.left) html += buildTreeHTML(node.left, level + 1);
                    if (node.right) html += buildTreeHTML(node.right, level + 1);
                    html += '</div>';
                }
                
                return html;
            }
            
            treeHTML += buildTreeHTML(root);
            treeHTML += '</div>';
            treeContainer.innerHTML = treeHTML;
        }

        // Event listener for the encode button
        encodeBtn.addEventListener('click', updateUI);

        // Initialize with example text
        window.addEventListener('DOMContentLoaded', updateUI);
    </script>
</body>
</html>