<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Visualization - Directed vs Undirected</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #45a049;
        }
        .graph-container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
        }
        .graph {
            background-color: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        canvas {
            border: 1px solid #ccc;
        }
        .info {
            margin: 20px 0;
            padding: 15px;
            background-color: #e7f3ff;
            border-left: 4px solid #2196F3;
            border-radius: 4px;
        }
        .node-info {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Graph Visualization: Directed vs Undirected Graphs</h1>
        
        <div class="info">
            <h3>About Graphs:</h3>
            <p><strong>Undirected Graph:</strong> Edges have no direction - connections are bidirectional.</p>
            <p><strong>Directed Graph (Digraph):</strong> Edges have direction - connections go from source to target.</p>
        </div>

        <div class="controls">
            <button onclick="addRandomNode()">Add Random Node</button>
            <button onclick="addRandomEdge()">Add Random Edge</button>
            <button onclick="clearGraphs()">Clear Graphs</button>
            <button onclick="generateRandomGraph()">Generate Random Graph</button>
        </div>

        <div class="graph-container">
            <div class="graph">
                <h3>Undirected Graph</h3>
                <canvas id="undirectedCanvas" width="500" height="400"></canvas>
                <div class="node-info" id="undirectedInfo">Click on nodes to see connections</div>
            </div>
            
            <div class="graph">
                <h3>Directed Graph</h3>
                <canvas id="directedCanvas" width="500" height="400"></canvas>
                <div class="node-info" id="directedInfo">Click on nodes to see connections</div>
            </div>
        </div>
    </div>

    <script>
        class Graph {
            constructor(type) {
                this.type = type; // 'directed' or 'undirected'
                this.nodes = [];
                this.edges = [];
                this.selectedNode = null;
            }

            addNode(x, y, label) {
                const node = {
                    id: this.nodes.length,
                    x: x,
                    y: y,
                    label: label || `Node ${this.nodes.length}`,
                    radius: 20
                };
                this.nodes.push(node);
                return node;
            }

            addEdge(sourceId, targetId) {
                // Check if edge already exists
                const existingEdge = this.edges.find(edge => 
                    edge.source === sourceId && edge.target === targetId
                );
                
                if (existingEdge) return;

                const edge = { source: sourceId, target: targetId };
                this.edges.push(edge);

                // For undirected graphs, add reverse edge if it doesn't exist
                if (this.type === 'undirected') {
                    const reverseEdge = this.edges.find(e => 
                        e.source === targetId && e.target === sourceId
                    );
                    if (!reverseEdge) {
                        this.edges.push({ source: targetId, target: sourceId });
                    }
                }
            }

            getNodeAt(x, y) {
                return this.nodes.find(node => {
                    const distance = Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2);
                    return distance <= node.radius;
                });
            }

            getConnections(nodeId) {
                const outgoing = this.edges.filter(edge => edge.source === nodeId)
                    .map(edge => this.nodes[edge.target].label);
                
                const incoming = this.edges.filter(edge => edge.target === nodeId && edge.source !== nodeId)
                    .map(edge => this.nodes[edge.source].label);

                return { outgoing, incoming };
            }
        }

        // Initialize graphs
        const undirectedGraph = new Graph('undirected');
        const directedGraph = new Graph('directed');
        
        // Canvas elements
        const undirectedCanvas = document.getElementById('undirectedCanvas');
        const directedCanvas = document.getElementById('directedCanvas');
        const undirectedCtx = undirectedCanvas.getContext('2d');
        const directedCtx = directedCanvas.getContext('2d');

        // Info displays
        const undirectedInfo = document.getElementById('undirectedInfo');
        const directedInfo = document.getElementById('directedInfo');

        // Initial sample graph
        function initializeSampleGraph() {
            // Add nodes to both graphs
            for (let i = 0; i < 5; i++) {
                const x = 100 + Math.random() * 300;
                const y = 100 + Math.random() * 200;
                undirectedGraph.addNode(x, y, String.fromCharCode(65 + i));
                directedGraph.addNode(x, y, String.fromCharCode(65 + i));
            }

            // Add some sample edges
            undirectedGraph.addEdge(0, 1);
            undirectedGraph.addEdge(1, 2);
            undirectedGraph.addEdge(2, 3);
            undirectedGraph.addEdge(3, 4);
            undirectedGraph.addEdge(4, 0);
            undirectedGraph.addEdge(1, 3);

            directedGraph.addEdge(0, 1);
            directedGraph.addEdge(1, 2);
            directedGraph.addEdge(2, 3);
            directedGraph.addEdge(3, 4);
            directedGraph.addEdge(4, 0);
            directedGraph.addEdge(1, 3);
            directedGraph.addEdge(3, 1); // Reverse edge to show direction

            drawGraphs();
        }

        function drawGraph(ctx, graph) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            // Draw edges
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            
            graph.edges.forEach(edge => {
                const source = graph.nodes[edge.source];
                const target = graph.nodes[edge.target];
                
                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                
                if (graph.type === 'directed') {
                    // Draw arrow for directed edges
                    const angle = Math.atan2(target.y - source.y, target.x - source.x);
                    const headLength = 15;
                    const distance = Math.sqrt((target.x - source.x) ** 2 + (target.y - source.y) ** 2);
                    const adjustedDistance = Math.max(0, distance - source.radius - 5);
                    
                    const endX = source.x + Math.cos(angle) * adjustedDistance;
                    const endY = source.y + Math.sin(angle) * adjustedDistance;
                    
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Draw arrowhead
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(
                        endX - headLength * Math.cos(angle - Math.PI / 6),
                        endY - headLength * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        endX - headLength * Math.cos(angle + Math.PI / 6),
                        endY - headLength * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fillStyle = '#666';
                    ctx.fill();
                } else {
                    // Straight line for undirected edges
                    const angle = Math.atan2(target.y - source.y, target.x - source.x);
                    const distance = Math.sqrt((target.x - source.x) ** 2 + (target.y - source.y) ** 2);
                    const adjustedDistance = Math.max(0, distance - source.radius - target.radius);
                    
                    const endX = source.x + Math.cos(angle) * (source.radius + adjustedDistance / 2);
                    const endY = source.y + Math.sin(angle) * (source.radius + adjustedDistance / 2);
                    
                    const controlX = (source.x + target.x) / 2;
                    const controlY = (source.y + target.y) / 2 - 30;
                    
                    ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                    ctx.stroke();
                }
            });

            // Draw nodes
            graph.nodes.forEach((node, index) => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, 2 * Math.PI);
                ctx.fillStyle = graph.selectedNode === index ? '#ff6b6b' : '#4ecdc4';
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw label
                ctx.fillStyle = '#333';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.label, node.x, node.y);
            });
        }

        function drawGraphs() {
            drawGraph(undirectedCtx, undirectedGraph);
            drawGraph(directedCtx, directedGraph);
        }

        function handleCanvasClick(event, graph, infoElement) {
            const rect = event.target.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const clickedNode = graph.getNodeAt(x, y);
            
            if (clickedNode) {
                graph.selectedNode = graph.selectedNode === clickedNode.id ? null : clickedNode.id;
                const connections = graph.getConnections(clickedNode.id);
                
                if (graph.selectedNode !== null) {
                    infoElement.textContent = 
                        `Selected: ${clickedNode.label} | ` +
                        `Outgoing: ${connections.outgoing.join(', ') || 'none'} | ` +
                        `Incoming: ${connections.incoming.join(', ') || 'none'}`;
                } else {
                    infoElement.textContent = 'Click on nodes to see connections';
                }
            } else {
                // Add new node if clicked on empty space
                const label = String.fromCharCode(65 + graph.nodes.length);
                graph.addNode(x, y, label);
                graph.selectedNode = null;
                infoElement.textContent = 'Click on nodes to see connections';
            }

            drawGraphs();
        }

        // Event listeners
        undirectedCanvas.addEventListener('click', (event) => {
            handleCanvasClick(event, undirectedGraph, undirectedInfo);
        });

        directedCanvas.addEventListener('click', (event) => {
            handleCanvasClick(event, directedGraph, directedInfo);
        });

        // Control functions
        function addRandomNode() {
            const x1 = 50 + Math.random() * 400;
            const y1 = 50 + Math.random() * 300;
            const x2 = 50 + Math.random() * 400;
            const y2 = 50 + Math.random() * 300;
            
            const label = String.fromCharCode(65 + undirectedGraph.nodes.length);
            undirectedGraph.addNode(x1, y1, label);
            directedGraph.addNode(x2, y2, label);
            
            drawGraphs();
        }

        function addRandomEdge() {
            if (undirectedGraph.nodes.length < 2) return;
            
            const node1 = Math.floor(Math.random() * undirectedGraph.nodes.length);
            let node2 = Math.floor(Math.random() * undirectedGraph.nodes.length);
            
            // Ensure different nodes
            while (node2 === node1 && undirectedGraph.nodes.length > 1) {
                node2 = Math.floor(Math.random() * undirectedGraph.nodes.length);
            }
            
            undirectedGraph.addEdge(node1, node2);
            directedGraph.addEdge(node1, node2);
            
            drawGraphs();
        }

        function clearGraphs() {
            undirectedGraph.nodes = [];
            undirectedGraph.edges = [];
            directedGraph.nodes = [];
            directedGraph.edges = [];
            undirectedGraph.selectedNode = null;
            directedGraph.selectedNode = null;
            undirectedInfo.textContent = 'Click on nodes to see connections';
            directedInfo.textContent = 'Click on nodes to see connections';
            drawGraphs();
        }

        function generateRandomGraph() {
            clearGraphs();
            
            // Add 6-10 random nodes
            const nodeCount = 6 + Math.floor(Math.random() * 5);
            for (let i = 0; i < nodeCount; i++) {
                const x1 = 50 + Math.random() * 400;
                const y1 = 50 + Math.random() * 300;
                const x2 = 50 + Math.random() * 400;
                const y2 = 50 + Math.random() * 300;
                
                const label = String.fromCharCode(65 + i);
                undirectedGraph.addNode(x1, y1, label);
                directedGraph.addNode(x2, y2, label);
            }
            
            // Add random edges (more for demonstration)
            const edgeCount = Math.floor(nodeCount * 1.5);
            for (let i = 0; i < edgeCount; i++) {
                const node1 = Math.floor(Math.random() * nodeCount);
                let node2 = Math.floor(Math.random() * nodeCount);
                
                while (node2 === node1 && nodeCount > 1) {
                    node2 = Math.floor(Math.random() * nodeCount);
                }
                
                undirectedGraph.addEdge(node1, node2);
                directedGraph.addEdge(node1, node2);
                
                // Add some reverse edges for directed graph to show directionality
                if (Math.random() > 0.7) {
                    directedGraph.addEdge(node2, node1);
                }
            }
            
            drawGraphs();
        }

        // Initialize
        initializeSampleGraph();
    </script>
</body>
</html>