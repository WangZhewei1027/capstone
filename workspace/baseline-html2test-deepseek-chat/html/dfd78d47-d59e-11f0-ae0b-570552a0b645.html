<!DOCTYPE html>
# Sliding Window Technique Implementation

I'll create an interactive demonstration of the sliding window algorithm, which is commonly used for solving problems that involve arrays or sequences.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Window Technique</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            margin: 0;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            padding: 25px;
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .description {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
            border-left: 4px solid #3498db;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 30px;
            align-items: center;
            justify-content: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-weight: 600;
        }
        
        input, select, button {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: 600;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .visualization {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 30px;
        }
        
        .array-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .array-element {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #e7f4fd;
            border: 2px solid #3498db;
            border-radius: 8px;
            font-weight: bold;
            font-size: 18px;
            transition: all 0.3s;
        }
        
        .window-element {
            background-color: #2ecc71;
            border-color: #27ae60;
            color: white;
        }
        
        .window-boundary {
            background-color: #e74c3c;
            border-color: #c0392b;
            color: white;
        }
        
        .algorithm-steps {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .step {
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            background-color: white;
        }
        
        .current-step {
            background-color: #e7f4fd;
            border-left: 4px solid #3498db;
        }
        
        .result {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            margin-top: 20px;
            padding: 15px;
            background-color: #f39c12;
            color: white;
            border-radius: 8px;
            display: none;
        }
        
        .complexity {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        
        .complexity-box {
            text-align: center;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            width: 45%;
        }
        
        .complexity-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #2c3e50;
        }
        
        .complexity-value {
            font-size: 18px;
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sliding Window Technique</h1>
        
        <div class="description">
            <p>The sliding window technique is an algorithmic approach used to solve problems involving arrays or sequences. Instead of processing each element repeatedly, it maintains a "window" that slides through the data, updating computations efficiently as it moves.</p>
            <p>This technique is particularly useful for problems involving subarrays or substrings, where you need to find a contiguous segment that satisfies certain conditions.</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="array-input">Array Elements (comma separated):</label>
                <input type="text" id="array-input" value="2,1,5,1,3,2" placeholder="e.g., 2,1,5,1,3,2">
            </div>
            
            <div class="control-group">
                <label for="window-size">Window Size (k):</label>
                <input type="number" id="window-size" value="3" min="1" max="10">
            </div>
            
            <div class="control-group">
                <label for="problem-type">Problem Type:</label>
                <select id="problem-type">
                    <option value="max-sum">Maximum Sum Subarray</option>
                    <option value="min-sum">Minimum Sum Subarray</option>
                    <option value="longest-substring">Longest Substring Without Repeating Characters</option>
                </select>
            </div>
            
            <button id="run-btn">Run Algorithm</button>
            <button id="step-btn">Next Step</button>
            <button id="reset-btn">Reset</button>
        </div>
        
        <div class="visualization">
            <div id="array-container" class="array-container">
                <!-- Array elements will be dynamically inserted here -->
            </div>
            
            <div class="algorithm-steps" id="algorithm-steps">
                <div class="step">Algorithm steps will appear here...</div>
            </div>
            
            <div id="result" class="result"></div>
            
            <div class="complexity">
                <div class="complexity-box">
                    <div class="complexity-title">Time Complexity</div>
                    <div class="complexity-value" id="time-complexity">O(n)</div>
                </div>
                <div class="complexity-box">
                    <div class="complexity-title">Space Complexity</div>
                    <div class="complexity-value" id="space-complexity">O(1)</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM elements
        const arrayInput = document.getElementById('array-input');
        const windowSizeInput = document.getElementById('window-size');
        const problemTypeSelect = document.getElementById('problem-type');
        const runBtn = document.getElementById('run-btn');
        const stepBtn = document.getElementById('step-btn');
        const resetBtn = document.getElementById('reset-btn');
        const arrayContainer = document.getElementById('array-container');
        const algorithmSteps = document.getElementById('algorithm-steps');
        const resultDiv = document.getElementById('result');
        const timeComplexity = document.getElementById('time-complexity');
        const spaceComplexity = document.getElementById('space-complexity');
        
        // Algorithm state
        let currentStep = 0;
        let steps = [];
        let array = [];
        let windowSize = 3;
        let currentWindow = [];
        
        // Initialize the visualization
        function initializeVisualization() {
            array = arrayInput.value.split(',').map(Number);
            windowSize = parseInt(windowSizeInput.value);
            currentStep = 0;
            steps = [];
            algorithmSteps.innerHTML = '';
            resultDiv.style.display = 'none';
            
            // Render array elements
            arrayContainer.innerHTML = '';
            array.forEach((value, index) => {
                const element = document.createElement('div');
                element.className = 'array-element';
                element.textContent = value;
                element.id = `element-${index}`;
                arrayContainer.appendChild(element);
            });
            
            // Generate algorithm steps based on problem type
            generateAlgorithmSteps();
        }
        
        // Generate algorithm steps based on problem type
        function generateAlgorithmSteps() {
            const problemType = problemTypeSelect.value;
            
            switch(problemType) {
                case 'max-sum':
                case 'min-sum':
                    generateSumSubarraySteps();
                    break;
                case 'longest-substring':
                    generateLongestSubstringSteps();
                    break;
            }
            
            // Update complexity information
            updateComplexityInfo();
            
            // Display first step
            displayCurrentStep();
        }
        
        // Generate steps for max/min sum subarray problems
        function generateSumSubarraySteps() {
            steps = [`Initialize window sum to 0`];
            
            // Calculate initial window sum
            let initialSum = 0;
            for (let i = 0; i < windowSize; i++) {
                initialSum += array[i];
                steps.push(`Add element at index ${i} (value: ${array[i]}) to window sum`);
            }
            
            steps.push(`Initial window sum: ${initialSum}`);
            
            let maxSum = initialSum;
            let minSum = initialSum;
            let currentSum = initialSum;
            let maxStart = 0;
            let minStart = 0;
            
            // Slide the window
            for (let i = windowSize; i < array.length; i++) {
                steps.push(`Slide window: remove element at index ${i - windowSize} (value: ${array[i - windowSize]})`);
                currentSum = currentSum - array[i - windowSize] + array[i];
                steps.push(`Add element at index ${i} (value: ${array[i]}) to window sum`);
                steps.push(`New window sum: ${currentSum}`);
                
                if (currentSum > maxSum) {
                    maxSum = currentSum;
                    maxStart = i - windowSize + 1;
                    steps.push(`New maximum sum found: ${maxSum} (starting at index ${maxStart})`);
                }
                
                if (currentSum < minSum) {
                    minSum = currentSum;
                    minStart = i - windowSize + 1;
                    steps.push(`New minimum sum found: ${minSum} (starting at index ${minStart})`);
                }
            }
            
            // Add final result step
            if (problemTypeSelect.value === 'max-sum') {
                steps.push(`Maximum sum of subarray of size ${windowSize} is ${maxSum}`);
            } else {
                steps.push(`Minimum sum of subarray of size ${windowSize} is ${minSum}`);
            }
        }
        
        // Generate steps for longest substring without repeating characters
        function generateLongestSubstringSteps() {
            steps = [`Initialize variables: start = 0, maxLength = 0, charMap = {}`];
            
            let start = 0;
            let maxLength = 0;
            let charMap = {};
            
            for (let end = 0; end < array.length; end++) {
                const char = array[end];
                steps.push(`Processing element at index ${end} (value: ${char})`);
                
                if (charMap[char] >= start) {
                    steps.push(`Character ${char} found in current window at index ${charMap[char]}`);
                    start = charMap[char] + 1;
                    steps.push(`Move window start to index ${start}`);
                }
                
                charMap[char] = end;
                maxLength = Math.max(maxLength, end - start + 1);
                steps.push(`Current window length: ${end - start + 1}, Max length so far: ${maxLength}`);
            }
            
            steps.push(`Longest substring without repeating characters has length ${maxLength}`);
        }
        
        // Update complexity information based on problem type
        function updateComplexityInfo() {
            const problemType = problemTypeSelect.value;
            
            if (problemType === 'longest-substring') {
                timeComplexity.textContent = 'O(n)';
                spaceComplexity.textContent = 'O(min(m, n))';
            } else {
                timeComplexity.textContent = 'O(n)';
                spaceComplexity.textContent = 'O(1)';
            }
        }
        
        // Display the current step of the algorithm
        function displayCurrentStep() {
            algorithmSteps.innerHTML = '';
            
            steps.forEach((step, index) => {
                const stepElement = document.createElement('div');
                stepElement.className = 'step';
                if (index === currentStep) {
                    stepElement.classList.add('current-step');
                }
                stepElement.textContent = `Step ${index + 1}: ${step}`;
                algorithmSteps.appendChild(stepElement);
            });
            
            // Scroll to the current step
            algorithmSteps.scrollTop = algorithmSteps.scrollHeight;
        }
        
        // Visualize the current window
        function visualizeWindow() {
            // Reset all elements to default style
            for (let i = 0; i < array.length; i++) {
                const element = document.getElementById(`element-${i}`);
                element.className = 'array-element';
            }
            
            // Highlight the current window based on algorithm step
            const problemType = problemTypeSelect.value;
            
            if (problemType === 'max-sum' || problemType === 'min-sum') {
                // For sum problems, we're sliding a fixed-size window
                let windowStart = 0;
                
                if (currentStep > 0 && currentStep < steps.length - 1) {
                    // Find the current window start based on step content
                    const stepText = steps[currentStep];
                    if (stepText.includes('Slide window')) {
                        // After sliding, window start increments by 1
                        const match = stepText.match(/remove element at index (\d+)/);
                        if (match) {
                            windowStart = parseInt(match[1]) + 1;
                        }
                    } else if (stepText.includes('Add element at index')) {
                        const match = stepText.match(/index (\d+)/);
                        if (match) {
                            const idx = parseInt(match[1]);
                            windowStart = idx - windowSize + 1;
                        }
                    }
                }
                
                // Highlight the window
                for (let i = windowStart; i < windowStart + windowSize && i < array.length; i++) {
                    const element = document.getElementById(`element-${i}`);
                    element.classList.add('window-element');
                }
                
                // Highlight the boundaries
                if (windowStart >= 0 && windowStart < array.length) {
                    const startElement = document.getElementById(`element-${windowStart}`);
                    startElement.classList.add('window-boundary');
                }
                
                if (windowStart + windowSize - 1 >= 0 && windowStart + windowSize - 1 < array.length) {
                    const endElement = document.getElementById(`element-${windowStart + windowSize - 1}`);
                    endElement.classList.add('window-boundary');
                }
                
            } else if (problemType === 'longest-substring') {
                // For longest substring, we need more sophisticated visualization
                // This is a simplified version for demonstration
                let start = 0;
                let end = 0;
                
                // Parse the step to determine current window
                if (currentStep > 0) {
                    const stepText = steps[currentStep];
                    
                    if (stepText.includes('Move window start to index')) {
                        const match = stepText.match(/index (\d+)/);
                        if (match) {
                            start = parseInt(match[1]);
                        }
                    }
                    
                    if (stepText.includes('Processing element at index')) {
                        const match = stepText.match(/index (\d+)/);
                        if (match) {
                            end = parseInt(match[1]);
                        }
                    }
                    
                    if (stepText.includes('Current window length')) {
                        const match = stepText.match(/length: (\d+)/);
                        if (match) {
                            const length = parseInt(match[1]);
                            start = end - length + 1;
                        }
                    }
                }
                
                // Highlight the window
                for (let i = start; i <= end && i < array.length; i++) {
                    const element = document.getElementById(`element-${i}`);
                    element.classList.add('window-element');
                }
                
                // Highlight the boundaries
                if (start >= 0 && start < array.length) {
                    const startElement = document.getElementById(`element-${start}`);
                    startElement.classList.add('window-boundary');
                }
                
                if (end >= 0 && end < array.length) {
                    const endElement = document.getElementById(`element-${end}`);
                    endElement.classList.add('window-boundary');
                }
            }
        }
        
        // Execute the next step of the algorithm
        function nextStep() {
            if (currentStep < steps.length - 1) {
                currentStep++;
                displayCurrentStep();
                visualizeWindow();
                
                // If we reached the final step, show the result
                if (currentStep === steps.length - 1) {
                    const resultText = steps[currentStep];
                    resultDiv.textContent = resultText;
                    resultDiv.style.display = 'block';
                }
            }
        }
        
        // Run the entire algorithm at once
        function runAlgorithm() {
            // Reset to beginning
            currentStep = 0;
            initializeVisualization();
            
            // Fast-forward to the end
            const interval = setInterval(() => {
                if (currentStep < steps.length - 1) {
                    nextStep();
                } else {
                    clearInterval(interval);
                }
            }, 1000);
        }
        
        // Event listeners
        runBtn.addEventListener('click', runAlgorithm);
        stepBtn.addEventListener('click', nextStep);
        resetBtn.addEventListener('click', initializeVisualization);
