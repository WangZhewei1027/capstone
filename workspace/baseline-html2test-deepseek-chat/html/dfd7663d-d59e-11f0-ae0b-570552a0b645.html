<!DOCTYPE html>
# Dijkstra's Algorithm Visualization

I've created an interactive visualization tool that demonstrates Dijkstra's algorithm step by step. This implementation allows you to see how the algorithm finds the shortest path between nodes in a graph.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e6e6e6;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            margin-bottom: 10px;
        }
        
        h1 {
            color: #4cc9f0;
            font-size: 2.5rem;
            text-shadow: 0 0 10px rgba(76, 201, 240, 0.7);
            margin-bottom: 10px;
        }
        
        .description {
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
            font-size: 1.1rem;
        }
        
        .visualization-container {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
        }
        
        .controls {
            flex: 1;
            min-width: 300px;
            background: rgba(30, 30, 46, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        h2 {
            color: #f72585;
            font-size: 1.5rem;
            margin-bottom: 15px;
            border-bottom: 2px solid #f72585;
            padding-bottom: 5px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        input, select, button {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
        }
        
        button {
            background: linear-gradient(135deg, #f72585 0%, #4361ee 100%);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(247, 37, 133, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .canvas-container {
            flex: 2;
            min-width: 600px;
            background: rgba(30, 30, 46, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            background: #1a1a2e;
            border-radius: 10px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
        }
        
        .information {
            background: rgba(30, 30, 46, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        .step-info {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            font-family: monospace;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .nodes {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .node-example {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        .unknown { background-color: #4a4a6a; }
        .visited { background-color: #4361ee; }
        .current { background-color: #f72585; }
        .final-path { background-color: #4cc9f0; }
        
        .instructions {
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-top: 15px;
            line-height: 1.5;
        }
        
        @media (max-width: 900px) {
            .visualization-container {
                flex-direction: column;
            }
            
            .canvas-container, .controls {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Dijkstra's Algorithm</h1>
            <p class="description">
                Dijkstra's algorithm is a popular algorithm for finding the shortest paths between nodes in a graph. 
                This visualization demonstrates how the algorithm works step by step.
            </p>
        </header>
        
        <div class="visualization-container">
            <div class="controls">
                <div class="control-group">
                    <h2>Graph Configuration</h2>
                    <label for="graphType">Graph Type:</label>
                    <select id="graphType">
                        <option value="predefined">Predefined Graph</option>
                        <option value="random">Random Graph</option>
                    </select>
                    
                    <label for="startNode">Start Node:</label>
                    <input type="number" id="startNode" min="0" max="6" value="0">
                    
                    <label for="endNode">End Node:</label>
                    <input type="number" id="endNode" min="0" max="6" value="6">
                    
                    <button id="resetBtn">Reset Graph</button>
                </div>
                
                <div class="control-group">
                    <h2>Algorithm Controls</h2>
                    <button id="stepBtn">Next Step</button>
                    <button id="runBtn">Run Algorithm</button>
                    <button id="pauseBtn">Pause</button>
                </div>
                
                <div class="control-group">
                    <h2>Node Legend</h2>
                    <div class="nodes">
                        <div class="node-example">
                            <div class="color-box unknown"></div>
                            <span>Unvisited</span>
                        </div>
                        <div class="node-example">
                            <div class="color-box visited"></div>
                            <span>Visited</span>
                        </div>
                        <div class="node-example">
                            <div class="color-box current"></div>
                            <span>Current</span>
                        </div>
                        <div class="node-example">
                            <div class="color-box final-path"></div>
                            <span>Shortest Path</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="graphCanvas" width="600" height="500"></canvas>
            </div>
        </div>
        
        <div class="information">
            <h2>Algorithm Steps</h2>
            <div class="step-info" id="stepInfo">
                <p>Click "Next Step" to start the visualization.</p>
            </div>
            
            <div class="instructions">
                <h3>How Dijkstra's Algorithm Works:</h3>
                <ol>
                    <li>Initialize all node distances as infinity, except the start node (distance 0)</li>
                    <li>Select the unvisited node with the smallest known distance</li>
                    <li>For the current node, examine its unvisited neighbors</li>
                    <li>Calculate their tentative distances through the current node</li>
                    <li>If the calculated distance is less than the known distance, update it</li>
                    <li>Mark the current node as visited</li>
                    <li>Repeat until the destination node is visited or all nodes are visited</li>
                    <li>Backtrack from the end node to find the shortest path</li>
                </ol>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const stepInfo = document.getElementById('stepInfo');
        
        // Graph configuration
        let graph = {
            nodes: [],
            edges: [],
            startNode: 0,
            endNode: 6
        };
        
        // Algorithm state
        let algorithmState = {
            distances: [],
            previous: [],
            visited: [],
            currentStep: 0,
            isRunning: false,
            isCompleted: false,
            currentNode: null,
            finalPath: []
        };
        
        // Initialize the graph
        function initializeGraph() {
            // Create nodes arranged in a circle
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 180;
            const nodeCount = 7;
            
            graph.nodes = [];
            for (let i = 0; i < nodeCount; i++) {
                const angle = (i / nodeCount) * 2 * Math.PI - Math.PI / 2;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                graph.nodes.push({ id: i, x: x, y: y });
            }
            
            // Create edges with weights
            graph.edges = [
                { from: 0, to: 1, weight: 2 },
                { from: 0, to: 2, weight: 6 },
                { from: 1, to: 3, weight: 5 },
                { from: 2, to: 3, weight: 8 },
                { from: 3, to: 4, weight: 10 },
                { from: 3, to: 5, weight: 15 },
                { from: 4, to: 6, weight: 2 },
                { from: 5, to: 6, weight: 6 },
                { from: 4, to: 5, weight: 6 },
                { from: 1, to: 2, weight: 3 }
            ];
            
            resetAlgorithm();
        }
        
        // Reset the algorithm to initial state
        function resetAlgorithm() {
            const startNode = parseInt(document.getElementById('startNode').value) || 0;
            const endNode = parseInt(document.getElementById('endNode').value) || 6;
            
            graph.startNode = Math.max(0, Math.min(startNode, graph.nodes.length - 1));
            graph.endNode = Math.max(0, Math.min(endNode, graph.nodes.length - 1));
            
            algorithmState = {
                distances: new Array(graph.nodes.length).fill(Infinity),
                previous: new Array(graph.nodes.length).fill(null),
                visited: new Array(graph.nodes.length).fill(false),
                currentStep: 0,
                isRunning: false,
                isCompleted: false,
                currentNode: null,
                finalPath: []
            };
            
            algorithmState.distances[graph.startNode] = 0;
            updateStepInfo("Algorithm reset. Ready to start.");
            drawGraph();
        }
        
        // Draw the graph on the canvas
        function drawGraph() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges
            ctx.strokeStyle = '#4a4a6a';
            ctx.lineWidth = 2;
            ctx.font = '14px Arial';
            ctx.fillStyle = '#e6e6e6';
            
            graph.edges.forEach(edge => {
                const fromNode = graph.nodes[edge.from];
                const toNode = graph.nodes[edge.to];
                
                // Draw line
                ctx.beginPath();
                ctx.moveTo(fromNode.x, fromNode.y);
                ctx.lineTo(toNode.x, toNode.y);
                ctx.stroke();
                
                // Draw weight
                const midX = (fromNode.x + toNode.x) / 2;
                const midY = (fromNode.y + toNode.y) / 2;
                
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(midX - 15, midY - 10, 30, 20);
                ctx.fillStyle = '#e6e6e6';
                ctx.fillText(edge.weight, midX - 8, midY + 5);
            });
            
            // Draw nodes
            graph.nodes.forEach((node, index) => {
                let nodeColor = '#4a4a6a'; // Default (unvisited)
                
                if (algorithmState.isCompleted && algorithmState.finalPath.includes(index)) {
                    nodeColor = '#4cc9f0'; // Final path
                } else if (index === algorithmState.currentNode) {
                    nodeColor = '#f72585'; // Current node
                } else if (algorithmState.visited[index]) {
                    nodeColor = '#4361ee'; // Visited node
                } else if (index === graph.startNode) {
                    nodeColor = '#4cc9f0'; // Start node
                } else if (index === graph.endNode) {
                    nodeColor = '#4cc9f0'; // End node
                }
                
                // Draw node
                ctx.beginPath();
                ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = nodeColor;
                ctx.fill();
                ctx.strokeStyle = '#e6e6e6';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw node ID
                ctx.fillStyle = '#e6e6e6';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.id, node.x, node.y);
                
                // Draw distance if known
                if (algorithmState.distances[index] !== Infinity) {
                    ctx.fillStyle = '#e6e6e6';
                    ctx.font = '12px Arial';
                    ctx.fillText(algorithmState.distances[index], node.x, node.y - 30);
                }
            });
        }
        
        // Update the step information display
        function updateStepInfo(message) {
            stepInfo.innerHTML = `<p>Step ${algorithmState.currentStep}: ${message}</p>`;
        }
        
        // Perform one step of the algorithm
        function algorithmStep() {
            if (algorithmState.isCompleted) {
                updateStepInfo("Algorithm completed. Shortest path found.");
                return;
            }
            
            algorithmState.currentStep++;
            
            // Find the unvisited node with the smallest distance
            let minDistance = Infinity;
            let minIndex = -1;
            
            for (let i = 0; i < graph.nodes.length; i++) {
                if (!algorithmState.visited[i] && algorithmState.distances[i] < minDistance) {
                    minDistance = algorithmState.distances[i];
                    minIndex = i;
                }
            }
            
            // If no node found or destination reached
            if (minIndex === -1) {
                algorithmState.isCompleted = true;
                updateStepInfo("No path exists from start to end node.");
                drawGraph();
                return;
            }
            
            algorithmState.currentNode = minIndex;
            algorithmState.visited[minIndex] = true;
            
            updateStepInfo(`Visiting node ${minIndex} with distance ${algorithmState.distances[minIndex]}`);
            
            // If we reached the destination
            if (minIndex === graph.endNode) {
                algorithmState.isCompleted = true;
                
                // Reconstruct the path
                let path = [];
                let current = graph.endNode;
                
                while (current !== null) {
                    path.unshift(current);
                    current = algorithmState.previous[current];
                }
                
                algorithmState.finalPath = path;
                
                updateStepInfo(`Shortest path found: ${path.join(' â†’ ')} with total distance ${algorithmState.distances[graph.endNode]}`);
                drawGraph();
                return;
            }
            
            // Update distances to neighbors
            graph.edges.forEach(edge => {
                if (edge.from === minIndex && !algorithmState.visited[edge.to]) {
                    const newDistance = algorithmState.distances[minIndex] + edge.weight;
                    
                    if (newDistance < algorithmState.distances[edge.to]) {
                        algorithmState.distances[edge.to] = newDistance;
                        algorithmState.previous[edge.to] = minIndex;
                        updateStepInfo(updateStepInfo.innerHTML + `<br>Updated node ${edge.to} distance to ${newDistance}`);
                    }
                }
                
                // For undirected graph, check both directions
                if (edge.to === minIndex && !algorithmState.visited[edge.from]) {
                    const newDistance = algorithmState.distances[minIndex] + edge.weight;
