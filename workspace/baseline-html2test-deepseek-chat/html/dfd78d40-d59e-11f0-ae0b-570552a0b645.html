<!DOCTYPE html>
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topological Sort Algorithm</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: #4a6fa5;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .content {
            padding: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .visualization {
            flex: 1;
            min-width: 300px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            background: #f9f9f9;
        }
        .controls {
            flex: 1;
            min-width: 300px;
            padding: 15px;
        }
        h1 {
            margin-bottom: 10px;
        }
        h2 {
            margin-bottom: 15px;
            color: #4a6fa5;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
        }
        p {
            margin-bottom: 15px;
        }
        textarea {
            width: 100%;
            height: 120px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            font-family: monospace;
            margin-bottom: 15px;
        }
        button {
            background: #4a6fa5;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover {
            background: #3a5a80;
        }
        button:disabled {
            background: #aaa;
            cursor: not-allowed;
        }
        .graph-display {
            height: 300px;
            border: 1px solid #ddd;
            margin-bottom: 15px;
            background: white;
            overflow: auto;
            padding: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .result-display {
            min-height: 200px;
            border: 1px solid #ddd;
            padding: 15px;
            background: white;
            border-radius: 4px;
        }
        .step-display {
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
        }
        .vertex {
            display: inline-block;
            width: 40px;
            height: 40px;
            line-height: 40px;
            text-align: center;
            border-radius: 50%;
            background: #4a6fa5;
            color: white;
            margin: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        .vertex.visited {
            background: #5cb85c;
        }
        .vertex.current {
            background: #f0ad4e;
            transform: scale(1.1);
        }
        .edge {
            stroke: #4a6fa5;
            stroke-width: 2;
            fill: none;
        }
        .arrow {
            stroke: #4a6fa5;
            stroke-width: 2;
            fill: #4a6fa5;
        }
        .topological-order {
            margin-bottom: 10px;
            font-weight: bold;
        }
        .step-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        svg {
            width: 100%;
            height: 100%;
        }
        .node {
            fill: #4a6fa5;
            stroke: #fff;
            stroke-width: 2;
        }
        .node-label {
            fill: white;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: central;
        }
        .visited-node {
            fill: #5cb85c;
        }
        .current-node {
            fill: #f0ad4e;
        }
        input {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .example-graphs {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        .example-btn {
            background: #f8f9fa;
            border: 1px solid #ddd;
            color: #333;
            padding: 8px;
            text-align: left;
        }
        .example-btn:hover {
            background: #e9ecef;
        }
        .predefined-graphs {
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Topological Sort Algorithm</h1>
            <p>Visualize and understand topological sorting on directed acyclic graphs (DAG)</p>
        </div>
        
        <div class="content">
            <div class="visualization">
                <h2>Graph Visualization</h2>
                <div class="graph-display" id="graphDisplay">
                    <svg id="graphCanvas" width="400" height="280"></svg>
                </div>
                
                <h2>Topological Order</h2>
                <div class="result-display" id="resultDisplay">
                    <p>Run the algorithm to see the topological order</p>
                </div>
                
                <div class="step-display" id="stepDisplay">
                    <p>No steps yet. Run the algorithm to see the steps.</p>
                </div>
            </div>
            
            <div class="controls">
                <h2>Algorithm Controls</h2>
                
                <div class="predefined-graphs">
                    <p>Try a predefined graph:</p>
                    <div class="example-graphs">
                        <button class="example-btn" onclick="loadExampleGraph('simple')">Simple Linear DAG:</button>
                        <button class="example-btn" onclick="loadExampleGraph('complex')">Complex DAG:</button>
                        <button class="example-btn" onclick="loadExampleGraph('tree')">Tree-like DAG:</button>
                        <button class="example-btn" onclick="loadExampleGraph('course')">Course Dependencies:</button>
                    </div>
                </div>
                
                <p>Enter graph edges below as "A->B" (one per line)</p>
                <textarea id="graphInput" placeholder="A->B
B->C
A->D
D->C"></textarea>
                
                <button onclick="validateAndParseGraph()">Parse Graph</button>
                <button id="runAlgorithmBtn" onclick="runAlgorithm()" disabled>Run Algorithm</button>
                <button id="stepBtn" onclick="stepAlgorithm()" disabled>Step Forward</button>
                <button onclick="resetAlgorithm()">Reset</button>
                
                <h2>About Topological Sort</h2>
                <p>Topological sort is an algorithm for ordering the nodes of a directed acyclic graph (DAG) such that for every directed edge u → v, u comes before v in the ordering.</p>
                <p>Applications include:</p>
                <ul>
                    <li>Course prerequisites scheduling</li>
                    <li>Build system dependency resolution</li>
                    <li>Event scheduling</li>
                    <li>Task scheduling with dependencies</li>
                </ul>
                
                <p>The algorithm works by repeatedly selecting nodes with no incoming edges (in-degree of 0), adding them to the order, and removing their outgoing edges.</p>
            </div>
        </div>
    </div>

    <script>
        // Graph data structure
        let graph = {
            nodes: [],
            edges: []
        };
        
        // Algorithm state
        let algorithmState = {
            inDegree: {},
            queue: [],
            order: [],
            step: 0,
            running: false,
            currentVertex: null
        };
        
        // Predefined graphs
        const exampleGraphs = {
            simple: {
                edges: ["A->B", "B->C", "C->D"],
                description: "Simple linear path A→B→C→D"
            },
            complex: {
                edges: ["A->B", "A->C", "B->D", "C->D", "D->E", "D->F"],
                description: "Complex DAG with multiple paths"
            },
            tree: {
                edges: ["A->B", "A->C", "B->D", "B->E", "C->F", "C->G"],
                description: "Tree-like structure"
            },
            course: {
                edges: ["Math101->Math201", "Math101->CS101", "CS101->CS201", "CS101->CS202", "CS201->CS301", "CS202->CS301"],
                description: "Course prerequisites"
            }
        };
        
        // Initialize the visualization
        function init() {
            // Set up default graph
            loadExampleGraph('simple');
            validateAndParseGraph();
            renderGraph();
        }
        
        // Load an example graph
        function loadExampleGraph(type) {
            const example = exampleGraphs[type];
            if (example) {
                document.getElementById('graphInput').value = example.edges.join('\n');
                validateAndParseGraph();
                document.getElementById('stepDisplay').innerHTML = `<p>Loaded: ${example.description}</p>`;
            }
        }
        
        // Parse the graph input
        function validateAndParseGraph() {
            const input = document.getElementById('graphInput').value;
            const lines = input.split('\n').filter(line => line.trim() !== '');
            
            graph.nodes = [];
            graph.edges = [];
            
            // Collect all unique nodes
            const nodeSet = new Set();
            
            for (const line of lines) {
                const parts = line.split('->');
                if (parts.length !== 2) {
                    alert(`Invalid edge format: ${line}. Use format "A->B"`);
                    return;
                }
                
                const from = parts[0].trim();
                const to = parts[1].trim();
                
                if (from === '' || to === '') {
                    alert(`Invalid edge format: ${line}. Nodes cannot be empty`);
                    return;
                }
                
                nodeSet.add(from);
                nodeSet.add(to);
                
                graph.edges.push({ from, to });
            }
            
            graph.nodes = Array.from(nodeSet).sort();
            
            // Reset algorithm state
            initializeAlgorithm();
            
            // Enable algorithm buttons
            document.getElementById('runAlgorithmBtn').disabled = false;
            document.getElementById('stepBtn').disabled = false;
            
            // Render the graph
            renderGraph();
            
            document.getElementById('stepDisplay').innerHTML = `<p>Graph parsed successfully. ${graph.nodes.length} nodes, ${graph.edges.length} edges.</p>`;
        }
        
        // Initialize the algorithm state
        function initializeAlgorithm() {
            algorithmState = {
                inDegree: {},
                queue: [],
                order: [],
                step: 0,
                running: false,
                currentVertex: null
            };
            
            // Calculate initial in-degrees
            for (const node of graph.nodes) {
                algorithmState.inDegree[node] = 0;
            }
            
            for (const edge of graph.edges) {
                algorithmState.inDegree[edge.to]++;
            }
            
            // Initialize queue with nodes having in-degree 0
            for (const node of graph.nodes) {
                if (algorithmState.inDegree[node] === 0) {
                    algorithmState.queue.push(node);
                }
            }
            
            updateResultDisplay();
        }
        
        // Run the algorithm to completion
        function runAlgorithm() {
            if (!algorithmState.running) {
                algorithmState.running = true;
                
                while (algorithmState.queue.length > 0) {
                    stepAlgorithm();
                }
                
                algorithmState.running = false;
                
                // Check if we have a valid topological sort
                if (algorithmState.order.length === graph.nodes.length) {
                    document.getElementById('stepDisplay').innerHTML += `<p><strong>Algorithm completed successfully!</strong></p>`;
                } else {
                    document.getElementById('stepDisplay').innerHTML += `<p><strong>Graph has cycles! Cannot perform topological sort.</strong></p>`;
                }
            }
        }
        
        // Perform one step of the algorithm
        function stepAlgorithm() {
            if (algorithmState.queue.length === 0) {
                algorithmState.running = false;
                return;
            }
            
            algorithmState.step++;
            const current = algorithmState.queue.shift();
            algorithmState.order.push(current);
            algorithmState.currentVertex = current;
            
            // Update in-degrees of neighbors
            for (const edge of graph.edges) {
                if (edge.from === current) {
                    algorithmState.inDegree[edge.to]--;
                    
                    // If in-degree becomes 0, add to queue
                    if (algorithmState.inDegree[edge.to] === 0) {
                        algorithmState.queue.push(edge.to);
                    }
                }
            }
            
            updateResultDisplay();
            renderGraph();
            
            let stepText = `<p><strong>Step ${algorithmState.step}:</strong> Processing node ${current}</p>`;
            stepText += `<p>Queue: [${algorithmState.queue.join(', ')}]</p>`;
            stepText += `<p>In-degrees: ${JSON.stringify(algorithmState.inDegree)}</p>`;
            
            document.getElementById('stepDisplay').innerHTML = stepText;
        }
        
        // Reset the algorithm
        function resetAlgorithm() {
            initializeAlgorithm();
            renderGraph();
            document.getElementById('stepDisplay').innerHTML = `<p>Algorithm reset. Ready to run.</p>`;
        }
        
        // Update the result display
        function updateResultDisplay() {
            const resultDiv = document.getElementById('resultDisplay');
            
            if (algorithmState.order.length === 0) {
                resultDiv.innerHTML = `<p>Run the algorithm to see the topological order</p>`;
                return;
            }
            
            let html = `<p class="topological-order">Topological Order: ${algorithmState.order.join(' → ')}</p>`;
            
            if (algorithmState.order.length === graph.nodes.length) {
                html += `<p><strong>Valid topological sort found!</strong></p>`;
            } else if (algorithmState.queue.length === 0 && algorithmState.order.length < graph.nodes.length) {
                html += `<p><strong>Graph contains cycles! Cannot complete topological sort.</strong></p>`;
            } else {
                html += `<p>Algorithm in progress...</p>`;
            }
            
            resultDiv.innerHTML = html;
        }
        
        // Render the graph visualization
        function renderGraph() {
            const svg = document.getElementById('graphCanvas');
            svg.innerHTML = ''; // Clear previous content
            
            // Set up dimensions
            const width = svg.getAttribute('width');
            const height = svg.getAttribute('height');
            
            // Calculate node positions in a circle
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.4;
            
            const nodePositions = {};
            const angleStep = (2 * Math.PI) / graph.nodes.length;
            
            graph.nodes.forEach((node, index) => {
                const angle = index * angleStep;
                nodePositions[node] = {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            });
            
            // Draw edges
            graph.edges.forEach(edge => {
                const fromPos = nodePositions[edge.from];
                const toPos = nodePositions[edge.to];
                
                // Draw arrow line
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', fromPos.x);
                line.setAttribute('y1', fromPos.y);
                line.setAttribute('x2', toPos.x);
                line.setAttribute('y2', toPos.y);
                line.setAttribute('class', 'edge');
                svg.appendChild(line);
                
                // Draw arrowhead
                const arrowSize = 10;
                const angle = Math.atan2(toPos.y - fromPos.y, toPos.x - fromPos.x);
                const arrowX = toPos.x - 20 * Math.cos(angle);
                const arrowY = toPos.y - 20 * Math.sin(angle);
                
                const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const points = [
                    `${arrowX},${arrowY}`,
                    `${arrowX - arrowSize * Math.cos(angle - Math.PI/6)},${arrowY - arrowSize * Math.sin(angle - Math.PI/6)}`,
                    `${arrowX - arrowSize * Math.cos(angle + Math.PI/6)},${arrowY - arrowSize * Math.sin(angle + Math.PI/6)}`
                ].join(' ');
                arrow.setAttribute('points', points);
                arrow.setAttribute('class', 'arrow');
                svg.appendChild(arrow);
            });
            
            // Draw nodes
            graph.nodes.forEach(node => {
                const pos = nodePositions[node];
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', pos.x);
                circle.setAttribute('cy', pos.y);
                circle.setAttribute('