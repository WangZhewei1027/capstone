<!DOCTYPE html>
# K-Nearest Neighbors (KNN) Interactive Demonstration

I'll create an interactive visualization that demonstrates how K-Nearest Neighbors classification works, allowing users to place points and see how the algorithm classifies them.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Nearest Neighbors (KNN) Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.2rem;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .content {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 20px;
        }
        
        .visualization-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        
        .controls {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        h2 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.5rem;
        }
        
        label {
            font-weight: 600;
            color: #34495e;
        }
        
        input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        button {
            padding: 12px;
            border: none;
            border-radius: 5px;
            background: #3498db;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 1rem;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        #canvas {
            width: 100%;
            height: 500px;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: crosshair;
            background: #f8f9fa;
        }
        
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        .explanation {
            margin-top: 30px;
            background: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.8rem;
        }
        
        p {
            line-height: 1.6;
            margin-bottom: 15px;
            color: #34495e;
        }
        
        .steps {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .step {
            flex: 1;
            min-width: 250px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        .step-number {
            display: inline-block;
            width: 30px;
            height: 30px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            margin-right: 10px;
            font-weight: bold;
        }
        
        .info-box {
            background: #e8f4fc;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #3498db;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 14px;
            display: none;
            z-index: 10;
        }
        
        @media (max-width: 900px) {
            .content {
                grid-template-columns: 1fr;
            }
            
            .steps {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>K-Nearest Neighbors (KNN) Algorithm</h1>
            <p class="subtitle">An interactive demonstration of how the K-Nearest Neighbors classification algorithm works. Place points on the canvas and see how KNN classifies new points based on their neighbors.</p>
        </header>
        
        <div class="content">
            <div class="visualization-container">
                <canvas id="canvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #e74c3c;"></div>
                        <span>Class A (Red)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2ecc71;"></div>
                        <span>Class B (Green)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #3498db;"></div>
                        <span>New Point (Blue)</span>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h2>Controls</h2>
                    <label for="k-value">K Value:</label>
                    <input type="number" id="k-value" min="1" max="20" value="5">
                    
                    <label>Mode:</label>
                    <div>
                        <input type="radio" id="mode-a" name="mode" value="A" checked>
                        <label for="mode-a">Class A (Red)</label>
                    </div>
                    <div>
                        <input type="radio" id="mode-b" name="mode" value="B">
                        <label for="mode-b">Class B (Green)</label>
                    </div>
                    <div>
                        <input type="radio" id="mode-classify" name="mode" value="classify">
                        <label for="mode-classify">Classify Point</label>
                    </div>
                </div>
                
                <div class="control-group">
                    <button id="reset-btn">Reset Canvas</button>
                    <button id="generate-random">Generate Random Points</button>
                </div>
                
                <div class="control-group">
                    <h2>How KNN Works</h2>
                    <p>1. Select a value for K (number of neighbors)</p>
                    <p>2. Calculate distance to all training points</p>
                    <p>3. Identify the K nearest neighbors</p>
                    <p>4. Classify based on majority vote of neighbors</p>
                </div>
            </div>
        </div>
        
        <div class="explanation">
            <h3>Understanding K-Nearest Neighbors</h3>
            <p>The K-Nearest Neighbors (KNN) algorithm is a simple, supervised machine learning algorithm that can be used for both classification and regression. It's based on the principle that similar things exist in close proximity.</p>
            
            <div class="info-box">
                <p><strong>Key Idea:</strong> The class of a new data point is determined by the classes of its K nearest neighbors in the feature space.</p>
            </div>
            
            <div class="steps">
                <div class="step">
                    <h3><span class="step-number">1</span>Choose K</h3>
                    <p>Select the number of neighbors (K) to consider. A small K value makes the algorithm sensitive to noise, while a large K value makes it more stable but possibly less accurate.</p>
                </div>
                
                <div class="step">
                    <h3><span class="step-number">2</span>Calculate Distance</h3>
                    <p>Compute the distance between the new point and all existing points. Typically, Euclidean distance is used, but other distance metrics can be applied.</p>
                </div>
                
                <div class="step">
                    <h3><span class="step-number">3</span>Find Neighbors</h3>
                    <p>Identify the K points with the smallest distances to the new point. These are the "nearest neighbors."</p>
                </div>
                
                <div class="step">
                    <h3><span class="step-number">4</span>Majority Vote</h3>
                    <p>For classification, assign the class that appears most frequently among the K neighbors. For regression, take the average of the neighbors' values.</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        
        // Set canvas dimensions
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            redraw();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Data storage
        let points = {
            A: [], // Class A points (red)
            B: []  // Class B points (green)
        };
        
        let newPoint = null; // Point to classify (blue)
        let nearestNeighbors = []; // Store nearest neighbors for visualization
        
        // Colors
        const colors = {
            A: '#e74c3c', // Red
            B: '#2ecc71', // Green
            newPoint: '#3498db', // Blue
            neighborLine: '#f39c12' // Orange
        };
        
        // Configuration
        let currentMode = 'A'; // Default mode: placing Class A points
        let kValue = 5; // Default K value
        
        // Initialize controls
        document.getElementById('k-value').value = kValue;
        
        // Event listeners for mode selection
        document.querySelectorAll('input[name="mode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                currentMode = e.target.value;
                redraw();
            });
        });
        
        // K value change
        document.getElementById('k-value').addEventListener('input', (e) => {
            kValue = parseInt(e.target.value) || 1;
            if (newPoint) classifyPoint(newPoint.x, newPoint.y);
            redraw();
        });
        
        // Reset button
        document.getElementById('reset-btn').addEventListener('click', () => {
            points.A = [];
            points.B = [];
            newPoint = null;
            nearestNeighbors = [];
            redraw();
        });
        
        // Generate random points
        document.getElementById('generate-random').addEventListener('click', () => {
            // Clear existing points
            points.A = [];
            points.B = [];
            newPoint = null;
            nearestNeighbors = [];
            
            // Generate random points for both classes
            for (let i = 0; i < 15; i++) {
                points.A.push({
                    x: Math.random() * (canvas.width - 40) + 20,
                    y: Math.random() * (canvas.height - 40) + 20
                });
                
                points.B.push({
                    x: Math.random() * (canvas.width - 40) + 20,
                    y: Math.random() * (canvas.height - 40) + 20
                });
            }
            
            redraw();
        });
        
        // Canvas click handler
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (currentMode === 'classify') {
                // Classify point
                newPoint = { x, y };
                classifyPoint(x, y);
            } else {
                // Add training point
                const point = { x, y };
                
                if (currentMode === 'A') {
                    points.A.push(point);
                } else if (currentMode === 'B') {
                    points.B.push(point);
                }
            }
            
            redraw();
        });
        
        // Mouse move for tooltip
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if mouse is over a point
            let overPoint = false;
            
            // Check class A points
            points.A.forEach(point => {
                const dist = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
                if (dist < 10) {
                    tooltip.innerHTML = `Class A<br>X: ${Math.round(point.x)}<br>Y: ${Math.round(point.y)}`;
                    tooltip.style.display = 'block';
                    tooltip.style.left = `${e.clientX + 10}px`;
                    tooltip.style.top = `${e.clientY + 10}px`;
                    overPoint = true;
                }
            });
            
            // Check class B points
            points.B.forEach(point => {
                const dist = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
                if (dist < 10) {
                    tooltip.innerHTML = `Class B<br>X: ${Math.round(point.x)}<br>Y: ${Math.round(point.y)}`;
                    tooltip.style.display = 'block';
                    tooltip.style.left = `${e.clientX + 10}px`;
                    tooltip.style.top = `${e.clientY + 10}px`;
                    overPoint = true;
                }
            });
            
            // Check new point
            if (newPoint) {
                const dist = Math.sqrt((newPoint.x - x) ** 2 + (newPoint.y - y) ** 2);
                if (dist < 10) {
                    tooltip.innerHTML = `New Point<br>X: ${Math.round(newPoint.x)}<br>Y: ${Math.round(newPoint.y)}<br>Classified as: ${newPoint.class || 'Not classified'}`;
                    tooltip.style.display = 'block';
                    tooltip.style.left = `${e.clientX + 10}px`;
                    tooltip.style.top = `${e.clientY + 10}px`;
                    overPoint = true;
                }
            }
            
            if (!overPoint) {
                tooltip.style.display = 'none';
            }
        });
        
        // Classify a point using KNN
        function classifyPoint(x, y) {
            // Combine all points
            const allPoints = [
                ...points.A.map(p => ({ ...p, class: 'A' })),
                ...points.B.map(p => ({ ...p, class: 'B' }))
            ];
            
            if (allPoints.length === 0) {
                newPoint.class = 'No training data';
                nearestNeighbors = [];
                return;
            }
            
            if (kValue > allPoints.length) {
                kValue = allPoints.length;
                document.getElementById('k-value').value = kValue;
            }
            
            // Calculate distances to all points
            const distances = allPoints.map(point => {
                const distance = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
                return { ...point, distance };
            });
            
            // Sort by distance
            distances.sort((a, b) => a.distance - b.distance);
            
            // Get K nearest neighbors
            nearestNeighbors = distances.slice(0, kValue);
            
            // Count votes for each class
            const votes = { A: 0, B: 0 };
            nearestNeighbors.forEach(neighbor => {
                votes[neighbor.class]++;
            });
            
            // Determine the class with majority vote
            if (votes.A > votes.B) {
                newPoint.class = 'A';
            } else if (votes.B > votes.A) {
                newPoint.class = 'B';
            } else {
                // In case of a tie, choose the class of the closest neighbor
                newPoint.class = nearestNeighbors[0].class;
            }
        }
        
        // Draw everything on the canvas
        function redraw() {
            // Clear canvas
            ctx.clearRect