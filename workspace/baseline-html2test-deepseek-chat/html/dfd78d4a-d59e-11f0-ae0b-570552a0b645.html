<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Nearest Neighbors (KNN) Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .header {
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .content {
            display: flex;
            gap: 20px;
        }
        .controls {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .visualization {
            flex: 2;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        canvas {
            border: 1px solid #ddd;
            background-color: #fafafa;
            cursor: crosshair;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="range"] {
            width: 100%;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        .value-display {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
        }
        .explanation {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            line-height: 1.6;
        }
        .class-legends {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>K-Nearest Neighbors (KNN) Algorithm Visualization</h1>
            <p>Click on the canvas to add data points. Set the K value and test point to see how KNN classifies new data.</p>
        </div>
        
        <div class="content">
            <div class="controls">
                <div class="form-group">
                    <label for="kValue">K Value (Number of Neighbors): <span id="kValueDisplay">3</span></label>
                    <input type="range" id="kValue" min="1" max="15" value="3">
                </div>
                
                <div class="form-group">
                    <label for="testX">Test Point X Coordinate: <span id="testXDisplay">250</span></label>
                    <input type="range" id="testX" min="0" max="500" value="250">
                </div>
                
                <div class="form-group">
                    <label for="testY">Test Point Y Coordinate: <span id="testYDisplay">250</span></label>
                    <input type="range" id="testY" min="0" max="500" value="250">
                </div>
                
                <div class="form-group">
                    <label>Current Class:</label>
                    <button id="classA">Class A (Red)</button>
                    <button id="classB">Class B (Blue)</button>
                    <button id="clear">Clear Points</button>
                </div>
                
                <div class="form-group">
                    <button id="classify">Classify Test Point</button>
                    <button id="autoClassify">Auto Classify Entire Space</button>
                </div>
                
                <div class="class-legends">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff4444;"></div>
                        <span>Class A</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #4444ff;"></div>
                        <span>Class B</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #44ff44;"></div>
                        <span>Test Point</span>
                    </div>
                </div>
                
                <div id="result" style="margin-top: 20px; font-weight: bold; min-height: 40px;"></div>
            </div>
            
            <div class="visualization">
                <canvas id="knnCanvas" width="500" height="500"></canvas>
            </div>
        </div>
        
        <div class="explanation">
            <h2>How K-Nearest Neighbors Works</h2>
            <p>The K-Nearest Neighbors (KNN) algorithm is a simple, instance-based learning algorithm used for classification and regression.</p>
            
            <h3>Key Concepts:</h3>
            <ul>
                <li><strong>K Value:</strong> The number of nearest neighbors to consider when classifying a new data point.</li>
                <li><strong>Distance Metric:</strong> KNN typically uses Euclidean distance to find the closest neighbors.</li>
                <li><strong>Majority Voting:</strong> The class with the most representatives among the K nearest neighbors determines the classification.</li>
            </ul>
            
            <h3>Steps in KNN:</h3>
            <ol>
                <li>Store all training data points with their known classifications.</li>
                <li>When a new data point needs classification, calculate its distance to all stored points.</li>
                <li>Select the K points with the smallest distances to the new point.</li>
                <li>Determine the majority class among these K neighbors.</li>
                <li>Assign the majority class to the new data point.</li>
            </ol>
            
            <p>Try different K values to see how it affects the classification boundaries. Smaller K values create more complex boundaries, while larger K values create smoother boundaries.</p>
        </div>
    </div>

    <script>
        // Canvas and context
        const canvas = document.getElementById('knnCanvas');
        const ctx = canvas.getContext('2d');
        
        // Data structures
        let points = {
            classA: [],
            classB: []
        };
        let currentClass = 'classA';
        let testPoint = { x: 250, y: 250 };
        
        // UI elements
        const kValueSlider = document.getElementById('kValue');
        const kValueDisplay = document.getElementById('kValueDisplay');
        const testXSlider = document.getElementById('testX');
        const testXDisplay = document.getElementById('testXDisplay');
        const testYSlider = document.getElementById('testY');
        const testYDisplay = document.getElementById('testYDisplay');
        const classAButton = document.getElementById('classA');
        const classBButton = document.getElementById('classB');
        const clearButton = document.getElementById('clear');
        const classifyButton = document.getElementById('classify');
        const autoClassifyButton = document.getElementById('autoClassify');
        const resultDiv = document.getElementById('result');
        
        // Initialize
        function init() {
            // Set up event listeners
            canvas.addEventListener('click', handleCanvasClick);
            kValueSlider.addEventListener('input', updateKValue);
            testXSlider.addEventListener('input', updateTestPoint);
            testYSlider.addEventListener('input', updateTestPoint);
            classAButton.addEventListener('click', () => setCurrentClass('classA'));
            classBButton.addEventListener('click', () => setCurrentClass('classB'));
            clearButton.addEventListener('click', clearPoints);
            classifyButton.addEventListener('click', classifyTestPoint);
            autoClassifyButton.addEventListener('click', autoClassifySpace);
            
            // Initialize displays
            updateKValue();
            updateTestPoint();
            
            // Draw initial state
            drawCanvas();
        }
        
        // Handle canvas clicks to add points
        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            points[currentClass].push({ x, y });
            drawCanvas();
        }
        
        // Update K value display
        function updateKValue() {
            const k = parseInt(kValueSlider.value);
            kValueDisplay.textContent = k;
            drawCanvas();
        }
        
        // Update test point position
        function updateTestPoint() {
            testPoint.x = parseInt(testXSlider.value);
            testPoint.y = parseInt(testYSlider.value);
            testXDisplay.textContent = testPoint.x;
            testYDisplay.textContent = testPoint.y;
            drawCanvas();
        }
        
        // Set current class for new points
        function setCurrentClass(className) {
            currentClass = className;
            classAButton.style.backgroundColor = (className === 'classA') ? '#45a049' : '#4CAF50';
            classBButton.style.backgroundColor = (className === 'classB') ? '#45a049' : '#4CAF50';
        }
        
        // Clear all points
        function clearPoints() {
            points.classA = [];
            points.classB = [];
            resultDiv.textContent = '';
            drawCanvas();
        }
        
        // Calculate Euclidean distance between two points
        function calculateDistance(point1, point2) {
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Classify the test point using KNN
        function classifyTestPoint() {
            const k = parseInt(kValueSlider.value);
            
            if (points.classA.length + points.classB.length < k) {
                resultDiv.textContent = `Need at least ${k} points to classify with K=${k}`;
                return;
            }
            
            // Calculate distances to all points
            const distances = [];
            
            points.classA.forEach(point => {
                distances.push({
                    point,
                    distance: calculateDistance(testPoint, point),
                    class: 'classA'
                });
            });
            
            points.classB.forEach(point => {
                distances.push({
                    point,
                    distance: calculateDistance(testPoint, point),
                    class: 'classB'
                });
            });
            
            // Sort by distance and get K nearest neighbors
            distances.sort((a, b) => a.distance - b.distance);
            const nearestNeighbors = distances.slice(0, k);
            
            // Count votes for each class
            const votes = { classA: 0, classB: 0 };
            nearestNeighbors.forEach(neighbor => {
                votes[neighbor.class]++;
            });
            
            // Determine the predicted class
            let predictedClass;
            if (votes.classA > votes.classB) {
                predictedClass = 'Class A';
            } else if (votes.classB > votes.classA) {
                predictedClass = 'Class B';
            } else {
                predictedClass = 'Tie (random choice)';
            }
            
            // Display results
            resultDiv.innerHTML = `
                <p>Predicted Class: <strong>${predictedClass}</strong></p>
                <p>Votes: Class A = ${votes.classA}, Class B = ${votes.classB}</p>
            `;
            
            // Redraw canvas to show neighbors
            drawCanvas(nearestNeighbors);
        }
        
        // Auto-classify the entire space (creates a decision boundary)
        function autoClassifySpace() {
            const k = parseInt(kValueSlider.value);
            
            if (points.classA.length + points.classB.length < k) {
                resultDiv.textContent = `Need at least ${k} points to classify with K=${k}`;
                return;
            }
            
            // Create a grid and classify each point
            const cellSize = 10;
            const width = canvas.width;
            const height = canvas.height;
            
            // Draw the background with classification colors
            for (let x = 0; x < width; x += cellSize) {
                for (let y = 0; y < height; y += cellSize) {
                    const gridPoint = { x: x + cellSize/2, y: y + cellSize/2 };
                    
                    // Calculate distances to all points
                    const distances = [];
                    
                    points.classA.forEach(point => {
                        distances.push({
                            point,
                            distance: calculateDistance(gridPoint, point),
                            class: 'classA'
                        });
                    });
                    
                    points.classB.forEach(point => {
                        distances.push({
                            point,
                            distance: calculateDistance(gridPoint, point),
                            class: 'classB'
                        });
                    });
                    
                    // Sort by distance and get K nearest neighbors
                    distances.sort((a, b) => a.distance - b.distance);
                    const nearestNeighbors = distances.slice(0, k);
                    
                    // Count votes for each class
                    const votes = { classA: 0, classB: 0 };
                    nearestNeighbors.forEach(neighbor => {
                        votes[neighbor.class]++;
                    });
                    
                    // Determine the color based on majority vote
                    let color;
                    if (votes.classA > votes.classB) {
                        color = 'rgba(255, 100, 100, 0.2)'; // Light red for class A
                    } else {
                        color = 'rgba(100, 100, 255, 0.2)'; // Light blue for class B
                    }
                    
                    // Draw the cell
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, cellSize, cellSize);
                }
            }
            
            // Redraw points on top
            drawPoints();
            drawTestPoint();
        }
        
        // Draw the canvas with all points and test point
        function drawCanvas(neighbors = []) {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw points
            drawPoints();
            
            // Highlight neighbors if provided
            if (neighbors.length > 0) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                
                neighbors.forEach(neighbor => {
                    ctx.beginPath();
                    ctx.arc(neighbor.point.x, neighbor.point.y, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw line to test point
                    ctx.beginPath();
                    ctx.moveTo(testPoint.x, testPoint.y);
                    ctx.lineTo(neighbor.point.x, neighbor.point.y);
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.stroke();
                });
            }
            
            // Draw test point
            drawTestPoint();
        }
        
        // Draw all data points
        function drawPoints() {
            // Draw class A points (red)
            ctx.fillStyle = '#ff4444';
            points.classA.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw class B points (blue)
            ctx.fillStyle = '#4444ff';
            points.classB.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Draw the test point
        function drawTestPoint() {
            ctx.fillStyle = '#44ff44';
            ctx.beginPath();
            ctx.arc(testPoint.x, testPoint.y, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Add a black border to make it more visible
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // Initialize the application
        init();
    </script>
</body>
</html>