<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floyd-Warshall Algorithm Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 60px;
        }
        
        .grid-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .matrix-container {
            flex: 1;
            min-width: 300px;
        }
        
        .graph-container {
            flex: 1;
            min-width: 400px;
        }
        
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 20px;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
            min-width: 40px;
        }
        
        th {
            background-color: #f2f2f2;
        }
        
        .current {
            background-color: #3498db;
            color: white;
        }
        
        .updated {
            background-color: #2ecc71;
            color: white;
            animation: highlight 1s ease;
        }
        
        @keyframes highlight {
            0% { background-color: #f1c40f; }
            100% { background-color: #2ecc71; }
        }
        
        .info-panel {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }
        
        .step-info {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .canvas-container {
            text-align: center;
            margin-top: 20px;
        }
        
        canvas {
            border: 1px solid #ddd;
            background-color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Floyd-Warshall Algorithm Visualization</h1>
        
        <div class="controls">
            <button id="resetBtn">Reset</button>
            <button id="stepBtn">Step</button>
            <button id="runBtn">Run All</button>
            <button id="pauseBtn" disabled>Pause</button>
            <label>Speed: <input type="number" id="speed" min="100" max="2000" value="500">ms</label>
            <label>Vertex Count: <input type="number" id="vertexCount" min="3" max="8" value="4"></label>
        </div>
        
        <div class="grid-container">
            <div class="matrix-container">
                <h3>Distance Matrix</h3>
                <div id="matrix"></div>
            </div>
            
            <div class="graph-container">
                <h3>Graph Visualization</h3>
                <div class="canvas-container">
                    <canvas id="graphCanvas" width="400" height="300"></canvas>
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <div class="step-info" id="stepInfo">Initial state</div>
            <div id="algorithmInfo">
                The Floyd-Warshall algorithm finds the shortest paths between all pairs of vertices in a weighted graph.
                It works for both directed and undirected graphs, and can handle negative weights (but not negative cycles).
            </div>
        </div>
    </div>

    <script>
        class FloydWarshall {
            constructor(vertexCount = 4) {
                this.vertexCount = vertexCount;
                this.distances = [];
                this.step = 0;
                this.k = 0;
                this.i = 0;
                this.j = 0;
                this.isRunning = false;
                this.intervalId = null;
                this.speed = 500;
                
                this.initMatrix();
            }
            
            initMatrix() {
                // Initialize with Infinity (no path) and 0 on diagonal
                this.distances = [];
                for (let i = 0; i < this.vertexCount; i++) {
                    this.distances[i] = [];
                    for (let j = 0; j < this.vertexCount; j++) {
                        if (i === j) {
                            this.distances[i][j] = 0;
                        } else {
                            this.distances[i][j] = Infinity;
                        }
                    }
                }
                
                // Add some random edges
                this.addRandomEdges();
                
                this.step = 0;
                this.k = 0;
                this.i = 0;
                this.j = 0;
            }
            
            addRandomEdges() {
                // Clear existing edges (except diagonal)
                for (let i = 0; i < this.vertexCount; i++) {
                    for (let j = 0; j < this.vertexCount; j++) {
                        if (i !== j) {
                            this.distances[i][j] = Infinity;
                        }
                    }
                }
                
                // Add random edges (approximately 50% of possible edges)
                const maxEdges = Math.floor(this.vertexCount * (this.vertexCount - 1) / 2);
                const edgeCount = Math.floor(maxEdges * 0.5) + 1;
                
                for (let e = 0; e < edgeCount; e++) {
                    let i, j;
                    do {
                        i = Math.floor(Math.random() * this.vertexCount);
                        j = Math.floor(Math.random() * this.vertexCount);
                    } while (i === j || this.distances[i][j] !== Infinity);
                    
                    this.distances[i][j] = Math.floor(Math.random() * 10) + 1;
                    
                    // For undirected graph, add reverse edge (comment out for directed)
                    this.distances[j][i] = this.distances[i][j];
                }
            }
            
            nextStep() {
                if (this.k >= this.vertexCount) {
                    return false; // Algorithm complete
                }
                
                if (this.i >= this.vertexCount) {
                    this.k++;
                    this.i = 0;
                    this.j = 0;
                    return this.k < this.vertexCount;
                }
                
                if (this.j >= this.vertexCount) {
                    this.i++;
                    this.j = 0;
                    return this.i < this.vertexCount;
                }
                
                // Floyd-Warshall algorithm step
                if (this.distances[this.i][this.k] + this.distances[this.k][this.j] < this.distances[this.i][this.j]) {
                    this.distances[this.i][this.j] = this.distances[this.i][this.k] + this.distances[this.k][this.j];
                    
                    // Return the updated cell for highlighting
                    return {
                        updated: true,
                        i: this.i,
                        j: this.j,
                        k: this.k
                    };
                }
                
                this.j++;
                this.step++;
                return { updated: false, i: this.i, j: this.j, k: this.k };
            }
            
            reset() {
                this.initMatrix();
            }
            
            setVertexCount(count) {
                this.vertexCount = Math.max(3, Math.min(8, count));
                this.reset();
            }
            
            setSpeed(speed) {
                this.speed = Math.max(100, Math.min(2000, speed));
                if (this.isRunning) {
                    this.stop();
                    this.start();
                }
            }
            
            start() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.intervalId = setInterval(() => {
                    if (!this.nextStep()) {
                        this.stop();
                    }
                    this.updateDisplay();
                }, this.speed);
            }
            
            stop() {
                this.isRunning = false;
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                    this.intervalId = null;
                }
            }
        }
        
        // Initialize the application
        const floydWarshall = new FloydWarshall();
        
        // DOM elements
        const matrixElement = document.getElementById('matrix');
        const stepInfoElement = document.getElementById('stepInfo');
        const resetBtn = document.getElementById('resetBtn');
        const stepBtn = document.getElementById('stepBtn');
        const runBtn = document.getElementById('runBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const speedInput = document.getElementById('speed');
        const vertexCountInput = document.getElementById('vertexCount');
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        
        // Initialize display
        updateDisplay();
        
        // Event listeners
        resetBtn.addEventListener('click', () => {
            floydWarshall.reset();
            updateDisplay();
        });
        
        stepBtn.addEventListener('click', () => {
            floydWarshall.nextStep();
            updateDisplay();
        });
        
        runBtn.addEventListener('click', () => {
            floydWarshall.start();
            updateButtons();
        });
        
        pauseBtn.addEventListener('click', () => {
            floydWarshall.stop();
            updateButtons();
        });
        
        speedInput.addEventListener('change', () => {
            floydWarshall.setSpeed(parseInt(speedInput.value));
        });
        
        vertexCountInput.addEventListener('change', () => {
            floydWarshall.setVertexCount(parseInt(vertexCountInput.value));
            updateDisplay();
        });
        
        function updateButtons() {
            runBtn.disabled = floydWarshall.isRunning;
            pauseBtn.disabled = !floydWarshall.isRunning;
        }
        
        function updateDisplay() {
            updateMatrixDisplay();
            updateStepInfo();
            drawGraph();
            updateButtons();
        }
        
        function updateMatrixDisplay() {
            let html = '<table><tr><th></th>';
            
            // Header row
            for (let i = 0; i < floydWarshall.vertexCount; i++) {
                html += `<th>${String.fromCharCode(65 + i)}</th>`;
            }
            html += '</tr>';
            
            // Data rows
            for (let i = 0; i < floydWarshall.vertexCount; i++) {
                html += `<tr><th>${String.fromCharCode(65 + i)}</th>`;
                for (let j = 0; j < floydWarshall.vertexCount; j++) {
                    let cellClass = '';
                    
                    if (i === floydWarshall.i && j === floydWarshall.j) {
                        cellClass = 'current';
                    } else if (i === floydWarshall.k || j === floydWarshall.k) {
                        // Highlight row and column of vertex k
                        cellClass = 'highlight';
                    }
                    
                    const value = floydWarshall.distances[i][j] === Infinity ? 'âˆž' : floydWarshall.distances[i][j];
                    html += `<td class="${cellClass}">${value}</td>`;
                }
                html += '</tr>';
            }
            html += '</table>';
            
            matrixElement.innerHTML = html;
        }
        
        function updateStepInfo() {
            if (floydWarshall.k >= floydWarshall.vertexCount) {
                stepInfoElement.textContent = 'Algorithm complete! All shortest paths calculated.';
            } else {
                stepInfoElement.textContent = 
                    `Step ${floydWarshall.step}: Checking path from ${String.fromCharCode(65 + floydWarshall.i)} to ${String.fromCharCode(65 + floydWarshall.j)} via ${String.fromCharCode(65 + floydWarshall.k)}`;
            }
        }
        
        function drawGraph() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Calculate vertex positions in a circle
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 50;
            
            const vertexPositions = [];
            for (let i = 0; i < floydWarshall.vertexCount; i++) {
                const angle = (2 * Math.PI * i) / floydWarshall.vertexCount - Math.PI / 2;
                vertexPositions[i] = {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            }
            
            // Draw edges
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.font = '12px Arial';
            ctx.fillStyle = '#2c3e50';
            
            for (let i = 0; i < floydWarshall.vertexCount; i++) {
                for (let j = 0; j < floydWarshall.vertexCount; j++) {
                    if (i !== j && floydWarshall.distances[i][j] !== Infinity) {
                        // Highlight current edge being considered
                        if ((i === floydWarshall.i && j === floydWarshall.j) || 
                            (i === floydWarshall.i && j === floydWarshall.k) || 
                            (i === floydWarshall.k && j === floydWarshall.j)) {
                            ctx.strokeStyle = '#e74c3c';
                            ctx.lineWidth = 3;
                        } else {
                            ctx.strokeStyle = '#3498db';
                            ctx.lineWidth = 2;
                        }
                        
                        const start = vertexPositions[i];
                        const end = vertexPositions[j];
                        
                        // Draw arrow
                        drawArrow(ctx, start.x, start.y, end.x, end.y);
                        
                        // Draw weight
                        const midX = (start.x + end.x) / 2;
                        const midY = (start.y + end.y) / 2;
                        
                        ctx.fillStyle = 'white';
                        ctx.fillRect(midX - 15, midY - 10, 30, 20);
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillText(floydWarshall.distances[i][j], midX - 5, midY + 5);
                    }
                }
            }
            
            // Draw vertices
            for (let i = 0; i < floydWarshall.vertexCount; i++) {
                const pos = vertexPositions[i];
                
                // Highlight current vertex k
                if (i === floydWarshall.k) {
                    ctx.fillStyle = '#e74c3c';
                } else if (i === floydWarshall.i || i === floydWarshall.j) {
                    ctx.fillStyle = '#f39c12';
                } else {
                    ctx.fillStyle = '#2ecc71';
                }
                
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 20, 0, 2 * Math.PI);
                ctx.fill();
                
                // Vertex label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(String.fromCharCode(65 + i), pos.x, pos.y);
            }
        }
        
        function drawArrow(ctx, fromX, fromY, toX, toY) {
            const headlen = 10;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            
            // Draw line
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            // Draw arrowhead
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI/6), toY - headlen * Math.sin(angle - Math.PI/6));
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI/6), toY - headlen * Math.sin(angle + Math.PI/6));
            ctx.stroke();
        }
    </script>
</body>
</html>