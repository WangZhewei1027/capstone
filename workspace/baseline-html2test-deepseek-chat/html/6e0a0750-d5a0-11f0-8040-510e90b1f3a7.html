<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huffman Coding Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .input-section, .output-section {
            margin-bottom: 20px;
        }
        textarea {
            width: 100%;
            height: 80px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
            white-space: pre-wrap;
        }
        .tree-visualization {
            margin-top: 20px;
            overflow-x: auto;
        }
        .node {
            display: inline-block;
            padding: 10px;
            margin: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #e9e9e9;
            text-align: center;
            min-width: 80px;
        }
        .leaf {
            background-color: #c9e7ff;
        }
        .frequency {
            font-weight: bold;
        }
        .character {
            font-size: 12px;
            color: #666;
        }
        .code {
            font-family: monospace;
            background-color: #f0f0f0;
            padding: 2px 5px;
            border-radius: 3px;
        }
        .compression-stats {
            margin-top: 15px;
            padding: 10px;
            background-color: #e7f3ff;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Huffman Coding Demo</h1>
        
        <div class="input-section">
            <h3>Enter text to encode:</h3>
            <textarea id="inputText" placeholder="Enter some text here...">Hello, World!</textarea>
            <br><br>
            <button onclick="encodeText()">Encode Text</button>
            <button onclick="decodeText()">Decode Text</button>
            <button onclick="clearAll()">Clear</button>
        </div>
        
        <div class="output-section">
            <h3>Results:</h3>
            <div id="output" class="result"></div>
            <div id="tree" class="tree-visualization"></div>
            <div id="stats" class="compression-stats"></div>
        </div>
    </div>

    <script>
        class HuffmanNode {
            constructor(character, frequency) {
                this.character = character;
                this.frequency = frequency;
                this.left = null;
                this.right = null;
            }
        }

        class HuffmanCoding {
            constructor() {
                this.codes = {};
                this.reverseCodes = {};
                this.root = null;
            }

            buildFrequencyTable(text) {
                const frequency = {};
                for (let char of text) {
                    frequency[char] = (frequency[char] || 0) + 1;
                }
                return frequency;
            }

            buildTree(frequency) {
                const nodes = [];
                
                for (let char in frequency) {
                    nodes.push(new HuffmanNode(char, frequency[char]));
                }

                while (nodes.length > 1) {
                    nodes.sort((a, b) => a.frequency - b.frequency);
                    
                    const left = nodes.shift();
                    const right = nodes.shift();
                    
                    const parent = new HuffmanNode(null, left.frequency + right.frequency);
                    parent.left = left;
                    parent.right = right;
                    
                    nodes.push(parent);
                }
                
                this.root = nodes[0];
                return this.root;
            }

            generateCodes(node = this.root, code = '') {
                if (node.character !== null) {
                    this.codes[node.character] = code;
                    this.reverseCodes[code] = node.character;
                    return;
                }
                
                if (node.left) {
                    this.generateCodes(node.left, code + '0');
                }
                
                if (node.right) {
                    this.generateCodes(node.right, code + '1');
                }
            }

            encode(text) {
                this.codes = {};
                this.reverseCodes = {};
                
                const frequency = this.buildFrequencyTable(text);
                this.buildTree(frequency);
                this.generateCodes();
                
                let encoded = '';
                for (let char of text) {
                    encoded += this.codes[char];
                }
                
                return encoded;
            }

            decode(encodedText) {
                let current = this.root;
                let decoded = '';
                
                for (let bit of encodedText) {
                    current = bit === '0' ? current.left : current.right;
                    
                    if (current.character !== null) {
                        decoded += current.character;
                        current = this.root;
                    }
                }
                
                return decoded;
            }

            getTreeVisualization() {
                return this._visualizeTree(this.root);
            }

            _visualizeTree(node, depth = 0) {
                if (!node) return '';
                
                const indent = '  '.repeat(depth);
                let visualization = '';
                
                if (node.character !== null) {
                    visualization += `${indent}Char: '${node.character === ' ' ? 'SPACE' : node.character}' Freq: ${node.frequency}\n`;
                } else {
                    visualization += `${indent}Node Freq: ${node.frequency}\n`;
                }
                
                if (node.left) {
                    visualization += `${indent}Left:\n${this._visualizeTree(node.left, depth + 1)}`;
                }
                
                if (node.right) {
                    visualization += `${indent}Right:\n${this._visualizeTree(node.right, depth + 1)}`;
                }
                
                return visualization;
            }

            getCompressionStats(originalText, encodedText) {
                const originalBits = originalText.length * 8;
                const encodedBits = encodedText.length;
                const compressionRatio = ((originalBits - encodedBits) / originalBits * 100).toFixed(2);
                
                return {
                    originalSize: originalBits,
                    compressedSize: encodedBits,
                    compressionRatio: compressionRatio,
                    averageCodeLength: (encodedBits / originalText.length).toFixed(2)
                };
            }
        }

        const huffman = new HuffmanCoding();

        function encodeText() {
            const inputText = document.getElementById('inputText').value;
            if (!inputText.trim()) {
                alert('Please enter some text to encode.');
                return;
            }

            const encoded = huffman.encode(inputText);
            const decoded = huffman.decode(encoded);
            const stats = huffman.getCompressionStats(inputText, encoded);

            let output = `Original Text: "${inputText}"\n\n`;
            output += `Character Frequencies:\n`;
            
            const frequency = huffman.buildFrequencyTable(inputText);
            for (let char in frequency) {
                const displayChar = char === ' ' ? 'SPACE' : char;
                output += `  '${displayChar}': ${frequency[char]} (Code: ${huffman.codes[char]})\n`;
            }
            
            output += `\nEncoded Binary: ${encoded}\n`;
            output += `Decoded Text: "${decoded}"\n`;
            output += `Verification: ${inputText === decoded ? '✓ Success' : '✗ Failed'}\n\n`;

            output += `Compression Statistics:\n`;
            output += `  Original Size: ${stats.originalSize} bits\n`;
            output += `  Compressed Size: ${stats.compressedSize} bits\n`;
            output += `  Compression Ratio: ${stats.compressionRatio}%\n`;
            output += `  Average Code Length: ${stats.averageCodeLength} bits/character\n`;

            document.getElementById('output').textContent = output;
            
            // Display tree visualization
            document.getElementById('tree').innerHTML = '<h4>Huffman Tree:</h4>' + 
                '<pre>' + huffman.getTreeVisualization() + '</pre>';
            
            // Display binary representation
            displayBinaryCodes(huffman.codes);
        }

        function decodeText() {
            const encodedText = prompt('Enter the binary string to decode:');
            if (!encodedText || !/^[01]+$/.test(encodedText)) {
                alert('Please enter a valid binary string (only 0s and 1s).');
                return;
            }

            try {
                const decoded = huffman.decode(encodedText);
                document.getElementById('output').textContent = 
                    `Encoded Binary: ${encodedText}\nDecoded Text: "${decoded}"`;
            } catch (error) {
                alert('Error decoding: ' + error.message);
            }
        }

        function displayBinaryCodes(codes) {
            let html = '<h4>Binary Codes:</h4><div class="codes-container">';
            for (let char in codes) {
                const displayChar = char === ' ' ? 'SPACE' : char;
                html += `<div class="node leaf">
                    <div class="character">'${displayChar}'</div>
                    <div class="code">${codes[char]}</div>
                </div>`;
            }
            html += '</div>';
            
            const statsDiv = document.getElementById('stats');
            statsDiv.innerHTML = html;
        }

        function clearAll() {
            document.getElementById('inputText').value = '';
            document.getElementById('output').textContent = '';
            document.getElementById('tree').innerHTML = '';
            document.getElementById('stats').innerHTML = '';
        }

        // Initialize with example
        document.getElementById('inputText').value = "Huffman coding is a lossless data compression algorithm.";
    </script>
</body>
</html>