<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Priority Queue Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .controls {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        input {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .queue-display {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            min-height: 200px;
        }
        .priority-item {
            display: inline-block;
            padding: 10px 15px;
            margin: 5px;
            background-color: #e0e0e0;
            border-radius: 5px;
            position: relative;
            transition: transform 0.3s, background-color 0.3s;
        }
        .priority-item.high {
            background-color: #ff5252;
            color: white;
        }
        .priority-item.medium {
            background-color: #ffb142;
            color: white;
        }
        .priority-item.low {
            background-color: #2ed573;
            color: white;
        }
        .priority-item.current {
            animation: pulse 1s infinite;
            transform: scale(1.05);
        }
        .priority-value {
            font-weight: bold;
            font-size: 18px;
        }
        .priority-label {
            font-size: 12px;
            margin-top: 5px;
        }
        .explanation {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0,0,0,0.2); }
            70% { box-shadow: 0 0 0 10px rgba(0,0,0,0); }
            100% { box-shadow: 0 0 0 0 rgba(0,0,0,0); }
        }
    </style>
</head>
<body>
    <h1>Priority Queue Visualization</h1>
    
    <div class="container">
        <div class="controls">
            <h3>Add Element</h3>
            <input type="text" id="elementValue" placeholder="Element value">
            <select id="prioritySelect">
                <option value="high">High Priority</option>
                <option value="medium" selected>Medium Priority</option>
                <option value="low">Low Priority</option>
            </select>
            <button id="addBtn">Add to Queue</button>
            
            <h3>Queue Operations</h3>
            <button id="removeBtn">Remove Highest Priority</button>
            <button id="clearBtn">Clear Queue</button>
        </div>
        
        <div class="queue-display" id="queueDisplay">
            <div id="queueContent"></div>
        </div>
        
        <div class="explanation">
            <h3>About Priority Queues</h3>
            <p>A priority queue is an abstract data type where each element has a "priority" associated with it. In a priority queue, an element with high priority is served before an element with low priority.</p>
            <p><strong>Implementation:</strong> This visualization uses a binary heap implementation which provides O(log n) time complexity for insertion and extraction of the highest priority element.</p>
            <p><strong>Priority Levels:</strong> High priority items (red) are processed first, followed by medium (orange), then low (green). Items with the same priority are processed in the order they were added (FIFO).</p>
        </div>
    </div>

    <script>
        class PriorityQueue {
            constructor() {
                this.heap = [];
            }

            // Helper function to get parent index
            parent(index) {
                return Math.floor((index - 1) / 2);
            }

            // Helper function to get left child index
            leftChild(index) {
                return 2 * index + 1;
            }

            // Helper function to get right child index
            rightChild(index) {
                return 2 * index + 2;
            }

            // Checks if the heap is empty
            isEmpty() {
                return this.heap.length === 0;
            }

            // Returns the size of the heap
            size() {
                return this.heap.length;
            }

            // Gets the priority value for comparison
            getPriorityValue(priority) {
                const priorityMap = {
                    'high': 3,
                    'medium': 2,
                    'low': 1
                };
                return priorityMap[priority];
            }

            // Adds an element to the priority queue
            enqueue(value, priority) {
                const priorityValue = this.getPriorityValue(priority);
                const element = { value, priority, priorityValue };
                this.heap.push(element);
                this.heapifyUp(this.heap.length - 1);
            }

            // Removes and returns the element with the highest priority
            dequeue() {
                if (this.isEmpty()) {
                    return null;
                }

                if (this.heap.length === 1) {
                    return this.heap.pop();
                }

                const max = this.heap[0];
                this.heap[0] = this.heap.pop();
                this.heapifyDown(0);
                return max;
            }

            // Returns the element with the highest priority without removing it
            peek() {
                return this.isEmpty() ? null : this.heap[0];
            }

            // Moves an element up the heap to maintain the heap property
            heapifyUp(index) {
                let currentIndex = index;
                while (
                    currentIndex > 0 &&
                    this.heap[currentIndex].priorityValue > this.heap[this.parent(currentIndex)].priorityValue
                ) {
                    this.swap(currentIndex, this.parent(currentIndex));
                    currentIndex = this.parent(currentIndex);
                }
            }

            // Moves an element down the heap to maintain the heap property
            heapifyDown(index) {
                let currentIndex = index;
                let maxIndex = index;

                const left = this.leftChild(currentIndex);
                const right = this.rightChild(currentIndex);

                if (left < this.heap.length && this.heap[left].priorityValue > this.heap[maxIndex].priorityValue) {
                    maxIndex = left;
                }

                if (right < this.heap.length && this.heap[right].priorityValue > this.heap[maxIndex].priorityValue) {
                    maxIndex = right;
                }

                if (currentIndex !== maxIndex) {
                    this.swap(currentIndex, maxIndex);
                    this.heapifyDown(maxIndex);
                }
            }

            // Swaps two elements in the heap
            swap(i, j) {
                [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
            }

            // Returns a copy of the heap for display purposes
            toArray() {
                return [...this.heap];
            }
        }

        // Initialize the priority queue
        const priorityQueue = new PriorityQueue();

        // DOM elements
        const elementValueInput = document.getElementById('elementValue');
        const prioritySelect = document.getElementById('prioritySelect');
        const addBtn = document.getElementById('addBtn');
        const removeBtn = document.getElementById('removeBtn');
        const clearBtn = document.getElementById('clearBtn');
        const queueContent = document.getElementById('queueContent');

        // Render the queue
        function renderQueue() {
            queueContent.innerHTML = '';
            
            if (priorityQueue.isEmpty()) {
                queueContent.innerHTML = '<p>Queue is empty. Add some elements!</p>';
                return;
            }

            const queueArray = priorityQueue.toArray();
            
            queueArray.forEach((item, index) => {
                const itemElement = document.createElement('div');
                itemElement.className = `priority-item ${item.priority}`;
                itemElement.innerHTML = `
                    <div class="priority-value">${item.value}</div>
                    <div class="priority-label">${item.priority}</div>
                `;
                
                // Highlight the first element (highest priority)
                if (index === 0) {
                    itemElement.classList.add('current');
                }
                
                queueContent.appendChild(itemElement);
            });
        }

        // Add element to the queue
        addBtn.addEventListener('click', () => {
            const value = elementValueInput.value.trim();
            const priority = prioritySelect.value;
            
            if (!value) {
                alert('Please enter a value for the element.');
                return;
            }
            
            priorityQueue.enqueue(value, priority);
            elementValueInput.value = '';
            renderQueue();
            
            // Brief animation for newly added element
            const items = document.querySelectorAll('.priority-item');
            if (items.length > 0) {
                const lastItem = items[items.length - 1];
                lastItem.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    lastItem.style.transform = 'scale(1)';
                }, 300);
            }
        });

        // Remove highest priority element
        removeBtn.addEventListener('click', () => {
            if (priorityQueue.isEmpty()) {
                alert('Queue is empty!');
                return;
            }
            
            const removed = priorityQueue.dequeue();
            alert(`Removed: ${removed.value} (${removed.priority} priority)`);
            renderQueue();
        });

        // Clear the queue
        clearBtn.addEventListener('click', () => {
            while (!priorityQueue.isEmpty()) {
                priorityQueue.dequeue();
            }
            renderQueue();
        });

        // Allow Enter key to add elements
        elementValueInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addBtn.click();
            }
        });

        // Initial render
        renderQueue();
    </script>
</body>
</html>