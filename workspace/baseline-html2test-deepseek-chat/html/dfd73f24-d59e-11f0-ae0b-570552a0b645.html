<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weighted Graph Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .canvas-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        canvas {
            border: 1px solid #ddd;
            background: #fafafa;
        }
        button {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background: #45a049;
        }
        input {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .info {
            margin-top: 20px;
            padding: 15px;
            background: #e7f3ff;
            border-radius: 4px;
            border-left: 4px solid #2196F3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Weighted Graph Visualization</h1>
        
        <div class="controls">
            <h3>Graph Controls</h3>
            <div>
                <input type="text" id="node1" placeholder="Node 1" value="A">
                <input type="text" id="node2" placeholder="Node 2" value="B">
                <input type="number" id="weight" placeholder="Weight" value="5" min="1" max="100">
                <button onclick="addEdge()">Add Edge</button>
                <button onclick="addNode()">Add Node</button>
                <button onclick="clearGraph()">Clear Graph</button>
            </div>
            <div style="margin-top: 10px;">
                <button onclick="findShortestPath()">Find Shortest Path</button>
                <input type="text" id="startNode" placeholder="Start Node" value="A">
                <input type="text" id="endNode" placeholder="End Node" value="C">
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="graphCanvas" width="800" height="500"></canvas>
        </div>

        <div class="info">
            <h3>About Weighted Graphs</h3>
            <p>A weighted graph is a graph where each edge has a numerical value (weight) associated with it. 
            Weights can represent distances, costs, capacities, or other quantities.</p>
            <p><strong>Common applications:</strong> Network routing, GPS navigation, social network analysis, 
            project scheduling, and optimization problems.</p>
        </div>
    </div>

    <script>
        class WeightedGraph {
            constructor() {
                this.nodes = new Set();
                this.edges = new Map();
                this.positions = new Map();
            }

            addNode(node) {
                if (!this.nodes.has(node)) {
                    this.nodes.add(node);
                    this.edges.set(node, new Map());
                    // Assign random position for visualization
                    this.positions.set(node, {
                        x: Math.random() * 700 + 50,
                        y: Math.random() * 400 + 50
                    });
                }
            }

            addEdge(node1, node2, weight) {
                this.addNode(node1);
                this.addNode(node2);
                
                this.edges.get(node1).set(node2, weight);
                this.edges.get(node2).set(node1, weight); // Undirected graph
            }

            getNeighbors(node) {
                return this.edges.get(node) || new Map();
            }

            // Dijkstra's algorithm for shortest path
            shortestPath(start, end) {
                if (!this.nodes.has(start) || !this.nodes.has(end)) {
                    return null;
                }

                const distances = new Map();
                const previous = new Map();
                const unvisited = new Set(this.nodes);

                // Initialize distances
                for (const node of this.nodes) {
                    distances.set(node, node === start ? 0 : Infinity);
                    previous.set(node, null);
                }

                while (unvisited.size > 0) {
                    // Find node with smallest distance
                    let current = null;
                    for (const node of unvisited) {
                        if (current === null || distances.get(node) < distances.get(current)) {
                            current = node;
                        }
                    }

                    if (current === end) break;

                    unvisited.delete(current);

                    // Update distances to neighbors
                    for (const [neighbor, weight] of this.getNeighbors(current)) {
                        const alt = distances.get(current) + weight;
                        if (alt < distances.get(neighbor)) {
                            distances.set(neighbor, alt);
                            previous.set(neighbor, current);
                        }
                    }
                }

                // Reconstruct path
                const path = [];
                let current = end;
                while (current !== null) {
                    path.unshift(current);
                    current = previous.get(current);
                }

                return path[0] === start ? path : null;
            }
        }

        const graph = new WeightedGraph();
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        let shortestPath = null;

        // Initialize with sample graph
        graph.addEdge('A', 'B', 4);
        graph.addEdge('A', 'C', 2);
        graph.addEdge('B', 'C', 1);
        graph.addEdge('B', 'D', 5);
        graph.addEdge('C', 'D', 8);
        graph.addEdge('C', 'E', 10);
        graph.addEdge('D', 'E', 2);

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            
            for (const node1 of graph.nodes) {
                for (const [node2, weight] of graph.edges.get(node1)) {
                    const pos1 = graph.positions.get(node1);
                    const pos2 = graph.positions.get(node2);
                    
                    // Highlight shortest path edges
                    if (shortestPath) {
                        const idx1 = shortestPath.indexOf(node1);
                        const idx2 = shortestPath.indexOf(node2);
                        if (idx1 !== -1 && idx2 !== -1 && Math.abs(idx1 - idx2) === 1) {
                            ctx.strokeStyle = '#ff4444';
                            ctx.lineWidth = 4;
                        } else {
                            ctx.strokeStyle = '#666';
                            ctx.lineWidth = 2;
                        }
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(pos1.x, pos1.y);
                    ctx.lineTo(pos2.x, pos2.y);
                    ctx.stroke();
                    
                    // Draw weight
                    const midX = (pos1.x + pos2.x) / 2;
                    const midY = (pos1.y + pos2.y) / 2;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(midX - 15, midY - 10, 30, 20);
                    ctx.fillStyle = '#333';
                    ctx.fillText(weight, midX, midY + 5);
                }
            }
            
            // Draw nodes
            for (const node of graph.nodes) {
                const pos = graph.positions.get(node);
                
                // Highlight shortest path nodes
                if (shortestPath && shortestPath.includes(node)) {
                    ctx.fillStyle = '#ff4444';
                } else {
                    ctx.fillStyle = '#4CAF50';
                }
                
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 20, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(node, pos.x, pos.y + 5);
            }
        }

        function addEdge() {
            const node1 = document.getElementById('node1').value.toUpperCase();
            const node2 = document.getElementById('node2').value.toUpperCase();
            const weight = parseInt(document.getElementById('weight').value);
            
            if (node1 && node2 && weight > 0) {
                graph.addEdge(node1, node2, weight);
                shortestPath = null;
                drawGraph();
            }
        }

        function addNode() {
            const node1 = document.getElementById('node1').value.toUpperCase();
            if (node1) {
                graph.addNode(node1);
                shortestPath = null;
                drawGraph();
            }
        }

        function clearGraph() {
            graph.nodes.clear();
            graph.edges.clear();
            graph.positions.clear();
            shortestPath = null;
            drawGraph();
        }

        function findShortestPath() {
            const start = document.getElementById('startNode').value.toUpperCase();
            const end = document.getElementById('endNode').value.toUpperCase();
            
            if (start && end) {
                shortestPath = graph.shortestPath(start, end);
                if (shortestPath) {
                    alert(`Shortest path: ${shortestPath.join(' â†’ ')}`);
                } else {
                    alert('No path found between the specified nodes.');
                }
                drawGraph();
            }
        }

        // Make nodes draggable
        let draggedNode = null;
        let dragOffset = { x: 0, y: 0 };

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            for (const node of graph.nodes) {
                const pos = graph.positions.get(node);
                const distance = Math.sqrt((mouseX - pos.x) ** 2 + (mouseY - pos.y) ** 2);
                
                if (distance <= 20) {
                    draggedNode = node;
                    dragOffset.x = mouseX - pos.x;
                    dragOffset.y = mouseY - pos.y;
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (draggedNode) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                graph.positions.get(draggedNode).x = mouseX - dragOffset.x;
                graph.positions.get(draggedNode).y = mouseY - dragOffset.y;
                drawGraph();
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedNode = null;
        });

        // Initial draw
        drawGraph();
    </script>
</body>
</html>