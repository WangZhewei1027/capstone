<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depth-First Search (DFS) Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 10px;
        }
        
        h2 {
            color: #34495e;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
            margin-top: 30px;
        }
        
        .description {
            background-color: #e8f4fd;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        .graph-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        #graph-visualization {
            flex: 1;
            min-width: 300px;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: white;
            position: relative;
        }
        
        .algorithm-steps {
            flex: 1;
            min-width: 300px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            height: 400px;
            overflow-y: auto;
        }
        
        .node {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .edge {
            position: absolute;
            height: 2px;
            background-color: #7f8c8d;
            transform-origin: 0 0;
        }
        
        .step-item {
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        
        .step-item.current {
            background-color: #d6eaf8;
            font-weight: bold;
        }
        
        .step-item.completed {
            background-color: #d5f5e3;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        .code-section {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-top: 20px;
        }
        
        .comment {
            color: #75715e;
        }
        
        .keyword {
            color: #f92672;
        }
        
        .function {
            color: #66d9ef;
        }
        
        .string {
            color: #e6db74;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            color: #7f8c8d;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <h1>Depth-First Search (DFS) Visualization</h1>
    
    <div class="description">
        <p><strong>Depth-First Search (DFS)</strong> is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.</p>
        <p>DFS uses a stack (either explicitly or via recursion) to remember where it should go when it reaches a dead end. This implementation demonstrates the iterative approach using a stack.</p>
    </div>
    
    <div class="controls">
        <div>
            <button id="start-btn">Start DFS</button>
            <button id="pause-btn" disabled>Pause</button>
            <button id="reset-btn">Reset</button>
        </div>
        <div>
            <label for="speed-control">Animation Speed:</label>
            <input type="range" id="speed-control" min="1" max="10" value="5">
        </div>
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background-color: #3498db;"></div>
            <span>Unvisited Node</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #f39c12;"></div>
            <span>Visited (In Stack)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #2ecc71;"></div>
            <span>Processed Node</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #e74c3c;"></div>
            <span>Current Node</span>
        </div>
    </div>
    
    <div class="graph-container">
        <div id="graph-visualization"></div>
        <div class="algorithm-steps" id="steps-container">
            <h3>DFS Steps</h3>
            <div id="steps-list"></div>
        </div>
    </div>
    
    <h2>DFS Algorithm Pseudocode</h2>
    <div class="code-section">
        <pre><code><span class="comment">// Depth-First Search (DFS) - Iterative Approach</span>
<span class="keyword">function</span> <span class="function">DFS</span>(startNode) {
    <span class="keyword">let</span> stack = [startNode];  <span class="comment">// Initialize stack with start node</span>
    <span class="keyword">let</span> visited = <span class="keyword">new</span> Set();  <span class="comment">// Track visited nodes</span>
    
    <span class="keyword">while</span> (stack.length > <span class="number">0</span>) {
        <span class="keyword">let</span> currentNode = stack.pop();  <span class="comment">// Get the last node from stack</span>
        
        <span class="keyword">if</span> (!visited.has(currentNode)) {
            visited.add(currentNode);  <span class="comment">// Mark as visited</span>
            <span class="function">processNode</span>(currentNode);  <span class="comment">// Process the node</span>
            
            <span class="comment">// Add unvisited neighbors to the stack</span>
            <span class="keyword">for</span> (<span class="keyword">let</span> neighbor <span class="keyword">of</span> getNeighbors(currentNode)) {
                <span class="keyword">if</span> (!visited.has(neighbor)) {
                    stack.push(neighbor);
                }
            }
        }
    }
}</code></pre>
    </div>
    
    <footer>
        <p>Depth-First Search Visualization | Algorithm Demonstration</p>
    </footer>

    <script>
        // Graph structure
        const graph = {
            'A': ['B', 'C'],
            'B': ['A', 'D', 'E'],
            'C': ['A', 'F'],
            'D': ['B'],
            'E': ['B', 'F'],
            'F': ['C', 'E']
        };

        // Node positions for visualization
        const nodePositions = {
            'A': { x: 150, y: 100 },
            'B': { x: 50, y: 200 },
            'C': { x: 250, y: 200 },
            'D': { x: 20, y: 300 },
            'E': { x: 100, y: 300 },
            'F': { x: 250, y: 300 }
        };

        // DOM elements
        const graphVisualization = document.getElementById('graph-visualization');
        const stepsList = document.getElementById('steps-list');
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const speedControl = document.getElementById('speed-control');

        // Animation state
        let animationId = null;
        let isPaused = false;
        let currentStep = 0;
        let visited = new Set();
        let stack = [];
        let steps = [];

        // Initialize the graph visualization
        function initializeGraph() {
            graphVisualization.innerHTML = '';
            
            // Draw edges
            for (const [node, neighbors] of Object.entries(graph)) {
                const nodePos = nodePositions[node];
                
                for (const neighbor of neighbors) {
                    const neighborPos = nodePositions[neighbor];
                    
                    // Calculate distance and angle
                    const dx = neighborPos.x - nodePos.x;
                    const dy = neighborPos.y - nodePos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    // Create edge element
                    const edge = document.createElement('div');
                    edge.className = 'edge';
                    edge.style.width = `${distance}px`;
                    edge.style.left = `${nodePos.x}px`;
                    edge.style.top = `${nodePos.y}px`;
                    edge.style.transform = `rotate(${angle}deg)`;
                    graphVisualization.appendChild(edge);
                }
            }
            
            // Draw nodes
            for (const node of Object.keys(nodePositions)) {
                const pos = nodePositions[node];
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.id = `node-${node}`;
                nodeElement.style.left = `${pos.x - 20}px`;
                nodeElement.style.top = `${pos.y - 20}px`;
                nodeElement.style.backgroundColor = '#3498db';
                nodeElement.textContent = node;
                graphVisualization.appendChild(nodeElement);
            }
        }

        // Update node appearance based on state
        function updateNode(node, state) {
            const nodeElement = document.getElementById(`node-${node}`);
            if (!nodeElement) return;
            
            switch(state) {
                case 'unvisited':
                    nodeElement.style.backgroundColor = '#3498db';
                    break;
                case 'visited':
                    nodeElement.style.backgroundColor = '#f39c12';
                    break;
                case 'processed':
                    nodeElement.style.backgroundColor = '#2ecc71';
                    break;
                case 'current':
                    nodeElement.style.backgroundColor = '#e74c3c';
                    break;
            }
        }

        // Perform DFS step by step
        function performDFSStep() {
            if (isPaused || currentStep >= steps.length) {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                startBtn.disabled = false;
                pauseBtn.disabled = true;
                return;
            }
            
            const step = steps[currentStep];
            
            // Update step visualization
            const stepItems = document.querySelectorAll('.step-item');
            stepItems.forEach((item, index) => {
                item.classList.remove('current');
                if (index < currentStep) item.classList.add('completed');
                if (index === currentStep) item.classList.add('current');
            });
            
            // Execute the step
            switch(step.type) {
                case 'push':
                    addStepToDisplay(`Push ${step.node} to stack`);
                    stack.push(step.node);
                    updateNode(step.node, 'visited');
                    break;
                    
                case 'pop':
                    addStepToDisplay(`Pop ${step.node} from stack`);
                    stack.pop();
                    updateNode(step.node, 'current');
                    break;
                    
                case 'process':
                    addStepToDisplay(`Process node ${step.node}`);
                    visited.add(step.node);
                    updateNode(step.node, 'processed');
                    break;
                    
                case 'visit_neighbors':
                    const neighbors = graph[step.node].filter(n => !visited.has(n));
                    if (neighbors.length > 0) {
                        addStepToDisplay(`Visit neighbors of ${step.node}: ${neighbors.join(', ')}`);
                    } else {
                        addStepToDisplay(`No unvisited neighbors for ${step.node}`);
                    }
                    break;
            }
            
            // Update stack display
            updateStackDisplay();
            
            currentStep++;
            
            // Schedule next step
            const speed = 1100 - (speedControl.value * 100);
            animationId = setTimeout(performDFSStep, speed);
        }

        // Generate DFS steps
        function generateDFSSteps(startNode) {
            steps = [];
            visited.clear();
            stack = [startNode];
            const visitedSet = new Set();
            
            // Initial step
            steps.push({ type: 'push', node: startNode });
            
            while (stack.length > 0) {
                const currentNode = stack[stack.length - 1];
                steps.push({ type: 'pop', node: currentNode });
                
                if (!visitedSet.has(currentNode)) {
                    steps.push({ type: 'process', node: currentNode });
                    visitedSet.add(currentNode);
                    
                    steps.push({ type: 'visit_neighbors', node: currentNode });
                    
                    // Add unvisited neighbors in reverse order to maintain visual order
                    const neighbors = graph[currentNode].filter(n => !visitedSet.has(n));
                    for (let i = neighbors.length - 1; i >= 0; i--) {
                        if (!visitedSet.has(neighbors[i])) {
                            steps.push({ type: 'push', node: neighbors[i] });
                        }
                    }
                }
            }
        }

        // Add step to display
        function addStepToDisplay(stepText) {
            // This function is called during animation to update the current step
            // The steps are already displayed during initialization
        }

        // Update stack visualization
        function updateStackDisplay() {
            // In a real implementation, you would update a visual stack representation
        }

        // Initialize steps display
        function initializeStepsDisplay() {
            stepsList.innerHTML = '';
            steps.forEach((step, index) => {
                const stepItem = document.createElement('div');
                stepItem.className = 'step-item';
                stepItem.id = `step-${index}`;
                
                let stepText = '';
                switch(step.type) {
                    case 'push':
                        stepText = `Push ${step.node} to stack`;
                        break;
                    case 'pop':
                        stepText = `Pop ${step.node} from stack`;
                        break;
                    case 'process':
                        stepText = `Process node ${step.node}`;
                        break;
                    case 'visit_neighbors':
                        const neighbors = graph[step.node].filter(n => !visited.has(n));
                        stepText = `Visit neighbors of ${step.node}`;
                        if (neighbors.length > 0) {
                            stepText += `: ${neighbors.join(', ')}`;
                        } else {
                            stepText += ` (no unvisited neighbors)`;
                        }
                        break;
                }
                
                stepItem.textContent = `${index + 1}. ${stepText}`;
                stepsList.appendChild(stepItem);
            });
        }

        // Event listeners
        startBtn.addEventListener('click', () => {
            if (currentStep >= steps.length) {
                // Reset if we've completed the animation
                resetDFS();
            }
            
            isPaused = false;
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            performDFSStep();
        });

        pauseBtn.addEventListener('click', () => {
            isPaused = true;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            
            if (animationId) {
                clearTimeout(animationId);
                animationId = null;
            }
        });

        resetBtn.addEventListener('click', resetDFS);

        // Reset DFS animation
        function resetDFS() {
            isPaused = true;
            currentStep = 0;
            visited.clear();
            stack = [];
            
            if (animationId) {
                clearTimeout(animationId);
                animationId = null;
            }
            
            // Reset node appearances
            for (const node of Object.keys(nodePositions)) {
                updateNode(node, 'unvisited');
            }
            
            // Reset steps display
            const stepItems = document.querySelectorAll('.step-item');
            stepItems.forEach(item => {
                item.classList.remove('current', 'completed');
            });
            
            startBtn.disabled = false;
            pauseBtn.disabled = true;
        }

        // Initialize the visualization
        initializeGraph();
        generateDFSSteps('A');
        initializeStepsDisplay();
    </script>
</body>
</html>