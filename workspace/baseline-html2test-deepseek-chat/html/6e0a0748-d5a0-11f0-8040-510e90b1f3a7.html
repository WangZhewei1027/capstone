<!DOCTYPE html>
# Bellman-Ford Algorithm Visualization

I'll create an interactive visualization of the Bellman-Ford algorithm that lets users build graphs and see the algorithm in action.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bellman-Ford Algorithm Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 900px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }
        
        #graph-canvas {
            width: 100%;
            height: 100%;
            background-color: #fdfdfd;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        button.active {
            background-color: #e74c3c;
        }
        
        .mode-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .mode-btn {
            padding: 6px 12px;
            background-color: #ecf0f1;
            color: #2c3e50;
            border: 1px solid #bdc3c7;
        }
        
        .mode-btn.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        
        .algorithm-info {
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .step-info {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .node-info, .edge-info {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .info-item {
            padding: 5px 10px;
            background-color: #f1f1f1;
            border-radius: 4px;
            text-align: center;
        }
        
        .info-item.active {
            background-color: #3498db;
            color: white;
        }
        
        .info-item.relaxed {
            background-color: #2ecc71;
            color: white;
        }
        
        .info-item.negative-cycle {
            background-color: #e74c3c;
            color: white;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        th {
            background-color: #f2f2f2;
        }
        
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        .negative-edge {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .instructions {
            background-color: #e8f4fd;
            border-radius: 4px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .instructions h3 {
            margin-top: 0;
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Bellman-Ford Algorithm Visualization</h1>
        <p class="subtitle">Visualize the shortest path finding algorithm that handles negative weight edges</p>
        
        <div class="grid">
            <div class="panel">
                <div class="controls">
                    <div class="mode-buttons">
                        <button id="add-node-btn" class="mode-btn active">Add Node</button>
                        <button id="add-edge-btn" class="mode-btn">Add Edge</button>
                        <button id="move-node-btn" class="mode-btn">Move Node</button>
                        <button id="delete-btn" class="mode-btn">Delete</button>
                    </div>
                    <button id="run-algorithm">Run Algorithm</button>
                    <button id="reset-graph">Reset Graph</button>
                    <button id="step-forward" disabled>Step Forward</button>
                    <button id="step-backward" disabled>Step Backward</button>
                </div>
                
                <div class="canvas-container">
                    <canvas id="graph-canvas"></canvas>
                </div>
                
                <div class="instructions">
                    <h3>How to use:</h3>
                    <ul>
                        <li><strong>Add Node:</strong> Click on an empty area to add a node</li>
                        <li><strong>Add Edge:</strong> Select two nodes to create an edge (you can set weight in the edge info)</li>
                        <li><strong>Move Node:</strong> Drag nodes to reposition them</li>
                        <li><strong>Delete:</strong> Click on a node or edge to delete it</li>
                        <li>Set the source node by clicking on it while the algorithm is not running</li>
                    </ul>
                </div>
            </div>
            
            <div class="panel">
                <div class="algorithm-info">
                    <h3>About Bellman-Ford Algorithm</h3>
                    <p>The Bellman-Ford algorithm finds the shortest path from a source node to all other nodes in a weighted graph. It can handle graphs with negative weight edges and detect negative cycles.</p>
                    <p><strong>Time Complexity:</strong> O(V*E) where V is the number of vertices and E is the number of edges.</p>
                </div>
                
                <div class="step-info">
                    <h3>Algorithm Steps</h3>
                    <div id="step-description">Ready to run the algorithm.</div>
                </div>
                
                <div>
                    <h3>Distance Table</h3>
                    <div id="distance-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>Node</th>
                                    <th>Distance</th>
                                    <th>Previous</th>
                                </tr>
                            </thead>
                            <tbody id="distance-table-body">
                                <!-- Will be populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #3498db;"></div>
                        <span>Source Node</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2ecc71;"></div>
                        <span>Relaxed Node/Edge</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #e74c3c;"></div>
                        <span>Negative Cycle</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Graph data structure
        class Graph {
            constructor() {
                this.nodes = [];
                this.edges = [];
                this.nextNodeId = 0;
            }
            
            addNode(x, y) {
                const node = {
                    id: this.nextNodeId++,
                    x: x,
                    y: y,
                    label: String.fromCharCode(65 + (this.nodes.length % 26)) // A, B, C, ...
                };
                this.nodes.push(node);
                return node;
            }
            
            addEdge(fromNode, toNode, weight = 1) {
                // Check if edge already exists
                if (this.edges.some(edge => 
                    (edge.from === fromNode.id && edge.to === toNode.id) || 
                    (edge.from === toNode.id && edge.to === fromNode.id))) {
                    return null;
                }
                
                const edge = {
                    from: fromNode.id,
                    to: toNode.id,
                    weight: parseInt(weight) || 1
                };
                this.edges.push(edge);
                return edge;
            }
            
            removeNode(nodeId) {
                // Remove the node
                this.nodes = this.nodes.filter(node => node.id !== nodeId);
                // Remove all edges connected to this node
                this.edges = this.edges.filter(edge => edge.from !== nodeId && edge.to !== nodeId);
            }
            
            removeEdge(fromNodeId, toNodeId) {
                this.edges = this.edges.filter(edge => 
                    !(edge.from === fromNodeId && edge.to === toNodeId));
            }
            
            getNode(id) {
                return this.nodes.find(node => node.id === id);
            }
            
            getEdgesFromNode(nodeId) {
                return this.edges.filter(edge => edge.from === nodeId);
            }
            
            // Bellman-Ford algorithm implementation
            bellmanFord(sourceId) {
                // Initialize distances
                const distances = {};
                const predecessors = {};
                
                // Initialize all distances to Infinity and predecessors to null
                this.nodes.forEach(node => {
                    distances[node.id] = node.id === sourceId ? 0 : Infinity;
                    predecessors[node.id] = null;
                });
                
                const steps = [];
                
                // Relax edges repeatedly (V-1 times)
                for (let i = 0; i < this.nodes.length - 1; i++) {
                    let relaxed = false;
                    
                    // Create a step snapshot
                    const step = {
                        iteration: i + 1,
                        distances: {...distances},
                        predecessors: {...predecessors},
                        relaxedEdges: []
                    };
                    
                    // Relax each edge
                    this.edges.forEach(edge => {
                        if (distances[edge.from] !== Infinity && 
                            distances[edge.from] + edge.weight < distances[edge.to]) {
                            
                            distances[edge.to] = distances[edge.from] + edge.weight;
                            predecessors[edge.to] = edge.from;
                            relaxed = true;
                            
                            step.relaxedEdges.push({
                                from: edge.from,
                                to: edge.to,
                                weight: edge.weight
                            });
                        }
                    });
                    
                    steps.push(step);
                    
                    // If no relaxation occurred, we can stop early
                    if (!relaxed) break;
                }
                
                // Check for negative cycles
                let negativeCycle = false;
                const negativeCycleEdges = [];
                
                this.edges.forEach(edge => {
                    if (distances[edge.from] !== Infinity && 
                        distances[edge.from] + edge.weight < distances[edge.to]) {
                        negativeCycle = true;
                        negativeCycleEdges.push({
                            from: edge.from,
                            to: edge.to,
                            weight: edge.weight
                        });
                    }
                });
                
                // Add final step with negative cycle info if applicable
                steps.push({
                    iteration: this.nodes.length,
                    distances: {...distances},
                    predecessors: {...predecessors},
                    relaxedEdges: [],
                    negativeCycle: negativeCycle,
                    negativeCycleEdges: negativeCycleEdges
                });
                
                return {
                    distances: distances,
                    predecessors: predecessors,
                    steps: steps,
                    hasNegativeCycle: negativeCycle
                };
            }
        }

        // Visualization controller
        class BellmanFordVisualizer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.graph = new Graph();
                this.sourceNodeId = null;
                this.algorithmResult = null;
                this.currentStep = 0;
                this.isRunning = false;
                this.mode = 'add-node'; // 'add-node', 'add-edge', 'move-node', 'delete'
                this.selectedNode = null;
                this.edgeWeightInput = null;
                
                // Set canvas size
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Initialize event listeners
                this.setupEventListeners();
                this.setupUI();
                
                // Draw initial empty graph
                this.draw();
            }
            
            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.draw();
            }
            
            setupEventListeners() {
                // Canvas mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                
                // Mode buttons
                document.getElementById('add-node-btn').addEventListener('click', () => this.setMode('add-node'));
                document.getElementById('add-edge-btn').addEventListener('click', () => this.setMode('add-edge'));
                document.getElementById('move-node-btn').addEventListener('click', () => this.setMode('move-node'));
                document.getElementById('delete-btn').addEventListener('click', () => this.setMode('delete'));
                
                // Control buttons
                document.getElementById('run-algorithm').addEventListener('click', () => this.runAlgorithm());
                document.getElementById('reset-graph').addEventListener('click', () => this.resetGraph());
                document.getElementById('step-forward').addEventListener('click', () => this.stepForward());
                document.getElementById('step-backward').addEventListener('click', () => this.stepBackward());
            }
            
            setupUI() {
                // Create edge weight input (initially hidden)
                this.edgeWeightInput = document.createElement('input');
                this.edgeWeightInput.type = 'number';
                this.edgeWeightInput.value = '1';
                this.edgeWeightInput.style.position = 'absolute';
                this.edgeWeightInput.style.display = 'none';
                this.edgeWeightInput.style.zIndex = '10';
                this.canvas.parentElement.appendChild(this.edgeWeightInput);
                
                this.edgeWeightInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        this.finalizeEdge();
                    } else if (e.key === 'Escape') {
                        this.cancelEdge();
                    }
                });
            }
            
            setMode(mode) {
                this.mode = mode;
                
                // Update UI
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(`${mode}-btn`).classList.add('active');
                
                // Reset selection state
                this.selectedNode = null;
                this.draw();
            }
            
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const node = this.getNodeAt(x, y);
                
                switch (this.mode) {
                    case 'add-node':
                        if (!node) {
                            this.graph.addNode(x, y);
                            this.draw();
                        }
                        break;
                        
                    case 'add-edge':
                        if (node) {
                            if (!this.selectedNode) {
                                this.selectedNode = node;
                                this.highlightNode(node);
                            } else if (this.selectedNode.id !== node.id) {
                                // Show weight input
                                this.showEdgeWeightInput(x, y, this.selectedNode, node);
                            }
                        }
                        break;
                        
                    case 'move-node':
                        if (node) {
                            this.selectedNode = node;
                            this.isDragging = true;
                        }
                        break;
                        
                    case 'delete':
                        if (node) {
                            this.graph.removeNode(node.id);
                            if (this.sourceNodeId === node.id) {
                                this.sourceNodeId = null;
                            }
                            this.draw();
                        } else {
                            // Check if clicking on an edge
                            const edge = this.getEdgeAt(x, y);
                            if (edge) {
                                this.graph.removeEdge(edge.from, edge.to);
                                this.draw();
                            }
                        }
                        break;
                }
                
                // Set source node if not running algorithm
                if (!this.isRunning && node && this.mode !== 'add-edge' && this.mode !== 'delete') {
                    this.sourceNodeId = node.id;
                    this.draw();
                }
            }
            
            handleMouse