<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kruskal's Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .graph-section {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .controls-section {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        canvas {
            border: 1px solid #ddd;
            background-color: #fafafa;
        }
        
        button {
            padding: 8px 16px;
            margin: 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .step-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 4px;
            min-height: 100px;
        }
        
        .edge-list {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .mst-edge {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .current-edge {
            background-color: #fffacd;
        }
        
        .node {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: #4CAF50;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Kruskal's Algorithm Visualization</h1>
    
    <div class="container">
        <div class="graph-section">
            <h3>Graph Visualization</h3>
            <canvas id="graphCanvas" width="500" height="400"></canvas>
        </div>
        
        <div class="controls-section">
            <h3>Algorithm Controls</h3>
            <div>
                <button id="resetBtn">Reset Graph</button>
                <button id="stepBtn">Next Step</button>
                <button id="runBtn">Run All Steps</button>
            </div>
            
            <div class="step-info">
                <h4>Current Step:</h4>
                <div id="stepDescription">Click "Next Step" to start execution</div>
            </div>
            
            <div class="edge-list">
                <h4>Edges (sorted by weight):</h4>
                <ul id="edgesList"></ul>
            </div>
            
            <div>
                <h4>Minimum Spanning Tree Weight: <span id="mstWeight">0</span></h4>
            </div>
        </div>
    </div>

    <script>
        class KruskalAlgorithm {
            constructor() {
                this.nodes = [];
                this.edges = [];
                this.mst = [];
                this.currentStep = 0;
                this.sortedEdges = [];
                this.parent = [];
                this.rank = [];
                this.isRunning = false;
                
                this.initializeDefaultGraph();
            }
            
            initializeDefaultGraph() {
                // Create a default graph for demonstration
                this.nodes = [
                    {id: 0, x: 100, y: 100},
                    {id: 1, x: 300, y: 100},
                    {id: 2, x: 200, y: 200},
                    {id: 3, x: 100, y: 300},
                    {id: 4, x: 300, y: 300}
                ];
                
                this.edges = [
                    {from: 0, to: 1, weight: 10},
                    {from: 0, to: 2, weight: 6},
                    {from: 0, to: 3, weight: 5},
                    {from: 1, to: 2, weight: 15},
                    {from: 1, to: 4, weight: 8},
                    {from: 2, to: 3, weight: 4},
                    {from: 2, to: 4, weight: 12},
                    {from: 3, to: 4, weight: 7}
                ];
                
                this.initializeUnionFind();
                this.sortEdges();
                this.updateEdgesList();
            }
            
            initializeUnionFind() {
                this.parent = [];
                this.rank = [];
                
                for (let i = 0; i < this.nodes.length; i++) {
                    this.parent[i] = i;
                    this.rank[i] = 0;
                }
            }
            
            sortEdges() {
                this.sortedEdges = [...this.edges];
                this.sortedEdges.sort((a, b) => a.weight - b.weight);
            }
            
            find(node) {
                if (this.parent[node] !== node) {
                    this.parent[node] = this.find(this.parent[node]);
                }
                return this.parent[node];
            }
            
            union(node1, node2) {
                let root1 = this.find(node1);
                let root2 = this.find(node2);
                
                if (root1 !== root2) {
                    if (this.rank[root1] > this.rank[root2]) {
                        this.parent[root2] = root1;
                    } else if (this.rank[root1] < this.rank[root2]) {
                        this.parent[root1] = root2;
                    } else {
                        this.parent[root2] = root1;
                        this.rank[root1]++;
                    }
                    return true;
                }
                return false;
            }
            
            nextStep() {
                if (this.currentStep >= this.sortedEdges.length) {
                    return false;
                }
                
                const currentEdge = this.sortedEdges[this.currentStep];
                const fromRoot = this.find(currentEdge.from);
                const toRoot = this.find(currentEdge.to);
                
                let description = `Considering edge ${currentEdge.from}-${currentEdge.to} (weight: ${currentEdge.weight})<br>`;
                
                if (fromRoot !== toRoot) {
                    this.union(currentEdge.from, currentEdge.to);
                    this.mst.push(currentEdge);
                    description += `✓ Added to MST (no cycle created)<br>`;
                    description += `Union-Find: Parent array: [${this.parent}]`;
                } else {
                    description += `✗ Skipped (would create cycle)<br>`;
                    description += `Both nodes are in the same set (root: ${fromRoot})`;
                }
                
                document.getElementById('stepDescription').innerHTML = description;
                this.currentStep++;
                
                this.updateEdgesList();
                this.calculateMSTWeight();
                return true;
            }
            
            runAllSteps() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                document.getElementById('runBtn').disabled = true;
                
                const runStep = () => {
                    if (!this.nextStep()) {
                        this.isRunning = false;
                        document.getElementById('runBtn').disabled = false;
                        return;
                    }
                    
                    setTimeout(runStep, 1000);
                };
                
                runStep();
            }
            
            reset() {
                this.mst = [];
                this.currentStep = 0;
                this.initializeUnionFind();
                document.getElementById('stepDescription').innerHTML = 'Algorithm reset. Click "Next Step" to start.';
                this.updateEdgesList();
                this.calculateMSTWeight();
            }
            
            updateEdgesList() {
                const edgesList = document.getElementById('edgesList');
                edgesList.innerHTML = '';
                
                this.sortedEdges.forEach((edge, index) => {
                    const li = document.createElement('li');
                    li.innerHTML = `Edge ${edge.from}-${edge.to}: weight ${edge.weight}`;
                    
                    if (index < this.currentStep) {
                        if (this.mst.includes(edge)) {
                            li.className = 'mst-edge';
                            li.innerHTML += ' ✓ (In MST)';
                        } else {
                            li.innerHTML += ' ✗ (Skipped)';
                        }
                    }
                    
                    if (index === this.currentStep && index < this.sortedEdges.length) {
                        li.className = 'current-edge';
                    }
                    
                    edgesList.appendChild(li);
                });
            }
            
            calculateMSTWeight() {
                const weight = this.mst.reduce((sum, edge) => sum + edge.weight, 0);
                document.getElementById('mstWeight').textContent = weight;
            }
            
            drawGraph(canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw edges
                this.edges.forEach(edge => {
                    const fromNode = this.nodes[edge.from];
                    const toNode = this.nodes[edge.to];
                    
                    ctx.beginPath();
                    ctx.moveTo(fromNode.x, fromNode.y);
                    ctx.lineTo(toNode.x, toNode.y);
                    
                    // Color MST edges differently
                    if (this.mst.includes(edge)) {
                        ctx.strokeStyle = '#4CAF50';
                        ctx.lineWidth = 3;
                    } else {
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 1;
                    }
                    
                    ctx.stroke();
                    
                    // Draw weight
                    const midX = (fromNode.x + toNode.x) / 2;
                    const midY = (fromNode.y + toNode.y) / 2;
                    ctx.fillStyle = '#333';
                    ctx.fillText(edge.weight, midX + 5, midY + 5);
                });
                
                // Highlight current edge being considered
                if (this.currentStep < this.sortedEdges.length) {
                    const currentEdge = this.sortedEdges[this.currentStep];
                    const fromNode = this.nodes[currentEdge.from];
                    const toNode = this.nodes[currentEdge.to];
                    
                    ctx.beginPath();
                    ctx.moveTo(fromNode.x, fromNode.y);
                    ctx.lineTo(toNode.x, toNode.y);
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // Draw nodes
                this.nodes.forEach(node => {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, 15, 0, 2 * Math.PI);
                    ctx.fillStyle = '#4CAF50';
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.id, node.x, node.y);
                });
            }
        }

        // Initialize the algorithm and setup event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('graphCanvas');
            const kruskal = new KruskalAlgorithm();
            
            // Draw initial graph
            kruskal.drawGraph(canvas);
            
            // Event listeners
            document.getElementById('stepBtn').addEventListener('click', function() {
                kruskal.nextStep();
                kruskal.drawGraph(canvas);
            });
            
            document.getElementById('runBtn').addEventListener('click', function() {
                kruskal.runAllSteps();
            });
            
            document.getElementById('resetBtn').addEventListener('click', function() {
                kruskal.reset();
                kruskal.drawGraph(canvas);
            });
        });
    </script>
</body>
</html>