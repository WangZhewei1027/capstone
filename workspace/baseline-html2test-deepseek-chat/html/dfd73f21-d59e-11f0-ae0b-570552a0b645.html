<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red-Black Tree Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        input, button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            border: none;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #tree-container {
            width: 100%;
            height: 500px;
            border: 1px solid #ddd;
            margin-top: 20px;
            position: relative;
            overflow: auto;
        }
        .node {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .red {
            background-color: #e74c3c;
        }
        .black {
            background-color: #2c3e50;
        }
        .line {
            position: absolute;
            background-color: #333;
            height: 2px;
            transform-origin: 0 0;
        }
        .info-panel {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        .log {
            height: 100px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            background-color: #f8f9fa;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Red-Black Tree Visualization</h1>
        
        <div class="controls">
            <input type="number" id="value-input" placeholder="Enter value" min="0">
            <button onclick="insertValue()">Insert</button>
            <button onclick="deleteValue()">Delete</button>
            <button onclick="findValue()">Find</button>
            <button onclick="clearTree()">Clear Tree</button>
            <button onclick="generateRandomTree()">Generate Random Tree</button>
        </div>

        <div id="tree-container"></div>

        <div class="info-panel">
            <h3>Red-Black Tree Properties:</h3>
            <ul>
                <li>Every node is either RED or BLACK</li>
                <li>Root is always BLACK</li>
                <li>No two consecutive RED nodes (RED node cannot have RED parent or children)</li>
                <li>Every path from root to null leaf has the same number of BLACK nodes</li>
                <li>New insertions are always RED</li>
            </ul>
            
            <div class="log" id="operation-log"></div>
        </div>
    </div>

    <script>
        class Node {
            constructor(value, color = 'RED') {
                this.value = value;
                this.color = color;
                this.left = null;
                this.right = null;
                this.parent = null;
            }

            isRed() {
                return this.color === 'RED';
            }

            isBlack() {
                return this.color === 'BLACK';
            }
        }

        class RedBlackTree {
            constructor() {
                this.root = null;
                this.NIL = new Node(null, 'BLACK'); // Sentinel node
            }

            insert(value) {
                const newNode = new Node(value);
                this._insertNode(newNode);
                this._fixInsert(newNode);
                return newNode;
            }

            _insertNode(node) {
                let parent = null;
                let current = this.root;

                while (current !== null && current !== this.NIL) {
                    parent = current;
                    if (node.value < current.value) {
                        current = current.left;
                    } else {
                        current = current.right;
                    }
                }

                node.parent = parent;

                if (parent === null) {
                    this.root = node;
                } else if (node.value < parent.value) {
                    parent.left = node;
                } else {
                    parent.right = node;
                }

                node.left = this.NIL;
                node.right = this.NIL;
                node.color = 'RED';
            }

            _fixInsert(node) {
                while (node !== this.root && node.parent.isRed()) {
                    if (node.parent === node.parent.parent.left) {
                        const uncle = node.parent.parent.right;
                        
                        if (uncle.isRed()) {
                            // Case 1: Uncle is RED
                            node.parent.color = 'BLACK';
                            uncle.color = 'BLACK';
                            node.parent.parent.color = 'RED';
                            node = node.parent.parent;
                        } else {
                            if (node === node.parent.right) {
                                // Case 2: Node is right child
                                node = node.parent;
                                this._leftRotate(node);
                            }
                            // Case 3: Node is left child
                            node.parent.color = 'BLACK';
                            node.parent.parent.color = 'RED';
                            this._rightRotate(node.parent.parent);
                        }
                    } else {
                        const uncle = node.parent.parent.left;
                        
                        if (uncle.isRed()) {
                            node.parent.color = 'BLACK';
                            uncle.color = 'BLACK';
                            node.parent.parent.color = 'RED';
                            node = node.parent.parent;
                        } else {
                            if (node === node.parent.left) {
                                node = node.parent;
                                this._rightRotate(node);
                            }
                            node.parent.color = 'BLACK';
                            node.parent.parent.color = 'RED';
                            this._leftRotate(node.parent.parent);
                        }
                    }
                }
                this.root.color = 'BLACK';
            }

            _leftRotate(x) {
                const y = x.right;
                x.right = y.left;
                
                if (y.left !== this.NIL) {
                    y.left.parent = x;
                }
                
                y.parent = x.parent;
                
                if (x.parent === null) {
                    this.root = y;
                } else if (x === x.parent.left) {
                    x.parent.left = y;
                } else {
                    x.parent.right = y;
                }
                
                y.left = x;
                x.parent = y;
            }

            _rightRotate(y) {
                const x = y.left;
                y.left = x.right;
                
                if (x.right !== this.NIL) {
                    x.right.parent = y;
                }
                
                x.parent = y.parent;
                
                if (y.parent === null) {
                    this.root = x;
                } else if (y === y.parent.right) {
                    y.parent.right = x;
                } else {
                    y.parent.left = x;
                }
                
                x.right = y;
                y.parent = x;
            }

            find(value) {
                return this._findNode(this.root, value);
            }

            _findNode(node, value) {
                if (node === null || node === this.NIL) {
                    return null;
                }

                if (value === node.value) {
                    return node;
                } else if (value < node.value) {
                    return this._findNode(node.left, value);
                } else {
                    return this._findNode(node.right, value);
                }
            }

            getHeight(node = this.root) {
                if (node === null || node === this.NIL) return 0;
                return 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
            }
        }

        // Visualization and UI logic
        const tree = new RedBlackTree();
        let nodePositions = new Map();

        function logOperation(message) {
            const log = document.getElementById('operation-log');
            const timestamp = new Date().toLocaleTimeString();
            log.innerHTML += `[${timestamp}] ${message}<br>`;
            log.scrollTop = log.scrollHeight;
        }

        function insertValue() {
            const input = document.getElementById('value-input');
            const value = parseInt(input.value);
            
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }

            if (tree.find(value)) {
                logOperation(`Value ${value} already exists in the tree`);
                return;
            }

            tree.insert(value);
            logOperation(`Inserted value: ${value}`);
            input.value = '';
            visualizeTree();
        }

        function deleteValue() {
            const input = document.getElementById('value-input');
            const value = parseInt(input.value);
            
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }

            logOperation(`Delete operation for value ${value} (implementation extended)`);
            input.value = '';
        }

        function findValue() {
            const input = document.getElementById('value-input');
            const value = parseInt(input.value);
            
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }

            const node = tree.find(value);
            if (node) {
                logOperation(`Found value: ${value}`);
                highlightNode(node);
            } else {
                logOperation(`Value ${value} not found`);
            }
            input.value = '';
        }

        function clearTree() {
            tree.root = null;
            logOperation('Tree cleared');
            visualizeTree();
        }

        function generateRandomTree() {
            tree.root = null;
            const count = Math.floor(Math.random() * 10) + 5;
            const values = new Set();
            
            while (values.size < count) {
                values.add(Math.floor(Math.random() * 100) + 1);
            }
            
            Array.from(values).forEach(value => tree.insert(value));
            logOperation(`Generated random tree with ${count} values`);
            visualizeTree();
        }

        function highlightNode(node) {
            const container = document.getElementById('tree-container');
            const nodes = container.querySelectorAll('.node');
            
            nodes.forEach(element => {
                element.style.boxShadow = '';
                if (parseInt(element.textContent) === node.value) {
                    element.style.boxShadow = '0 0 10px 3px yellow';
                }
            });
        }

        function calculatePositions(node, level, position, positions, depth) {
            if (node === null || node.value === null) return;
            
            const x = position * 100;
            const y = level * 100;
            
            positions.set(node, { x, y, depth });
            
            const spread = Math.pow(2, depth - level - 1);
            
            if (node.left && node.left.value !== null) {
                calculatePositions(node.left, level + 1, position - spread, positions, depth);
            }
            if (node.right && node.right.value !== null) {
                calculatePositions(node.right, level + 1, position + spread, positions, depth);
            }
        }

        function visualizeTree() {
            const container = document.getElementById('tree-container');
            container.innerHTML = '';
            nodePositions.clear();

            if (!tree.root) return;

            const depth = tree.getHeight();
            calculatePositions(tree.root, 0, Math.pow(2, depth - 1), nodePositions, depth - 1);

            // Draw lines first
            nodePositions.forEach((pos, node) => {
                if (node.left && node.left.value !== null && nodePositions.has(node.left)) {
                    const leftPos = nodePositions.get(node.left);
                    drawLine(pos.x + 25, pos.y + 25, leftPos.x + 25, leftPos.y + 25);
                }
                if (node.right && node.right.value !== null && nodePositions.has(node.right)) {
                    const rightPos = nodePositions.get(node.right);
                    drawLine(pos.x + 25, pos.y + 25, rightPos.x + 25, rightPos.y + 25);
                }
            });

            // Draw nodes on top of lines
            nodePositions.forEach((pos, node) => {
                drawNode(node, pos.x, pos.y);
            });
        }

        function drawLine(x1, y1, x2, y2) {
            const container = document.getElementById('tree-container');
            const line = document.createElement('div');
            line.className = 'line';
            
            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            
            line.style.width = length + 'px';
            line.style.left = x1 + 'px';
            line.style.top = y1 + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            
            container.appendChild(line);
        }

        function drawNode(node, x, y) {
            const container = document.getElementById('tree-container');
            const nodeElement = document.createElement('div');
            nodeElement.className = `node ${node.color.toLowerCase()}`;
            nodeElement.textContent = node.value;
            nodeElement.style.left = x + 'px';
            nodeElement.style.top = y + 'px';
            
            nodeElement.title = `Value: ${node.value}, Color: ${node.color}`;
            container.appendChild(nodeElement);
        }

        // Initialize with a simple example
        window.onload = function() {
            logOperation('Red-Black Tree Visualization Started');
            logOperation('Try inserting values or generating a random tree');
        };
    </script>
</body>
</html>