<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breadth-First Search (BFS) Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            display: flex;
            gap: 30px;
            margin-top: 20px;
        }
        
        .controls {
            width: 300px;
            background-color: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
        }
        
        .visualization {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .graph-display {
            height: 400px;
            border: 1px solid #ccc;
            margin-bottom: 20px;
            position: relative;
            background-color: #f9f9f9;
        }
        
        .node {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #4CAF50;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .node.visited {
            background-color: #2196F3;
        }
        
        .node.current {
            background-color: #FF9800;
            transform: scale(1.2);
        }
        
        .edge {
            position: absolute;
            height: 2px;
            background-color: #666;
            transform-origin: 0 0;
        }
        
        .queue-display {
            min-height: 100px;
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        
        .queue-item {
            display: inline-block;
            margin: 5px;
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border-radius: 4px;
        }
        
        button {
            padding: 10px 15px;
            margin: 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .step-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #e7f3ff;
            border-radius: 4px;
        }
        
        .explanation {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-left: 4px solid #4CAF50;
        }
    </style>
</head>
<body>
    <h1>Breadth-First Search (BFS) Visualization</h1>
    
    <div class="container">
        <div class="controls">
            <h3>Controls</h3>
            <button id="startBtn">Start BFS</button>
            <button id="nextBtn" disabled>Next Step</button>
            <button id="resetBtn">Reset</button>
            
            <div class="step-info">
                <h4>Current Step:</h4>
                <p id="stepDescription">Ready to start BFS</p>
            </div>
            
            <div>
                <h4>Graph Configuration:</h4>
                <label>
                    Start Node: 
                    <select id="startNode">
                        <option value="A">A</option>
                        <option value="B">B</option>
                        <option value="C">C</option>
                        <option value="D">D</option>
                        <option value="E">E</option>
                        <option value="F">F</option>
                    </select>
                </label>
            </div>
        </div>
        
        <div class="visualization">
            <div class="graph-display" id="graphCanvas">
                <!-- Graph will be drawn here by JavaScript -->
            </div>
            
            <div class="queue-display">
                <h4>Queue:</h4>
                <div id="queueContents"></div>
            </div>
        </div>
    </div>
    
    <div class="explanation">
        <h3>Breadth-First Search Algorithm</h3>
        <p>BFS is a graph traversal algorithm that explores all the vertices of a graph in breadth-first order. It starts at a selected node and explores all its neighbors at the present depth before moving on to nodes at the next depth level.</p>
        
        <p><strong>Algorithm Steps:</strong></p>
        <ol>
            <li>Start from the selected root node</li>
            <li>Visit the root node and mark it as visited</li>
            <li>Enqueue all adjacent unvisited nodes</li>
            <li>Dequeue a node and visit its unvisited neighbors</li>
            <li>Repeat until the queue is empty</li>
        </ol>
        
        <p><strong>Time Complexity:</strong> O(V + E) where V is the number of vertices and E is the number of edges</p>
        <p><strong>Space Complexity:</strong> O(V) for storing visited nodes and the queue</p>
    </div>

    <script>
        // Graph representation (adjacency list)
        const graph = {
            'A': ['B', 'C'],
            'B': ['A', 'D', 'E'],
            'C': ['A', 'F'],
            'D': ['B'],
            'E': ['B', 'F'],
            'F': ['C', 'E']
        };

        // Node positions for visualization
        const nodePositions = {
            'A': { x: 200, y: 100 },
            'B': { x: 100, y: 200 },
            'C': { x: 300, y: 200 },
            'D': { x: 50, y: 300 },
            'E': { x: 150, y: 300 },
            'F': { x: 250, y: 300 }
        };

        // BFS Algorithm State
        let bfsState = {
            visited: new Set(),
            queue: [],
            current: null,
            step: 0,
            isRunning: false
        };

        // DOM Elements
        const graphCanvas = document.getElementById('graphCanvas');
        const queueContents = document.getElementById('queueContents');
        const stepDescription = document.getElementById('stepDescription');
        const startBtn = document.getElementById('startBtn');
        const nextBtn = document.getElementById('nextBtn');
        const resetBtn = document.getElementById('resetBtn');
        const startNodeSelect = document.getElementById('startNode');

        // Initialize visualization
        function initializeGraph() {
            graphCanvas.innerHTML = '';
            
            // Draw edges first (so they appear behind nodes)
            for (const node in graph) {
                for (const neighbor of graph[node]) {
                    drawEdge(node, neighbor);
                }
            }
            
            // Draw nodes
            for (const node in nodePositions) {
                drawNode(node, nodePositions[node].x, nodePositions[node].y);
            }
            
            updateQueueDisplay();
        }

        function drawNode(label, x, y) {
            const node = document.createElement('div');
            node.className = 'node';
            node.id = `node-${label}`;
            node.textContent = label;
            node.style.left = `${x - 20}px`;
            node.style.top = `${y - 20}px`;
            graphCanvas.appendChild(node);
        }

        function drawEdge(node1, node2) {
            const pos1 = nodePositions[node1];
            const pos2 = nodePositions[node2];
            
            // Calculate distance and angle between nodes
            const dx = pos2.x - pos1.x;
            const dy = pos2.y - pos1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            const edge = document.createElement('div');
            edge.className = 'edge';
            edge.style.width = `${distance}px`;
            edge.style.left = `${pos1.x}px`;
            edge.style.top = `${pos1.y}px`;
            edge.style.transform = `rotate(${angle}deg)`;
            graphCanvas.appendChild(edge);
        }

        function updateNodeVisualization() {
            // Reset all nodes
            document.querySelectorAll('.node').forEach(node => {
                node.classList.remove('visited', 'current');
            });
            
            // Mark visited nodes
            bfsState.visited.forEach(node => {
                const nodeElement = document.getElementById(`node-${node}`);
                if (nodeElement) {
                    nodeElement.classList.add('visited');
                }
            });
            
            // Mark current node
            if (bfsState.current) {
                const currentNode = document.getElementById(`node-${bfsState.current}`);
                if (currentNode) {
                    currentNode.classList.add('current');
                }
            }
        }

        function updateQueueDisplay() {
            queueContents.innerHTML = '';
            bfsState.queue.forEach(node => {
                const queueItem = document.createElement('div');
                queueItem.className = 'queue-item';
                queueItem.textContent = node;
                queueContents.appendChild(queueItem);
            });
        }

        function updateStepDescription() {
            const step = bfsState.step;
            let description = '';
            
            switch(step) {
                case 0:
                    description = 'Ready to start BFS. Click "Start BFS" to begin.';
                    break;
                case 1:
                    description = `Starting BFS from node ${bfsState.current}. Added to queue.`;
                    break;
                case 2:
                    description = `Visiting node ${bfsState.current}. Marking as visited.`;
                    break;
                case 3:
                    description = `Exploring neighbors of ${bfsState.current}. Adding unvisited neighbors to queue.`;
                    break;
                case 4:
                    description = `${bfsState.current} processed. Moving to next node in queue.`;
                    break;
                case 5:
                    description = 'BFS completed. All reachable nodes have been visited.';
                    break;
                default:
                    description = `Step ${step}: Processing...`;
            }
            
            stepDescription.textContent = description;
        }

        function bfsStep() {
            if (bfsState.queue.length === 0) {
                if (bfsState.step === 0) {
                    // Initialize BFS
                    const startNode = startNodeSelect.value;
                    bfsState.queue.push(startNode);
                    bfsState.visited.add(startNode);
                    bfsState.current = startNode;
                    bfsState.step = 1;
                    bfsState.isRunning = true;
                } else {
                    // BFS completed
                    bfsState.isRunning = false;
                    bfsState.step = 5;
                    nextBtn.disabled = true;
                    startBtn.disabled = false;
                }
            } else {
                if (bfsState.step === 1 || bfsState.step === 4) {
                    // Dequeue and visit next node
                    bfsState.current = bfsState.queue.shift();
                    bfsState.step = 2;
                } else if (bfsState.step === 2) {
                    // Mark as visited and explore neighbors
                    bfsState.visited.add(bfsState.current);
                    bfsState.step = 3;
                } else if (bfsState.step === 3) {
                    // Add unvisited neighbors to queue
                    const neighbors = graph[bfsState.current];
                    for (const neighbor of neighbors) {
                        if (!bfsState.visited.has(neighbor)) {
                            bfsState.visited.add(neighbor);
                            bfsState.queue.push(neighbor);
                        }
                    }
                    bfsState.step = 4;
                }
            }
            
            updateNodeVisualization();
            updateQueueDisplay();
            updateStepDescription();
        }

        function resetBFS() {
            bfsState = {
                visited: new Set(),
                queue: [],
                current: null,
                step: 0,
                isRunning: false
            };
            
            nextBtn.disabled = true;
            startBtn.disabled = false;
            
            updateNodeVisualization();
            updateQueueDisplay();
            updateStepDescription();
        }

        // Event Listeners
        startBtn.addEventListener('click', () => {
            resetBFS();
            bfsStep(); // Initial step
            nextBtn.disabled = false;
            startBtn.disabled = true;
        });

        nextBtn.addEventListener('click', bfsStep);

        resetBtn.addEventListener('click', () => {
            resetBFS();
            initializeGraph();
        });

        startNodeSelect.addEventListener('change', resetBFS);

        // Initialize
        initializeGraph();
    </script>
</body>
</html>