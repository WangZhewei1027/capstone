{
  "id": "6e0a0749-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:19:33.467Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Floyd-Warshall Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Floyd-Warshall Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            display: grid;\n            grid-template-columns: 1fr 1fr;\n            gap: 20px;\n        }\n        .graph-section, .matrix-section {\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        canvas {\n            border: 1px solid #ddd;\n            background-color: white;\n        }\n        table {\n            border-collapse: collapse;\n            width: 100%;\n            margin: 10px 0;\n        }\n        th, td {\n            border: 1px solid #ddd;\n            padding: 8px;\n            text-align: center;\n            min-width: 40px;\n        }\n        th {\n            background-color: #f0f0f0;\n        }\n        .current {\n            background-color: #ffe6cc;\n        }\n        .updated {\n            background-color: #ccffcc;\n        }\n        .controls {\n            margin: 20px 0;\n            text-align: center;\n        }\n        button {\n            padding: 10px 20px;\n            margin: 0 5px;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        button:disabled {\n            background-color: #cccccc;\n            cursor: not-allowed;\n        }\n        .step-info {\n            margin: 10px 0;\n            padding: 10px;\n            background-color: #e6f3ff;\n            border-radius: 4px;\n        }\n    </style>\n</head>\n<body>\n    <h1>Floyd-Warshall Algorithm Visualization</h1>\n    \n    <div class=\"container\">\n        <div class=\"graph-section\">\n            <h2>Graph Visualization</h2>\n            <canvas id=\"graphCanvas\" width=\"500\" height=\"400\"></canvas>\n            <div class=\"controls\">\n                <button id=\"prevStep\">Previous Step</button>\n                <button id=\"nextStep\">Next Step</button>\n                <button id=\"reset\">Reset</button>\n                <button id=\"autoPlay\">Auto Play</button>\n            </div>\n            <div id=\"stepInfo\" class=\"step-info\"></div>\n        </div>\n        \n        <div class=\"matrix-section\">\n            <h2>Distance Matrix</h2>\n            <div id=\"matrixContainer\"></div>\n            <h3>Algorithm Explanation</h3>\n            <p>The Floyd-Warshall algorithm finds shortest paths between all pairs of vertices in a weighted graph.</p>\n            <p>Time Complexity: O(V³) where V is the number of vertices.</p>\n        </div>\n    </div>\n\n    <script>\n        class FloydWarshall {\n            constructor(vertices, edges) {\n                this.vertices = vertices;\n                this.edges = edges;\n                this.V = vertices.length;\n                \n                // Initialize distance matrix with Infinity\n                this.dist = Array(this.V).fill().map(() => Array(this.V).fill(Infinity));\n                \n                // Set diagonal to 0 and initialize with given edges\n                for (let i = 0; i < this.V; i++) {\n                    this.dist[i][i] = 0;\n                }\n                \n                for (const edge of edges) {\n                    this.dist[edge.from][edge.to] = edge.weight;\n                }\n                \n                this.steps = [];\n                this.currentStep = 0;\n                this.generateSteps();\n            }\n            \n            generateSteps() {\n                this.steps = [];\n                \n                // Copy initial state\n                this.steps.push({\n                    k: -1,\n                    i: -1,\n                    j: -1,\n                    matrix: JSON.parse(JSON.stringify(this.dist)),\n                    description: \"Initial distance matrix\"\n                });\n                \n                // Floyd-Warshall algorithm\n                for (let k = 0; k < this.V; k++) {\n                    for (let i = 0; i < this.V; i++) {\n                        for (let j = 0; j < this.V; j++) {\n                            const currentDist = this.dist[i][j];\n                            const newDist = this.dist[i][k] + this.dist[k][j];\n                            \n                            if (newDist < currentDist && \n                                this.dist[i][k] !== Infinity && \n                                this.dist[k][j] !== Infinity) {\n                                this.dist[i][j] = newDist;\n                                \n                                this.steps.push({\n                                    k: k,\n                                    i: i,\n                                    j: j,\n                                    matrix: JSON.parse(JSON.stringify(this.dist)),\n                                    description: `Considering intermediate vertex ${String.fromCharCode(65 + k)}: ` +\n                                                `dist[${String.fromCharCode(65 + i)}][${String.fromCharCode(65 + j)}] = ` +\n                                                `min(${currentDist}, ${this.dist[i][k]} + ${this.dist[k][j]} = ${newDist})`\n                                });\n                            } else {\n                                this.steps.push({\n                                    k: k,\n                                    i: i,\n                                    j: j,\n                                    matrix: JSON.parse(JSON.stringify(this.dist)),\n                                    description: `Considering intermediate vertex ${String.fromCharCode(65 + k)}: ` +\n                                                `No improvement for dist[${String.fromCharCode(65 + i)}][${String.fromCharCode(65 + j)}]`\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            \n            getCurrentStep() {\n                return this.steps[this.currentStep];\n            }\n            \n            nextStep() {\n                if (this.currentStep < this.steps.length - 1) {\n                    this.currentStep++;\n                }\n                return this.getCurrentStep();\n            }\n            \n            prevStep() {\n                if (this.currentStep > 0) {\n                    this.currentStep--;\n                }\n                return this.getCurrentStep();\n            }\n            \n            reset() {\n                this.currentStep = 0;\n                return this.getCurrentStep();\n            }\n        }\n\n        class GraphRenderer {\n            constructor(canvasId, vertices, edges) {\n                this.canvas = document.getElementById(canvasId);\n                this.ctx = this.canvas.getContext('2d');\n                this.vertices = vertices;\n                this.edges = edges;\n                this.vertexRadius = 20;\n                \n                this.calculatePositions();\n            }\n            \n            calculatePositions() {\n                const centerX = this.canvas.width / 2;\n                const centerY = this.canvas.height / 2;\n                const radius = Math.min(centerX, centerY) * 0.7;\n                \n                this.vertexPositions = [];\n                for (let i = 0; i < this.vertices.length; i++) {\n                    const angle = (2 * Math.PI * i) / this.vertices.length;\n                    const x = centerX + radius * Math.cos(angle);\n                    const y = centerY + radius * Math.sin(angle);\n                    this.vertexPositions.push({ x, y });\n                }\n            }\n            \n            render(currentStep) {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                \n                // Draw edges\n                for (const edge of this.edges) {\n                    const fromPos = this.vertexPositions[edge.from];\n                    const toPos = this.vertexPositions[edge.to];\n                    \n                    // Highlight current edge being considered\n                    const isCurrent = currentStep && \n                                     currentStep.i === edge.from && \n                                     currentStep.j === edge.to;\n                    \n                    this.drawEdge(fromPos, toPos, edge.weight, isCurrent);\n                }\n                \n                // Draw vertices\n                for (let i = 0; i < this.vertices.length; i++) {\n                    const pos = this.vertexPositions[i];\n                    const isK = currentStep && currentStep.k === i;\n                    this.drawVertex(pos, this.vertices[i], isK);\n                }\n                \n                // Label current operation\n                if (currentStep && currentStep.k !== -1) {\n                    this.ctx.fillStyle = '#333';\n                    this.ctx.font = '14px Arial';\n                    this.ctx.fillText(\n                        `Intermediate: ${String.fromCharCode(65 + currentStep.k)}`, \n                        10, 20\n                    );\n                }\n            }\n            \n            drawEdge(fromPos, toPos, weight, highlight = false) {\n                this.ctx.beginPath();\n                this.ctx.moveTo(fromPos.x, fromPos.y);\n                this.ctx.lineTo(toPos.x, toPos.y);\n                this.ctx.strokeStyle = highlight ? '#ff4444' : '#666';\n                this.ctx.lineWidth = highlight ? 3 : 2;\n                this.ctx.stroke();\n                \n                // Draw weight\n                const midX = (fromPos.x + toPos.x) / 2;\n                const midY = (fromPos.y + toPos.y) / 2;\n                \n                this.ctx.fillStyle = highlight ? '#ff4444' : '#333';\n                this.ctx.fillRect(midX - 15, midY - 10, 30, 20);\n                this.ctx.fillStyle = 'white';\n                this.ctx.font = '12px Arial';\n                this.ctx.textAlign = 'center';\n                this.ctx.fillText(weight.toString(), midX, midY + 4);\n            }\n            \n            drawVertex(pos, label, highlight = false) {\n                this.ctx.beginPath();\n                this.ctx.arc(pos.x, pos.y, this.vertexRadius, 0, 2 * Math.PI);\n                this.ctx.fillStyle = highlight ? '#ffcc00' : '#4CAF50';\n                this.ctx.fill();\n                this.ctx.strokeStyle = '#333';\n                this.ctx.lineWidth = 2;\n                this.ctx.stroke();\n                \n                this.ctx.fillStyle = 'white';\n                this.ctx.font = 'bold 16px Arial';\n                this.ctx.textAlign = 'center';\n                this.ctx.textBaseline = 'middle';\n                this.ctx.fillText(label, pos.x, pos.y);\n            }\n        }\n\n        class MatrixRenderer {\n            constructor(matrixContainerId, vertices) {\n                this.container = document.getElementById(matrixContainerId);\n                this.vertices = vertices;\n            }\n            \n            render(currentStep) {\n                if (!currentStep) return;\n                \n                const table = document.createElement('table');\n                const headerRow = document.createElement('tr');\n                \n                // Empty corner cell\n                headerRow.appendChild(document.createElement('th'));\n                \n                // Column headers\n                for (let i = 0; i < this.vertices.length; i++) {\n                    const th = document.createElement('th');\n                    th.textContent = this.vertices[i];\n                    headerRow.appendChild(th);\n                }\n                table.appendChild(headerRow);\n                \n                // Matrix rows\n                for (let i = 0; i < this.vertices.length; i++) {\n                    const row = document.createElement('tr');\n                    \n                    // Row header\n                    const rowHeader = document.createElement('th');\n                    rowHeader.textContent = this.vertices[i];\n                    row.appendChild(rowHeader);\n                    \n                    // Data cells\n                    for (let j = 0; j < this.vertices.length; j++) {\n                        const cell = document.createElement('td');\n                        \n                        // Highlight current cell being processed\n                        if (currentStep.i === i && currentStep.j === j) {\n                            cell.classList.add('current');\n                        }\n                        \n                        // Highlight updated cells\n                        const previousStep = currentStep.k > -1 ? \n                            window.floydWarshall.steps[window.floydWarshall.currentStep - 1] : null;\n                        if (previousStep && \n                            currentStep.matrix[i][j] !== previousStep.matrix[i][j]) {\n                            cell.classList.add('updated');\n                        }\n                        \n                        cell.textContent = currentStep.matrix[i][j] === Infinity ? \n                                          '∞' : currentStep.matrix[i][j];\n                        row.appendChild(cell);\n                    }\n                    \n                    table.appendChild(row);\n                }\n                \n                this.container.innerHTML = '';\n                this.container.appendChild(table);\n            }\n        }\n\n        // Initialize the application\n        document.addEventListener('DOMContentLoaded', function() {\n            // Sample graph data\n            const vertices = ['A', 'B', 'C', 'D'];\n            const edges = [\n                { from: 0, to: 1, weight: 3 },\n                { from: 0, to: 3, weight: 7 },\n                { from: 1, to: 0, weight: 8 },\n                { from: 1, to: 2, weight: 2 },\n                { from: 2, to: 0, weight: 5 },\n                { from: 2, to: 3, weight: 1 },\n                { from: 3, to: 0, weight: 2 }\n            ];\n            \n            // Initialize components\n            window.floydWarshall = new FloydWarshall(vertices, edges);\n            window.graphRenderer = new GraphRenderer('graphCanvas', vertices, edges);\n            window.matrixRenderer = new MatrixRenderer('matrixContainer', vertices);\n            \n            // Initial render\n            updateVisualization();\n            \n            // Event listeners\n            document.getElementById('nextStep').addEventListener('click', function() {\n                window.floydWarshall.nextStep();\n                updateVisualization();\n            });\n            \n            document.getElementById('prevStep').addEventListener('click', function() {\n                window.floydWarshall.prevStep();\n                updateVisualization();\n            });\n            \n            document.getElementById('reset').addEventListener('click', function() {\n                window.floydWarshall.reset();\n                updateVisualization();\n            });\n            \n            let autoPlayInterval = null;\n            document.getElementById('autoPlay').addEventListener('click', function() {\n                if (autoPlayInterval) {\n                    clearInterval(autoPlayInterval);\n                    autoPlayInterval = null;\n                    this.textContent = 'Auto Play';\n                } else {\n                    autoPlayInterval = setInterval(function() {\n                        if (window.floydWarshall.currentStep < window.floydWarshall.steps.length - 1) {\n                            window.floydWarshall.nextStep();\n                            updateVisualization();\n                        } else {\n                            clearInterval(autoPlayInterval);\n                            autoPlayInterval = null;\n                            document.getElementById('autoPlay').textContent = 'Auto Play';\n                        }\n                    }, 1000);\n                    this.textContent = 'Stop';\n                }\n            });\n            \n            function updateVisualization() {\n                const currentStep = window.floydWarshall.getCurrentStep();\n                \n                // Update graph\n                window.graphRenderer.render(currentStep);\n                \n                // Update matrix\n                window.matrixRenderer.render(currentStep);\n                \n                // Update step info\n                document.getElementById('stepInfo').textContent = \n                    `Step ${window.floydWarshall.currentStep + 1}/${window.floydWarshall.steps.length}: ${currentStep.description}`;\n                \n                // Update button states\n                document.getElementById('prevStep').disabled = window.floydWarshall.currentStep === 0;\n                document.getElementById('nextStep').disabled = \n                    window.floydWarshall.currentStep === window.floydWarshall.steps.length - 1;\n            }\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Floyd-Warshall Algorithm"
    }
  ],
  "topic": "Floyd-Warshall Algorithm",
  "hasFSM": false,
  "hasTest": true
}