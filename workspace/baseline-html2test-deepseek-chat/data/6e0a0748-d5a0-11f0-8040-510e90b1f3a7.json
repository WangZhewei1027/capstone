{
  "id": "6e0a0748-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:19:57.310Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Bellman-Ford Algorithm",
  "answer": {
    "role": "assistant",
    "content": "# Bellman-Ford Algorithm Visualization\n\nI'll create an interactive visualization of the Bellman-Ford algorithm that lets users build graphs and see the algorithm in action.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Bellman-Ford Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f7fa;\n            color: #333;\n        }\n        \n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n        }\n        \n        h1 {\n            color: #2c3e50;\n            text-align: center;\n            margin-bottom: 10px;\n        }\n        \n        .subtitle {\n            text-align: center;\n            color: #7f8c8d;\n            margin-bottom: 30px;\n        }\n        \n        .grid {\n            display: grid;\n            grid-template-columns: 1fr 1fr;\n            gap: 20px;\n        }\n        \n        @media (max-width: 900px) {\n            .grid {\n                grid-template-columns: 1fr;\n            }\n        }\n        \n        .panel {\n            background: white;\n            border-radius: 8px;\n            box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n            padding: 20px;\n        }\n        \n        .canvas-container {\n            position: relative;\n            width: 100%;\n            height: 500px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            overflow: hidden;\n        }\n        \n        #graph-canvas {\n            width: 100%;\n            height: 100%;\n            background-color: #fdfdfd;\n        }\n        \n        .controls {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 10px;\n            margin-bottom: 20px;\n        }\n        \n        button {\n            padding: 8px 16px;\n            background-color: #3498db;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 14px;\n            transition: background-color 0.2s;\n        }\n        \n        button:hover {\n            background-color: #2980b9;\n        }\n        \n        button:disabled {\n            background-color: #bdc3c7;\n            cursor: not-allowed;\n        }\n        \n        button.active {\n            background-color: #e74c3c;\n        }\n        \n        .mode-buttons {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 5px;\n            margin-bottom: 15px;\n        }\n        \n        .mode-btn {\n            padding: 6px 12px;\n            background-color: #ecf0f1;\n            color: #2c3e50;\n            border: 1px solid #bdc3c7;\n        }\n        \n        .mode-btn.active {\n            background-color: #3498db;\n            color: white;\n            border-color: #3498db;\n        }\n        \n        .algorithm-info {\n            background-color: #f8f9fa;\n            border-left: 4px solid #3498db;\n            padding: 15px;\n            border-radius: 4px;\n            margin-bottom: 20px;\n        }\n        \n        .step-info {\n            background-color: #fff8e1;\n            border-left: 4px solid #ffc107;\n            padding: 15px;\n            border-radius: 4px;\n            margin-bottom: 20px;\n        }\n        \n        .node-info, .edge-info {\n            display: grid;\n            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));\n            gap: 10px;\n            margin-top: 10px;\n        }\n        \n        .info-item {\n            padding: 5px 10px;\n            background-color: #f1f1f1;\n            border-radius: 4px;\n            text-align: center;\n        }\n        \n        .info-item.active {\n            background-color: #3498db;\n            color: white;\n        }\n        \n        .info-item.relaxed {\n            background-color: #2ecc71;\n            color: white;\n        }\n        \n        .info-item.negative-cycle {\n            background-color: #e74c3c;\n            color: white;\n        }\n        \n        table {\n            width: 100%;\n            border-collapse: collapse;\n            margin-top: 15px;\n        }\n        \n        th, td {\n            border: 1px solid #ddd;\n            padding: 8px;\n            text-align: center;\n        }\n        \n        th {\n            background-color: #f2f2f2;\n        }\n        \n        tr:nth-child(even) {\n            background-color: #f9f9f9;\n        }\n        \n        .legend {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 15px;\n            margin-top: 15px;\n        }\n        \n        .legend-item {\n            display: flex;\n            align-items: center;\n            gap: 5px;\n        }\n        \n        .legend-color {\n            width: 20px;\n            height: 20px;\n            border-radius: 4px;\n        }\n        \n        .negative-edge {\n            color: #e74c3c;\n            font-weight: bold;\n        }\n        \n        .instructions {\n            background-color: #e8f4fd;\n            border-radius: 4px;\n            padding: 15px;\n            margin-top: 20px;\n        }\n        \n        .instructions h3 {\n            margin-top: 0;\n        }\n        \n        .instructions ul {\n            padding-left: 20px;\n        }\n        \n        .instructions li {\n            margin-bottom: 8px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Bellman-Ford Algorithm Visualization</h1>\n        <p class=\"subtitle\">Visualize the shortest path finding algorithm that handles negative weight edges</p>\n        \n        <div class=\"grid\">\n            <div class=\"panel\">\n                <div class=\"controls\">\n                    <div class=\"mode-buttons\">\n                        <button id=\"add-node-btn\" class=\"mode-btn active\">Add Node</button>\n                        <button id=\"add-edge-btn\" class=\"mode-btn\">Add Edge</button>\n                        <button id=\"move-node-btn\" class=\"mode-btn\">Move Node</button>\n                        <button id=\"delete-btn\" class=\"mode-btn\">Delete</button>\n                    </div>\n                    <button id=\"run-algorithm\">Run Algorithm</button>\n                    <button id=\"reset-graph\">Reset Graph</button>\n                    <button id=\"step-forward\" disabled>Step Forward</button>\n                    <button id=\"step-backward\" disabled>Step Backward</button>\n                </div>\n                \n                <div class=\"canvas-container\">\n                    <canvas id=\"graph-canvas\"></canvas>\n                </div>\n                \n                <div class=\"instructions\">\n                    <h3>How to use:</h3>\n                    <ul>\n                        <li><strong>Add Node:</strong> Click on an empty area to add a node</li>\n                        <li><strong>Add Edge:</strong> Select two nodes to create an edge (you can set weight in the edge info)</li>\n                        <li><strong>Move Node:</strong> Drag nodes to reposition them</li>\n                        <li><strong>Delete:</strong> Click on a node or edge to delete it</li>\n                        <li>Set the source node by clicking on it while the algorithm is not running</li>\n                    </ul>\n                </div>\n            </div>\n            \n            <div class=\"panel\">\n                <div class=\"algorithm-info\">\n                    <h3>About Bellman-Ford Algorithm</h3>\n                    <p>The Bellman-Ford algorithm finds the shortest path from a source node to all other nodes in a weighted graph. It can handle graphs with negative weight edges and detect negative cycles.</p>\n                    <p><strong>Time Complexity:</strong> O(V*E) where V is the number of vertices and E is the number of edges.</p>\n                </div>\n                \n                <div class=\"step-info\">\n                    <h3>Algorithm Steps</h3>\n                    <div id=\"step-description\">Ready to run the algorithm.</div>\n                </div>\n                \n                <div>\n                    <h3>Distance Table</h3>\n                    <div id=\"distance-table\">\n                        <table>\n                            <thead>\n                                <tr>\n                                    <th>Node</th>\n                                    <th>Distance</th>\n                                    <th>Previous</th>\n                                </tr>\n                            </thead>\n                            <tbody id=\"distance-table-body\">\n                                <!-- Will be populated by JavaScript -->\n                            </tbody>\n                        </table>\n                    </div>\n                </div>\n                \n                <div class=\"legend\">\n                    <div class=\"legend-item\">\n                        <div class=\"legend-color\" style=\"background-color: #3498db;\"></div>\n                        <span>Source Node</span>\n                    </div>\n                    <div class=\"legend-item\">\n                        <div class=\"legend-color\" style=\"background-color: #2ecc71;\"></div>\n                        <span>Relaxed Node/Edge</span>\n                    </div>\n                    <div class=\"legend-item\">\n                        <div class=\"legend-color\" style=\"background-color: #e74c3c;\"></div>\n                        <span>Negative Cycle</span>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        // Graph data structure\n        class Graph {\n            constructor() {\n                this.nodes = [];\n                this.edges = [];\n                this.nextNodeId = 0;\n            }\n            \n            addNode(x, y) {\n                const node = {\n                    id: this.nextNodeId++,\n                    x: x,\n                    y: y,\n                    label: String.fromCharCode(65 + (this.nodes.length % 26)) // A, B, C, ...\n                };\n                this.nodes.push(node);\n                return node;\n            }\n            \n            addEdge(fromNode, toNode, weight = 1) {\n                // Check if edge already exists\n                if (this.edges.some(edge => \n                    (edge.from === fromNode.id && edge.to === toNode.id) || \n                    (edge.from === toNode.id && edge.to === fromNode.id))) {\n                    return null;\n                }\n                \n                const edge = {\n                    from: fromNode.id,\n                    to: toNode.id,\n                    weight: parseInt(weight) || 1\n                };\n                this.edges.push(edge);\n                return edge;\n            }\n            \n            removeNode(nodeId) {\n                // Remove the node\n                this.nodes = this.nodes.filter(node => node.id !== nodeId);\n                // Remove all edges connected to this node\n                this.edges = this.edges.filter(edge => edge.from !== nodeId && edge.to !== nodeId);\n            }\n            \n            removeEdge(fromNodeId, toNodeId) {\n                this.edges = this.edges.filter(edge => \n                    !(edge.from === fromNodeId && edge.to === toNodeId));\n            }\n            \n            getNode(id) {\n                return this.nodes.find(node => node.id === id);\n            }\n            \n            getEdgesFromNode(nodeId) {\n                return this.edges.filter(edge => edge.from === nodeId);\n            }\n            \n            // Bellman-Ford algorithm implementation\n            bellmanFord(sourceId) {\n                // Initialize distances\n                const distances = {};\n                const predecessors = {};\n                \n                // Initialize all distances to Infinity and predecessors to null\n                this.nodes.forEach(node => {\n                    distances[node.id] = node.id === sourceId ? 0 : Infinity;\n                    predecessors[node.id] = null;\n                });\n                \n                const steps = [];\n                \n                // Relax edges repeatedly (V-1 times)\n                for (let i = 0; i < this.nodes.length - 1; i++) {\n                    let relaxed = false;\n                    \n                    // Create a step snapshot\n                    const step = {\n                        iteration: i + 1,\n                        distances: {...distances},\n                        predecessors: {...predecessors},\n                        relaxedEdges: []\n                    };\n                    \n                    // Relax each edge\n                    this.edges.forEach(edge => {\n                        if (distances[edge.from] !== Infinity && \n                            distances[edge.from] + edge.weight < distances[edge.to]) {\n                            \n                            distances[edge.to] = distances[edge.from] + edge.weight;\n                            predecessors[edge.to] = edge.from;\n                            relaxed = true;\n                            \n                            step.relaxedEdges.push({\n                                from: edge.from,\n                                to: edge.to,\n                                weight: edge.weight\n                            });\n                        }\n                    });\n                    \n                    steps.push(step);\n                    \n                    // If no relaxation occurred, we can stop early\n                    if (!relaxed) break;\n                }\n                \n                // Check for negative cycles\n                let negativeCycle = false;\n                const negativeCycleEdges = [];\n                \n                this.edges.forEach(edge => {\n                    if (distances[edge.from] !== Infinity && \n                        distances[edge.from] + edge.weight < distances[edge.to]) {\n                        negativeCycle = true;\n                        negativeCycleEdges.push({\n                            from: edge.from,\n                            to: edge.to,\n                            weight: edge.weight\n                        });\n                    }\n                });\n                \n                // Add final step with negative cycle info if applicable\n                steps.push({\n                    iteration: this.nodes.length,\n                    distances: {...distances},\n                    predecessors: {...predecessors},\n                    relaxedEdges: [],\n                    negativeCycle: negativeCycle,\n                    negativeCycleEdges: negativeCycleEdges\n                });\n                \n                return {\n                    distances: distances,\n                    predecessors: predecessors,\n                    steps: steps,\n                    hasNegativeCycle: negativeCycle\n                };\n            }\n        }\n\n        // Visualization controller\n        class BellmanFordVisualizer {\n            constructor(canvasId) {\n                this.canvas = document.getElementById(canvasId);\n                this.ctx = this.canvas.getContext('2d');\n                this.graph = new Graph();\n                this.sourceNodeId = null;\n                this.algorithmResult = null;\n                this.currentStep = 0;\n                this.isRunning = false;\n                this.mode = 'add-node'; // 'add-node', 'add-edge', 'move-node', 'delete'\n                this.selectedNode = null;\n                this.edgeWeightInput = null;\n                \n                // Set canvas size\n                this.resizeCanvas();\n                window.addEventListener('resize', () => this.resizeCanvas());\n                \n                // Initialize event listeners\n                this.setupEventListeners();\n                this.setupUI();\n                \n                // Draw initial empty graph\n                this.draw();\n            }\n            \n            resizeCanvas() {\n                const container = this.canvas.parentElement;\n                this.canvas.width = container.clientWidth;\n                this.canvas.height = container.clientHeight;\n                this.draw();\n            }\n            \n            setupEventListeners() {\n                // Canvas mouse events\n                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));\n                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));\n                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));\n                \n                // Mode buttons\n                document.getElementById('add-node-btn').addEventListener('click', () => this.setMode('add-node'));\n                document.getElementById('add-edge-btn').addEventListener('click', () => this.setMode('add-edge'));\n                document.getElementById('move-node-btn').addEventListener('click', () => this.setMode('move-node'));\n                document.getElementById('delete-btn').addEventListener('click', () => this.setMode('delete'));\n                \n                // Control buttons\n                document.getElementById('run-algorithm').addEventListener('click', () => this.runAlgorithm());\n                document.getElementById('reset-graph').addEventListener('click', () => this.resetGraph());\n                document.getElementById('step-forward').addEventListener('click', () => this.stepForward());\n                document.getElementById('step-backward').addEventListener('click', () => this.stepBackward());\n            }\n            \n            setupUI() {\n                // Create edge weight input (initially hidden)\n                this.edgeWeightInput = document.createElement('input');\n                this.edgeWeightInput.type = 'number';\n                this.edgeWeightInput.value = '1';\n                this.edgeWeightInput.style.position = 'absolute';\n                this.edgeWeightInput.style.display = 'none';\n                this.edgeWeightInput.style.zIndex = '10';\n                this.canvas.parentElement.appendChild(this.edgeWeightInput);\n                \n                this.edgeWeightInput.addEventListener('keydown', (e) => {\n                    if (e.key === 'Enter') {\n                        this.finalizeEdge();\n                    } else if (e.key === 'Escape') {\n                        this.cancelEdge();\n                    }\n                });\n            }\n            \n            setMode(mode) {\n                this.mode = mode;\n                \n                // Update UI\n                document.querySelectorAll('.mode-btn').forEach(btn => {\n                    btn.classList.remove('active');\n                });\n                document.getElementById(`${mode}-btn`).classList.add('active');\n                \n                // Reset selection state\n                this.selectedNode = null;\n                this.draw();\n            }\n            \n            handleMouseDown(e) {\n                const rect = this.canvas.getBoundingClientRect();\n                const x = e.clientX - rect.left;\n                const y = e.clientY - rect.top;\n                \n                const node = this.getNodeAt(x, y);\n                \n                switch (this.mode) {\n                    case 'add-node':\n                        if (!node) {\n                            this.graph.addNode(x, y);\n                            this.draw();\n                        }\n                        break;\n                        \n                    case 'add-edge':\n                        if (node) {\n                            if (!this.selectedNode) {\n                                this.selectedNode = node;\n                                this.highlightNode(node);\n                            } else if (this.selectedNode.id !== node.id) {\n                                // Show weight input\n                                this.showEdgeWeightInput(x, y, this.selectedNode, node);\n                            }\n                        }\n                        break;\n                        \n                    case 'move-node':\n                        if (node) {\n                            this.selectedNode = node;\n                            this.isDragging = true;\n                        }\n                        break;\n                        \n                    case 'delete':\n                        if (node) {\n                            this.graph.removeNode(node.id);\n                            if (this.sourceNodeId === node.id) {\n                                this.sourceNodeId = null;\n                            }\n                            this.draw();\n                        } else {\n                            // Check if clicking on an edge\n                            const edge = this.getEdgeAt(x, y);\n                            if (edge) {\n                                this.graph.removeEdge(edge.from, edge.to);\n                                this.draw();\n                            }\n                        }\n                        break;\n                }\n                \n                // Set source node if not running algorithm\n                if (!this.isRunning && node && this.mode !== 'add-edge' && this.mode !== 'delete') {\n                    this.sourceNodeId = node.id;\n                    this.draw();\n                }\n            }\n            \n            handleMouse"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Bellman-Ford Algorithm"
    }
  ],
  "topic": "Bellman-Ford Algorithm",
  "hasFSM": false,
  "hasTest": true
}