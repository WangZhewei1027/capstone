{
  "id": "6e09e031-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:20:00.607Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency List",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Adjacency List</title>\n    <style>\n        * {\n            box-sizing: border-box;\n            margin: 0;\n            padding: 0;\n        }\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            min-height: 100vh;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            padding: 20px;\n        }\n        .container {\n            max-width: 1200px;\n            width: 100%;\n            margin: 0 auto;\n        }\n        header {\n            text-align: center;\n            color: white;\n            margin-bottom: 30px;\n            padding: 20px;\n        }\n        h1 {\n            font-size: 2.5rem;\n            margin-bottom: 10px;\n            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);\n        }\n        .subtitle {\n            font-size: 1.2rem;\n            opacity: 0.9;\n            max-width: 800px;\n            margin: 0 auto;\n            line-height: 1.5;\n        }\n        .content {\n            display: grid;\n            grid-template-columns: 1fr 1px 1fr;\n            gap: 30px;\n            background: white;\n            border-radius: 15px;\n            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);\n            overflow: hidden;\n            margin-bottom: 30px;\n        }\n        @media (max-width: 768px) {\n            .content {\n                grid-template-columns: 1fr;\n            }\n            .divider {\n                display: none;\n            }\n        }\n        .panel {\n            padding: 30px;\n        }\n        .divider {\n            background: #eee;\n            width: 1px;\n        }\n        h2 {\n            color: #5a4fcf;\n            margin-bottom: 20px;\n            font-size: 1.8rem;\n        }\n        .graph-input {\n            margin-bottom: 25px;\n        }\n        .graph-input label {\n            display: block;\n            margin-bottom: 10px;\n            font-weight: 600;\n            color: #444;\n        }\n        textarea {\n            width: 100%;\n            height: 120px;\n            padding: 15px;\n            border: 2px solid #ddd;\n            border-radius: 8px;\n            font-family: 'Courier New', monospace;\n            font-size: 14px;\n            resize: vertical;\n            transition: border-color 0.3s;\n        }\n        textarea:focus {\n            outline: none;\n            border-color: #5a4fcf;\n        }\n        .instructions {\n            background: #f9f9f9;\n            padding: 15px;\n            border-radius: 8px;\n            font-size: 0.9rem;\n            line-height: 1.5;\n            margin-top: 10px;\n            border-left: 4px solid #5a4fcf;\n        }\n        .instructions code {\n            background: #eee;\n            padding: 2px 4px;\n            border-radius: 3px;\n            font-family: 'Courier New', monospace;\n        }\n        .btn {\n            background: linear-gradient(to right, #5a4fcf, #6a5af9);\n            color: white;\n            border: none;\n            padding: 12px 25px;\n            border-radius: 8px;\n            font-size: 1rem;\n            font-weight: 600;\n            cursor: pointer;\n            transition: transform 0.2s, box-shadow 0.2s;\n            margin-top: 10px;\n        }\n        .btn:hover {\n            transform: translateY(-2px);\n            box-shadow: 0 5px 15px rgba(90, 79, 207, 0.4);\n        }\n        .btn:active {\n            transform: translateY(0);\n        }\n        .visualization {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n        }\n        #graphCanvas {\n            border: 2px solid #eee;\n            border-radius: 10px;\n            background: white;\n            margin-top: 20px;\n            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);\n        }\n        .adjacency-list {\n            margin-top: 20px;\n            width: 100%;\n        }\n        .list-title {\n            font-weight: 600;\n            margin-bottom: 10px;\n            color: #444;\n        }\n        .list-container {\n            background: #f9f9f9;\n            border-radius: 8px;\n            padding: 15px;\n            font-family: 'Courier New', monospace;\n            max-height: 200px;\n            overflow-y: auto;\n            border: 1px solid #eee;\n        }\n        .legend {\n            display: flex;\n            justify-content: center;\n            margin-top: 20px;\n            flex-wrap: wrap;\n            gap: 15px;\n        }\n        .legend-item {\n            display: flex;\n            align-items: center;\n            font-size: 0.9rem;\n        }\n        .legend-color {\n            width: 20px;\n            height: 20px;\n            border-radius: 50%;\n            margin-right: 8px;\n        }\n        .operations {\n            margin-top: 20px;\n        }\n        .operations h3 {\n            margin-bottom: 10px;\n            color: #444;\n        }\n        .operation-buttons {\n            display: flex;\n            gap: 10px;\n            flex-wrap: wrap;\n        }\n        .operation-btn {\n            background: #f1f1f1;\n            border: 1px solid #ddd;\n            padding: 8px 15px;\n            border-radius: 5px;\n            cursor: pointer;\n            transition: background 0.2s;\n            font-size: 0.9rem;\n        }\n        .operation-btn:hover {\n            background: #e9e9e9;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>Adjacency List Visualization</h1>\n            <p class=\"subtitle\">\n                An adjacency list is a collection of lists used to represent a finite graph. Each list describes the set of neighbors of a vertex in the graph. \n                This data structure is efficient for sparse graphs and is widely used in graph algorithms.\n            </p>\n        </header>\n        \n        <div class=\"content\">\n            <div class=\"panel\">\n                <h2>Graph Input</h2>\n                <div class=\"graph-input\">\n                    <label for=\"graphData\">Enter Graph Data (JSON format):</label>\n                    <textarea id=\"graphData\">{\n  \"A\": [\"B\", \"C\"],\n  \"B\": [\"A\", \"D\", \"E\"],\n  \"C\": [\"A\", \"F\"],\n  \"D\": [\"B\"],\n  \"E\": [\"B\", \"F\"],\n  \"F\": [\"C\", \"E\"]\n}</textarea>\n                    \n                    <div class=\"instructions\">\n                        <p><strong>Format:</strong> Each key is a vertex, and its value is an array of adjacent vertices.</p>\n                        <p><strong>Example:</strong> <code>{\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"D\"]}</code> means A is connected to B and C, and B is connected to A and D.</p>\n                    </div>\n                    \n                    <button id=\"visualizeBtn\" class=\"btn\">Visualize Graph</button>\n                </div>\n                \n                <div class=\"operations\">\n                    <h3>Graph Operations</h3>\n                    <div class=\"operation-buttons\">\n                        <button class=\"operation-btn\" id=\"dfsBtn\">DFS Traversal</button>\n                        <button class=\"operation-btn\" id=\"bfsBtn\">BFS Traversal</button>\n                        <button class=\"operation-btn\" id=\"resetBtn\">Reset Visualization</button>\n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"divider\"></div>\n            \n            <div class=\"panel\">\n                <h2>Visualization</h2>\n                <div class=\"visualization\">\n                    <canvas id=\"graphCanvas\" width=\"500\" height=\"400\"></canvas>\n                    \n                    <div class=\"legend\">\n                        <div class=\"legend-item\">\n                            <div class=\"legend-color\" style=\"background-color: #5a4fcf;\"></div>\n                            <span>Vertex</span>\n                        </div>\n                        <div class=\"legend-item\">\n                            <div class=\"legend-color\" style=\"background-color: #e74c3c;\"></div>\n                            <span>Visited (DFS/BFS)</span>\n                        </div>\n                        <div class=\"legend-item\">\n                            <div class=\"legend-color\" style=\"background-color: #2ecc71;\"></div>\n                            <span>Current</span>\n                        </div>\n                    </div>\n                </div>\n                \n                <div class=\"adjacency-list\">\n                    <div class=\"list-title\">Adjacency List Representation:</div>\n                    <div class=\"list-container\" id=\"adjacencyListText\"></div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        // DOM elements\n        const graphDataTextarea = document.getElementById('graphData');\n        const visualizeBtn = document.getElementById('visualizeBtn');\n        const graphCanvas = document.getElementById('graphCanvas');\n        const adjacencyListText = document.getElementById('adjacencyListText');\n        const dfsBtn = document.getElementById('dfsBtn');\n        const bfsBtn = document.getElementById('bfsBtn');\n        const resetBtn = document.getElementById('resetBtn');\n        \n        // Canvas context\n        const ctx = graphCanvas.getContext('2d');\n        \n        // Graph data and state\n        let graph = {};\n        let vertices = [];\n        let animationId = null;\n        let visitedVertices = new Set();\n        let currentVertex = null;\n        \n        // Initialize\n        displayAdjacencyList();\n        \n        // Event listeners\n        visualizeBtn.addEventListener('click', () => {\n            try {\n                const input = graphDataTextarea.value.trim();\n                graph = JSON.parse(input);\n                validateGraph();\n                vertices = Object.keys(graph);\n                resetVisualization();\n                displayAdjacencyList();\n                drawGraph();\n            } catch (error) {\n                alert('Invalid JSON format. Please check your input.');\n                console.error(error);\n            }\n        });\n        \n        dfsBtn.addEventListener('click', () => {\n            if (Object.keys(graph).length === 0) return;\n            resetVisualization();\n            performDFS();\n        });\n        \n        bfsBtn.addEventListener('click', () => {\n            if (Object.keys(graph).length === 0) return;\n            resetVisualization();\n            performBFS();\n        });\n        \n        resetBtn.addEventListener('click', resetVisualization);\n        \n        // Validate graph structure\n        function validateGraph() {\n            for (const vertex in graph) {\n                if (!Array.isArray(graph[vertex])) {\n                    throw new Error(`Value for vertex ${vertex} must be an array`);\n                }\n                \n                // Check if all neighbors exist in the graph\n                for (const neighbor of graph[vertex]) {\n                    if (!(neighbor in graph)) {\n                        throw new Error(`Vertex ${neighbor} is not defined in the graph`);\n                    }\n                    \n                    // Check if the graph is undirected (symmetric)\n                    if (!graph[neighbor].includes(vertex)) {\n                        console.warn(`Warning: Edge from ${vertex} to ${neighbor} exists, but not from ${neighbor} to ${vertex}`);\n                    }\n                }\n            }\n        }\n        \n        // Display adjacency list as text\n        function displayAdjacencyList() {\n            if (Object.keys(graph).length === 0) {\n                adjacencyListText.innerHTML = 'Enter graph data and click \"Visualize Graph\"';\n                return;\n            }\n            \n            let html = '';\n            for (const vertex in graph) {\n                html += `<strong>${vertex}:</strong> [${graph[vertex].join(', ')}]<br>`;\n            }\n            adjacencyListText.innerHTML = html;\n        }\n        \n        // Reset visualization state\n        function resetVisualization() {\n            visitedVertices.clear();\n            currentVertex = null;\n            if (animationId) {\n                cancelAnimationFrame(animationId);\n                animationId = null;\n            }\n            drawGraph();\n        }\n        \n        // Draw the graph on canvas\n        function drawGraph() {\n            ctx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);\n            \n            if (Object.keys(graph).length === 0) return;\n            \n            // Calculate vertex positions in a circular layout\n            const centerX = graphCanvas.width / 2;\n            const centerY = graphCanvas.height / 2;\n            const radius = Math.min(centerX, centerY) * 0.7;\n            const angleStep = (2 * Math.PI) / vertices.length;\n            \n            const vertexPositions = {};\n            \n            // Draw edges first (so they appear behind vertices)\n            for (let i = 0; i < vertices.length; i++) {\n                const vertex = vertices[i];\n                const angle = i * angleStep;\n                const x = centerX + radius * Math.cos(angle);\n                const y = centerY + radius * Math.sin(angle);\n                vertexPositions[vertex] = { x, y };\n                \n                // Draw edges to neighbors\n                for (const neighbor of graph[vertex]) {\n                    const neighborIndex = vertices.indexOf(neighbor);\n                    if (neighborIndex > i) { // Draw each edge only once\n                        const neighborAngle = neighborIndex * angleStep;\n                        const neighborX = centerX + radius * Math.cos(neighborAngle);\n                        const neighborY = centerY + radius * Math.sin(neighborAngle);\n                        \n                        // Draw line\n                        ctx.beginPath();\n                        ctx.moveTo(x, y);\n                        ctx.lineTo(neighborX, neighborY);\n                        ctx.strokeStyle = '#ddd';\n                        ctx.lineWidth = 2;\n                        ctx.stroke();\n                        \n                        // Draw arrowhead in the middle of the edge\n                        const midX = (x + neighborX) / 2;\n                        const midY = (y + neighborY) / 2;\n                        \n                        // Calculate angle of the line\n                        const angle = Math.atan2(neighborY - y, neighborX - x);\n                        \n                        // Draw arrowhead\n                        ctx.save();\n                        ctx.translate(midX, midY);\n                        ctx.rotate(angle);\n                        \n                        ctx.beginPath();\n                        ctx.moveTo(0, 0);\n                        ctx.lineTo(-10, -5);\n                        ctx.lineTo(-10, 5);\n                        ctx.closePath();\n                        ctx.fillStyle = '#ddd';\n                        ctx.fill();\n                        \n                        ctx.restore();\n                    }\n                }\n            }\n            \n            // Draw vertices\n            for (const vertex in vertexPositions) {\n                const pos = vertexPositions[vertex];\n                \n                // Determine vertex color based on state\n                let fillColor = '#5a4fcf'; // Default\n                if (currentVertex === vertex) {\n                    fillColor = '#2ecc71'; // Current\n                } else if (visitedVertices.has(vertex)) {\n                    fillColor = '#e74c3c'; // Visited\n                }\n                \n                // Draw vertex circle\n                ctx.beginPath();\n                ctx.arc(pos.x, pos.y, 20, 0, 2 * Math.PI);\n                ctx.fillStyle = fillColor;\n                ctx.fill();\n                ctx.strokeStyle = '#fff';\n                ctx.lineWidth = 2;\n                ctx.stroke();\n                \n                // Draw vertex label\n                ctx.fillStyle = 'white';\n                ctx.font = 'bold 16px Arial';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillText(vertex, pos.x, pos.y);\n            }\n        }\n        \n        // Perform Depth-First Search\n        function performDFS() {\n            resetVisualization();\n            const startVertex = vertices[0];\n            const stack = [startVertex];\n            visitedVertices.add(startVertex);\n            currentVertex = startVertex;\n            \n            let step = 0;\n            \n            function animateDFS() {\n                if (stack.length === 0) {\n                    currentVertex = null;\n                    drawGraph();\n                    return;\n                }\n                \n                currentVertex = stack.pop();\n                drawGraph();\n                \n                // Wait before processing next vertex\n                setTimeout(() => {\n                    for (const neighbor of graph[currentVertex]) {\n                        if (!visitedVertices.has(neighbor)) {\n                            visitedVertices.add(neighbor);\n                            stack.push(neighbor);\n                        }\n                    }\n                    \n                    step++;\n                    if (step < vertices.length * 2) { // Safety limit\n                        animationId = requestAnimationFrame(animateDFS);\n                    }\n                }, 800);\n            }\n            \n            animateDFS();\n        }\n        \n        // Perform Breadth-First Search\n        function performBFS() {\n            resetVisualization();\n            const startVertex = vertices[0];\n            const queue = [startVertex];\n            visitedVertices.add(startVertex);\n            currentVertex = startVertex;\n            \n            let step = 0;\n            \n            function animateBFS() {\n                if (queue.length === 0) {\n                    currentVertex = null;\n                    drawGraph();\n                    return;\n                }\n                \n                currentVertex = queue.shift();\n                drawGraph();\n                \n                // Wait before processing next vertex\n                setTimeout(() => {\n                    for (const neighbor of graph[currentVertex]) {\n                        if (!visitedVertices.has(neighbor)) {\n                            visitedVertices.add(neighbor);\n                            queue.push(neighbor);\n                        }\n                    }\n                    \n                    step++;\n                    if (step < vertices.length * 2) { // Safety limit\n                        animationId = requestAnimationFrame(animateBFS);\n                    }\n                }, 800);\n            }\n            \n            animateBFS();\n        }\n        \n        // Initial draw with sample data\n        try {\n            graph = JSON.parse(graphDataTextarea.value);\n            vertices = Object.keys(graph);\n            drawGraph();\n        } catch (error) {\n            console.error('Error parsing initial graph data:', error);\n        }\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency List"
    }
  ],
  "topic": "Adjacency List",
  "hasFSM": false,
  "hasTest": true
}