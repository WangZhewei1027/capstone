{
  "id": "6e09b922-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:19:34.092Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Graph Theory - Directed vs Undirected</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        \n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n        }\n        \n        h1 {\n            text-align: center;\n            color: #333;\n            margin-bottom: 30px;\n        }\n        \n        .graph-container {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 40px;\n            justify-content: center;\n        }\n        \n        .graph-section {\n            background: white;\n            padding: 20px;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n            width: 500px;\n            min-height: 400px;\n        }\n        \n        h2 {\n            color: #555;\n            border-bottom: 2px solid #ddd;\n            padding-bottom: 10px;\n        }\n        \n        .graph-canvas {\n            border: 1px solid #ddd;\n            margin-top: 15px;\n            cursor: pointer;\n        }\n        \n        .controls {\n            margin: 15px 0;\n            text-align: center;\n        }\n        \n        button {\n            background-color: #4CAF50;\n            color: white;\n            padding: 8px 16px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            margin: 0 5px;\n        }\n        \n        button:hover {\n            background-color: #45a049;\n        }\n        \n        .node {\n            position: absolute;\n            width: 40px;\n            height: 40px;\n            background-color: #4CAF50;\n            border-radius: 50%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            color: white;\n            font-weight: bold;\n            cursor: move;\n            user-select: none;\n        }\n        \n        .explanation {\n            margin-top: 20px;\n            background-color: #e8f5e8;\n            padding: 15px;\n            border-radius: 5px;\n            border-left: 4px solid #4CAF50;\n        }\n        \n        .highlight {\n            background-color: #ffeb3b;\n            padding: 2px 4px;\n            border-radius: 3px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Graph Theory: Directed vs Undirected Graphs</h1>\n        \n        <div class=\"graph-container\">\n            <div class=\"graph-section\">\n                <h2>Undirected Graph</h2>\n                <div class=\"controls\">\n                    <button onclick=\"addNode('undirected')\">Add Node</button>\n                    <button onclick=\"addEdge('undirected')\">Add Edge</button>\n                    <button onclick=\"clearGraph('undirected')\">Clear</button>\n                </div>\n                <canvas id=\"undirectedCanvas\" width=\"460\" height=\"300\" class=\"graph-canvas\"></canvas>\n                <div class=\"explanation\">\n                    <p><span class=\"highlight\">Undirected Graph:</span> Edges have no direction. If node A is connected to node B, then B is automatically connected to A.</p>\n                    <p><strong>Example:</strong> Friendship network (if Alice is friends with Bob, Bob is friends with Alice).</p>\n                </div>\n            </div>\n            \n            <div class=\"graph-section\">\n                <h2>Directed Graph (Digraph)</h2>\n                <div class=\"controls\">\n                    <button onclick=\"addNode('directed')\">Add Node</button>\n                    <button onclick=\"addEdge('directed')\">Add Edge</button>\n                    <button onclick=\"clearGraph('directed')\">Clear</button>\n                </div>\n                <canvas id=\"directedCanvas\" width=\"460\" height=\"300\" class=\"graph-canvas\"></canvas>\n                <div class=\"explanation\">\n                    <p><span class=\"highlight\">Directed Graph:</span> Edges have direction. A â†’ B means connection from A to B, but not necessarily from B to A.</p>\n                    <p><strong>Example:</strong> Web page links (page A links to page B, but B may not link back to A).</p>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        class Graph {\n            constructor(type) {\n                this.type = type; // 'directed' or 'undirected'\n                this.nodes = [];\n                this.edges = [];\n                this.selectedNode = null;\n                this.edgeStart = null;\n                this.canvas = document.getElementById(type + 'Canvas');\n                this.ctx = this.canvas.getContext('2d');\n                this.nodeRadius = 20;\n                \n                this.setupEventListeners();\n                this.draw();\n            }\n            \n            setupEventListeners() {\n                this.canvas.addEventListener('click', (e) => this.handleClick(e));\n                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));\n            }\n            \n            handleClick(e) {\n                const rect = this.canvas.getBoundingClientRect();\n                const x = e.clientX - rect.left;\n                const y = e.clientY - rect.top;\n                \n                // Check if clicked on existing node\n                const clickedNode = this.getNodeAt(x, y);\n                \n                if (clickedNode) {\n                    if (this.edgeStart) {\n                        // Complete edge creation\n                        if (this.edgeStart !== clickedNode) {\n                            this.addEdge(this.edgeStart, clickedNode);\n                        }\n                        this.edgeStart = null;\n                    } else {\n                        // Select node for potential edge creation\n                        this.selectedNode = clickedNode;\n                    }\n                } else {\n                    // Add new node\n                    this.addNode(x, y);\n                    this.selectedNode = null;\n                }\n                \n                this.draw();\n            }\n            \n            handleMouseMove(e) {\n                if (this.selectedNode) {\n                    const rect = this.canvas.getBoundingClientRect();\n                    const x = e.clientX - rect.left;\n                    const y = e.clientY - rect.top;\n                    \n                    this.selectedNode.x = Math.max(this.nodeRadius, Math.min(this.canvas.width - this.nodeRadius, x));\n                    this.selectedNode.y = Math.max(this.nodeRadius, Math.min(this.canvas.height - this.nodeRadius, y));\n                    this.draw();\n                }\n            }\n            \n            getNodeAt(x, y) {\n                for (let node of this.nodes) {\n                    const distance = Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2);\n                    if (distance <= this.nodeRadius) {\n                        return node;\n                    }\n                }\n                return null;\n            }\n            \n            addNode(x, y) {\n                const node = {\n                    id: this.nodes.length + 1,\n                    x: x || Math.random() * (this.canvas.width - 80) + 40,\n                    y: y || Math.random() * (this.canvas.height - 80) + 40\n                };\n                this.nodes.push(node);\n            }\n            \n            addEdge(fromNode, toNode) {\n                // Check if edge already exists\n                const existingEdge = this.edges.find(edge => \n                    edge.from === fromNode && edge.to === toNode\n                );\n                \n                if (!existingEdge) {\n                    this.edges.push({ from: fromNode, to: toNode });\n                    \n                    // For undirected graphs, add reverse edge automatically\n                    if (this.type === 'undirected') {\n                        const reverseEdge = this.edges.find(edge => \n                            edge.from === toNode && edge.to === fromNode\n                        );\n                        if (!reverseEdge) {\n                            this.edges.push({ from: toNode, to: fromNode });\n                        }\n                    }\n                }\n            }\n            \n            clear() {\n                this.nodes = [];\n                this.edges = [];\n                this.selectedNode = null;\n                this.edgeStart = null;\n                this.draw();\n            }\n            \n            draw() {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                \n                // Draw edges\n                this.ctx.strokeStyle = '#333';\n                this.ctx.lineWidth = 2;\n                \n                for (let edge of this.edges) {\n                    this.drawEdge(edge.from, edge.to);\n                }\n                \n                // Draw nodes\n                for (let node of this.nodes) {\n                    this.drawNode(node);\n                }\n                \n                // Draw temporary edge if creating one\n                if (this.edgeStart) {\n                    this.ctx.strokeStyle = '#ff6b6b';\n                    this.ctx.setLineDash([5, 5]);\n                    this.drawEdge(this.edgeStart, { x: this.canvas.width / 2, y: this.canvas.height / 2 });\n                    this.ctx.setLineDash([]);\n                }\n            }\n            \n            drawEdge(from, to) {\n                this.ctx.beginPath();\n                this.ctx.moveTo(from.x, from.y);\n                \n                if (this.type === 'directed') {\n                    // Draw arrow for directed edges\n                    const angle = Math.atan2(to.y - from.y, to.x - from.x);\n                    const headLength = 10;\n                    const fromAdjusted = {\n                        x: from.x + Math.cos(angle) * this.nodeRadius,\n                        y: from.y + Math.sin(angle) * this.nodeRadius\n                    };\n                    const toAdjusted = {\n                        x: to.x - Math.cos(angle) * this.nodeRadius,\n                        y: to.y - Math.sin(angle) * this.nodeRadius\n                    };\n                    \n                    this.ctx.lineTo(toAdjusted.x, toAdjusted.y);\n                    this.ctx.stroke();\n                    \n                    // Arrow head\n                    this.ctx.beginPath();\n                    this.ctx.moveTo(toAdjusted.x, toAdjusted.y);\n                    this.ctx.lineTo(\n                        toAdjusted.x - headLength * Math.cos(angle - Math.PI / 6),\n                        toAdjusted.y - headLength * Math.sin(angle - Math.PI / 6)\n                    );\n                    this.ctx.lineTo(\n                        toAdjusted.x - headLength * Math.cos(angle + Math.PI / 6),\n                        toAdjusted.y - headLength * Math.sin(angle + Math.PI / 6)\n                    );\n                    this.ctx.closePath();\n                    this.ctx.fillStyle = '#333';\n                    this.ctx.fill();\n                } else {\n                    // Straight line for undirected edges\n                    this.ctx.lineTo(to.x, to.y);\n                    this.ctx.stroke();\n                }\n            }\n            \n            drawNode(node) {\n                this.ctx.fillStyle = node === this.selectedNode ? '#ff6b6b' : '#4CAF50';\n                this.ctx.beginPath();\n                this.ctx.arc(node.x, node.y, this.nodeRadius, 0, 2 * Math.PI);\n                this.ctx.fill();\n                \n                this.ctx.fillStyle = 'white';\n                this.ctx.font = '16px Arial';\n                this.ctx.textAlign = 'center';\n                this.ctx.textBaseline = 'middle';\n                this.ctx.fillText(node.id, node.x, node.y);\n            }\n        }\n        \n        // Initialize graphs\n        const undirectedGraph = new Graph('undirected');\n        const directedGraph = new Graph('directed');\n        \n        // Add some demo nodes and edges\n        function initializeDemoGraphs() {\n            // Undirected graph demo\n            undirectedGraph.addNode(100, 100);\n            undirectedGraph.addNode(200, 150);\n            undirectedGraph.addNode(150, 250);\n            undirectedGraph.addEdge(undirectedGraph.nodes[0], undirectedGraph.nodes[1]);\n            undirectedGraph.addEdge(undirectedGraph.nodes[1], undirectedGraph.nodes[2]);\n            undirectedGraph.addEdge(undirectedGraph.nodes[2], undirectedGraph.nodes[0]);\n            \n            // Directed graph demo\n            directedGraph.addNode(100, 100);\n            directedGraph.addNode(300, 100);\n            directedGraph.addNode(200, 250);\n            directedGraph.addEdge(directedGraph.nodes[0], directedGraph.nodes[1]);\n            directedGraph.addEdge(directedGraph.nodes[1], directedGraph.nodes[2]);\n            directedGraph.addEdge(directedGraph.nodes[2], directedGraph.nodes[0]);\n            \n            undirectedGraph.draw();\n            directedGraph.draw();\n        }\n        \n        // Global functions for buttons\n        function addNode(type) {\n            if (type === 'undirected') {\n                undirectedGraph.addNode();\n                undirectedGraph.draw();\n            } else {\n                directedGraph.addNode();\n                directedGraph.draw();\n            }\n        }\n        \n        function addEdge(type) {\n            if (type === 'undirected') {\n                if (undirectedGraph.selectedNode && !undirectedGraph.edgeStart) {\n                    undirectedGraph.edgeStart = undirectedGraph.selectedNode;\n                }\n            } else {\n                if (directedGraph.selectedNode && !directedGraph.edgeStart) {\n                    directedGraph.edgeStart = directedGraph.selectedNode;\n                }\n            }\n        }\n        \n        function clearGraph(type) {\n            if (type === 'undirected') {\n                undirectedGraph.clear();\n            } else {\n                directedGraph.clear();\n            }\n        }\n        \n        // Initialize demo on load\n        window.addEventListener('load', initializeDemoGraphs);\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": false,
  "hasTest": true
}