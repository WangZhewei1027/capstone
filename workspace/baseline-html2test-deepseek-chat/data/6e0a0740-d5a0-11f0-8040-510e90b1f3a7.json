{
  "id": "6e0a0740-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:20:13.766Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Heap Sort",
  "answer": {
    "role": "assistant",
    "content": "# Heap Sort Algorithm Demonstration\n\nHere's an interactive HTML demonstration of the Heap Sort algorithm:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Heap Sort Algorithm</title>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            max-width: 900px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n            color: #333;\n        }\n        \n        h1 {\n            text-align: center;\n            color: #2c3e50;\n        }\n        \n        .container {\n            background-color: white;\n            border-radius: 8px;\n            padding: 20px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n            margin-bottom: 20px;\n        }\n        \n        .controls {\n            display: flex;\n            justify-content: space-between;\n            margin-bottom: 20px;\n            flex-wrap: wrap;\n            gap: 10px;\n        }\n        \n        button {\n            background-color: #3498db;\n            color: white;\n            border: none;\n            padding: 8px 15px;\n            border-radius: 4px;\n            cursor: pointer;\n            transition: background-color 0.3s;\n        }\n        \n        button:hover {\n            background-color: #2980b9;\n        }\n        \n        button:disabled {\n            background-color: #bdc3c7;\n            cursor: not-allowed;\n        }\n        \n        .array-input {\n            flex-grow: 1;\n            padding: 8px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n        }\n        \n        .visualization {\n            display: flex;\n            justify-content: center;\n            align-items: flex-end;\n            height: 250px;\n            background-color: #ecf0f1;\n            border-radius: 4px;\n            padding: 10px;\n            margin-bottom: 20px;\n        }\n        \n        .element {\n            background-color: #3498db;\n            margin: 0 2px;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            color: white;\n            font-weight: bold;\n            transition: all 0.3s ease;\n        }\n        \n        .current {\n            background-color: #e74c3c;\n        }\n        \n        .sorted {\n            background-color: #2ecc71;\n        }\n        \n        .heap-node {\n            background-color: #f39c12;\n        }\n        \n        .code-container {\n            background-color: #2c3e50;\n            color: #ecf0f1;\n            padding: 15px;\n            border-radius: 4px;\n            margin-top: 20px;\n            font-family: 'Courier New', monospace;\n            overflow-x: auto;\n        }\n        \n        .highlight {\n            background-color: #e74c3c;\n            padding: 2px;\n        }\n        \n        .legend {\n            display: flex;\n            justify-content: center;\n            gap: 20px;\n            margin-bottom: 20px;\n        }\n        \n        .legend-item {\n            display: flex;\n            align-items: center;\n            gap: 5px;\n        }\n        \n        .legend-color {\n            width: 20px;\n            height: 20px;\n            border-radius: 4px;\n        }\n        \n        .heap-visual {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            margin-top: 20px;\n        }\n        \n        .heap-row {\n            display: flex;\n            justify-content: center;\n            margin-bottom: 10px;\n        }\n        \n        .heap-element {\n            width: 40px;\n            height: 40px;\n            border-radius: 50%;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            background-color: #f39c12;\n            color: white;\n            font-weight: bold;\n            margin: 0 10px;\n        }\n        \n        .heap-connections {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            top: 0;\n            left: 0;\n            pointer-events: none;\n        }\n        \n        .heap-container {\n            position: relative;\n        }\n    </style>\n</head>\n<body>\n    <h1>Heap Sort Algorithm Visualization</h1>\n    \n    <div class=\"container\">\n        <div class=\"controls\">\n            <input type=\"text\" id=\"arrayInput\" class=\"array-input\" placeholder=\"Enter numbers separated by commas (e.g., 5, 2, 8, 1, 9)\">\n            <button id=\"resetBtn\">Reset</button>\n            <button id=\"randomBtn\">Generate Random Array</button>\n            <button id=\"startBtn\">Start Sorting</button>\n            <button id=\"stepBtn\">Next Step</button>\n        </div>\n        \n        <div class=\"legend\">\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background-color: #3498db;\"></div>\n                <span>Unsorted</span>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background-color: #f39c12;\"></div>\n                <span>Heap Node</span>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background-color: #e74c3c;\"></div>\n                <span>Current Element</span>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background-color: #2ecc71;\"></div>\n                <span>Sorted</span>\n            </div>\n        </div>\n        \n        <div id=\"visualization\" class=\"visualization\">\n            <!-- Array elements will be generated here -->\n        </div>\n        \n        <div class=\"heap-container\">\n            <h3>Heap Structure</h3>\n            <div id=\"heapVisual\" class=\"heap-visual\">\n                <!-- Heap visualization will be generated here -->\n            </div>\n        </div>\n        \n        <div class=\"code-container\">\n            <pre id=\"codeDisplay\">\n// Heap Sort Algorithm\n\nfunction heapSort(arr) {\n    let n = arr.length;\n    \n    // Build max heap\n    for (let i = Math.floor(n/2) - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n    \n    // Extract elements from heap one by one\n    for (let i = n - 1; i > 0; i--) {\n        // Move current root to end\n        [arr[0], arr[i]] = [arr[i], arr[0]];\n        \n        // Call heapify on the reduced heap\n        heapify(arr, i, 0);\n    }\n}\n\nfunction heapify(arr, n, i) {\n    let largest = i;        // Initialize largest as root\n    let left = 2 * i + 1;   // left child\n    let right = 2 * i + 2;  // right child\n    \n    // If left child is larger than root\n    if (left < n && arr[left] > arr[largest]) {\n        largest = left;\n    }\n    \n    // If right child is larger than largest so far\n    if (right < n && arr[right] > arr[largest]) {\n        largest = right;\n    }\n    \n    // If largest is not root\n    if (largest !== i) {\n        [arr[i], arr[largest]] = [arr[largest], arr[i]];\n        \n        // Recursively heapify the affected sub-tree\n        heapify(arr, n, largest);\n    }\n}\n            </pre>\n        </div>\n    </div>\n    \n    <div class=\"container\">\n        <h2>How Heap Sort Works</h2>\n        <p>Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure. It has an O(n log n) time complexity, making it efficient for large datasets.</p>\n        \n        <h3>Steps:</h3>\n        <ol>\n            <li><strong>Build a max heap</strong> from the input data.</li>\n            <li>The largest element is at the root of the heap. Replace it with the last item of the heap followed by reducing the size of the heap by one.</li>\n            <li><strong>Heapify</strong> the root of the tree.</li>\n            <li>Repeat the above steps while the size of the heap is greater than 1.</li>\n        </ol>\n        \n        <h3>Complexity:</h3>\n        <ul>\n            <li>Time Complexity: O(n log n) in all cases</li>\n            <li>Space Complexity: O(1) as it's an in-place algorithm</li>\n        </ul>\n    </div>\n\n    <script>\n        // Algorithm state\n        let array = [];\n        let sortedArray = [];\n        let currentStep = 0;\n        let heapSize = 0;\n        let sorting = false;\n        let steps = [];\n        let currentHeap = [];\n        \n        // DOM elements\n        const arrayInput = document.getElementById('arrayInput');\n        const resetBtn = document.getElementById('resetBtn');\n        const randomBtn = document.getElementById('randomBtn');\n        const startBtn = document.getElementById('startBtn');\n        const stepBtn = document.getElementById('stepBtn');\n        const visualization = document.getElementById('visualization');\n        const heapVisual = document.getElementById('heapVisual');\n        const codeDisplay = document.getElementById('codeDisplay');\n        \n        // Initialize with a sample array\n        arrayInput.value = '5, 2, 8, 1, 9, 3, 7, 4, 6';\n        initializeArray();\n        \n        // Event listeners\n        resetBtn.addEventListener('click', initializeArray);\n        randomBtn.addEventListener('click', generateRandomArray);\n        startBtn.addEventListener('click', startSorting);\n        stepBtn.addEventListener('click', performNextStep);\n        \n        function initializeArray() {\n            const input = arrayInput.value.split(',').map(num => parseInt(num.trim())).filter(num => !isNaN(num));\n            array = input.length > 0 ? input : [5, 2, 8, 1, 9, 3, 7, 4, 6];\n            arrayInput.value = array.join(', ');\n            sortedArray = [...array];\n            currentStep = 0;\n            heapSize = array.length;\n            sorting = false;\n            steps = [];\n            visualizeArray();\n            updateButtons();\n            highlightCode(-1);\n            \n            // Initialize steps for heap sort\n            prepareHeapSort();\n        }\n        \n        function generateRandomArray() {\n            const size = Math.floor(Math.random() * 10) + 5; // 5 to 14 elements\n            array = Array.from({length: size}, () => Math.floor(Math.random() * 100) + 1);\n            arrayInput.value = array.join(', ');\n            initializeArray();\n        }\n        \n        function prepareHeapSort() {\n            // Reset steps\n            steps = [];\n            \n            // Create a copy to manipulate\n            const arr = [...array];\n            const n = arr.length;\n            \n            // Build max heap phase\n            for (let i = Math.floor(n/2) - 1; i >= 0; i--) {\n                heapify(arr, n, i, true);\n            }\n            \n            // Extract elements from heap one by one\n            for (let i = n - 1; i > 0; i--) {\n                // Save state before swapping\n                steps.push({\n                    array: [...arr],\n                    action: 'swap',\n                    index1: 0,\n                    index2: i,\n                    heapSize: i,\n                    description: `Swap root (${arr[0]}) with last element (${arr[i]})`\n                });\n                \n                // Perform swap\n                [arr[0], arr[i]] = [arr[i], arr[0]];\n                \n                // Save state after swapping\n                steps.push({\n                    array: [...arr],\n                    action: 'heapify',\n                    index: 0,\n                    heapSize: i,\n                    description: `Heapify the root (index 0)`\n                });\n                \n                // Heapify the root\n                heapify(arr, i, 0, false);\n            }\n            \n            // Final state - fully sorted\n            steps.push({\n                array: [...arr],\n                action: 'complete',\n                description: 'Array is fully sorted'\n            });\n        }\n        \n        function heapify(arr, n, i, isBuilding) {\n            let largest = i;\n            let left = 2 * i + 1;\n            let right = 2 * i + 2;\n            \n            // Save initial state\n            if (isBuilding) {\n                steps.push({\n                    array: [...arr],\n                    action: 'heapify',\n                    index: i,\n                    heapSize: n,\n                    description: `Building heap: heapify node at index ${i}`\n                });\n            }\n            \n            // Check left child\n            if (left < n && arr[left] > arr[largest]) {\n                largest = left;\n            }\n            \n            // Check right child\n            if (right < n && arr[right] > arr[largest]) {\n                largest = right;\n            }\n            \n            // If largest is not the current node, swap and heapify\n            if (largest !== i) {\n                // Save state before swapping\n                steps.push({\n                    array: [...arr],\n                    action: 'swap',\n                    index1: i,\n                    index2: largest,\n                    heapSize: n,\n                    description: `Swap ${arr[i]} at index ${i} with ${arr[largest]} at index ${largest}`\n                });\n                \n                // Perform swap\n                [arr[i], arr[largest]] = [arr[largest], arr[i]];\n                \n                // Save state after swapping\n                steps.push({\n                    array: [...arr],\n                    action: 'heapify',\n                    index: largest,\n                    heapSize: n,\n                    description: `Continue heapifying from index ${largest}`\n                });\n                \n                // Recursively heapify the affected sub-tree\n                heapify(arr, n, largest, isBuilding);\n            }\n        }\n        \n        function startSorting() {\n            if (sorting) return;\n            sorting = true;\n            updateButtons();\n            \n            // Auto-advance through steps\n            const interval = setInterval(() => {\n                if (currentStep >= steps.length) {\n                    clearInterval(interval);\n                    sorting = false;\n                    updateButtons();\n                    return;\n                }\n                \n                performNextStep();\n            }, 1500);\n        }\n        \n        function performNextStep() {\n            if (currentStep >= steps.length) return;\n            \n            const step = steps[currentStep];\n            sortedArray = [...step.array];\n            heapSize = step.heapSize || sortedArray.length;\n            \n            visualizeArray();\n            visualizeHeap();\n            highlightCode(currentStep);\n            \n            currentStep++;\n            updateButtons();\n        }\n        \n        function visualizeArray() {\n            visualization.innerHTML = '';\n            const maxValue = Math.max(...sortedArray);\n            const containerHeight = visualization.clientHeight - 20;\n            \n            sortedArray.forEach((value, index) => {\n                const element = document.createElement('div');\n                element.className = 'element';\n                element.textContent = value;\n                \n                // Calculate height based on value\n                const height = (value / maxValue) * containerHeight;\n                element.style.height = `${height}px`;\n                element.style.width = `calc(100% / ${sortedArray.length} - 4px)`;\n                \n                // Apply styling based on current state\n                if (index >= heapSize) {\n                    element.classList.add('sorted');\n                } else if (currentStep < steps.length && steps[currentStep]) {\n                    const step = steps[currentStep];\n                    if ((step.index1 === index || step.index2 === index) && step.action === 'swap') {\n                        element.classList.add('current');\n                    } else if (step.index === index && step.action === 'heapify') {\n                        element.classList.add('heap-node');\n                    }\n                }\n                \n                visualization.appendChild(element);\n            });\n        }\n        \n        function visualizeHeap() {\n            if (heapSize === 0) return;\n            \n            heapVisual.innerHTML = '';\n            \n            // Build heap structure for visualization\n            const heapElements = [];\n            for (let i = 0; i < heapSize; i++) {\n                heapElements.push({\n                    value: sortedArray[i],\n                    index: i,\n                    level: Math.floor(Math.log2(i + 1)),\n                    position: i - (Math.pow(2, Math.floor(Math.log2(i + 1))) - 1)\n                });\n            }\n            \n            // Group by level\n            const levels = {};\n            heapElements.forEach(item => {\n                if (!levels[item.level]) levels[item.level] = [];\n                levels[item.level].push(item);\n            });\n            \n            // Create rows for each level\n            Object.keys(levels).forEach(level => {\n                const row = document.createElement('div');\n                row.className = 'heap-row';\n                \n                levels[level].forEach(item => {\n                    const element = document.createElement('div');\n                    element.className = 'heap-element';\n                    element.textContent = item.value;\n                    \n                    // Highlight if this is the current node being processed\n                    if (currentStep < steps.length && steps[currentStep]) {\n                        const step = steps[currentStep];\n                        if ((step.index1 === item.index || step.index2 === item.index) && step.action === 'swap') {\n                            element.style.backgroundColor = '#e74c3c';\n                        } else if (step.index === item.index && step.action === 'heapify') {\n                            element.style.backgroundColor = '#e74c3c';\n                        }\n                    }\n                    \n                    row.appendChild(element);\n                });\n                \n                heapVisual.appendChild(row);\n            });\n            \n            // Add description if available\n            if (currentStep < steps.length && steps[currentStep]) {\n                const description = document.createElement('p');\n                description.textContent = steps[currentStep].description;\n                description.style.textAlign = 'center';\n                description.style.marginTop = '10px';\n                heapVisual.appendChild(description);\n            }\n        }\n        \n        function highlightCode(stepIndex) {\n            // Remove previous highlights\n            codeDisplay.innerHTML = codeDisplay.textContent;\n            \n            if (stepIndex < 0) return;\n            \n            // Simple highlighting based on step type\n            const codeText = codeDisplay.textContent;\n            let highlightedCode = codeText;\n            \n            if (steps[stepIndex]) {\n                const step = steps[stepIndex];\n                \n                if (step.action === 'heapify') {\n                    highlightedCode = codeText.replace(/heapify\\(arr, n, i\\)/g, '<span class=\"highlight\">heapify(arr, n, i)</span>');\n                } else if (step.action === 'swap') {\n"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap Sort"
    }
  ],
  "topic": "Heap Sort",
  "hasFSM": false,
  "hasTest": true
}