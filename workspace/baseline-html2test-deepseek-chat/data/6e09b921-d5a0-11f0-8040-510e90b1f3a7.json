{
  "id": "6e09b921-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:20:02.213Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Heap (Min/Max)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Heap Visualization (Min/Max Heap)</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 1000px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        \n        .container {\n            display: flex;\n            flex-direction: column;\n            gap: 20px;\n        }\n        \n        .controls {\n            background: white;\n            padding: 15px;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        \n        .heap-display {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px-4px rgba(0,0,0,0.1);\n            min-height: 400px;\n        }\n        \n        .tree {\n            position: relative;\n            margin: 20px 0;\n        }\n        \n        .node {\n            width: 50px;\n            height: 50px;\n            border-radius: 50%;\n            background: #4CAF50;\n            color: white;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            position: absolute;\n            font-weight: bold;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.2);\n            transition: all 0.3s ease;\n        }\n        \n        .node.highlight {\n            background: #FF9800;\n            transform: scale(1.2);\n        }\n        \n        .connection {\n            position: absolute;\n            background: #333;\n            height: 2px;\n            transform-origin: 0 0;\n        }\n        \n        .array-display {\n            margin-top: 20px;\n            display: flex;\n            justify-content: center;\n            flex-wrap: wrap;\n            gap: 10px;\n        }\n        \n        .array-cell {\n            width: 50px;\n            height: 50px;\n            background: #2196F3;\n            color: white;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            border-radius: 5px;\n            font-weight: bold;\n        }\n        \n        .array-cell.index {\n            background: #607D8B;\n            font-size: 0.8em;\n        }\n        \n        button {\n            padding: 8px 16px;\n            margin: 5px;\n            border: none;\n            border-radius: 4px;\n            background: #2196F3;\n            color: white;\n            cursor: pointer;\n            transition: background 0.3s;\n        }\n        \n        button:hover {\n            background: #1976D2;\n        }\n        \n        button:disabled {\n            background: #BDBDBD;\n            cursor: not-allowed;\n        }\n        \n        input {\n            padding: 8px;\n            margin: 5px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n        }\n        \n        .explanation {\n            background: #E3F2FD;\n            padding: 15px;\n            border-radius: 8px;\n            margin-top: 10px;\n            border-left: 4px solid #2196F3;\n        }\n        \n        .log {\n            background: #f8f8f8;\n            border: 1px solid #ddd;\n            padding: 10px;\n            border-radius: 4px;\n            max-height: 150px;\n            overflow-y: auto;\n            font-family: monospace;\n            font-size: 0.9em;\n        }\n        \n        .toggle-buttons {\n            display: flex;\n            gap: 10px;\n            margin-bottom: 10px;\n        }\n        \n        .toggle-buttons button {\n            flex: 1;\n        }\n        \n        .toggle-buttons button.active {\n            background: #FF9800;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Heap Data Structure Visualization</h1>\n        \n        <div class=\"controls\">\n            <div class=\"toggle-buttons\">\n                <button id=\"minHeapBtn\" class=\"active\">Min Heap</button>\n                <button id=\"maxHeapBtn\">Max Heap</button>\n            </div>\n            \n            <div>\n                <input type=\"number\" id=\"valueInput\" placeholder=\"Enter a number\" min=\"0\" max=\"99\">\n                <button id=\"insertBtn\">Insert</button>\n                <button id=\"removeBtn\">Remove Root</button>\n                <button id=\"randomBtn\">Insert Random</button>\n                <button id=\"clearBtn\">Clear Heap</button>\n            </div>\n        </div>\n        \n        <div class=\"heap-display\">\n            <div id=\"treeContainer\" class=\"tree\"></div>\n            <div id=\"arrayContainer\" class=\"array-display\"></div>\n        </div>\n        \n        <div class=\"explanation\">\n            <h3>Heap Properties:</h3>\n            <p id=\"heapExplanation\">\n                <strong>Min Heap:</strong> Parent nodes are always smaller than or equal to their children.<br>\n                <strong>Max Heap:</strong> Parent nodes are always greater than or equal to their children.<br>\n                Heap is a complete binary tree, meaning all levels are fully filled except possibly the last.\n            </p>\n        </div>\n        \n        <div class=\"log\">\n            <h3>Operation Log:</h3>\n            <div id=\"logContent\"></div>\n        </div>\n    </div>\n\n    <script>\n        class Heap {\n            constructor(isMinHeap = true) {\n                this.heap = [];\n                this.isMinHeap = isMinHeap;\n            }\n            \n            // Get parent index\n            parent(index) {\n                return Math.floor((index - 1) / 2);\n            }\n            \n            // Get left child index\n            leftChild(index) {\n                return 2 * index + 1;\n            }\n            \n            // Get right child index\n            rightChild(index) {\n                return 2 * index + 2;\n            }\n            \n            // Swap two elements in the heap\n            swap(i, j) {\n                [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\n            }\n            \n            // Compare based on heap type\n            compare(i, j) {\n                return this.isMinHeap \n                    ? this.heap[i] < this.heap[j] \n                    : this.heap[i] > this.heap[j];\n            }\n            \n            // Insert a new value\n            insert(value) {\n                this.heap.push(value);\n                this.heapifyUp(this.heap.length - 1);\n            }\n            \n            // Heapify up (bubble up)\n            heapifyUp(index) {\n                while (index > 0 && this.compare(index, this.parent(index))) {\n                    this.swap(index, this.parent(index));\n                    index = this.parent(index);\n                }\n            }\n            \n            // Extract root (min or max)\n            extractRoot() {\n                if (this.heap.length === 0) return null;\n                if (this.heap.length === 1) return this.heap.pop();\n                \n                const root = this.heap[0];\n                this.heap[0] = this.heap.pop();\n                this.heapifyDown(0);\n                return root;\n            }\n            \n            // Heapify down (bubble down)\n            heapifyDown(index) {\n                let extreme = index;\n                const left = this.leftChild(index);\n                const right = this.rightChild(index);\n                \n                if (left < this.heap.length && this.compare(left, extreme)) {\n                    extreme = left;\n                }\n                \n                if (right < this.heap.length && this.compare(right, extreme)) {\n                    extreme = right;\n                }\n                \n                if (extreme !== index) {\n                    this.swap(index, extreme);\n                    this.heapifyDown(extreme);\n                }\n            }\n            \n            // Get root without removing\n            peek() {\n                return this.heap.length > 0 ? this.heap[0] : null;\n            }\n            \n            // Get size\n            size() {\n                return this.heap.length;\n            }\n        }\n\n        class HeapVisualizer {\n            constructor() {\n                this.heap = new Heap(true); // Default to min heap\n                this.treeContainer = document.getElementById('treeContainer');\n                this.arrayContainer = document.getElementById('arrayContainer');\n                this.logContent = document.getElementById('logContent');\n                this.heapExplanation = document.getElementById('heapExplanation');\n                \n                this.initEventListeners();\n                this.updateDisplay();\n            }\n            \n            initEventListeners() {\n                document.getElementById('insertBtn').addEventListener('click', () => {\n                    const value = parseInt(document.getElementById('valueInput').value);\n                    if (!isNaN(value)) {\n                        this.insertValue(value);\n                        document.getElementById('valueInput').value = '';\n                    }\n                });\n                \n                document.getElementById('removeBtn').addEventListener('click', () => {\n                    this.removeRoot();\n                });\n                \n                document.getElementById('randomBtn').addEventListener('click', () => {\n                    const randomValue = Math.floor(Math.random() * 50) + 1;\n                    this.insertValue(randomValue);\n                });\n                \n                document.getElementById('clearBtn').addEventListener('click', () => {\n                    this.clearHeap();\n                });\n                \n                document.getElementById('minHeapBtn').addEventListener('click', () => {\n                    this.switchToMinHeap();\n                });\n                \n                document.getElementById('maxHeapBtn').addEventListener('click', () => {\n                    this.switchToMaxHeap();\n                });\n                \n                document.getElementById('valueInput').addEventListener('keypress', (e) => {\n                    if (e.key === 'Enter') {\n                        const value = parseInt(document.getElementById('valueInput').value);\n                        if (!isNaN(value)) {\n                            this.insertValue(value);\n                            document.getElementById('valueInput').value = '';\n                        }\n                    }\n                });\n            }\n            \n            insertValue(value) {\n                this.heap.insert(value);\n                this.log(`Inserted ${value}`);\n                this.updateDisplay();\n            }\n            \n            removeRoot() {\n                if (this.heap.size() === 0) {\n                    this.log('Heap is empty!');\n                    return;\n                }\n                \n                const root = this.heap.extractRoot();\n                this.log(`Removed root: ${root}`);\n                this.updateDisplay();\n            }\n            \n            switchToMinHeap() {\n                if (!this.heap.isMinHeap) {\n                    this.convertHeap(true);\n                    document.getElementById('minHeapBtn').classList.add('active');\n                    document.getElementById('maxHeapBtn').classList.remove('active');\n                    this.heapExplanation.innerHTML = `\n                        <strong>Min Heap:</strong> Parent nodes are always smaller than or equal to their children.<br>\n                        Heap is a complete binary tree, meaning all levels are fully filled except possibly the last.\n                    `;\n                }\n            }\n            \n            switchToMaxHeap() {\n                if (this.heap.isMinHeap) {\n                    this.convertHeap(false);\n                    document.getElementById('minHeapBtn').classList.remove('active');\n                    document.getElementById('maxHeapBtn').classList.add('active');\n                    this.heapExplanation.innerHTML = `\n                        <strong>Max Heap:</strong> Parent nodes are always greater than or equal to their children.<br>\n                        Heap is a complete binary tree, meaning all levels are fully filled except possibly the last.\n                    `;\n                }\n            }\n            \n            convertHeap(toMinHeap) {\n                const values = [...this.heap.heap];\n                this.heap = new Heap(toMinHeap);\n                values.forEach(value => this.heap.insert(value));\n                this.log(`Converted to ${toMinHeap ? 'Min' : 'Max'} Heap`);\n                this.updateDisplay();\n            }\n            \n            clearHeap() {\n                this.heap = new Heap(this.heap.isMinHeap);\n                this.log('Cleared heap');\n                this.updateDisplay();\n            }\n            \n            log(message) {\n                const timestamp = new Date().toLocaleTimeString();\n                const logEntry = document.createElement('div');\n                logEntry.textContent = `[${timestamp}] ${message}`;\n                this.logContent.appendChild(logEntry);\n                this.logContent.scrollTop = this.logContent.scrollHeight;\n            }\n            \n            updateDisplay() {\n                this.renderTree();\n                this.renderArray();\n            }\n            \n            renderTree() {\n                this.treeContainer.innerHTML = '';\n                \n                if (this.heap.size() === 0) {\n                    const emptyMsg = document.createElement('div');\n                    emptyMsg.textContent = 'Heap is empty';\n                    emptyMsg.style.color = '#999';\n                    this.treeContainer.appendChild(emptyMsg);\n                    return;\n                }\n                \n                const levels = this.calculateTreeLevels();\n                const nodeSize = 50;\n                const levelHeight = 100;\n                \n                levels.forEach((level, levelIndex) => {\n                    const levelWidth = Math.pow(2, levelIndex) * nodeSize * 2;\n                    level.forEach((value, nodeIndex) => {\n                        const x = (nodeIndex + 0.5) * (levelWidth / level.length) - nodeSize / 2;\n                        const y = levelIndex * levelHeight;\n                        \n                        // Create node\n                        const node = document.createElement('div');\n                        node.className = 'node';\n                        node.textContent = value;\n                        node.style.left = `${x}px`;\n                        node.style.top = `${y}px`;\n                        this.treeContainer.appendChild(node);\n                        \n                        // Draw connections to children\n                        const heapIndex = Math.pow(2, levelIndex) - 1 + nodeIndex;\n                        const leftChildIndex = this.heap.leftChild(heapIndex);\n                        const rightChildIndex = this.heap.rightChild(heapIndex);\n                        \n                        if (leftChildIndex < this.heap.size()) {\n                            this.drawConnection(x + nodeSize / 2, y + nodeSize, \n                                (2 * nodeIndex + 0.5) * (levelWidth / 2 / level.length) - nodeSize / 2 + nodeSize / 2, \n                                y + levelHeight);\n                        }\n                        \n                        if (rightChildIndex < this.heap.size()) {\n                            this.drawConnection(x + nodeSize / 2, y + nodeSize, \n                                (2 * nodeIndex + 1.5) * (levelWidth / 2 / level.length) - nodeSize / 2 + nodeSize / 2, \n                                y + levelHeight);\n                        }\n                    });\n                });\n                \n                // Highlight root\n                if (this.heap.size() > 0) {\n                    const rootNode = this.treeContainer.querySelector('.node');\n                    if (rootNode) {\n                        setTimeout(() => {\n                            rootNode.classList.add('highlight');\n                            setTimeout(() => rootNode.classList.remove('highlight'), 1000);\n                        }, 100);\n                    }\n                }\n            }\n            \n            drawConnection(x1, y1, x2, y2) {\n                const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n                \n                const connection = document.createElement('div');\n                connection.className = 'connection';\n                connection.style.width = `${length}px`;\n                connection.style.left = `${x1}px`;\n                connection.style.top = `${y1}px`;\n                connection.style.transform = `rotate(${angle}deg)`;\n                \n                this.treeContainer.appendChild(connection);\n            }\n            \n            calculateTreeLevels() {\n                const levels = [];\n                let currentLevel = 0;\n                let nodesInLevel = 1;\n                let currentIndex = 0;\n                \n                while (currentIndex < this.heap.size()) {\n                    const level = [];\n                    for (let i = 0; i < nodesInLevel && currentIndex < this.heap.size(); i++) {\n                        level.push(this.heap.heap[currentIndex]);\n                        currentIndex++;\n                    }\n                    levels.push(level);\n                    nodesInLevel *= 2;\n                    currentLevel++;\n                }\n                \n                return levels;\n            }\n            \n            renderArray() {\n                this.arrayContainer.innerHTML = '';\n                \n                if (this.heap.size() === 0) {\n                    return;\n                }\n                \n                // Add index row\n                const indexRow = document.createElement('div');\n                indexRow.style.display = 'flex';\n                indexRow.style.gap = '10px';\n                indexRow.style.marginBottom = '5px';\n                \n                for (let i = 0; i < this.heap.size(); i++) {\n                    const indexCell = document.createElement('div');\n                    indexCell.className = 'array-cell index';\n                    indexCell.textContent = i;\n                    indexRow.appendChild(indexCell);\n                }\n                this.arrayContainer.appendChild(indexRow);\n                \n                // Add value row\n                const valueRow = document.createElement('div');\n                valueRow.style.display = 'flex';\n                valueRow.style.gap = '10px';\n                \n                for (let i = 0; i < this.heap.size(); i++) {\n                    const valueCell = document.createElement('div');\n                    valueCell.className = 'array-cell';\n                    valueCell.textContent = this.heap.heap[i];\n                    valueRow.appendChild(valueCell);\n                }\n                this.arrayContainer.appendChild(valueRow);\n            }\n        }\n\n        // Initialize the visualizer when the page loads\n        document.addEventListener('DOMContentLoaded', () => {\n            new HeapVisualizer();\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap (Min/Max)"
    }
  ],
  "topic": "Heap (Min/Max)",
  "hasFSM": false,
  "hasTest": true
}