{
  "id": "6e099210-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:19:51.993Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Binary Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Binary Tree Visualization</title>\n    <style>\n        * {\n            box-sizing: border-box;\n            margin: 0;\n            padding: 0;\n        }\n        \n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            min-height: 100vh;\n            padding: 20px;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n        }\n        \n        .container {\n            max-width: 1200px;\n            width: 100%;\n            background: white;\n            border-radius: 15px;\n            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);\n            padding: 30px;\n            margin-top: 20px;\n        }\n        \n        h1 {\n            color: white;\n            text-align: center;\n            margin-bottom: 10px;\n            font-size: 2.5rem;\n            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);\n        }\n        \n        .subtitle {\n            color: white;\n            text-align: center;\n            margin-bottom: 30px;\n            font-size: 1.2rem;\n        }\n        \n        .controls {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 15px;\n            margin-bottom: 30px;\n            padding: 20px;\n            background: #f8f9fa;\n            border-radius: 10px;\n        }\n        \n        .control-group {\n            display: flex;\n            flex-direction: column;\n            gap: 8px;\n        }\n        \n        label {\n            font-weight: 600;\n            color: #495057;\n        }\n        \n        input, select, button {\n            padding: 10px 15px;\n            border: 1px solid #ced4da;\n            border-radius: 5px;\n            font-size: 1rem;\n        }\n        \n        button {\n            background: #4e73df;\n            color: white;\n            border: none;\n            cursor: pointer;\n            transition: all 0.3s;\n            font-weight: 600;\n        }\n        \n        button:hover {\n            background: #2e59d9;\n            transform: translateY(-2px);\n            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);\n        }\n        \n        #tree-container {\n            height: 500px;\n            border: 1px solid #e3e6f0;\n            border-radius: 10px;\n            overflow: auto;\n            background: #f8f9fc;\n            position: relative;\n            margin-bottom: 30px;\n        }\n        \n        .node {\n            position: absolute;\n            width: 50px;\n            height: 50px;\n            border-radius: 50%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            color: white;\n            background: #4e73df;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            transition: all 0.3s;\n            z-index: 2;\n        }\n        \n        .node.highlight {\n            background: #e74a3b;\n            transform: scale(1.2);\n            box-shadow: 0 0 15px #e74a3b;\n        }\n        \n        .line {\n            position: absolute;\n            height: 2px;\n            background: #858796;\n            transform-origin: 0 0;\n            z-index: 1;\n        }\n        \n        .traversal-result {\n            background: #f8f9fc;\n            padding: 20px;\n            border-radius: 10px;\n            margin-top: 20px;\n        }\n        \n        .traversal-result h3 {\n            color: #4e73df;\n            margin-bottom: 10px;\n        }\n        \n        #traversal-output {\n            padding: 15px;\n            background: white;\n            border-radius: 5px;\n            border: 1px solid #e3e6f0;\n            min-height: 60px;\n            font-family: monospace;\n        }\n        \n        .legend {\n            display: flex;\n            justify-content: center;\n            gap: 20px;\n            margin-top: 20px;\n        }\n        \n        .legend-item {\n            display: flex;\n            align-items: center;\n            gap: 5px;\n        }\n        \n        .legend-color {\n            width: 20px;\n            height: 20px;\n            border-radius: 50%;\n        }\n        \n        .code-example {\n            background: #2d3748;\n            color: #e2e8f0;\n            padding: 20px;\n            border-radius: 10px;\n            margin-top: 30px;\n            font-family: 'Courier New', Courier, monospace;\n            overflow-x: auto;\n        }\n        \n        .explanation {\n            margin-top: 30px;\n            line-height: 1.6;\n        }\n        \n        .explanation h2 {\n            color: #4e73df;\n            margin-bottom: 15px;\n        }\n    </style>\n</head>\n<body>\n    <h1>Binary Tree Visualization</h1>\n    <p class=\"subtitle\">Visualize and understand binary tree operations</p>\n    \n    <div class=\"container\">\n        <div class=\"controls\">\n            <div class=\"control-group\">\n                <label for=\"nodeValue\">Node Value</label>\n                <input type=\"number\" id=\"nodeValue\" min=\"1\" max=\"100\" value=\"10\">\n            </div>\n            \n            <div class=\"control-group\">\n                <label for=\"traversalType\">Traversal Type</label>\n                <select id=\"traversalType\">\n                    <option value=\"inorder\">In-order</option>\n                    <option value=\"preorder\">Pre-order</option>\n                    <option value=\"postorder\">Post-order</option>\n                    <option value=\"levelorder\">Level-order</option>\n                </select>\n            </div>\n            \n            <div class=\"control-group\">\n                <label>&nbsp;</label>\n                <button id=\"addNodeBtn\">Add Node</button>\n            </div>\n            \n            <div class=\"control-group\">\n                <label>&nbsp;</label>\n                <button id=\"traverseBtn\">Traverse Tree</button>\n            </div>\n            \n            <div class=\"control-group\">\n                <label>&nbsp;</label>\n                <button id=\"resetBtn\">Reset Tree</button>\n            </div>\n        </div>\n        \n        <div id=\"tree-container\"></div>\n        \n        <div class=\"traversal-result\">\n            <h3>Traversal Result</h3>\n            <div id=\"traversal-output\">Tree is empty. Add nodes to see traversal.</div>\n        </div>\n        \n        <div class=\"legend\">\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background: #4e73df;\"></div>\n                <span>Normal Node</span>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background: #e74a3b;\"></div>\n                <span>Highlighted (During Traversal)</span>\n            </div>\n        </div>\n        \n        <div class=\"code-example\">\n            <pre>// Binary Tree Node Definition\nclass Node {\n    constructor(value) {\n        this.value = value;\n        this.left = null;\n        this.right = null;\n    }\n}\n\n// In-order Traversal (Left, Root, Right)\nfunction inOrderTraversal(node) {\n    if (node !== null) {\n        inOrderTraversal(node.left);\n        console.log(node.value);\n        inOrderTraversal(node.right);\n    }\n}\n\n// Pre-order Traversal (Root, Left, Right)\nfunction preOrderTraversal(node) {\n    if (node !== null) {\n        console.log(node.value);\n        preOrderTraversal(node.left);\n        preOrderTraversal(node.right);\n    }\n}\n\n// Post-order Traversal (Left, Right, Root)\nfunction postOrderTraversal(node) {\n    if (node !== null) {\n        postOrderTraversal(node.left);\n        postOrderTraversal(node.right);\n        console.log(node.value);\n    }\n}</pre>\n        </div>\n        \n        <div class=\"explanation\">\n            <h2>What is a Binary Tree?</h2>\n            <p>A binary tree is a hierarchical data structure in which each node has at most two children, referred to as the left child and the right child.</p>\n            \n            <h2>Binary Tree Properties:</h2>\n            <ul>\n                <li><strong>Root:</strong> The top node of the tree</li>\n                <li><strong>Child:</strong> A node directly connected to another node when moving away from the root</li>\n                <li><strong>Parent:</strong> The converse notion of a child</li>\n                <li><strong>Leaf:</strong> A node with no children</li>\n                <li><strong>Depth:</strong> The length of the path from the root to the node</li>\n                <li><strong>Height:</strong> The length of the path from the node to the deepest leaf</li>\n            </ul>\n            \n            <h2>Tree Traversal Methods:</h2>\n            <ul>\n                <li><strong>In-order:</strong> Left subtree, Root, Right subtree</li>\n                <li><strong>Pre-order:</strong> Root, Left subtree, Right subtree</li>\n                <li><strong>Post-order:</strong> Left subtree, Right subtree, Root</li>\n                <li><strong>Level-order:</strong> Nodes are visited level by level from top to bottom</li>\n            </ul>\n        </div>\n    </div>\n\n    <script>\n        class TreeNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n                this.x = 0;\n                this.y = 0;\n            }\n        }\n        \n        class BinaryTree {\n            constructor() {\n                this.root = null;\n                this.nodeCount = 0;\n                this.container = document.getElementById('tree-container');\n                this.traversalOutput = document.getElementById('traversal-output');\n            }\n            \n            addNode(value) {\n                const newNode = new TreeNode(value);\n                \n                if (this.root === null) {\n                    this.root = newNode;\n                    this.root.x = this.container.offsetWidth / 2;\n                    this.root.y = 50;\n                } else {\n                    this.insertNode(this.root, newNode);\n                }\n                \n                this.nodeCount++;\n                this.updateVisualization();\n                return newNode;\n            }\n            \n            insertNode(node, newNode) {\n                if (newNode.value < node.value) {\n                    if (node.left === null) {\n                        node.left = newNode;\n                    } else {\n                        this.insertNode(node.left, newNode);\n                    }\n                } else {\n                    if (node.right === null) {\n                        node.right = newNode;\n                    } else {\n                        this.insertNode(node.right, newNode);\n                    }\n                }\n            }\n            \n            calculatePositions(node, x, y, level, minHorizontalGap) {\n                if (node === null) return;\n                \n                // Calculate horizontal gap based on level\n                const horizontalGap = minHorizontalGap / Math.pow(1.5, level);\n                \n                // Process left subtree\n                if (node.left !== null) {\n                    node.left.x = x - horizontalGap;\n                    node.left.y = y + 100;\n                    this.calculatePositions(node.left, node.left.x, node.left.y, level + 1, minHorizontalGap);\n                }\n                \n                // Process right subtree\n                if (node.right !== null) {\n                    node.right.x = x + horizontalGap;\n                    node.right.y = y + 100;\n                    this.calculatePositions(node.right, node.right.x, node.right.y, level + 1, minHorizontalGap);\n                }\n                \n                node.x = x;\n                node.y = y;\n            }\n            \n            updateVisualization() {\n                // Clear the container\n                this.container.innerHTML = '';\n                \n                if (this.root === null) return;\n                \n                // Calculate positions for all nodes\n                const initialX = this.container.offsetWidth / 2;\n                const initialY = 50;\n                const minHorizontalGap = 200;\n                \n                this.calculatePositions(this.root, initialX, initialY, 0, minHorizontalGap);\n                \n                // Draw lines first (so they appear behind nodes)\n                this.drawConnections(this.root);\n                \n                // Draw nodes\n                this.drawNode(this.root);\n            }\n            \n            drawConnections(node) {\n                if (node === null) return;\n                \n                if (node.left !== null) {\n                    this.drawLine(node.x, node.y, node.left.x, node.left.y);\n                    this.drawConnections(node.left);\n                }\n                \n                if (node.right !== null) {\n                    this.drawLine(node.x, node.y, node.right.x, node.right.y);\n                    this.drawConnections(node.right);\n                }\n            }\n            \n            drawLine(x1, y1, x2, y2) {\n                const line = document.createElement('div');\n                line.className = 'line';\n                \n                const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n                \n                line.style.width = `${length}px`;\n                line.style.left = `${x1}px`;\n                line.style.top = `${y1}px`;\n                line.style.transform = `rotate(${angle}deg)`;\n                \n                this.container.appendChild(line);\n            }\n            \n            drawNode(node) {\n                const nodeElement = document.createElement('div');\n                nodeElement.className = 'node';\n                nodeElement.textContent = node.value;\n                nodeElement.style.left = `${node.x - 25}px`;\n                nodeElement.style.top = `${node.y - 25}px`;\n                \n                this.container.appendChild(nodeElement);\n            }\n            \n            async traverse(type) {\n                this.traversalOutput.textContent = '';\n                \n                switch(type) {\n                    case 'inorder':\n                        await this.inOrderTraversal(this.root);\n                        break;\n                    case 'preorder':\n                        await this.preOrderTraversal(this.root);\n                        break;\n                    case 'postorder':\n                        await this.postOrderTraversal(this.root);\n                        break;\n                    case 'levelorder':\n                        await this.levelOrderTraversal(this.root);\n                        break;\n                }\n            }\n            \n            async inOrderTraversal(node) {\n                if (node !== null) {\n                    await this.inOrderTraversal(node.left);\n                    await this.highlightNode(node);\n                    await this.inOrderTraversal(node.right);\n                }\n            }\n            \n            async preOrderTraversal(node) {\n                if (node !== null) {\n                    await this.highlightNode(node);\n                    await this.preOrderTraversal(node.left);\n                    await this.preOrderTraversal(node.right);\n                }\n            }\n            \n            async postOrderTraversal(node) {\n                if (node !== null) {\n                    await this.postOrderTraversal(node.left);\n                    await this.postOrderTraversal(node.right);\n                    await this.highlightNode(node);\n                }\n            }\n            \n            async levelOrderTraversal(node) {\n                if (node === null) return;\n                \n                const queue = [node];\n                \n                while (queue.length > 0) {\n                    const currentNode = queue.shift();\n                    await this.highlightNode(currentNode);\n                    \n                    if (currentNode.left !== null) {\n                        queue.push(currentNode.left);\n                    }\n                    \n                    if (currentNode.right !== null) {\n                        queue.push(currentNode.right);\n                    }\n                }\n            }\n            \n            async highlightNode(node) {\n                // Find the node element\n                const nodes = document.getElementsByClassName('node');\n                for (let nodeElement of nodes) {\n                    if (parseInt(nodeElement.textContent) === node.value) {\n                        nodeElement.classList.add('highlight');\n                        \n                        // Update traversal output\n                        if (this.traversalOutput.textContent === '') {\n                            this.traversalOutput.textContent = node.value;\n                        } else {\n                            this.traversalOutput.textContent += ' â†’ ' + node.value;\n                        }\n                        \n                        // Wait for a moment\n                        await new Promise(resolve => setTimeout(resolve, 800));\n                        nodeElement.classList.remove('highlight');\n                        break;\n                    }\n                }\n            }\n            \n            reset() {\n                this.root = null;\n                this.nodeCount = 0;\n                this.container.innerHTML = '';\n                this.traversalOutput.textContent = 'Tree is empty. Add nodes to see traversal.';\n            }\n        }\n        \n        // Initialize the binary tree\n        const binaryTree = new BinaryTree();\n        \n        // Event listeners\n        document.getElementById('addNodeBtn').addEventListener('click', () => {\n            const value = parseInt(document.getElementById('nodeValue').value);\n            if (!isNaN(value)) {\n                binaryTree.addNode(value);\n                document.getElementById('nodeValue').value = value + 1;\n            }\n        });\n        \n        document.getElementById('traverseBtn').addEventListener('click', () => {\n            const traversalType = document.getElementById('traversalType').value;\n            binaryTree.traverse(traversalType);\n        });\n        \n        document.getElementById('resetBtn').addEventListener('click', () => {\n            binaryTree.reset();\n        });\n        \n        // Allow Enter key to add nodes\n        document.getElementById('nodeValue').addEventListener('keyup', (event) => {\n            if (event.key === 'Enter') {\n                document.getElementById('addNodeBtn').click();\n            }\n        });\n        \n        // Handle window resize\n        window.addEventListener('resize', () => {\n            binaryTree.updateVisualization();\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Tree"
    }
  ],
  "topic": "Binary Tree",
  "hasFSM": false,
  "hasTest": true
}