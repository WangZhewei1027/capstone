{
  "id": "dfd7663b-d59e-11f0-ae0b-570552a0b645",
  "timestamp": "2025-12-10T08:08:22.647Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Depth-First Search (DFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Depth-First Search (DFS) Visualization</title>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f7fa;\n            color: #333;\n        }\n        \n        h1 {\n            color: #2c3e50;\n            text-align: center;\n            margin-bottom: 10px;\n        }\n        \n        h2 {\n            color: #34495e;\n            border-bottom: 1px solid #ddd;\n            padding-bottom: 5px;\n            margin-top: 30px;\n        }\n        \n        .description {\n            background-color: #e8f4fd;\n            padding: 15px;\n            border-radius: 5px;\n            margin-bottom: 20px;\n            line-height: 1.6;\n        }\n        \n        .controls {\n            display: flex;\n            justify-content: space-between;\n            margin: 20px 0;\n            padding: 10px;\n            background-color: #fff;\n            border-radius: 5px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        \n        button {\n            background-color: #3498db;\n            color: white;\n            border: none;\n            padding: 8px 15px;\n            border-radius: 4px;\n            cursor: pointer;\n            transition: background-color 0.3s;\n        }\n        \n        button:hover {\n            background-color: #2980b9;\n        }\n        \n        button:disabled {\n            background-color: #95a5a6;\n            cursor: not-allowed;\n        }\n        \n        .graph-container {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 20px;\n        }\n        \n        #graph-visualization {\n            flex: 1;\n            min-width: 300px;\n            height: 400px;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            background-color: white;\n            position: relative;\n        }\n        \n        .algorithm-steps {\n            flex: 1;\n            min-width: 300px;\n            background-color: white;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            padding: 15px;\n            height: 400px;\n            overflow-y: auto;\n        }\n        \n        .node {\n            position: absolute;\n            width: 40px;\n            height: 40px;\n            border-radius: 50%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            color: white;\n            font-weight: bold;\n            cursor: pointer;\n            transition: all 0.3s;\n        }\n        \n        .edge {\n            position: absolute;\n            height: 2px;\n            background-color: #7f8c8d;\n            transform-origin: 0 0;\n        }\n        \n        .step-item {\n            padding: 8px;\n            margin-bottom: 5px;\n            border-radius: 4px;\n            transition: background-color 0.3s;\n        }\n        \n        .step-item.current {\n            background-color: #d6eaf8;\n            font-weight: bold;\n        }\n        \n        .step-item.completed {\n            background-color: #d5f5e3;\n        }\n        \n        .legend {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 15px;\n            margin: 15px 0;\n        }\n        \n        .legend-item {\n            display: flex;\n            align-items: center;\n            gap: 5px;\n        }\n        \n        .legend-color {\n            width: 20px;\n            height: 20px;\n            border-radius: 4px;\n        }\n        \n        .code-section {\n            background-color: #2d2d2d;\n            color: #f8f8f2;\n            padding: 15px;\n            border-radius: 5px;\n            overflow-x: auto;\n            margin-top: 20px;\n        }\n        \n        .comment {\n            color: #75715e;\n        }\n        \n        .keyword {\n            color: #f92672;\n        }\n        \n        .function {\n            color: #66d9ef;\n        }\n        \n        .string {\n            color: #e6db74;\n        }\n        \n        footer {\n            text-align: center;\n            margin-top: 30px;\n            color: #7f8c8d;\n            font-size: 0.9em;\n        }\n    </style>\n</head>\n<body>\n    <h1>Depth-First Search (DFS) Visualization</h1>\n    \n    <div class=\"description\">\n        <p><strong>Depth-First Search (DFS)</strong> is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.</p>\n        <p>DFS uses a stack (either explicitly or via recursion) to remember where it should go when it reaches a dead end. This implementation demonstrates the iterative approach using a stack.</p>\n    </div>\n    \n    <div class=\"controls\">\n        <div>\n            <button id=\"start-btn\">Start DFS</button>\n            <button id=\"pause-btn\" disabled>Pause</button>\n            <button id=\"reset-btn\">Reset</button>\n        </div>\n        <div>\n            <label for=\"speed-control\">Animation Speed:</label>\n            <input type=\"range\" id=\"speed-control\" min=\"1\" max=\"10\" value=\"5\">\n        </div>\n    </div>\n    \n    <div class=\"legend\">\n        <div class=\"legend-item\">\n            <div class=\"legend-color\" style=\"background-color: #3498db;\"></div>\n            <span>Unvisited Node</span>\n        </div>\n        <div class=\"legend-item\">\n            <div class=\"legend-color\" style=\"background-color: #f39c12;\"></div>\n            <span>Visited (In Stack)</span>\n        </div>\n        <div class=\"legend-item\">\n            <div class=\"legend-color\" style=\"background-color: #2ecc71;\"></div>\n            <span>Processed Node</span>\n        </div>\n        <div class=\"legend-item\">\n            <div class=\"legend-color\" style=\"background-color: #e74c3c;\"></div>\n            <span>Current Node</span>\n        </div>\n    </div>\n    \n    <div class=\"graph-container\">\n        <div id=\"graph-visualization\"></div>\n        <div class=\"algorithm-steps\" id=\"steps-container\">\n            <h3>DFS Steps</h3>\n            <div id=\"steps-list\"></div>\n        </div>\n    </div>\n    \n    <h2>DFS Algorithm Pseudocode</h2>\n    <div class=\"code-section\">\n        <pre><code><span class=\"comment\">// Depth-First Search (DFS) - Iterative Approach</span>\n<span class=\"keyword\">function</span> <span class=\"function\">DFS</span>(startNode) {\n    <span class=\"keyword\">let</span> stack = [startNode];  <span class=\"comment\">// Initialize stack with start node</span>\n    <span class=\"keyword\">let</span> visited = <span class=\"keyword\">new</span> Set();  <span class=\"comment\">// Track visited nodes</span>\n    \n    <span class=\"keyword\">while</span> (stack.length > <span class=\"number\">0</span>) {\n        <span class=\"keyword\">let</span> currentNode = stack.pop();  <span class=\"comment\">// Get the last node from stack</span>\n        \n        <span class=\"keyword\">if</span> (!visited.has(currentNode)) {\n            visited.add(currentNode);  <span class=\"comment\">// Mark as visited</span>\n            <span class=\"function\">processNode</span>(currentNode);  <span class=\"comment\">// Process the node</span>\n            \n            <span class=\"comment\">// Add unvisited neighbors to the stack</span>\n            <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> neighbor <span class=\"keyword\">of</span> getNeighbors(currentNode)) {\n                <span class=\"keyword\">if</span> (!visited.has(neighbor)) {\n                    stack.push(neighbor);\n                }\n            }\n        }\n    }\n}</code></pre>\n    </div>\n    \n    <footer>\n        <p>Depth-First Search Visualization | Algorithm Demonstration</p>\n    </footer>\n\n    <script>\n        // Graph structure\n        const graph = {\n            'A': ['B', 'C'],\n            'B': ['A', 'D', 'E'],\n            'C': ['A', 'F'],\n            'D': ['B'],\n            'E': ['B', 'F'],\n            'F': ['C', 'E']\n        };\n\n        // Node positions for visualization\n        const nodePositions = {\n            'A': { x: 150, y: 100 },\n            'B': { x: 50, y: 200 },\n            'C': { x: 250, y: 200 },\n            'D': { x: 20, y: 300 },\n            'E': { x: 100, y: 300 },\n            'F': { x: 250, y: 300 }\n        };\n\n        // DOM elements\n        const graphVisualization = document.getElementById('graph-visualization');\n        const stepsList = document.getElementById('steps-list');\n        const startBtn = document.getElementById('start-btn');\n        const pauseBtn = document.getElementById('pause-btn');\n        const resetBtn = document.getElementById('reset-btn');\n        const speedControl = document.getElementById('speed-control');\n\n        // Animation state\n        let animationId = null;\n        let isPaused = false;\n        let currentStep = 0;\n        let visited = new Set();\n        let stack = [];\n        let steps = [];\n\n        // Initialize the graph visualization\n        function initializeGraph() {\n            graphVisualization.innerHTML = '';\n            \n            // Draw edges\n            for (const [node, neighbors] of Object.entries(graph)) {\n                const nodePos = nodePositions[node];\n                \n                for (const neighbor of neighbors) {\n                    const neighborPos = nodePositions[neighbor];\n                    \n                    // Calculate distance and angle\n                    const dx = neighborPos.x - nodePos.x;\n                    const dy = neighborPos.y - nodePos.y;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;\n                    \n                    // Create edge element\n                    const edge = document.createElement('div');\n                    edge.className = 'edge';\n                    edge.style.width = `${distance}px`;\n                    edge.style.left = `${nodePos.x}px`;\n                    edge.style.top = `${nodePos.y}px`;\n                    edge.style.transform = `rotate(${angle}deg)`;\n                    graphVisualization.appendChild(edge);\n                }\n            }\n            \n            // Draw nodes\n            for (const node of Object.keys(nodePositions)) {\n                const pos = nodePositions[node];\n                const nodeElement = document.createElement('div');\n                nodeElement.className = 'node';\n                nodeElement.id = `node-${node}`;\n                nodeElement.style.left = `${pos.x - 20}px`;\n                nodeElement.style.top = `${pos.y - 20}px`;\n                nodeElement.style.backgroundColor = '#3498db';\n                nodeElement.textContent = node;\n                graphVisualization.appendChild(nodeElement);\n            }\n        }\n\n        // Update node appearance based on state\n        function updateNode(node, state) {\n            const nodeElement = document.getElementById(`node-${node}`);\n            if (!nodeElement) return;\n            \n            switch(state) {\n                case 'unvisited':\n                    nodeElement.style.backgroundColor = '#3498db';\n                    break;\n                case 'visited':\n                    nodeElement.style.backgroundColor = '#f39c12';\n                    break;\n                case 'processed':\n                    nodeElement.style.backgroundColor = '#2ecc71';\n                    break;\n                case 'current':\n                    nodeElement.style.backgroundColor = '#e74c3c';\n                    break;\n            }\n        }\n\n        // Perform DFS step by step\n        function performDFSStep() {\n            if (isPaused || currentStep >= steps.length) {\n                if (animationId) {\n                    cancelAnimationFrame(animationId);\n                    animationId = null;\n                }\n                startBtn.disabled = false;\n                pauseBtn.disabled = true;\n                return;\n            }\n            \n            const step = steps[currentStep];\n            \n            // Update step visualization\n            const stepItems = document.querySelectorAll('.step-item');\n            stepItems.forEach((item, index) => {\n                item.classList.remove('current');\n                if (index < currentStep) item.classList.add('completed');\n                if (index === currentStep) item.classList.add('current');\n            });\n            \n            // Execute the step\n            switch(step.type) {\n                case 'push':\n                    addStepToDisplay(`Push ${step.node} to stack`);\n                    stack.push(step.node);\n                    updateNode(step.node, 'visited');\n                    break;\n                    \n                case 'pop':\n                    addStepToDisplay(`Pop ${step.node} from stack`);\n                    stack.pop();\n                    updateNode(step.node, 'current');\n                    break;\n                    \n                case 'process':\n                    addStepToDisplay(`Process node ${step.node}`);\n                    visited.add(step.node);\n                    updateNode(step.node, 'processed');\n                    break;\n                    \n                case 'visit_neighbors':\n                    const neighbors = graph[step.node].filter(n => !visited.has(n));\n                    if (neighbors.length > 0) {\n                        addStepToDisplay(`Visit neighbors of ${step.node}: ${neighbors.join(', ')}`);\n                    } else {\n                        addStepToDisplay(`No unvisited neighbors for ${step.node}`);\n                    }\n                    break;\n            }\n            \n            // Update stack display\n            updateStackDisplay();\n            \n            currentStep++;\n            \n            // Schedule next step\n            const speed = 1100 - (speedControl.value * 100);\n            animationId = setTimeout(performDFSStep, speed);\n        }\n\n        // Generate DFS steps\n        function generateDFSSteps(startNode) {\n            steps = [];\n            visited.clear();\n            stack = [startNode];\n            const visitedSet = new Set();\n            \n            // Initial step\n            steps.push({ type: 'push', node: startNode });\n            \n            while (stack.length > 0) {\n                const currentNode = stack[stack.length - 1];\n                steps.push({ type: 'pop', node: currentNode });\n                \n                if (!visitedSet.has(currentNode)) {\n                    steps.push({ type: 'process', node: currentNode });\n                    visitedSet.add(currentNode);\n                    \n                    steps.push({ type: 'visit_neighbors', node: currentNode });\n                    \n                    // Add unvisited neighbors in reverse order to maintain visual order\n                    const neighbors = graph[currentNode].filter(n => !visitedSet.has(n));\n                    for (let i = neighbors.length - 1; i >= 0; i--) {\n                        if (!visitedSet.has(neighbors[i])) {\n                            steps.push({ type: 'push', node: neighbors[i] });\n                        }\n                    }\n                }\n            }\n        }\n\n        // Add step to display\n        function addStepToDisplay(stepText) {\n            // This function is called during animation to update the current step\n            // The steps are already displayed during initialization\n        }\n\n        // Update stack visualization\n        function updateStackDisplay() {\n            // In a real implementation, you would update a visual stack representation\n        }\n\n        // Initialize steps display\n        function initializeStepsDisplay() {\n            stepsList.innerHTML = '';\n            steps.forEach((step, index) => {\n                const stepItem = document.createElement('div');\n                stepItem.className = 'step-item';\n                stepItem.id = `step-${index}`;\n                \n                let stepText = '';\n                switch(step.type) {\n                    case 'push':\n                        stepText = `Push ${step.node} to stack`;\n                        break;\n                    case 'pop':\n                        stepText = `Pop ${step.node} from stack`;\n                        break;\n                    case 'process':\n                        stepText = `Process node ${step.node}`;\n                        break;\n                    case 'visit_neighbors':\n                        const neighbors = graph[step.node].filter(n => !visited.has(n));\n                        stepText = `Visit neighbors of ${step.node}`;\n                        if (neighbors.length > 0) {\n                            stepText += `: ${neighbors.join(', ')}`;\n                        } else {\n                            stepText += ` (no unvisited neighbors)`;\n                        }\n                        break;\n                }\n                \n                stepItem.textContent = `${index + 1}. ${stepText}`;\n                stepsList.appendChild(stepItem);\n            });\n        }\n\n        // Event listeners\n        startBtn.addEventListener('click', () => {\n            if (currentStep >= steps.length) {\n                // Reset if we've completed the animation\n                resetDFS();\n            }\n            \n            isPaused = false;\n            startBtn.disabled = true;\n            pauseBtn.disabled = false;\n            performDFSStep();\n        });\n\n        pauseBtn.addEventListener('click', () => {\n            isPaused = true;\n            startBtn.disabled = false;\n            pauseBtn.disabled = true;\n            \n            if (animationId) {\n                clearTimeout(animationId);\n                animationId = null;\n            }\n        });\n\n        resetBtn.addEventListener('click', resetDFS);\n\n        // Reset DFS animation\n        function resetDFS() {\n            isPaused = true;\n            currentStep = 0;\n            visited.clear();\n            stack = [];\n            \n            if (animationId) {\n                clearTimeout(animationId);\n                animationId = null;\n            }\n            \n            // Reset node appearances\n            for (const node of Object.keys(nodePositions)) {\n                updateNode(node, 'unvisited');\n            }\n            \n            // Reset steps display\n            const stepItems = document.querySelectorAll('.step-item');\n            stepItems.forEach(item => {\n                item.classList.remove('current', 'completed');\n            });\n            \n            startBtn.disabled = false;\n            pauseBtn.disabled = true;\n        }\n\n        // Initialize the visualization\n        initializeGraph();\n        generateDFSSteps('A');\n        initializeStepsDisplay();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Depth-First Search (DFS)"
    }
  ],
  "topic": "Depth-First Search (DFS)",
  "hasFSM": false,
  "hasTest": true
}