{
  "id": "6e09b920-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:19:51.731Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Red-Black Tree",
  "answer": {
    "role": "assistant",
    "content": "# Interactive Red-Black Tree Visualization\n\nI'll create a comprehensive visualization of a Red-Black Tree with insertion functionality and detailed animations to demonstrate how this self-balancing binary search tree works.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Red-Black Tree Visualization</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        \n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            line-height: 1.6;\n            color: #333;\n            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);\n            min-height: 100vh;\n            padding: 20px;\n        }\n        \n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n        }\n        \n        header {\n            text-align: center;\n            margin-bottom: 30px;\n            padding: 20px;\n            background-color: white;\n            border-radius: 10px;\n            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);\n        }\n        \n        h1 {\n            color: #2c3e50;\n            margin-bottom: 10px;\n        }\n        \n        .description {\n            color: #7f8c8d;\n            max-width: 800px;\n            margin: 0 auto;\n        }\n        \n        .content {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 20px;\n            margin-bottom: 30px;\n        }\n        \n        .controls {\n            flex: 1;\n            min-width: 300px;\n            background-color: white;\n            border-radius: 10px;\n            padding: 20px;\n            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);\n        }\n        \n        .visualization {\n            flex: 2;\n            min-width: 300px;\n            background-color: white;\n            border-radius: 10px;\n            padding: 20px;\n            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);\n            display: flex;\n            flex-direction: column;\n        }\n        \n        .tree-container {\n            flex: 1;\n            overflow: auto;\n            min-height: 400px;\n            border: 1px solid #eee;\n            border-radius: 5px;\n            padding: 10px;\n            background-color: #f9f9f9;\n        }\n        \n        .input-group {\n            margin-bottom: 15px;\n        }\n        \n        label {\n            display: block;\n            margin-bottom: 5px;\n            font-weight: 500;\n        }\n        \n        input {\n            width: 100%;\n            padding: 10px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            font-size: 16px;\n        }\n        \n        button {\n            background-color: #3498db;\n            color: white;\n            border: none;\n            padding: 10px 15px;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 16px;\n            transition: background-color 0.3s;\n            width: 100%;\n            margin-top: 5px;\n        }\n        \n        button:hover {\n            background-color: #2980b9;\n        }\n        \n        .operations {\n            margin-top: 20px;\n        }\n        \n        .operations button {\n            margin-bottom: 10px;\n        }\n        \n        .legend {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 15px;\n            margin-top: 15px;\n            justify-content: center;\n        }\n        \n        .legend-item {\n            display: flex;\n            align-items: center;\n        }\n        \n        .color-box {\n            width: 20px;\n            height: 20px;\n            border-radius: 50%;\n            margin-right: 5px;\n            border: 1px solid #999;\n        }\n        \n        .red {\n            background-color: #e74c3c;\n        }\n        \n        .black {\n            background-color: #2c3e50;\n            color: white;\n        }\n        \n        .properties {\n            margin-top: 20px;\n            padding: 15px;\n            background-color: #f8f9fa;\n            border-radius: 5px;\n        }\n        \n        .history {\n            margin-top: 20px;\n        }\n        \n        .history-list {\n            max-height: 150px;\n            overflow-y: auto;\n            border: 1px solid #eee;\n            border-radius: 5px;\n            padding: 10px;\n            background-color: #f9f9f9;\n        }\n        \n        .history-item {\n            padding: 5px 0;\n            border-bottom: 1px solid #eee;\n        }\n        \n        .history-item:last-child {\n            border-bottom: none;\n        }\n        \n        svg {\n            display: block;\n            margin: 0 auto;\n        }\n        \n        .node {\n            cursor: pointer;\n        }\n        \n        .node-text {\n            font-weight: bold;\n            font-size: 14px;\n            text-anchor: middle;\n            dominant-baseline: central;\n        }\n        \n        .red-node {\n            fill: #e74c3c;\n        }\n        \n        .black-node {\n            fill: #2c3e50;\n        }\n        \n        .highlight {\n            animation: pulse 1s infinite;\n        }\n        \n        @keyframes pulse {\n            0% { stroke-width: 2px; }\n            50% { stroke-width: 4px; stroke: #f39c12; }\n            100% { stroke-width: 2px; }\n        }\n        \n        footer {\n            text-align: center;\n            padding: 20px;\n            color: #7f8c8d;\n            font-size: 0.9em;\n        }\n        \n        @media (max-width: 768px) {\n            .content {\n                flex-direction: column;\n            }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>Red-Black Tree Visualization</h1>\n            <p class=\"description\">\n                A Red-Black Tree is a self-balancing binary search tree where each node contains an extra bit for denoting the color of the node (red or black). \n                These trees maintain balance by ensuring that no path from the root to a leaf is more than twice as long as any other path.\n            </p>\n        </header>\n        \n        <div class=\"content\">\n            <div class=\"controls\">\n                <div class=\"input-group\">\n                    <label for=\"nodeValue\">Enter a value to insert:</label>\n                    <input type=\"number\" id=\"nodeValue\" placeholder=\"Enter a number\">\n                    <button id=\"insertBtn\">Insert Value</button>\n                </div>\n                \n                <div class=\"operations\">\n                    <button id=\"randomBtn\">Insert Random Value</button>\n                    <button id=\"clearBtn\">Clear Tree</button>\n                    <button id=\"balanceBtn\">Show Balance Properties</button>\n                </div>\n                \n                <div class=\"properties\">\n                    <h3>Red-Black Tree Properties:</h3>\n                    <ul>\n                        <li>Every node is either RED or BLACK</li>\n                        <li>The root is always BLACK</li>\n                        <li>All leaves (NIL) are BLACK</li>\n                        <li>If a node is RED, both children are BLACK</li>\n                        <li>Every path from a node to its NIL descendants has the same number of BLACK nodes</li>\n                    </ul>\n                </div>\n                \n                <div class=\"legend\">\n                    <div class=\"legend-item\">\n                        <div class=\"color-box red\"></div>\n                        <span>Red Node</span>\n                    </div>\n                    <div class=\"legend-item\">\n                        <div class=\"color-box black\"></div>\n                        <span>Black Node</span>\n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"visualization\">\n                <h2>Tree Visualization</h2>\n                <div class=\"tree-container\" id=\"treeContainer\">\n                    <svg id=\"treeSVG\" width=\"100%\" height=\"100%\"></svg>\n                </div>\n                \n                <div class=\"history\">\n                    <h3>Operation History:</h3>\n                    <div class=\"history-list\" id=\"historyList\">\n                        <div class=\"history-item\">Tree initialized</div>\n                    </div>\n                </div>\n            </div>\n        </div>\n        \n        <footer>\n            <p>Red-Black Tree Visualization | Created for educational purposes</p>\n        </footer>\n    </div>\n\n    <script>\n        // Red-Black Tree Implementation\n        class Node {\n            constructor(value, color = 'RED') {\n                this.value = value;\n                this.color = color;\n                this.left = null;\n                this.right = null;\n                this.parent = null;\n            }\n            \n            isRed() {\n                return this.color === 'RED';\n            }\n            \n            isBlack() {\n                return this.color === 'BLACK';\n            }\n        }\n\n        class RedBlackTree {\n            constructor() {\n                this.root = null;\n                this.NIL = new Node(null, 'BLACK'); // Sentinel node\n            }\n            \n            // Insert a value into the tree\n            insert(value) {\n                const newNode = new Node(value);\n                if (this.root === null) {\n                    this.root = newNode;\n                    this.root.color = 'BLACK';\n                    return newNode;\n                }\n                \n                let current = this.root;\n                let parent = null;\n                \n                while (current !== null) {\n                    parent = current;\n                    if (value < current.value) {\n                        current = current.left;\n                    } else if (value > current.value) {\n                        current = current.right;\n                    } else {\n                        // Value already exists\n                        return null;\n                    }\n                }\n                \n                newNode.parent = parent;\n                if (value < parent.value) {\n                    parent.left = newNode;\n                } else {\n                    parent.right = newNode;\n                }\n                \n                this.fixInsert(newNode);\n                return newNode;\n            }\n            \n            // Fix the tree after insertion\n            fixInsert(node) {\n                while (node !== this.root && node.parent.isRed()) {\n                    if (node.parent === node.parent.parent.left) {\n                        const uncle = node.parent.parent.right;\n                        \n                        if (uncle !== null && uncle.isRed()) {\n                            // Case 1: Uncle is red\n                            node.parent.color = 'BLACK';\n                            uncle.color = 'BLACK';\n                            node.parent.parent.color = 'RED';\n                            node = node.parent.parent;\n                        } else {\n                            if (node === node.parent.right) {\n                                // Case 2: Node is right child\n                                node = node.parent;\n                                this.rotateLeft(node);\n                            }\n                            \n                            // Case 3: Node is left child\n                            node.parent.color = 'BLACK';\n                            node.parent.parent.color = 'RED';\n                            this.rotateRight(node.parent.parent);\n                        }\n                    } else {\n                        // Symmetric case\n                        const uncle = node.parent.parent.left;\n                        \n                        if (uncle !== null && uncle.isRed()) {\n                            // Case 1: Uncle is red\n                            node.parent.color = 'BLACK';\n                            uncle.color = 'BLACK';\n                            node.parent.parent.color = 'RED';\n                            node = node.parent.parent;\n                        } else {\n                            if (node === node.parent.left) {\n                                // Case 2: Node is left child\n                                node = node.parent;\n                                this.rotateRight(node);\n                            }\n                            \n                            // Case 3: Node is right child\n                            node.parent.color = 'BLACK';\n                            node.parent.parent.color = 'RED';\n                            this.rotateLeft(node.parent.parent);\n                        }\n                    }\n                }\n                \n                this.root.color = 'BLACK';\n            }\n            \n            // Rotate left around a node\n            rotateLeft(node) {\n                const rightChild = node.right;\n                node.right = rightChild.left;\n                \n                if (rightChild.left !== null) {\n                    rightChild.left.parent = node;\n                }\n                \n                rightChild.parent = node.parent;\n                \n                if (node.parent === null) {\n                    this.root = rightChild;\n                } else if (node === node.parent.left) {\n                    node.parent.left = rightChild;\n                } else {\n                    node.parent.right = rightChild;\n                }\n                \n                rightChild.left = node;\n                node.parent = rightChild;\n            }\n            \n            // Rotate right around a node\n            rotateRight(node) {\n                const leftChild = node.left;\n                node.left = leftChild.right;\n                \n                if (leftChild.right !== null) {\n                    leftChild.right.parent = node;\n                }\n                \n                leftChild.parent = node.parent;\n                \n                if (node.parent === null) {\n                    this.root = leftChild;\n                } else if (node === node.parent.right) {\n                    node.parent.right = leftChild;\n                } else {\n                    node.parent.left = leftChild;\n                }\n                \n                leftChild.right = node;\n                node.parent = leftChild;\n            }\n            \n            // Find a node with the given value\n            find(value) {\n                let current = this.root;\n                while (current !== null) {\n                    if (value === current.value) {\n                        return current;\n                    } else if (value < current.value) {\n                        current = current.left;\n                    } else {\n                        current = current.right;\n                    }\n                }\n                return null;\n            }\n        }\n\n        // Visualization Code\n        class TreeVisualizer {\n            constructor(containerId) {\n                this.container = document.getElementById(containerId);\n                this.svg = document.getElementById('treeSVG');\n                this.tree = new RedBlackTree();\n                this.nodeRadius = 20;\n                this.levelHeight = 80;\n                this.animationSpeed = 800;\n                \n                this.setupEventListeners();\n                this.updateVisualization();\n            }\n            \n            setupEventListeners() {\n                document.getElementById('insertBtn').addEventListener('click', () => {\n                    const value = parseInt(document.getElementById('nodeValue').value);\n                    if (!isNaN(value)) {\n                        this.insertValue(value);\n                        document.getElementById('nodeValue').value = '';\n                    }\n                });\n                \n                document.getElementById('randomBtn').addEventListener('click', () => {\n                    const value = Math.floor(Math.random() * 100) + 1;\n                    this.insertValue(value);\n                });\n                \n                document.getElementById('clearBtn').addEventListener('click', () => {\n                    this.tree = new RedBlackTree();\n                    this.updateVisualization();\n                    this.addHistory('Tree cleared');\n                });\n                \n                document.getElementById('balanceBtn').addEventListener('click', () => {\n                    this.highlightBalanceProperties();\n                });\n                \n                document.getElementById('nodeValue').addEventListener('keypress', (e) => {\n                    if (e.key === 'Enter') {\n                        document.getElementById('insertBtn').click();\n                    }\n                });\n            }\n            \n            insertValue(value) {\n                if (this.tree.find(value) !== null) {\n                    this.addHistory(`Value ${value} already exists in the tree`);\n                    return;\n                }\n                \n                this.addHistory(`Inserting value ${value}`);\n                this.tree.insert(value);\n                this.updateVisualization();\n                \n                // Highlight the newly inserted node\n                setTimeout(() => {\n                    this.highlightNode(value);\n                }, 300);\n            }\n            \n            updateVisualization() {\n                // Clear the SVG\n                this.svg.innerHTML = '';\n                \n                if (this.tree.root === null) {\n                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n                    text.setAttribute('x', '50%');\n                    text.setAttribute('y', '50%');\n                    text.setAttribute('text-anchor', 'middle');\n                    text.setAttribute('dominant-baseline', 'middle');\n                    text.textContent = 'Tree is empty';\n                    text.setAttribute('fill', '#7f8c8d');\n                    this.svg.appendChild(text);\n                    return;\n                }\n                \n                // Calculate node positions\n                const positions = this.calculateNodePositions(this.tree.root);\n                \n                // Draw edges first (so they appear behind nodes)\n                this.drawEdges(this.tree.root, positions);\n                \n                // Draw nodes\n                this.drawNodes(positions);\n            }\n            \n            calculateNodePositions(root) {\n                const positions = new Map();\n                this.calculatePositionsRecursive(root, positions, 0, 0, 0);\n                return positions;\n            }\n            \n            calculatePositionsRecursive(node, positions, level, position, offset) {\n                if (node === null) return offset;\n                \n                // Calculate left subtree width\n                const leftOffset = this.calculatePositionsRecursive(node.left, positions, level + 1, position, offset);\n                \n                // Calculate current node position\n                const x = leftOffset * this.nodeRadius * 2.5;\n                const y = level * this.levelHeight + this.nodeRadius;\n                \n                positions.set(node, { x, y, value: node.value, color: node.color });\n                \n                // Calculate right subtree width\n                const rightOffset = this.calculatePositionsRecursive(node.right, positions, level + 1, position, leftOffset + 1);\n                \n                return rightOffset;\n            }\n            \n            drawEdges(node, positions) {\n                if (node === null) return;\n                \n                const nodePos = positions.get(node);\n                \n                if (node.left !== null) {\n                    const leftPos = positions.get(node.left);\n                    this.drawEdge(nodePos.x, nodePos.y, leftPos.x, leftPos.y);\n                    this.drawEdges(node.left, positions);\n                }\n                \n                if (node.right !== null) {\n                    const rightPos = positions.get(node.right);\n                    this.drawEdge(nodePos.x, nodePos.y, rightPos.x, rightPos.y);\n                    this.drawEdges(node.right, positions);\n                }\n            }\n            \n            drawEdge(x1, y1, x2, y2) {\n                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n                line.setAttribute('x1', x1);\n                line.setAttribute('y1', y1);\n                line.setAttribute('x2', x2);\n                line.setAttribute('y2', y2);\n                line.setAttribute('stroke', '#7f8c8d');\n                line.setAttribute('stroke-width', '2');\n                this.svg.appendChild(line);\n            }\n            \n            drawNodes(positions) {\n                positions.forEach((pos, node) => {\n                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n                    circle.setAttribute('cx', pos.x);\n                    circle.setAttribute('cy', pos.y);\n                    circle.setAttribute('r', this.nodeRadius);\n                    circle"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Red-Black Tree"
    }
  ],
  "topic": "Red-Black Tree",
  "hasFSM": false,
  "hasTest": true
}