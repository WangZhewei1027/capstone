{
  "id": "dfd7663c-d59e-11f0-ae0b-570552a0b645",
  "timestamp": "2025-12-10T08:07:53.405Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Breadth-First Search (BFS) Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            line-height: 1.6;\n        }\n        \n        .container {\n            display: flex;\n            gap: 30px;\n            margin-top: 20px;\n        }\n        \n        .controls {\n            width: 300px;\n            background-color: #f5f5f5;\n            padding: 20px;\n            border-radius: 8px;\n        }\n        \n        .visualization {\n            flex: 1;\n            display: flex;\n            flex-direction: column;\n        }\n        \n        .graph-display {\n            height: 400px;\n            border: 1px solid #ccc;\n            margin-bottom: 20px;\n            position: relative;\n            background-color: #f9f9f9;\n        }\n        \n        .node {\n            position: absolute;\n            width: 40px;\n            height: 40px;\n            border-radius: 50%;\n            background-color: #4CAF50;\n            color: white;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            cursor: pointer;\n            transition: all 0.3s;\n        }\n        \n        .node.visited {\n            background-color: #2196F3;\n        }\n        \n        .node.current {\n            background-color: #FF9800;\n            transform: scale(1.2);\n        }\n        \n        .edge {\n            position: absolute;\n            height: 2px;\n            background-color: #666;\n            transform-origin: 0 0;\n        }\n        \n        .queue-display {\n            min-height: 100px;\n            border: 1px solid #ccc;\n            padding: 10px;\n            background-color: #f0f0f0;\n            border-radius: 4px;\n        }\n        \n        .queue-item {\n            display: inline-block;\n            margin: 5px;\n            padding: 8px 12px;\n            background-color: #4CAF50;\n            color: white;\n            border-radius: 4px;\n        }\n        \n        button {\n            padding: 10px 15px;\n            margin: 5px;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n        \n        button:hover {\n            background-color: #45a049;\n        }\n        \n        button:disabled {\n            background-color: #cccccc;\n            cursor: not-allowed;\n        }\n        \n        .step-info {\n            margin-top: 10px;\n            padding: 10px;\n            background-color: #e7f3ff;\n            border-radius: 4px;\n        }\n        \n        .explanation {\n            margin-top: 20px;\n            padding: 15px;\n            background-color: #f9f9f9;\n            border-left: 4px solid #4CAF50;\n        }\n    </style>\n</head>\n<body>\n    <h1>Breadth-First Search (BFS) Visualization</h1>\n    \n    <div class=\"container\">\n        <div class=\"controls\">\n            <h3>Controls</h3>\n            <button id=\"startBtn\">Start BFS</button>\n            <button id=\"nextBtn\" disabled>Next Step</button>\n            <button id=\"resetBtn\">Reset</button>\n            \n            <div class=\"step-info\">\n                <h4>Current Step:</h4>\n                <p id=\"stepDescription\">Ready to start BFS</p>\n            </div>\n            \n            <div>\n                <h4>Graph Configuration:</h4>\n                <label>\n                    Start Node: \n                    <select id=\"startNode\">\n                        <option value=\"A\">A</option>\n                        <option value=\"B\">B</option>\n                        <option value=\"C\">C</option>\n                        <option value=\"D\">D</option>\n                        <option value=\"E\">E</option>\n                        <option value=\"F\">F</option>\n                    </select>\n                </label>\n            </div>\n        </div>\n        \n        <div class=\"visualization\">\n            <div class=\"graph-display\" id=\"graphCanvas\">\n                <!-- Graph will be drawn here by JavaScript -->\n            </div>\n            \n            <div class=\"queue-display\">\n                <h4>Queue:</h4>\n                <div id=\"queueContents\"></div>\n            </div>\n        </div>\n    </div>\n    \n    <div class=\"explanation\">\n        <h3>Breadth-First Search Algorithm</h3>\n        <p>BFS is a graph traversal algorithm that explores all the vertices of a graph in breadth-first order. It starts at a selected node and explores all its neighbors at the present depth before moving on to nodes at the next depth level.</p>\n        \n        <p><strong>Algorithm Steps:</strong></p>\n        <ol>\n            <li>Start from the selected root node</li>\n            <li>Visit the root node and mark it as visited</li>\n            <li>Enqueue all adjacent unvisited nodes</li>\n            <li>Dequeue a node and visit its unvisited neighbors</li>\n            <li>Repeat until the queue is empty</li>\n        </ol>\n        \n        <p><strong>Time Complexity:</strong> O(V + E) where V is the number of vertices and E is the number of edges</p>\n        <p><strong>Space Complexity:</strong> O(V) for storing visited nodes and the queue</p>\n    </div>\n\n    <script>\n        // Graph representation (adjacency list)\n        const graph = {\n            'A': ['B', 'C'],\n            'B': ['A', 'D', 'E'],\n            'C': ['A', 'F'],\n            'D': ['B'],\n            'E': ['B', 'F'],\n            'F': ['C', 'E']\n        };\n\n        // Node positions for visualization\n        const nodePositions = {\n            'A': { x: 200, y: 100 },\n            'B': { x: 100, y: 200 },\n            'C': { x: 300, y: 200 },\n            'D': { x: 50, y: 300 },\n            'E': { x: 150, y: 300 },\n            'F': { x: 250, y: 300 }\n        };\n\n        // BFS Algorithm State\n        let bfsState = {\n            visited: new Set(),\n            queue: [],\n            current: null,\n            step: 0,\n            isRunning: false\n        };\n\n        // DOM Elements\n        const graphCanvas = document.getElementById('graphCanvas');\n        const queueContents = document.getElementById('queueContents');\n        const stepDescription = document.getElementById('stepDescription');\n        const startBtn = document.getElementById('startBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const resetBtn = document.getElementById('resetBtn');\n        const startNodeSelect = document.getElementById('startNode');\n\n        // Initialize visualization\n        function initializeGraph() {\n            graphCanvas.innerHTML = '';\n            \n            // Draw edges first (so they appear behind nodes)\n            for (const node in graph) {\n                for (const neighbor of graph[node]) {\n                    drawEdge(node, neighbor);\n                }\n            }\n            \n            // Draw nodes\n            for (const node in nodePositions) {\n                drawNode(node, nodePositions[node].x, nodePositions[node].y);\n            }\n            \n            updateQueueDisplay();\n        }\n\n        function drawNode(label, x, y) {\n            const node = document.createElement('div');\n            node.className = 'node';\n            node.id = `node-${label}`;\n            node.textContent = label;\n            node.style.left = `${x - 20}px`;\n            node.style.top = `${y - 20}px`;\n            graphCanvas.appendChild(node);\n        }\n\n        function drawEdge(node1, node2) {\n            const pos1 = nodePositions[node1];\n            const pos2 = nodePositions[node2];\n            \n            // Calculate distance and angle between nodes\n            const dx = pos2.x - pos1.x;\n            const dy = pos2.y - pos1.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            const angle = Math.atan2(dy, dx) * 180 / Math.PI;\n            \n            const edge = document.createElement('div');\n            edge.className = 'edge';\n            edge.style.width = `${distance}px`;\n            edge.style.left = `${pos1.x}px`;\n            edge.style.top = `${pos1.y}px`;\n            edge.style.transform = `rotate(${angle}deg)`;\n            graphCanvas.appendChild(edge);\n        }\n\n        function updateNodeVisualization() {\n            // Reset all nodes\n            document.querySelectorAll('.node').forEach(node => {\n                node.classList.remove('visited', 'current');\n            });\n            \n            // Mark visited nodes\n            bfsState.visited.forEach(node => {\n                const nodeElement = document.getElementById(`node-${node}`);\n                if (nodeElement) {\n                    nodeElement.classList.add('visited');\n                }\n            });\n            \n            // Mark current node\n            if (bfsState.current) {\n                const currentNode = document.getElementById(`node-${bfsState.current}`);\n                if (currentNode) {\n                    currentNode.classList.add('current');\n                }\n            }\n        }\n\n        function updateQueueDisplay() {\n            queueContents.innerHTML = '';\n            bfsState.queue.forEach(node => {\n                const queueItem = document.createElement('div');\n                queueItem.className = 'queue-item';\n                queueItem.textContent = node;\n                queueContents.appendChild(queueItem);\n            });\n        }\n\n        function updateStepDescription() {\n            const step = bfsState.step;\n            let description = '';\n            \n            switch(step) {\n                case 0:\n                    description = 'Ready to start BFS. Click \"Start BFS\" to begin.';\n                    break;\n                case 1:\n                    description = `Starting BFS from node ${bfsState.current}. Added to queue.`;\n                    break;\n                case 2:\n                    description = `Visiting node ${bfsState.current}. Marking as visited.`;\n                    break;\n                case 3:\n                    description = `Exploring neighbors of ${bfsState.current}. Adding unvisited neighbors to queue.`;\n                    break;\n                case 4:\n                    description = `${bfsState.current} processed. Moving to next node in queue.`;\n                    break;\n                case 5:\n                    description = 'BFS completed. All reachable nodes have been visited.';\n                    break;\n                default:\n                    description = `Step ${step}: Processing...`;\n            }\n            \n            stepDescription.textContent = description;\n        }\n\n        function bfsStep() {\n            if (bfsState.queue.length === 0) {\n                if (bfsState.step === 0) {\n                    // Initialize BFS\n                    const startNode = startNodeSelect.value;\n                    bfsState.queue.push(startNode);\n                    bfsState.visited.add(startNode);\n                    bfsState.current = startNode;\n                    bfsState.step = 1;\n                    bfsState.isRunning = true;\n                } else {\n                    // BFS completed\n                    bfsState.isRunning = false;\n                    bfsState.step = 5;\n                    nextBtn.disabled = true;\n                    startBtn.disabled = false;\n                }\n            } else {\n                if (bfsState.step === 1 || bfsState.step === 4) {\n                    // Dequeue and visit next node\n                    bfsState.current = bfsState.queue.shift();\n                    bfsState.step = 2;\n                } else if (bfsState.step === 2) {\n                    // Mark as visited and explore neighbors\n                    bfsState.visited.add(bfsState.current);\n                    bfsState.step = 3;\n                } else if (bfsState.step === 3) {\n                    // Add unvisited neighbors to queue\n                    const neighbors = graph[bfsState.current];\n                    for (const neighbor of neighbors) {\n                        if (!bfsState.visited.has(neighbor)) {\n                            bfsState.visited.add(neighbor);\n                            bfsState.queue.push(neighbor);\n                        }\n                    }\n                    bfsState.step = 4;\n                }\n            }\n            \n            updateNodeVisualization();\n            updateQueueDisplay();\n            updateStepDescription();\n        }\n\n        function resetBFS() {\n            bfsState = {\n                visited: new Set(),\n                queue: [],\n                current: null,\n                step: 0,\n                isRunning: false\n            };\n            \n            nextBtn.disabled = true;\n            startBtn.disabled = false;\n            \n            updateNodeVisualization();\n            updateQueueDisplay();\n            updateStepDescription();\n        }\n\n        // Event Listeners\n        startBtn.addEventListener('click', () => {\n            resetBFS();\n            bfsStep(); // Initial step\n            nextBtn.disabled = false;\n            startBtn.disabled = true;\n        });\n\n        nextBtn.addEventListener('click', bfsStep);\n\n        resetBtn.addEventListener('click', () => {\n            resetBFS();\n            initializeGraph();\n        });\n\n        startNodeSelect.addEventListener('change', resetBFS);\n\n        // Initialize\n        initializeGraph();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": false,
  "hasTest": true
}