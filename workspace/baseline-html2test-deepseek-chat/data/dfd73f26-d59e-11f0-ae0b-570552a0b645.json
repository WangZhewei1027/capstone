{
  "id": "dfd73f26-d59e-11f0-ae0b-570552a0b645",
  "timestamp": "2025-12-10T08:08:28.163Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency List",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Adjacency List Visualization</title>\n    <style>\n        * {\n            box-sizing: border-box;\n            margin: 0;\n            padding: 0;\n        }\n        \n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            min-height: 100vh;\n            padding: 20px;\n            color: #333;\n        }\n        \n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n            background: white;\n            border-radius: 15px;\n            box-shadow: 0 10px 30px rgba(0,0,0,0.2);\n            overflow: hidden;\n        }\n        \n        header {\n            background: #2c3e50;\n            color: white;\n            padding: 20px;\n            text-align: center;\n        }\n        \n        h1 {\n            font-size: 2.5rem;\n            margin-bottom: 10px;\n        }\n        \n        .subtitle {\n            font-size: 1.2rem;\n            opacity: 0.8;\n        }\n        \n        .content {\n            display: flex;\n            flex-wrap: wrap;\n            padding: 20px;\n        }\n        \n        .controls {\n            flex: 1;\n            min-width: 300px;\n            padding: 20px;\n            background: #f8f9fa;\n            border-radius: 10px;\n            margin-right: 20px;\n        }\n        \n        .visualization {\n            flex: 2;\n            min-width: 500px;\n            padding: 20px;\n        }\n        \n        .control-group {\n            margin-bottom: 20px;\n        }\n        \n        h2 {\n            color: #2c3e50;\n            margin-bottom: 15px;\n            font-size: 1.5rem;\n        }\n        \n        label {\n            display: block;\n            margin-bottom: 5px;\n            font-weight: bold;\n        }\n        \n        input, select, button {\n            width: 100%;\n            padding: 10px;\n            margin-bottom: 10px;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            font-size: 1rem;\n        }\n        \n        button {\n            background: #3498db;\n            color: white;\n            border: none;\n            cursor: pointer;\n            transition: background 0.3s;\n            font-weight: bold;\n        }\n        \n        button:hover {\n            background: #2980b9;\n        }\n        \n        button.reset {\n            background: #e74c3c;\n        }\n        \n        button.reset:hover {\n            background: #c0392b;\n        }\n        \n        .graph-container {\n            width: 100%;\n            height: 400px;\n            border: 1px solid #ddd;\n            border-radius: 10px;\n            position: relative;\n            overflow: auto;\n            background: #f9f9f9;\n        }\n        \n        .node {\n            position: absolute;\n            width: 50px;\n            height: 50px;\n            border-radius: 50%;\n            background: #3498db;\n            color: white;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            box-shadow: 0 3px 6px rgba(0,0,0,0.1);\n            cursor: pointer;\n            transition: all 0.3s;\n            z-index: 10;\n        }\n        \n        .node:hover {\n            transform: scale(1.1);\n            box-shadow: 0 5px 15px rgba(0,0,0,0.2);\n        }\n        \n        .edge {\n            position: absolute;\n            height: 3px;\n            background: #e74c3c;\n            transform-origin: 0 0;\n            z-index: 1;\n        }\n        \n        .adjacency-list {\n            margin-top: 20px;\n            background: #f8f9fa;\n            border-radius: 10px;\n            padding: 15px;\n            max-height: 200px;\n            overflow-y: auto;\n        }\n        \n        .adjacency-item {\n            margin-bottom: 10px;\n            padding: 10px;\n            background: white;\n            border-radius: 5px;\n            border-left: 4px solid #3498db;\n        }\n        \n        .info-panel {\n            margin-top: 20px;\n            padding: 15px;\n            background: #e8f4fc;\n            border-radius: 10px;\n            border-left: 4px solid #3498db;\n        }\n        \n        .highlight {\n            background: #fff3cd !important;\n            border-color: #ffc107 !important;\n        }\n        \n        @media (max-width: 768px) {\n            .content {\n                flex-direction: column;\n            }\n            \n            .controls, .visualization {\n                min-width: 100%;\n                margin-right: 0;\n                margin-bottom: 20px;\n            }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>Adjacency List Visualization</h1>\n            <div class=\"subtitle\">A visual demonstration of graph representation using adjacency lists</div>\n        </header>\n        \n        <div class=\"content\">\n            <div class=\"controls\">\n                <div class=\"control-group\">\n                    <h2>Graph Controls</h2>\n                    <label for=\"nodeCount\">Number of Nodes:</label>\n                    <input type=\"number\" id=\"nodeCount\" min=\"2\" max=\"10\" value=\"5\">\n                    \n                    <label for=\"graphType\">Graph Type:</label>\n                    <select id=\"graphType\">\n                        <option value=\"directed\">Directed Graph</option>\n                        <option value=\"undirected\">Undirected Graph</option>\n                    </select>\n                    \n                    <button id=\"generateGraph\">Generate Graph</button>\n                    <button id=\"resetGraph\" class=\"reset\">Reset Graph</button>\n                </div>\n                \n                <div class=\"control-group\">\n                    <h2>Add Connection</h2>\n                    <label for=\"fromNode\">From Node:</label>\n                    <select id=\"fromNode\"></select>\n                    \n                    <label for=\"toNode\">To Node:</label>\n                    <select id=\"toNode\"></select>\n                    \n                    <button id=\"addEdge\">Add Connection</button>\n                </div>\n                \n                <div class=\"control-group\">\n                    <h2>About Adjacency Lists</h2>\n                    <div class=\"info-panel\">\n                        <p>An adjacency list represents a graph as an array of linked lists. Each index represents a vertex, and each element in the linked list represents the vertices adjacent to that vertex.</p>\n                        <p><strong>Space Complexity:</strong> O(V + E) where V is vertices and E is edges</p>\n                        <p><strong>Advantages:</strong> Efficient for sparse graphs, easy to find all vertices adjacent to a given vertex</p>\n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"visualization\">\n                <h2>Graph Visualization</h2>\n                <div class=\"graph-container\" id=\"graphContainer\">\n                    <!-- Graph will be rendered here -->\n                </div>\n                \n                <h2>Adjacency List Representation</h2>\n                <div class=\"adjacency-list\" id=\"adjacencyList\">\n                    <!-- Adjacency list will be displayed here -->\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        class AdjacencyListVisualizer {\n            constructor() {\n                this.nodes = [];\n                this.edges = [];\n                this.nodeCount = 5;\n                this.graphType = 'directed';\n                this.nodePositions = [];\n                \n                this.initializeEventListeners();\n                this.generateGraph();\n            }\n            \n            initializeEventListeners() {\n                document.getElementById('generateGraph').addEventListener('click', () => {\n                    this.nodeCount = parseInt(document.getElementById('nodeCount').value);\n                    this.graphType = document.getElementById('graphType').value;\n                    this.generateGraph();\n                });\n                \n                document.getElementById('resetGraph').addEventListener('click', () => {\n                    this.nodes = [];\n                    this.edges = [];\n                    this.renderGraph();\n                    this.updateAdjacencyList();\n                });\n                \n                document.getElementById('addEdge').addEventListener('click', () => {\n                    this.addEdge();\n                });\n            }\n            \n            generateGraph() {\n                this.nodes = Array.from({length: this.nodeCount}, (_, i) => i);\n                this.edges = [];\n                \n                // Generate random edges for demo\n                for (let i = 0; i < this.nodeCount * 1.5; i++) {\n                    const from = Math.floor(Math.random() * this.nodeCount);\n                    let to = Math.floor(Math.random() * this.nodeCount);\n                    \n                    // Ensure we don't have self-loops for simplicity\n                    while (to === from) {\n                        to = Math.floor(Math.random() * this.nodeCount);\n                    }\n                    \n                    if (!this.edgeExists(from, to)) {\n                        this.edges.push({from, to});\n                    }\n                }\n                \n                this.calculateNodePositions();\n                this.renderGraph();\n                this.updateNodeSelects();\n                this.updateAdjacencyList();\n            }\n            \n            calculateNodePositions() {\n                const container = document.getElementById('graphContainer');\n                const width = container.clientWidth - 100;\n                const height = container.clientHeight - 100;\n                \n                this.nodePositions = [];\n                \n                // Arrange nodes in a circle\n                const centerX = width / 2;\n                const centerY = height / 2;\n                const radius = Math.min(width, height) / 3;\n                \n                for (let i = 0; i < this.nodeCount; i++) {\n                    const angle = (2 * Math.PI * i) / this.nodeCount;\n                    const x = centerX + radius * Math.cos(angle);\n                    const y = centerY + radius * Math.sin(angle);\n                    this.nodePositions.push({x, y});\n                }\n            }\n            \n            renderGraph() {\n                const container = document.getElementById('graphContainer');\n                container.innerHTML = '';\n                \n                // Render edges first (so they appear behind nodes)\n                this.edges.forEach(edge => {\n                    this.renderEdge(edge);\n                });\n                \n                // Render nodes\n                this.nodes.forEach((node, index) => {\n                    this.renderNode(node, index);\n                });\n            }\n            \n            renderNode(node, index) {\n                const container = document.getElementById('graphContainer');\n                const position = this.nodePositions[index];\n                \n                const nodeElement = document.createElement('div');\n                nodeElement.className = 'node';\n                nodeElement.textContent = node;\n                nodeElement.style.left = `${position.x}px`;\n                nodeElement.style.top = `${position.y}px`;\n                nodeElement.dataset.nodeId = node;\n                \n                // Add click event to highlight connections\n                nodeElement.addEventListener('click', () => {\n                    this.highlightConnections(node);\n                });\n                \n                container.appendChild(nodeElement);\n            }\n            \n            renderEdge(edge) {\n                const container = document.getElementById('graphContainer');\n                const fromPos = this.nodePositions[edge.from];\n                const toPos = this.nodePositions[edge.to];\n                \n                // Calculate distance and angle between nodes\n                const dx = toPos.x - fromPos.x;\n                const dy = toPos.y - fromPos.y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                const angle = Math.atan2(dy, dx) * 180 / Math.PI;\n                \n                const edgeElement = document.createElement('div');\n                edgeElement.className = 'edge';\n                edgeElement.style.width = `${distance}px`;\n                edgeElement.style.left = `${fromPos.x + 25}px`; // Adjust for node radius\n                edgeElement.style.top = `${fromPos.y + 25}px`;\n                edgeElement.style.transform = `rotate(${angle}deg)`;\n                edgeElement.dataset.from = edge.from;\n                edgeElement.dataset.to = edge.to;\n                \n                container.appendChild(edgeElement);\n                \n                // Add arrowhead for directed graphs\n                if (this.graphType === 'directed') {\n                    this.addArrowhead(fromPos, toPos, angle);\n                }\n            }\n            \n            addArrowhead(fromPos, toPos, angle) {\n                const container = document.getElementById('graphContainer');\n                \n                // Calculate position for arrowhead (near the target node)\n                const arrowSize = 10;\n                const offset = 40; // Distance from center of target node\n                \n                const dx = toPos.x - fromPos.x;\n                const dy = toPos.y - fromPos.y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                const ratio = (distance - offset) / distance;\n                \n                const arrowX = fromPos.x + dx * ratio + 25;\n                const arrowY = fromPos.y + dy * ratio + 25;\n                \n                const arrow = document.createElement('div');\n                arrow.style.width = '0';\n                arrow.style.height = '0';\n                arrow.style.borderLeft = `${arrowSize}px solid #e74c3c`;\n                arrow.style.borderTop = `${arrowSize/2}px solid transparent`;\n                arrow.style.borderBottom = `${arrowSize/2}px solid transparent`;\n                arrow.style.position = 'absolute';\n                arrow.style.left = `${arrowX}px`;\n                arrow.style.top = `${arrowY}px`;\n                arrow.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;\n                \n                container.appendChild(arrow);\n            }\n            \n            addEdge() {\n                const fromNode = parseInt(document.getElementById('fromNode').value);\n                const toNode = parseInt(document.getElementById('toNode').value);\n                \n                if (fromNode === toNode) {\n                    alert('Self-loops are not allowed in this visualization');\n                    return;\n                }\n                \n                if (this.edgeExists(fromNode, toNode)) {\n                    alert('This edge already exists!');\n                    return;\n                }\n                \n                this.edges.push({from: fromNode, to: toNode});\n                \n                // For undirected graphs, add the reverse edge\n                if (this.graphType === 'undirected' && !this.edgeExists(toNode, fromNode)) {\n                    this.edges.push({from: toNode, to: fromNode});\n                }\n                \n                this.renderGraph();\n                this.updateAdjacencyList();\n            }\n            \n            edgeExists(from, to) {\n                return this.edges.some(edge => edge.from === from && edge.to === to);\n            }\n            \n            updateNodeSelects() {\n                const fromNodeSelect = document.getElementById('fromNode');\n                const toNodeSelect = document.getElementById('toNode');\n                \n                fromNodeSelect.innerHTML = '';\n                toNodeSelect.innerHTML = '';\n                \n                this.nodes.forEach(node => {\n                    const option1 = document.createElement('option');\n                    option1.value = node;\n                    option1.textContent = `Node ${node}`;\n                    fromNodeSelect.appendChild(option1);\n                    \n                    const option2 = document.createElement('option');\n                    option2.value = node;\n                    option2.textContent = `Node ${node}`;\n                    toNodeSelect.appendChild(option2);\n                });\n            }\n            \n            updateAdjacencyList() {\n                const adjacencyListElement = document.getElementById('adjacencyList');\n                adjacencyListElement.innerHTML = '';\n                \n                // Create adjacency list data structure\n                const adjacencyList = {};\n                this.nodes.forEach(node => {\n                    adjacencyList[node] = [];\n                });\n                \n                this.edges.forEach(edge => {\n                    if (!adjacencyList[edge.from].includes(edge.to)) {\n                        adjacencyList[edge.from].push(edge.to);\n                    }\n                });\n                \n                // Display the adjacency list\n                Object.keys(adjacencyList).forEach(node => {\n                    const item = document.createElement('div');\n                    item.className = 'adjacency-item';\n                    item.innerHTML = `<strong>Node ${node}:</strong> [${adjacencyList[node].join(', ')}]`;\n                    item.dataset.nodeId = node;\n                    \n                    // Add click event to highlight connections\n                    item.addEventListener('click', () => {\n                        this.highlightConnections(parseInt(node));\n                    });\n                    \n                    adjacencyListElement.appendChild(item);\n                });\n            }\n            \n            highlightConnections(nodeId) {\n                // Remove previous highlights\n                document.querySelectorAll('.node, .edge, .adjacency-item').forEach(el => {\n                    el.classList.remove('highlight');\n                });\n                \n                // Highlight the selected node\n                const selectedNode = document.querySelector(`.node[data-node-id=\"${nodeId}\"]`);\n                const selectedListItem = document.querySelector(`.adjacency-item[data-node-id=\"${nodeId}\"]`);\n                \n                if (selectedNode) selectedNode.classList.add('highlight');\n                if (selectedListItem) selectedListItem.classList.add('highlight');\n                \n                // Highlight edges from this node\n                document.querySelectorAll('.edge').forEach(edge => {\n                    if (parseInt(edge.dataset.from) === nodeId) {\n                        edge.classList.add('highlight');\n                        \n                        // Highlight the target node\n                        const targetNode = document.querySelector(`.node[data-node-id=\"${edge.dataset.to}\"]`);\n                        if (targetNode) targetNode.classList.add('highlight');\n                    }\n                });\n                \n                // For undirected graphs, also highlight edges to this node\n                if (this.graphType === 'undirected') {\n                    document.querySelectorAll('.edge').forEach(edge => {\n                        if (parseInt(edge.dataset.to) === nodeId) {\n                            edge.classList.add('highlight');\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Initialize the visualization when the page loads\n        document.addEventListener('DOMContentLoaded', () => {\n            new AdjacencyListVisualizer();\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency List"
    }
  ],
  "topic": "Adjacency List",
  "hasFSM": false,
  "hasTest": true
}