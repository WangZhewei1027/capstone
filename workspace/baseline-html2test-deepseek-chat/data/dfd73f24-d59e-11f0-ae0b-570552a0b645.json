{
  "id": "dfd73f24-d59e-11f0-ae0b-570552a0b645",
  "timestamp": "2025-12-10T08:07:37.657Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Weighted Graph Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background: #f5f5f5;\n        }\n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n        }\n        .controls {\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            margin-bottom: 20px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        .canvas-container {\n            background: white;\n            border-radius: 8px;\n            padding: 20px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        canvas {\n            border: 1px solid #ddd;\n            background: #fafafa;\n        }\n        button {\n            padding: 8px 16px;\n            margin: 5px;\n            border: none;\n            border-radius: 4px;\n            background: #4CAF50;\n            color: white;\n            cursor: pointer;\n        }\n        button:hover {\n            background: #45a049;\n        }\n        input {\n            padding: 8px;\n            margin: 5px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n        }\n        .info {\n            margin-top: 20px;\n            padding: 15px;\n            background: #e7f3ff;\n            border-radius: 4px;\n            border-left: 4px solid #2196F3;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Weighted Graph Visualization</h1>\n        \n        <div class=\"controls\">\n            <h3>Graph Controls</h3>\n            <div>\n                <input type=\"text\" id=\"node1\" placeholder=\"Node 1\" value=\"A\">\n                <input type=\"text\" id=\"node2\" placeholder=\"Node 2\" value=\"B\">\n                <input type=\"number\" id=\"weight\" placeholder=\"Weight\" value=\"5\" min=\"1\" max=\"100\">\n                <button onclick=\"addEdge()\">Add Edge</button>\n                <button onclick=\"addNode()\">Add Node</button>\n                <button onclick=\"clearGraph()\">Clear Graph</button>\n            </div>\n            <div style=\"margin-top: 10px;\">\n                <button onclick=\"findShortestPath()\">Find Shortest Path</button>\n                <input type=\"text\" id=\"startNode\" placeholder=\"Start Node\" value=\"A\">\n                <input type=\"text\" id=\"endNode\" placeholder=\"End Node\" value=\"C\">\n            </div>\n        </div>\n\n        <div class=\"canvas-container\">\n            <canvas id=\"graphCanvas\" width=\"800\" height=\"500\"></canvas>\n        </div>\n\n        <div class=\"info\">\n            <h3>About Weighted Graphs</h3>\n            <p>A weighted graph is a graph where each edge has a numerical value (weight) associated with it. \n            Weights can represent distances, costs, capacities, or other quantities.</p>\n            <p><strong>Common applications:</strong> Network routing, GPS navigation, social network analysis, \n            project scheduling, and optimization problems.</p>\n        </div>\n    </div>\n\n    <script>\n        class WeightedGraph {\n            constructor() {\n                this.nodes = new Set();\n                this.edges = new Map();\n                this.positions = new Map();\n            }\n\n            addNode(node) {\n                if (!this.nodes.has(node)) {\n                    this.nodes.add(node);\n                    this.edges.set(node, new Map());\n                    // Assign random position for visualization\n                    this.positions.set(node, {\n                        x: Math.random() * 700 + 50,\n                        y: Math.random() * 400 + 50\n                    });\n                }\n            }\n\n            addEdge(node1, node2, weight) {\n                this.addNode(node1);\n                this.addNode(node2);\n                \n                this.edges.get(node1).set(node2, weight);\n                this.edges.get(node2).set(node1, weight); // Undirected graph\n            }\n\n            getNeighbors(node) {\n                return this.edges.get(node) || new Map();\n            }\n\n            // Dijkstra's algorithm for shortest path\n            shortestPath(start, end) {\n                if (!this.nodes.has(start) || !this.nodes.has(end)) {\n                    return null;\n                }\n\n                const distances = new Map();\n                const previous = new Map();\n                const unvisited = new Set(this.nodes);\n\n                // Initialize distances\n                for (const node of this.nodes) {\n                    distances.set(node, node === start ? 0 : Infinity);\n                    previous.set(node, null);\n                }\n\n                while (unvisited.size > 0) {\n                    // Find node with smallest distance\n                    let current = null;\n                    for (const node of unvisited) {\n                        if (current === null || distances.get(node) < distances.get(current)) {\n                            current = node;\n                        }\n                    }\n\n                    if (current === end) break;\n\n                    unvisited.delete(current);\n\n                    // Update distances to neighbors\n                    for (const [neighbor, weight] of this.getNeighbors(current)) {\n                        const alt = distances.get(current) + weight;\n                        if (alt < distances.get(neighbor)) {\n                            distances.set(neighbor, alt);\n                            previous.set(neighbor, current);\n                        }\n                    }\n                }\n\n                // Reconstruct path\n                const path = [];\n                let current = end;\n                while (current !== null) {\n                    path.unshift(current);\n                    current = previous.get(current);\n                }\n\n                return path[0] === start ? path : null;\n            }\n        }\n\n        const graph = new WeightedGraph();\n        const canvas = document.getElementById('graphCanvas');\n        const ctx = canvas.getContext('2d');\n        let shortestPath = null;\n\n        // Initialize with sample graph\n        graph.addEdge('A', 'B', 4);\n        graph.addEdge('A', 'C', 2);\n        graph.addEdge('B', 'C', 1);\n        graph.addEdge('B', 'D', 5);\n        graph.addEdge('C', 'D', 8);\n        graph.addEdge('C', 'E', 10);\n        graph.addEdge('D', 'E', 2);\n\n        function drawGraph() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Draw edges\n            ctx.strokeStyle = '#666';\n            ctx.lineWidth = 2;\n            ctx.font = '14px Arial';\n            ctx.textAlign = 'center';\n            \n            for (const node1 of graph.nodes) {\n                for (const [node2, weight] of graph.edges.get(node1)) {\n                    const pos1 = graph.positions.get(node1);\n                    const pos2 = graph.positions.get(node2);\n                    \n                    // Highlight shortest path edges\n                    if (shortestPath) {\n                        const idx1 = shortestPath.indexOf(node1);\n                        const idx2 = shortestPath.indexOf(node2);\n                        if (idx1 !== -1 && idx2 !== -1 && Math.abs(idx1 - idx2) === 1) {\n                            ctx.strokeStyle = '#ff4444';\n                            ctx.lineWidth = 4;\n                        } else {\n                            ctx.strokeStyle = '#666';\n                            ctx.lineWidth = 2;\n                        }\n                    }\n                    \n                    ctx.beginPath();\n                    ctx.moveTo(pos1.x, pos1.y);\n                    ctx.lineTo(pos2.x, pos2.y);\n                    ctx.stroke();\n                    \n                    // Draw weight\n                    const midX = (pos1.x + pos2.x) / 2;\n                    const midY = (pos1.y + pos2.y) / 2;\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(midX - 15, midY - 10, 30, 20);\n                    ctx.fillStyle = '#333';\n                    ctx.fillText(weight, midX, midY + 5);\n                }\n            }\n            \n            // Draw nodes\n            for (const node of graph.nodes) {\n                const pos = graph.positions.get(node);\n                \n                // Highlight shortest path nodes\n                if (shortestPath && shortestPath.includes(node)) {\n                    ctx.fillStyle = '#ff4444';\n                } else {\n                    ctx.fillStyle = '#4CAF50';\n                }\n                \n                ctx.beginPath();\n                ctx.arc(pos.x, pos.y, 20, 0, 2 * Math.PI);\n                ctx.fill();\n                \n                ctx.fillStyle = 'white';\n                ctx.font = 'bold 16px Arial';\n                ctx.fillText(node, pos.x, pos.y + 5);\n            }\n        }\n\n        function addEdge() {\n            const node1 = document.getElementById('node1').value.toUpperCase();\n            const node2 = document.getElementById('node2').value.toUpperCase();\n            const weight = parseInt(document.getElementById('weight').value);\n            \n            if (node1 && node2 && weight > 0) {\n                graph.addEdge(node1, node2, weight);\n                shortestPath = null;\n                drawGraph();\n            }\n        }\n\n        function addNode() {\n            const node1 = document.getElementById('node1').value.toUpperCase();\n            if (node1) {\n                graph.addNode(node1);\n                shortestPath = null;\n                drawGraph();\n            }\n        }\n\n        function clearGraph() {\n            graph.nodes.clear();\n            graph.edges.clear();\n            graph.positions.clear();\n            shortestPath = null;\n            drawGraph();\n        }\n\n        function findShortestPath() {\n            const start = document.getElementById('startNode').value.toUpperCase();\n            const end = document.getElementById('endNode').value.toUpperCase();\n            \n            if (start && end) {\n                shortestPath = graph.shortestPath(start, end);\n                if (shortestPath) {\n                    alert(`Shortest path: ${shortestPath.join(' â†’ ')}`);\n                } else {\n                    alert('No path found between the specified nodes.');\n                }\n                drawGraph();\n            }\n        }\n\n        // Make nodes draggable\n        let draggedNode = null;\n        let dragOffset = { x: 0, y: 0 };\n\n        canvas.addEventListener('mousedown', (e) => {\n            const rect = canvas.getBoundingClientRect();\n            const mouseX = e.clientX - rect.left;\n            const mouseY = e.clientY - rect.top;\n            \n            for (const node of graph.nodes) {\n                const pos = graph.positions.get(node);\n                const distance = Math.sqrt((mouseX - pos.x) ** 2 + (mouseY - pos.y) ** 2);\n                \n                if (distance <= 20) {\n                    draggedNode = node;\n                    dragOffset.x = mouseX - pos.x;\n                    dragOffset.y = mouseY - pos.y;\n                    break;\n                }\n            }\n        });\n\n        canvas.addEventListener('mousemove', (e) => {\n            if (draggedNode) {\n                const rect = canvas.getBoundingClientRect();\n                const mouseX = e.clientX - rect.left;\n                const mouseY = e.clientY - rect.top;\n                \n                graph.positions.get(draggedNode).x = mouseX - dragOffset.x;\n                graph.positions.get(draggedNode).y = mouseY - dragOffset.y;\n                drawGraph();\n            }\n        });\n\n        canvas.addEventListener('mouseup', () => {\n            draggedNode = null;\n        });\n\n        // Initial draw\n        drawGraph();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": false,
  "hasTest": true
}