{
  "id": "dfd78d47-d59e-11f0-ae0b-570552a0b645",
  "timestamp": "2025-12-10T08:09:16.767Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Sliding Window",
  "answer": {
    "role": "assistant",
    "content": "# Sliding Window Technique Implementation\n\nI'll create an interactive demonstration of the sliding window algorithm, which is commonly used for solving problems that involve arrays or sequences.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Sliding Window Technique</title>\n    <style>\n        * {\n            box-sizing: border-box;\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n        }\n        \n        body {\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f7fa;\n            color: #333;\n            line-height: 1.6;\n        }\n        \n        .container {\n            max-width: 900px;\n            margin: 0 auto;\n            background-color: white;\n            border-radius: 10px;\n            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);\n            padding: 25px;\n        }\n        \n        h1 {\n            color: #2c3e50;\n            text-align: center;\n            margin-bottom: 30px;\n        }\n        \n        .description {\n            background-color: #f8f9fa;\n            padding: 20px;\n            border-radius: 8px;\n            margin-bottom: 25px;\n            border-left: 4px solid #3498db;\n        }\n        \n        .controls {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 15px;\n            margin-bottom: 30px;\n            align-items: center;\n            justify-content: center;\n        }\n        \n        .control-group {\n            display: flex;\n            flex-direction: column;\n            gap: 5px;\n        }\n        \n        label {\n            font-weight: 600;\n        }\n        \n        input, select, button {\n            padding: 10px 15px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            font-size: 16px;\n        }\n        \n        button {\n            background-color: #3498db;\n            color: white;\n            border: none;\n            cursor: pointer;\n            transition: background-color 0.3s;\n            font-weight: 600;\n        }\n        \n        button:hover {\n            background-color: #2980b9;\n        }\n        \n        .visualization {\n            display: flex;\n            flex-direction: column;\n            gap: 20px;\n            margin-top: 30px;\n        }\n        \n        .array-container {\n            display: flex;\n            justify-content: center;\n            flex-wrap: wrap;\n            gap: 10px;\n            margin-bottom: 20px;\n        }\n        \n        .array-element {\n            width: 50px;\n            height: 50px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            background-color: #e7f4fd;\n            border: 2px solid #3498db;\n            border-radius: 8px;\n            font-weight: bold;\n            font-size: 18px;\n            transition: all 0.3s;\n        }\n        \n        .window-element {\n            background-color: #2ecc71;\n            border-color: #27ae60;\n            color: white;\n        }\n        \n        .window-boundary {\n            background-color: #e74c3c;\n            border-color: #c0392b;\n            color: white;\n        }\n        \n        .algorithm-steps {\n            background-color: #f8f9fa;\n            padding: 15px;\n            border-radius: 8px;\n            margin-top: 20px;\n            max-height: 200px;\n            overflow-y: auto;\n        }\n        \n        .step {\n            padding: 10px;\n            margin-bottom: 5px;\n            border-radius: 4px;\n            background-color: white;\n        }\n        \n        .current-step {\n            background-color: #e7f4fd;\n            border-left: 4px solid #3498db;\n        }\n        \n        .result {\n            text-align: center;\n            font-size: 20px;\n            font-weight: bold;\n            margin-top: 20px;\n            padding: 15px;\n            background-color: #f39c12;\n            color: white;\n            border-radius: 8px;\n            display: none;\n        }\n        \n        .complexity {\n            display: flex;\n            justify-content: space-around;\n            margin-top: 30px;\n            padding-top: 20px;\n            border-top: 1px solid #eee;\n        }\n        \n        .complexity-box {\n            text-align: center;\n            padding: 15px;\n            background-color: #f8f9fa;\n            border-radius: 8px;\n            width: 45%;\n        }\n        \n        .complexity-title {\n            font-weight: bold;\n            margin-bottom: 5px;\n            color: #2c3e50;\n        }\n        \n        .complexity-value {\n            font-size: 18px;\n            color: #e74c3c;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Sliding Window Technique</h1>\n        \n        <div class=\"description\">\n            <p>The sliding window technique is an algorithmic approach used to solve problems involving arrays or sequences. Instead of processing each element repeatedly, it maintains a \"window\" that slides through the data, updating computations efficiently as it moves.</p>\n            <p>This technique is particularly useful for problems involving subarrays or substrings, where you need to find a contiguous segment that satisfies certain conditions.</p>\n        </div>\n        \n        <div class=\"controls\">\n            <div class=\"control-group\">\n                <label for=\"array-input\">Array Elements (comma separated):</label>\n                <input type=\"text\" id=\"array-input\" value=\"2,1,5,1,3,2\" placeholder=\"e.g., 2,1,5,1,3,2\">\n            </div>\n            \n            <div class=\"control-group\">\n                <label for=\"window-size\">Window Size (k):</label>\n                <input type=\"number\" id=\"window-size\" value=\"3\" min=\"1\" max=\"10\">\n            </div>\n            \n            <div class=\"control-group\">\n                <label for=\"problem-type\">Problem Type:</label>\n                <select id=\"problem-type\">\n                    <option value=\"max-sum\">Maximum Sum Subarray</option>\n                    <option value=\"min-sum\">Minimum Sum Subarray</option>\n                    <option value=\"longest-substring\">Longest Substring Without Repeating Characters</option>\n                </select>\n            </div>\n            \n            <button id=\"run-btn\">Run Algorithm</button>\n            <button id=\"step-btn\">Next Step</button>\n            <button id=\"reset-btn\">Reset</button>\n        </div>\n        \n        <div class=\"visualization\">\n            <div id=\"array-container\" class=\"array-container\">\n                <!-- Array elements will be dynamically inserted here -->\n            </div>\n            \n            <div class=\"algorithm-steps\" id=\"algorithm-steps\">\n                <div class=\"step\">Algorithm steps will appear here...</div>\n            </div>\n            \n            <div id=\"result\" class=\"result\"></div>\n            \n            <div class=\"complexity\">\n                <div class=\"complexity-box\">\n                    <div class=\"complexity-title\">Time Complexity</div>\n                    <div class=\"complexity-value\" id=\"time-complexity\">O(n)</div>\n                </div>\n                <div class=\"complexity-box\">\n                    <div class=\"complexity-title\">Space Complexity</div>\n                    <div class=\"complexity-value\" id=\"space-complexity\">O(1)</div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        // DOM elements\n        const arrayInput = document.getElementById('array-input');\n        const windowSizeInput = document.getElementById('window-size');\n        const problemTypeSelect = document.getElementById('problem-type');\n        const runBtn = document.getElementById('run-btn');\n        const stepBtn = document.getElementById('step-btn');\n        const resetBtn = document.getElementById('reset-btn');\n        const arrayContainer = document.getElementById('array-container');\n        const algorithmSteps = document.getElementById('algorithm-steps');\n        const resultDiv = document.getElementById('result');\n        const timeComplexity = document.getElementById('time-complexity');\n        const spaceComplexity = document.getElementById('space-complexity');\n        \n        // Algorithm state\n        let currentStep = 0;\n        let steps = [];\n        let array = [];\n        let windowSize = 3;\n        let currentWindow = [];\n        \n        // Initialize the visualization\n        function initializeVisualization() {\n            array = arrayInput.value.split(',').map(Number);\n            windowSize = parseInt(windowSizeInput.value);\n            currentStep = 0;\n            steps = [];\n            algorithmSteps.innerHTML = '';\n            resultDiv.style.display = 'none';\n            \n            // Render array elements\n            arrayContainer.innerHTML = '';\n            array.forEach((value, index) => {\n                const element = document.createElement('div');\n                element.className = 'array-element';\n                element.textContent = value;\n                element.id = `element-${index}`;\n                arrayContainer.appendChild(element);\n            });\n            \n            // Generate algorithm steps based on problem type\n            generateAlgorithmSteps();\n        }\n        \n        // Generate algorithm steps based on problem type\n        function generateAlgorithmSteps() {\n            const problemType = problemTypeSelect.value;\n            \n            switch(problemType) {\n                case 'max-sum':\n                case 'min-sum':\n                    generateSumSubarraySteps();\n                    break;\n                case 'longest-substring':\n                    generateLongestSubstringSteps();\n                    break;\n            }\n            \n            // Update complexity information\n            updateComplexityInfo();\n            \n            // Display first step\n            displayCurrentStep();\n        }\n        \n        // Generate steps for max/min sum subarray problems\n        function generateSumSubarraySteps() {\n            steps = [`Initialize window sum to 0`];\n            \n            // Calculate initial window sum\n            let initialSum = 0;\n            for (let i = 0; i < windowSize; i++) {\n                initialSum += array[i];\n                steps.push(`Add element at index ${i} (value: ${array[i]}) to window sum`);\n            }\n            \n            steps.push(`Initial window sum: ${initialSum}`);\n            \n            let maxSum = initialSum;\n            let minSum = initialSum;\n            let currentSum = initialSum;\n            let maxStart = 0;\n            let minStart = 0;\n            \n            // Slide the window\n            for (let i = windowSize; i < array.length; i++) {\n                steps.push(`Slide window: remove element at index ${i - windowSize} (value: ${array[i - windowSize]})`);\n                currentSum = currentSum - array[i - windowSize] + array[i];\n                steps.push(`Add element at index ${i} (value: ${array[i]}) to window sum`);\n                steps.push(`New window sum: ${currentSum}`);\n                \n                if (currentSum > maxSum) {\n                    maxSum = currentSum;\n                    maxStart = i - windowSize + 1;\n                    steps.push(`New maximum sum found: ${maxSum} (starting at index ${maxStart})`);\n                }\n                \n                if (currentSum < minSum) {\n                    minSum = currentSum;\n                    minStart = i - windowSize + 1;\n                    steps.push(`New minimum sum found: ${minSum} (starting at index ${minStart})`);\n                }\n            }\n            \n            // Add final result step\n            if (problemTypeSelect.value === 'max-sum') {\n                steps.push(`Maximum sum of subarray of size ${windowSize} is ${maxSum}`);\n            } else {\n                steps.push(`Minimum sum of subarray of size ${windowSize} is ${minSum}`);\n            }\n        }\n        \n        // Generate steps for longest substring without repeating characters\n        function generateLongestSubstringSteps() {\n            steps = [`Initialize variables: start = 0, maxLength = 0, charMap = {}`];\n            \n            let start = 0;\n            let maxLength = 0;\n            let charMap = {};\n            \n            for (let end = 0; end < array.length; end++) {\n                const char = array[end];\n                steps.push(`Processing element at index ${end} (value: ${char})`);\n                \n                if (charMap[char] >= start) {\n                    steps.push(`Character ${char} found in current window at index ${charMap[char]}`);\n                    start = charMap[char] + 1;\n                    steps.push(`Move window start to index ${start}`);\n                }\n                \n                charMap[char] = end;\n                maxLength = Math.max(maxLength, end - start + 1);\n                steps.push(`Current window length: ${end - start + 1}, Max length so far: ${maxLength}`);\n            }\n            \n            steps.push(`Longest substring without repeating characters has length ${maxLength}`);\n        }\n        \n        // Update complexity information based on problem type\n        function updateComplexityInfo() {\n            const problemType = problemTypeSelect.value;\n            \n            if (problemType === 'longest-substring') {\n                timeComplexity.textContent = 'O(n)';\n                spaceComplexity.textContent = 'O(min(m, n))';\n            } else {\n                timeComplexity.textContent = 'O(n)';\n                spaceComplexity.textContent = 'O(1)';\n            }\n        }\n        \n        // Display the current step of the algorithm\n        function displayCurrentStep() {\n            algorithmSteps.innerHTML = '';\n            \n            steps.forEach((step, index) => {\n                const stepElement = document.createElement('div');\n                stepElement.className = 'step';\n                if (index === currentStep) {\n                    stepElement.classList.add('current-step');\n                }\n                stepElement.textContent = `Step ${index + 1}: ${step}`;\n                algorithmSteps.appendChild(stepElement);\n            });\n            \n            // Scroll to the current step\n            algorithmSteps.scrollTop = algorithmSteps.scrollHeight;\n        }\n        \n        // Visualize the current window\n        function visualizeWindow() {\n            // Reset all elements to default style\n            for (let i = 0; i < array.length; i++) {\n                const element = document.getElementById(`element-${i}`);\n                element.className = 'array-element';\n            }\n            \n            // Highlight the current window based on algorithm step\n            const problemType = problemTypeSelect.value;\n            \n            if (problemType === 'max-sum' || problemType === 'min-sum') {\n                // For sum problems, we're sliding a fixed-size window\n                let windowStart = 0;\n                \n                if (currentStep > 0 && currentStep < steps.length - 1) {\n                    // Find the current window start based on step content\n                    const stepText = steps[currentStep];\n                    if (stepText.includes('Slide window')) {\n                        // After sliding, window start increments by 1\n                        const match = stepText.match(/remove element at index (\\d+)/);\n                        if (match) {\n                            windowStart = parseInt(match[1]) + 1;\n                        }\n                    } else if (stepText.includes('Add element at index')) {\n                        const match = stepText.match(/index (\\d+)/);\n                        if (match) {\n                            const idx = parseInt(match[1]);\n                            windowStart = idx - windowSize + 1;\n                        }\n                    }\n                }\n                \n                // Highlight the window\n                for (let i = windowStart; i < windowStart + windowSize && i < array.length; i++) {\n                    const element = document.getElementById(`element-${i}`);\n                    element.classList.add('window-element');\n                }\n                \n                // Highlight the boundaries\n                if (windowStart >= 0 && windowStart < array.length) {\n                    const startElement = document.getElementById(`element-${windowStart}`);\n                    startElement.classList.add('window-boundary');\n                }\n                \n                if (windowStart + windowSize - 1 >= 0 && windowStart + windowSize - 1 < array.length) {\n                    const endElement = document.getElementById(`element-${windowStart + windowSize - 1}`);\n                    endElement.classList.add('window-boundary');\n                }\n                \n            } else if (problemType === 'longest-substring') {\n                // For longest substring, we need more sophisticated visualization\n                // This is a simplified version for demonstration\n                let start = 0;\n                let end = 0;\n                \n                // Parse the step to determine current window\n                if (currentStep > 0) {\n                    const stepText = steps[currentStep];\n                    \n                    if (stepText.includes('Move window start to index')) {\n                        const match = stepText.match(/index (\\d+)/);\n                        if (match) {\n                            start = parseInt(match[1]);\n                        }\n                    }\n                    \n                    if (stepText.includes('Processing element at index')) {\n                        const match = stepText.match(/index (\\d+)/);\n                        if (match) {\n                            end = parseInt(match[1]);\n                        }\n                    }\n                    \n                    if (stepText.includes('Current window length')) {\n                        const match = stepText.match(/length: (\\d+)/);\n                        if (match) {\n                            const length = parseInt(match[1]);\n                            start = end - length + 1;\n                        }\n                    }\n                }\n                \n                // Highlight the window\n                for (let i = start; i <= end && i < array.length; i++) {\n                    const element = document.getElementById(`element-${i}`);\n                    element.classList.add('window-element');\n                }\n                \n                // Highlight the boundaries\n                if (start >= 0 && start < array.length) {\n                    const startElement = document.getElementById(`element-${start}`);\n                    startElement.classList.add('window-boundary');\n                }\n                \n                if (end >= 0 && end < array.length) {\n                    const endElement = document.getElementById(`element-${end}`);\n                    endElement.classList.add('window-boundary');\n                }\n            }\n        }\n        \n        // Execute the next step of the algorithm\n        function nextStep() {\n            if (currentStep < steps.length - 1) {\n                currentStep++;\n                displayCurrentStep();\n                visualizeWindow();\n                \n                // If we reached the final step, show the result\n                if (currentStep === steps.length - 1) {\n                    const resultText = steps[currentStep];\n                    resultDiv.textContent = resultText;\n                    resultDiv.style.display = 'block';\n                }\n            }\n        }\n        \n        // Run the entire algorithm at once\n        function runAlgorithm() {\n            // Reset to beginning\n            currentStep = 0;\n            initializeVisualization();\n            \n            // Fast-forward to the end\n            const interval = setInterval(() => {\n                if (currentStep < steps.length - 1) {\n                    nextStep();\n                } else {\n                    clearInterval(interval);\n                }\n            }, 1000);\n        }\n        \n        // Event listeners\n        runBtn.addEventListener('click', runAlgorithm);\n        stepBtn.addEventListener('click', nextStep);\n        resetBtn.addEventListener('click', initializeVisualization);\n"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Sliding Window"
    }
  ],
  "topic": "Sliding Window",
  "hasFSM": false,
  "hasTest": true
}