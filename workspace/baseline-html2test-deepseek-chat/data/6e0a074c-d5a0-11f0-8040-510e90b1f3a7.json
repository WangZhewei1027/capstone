{
  "id": "6e0a074c-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:19:08.563Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Topological Sort Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            display: flex;\n            gap: 30px;\n            flex-wrap: wrap;\n        }\n        .input-section, .visualization-section {\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        .input-section {\n            flex: 1;\n            min-width: 300px;\n        }\n        .visualization-section {\n            flex: 2;\n            min-width: 500px;\n        }\n        textarea {\n            width: 100%;\n            height: 150px;\n            margin: 10px 0;\n            padding: 10px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            font-family: monospace;\n        }\n        button {\n            background-color: #4CAF50;\n            color: white;\n            padding: 10px 20px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 16px;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        .graph-container {\n            position: relative;\n            height: 300px;\n            border: 1px solid #ddd;\n            margin: 20px 0;\n            background-color: #fafafa;\n        }\n        .node {\n            position: absolute;\n            width: 40px;\n            height: 40px;\n            border-radius: 50%;\n            background-color: #4CAF50;\n            color: white;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            cursor: pointer;\n        }\n        .edge {\n            position: absolute;\n            background-color: #333;\n            height: 2px;\n            transform-origin: 0 0;\n        }\n        .arrow {\n            position: absolute;\n            width: 0;\n            height: 0;\n            border-left: 6px solid transparent;\n            border-right: 6px solid transparent;\n            border-top: 10px solid #333;\n        }\n        .result {\n            margin-top: 20px;\n            padding: 15px;\n            background-color: #e8f5e8;\n            border-radius: 4px;\n            border-left: 4px solid #4CAF50;\n        }\n        .step {\n            margin: 5px 0;\n            padding: 5px;\n            background-color: #f0f0f0;\n        }\n        .current {\n            background-color: #fff3cd;\n        }\n        .explanation {\n            margin-top: 20px;\n            padding: 15px;\n            background-color: #e3f2fd;\n            border-radius: 4px;\n            border-left: 4px solid #2196F3;\n        }\n    </style>\n</head>\n<body>\n    <h1>Topological Sort Visualization</h1>\n    \n    <div class=\"container\">\n        <div class=\"input-section\">\n            <h2>Input Graph</h2>\n            <p>Enter dependencies in the format: A->B, B->C (one per line)</p>\n            <textarea id=\"graphInput\" placeholder=\"A->B\nB->C\nA->D\nD->C\">A->B\nB->C\nA->D\nD->C</textarea>\n            <button onclick=\"performTopologicalSort()\">Perform Topological Sort</button>\n            \n            <div class=\"explanation\">\n                <h3>What is Topological Sort?</h3>\n                <p>Topological sorting is a linear ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge u→v, vertex u comes before v in the ordering.</p>\n                <p><strong>Applications:</strong> Course scheduling, build systems, task scheduling, dependency resolution</p>\n                <p><strong>Algorithm (Kahn's):</strong></p>\n                <ol>\n                    <li>Calculate in-degree (number of incoming edges) for each node</li>\n                    <li>Add all nodes with in-degree 0 to a queue</li>\n                    <li>While queue is not empty:\n                        <ul>\n                            <li>Remove a node from the queue</li>\n                            <li>Add it to the topological order</li>\n                            <li>For each neighbor, decrease its in-degree by 1</li>\n                            <li>If neighbor's in-degree becomes 0, add it to the queue</li>\n                        </ul>\n                    </li>\n                </ol>\n            </div>\n        </div>\n        \n        <div class=\"visualization-section\">\n            <h2>Visualization</h2>\n            <div class=\"graph-container\" id=\"graphContainer\"></div>\n            \n            <h3>Topological Sort Result:</h3>\n            <div class=\"result\" id=\"result\"></div>\n            \n            <h3>Step-by-step Execution:</h3>\n            <div id=\"steps\"></div>\n        </div>\n    </div>\n\n    <script>\n        class Graph {\n            constructor() {\n                this.adjacencyList = new Map();\n                this.nodes = new Set();\n            }\n            \n            addEdge(from, to) {\n                if (!this.adjacencyList.has(from)) {\n                    this.adjacencyList.set(from, []);\n                }\n                this.adjacencyList.get(from).push(to);\n                this.nodes.add(from);\n                this.nodes.add(to);\n            }\n            \n            getInDegrees() {\n                const inDegree = new Map();\n                \n                // Initialize in-degree for all nodes to 0\n                for (const node of this.nodes) {\n                    inDegree.set(node, 0);\n                }\n                \n                // Calculate in-degree for each node\n                for (const [from, neighbors] of this.adjacencyList) {\n                    for (const to of neighbors) {\n                        inDegree.set(to, inDegree.get(to) + 1);\n                    }\n                }\n                \n                return inDegree;\n            }\n            \n            topologicalSort() {\n                const inDegree = this.getInDegrees();\n                const queue = [];\n                const result = [];\n                const steps = [];\n                \n                // Add all nodes with in-degree 0 to the queue\n                for (const node of this.nodes) {\n                    if (inDegree.get(node) === 0) {\n                        queue.push(node);\n                    }\n                }\n                \n                steps.push(`Initial nodes with in-degree 0: [${queue.join(', ')}]`);\n                \n                while (queue.length > 0) {\n                    const node = queue.shift();\n                    result.push(node);\n                    \n                    steps.push(`Processing node: ${node}`);\n                    \n                    if (this.adjacencyList.has(node)) {\n                        for (const neighbor of this.adjacencyList.get(node)) {\n                            inDegree.set(neighbor, inDegree.get(neighbor) - 1);\n                            steps.push(`Decreased in-degree of ${neighbor} to ${inDegree.get(neighbor)}`);\n                            \n                            if (inDegree.get(neighbor) === 0) {\n                                queue.push(neighbor);\n                                steps.push(`Added ${neighbor} to queue (in-degree became 0)`);\n                            }\n                        }\n                    }\n                    \n                    steps.push(`Current topological order: [${result.join(', ')}]`);\n                    steps.push(`Queue: [${queue.join(', ')}]`);\n                }\n                \n                // Check if graph has cycles\n                if (result.length !== this.nodes.size) {\n                    throw new Error('Graph has a cycle! Topological sort not possible.');\n                }\n                \n                return { result, steps };\n            }\n        }\n        \n        function parseGraph(input) {\n            const graph = new Graph();\n            const lines = input.split('\\n').filter(line => line.trim() !== '');\n            \n            for (const line of lines) {\n                const match = line.match(/(\\w+)\\s*->\\s*(\\w+)/);\n                if (match) {\n                    graph.addEdge(match[1], match[2]);\n                }\n            }\n            \n            return graph;\n        }\n        \n        function drawGraph(graph, container) {\n            container.innerHTML = '';\n            \n            const nodes = Array.from(graph.nodes);\n            const positions = {};\n            const radius = 150;\n            const centerX = container.offsetWidth / 2;\n            const centerY = container.offsetHeight / 2;\n            \n            // Position nodes in a circle\n            nodes.forEach((node, index) => {\n                const angle = (2 * Math.PI * index) / nodes.length;\n                const x = centerX + radius * Math.cos(angle);\n                const y = centerY + radius * Math.sin(angle);\n                \n                positions[node] = { x, y };\n                \n                const nodeElement = document.createElement('div');\n                nodeElement.className = 'node';\n                nodeElement.textContent = node;\n                nodeElement.style.left = (x - 20) + 'px';\n                nodeElement.style.top = (y - 20) + 'px';\n                container.appendChild(nodeElement);\n            });\n            \n            // Draw edges\n            for (const [from, neighbors] of graph.adjacencyList) {\n                for (const to of neighbors) {\n                    const fromPos = positions[from];\n                    const toPos = positions[to];\n                    \n                    // Calculate angle and distance\n                    const dx = toPos.x - fromPos.x;\n                    const dy = toPos.y - fromPos.y;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;\n                    \n                    // Draw edge line\n                    const edge = document.createElement('div');\n                    edge.className = 'edge';\n                    edge.style.width = (distance - 40) + 'px'; // Subtract node radii\n                    edge.style.left = (fromPos.x + 20) + 'px';\n                    edge.style.top = (fromPos.y + 20) + 'px';\n                    edge.style.transform = `rotate(${angle}deg)`;\n                    container.appendChild(edge);\n                    \n                    // Draw arrowhead\n                    const arrow = document.createElement('div');\n                    arrow.className = 'arrow';\n                    arrow.style.left = (toPos.x - 6) + 'px';\n                    arrow.style.top = (toPos.y - 5) + 'px';\n                    arrow.style.transform = `rotate(${angle}deg)`;\n                    container.appendChild(arrow);\n                }\n            }\n        }\n        \n        function performTopologicalSort() {\n            const input = document.getElementById('graphInput').value;\n            const resultDiv = document.getElementById('result');\n            const stepsDiv = document.getElementById('steps');\n            const graphContainer = document.getElementById('graphContainer');\n            \n            resultDiv.innerHTML = '';\n            stepsDiv.innerHTML = '';\n            \n            try {\n                const graph = parseGraph(input);\n                drawGraph(graph, graphContainer);\n                \n                const { result, steps } = graph.topologicalSort();\n                \n                resultDiv.innerHTML = `<strong>Topological Order:</strong> ${result.join(' → ')}`;\n                \n                steps.forEach((step, index) => {\n                    const stepElement = document.createElement('div');\n                    stepElement.className = 'step';\n                    stepElement.textContent = `Step ${index + 1}: ${step}`;\n                    stepsDiv.appendChild(stepElement);\n                });\n            } catch (error) {\n                resultDiv.innerHTML = `<strong>Error:</strong> ${error.message}`;\n                resultDiv.style.backgroundColor = '#ffe6e6';\n                resultDiv.style.borderLeftColor = '#ff4444';\n            }\n        }\n        \n        // Initialize with default example\n        window.onload = performTopologicalSort;\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": false,
  "hasTest": true
}