{
  "id": "dfd71813-d59e-11f0-ae0b-570552a0b645",
  "timestamp": "2025-12-10T08:08:10.549Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Binary Tree",
  "answer": {
    "role": "assistant",
    "content": "# Binary Tree Visualization with JavaScript\n\nHere's an interactive visualization of a binary tree that demonstrates insertion, traversal, and deletion operations:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Binary Tree Visualization</title>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f9ff;\n            color: #333;\n        }\n        h1 {\n            color: #2c3e50;\n            text-align: center;\n            margin-bottom: 10px;\n        }\n        .description {\n            text-align: center;\n            margin-bottom: 30px;\n            color: #666;\n        }\n        .container {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 30px;\n        }\n        .panel {\n            background: white;\n            border-radius: 10px;\n            padding: 20px;\n            box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n            margin-bottom: 20px;\n        }\n        .controls {\n            flex: 1;\n            min-width: 300px;\n        }\n        .tree-visual {\n            flex: 2;\n            min-width: 500px;\n            height: 600px;\n            border: 1px solid #e0e0e0;\n            overflow: auto;\n        }\n        .input-group {\n            margin-bottom: 15px;\n        }\n        button {\n            background-color: #3498db;\n            color: white;\n            border: none;\n            padding: 8px 15px;\n            border-radius: 5px;\n            cursor: pointer;\n            transition: background-color 0.2s;\n            margin-right: 10px;\n            margin-bottom: 10px;\n        }\n        button:hover {\n            background-color: #2980b9;\n        }\n        button:active {\n            transform: translateY(1px);\n        }\n        input[type=\"number\"] {\n            padding: 8px;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            width: 80px;\n        }\n        select {\n            padding: 8px;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            background: white;\n        }\n        .status {\n            margin-top: 15px;\n            padding: 10px;\n            border-radius: 5px;\n            background-color: #f8f9fa;\n        }\n        .highlight {\n            font-weight: bold;\n            color: #e74c3c;\n        }\n        .node {\n            position: absolute;\n            width: 40px;\n            height: 40px;\n            background: #3498db;\n            color: white;\n            border-radius: 50%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            cursor: pointer;\n            transition: all 0.3s;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.2);\n            z-index: 10;\n        }\n        .node.highlighted {\n            background: #e74c3c;\n            transform: scale(1.2);\n            z-index: 20;\n        }\n        .node.deleted {\n            opacity: 0.5;\n            background: #95a5a6;\n        }\n        .line {\n            position: absolute;\n            height: 2px;\n            background: #34495e;\n            transform-origin: 0 0;\n            z-index: 5;\n        }\n        .operation-log {\n            margin-top: 20px;\n            max-height: 200px;\n            overflow-y: auto;\n            border: 1px solid #eee;\n            padding: 10px;\n            border-radius: 5px;\n            background: #f9f9f9;\n        }\n        .operation-item {\n            margin-bottom: 5px;\n            padding: 5px;\n            border-bottom: 1px solid #eee;\n        }\n        .tree-info {\n            margin-top: 20px;\n            font-size: 0.9em;\n            color: #777;\n        }\n        .algorithm-explanation {\n            margin-top: 30px;\n            padding: 20px;\n            background: #f8f9fa;\n            border-radius: 10px;\n        }\n        .explanation-text {\n            line-height: 1.6;\n        }\n    </style>\n</head>\n<body>\n    <h1>Binary Tree Visualization</h1>\n    <div class=\"description\">\n        A binary tree is a hierarchical data structure where each node has at most two children: left and right.\n    </div>\n    \n    <div class=\"container\">\n        <div class=\"panel controls\">\n            <h2>Controls</h2>\n            \n            <div class=\"input-group\">\n                <label>Node Value:</label>\n                <input type=\"number\" id=\"nodeValue\" min=\"1\" max=\"100\" value=\"15\">\n                <button id=\"insertBtn\">Insert Node</button>\n            </div>\n            \n            <div class=\"input-group\">\n                <label>Delete Node:</label>\n                <input type=\"number\" id=\"deleteValue\" min=\"1\" max=\"100\" value=\"15\">\n                <button id=\"deleteBtn\">Delete Node</button>\n            </div>\n            \n            <div class=\"input-group\">\n                <label>Traversal Type:</label>\n                <select id=\"traversalType\">\n                    <option value=\"inorder\">In-Order (Left, Root, Right)</option>\n                    <option value=\"preorder\">Pre-Order (Root, Left, Right)</option>\n                    <option value=\"postorder\">Post-Order (Left, Right, Root)</option>\n                    <option value=\"levelorder\">Level-Order (Breadth-First)</option>\n                </select>\n                <button id=\"traverseBtn\">Traverse Tree</button>\n            </div>\n            \n            <div class=\"input-group\">\n                <button id=\"clearBtn\">Clear Tree</button>\n                <button id=\"randomBtn\">Generate Random Tree</button>\n            </div>\n            \n            <div class=\"status\" id=\"status\">\n                Status: Ready\n            </div>\n            \n            <div class=\"operation-log\" id=\"operationLog\">\n                <h3>Operation Log</h3>\n            </div>\n            \n            <div class=\"tree-info\">\n                <strong>Tree Information:</strong>\n                <div id=\"treeInfo\">No tree generated yet.</div>\n            </div>\n        </div>\n        \n        <div class=\"panel tree-visual\" id=\"treeContainer\">\n            <h2>Binary Tree Visualization</h2>\n            <div id=\"treeCanvas\"></div>\n        </div>\n    </div>\n    \n    <div class=\"panel algorithm-explanation\">\n        <h2>Binary Tree Properties & Algorithms</h2>\n        <div class=\"explanation-text\">\n            <p><strong>Properties of Binary Trees:</strong></p>\n            <ul>\n                <li>Each node has at most two children (left and right)</li>\n                <li>The topmost node is called the root</li>\n                <li>Nodes with no children are called leaves</li>\n                <li>The depth of a node is the number of edges from the root to that node</li>\n                <li>The height of a tree is the maximum depth of any node</li>\n            </ul>\n            \n            <p><strong>Traversal Algorithms:</strong></p>\n            <ul>\n                <li><strong>In-Order:</strong> Visit left subtree, then root, then right subtree. Produces sorted order in Binary Search Trees.</li>\n                <li><strong>Pre-Order:</strong> Visit root, then left subtree, then right subtree. Useful for creating a copy of the tree.</li>\n                <li><strong>Post-Order:</strong> Visit left subtree, then right subtree, then root. Useful for deleting the tree.</li>\n                <li><strong>Level-Order:</strong> Visit nodes level by level from top to bottom. Uses a queue data structure.</li>\n            </ul>\n        </div>\n    </div>\n\n    <script>\n        // Binary Tree Node class\n        class TreeNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n                this.id = TreeNode.nextId++;\n            }\n            \n            // Static property to generate unique IDs for nodes\n            static nextId = 1;\n        }\n\n        // Binary Tree class\n        class BinaryTree {\n            constructor() {\n                this.root = null;\n                this.nodeCount = 0;\n                this.height = 0;\n            }\n            \n            // Insert a new node with the given value\n            insert(value) {\n                const newNode = new TreeNode(value);\n                \n                if (!this.root) {\n                    this.root = newNode;\n                    this.nodeCount = 1;\n                    this.height = 1;\n                    return this.root;\n                }\n                \n                let current = this.root;\n                let depth = 1;\n                \n                while (current) {\n                    if (value < current.value) {\n                        if (!current.left) {\n                            current.left = newNode;\n                            depth++;\n                            break;\n                        } else {\n                            current = current.left;\n                            depth++;\n                        }\n                    } else {\n                        if (!current.right) {\n                            current.right = newNode;\n                            depth++;\n                            break;\n                        } else {\n                            current = current.right;\n                            depth++;\n                        }\n                    }\n                }\n                \n                this.nodeCount++;\n                this.height = Math.max(this.height, depth);\n                \n                return newNode;\n            }\n            \n            // Find a node with the given value\n            find(value) {\n                let current = this.root;\n                \n                while (current) {\n                    if (value === current.value) {\n                        return current;\n                    } else if (value < current.value) {\n                        current = current.left;\n                    } else {\n                        current = current.right;\n                    }\n                }\n                \n                return null;\n            }\n            \n            // Delete a node with the given value\n            delete(value) {\n                if (!this.root) return null;\n                \n                let parent = null;\n                let current = this.root;\n                let isLeftChild = false;\n                \n                // Find the node to delete and its parent\n                while (current && current.value !== value) {\n                    parent = current;\n                    \n                    if (value < current.value) {\n                        current = current.left;\n                        isLeftChild = true;\n                    } else {\n                        current = current.right;\n                        isLeftChild = false;\n                    }\n                }\n                \n                if (!current) return null; // Node not found\n                \n                // Case 1: Node to delete has no children\n                if (!current.left && !current.right) {\n                    if (current === this.root) {\n                        this.root = null;\n                    } else if (isLeftChild) {\n                        parent.left = null;\n                    } else {\n                        parent.right = null;\n                    }\n                }\n                // Case 2: Node to delete has one child\n                else if (!current.left || !current.right) {\n                    const child = current.left || current.right;\n                    \n                    if (current === this.root) {\n                        this.root = child;\n                    } else if (isLeftChild) {\n                        parent.left = child;\n                    } else {\n                        parent.right = child;\n                    }\n                }\n                // Case 3: Node to delete has two children\n                else {\n                    // Find the minimum value in the right subtree (successor)\n                    let successorParent = current;\n                    let successor = current.right;\n                    \n                    while (successor.left) {\n                        successorParent = successor;\n                        successor = successor.left;\n                    }\n                    \n                    // Replace current value with successor value\n                    current.value = successor.value;\n                    \n                    // Delete the successor node\n                    if (successorParent === current) {\n                        successorParent.right = successor.right;\n                    } else {\n                        successorParent.left = successor.right;\n                    }\n                    \n                    current = successor; // Mark the successor for deletion\n                }\n                \n                this.nodeCount--;\n                this.height = this.calculateHeight(this.root);\n                \n                return current;\n            }\n            \n            // Calculate the height of the tree\n            calculateHeight(node) {\n                if (!node) return 0;\n                \n                const leftHeight = this.calculateHeight(node.left);\n                const rightHeight = this.calculateHeight(node.right);\n                \n                return Math.max(leftHeight, rightHeight) + 1;\n            }\n            \n            // Traversal methods\n            inOrder(node = this.root, result = []) {\n                if (node) {\n                    this.inOrder(node.left, result);\n                    result.push(node);\n                    this.inOrder(node.right, result);\n                }\n                return result;\n            }\n            \n            preOrder(node = this.root, result = []) {\n                if (node) {\n                    result.push(node);\n                    this.preOrder(node.left, result);\n                    this.preOrder(node.right, result);\n                }\n                return result;\n            }\n            \n            postOrder(node = this.root, result = []) {\n                if (node) {\n                    this.postOrder(node.left, result);\n                    this.postOrder(node.right, result);\n                    result.push(node);\n                }\n                return result;\n            }\n            \n            levelOrder() {\n                if (!this.root) return [];\n                \n                const result = [];\n                const queue = [this.root];\n                \n                while (queue.length > 0) {\n                    const node = queue.shift();\n                    result.push(node);\n                    \n                    if (node.left) queue.push(node.left);\n                    if (node.right) queue.push(node.right);\n                }\n                \n                return result;\n            }\n            \n            // Clear the tree\n            clear() {\n                this.root = null;\n                this.nodeCount = 0;\n                this.height = 0;\n            }\n            \n            // Generate a random tree\n            generateRandom(count = 10) {\n                this.clear();\n                \n                for (let i = 0; i < count; i++) {\n                    const value = Math.floor(Math.random() * 100) + 1;\n                    this.insert(value);\n                }\n                \n                return this.root;\n            }\n            \n            // Get tree statistics\n            getInfo() {\n                return {\n                    nodeCount: this.nodeCount,\n                    height: this.height,\n                    isComplete: this.isComplete(),\n                    isBalanced: this.isBalanced()\n                };\n            }\n            \n            // Check if the tree is complete\n            isComplete() {\n                if (!this.root) return true;\n                \n                const queue = [this.root];\n                let foundNull = false;\n                \n                while (queue.length > 0) {\n                    const node = queue.shift();\n                    \n                    if (!node) {\n                        foundNull = true;\n                    } else {\n                        if (foundNull) return false;\n                        queue.push(node.left);\n                        queue.push(node.right);\n                    }\n                }\n                \n                return true;\n            }\n            \n            // Check if the tree is balanced\n            isBalanced(node = this.root) {\n                if (!node) return true;\n                \n                const leftHeight = this.calculateHeight(node.left);\n                const rightHeight = this.calculateHeight(node.right);\n                \n                return Math.abs(leftHeight - rightHeight) <= 1 && \n                       this.isBalanced(node.left) && \n                       this.isBalanced(node.right);\n            }\n        }\n\n        // Visualization class\n        class TreeVisualizer {\n            constructor(containerId) {\n                this.container = document.getElementById(containerId);\n                this.canvas = document.getElementById('treeCanvas');\n                this.tree = new BinaryTree();\n                this.highlightedNode = null;\n                this.traversalInterval = null;\n                this.nodePositions = new Map();\n                this.logOperations = [];\n                this.zoom = 1;\n                \n                this.init();\n            }\n            \n            init() {\n                this.setupEventListeners();\n                this.updateTreeInfo();\n            }\n            \n            setupEventListeners() {\n                document.getElementById('insertBtn').addEventListener('click', () => {\n                    const value = parseInt(document.getElementById('nodeValue').value);\n                    if (value && value >= 1 && value <= 100) {\n                        this.insertNode(value);\n                    } else {\n                        this.updateStatus('Please enter a valid value between 1 and 100');\n                    }\n                });\n                \n                document.getElementById('deleteBtn').addEventListener('click', () => {\n                    const value = parseInt(document.getElementById('deleteValue').value);\n                    if (value && value >= 1 && value <= 100) {\n                        this.deleteNode(value);\n                    } else {\n                        this.updateStatus('Please enter a valid value between 1 and 100');\n                    }\n                });\n                \n                document.getElementById('traverseBtn').addEventListener('click', () => {\n                    const type = document.getElementById('traversalType').value;\n                    this.traverseTree(type);\n                });\n                \n                document.getElementById('clearBtn').addEventListener('click', () => {\n                    this.clearTree();\n                });\n                \n                document.getElementById('randomBtn').addEventListener('click', () => {\n                    this.generateRandomTree();\n                });\n                \n                // Allow Enter key to insert nodes\n                document.getElementById('nodeValue').addEventListener('keypress', (e) => {\n                    if (e.key === 'Enter') {\n                        document.getElementById('insertBtn').click();\n                    }\n                });\n            }\n            \n            insertNode(value) {\n                if (this.tree.find(value)) {\n                    this.updateStatus(`Node with value ${value} already exists`);\n                    return;\n                }\n                \n                const node = this.tree.insert(value);\n                this.logOperation(`Inserted node with value ${value}`);\n                this.updateStatus(`Inserted node with value ${value}`);\n                this.drawTree();\n                this.highlightNode(node, 1500);\n            }\n            \n            deleteNode(value) {\n                const node = this.tree.find(value);\n                if (!node) {\n                    this.updateStatus(`Node with value ${value} not found`);\n                    return;\n                }\n                \n                const deletedNode = this.tree.delete(value);\n                this.logOperation(`Deleted node with value ${value}`);\n                this.updateStatus(`Deleted node with value ${value}`);\n                this.drawTree();\n                \n                // Show a temporary message about the deleted node\n                setTimeout(() => {\n                    this.updateStatus(`Node with value ${value} has been deleted`);\n                }, 500);\n            }\n            \n            traverseTree(type) {\n                if (!this.tree.root) {\n                    this.updateStatus('Tree is empty');\n                    return;\n                }\n                \n                let nodes;\n                let description;\n                \n                switch (type) {\n                    case 'inorder':\n                        nodes = this.tree.inOrder();\n                        description = 'In-order traversal (Left, Root, Right)';\n                        break;\n                    case 'preorder':\n                        nodes = this.tree.preOrder();\n                        description = 'Pre-order traversal (Root, Left, Right)';\n                        break;\n                    case 'postorder':\n                        nodes = this.tree.postOrder();\n                        description = 'Post-order traversal (Left, Right, Root)';\n                       "
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Tree"
    }
  ],
  "topic": "Binary Tree",
  "hasFSM": false,
  "hasTest": true
}