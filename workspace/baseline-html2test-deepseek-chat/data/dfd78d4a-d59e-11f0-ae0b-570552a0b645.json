{
  "id": "dfd78d4a-d59e-11f0-ae0b-570552a0b645",
  "timestamp": "2025-12-10T08:08:44.913Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "K-Nearest Neighbors (KNN)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>K-Nearest Neighbors (KNN) Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            display: flex;\n            flex-direction: column;\n            gap: 20px;\n        }\n        .header {\n            text-align: center;\n            background: white;\n            padding: 20px;\n            border-radius: 10px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        .content {\n            display: flex;\n            gap: 20px;\n        }\n        .controls {\n            flex: 1;\n            background: white;\n            padding: 20px;\n            border-radius: 10px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        .visualization {\n            flex: 2;\n            background: white;\n            padding: 20px;\n            border-radius: 10px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        canvas {\n            border: 1px solid #ddd;\n            background-color: #fafafa;\n            cursor: crosshair;\n        }\n        .form-group {\n            margin-bottom: 15px;\n        }\n        label {\n            display: block;\n            margin-bottom: 5px;\n            font-weight: bold;\n        }\n        input[type=\"range\"] {\n            width: 100%;\n        }\n        button {\n            background-color: #4CAF50;\n            color: white;\n            padding: 10px 15px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            margin-right: 10px;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        .value-display {\n            display: inline-block;\n            margin-left: 10px;\n            font-weight: bold;\n        }\n        .explanation {\n            background: white;\n            padding: 20px;\n            border-radius: 10px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n            line-height: 1.6;\n        }\n        .class-legends {\n            display: flex;\n            gap: 10px;\n            margin-top: 10px;\n        }\n        .legend-item {\n            display: flex;\n            align-items: center;\n            gap: 5px;\n        }\n        .legend-color {\n            width: 15px;\n            height: 15px;\n            border-radius: 50%;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>K-Nearest Neighbors (KNN) Algorithm Visualization</h1>\n            <p>Click on the canvas to add data points. Set the K value and test point to see how KNN classifies new data.</p>\n        </div>\n        \n        <div class=\"content\">\n            <div class=\"controls\">\n                <div class=\"form-group\">\n                    <label for=\"kValue\">K Value (Number of Neighbors): <span id=\"kValueDisplay\">3</span></label>\n                    <input type=\"range\" id=\"kValue\" min=\"1\" max=\"15\" value=\"3\">\n                </div>\n                \n                <div class=\"form-group\">\n                    <label for=\"testX\">Test Point X Coordinate: <span id=\"testXDisplay\">250</span></label>\n                    <input type=\"range\" id=\"testX\" min=\"0\" max=\"500\" value=\"250\">\n                </div>\n                \n                <div class=\"form-group\">\n                    <label for=\"testY\">Test Point Y Coordinate: <span id=\"testYDisplay\">250</span></label>\n                    <input type=\"range\" id=\"testY\" min=\"0\" max=\"500\" value=\"250\">\n                </div>\n                \n                <div class=\"form-group\">\n                    <label>Current Class:</label>\n                    <button id=\"classA\">Class A (Red)</button>\n                    <button id=\"classB\">Class B (Blue)</button>\n                    <button id=\"clear\">Clear Points</button>\n                </div>\n                \n                <div class=\"form-group\">\n                    <button id=\"classify\">Classify Test Point</button>\n                    <button id=\"autoClassify\">Auto Classify Entire Space</button>\n                </div>\n                \n                <div class=\"class-legends\">\n                    <div class=\"legend-item\">\n                        <div class=\"legend-color\" style=\"background-color: #ff4444;\"></div>\n                        <span>Class A</span>\n                    </div>\n                    <div class=\"legend-item\">\n                        <div class=\"legend-color\" style=\"background-color: #4444ff;\"></div>\n                        <span>Class B</span>\n                    </div>\n                    <div class=\"legend-item\">\n                        <div class=\"legend-color\" style=\"background-color: #44ff44;\"></div>\n                        <span>Test Point</span>\n                    </div>\n                </div>\n                \n                <div id=\"result\" style=\"margin-top: 20px; font-weight: bold; min-height: 40px;\"></div>\n            </div>\n            \n            <div class=\"visualization\">\n                <canvas id=\"knnCanvas\" width=\"500\" height=\"500\"></canvas>\n            </div>\n        </div>\n        \n        <div class=\"explanation\">\n            <h2>How K-Nearest Neighbors Works</h2>\n            <p>The K-Nearest Neighbors (KNN) algorithm is a simple, instance-based learning algorithm used for classification and regression.</p>\n            \n            <h3>Key Concepts:</h3>\n            <ul>\n                <li><strong>K Value:</strong> The number of nearest neighbors to consider when classifying a new data point.</li>\n                <li><strong>Distance Metric:</strong> KNN typically uses Euclidean distance to find the closest neighbors.</li>\n                <li><strong>Majority Voting:</strong> The class with the most representatives among the K nearest neighbors determines the classification.</li>\n            </ul>\n            \n            <h3>Steps in KNN:</h3>\n            <ol>\n                <li>Store all training data points with their known classifications.</li>\n                <li>When a new data point needs classification, calculate its distance to all stored points.</li>\n                <li>Select the K points with the smallest distances to the new point.</li>\n                <li>Determine the majority class among these K neighbors.</li>\n                <li>Assign the majority class to the new data point.</li>\n            </ol>\n            \n            <p>Try different K values to see how it affects the classification boundaries. Smaller K values create more complex boundaries, while larger K values create smoother boundaries.</p>\n        </div>\n    </div>\n\n    <script>\n        // Canvas and context\n        const canvas = document.getElementById('knnCanvas');\n        const ctx = canvas.getContext('2d');\n        \n        // Data structures\n        let points = {\n            classA: [],\n            classB: []\n        };\n        let currentClass = 'classA';\n        let testPoint = { x: 250, y: 250 };\n        \n        // UI elements\n        const kValueSlider = document.getElementById('kValue');\n        const kValueDisplay = document.getElementById('kValueDisplay');\n        const testXSlider = document.getElementById('testX');\n        const testXDisplay = document.getElementById('testXDisplay');\n        const testYSlider = document.getElementById('testY');\n        const testYDisplay = document.getElementById('testYDisplay');\n        const classAButton = document.getElementById('classA');\n        const classBButton = document.getElementById('classB');\n        const clearButton = document.getElementById('clear');\n        const classifyButton = document.getElementById('classify');\n        const autoClassifyButton = document.getElementById('autoClassify');\n        const resultDiv = document.getElementById('result');\n        \n        // Initialize\n        function init() {\n            // Set up event listeners\n            canvas.addEventListener('click', handleCanvasClick);\n            kValueSlider.addEventListener('input', updateKValue);\n            testXSlider.addEventListener('input', updateTestPoint);\n            testYSlider.addEventListener('input', updateTestPoint);\n            classAButton.addEventListener('click', () => setCurrentClass('classA'));\n            classBButton.addEventListener('click', () => setCurrentClass('classB'));\n            clearButton.addEventListener('click', clearPoints);\n            classifyButton.addEventListener('click', classifyTestPoint);\n            autoClassifyButton.addEventListener('click', autoClassifySpace);\n            \n            // Initialize displays\n            updateKValue();\n            updateTestPoint();\n            \n            // Draw initial state\n            drawCanvas();\n        }\n        \n        // Handle canvas clicks to add points\n        function handleCanvasClick(event) {\n            const rect = canvas.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            \n            points[currentClass].push({ x, y });\n            drawCanvas();\n        }\n        \n        // Update K value display\n        function updateKValue() {\n            const k = parseInt(kValueSlider.value);\n            kValueDisplay.textContent = k;\n            drawCanvas();\n        }\n        \n        // Update test point position\n        function updateTestPoint() {\n            testPoint.x = parseInt(testXSlider.value);\n            testPoint.y = parseInt(testYSlider.value);\n            testXDisplay.textContent = testPoint.x;\n            testYDisplay.textContent = testPoint.y;\n            drawCanvas();\n        }\n        \n        // Set current class for new points\n        function setCurrentClass(className) {\n            currentClass = className;\n            classAButton.style.backgroundColor = (className === 'classA') ? '#45a049' : '#4CAF50';\n            classBButton.style.backgroundColor = (className === 'classB') ? '#45a049' : '#4CAF50';\n        }\n        \n        // Clear all points\n        function clearPoints() {\n            points.classA = [];\n            points.classB = [];\n            resultDiv.textContent = '';\n            drawCanvas();\n        }\n        \n        // Calculate Euclidean distance between two points\n        function calculateDistance(point1, point2) {\n            const dx = point1.x - point2.x;\n            const dy = point1.y - point2.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n        \n        // Classify the test point using KNN\n        function classifyTestPoint() {\n            const k = parseInt(kValueSlider.value);\n            \n            if (points.classA.length + points.classB.length < k) {\n                resultDiv.textContent = `Need at least ${k} points to classify with K=${k}`;\n                return;\n            }\n            \n            // Calculate distances to all points\n            const distances = [];\n            \n            points.classA.forEach(point => {\n                distances.push({\n                    point,\n                    distance: calculateDistance(testPoint, point),\n                    class: 'classA'\n                });\n            });\n            \n            points.classB.forEach(point => {\n                distances.push({\n                    point,\n                    distance: calculateDistance(testPoint, point),\n                    class: 'classB'\n                });\n            });\n            \n            // Sort by distance and get K nearest neighbors\n            distances.sort((a, b) => a.distance - b.distance);\n            const nearestNeighbors = distances.slice(0, k);\n            \n            // Count votes for each class\n            const votes = { classA: 0, classB: 0 };\n            nearestNeighbors.forEach(neighbor => {\n                votes[neighbor.class]++;\n            });\n            \n            // Determine the predicted class\n            let predictedClass;\n            if (votes.classA > votes.classB) {\n                predictedClass = 'Class A';\n            } else if (votes.classB > votes.classA) {\n                predictedClass = 'Class B';\n            } else {\n                predictedClass = 'Tie (random choice)';\n            }\n            \n            // Display results\n            resultDiv.innerHTML = `\n                <p>Predicted Class: <strong>${predictedClass}</strong></p>\n                <p>Votes: Class A = ${votes.classA}, Class B = ${votes.classB}</p>\n            `;\n            \n            // Redraw canvas to show neighbors\n            drawCanvas(nearestNeighbors);\n        }\n        \n        // Auto-classify the entire space (creates a decision boundary)\n        function autoClassifySpace() {\n            const k = parseInt(kValueSlider.value);\n            \n            if (points.classA.length + points.classB.length < k) {\n                resultDiv.textContent = `Need at least ${k} points to classify with K=${k}`;\n                return;\n            }\n            \n            // Create a grid and classify each point\n            const cellSize = 10;\n            const width = canvas.width;\n            const height = canvas.height;\n            \n            // Draw the background with classification colors\n            for (let x = 0; x < width; x += cellSize) {\n                for (let y = 0; y < height; y += cellSize) {\n                    const gridPoint = { x: x + cellSize/2, y: y + cellSize/2 };\n                    \n                    // Calculate distances to all points\n                    const distances = [];\n                    \n                    points.classA.forEach(point => {\n                        distances.push({\n                            point,\n                            distance: calculateDistance(gridPoint, point),\n                            class: 'classA'\n                        });\n                    });\n                    \n                    points.classB.forEach(point => {\n                        distances.push({\n                            point,\n                            distance: calculateDistance(gridPoint, point),\n                            class: 'classB'\n                        });\n                    });\n                    \n                    // Sort by distance and get K nearest neighbors\n                    distances.sort((a, b) => a.distance - b.distance);\n                    const nearestNeighbors = distances.slice(0, k);\n                    \n                    // Count votes for each class\n                    const votes = { classA: 0, classB: 0 };\n                    nearestNeighbors.forEach(neighbor => {\n                        votes[neighbor.class]++;\n                    });\n                    \n                    // Determine the color based on majority vote\n                    let color;\n                    if (votes.classA > votes.classB) {\n                        color = 'rgba(255, 100, 100, 0.2)'; // Light red for class A\n                    } else {\n                        color = 'rgba(100, 100, 255, 0.2)'; // Light blue for class B\n                    }\n                    \n                    // Draw the cell\n                    ctx.fillStyle = color;\n                    ctx.fillRect(x, y, cellSize, cellSize);\n                }\n            }\n            \n            // Redraw points on top\n            drawPoints();\n            drawTestPoint();\n        }\n        \n        // Draw the canvas with all points and test point\n        function drawCanvas(neighbors = []) {\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Draw points\n            drawPoints();\n            \n            // Highlight neighbors if provided\n            if (neighbors.length > 0) {\n                ctx.strokeStyle = '#ffff00';\n                ctx.lineWidth = 2;\n                \n                neighbors.forEach(neighbor => {\n                    ctx.beginPath();\n                    ctx.arc(neighbor.point.x, neighbor.point.y, 8, 0, Math.PI * 2);\n                    ctx.stroke();\n                    \n                    // Draw line to test point\n                    ctx.beginPath();\n                    ctx.moveTo(testPoint.x, testPoint.y);\n                    ctx.lineTo(neighbor.point.x, neighbor.point.y);\n                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';\n                    ctx.stroke();\n                });\n            }\n            \n            // Draw test point\n            drawTestPoint();\n        }\n        \n        // Draw all data points\n        function drawPoints() {\n            // Draw class A points (red)\n            ctx.fillStyle = '#ff4444';\n            points.classA.forEach(point => {\n                ctx.beginPath();\n                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\n                ctx.fill();\n            });\n            \n            // Draw class B points (blue)\n            ctx.fillStyle = '#4444ff';\n            points.classB.forEach(point => {\n                ctx.beginPath();\n                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\n                ctx.fill();\n            });\n        }\n        \n        // Draw the test point\n        function drawTestPoint() {\n            ctx.fillStyle = '#44ff44';\n            ctx.beginPath();\n            ctx.arc(testPoint.x, testPoint.y, 8, 0, Math.PI * 2);\n            ctx.fill();\n            \n            // Add a black border to make it more visible\n            ctx.strokeStyle = '#000000';\n            ctx.lineWidth = 1;\n            ctx.stroke();\n        }\n        \n        // Initialize the application\n        init();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Nearest Neighbors (KNN)"
    }
  ],
  "topic": "K-Nearest Neighbors (KNN)",
  "hasFSM": false,
  "hasTest": true
}