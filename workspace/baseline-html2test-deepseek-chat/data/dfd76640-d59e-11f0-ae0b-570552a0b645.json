{
  "id": "dfd76640-d59e-11f0-ae0b-570552a0b645",
  "timestamp": "2025-12-10T08:07:53.662Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Kruskal's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        \n        .container {\n            display: flex;\n            gap: 20px;\n            margin-top: 20px;\n        }\n        \n        .graph-section {\n            flex: 1;\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        \n        .controls-section {\n            flex: 1;\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        \n        canvas {\n            border: 1px solid #ddd;\n            background-color: #fafafa;\n        }\n        \n        button {\n            padding: 8px 16px;\n            margin: 5px;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n        \n        button:hover {\n            background-color: #45a049;\n        }\n        \n        button:disabled {\n            background-color: #cccccc;\n            cursor: not-allowed;\n        }\n        \n        .step-info {\n            margin-top: 15px;\n            padding: 10px;\n            background-color: #f0f0f0;\n            border-radius: 4px;\n            min-height: 100px;\n        }\n        \n        .edge-list {\n            margin-top: 15px;\n            max-height: 200px;\n            overflow-y: auto;\n        }\n        \n        .mst-edge {\n            color: #4CAF50;\n            font-weight: bold;\n        }\n        \n        .current-edge {\n            background-color: #fffacd;\n        }\n        \n        .node {\n            position: absolute;\n            width: 30px;\n            height: 30px;\n            background-color: #4CAF50;\n            border-radius: 50%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            color: white;\n            font-weight: bold;\n        }\n    </style>\n</head>\n<body>\n    <h1>Kruskal's Algorithm Visualization</h1>\n    \n    <div class=\"container\">\n        <div class=\"graph-section\">\n            <h3>Graph Visualization</h3>\n            <canvas id=\"graphCanvas\" width=\"500\" height=\"400\"></canvas>\n        </div>\n        \n        <div class=\"controls-section\">\n            <h3>Algorithm Controls</h3>\n            <div>\n                <button id=\"resetBtn\">Reset Graph</button>\n                <button id=\"stepBtn\">Next Step</button>\n                <button id=\"runBtn\">Run All Steps</button>\n            </div>\n            \n            <div class=\"step-info\">\n                <h4>Current Step:</h4>\n                <div id=\"stepDescription\">Click \"Next Step\" to start execution</div>\n            </div>\n            \n            <div class=\"edge-list\">\n                <h4>Edges (sorted by weight):</h4>\n                <ul id=\"edgesList\"></ul>\n            </div>\n            \n            <div>\n                <h4>Minimum Spanning Tree Weight: <span id=\"mstWeight\">0</span></h4>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        class KruskalAlgorithm {\n            constructor() {\n                this.nodes = [];\n                this.edges = [];\n                this.mst = [];\n                this.currentStep = 0;\n                this.sortedEdges = [];\n                this.parent = [];\n                this.rank = [];\n                this.isRunning = false;\n                \n                this.initializeDefaultGraph();\n            }\n            \n            initializeDefaultGraph() {\n                // Create a default graph for demonstration\n                this.nodes = [\n                    {id: 0, x: 100, y: 100},\n                    {id: 1, x: 300, y: 100},\n                    {id: 2, x: 200, y: 200},\n                    {id: 3, x: 100, y: 300},\n                    {id: 4, x: 300, y: 300}\n                ];\n                \n                this.edges = [\n                    {from: 0, to: 1, weight: 10},\n                    {from: 0, to: 2, weight: 6},\n                    {from: 0, to: 3, weight: 5},\n                    {from: 1, to: 2, weight: 15},\n                    {from: 1, to: 4, weight: 8},\n                    {from: 2, to: 3, weight: 4},\n                    {from: 2, to: 4, weight: 12},\n                    {from: 3, to: 4, weight: 7}\n                ];\n                \n                this.initializeUnionFind();\n                this.sortEdges();\n                this.updateEdgesList();\n            }\n            \n            initializeUnionFind() {\n                this.parent = [];\n                this.rank = [];\n                \n                for (let i = 0; i < this.nodes.length; i++) {\n                    this.parent[i] = i;\n                    this.rank[i] = 0;\n                }\n            }\n            \n            sortEdges() {\n                this.sortedEdges = [...this.edges];\n                this.sortedEdges.sort((a, b) => a.weight - b.weight);\n            }\n            \n            find(node) {\n                if (this.parent[node] !== node) {\n                    this.parent[node] = this.find(this.parent[node]);\n                }\n                return this.parent[node];\n            }\n            \n            union(node1, node2) {\n                let root1 = this.find(node1);\n                let root2 = this.find(node2);\n                \n                if (root1 !== root2) {\n                    if (this.rank[root1] > this.rank[root2]) {\n                        this.parent[root2] = root1;\n                    } else if (this.rank[root1] < this.rank[root2]) {\n                        this.parent[root1] = root2;\n                    } else {\n                        this.parent[root2] = root1;\n                        this.rank[root1]++;\n                    }\n                    return true;\n                }\n                return false;\n            }\n            \n            nextStep() {\n                if (this.currentStep >= this.sortedEdges.length) {\n                    return false;\n                }\n                \n                const currentEdge = this.sortedEdges[this.currentStep];\n                const fromRoot = this.find(currentEdge.from);\n                const toRoot = this.find(currentEdge.to);\n                \n                let description = `Considering edge ${currentEdge.from}-${currentEdge.to} (weight: ${currentEdge.weight})<br>`;\n                \n                if (fromRoot !== toRoot) {\n                    this.union(currentEdge.from, currentEdge.to);\n                    this.mst.push(currentEdge);\n                    description += `✓ Added to MST (no cycle created)<br>`;\n                    description += `Union-Find: Parent array: [${this.parent}]`;\n                } else {\n                    description += `✗ Skipped (would create cycle)<br>`;\n                    description += `Both nodes are in the same set (root: ${fromRoot})`;\n                }\n                \n                document.getElementById('stepDescription').innerHTML = description;\n                this.currentStep++;\n                \n                this.updateEdgesList();\n                this.calculateMSTWeight();\n                return true;\n            }\n            \n            runAllSteps() {\n                if (this.isRunning) return;\n                \n                this.isRunning = true;\n                document.getElementById('runBtn').disabled = true;\n                \n                const runStep = () => {\n                    if (!this.nextStep()) {\n                        this.isRunning = false;\n                        document.getElementById('runBtn').disabled = false;\n                        return;\n                    }\n                    \n                    setTimeout(runStep, 1000);\n                };\n                \n                runStep();\n            }\n            \n            reset() {\n                this.mst = [];\n                this.currentStep = 0;\n                this.initializeUnionFind();\n                document.getElementById('stepDescription').innerHTML = 'Algorithm reset. Click \"Next Step\" to start.';\n                this.updateEdgesList();\n                this.calculateMSTWeight();\n            }\n            \n            updateEdgesList() {\n                const edgesList = document.getElementById('edgesList');\n                edgesList.innerHTML = '';\n                \n                this.sortedEdges.forEach((edge, index) => {\n                    const li = document.createElement('li');\n                    li.innerHTML = `Edge ${edge.from}-${edge.to}: weight ${edge.weight}`;\n                    \n                    if (index < this.currentStep) {\n                        if (this.mst.includes(edge)) {\n                            li.className = 'mst-edge';\n                            li.innerHTML += ' ✓ (In MST)';\n                        } else {\n                            li.innerHTML += ' ✗ (Skipped)';\n                        }\n                    }\n                    \n                    if (index === this.currentStep && index < this.sortedEdges.length) {\n                        li.className = 'current-edge';\n                    }\n                    \n                    edgesList.appendChild(li);\n                });\n            }\n            \n            calculateMSTWeight() {\n                const weight = this.mst.reduce((sum, edge) => sum + edge.weight, 0);\n                document.getElementById('mstWeight').textContent = weight;\n            }\n            \n            drawGraph(canvas) {\n                const ctx = canvas.getContext('2d');\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                \n                // Draw edges\n                this.edges.forEach(edge => {\n                    const fromNode = this.nodes[edge.from];\n                    const toNode = this.nodes[edge.to];\n                    \n                    ctx.beginPath();\n                    ctx.moveTo(fromNode.x, fromNode.y);\n                    ctx.lineTo(toNode.x, toNode.y);\n                    \n                    // Color MST edges differently\n                    if (this.mst.includes(edge)) {\n                        ctx.strokeStyle = '#4CAF50';\n                        ctx.lineWidth = 3;\n                    } else {\n                        ctx.strokeStyle = '#666';\n                        ctx.lineWidth = 1;\n                    }\n                    \n                    ctx.stroke();\n                    \n                    // Draw weight\n                    const midX = (fromNode.x + toNode.x) / 2;\n                    const midY = (fromNode.y + toNode.y) / 2;\n                    ctx.fillStyle = '#333';\n                    ctx.fillText(edge.weight, midX + 5, midY + 5);\n                });\n                \n                // Highlight current edge being considered\n                if (this.currentStep < this.sortedEdges.length) {\n                    const currentEdge = this.sortedEdges[this.currentStep];\n                    const fromNode = this.nodes[currentEdge.from];\n                    const toNode = this.nodes[currentEdge.to];\n                    \n                    ctx.beginPath();\n                    ctx.moveTo(fromNode.x, fromNode.y);\n                    ctx.lineTo(toNode.x, toNode.y);\n                    ctx.strokeStyle = '#ff6b6b';\n                    ctx.lineWidth = 2;\n                    ctx.stroke();\n                }\n                \n                // Draw nodes\n                this.nodes.forEach(node => {\n                    ctx.beginPath();\n                    ctx.arc(node.x, node.y, 15, 0, 2 * Math.PI);\n                    ctx.fillStyle = '#4CAF50';\n                    ctx.fill();\n                    ctx.fillStyle = 'white';\n                    ctx.font = 'bold 12px Arial';\n                    ctx.textAlign = 'center';\n                    ctx.textBaseline = 'middle';\n                    ctx.fillText(node.id, node.x, node.y);\n                });\n            }\n        }\n\n        // Initialize the algorithm and setup event listeners\n        document.addEventListener('DOMContentLoaded', function() {\n            const canvas = document.getElementById('graphCanvas');\n            const kruskal = new KruskalAlgorithm();\n            \n            // Draw initial graph\n            kruskal.drawGraph(canvas);\n            \n            // Event listeners\n            document.getElementById('stepBtn').addEventListener('click', function() {\n                kruskal.nextStep();\n                kruskal.drawGraph(canvas);\n            });\n            \n            document.getElementById('runBtn').addEventListener('click', function() {\n                kruskal.runAllSteps();\n            });\n            \n            document.getElementById('resetBtn').addEventListener('click', function() {\n                kruskal.reset();\n                kruskal.drawGraph(canvas);\n            });\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}