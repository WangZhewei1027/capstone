{
  "id": "dfd7663f-d59e-11f0-ae0b-570552a0b645",
  "timestamp": "2025-12-10T08:08:50.777Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Floyd-Warshall Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Floyd-Warshall Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        \n        .container {\n            background-color: white;\n            border-radius: 8px;\n            padding: 20px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        \n        h1 {\n            color: #2c3e50;\n            text-align: center;\n            margin-bottom: 30px;\n        }\n        \n        .controls {\n            display: flex;\n            gap: 10px;\n            margin-bottom: 20px;\n            flex-wrap: wrap;\n        }\n        \n        button {\n            padding: 8px 16px;\n            background-color: #3498db;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            transition: background-color 0.3s;\n        }\n        \n        button:hover {\n            background-color: #2980b9;\n        }\n        \n        button:disabled {\n            background-color: #bdc3c7;\n            cursor: not-allowed;\n        }\n        \n        input {\n            padding: 8px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            width: 60px;\n        }\n        \n        .grid-container {\n            display: flex;\n            gap: 20px;\n            flex-wrap: wrap;\n        }\n        \n        .matrix-container {\n            flex: 1;\n            min-width: 300px;\n        }\n        \n        .graph-container {\n            flex: 1;\n            min-width: 400px;\n        }\n        \n        table {\n            border-collapse: collapse;\n            width: 100%;\n            margin-bottom: 20px;\n        }\n        \n        th, td {\n            border: 1px solid #ddd;\n            padding: 8px;\n            text-align: center;\n            min-width: 40px;\n        }\n        \n        th {\n            background-color: #f2f2f2;\n        }\n        \n        .current {\n            background-color: #3498db;\n            color: white;\n        }\n        \n        .updated {\n            background-color: #2ecc71;\n            color: white;\n            animation: highlight 1s ease;\n        }\n        \n        @keyframes highlight {\n            0% { background-color: #f1c40f; }\n            100% { background-color: #2ecc71; }\n        }\n        \n        .info-panel {\n            margin-top: 20px;\n            padding: 15px;\n            background-color: #f8f9fa;\n            border-radius: 4px;\n            border-left: 4px solid #3498db;\n        }\n        \n        .step-info {\n            font-weight: bold;\n            margin-bottom: 10px;\n        }\n        \n        .canvas-container {\n            text-align: center;\n            margin-top: 20px;\n        }\n        \n        canvas {\n            border: 1px solid #ddd;\n            background-color: white;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Floyd-Warshall Algorithm Visualization</h1>\n        \n        <div class=\"controls\">\n            <button id=\"resetBtn\">Reset</button>\n            <button id=\"stepBtn\">Step</button>\n            <button id=\"runBtn\">Run All</button>\n            <button id=\"pauseBtn\" disabled>Pause</button>\n            <label>Speed: <input type=\"number\" id=\"speed\" min=\"100\" max=\"2000\" value=\"500\">ms</label>\n            <label>Vertex Count: <input type=\"number\" id=\"vertexCount\" min=\"3\" max=\"8\" value=\"4\"></label>\n        </div>\n        \n        <div class=\"grid-container\">\n            <div class=\"matrix-container\">\n                <h3>Distance Matrix</h3>\n                <div id=\"matrix\"></div>\n            </div>\n            \n            <div class=\"graph-container\">\n                <h3>Graph Visualization</h3>\n                <div class=\"canvas-container\">\n                    <canvas id=\"graphCanvas\" width=\"400\" height=\"300\"></canvas>\n                </div>\n            </div>\n        </div>\n        \n        <div class=\"info-panel\">\n            <div class=\"step-info\" id=\"stepInfo\">Initial state</div>\n            <div id=\"algorithmInfo\">\n                The Floyd-Warshall algorithm finds the shortest paths between all pairs of vertices in a weighted graph.\n                It works for both directed and undirected graphs, and can handle negative weights (but not negative cycles).\n            </div>\n        </div>\n    </div>\n\n    <script>\n        class FloydWarshall {\n            constructor(vertexCount = 4) {\n                this.vertexCount = vertexCount;\n                this.distances = [];\n                this.step = 0;\n                this.k = 0;\n                this.i = 0;\n                this.j = 0;\n                this.isRunning = false;\n                this.intervalId = null;\n                this.speed = 500;\n                \n                this.initMatrix();\n            }\n            \n            initMatrix() {\n                // Initialize with Infinity (no path) and 0 on diagonal\n                this.distances = [];\n                for (let i = 0; i < this.vertexCount; i++) {\n                    this.distances[i] = [];\n                    for (let j = 0; j < this.vertexCount; j++) {\n                        if (i === j) {\n                            this.distances[i][j] = 0;\n                        } else {\n                            this.distances[i][j] = Infinity;\n                        }\n                    }\n                }\n                \n                // Add some random edges\n                this.addRandomEdges();\n                \n                this.step = 0;\n                this.k = 0;\n                this.i = 0;\n                this.j = 0;\n            }\n            \n            addRandomEdges() {\n                // Clear existing edges (except diagonal)\n                for (let i = 0; i < this.vertexCount; i++) {\n                    for (let j = 0; j < this.vertexCount; j++) {\n                        if (i !== j) {\n                            this.distances[i][j] = Infinity;\n                        }\n                    }\n                }\n                \n                // Add random edges (approximately 50% of possible edges)\n                const maxEdges = Math.floor(this.vertexCount * (this.vertexCount - 1) / 2);\n                const edgeCount = Math.floor(maxEdges * 0.5) + 1;\n                \n                for (let e = 0; e < edgeCount; e++) {\n                    let i, j;\n                    do {\n                        i = Math.floor(Math.random() * this.vertexCount);\n                        j = Math.floor(Math.random() * this.vertexCount);\n                    } while (i === j || this.distances[i][j] !== Infinity);\n                    \n                    this.distances[i][j] = Math.floor(Math.random() * 10) + 1;\n                    \n                    // For undirected graph, add reverse edge (comment out for directed)\n                    this.distances[j][i] = this.distances[i][j];\n                }\n            }\n            \n            nextStep() {\n                if (this.k >= this.vertexCount) {\n                    return false; // Algorithm complete\n                }\n                \n                if (this.i >= this.vertexCount) {\n                    this.k++;\n                    this.i = 0;\n                    this.j = 0;\n                    return this.k < this.vertexCount;\n                }\n                \n                if (this.j >= this.vertexCount) {\n                    this.i++;\n                    this.j = 0;\n                    return this.i < this.vertexCount;\n                }\n                \n                // Floyd-Warshall algorithm step\n                if (this.distances[this.i][this.k] + this.distances[this.k][this.j] < this.distances[this.i][this.j]) {\n                    this.distances[this.i][this.j] = this.distances[this.i][this.k] + this.distances[this.k][this.j];\n                    \n                    // Return the updated cell for highlighting\n                    return {\n                        updated: true,\n                        i: this.i,\n                        j: this.j,\n                        k: this.k\n                    };\n                }\n                \n                this.j++;\n                this.step++;\n                return { updated: false, i: this.i, j: this.j, k: this.k };\n            }\n            \n            reset() {\n                this.initMatrix();\n            }\n            \n            setVertexCount(count) {\n                this.vertexCount = Math.max(3, Math.min(8, count));\n                this.reset();\n            }\n            \n            setSpeed(speed) {\n                this.speed = Math.max(100, Math.min(2000, speed));\n                if (this.isRunning) {\n                    this.stop();\n                    this.start();\n                }\n            }\n            \n            start() {\n                if (this.isRunning) return;\n                \n                this.isRunning = true;\n                this.intervalId = setInterval(() => {\n                    if (!this.nextStep()) {\n                        this.stop();\n                    }\n                    this.updateDisplay();\n                }, this.speed);\n            }\n            \n            stop() {\n                this.isRunning = false;\n                if (this.intervalId) {\n                    clearInterval(this.intervalId);\n                    this.intervalId = null;\n                }\n            }\n        }\n        \n        // Initialize the application\n        const floydWarshall = new FloydWarshall();\n        \n        // DOM elements\n        const matrixElement = document.getElementById('matrix');\n        const stepInfoElement = document.getElementById('stepInfo');\n        const resetBtn = document.getElementById('resetBtn');\n        const stepBtn = document.getElementById('stepBtn');\n        const runBtn = document.getElementById('runBtn');\n        const pauseBtn = document.getElementById('pauseBtn');\n        const speedInput = document.getElementById('speed');\n        const vertexCountInput = document.getElementById('vertexCount');\n        const canvas = document.getElementById('graphCanvas');\n        const ctx = canvas.getContext('2d');\n        \n        // Initialize display\n        updateDisplay();\n        \n        // Event listeners\n        resetBtn.addEventListener('click', () => {\n            floydWarshall.reset();\n            updateDisplay();\n        });\n        \n        stepBtn.addEventListener('click', () => {\n            floydWarshall.nextStep();\n            updateDisplay();\n        });\n        \n        runBtn.addEventListener('click', () => {\n            floydWarshall.start();\n            updateButtons();\n        });\n        \n        pauseBtn.addEventListener('click', () => {\n            floydWarshall.stop();\n            updateButtons();\n        });\n        \n        speedInput.addEventListener('change', () => {\n            floydWarshall.setSpeed(parseInt(speedInput.value));\n        });\n        \n        vertexCountInput.addEventListener('change', () => {\n            floydWarshall.setVertexCount(parseInt(vertexCountInput.value));\n            updateDisplay();\n        });\n        \n        function updateButtons() {\n            runBtn.disabled = floydWarshall.isRunning;\n            pauseBtn.disabled = !floydWarshall.isRunning;\n        }\n        \n        function updateDisplay() {\n            updateMatrixDisplay();\n            updateStepInfo();\n            drawGraph();\n            updateButtons();\n        }\n        \n        function updateMatrixDisplay() {\n            let html = '<table><tr><th></th>';\n            \n            // Header row\n            for (let i = 0; i < floydWarshall.vertexCount; i++) {\n                html += `<th>${String.fromCharCode(65 + i)}</th>`;\n            }\n            html += '</tr>';\n            \n            // Data rows\n            for (let i = 0; i < floydWarshall.vertexCount; i++) {\n                html += `<tr><th>${String.fromCharCode(65 + i)}</th>`;\n                for (let j = 0; j < floydWarshall.vertexCount; j++) {\n                    let cellClass = '';\n                    \n                    if (i === floydWarshall.i && j === floydWarshall.j) {\n                        cellClass = 'current';\n                    } else if (i === floydWarshall.k || j === floydWarshall.k) {\n                        // Highlight row and column of vertex k\n                        cellClass = 'highlight';\n                    }\n                    \n                    const value = floydWarshall.distances[i][j] === Infinity ? 'âˆž' : floydWarshall.distances[i][j];\n                    html += `<td class=\"${cellClass}\">${value}</td>`;\n                }\n                html += '</tr>';\n            }\n            html += '</table>';\n            \n            matrixElement.innerHTML = html;\n        }\n        \n        function updateStepInfo() {\n            if (floydWarshall.k >= floydWarshall.vertexCount) {\n                stepInfoElement.textContent = 'Algorithm complete! All shortest paths calculated.';\n            } else {\n                stepInfoElement.textContent = \n                    `Step ${floydWarshall.step}: Checking path from ${String.fromCharCode(65 + floydWarshall.i)} to ${String.fromCharCode(65 + floydWarshall.j)} via ${String.fromCharCode(65 + floydWarshall.k)}`;\n            }\n        }\n        \n        function drawGraph() {\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Calculate vertex positions in a circle\n            const centerX = canvas.width / 2;\n            const centerY = canvas.height / 2;\n            const radius = Math.min(centerX, centerY) - 50;\n            \n            const vertexPositions = [];\n            for (let i = 0; i < floydWarshall.vertexCount; i++) {\n                const angle = (2 * Math.PI * i) / floydWarshall.vertexCount - Math.PI / 2;\n                vertexPositions[i] = {\n                    x: centerX + radius * Math.cos(angle),\n                    y: centerY + radius * Math.sin(angle)\n                };\n            }\n            \n            // Draw edges\n            ctx.strokeStyle = '#3498db';\n            ctx.lineWidth = 2;\n            ctx.font = '12px Arial';\n            ctx.fillStyle = '#2c3e50';\n            \n            for (let i = 0; i < floydWarshall.vertexCount; i++) {\n                for (let j = 0; j < floydWarshall.vertexCount; j++) {\n                    if (i !== j && floydWarshall.distances[i][j] !== Infinity) {\n                        // Highlight current edge being considered\n                        if ((i === floydWarshall.i && j === floydWarshall.j) || \n                            (i === floydWarshall.i && j === floydWarshall.k) || \n                            (i === floydWarshall.k && j === floydWarshall.j)) {\n                            ctx.strokeStyle = '#e74c3c';\n                            ctx.lineWidth = 3;\n                        } else {\n                            ctx.strokeStyle = '#3498db';\n                            ctx.lineWidth = 2;\n                        }\n                        \n                        const start = vertexPositions[i];\n                        const end = vertexPositions[j];\n                        \n                        // Draw arrow\n                        drawArrow(ctx, start.x, start.y, end.x, end.y);\n                        \n                        // Draw weight\n                        const midX = (start.x + end.x) / 2;\n                        const midY = (start.y + end.y) / 2;\n                        \n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(midX - 15, midY - 10, 30, 20);\n                        ctx.fillStyle = '#2c3e50';\n                        ctx.fillText(floydWarshall.distances[i][j], midX - 5, midY + 5);\n                    }\n                }\n            }\n            \n            // Draw vertices\n            for (let i = 0; i < floydWarshall.vertexCount; i++) {\n                const pos = vertexPositions[i];\n                \n                // Highlight current vertex k\n                if (i === floydWarshall.k) {\n                    ctx.fillStyle = '#e74c3c';\n                } else if (i === floydWarshall.i || i === floydWarshall.j) {\n                    ctx.fillStyle = '#f39c12';\n                } else {\n                    ctx.fillStyle = '#2ecc71';\n                }\n                \n                ctx.beginPath();\n                ctx.arc(pos.x, pos.y, 20, 0, 2 * Math.PI);\n                ctx.fill();\n                \n                // Vertex label\n                ctx.fillStyle = 'white';\n                ctx.font = 'bold 16px Arial';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillText(String.fromCharCode(65 + i), pos.x, pos.y);\n            }\n        }\n        \n        function drawArrow(ctx, fromX, fromY, toX, toY) {\n            const headlen = 10;\n            const dx = toX - fromX;\n            const dy = toY - fromY;\n            const angle = Math.atan2(dy, dx);\n            \n            // Draw line\n            ctx.beginPath();\n            ctx.moveTo(fromX, fromY);\n            ctx.lineTo(toX, toY);\n            ctx.stroke();\n            \n            // Draw arrowhead\n            ctx.beginPath();\n            ctx.moveTo(toX, toY);\n            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI/6), toY - headlen * Math.sin(angle - Math.PI/6));\n            ctx.moveTo(toX, toY);\n            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI/6), toY - headlen * Math.sin(angle + Math.PI/6));\n            ctx.stroke();\n        }\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Floyd-Warshall Algorithm"
    }
  ],
  "topic": "Floyd-Warshall Algorithm",
  "hasFSM": false,
  "hasTest": true
}