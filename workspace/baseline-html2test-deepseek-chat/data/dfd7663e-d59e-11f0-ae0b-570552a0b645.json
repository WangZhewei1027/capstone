{
  "id": "dfd7663e-d59e-11f0-ae0b-570552a0b645",
  "timestamp": "2025-12-10T08:08:30.782Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Bellman-Ford Algorithm",
  "answer": {
    "role": "assistant",
    "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Bellman-Ford Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        \n        .container {\n            display: flex;\n            gap: 20px;\n            margin-top: 20px;\n        }\n        \n        .graph-section, .algorithm-section {\n            flex: 1;\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        \n        canvas {\n            border: 1px solid #ddd;\n            background-color: #fff;\n        }\n        \n        .controls {\n            margin: 20px 0;\n            display: flex;\n            gap: 10px;\n            flex-wrap: wrap;\n        }\n        \n        button {\n            padding: 8px 16px;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n        \n        button:hover {\n            background-color: #45a049;\n        }\n        \n        button:disabled {\n            background-color: #cccccc;\n            cursor: not-allowed;\n        }\n        \n        .step-info {\n            background-color: #e8f4fd;\n            padding: 10px;\n            border-radius: 4px;\n            margin: 10px 0;\n            min-height: 60px;\n        }\n        \n        .distance-table {\n            margin-top: 20px;\n            width: 100%;\n            border-collapse: collapse;\n        }\n        \n        .distance-table th, .distance-table td {\n            border: 1px solid #ddd;\n            padding: 8px;\n            text-align: center;\n        }\n        \n        .distance-table th {\n            background-color: #f2f2f2;\n        }\n        \n        .node {\n            fill: #4CAF50;\n            stroke: #333;\n            stroke-width: 2;\n        }\n        \n        .edge {\n            stroke: #666;\n            stroke-width: 2;\n            fill: none;\n        }\n        \n        .edge-weight {\n            font-size: 14px;\n            font-weight: bold;\n            fill: #333;\n        }\n        \n        .current-edge {\n            stroke: #ff0000;\n            stroke-width: 3;\n        }\n        \n        .updated-node {\n            fill: #ff9800;\n        }\n        \n        .negative-cycle {\n            color: #f44336;\n            font-weight: bold;\n        }\n    </style>\n</head>\n<body>\n    <h1>Bellman-Ford Algorithm Visualization</h1>\n    \n    <div class=\"controls\">\n        <button id=\"stepBtn\">Next Step</button>\n        <button id=\"runBtn\">Run Algorithm</button>\n        <button id=\"resetBtn\">Reset</button>\n        <button id=\"randomGraphBtn\">Generate Random Graph</button>\n        <select id=\"graphSelect\">\n            <option value=\"simple\">Simple Graph</option>\n            <option value=\"negative\">Graph with Negative Edge</option>\n            <option value=\"cycle\">Graph with Negative Cycle</option>\n        </select>\n    </div>\n    \n    <div class=\"container\">\n        <div class=\"graph-section\">\n            <h2>Graph Visualization</h2>\n            <canvas id=\"graphCanvas\" width=\"500\" height=\"400\"></canvas>\n        </div>\n        \n        <div class=\"algorithm-section\">\n            <h2>Algorithm Execution</h2>\n            <div class=\"step-info\" id=\"stepInfo\">\n                Click \"Next Step\" to start the algorithm execution.\n            </div>\n            \n            <h3>Distance Table</h3>\n            <table class=\"distance-table\" id=\"distanceTable\">\n                <thead>\n                    <tr>\n                        <th>Vertex</th>\n                        <th>Distance</th>\n                        <th>Previous</th>\n                    </tr>\n                </thead>\n                <tbody id=\"distanceTableBody\">\n                </tbody>\n            </table>\n            \n            <h3>Algorithm Steps</h3>\n            <div id=\"algorithmSteps\"></div>\n        </div>\n    </div>\n\n    <script>\n        class BellmanFord {\n            constructor() {\n                this.graph = {\n                    nodes: [],\n                    edges: []\n                };\n                this.distances = {};\n                this.previous = {};\n                this.step = 0;\n                this.maxSteps = 0;\n                this.sourceNode = 0;\n                this.isRunning = false;\n                this.animationSpeed = 1000;\n                this.animationInterval = null;\n                this.canvas = document.getElementById('graphCanvas');\n                this.ctx = this.canvas.getContext('2d');\n                \n                this.initializeEventListeners();\n                this.generateGraph('simple');\n                this.drawGraph();\n                this.updateDistanceTable();\n            }\n            \n            initializeEventListeners() {\n                document.getElementById('stepBtn').addEventListener('click', () => this.nextStep());\n                document.getElementById('runBtn').addEventListener('click', () => this.toggleRun());\n                document.getElementById('resetBtn').addEventListener('click', () => this.reset());\n                document.getElementById('randomGraphBtn').addEventListener('click', () => this.generateRandomGraph());\n                document.getElementById('graphSelect').addEventListener('change', (e) => {\n                    this.generateGraph(e.target.value);\n                    this.drawGraph();\n                    this.updateDistanceTable();\n                });\n            }\n            \n            generateGraph(type) {\n                this.graph = { nodes: [], edges: [] };\n                \n                // Create 5 nodes positioned in a circle\n                const centerX = this.canvas.width / 2;\n                const centerY = this.canvas.height / 2;\n                const radius = 150;\n                \n                for (let i = 0; i < 5; i++) {\n                    const angle = (i * 2 * Math.PI) / 5;\n                    const x = centerX + radius * Math.cos(angle);\n                    const y = centerY + radius * Math.sin(angle);\n                    this.graph.nodes.push({ id: i, x: x, y: y });\n                }\n                \n                switch(type) {\n                    case 'simple':\n                        this.graph.edges = [\n                            { from: 0, to: 1, weight: 6 },\n                            { from: 0, to: 3, weight: 7 },\n                            { from: 1, to: 2, weight: 5 },\n                            { from: 1, to: 3, weight: 8 },\n                            { from: 1, to: 4, weight: -4 },\n                            { from: 2, to: 1, weight: -2 },\n                            { from: 3, to: 2, weight: -3 },\n                            { from: 3, to: 4, weight: 9 },\n                            { from: 4, to: 0, weight: 2 },\n                            { from: 4, to: 2, weight: 7 }\n                        ];\n                        break;\n                        \n                    case 'negative':\n                        this.graph.edges = [\n                            { from: 0, to: 1, weight: 6 },\n                            { from: 0, to: 3, weight: 7 },\n                            { from: 1, to: 2, weight: 5 },\n                            { from: 1, to: 3, weight: 8 },\n                            { from: 1, to: 4, weight: -4 },\n                            { from: 2, to: 1, weight: -2 },\n                            { from: 3, to: 2, weight: -3 },\n                            { from: 3, to: 4, weight: 9 },\n                            { from: 4, to: 0, weight: 2 },\n                            { from: 4, to: 2, weight: 7 }\n                        ];\n                        break;\n                        \n                    case 'cycle':\n                        this.graph.edges = [\n                            { from: 0, to: 1, weight: 6 },\n                            { from: 1, to: 2, weight: 5 },\n                            { from: 2, to: 3, weight: -2 },\n                            { from: 3, to: 4, weight: -3 },\n                            { from: 4, to: 1, weight: -8 }  // This creates a negative cycle\n                        ];\n                        break;\n                }\n                \n                this.reset();\n            }\n            \n            generateRandomGraph() {\n                this.graph = { nodes: [], edges: [] };\n                \n                const numNodes = 6;\n                const centerX = this.canvas.width / 2;\n                const centerY = this.canvas.height / 2;\n                const radius = 150;\n                \n                for (let i = 0; i < numNodes; i++) {\n                    const angle = (i * 2 * Math.PI) / numNodes;\n                    const x = centerX + radius * Math.cos(angle);\n                    const y = centerY + radius * Math.sin(angle);\n                    this.graph.nodes.push({ id: i, x: x, y: y });\n                }\n                \n                // Generate random edges\n                for (let i = 0; i < numNodes; i++) {\n                    for (let j = 0; j < numNodes; j++) {\n                        if (i !== j && Math.random() > 0.6) {\n                            const weight = Math.floor(Math.random() * 20) - 5; // Random weight between -5 and 15\n                            this.graph.edges.push({ from: i, to: j, weight: weight });\n                        }\n                    }\n                }\n                \n                this.reset();\n                this.drawGraph();\n                this.updateDistanceTable();\n            }\n            \n            reset() {\n                this.step = 0;\n                this.isRunning = false;\n                \n                // Initialize distances\n                this.distances = {};\n                this.previous = {};\n                \n                for (let node of this.graph.nodes) {\n                    this.distances[node.id] = node.id === this.sourceNode ? 0 : Infinity;\n                    this.previous[node.id] = null;\n                }\n                \n                this.maxSteps = this.graph.nodes.length - 1;\n                \n                document.getElementById('stepInfo').innerHTML = \n                    'Algorithm reset. Ready to start from source node ' + this.sourceNode + '.';\n                document.getElementById('algorithmSteps').innerHTML = '';\n                \n                if (this.animationInterval) {\n                    clearInterval(this.animationInterval);\n                    this.animationInterval = null;\n                }\n                \n                document.getElementById('runBtn').textContent = 'Run Algorithm';\n                this.drawGraph();\n                this.updateDistanceTable();\n            }\n            \n            nextStep() {\n                if (this.step === 0) {\n                    document.getElementById('algorithmSteps').innerHTML = \n                        '<p>Step 1: Initialize distances. Source node distance set to 0, others to Infinity.</p>';\n                    this.step++;\n                    this.updateStepInfo('Initialization complete.');\n                    return;\n                }\n                \n                if (this.step > this.maxSteps) {\n                    // Check for negative cycles\n                    let hasNegativeCycle = false;\n                    let cycleInfo = '';\n                    \n                    for (let edge of this.graph.edges) {\n                        if (this.distances[edge.from] + edge.weight < this.distances[edge.to]) {\n                            hasNegativeCycle = true;\n                            cycleInfo = `Negative cycle detected! Edge (${edge.from} → ${edge.to}) with weight ${edge.weight} would reduce distance.`;\n                            break;\n                        }\n                    }\n                    \n                    if (hasNegativeCycle) {\n                        document.getElementById('stepInfo').innerHTML = \n                            '<span class=\"negative-cycle\">' + cycleInfo + '</span>';\n                        document.getElementById('algorithmSteps').innerHTML += \n                            '<p class=\"negative-cycle\">' + cycleInfo + '</p>';\n                    } else {\n                        document.getElementById('stepInfo').innerHTML = \n                            'Algorithm completed successfully. No negative cycles detected.';\n                        document.getElementById('algorithmSteps').innerHTML += \n                            '<p>Final step: No negative cycles detected. Algorithm complete.</p>';\n                    }\n                    \n                    this.step++;\n                    return;\n                }\n                \n                let updated = false;\n                let stepInfo = `Relaxation round ${this.step}: `;\n                let stepDetails = '';\n                \n                for (let i = 0; i < this.graph.edges.length; i++) {\n                    const edge = this.graph.edges[i];\n                    const u = edge.from;\n                    const v = edge.to;\n                    const w = edge.weight;\n                    \n                    if (this.distances[u] !== Infinity && this.distances[u] + w < this.distances[v]) {\n                        this.distances[v] = this.distances[u] + w;\n                        this.previous[v] = u;\n                        updated = true;\n                        \n                        stepDetails += `Relaxing edge (${u} → ${v}): distance[${v}] = min(∞, ${this.distances[u]} + ${w} = ${this.distances[u] + w})<br>`;\n                    }\n                }\n                \n                if (updated) {\n                    stepInfo += 'Some distances were updated.';\n                } else {\n                    stepInfo += 'No distances were updated.';\n                }\n                \n                this.updateStepInfo(stepInfo, stepDetails);\n                document.getElementById('algorithmSteps').innerHTML += \n                    `<p><strong>Step ${this.step + 1}:</strong> ${stepInfo}<br>${stepDetails}</p>`;\n                \n                this.step++;\n                this.drawGraph(this.step - 1);\n                this.updateDistanceTable();\n            }\n            \n            updateStepInfo(info, details = '') {\n                document.getElementById('stepInfo').innerHTML = \n                    `<strong>Step ${this.step}:</strong> ${info}<br>${details}`;\n            }\n            \n            toggleRun() {\n                if (this.isRunning) {\n                    this.isRunning = false;\n                    document.getElementById('runBtn').textContent = 'Run Algorithm';\n                    \n                    if (this.animationInterval) {\n                        clearInterval(this.animationInterval);\n                        this.animationInterval = null;\n                    }\n                } else {\n                    this.isRunning = true;\n                    document.getElementById('runBtn').textContent = 'Pause';\n                    \n                    this.animationInterval = setInterval(() => {\n                        if (this.step > this.maxSteps + 1) {\n                            this.toggleRun();\n                            return;\n                        }\n                        \n                        this.nextStep();\n                    }, this.animationSpeed);\n                }\n            }\n            \n            drawGraph(highlightEdgeIndex = -1) {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                \n                // Draw edges\n                for (let i = 0; i < this.graph.edges.length; i++) {\n                    const edge = this.graph.edges[i];\n                    const fromNode = this.graph.nodes[edge.from];\n                    const toNode = this.graph.nodes[edge.to];\n                    \n                    this.ctx.beginPath();\n                    this.ctx.strokeStyle = i === highlightEdgeIndex ? '#ff0000' : '#666';\n                    this.ctx.lineWidth = i === highlightEdgeIndex ? 3 : 2;\n                    \n                    // Draw arrow\n                    const headlen = 10;\n                    const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);\n                    \n                    this.ctx.moveTo(fromNode.x, fromNode.y);\n                    this.ctx.lineTo(toNode.x, toNode.y);\n                    this.ctx.stroke();\n                    \n                    // Arrowhead\n                    this.ctx.beginPath();\n                    this.ctx.moveTo(toNode.x, toNode.y);\n                    this.ctx.lineTo(\n                        toNode.x - headlen * Math.cos(angle - Math.PI/6),\n                        toNode.y - headlen * Math.sin(angle - Math.PI/6)\n                    );\n                    this.ctx.lineTo(\n                        toNode.x - headlen * Math.cos(angle + Math.PI/6),\n                        toNode.y - headlen * Math.sin(angle + Math.PI/6)\n                    );\n                    this.ctx.closePath();\n                    this.ctx.fillStyle = i === highlightEdgeIndex ? '#ff0000' : '#666';\n                    this.ctx.fill();\n                    \n                    // Edge weight\n                    const midX = (fromNode.x + toNode.x) / 2;\n                    const midY = (fromNode.y + toNode.y) / 2;\n                    \n                    this.ctx.fillStyle = '#333';\n                    this.ctx.font = '14px Arial';\n                    this.ctx.fillText(edge.weight, midX + 5, midY + 5);\n                }\n                \n                // Draw nodes\n                for (let node of this.graph.nodes) {\n                    this.ctx.beginPath();\n                    this.ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);\n                    this.ctx.fillStyle = node.id === this.sourceNode ? '#4CAF50' : \n                                        (this.distances[node.id] !== Infinity ? '#ff9800' : '#4CAF50');\n                    this.ctx.fill();\n                    this.ctx.strokeStyle = '#333';\n                    this.ctx.lineWidth = 2;\n                    this.ctx.stroke();\n                    \n                    // Node label\n                    this.ctx.fillStyle = '#fff';\n                    this.ctx.font = 'bold 16px Arial';\n                    this.ctx.textAlign = 'center';\n                    this.ctx.textBaseline = 'middle';\n                    this.ctx.fillText(node.id, node.x, node.y);\n                    \n                    // Distance label\n                    this.ctx.fillStyle = '#333';\n                    this.ctx.font = '12px Arial';\n                    this.ctx.fillText(\n                        this.distances[node.id] === Infinity ? '∞' : this.distances[node.id], \n                        node.x, \n                        node.y + 30\n                    );\n                }\n            }\n            \n            updateDistanceTable() {\n                const tableBody = document.getElementById('distanceTableBody');\n                tableBody.innerHTML = '';\n                \n                for (let node of this.graph.nodes) {\n                    const row = document.createElement('tr');\n                    \n                    const cellNode = document.createElement('td');\n                    cellNode.textContent = node.id;\n                    row.appendChild(cellNode);\n                    \n                    const cellDistance = document.createElement('td');\n                    cellDistance.textContent = this.distances[node.id] === Infinity ? '∞' : this.distances[node.id];\n                    row.appendChild(cellDistance);\n                    \n                    const cellPrevious = document.createElement('td');\n                    cellPrevious.textContent = this.previous[node.id] === null ? '-' : this.previous[node.id];\n                    row.appendChild(cellPrevious);\n                    \n                    tableBody.appendChild(row);\n                }\n            }\n        }\n        \n"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Bellman-Ford Algorithm"
    }
  ],
  "topic": "Bellman-Ford Algorithm",
  "hasFSM": false,
  "hasTest": true
}