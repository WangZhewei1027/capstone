{
  "id": "6e09e030-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:19:49.054Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency Matrix",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Adjacency Matrix Visualization</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        body {\n            font-family: Arial, sans-serif;\n            line-height: 1.6;\n            padding: 20px;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            min-height: 100vh;\n        }\n\n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n            background: white;\n            border-radius: 15px;\n            box-shadow: 0 10px 30px rgba(0,0,0,0.2);\n            overflow: hidden;\n        }\n\n        header {\n            background: #2c3e50;\n            color: white;\n            padding: 30px;\n            text-align: center;\n        }\n\n        h1 {\n            font-size: 2.5em;\n            margin-bottom: 10px;\n        }\n\n        .subtitle {\n            font-size: 1.2em;\n            opacity: 0.9;\n        }\n\n        .content {\n            display: grid;\n            grid-template-columns: 1fr 1fr;\n            gap: 30px;\n            padding: 30px;\n        }\n\n        @media (max-width: 768px) {\n            .content {\n                grid-template-columns: 1fr;\n            }\n        }\n\n        .graph-section, .matrix-section {\n            background: #f8f9fa;\n            border-radius: 10px;\n            padding: 20px;\n        }\n\n        h2 {\n            color: #2c3e50;\n            margin-bottom: 20px;\n            border-bottom: 2px solid #3498db;\n            padding-bottom: 10px;\n        }\n\n        .canvas-container {\n            border: 2px solid #bdc3c7;\n            border-radius: 8px;\n            background: white;\n            margin-bottom: 20px;\n            position: relative;\n            overflow: hidden;\n        }\n\n        canvas {\n            width: 100%;\n            height: 300px;\n            display: block;\n        }\n\n        .matrix {\n            display: grid;\n            gap: 5px;\n            margin-bottom: 20px;\n            justify-content: center;\n        }\n\n        .matrix-cell {\n            width: 40px;\n            height: 40px;\n            border: 2px solid #34495e;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            background: white;\n            transition: all 0.3s ease;\n            cursor: pointer;\n        }\n\n        .matrix-cell.header {\n            background: #34495e;\n            color: white;\n            border-color: #2c3e50;\n        }\n\n        .matrix-cell.active {\n            background: #e74c3c;\n            color: white;\n            transform: scale(1.1);\n        }\n\n        .matrix-cell.edge {\n            background: #3498db;\n            color: white;\n        }\n\n        .controls {\n            display: flex;\n            gap: 10px;\n            margin-bottom: 20px;\n            flex-wrap: wrap;\n        }\n\n        button {\n            padding: 10px 15px;\n            border: none;\n            border-radius: 5px;\n            background: #3498db;\n            color: white;\n            cursor: pointer;\n            transition: background 0.3s ease;\n            font-weight: bold;\n        }\n\n        button:hover {\n            background: #2980b9;\n        }\n\n        button.reset {\n            background: #e74c3c;\n        }\n\n        button.reset:hover {\n            background: #c0392b;\n        }\n\n        .explanation {\n            background: #ecf0f1;\n            padding: 15px;\n            border-radius: 8px;\n            border-left: 4px solid #3498db;\n        }\n\n        .highlight {\n            background: #fff3cd;\n            padding: 2px 5px;\n            border-radius: 3px;\n            font-weight: bold;\n        }\n\n        footer {\n            text-align: center;\n            padding: 20px;\n            background: #ecf0f1;\n            color: #7f8c8d;\n            border-top: 1px solid #bdc3c7;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>Adjacency Matrix</h1>\n            <div class=\"subtitle\">Interactive Graph Representation</div>\n        </header>\n\n        <div class=\"content\">\n            <div class=\"graph-section\">\n                <h2>Graph Visualization</h2>\n                <div class=\"canvas-container\">\n                    <canvas id=\"graphCanvas\"></canvas>\n                </div>\n                <div class=\"controls\">\n                    <button id=\"addNode\">Add Node</button>\n                    <button id=\"addEdge\">Add Edge Mode</button>\n                    <button id=\"clearEdges\">Clear Edges</button>\n                    <button id=\"resetGraph\" class=\"reset\">Reset Graph</button>\n                </div>\n                <div class=\"explanation\">\n                    <p><span class=\"highlight\">Click on nodes</span> to select them, then <span class=\"highlight\">click another node</span> to create an edge between them.</p>\n                    <p>Nodes are represented as circles, edges as lines connecting them.</p>\n                </div>\n            </div>\n\n            <div class=\"matrix-section\">\n                <h2>Adjacency Matrix</h2>\n                <div id=\"matrixContainer\" class=\"matrix\"></div>\n                <div class=\"explanation\">\n                    <p>An <span class=\"highlight\">adjacency matrix</span> is a square matrix used to represent a finite graph.</p>\n                    <p>Matrix element <span class=\"highlight\">[i][j]</span> is 1 if there is an edge from vertex i to vertex j, otherwise 0.</p>\n                    <p><span class=\"highlight\">Click matrix cells</span> to see the corresponding edge highlighted in the graph.</p>\n                </div>\n            </div>\n        </div>\n\n        <footer>\n            <p>Adjacency Matrix Visualization | Graph Theory Demonstration</p>\n        </footer>\n    </div>\n\n    <script>\n        class GraphVisualizer {\n            constructor() {\n                this.canvas = document.getElementById('graphCanvas');\n                this.ctx = this.canvas.getContext('2d');\n                this.matrixContainer = document.getElementById('matrixContainer');\n                \n                this.nodes = [];\n                this.edges = [];\n                this.selectedNode = null;\n                this.mode = 'select'; // 'select' or 'edge'\n                this.nodeRadius = 25;\n                this.nextNodeId = 0;\n                \n                this.setupEventListeners();\n                this.resizeCanvas();\n                this.initializeGraph();\n                this.updateMatrix();\n                \n                window.addEventListener('resize', () => this.resizeCanvas());\n            }\n\n            resizeCanvas() {\n                const container = this.canvas.parentElement;\n                this.canvas.width = container.clientWidth;\n                this.canvas.height = 300;\n                this.drawGraph();\n            }\n\n            setupEventListeners() {\n                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));\n                \n                document.getElementById('addNode').addEventListener('click', () => {\n                    this.addNode(this.canvas.width / 2, this.canvas.height / 2);\n                });\n                \n                document.getElementById('addEdge').addEventListener('click', () => {\n                    this.mode = 'edge';\n                    this.selectedNode = null;\n                    this.updateInstructions();\n                });\n                \n                document.getElementById('clearEdges').addEventListener('click', () => {\n                    this.edges = [];\n                    this.updateMatrix();\n                    this.drawGraph();\n                });\n                \n                document.getElementById('resetGraph').addEventListener('click', () => {\n                    this.resetGraph();\n                });\n            }\n\n            initializeGraph() {\n                // Add some initial nodes\n                this.addNode(100, 100);\n                this.addNode(200, 200);\n                this.addNode(300, 100);\n            }\n\n            resetGraph() {\n                this.nodes = [];\n                this.edges = [];\n                this.selectedNode = null;\n                this.nextNodeId = 0;\n                this.initializeGraph();\n                this.updateMatrix();\n                this.drawGraph();\n            }\n\n            addNode(x, y) {\n                const node = {\n                    id: this.nextNodeId++,\n                    x: x,\n                    y: y,\n                    label: String.fromCharCode(65 + this.nextNodeId - 1) // A, B, C, ...\n                };\n                this.nodes.push(node);\n                this.updateMatrix();\n                this.drawGraph();\n            }\n\n            handleCanvasClick(e) {\n                const rect = this.canvas.getBoundingClientRect();\n                const x = e.clientX - rect.left;\n                const y = e.clientY - rect.top;\n\n                // Check if clicked on existing node\n                const clickedNode = this.getNodeAt(x, y);\n                \n                if (clickedNode) {\n                    if (this.mode === 'edge') {\n                        if (this.selectedNode === null) {\n                            this.selectedNode = clickedNode;\n                        } else if (this.selectedNode !== clickedNode) {\n                            this.addEdge(this.selectedNode.id, clickedNode.id);\n                            this.selectedNode = null;\n                        }\n                    } else {\n                        this.selectedNode = clickedNode;\n                    }\n                } else if (this.mode !== 'edge') {\n                    this.selectedNode = null;\n                }\n\n                this.drawGraph();\n            }\n\n            getNodeAt(x, y) {\n                for (const node of this.nodes) {\n                    const distance = Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2);\n                    if (distance <= this.nodeRadius) {\n                        return node;\n                    }\n                }\n                return null;\n            }\n\n            addEdge(fromId, toId) {\n                // Check if edge already exists\n                if (!this.edges.some(edge => \n                    (edge.from === fromId && edge.to === toId) || \n                    (edge.from === toId && edge.to === fromId))) {\n                    this.edges.push({ from: fromId, to: toId });\n                    this.updateMatrix();\n                }\n            }\n\n            updateInstructions() {\n                // Could update instructions based on mode\n            }\n\n            drawGraph() {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                \n                // Draw edges\n                this.ctx.strokeStyle = '#3498db';\n                this.ctx.lineWidth = 3;\n                for (const edge of this.edges) {\n                    const fromNode = this.nodes.find(n => n.id === edge.from);\n                    const toNode = this.nodes.find(n => n.id === edge.to);\n                    \n                    if (fromNode && toNode) {\n                        this.ctx.beginPath();\n                        this.ctx.moveTo(fromNode.x, fromNode.y);\n                        this.ctx.lineTo(toNode.x, toNode.y);\n                        this.ctx.stroke();\n                    }\n                }\n\n                // Draw nodes\n                for (const node of this.nodes) {\n                    this.ctx.fillStyle = node === this.selectedNode ? '#e74c3c' : '#2c3e50';\n                    this.ctx.beginPath();\n                    this.ctx.arc(node.x, node.y, this.nodeRadius, 0, 2 * Math.PI);\n                    this.ctx.fill();\n                    \n                    // Draw node label\n                    this.ctx.fillStyle = 'white';\n                    this.ctx.font = 'bold 16px Arial';\n                    this.ctx.textAlign = 'center';\n                    this.ctx.textBaseline = 'middle';\n                    this.ctx.fillText(node.label, node.x, node.y);\n                }\n            }\n\n            updateMatrix() {\n                this.matrixContainer.innerHTML = '';\n                \n                if (this.nodes.length === 0) return;\n\n                // Create header row\n                const headerRow = document.createElement('div');\n                headerRow.style.display = 'contents';\n                \n                // Empty corner cell\n                const cornerCell = document.createElement('div');\n                cornerCell.className = 'matrix-cell header';\n                cornerCell.textContent = '';\n                headerRow.appendChild(cornerCell);\n                \n                // Column headers\n                for (const node of this.nodes) {\n                    const headerCell = document.createElement('div');\n                    headerCell.className = 'matrix-cell header';\n                    headerCell.textContent = node.label;\n                    headerRow.appendChild(headerCell);\n                }\n                this.matrixContainer.appendChild(headerRow);\n\n                // Create matrix rows\n                for (let i = 0; i < this.nodes.length; i++) {\n                    const row = document.createElement('div');\n                    row.style.display = 'contents';\n                    \n                    // Row header\n                    const rowHeader = document.createElement('div');\n                    rowHeader.className = 'matrix-cell header';\n                    rowHeader.textContent = this.nodes[i].label;\n                    row.appendChild(rowHeader);\n                    \n                    // Matrix cells\n                    for (let j = 0; j < this.nodes.length; j++) {\n                        const cell = document.createElement('div');\n                        cell.className = 'matrix-cell';\n                        \n                        const hasEdge = this.edges.some(edge => \n                            (edge.from === this.nodes[i].id && edge.to === this.nodes[j].id) ||\n                            (edge.from === this.nodes[j].id && edge.to === this.nodes[i].id)\n                        );\n                        \n                        cell.textContent = hasEdge ? '1' : '0';\n                        if (hasEdge) {\n                            cell.classList.add('edge');\n                        }\n                        \n                        cell.addEventListener('click', () => {\n                            this.highlightEdge(this.nodes[i].id, this.nodes[j].id);\n                        });\n                        \n                        row.appendChild(cell);\n                    }\n                    this.matrixContainer.appendChild(row);\n                }\n            }\n\n            highlightEdge(fromId, toId) {\n                // Create temporary highlight effect\n                const edgeExists = this.edges.some(edge => \n                    (edge.from === fromId && edge.to === toId) ||\n                    (edge.from === toId && edge.to === fromId)\n                );\n                \n                if (edgeExists) {\n                    this.ctx.strokeStyle = '#e74c3c';\n                    this.ctx.lineWidth = 5;\n                    \n                    const fromNode = this.nodes.find(n => n.id === fromId);\n                    const toNode = this.nodes.find(n => n.id === toId);\n                    \n                    if (fromNode && toNode) {\n                        this.ctx.beginPath();\n                        this.ctx.moveTo(fromNode.x, fromNode.y);\n                        this.ctx.lineTo(toNode.x, toNode.y);\n                        this.ctx.stroke();\n                        \n                        // Reset after delay\n                        setTimeout(() => {\n                            this.drawGraph();\n                        }, 500);\n                    }\n                }\n            }\n        }\n\n        // Initialize the visualizer when the page loads\n        document.addEventListener('DOMContentLoaded', () => {\n            new GraphVisualizer();\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency Matrix"
    }
  ],
  "topic": "Adjacency Matrix",
  "hasFSM": false,
  "hasTest": true
}