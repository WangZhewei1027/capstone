{
  "id": "6e0a0745-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:19:45.663Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Depth-First Search (DFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Depth-First Search Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n        }\n        .controls {\n            margin-bottom: 20px;\n            padding: 15px;\n            background: white;\n            border-radius: 5px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        button {\n            padding: 10px 15px;\n            margin: 5px;\n            background: #007bff;\n            color: white;\n            border: none;\n            border-radius: 3px;\n            cursor: pointer;\n        }\n        button:hover {\n            background: #0056b3;\n        }\n        button:disabled {\n            background: #6c757d;\n            cursor: not-allowed;\n        }\n        .canvas-container {\n            background: white;\n            padding: 20px;\n            border-radius: 5px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n            margin-bottom: 20px;\n        }\n        canvas {\n            border: 1px solid #ddd;\n        }\n        .info-panel {\n            background: white;\n            padding: 15px;\n            border-radius: 5px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        .status {\n            margin: 10px 0;\n            padding: 10px;\n            border-radius: 3px;\n        }\n        .current {\n            background: #d4edda;\n            border: 1px solid #c3e6cb;\n        }\n        .visited {\n            background: #e2e3e5;\n            border: 1px solid #d6d8db;\n        }\n        .stack {\n            background: #fff3cd;\n            border: 1px solid #ffeaa7;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Depth-First Search Visualization</h1>\n        \n        <div class=\"controls\">\n            <button onclick=\"startDFS()\">Start DFS</button>\n            <button onclick=\"nextStep()\">Next Step</button>\n            <button onclick=\"resetDFS()\">Reset</button>\n            <button onclick=\"generateRandomGraph()\">Generate Random Graph</button>\n            <select id=\"speed\" onchange=\"updateSpeed()\">\n                <option value=\"1000\">Slow</option>\n                <option value=\"500\" selected>Medium</option>\n                <option value=\"200\">Fast</option>\n            </select>\n            <span>Start Node: <input type=\"number\" id=\"startNode\" min=\"0\" max=\"7\" value=\"0\" style=\"width: 50px;\"></span>\n        </div>\n\n        <div class=\"canvas-container\">\n            <canvas id=\"graphCanvas\" width=\"800\" height=\"400\"></canvas>\n        </div>\n\n        <div class=\"info-panel\">\n            <h3>DFS Status</h3>\n            <div id=\"status\" class=\"status\">\n                Ready to start DFS traversal...\n            </div>\n            <h4>Algorithm Steps:</h4>\n            <ol id=\"steps\"></ol>\n            <h4>Stack Contents:</h4>\n            <div id=\"stackContents\" class=\"status stack\"></div>\n            <h4>Visited Nodes:</h4>\n            <div id=\"visitedNodes\" class=\"status visited\"></div>\n        </div>\n    </div>\n\n    <script>\n        class Graph {\n            constructor() {\n                this.adjacencyList = {};\n                this.nodes = [];\n                this.edges = [];\n            }\n\n            addNode(id, x, y) {\n                this.nodes.push({ id, x, y });\n                this.adjacencyList[id] = [];\n            }\n\n            addEdge(from, to) {\n                this.edges.push({ from, to });\n                this.adjacencyList[from].push(to);\n                // For undirected graph, add reverse edge\n                if (!this.adjacencyList[to].includes(from)) {\n                    this.adjacencyList[to].push(from);\n                }\n            }\n\n            getNeighbors(node) {\n                return this.adjacencyList[node] || [];\n            }\n        }\n\n        class DFSVisualizer {\n            constructor(canvas) {\n                this.canvas = canvas;\n                this.ctx = canvas.getContext('2d');\n                this.graph = new Graph();\n                this.visited = new Set();\n                this.stack = [];\n                this.currentNode = null;\n                this.isRunning = false;\n                this.animationSpeed = 500;\n                this.animationId = null;\n                this.steps = [];\n                this.currentStep = 0;\n\n                this.initializeGraph();\n            }\n\n            initializeGraph() {\n                // Create a sample graph with 8 nodes\n                const nodePositions = [\n                    {x: 200, y: 100}, {x: 400, y: 100}, {x: 600, y: 100},\n                    {x: 100, y: 200}, {x: 300, y: 200}, {x: 500, y: 200}, {x: 700, y: 200},\n                    {x: 400, y: 300}\n                ];\n\n                for (let i = 0; i < 8; i++) {\n                    this.graph.addNode(i, nodePositions[i].x, nodePositions[i].y);\n                }\n\n                // Add edges to create an interesting graph\n                this.graph.addEdge(0, 1);\n                this.graph.addEdge(0, 3);\n                this.graph.addEdge(1, 2);\n                this.graph.addEdge(1, 4);\n                this.graph.addEdge(2, 5);\n                this.graph.addEdge(3, 4);\n                this.graph.addEdge(4, 5);\n                this.graph.addEdge(4, 7);\n                this.graph.addEdge(5, 6);\n                this.graph.addEdge(6, 7);\n\n                this.drawGraph();\n            }\n\n            drawGraph() {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                \n                // Draw edges\n                this.ctx.strokeStyle = '#666';\n                this.ctx.lineWidth = 2;\n                this.graph.edges.forEach(edge => {\n                    const fromNode = this.graph.nodes[edge.from];\n                    const toNode = this.graph.nodes[edge.to];\n                    this.ctx.beginPath();\n                    this.ctx.moveTo(fromNode.x, fromNode.y);\n                    this.ctx.lineTo(toNode.x, toNode.y);\n                    this.ctx.stroke();\n                });\n\n                // Draw nodes\n                this.graph.nodes.forEach(node => {\n                    let color = '#007bff'; // Default color\n                    \n                    if (this.visited.has(node.id)) {\n                        color = '#28a745'; // Visited nodes\n                    }\n                    if (node.id === this.currentNode) {\n                        color = '#dc3545'; // Current node\n                    }\n                    if (this.stack.includes(node.id)) {\n                        color = '#ffc107'; // Nodes in stack\n                    }\n\n                    this.ctx.fillStyle = color;\n                    this.ctx.beginPath();\n                    this.ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);\n                    this.ctx.fill();\n                    \n                    this.ctx.fillStyle = 'white';\n                    this.ctx.font = '16px Arial';\n                    this.ctx.textAlign = 'center';\n                    this.ctx.textBaseline = 'middle';\n                    this.ctx.fillText(node.id, node.x, node.y);\n                });\n            }\n\n            dfsStep() {\n                if (this.stack.length === 0) {\n                    this.isRunning = false;\n                    this.updateStatus(\"DFS completed!\");\n                    return;\n                }\n\n                this.currentNode = this.stack.pop();\n                this.steps.push(`Processing node ${this.currentNode}`);\n\n                if (!this.visited.has(this.currentNode)) {\n                    this.visited.add(this.currentNode);\n                    this.steps.push(`Visited node ${this.currentNode}`);\n\n                    // Get unvisited neighbors and add to stack\n                    const neighbors = this.graph.getNeighbors(this.currentNode);\n                    const unvisitedNeighbors = neighbors.filter(node => !this.visited.has(node));\n                    \n                    unvisitedNeighbors.forEach(neighbor => {\n                        this.stack.push(neighbor);\n                        this.steps.push(`Added node ${neighbor} to stack`);\n                    });\n                }\n\n                this.drawGraph();\n                this.updateDisplay();\n                this.currentStep++;\n            }\n\n            startDFS(startNode = 0) {\n                if (this.isRunning) return;\n\n                this.resetDFS();\n                this.isRunning = true;\n                this.visited.clear();\n                this.stack = [startNode];\n                this.steps = [`Starting DFS from node ${startNode}`];\n                this.currentStep = 0;\n                \n                this.updateStatus(`Starting DFS from node ${startNode}`);\n                this.animateDFS();\n            }\n\n            animateDFS() {\n                if (!this.isRunning) return;\n\n                this.dfsStep();\n                \n                if (this.isRunning) {\n                    this.animationId = setTimeout(() => {\n                        this.animateDFS();\n                    }, this.animationSpeed);\n                }\n            }\n\n            nextStep() {\n                if (!this.isRunning) {\n                    if (this.stack.length === 0 && this.visited.size === 0) {\n                        const startNode = parseInt(document.getElementById('startNode').value);\n                        this.stack = [startNode];\n                        this.steps = [`Starting DFS from node ${startNode}`];\n                        this.isRunning = true;\n                    }\n                }\n                \n                if (this.isRunning) {\n                    this.dfsStep();\n                }\n            }\n\n            resetDFS() {\n                this.isRunning = false;\n                this.visited.clear();\n                this.stack = [];\n                this.currentNode = null;\n                this.steps = [];\n                this.currentStep = 0;\n                clearTimeout(this.animationId);\n                this.drawGraph();\n                this.updateStatus(\"DFS reset - ready to start\");\n                this.updateDisplay();\n            }\n\n            updateDisplay() {\n                const statusDiv = document.getElementById('status');\n                const stepsList = document.getElementById('steps');\n                const stackDiv = document.getElementById('stackContents');\n                const visitedDiv = document.getElementById('visitedNodes');\n\n                // Update status\n                if (this.currentNode !== null) {\n                    statusDiv.innerHTML = `<strong>Current Node:</strong> ${this.currentNode}`;\n                    statusDiv.className = 'status current';\n                }\n\n                // Update steps\n                stepsList.innerHTML = '';\n                this.steps.slice(-10).forEach(step => {\n                    const li = document.createElement('li');\n                    li.textContent = step;\n                    stepsList.appendChild(li);\n                });\n\n                // Update stack\n                stackDiv.textContent = this.stack.length > 0 ? this.stack.join(' â†’ ') : 'Empty';\n                stackDiv.className = 'status stack';\n\n                // Update visited nodes\n                visitedDiv.textContent = this.visited.size > 0 ? \n                    Array.from(this.visited).join(', ') : 'None';\n                visitedDiv.className = 'status visited';\n            }\n\n            updateStatus(message) {\n                document.getElementById('status').textContent = message;\n            }\n\n            setSpeed(speed) {\n                this.animationSpeed = speed;\n            }\n\n            generateRandomGraph() {\n                this.resetDFS();\n                this.graph = new Graph();\n                \n                const nodeCount = 8;\n                const nodePositions = [\n                    {x: 200, y: 100}, {x: 400, y: 100}, {x: 600, y: 100},\n                    {x: 100, y: 200}, {x: 300, y: 200}, {x: 500, y: 200}, {x: 700, y: 200},\n                    {x: 400, y: 300}\n                ];\n\n                // Add nodes\n                for (let i = 0; i < nodeCount; i++) {\n                    this.graph.addNode(i, nodePositions[i].x, nodePositions[i].y);\n                }\n\n                // Add random edges (ensuring connectivity)\n                const edges = new Set();\n                \n                // Create a spanning tree to ensure connectivity\n                for (let i = 1; i < nodeCount; i++) {\n                    const j = Math.floor(Math.random() * i);\n                    edges.add(`${Math.min(i, j)}-${Math.max(i, j)}`);\n                }\n\n                // Add some additional random edges\n                const additionalEdges = Math.floor(Math.random() * 5) + 3;\n                for (let i = 0; i < additionalEdges; i++) {\n                    const from = Math.floor(Math.random() * nodeCount);\n                    const to = Math.floor(Math.random() * nodeCount);\n                    if (from !== to) {\n                        edges.add(`${Math.min(from, to)}-${Math.max(from, to)}`);\n                    }\n                }\n\n                // Add edges to graph\n                edges.forEach(edge => {\n                    const [from, to] = edge.split('-').map(Number);\n                    this.graph.addEdge(from, to);\n                });\n\n                this.drawGraph();\n                this.updateStatus(\"New random graph generated!\");\n            }\n        }\n\n        // Initialize the visualizer\n        let visualizer;\n\n        function initialize() {\n            const canvas = document.getElementById('graphCanvas');\n            visualizer = new DFSVisualizer(canvas);\n        }\n\n        function startDFS() {\n            const startNode = parseInt(document.getElementById('startNode').value);\n            visualizer.startDFS(startNode);\n        }\n\n        function nextStep() {\n            visualizer.nextStep();\n        }\n\n        function resetDFS() {\n            visualizer.resetDFS();\n        }\n\n        function generateRandomGraph() {\n            visualizer.generateRandomGraph();\n        }\n\n        function updateSpeed() {\n            const speed = parseInt(document.getElementById('speed').value);\n            visualizer.setSpeed(speed);\n        }\n\n        // Initialize when page loads\n        window.onload = initialize;\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Depth-First Search (DFS)"
    }
  ],
  "topic": "Depth-First Search (DFS)",
  "hasFSM": false,
  "hasTest": true
}