{
  "id": "6e0a074a-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:20:16.806Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Kruskal's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            line-height: 1.6;\n            color: #333;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        header {\n            text-align: center;\n            margin-bottom: 30px;\n            background-color: #2c3e50;\n            color: white;\n            padding: 20px;\n            border-radius: 5px;\n        }\n        h1 {\n            margin: 0;\n        }\n        .description {\n            background-color: white;\n            padding: 20px;\n            border-radius: 5px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n            margin-bottom: 20px;\n        }\n        .container {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 20px;\n        }\n        .controls {\n            background-color: white;\n            padding: 20px;\n            border-radius: 5px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n            flex: 1;\n            min-width: 300px;\n        }\n        #graph-container {\n            background-color: white;\n            border-radius: 5px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n            flex: 2;\n            min-width: 400px;\n            position: relative;\n            height: 500px;\n            overflow: auto;\n        }\n        canvas {\n            display: block;\n            margin: 0 auto;\n        }\n        button {\n            background-color: #3498db;\n            color: white;\n            border: none;\n            padding: 10px 15px;\n            border-radius: 4px;\n            cursor: pointer;\n            margin-right: 10px;\n            margin-bottom: 10px;\n            transition: background-color 0.3s;\n        }\n        button:hover {\n            background-color: #2980b9;\n        }\n        button:disabled {\n            background-color: #bdc3c7;\n            cursor: not-allowed;\n        }\n        .step-info {\n            margin-top: 20px;\n            background-color: #ecf0f1;\n            padding: 15px;\n            border-radius: 4px;\n        }\n        .slider-container {\n            margin: 15px 0;\n        }\n        label {\n            display: block;\n            margin-bottom: 5px;\n        }\n        ul {\n            padding-left: 20px;\n        }\n        .mst-weight {\n            margin-top: 20px;\n            font-weight: bold;\n            color: #e74c3c;\n            font-size: 1.2em;\n        }\n        .completed {\n            background-color: #2ecc71;\n        }\n    </style>\n</head>\n<body>\n    <header>\n        <h1>Kruskal's Algorithm Visualization</h1>\n    </header>\n\n    <div class=\"description\">\n        <h2>What is Kruskal's Algorithm?</h2>\n        <p>Kruskal's algorithm is a greedy algorithm that finds a minimum spanning tree (MST) for a connected, weighted graph. It works by:</p>\n        <ol>\n            <li>Sorting all the edges in non-decreasing order of their weight</li>\n            <li>Picking the smallest edge and checking if it forms a cycle with the spanning tree formed so far</li>\n            <li>If no cycle is formed, include the edge in the MST; otherwise, discard it</li>\n            <li>Repeat step 2 until there are (V-1) edges in the MST (where V is the number of vertices)</li>\n        </ol>\n        <p>This visualization demonstrates how Kruskal's algorithm works step by step.</p>\n    </div>\n\n    <div class=\"container\">\n        <div class=\"controls\">\n            <h3>Graph Controls</h3>\n            <div>\n                <button id=\"random-graph\">Generate Random Graph</button>\n                <button id=\"step-by-step\">Step-by-Step</button>\n                <button id=\"play\">Play Animation</button>\n                <button id=\"reset\">Reset</button>\n            </div>\n\n            <div class=\"slider-container\">\n                <label for=\"vertices\">Number of Vertices: <span id=\"vertices-value\">8</span></label>\n                <input type=\"range\" id=\"vertices\" min=\"4\" max=\"15\" value=\"8\">\n            </div>\n\n            <div class=\"slider-container\">\n                <label for=\"speed\">Animation Speed: <span id=\"speed-value\">Normal</span></label>\n                <input type=\"range\" id=\"speed\" min=\"1\" max=\"5\" value=\"3\">\n            </div>\n\n            <div id=\"step-info\" class=\"step-info\">\n                <h4>Current Step</h4>\n                <p id=\"step-description\">Click \"Step-by-Step\" or \"Play Animation\" to start.</p>\n            </div>\n\n            <div id=\"mst-info\" class=\"mst-weight\">\n                MST Weight: <span id=\"mst-weight\">0</span>\n            </div>\n        </div>\n\n        <div id=\"graph-container\">\n            <canvas id=\"graph-canvas\" width=\"600\" height=\"500\"></canvas>\n        </div>\n    </div>\n\n    <script>\n        // Graph representation and Kruskal's Algorithm implementation\n        class Graph {\n            constructor(vertices) {\n                this.V = vertices;\n                this.edges = [];\n                this.vertices = [];\n                this.initializeVertices();\n            }\n\n            initializeVertices() {\n                // Generate random positions for vertices\n                const canvas = document.getElementById('graph-canvas');\n                const padding = 50;\n                this.vertices = [];\n                \n                for (let i = 0; i < this.V; i++) {\n                    const x = padding + Math.random() * (canvas.width - 2 * padding);\n                    const y = padding + Math.random() * (canvas.height - 2 * padding);\n                    this.vertices.push({ id: i, x, y });\n                }\n            }\n\n            addEdge(u, v, weight) {\n                this.edges.push({ u, v, weight });\n            }\n\n            generateRandomGraph() {\n                this.edges = [];\n                \n                // Generate edges with random weights\n                for (let i = 0; i < this.V; i++) {\n                    for (let j = i + 1; j < this.V; j++) {\n                        // Randomly decide whether to include edge or not\n                        if (Math.random() > 0.6) continue;\n                        \n                        // Calculate weight based on distance\n                        const dx = this.vertices[i].x - this.vertices[j].x;\n                        const dy = this.vertices[i].y - this.vertices[j].y;\n                        const weight = Math.round(Math.sqrt(dx * dx + dy * dy));\n                        \n                        this.addEdge(i, j, weight);\n                    }\n                }\n                \n                // Ensure the graph is connected by adding additional edges if needed\n                this.ensureConnectivity();\n            }\n\n            ensureConnectivity() {\n                // Simple approach to ensure connectivity\n                const connected = new Set([0]); // Start with vertex 0\n                const unconnected = new Set();\n                \n                for (let i = 1; i < this.V; i++) {\n                    unconnected.add(i);\n                }\n                \n                // Connect vertices until all are connected\n                while (unconnected.size > 0) {\n                    const connectedArray = Array.from(connected);\n                    const unconnectedArray = Array.from(unconnected);\n                    \n                    const u = connectedArray[Math.floor(Math.random() * connectedArray.length)];\n                    const v = unconnectedArray[Math.floor(Math.random() * unconnectedArray.length)];\n                    \n                    // Add edge between u and v\n                    const dx = this.vertices[u].x - this.vertices[v].x;\n                    const dy = this.vertices[u].y - this.vertices[v].y;\n                    const weight = Math.round(Math.sqrt(dx * dx + dy * dy));\n                    \n                    this.addEdge(u, v, weight);\n                    \n                    // Move v from unconnected to connected\n                    connected.add(v);\n                    unconnected.delete(v);\n                }\n            }\n\n            // Kruskal's algorithm implementation\n            kruskalMST() {\n                // Sort edges by weight\n                const sortedEdges = [...this.edges].sort((a, b) => a.weight - b.weight);\n                \n                // Initialize parent array for union-find\n                const parent = [];\n                for (let i = 0; i < this.V; i++) {\n                    parent[i] = i;\n                }\n                \n                const mst = [];\n                \n                // Find function for union-find\n                const find = (i) => {\n                    if (parent[i] !== i) {\n                        parent[i] = find(parent[i]);\n                    }\n                    return parent[i];\n                };\n                \n                // Union function for union-find\n                const union = (x, y) => {\n                    parent[x] = y;\n                };\n                \n                // Process edges in sorted order\n                for (const edge of sortedEdges) {\n                    const x = find(edge.u);\n                    const y = find(edge.v);\n                    \n                    if (x !== y) {\n                        mst.push(edge);\n                        union(x, y);\n                    }\n                }\n                \n                return mst;\n            }\n        }\n\n        // Visualization class\n        class GraphVisualizer {\n            constructor() {\n                this.canvas = document.getElementById('graph-canvas');\n                this.ctx = this.canvas.getContext('2d');\n                this.graph = new Graph(8);\n                this.currentStep = 0;\n                this.isAnimating = false;\n                this.animationSpeed = 1000;\n                this.intervalId = null;\n                this.mstEdges = [];\n                this.mstStep = 0;\n                this.totalWeight = 0;\n                \n                // Generate initial random graph\n                this.graph.generateRandomGraph();\n                this.initializeKruskal();\n                \n                // Draw initial graph\n                this.drawGraph();\n                \n                // Set up event listeners\n                this.setupEventListeners();\n            }\n\n            initializeKruskal() {\n                // Sort edges by weight for Kruskal's algorithm\n                this.sortedEdges = [...this.graph.edges].sort((a, b) => a.weight - b.weight);\n                \n                // Initialize parent array for union-find\n                this.parent = [];\n                for (let i = 0; i < this.graph.V; i++) {\n                    this.parent[i] = i;\n                }\n                \n                this.mstEdges = [];\n                this.mstStep = 0;\n                this.totalWeight = 0;\n            }\n\n            setupEventListeners() {\n                document.getElementById('random-graph').addEventListener('click', () => {\n                    this.resetAnimation();\n                    const vertices = parseInt(document.getElementById('vertices').value);\n                    this.graph = new Graph(vertices);\n                    this.graph.generateRandomGraph();\n                    this.initializeKruskal();\n                    this.drawGraph();\n                    this.updateStepInfo(\"New random graph generated. Click 'Step-by-Step' or 'Play Animation' to start Kruskal's algorithm.\");\n                });\n\n                document.getElementById('step-by-step').addEventListener('click', () => {\n                    if (this.isAnimating) {\n                        this.pauseAnimation();\n                    }\n                    this.performKruskalStep();\n                });\n\n                document.getElementById('play').addEventListener('click', () => {\n                    if (this.isAnimating) {\n                        this.pauseAnimation();\n                    } else {\n                        this.startAnimation();\n                    }\n                });\n\n                document.getElementById('reset').addEventListener('click', () => {\n                    this.resetAnimation();\n                });\n\n                document.getElementById('vertices').addEventListener('input', (e) => {\n                    document.getElementById('vertices-value').textContent = e.target.value;\n                });\n\n                document.getElementById('speed').addEventListener('input', (e) => {\n                    const speedValues = ['Very Slow', 'Slow', 'Normal', 'Fast', 'Very Fast'];\n                    document.getElementById('speed-value').textContent = speedValues[e.target.value - 1];\n                    this.animationSpeed = 2000 - (e.target.value - 1) * 400;\n                    \n                    // Update animation speed if currently animating\n                    if (this.isAnimating) {\n                        this.pauseAnimation();\n                        this.startAnimation();\n                    }\n                });\n            }\n\n            performKruskalStep() {\n                if (this.mstStep >= this.sortedEdges.length || this.mstEdges.length >= this.graph.V - 1) {\n                    this.updateStepInfo(\"Kruskal's algorithm completed. MST has \" + this.mstEdges.length + \" edges.\");\n                    return;\n                }\n\n                const edge = this.sortedEdges[this.mstStep];\n                this.mstStep++;\n                \n                const find = (i) => {\n                    if (this.parent[i] !== i) {\n                        this.parent[i] = find(this.parent[i]);\n                    }\n                    return this.parent[i];\n                };\n                \n                const x = find(edge.u);\n                const y = find(edge.v);\n                \n                if (x !== y) {\n                    // Add edge to MST\n                    this.mstEdges.push(edge);\n                    this.totalWeight += edge.weight;\n                    \n                    // Union the sets\n                    this.parent[x] = y;\n                    \n                    this.updateStepInfo(`Added edge (${edge.u}, ${edge.v}) with weight ${edge.weight} to MST. No cycle formed.`);\n                } else {\n                    this.updateStepInfo(`Skipped edge (${edge.u}, ${edge.v}) with weight ${edge.weight}. Adding it would create a cycle.`);\n                }\n                \n                this.drawGraph();\n                document.getElementById('mst-weight').textContent = this.totalWeight;\n                \n                if (this.mstStep >= this.sortedEdges.length || this.mstEdges.length >= this.graph.V - 1) {\n                    this.updateStepInfo(\"Kruskal's algorithm completed. MST has \" + this.mstEdges.length + \" edges.\");\n                }\n            }\n\n            startAnimation() {\n                if (this.mstStep >= this.sortedEdges.length || this.mstEdges.length >= this.graph.V - 1) {\n                    return;\n                }\n                \n                this.isAnimating = true;\n                document.getElementById('play').textContent = 'Pause';\n                \n                this.intervalId = setInterval(() => {\n                    this.performKruskalStep();\n                    \n                    if (this.mstStep >= this.sortedEdges.length || this.mstEdges.length >= this.graph.V - 1) {\n                        this.pauseAnimation();\n                    }\n                }, this.animationSpeed);\n            }\n\n            pauseAnimation() {\n                this.isAnimating = false;\n                clearInterval(this.intervalId);\n                document.getElementById('play').textContent = 'Play Animation';\n            }\n\n            resetAnimation() {\n                this.pauseAnimation();\n                this.initializeKruskal();\n                this.drawGraph();\n                this.updateStepInfo(\"Algorithm reset. Click 'Step-by-Step' or 'Play Animation' to start.\");\n                document.getElementById('mst-weight').textContent = '0';\n            }\n\n            updateStepInfo(description) {\n                document.getElementById('step-description').textContent = description;\n            }\n\n            drawGraph() {\n                // Clear canvas\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                \n                // Draw edges\n                for (const edge of this.graph.edges) {\n                    const u = this.graph.vertices[edge.u];\n                    const v = this.graph.vertices[edge.v];\n                    \n                    // Check if edge is in MST\n                    const isInMST = this.mstEdges.some(e => \n                        (e.u === edge.u && e.v === edge.v) || (e.u === edge.v && e.v === edge.u)\n                    );\n                    \n                    // Check if edge is being considered\n                    const isCurrent = this.mstStep > 0 && \n                        this.sortedEdges[this.mstStep - 1].u === edge.u && \n                        this.sortedEdges[this.mstStep - 1].v === edge.v;\n                    \n                    // Set edge style\n                    if (isInMST) {\n                        this.ctx.strokeStyle = '#2ecc71'; // Green for MST edges\n                        this.ctx.lineWidth = 3;\n                    } else if (isCurrent) {\n                        this.ctx.strokeStyle = '#e74c3c'; // Red for current edge\n                        this.ctx.lineWidth = 3;\n                    } else {\n                        this.ctx.strokeStyle = '#3498db'; // Blue for regular edges\n                        this.ctx.lineWidth = 2;\n                    }\n                    \n                    // Draw edge\n                    this.ctx.beginPath();\n                    this.ctx.moveTo(u.x, u.y);\n                    this.ctx.lineTo(v.x, v.y);\n                    this.ctx.stroke();\n                    \n                    // Draw weight\n                    this.ctx.fillStyle = 'black';\n                    this.ctx.font = '12px Arial';\n                    this.ctx.fillText(\n                        edge.weight.toString(), \n                        (u.x + v.x) / 2, \n                        (u.y + v.y) / 2\n                    );\n                }\n                \n                // Draw vertices\n                for (const vertex of this.graph.vertices) {\n                    this.ctx.beginPath();\n                    this.ctx.arc(vertex.x, vertex.y, 15, 0, 2 * Math.PI);\n                    this.ctx.fillStyle = '#2c3e50';\n                    this.ctx.fill();\n                    \n                    this.ctx.fillStyle = 'white';\n                    this.ctx.font = 'bold 14px Arial';\n                    this.ctx.textAlign = 'center';\n                    this.ctx.textBaseline = 'middle';\n                    this.ctx.fillText(vertex.id.toString(), vertex.x, vertex.y);\n                }\n            }\n        }\n\n        // Initialize the visualization when the page loads\n        window.addEventListener('load', () => {\n            new GraphVisualizer();\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}