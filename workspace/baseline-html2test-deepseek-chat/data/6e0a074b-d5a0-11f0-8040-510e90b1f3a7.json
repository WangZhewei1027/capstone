{
  "id": "6e0a074b-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:19:52.104Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "# Prim's Algorithm Visualization\n\nI'll create an interactive visualization of Prim's Algorithm for finding Minimum Spanning Trees (MST). This visualization will let users build their own graphs and watch the algorithm in action.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Prim's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f7fa;\n            color: #333;\n        }\n        h1 {\n            text-align: center;\n            color: #2c3e50;\n            margin-bottom: 10px;\n        }\n        .description {\n            text-align: center;\n            margin-bottom: 25px;\n            color: #7f8c8d;\n        }\n        .container {\n            display: flex;\n            flex-direction: column;\n            gap: 20px;\n        }\n        .controls {\n            background-color: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        .control-group {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 15px;\n            margin-bottom: 15px;\n            align-items: center;\n        }\n        button {\n            padding: 10px 15px;\n            background-color: #3498db;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 14px;\n            transition: background-color 0.2s;\n        }\n        button:hover {\n            background-color: #2980b9;\n        }\n        button:disabled {\n            background-color: #bdc3c7;\n            cursor: not-allowed;\n        }\n        .visualization {\n            display: flex;\n            gap: 20px;\n        }\n        #graphCanvas {\n            background-color: white;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        .info-panel {\n            flex: 1;\n            background-color: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        .info-panel h3 {\n            margin-top: 0;\n            color: #2c3e50;\n        }\n        .step-info {\n            background-color: #f8f9fa;\n            padding: 15px;\n            border-radius: 4px;\n            min-height: 150px;\n            margin-bottom: 15px;\n        }\n        .logs {\n            height: 200px;\n            overflow-y: auto;\n            background-color: #f8f9fa;\n            padding: 10px;\n            border-radius: 4px;\n            font-family: monospace;\n            font-size: 14px;\n        }\n        .node-count {\n            width: 80px;\n            padding: 8px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n        }\n        .legend {\n            display: flex;\n            gap: 15px;\n            margin-top: 15px;\n        }\n        .legend-item {\n            display: flex;\n            align-items: center;\n            gap: 5px;\n        }\n        .legend-color {\n            width: 20px;\n            height: 20px;\n            border-radius: 50%;\n        }\n        .mst-edge {\n            background-color: #2ecc71;\n        }\n        .candidate-edge {\n            background-color: #3498db;\n        }\n        .unvisited-node {\n            background-color: #e74c3c;\n        }\n        .visited-node {\n            background-color: #2ecc71;\n        }\n    </style>\n</head>\n<body>\n    <h1>Prim's Algorithm Visualization</h1>\n    <p class=\"description\">Prim's Algorithm finds a Minimum Spanning Tree (MST) for a weighted undirected graph.</p>\n    \n    <div class=\"container\">\n        <div class=\"controls\">\n            <div class=\"control-group\">\n                <button id=\"addNodeBtn\">Add Node</button>\n                <button id=\"runAlgorithmBtn\">Run Prim's Algorithm</button>\n                <button id=\"nextStepBtn\">Next Step</button>\n                <button id=\"resetBtn\">Reset</button>\n                <button id=\"randomGraphBtn\">Generate Random Graph</button>\n                <input type=\"number\" id=\"nodeCount\" class=\"node-count\" min=\"3\" max=\"10\" value=\"5\" placeholder=\"Nodes\">\n            </div>\n            <div class=\"control-group\">\n                <span>Click on the canvas to add nodes. Click and drag between nodes to add edges.</span>\n            </div>\n        </div>\n        \n        <div class=\"visualization\">\n            <canvas id=\"graphCanvas\" width=\"800\" height=\"500\"></canvas>\n            \n            <div class=\"info-panel\">\n                <h3>Algorithm Steps</h3>\n                <div class=\"step-info\" id=\"stepInfo\">\n                    <p>Click \"Run Prim's Algorithm\" to start the visualization.</p>\n                </div>\n                \n                <h3>Algorithm Log</h3>\n                <div class=\"logs\" id=\"logs\"></div>\n                \n                <div class=\"legend\">\n                    <div class=\"legend-item\">\n                        <div class=\"legend-color visited-node\"></div>\n                        <span>Visited Node</span>\n                    </div>\n                    <div class=\"legend-item\">\n                        <div class=\"legend-color unvisited-node\"></div>\n                        <span>Unvisited Node</span>\n                    </div>\n                    <div class=\"legend-item\">\n                        <div class=\"legend-color mst-edge\"></div>\n                        <span>MST Edge</span>\n                    </div>\n                    <div class=\"legend-item\">\n                        <div class=\"legend-color candidate-edge\"></div>\n                        <span>Candidate Edge</span>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        // Canvas setup\n        const canvas = document.getElementById('graphCanvas');\n        const ctx = canvas.getContext('2d');\n        \n        // UI elements\n        const addNodeBtn = document.getElementById('addNodeBtn');\n        const runAlgorithmBtn = document.getElementById('runAlgorithmBtn');\n        const nextStepBtn = document.getElementById('nextStepBtn');\n        const resetBtn = document.getElementById('resetBtn');\n        const randomGraphBtn = document.getElementById('randomGraphBtn');\n        const nodeCountInput = document.getElementById('nodeCount');\n        const stepInfo = document.getElementById('stepInfo');\n        const logs = document.getElementById('logs');\n        \n        // Graph data structure\n        let nodes = [];\n        let edges = [];\n        let isRunningAlgorithm = false;\n        let algorithmStep = 0;\n        let animationId = null;\n        \n        // Prim's algorithm state\n        let visited = new Set();\n        let mstEdges = [];\n        let candidateEdges = [];\n        \n        // Node class\n        class Node {\n            constructor(x, y) {\n                this.x = x;\n                this.y = y;\n                this.id = nodes.length;\n                this.radius = 20;\n            }\n            \n            draw() {\n                // Draw node circle\n                ctx.beginPath();\n                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n                \n                if (visited.has(this.id)) {\n                    ctx.fillStyle = '#2ecc71'; // Visited node - green\n                } else {\n                    ctx.fillStyle = '#e74c3c'; // Unvisited node - red\n                }\n                \n                ctx.fill();\n                ctx.strokeStyle = '#2c3e50';\n                ctx.lineWidth = 2;\n                ctx.stroke();\n                \n                // Draw node label\n                ctx.fillStyle = 'white';\n                ctx.font = '16px Arial';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillText(this.id, this.x, this.y);\n            }\n            \n            containsPoint(x, y) {\n                const distance = Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2);\n                return distance <= this.radius;\n            }\n        }\n        \n        // Edge class\n        class Edge {\n            constructor(node1, node2, weight) {\n                this.node1 = node1;\n                this.node2 = node2;\n                this.weight = weight || Math.floor(Math.random() * 20) + 1;\n            }\n            \n            draw() {\n                const x1 = this.node1.x;\n                const y1 = this.node1.y;\n                const x2 = this.node2.x;\n                const y2 = this.node2.y;\n                \n                // Determine edge color based on state\n                if (mstEdges.some(e => \n                    (e.node1.id === this.node1.id && e.node2.id === this.node2.id) ||\n                    (e.node1.id === this.node2.id && e.node2.id === this.node1.id))) {\n                    ctx.strokeStyle = '#2ecc71'; // MST edge - green\n                    ctx.lineWidth = 4;\n                } else if (candidateEdges.some(e => \n                    (e.node1.id === this.node1.id && e.node2.id === this.node2.id) ||\n                    (e.node1.id === this.node2.id && e.node2.id === this.node1.id))) {\n                    ctx.strokeStyle = '#3498db'; // Candidate edge - blue\n                    ctx.lineWidth = 3;\n                } else {\n                    ctx.strokeStyle = '#7f8c8d'; // Regular edge - gray\n                    ctx.lineWidth = 2;\n                }\n                \n                // Draw the edge line\n                ctx.beginPath();\n                ctx.moveTo(x1, y1);\n                ctx.lineTo(x2, y2);\n                ctx.stroke();\n                \n                // Draw weight label\n                const midX = (x1 + x2) / 2;\n                const midY = (y1 + y2) / 2;\n                \n                ctx.fillStyle = 'white';\n                ctx.strokeStyle = '#2c3e50';\n                ctx.lineWidth = 1;\n                ctx.fillRect(midX - 15, midY - 10, 30, 20);\n                ctx.strokeRect(midX - 15, midY - 10, 30, 20);\n                \n                ctx.fillStyle = '#2c3e50';\n                ctx.font = '12px Arial';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillText(this.weight, midX, midY);\n            }\n        }\n        \n        // Draw the graph\n        function drawGraph() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Draw edges first (so they appear behind nodes)\n            edges.forEach(edge => edge.draw());\n            \n            // Draw nodes on top\n            nodes.forEach(node => node.draw());\n        }\n        \n        // Find node at coordinates\n        function findNodeAt(x, y) {\n            for (let i = nodes.length - 1; i >= 0; i--) {\n                if (nodes[i].containsPoint(x, y)) {\n                    return nodes[i];\n                }\n            }\n            return null;\n        }\n        \n        // Reset the algorithm state\n        function resetAlgorithm() {\n            visited.clear();\n            mstEdges = [];\n            candidateEdges = [];\n            algorithmStep = 0;\n            isRunningAlgorithm = false;\n            stepInfo.innerHTML = '<p>Click \"Run Prim\\'s Algorithm\" to start the visualization.</p>';\n            logs.innerHTML = '';\n            drawGraph();\n        }\n        \n        // Add a log message\n        function addLog(message) {\n            const logEntry = document.createElement('div');\n            logEntry.textContent = `Step ${algorithmStep}: ${message}`;\n            logs.appendChild(logEntry);\n            logs.scrollTop = logs.scrollHeight;\n        }\n        \n        // Perform one step of Prim's algorithm\n        function primStep() {\n            if (!isRunningAlgorithm) return;\n            \n            algorithmStep++;\n            let message = '';\n            \n            // Step 1: Initialize with the first node if no nodes visited yet\n            if (visited.size === 0 && nodes.length > 0) {\n                const startNode = nodes[0];\n                visited.add(startNode.id);\n                message = `Starting with node ${startNode.id}`;\n                addLog(message);\n                stepInfo.innerHTML = `<p>${message}</p><p>Added node ${startNode.id} to the MST.</p>`;\n                drawGraph();\n                return;\n            }\n            \n            // Step 2: If all nodes are visited, we're done\n            if (visited.size === nodes.length) {\n                message = 'All nodes are in the MST. Algorithm completed!';\n                addLog(message);\n                stepInfo.innerHTML = `<p>${message}</p><p>Total MST weight: ${calculateMSTWeight()}</p>`;\n                isRunningAlgorithm = false;\n                drawGraph();\n                return;\n            }\n            \n            // Step 3: Update candidate edges (edges connecting visited to unvisited nodes)\n            candidateEdges = [];\n            edges.forEach(edge => {\n                const node1Visited = visited.has(edge.node1.id);\n                const node2Visited = visited.has(edge.node2.id);\n                \n                // Candidate edge connects a visited node to an unvisited node\n                if ((node1Visited && !node2Visited) || (!node1Visited && node2Visited)) {\n                    candidateEdges.push(edge);\n                }\n            });\n            \n            // Step 4: If no candidate edges, the graph might be disconnected\n            if (candidateEdges.length === 0) {\n                message = 'No candidate edges found. The graph might be disconnected.';\n                addLog(message);\n                stepInfo.innerHTML = `<p>${message}</p>`;\n                isRunningAlgorithm = false;\n                drawGraph();\n                return;\n            }\n            \n            // Step 5: Find the minimum weight candidate edge\n            let minEdge = candidateEdges[0];\n            for (let i = 1; i < candidateEdges.length; i++) {\n                if (candidateEdges[i].weight < minEdge.weight) {\n                    minEdge = candidateEdges[i];\n                }\n            }\n            \n            // Step 6: Add the edge to MST and mark the unvisited node as visited\n            mstEdges.push(minEdge);\n            const newNode = visited.has(minEdge.node1.id) ? minEdge.node2 : minEdge.node1;\n            visited.add(newNode.id);\n            \n            message = `Added edge (${minEdge.node1.id}-${minEdge.node2.id}) with weight ${minEdge.weight} to MST`;\n            addLog(message);\n            stepInfo.innerHTML = `<p>${message}</p><p>Added node ${newNode.id} to the MST.</p>`;\n            \n            drawGraph();\n        }\n        \n        // Calculate the total weight of the MST\n        function calculateMSTWeight() {\n            return mstEdges.reduce((sum, edge) => sum + edge.weight, 0);\n        }\n        \n        // Run the algorithm continuously\n        function runAlgorithm() {\n            if (nodes.length < 2) {\n                alert('Please add at least 2 nodes to run the algorithm.');\n                return;\n            }\n            \n            isRunningAlgorithm = true;\n            algorithmStep = 0;\n            visited.clear();\n            mstEdges = [];\n            candidateEdges = [];\n            logs.innerHTML = '';\n            \n            // Run the algorithm steps with a delay for visualization\n            function runStep() {\n                if (isRunningAlgorithm && visited.size < nodes.length) {\n                    primStep();\n                    animationId = setTimeout(runStep, 1500);\n                }\n            }\n            \n            runStep();\n        }\n        \n        // Generate a random graph\n        function generateRandomGraph() {\n            const nodeCount = parseInt(nodeCountInput.value) || 5;\n            if (nodeCount < 3 || nodeCount > 10) {\n                alert('Please enter a number between 3 and 10 for nodes.');\n                return;\n            }\n            \n            resetAlgorithm();\n            nodes = [];\n            edges = [];\n            \n            // Create nodes in a circular arrangement\n            const centerX = canvas.width / 2;\n            const centerY = canvas.height / 2;\n            const radius = Math.min(canvas.width, canvas.height) * 0.35;\n            \n            for (let i = 0; i < nodeCount; i++) {\n                const angle = (2 * Math.PI * i) / nodeCount;\n                const x = centerX + radius * Math.cos(angle);\n                const y = centerY + radius * Math.sin(angle);\n                nodes.push(new Node(x, y));\n            }\n            \n            // Create edges - connect each node to a few others\n            for (let i = 0; i < nodeCount; i++) {\n                // Connect to the next node (creating a cycle)\n                edges.push(new Edge(nodes[i], nodes[(i + 1) % nodeCount]));\n                \n                // Randomly connect to one or two other nodes\n                const extraConnections = Math.floor(Math.random() * 2) + 1;\n                for (let j = 0; j < extraConnections; j++) {\n                    const randomNode = Math.floor(Math.random() * nodeCount);\n                    if (randomNode !== i && randomNode !== (i + 1) % nodeCount) {\n                        // Check if edge already exists\n                        const edgeExists = edges.some(edge => \n                            (edge.node1.id === i && edge.node2.id === randomNode) ||\n                            (edge.node1.id === randomNode && edge.node2.id === i));\n                        \n                        if (!edgeExists) {\n                            edges.push(new Edge(nodes[i], nodes[randomNode]));\n                        }\n                    }\n                }\n            }\n            \n            drawGraph();\n            stepInfo.innerHTML = `<p>Random graph generated with ${nodeCount} nodes and ${edges.length} edges.</p>`;\n        }\n        \n        // Event listeners\n        addNodeBtn.addEventListener('click', () => {\n            resetAlgorithm();\n            // Add a node at a random position (avoiding edges)\n            const padding = 40;\n            const x = Math.random() * (canvas.width - 2 * padding) + padding;\n            const y = Math.random() * (canvas.height - 2 * padding) + padding;\n            nodes.push(new Node(x, y));\n            drawGraph();\n        });\n        \n        runAlgorithmBtn.addEventListener('click', runAlgorithm);\n        \n        nextStepBtn.addEventListener('click', () => {\n            if (!isRunningAlgorithm) {\n                if (nodes.length < 2)"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}